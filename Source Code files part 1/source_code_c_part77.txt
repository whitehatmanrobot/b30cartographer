***************
HRESULT CWbemObject::GetSystemProperty(int nIndex, CVar* pVar)
{
    switch(nIndex)
    {
    case CSystemProperties::e_SysProp_Server:
        return GetServer(pVar);
    case CSystemProperties::e_SysProp_Namespace:
        return GetNamespace(pVar);
    case CSystemProperties::e_SysProp_Genus:
        return GetGenus(pVar);
    case CSystemProperties::e_SysProp_Class:
        return GetClassName(pVar);
    case CSystemProperties::e_SysProp_Superclass:
        return GetSuperclassName(pVar);
    case CSystemProperties::e_SysProp_Path:
        return GetPath(pVar);
    case CSystemProperties::e_SysProp_Relpath:
        return GetRelPath(pVar);
    case CSystemProperties::e_SysProp_PropertyCount:
        return GetPropertyCount(pVar);
    case CSystemProperties::e_SysProp_Dynasty:
        return GetDynasty(pVar);
    case CSystemProperties::e_SysProp_Derivation:
        return GetDerivation(pVar);
    }
    return WBEM_E_NOT_FOUND;
}

//******************************************************************************
//
//  See fastobj.h for documentation
//
//******************************************************************************
HRESULT CWbemObject::GetServer(CVar* pVar)
{
    if(m_DecorationPart.IsDecorated())
    {
        // Check for allocation failures
        if ( !m_DecorationPart.m_pcsServer->StoreToCVar(*pVar) )
        {
            return WBEM_E_OUT_OF_MEMORY;
        }

    }
    else
    {
        pVar->SetAsNull();
    }
    return WBEM_NO_ERROR;
}
//******************************************************************************
//
//  See fastobj.h for documentation
//
//******************************************************************************
HRESULT CWbemObject::GetNamespace(CVar* pVar)
{
    if(m_DecorationPart.IsDecorated())
    {
        // Check for allocation failures
        if ( !m_DecorationPart.m_pcsNamespace->StoreToCVar(*pVar) )
        {
            return WBEM_E_OUT_OF_MEMORY;
        }
    }
    else
    {
        pVar->SetAsNull();
    }
    return WBEM_NO_ERROR;
}
//******************************************************************************
//
//  See fastobj.h for documentation
//
//******************************************************************************
HRESULT CWbemObject::GetServerAndNamespace(CVar* pVar)
{
    HRESULT hr = WBEM_S_NO_ERROR;

    if(m_DecorationPart.IsDecorated())
    {
        // We need to manually throw exceptions if the BSTR allocations fail.
        BSTR strServer = m_DecorationPart.m_pcsServer->CreateBSTRCopy();
        CSysFreeMe  sfmSvr( strServer );

        if ( NULL != strServer )
        {
            BSTR strNamespace = m_DecorationPart.m_pcsNamespace->CreateBSTRCopy();
            CSysFreeMe  sfmNS( strNamespace );

            if ( NULL != strNamespace )
            {
                    size_t size = SysStringLen(strServer) + SysStringLen(strNamespace) + 10;
                    WCHAR* wszName = new WCHAR[size];

                if ( NULL != wszName )
                {
                    StringCchPrintfW( wszName, size, L"\\\\%s\\%s", strServer, strNamespace );
                    // Let the CVar deal with deleting the memory
                    pVar->SetLPWSTR( wszName, TRUE );
                    }
                else
                    {
             hr =  WBEM_E_OUT_OF_MEMORY;
                    }

            }
            else
            {
                hr = WBEM_E_OUT_OF_MEMORY;
            }

        }
        else
        {
            hr = WBEM_E_OUT_OF_MEMORY;
        }
    }
    else
    {
        // No decoration, so just set to NULL
        pVar->SetAsNull();
    }

    return hr;
}

//******************************************************************************
//
//  See fastobj.h for documentation
//
//******************************************************************************
HRESULT CWbemObject::GetPath(CVar* pVar)
{
    if(m_DecorationPart.IsDecorated())
    {
       wmilib::auto_ptr<WCHAR> wszFullPath(GetFullPath());
       if(wszFullPath.get() == NULL)
       {
           // ISSUE: 525177 how to fix a bug with a new bug per War Team
           pVar->SetAsNull();           
       }
       else
       {
           pVar->SetBSTR(wszFullPath.get());
       }
    }
    else
    {
        pVar->SetAsNull();
    }
    return WBEM_NO_ERROR;
}
//******************************************************************************
//
//  See fastobj.h for documentation
//
//******************************************************************************
HRESULT CWbemObject::GetRelPath(CVar* pVar)
{
    wmilib::auto_ptr<WCHAR> wszRelPath(GetRelPath());
    if(wszRelPath.get() == NULL)
    {
        pVar->SetAsNull();
    }
    else
    {
        pVar->SetBSTR(wszRelPath.get());
    }
    return WBEM_NO_ERROR;
}
//******************************************************************************
//
//  See fastobj.h for documentation
//
//******************************************************************************
LPWSTR CWbemObject::GetFullPath()
{
    if(!m_DecorationPart.IsDecorated()) return NULL;

    wmilib::auto_ptr<WCHAR> pRelPath(GetRelPath());
    if (!pRelPath.get())
        return 0;
    

    WCHAR* wszPath = NULL;

    // We need to manually throw exceptions if the BSTR allocations fail.
    BSTR strServer = m_DecorationPart.m_pcsServer->CreateBSTRCopy();
    CSysFreeMe  sfmSvr( strServer );

    if ( NULL != strServer )
    {
        BSTR strNamespace = m_DecorationPart.m_pcsNamespace->CreateBSTRCopy();
        CSysFreeMe  sfmNS( strNamespace );

        if ( NULL != strNamespace )
        {
  size_t size = SysStringLen(strServer) + SysStringLen(strNamespace) + wcslen(pRelPath.get()) + 10;
            wszPath = new WCHAR[size];

            if ( NULL != wszPath )
            {
                StringCchPrintfW(wszPath, size, L"\\\\%s\\%s:%s", strServer, strNamespace, pRelPath.get());
            }
            else
            {
                throw CX_MemoryException();
            }
        }
        else
        {
            throw CX_MemoryException();
        }
    }
    else
    {
        throw CX_MemoryException();
    }
    return wszPath;
}

//******************************************************************************
//
//  See fastobj.h for documentation.
//
//******************************************************************************
HRESULT CWbemObject::GetDerivation(CVar* pVar)
{
    return GetClassPart()->GetDerivation(pVar);
}
//******************************************************************************
//
//  See fastobj.h for documentation
//
//******************************************************************************
BOOL CWbemObject::HasRefs()
{
    CClassPart* pClassPart = GetClassPart();

    for(int i = 0; i < pClassPart->m_Properties.GetNumProperties(); i++)
    {
        CPropertyLookup* pLookup = pClassPart->m_Properties.GetAt(i);
        CPropertyInformation* pInfo =
            pLookup->GetInformation(&pClassPart->m_Heap);
        if(CType::GetActualType(pInfo->nType) == CIM_REFERENCE)
            return TRUE;
    }
    return FALSE;
}




//******************************************************************************
//
//  See fastobj.h for documentation
//
//******************************************************************************
STDMETHODIMP CWbemObject::CompareTo(long lFlags, IWbemClassObject* pCompareTo)
{
    // Check for out of memory
    try
    {
        CLock lock(this, WBEM_FLAG_ALLOW_READ);

        if(pCompareTo == NULL)
            return WBEM_E_INVALID_PARAMETER;

        HRESULT hres;

        // IMPORTANT: assumes that the other object was created by us as well.
        // ===================================================================

        CWbemObject* pOther = NULL;
        if ( FAILED( WbemObjectFromCOMPtr( pCompareTo, &pOther ) ) )
        {
            return WBEM_E_INVALID_OBJECT;
        }
        
        // Auto Release
        CReleaseMe    rmObj( (IWbemClassObject*) pOther );

        LONG lFlagsLeft = lFlags;
        BOOL bIgnoreQuals = lFlags & WBEM_FLAG_IGNORE_QUALIFIERS;
        lFlagsLeft &= ~WBEM_FLAG_IGNORE_QUALIFIERS;

        BOOL bIgnoreSource = lFlags & WBEM_FLAG_IGNORE_OBJECT_SOURCE;
        lFlagsLeft &= ~WBEM_FLAG_IGNORE_OBJECT_SOURCE;

        BOOL bIgnoreDefaults = lFlags & WBEM_FLAG_IGNORE_DEFAULT_VALUES;
        lFlagsLeft &= ~WBEM_FLAG_IGNORE_DEFAULT_VALUES;

        BOOL bIgnoreDefs = lFlags & WBEM_FLAG_IGNORE_CLASS;
        lFlagsLeft &= ~WBEM_FLAG_IGNORE_CLASS;

        BOOL bIgnoreCase = lFlags & WBEM_FLAG_IGNORE_CASE;
        lFlagsLeft &= ~WBEM_FLAG_IGNORE_CASE;

        BOOL bIgnoreFlavor = lFlags & WBEM_FLAG_IGNORE_FLAVOR;
        lFlagsLeft &= ~WBEM_FLAG_IGNORE_FLAVOR;

        if(lFlagsLeft != 0)
        {
            // Undefined flags were found
            // ==========================
            return WBEM_E_INVALID_PARAMETER;
        }

        // Compare the object's memory blocks just in case they match
        // ==========================================================

        if(GetBlockLength() == pOther->GetBlockLength() &&
            memcmp(GetStart(), pOther->GetStart(), GetBlockLength()) == 0)
        {
            return WBEM_S_SAME;
        }

        // Compare decorations if required.
        // ===============================

        if(!bIgnoreSource && !m_DecorationPart.CompareTo(pOther->m_DecorationPart))
            return WBEM_S_DIFFERENT;

        CClassPart* pThisClass = GetClassPart();
        CClassPart* pOtherClass = pOther->GetClassPart();

        if(!bIgnoreDefs)
        {
            // Compare class name and superclass name
            // ======================================

            if(!pThisClass->CompareDefs(*pOtherClass))
                return WBEM_S_DIFFERENT;
        }

        // Compare qualifier sets if required
        // ==================================

        if(!bIgnoreQuals)
        {
            IWbemQualifierSet   *pThisSet = NULL;
            IWbemQualifierSet   *pOtherSet = NULL;

            GetQualifierSet(&pThisSet);
            CReleaseMe          rm1( pThisSet );

            pOther->GetQualifierSet(&pOtherSet);
            CReleaseMe          rm2( pOtherSet );


            hres =
                ((IExtendedQualifierSet*)pThisSet)->CompareTo(lFlags, pOtherSet);
            if(hres != WBEM_S_SAME)
                return WBEM_S_DIFFERENT;
        }

        // Compare property definitions
        // ============================
        if (pThisClass->m_Properties.GetNumProperties() > pOtherClass->m_Properties.GetNumProperties())
          {
                return WBEM_S_DIFFERENT;          
          }

        for(int i = 0; i < pThisClass->m_Properties.GetNumProperties(); i++)
        {
            CPropertyLookup* pLookup = pThisClass->m_Properties.GetAt(i);
            CPropertyLookup* pOtherLookup = pOtherClass->m_Properties.GetAt(i);

            if(!bIgnoreDefs)
            {
                // Compare names
                // =============

                if(pThisClass->m_Heap.ResolveString(pLookup->ptrName)->
                    CompareNoCase(
                    *pOtherClass->m_Heap.ResolveString(pOtherLookup->ptrName))
                    != 0)
                {
                    return WBEM_S_DIFFERENT;
                }
            }

            // Get property information structures
            // ===================================

            CPropertyInformation* pInfo =
                pLookup->GetInformation(&pThisClass->m_Heap);
            CPropertyInformation* pOtherInfo =
                pOtherLookup->GetInformation(&pOtherClass->m_Heap);

            if(!bIgnoreDefs)
            {

                // Compare types
                // =============

                if(pInfo->nType != pOtherInfo->nType)
                {
                    return WBEM_S_DIFFERENT;
                }
            }

            if( !bIgnoreDefaults || IsInstance() )
            {
                // Protect against NULLs
                if ( NULL == pInfo || NULL == pOtherInfo )
                {
                    return WBEM_E_NOT_FOUND;
                }

                // Compare values
                // ==============

                CVar vThis, vOther;
                hres = GetProperty(pInfo, &vThis);
                if(FAILED(hres)) return hres;
                hres = pOther->GetProperty(pOtherInfo, &vOther);
                if(FAILED(hres)) return hres;

                if(!vThis.CompareTo(vOther, bIgnoreCase))
                {
                    // Check if the values are embedded objects
                    // ========================================

                    if(vThis.GetType() == VT_EMBEDDED_OBJECT &&
                        vOther.GetType() == VT_EMBEDDED_OBJECT)
                    {
                        IWbemClassObject* pThisEmb =
                            (IWbemClassObject*)vThis.GetEmbeddedObject();
                        IWbemClassObject* pOtherEmb =
                            (IWbemClassObject*)vOther.GetEmbeddedObject();

                        // Compare them taking everything into account --- the flags
                        // do not apply!
                        // =========================================================

                        hres = pThisEmb->CompareTo(0, pOtherEmb);
                        if(hres != WBEM_S_SAME)
                            return hres;
                    }
                    else
                    {
                        return WBEM_S_DIFFERENT;
                    }
                }
            }

            // Compare qualifiers if required
            // ==============================

            if( !bIgnoreQuals )
            {
                // Cleanup when we drop out of scope
                BSTR strName = pThisClass->m_Heap.ResolveString(pLookup->ptrName)->
                    CreateBSTRCopy();
                CSysFreeMe  sfm( strName );

                // Check for allocation failures
                if ( NULL == strName )
                {
                    return WBEM_E_OUT_OF_MEMORY;
                }

                // Don't do this if this appears to be a system property
                if ( !CSystemProperties::IsPossibleSystemPropertyName( strName ) )
                {
                    IWbemQualifierSet   *pThisSet = NULL;
                    IWbemQualifierSet   *pOtherSet = NULL;

                    // Release both when they  fall out of scope

                    hres = GetPropertyQualifierSet(strName, &pThisSet);
                    CReleaseMe          rm1( pThisSet );
                    if(FAILED(hres)) return hres;

                    hres = pOther->GetPropertyQualifierSet(strName, &pOtherSet);
                    CReleaseMe          rm2( pOtherSet );
                    if(FAILED(hres)) return hres;

                    hres = ((IExtendedQualifierSet*)pThisSet)->CompareTo(lFlags, pOtherSet);

                    if(hres != WBEM_S_SAME)
                        return WBEM_S_DIFFERENT;
                }
            }
        }

        return WBEM_S_SAME;
    }
    catch (CX_MemoryException)
    {
        return WBEM_E_OUT_OF_MEMORY;
    }
    catch (...)
    {
        return WBEM_E_FAILED;
    }

}

//******************************************************************************
//
//  See fastobj.h for documentation
//
//******************************************************************************
STDMETHODIMP CWbemObject::GetPropertyOrigin(LPCWSTR wszProperty,
                                           BSTR* pstrClassName)
{
    // No allocations in this function so no need to do any exception handling
    try
    {
        CLock lock(this, WBEM_FLAG_ALLOW_READ);

        if(wszProperty == NULL || pstrClassName == NULL ||
                wcslen(wszProperty) == 0)
        {
            return WBEM_E_INVALID_PARAMETER;
        }

        // If this is a limited version, return an error since we really can't
        // accurately return property origin data.

        if ( m_DecorationPart.IsLimited() )
        {
            return WBEM_E_INVALID_OBJECT;
        }

        return GetClassPart()->GetPropertyOrigin(wszProperty, pstrClassName);
    }
    catch(...)
    {
        return WBEM_E_CRITICAL_ERROR;
    }
}

STDMETHODIMP CWbemObject::InheritsFrom(LPCWSTR wszClassName)
{
    // Check for out of memory
    try
    {
        CLock lock(this, WBEM_FLAG_ALLOW_READ);

        if(wszClassName == NULL)
            return WBEM_E_INVALID_PARAMETER;

        if(GetClassPart()->InheritsFrom(wszClassName))
        {
            return WBEM_S_NO_ERROR;
        }
        else return WBEM_S_FALSE;
    }
    catch (CX_MemoryException)
    {
        return WBEM_E_OUT_OF_MEMORY;
    }
    catch (...)
    {
        return WBEM_E_FAILED;
    }

}

STDMETHODIMP CWbemObject::GetPropertyValue(WBEM_PROPERTY_NAME* pName, long lFlags,
                                          WBEM_WSTR* pwszCimType,
                                          VARIANT* pvValue)
{
    // Check for out of memory
    try
    {
        CLock lock(this, WBEM_FLAG_ALLOW_READ);

        if(pwszCimType)
            *pwszCimType = NULL;

        // Check that the first element is a property name
        // ===============================================

        if(pName->m_lNumElements <= 0) return WBEM_E_INVALID_PARAMETER;
        if(pName->m_aElements[0].m_nType != WBEM_NAME_ELEMENT_TYPE_PROPERTY)
            return WBEM_E_INVALID_PARAMETER;

        // Get that first property
        // =======================

        CVar vCurrent;
        CVar vCimType;
        HRESULT hres = GetProperty(pName->m_aElements[0].Element.m_wszPropertyName,
                                    &vCurrent);
        if(FAILED(hres)) return hres;
        GetPropQualifier(pName->m_aElements[0].Element.m_wszPropertyName,
            TYPEQUAL, &vCimType, NULL);

        // Process the rest of the elements
        // ================================

        long lIndex = 1;
        while(lIndex < pName->m_lNumElements)
        {
            WBEM_NAME_ELEMENT& El = pName->m_aElements[lIndex];
            if(El.m_nType == WBEM_NAME_ELEMENT_TYPE_INDEX)
            {
                if(vCurrent.GetType() != VT_EX_CVARVECTOR)
                    return WBEM_E_NOT_FOUND;

                CVar    vTemp;
                vCurrent.GetVarVector()->FillCVarAt( El.Element.m_lArrayIndex, vTemp );
                vCurrent = vTemp;
            }
            else if(El.m_nType == WBEM_NAME_ELEMENT_TYPE_PROPERTY)
            {
                if(vCurrent.GetType() != VT_EMBEDDED_OBJECT)
                    return WBEM_E_NOT_FOUND;
                CWbemObject* pObj =
                    (CWbemObject*)(IWbemClassObject*)vCurrent.GetEmbeddedObject();
                if (NULL == pObj) return WBEM_E_OUT_OF_MEMORY;
                vCurrent.Empty();
                hres = pObj->GetProperty(El.Element.m_wszPropertyName, &vCurrent);

                // Clear now to prevent memory leaks
                vCimType.Empty();

                pObj->GetPropQualifier(El.Element.m_wszPropertyName, TYPEQUAL,
                    &vCimType);
                pObj->Release();
                if(FAILED(hres)) return hres;
            }
            lIndex++;
        }

        // Copy the CVar we ended up with into the variant
        // ===============================================

        vCurrent.FillVariant(pvValue, TRUE);
        if(pwszCimType && vCimType.GetType() == VT_BSTR)
            *pwszCimType = WbemStringCopy(vCimType.GetLPWSTR());
        return WBEM_S_NO_ERROR;
    }
    catch (CX_MemoryException)
    {
        return WBEM_E_OUT_OF_MEMORY;
    }
    catch (...)
    {
        return WBEM_E_FAILED;
    }

}


STDMETHODIMP CWbemObject::GetPropertyHandle(LPCWSTR wszPropertyName,
                                            CIMTYPE* pct,
                                            long* plHandle)
{
    // IWbemObjectAccess - No intrinsic thread safety or try/catch exception handling
    // This is a high-perf interface
    
    // Allocation Exceptions handled underneath
    return GetClassPart()->GetPropertyHandle(wszPropertyName, pct, plHandle);
}

STDMETHODIMP CWbemObject::GetPropertyInfoByHandle(long lHandle,
                                        BSTR* pstrPropertyName, CIMTYPE* pct)
{
    // IWbemObjectAccess - No intrinsic thread safety or try/catch exception handling
    // This is a high-perf interface
    
    // Allocation Exceptions handled underneath
    return GetClassPart()->GetPropertyInfoByHandle(lHandle, pstrPropertyName,
                                        pct);
}


HRESULT CWbemObject::IsValidPropertyHandle( long lHandle )
{
    // Shouldn' be any allocations here
    return GetClassPart()->IsValidPropertyHandle( lHandle );
}


HRESULT CWbemObject::WritePropertyValue(long lHandle, long lNumBytes,
                                        const BYTE* pData)
{
    // IWbemObjectAccess - No intrinsic thread safety or try/catch exception handling
    // This is a high-perf interface
    
    int nIndex = WBEM_OBJACCESS_HANDLE_GETINDEX(lHandle);
    if (nIndex > m_refDataTable.m_nProps) return WBEM_E_INVALID_PARAMETER;
	int nOffset = WBEM_OBJACCESS_HANDLE_GETOFFSET(lHandle);

    BOOL bUseOld = !m_refDataTable.IsDefault(nIndex) &&
                        !m_refDataTable.IsNull(nIndex);
    m_refDataTable.SetNullness(nIndex, FALSE);
    m_refDataTable.SetDefaultness(nIndex, FALSE);

    if(WBEM_OBJACCESS_HANDLE_ISPOINTER(lHandle))
    {

        // Allocation errors are handled underneath

        // Handle strings.

	    if (nOffset+sizeof(heapptr_t) > m_refDataTable.GetLength()) return WBEM_E_INVALID_PARAMETER;
        
        LPCWSTR wszData = (LPCWSTR)pData;

        // Verify null-termination
        // =======================

        // The number of bytes must be divisible by 2, >= 2 and
        // the character in the buffer at the end must be a NULL.
        // This will be faster than doing an lstrlen.

        if (    ( lNumBytes < 2 ) ||
                ( lNumBytes % 2 ) ||
                ( wszData[lNumBytes/2 - 1] != 0 ) )
            return WBEM_E_INVALID_PARAMETER;


        // Create a value pointing to the right offset in the data table
        // =============================================================

        CDataTablePtr ValuePtr(&m_refDataTable, nOffset);
        CVar v;
        v.SetLPWSTR((LPWSTR)pData, TRUE);
        v.SetCanDelete(FALSE);


		heapptr_t oldOffset = ValuePtr.AccessPtrData();
        CCompressedString* pcsOld = m_refDataHeap.ResolveString(oldOffset);

		if (!pcsOld) return WBEM_E_INVALID_PARAMETER;
            
		if (!pcsOld->NValidateSize(m_refDataHeap.ElementMaxSize(oldOffset)))
		{
			return WBEM_E_INVALID_PARAMETER;
		};

        // Check for possible memory allocation failures
        Type_t  nReturnType;
        HRESULT hr = CUntypedValue::LoadFromCVar(&ValuePtr, v, VT_BSTR, &m_refDataHeap,
                        nReturnType,bUseOld);
        
        if ( FAILED( hr ) )
        {
            return hr;
        }

        if ( CIM_ILLEGAL == nReturnType )
        {
            return WBEM_E_TYPE_MISMATCH;
        }
    }
    else
    {
        if ( lNumBytes != WBEM_OBJACCESS_HANDLE_GETLENGTH(lHandle) )
        {
            return WBEM_E_INVALID_PARAMETER;
        }
	    if (nOffset+lNumBytes > m_refDataTable.GetLength()) return WBEM_E_INVALID_PARAMETER;

        // Just copy
        // =========

        memcpy((void*)(m_refDataTable.m_pData + (WBEM_OBJACCESS_HANDLE_GETOFFSET(lHandle))),
                pData, WBEM_OBJACCESS_HANDLE_GETLENGTH(lHandle));
    }

    return WBEM_S_NO_ERROR;
}

HRESULT CWbemObject::ReadPropertyValue(long lHandle, long lNumBytes,
                                        long* plRead, BYTE* pData)
{
    // IWbemObjectAccess - No intrinsic thread safety or try/catch exception handling
    // This is a high-perf interface

    int nIndex = WBEM_OBJACCESS_HANDLE_GETINDEX(lHandle);
    if (nIndex > m_refDataTable.m_nProps) return WBEM_E_INVALID_PARAMETER;
	int nOffset = WBEM_OBJACCESS_HANDLE_GETOFFSET(lHandle);

    if(m_refDataTable.IsNull(nIndex))
    {
        *plRead = 0;
        return WBEM_S_FALSE;
    }

    if(m_refDataTable.IsDefault(nIndex))
    {
        long    lRead = 0;
        return GetClassPart()->GetDefaultByHandle( lHandle, lNumBytes, plRead, pData );
    }

    if(WBEM_OBJACCESS_HANDLE_ISPOINTER(lHandle))
    {
        // Handle strings.
	    if (nOffset+sizeof(heapptr_t) > m_refDataTable.GetLength()) return WBEM_E_INVALID_PARAMETER;
		heapptr_t oldOffset = *(PHEAPPTRT)(m_refDataTable.m_pData +
                              (WBEM_OBJACCESS_HANDLE_GETOFFSET(lHandle)));
		
        CCompressedString* pcs = m_refDataHeap.ResolveString(oldOffset);

		if (!pcs) return WBEM_E_INVALID_PARAMETER;

		if (!pcs->NValidateSize(m_refDataHeap.ElementMaxSize(oldOffset)))
		{
			return WBEM_E_INVALID_PARAMETER;
		}

        long lNumChars = pcs->GetStringLength();
        //
        *plRead = (lNumChars + 1) * 2;
        if(*plRead > lNumBytes)
        {
            return WBEM_E_BUFFER_TOO_SMALL;
        }

        if(pcs->IsUnicode())
        {
            memcpy(pData, pcs->GetRawData(), lNumChars * 2);
        }
        else
        {
            WCHAR* pwcDest = (WCHAR*)pData;
            char* pcSource = (char*)pcs->GetRawData();
            long lLeft = lNumChars;
            while(lLeft--)
            {
                *(pwcDest++) = (WCHAR)*(pcSource++);
            }
        }

        ((LPWSTR)pData)[lNumChars] = 0;

        return WBEM_S_NO_ERROR;
    }
    else
    {
        // Just copy
        // =========

        *plRead = WBEM_OBJACCESS_HANDLE_GETLENGTH(lHandle);

        // Buffer is too small
        if(*plRead > lNumBytes)
        {
            return WBEM_E_BUFFER_TOO_SMALL;
        }

	    if (nOffset+*plRead > m_refDataTable.GetLength()) return WBEM_E_INVALID_PARAMETER;


        memcpy(pData, (void*)(m_refDataTable.m_pData + (WBEM_OBJACCESS_HANDLE_GETOFFSET(lHandle))),
                *plRead);
        return WBEM_S_NO_ERROR;
    }
}

HRESULT CWbemObject::ReadDWORD(long lHandle, DWORD* pdw)
{
    // No allocation errors here.  Just direct memory access
    // IWbemObjectAccess - No intrinsic thread safety or try/catch exception handling

    // This is a high-perf interface

    int nIndex = WBEM_OBJACCESS_HANDLE_GETINDEX(lHandle);
   
    if (nIndex > m_refDataTable.m_nProps) return WBEM_E_INVALID_PARAMETER;
    int nOffset = WBEM_OBJACCESS_HANDLE_GETOFFSET(lHandle);
    if (nOffset+sizeof(DWORD) > m_refDataTable.GetLength()) return WBEM_E_INVALID_PARAMETER;

    // Check NULLness and Defaultness
    if(m_refDataTable.IsNull(nIndex))
    {
        *pdw = 0;
        return WBEM_S_FALSE;
    }

    if(m_refDataTable.IsDefault(nIndex))
    {
        long    lRead = 0;
        return GetClassPart()->GetDefaultByHandle( lHandle, sizeof(DWORD), &lRead, (BYTE*) pdw );
    }

    *pdw = *(UNALIGNED DWORD*)(m_refDataTable.m_pData + (WBEM_OBJACCESS_HANDLE_GETOFFSET(lHandle)));
    return WBEM_S_NO_ERROR;
}

HRESULT CWbemObject::WriteDWORD(long lHandle, DWORD dw)
{
    // IWbemObjectAccess - No intrinsic thread safety or try/catch exception handling
    // This is a high-perf interface

    // No allocation errors here.  Just direct memory access

    int nIndex = WBEM_OBJACCESS_HANDLE_GETINDEX(lHandle);

    if (nIndex > m_refDataTable.m_nProps) return WBEM_E_INVALID_PARAMETER;
  
    int nOffset = WBEM_OBJACCESS_HANDLE_GETOFFSET(lHandle);

    if (nOffset+sizeof(DWORD) > m_refDataTable.GetLength()) return WBEM_E_INVALID_PARAMETER;
    
    m_refDataTable.SetNullness(nIndex, FALSE);
    m_refDataTable.SetDefaultness(nIndex, FALSE);

    *(UNALIGNED DWORD*)(m_refDataTable.m_pData + (WBEM_OBJACCESS_HANDLE_GETOFFSET(lHandle))) = dw;
    return WBEM_S_NO_ERROR;
}

HRESULT CWbemObject::ReadQWORD(long lHandle, unsigned __int64* pqw)
{
    // IWbemObjectAccess - No intrinsic thread safety or try/catch exception handling
    // This is a high-perf interface

    // No allocation errors here.  Just direct memory access

    int nIndex = WBEM_OBJACCESS_HANDLE_GETINDEX(lHandle);

    if (nIndex > m_refDataTable.m_nProps) return WBEM_E_INVALID_PARAMETER;
    int nOffset = WBEM_OBJACCESS_HANDLE_GETOFFSET(lHandle);
    if (nOffset+sizeof(__int64) > m_refDataTable.GetLength()) return WBEM_E_INVALID_PARAMETER;
    
    if(m_refDataTable.IsNull(nIndex))
    {
        *pqw = 0;
        return WBEM_S_FALSE;
    }

    if(m_refDataTable.IsDefault(nIndex))
    {
        long    lRead = 0;
        return GetClassPart()->GetDefaultByHandle( lHandle, sizeof(unsigned __int64), &lRead, (BYTE*) pqw );
    }

    *pqw = *(UNALIGNED __int64*)(m_refDataTable.m_pData + (WBEM_OBJACCESS_HANDLE_GETOFFSET(lHandle)));
    return WBEM_S_NO_ERROR;
}

HRESULT CWbemObject::WriteQWORD(long lHandle, unsigned __int64 qw)
{
    // IWbemObjectAccess - No intrinsic thread safety or try/catch exception handling
    // This is a high-perf interface

    // No allocation errors here.  Just direct memory access

    int nIndex = WBEM_OBJACCESS_HANDLE_GETINDEX(lHandle);

    if (nIndex > m_refDataTable.m_nProps) return WBEM_E_INVALID_PARAMETER;
    int nOffset = WBEM_OBJACCESS_HANDLE_GETOFFSET(lHandle);
    if (nOffset+sizeof(__int64) > m_refDataTable.GetLength()) return WBEM_E_INVALID_PARAMETER;
    
    m_refDataTable.SetNullness(nIndex, FALSE);
    m_refDataTable.SetDefaultness(nIndex, FALSE);
    *(UNALIGNED __int64*)(m_refDataTable.m_pData + (WBEM_OBJACCESS_HANDLE_GETOFFSET(lHandle))) = qw;
    return WBEM_S_NO_ERROR;
}

CWbemObject* CWbemObject::GetEmbeddedObj(long lHandle)
{
    // DEVNOTE:EXCEPTION:RETVAL - This function has been reviewed and should cleanup properly
    // if an exception is thrown

    int nIndex = WBEM_OBJACCESS_HANDLE_GETINDEX(lHandle);

    // Check for NULLNess and a default

    if(m_refDataTable.IsNull(nIndex))
    {
        return NULL;
    }

    CEmbeddedObject* pEmbedding;

    if ( m_refDataTable.IsDefault( nIndex ) )
    {
        GetClassPart()->GetDefaultPtrByHandle( lHandle, (void**) &pEmbedding );
    }
    else
    {

        pEmbedding =
            (CEmbeddedObject*)m_refDataHeap.ResolveHeapPointer(
                *(PHEAPPTRT)(m_refDataTable.m_pData + (WBEM_OBJACCESS_HANDLE_GETOFFSET(lHandle))));
    }

    if ( NULL != pEmbedding )
    {
        return pEmbedding->GetEmbedded();
    }
    else
    {
        return NULL;
    }
}

INTERNAL CCompressedString* CWbemObject::GetPropertyString(long lHandle)
{
    int nIndex = WBEM_OBJACCESS_HANDLE_GETINDEX(lHandle);
    if(m_refDataTable.IsNull(nIndex))
    {
        return NULL;
    }

    CCompressedString*  pCs;

    // Check for defaultness
    if ( m_refDataTable.IsDefault( nIndex ) )
    {
        GetClassPart()->GetDefaultPtrByHandle( lHandle, (void**) &pCs );
    }
    else
    {
        pCs = m_refDataHeap.ResolveString(
                    *(PHEAPPTRT)(m_refDataTable.m_pData + (WBEM_OBJACCESS_HANDLE_GETOFFSET(lHandle))));
    }
    return  pCs;
}

HRESULT CWbemObject::GetArrayPropertyHandle(LPCWSTR wszPropertyName,
                                            CIMTYPE* pct,
                                            long* plHandle)
{
    // Allocation Exceptions handled underneath
    return GetClassPart()->GetPropertyHandleEx(wszPropertyName, pct, plHandle);
}

INTERNAL CUntypedArray* CWbemObject::GetArrayByHandle(long lHandle)
{
    int nIndex = WBEM_OBJACCESS_HANDLE_GETINDEX(lHandle);
    if(m_refDataTable.IsNull(nIndex))
    {
        return NULL;
    }

    CUntypedArray* pArr = NULL;
    // Check for defaultness
    if ( m_refDataTable.IsDefault( nIndex ) )
    {
        GetClassPart()->GetDefaultPtrByHandle( lHandle, (void**) &pArr );
    }
    else
    {
        pArr = (CUntypedArray*) m_refDataHeap.ResolveHeapPointer(
                    *(PHEAPPTRT)(m_refDataTable.m_pData + (WBEM_OBJACCESS_HANDLE_GETOFFSET(lHandle))));
    }

    return pArr;
}

INTERNAL heapptr_t CWbemObject::GetHeapPtrByHandle(long lHandle)
{
    int nIndex = WBEM_OBJACCESS_HANDLE_GETINDEX(lHandle);

    // Check for defaultness
    if ( m_refDataTable.IsDefault( nIndex ) )
    {
        return GetClassPart()->GetHeapPtrByHandle( lHandle );
    }

    // Return the value at the offset
    return *(PHEAPPTRT)(m_refDataTable.m_pData + (WBEM_OBJACCESS_HANDLE_GETOFFSET(lHandle)));
}



//******************************************************************************
//
//  See fastobj.h for documentation
//
//******************************************************************************
STDMETHODIMP CWbemObject::GetUnmarshalClass(REFIID riid, void* pv,
    DWORD dwDestContext, void* pvReserved, DWORD mshlFlags, CLSID* pClsid)
{
    if (0 == pClsid) return E_POINTER;
    *pClsid = CLSID_WbemClassObjectProxy;
    return S_OK;
}

//******************************************************************************
//
//  See fastobj.h for documentation
//
//******************************************************************************
STDMETHODIMP CWbemObject::GetMarshalSizeMax(REFIID riid, void* pv,
    DWORD dwDestContext, void* pvReserved, DWORD mshlFlags, ULONG* plSize)
{
    if (0 == plSize) return E_POINTER;
    CLock lock(this, WBEM_FLAG_ALLOW_READ);
    // Let the object decide how big it is
    return GetMaxMarshalStreamSize( plSize );
}

// Default Implementation
HRESULT CWbemObject::GetMaxMarshalStreamSize( ULONG* pulSize )
{
    *pulSize = GetBlockLength() + sizeof(DWORD) * 2;
    return S_OK;
}

//******************************************************************************
//
//  See fastobj.h for documentation
//
//******************************************************************************
STDMETHODIMP CWbemObject::MarshalInterface(IStream* pStream, REFIID riid,
    void* pv,  DWORD dwDestContext, void* pvReserved, DWORD mshlFlags)
{
    try
    {
        CLock lock(this);

        HRESULT hres = ValidateObject( 0L );

        if ( FAILED( hres ) )
        {
            return E_FAIL;
        }

        CompactAll();

        hres = WriteToStream( pStream );

        return hres;
    }
    catch(...)
    {
        return E_FAIL;
    }
}

//******************************************************************************
//
//  See fastobj.h for documentation
//
//******************************************************************************
STDMETHODIMP CWbemObject::UnmarshalInterface(IStream* pStream, REFIID riid,
    void** ppv)
{
    return E_UNEXPECTED;
}

//******************************************************************************
//
//  See fastobj.h for documentation
//
//******************************************************************************
STDMETHODIMP CWbemObject::ReleaseMarshalData(IStream* pStream)
{
    return E_UNEXPECTED;
}

//******************************************************************************
//
//  See fastobj.h for documentation
//
//******************************************************************************
STDMETHODIMP CWbemObject::DisconnectObject(DWORD dwReserved)
{
    return S_OK;
}

STDMETHODIMP CWbemObject::GetDescription(BSTR* pstrDescription)
{
    try
    {
        CLock lock(this, WBEM_FLAG_ALLOW_READ);

        *pstrDescription = NULL;

        CVar vDesc;
        if(SUCCEEDED(GetProperty(L"Description", &vDesc)))
        {
            // Return "" if vDesc is NULL, otherwise the actual value
            if ( vDesc.IsNull() )
            {
                *pstrDescription = COleAuto::_SysAllocString( L"" );
            }
            else
            {
                *pstrDescription = COleAuto::_SysAllocString( vDesc.GetLPWSTR() );
            }
        }

        return S_OK;
    }
    catch (CX_MemoryException)
    {
        return E_OUTOFMEMORY;
    }
    catch (...)
    {
        return E_FAIL;
    }

}

STDMETHODIMP CWbemObject::GetGUID(GUID* pguid)
{
    if (0 == pguid) return WBEM_E_INVALID_PARAMETER;
    *pguid = IID_IWbemServices;
    return S_OK;
}
STDMETHODIMP CWbemObject::GetHelpContext(DWORD* pdwHelpContext)
{
    try
    {
        *pdwHelpContext = 0;
        return S_OK;
    }
    catch(...)
    {
        return E_FAIL;
    }
}
STDMETHODIMP CWbemObject::GetHelpFile(BSTR* pstrHelpFile)
{
    try
    {
        *pstrHelpFile = 0;
        return S_OK;
    }
    catch(...)
    {
        return E_FAIL;
    }
}
STDMETHODIMP CWbemObject::GetSource(BSTR* pstrSource)
{
    // Check for out of memory
    try
    {
        *pstrSource = COleAuto::_SysAllocString(L"WinMgmt");
        return S_OK;
    }
    catch (CX_MemoryException)
    {
        return WBEM_E_OUT_OF_MEMORY;
    }
    catch (...)
    {
        return WBEM_E_FAILED;
    }

}


STDMETHODIMP CWbemObject::Lock(long lFlags)
{
    // Since the flags really don't do anything, we'll require 0L on this call.
    m_Lock.Lock();
    return WBEM_S_NO_ERROR;
}

STDMETHODIMP CWbemObject::Unlock(long lFlags)
{
    // Since the flags really don't do anything, we'll require 0L on this call.

    m_Lock.Unlock();
    return WBEM_S_NO_ERROR;
}

// Iplementations of _IWmiObject functions for getting part data

// Check what the state of the internal data
STDMETHODIMP CWbemObject::QueryPartInfo( DWORD *pdwResult )
{
    try
    {
        *pdwResult = m_dwInternalStatus;
        return WBEM_S_NO_ERROR;
    }
    catch(...)
    {
        return WBEM_E_CRITICAL_ERROR;
    }
}

// The following code unmerges and merges BLOBs with CRC checking so we can
// verify if any corruptions are occuring outside of our control

#ifdef OBJECT_BLOB_CRC

// Buffer size
#define SIZE_OF_MD5_BUFFER    16

// Sets the object memory to a new BLOB
STDMETHODIMP CWbemObject::SetObjectMemory( LPVOID pMem, DWORD dwMemSize )
{
    // An exception can be thrown by SetData.  If so, the original object should
    // be '86'd (we can't fix it, since we would need to call SetData ourselves
    // to repair it and that may cause another exception

    // Check for out of memory
    try
    {
        HRESULT hr = WBEM_E_INVALID_PARAMETER;

        if ( NULL != pMem )
        {
            // Changing the BLOB, so we better be thread safe
            CLock lock(this);

            BYTE    bHash[SIZE_OF_MD5_BUFFER];
            BYTE*    pbTemp = (LPBYTE) pMem;

            // First we need to verify the hash
            MD5::Transform( pbTemp + SIZE_OF_MD5_BUFFER, dwMemSize - SIZE_OF_MD5_BUFFER, bHash );

            if ( memcmp( bHash, pbTemp, SIZE_OF_MD5_BUFFER ) != 0 )
            {
                OutputDebugString( "BLOB hash value check failed!" );
                DebugBreak();
                return WBEM_E_CRITICAL_ERROR;
            }

            pbTemp += SIZE_OF_MD5_BUFFER;
            dwMemSize -= SIZE_OF_MD5_BUFFER            ;

            BYTE*    pbData = m_pBlobControl->Allocate(dwMemSize);

            if ( NULL != pbData )
            {
                // Delete prior memory
                m_pBlobControl->Delete(GetStart());

                // Copy the bytes across
                CopyMemory( pbData, pbTemp, dwMemSize );

                SetData( pbData, dwMemSize );

                // Cleanup the memory that was passed into us
                CoTaskMemFree( pMem );

                hr = WBEM_S_NO_ERROR;
            }
            else
            {
                hr = WBEM_E_OUT_OF_MEMORY;
            }

        }

        return hr;
    }
    catch (CX_MemoryException)
    {
        return WBEM_E_OUT_OF_MEMORY;
    }
    catch (...)
    {
        return WBEM_E_FAILED;
    }

}

// Copies our entire BLOB into a user provided buffer
STDMETHODIMP CWbemObject::GetObjectMemory( LPVOID pDestination, DWORD dwDestBufSize, DWORD *pdwUsed )
{
    // Nothing is allocated here, so we should be ok
    if (NULL == pdwUsed) return WBEM_E_INVALID_PARAMETER;

    HRESULT hr;
    
    try
    {
        // Copying the BLOB, so make sure nobody tears it out from underneath us
        CLock lock(this);

        // How big a block we need (we will prepend with an MD5 Hash)
        DWORD    dwBlockLen = GetBlockLength();
        DWORD    dwTotalLen = dwBlockLen + SIZE_OF_MD5_BUFFER;

        *pdwUsed = dwTotalLen;

        // Make sure the size of the block is big enough, or return
        // a failure code.

        if ( dwDestBufSize >= *pdwUsed )
        {
            // Make sure we have a buffer to copy to
            if ( NULL != pDestination )
            {
                // Copy the memory 16 bytes in so we can prepend with an ND5 hash
                CopyMemory( ( (BYTE*) pDestination ) + SIZE_OF_MD5_BUFFER, GetStart(), dwBlockLen );
                MD5::Transform( GetStart(), dwBlockLen, (BYTE*) pDestination ); 

                hr = WBEM_S_NO_ERROR;
            }
            else
            {
                hr = WBEM_E_INVALID_PARAMETER;
            }
        }
        else
        {
            hr = WBEM_E_BUFFER_TOO_SMALL;
        }

        return hr;
    }
    catch(...)
    {
        return WBEM_E_CRITICAL_ERROR;
    }
}

#else

// Sets the object memory to a new BLOB
STDMETHODIMP CWbemObject::SetObjectMemory( LPVOID pMem, DWORD dwMemSize )
{
    // An exception can be thrown by SetData.  If so, the original object should
    // be '86'd (we can't fix it, since we would need to call SetData ourselves
    // to repair it and that may cause another exception

    // Check for out of memory
    try
    {
        HRESULT hr = WBEM_E_INVALID_PARAMETER;

        if ( NULL != pMem )
        {
            // Changing the BLOB, so we better be thread safe
            CLock lock(this);


            // Use the current BLOB Control to delete the underlying BLOB,
            // then delete the BLOB control and replace it with the new one
            // and SetData.
            m_pBlobControl->Delete(GetStart());

            // Use a new COM Blob control, as the supplied memory must
            // be CoTaskMemAlloced/Freed.
            
            m_pBlobControl = & g_CCOMBlobControl;

            SetData( (LPMEMORY) pMem, dwMemSize );

            hr = WBEM_S_NO_ERROR;
        }

        return hr;
    }
    catch (CX_MemoryException)
    {
        return WBEM_E_OUT_OF_MEMORY;
    }
    catch (...)
    {
        return WBEM_E_FAILED;
    }

}

// Copies our entire BLOB into a user provided buffer
STDMETHODIMP CWbemObject::GetObjectMemory( LPVOID pDestination, DWORD dwDestBufSize, DWORD *pdwUsed )
{
    // Nothing is allocated here, so we should be ok

    HRESULT hr;

    try
    {
        // Copying the BLOB, so make sure nobody tears it out from underneath us
        CLock lock(this);

        // How big a block we need
        *pdwUsed = GetBlockLength();

        // Make sure the size of the block is big enough, or return
        // a failure code.

        if ( dwDestBufSize >= GetBlockLength() )
        {
            // Make sure we have a buffer to copy to
            if ( NULL != pDestination )
            {
                CopyMemory( pDestination, GetStart(), GetBlockLength() );
                hr = WBEM_S_NO_ERROR;
            }
            else
            {
                hr = WBEM_E_INVALID_PARAMETER;
            }
        }
        else
        {
            hr = WBEM_E_BUFFER_TOO_SMALL;
        }

        return hr;
    }
    catch(...)
    {
        return WBEM_E_CRITICAL_ERROR;
    }
}

#endif

// Access to Decorate
STDMETHODIMP CWbemObject::SetDecoration( LPCWSTR pwcsServer, LPCWSTR pwcsNamespace )
{
    // Nothing is allocated here, so we should be ok

    try
    {
        // Changing the BLOB, so make sure nobody tears it out from underneath us
        CLock lock(this);

        return Decorate( pwcsServer, pwcsNamespace );
    }
    catch(...)
    {
        return WBEM_E_CRITICAL_ERROR;
    }
}

STDMETHODIMP CWbemObject::RemoveDecoration( void )
{
    // Nothing is allocated here, so we should be ok

    try
    {
        // Changing the BLOB, so make sure nobody tears it out from underneath us
        CLock lock(this);

        //It's a void!
        Undecorate();

        return WBEM_S_NO_ERROR;
    }
    catch(...)
    {
        return WBEM_E_CRITICAL_ERROR;
    }
}

BOOL CWbemObject::AreEqual(CWbemObject* pObj1, CWbemObject* pObj2,
                            long lFlags)
{
    if(pObj1 == NULL)
    {
        if(pObj2 != NULL) return FALSE;
        else return TRUE;
    }
    else if(pObj2 == NULL) return FALSE;
    else
    {
        return (pObj1->CompareTo(lFlags, pObj2) == S_OK);
    }
}

HRESULT CWbemObject::GetPropertyIndex(LPCWSTR wszName, int* pnIndex)
{
    int nSysIndex = CSystemProperties::FindName(wszName);
    if(nSysIndex > 0)
    {
        *pnIndex = -nSysIndex;
        return S_OK;
    }

    CPropertyInformation* pInfo = GetClassPart()->FindPropertyInfo(wszName);
    if(pInfo == NULL)
        return WBEM_E_NOT_FOUND;

    *pnIndex = pInfo->nDataIndex;
    return S_OK;
}

HRESULT CWbemObject::GetPropertyNameFromIndex(int nIndex, BSTR* pstrName)
{
    // Check for out of memory
    try
    {
        if(nIndex < 0)
        {
            *pstrName = CSystemProperties::GetNameAsBSTR(-nIndex);
            return S_OK;
        }

        CClassPart& ClassPart = *GetClassPart();
        CPropertyLookup* pLookup =
            ClassPart.m_Properties.GetAt(nIndex);

        *pstrName = ClassPart.m_Heap.ResolveString(pLookup->ptrName)->
                        CreateBSTRCopy();

        // Check for allocation failures
        if ( NULL == *pstrName )
        {
            return WBEM_E_OUT_OF_MEMORY;
        }

        return S_OK;
    }
    catch (CX_MemoryException)
    {
        return WBEM_E_OUT_OF_MEMORY;
    }
    catch (...)
    {
        return WBEM_E_FAILED;
    }

}

STDMETHODIMP CWbemObject::SetServerNamespace(LPCWSTR wszServer,
                                            LPCWSTR wszNamespace)
{
    // Memory testing done underneath
    return Decorate(wszServer, wszNamespace);
}

// DEVNOTE:TODO:MEMORY - We should change this header to return an HRESULT
BOOL CWbemObject::ValidateRange(BSTR* pstrName)
{
    HRESULT hr = GetClassPart()->m_Properties.ValidateRange(pstrName,
                                                        &m_refDataTable,
                                                        &m_refDataHeap);

    // Interpret return.  We are successful, if nothing failed and the
    // return is not WBEM_S_FALSE.

    if ( SUCCEEDED( hr ) )
    {
        return WBEM_S_FALSE != hr;
    }

    return FALSE;
}

BOOL CWbemObject::IsSameClass(CWbemObject* pOther)
{
    if(GetClassPart()->GetLength() != pOther->GetClassPart()->GetLength())
        return FALSE;

    return (memcmp(GetClassPart()->GetStart(),
                    pOther->GetClassPart()->GetStart(),
                    GetClassPart()->GetLength()) == 0);
}

HRESULT CWbemObject::ValidatePath(ParsedObjectPath* pPath)
{
    CClassPart* pClassPart = GetClassPart();

    // Make sure singleton-ness holds
    // ==============================

    if((pPath->m_bSingletonObj != FALSE) !=
        (pClassPart->IsSingleton() != FALSE))
    {
        return WBEM_E_INVALID_OBJECT_PATH;
    }

    // Make sure that all the properties mentioned are keys
    // ====================================================

    int i;
    for(i = 0; i < (int)pPath->m_dwNumKeys; i++)
    {
        LPCWSTR wszName = pPath->m_paKeys[i]->m_pName;
        if(wszName)
        {
            CVar vKey;
            CPropertyInformation* pInfo = pClassPart->FindPropertyInfo(wszName);
            if(pInfo == NULL)
                return WBEM_E_INVALID_OBJECT_PATH;
            if(FAILED(pClassPart->GetPropQualifier(pInfo, L"key", &vKey)))
                return WBEM_E_INVALID_OBJECT_PATH;
            if(vKey.GetType() != VT_BOOL || !vKey.GetBool())
                return WBEM_E_INVALID_OBJECT_PATH;
        }
    }

    // Make sure all the keys are listed
    // =================================

    CPropertyLookupTable& Properties = pClassPart->m_Properties;
    CFastHeap& Heap = pClassPart->m_Heap;

    DWORD dwNumKeys = 0;
    for (i = 0; i < Properties.GetNumProperties(); i++)
    {
        CPropertyLookup* pLookup = Properties.GetAt(i);
        CPropertyInformation* pInfo = pLookup->GetInformation(&Heap);

        // Determine if this property is marked with a 'key' Qualifier.
        // ============================================================

        if(pInfo->IsKey())
            dwNumKeys++;
    }

    if(dwNumKeys != pPath->m_dwNumKeys)
        return WBEM_E_INVALID_OBJECT_PATH;

    return WBEM_S_NO_ERROR;
}

HRESULT CWbemObject::EnabledValidateObject( CWbemObject* pObj )
{
    return pObj->IsValidObj();
}

// This doesn't
HRESULT CWbemObject::DisabledValidateObject( CWbemObject* pObj )
{
    return WBEM_S_NO_ERROR;
}

STDMETHODIMP CWbemObject::CompareClassParts( IWbemClassObject* pObj, long lFlags )
{
    if ( NULL == pObj )
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    try
    {
        // Checking the BLOB
        CLock lock1(this);
        CLock lock2((CWbemObject*) pObj);

        CClassPart* pThisClassPart = GetClassPart();
        CClassPart* pThatClassPart = ((CWbemObject*) pObj)->GetClassPart();

        if ( NULL == pThisClassPart || NULL == pThatClassPart )
        {
            return WBEM_E_FAILED;
        }

        BOOL    fMatch = FALSE;

        if ( WBEM_FLAG_COMPARE_BINARY == lFlags )
        {
            fMatch = pThisClassPart->IsIdenticalWith( *pThatClassPart );
        }
        else if ( WBEM_FLAG_COMPARE_LOCALIZED == lFlags )
        {
            BOOL    fLocalized = ( WBEM_FLAG_COMPARE_LOCALIZED == lFlags );
            EReconciliation e = pThisClassPart->CompareExactMatch( *pThatClassPart, fLocalized );

            if ( e_OutOfMemory == e )
            {
                return WBEM_E_OUT_OF_MEMORY;
            }

            fMatch = ( e_ExactMatch == e );
        }

        return ( fMatch ? WBEM_S_SAME : WBEM_S_FALSE );
    }
    catch(CX_MemoryException)
    {
        return WBEM_E_OUT_OF_MEMORY;
    }
    catch(...)
    {
        return WBEM_E_CRITICAL_ERROR;
    }

}

// We will throw exceptions in OOM scenarios.

length_t CWbemObject::Unmerge(LPMEMORY* ppStart)
{
    int nLen = EstimateUnmergeSpace();
    length_t    nUnmergedLength = 0L;   // this should be passed in

    HRESULT hr = WBEM_E_OUT_OF_MEMORY;

    // Unmerging uses memcpy and is for storing outside, so don't worry about
    // alinging this guy.
    *ppStart = new BYTE[nLen];

    if ( NULL != *ppStart )
    {
        memset(*ppStart, 0, nLen);
        hr = Unmerge(*ppStart, nLen, &nUnmergedLength);

        if ( FAILED( hr ) )
        {
            delete[] *ppStart;
            *ppStart = NULL;

            if ( WBEM_E_OUT_OF_MEMORY == hr )
            {
                throw CX_MemoryException();
            }
        }
    }
    else
    {
        throw CX_MemoryException();
    }

    return nUnmergedLength;

}

/* New _IWmiObject implementations. */

STDMETHODIMP CWbemObject::GetPropertyHandleEx( LPCWSTR wszPropertyName,
                                            long lFlags,
                                            CIMTYPE* pct,
                                            long* plHandle )
{
    try
    {
        // Check flags
        if ( lFlags != 0L )
        {
            return WBEM_E_INVALID_PARAMETER;
        }

        // Allocation Exceptions handled underneath
        return GetClassPart()->GetPropertyHandleEx(wszPropertyName, pct, plHandle);
    }
    catch(...)
    {
        return WBEM_E_CRITICAL_ERROR;
    }
}

// Sets properties using a handle.  If pvData is NULL, it NULLs the property.
// Can set an array to NULL.  To set actual data use the corresponding array
// function.  Objects require a pointer to an _IWmiObject pointer.  Strings
// are pointers to a NULL terminated WCHAR.
STDMETHODIMP CWbemObject::SetPropByHandle( long lHandle, long lFlags, ULONG uDataSize, LPVOID pvData )
{
    try
    {
        // Check flags
        if ( lFlags != 0L )
        {
            return WBEM_E_INVALID_PARAMETER;
        }

        HRESULT    hr = WBEM_S_NO_ERROR;

        int nIndex = WBEM_OBJACCESS_HANDLE_GETINDEX(lHandle);

        // If pvData is NULL, then we will NULL out the value

        if ( NULL == pvData )
        {
            // Special case reserved handling
            if ( WBEM_OBJACCESS_HANDLE_ISRESERVED(lHandle) )
            {
                // No reserved can be set to NULL.
                return WBEM_E_ILLEGAL_OPERATION;
            }    // IF Reserved

            // If it's a pointer, make sure it's not an array
            if(WBEM_OBJACCESS_HANDLE_ISPOINTER(lHandle))
            {
                // Point to the proper heap and datatable
                CFastHeap*    pHeap = &m_refDataHeap;
                CDataTable*    pDataTable = &m_refDataTable;

                // Oops!  Get them from the class part
                if ( m_refDataTable.IsDefault( nIndex ) )
                {
                    pHeap = GetClassPart()->GetHeap();
                    pDataTable = GetClassPart()->GetDataTable();
                }

                // Now get the heapptr
                heapptr_t ptrData = *(PHEAPPTRT)(pDataTable->m_pData + (WBEM_OBJACCESS_HANDLE_GETOFFSET(lHandle)));

                if ( WBEM_OBJACCESS_HANDLE_ISARRAY(lHandle) )
                {
                    CUntypedArray*    pArray = (CUntypedArray*) pHeap->ResolveHeapPointer( ptrData );
                    pHeap->Free( ptrData, pArray->GetLengthByActualLength( WBEM_OBJACCESS_HANDLE_GETLENGTH(lHandle) ) );
                }
                else if ( WBEM_OBJACCESS_HANDLE_ISSTRING(lHandle) )
                {
                    pHeap->FreeString( ptrData );
                }
                else
                {
                    CEmbeddedObject* pObj = (CEmbeddedObject*) pHeap->ResolveHeapPointer( ptrData );
                    pHeap->Free( ptrData, pObj->GetLength() );
                }

            }    // IF IsPointer

            // Set the NULLness and Defaultness bits

            if ( SUCCEEDED( hr ) )
            {
                m_refDataTable.SetNullness( nIndex, TRUE );
                m_refDataTable.SetDefaultness( nIndex, FALSE );
            }

        }
        else    // We're actually setting some data (or so we hope)
        {
            // Whether or not we will allow the previous pointer to
            // be reused.
            BOOL bUseOld = FALSE;

            // We're actually setting the value here.
            // Ignore arrays and reserved handles
            if ( !WBEM_OBJACCESS_HANDLE_ISRESERVED(lHandle) )
            {
                bUseOld = !m_refDataTable.IsDefault(nIndex) &&
                            !m_refDataTable.IsNull(nIndex);

                if ( !WBEM_OBJACCESS_HANDLE_ISARRAY(lHandle) )
                {
                    m_refDataTable.SetNullness(nIndex, FALSE);
                    m_refDataTable.SetDefaultness(nIndex, FALSE);
                }
            }

            if (WBEM_OBJACCESS_HANDLE_ISPOINTER(lHandle))
            {
                BOOL    fReserved = FALSE;

                // Look for property info only if we need to.
                if ( FASTOBJ_CLASSNAME_PROP_HANDLE == lHandle )
                {
                    fReserved = TRUE;
                }
                else if ( FASTOBJ_SUPERCLASSNAME_PROP_HANDLE == lHandle )
                {
                    // Don't allow setting the superclass name just yet.
                    hr = WBEM_E_INVALID_OPERATION;
                }

                if ( SUCCEEDED( hr ) )
                {
                    if ( fReserved || !WBEM_OBJACCESS_HANDLE_ISARRAY(lHandle) )
                    {
                        CIMTYPE    ctBasic = CIM_OBJECT;

                        if ( WBEM_OBJACCESS_HANDLE_ISSTRING(lHandle) )
                        {
                            LPCWSTR wszData = (LPCWSTR) pvData;

                            // The number of bytes must be divisible by 2, >= 2 and
                            // the character in the buffer at the end must be a NULL.
                            // This will be faster than doing an lstrlen.

                            if (    ( uDataSize < 2 ) ||
                                    ( uDataSize % 2 ) ||
                                    ( wszData[uDataSize/2 - 1] != 0 ) )
                            {
                                return WBEM_E_INVALID_PARAMETER;
                            }

                            ctBasic = CIM_STRING;
                        }

                        if ( SUCCEEDED( hr ) )
                        {
                            CVar var;

                            // Fill the CVar properly

                            hr = CUntypedValue::FillCVarFromUserBuffer(ctBasic, &var,
                                                                        uDataSize,
                                                                        pvData );


                            if ( SUCCEEDED( hr ) )
                            {
                                // Uses the appropriate method to do this
                                if ( FASTOBJ_CLASSNAME_PROP_HANDLE == lHandle )
                                {
                                    hr = GetClassPart()->SetClassName( &var );
                                }
                                else
                                {
                                    int nOffset = (WBEM_OBJACCESS_HANDLE_GETOFFSET(lHandle));
                                    // Create a value pointing to the right offset in the data table
                                    // =============================================================

                                    CDataTablePtr ValuePtr(&m_refDataTable, nOffset);
                                    
                                    // Check for possible memory allocation failures
                                    Type_t  nReturnType;

                                    hr = CUntypedValue::LoadFromCVar( &ValuePtr, var, CType::GetVARTYPE(ctBasic),
                                                                    &m_refDataHeap,    nReturnType, bUseOld );

                                    if ( CIM_ILLEGAL == nReturnType )
                                    {
                                        hr = WBEM_E_TYPE_MISMATCH;
                                    }
                                }


                            }    // IF Filled the CVar

                        }    // IF we're good to go

                    }    // IF not an array
                    else
                    {
                        hr = WBEM_E_INVALID_OPERATION;
                    }

                }    // If got CIMTYPE
            }
            else
            {

                if ( uDataSize != WBEM_OBJACCESS_HANDLE_GETLENGTH(lHandle) )
                {
                    return WBEM_E_INVALID_PARAMETER;
                }

                // Just copy
                // =========

                memcpy((void*)(m_refDataTable.m_pData + (WBEM_OBJACCESS_HANDLE_GETOFFSET(lHandle))),
                        pvData, WBEM_OBJACCESS_HANDLE_GETLENGTH(lHandle));
            }
        }

        return hr;
    }
    catch(...)
    {
        return WBEM_E_CRITICAL_ERROR;
    }
}

// Retrieves direct pointer into V1 BLOB.  Does not do so for strings, arrays or embedded objects
STDMETHODIMP CWbemObject::GetPropAddrByHandle( long lHandle, long lFlags, ULONG* puFlags, LPVOID *pAddress )
{
    try
    {
        // Check flags
        if ( lFlags & ~WMIOBJECT_FLAG_ENCODING_V1 )
        {
            return WBEM_E_INVALID_PARAMETER;
        }

        HRESULT    hr = WBEM_S_NO_ERROR;

        // No intrinsic lock/unlock here.

        int nIndex = WBEM_OBJACCESS_HANDLE_GETINDEX(lHandle);
        if( !WBEM_OBJACCESS_HANDLE_ISRESERVED(lHandle) && m_refDataTable.IsNull(nIndex) )
        {
            *pAddress = 0;
            return WBEM_S_FALSE;
        }

        // If it's a pointer, make sure it's not an array
        if(WBEM_OBJACCESS_HANDLE_ISPOINTER(lHandle))
        {
            // Remember that a reserved flag will have all the mutually
            // exclusive stuff set
            if ( WBEM_OBJACCESS_HANDLE_ISARRAY(lHandle) &&
                !WBEM_OBJACCESS_HANDLE_ISRESERVED(lHandle) )
            {
                hr = WBEM_E_INVALID_OPERATION;
            }
            else
            {
                // If it's a string, we should treat it as such
                if ( WBEM_OBJACCESS_HANDLE_ISSTRING(lHandle) )
                {
                    CCompressedString*    pcs;
                    
                    // Gets the appropriate compressed string pointer
                    if ( FASTOBJ_CLASSNAME_PROP_HANDLE == lHandle )
                    {
                        pcs = GetClassPart()->GetClassName();
                    }
                    else if ( FASTOBJ_SUPERCLASSNAME_PROP_HANDLE == lHandle )
                    {
                        pcs = GetClassPart()->GetSuperclassName();
                    }
                    else
                    {
                        pcs = GetPropertyString( lHandle );
                    }

                    // Load up the values now.
                    if ( NULL != pcs )
                    {
                        // If the v1 Encoding flag is set, the user says they know what they're doing
                        // so let 'em have the raw pointer
                        if ( lFlags & WMIOBJECT_FLAG_ENCODING_V1 )
                        {
                            *pAddress = pcs;
                        }
                        else
                        {
                            *puFlags = *( pcs->GetStart() );
                            *pAddress = pcs->GetRawData();
                        }
                    }
                    else
                    {
                        hr = WBEM_S_FALSE;
                    }

                }
                else if ( WBEM_OBJACCESS_HANDLE_ISOBJECT(lHandle) )
                {
                    CWbemObject*    pObj = GetEmbeddedObj( lHandle );

                    if ( NULL != pObj )
                    {
                        // Just return the pointer
                        *pAddress = (PVOID) pObj;
                    }
                    else
                    {
                        hr = WBEM_E_OUT_OF_MEMORY;
                    }
                }

            }    // Else its not an array

        }    // IF IsPointer
        else
        {
                // Check if it's a default
            if(m_refDataTable.IsDefault(nIndex))
            {
                return GetClassPart()->GetDefaultPtrByHandle( lHandle, pAddress );
            }

            // Just save the memory address
            // =========

            *pAddress = (void*)(m_refDataTable.m_pData + (WBEM_OBJACCESS_HANDLE_GETOFFSET(lHandle)));
        }    // IF we should get the property

        return hr;
    }
    catch(...)
    {
        return WBEM_E_CRITICAL_ERROR;
    }

}

HRESULT CWbemObject::IsArrayPropertyHandle( long lHandle, CIMTYPE* pctIntrinisic, length_t* pnLength )
{
    try
    {
        HRESULT    hr = WBEM_S_NO_ERROR;

        if(WBEM_OBJACCESS_HANDLE_ISPOINTER(lHandle))
        {
            if ( WBEM_OBJACCESS_HANDLE_ISPOINTER(lHandle) )
            {
                // Get the basic type
                if ( WBEM_OBJACCESS_HANDLE_ISSTRING(lHandle) )
                {
                    *pctIntrinisic = CIM_STRING;
                }
                else if ( WBEM_OBJACCESS_HANDLE_ISOBJECT(lHandle) )
                {
                    *pctIntrinisic = CIM_OBJECT;
                }
                else
                {
                    *pctIntrinisic = CIM_ILLEGAL;
                }
                
                // Retrieve the intrinsic type length (it'll be ignored for
                // the above two anyway).
                *pnLength = WBEM_OBJACCESS_HANDLE_GETLENGTH(lHandle);
            }
            else
            {
                hr = WBEM_E_INVALID_OPERATION;

            }

        }
        else
        {
            hr = WBEM_E_INVALID_OPERATION;
        }

        return hr;
    }
    catch(...)
    {
        return WBEM_E_CRITICAL_ERROR;
    }

}

// Retrieves direct pointer into V1 BLOB.  Does not do so for strings, arrays or embedded objects
STDMETHODIMP CWbemObject::GetArrayPropAddrByHandle( long lHandle, long lFlags, ULONG* puNumElements, LPVOID* pAddress )
{
    try
    {
        // Check flags
        if ( lFlags != 0L )
        {
            return WBEM_E_INVALID_PARAMETER;
        }

        // No intrinsic lock/unlock here.

        int nIndex = WBEM_OBJACCESS_HANDLE_GETINDEX(lHandle);
        if(m_refDataTable.IsNull(nIndex))
        {
            *pAddress = 0;
            return WBEM_S_FALSE;
        }

        CIMTYPE        ct = 0;
        length_t    nLength;
        HRESULT    hr = IsArrayPropertyHandle( lHandle, &ct, &nLength );

        // It must be a pointer and non-string/object
        // We may decide to chop this if it's taking too
        // many cycles.

        if( SUCCEEDED( hr ) )
        {
            // No strings, objects or Date_Time
            if ( WBEM_OBJACCESS_HANDLE_ISSTRING(lHandle) || 
                WBEM_OBJACCESS_HANDLE_ISOBJECT(lHandle) )
            {
                hr = WBEM_E_INVALID_OPERATION;
            }

        }    // IF IsPointer

        if ( SUCCEEDED( hr ) )
        {
            CUntypedArray*    pArray = GetArrayByHandle( lHandle );

            if ( NULL != pArray )
            {
                // Get the number of elements and a pointer to the first byte
                *puNumElements = pArray->GetNumElements();
                if (*puNumElements)
                    *pAddress = pArray->GetElement( 0, 1 );
                else
                	*pAddress = NULL;
            }
            else
            {
                hr = WBEM_S_FALSE;
            }


        }    // IF we should get the property

        return hr;
    }
    catch(...)
    {
        return WBEM_E_CRITICAL_ERROR;
    }

}

// Retrieves direct pointer into V1 BLOB.  Since it does double indirection, we handle strings
// and objects here as well.
STDMETHODIMP CWbemObject::GetArrayPropInfoByHandle( long lHandle, long lFlags, BSTR* pstrName,
                                        CIMTYPE* pct, ULONG* puNumElements )
{
    try
    {
        // Check flags
        if ( lFlags != 0L )
        {
            return WBEM_E_INVALID_PARAMETER;
        }

        // No intrinsic lock/unlock here.

        // Make sure this is an array proprty
        CIMTYPE        ct = 0;
        length_t    nLength;
        HRESULT    hr = IsArrayPropertyHandle( lHandle, &ct, &nLength );

        if ( SUCCEEDED( hr ) )
        {
            hr = GetPropertyInfoByHandle( lHandle, pstrName, pct );

            if ( SUCCEEDED(hr) )
            {
                int nIndex = WBEM_OBJACCESS_HANDLE_GETINDEX(lHandle);
                if(!m_refDataTable.IsNull(nIndex))
                {
                    // Grab the array, then point to the required element
                    CUntypedArray*    pArray = GetArrayByHandle( lHandle );

                    if ( NULL != pArray )
                    {
                        // Get the number of elements and a pointer to the first byte
                        *puNumElements = pArray->GetNumElements();

                    }
                    else
                    {
                        hr = WBEM_S_FALSE;
                    }
                }
                else
                {
                    *puNumElements = 0;
                }

            }    // If we got basic property info


        }    // IF we should get the property

        return hr;
    }
    catch(...)
    {
        return WBEM_E_CRITICAL_ERROR;
    }
}

// Retrieves direct pointer into V1 BLOB.  Since it does double indirection, we handle strings
// and objects here as well.
STDMETHODIMP CWbemObject::GetArrayPropElementByHandle( long lHandle, long lFlags, ULONG uElement,
                                                    ULONG* puFlags,    ULONG* puNumElements, LPVOID *pAddress )
{
    try
    {
        // Check flags
        if ( lFlags != 0L )
        {
            return WBEM_E_INVALID_PARAMETER;
        }

        // No intrinsic lock/unlock here.

        int nIndex = WBEM_OBJACCESS_HANDLE_GETINDEX(lHandle);
        if(m_refDataTable.IsNull(nIndex))
        {
            *pAddress = 0;
            return WBEM_S_FALSE;
        }

        // Make sure this is an array proprty
        CIMTYPE        ct = 0;
        length_t    nLength;
        HRESULT    hr = IsArrayPropertyHandle( lHandle, &ct, &nLength );

        if ( SUCCEEDED( hr ) )
        {
            // Grab the array, then point to the required element
            CUntypedArray*    pArray = GetArrayByHandle( lHandle );

            if ( NULL != pArray )
            {
                // Get the number of elements and a pointer to the first byte
                *puNumElements = pArray->GetNumElements();

                // Check that we're requesting a valid element
                if ( *puNumElements > uElement )
                {

                    // Point to the memory - Get the actual Length, since the length in the
                    // handle will be wrong
                    LPMEMORY pbData = pArray->GetElement( uElement, WBEM_OBJACCESS_HANDLE_GETLENGTH(lHandle) );

                    // If it's a string or object, we need to further dereference
                    if ( WBEM_OBJACCESS_HANDLE_ISSTRING(lHandle) )
                    {
                        // Make sure we dereference from the proper heap
                        CCompressedString* pcs = NULL;

                        if ( m_refDataTable.IsDefault( nIndex ) )
                        {
                            pcs = GetClassPart()->ResolveHeapString( *((PHEAPPTRT) pbData ) );
                        }
                        else
                        {
                            pcs = m_refDataHeap.ResolveString( *((PHEAPPTRT) pbData ) );
                        }

                        // Load up the values now.
                        if ( NULL != pcs )
                        {
                            *puFlags = *( pcs->GetStart() );
                            *pAddress = pcs->GetRawData();
                        }
                        else
                        {
                            hr = WBEM_S_FALSE;
                        }

                    }
                    else if ( WBEM_OBJACCESS_HANDLE_ISOBJECT(lHandle) )
                    {
                        CEmbeddedObject* pEmbedding = NULL;

                        // Make sure we dereference from the proper heap
                        if ( m_refDataTable.IsDefault( nIndex ) )
                        {
                            GetClassPart()->GetDefaultPtrByHandle( lHandle, (void**) &pEmbedding );
                        }
                        else
                        {

                            pEmbedding =
                                (CEmbeddedObject*)m_refDataHeap.ResolveHeapPointer(
                                    *(PHEAPPTRT)(m_refDataTable.m_pData + (WBEM_OBJACCESS_HANDLE_GETOFFSET(lHandle))));
                        }

                        // Load up the values now.
                        if ( NULL != pEmbedding )
                        {
                            CWbemObject*    pObj = pEmbedding->GetEmbedded();

                            if ( NULL != pObj )
                            {
                                *pAddress = (LPVOID) pObj;
                            }
                            else
                            {
                                hr = WBEM_E_OUT_OF_MEMORY;
                            }
                        }
                        else
                        {
                            hr = WBEM_S_FALSE;
                        }

                    }
                    else
                    {
                        // We're pointing at the element
                        *pAddress = pbData;
                    }

                }    // IF requesting a valid element
                else
                {
                    hr = WBEM_E_NOT_FOUND;
                }
            }
            else
            {
                hr = WBEM_S_FALSE;
            }


        }    // IF we should get the property

        return hr;
    }
    catch(...)
    {
        return WBEM_E_CRITICAL_ERROR;
    }
}

// Gets a range of elements from inside an array.  BuffSize must reflect uNumElements of the size of
// element being set.  Strings must be linear WCHAR strings separated by NULLs.  Object properties
// must consist of an array of _IWmiObject pointers.  The range MUST fit within the bounds
// of the current array.
STDMETHODIMP CWbemObject::GetArrayPropRangeByHandle( long lHandle, long lFlags, ULONG uStartIndex,
                                ULONG uNumElements, ULONG uBuffSize, ULONG* pulBuffUsed,
                                ULONG* puNumReturned, LPVOID pData )
{
    try
    {
        // Check for invalid flags
        if ( ( lFlags & ~WMIARRAY_FLAG_ALLELEMENTS ) )
        {
            return WBEM_E_INVALID_PARAMETER;
        }

        // No intrinsic lock/unlock here.

        int nIndex = WBEM_OBJACCESS_HANDLE_GETINDEX(lHandle);

        // We can't do this if the main data table is NULL or we are defaulted and
        // the parent datatable is also NULL.
        if( m_refDataTable.IsNull(nIndex) ||
            ( m_refDataTable.IsNull(nIndex) && GetClassPart()->GetDataTable()->IsNull( nIndex ) ) )
        {
            return WBEM_E_INVALID_OPERATION;
        }

        // Make sure this is an array proprty
        CIMTYPE        ct = 0;
        length_t    nLength;
        HRESULT    hr = IsArrayPropertyHandle( lHandle, &ct, &nLength );

        if ( SUCCEEDED( hr ) )
        {
            // Get a direct heap pointer
            heapptr_t    ptrArray = GetHeapPtrByHandle( lHandle );

            // Point to the proper heap
            CFastHeap*    pHeap = ( m_refDataTable.IsDefault( nIndex ) ?
                                    GetClassPart()->GetHeap() : &m_refDataHeap );

            // A boy and his virtual functions.  This is what makes everything work in case
            // the BLOB gets ripped out from underneath us.  The CHeapPtr class has GetPointer
            // overloaded so we can always fix ourselves up to the underlying BLOB.

            CHeapPtr ArrayPtr(pHeap, ptrArray);

            // If we're told to get all elements, then we need to get them from the
            // starting index to the end
            if ( lFlags & WMIARRAY_FLAG_ALLELEMENTS )
            {
                CUntypedArray*    pArray = (CUntypedArray*) ArrayPtr.GetPointer();
                uNumElements = pArray->GetNumElements() - uStartIndex;
            }

            // How many will we get?
            *puNumReturned = uNumElements;

            hr = CUntypedArray::GetRange( &ArrayPtr, ct, nLength, pHeap, uStartIndex, uNumElements, uBuffSize,
                    pulBuffUsed, pData );

        }    // IF we decided we're really going to do this


        return hr;
    }
    catch(...)
    {
        return WBEM_E_CRITICAL_ERROR;
    }

}

// Sets the data at the specified array element.  BuffSize must be appropriate based on the
// actual element being set.  Object properties require a pointer to an _IWmiObject pointer.
// Strings must be WCHAR null-terminated
STDMETHODIMP CWbemObject::SetArrayPropElementByHandle( long lHandle, long lFlags, ULONG uElement,
                                                        ULONG uBuffSize, LPVOID pData )
{
    return SetArrayPropRangeByHandle( lHandle, lFlags, uElement, 1, uBuffSize, pData );
}

// Sets a range of elements inside an array.  BuffSize must reflect uNumElements of the size of
// element being set.  Strings must be linear WCHAR strings separated by NULLs.  Object properties
// must consist of an array of _IWmiObject pointers.  The function will shrink/grow the array
// as needed if WMIARRAY_FLAG_ALLELEMENTS is set - otherwise the array must fit in the current
// array
STDMETHODIMP CWbemObject::SetArrayPropRangeByHandle( long lHandle, long lFlags, ULONG uStartIndex,
                                                    ULONG uNumElements, ULONG uBuffSize, LPVOID pData )
{
    try
    {
        // Check flags
        if ( lFlags & ~WMIARRAY_FLAG_ALLELEMENTS )
        {
            return WBEM_E_INVALID_PARAMETER;
        }

        // No intrinsic lock/unlock here.

        int nIndex = WBEM_OBJACCESS_HANDLE_GETINDEX(lHandle);

        // This will dictate how we handle the array later
        BOOL    fNullOrDefault = m_refDataTable.IsNull(nIndex) || 
                                    m_refDataTable.IsDefault(nIndex);

        // Only handle NULL or default if we are setting all elements
        if( fNullOrDefault && ! (lFlags & WMIARRAY_FLAG_ALLELEMENTS) )
        {
            return WBEM_E_INVALID_OPERATION;
        }

        // Make sure this is an array proprty
        CIMTYPE        ct = 0;
        length_t    nLength;
        HRESULT    hr = IsArrayPropertyHandle( lHandle, &ct, &nLength );

        if ( SUCCEEDED( hr ) )
        {
            // We always set in only the main data table, and not the one from the
            // class part.

            CFastHeap*    pHeap = &m_refDataHeap;
            CDataTable*    pDataTable = &m_refDataTable;

            // If the array is reallocated, fixup will occur here through
            // the magic of virtual functions.
            CDataTablePtr    DataTablePtr( pDataTable, WBEM_OBJACCESS_HANDLE_GETOFFSET(lHandle) );

            // Make sure that if the value is NULL or default, we have an invalid heap ptr at the address
            // or we can cause potential problems by writing to the wrong location.
            if( fNullOrDefault )
            {
                DataTablePtr.AccessPtrData() = INVALID_HEAP_ADDRESS;
            }

            hr = CUntypedArray::SetRange( &DataTablePtr, lFlags, ct, nLength, pHeap, uStartIndex,
                                        uNumElements, uBuffSize, pData );

            if ( SUCCEEDED(hr) )
            {
                // We always set the array, so we're basically no longer NULL at this
                // point.  If the user sets a zero element range, we are a zero element array
                m_refDataTable.SetNullness( nIndex, FALSE );
                m_refDataTable.SetDefaultness( nIndex, FALSE );
            }

        }    // IF we decided we're really going to do this


        return hr;
    }
    catch(...)
    {
        return WBEM_E_CRITICAL_ERROR;
    }

}

// Removes a single elements from an array.
STDMETHODIMP CWbemObject::RemoveArrayPropElementByHandle( long lHandle, long lFlags, ULONG uElement )
{
    return RemoveArrayPropRangeByHandle( lHandle, lFlags, uElement, 1 );
}

// Removes a range of elements from an array.  The range MUST fit within the bounds
// of the current array
STDMETHODIMP CWbemObject::RemoveArrayPropRangeByHandle( long lHandle, long lFlags, ULONG uStartIndex,
                                                        ULONG uNumElements )
{
    try
    {
        // Check flags
        if ( lFlags & ~WMIARRAY_FLAG_ALLELEMENTS )
        {
            return WBEM_E_INVALID_PARAMETER;
        }

        // No intrinsic lock/unlock here.

        int nIndex = WBEM_OBJACCESS_HANDLE_GETINDEX(lHandle);

        // We can't write to an array that doesn't exist in the main datatable
        if(m_refDataTable.IsNull(nIndex) || m_refDataTable.IsDefault(nIndex))
        {
            return WBEM_E_INVALID_OPERATION;
        }

        // Make sure this is an array proprty
        CIMTYPE        ct = 0;
        length_t    nLength;
        HRESULT    hr = IsArrayPropertyHandle( lHandle, &ct, &nLength );

        if ( SUCCEEDED( hr ) )
        {
            // Get a direct heap pointer
            heapptr_t    ptrArray = GetHeapPtrByHandle( lHandle );

            // Point to the proper heap
            CFastHeap*    pHeap = &m_refDataHeap;

            // A boy and his virtual functions.  This is what makes everything work in case
            // the BLOB gets ripped out from underneath us.  The CHeapPtr class has GetPointer
            // overloaded so we can always fix ourselves up to the underlying BLOB.

            CHeapPtr ArrayPtr(pHeap, ptrArray);

            // If we're told to remove all elements, then we need to figure out how
            // many to perform this operation on.
            if ( lFlags & WMIARRAY_FLAG_ALLELEMENTS )
            {
                CUntypedArray*    pArray = (CUntypedArray*) ArrayPtr.GetPointer();
                uNumElements = pArray->GetNumElements() - uStartIndex;
            }


            hr = CUntypedArray::RemoveRange( &ArrayPtr, ct, nLength, pHeap, uStartIndex, uNumElements );

        }    // IF we decided we're really going to do this


        return hr;
    }
    catch(...)
    {
        return WBEM_E_CRITICAL_ERROR;
    }

}

// Appends a range of elements to an array.  BuffSize must reflect uNumElements of the size of
// element being set.  Strings must be linear WCHAR strings separated by NULLs.  Object properties
// must consist of an array of _IWmiObject pointers.  The range MUST fit within the bounds
// of the current array
STDMETHODIMP CWbemObject::AppendArrayPropRangeByHandle( long lHandle, long lFlags,    ULONG uNumElements,
                                                       ULONG uBuffSize, LPVOID pData )
{
    try
    {
        // Check flags
        if ( lFlags != 0L )
        {
            return WBEM_E_INVALID_PARAMETER;
        }

        // No intrinsic lock/unlock here.

        int nIndex = WBEM_OBJACCESS_HANDLE_GETINDEX(lHandle);

        // Make sure this is an array proprty
        CIMTYPE        ct = 0;
        length_t    nLength;
        HRESULT    hr = IsArrayPropertyHandle( lHandle, &ct, &nLength );

        if ( SUCCEEDED( hr ) )
        {
            // We always set in only the main data table, and not the one from the
            // class part.

            CFastHeap*    pHeap = &m_refDataHeap;
            CDataTable*    pDataTable = &m_refDataTable;

            // If the array is reallocated, fixup will occur here through
            // the magic of virtual functions.
            CDataTablePtr    DataTablePtr( pDataTable, WBEM_OBJACCESS_HANDLE_GETOFFSET(lHandle) );

            // Make sure that if the value is NULL or default, we have an invalid heap ptr at the address
            // or we can cause potential problems by writing to the wrong location.
            if( m_refDataTable.IsDefault( nIndex ) || m_refDataTable.IsNull( nIndex ) )
            {
                DataTablePtr.AccessPtrData() = INVALID_HEAP_ADDRESS;
            }

            hr = CUntypedArray::AppendRange( &DataTablePtr, ct, nLength, pHeap,
                                            uNumElements, uBuffSize, pData );

            if ( SUCCEEDED(hr) )
            {
                // We always set the array, so we're basically no longer NULL at this
                // point.  If the user appends 0 elements, this is now a 0 element
                // array/
                m_refDataTable.SetNullness( nIndex, FALSE );
                m_refDataTable.SetDefaultness( nIndex, FALSE );
            }

        }    // IF we decided we're really going to do this


        return hr;
    }
    catch(...)
    {
        return WBEM_E_CRITICAL_ERROR;
    }

}

// Removes a range of elements from an array.  The range MUST fit within the bounds
// of the current array
STDMETHODIMP CWbemObject::ReadProp( LPCWSTR pszPropName, long lFlags, ULONG uBuffSize, CIMTYPE *puCimType,
                                    long* plFlavor, BOOL* pfIsNull, ULONG* puBuffSizeUsed, LPVOID pUserBuff )
{
    try
    {
        if ( lFlags != 0L )
        {
            return WBEM_E_INVALID_PARAMETER;
        }

        // Protect the BLOB during this operation
        CLock   lock( this, WBEM_FLAG_ALLOW_READ );

        // If the value starts with an underscore see if it's a System Property
        // DisplayName, and if so, switch to a property name - otherwise, this
        // will just return the string we passed in
        
        //pszPropName = CSystemProperties::GetExtPropName( pszPropName );

        // Always get the CIMTYPE, since we'll need this to deal with the
        // fact that this may be an array property
        CIMTYPE    ct;
        HRESULT    hr = GetPropertyType( pszPropName, &ct, plFlavor );

        if ( SUCCEEDED( hr ) )
        {
            // Store the cimtype if it was requested
            if ( NULL != puCimType )
            {
                *puCimType = ct;
            }

            if ( SUCCEEDED( hr ) )
            {
                if ( CType::IsArray( ct ) )
                {
                    // We'll still return an array pointer for NULL array properties.

                    // We'll need this many bytes to do our dirty work.
                    *puBuffSizeUsed = sizeof( _IWmiArray*);

                    if ( uBuffSize >= sizeof( _IWmiArray*) && NULL != pUserBuff )
                    {
                        // Allocate an array object, initialize it and QI for the
                        // appropriate object
                        CWmiArray*    pArray = new CWmiArray;

                        if ( NULL != pArray )
                        {
                            hr = pArray->InitializePropertyArray( this, pszPropName );

                            if ( SUCCEEDED( hr ) )
                            {
                                // We want to QI into the memory pointed at by pUserBuff
                                hr = pArray->QueryInterface( IID__IWmiArray, (LPVOID*) pUserBuff );
                            }
                        }
                        else
                        {
                            hr = WBEM_E_OUT_OF_MEMORY;
                        }
                    }
                    else
                    {
                        hr = WBEM_E_BUFFER_TOO_SMALL;
                    }
                }
                else
                {
                    CIMTYPE    ctBasic = CType::GetBasic( ct );
                    CVar    var;

                    hr = GetProperty( pszPropName, &var );

                    if ( SUCCEEDED( hr ) )
                    {

                        *pfIsNull = var.IsNull();

                        if ( !*pfIsNull )
                        {
                            hr = CUntypedValue::LoadUserBuffFromCVar( ctBasic, &var, uBuffSize, puBuffSizeUsed,
                                    pUserBuff );
                        }

                    }    // IF GetProperty

                }    // IF a non-array property.

            }    // IF is NULL

        }    // IF we got basic info

        return hr;
    }
    catch(...)
    {
        return WBEM_E_CRITICAL_ERROR;
    }

}

// Assumes caller knows prop type; Supports all CIMTYPES.
// Strings MUST be null-terminated wchar_t arrays.
// Objects are passed in as pointers to _IWmiObject pointers
// Using a NULL buffer will set the property to NULL
// Array properties must conform to array guidelines.  Will
// completely blow away an old array.
STDMETHODIMP CWbemObject::WriteProp( LPCWSTR pszPropName, long lFlags, ULONG uBufSize, ULONG uNumElements,
                                    CIMTYPE uCimType, LPVOID pUserBuf )
{
    try
    {
        if ( lFlags != 0L )
        {
            return WBEM_E_INVALID_PARAMETER;
        }

        // Protect the BLOB during this operation
        CLock   lock( this, WBEM_FLAG_ALLOW_READ );

        CVar    var;
        
        HRESULT    hr = WBEM_S_NO_ERROR;

        // IF this is an array, we will dump it out, and then set the range using
        // the appropriate method.
        if ( CType::IsArray( uCimType ) )
        {
            // First, we'll set as a NULL property.  If it already exists, this will dump the
            // property.
            var.SetAsNull();

            // Now just set the property
            hr = SetPropValue( pszPropName, &var, uCimType );

            // If the User Buffer is NULL, then we just did our job
            if ( SUCCEEDED( hr ) && NULL != pUserBuf )
            {
                long    lHandle = 0L;

                // Get the handle, then set the array
                hr = GetPropertyHandleEx( pszPropName, lFlags, NULL, &lHandle );

                if ( SUCCEEDED( hr ) )
                {
                    hr = SetArrayPropRangeByHandle( lHandle, WMIARRAY_FLAG_ALLELEMENTS, 0L, uNumElements,
                                                    uBufSize, pUserBuf );
                }

            }    // IF NULLed out array

        }
        else
        {
            hr = CUntypedValue::FillCVarFromUserBuffer( uCimType, &var, uBufSize, pUserBuf );

            if ( SUCCEEDED( hr ) )
            {
                // Now just set the property
                hr = SetPropValue( pszPropName, &var, uCimType );
            }
        }

        return hr;
    }
    catch(...)
    {
        return WBEM_E_CRITICAL_ERROR;
    }

}

// Limited to numeric, simple null terminated string types and simple arrays
// Strings are copied in-place and null-terminated.
// Arrays come out as a pointer to IWmiArray
STDMETHODIMP CWbemObject::GetObjQual( LPCWSTR pszQualName, long lFlags, ULONG uBufSize, CIMTYPE *puCimType,
                                    ULONG *puQualFlavor, ULONG* puBuffSizeUsed,    LPVOID pDestBuf )
{
    try
    {
        CIMTYPE    ct = 0;

        // Protect the BLOB during this operation
        CLock   lock( this, WBEM_FLAG_ALLOW_READ );

        //    First, get the type, if it's an array, we need to gin up an _IWmiArray pointer.
        //    We don't want the Var this time, since that may get hung up in an array
        HRESULT hr = GetQualifier( pszQualName, NULL, (long*) puQualFlavor, &ct );

        if ( SUCCEEDED( hr ) )
        {
            // Save the CIMTYPE as appropriate
            if ( NULL != puCimType )
            {
                *puCimType = ct;
            }

            if ( CType::IsArray( ct ) )
            {
                // We'll need this many bytes to do our dirty work.
                *puBuffSizeUsed = sizeof( _IWmiArray*);

                if ( uBufSize >= sizeof( _IWmiArray*) && NULL != pDestBuf )
                {
                    // Allocate an array object, initialize it and QI for the
                    // appropriate object
                    CWmiArray*    pArray = new CWmiArray;

                    if ( NULL != pArray )
                    {
                        hr = pArray->InitializeQualifierArray( this, NULL, pszQualName, ct );

                        if ( SUCCEEDED( hr ) )
                        {
                            // We want to QI into the memory pointed at by pUserBuff
                            hr = pArray->QueryInterface( IID__IWmiArray, (LPVOID*) pDestBuf );
                        }
                        else
                        {
                            delete pArray;
                        }
                    }
                    else
                    {
                        hr = WBEM_E_OUT_OF_MEMORY;
                    }
                }
                else
                {
                    hr = WBEM_E_BUFFER_TOO_SMALL;
                }
            }
            else
            {
                // Now get the value
                CVar    var;

                hr = GetQualifier( pszQualName, &var, NULL );

                if ( SUCCEEDED( hr ) )
                {
                    hr = CUntypedValue::LoadUserBuffFromCVar( CType::GetBasic(ct), &var, uBufSize,
                            puBuffSizeUsed,    pDestBuf );
                }
            }
        }
        return hr;
    }
    catch(...)
    {
        return WBEM_E_CRITICAL_ERROR;
    }
}

// Limited to numeric, simple null terminated string types and simple arrays
// Strings MUST be WCHAR
// Arrays are set using _IWmiArray interface from Get
STDMETHODIMP CWbemObject::SetObjQual( LPCWSTR pszQualName, long lFlags, ULONG uBufSize, ULONG uNumElements,
                                        CIMTYPE uCimType, ULONG uQualFlavor, LPVOID pUserBuf )
{
    try
    {
        if ( lFlags != 0L )
        {
            return WBEM_E_INVALID_PARAMETER;
        }

        // Check that the CIMTYPE is proper (if so, then a conversion may occur (e.g. CIM_UINT32 becomes CIM_SINT32))
        VARTYPE    vt = CType::GetVARTYPE( uCimType );

        if ( !CBasicQualifierSet::IsValidQualifierType( vt ) )
        {
            return WBEM_E_TYPE_MISMATCH;
        }

        uCimType = (Type_t) CType::VARTYPEToType( vt );

        // Protect the BLOB during this operation
        CLock   lock( this, WBEM_FLAG_ALLOW_READ );

        CVar    var;
        HRESULT    hr = WBEM_S_NO_ERROR;

        // Special handling for arrays
        if ( CType::IsArray( uCimType ) )
        {
            // Reroute to the array code
            hr = SetQualifierArrayRange( NULL, pszQualName, FALSE, WMIARRAY_FLAG_ALLELEMENTS, uQualFlavor,
                uCimType, 0L, uNumElements, uBufSize, pUserBuf );
        }
        else
        {
            hr = CUntypedValue::FillCVarFromUserBuffer( uCimType, &var, uBufSize, pUserBuf );

            if ( SUCCEEDED( hr ) )
            {
                // Now just set the property
                hr = SetQualifier( pszQualName, &var, (long) uQualFlavor );
            }
        }

        return hr;
    }
    catch(...)
    {
        return WBEM_E_CRITICAL_ERROR;
    }
}

// Limited to numeric, simple null terminated string types and simple arrays
// Strings are copied in-place and null-terminated.
// Arrays come out as a pointer to IWmiArray
STDMETHODIMP CWbemObject::GetPropQual( LPCWSTR pszPropName, LPCWSTR pszQualName, long lFlags, ULONG uBufSize,
                                        CIMTYPE *puCimType, ULONG *puQualFlavor, ULONG* puBuffSizeUsed,
                                        LPVOID pDestBuf )
{
    try
    {
        CIMTYPE    ct = 0;

        // Protect the BLOB during this operation
        CLock   lock( this, WBEM_FLAG_ALLOW_READ );

        // Don't believe we need to deal with NULL types here.

        //    First, get the type, if it's an array, we need to gin up an _IWmiArray pointer.
        //    We don't want the Var this time, since that may get hung up in an array
        HRESULT hr = GetPropQualifier( pszPropName, pszQualName, NULL, (long*) puQualFlavor, &ct );

        if ( SUCCEEDED( hr ) )
        {
            // Get the cimtype from the array
            if ( NULL != puCimType )
            {
                *puCimType = ct;
            }

            if ( CType::IsArray( ct ) )
            {
                // We'll need this many bytes to do our dirty work.
                *puBuffSizeUsed = sizeof( _IWmiArray*);

                if ( uBufSize >= sizeof( _IWmiArray*) && NULL != pDestBuf )
                {
                    // Allocate an array object, initialize it and QI for the
                    // appropriate object
                    CWmiArray*    pArray = new CWmiArray;

                    if ( NULL != pArray )
                    {
                        hr = pArray->InitializeQualifierArray( this, pszPropName, pszQualName, ct );

                        if ( SUCCEEDED( hr ) )
                        {
                            // We want to QI into the memory pointed at by pUserBuff
                            hr = pArray->QueryInterface( IID__IWmiArray, (LPVOID*) pDestBuf );
                        }
                        else
                        {
                            delete pArray;
                        }
                    }
                    else
                    {
                        hr = WBEM_E_OUT_OF_MEMORY;
                    }
                }
                else
                {
                    hr = WBEM_E_BUFFER_TOO_SMALL;
                }
            }
            else
            {
                // Now get the value
                CVar    var;

                hr = GetPropQualifier( pszPropName, pszQualName, &var, NULL );

                if ( SUCCEEDED( hr ) )
                {
                    hr = CUntypedValue::LoadUserBuffFromCVar( CType::GetBasic(ct), &var, uBufSize,
                            puBuffSizeUsed,    pDestBuf );
                }
            }
        }
        return hr;
    }
    catch(...)
    {
        return WBEM_E_CRITICAL_ERROR;
    }
}

// Limited to numeric, simple null terminated string types and simple arrays
// Strings MUST be WCHAR
// Arrays are set using _IWmiArray interface from Get
STDMETHODIMP CWbemObject::SetPropQual( LPCWSTR pszPropName, LPCWSTR pszQualName, long lFlags, ULONG uBufSize,
                                        ULONG uNumElements, CIMTYPE uCimType, ULONG uQualFlavor,
                                        LPVOID pUserBuf )
{
    try
    {
        if ( lFlags != 0L )
        {
            return WBEM_E_INVALID_PARAMETER;
        }

        // Check that the CIMTYPE is proper (if so, then a conversion may occur (e.g. CIM_UINT32 becomes CIM_SINT32))
        VARTYPE    vt = CType::GetVARTYPE( uCimType );

        if ( !CBasicQualifierSet::IsValidQualifierType( vt ) )
        {
            return WBEM_E_TYPE_MISMATCH;
        }

        uCimType = (Type_t) CType::VARTYPEToType( vt );

        // Protect the BLOB during this operation
        CLock   lock( this, WBEM_FLAG_ALLOW_READ );

        CVar    var;
        HRESULT    hr = WBEM_S_NO_ERROR;

        // Special handling for arrays
        if ( CType::IsArray( uCimType ) )
        {
            // Reroute to the array code
            hr = SetQualifierArrayRange( pszPropName, pszQualName, FALSE, WMIARRAY_FLAG_ALLELEMENTS, uQualFlavor,
                uCimType, 0L, uNumElements, uBufSize, pUserBuf );
        }
        else
        {
            hr = CUntypedValue::FillCVarFromUserBuffer( uCimType, &var, uBufSize, pUserBuf );

            if ( SUCCEEDED( hr ) )
            {
                // Now just set the property qualifier
                hr = SetPropQualifier( pszPropName, pszQualName, (long) uQualFlavor, &var );
            }
        }
        return hr;
    }
    catch(...)
    {
        return WBEM_E_CRITICAL_ERROR;
    }
}

// Limited to numeric, simple null terminated string types and simple arrays
// Strings are copied in-place and null-terminated.
// Arrays come out as a pointer to IWmiArray
STDMETHODIMP CWbemObject::GetMethodQual( LPCWSTR pszMethodName, LPCWSTR pszQualName, long lFlags, ULONG uBufSize,
                                        CIMTYPE *puCimType, ULONG *puQualFlavor, ULONG* puBuffSizeUsed,
                                        LPVOID pDestBuf )
{
    try
    {
        CIMTYPE    ct = 0;

        // Protect the BLOB during this operation
        CLock   lock( this, WBEM_FLAG_ALLOW_READ );

        // Don't believe we need to deal with NULL types here.

        //    First, get the type, if it's an array, we need to gin up an _IWmiArray pointer.
        //    We don't want the Var this time, since that may get hung up in an array
        HRESULT hr = GetMethodQualifier( pszMethodName, pszQualName, NULL, (long*) puQualFlavor, &ct );

        if ( SUCCEEDED( hr ) )
        {
            // Save the CIMTYPE as appropriate
            if ( NULL != puCimType )
            {
                *puCimType = ct;
            }

            if ( CType::IsArray( ct ) )
            {
                // We'll need this many bytes to do our dirty work.
                *puBuffSizeUsed = sizeof( _IWmiArray*);

                if ( uBufSize >= sizeof( _IWmiArray*) && NULL != pDestBuf )
                {
                    // Allocate an array object, initialize it and QI for the
                    // appropriate object
                    CWmiArray*    pArray = new CWmiArray;

                    if ( NULL != pArray )
                    {
                        hr = pArray->InitializeQualifierArray( this, pszMethodName, pszQualName, ct );

                        if ( SUCCEEDED( hr ) )
                        {
                            // We want to QI into the memory pointed at by pUserBuff
                            hr = pArray->QueryInterface( IID__IWmiArray, (LPVOID*) pDestBuf );
                        }
                    }
                    else
                    {
                        hr = WBEM_E_OUT_OF_MEMORY;
                    }
                }
                else
                {
                    hr = WBEM_E_BUFFER_TOO_SMALL;
                }

            }
            else
            {
                // Now get the value
                CVar    var;

                hr = GetMethodQualifier( pszMethodName, pszQualName, &var, NULL );

                if ( SUCCEEDED( hr ) )
                {
                    hr = CUntypedValue::LoadUserBuffFromCVar( CType::GetBasic(ct), &var, uBufSize,
                            puBuffSizeUsed,    pDestBuf );
                }

            }    // IF Not an Array

        }    // IF got qualifier data


        return hr;
    }
    catch(...)
    {
        return WBEM_E_CRITICAL_ERROR;
    }
}

// Limited to numeric, simple null terminated string types and simple arrays
// Strings MUST be WCHAR
// Arrays are set using _IWmiArray interface from Get
STDMETHODIMP CWbemObject::SetMethodQual( LPCWSTR pszMethodName, LPCWSTR pszQualName, long lFlags, ULONG uBufSize,
                                        ULONG uNumElements, CIMTYPE uCimType, ULONG uQualFlavor,
                                        LPVOID pUserBuf )
{
    try
    {
        if ( lFlags != 0L )
        {
            return WBEM_E_INVALID_PARAMETER;
        }

        // Check that the CIMTYPE is proper (if so, then a conversion may occur (e.g. CIM_UINT32 becomes CIM_SINT32))
        VARTYPE    vt = CType::GetVARTYPE( uCimType );

        if ( !CBasicQualifierSet::IsValidQualifierType( vt ) )
        {
            return WBEM_E_TYPE_MISMATCH;
        }

        uCimType = (Type_t) CType::VARTYPEToType( vt );

        // Protect the BLOB during this operation
        CLock   lock( this, WBEM_FLAG_ALLOW_READ );

        CVar    var;
        HRESULT    hr = WBEM_S_NO_ERROR;

        // Special handling for arrays
        if ( CType::IsArray( uCimType ) )
        {
            // Reroute to the array code
            hr = SetQualifierArrayRange( pszMethodName, pszQualName, TRUE, WMIARRAY_FLAG_ALLELEMENTS, uQualFlavor,
                uCimType, 0L, uNumElements, uBufSize, pUserBuf );
        }
        else
        {
            hr = CUntypedValue::FillCVarFromUserBuffer( uCimType, &var, uBufSize, pUserBuf );

            if ( SUCCEEDED( hr ) )
            {
                // Now just set the property qualifier
                hr = SetMethodQualifier( pszMethodName, pszQualName, (long) uQualFlavor, &var );
            }
        }

        return hr;
    }
    catch(...)
    {
        return WBEM_E_CRITICAL_ERROR;
    }

}

// Returns flags indicating singleton, dynamic, association, etc.
STDMETHODIMP CWbemObject::QueryObjectFlags( long lFlags, unsigned __int64 qObjectInfoMask,
                                          unsigned __int64* pqObjectInfo)
{
    if ( 0L != lFlags || 0 == pqObjectInfo )
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    // Lock the BLOB
    CLock    lock( this );

    // Clear the destination data
    *pqObjectInfo = 0;

    CClassPart*    pClassPart = GetClassPart();

    if ( qObjectInfoMask & WMIOBJECT_GETOBJECT_LOFLAG_ASSOCIATION )
    {
        if ( pClassPart->IsAssociation() )
        {
            *pqObjectInfo |= WMIOBJECT_GETOBJECT_LOFLAG_ASSOCIATION;
        }
    }

    if ( qObjectInfoMask & WMIOBJECT_GETOBJECT_LOFLAG_DYNAMIC )
    {
        if ( pClassPart->IsDynamic() )
        {
            *pqObjectInfo |= WMIOBJECT_GETOBJECT_LOFLAG_DYNAMIC;
        }
    }

    if ( qObjectInfoMask & WMIOBJECT_GETOBJECT_LOFLAG_SINGLETON )
    {
        if ( pClassPart->IsSingleton() )
        {
            *pqObjectInfo |= WMIOBJECT_GETOBJECT_LOFLAG_SINGLETON;
        }
    }

    if ( qObjectInfoMask & WMIOBJECT_GETOBJECT_LOFLAG_AMENDMENT )
    {
        if ( pClassPart->IsAmendment() )
        {
            *pqObjectInfo |= WMIOBJECT_GETOBJECT_LOFLAG_AMENDMENT;
        }
    }

    if ( qObjectInfoMask & WMIOBJECT_GETOBJECT_LOFLAG_LOCALIZED )
    {
        if ( IsLocalized() )
        {
            *pqObjectInfo |= WMIOBJECT_GETOBJECT_LOFLAG_LOCALIZED;
        }
    }

    if ( qObjectInfoMask & WMIOBJECT_GETOBJECT_LOFLAG_KEYED )
    {
        if ( IsKeyed() )
        {
            *pqObjectInfo |= WMIOBJECT_GETOBJECT_LOFLAG_KEYED;
        }
    }

    if ( qObjectInfoMask & WMIOBJECT_GETOBJECT_LOFLAG_ABSTRACT )
    {
        if ( pClassPart->IsAbstract() )
        {
            *pqObjectInfo |= WMIOBJECT_GETOBJECT_LOFLAG_ASSOCIATION;
        }
    }

    if ( qObjectInfoMask & WMIOBJECT_GETOBJECT_LOFLAG_HIPERF )
    {
        if ( pClassPart->IsHiPerf() )
        {
            *pqObjectInfo |= WMIOBJECT_GETOBJECT_LOFLAG_ASSOCIATION;
        }
    }

    if ( qObjectInfoMask & WMIOBJECT_GETOBJECT_LOFLAG_AUTOCOOK )
    {
        if ( pClassPart->IsAutocook() )
        {
            *pqObjectInfo |= WMIOBJECT_GETOBJECT_LOFLAG_ASSOCIATION;
        }
    }

    if ( qObjectInfoMask & WMIOBJECT_GETOBJECT_LOFLAG_DECORATED )
    {
        if ( m_DecorationPart.IsDecorated() )
        {
            *pqObjectInfo |= WMIOBJECT_GETOBJECT_LOFLAG_DECORATED;
        }
    }

    if ( qObjectInfoMask & WMIOBJECT_GETOBJECT_LOFLAG_LIMITED )
    {
        if ( IsLimited() )
        {
            *pqObjectInfo |= WMIOBJECT_GETOBJECT_LOFLAG_LIMITED;
        }
    }

    if ( qObjectInfoMask & WMIOBJECT_GETOBJECT_LOFLAG_CLIENTONLY )
    {
        if ( IsClientOnly() )
        {
            *pqObjectInfo |= WMIOBJECT_GETOBJECT_LOFLAG_CLIENTONLY;
        }
    }

    return WBEM_S_NO_ERROR;
}

// Helper for accessing Boolean qualifiers
BOOL CWbemObject::CheckBooleanPropQual( LPCWSTR pwszPropName, LPCWSTR pwszQualName )
{
    BOOL    fReturn = FALSE;
    CVar    var;

    HRESULT    hr = GetPropQualifier( pwszPropName, pwszQualName, &var, NULL );

    if ( SUCCEEDED( hr ) )
    {
        fReturn = ( var.GetType() == VT_BOOL    &&
                    var.GetBool() );
    }

    return fReturn;
}

// Returns flags indicating key, index, etc.
STDMETHODIMP CWbemObject::QueryPropertyFlags( long lFlags, LPCWSTR pszPropertyName,
                                unsigned __int64 qPropertyInfoMask, unsigned __int64 *pqPropertyInfo )
{
    try
    {
        if ( 0L != lFlags || 0 == pqPropertyInfo )
        {
            return WBEM_E_INVALID_PARAMETER;
        }

        // Lock the BLOB
        CLock    lock( this );

        *pqPropertyInfo = 0;

        if ( qPropertyInfoMask & WMIOBJECT_GETPROPERTY_LOFLAG_KEY )
        {
            if ( CheckBooleanPropQual( pszPropertyName, L"key" ) )
            {
                *pqPropertyInfo |= WMIOBJECT_GETPROPERTY_LOFLAG_KEY;
            }
        }

        if ( qPropertyInfoMask & WMIOBJECT_GETPROPERTY_LOFLAG_INDEX )
        {
            if ( CheckBooleanPropQual( pszPropertyName, L"index" ) )
            {
                *pqPropertyInfo |= WMIOBJECT_GETPROPERTY_LOFLAG_INDEX;
            }
        }

        if ( qPropertyInfoMask & WMIOBJECT_GETPROPERTY_LOFLAG_DYNAMIC )
        {
            if ( CheckBooleanPropQual( pszPropertyName, L"dynamic" ) )
            {
                *pqPropertyInfo |= WMIOBJECT_GETPROPERTY_LOFLAG_DYNAMIC;
            }
        }

        return WBEM_S_NO_ERROR;
    }
    catch(...)
    {
        return WBEM_E_CRITICAL_ERROR;
    }
}

HRESULT CWbemObject::FindMethod( LPCWSTR wszMethod )
{
    return WBEM_E_INVALID_OPERATION;
}

// Sets an array value in a qualifier, but allows for doing so - in place.
HRESULT CWbemObject::SetQualifierArrayRange( LPCWSTR pwszPrimaryName, LPCWSTR pwszQualName, BOOL fIsMethod, long lFlags,
                                    ULONG uFlavor, CIMTYPE ct, ULONG uStartIndex, ULONG uNumElements, ULONG uBuffSize,
                                    LPVOID pData )
{
    try
    {
        HRESULT    hr = WBEM_S_NO_ERROR;

        CLock    lock( this );

        CTypedValue    value;
        CFastHeap*    pHeap = NULL;
        long        lCurrentFlavor;
        heapptr_t    ptrTemp = INVALID_HEAP_ADDRESS;
        BOOL        fPrimaryError = FALSE;

        if ( NULL != pwszPrimaryName )
        {
            if ( fIsMethod )
            {
                // Check the method first:
                hr = FindMethod( pwszPrimaryName );

                if ( SUCCEEDED( hr ) )
                {
                    // This is a method qualifier
                    hr = GetMethodQualifier( pwszPrimaryName, pwszQualName, &lCurrentFlavor, &value, &pHeap, TRUE );
                }
                else
                {
                    fPrimaryError = TRUE;
                }
            }
            else
            {
                // Check the property first:
                hr = GetPropertyType( pwszPrimaryName, NULL, NULL );

                if ( SUCCEEDED( hr ) )
                {
                    // This is a property qualifier
                    hr = GetPropQualifier( pwszPrimaryName, pwszQualName, &lCurrentFlavor, &value, &pHeap, TRUE );
                }
                else
                {
                    fPrimaryError = TRUE;
                }
            }
        }
        else
        {
            // Object level qualifier
            hr = GetQualifier( pwszQualName, &lCurrentFlavor, &value, &pHeap, TRUE );

        }

        // We only let not found qualifiers through
        if ( !fPrimaryError )
        {
            // IF this failed, because the qualifier does not exist, then we will
            // assume we will be able to add it, and will set the Value to be like an
            // empty value
            if ( FAILED( hr ) && WBEM_E_NOT_FOUND == hr )
            {
                // If it does not exist, then we only let this through if we are setting
                // all elements

                if ( lFlags & WMIARRAY_FLAG_ALLELEMENTS && 0 == uStartIndex  )
                {
                    CTypedValue    temp( ct, (LPMEMORY) &ptrTemp );
                    temp.CopyTo( &value );

                    hr = WBEM_S_NO_ERROR;
                }
                else
                {
                    hr = WBEM_E_ILLEGAL_OPERATION;
                }
            }
            else
            {
                // If the qualifier is not local, then we should again NULL out the
                // value, since we will be setting the qualifier locally

                if ( !CQualifierFlavor::IsLocal( (BYTE) lCurrentFlavor ) )
                {
                    CTypedValue    temp( ct, (LPMEMORY) &ptrTemp );
                    temp.CopyTo( &value );
                }
            }

        }

        if ( SUCCEEDED( hr ) )
        {
            // Fake up an address for the value to change.  The heap will always be the
            // current refDataHeap.  Then we can go ahead and let they Untyped array function
            // take care of setting the range.  Once that is done, we will do a final set on
            // the qualifier value.

            CStaticPtr ValuePtr( value.GetRawData() );

            CIMTYPE    ctBasic = CType::GetBasic(ct);

            hr = CUntypedArray::SetRange( &ValuePtr, lFlags, ctBasic, CType::GetLength( ctBasic ), &m_refDataHeap, uStartIndex, uNumElements, uBuffSize, pData );

            if ( SUCCEEDED( hr ) )
            {
                if ( ARRAYFLAVOR_USEEXISTING == uFlavor )
                {
                    // Use the existing flavor
                    uFlavor = lCurrentFlavor;
                }

                if ( NULL != pwszPrimaryName )
                {
                    if ( fIsMethod )
                    {
                        // This is a method qualifier
                        hr = SetMethodQualifier( pwszPrimaryName, pwszQualName, uFlavor, &value );
                    }
                    else
                    {
                        // This is a property qualifier
                        hr = SetPropQualifier( pwszPrimaryName, pwszQualName, uFlavor, &value );
                    }
                }
                else
                {
                    // Object level qualifier
                    hr = SetQualifier( pwszQualName, uFlavor, &value );
                }
            }
        }    // If okay to try and set a qualifier
        return hr;
    }
    catch(...)
    {
        return WBEM_E_CRITICAL_ERROR;
    }
}

// Sets an array value in a qualifier, but allows for doing so - in place.
HRESULT CWbemObject::AppendQualifierArrayRange( LPCWSTR pwszPrimaryName, LPCWSTR pwszQualName, BOOL fIsMethod,
                                long lFlags, CIMTYPE ct, ULONG uNumElements, ULONG uBuffSize, LPVOID pData )
{
    try
    {
        HRESULT    hr = WBEM_S_NO_ERROR;

        CLock    lock( this );


        CTypedValue    value;
        CFastHeap*    pHeap = NULL;
        long        lCurrentFlavor;
        heapptr_t    ptrTemp = INVALID_HEAP_ADDRESS;
        BOOL        fPrimaryError = FALSE;

        if ( NULL != pwszPrimaryName )
        {
            if ( fIsMethod )
            {
                // Check the method first:
                hr = FindMethod( pwszPrimaryName );

                if ( SUCCEEDED( hr ) )
                {
                    // This is a method qualifier
                    hr = GetMethodQualifier( pwszPrimaryName, pwszQualName, &lCurrentFlavor, &value, &pHeap, TRUE );
                }
                else
                {
                    fPrimaryError = TRUE;
                }
            }
            else
            {
                // Check the property first:
                hr = GetPropertyType( pwszPrimaryName, NULL, NULL );

                if ( SUCCEEDED( hr ) )
                {
                    // This is a property qualifier
                    hr = GetPropQualifier( pwszPrimaryName, pwszQualName, &lCurrentFlavor, &value, &pHeap, TRUE );
                }
                else
                {
                    fPrimaryError = TRUE;
                }
            }
        }
        else
        {
            // Object level qualifier
            hr = GetQualifier( pwszQualName, &lCurrentFlavor, &value, &pHeap, TRUE );

        }

        // We only let not found qualifiers through
        if ( !fPrimaryError )
        {
            // IF this failed, because the qualifier does not exist, then we will
            // assume we will be able to add it, and will set the Value to be like an
            // empty value
            if ( FAILED( hr ) && WBEM_E_NOT_FOUND == hr )
            {
                CTypedValue    temp( ct, (LPMEMORY) &ptrTemp );
                temp.CopyTo( &value );

                hr = WBEM_S_NO_ERROR;
            }
            else if ( SUCCEEDED( hr ) )
            {
                // If the qualifier is not local, then this is an invalid operation

                if ( !CQualifierFlavor::IsLocal( (BYTE) lCurrentFlavor ) )
                {
                    hr = WBEM_E_PROPAGATED_QUALIFIER;
                }
            }
        }

        if ( SUCCEEDED( hr ) )
        {
            // Fake up an address for the value to change.  The heap will always be the
            // current refDataHeap.  Then we can go ahead and let they Untyped array function
            // take care of setting the range.  Once that is done, we will do a final set on
            // the qualifier value.

            CStaticPtr ValuePtr( value.GetRawData() );

            CIMTYPE    ctBasic = CType::GetBasic(ct);

            hr = CUntypedArray::AppendRange( &ValuePtr, ctBasic, CType::GetLength( ctBasic ), &m_refDataHeap,
                                            uNumElements, uBuffSize, pData );

            if ( SUCCEEDED( hr ) )
            {
                if ( NULL != pwszPrimaryName )
                {
                    if ( fIsMethod )
                    {
                        // This is a method qualifier
                        hr = SetMethodQualifier( pwszPrimaryName, pwszQualName, lCurrentFlavor, &value );
                    }
                    else
                    {
                        // This is a property qualifier
                        hr = SetPropQualifier( pwszPrimaryName, pwszQualName, lCurrentFlavor, &value );
                    }
                }
                else
                {
                    // Object level qualifier
                    hr = SetQualifier( pwszQualName, lCurrentFlavor, &value );
                }

            }
        }

        return hr;
    }
    catch(...)
    {
        return WBEM_E_CRITICAL_ERROR;
    }
}

// Appends to an existing array value in a qualifier, but allows for doing so - in place.
HRESULT CWbemObject::RemoveQualifierArrayRange( LPCWSTR pwszPrimaryName, LPCWSTR pwszQualName, BOOL fIsMethod,
                                long lFlags, ULONG uStartIndex, ULONG uNumElements )
{
    try
    {
        HRESULT    hr = WBEM_S_NO_ERROR;

        CLock    lock( this );

        CTypedValue    value;
        CFastHeap*    pHeap = NULL;
        long        lCurrentFlavor;
        heapptr_t    ptrTemp = INVALID_HEAP_ADDRESS;
        BOOL        fPrimaryError = FALSE;

        if ( NULL != pwszPrimaryName )
        {
            if ( fIsMethod )
            {
                // Check the method first:
                hr = FindMethod( pwszPrimaryName );

                if ( SUCCEEDED( hr ) )
                {
                    // This is a method qualifier
                    hr = GetMethodQualifier( pwszPrimaryName, pwszQualName, &lCurrentFlavor, &value, &pHeap, TRUE );
                }
                else
                {
                    fPrimaryError = TRUE;
                }
            }
            else
            {
                // Check the property first:
                hr = GetPropertyType( pwszPrimaryName, NULL, NULL );

                if ( SUCCEEDED( hr ) )
                {
                    // This is a property qualifier
                    hr = GetPropQualifier( pwszPrimaryName, pwszQualName, &lCurrentFlavor, &value, &pHeap, TRUE );
                }
                else
                {
                    fPrimaryError = TRUE;
                }
            }
        }
        else
        {
            // Object level qualifier
            hr = GetQualifier( pwszQualName, &lCurrentFlavor, &value, &pHeap, TRUE );
        }

        // We won't allow modification of the array if the qualifier is not local
        if ( !fPrimaryError )
        {
            if ( SUCCEEDED( hr ) && !CQualifierFlavor::IsLocal( (BYTE) lCurrentFlavor ) )
            {
                hr = WBEM_E_PROPAGATED_QUALIFIER;
            }
        }

        if ( SUCCEEDED( hr ) )
        {
            // Fake up an address for the value to change.  The heap will always be the
            // current refDataHeap.  Then we can go ahead and let they Untyped array function
            // take care of setting the range.  Once that is done, we will do a final set on
            // the qualifier value.

            CHeapPtr HeapPtr( &m_refDataHeap, value.AccessPtrData() );

            // If we're told to remove all elements, then we need to figure out how
            // many to perform this operation on.
            if ( lFlags & WMIARRAY_FLAG_ALLELEMENTS )
            {
                CUntypedArray*    pArray = (CUntypedArray*) HeapPtr.GetPointer();
                uNumElements = pArray->GetNumElements() - uStartIndex;
            }

            CIMTYPE    ctBasic = CType::GetBasic( value.GetType() );

            // This is all done in-place, so the array wopn't move
            hr = CUntypedArray::RemoveRange( &HeapPtr, ctBasic, CType::GetLength(ctBasic), &m_refDataHeap,
                                            uStartIndex, uNumElements );

        }

        return hr;
    }
    catch(...)
    {
        return WBEM_E_CRITICAL_ERROR;
    }
}

// Gets array info for a qualifier
HRESULT CWbemObject::GetQualifierArrayInfo( LPCWSTR pwszPrimaryName, LPCWSTR pwszQualName, BOOL fIsMethod,
                                long lFlags, CIMTYPE* pct, ULONG* puNumElements )
{
    try
    {
        HRESULT    hr = WBEM_S_NO_ERROR;

        CTypedValue    value;
        CFastHeap*    pHeap = NULL;
        long        lCurrentFlavor;
        heapptr_t    ptrTemp = INVALID_HEAP_ADDRESS;

        if ( NULL != pwszPrimaryName )
        {
            if ( fIsMethod )
            {
                // This is a method qualifier
                hr = GetMethodQualifier( pwszPrimaryName, pwszQualName, &lCurrentFlavor, &value, &pHeap, FALSE );
            }
            else
            {
                // This is a property qualifier
                hr = GetPropQualifier( pwszPrimaryName, pwszQualName, &lCurrentFlavor, &value, &pHeap, FALSE );
            }

        }
        else
        {
            // Object level qualifier
            hr = GetQualifier( pwszQualName, &lCurrentFlavor, &value, &pHeap, FALSE );
        }

        if ( SUCCEEDED( hr ) )
        {
            CUntypedArray*    pArray = (CUntypedArray*) pHeap->ResolveHeapPointer( value.AccessPtrData() );

            if ( NULL != pct )
            {
                *pct = value.GetType();

                if ( NULL != puNumElements )
                {
                    *puNumElements = pArray->GetNumElements();
                }

            }

        }    // IF got qualifier array

        return hr;
    }
    catch(...)
    {
        return WBEM_E_CRITICAL_ERROR;
    }

}

// Gets array data for a qualifier
HRESULT CWbemObject::GetQualifierArrayRange( LPCWSTR pwszPrimaryName, LPCWSTR pwszQualName, BOOL fIsMethod,
                                    long lFlags, ULONG uStartIndex,    ULONG uNumElements, ULONG uBuffSize,
                                    ULONG* puNumReturned, ULONG* pulBuffUsed, LPVOID pData )
{
    try
    {
        HRESULT    hr = WBEM_S_NO_ERROR;

        CTypedValue    value;
        CFastHeap*    pHeap = NULL;
        long        lCurrentFlavor;
        heapptr_t    ptrTemp = INVALID_HEAP_ADDRESS;

        if ( NULL != pwszPrimaryName )
        {
            if ( fIsMethod )
            {
                // This is a method qualifier
                hr = GetMethodQualifier( pwszPrimaryName, pwszQualName, &lCurrentFlavor, &value, &pHeap, FALSE );
            }
            else
            {
                // This is a property qualifier
                hr = GetPropQualifier( pwszPrimaryName, pwszQualName, &lCurrentFlavor, &value, &pHeap, FALSE );
            }

        }
        else
        {
            // Object level qualifier
            hr = GetQualifier( pwszQualName, &lCurrentFlavor, &value, &pHeap, FALSE );
        }

        if ( SUCCEEDED( hr ) )
        {
            // A boy and his virtual functions.  This is what makes everything work in case
            // the BLOB gets ripped out from underneath us.  The CHeapPtr class has GetPointer
            // overloaded so we can always fix ourselves up to the underlying BLOB.

            CHeapPtr ArrayPtr(pHeap, value.AccessPtrData());

            // If we're told to get all elements, then we need to get them from the
            // starting index to the end
            if ( lFlags & WMIARRAY_FLAG_ALLELEMENTS )
            {
                CUntypedArray*    pArray = (CUntypedArray*) ArrayPtr.GetPointer();
                uNumElements = pArray->GetNumElements() - uStartIndex;
            }

            // How many will we get?
            *puNumReturned = uNumElements;

            CIMTYPE    ctBasic = CType::GetBasic( value.GetType() );

            hr = CUntypedArray::GetRange( &ArrayPtr, ctBasic, CType::GetLength( ctBasic ), pHeap,
                    uStartIndex, uNumElements, uBuffSize, pulBuffUsed, pData );

        }    // IF got qualifier array

        return hr;
    }
    catch(...)
    {
        return WBEM_E_CRITICAL_ERROR;
    }

}

// Sets flags, including internal ones normally inaccessible.
STDMETHODIMP CWbemObject::SetObjectFlags( long lFlags,
                            unsigned __int64 qObjectInfoOnFlags,
                            unsigned __int64 qObjectInfoOffFlags )
{
    try
    {
        if ( 0L != lFlags )
        {
            return WBEM_E_INVALID_PARAMETER;
        }

        if ( qObjectInfoOnFlags & WMIOBJECT_SETOBJECT_LOFLAG_LIMITED )
        {
            m_DecorationPart.SetLimited();
        }

        if ( qObjectInfoOnFlags & WMIOBJECT_SETOBJECT_LOFLAG_CLIENTONLY )
        {
            m_DecorationPart.SetClientOnly();
        }

        if ( qObjectInfoOnFlags & WMIOBJECT_SETOBJECT_LOFLAG_LOCALIZED )
        {
            SetLocalized( TRUE );
        }

        return WBEM_S_NO_ERROR;
    }
    catch(...)
    {
        return WBEM_E_CRITICAL_ERROR;
    }
}

    // Merges in amended qualifiers from the amended class object into the
    // current object.  If lFlags is WMIOBJECT_MERGEAMENDED_FLAG_PARENTLOCALIZED,
    // this means that the parent object was localized, but not the current,
    // so we need to prevent certain qualifiers from "moving over."
STDMETHODIMP CWbemObject::MergeAmended( long lFlags, _IWmiObject* pAmendedClass )
{
    try
    {
        _DBG_ASSERT(pAmendedClass);
        
        // Only take in supported flags
        if ( lFlags &~WMIOBJECT_MERGEAMENDED_FLAG_PARENTLOCALIZED )
        {
            return WBEM_E_INVALID_PARAMETER;
        }

        CLock    lock( this );

        // This needs to be fixed up to NOT use the qualifier set APIs to speed things up
        IWbemQualifierSet*    pLocalizedQs = NULL;
        IWbemQualifierSet*    pThisQs = NULL;
        bool    bChg = false;
        bool    fParentLocalized = lFlags & WMIOBJECT_MERGEAMENDED_FLAG_PARENTLOCALIZED;
        BOOL    fInstance = IsInstance();

        // At this point, we have the localized copy, and are
        // ready to combine qualifiers.  Start with class qualifiers.
        // ============================================================

        if (FAILED(pAmendedClass->GetQualifierSet(&pLocalizedQs)))
        {
            return WBEM_S_NO_ERROR;
        }
        CReleaseMe    rmlqs( pLocalizedQs );

        if (FAILED(GetQualifierSet(&pThisQs)))
        {
            return WBEM_S_NO_ERROR;
        }
        CReleaseMe    rmtqs( pThisQs );

        HRESULT    hr = LocalizeQualifiers(fInstance, fParentLocalized, pThisQs, pLocalizedQs, bChg);

        pLocalizedQs->EndEnumeration();
        if (FAILED(hr))
        {
            return hr;
        }

        hr = LocalizeProperties(fInstance, fParentLocalized, this, pAmendedClass, bChg);

        // Methods.
        // Putting a method cancels enumeration, so we have to enumerate first.

        IWbemClassObject *pLIn = NULL, *pLOut = NULL;
        IWbemClassObject *pOIn = NULL, *pOOut = NULL;
        int iPos = 0;

        hr = pAmendedClass->BeginMethodEnumeration(0);

        if ( SUCCEEDED( hr ) )
        {
            BSTR    bstrMethodName = NULL;

            while( pAmendedClass->NextMethod( 0, &bstrMethodName, 0, 0 ) == S_OK )
            {
                // Auto cleanup
                CSysFreeMe    sfm( bstrMethodName );

                pLIn = NULL;
                pOIn = NULL;
                pLOut = NULL;
                pOOut = NULL;
                pAmendedClass->GetMethod(bstrMethodName, 0, &pLIn, &pLOut);

                hr = GetMethod(bstrMethodName, 0, &pOIn, &pOOut);

                CReleaseMe rm0(pLIn);
                CReleaseMe rm1(pOIn);
                CReleaseMe rm2(pLOut);
                CReleaseMe rm3(pOOut);

                // METHOD IN PARAMETERS
                if (pLIn)
                    if (pOIn)
                        hr = LocalizeProperties(fInstance, fParentLocalized, pOIn, pLIn, bChg);

                if (pLOut)
                    if (pOOut)
                        hr = LocalizeProperties(fInstance, fParentLocalized, pOOut, pLOut, bChg);

                // METHOD QUALIFIERS

                hr = GetMethodQualifierSet(bstrMethodName, &pThisQs);
                if (FAILED(hr))
                {
                    continue;
                }
                CReleaseMe    rmThisQs( pThisQs );

                hr = pAmendedClass->GetMethodQualifierSet(bstrMethodName, &pLocalizedQs);
                if (FAILED(hr))
                {
                    continue;
                }
                CReleaseMe    rmLocalizedQs( pLocalizedQs );

                hr = LocalizeQualifiers(fInstance, fParentLocalized, pThisQs, pLocalizedQs, bChg);

                PutMethod(bstrMethodName, 0, pOIn, pOOut);

            }    // WHILE Enum Methods
            

            pAmendedClass->EndMethodEnumeration();

        }    // IF BeginMethodEnumeration
        else
        {
            // Mask this error
            hr = WBEM_S_NO_ERROR;
        }

        // If we changed, we should be localized
        if (bChg)
            SetLocalized(true);

        return hr;
    }
    catch(...)
    {
        return WBEM_E_CRITICAL_ERROR;
    }
}

// Helper function to localize qualifiers
HRESULT CWbemObject::LocalizeQualifiers(BOOL bInstance, bool bParentLocalized,
                                        IWbemQualifierSet *pBase, IWbemQualifierSet *pLocalized,
                                        bool &bChg)
{
    try
    {
        HRESULT hr = WBEM_S_NO_ERROR;

        pLocalized->BeginEnumeration(0);

        BSTR strName = NULL;
        VARIANT vVal;
        VariantInit(&vVal);

        long lFlavor;
        while(pLocalized->Next(0, &strName, &vVal, &lFlavor) == S_OK)
        {
            // Ignore if this is an instance.

            if (bInstance && !(lFlavor & WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE))
            {
                VariantClear(&vVal);
                SysFreeString(strName);
                continue;
            }

            if (!wbem_wcsicmp(strName, L"amendment") ||
                !wbem_wcsicmp(strName, L"key") ||
                !wbem_wcsicmp(strName, L"singleton") ||
                !wbem_wcsicmp(strName, L"dynamic") ||
                !wbem_wcsicmp(strName, L"indexed") ||
                !wbem_wcsicmp(strName, L"cimtype") ||
                !wbem_wcsicmp(strName, L"static") ||
                !wbem_wcsicmp(strName, L"implemented") ||
                !wbem_wcsicmp(strName, L"abstract"))
            {
                VariantClear(&vVal);
                SysFreeString(strName);
                continue;
            }

            // If this is not a propagated qualifier,
            // ignore it.  (Bug #45799)
            // =====================================

            if (bParentLocalized &&
                !(lFlavor & WBEM_FLAVOR_FLAG_PROPAGATE_TO_DERIVED_CLASS))
            {
                VariantClear(&vVal);
                SysFreeString(strName);
                continue;
            }

            // Now, we need to test for this in the other
            // class.
            // The only localized qualifiers that do not override the
            // default are where only parent qualifiers exist, but the
            // child has overriden its own parent.
            // =======================================================

            VARIANT vBasicVal;
            VariantInit(&vBasicVal);
            long lBasicFlavor;

            if (pBase->Get(strName, 0, &vBasicVal, &lBasicFlavor) != WBEM_E_NOT_FOUND)
            {
                if (bParentLocalized &&                             // If there is no localized copy of this class
                    (lBasicFlavor & WBEM_FLAVOR_OVERRIDABLE) &&     // .. and this is an overridable qualifier
                     (lBasicFlavor & WBEM_FLAVOR_FLAG_PROPAGATE_TO_DERIVED_CLASS) && // and this is propogated
                     (lBasicFlavor & WBEM_FLAVOR_ORIGIN_LOCAL))     // .. and this was actualy overridden
                {
                    VariantClear(&vVal);                            // .. DON'T DO IT.
                    VariantClear(&vBasicVal);
                    SysFreeString(strName);
                    continue;
                }

                if (bParentLocalized &&
                    !(lBasicFlavor & WBEM_FLAVOR_FLAG_PROPAGATE_TO_DERIVED_CLASS))
                {
                    VariantClear(&vVal);
                    VariantClear(&vBasicVal);
                    SysFreeString(strName);
                    continue;
                }
            }

            pBase->Put(strName, &vVal, (lFlavor&~WBEM_FLAVOR_ORIGIN_PROPAGATED) | WBEM_FLAVOR_AMENDED);
            bChg = true;

            VariantClear(&vVal);
            VariantClear(&vBasicVal);
            SysFreeString(strName);

        }
        return hr;
    }
    catch(...)
    {
        return WBEM_E_CRITICAL_ERROR;
    }
}

// Helper function to localize properties
HRESULT CWbemObject::LocalizeProperties(BOOL bInstance, bool bParentLocalized, IWbemClassObject *pOriginal,
                                        IWbemClassObject *pLocalized, bool &bChg)
{
    try
    {
        HRESULT hr = WBEM_S_NO_ERROR;

        pLocalized->BeginEnumeration(WBEM_FLAG_NONSYSTEM_ONLY);

        BSTR strPropName;
        LONG lLong;
        CIMTYPE ct;
        VARIANT vNewVal;

        while(pLocalized->Next(0, &strPropName, &vNewVal, &ct, &lLong) == S_OK)
        {
            IWbemQualifierSet *pLocalizedQs = NULL, *pThisQs = NULL;
            VARIANT vBasicVal;
            VariantInit(&vBasicVal);

            if (FAILED(pLocalized->GetPropertyQualifierSet(strPropName,&pLocalizedQs)))
            {
                SysFreeString(strPropName);
                VariantClear(&vNewVal);
                continue;
            }
            CReleaseMe rm1(pLocalizedQs);

            if (FAILED(pOriginal->GetPropertyQualifierSet(strPropName, &pThisQs)))
            {
                SysFreeString(strPropName);
                VariantClear(&vNewVal);
                continue;
            }
            CReleaseMe rm2(pThisQs);

            hr = LocalizeQualifiers(bInstance, bParentLocalized, pThisQs, pLocalizedQs, bChg);
            if (FAILED(hr))
            {
                SysFreeString(strPropName);
                VariantClear(&vNewVal);
                continue;
            }

            SysFreeString(strPropName);
            VariantClear(&vNewVal);

        }

        pLocalized->EndEnumeration();

        return hr;
    }
    catch(...)
    {
        return WBEM_E_CRITICAL_ERROR;
    }
}

// Retrieves the derivation of an object as an array of LPCWSTR's, each one
// terminated by a NULL.  Leftmost class is at the top of the chain
STDMETHODIMP CWbemObject::GetDerivation( long lFlags, ULONG uBufferSize, ULONG* puNumAntecedents,
                                        ULONG* puBuffSizeUsed, LPWSTR pwstrUserBuffer )
{
    try
    {
        if ( lFlags != 0L )
        {
            return WBEM_E_INVALID_PARAMETER;
        }

        CLock    lock( this );

        CVar    varDerivation;

        HRESULT    hr = GetClassPart()->GetDerivation( &varDerivation );

        if ( SUCCEEDED( hr ) )
        {
            if ( varDerivation.GetType() == VT_EX_CVARVECTOR && varDerivation.GetVarVector()->Size() > 0 )
            {
                CVarVector*    pvv = varDerivation.GetVarVector();

                // How many there are
                *puNumAntecedents = pvv->Size();
                *puBuffSizeUsed = 0;

                LPWSTR    pwstrTemp = pwstrUserBuffer;
                ULONG remainingBuffer = uBufferSize;
                for ( long x = ( *puNumAntecedents - 1 ); x > 0; x-- )
                {
                    // Point at the class name and store ts lenth
                    LPCWSTR    pwszAntecedent = pvv->GetAt( x ).GetLPWSTR();
                    ULONG    uLen = wcslen( pwszAntecedent ) + 1;

                    // Add to the required size
                    *puBuffSizeUsed +=    uLen;

                    // If we have a plcae to copy into and haven't exceeded its
                    // size, copy the string, and jump to the next location
                    if ( NULL != pwstrTemp && *puBuffSizeUsed <= uBufferSize )
                    {
                        StringCchCopyW( pwstrTemp, uBufferSize, pwszAntecedent );
                        pwstrTemp += uLen;
                        remainingBuffer -= uLen;
                    }

                }
                // Set an error as apropriate
                if ( NULL == pwstrTemp || *puBuffSizeUsed > uBufferSize )
                {
                    hr = WBEM_E_BUFFER_TOO_SMALL;
                }

            }
            else
            {
                *puNumAntecedents = 0;
                *puBuffSizeUsed = 0;
            }

        }    // IF we got the derivation

        return hr;
    }
    catch(...)
    {
        return WBEM_E_CRITICAL_ERROR;
    }
}

// Returns CWbemObject - allows for quick discovery of the real CWbemObject
// in case we've been wrapped.
STDMETHODIMP CWbemObject::_GetCoreInfo( long lFlags, void** ppvData )
{
    // AddRef us and return
    AddRef();
    *ppvData = (void*) this;

    return WBEM_S_NO_ERROR;
}

// Helper function to see if we know about a classname or not
classindex_t CWbemObject::GetClassIndex( LPCWSTR pwszClassName )
{
    return GetClassPart()->GetClassIndex( pwszClassName );
}

// Helper function to get a CWbemObject from IWbemClassObject;
HRESULT CWbemObject::WbemObjectFromCOMPtr( IUnknown* pUnk, CWbemObject** ppObj )
{
    // NULL is okay
    if ( NULL == pUnk )
    {
        *ppObj = NULL;
        return WBEM_S_NO_ERROR;
    }

    _IWmiObject*    pWmiObject = NULL;

    HRESULT    hr = pUnk->QueryInterface( IID__IWmiObject, (void**) &pWmiObject );
    CReleaseMe    rm(pWmiObject);

    if ( SUCCEEDED( hr ) )
    {
        // Okay pull out the object
        hr = pWmiObject->_GetCoreInfo( 0L, (void**) ppObj );    
    }
    else
    {
        // This will only happen if the object ain't one of ours
        hr = WBEM_E_INVALID_OPERATION;
    }

    return hr;
}


// Returns a BLOB of memory containing minimal data (local)
STDMETHODIMP CWbemObject::Unmerge( long lFlags, ULONG uBuffSize, ULONG* puBuffSizeUsed, LPVOID pData )
{
    try
    {
        if ( 0L != lFlags )
        {
            return WBEM_E_INVALID_PARAMETER;
        }

        int nLen = EstimateUnmergeSpace();
        length_t    nUnmergedLength = 0L;   // this should be passed in

        HRESULT hr = WBEM_E_OUT_OF_MEMORY;

        if ( NULL != puBuffSizeUsed )
        {
            *puBuffSizeUsed = nLen;
        }

        if ( uBuffSize >= nLen && NULL != pData )
        {
            // The buffer is big enough, so let the games begin.
            memset(pData, 0, nLen);
            hr = Unmerge( (LPBYTE) pData, nLen, &nUnmergedLength );

            if ( SUCCEEDED( hr ) && NULL != puBuffSizeUsed )
            {
                // This is the actual number of bytes used
                *puBuffSizeUsed = nUnmergedLength;
            }
        }
        else
        {
            hr = WBEM_E_BUFFER_TOO_SMALL;
        }

        return hr;

    }
    catch( CX_MemoryException )
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    catch( ... )
    {
        return WBEM_E_CRITICAL_ERROR;
    }

}

// Returns the name of the class where the keys were defined
STDMETHODIMP CWbemObject::GetKeyOrigin( long lFlags, DWORD dwNumChars, DWORD* pdwNumUsed, LPWSTR pwszClassName )
{
    try
    {
        if ( 0L != lFlags )
        {
            return WBEM_E_INVALID_PARAMETER;
        }

        CLock    lock( this );

        WString    wstr;

        HRESULT    hr = GetClassPart()->GetKeyOrigin( wstr );

        if ( SUCCEEDED( hr ) )
        {
            *pdwNumUsed = wstr.Length() + 1;

            if ( dwNumChars >= *pdwNumUsed && NULL != pwszClassName )
            {
                StringCchCopyW( pwszClassName, dwNumChars, wstr );
            }
            else
            {
                hr = WBEM_E_BUFFER_TOO_SMALL;
            }
        }

        return hr;

    }
    catch( CX_MemoryException )
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    catch( ... )
    {
        return WBEM_E_CRITICAL_ERROR;
    }
}

// Returns the key string of the class
STDMETHODIMP CWbemObject::GetKeyString( long lFlags, BSTR* ppwszKeyString )
{
    try
    {
        if ( 0L != lFlags || NULL == ppwszKeyString )
        {
            return WBEM_E_INVALID_PARAMETER;
        }

        CLock    lock( this );

        HRESULT    hr = WBEM_S_NO_ERROR;

        if ( IsInstance() )
        {
            WString    wstr;

            CWbemInstance*    pInst = (CWbemInstance*) this;

            LPWSTR    pwszStr = pInst->GetKeyStr();
            CVectorDeleteMe<WCHAR> vdm(pwszStr);

            if ( NULL != pwszStr )
            {
                *ppwszKeyString = SysAllocString( pwszStr );

                if ( NULL == *ppwszKeyString )
                {
                    hr = WBEM_E_OUT_OF_MEMORY;
                }

            }
            else
            {
                hr = WBEM_E_INVALID_OPERATION;
            }

        }
        else
        {
            return WBEM_E_INVALID_OPERATION;
        }

        return hr;

    }
    catch( CX_MemoryException )
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    catch( ... )
    {
        return WBEM_E_CRITICAL_ERROR;
    }
}

// Returns the key string of the class
STDMETHODIMP CWbemObject::GetNormalizedPath( long lFlags, BSTR* ppwszPath )
{
    try
    {
        if ( 0L != lFlags || NULL == ppwszPath )
        {
            return WBEM_E_INVALID_PARAMETER;
        }

        *ppwszPath = NULL;

        LPWSTR wszRelpath = GetRelPath( TRUE );

        if ( wszRelpath == NULL )
        {
            return WBEM_E_INVALID_OBJECT;
        }

        *ppwszPath = SysAllocString( wszRelpath );

        delete wszRelpath;

        return *ppwszPath != NULL?WBEM_S_NO_ERROR:WBEM_E_OUT_OF_MEMORY;
    }
    catch( CX_MemoryException )
    {
            return WBEM_E_OUT_OF_MEMORY;
    }

    catch( ... )
    {
            return WBEM_E_CRITICAL_ERROR;
    }
}


// Allows special filtering when enumerating properties outside the
// bounds of those allowed via BeginEnumeration().
STDMETHODIMP CWbemObject::BeginEnumerationEx( long lFlags, long lExtFlags )
{
    try
    {
        CLock    lock(this);

        if ( lExtFlags & ~WMIOBJECT_BEGINENUMEX_FLAG_GETEXTPROPS )
            return WBEM_E_INVALID_PARAMETER;

        HRESULT    hr = BeginEnumeration( lFlags );

        if ( SUCCEEDED( hr ) )
        {
            m_lExtEnumFlags = lExtFlags;
        }

        return hr;
    }
    catch( CX_MemoryException )
    {
        return WBEM_E_OUT_OF_MEMORY;
    }
    catch(...)
    {
        return WBEM_E_CRITICAL_ERROR;
    }
}

// Returns a VARTYPE from a CIMTYPE
STDMETHODIMP CWbemObject::CIMTYPEToVARTYPE( CIMTYPE ct, VARTYPE* pvt )
{
    try
    {
        *pvt = CType::GetVARTYPE( ct );
        return WBEM_S_NO_ERROR;
    }
    catch(...)
    {
        return WBEM_E_CRITICAL_ERROR;
    }
}

BOOL    g_fCheckedValidateFlag = FALSE;
BOOL    g_fDefaultValidate = FALSE;

// Validates an object blob
STDMETHODIMP CWbemObject::ValidateObject( long lFlags )
{

    // If we've never checked for the global validation flag, do so now.
    if ( !g_fCheckedValidateFlag )
    {
        Registry    reg( HKEY_LOCAL_MACHINE, KEY_READ, WBEM_REG_WINMGMT );
        DWORD    dwValidate = 0;

        reg.GetDWORDStr( __TEXT("EnableObjectValidation"), &dwValidate );
        g_fDefaultValidate = dwValidate;
        g_fCheckedValidateFlag = TRUE;
    }

    if ( lFlags & WMIOBJECT_VALIDATEOBJECT_FLAG_FORCE || g_fDefaultValidate )
    {
        return IsValidObj();
    }

    return WBEM_S_NO_ERROR;
}

// Returns the parent class name from a BLOB
STDMETHODIMP CWbemObject::GetParentClassFromBlob( long lFlags, ULONG uBuffSize, LPVOID pbData, BSTR* pbstrParentClass )
{
    return WBEM_E_NOT_AVAILABLE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\marshalers\coreprox\fastobj.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    FASTOBJ.H

Abstract:

  This file defines the classes related to generic object representation
  in WbemObjects. Its derived classes for instances (CWbemInstance) and
  classes (CWbemClass) are described in fastcls.h and fastinst.h.

  Classes defined:
      CDecorationPart     Information about the origins of the object.
      CWbemObject          Any object --- class or instance.

History:

  3/10/97     a-levn  Fully documented
  12//17/98 sanjes -    Partially Reviewed for Out of Memory.

--*/

#ifndef __FAST_WBEMOBJECT__H_
#define __FAST_WBEMOBJECT__H_

#include <assert.h>
#include <stddef.h>
#include <wbemidl.h>
#include <wbemint.h>
#include "corepol.h"

#include "fastqual.h"
#include "fastprop.h"
#include "fastsys.h"
#include <genlex.h>
#include <objpath.h>
#include <shmlock.h>


extern DWORD g_ContextLimit;
extern DWORD g_ObjectLimit;
extern DWORD g_IdentifierLimit;

//!!! Enable verbose assertions if we are a checked build!
#ifdef DBG
#define FASTOBJ_ASSERT_ENABLE
#endif


#if (defined FASTOBJ_ASSERT_ENABLE)

HRESULT _RetFastObjAssert(TCHAR *msg, HRESULT hres, const char *filename, int line);
#define RET_FASTOBJ_ASSERT(hres, msg)  return _RetFastObjAssert(msg, hres, __FILE__, __LINE__)
#define FASTOBJ_ASSERT( hres, msg) _RetFastObjAssert(msg, hres, __FILE__, __LINE__)

#else

#define RET_FASTOBJ_ASSERT(msg, hres)  return hres
#define FASTOBJ_ASSERT(msg, hres)

#endif

//#pragma pack(push, 1)

#define INVALID_PROPERTY_INDEX 0x7FFFFFFF
#define WBEM_FLAG_NO_SEPARATOR 0x80000000

#define FAST_WBEM_OBJECT_SIGNATURE 0x12345678

// This is a workaround for faststr clients like ESS who
// may need to directly access raw bytes of object data.
// In those cases, if the blob is not properly aligned,
// on Alphas and possibly Win64 machines, wcslen, wcscpy
// and SysAllocString have a tendency to crash if the
// bytes are in *just* the right location at the end of
// a page boundary.  By *silently* padding our BLOBs with
// 4 extra bytes, we ensure that there will always be
// space at the end of the BLOB to prevent the aformentioned
// functions from inexplicably crashing.
#define ALIGN_FASTOBJ_BLOB(a)   a + 4

//*****************************************************************************
//*****************************************************************************
//
//  struct CDecorationPart
//
//  This class represents overall information about an object, including its
//  genus (class or instance) and origin (server and namespace).
//
//  The layout of the memory block (it is the first part of every object!) is:
//
//      BYTE fFlags     A combination of flags from the flag enumeration
//                      (below), it specifies whether the object is a class or
//                      an instance, as well as whether it is "decorated", i.e.
//                      contains the origin information. All objects that came
//                      from WINMGMT are decorated. Objects created by the client
//                      (via SpawnInstance, for example) are not.
//          If the flags specify that the object is not decorated, this is the
//          end of the structure. Otherwise, the following information follows:
//
//      CCompressedString csServer      The name of the server as a compressed
//                                      string (see faststr.h)
//      CCompressedString csNamespace   the full name of the namespace as a
//                                      compressed string (see faststr.h)
//
//*****************************************************************************
//
//  SetData
//
//  Initialization function.
//
//  PARAMETERS:
//
//      LPMEMORY pData      Points to the memory block of the part.
//
//*****************************************************************************
//
//  GetStart
//
//  RETURN VALUES:
//
//      LPMEMORY:   the memory block of the part.
//
//*****************************************************************************
//
//  GetLength
//
//  RETURN VALUES:
//
//      length_t:   the length of the memory block of the part.
//
//*****************************************************************************
//
//  Rebase
//
//  Informs the object of the new location of its memory block.
//
//  PARAMETERS:
//
//      LPMEMORY pData      The new location of the memory block.
//
//*****************************************************************************
//
//  IsDecorated
//
//  Checks if the object is decorated (as determined by the flag)
//
//  RETURN VALUES:
//
//      BOOL:   TRUE iff the origin information is present
//
//*****************************************************************************
//
//  IsInstance
//
//  Checks if the object is a class or an instance.
//
//  RETURN VALUES:
//
//      BOOL:   TRUE iff the object is an instance.
//
//*****************************************************************************
//
//  static GetMinLength
//
//  RETURN VALUES:
//
//      length_t:   the number of bytes required for an empty decoration part.
//
//*****************************************************************************
//
//  static ComuteNecessarySpace
//
//  Computes the number of bytes required for a decoration part with the given
//  server name and namespace name.
//
//  Parameters;
//
//      LPCWSTR wszServer       The name of the server to store.
//      LPCWSTR wszNamespace    The name of the namespace to store.
//
//  Returns;
//
//      length_t:   the number of bytes required
//
//*****************************************************************************
//
//  CreateEmpty
//
//  Creates an empty (undecorated) decoration part on a given block of memory
//
//  PARAMETERS:
//
//      BYTE byFlags            The value of the flags field to set.
//      LPMEMORY pWhere         The memory block to create in.
//
//  RETURN VALUES:
//
//      LPMEMORY:   the first byte after the decoration part.
//
//*****************************************************************************
//
//  Create
//
//  Creates a complete (decorated) decoration part on a given block of memory.
//
//  PARAMETERS:
//
//      BYTE byFlags            The value of the flags field to set.
//      LPCWSTR wszServer       The name of the server to set.
//      LPCWSTR wszNamespace    The name of the namespace to set.
//      LPMEMORY pWhere         The memory block to create in.
//
//  RETURN VALUES:
//
//      LPMEMORY:   the first byte after the decoration part.
//
//*****************************************************************************
//
//  CompareTo
//
//  Compares this decoration part to another decoration part.
//
//  PARAMETERS:
//
//      IN READONLY CDecorationPart& Other  The part to compare to.
//
//  RETURN VALUES:
//
//      BOOL:   TRUE only if the flags are the same and the server and
//              namespace are the same to within the case.
//
//*****************************************************************************
enum
{
    OBJECT_FLAG_CLASS = WBEM_GENUS_CLASS,
    OBJECT_FLAG_INSTANCE = WBEM_GENUS_INSTANCE,
    OBJECT_FLAG_MASK_GENUS = 3,

    OBJECT_FLAG_UNDECORATED = 0,
    OBJECT_FLAG_DECORATED = 4,
    OBJECT_FLAG_MASK_DECORATION = 4,

    OBJECT_FLAG_COMPLETE = 0,
    OBJECT_FLAG_LIMITED = 0x10,
    OBJECT_FLAG_MASK_LIMITATION = 0x10,

    OBJECT_FLAG_CLIENT_ONLY = 0x20,
    OBJECT_FLAG_MASK_CLIENT_ONLY = 0x20,

    OBJECT_FLAG_KEYS_REMOVED = 0x40,
    OBJECT_FLAG_KEYS_PRESENT = 0,
    OBJECT_FLAG_MASK_KEY_PRESENCE = 0x40,
};

class COREPROX_POLARITY CDecorationPart
{
public:
    BYTE* m_pfFlags;
    CCompressedString* m_pcsServer;
    CCompressedString* m_pcsNamespace;

    CDecorationPart() : m_pfFlags(NULL) {}
    void SetData(LPMEMORY pData)
    {
        m_pfFlags = pData;
        if(IsDecorated())
        {
            m_pcsServer = (CCompressedString*)(pData + sizeof(BYTE));
            m_pcsNamespace = (CCompressedString*)
                (LPMEMORY(m_pcsServer) + m_pcsServer->GetLength());
        }
        else
        {
            m_pcsServer = m_pcsNamespace = NULL;
        }
    }
    static size_t ValidateBuffer(LPMEMORY pData, size_t bufferLength)
    {
		
    	if (bufferLength <sizeof(BYTE)) throw CX_Exception();

	size_t step = sizeof(BYTE);    	


        if((*pData & OBJECT_FLAG_DECORATED))
        {
	    step += ((CCompressedString*)(pData+step))->ValidateSize(bufferLength - step);
	    step += ((CCompressedString*)(pData+step))->ValidateSize(bufferLength - step);		
        }
        return step;
    }

     BOOL IsDecorated()
        {return (*m_pfFlags & OBJECT_FLAG_DECORATED);}
     LPMEMORY GetStart() {return m_pfFlags;}
     length_t GetLength()
    {
        if(IsDecorated())
            return sizeof(BYTE) + m_pcsServer->GetLength() +
                                    m_pcsNamespace->GetLength();
        else
            return sizeof(BYTE);
    }
     void Rebase(LPMEMORY pNewMemory)
    {
        m_pfFlags = pNewMemory;
        if(IsDecorated())
        {
            m_pcsServer = (CCompressedString*)(pNewMemory + sizeof(BYTE));
            m_pcsNamespace = (CCompressedString*)
                (LPMEMORY(m_pcsServer) + m_pcsServer->GetLength());
        }
    }
    BOOL IsInstance()
    {return (*m_pfFlags & OBJECT_FLAG_MASK_GENUS) == OBJECT_FLAG_INSTANCE;}

    BOOL IsLimited()
    {return (*m_pfFlags & OBJECT_FLAG_MASK_LIMITATION) == OBJECT_FLAG_LIMITED;}
    BOOL IsClientOnly()
    {return (*m_pfFlags & OBJECT_FLAG_MASK_CLIENT_ONLY) == OBJECT_FLAG_CLIENT_ONLY;}
    BOOL AreKeysRemoved()
    {return (*m_pfFlags & OBJECT_FLAG_MASK_KEY_PRESENCE) == OBJECT_FLAG_KEYS_REMOVED;}
     void SetClientOnly()
    {
        *m_pfFlags &= ~OBJECT_FLAG_MASK_CLIENT_ONLY;
        *m_pfFlags |= OBJECT_FLAG_CLIENT_ONLY;
    }

     void SetLimited()
    {
        *m_pfFlags &= ~OBJECT_FLAG_MASK_LIMITATION;
        *m_pfFlags |= OBJECT_FLAG_LIMITED;
    }

public:
    static  length_t GetMinLength() {return sizeof(BYTE);}
    static  length_t ComputeNecessarySpace(LPCWSTR wszServer,
        LPCWSTR wszNamespace)
    {
        return sizeof(BYTE) +
            CCompressedString::ComputeNecessarySpace(wszServer) +
            CCompressedString::ComputeNecessarySpace(wszNamespace);
    }

     LPMEMORY CreateEmpty(BYTE byFlags, LPMEMORY pWhere)
    {
        m_pfFlags = pWhere;

        *m_pfFlags = (byFlags & ~OBJECT_FLAG_DECORATED);

        m_pcsServer = m_pcsNamespace = NULL;
        return pWhere + sizeof(BYTE);
    }

     void Create(BYTE fFlags, LPCWSTR wszServer, LPCWSTR wszNamespace,
        LPMEMORY pWhere)
    {
        m_pfFlags = pWhere;
        *m_pfFlags = fFlags | OBJECT_FLAG_DECORATED;

        m_pcsServer = (CCompressedString*)(pWhere + sizeof(BYTE));
        m_pcsServer->SetFromUnicode(wszServer);
        m_pcsNamespace = (CCompressedString*)
            (LPMEMORY(m_pcsServer) + m_pcsServer->GetLength());
        m_pcsNamespace->SetFromUnicode(wszNamespace);
    }
     BOOL CompareTo(CDecorationPart& Other)
    {
        if((m_pcsServer == NULL) != (Other.m_pcsServer == NULL))
            return FALSE;
        if(m_pcsServer && m_pcsServer->CompareNoCase(*Other.m_pcsServer))
            return FALSE;
        if((m_pcsNamespace == NULL) != (Other.m_pcsNamespace == NULL))
            return FALSE;
        if(m_pcsNamespace && m_pcsNamespace->CompareNoCase(*Other.m_pcsNamespace))
            return FALSE;
        return TRUE;
    }

    static BOOL MapLimitation(IN CWStringArray* pwsNames,
                       IN OUT CLimitationMapping* pMap);
    LPMEMORY CreateLimitedRepresentation(READ_ONLY CLimitationMapping* pMap,
                                         OUT LPMEMORY pWhere);
    static void MarkKeyRemoval(OUT LPMEMORY pWhere)
    {
        *pWhere &= ~OBJECT_FLAG_MASK_KEY_PRESENCE;
        *pWhere |= OBJECT_FLAG_KEYS_REMOVED;
    }
};

// Need to use Interlocked functions here
//#pragma pack(push, 4)


#define BLOB_SIZE_MAX	0x7FFFFFFF

class CBlobControl
{
public:
    virtual ~CBlobControl(){}
    virtual LPMEMORY Allocate(int nLength) = 0;
    virtual LPMEMORY Reallocate(LPMEMORY pOld, int nOldLength,
                                    int nNewLength) = 0;
    virtual void Delete(LPMEMORY pOld) = 0;
};

class CGetHeap
{
private:
    HANDLE m_hHeap;
    BOOL   m_bNewHeap;
public:
    CGetHeap();
    ~CGetHeap();

    operator HANDLE(){ return m_hHeap; };
};

//
//  if you plan hooking the Allocation function in arena.cpp
//  beware that there few places where the heap is used 
//  throught the regular heap functions,
//  like WStringArray and _BtrMemAlloc
//

class CBasicBlobControl : public CBlobControl
{
public:

    static CGetHeap m_Heap;

    virtual LPMEMORY Allocate(int nLength)
	{
	    return sAllocate(nLength);
	}

    virtual LPMEMORY Reallocate(LPMEMORY pOld, int nOldLength,
                                    int nNewLength)
    {
        return sReallocate(pOld,nOldLength,nNewLength);
    }
    virtual void Delete(LPMEMORY pOld)
    {
        return sDelete(pOld);
    }

    static LPMEMORY sAllocate(int nLength)
	{
		if ( ((DWORD) nLength) > BLOB_SIZE_MAX )
		{
			return NULL;
		}

		return (LPMEMORY)HeapAlloc(m_Heap,0,ALIGN_FASTOBJ_BLOB(nLength));
	}
    static LPMEMORY sReallocate(LPMEMORY pOld, int nOldLength,
                                    int nNewLength)
    {
	    if ( ((DWORD) nNewLength)  > BLOB_SIZE_MAX )
	    {
	     return NULL;
   	    }

        LPMEMORY pNew = (LPMEMORY)HeapReAlloc( m_Heap, HEAP_ZERO_MEMORY, pOld, ALIGN_FASTOBJ_BLOB(nNewLength) );

        return pNew;
    }
    static void sDelete(LPMEMORY pOld)
    {
        HeapFree(m_Heap,0,pOld);
    }
    
};

extern CBasicBlobControl g_CBasicBlobControl;

class CCOMBlobControl : public CBlobControl
{
public:
    virtual LPMEMORY Allocate(int nLength)
	{
		if ( ((DWORD) nLength)  > BLOB_SIZE_MAX )
		{
			return NULL;
		}

		return (LPMEMORY) CoTaskMemAlloc(ALIGN_FASTOBJ_BLOB(nLength));
	}

    virtual LPMEMORY Reallocate(LPMEMORY pOld, int nOldLength,
                                    int nNewLength)
    {

		if ( ((DWORD) nNewLength)  > BLOB_SIZE_MAX )
		{
			return NULL;
		}

        // CoTaskMemRealloc will copy and free memory as needed
        return (LPMEMORY) CoTaskMemRealloc( pOld, ALIGN_FASTOBJ_BLOB(nNewLength) );
    }
    virtual void Delete(LPMEMORY pOld)
    {
        CoTaskMemFree( pOld );
    }
};

extern CCOMBlobControl g_CCOMBlobControl;

struct COREPROX_POLARITY SHMEM_HANDLE
{
    DWORD m_dwBlock;
    DWORD m_dwOffset;
};

class COREPROX_POLARITY CDerivationList : public CCompressedStringList
{
public:
    static  LPMEMORY Merge(CCompressedStringList& cslParent,
                                 CCompressedStringList& cslChild,
                                 LPMEMORY pDest)
    {
        LPMEMORY pCurrent = pDest + GetHeaderLength();
        pCurrent = cslChild.CopyData(pCurrent);
        pCurrent = cslParent.CopyData(pCurrent);

        // DEVNOTE:WIN64:SJS - 64-bit pointer values truncated into
        // signed/unsigned 32-bit value.  We do not support length
        // > 0xFFFFFFFF so cast is ok.

        *(UNALIGNED length_t*)pDest = (length_t) ( pCurrent - pDest );

        return pCurrent;
    }

     LPMEMORY Unmerge(LPMEMORY pDest)
    {
        CCompressedString* pcsFirst = GetFirst();
        LPMEMORY pCurrent = pDest + GetHeaderLength();
        if(pcsFirst != NULL)
        {
            int nLength = pcsFirst->GetLength() + GetSeparatorLength();
            memcpy(pCurrent, (LPMEMORY)pcsFirst, nLength);
            pCurrent += nLength;
        }

        // DEVNOTE:WIN64:SJS - 64-bit pointer values truncated into
        // signed/unsigned 32-bit value.  We do not support length
        // > 0xFFFFFFFF so cast is ok.

        *(UNALIGNED length_t*)pDest = (length_t) ( pCurrent - pDest );
        return pCurrent;
    }

    LPMEMORY CreateLimitedRepresentation(CLimitationMapping* pMap,
                                                LPMEMORY pWhere);
};

// Forward class definitions
class CWmiArray;

//*****************************************************************************
//*****************************************************************************
//
//  class CWbemObject
//
//  This is the base class for both Wbem instances (represented by CWbemInstance
//  in fastinst.h) and Wbem classes (represented by CWbemClass in fastcls.h).
//
//  It handles all the functionality that is common between the two and defines
//  virtual functions to be used by internal code that does not wish to
//  distinguish between classes and instances.
//
//  This class does not have a well-defined memory block, since classes and
//  instances have completely different formats. But every memory block of an
//  object starts with a decoration part (as represented by CDecorationPart
//  above.
//
//  CWbemObject also effects memory allocation for classes and instances. There
//  is a provision for a CWbemObject on a memory block it does not own (and
//  should ne deallocate), but it is not used.
//
//*****************************************************************************
//**************************** protected interface ****************************
//
//  Reallocate
//
//  Called by derived classes when they need to extend the size of the memory
//  block, this function allocates a new block of memory and deletes the old
//  one.
//
//  PARAMETERS:
//
//      length_t nNewLength     The number of bytes to allocate.
//
//  RETURN VALUES:
//
//      LPMEMORY:   pointer to the memory block
//
//*****************************************************************************
//
//  GetStart
//
//  Returns the pointer to the memory block of the object.
//
//  RETURN VALUES:
//
//      LPMEMORY
//
//*****************************************************************************
//
//  PURE GetBlockLength
//
//  Defined by derived classes to return the length of their memory block.
//
//  RETURN VALUES:
//
//      length_t:   the length
//
//*****************************************************************************
//
//  PURE GetClassPart
//
//  Defined by derived classes to return the pointer to the CClassPart object
//  describing the class of the object. See CWbemClass and CWbemInstance for
//  details on how that information is stored.
//
//  RETURN VALUES:
//
//      CClassPart*: pointer to the class part describing this class.
//
//*****************************************************************************
//
//  PURE GetProperty
//
//  Defined by derived classes to get the value of the property referenced
//  by a given CPropertyInformation structure (see fastprop.h). CWbemObject
//  can obtain this structure from the CClassPart it can get from GetClassPart,
//  so these two methods combined give CWbemObject own methods full access to
//  object properties, without knowing where they are stored.
//
//  PARAMETERS:
//
//      IN CPropertyInformation* pInfo  The information structure for the
//                                      desired property.
//      OUT CVar* pVar                  Destination for the value. Must NOT
//                                      already contain a value.
//  RETURN VALUES:
//
//      WBEM_S_NO_ERROR          On Success
//      (No errors can really occur at this stage, since the property has
//      already been "found").
//
//*****************************************************************************
//****************************** Persistence interface ************************
//
//  WriteToStream
//
//  Writes a serialized representation of the object into a CMemStream (see
//  strm.h). Since our objects are always represented serially, this is nothing
//  more than a couple of memcpys.
//
//  The format of an object in the stream consists of a signature, the length
//  of the block, and the block itself.
//
//  PARAMETERS:
//
//      CMemStream* pStream      The stream to write to.
//
//  RETURN VALUES:
//
//      int:    Any of CMemStream return codes (see strm.h),
//              CMemStream::no_error for success.
//
//*****************************************************************************
//
//  static CreateFromStream
//
//  Reads an object representation from a stream (see WriteStream for format)
//  and creates a CWbemObject corresponding to it.
//
//  Parameters I:
//
//      CMemStream* pStream     The stream to read from.
//
//  Parameters II:
//
//      IStream* pStream        The stream to read from
//
//  RETURN VALUES:
//
//      CWbemObject*:    representing the object, or NULL on error.
//
//*****************************************************************************
//
//  PURE EstimateUnmergeSpace
//
//  When objects are stored into the database, only those parts of them that
//  are different from the parent object (parent class for classes, class for
//  instances) are stored. This function is defined by derived classes to
//  calculate the amount of space needed for such an unmerged representation
//  of the object.
//
//  RETURN VALUES:
//
//      length_t:       the number of bytes required. May be an overestimate.
//
//*****************************************************************************
//
//  PURE Unmerge
//
//  When objects are stored into the database, only those parts of them that
//  are different from the parent object (parent class for classes, class for
//  instances) are stored. This function is defined by derived classes to
//  create such an unmerged representation of the object on a given memory
//  block.
//
//  PARAMETERS:
//
//      LPMEMORY pBlock                 The memory block. Assumed to be large
//                                      enough to contain all the data.
//      int nAllocatedSpace             The size of the block.
//
//  RETURN VALUES:
//
//      LPMEMORY:   points to the firsy byte after the object
//
//*****************************************************************************
//
//  Unmerge
//
//  A helper function for internal clients. Combines the functionality of
//  EstimateUnmergeSpace and Unmerge to allocate enough memory, create an
//  unmerge, and return the pointer to the caller.
//
//  PARAMETERS:
//
//      OUT LPMEMORY* pBlock        Destination for the newely allocated block.
//                                  The caller is responsible for deleting it
//                                  (delete *pBlock).
//  RETURN VALUES:
//
//      length_t:   the allocated length of the returned block.
//
//*****************************************************************************
//************************* internal public interface *************************
//
//  PURE GetProperty
//
//  Implemented by derived classes to return the value of a given property.
//
//  PARAMETERS:
//
//      IN LPCWSTR wszName      The name of the property to access.
//      OUT CVar* pVar          Destination for the value. Must not already
//                              contain a value.
//  RETURN VALUES:
//
//      WBEM_S_NO_ERROR          On Success
//      WBEM_E_NOT_FOUND         No such property.
//
//*****************************************************************************
//
//  GetPropertyType
//
//  Returns the datatype and flavor of a given property
//
//  PARAMETERS:
//
//      IN LPCWSTR wszName      The name of the proeprty to access.
//      OUT CIMTYPE* pctType    Destination for the type of the property. May
//                              be NULL if not required.
//      OUT LONG* plFlavor      Destination for the flavor of the property.
//                              May be NULL if not required.
//  RETURN VALUES:
//
//      WBEM_S_NO_ERROR          On Success
//      WBEM_E_NOT_FOUND         No such property.
//
//*****************************************************************************
//
//  GetPropertyType
//
//  Returns the datatype and flavor of a given property
//
//  PARAMETERS:
//
//      CPropertyInformation*   pInfo - Identifies property to access.
//      OUT CIMTYPE* pctType    Destination for the type of the property. May
//                              be NULL if not required.
//      OUT LONG* plFlavor      Destination for the flavor of the property.
//                              May be NULL if not required.
//  RETURN VALUES:
//
//      WBEM_S_NO_ERROR          On Success
//
//*****************************************************************************
//
//  PURE SetPropValue
//
//  Implemented by derived classes to set the value of the property. In the
//  case of a class, the property will be added if not already present.
//
//  PARAMETERS:
//
//      IN LPCWSTR wszProp       The name of the property to set.
//      IN CVar *pVal           The value to store in the property.
//      IN CIMTYPE ctType       specifies the actual type of the property.
//
//  RETURN VALUES:
//
//      WBEM_S_NO_ERROR          On Success
//      WBEM_E_NOT_FOUND         No such property in the instance.
//      WBEM_E_TYPE_MISMATCH     The value does not match the property type
//
//*****************************************************************************
//
//  PURE SetPropQualifier
//
//  Implemented by derived classes to set the value of a given qualifier on
//  a given property.
//
//  PARAMETERS:
//
//      IN LPCWSTR wszProp       The name of the property.
//      IN LPCWSTR wszQualifier  The name of the qualifier.
//      IN long lFlavor         The flavor for the qualifier (see fastqual.h)
//      IN CVar *pVal           The value of the qualifier
//
//  RETURN VALUES:
//
//      WBEM_S_NO_ERROR              On Success
//      WBEM_E_NOT_FOUND             No such property.
//      WBEM_E_OVERRIDE_NOT_ALLOWED  The qualifier is defined in the parent set
//                                  and overrides are not allowed by the flavor
//      WBEM_E_CANNOT_BE_KEY         An attempt was made to introduce a key
//                                  qualifier in a set where it does not belong
//
//*****************************************************************************
//
//  PURE GetPropQualifier
//
//  Retrieves the value of a given qualifier on a given property.
//
//  PARAMETERS:
//
//      IN LPCWSTR wszProp       The name of the property.
//      IN LPCWSTR wszQualifier  The name of the qualifier.
//      OUT CVar* pVar          Destination for the value of the qualifier.
//                              Must not already contain a value.
//      OUT long* plFlavor      Destination for the flavor of the qualifier.
//                              May be NULL if not required.
//  RETURN VALUES:
//
//      WBEM_S_NO_ERROR              On Success
//      WBEM_E_NOT_FOUND             No such property or no such qualifier.
//
//*****************************************************************************
//
//  PURE GetQualifier
//
//  Retrieves a qualifier from the object itself, that is,either an instance or
//  a class qualifier.
//
//  PARAMETERS:
//
//      IN LPCWSTR wszName       The name of the qualifier to retrieve.
//      OUT CVar* pVal          Destination for the value of the qualifier.
//                              Must not already contain a value.
//      OUT long* plFlavor      Destination for the flavor of the qualifier.
//                              May be NULL if not required.
//      IN BOOL fLocalOnly      Only retrieve local qualifiers
//  RETURN VALUES:
//
//      WBEM_S_NO_ERROR              On Success
//      WBEM_E_NOT_FOUND             No such qualifier.
//
//*****************************************************************************
//
//  PURE GetNumProperties
//
//  Retrieves the number of properties in the object
//
//  RETURN VALUES:
//
//      int:
//
//*****************************************************************************
//
//  PURE GetPropName
//
//  Retrieves the name of the property at a given index. This index has no
//  meaning except inthe context of this enumeration. It is NOT the v-table
//  index of the property.
//
//  PARAMETERS:
//
//      IN int nIndex        The index of the property to retrieve. Assumed to
//                           be within range (see GetNumProperties).
//      OUT CVar* pVar       Destination for the name. Must not already contain
//                           a value.
//
//*****************************************************************************
//
//  GetSystemProperty
//
//  Retrieves a system property by its index (see fastsys.h).
//
//  PARAMETERS:
//
//      int nIndex          The index of the system property (see fastsys.h)
//      OUT CVar* pVar      Destination for the value. Must not already contain
//                          a value.
//  RETURN VALUES:
//
//      WBEM_S_NO_ERROR          On Success
//      WBEM_E_NOT_FOUND         Invalid index or this system property is not
//                              defined in this object.
//      WBEM_E_UNDECORATED_OBJECT    This object has no origin information (see
//                                  CDecorationPart) and therefore does not
//                                  have decoration-related properties.
//
//*****************************************************************************
//
//  GetSystemPropertyByName
//
//  Retrieves a system property by its name (e.g. "__CLASS"). See fastsys.h
//
//  PARAMETERS:
//
//      IN LPCWSTR wszName  The name of the property to access.
//      OUT CVar* pVar      Destination for the value. Must not already contain
//                          a value.
//  RETURN VALUES:
//
//      WBEM_S_NO_ERROR          On Success
//      WBEM_E_NOT_FOUND         Invalid name or this system property is not
//                              defined in this object.
//      WBEM_E_UNDECORATED_OBJECT    This object has no origin information (see
//                                  CDecorationPart) and therefore does not
//                                  have decoration-related properties.
//
//*****************************************************************************
//
//  PURE IsKeyed
//
//  Defined by derived classes to verify if this object has keys.
//
//  RETURN VALUES:
//
//      BOOL:   TRUE if the object either has 'key' properties or is singleton.
//
//*****************************************************************************
//
//  PURE GetRelPath
//
//  Defined by derived classes to determine the relative path of the object.
//
//  RETURN VALUES:
//
//      LPWSTR: the newnely allocated string containing the path or NULL on
//              errors. The caller must delete this string.
//
//*****************************************************************************
//
//  GetFullPath
//
//  Returns the complete path to the object, assuming the object is decorated,
//  or NULL on errors.
//
//  RETURN VALUES:
//
//      LPWSTR: the complete path or NULL. The caller must delete this string.
//
//*****************************************************************************
//
//  PURE Decorate
//
//  Defined by derived classes to set the origin information for the object.
//
//  PARAMETERS:
//
//      LPCWSTR wszServer       the name of the server to set.
//      LPCWSTR wszNamespace    the name of the namespace to set.
//
//*****************************************************************************
//
//  PURE Undecorate
//
//  Defined by derived classes to remove the origin informaiton from the object
//
//*****************************************************************************
//
//  HasRefs
//
//  Checks if the object has properties which are references.
//
//  Returns;
//
//      BOOL: TRUE if it does.
//
//*****************************************************************************
//
//  PURE GetIndexedProps
//
//  Returns the array of the names of all the proeprties that are indexed.
//
//  PARAMETERS:
//
//      OUT CWStringArray& aNames       Destination for the names. Assumed to
//                                      be empty.
//
//*****************************************************************************
//
//  PURE GetKeyProps
//
//  Returns the array of the names of all the proeprties that are keys.
//
//  PARAMETERS:
//
//      OUT CWStringArray& aNames       Destination for the names. Assumed to
//                                      be empty.
//
//*****************************************************************************
//
//  GetKeyOrigin
//
//  Returns the name of the class of origin of the keys.
//
//  PARAMETERS:
//
//      OUT CWString& wsClass       Destination for the name.
//
//*****************************************************************************
//
//  IsInstance
//
//  Checks the genus of the object to see if it is a class or an instance.
//
//  RETURN VALUES:
//
//      BOOL:   TRUE if it is an instance
//
//*****************************************************************************
//
//  IsLimited
//
//  Checks if this object is complete or limited, i.e. the result of a
//  projection --- some properties and/or qualifiers are missing. There are
//  many restrictions placed on the use of such objects in the system.
//
//  RETURN VALUES:
//
//      BOOL:   TRUE if the object is limited.
//
//*****************************************************************************
//
//  PURE CompactAll
//
//  Implememnted by derived classes to compact their memory block removing any
//  holes between components. This does not include heap compaction and thus
//  is relatively fast.
//
//*****************************************************************************
//
//  GetServer
//
//  Retrieves the name of the server from the decoration part of the object.
//
//  PARAMETERS:
//
//      OUT CVar* pVar      Destination for the value. Must not already contain
//                          a value.
//  RETURN VALUES:
//
//      WBEM_S_NO_ERROR              On Success
//      WBEM_S_UNDECORATED_OBJECT    If decoration information is not set.
//
//*****************************************************************************
//
//  GetNamespace
//
//  Retrieves the name of the namespace from the decoration part of the object.
//
//  PARAMETERS:
//
//      OUT CVar* pVar      Destination for the value. Must not already contain
//                          a value.
//  RETURN VALUES:
//
//      WBEM_S_NO_ERROR              On Success
//      WBEM_S_UNDECORATED_OBJECT    If decoration information is not set.
//
//*****************************************************************************
//
//  GetRelPath
//
//  Retrieves the relative path of the object.
//
//  PARAMETERS:
//
//      OUT CVar* pVar      Destination for the value. Must not already contain
//                          a value.
//  RETURN VALUES:
//
//      WBEM_S_NO_ERROR          On Success
//      WBEM_S_INVALID_OBJECT    If some of the key proeprties do not have
//                              values or the class is not keyed.
//
//*****************************************************************************
//
//  GetPath
//
//  Retrieves the full path of the object.
//
//  PARAMETERS:
//
//      OUT CVar* pVar      Destination for the value. Must not already contain
//                          a value.
//  RETURN VALUES:
//
//      WBEM_S_NO_ERROR              On Success
//      WBEM_S_INVALID_OBJECT        If some of the key proeprties do not have
//                                  values or the class is not keyed.
//      WBEM_S_UNDECORATED_OBJECT    If decoration information is not set.
//
//*****************************************************************************
//
//  PURE GetGenus
//
//  Retrieves the genus of the object
//
//  PARAMETERS:
//
//      OUT CVar* pVar      Destination for the value. Must not already contain
//                          a value.
//  RETURN VALUES:
//
//      WBEM_S_NO_ERROR          On Success
//
//*****************************************************************************
//
//  PURE GetClassName
//
//  Retrieves the class name of the object
//
//  PARAMETERS:
//
//      OUT CVar* pVar      Destination for the value. Must not already contain
//                          a value.
//  RETURN VALUES:
//
//      WBEM_S_NO_ERROR          On Success
//      WBEM_E_NOT_FOUND         the class name has not been set.
//
//*****************************************************************************
//
//  PURE GetDynasty
//
//  Retrieves the dynasty of the object, i.e. the name of the top-level class
//  its class is derived from.
//
//  PARAMETERS:
//
//      OUT CVar* pVar      Destination for the value. Must not already contain
//                          a value.
//  RETURN VALUES:
//
//      WBEM_S_NO_ERROR          On Success
//      WBEM_E_NOT_FOUND         the class name has not been set.
//
//*****************************************************************************
//
//  PURE GetSuperclassName
//
//  Retrieves the parent class name of the object
//
//  PARAMETERS:
//
//      OUT CVar* pVar      Destination for the value. Must not already contain
//                          a value.
//  RETURN VALUES:
//
//      WBEM_S_NO_ERROR          On Success
//      WBEM_E_NOT_FOUND         the class is a top-levle class.
//
//*****************************************************************************
//
//  PURE GetPropertyCount
//
//  Retrieves the number of proerpties in the object
//
//  PARAMETERS:
//
//      OUT CVar* pVar      Destination for the value. Must not already contain
//                          a value.
//  RETURN VALUES:
//
//      WBEM_S_NO_ERROR          On Success
//
//*****************************************************************************
//
//  EstimateLimitedRepresentationLength
//
//  Estimates the amount of space that a limited representation of an object
//  will take. A limited representation is one with certain properties and/or
//  qualifiers removed from the object.
//
//  PARAMETERS:
//
//      IN long lFlags              The flags specifying what information to
//                                  exclude. Can be any combination of these:
//                                  WBEM_FLAG_EXCLUDE_OBJECT_QUALIFIERS:
//                                      No class or instance qualifiers.
//                                  WBEM_FLAG_EXCLUDE_PROPERTY_QUALIFIERS:
//                                      No property qualifiers
//
//      IN CWStringArray* pwsProps  If not NULL, specifies the array of names
//                                  for properties to include. Every other
//                                  property will be excluded. This includes
//                                  system properties like SERVER and NAMESPACE.
//                                  If RELPATH is specified here, it forces
//                                  inclusion of all key properties. If PATH
//                                  is specified, it forces RELPATH, SERVER and
//                                  NAMESPACE.
//  RETURN VALUES:
//
//      length_t:   an (over-)estimate for the amount of space required
//
//*****************************************************************************
//
//  CreateLimitedRepresentation
//
//  Creates a limited representation of the object on a given block of memory
//  as described in EstimateLimitedRepresentationLength above.
//
//  PARAMETERS:
//
//      IN long lFlags              The flags specifying what information to
//                                  exclude. Can be any combination of these:
//                                  WBEM_FLAG_EXCLUDE_OBJECT_QUALIFIERS:
//                                      No class or instance qualifiers.
//                                  WBEM_FLAG_EXCLUDE_PROPERTY_QUALIFIERS:
//                                      No property qualifiers
//
//      IN CWStringArray* pwsProps  If not NULL, specifies the array of names
//                                  for properties to include. Every other
//                                  property will be excluded. This includes
//                                  system properties like SERVER and NAMESPACE.
//                                  If RELPATH is specified here, it forces
//                                  inclusion of all key properties. If PATH
//                                  is specified, it forces RELPATH, SERVER and
//                                  NAMESPACE.
//      IN nAllocatedSize           The size of the memory block allocated for
//                                  the operation --- pDest.
//      OUT LPMEMORY pDest          Destination for the representation. Must
//                                  be large enough to contain all the data ---
//                                  see EstimateLimitedRepresentationSpace.
//  RETURN VALUES:
//
//      LPMEMORY:   NULL on failure, pointer to the first byte after the data
//                  written on success.
//
//*****************************************************************************
//
//  IsLocalized
//
//  Returns whether or not any localization bits have been set.
//
//  PARAMETERS:
//
//      none

//  RETURN VALUES:
//
//      BOOL    TRUE at least one localization bit was set.
//
//*****************************************************************************
//
//  SetLocalized
//
//  Sets the localized bit in the appropriate spot.
//
//  PARAMETERS:
//
//      BOOL    TRUE turns on bit, FALSE turns off

//  RETURN VALUES:
//
//      none.
//
//*****************************************************************************
//****************************** IWbemClassObject interface ********************
//
//  This interface is documented in the help file.
//
//*****************************************************************************
//****************************** IMarshal interface ***************************
//
//  CWbemObject implements standard COM IMarshal interface. The idea is to keep
//  CWbemObjects local and never marshal individual calls for properties and
//  such. So, whenever a pointer to CWbemObject needs to be marshalled across
//  process boundaries (when an object is being sent to the client or when the
//  client calls something like PutInstance), we want to simply send all the
//  object data to the destination so that any subsequent access to the object
//  by the callee would be local.
//
//  To accomplish this in COM, we implement our own IMarshal which does the
//  following (THIS IS NOT A HACK --- THIS IS THE PROPER COM WAY OF
//  ACCOMPLISHING WHAT WE WANT, AS DOCUMENTED IN BROCKSCHMIDT).
//
//*****************************************************************************
//
//  GetUnmarshalClass
//
//  Returns CLSID_WbemClassObjectProxy. This class ID points to the DLL containg
//  this very code.
//
//*****************************************************************************
//
//  MarshalInterface
//
//  By COM rules, this function is supposed to write enough information to a
//  stream to allow the proxy to connect back to the original object. Since we
//  don't want the proxy to connect and want it to be able to field all
//  questions by itself, we simply write the serialized representation of the
//  object into the stream.
//
//*****************************************************************************
//
//  UnmarshalInterface
//
//  This method is never called on an actual CWbemObject, since the object
//  ontainable at our UnmarshalClass is actually a CFastProxy (see fastprox.h
//  under marshalers\fastprox).
//
//*****************************************************************************
//
//  ReleaseMarsalData
//
//  This method is never called on an actual CWbemObject, since the object
//  ontainable at our UnmarshalClass is actually a CFastProxy (see fastprox.h
//  under marshalers\fastprox).
//
//*****************************************************************************
//
//  DisconnectObject
//
//  This method is never called on an actual CWbemObject, since the object
//  ontainable at our UnmarshalClass is actually a CFastProxy (see fastprox.h
//  under marshalers\fastprox).
//
//*****************************************************************************
//************************** IWbemPropertySource *******************************
//
//  GetPropertyValue
//
//  Retrieves a property value given the complex property name --- this can
//  include embeddeed object references and array references.
//
//  Parameters:
//
//      IN WBEM_PROPERTY_NAME* pName     The structure containing the name of the
//                                      property to retrieve. See providl.idl
//                                      for more information.
//      IN long lFlags                  Reserved.
//      OUT LPWSTR* pwszCimType         Destination for the CIM type of the
//                                      property, i.e. "sint32" or
//                                      "ref:MyClass". If NULL, not supplied.
//                                      If not NULL, the caller must call
//                                      CoTaskFree.
//      OUT VARIANT* pvValue            Destination for the value. Must not
//                                      contain releasable information on entry.
//  RETURN VALUES:
//
//      WBEM_S_NO_ERROR      Success
//      WBEM_E_NOT_FOUND     No such property
//
//*****************************************************************************

#define ARRAYFLAVOR_USEEXISTING	0xFFFFFFFF

// Forward declarations
class	CUmiPropertyArray;
class	CUmiProperty;

class COREPROX_POLARITY CWbemObject : public _IWmiObject, public IMarshal,
                   public IWbemPropertySource, public IErrorInfo,
                   public IWbemConstructClassObject

 {
 
public:
    int m_nRef;

 protected:
    BOOL m_bOwnMemory;
    int m_nCurrentProp;
    long m_lEnumFlags;
	long m_lExtEnumFlags;

     DWORD m_dwInternalStatus;

    // Maintains a pointer to a WbemClassObject we are merged with.  This means we
    // are sharing pointers into the other class object's BLOB.
    IWbemClassObject*   m_pMergedClassObject;


    CDecorationPart m_DecorationPart;

    SHARED_LOCK_DATA m_LockData;
    CSharedLock m_Lock;
    CBlobControl* m_pBlobControl;

    CDataTable& m_refDataTable;
    CFastHeap& m_refDataHeap;
    CDerivationList& m_refDerivationList;

protected:
    CWbemObject(CDataTable& refDataTable, CFastHeap& refDataHeap,
                CDerivationList& refDerivationList);

    LPMEMORY Reallocate(length_t nNewLength)
    {
        return m_pBlobControl->Reallocate(GetStart(), GetBlockLength(),
                        nNewLength);
    }


    virtual HRESULT GetProperty(CPropertyInformation* pInfo,
        CVar* pVar) = 0;

    virtual CClassPart* GetClassPart() = 0;

    // Rerouting targets for object validation
    static HRESULT EnabledValidateObject( CWbemObject* pObj );
    static HRESULT DisabledValidateObject( CWbemObject* pObj );

	HRESULT LocalizeQualifiers(BOOL bInstance, bool bParentLocalized,
							IWbemQualifierSet *pBase, IWbemQualifierSet *pLocalized,
							bool &bChg);

	HRESULT LocalizeProperties(BOOL bInstance, bool bParentLocalized, IWbemClassObject *pOriginal,
								IWbemClassObject *pLocalized, bool &bChg);

public:
 
    LPMEMORY GetStart() {return m_DecorationPart.GetStart();}
    virtual DWORD GetBlockLength() = 0;

    // These three functions return NULL in OOM and error
    // conditions
    static CWbemObject* CreateFromStream(IStream* pStrm);
    static CWbemObject* CreateFromMemory(LPMEMORY pMemory, int nLength,
        BOOL bAcquire, CBlobControl& allocator);

    virtual HRESULT WriteToStream( IStream* pStrm );
    virtual HRESULT GetMaxMarshalStreamSize( ULONG* pulSize );

    virtual length_t EstimateUnmergeSpace() = 0;
    virtual HRESULT Unmerge(LPMEMORY pStart, int nAllocatedLength, length_t* pnUnmergedLength) = 0;

    // We will throw exceptions in OOM scenarios.

    length_t Unmerge(LPMEMORY* ppStart);

    virtual ~CWbemObject();
public:
    // Quick 'get' and 'set' functions.
    // ===============================
    virtual HRESULT GetProperty(LPCWSTR wszName, CVar* pVal) = 0;
    virtual HRESULT GetPropertyType(LPCWSTR wszName, CIMTYPE* pctType,
                                    long* plFlavor = NULL) = 0;
    virtual HRESULT GetPropertyType(CPropertyInformation* pInfo, CIMTYPE* pctType,
                                    long* plFlavor = NULL) = 0;

    virtual HRESULT SetPropValue(LPCWSTR wszProp, CVar *pVal,
        CIMTYPE ctType) = 0;
    virtual HRESULT SetPropQualifier(LPCWSTR wszProp, LPCWSTR wszQualifier,
        long lFlavor, CVar *pVal) = 0;
    virtual HRESULT SetPropQualifier(LPCWSTR wszProp, LPCWSTR wszQualifier,
        long lFlavor, CTypedValue* pTypedVal) = 0;

    virtual HRESULT GetPropQualifier(LPCWSTR wszProp, LPCWSTR wszQualifier,
        CVar* pVar, long* plFlavor = NULL, CIMTYPE* pct = NULL) = 0;
    virtual HRESULT GetPropQualifier(CPropertyInformation* pInfo,
        LPCWSTR wszQualifier, CVar* pVar, long* plFlavor = NULL, CIMTYPE* pct = NULL) = 0;

    virtual HRESULT GetPropQualifier(LPCWSTR wszName, LPCWSTR wszQualifier, long* plFlavor,
		CTypedValue* pTypedVal, CFastHeap** ppHeap, BOOL fValidateSet) = 0;
    virtual HRESULT GetPropQualifier(CPropertyInformation* pInfo,
		LPCWSTR wszQualifier, long* plFlavor, CTypedValue* pTypedVal,
		CFastHeap** ppHeap, BOOL fValidateSet) = 0;

    virtual HRESULT GetMethodQualifier(LPCWSTR wszMethod, LPCWSTR wszQualifier,
        CVar* pVar, long* plFlavor = NULL, CIMTYPE* pct = NULL) = 0;
    virtual HRESULT GetMethodQualifier(LPCWSTR wszMethod, LPCWSTR wszQualifier, long* plFlavor,
		CTypedValue* pTypedVal, CFastHeap** ppHeap, BOOL fValidateSet) = 0;
    virtual HRESULT SetMethodQualifier(LPCWSTR wszMethod, LPCWSTR wszQualifier, long lFlavor, 
        CVar *pVal) = 0;
    virtual HRESULT SetMethodQualifier(LPCWSTR wszMethod, LPCWSTR wszQualifier,
        long lFlavor, CTypedValue* pTypedVal) = 0;
	virtual HRESULT FindMethod( LPCWSTR wszMethod );

    virtual HRESULT GetQualifier(LPCWSTR wszName, CVar* pVal,
        long* plFlavor = NULL, CIMTYPE* pct = NULL ) = 0;
    virtual HRESULT GetQualifier(LPCWSTR wszName, long* plFlavor, CTypedValue* pTypedVal,
		CFastHeap** ppHeap, BOOL fValidateSet) = 0;
    virtual HRESULT SetQualifier(LPCWSTR wszName, long lFlavor, CTypedValue* pTypedVal ) = 0;
    virtual HRESULT SetQualifier(LPCWSTR wszName, CVar* pVal,
        long lFlavor = 0) = 0;

    virtual BOOL IsLocalized( void ) = 0;
    virtual void SetLocalized( BOOL fLocalized ) = 0;

    virtual int GetNumProperties() = 0;
    virtual HRESULT GetPropName(int nIndex, CVar* pVal) = 0;

    HRESULT GetSystemProperty(int nIndex, CVar* pVar);
    HRESULT GetSystemPropertyByName(LPCWSTR wszName, CVar* pVar)
    {
        int nIndex = CSystemProperties::FindName(wszName);
        if(nIndex < 0) return WBEM_E_NOT_FOUND;
        return GetSystemProperty(nIndex, pVar);
    }
    HRESULT GetDerivation(CVar* pVar);

    virtual BOOL IsKeyed() = 0;
    virtual LPWSTR GetRelPath( BOOL bNormalized=FALSE ) = 0;

    LPWSTR GetFullPath();

    virtual HRESULT Decorate(LPCWSTR wszServer, LPCWSTR wszNamespace) = 0;
    virtual void Undecorate() = 0;


    BOOL HasRefs();

    virtual  BOOL GetIndexedProps(CWStringArray& awsNames) = 0;
    virtual  BOOL GetKeyProps(CWStringArray& awsNames) = 0;
    virtual  HRESULT GetKeyOrigin(WString& wsClass) = 0;

    length_t EstimateLimitedRepresentationSpace(
        IN long lFlags,
        IN CWStringArray* pwsNames)
    {
        return (length_t)GetBlockLength();
    }

    HRESULT GetServer(CVar* pVar);
    HRESULT GetNamespace(CVar* pVar);
    HRESULT GetServerAndNamespace( CVar* pVar );
    HRESULT GetPath(CVar* pVar);
    HRESULT GetRelPath(CVar* pVar);

    int GetNumParents()
    {
        return m_refDerivationList.GetNumStrings();
    }

    INTERNAL CCompressedString* GetParentAtIndex(int nIndex)
    {
        return m_refDerivationList.GetAtFromLast(nIndex);
    }
    INTERNAL CCompressedString* GetClassInternal();
    INTERNAL CCompressedString* GetPropertyString(long lHandle);
    HRESULT GetArrayPropertyHandle(LPCWSTR wszPropertyName,
                                            CIMTYPE* pct,
                                            long* plHandle);
    INTERNAL CUntypedArray* GetArrayByHandle(long lHandle);
	INTERNAL heapptr_t GetHeapPtrByHandle(long lHandle);

    CWbemObject* GetEmbeddedObj(long lHandle);

    virtual HRESULT GetGenus(CVar* pVar) = 0;
    virtual HRESULT GetClassName(CVar* pVar) = 0;
    virtual HRESULT GetDynasty(CVar* pVar) = 0;
    virtual HRESULT GetSuperclassName(CVar* pVar) = 0;
    virtual HRESULT GetPropertyCount(CVar* pVar) = 0;

    BOOL IsInstance()
    {
       return m_DecorationPart.IsInstance();
    }

    BOOL IsLimited()
    {
       return m_DecorationPart.IsLimited();
    }

    BOOL IsClientOnly()
    {
       return m_DecorationPart.IsClientOnly();
    }

    void SetClientOnly()
    {
       m_DecorationPart.SetClientOnly();
    }

	BOOL CheckBooleanPropQual( LPCWSTR pwszPropName, LPCWSTR pwszQualName );

    virtual void CompactAll()  = 0;
    virtual HRESULT CopyBlobOf(CWbemObject* pSource) = 0;
    static void EnableValidateObject( BOOL fEnable );

    virtual HRESULT IsValidObj( void ) = 0;

// DEVNOTE:TODO:MEMORY - We should change this header to return an HRESULT
    BOOL ValidateRange(BSTR* pstrName);

    virtual void SetData(LPMEMORY pData, int nTotalLength) = 0;

    static DELETE_ME LPWSTR GetValueText(long lFlags, READ_ONLY CVar& vValue,
                                            Type_t nType = 0);
    HRESULT ValidatePath(ParsedObjectPath* pPath);

	// Qualifier Array Support Functions
    HRESULT SetQualifierArrayRange( LPCWSTR pwszPrimaryName, LPCWSTR pwszQualName, BOOL fIsMethod, long lFlags,
									ULONG uflavor, CIMTYPE ct, ULONG uStartIndex, ULONG uNumElements, ULONG uBuffSize,
									LPVOID pData );
    // Sets a range of elements inside an array.  BuffSize must reflect uNumElements of the size of
	// element being set.  Strings must be linear WCHAR strings separated by NULLs.  Object properties
	// must consist of an array of _IWmiObject pointers.  The function will shrink/grow the array
	// as needed if WMIARRAY_FLAG_ALLELEMENTS is set - otherwise the array must fit in the current
	// array

	HRESULT AppendQualifierArrayRange( LPCWSTR pwszPrimaryName, LPCWSTR pwszQualName, BOOL fIsMethod,
								long lFlags, CIMTYPE ct, ULONG uNumElements, ULONG uBuffSize, LPVOID pData );
    // Sets a range of elements inside an array.  BuffSize must reflect uNumElements of the size of
	// element being set.  Strings must be linear WCHAR strings separated by NULLs.  Object properties
	// must consist of an array of _IWmiObject pointers.  The function will shrink/grow the array
	// as needed if WMIARRAY_FLAG_ALLELEMENTS is set - otherwise the array must fit in the current
	// array

	HRESULT RemoveQualifierArrayRange( LPCWSTR pwszPrimaryName, LPCWSTR pwszQualName, BOOL fIsMethod,
								long lFlags, ULONG uStartIndex, ULONG uNumElements );
    // Sets a range of elements inside an array.  BuffSize must reflect uNumElements of the size of
	// element being set.  Strings must be linear WCHAR strings separated by NULLs.  Object properties
	// must consist of an array of _IWmiObject pointers.  The function will shrink/grow the array
	// as needed if WMIARRAY_FLAG_ALLELEMENTS is set - otherwise the array must fit in the current
	// array

	HRESULT GetQualifierArrayInfo( LPCWSTR pwszPrimaryName, LPCWSTR pwszQualName, BOOL fIsMethod,
								long lFlags, CIMTYPE* pct, ULONG* puNumElements );
    // Sets a range of elements inside an array.  BuffSize must reflect uNumElements of the size of
	// element being set.  Strings must be linear WCHAR strings separated by NULLs.  Object properties
	// must consist of an array of _IWmiObject pointers.  The function will shrink/grow the array
	// as needed if WMIARRAY_FLAG_ALLELEMENTS is set - otherwise the array must fit in the current
	// array

    HRESULT GetQualifierArrayRange( LPCWSTR pwszPrimaryName, LPCWSTR pwszQualName, BOOL fIsMethod,
									long lFlags, ULONG uStartIndex,	ULONG uNumElements, ULONG uBuffSize,
									ULONG* puNumReturned, ULONG* pulBuffUsed, LPVOID pData );
    // Gets a range of elements from inside an array.  BuffSize must reflect uNumElements of the size of
	// element being set.  Strings must be linear WCHAR strings separated by NULLs.  Object properties
	// must consist of an array of _IWmiObject pointers.  The range MUST fit within the bounds
	// of the current array.

	// Helper function to get the actual index of a class
	classindex_t GetClassIndex( LPCWSTR pwszClassName );

	// Helper function to get a CWbemObject from IWbemClassObject;
	static HRESULT WbemObjectFromCOMPtr( IUnknown* pUnk, CWbemObject** ppObj );

	// UMI Helper functions
	HRESULT GetIntoArray( CUmiPropertyArray* pArray, LPCWSTR pszName, ULONG uFlags );
	HRESULT PutUmiProperty( CUmiProperty* pProp, LPCWSTR pszName, ULONG uFlags );

	// System Time proeprty helper functions
	//HRESULT InitSystemTimeProps( void );

public:

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(REFIID riid, LPVOID FAR* ppvObj);
    STDMETHOD_(ULONG, AddRef)();
    STDMETHOD_(ULONG, Release)();

    /* IWbemClassObject methods */
    STDMETHOD(GetQualifierSet)(IWbemQualifierSet** pQualifierSet) = 0;
    STDMETHOD(Get)(LPCWSTR wszName, long lFlags, VARIANT* pVal, CIMTYPE* pctType,
        long* plFlavor);

    STDMETHOD(Put)(LPCWSTR wszName, long lFlags, VARIANT* pVal, CIMTYPE ctType) = 0;
    STDMETHOD(Delete)(LPCWSTR wszName) = 0;
    STDMETHOD(GetNames)(LPCWSTR wszName, long lFlags, VARIANT* pVal,
                        SAFEARRAY** pNames);
    STDMETHOD(BeginEnumeration)(long lEnumFlags);

    STDMETHOD(Next)(long lFlags, BSTR* pName, VARIANT* pVal, CIMTYPE* pctType,
                    long* plFlavor);

    STDMETHOD(EndEnumeration)();

    STDMETHOD(GetPropertyQualifierSet)(LPCWSTR wszProperty,
                                       IWbemQualifierSet** pQualifierSet) = 0;
    STDMETHOD(Clone)(IWbemClassObject** pCopy) = 0;
    STDMETHOD(GetObjectText)(long lFlags, BSTR* pMofSyntax) = 0;

    STDMETHOD(CompareTo)(long lFlags, IWbemClassObject* pCompareTo);
    STDMETHOD(GetPropertyOrigin)(LPCWSTR wszProperty, BSTR* pstrClassName);
    STDMETHOD(InheritsFrom)(LPCWSTR wszClassName);

    /* IWbemPropertySource methods */

    STDMETHOD(GetPropertyValue)(WBEM_PROPERTY_NAME* pName, long lFlags,
        WBEM_WSTR* pwszCimType, VARIANT* pvValue);

    // IMarshal methods

    STDMETHOD(GetUnmarshalClass)(REFIID riid, void* pv, DWORD dwDestContext,
        void* pvReserved, DWORD mshlFlags, CLSID* pClsid);
    STDMETHOD(GetMarshalSizeMax)(REFIID riid, void* pv, DWORD dwDestContext,
        void* pvReserved, DWORD mshlFlags, ULONG* plSize);
    STDMETHOD(MarshalInterface)(IStream* pStream, REFIID riid, void* pv,
        DWORD dwDestContext, void* pvReserved, DWORD mshlFlags);
    STDMETHOD(UnmarshalInterface)(IStream* pStream, REFIID riid, void** ppv);
    STDMETHOD(ReleaseMarshalData)(IStream* pStream);
    STDMETHOD(DisconnectObject)(DWORD dwReserved);

    // IErrorInfo methods

    STDMETHOD(GetDescription)(BSTR* pstrDescription);
    STDMETHOD(GetGUID)(GUID* pguid);
    STDMETHOD(GetHelpContext)(DWORD* pdwHelpContext);
    STDMETHOD(GetHelpFile)(BSTR* pstrHelpFile);
    STDMETHOD(GetSource)(BSTR* pstrSource);

    // IWbemConstructClassObject methods
    // =================================

    STDMETHOD(SetInheritanceChain)(long lNumAntecedents,
        LPWSTR* awszAntecedents) = 0;
    STDMETHOD(SetPropertyOrigin)(LPCWSTR wszPropertyName, long lOriginIndex) = 0;
    STDMETHOD(SetMethodOrigin)(LPCWSTR wszMethodName, long lOriginIndex) = 0;
    STDMETHOD(SetServerNamespace)(LPCWSTR wszServer, LPCWSTR wszNamespace);

    // IWbemObjectAccess

    STDMETHOD(GetPropertyHandle)(LPCWSTR wszPropertyName, CIMTYPE* pct,
        long *plHandle);

    STDMETHOD(WritePropertyValue)(long lHandle, long lNumBytes,
                const byte *pData);
    STDMETHOD(ReadPropertyValue)(long lHandle, long lBufferSize,
        long *plNumBytes, byte *pData);

    STDMETHOD(ReadDWORD)(long lHandle, DWORD *pdw);
    STDMETHOD(WriteDWORD)(long lHandle, DWORD dw);
    STDMETHOD(ReadQWORD)(long lHandle, unsigned __int64 *pqw);
    STDMETHOD(WriteQWORD)(long lHandle, unsigned __int64 qw);

    STDMETHOD(GetPropertyInfoByHandle)(long lHandle, BSTR* pstrName,
             CIMTYPE* pct);

    STDMETHOD(Lock)(long lFlags);
    STDMETHOD(Unlock)(long lFlags);

    HRESULT IsValidPropertyHandle( long lHandle );

    static BOOL AreEqual(CWbemObject* pObj1, CWbemObject* pObj2,
                            long lFlags = 0);

    HRESULT GetPropertyNameFromIndex(int nIndex, BSTR* pstrName);
    HRESULT GetPropertyIndex(LPCWSTR wszName, int* pnIndex);

    BOOL IsSameClass(CWbemObject* pOther);
	HRESULT IsArrayPropertyHandle( long lHandle, CIMTYPE* pctIntrinisic, length_t* pnLength );

	// _IWmiObjectAccessEx methods
    // =================================
    STDMETHOD(GetPropertyHandleEx)( LPCWSTR pszPropName, long lFlags, CIMTYPE* puCimType, long* plHandle );
	// Returns property handle for ALL types

    STDMETHOD(SetPropByHandle)( long lHandle, long lFlags, ULONG uDataSize, LPVOID pvData );
	// Sets properties using a handle.  If pvData is NULL, it NULLs the property.
	// Can set an array to NULL.  To set actual data use the corresponding array
	// function.  Objects must be pointers to _IWmiObject pointers.

    STDMETHOD(GetPropAddrByHandle)( long lHandle, long lFlags, ULONG* puFlags, LPVOID *pAddress );
    // Returns a pointer to a memory address containing the requested data
	// Caller should not write into the memory address.  The memory address is
	// not guaranteed to be valid if the object is modified.
	// For String properties, puFlags will contain info on the string
	// For object properties, LPVOID will get back an _IWmiObject pointer
	// that must be released by the caller.  Does not return arrays.

    STDMETHOD(GetArrayPropInfoByHandle)( long lHandle, long lFlags, BSTR* pstrName,
										CIMTYPE* pct, ULONG* puNumElements );
    // Returns a pointer directly to a memory address containing contiguous
	// elements.  Limited to non-string/obj types

    STDMETHOD(GetArrayPropAddrByHandle)( long lHandle, long lFlags, ULONG* puNumElements, LPVOID *pAddress );
    // Returns a pointer directly to a memory address containing contiguous
	// elements.  Limited to non-string/obj types

    STDMETHOD(GetArrayPropElementByHandle)( long lHandle, long lFlags, ULONG uElement, ULONG* puFlags,
				ULONG* puNumElements, LPVOID *pAddress );
    // Returns a pointer to a memory address containing the requested data
	// Caller should not write into the memory address.  The memory address is
	// not guaranteed to be valid if the object is modified.
	// For String properties, puFlags will contain info on the string
	// For object properties, LPVOID will get back an _IWmiObject pointer
	// that must be released by the caller.

    STDMETHOD(SetArrayPropElementByHandle)( long lHandle, long lFlags, ULONG uElement, ULONG uBuffSize,
				LPVOID pData );
    // Sets the data at the specified array element.  BuffSize must be appropriate based on the
	// actual element being set.  Object properties require an _IWmiObject pointer.  Strings must
	// be WCHAR null-terminated

    STDMETHOD(RemoveArrayPropElementByHandle)( long lHandle, long lFlags, ULONG uElement );
    // Removes the data at the specified array element.

    STDMETHOD(GetArrayPropRangeByHandle)( long lHandle, long lFlags, ULONG uStartIndex,
				ULONG uNumElements, ULONG uBuffSize, ULONG* puNumReturned, ULONG* pulBuffUsed,
				LPVOID pData );
    // Gets a range of elements from inside an array.  BuffSize must reflect uNumElements of the size of
	// element being set.  Strings must be linear WCHAR strings separated by NULLs.  Object properties
	// must consist of an array of _IWmiObject pointers.  The range MUST fit within the bounds
	// of the current array.

    STDMETHOD(SetArrayPropRangeByHandle)( long lHandle, long lFlags, ULONG uStartIndex,
				ULONG uNumElements, ULONG uBuffSize, LPVOID pData );
    // Sets a range of elements inside an array.  BuffSize must reflect uNumElements of the size of
	// element being set.  Strings must be linear WCHAR strings separated by NULLs.  Object properties
	// must consist of an array of _IWmiObject pointers.  The function will shrink/grow the array
	// as needed if WMIARRAY_FLAG_ALLELEMENTS is set - otherwise the array must fit in the current
	// array

    STDMETHOD(RemoveArrayPropRangeByHandle)( long lHandle, long lFlags, ULONG uStartIndex, ULONG uNumElements );
    // Removes a range of elements from an array.  The range MUST fit within the bounds
	// of the current array

    STDMETHOD(AppendArrayPropRangeByHandle)( long lHandle, long lFlags, ULONG uNumElements,
				ULONG uBuffSize, LPVOID pData );
    // Appends elements to the end of an array.  BuffSize must reflect uNumElements of the size of
	// element being set.  Strings must be linear WCHAR strings separated by NULLs.  Object properties
	// must consist of an array of _IWmiObject pointers.


    STDMETHOD(ReadProp)( LPCWSTR pszPropName, long lFlags, ULONG uBuffSize, CIMTYPE *puCimType,
							long* plFlavor, BOOL* pfIsNull, ULONG* puBuffSizeUsed, LPVOID pUserBuf );
    // Assumes caller knows prop type; Objects returned as _IWmiObject pointers.  Strings
	// returned as WCHAR Null terminated strings, copied in place.  Arrays returned as _IWmiArray
	// pointer.  Array pointer used to access actual array values.

    STDMETHOD(WriteProp)( LPCWSTR pszPropName, long lFlags, ULONG uBufSize, ULONG uNumElements,
							CIMTYPE uCimType, LPVOID pUserBuf );
    // Assumes caller knows prop type; Supports all CIMTYPES.
	// Strings MUST be null-terminated wchar_t arrays.
	// Objects are passed in as pointers to _IWmiObject pointers
	// Using a NULL buffer will set the property to NULL
	// Array properties must conform to array guidelines.  Will
	// completely blow away an old array.

    STDMETHOD(GetObjQual)( LPCWSTR pszQualName, long lFlags, ULONG uBufSize, CIMTYPE *puCimType,
							ULONG *puQualFlavor, ULONG* puBuffSizeUsed,	LPVOID pDestBuf );
    // Limited to numeric, simple null terminated string types and simple arrays
	// Strings are copied in-place and null-terminated.
	// Arrays come out as a pointer to IWmiArray

    STDMETHOD(SetObjQual)( LPCWSTR pszQualName, long lFlags, ULONG uBufSize, ULONG uNumElements,
							CIMTYPE uCimType, ULONG uQualFlavor, LPVOID pUserBuf );
    // Limited to numeric, simple null terminated string types and simple arrays
	// Strings MUST be WCHAR
	// Arrays are set using _IWmiArray interface from Get

    STDMETHOD(GetPropQual)( LPCWSTR pszPropName, LPCWSTR pszQualName, long lFlags, ULONG uBufSize,
							CIMTYPE *puCimType, ULONG *puQualFlavor, ULONG* puBuffSizeUsed,
							LPVOID pDestBuf );
    // Limited to numeric, simple null terminated string types and simple arrays
	// Strings are copied in-place and null-terminated.
	// Arrays come out as a pointer to IWmiArray

    STDMETHOD(SetPropQual)( LPCWSTR pszPropName, LPCWSTR pszQualName, long lFlags, ULONG uBufSize,
							ULONG uNumElements,	CIMTYPE uCimType, ULONG uQualFlavor, LPVOID pUserBuf );
    // Limited to numeric, simple null terminated string types and simple arrays
	// Strings MUST be WCHAR
	// Arrays are set using _IWmiArray interface from Get

    STDMETHOD(GetMethodQual)( LPCWSTR pszMethodName, LPCWSTR pszQualName, long lFlags, ULONG uBufSize,
							CIMTYPE *puCimType, ULONG *puQualFlavor, ULONG* puBuffSizeUsed,
							LPVOID pDestBuf );
    // Limited to numeric, simple null terminated string types and simple arrays
	// Strings are copied in-place and null-terminated.
	// Arrays come out as a pointer to IWmiArray

    STDMETHOD(SetMethodQual)( LPCWSTR pszMethodName, LPCWSTR pszQualName, long lFlags, ULONG uBufSize,
							ULONG uNumElements,	CIMTYPE uCimType, ULONG uQualFlavor, LPVOID pUserBuf );
    // Limited to numeric, simple null terminated string types and simple arrays
	// Strings MUST be WCHAR
	// Arrays are set using _IWmiArray interface from Get

	//
	//	_IWmiObject functions
	STDMETHOD(CopyInstanceData)( long lFlags, _IWmiObject* pSourceInstance ) = 0;
	// Copies instance data from source instance into current instance
	// Class Data must be exactly the same

    STDMETHOD(QueryObjectFlags)( long lFlags, unsigned __int64 qObjectInfoMask,
				unsigned __int64 *pqObjectInfo );
	// Returns flags indicating singleton, dynamic, association, etc.

    STDMETHOD(SetObjectFlags)( long lFlags, unsigned __int64 qObjectInfoOnFlags,
								unsigned __int64 qObjectInfoOffFlags );
	// Sets flags, including internal ones normally inaccessible.

    STDMETHOD(QueryPropertyFlags)( long lFlags, LPCWSTR pszPropertyName, unsigned __int64 qPropertyInfoMask,
				unsigned __int64 *pqPropertyInfo );
	// Returns flags indicating key, index, etc.

	STDMETHOD(CloneEx)( long lFlags, _IWmiObject* pDestObject ) = 0;
    // Clones the current object into the supplied one.  Reuses memory as
	// needed

    STDMETHOD(IsParentClass)( long lFlags, _IWmiObject* pClass ) = 0;
	// Checks if the current object is a child of the specified class (i.e. is Instance of,
	// or is Child of )

    STDMETHOD(CompareDerivedMostClass)( long lFlags, _IWmiObject* pClass ) = 0;
	// Compares the derived most class information of two class objects.

    STDMETHOD(MergeAmended)( long lFlags, _IWmiObject* pAmendedClass );
	// Merges in amended qualifiers from the amended class object into the
	// current object.  If lFlags is WMIOBJECT_MERGEAMENDED_FLAG_PAENTLOCALIZED,
	// this means that the parent object was localized, but not the current,
	// so we need to prevent certain qualifiers from "moving over."

	STDMETHOD(GetDerivation)( long lFlags, ULONG uBufferSize, ULONG* puNumAntecedents,
							ULONG* puBuffSizeUsed, LPWSTR pwstrUserBuffer );
	// Retrieves the derivation of an object as an array of LPCWSTR's, each one
	// terminated by a NULL.  Leftmost class is at the top of the chain

	STDMETHOD(_GetCoreInfo)( long lFlags, void** ppvData );
	//Returns CWbemObject

    STDMETHOD(QueryPartInfo)( DWORD *pdwResult );

    STDMETHOD(SetObjectMemory)( LPVOID pMem, DWORD dwMemSize );
    STDMETHOD(GetObjectMemory)( LPVOID pDestination, DWORD dwDestBufSize, DWORD *pdwUsed );
    STDMETHOD(SetObjectParts)( LPVOID pMem, DWORD dwMemSize, DWORD dwParts ) = 0;
    STDMETHOD(GetObjectParts)( LPVOID pDestination, DWORD dwDestBufSize, DWORD dwParts, DWORD *pdwUsed ) = 0;

    STDMETHOD(StripClassPart)() = 0;
    STDMETHOD(IsObjectInstance)()
    { return ( IsInstance() ? WBEM_S_NO_ERROR : WBEM_S_FALSE ); }

    STDMETHOD(GetClassPart)( LPVOID pDestination, DWORD dwDestBufSize, DWORD *pdwUsed ) = 0;
    STDMETHOD(SetClassPart)( LPVOID pClassPart, DWORD dwSize ) = 0;
    STDMETHOD(MergeClassPart)( IWbemClassObject *pClassPart ) = 0;

    STDMETHOD(SetDecoration)( LPCWSTR pwcsServer, LPCWSTR pwcsNamespace );
    STDMETHOD(RemoveDecoration)( void );

    STDMETHOD(CompareClassParts)( IWbemClassObject* pObj, long lFlags );

    STDMETHOD(ClearWriteOnlyProperties)( void ) = 0;

    STDMETHOD(GetClassSubset)( DWORD dwNumNames, LPCWSTR *pPropNames, _IWmiObject **pNewClass ) = 0;
	// Creates a limited representation class for projection queries

    STDMETHOD(MakeSubsetInst)( _IWmiObject *pInstance, _IWmiObject** pNewInstance ) = 0;
	// Creates a limited representation instance for projection queries
	// "this" _IWmiObject must be a limited class

	STDMETHOD(Unmerge)( long lFlags, ULONG uBuffSize, ULONG* puBuffSizeUsed, LPVOID pData );
	// Returns a BLOB of memory containing minimal data (local)

	STDMETHOD(Merge)( long lFlags, ULONG uBuffSize, LPVOID pbData, _IWmiObject** ppNewObj ) = 0;
	// Merges a blob with the current object memory and creates a new object

	STDMETHOD(ReconcileWith)( long lFlags, _IWmiObject* pNewObj ) = 0;
	// Reconciles an object with the current one.  If WMIOBJECT_RECONCILE_FLAG_TESTRECONCILE
	// is specified this will only perform a test

	STDMETHOD(GetKeyOrigin)( long lFlags, DWORD dwNumChars, DWORD* pdwNumUsed, LPWSTR pwzClassName );
	// Returns the name of the class where the keys were defined

	STDMETHOD(GetKeyString)( long lFlags, BSTR* ppwzKeyString );
	// Returns the key string that defines the instance

	STDMETHOD(GetNormalizedPath)( long lFlags, BSTR* ppwzKeyString );
	// Returns the normalized path of an instance

	STDMETHOD(Upgrade)( _IWmiObject* pNewParentClass, long lFlags, _IWmiObject** ppNewChild ) = 0;
	// Upgrades class and instance objects

	STDMETHOD(Update)( _IWmiObject* pOldChildClass, long lFlags, _IWmiObject** ppNewChildClass ) = 0;
	// Updates derived class object using the safe/force mode logic

	STDMETHOD(BeginEnumerationEx)( long lFlags, long lExtFlags );
	// Allows special filtering when enumerating properties outside the
	// bounds of those allowed via BeginEnumeration().
	
	STDMETHOD(CIMTYPEToVARTYPE)( CIMTYPE ct, VARTYPE* pvt );
	// Returns a VARTYPE from a CIMTYPE

	STDMETHOD(SpawnKeyedInstance)( long lFlags, LPCWSTR pwszPath, _IWmiObject** ppInst ) = 0;
	// Spawns an instance of a class and fills out the key properties using the supplied
	// path.

	STDMETHOD(ValidateObject)( long lFlags );
	// Validates an object blob

	STDMETHOD(GetParentClassFromBlob)( long lFlags, ULONG uBuffSize, LPVOID pbData, BSTR* pbstrParentClass );
	// Returns the parent class name from a BLOB

	STDMETHOD(CloneAndDecorate)(long lFlags,WCHAR * pszServer,WCHAR * pszNamespace,IWbemClassObject** ppDestObject) = 0;

	STDMETHOD(MergeAndDecorate)(long lFlags,ULONG uBuffSize,LPVOID pbData,WCHAR * pServer,WCHAR * pNamespace,_IWmiObject** ppNewObj) = 0;

protected:

    class CLock
    {
    protected:
        CWbemObject* m_p;
    public:
        CLock(CWbemObject* p, long lFlags = 0) : m_p(p) { if ( NULL != p ) p->Lock(lFlags);}
        ~CLock() { if ( NULL != m_p ) m_p->Unlock(0);}
    };

    friend CQualifierSet;
	friend CWmiArray;

#ifdef _DEBUG_REFCOUNT
private:
    LONG BackTraceIndex;
    DWORD Signature;    
    PVOID Traces[64][8];
#endif
};

#define WBEM_INSTANCE_ALL_PARTS     WBEM_OBJ_DECORATION_PART | WBEM_OBJ_CLASS_PART | WBEM_OBJ_INSTANCE_PART

//#pragma pack(pop)
//#pragma pack(pop)

#ifdef OBJECT_TRACKING
#pragma message("** Object Tracking **")
void COREPROX_POLARITY ObjectTracking_Dump();
void COREPROX_POLARITY ObjTracking_Add(CWbemObject *p);
void COREPROX_POLARITY ObjTracking_Remove(CWbemObject *p);
#endif


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\marshalers\coreprox\fastprbg.cpp ===
/*++

Copyright (C) 2000-2001 Microsoft Corporation

Module Name:

    FASTPRBG.CPP

Abstract:

  CFastPropertyBag Definition.

  Implements an array of property data for minimal storage.

History:

  24-Feb-2000	sanjes    Created.

--*/

#include "precomp.h"
#include <stdio.h>
#include "fastall.h"
#include "fastprbg.h"
#include <corex.h>
#include "strutils.h"
#include <wbemutil.h>

// This class assumes that the incoming data is properly validated
//***************************************************************************
//
//  CFastPropertyBagItem::~CFastPropertyBagItem
//
//***************************************************************************
// ok
CFastPropertyBagItem::CFastPropertyBagItem( LPCWSTR pszName, CIMTYPE ctData, ULONG uDataLength, ULONG uNumElements,
									LPVOID pvData )
:	m_wsPropertyName( pszName ),
	m_ctData( ctData ),
	m_uDataLength( uDataLength ),
	m_uNumElements( uNumElements ),
	m_pvData( NULL ),
	m_lRefCount( 1L )	// Then we always know to release it!
{

	// If the data is non-NULL we need to store it.

	if ( NULL != pvData )
	{
		// IF it's pointer type data then we will allocate storage,
		// unless the length happens to fit in our buffer
		if ( CType::IsPointerType( ctData ) )
		{

			if ( uDataLength >= MAXIMUM_FIXED_DATA_LENGTH )
			{
				m_pvData = (void*) new BYTE[uDataLength];

				if ( NULL == m_pvData )
				{
					m_wsPropertyName.Empty();
					throw CX_MemoryException();
				}
			}
			else
			{
				m_pvData = (void*) m_bRawData;
			}

		}
		else
		{
			m_pvData = (void*) m_bRawData;
		}

		// Copy data into the proper location
		CopyMemory( m_pvData, pvData, uDataLength );

		// We should Addref the incoming objects
		if ( CType::GetBasic( m_ctData ) == CIM_OBJECT )
		{
			ULONG	uNumObj = 1;

			if ( CType::IsArray( m_ctData ) )
			{
				uNumObj = m_uNumElements;
			}

			for ( ULONG uCtr = 0; uCtr < uNumObj; uCtr++ )
			{
				(*(IUnknown**) m_pvData )->AddRef();
			}

		}	// IF embedded objects

	}	// IF NULL != pvData

}
    
//***************************************************************************
//
//  CFastPropertyBagItem::~CFastPropertyBagItem
//
//***************************************************************************
// ok
CFastPropertyBagItem::~CFastPropertyBagItem()
{
	// Cleanup
	if ( NULL != m_pvData )
	{
		// We should Release objects we are holding onto
		if ( CType::GetBasic( m_ctData ) == CIM_OBJECT )
		{
			ULONG	uNumObj = 1;

			if ( CType::IsArray( m_ctData ) )
			{
				uNumObj = m_uNumElements;
			}

			for ( ULONG uCtr = 0; uCtr < uNumObj; uCtr++ )
			{
				(*(IUnknown**) m_pvData )->Release();
			}

		}	// IF embedded objects

		// Check if it's pointing to our raw buffer before we
		// free it
		if ( m_pvData != (void*) m_bRawData )
		{
			delete m_pvData;
		}
	}
}

ULONG CFastPropertyBagItem::AddRef()
{
    return InterlockedIncrement((long*)&m_lRefCount);
}

ULONG CFastPropertyBagItem::Release()
{
    long lRef = InterlockedDecrement((long*)&m_lRefCount);
    _ASSERT(lRef >= 0, __TEXT("Reference count on CFastPropertyBagItem went below 0!"))

    if(lRef == 0)
        delete this;
    return lRef;
}

//***************************************************************************
//
//  CFastPropertyBag::~CFastPropertyBag
//
//***************************************************************************
// ok
CFastPropertyBag::CFastPropertyBag( void )
:	m_aProperties()
{
}
    
//***************************************************************************
//
//  CFastPropertyBag::~CFastPropertyBag
//
//***************************************************************************
// ok
CFastPropertyBag::~CFastPropertyBag()
{
}

//***************************************************************************
//
//  CFastPropertyBag::FindProperty
//	Locates a property bag item
//
//***************************************************************************
CFastPropertyBagItem*	CFastPropertyBag::FindProperty( LPCWSTR pszName )
{
	CFastPropertyBagItem*	pItem = NULL;

	for ( int x = 0; x < m_aProperties.GetSize(); x++ )
	{
		pItem = m_aProperties.GetAt(x);

		if ( pItem->IsPropertyName( pszName ) )
		{
			return pItem;
		}

	}

	return NULL;
}

//***************************************************************************
//
//  CFastPropertyBag::FindProperty
//	Locates a property bag item
//
//***************************************************************************
int	CFastPropertyBag::FindPropertyIndex( LPCWSTR pszName )
{
	CFastPropertyBagItem*	pItem = NULL;

	for ( int x = 0; x < m_aProperties.GetSize(); x++ )
	{
		pItem = m_aProperties.GetAt(x);

		if ( pItem->IsPropertyName( pszName ) )
		{
			return x;
		}

	}

	return -1;
}

//***************************************************************************
//
//  CFastPropertyBag::Add
//	Adds a property and value to the bag
//
//***************************************************************************
HRESULT CFastPropertyBag::Add( LPCWSTR pszName, CIMTYPE ctData, ULONG uDataLength, ULONG uNumElements, LPVOID pvData )
{
	HRESULT	hr = WBEM_S_NO_ERROR;

	try
	{
		// Verify the data size
		if ( CType::IsArray( ctData ) )
		{
			hr = CUntypedArray::CheckRangeSize( CType::GetBasic( ctData ), uDataLength, uNumElements, uDataLength, pvData );
		}
		else
		{
			CVar	var;
			hr = CUntypedValue::FillCVarFromUserBuffer( ctData, &var, uDataLength, pvData );
		}

		if ( SUCCEEDED( hr ) )
		{
			// Make sure we release it if we allocate it
			CFastPropertyBagItem* pItem = new CFastPropertyBagItem( pszName, ctData, uDataLength,
																	uNumElements, pvData );
			CTemplateReleaseMe<CFastPropertyBagItem>	rm( pItem );

			if ( NULL != pItem )
			{
				if ( m_aProperties.Add( pItem ) < 0 )
				{
					hr = WBEM_E_OUT_OF_MEMORY;
				}
			}

		}	// IF buffer was valid

	}
	catch( CX_MemoryException )
	{
		hr = WBEM_E_OUT_OF_MEMORY;
	}
	catch(...)
	{
		hr = WBEM_E_FAILED;
	}

	return hr;
}

//***************************************************************************
//
//  CFastPropertyBag::Get
//	Returns values for a property.  Note that embedded objects
//	are NOT AddRef'd.  Caller should not atempt to free returned memory.
//
//***************************************************************************
HRESULT CFastPropertyBag::Get( int nIndex, LPCWSTR* ppszName, CIMTYPE* pctData, ULONG* puDataLength, ULONG* puNumElements, LPVOID* ppvData )
{
	HRESULT	hr = WBEM_S_NO_ERROR;

	// Make sure it doesn't already exist

	if ( nIndex >= 0 && nIndex < m_aProperties.GetSize() )
	{
		CFastPropertyBagItem*	pItem = m_aProperties.GetAt( nIndex );

		if ( NULL != pItem )
		{
			pItem->GetData( ppszName, pctData, puDataLength, puNumElements, ppvData );
		}
		else
		{
			hr = WBEM_E_NOT_FOUND;
		}
	}
	else
	{
		hr = WBEM_E_NOT_FOUND;
	}

	return hr;
}

//***************************************************************************
//
//  CFastPropertyBag::Get
//	Returns values for a property.  Note that embedded objects
//	are NOT AddRef'd
//
//***************************************************************************
HRESULT CFastPropertyBag::Get( LPCWSTR pszName, CIMTYPE* pctData, ULONG* puDataLength, ULONG* puNumElements, LPVOID* ppvData )
{
	HRESULT	hr = WBEM_S_NO_ERROR;

	// Make sure it doesn't already exist
	CFastPropertyBagItem*	pItem = FindProperty( pszName );

	if ( NULL != pItem )
	{
		pItem->GetData( pctData, puDataLength, puNumElements, ppvData );
	}
	else
	{
		hr = WBEM_E_NOT_FOUND;
	}

	return hr;
}

//***************************************************************************
//
//  CFastPropertyBag::Remove
//	Removes a property from the bag
//
//***************************************************************************
HRESULT CFastPropertyBag::Remove( LPCWSTR pszName )
{
	HRESULT	hr = WBEM_S_NO_ERROR;

	// Make sure it doesn't already exist
	int	nIndex = FindPropertyIndex( pszName );

	if ( nIndex >= 0 )
	{
		m_aProperties.RemoveAt( nIndex );
	}
	else
	{
		hr = WBEM_E_NOT_FOUND;
	}

	return hr;
}

//***************************************************************************
//
//  CFastPropertyBag::RemoveAll
//	Removes all properties from the bag
//
//***************************************************************************
HRESULT CFastPropertyBag::RemoveAll( void )
{
	m_aProperties.RemoveAll();
	return WBEM_S_NO_ERROR;
}

//***************************************************************************
//
//  CFastPropertyBag::Copy
//	Copies all properties from a source bag
//
//***************************************************************************
HRESULT	CFastPropertyBag::Copy( const CFastPropertyBag& source )
{
	HRESULT	hr = WBEM_S_NO_ERROR;

	// Basically we just AddRef the new properties
	for ( int x = 0; SUCCEEDED( hr ) && x < source.m_aProperties.GetSize(); x++ )
	{
		CFastPropertyBagItem* pItem = (CFastPropertyBagItem*) source.m_aProperties.GetAt( x );

		if ( m_aProperties.Add( pItem ) != CFlexArray::no_error )
		{
			hr = WBEM_E_OUT_OF_MEMORY;
		}
	}

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\marshalers\coreprox\fastprbg.h ===
/*++

Copyright (C) 2000-2001 Microsoft Corporation

Module Name:

    FASTPRBG.H

Abstract:

  CFastPropertyBag Definition.

  Implements an array of property data for minimal storage.

History:

  24-Feb-2000	sanjes    Created.

--*/

#ifndef _FASTPRBG_H_
#define _FASTPRBG_H_

#include "corepol.h"
#include <arena.h>
#include "fastval.h"
#include "arrtempl.h"

// Storage class for property names and their associated data
class CFastPropertyBagItem
{
private:
	WString	m_wsPropertyName;
	BYTE	m_bRawData[MAXIMUM_FIXED_DATA_LENGTH];
	CIMTYPE	m_ctData;
	ULONG	m_uDataLength;
	ULONG	m_uNumElements;
	LPVOID	m_pvData;
	long	m_lRefCount;

public:

	CFastPropertyBagItem( LPCWSTR pszName, CIMTYPE ctData, ULONG uDataLength, ULONG uNumElements, LPVOID pvData );
	~CFastPropertyBagItem();

	// AddRef/Release methods
	ULONG	AddRef( void );
	ULONG	Release( void );

	BOOL IsPropertyName( LPCWSTR pszName )
	{	return m_wsPropertyName.EqualNoCase( pszName );	}

	void GetData( CIMTYPE* pct, ULONG* puDataLength, ULONG* puNumElements, LPVOID*ppvData )
	{ *pct = m_ctData;	*puDataLength = m_uDataLength;	*puNumElements = m_uNumElements; *ppvData = m_pvData; }
	void GetData( LPCWSTR* ppwszName, CIMTYPE* pct, ULONG* puDataLength, ULONG* puNumElements, LPVOID*ppvData )
	{ *ppwszName = m_wsPropertyName; *pct = m_ctData;	*puDataLength = m_uDataLength;
		*puNumElements = m_uNumElements; *ppvData = m_pvData; }
};

// Workaround for import/export issues
class COREPROX_POLARITY CPropertyBagItemArray : public CRefedPointerArray<CFastPropertyBagItem>
{
public:
	CPropertyBagItemArray() {};
	~CPropertyBagItemArray() {};
};

//***************************************************************************
//
//  class CFastPropertyBag
//
//  Implementation of our comless property bag
//
//***************************************************************************

class COREPROX_POLARITY CFastPropertyBag
{
protected:

	CPropertyBagItemArray	m_aProperties;

	// Locates an item
	CFastPropertyBagItem*	FindProperty( LPCWSTR pszName );
	// Locates an item
	int	FindPropertyIndex( LPCWSTR pszName );

public:

    CFastPropertyBag();
	virtual ~CFastPropertyBag(); 

	HRESULT Add( LPCWSTR pszName, CIMTYPE ctData, ULONG uDataLength, ULONG uNumElements, LPVOID pvData );
	HRESULT Get( LPCWSTR pszName, CIMTYPE* pctData, ULONG* puDataLength, ULONG* puNumElements, LPVOID* pvData );
	HRESULT Get( int nIndex, LPCWSTR* ppszName, CIMTYPE* pctData, ULONG* puDataLength, ULONG* puNumElements,
				LPVOID* pvData );
	HRESULT Remove( LPCWSTR pszName );
	HRESULT RemoveAll( void );

	HRESULT	Copy( const CFastPropertyBag& source );

	// How many are there?
	int Size( void ) { return m_aProperties.GetSize(); }
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\marshalers\coreprox\fastprop.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    FASTPROP.CPP

Abstract:

  This file implements the classes related to property representation 
  in WbemObjects

  Classes defined: 
      CPropertyInformation    Property type, location and qualifiers
      CPropertyLookup         Property name and information pointers.
      CPropertyLookupTable    Binary search table.
      CDataTable              Property data table
      CDataTableContainer     Anything that has a data table inside of it.

History:

    3/10/97     a-levn  Fully documented
    12//17/98   sanjes -    Partially Reviewed for Out of Memory.

--*/

#include "precomp.h"
#include "wbemutil.h"
#include "fastall.h"
#include <genlex.h>
#include <opathlex.h>
#include <objpath.h>
#include <CWbemTime.h>
#include <arrtempl.h>
 

//******************************************************************************
//
//  See fastprop.h for documentation
//
//******************************************************************************
void CPropertyInformation::WritePropagatedHeader(CFastHeap* pOldHeap,
                CPropertyInformation* pDest, CFastHeap* pNewHeap)
{
    pDest->nType = CType::MakeParents(nType);
    pDest->nDataOffset = nDataOffset;
    pDest->nDataIndex = nDataIndex;
    pDest->nOrigin = nOrigin;
}
//******************************************************************************
//
//  See fastprop.h for documentation
//
//******************************************************************************
BOOL CPropertyInformation::IsRef(CFastHeap* pHeap)
{
    return (CType::GetActualType(nType) == CIM_REFERENCE);
}
    
HRESULT CPropertyInformation::ValidateRange(CFastHeap* pHeap, CDataTable* pData,
                                            CFastHeap* pDataHeap)
{
    if(pData->IsNull(nDataIndex))
        return WBEM_S_NO_ERROR;

    if(pData->IsDefault(nDataIndex))
        return WBEM_S_NO_ERROR;

    if(CType::GetBasic(nType) == CIM_OBJECT)
    {
        // Get the cimtype qualifier
        // =========================

        CQualifier* pQual = CBasicQualifierSet::GetQualifierLocally(
            GetQualifierSetData(), pHeap, L"cimtype");
        if(pQual == NULL)
            return WBEM_S_NO_ERROR; // impossible
        
        CVar vCimType;

        // Check for allocation failure
        if ( !pQual->Value.StoreToCVar(vCimType, pHeap) )
        {
            return WBEM_E_OUT_OF_MEMORY;
        }

        if(vCimType.GetType() != VT_BSTR)
            return WBEM_S_NO_ERROR; // impossible

        LPCWSTR wszCimType = vCimType.GetLPWSTR();
        if(!wbem_wcsicmp(wszCimType, L"object"))
            return WBEM_S_NO_ERROR; // no restrictions

        LPCWSTR wszClassName = wszCimType + 7; // "object:"

        CUntypedValue* pValue = pData->GetOffset(nDataOffset);
        
        if(CType::IsArray(nType))
        {
            HRESULT hr = WBEM_S_NO_ERROR;
            CUntypedArray* pArrValue = (CUntypedArray*)
                pDataHeap->ResolveHeapPointer(*(PHEAPPTRT)pValue);
    
            for(int i = 0; i < pArrValue->GetNumElements(); i++)
            {
                heapptr_t ptrElement = 
                    *(PHEAPPTRT)(pArrValue->GetElement(i, sizeof(heapptr_t)));
                
                CEmbeddedObject* pEmbObj = (CEmbeddedObject*)
                    pDataHeap->ResolveHeapPointer(ptrElement);

                // Check for errors and WBEM_S_FALSE
                hr = ValidateObjectRange(pEmbObj, wszClassName);
                
                if ( WBEM_S_NO_ERROR != hr )
                {
                    return hr;
                }

            }

            return hr;
        }
        else
        {
            CEmbeddedObject* pEmbObj = (CEmbeddedObject*)
                    pDataHeap->ResolveHeapPointer(*(PHEAPPTRT)pValue);
            return ValidateObjectRange(pEmbObj, wszClassName);
        }
    }
        
    if(CType::GetBasic(nType) != CIM_REFERENCE &&
        CType::GetBasic(nType) != CIM_DATETIME)
    {
        return WBEM_S_NO_ERROR;
    }

    CUntypedValue* pValue = pData->GetOffset(nDataOffset);
    
    if(CType::IsArray(nType))
    {
        HRESULT hr = WBEM_S_NO_ERROR;
        CUntypedArray* pArrValue = (CUntypedArray*)
            pDataHeap->ResolveHeapPointer(*(PHEAPPTRT)pValue);

        for(int i = 0; i < pArrValue->GetNumElements(); i++)
        {
            heapptr_t ptrElement = 
                *(PHEAPPTRT)(pArrValue->GetElement(i, sizeof(heapptr_t)));
            CCompressedString* pcsValue = pDataHeap->ResolveString(ptrElement);

            // Check for errors and WBEM_S_FALSE
            hr = ValidateStringRange(pcsValue);
            if ( WBEM_S_NO_ERROR != hr )
            {
                return hr;
            }
        }

        return hr;
    }
    else
    {
        CCompressedString* pcsValue = 
            pDataHeap->ResolveString(*(PHEAPPTRT)pValue);
        return ValidateStringRange(pcsValue);
    }
}
        
HRESULT CPropertyInformation::ValidateObjectRange(CEmbeddedObject* pEmbObj,
                                                LPCWSTR wszClassName)
{
    CWbemObject* pObj = pEmbObj->GetEmbedded();
    if(pObj == NULL)
        return TRUE;

    HRESULT hr = pObj->InheritsFrom((LPWSTR)wszClassName);
    pObj->Release();
    return hr;
}

HRESULT CPropertyInformation::ValidateStringRange(CCompressedString* pcsValue)
{
    if(CType::GetBasic(nType) == CIM_REFERENCE)
    {
        // Free the string when we fall out of scope
        BSTR strPath = pcsValue->CreateBSTRCopy();
        CSysFreeMe  sfm( strPath );

        // Check for allocation failures
        if ( NULL == strPath )
        {
            return WBEM_E_OUT_OF_MEMORY;
        }

        CObjectPathParser Parser;
        ParsedObjectPath* pOutput = NULL;
        BOOL bRet = 
            (Parser.Parse(strPath, &pOutput) == CObjectPathParser::NoError &&
                pOutput->IsObject());
        delete pOutput;

        return ( bRet ? WBEM_S_NO_ERROR : WBEM_S_FALSE );
    }
    else if(CType::GetBasic(nType) == CIM_DATETIME)
    {
        return ValidateDateTime(pcsValue);
    }
    else return WBEM_S_NO_ERROR;
}

HRESULT CPropertyInformation::ValidateDateTime(CCompressedString* pcsValue)
{
    if(pcsValue->IsUnicode())
        return WBEM_S_FALSE;

    // Pre-test
    // ========

    LPCSTR sz = (LPCSTR)pcsValue->GetRawData();
    if(strlen(sz) != 25)
        return WBEM_S_FALSE;

    if(sz[14] != '.' && sz[14] != '*')
        return WBEM_S_FALSE;

    if(sz[21] != ':' && sz[21] != '-' && sz[21] != '+' && sz[21] != '*')
        return WBEM_S_FALSE;

    for(int i = 0; i < 25; i++)
    {
        if(i == 21 || i == 14)
            continue;
        if(sz[i] != '*' && !wbem_isdigit(sz[i]))
            return WBEM_S_FALSE;
    }

    // Passed pre-test. Check if any stars were specified
    // ==================================================

    if(strchr(sz, '*'))
    {
        // No further checking
        return WBEM_S_NO_ERROR;
    }

    if(sz[21] == ':')
    {
        // Interval -- no checking
        return WBEM_S_NO_ERROR;
    }

    // Cleanup the BSTR when we fall out of scope
    BSTR str = pcsValue->CreateBSTRCopy();
    CSysFreeMe  sfm( str );

    // Check for allocation failures
    if ( NULL == str )
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    CWbemTime Time;
    BOOL bRes = Time.SetDMTF(str);
    return ( bRes ? WBEM_S_NO_ERROR : WBEM_S_FALSE);
}

//******************************************************************************
//******************************************************************************
//******************************************************************************

//******************************************************************************
//
//  See fastprop.h for documentation
//
//******************************************************************************
BOOL CPropertyLookup::IsIncludedUnderLimitation(IN CWStringArray* pwsNames,
                                             IN CFastHeap* pCurrentHeap)
{
    // DEVNOTE:MEMORY:RETVAL - This function should really return an HRESULT

    if(pwsNames == NULL)
    {
        return TRUE;
    }

    // Only properties in the array must be included
    // =============================================

    // From here we will throw an exception.  It will be up to the outside
    // to deal with it.
    BSTR strName = pCurrentHeap->ResolveString(ptrName)->CreateBSTRCopy();
    CSysFreeMe  sfm( strName );

    if ( NULL == strName )
    {
        throw CX_MemoryException();
    }

    int nRes = pwsNames->FindStr(strName, CWStringArray::no_case);

    if(nRes != CWStringArray::not_found)
    {
        return TRUE;
    }

    return FALSE;
}
        
size_t CPropertyLookupTable::ValidateBuffer(LPMEMORY start, size_t cbMax )
{
	if (cbMax < sizeof(int)) throw CX_Exception();
	CPropertyLookupTable probe;
	probe.SetData(start, 0);
	size_t step = probe.GetLength();
	if (step > cbMax) throw CX_Exception();
	return step;
};
//******************************************************************************
//
//  See fastprop.h for documentation
//
//******************************************************************************
HRESULT CPropertyLookupTable::InsertProperty(LPCWSTR wszName, Type_t nType, int& nReturnIndex)
{
    // Determine where the new property will go in the data table
    // ==========================================================

    CFastHeap* pHeap = m_pContainer->GetHeap();

    int nNewOffset = 0;
    int nNewIndex = 0;
    int nNewType = nType;

    for(int i = 0; i < *m_pnProps; i++)
    {
        CPropertyInformation* pInfo = (CPropertyInformation*)
            pHeap->ResolveHeapPointer(GetAt(i)->ptrInformation);

        int nAfterOffset = pInfo->nDataOffset + CType::GetLength(pInfo->nType);
        if(nAfterOffset > nNewOffset)
        {
            nNewOffset = nAfterOffset;
        }

        if(pInfo->nDataIndex + 1 > nNewIndex)
        {
            nNewIndex = pInfo->nDataIndex + 1;
        }
    }

    // Get more space in the data table
    // ================================

    int nValueLen = CType::GetLength(nType);

    // WARNING: next line may result in rebase call on ourselves!!!
    if (!m_pContainer->GetDataTable()->ExtendTo( (propindex_t) nNewIndex, nNewOffset + nValueLen))
    	return WBEM_E_OUT_OF_MEMORY;

    // Create property information structure (no qualifiers)
    // =====================================================

    // Check for allocation failure.
    heapptr_t ptrInformation;
    if ( !pHeap->Allocate(CPropertyInformation::GetMinLength(), ptrInformation) )
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    if (wcslen(wszName) > 2 && wszName[0] == L'_')
    {
        nNewType |= CIMTYPE_EX_PARENTS;
    }

    ((CPropertyInformation*)pHeap->ResolveHeapPointer(ptrInformation))->
        SetBasic(nNewType, (propindex_t) nNewIndex, nNewOffset, 
        m_pContainer->GetCurrentOrigin());

    // NULL the data out in the data table
    // ===================================

    memset((void*)(m_pContainer->GetDataTable()->GetOffset(nNewOffset)),
        0xFF, nValueLen);
    m_pContainer->GetDataTable()->SetNullness(nNewIndex, TRUE);

    // Create the lookup node
    // ======================

    CPropertyLookup Lookup;

    // Check for allocation failure.
    if ( !pHeap->CreateNoCaseStringHeapPtr(wszName, Lookup.ptrName) )
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    Lookup.ptrInformation = ptrInformation;

    return InsertProperty(Lookup, nReturnIndex);
}


//******************************************************************************
//
//  See fastprop.h for documentation
//
//******************************************************************************
HRESULT CPropertyLookupTable::InsertProperty(const CPropertyLookup& Lookup, int& nReturnIndex)
{
    // Get more space from the container
    // =================================

    if ( !m_pContainer->ExtendPropertyTableSpace(GetStart(), GetLength(), 
            GetLength() + sizeof(CPropertyLookup)) )
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    // Search for the place to insert
    // ==============================

    CFastHeap* pHeap = m_pContainer->GetHeap();
    CCompressedString* pcsNewName = pHeap->ResolveString(Lookup.ptrName);

    int nIndex = 0;
    while(nIndex < *m_pnProps)
    {
        CCompressedString* pcsPropName = pHeap->ResolveString(
            GetAt(nIndex)->ptrName);

        int nCompare = pcsNewName->CompareNoCase(*pcsPropName);
        if(nCompare == 0)
        {
            // Found the property with the same name
            // =====================================

            // Delete old value
            // ================

            CPropertyInformation* pOldInfo = (CPropertyInformation*)
                pHeap->ResolveHeapPointer(GetAt(nIndex)->ptrInformation);
            
            pOldInfo->Delete(pHeap);
            pHeap->Free(GetAt(nIndex)->ptrInformation, pOldInfo->GetLength());

            // Copy new value
            // ==============

            GetAt(nIndex)->ptrInformation = Lookup.ptrInformation;

            // Delete new property name from the heap --- already there
            // ========================================================

            pHeap->FreeString(Lookup.ptrName);
            
            nReturnIndex = nIndex;
            return WBEM_NO_ERROR;
        }
        else if(nCompare > 0)
        {
            // Still not there
            // ===============

            nIndex++;
        }
        else // nCompare < 0
        {
            // Found insertion point. Move everything else to the right
            // ========================================================

            memmove((void*)GetAt(nIndex+1), (void*)GetAt(nIndex),
                sizeof(CPropertyLookup)*(*m_pnProps-nIndex));

            (*m_pnProps)++;

            // Copy our node here
            // ==================

            memcpy((void*)GetAt(nIndex), (void*)&Lookup,
                sizeof(CPropertyLookup));

            nReturnIndex = nIndex;
            return WBEM_NO_ERROR;
        }
    }

    // If here, we finished the list without finding a place.
    // Add it at the end
    // ======================================================

    memcpy((void*)GetAt(*m_pnProps), (void*)&Lookup, 
            sizeof(CPropertyLookup));

    (*m_pnProps)++;

    nReturnIndex = (*m_pnProps - 1);
    return WBEM_NO_ERROR;

}

//******************************************************************************
//
//  See fastprop.h for documentation
//
//******************************************************************************
void CPropertyLookupTable::DeleteProperty(CPropertyLookup* pLookup, int nFlags)
{
    CFastHeap* pHeap = m_pContainer->GetHeap();
    CDataTable* pDataTable = m_pContainer->GetDataTable();
    CPropertyInformation* pInfo = pLookup->GetInformation(pHeap);

    if(nFlags == e_UpdateDataTable)
    {
        // Shift all the properties in the data table
        // ==========================================

        CFastHeap* pHeap2 = m_pContainer->GetHeap();
        CPropertyInformation* pInfoToDelete = (CPropertyInformation*)
            pHeap2->ResolveHeapPointer(pLookup->ptrInformation);
        int nDataSize = CType::GetLength(pInfoToDelete->nType);

        for(int i = 0; i < *m_pnProps; i++)
        {
            CPropertyInformation* pPropInfo = (CPropertyInformation*)
                pHeap2->ResolveHeapPointer(GetAt(i)->ptrInformation);
            if(pPropInfo->nDataOffset > pInfoToDelete->nDataOffset)
            {
                pPropInfo->nDataOffset -= nDataSize;
            }
            if(pPropInfo->nDataIndex > pInfoToDelete->nDataIndex)
            {
                pPropInfo->nDataIndex--;
            }
        }

        // Inform the data table that it is now shorter
        // ============================================

        // WARNING: this may rebase us!
        pDataTable->RemoveProperty(
            pInfoToDelete->nDataIndex, pInfoToDelete->nDataOffset, nDataSize);
    }

    // Delete all information associated with this property from the heap
    // ==================================================================

    pLookup->Delete(pHeap);

    // Collapse this location in the data table
    // ========================================

    // DEVNOTE:WIN64:SJS - 64-bit pointer values truncated into 
    // signed/unsigned 32-bit value.  We do not support length
    // > 0xFFFFFFFF, so cast is ok.

    int nSizeOfTail = *m_pnProps - (int) (pLookup+1 - GetAt(0));

    memmove(pLookup, pLookup + 1, sizeof(CPropertyLookup)*nSizeOfTail);
    m_pContainer->ReducePropertyTableSpace(GetStart(), 
        GetLength(), sizeof(CPropertyLookup));

    // Adjust our length
    // =================

    (*m_pnProps)--;
}


//******************************************************************************
//
//  See fastprop.h for documentation
//
//******************************************************************************
LPMEMORY CPropertyLookupTable::Merge(
                  CPropertyLookupTable* pParentTable, CFastHeap* pParentHeap,
                  CPropertyLookupTable* pChildTable, CFastHeap* pChildHeap,
                  LPMEMORY pDest, CFastHeap* pNewHeap, BOOL bCheckValidity)
{
    // IMPORTANT: THIS FUNCTION ASSUMES THAT THERE IS ENOUGH FREE SPACE ON THE
    // NEW HEAP, THAT pDest will never be moved.
    // =======================================================================


    // Prepare the destination
    // =======================

    CPropertyLookup* pCurrentEnd = (CPropertyLookup*)(pDest + sizeof(int));

    int nParentIndex = 0, nChildIndex = 0;
    while(nParentIndex < pParentTable->GetNumProperties() &&
          nChildIndex < pChildTable->GetNumProperties())
    {
        // Compare property names
        // ======================

        CPropertyLookup* pParentLookup = pParentTable->GetAt(nParentIndex);
        CPropertyLookup* pChildLookup = pChildTable->GetAt(nChildIndex);

        int nCompare = pParentHeap->ResolveString(pParentLookup->ptrName)->
            CompareNoCase(*pChildHeap->ResolveString(pChildLookup->ptrName));

        if(nCompare < 0)
        {
            // Take parent's property
            // ======================

            // Check for memory allocation failures
            if ( !pParentLookup->WritePropagatedVersion(pCurrentEnd,
                    pParentHeap, pNewHeap) )
            {
                return NULL;
            }

            nParentIndex++;
        }
        else if(nCompare > 0)
        {
            // Take child's property
            // =====================

            memcpy(pCurrentEnd, pChildLookup, sizeof(CPropertyLookup));
            CStaticPtr CurrentEnd((LPMEMORY)pCurrentEnd);

            // Check for memory allocation failures
            if ( !CPropertyLookup::TranslateToNewHeap(&CurrentEnd, pChildHeap, 
                                                      pNewHeap) )
            {
                return NULL;
            }

            nChildIndex++;
        }
        else
        {
            // Merge them together
            // ===================

            // Check for memory allocation failures
            if ( !CCompressedString::CopyToNewHeap(
                    pParentLookup->ptrName, pParentHeap, pNewHeap,
                    pCurrentEnd->ptrName) )
            {
                return NULL;
            }

            // Compute the space that merged property information will take
            // up on the heap
            // ============================================================

            CPropertyInformation* pParentInfo = 
                pParentLookup->GetInformation(pParentHeap);
            CPropertyInformation* pChildInfo = 
                pChildLookup->GetInformation(pChildHeap);

            if(bCheckValidity)
            {
                if(CType::GetActualType(pParentInfo->nType) != 
                    CType::GetActualType(pChildInfo->nType))
                    return NULL;

                if(pParentInfo->nDataOffset != pChildInfo->nDataOffset ||
                    pParentInfo->nDataIndex != pChildInfo->nDataIndex)
                {
                    return NULL;
                }
            }
                           
            int nMergedQualifiersLen = CBasicQualifierSet::ComputeMergeSpace(
                pParentInfo->GetQualifierSetData(), pParentHeap,
                pChildInfo->GetQualifierSetData(), pChildHeap);

		if (nMergedQualifiersLen == -1) return NULL;
            // Allocate it on the heap and set up information header
            // =====================================================

            // Check for memory allocation failures
            if ( !pNewHeap->Allocate(
                    CPropertyInformation::GetHeaderLength() + 
                    nMergedQualifiersLen, pCurrentEnd->ptrInformation) )
            {
                return NULL;
            }

            CPropertyInformation* pMergeInfo = (CPropertyInformation*)
                pNewHeap->ResolveHeapPointer(pCurrentEnd->ptrInformation);

            // This call does no allocations so don't worry about leaks.
            pParentInfo->WritePropagatedHeader(pParentHeap, 
                                      pMergeInfo, pNewHeap);

            if ( CBasicQualifierSet::Merge(
                    pParentInfo->GetQualifierSetData(), pParentHeap,
                    pChildInfo->GetQualifierSetData(), pChildHeap,
                    pMergeInfo->GetQualifierSetData(), pNewHeap, 
                    bCheckValidity
                    ) == NULL )
            {
                return NULL;
            }

            nParentIndex++;
            nChildIndex++;
        }
        /* end of comparing two properties by name */

        pCurrentEnd++;
    }
    
    while(nParentIndex < pParentTable->GetNumProperties())
    {
        // Take parent's property
        // ======================

        CPropertyLookup* pParentLookup = pParentTable->GetAt(nParentIndex);


        // Check for memory allocation failures
        if ( !pParentLookup->WritePropagatedVersion(pCurrentEnd,
                        pParentHeap, pNewHeap ) )
        {
            return NULL;
        }

        nParentIndex++;
        pCurrentEnd++;
    }

    while(nChildIndex < pChildTable->GetNumProperties())
    {    
        // Take child's property
        // =====================

        CPropertyLookup* pChildLookup = pChildTable->GetAt(nChildIndex);
        memcpy(pCurrentEnd, pChildLookup, sizeof(CPropertyLookup));
        CStaticPtr CurrentEnd((LPMEMORY)pCurrentEnd);

        // Check for memory allocation failures
        if ( !CPropertyLookup::TranslateToNewHeap(&CurrentEnd, pChildHeap, 
                                                pNewHeap) )
        {
            return NULL;
        }

        nChildIndex++;
        pCurrentEnd++;
    }

    // Set the length
    // ==============

    // DEVNOTE:WIN64:SJS - 64-bit pointer values truncated into 
    // signed/unsigned 32-bit value. We do not support length
    // > 0xFFFFFFFF, so cast is ok.

    *(UNALIGNED int*)pDest = (int) ( pCurrentEnd - (CPropertyLookup*)(pDest + sizeof(int)) );

    return (LPMEMORY)pCurrentEnd;
}

//******************************************************************************
//
//  See fastprop.h for documentation
//
//******************************************************************************
LPMEMORY CPropertyLookupTable::Unmerge(CDataTable* pDataTable, 
                                       CFastHeap* pCurrentHeap,
                                       LPMEMORY pDest, CFastHeap* pNewHeap)
{
    // IMPORTANT: THIS FUNCTION ASSUMES THAT THERE IS ENOUGH FREE SPACE ON THE
    // NEW HEAP, THAT pDest will never be moved.
    // =======================================================================

    CPropertyLookup* pCurrentNew = (CPropertyLookup*)(pDest + sizeof(int));

    for(int i = 0; i < GetNumProperties(); i++)
    {
        CPropertyLookup* pCurrent = GetAt(i);
        CPropertyInformation* pInfo = pCurrent->GetInformation(pCurrentHeap);

        // Check if it is local
        // ====================

        if(!pInfo->IsOverriden(pDataTable))
        {
            continue;
        }

        // Add it to the unmerge
        // =====================

        // Check for allocation errors
        if ( !CCompressedString::CopyToNewHeap(
                pCurrent->ptrName, pCurrentHeap, pNewHeap,
                pCurrentNew->ptrName) )
        {
            return NULL;
        }
        
        // Check for allocation errors
        if ( !pInfo->ProduceUnmergedVersion(
                pCurrentHeap, pNewHeap,
                pCurrentNew->ptrInformation) )
        {
            return NULL;
        }

        pCurrentNew++;
    }

    // Set the length
    // ==============

    // DEVNOTE:WIN64:SJS - 64-bit pointer values truncated into 
    // signed/unsigned 32-bit value. We do not support length
    // > 0xFFFFFFFF, so cast is ok.

    *(UNALIGNED int*)pDest = (int) ( pCurrentNew - (CPropertyLookup*)(pDest + sizeof(int)) );

    return (LPMEMORY)pCurrentNew;
}


//******************************************************************************
//
//  See fastprop.h for documentation
//
//******************************************************************************
LPMEMORY CPropertyLookupTable::WritePropagatedVersion(
       CFastHeap* pCurrentHeap, 
       LPMEMORY pDest, CFastHeap* pNewHeap)
{
    // IMPORTANT: THIS FUNCTION ASSUMES THAT THERE IS ENOUGH FREE SPACE ON THE
    // NEW HEAP, THAT pDest will never be moved.
    // =======================================================================

    *(UNALIGNED int*)pDest = GetNumProperties();
    CPropertyLookup* pCurrentNew = (CPropertyLookup*)(pDest + sizeof(int));

    for(int i = 0; i < GetNumProperties(); i++)
    {
        CPropertyLookup* pCurrent = GetAt(i);
        CPropertyInformation* pInfo = pCurrent->GetInformation(pCurrentHeap);

        // Check for allocation failures
        if ( !pCurrent->WritePropagatedVersion(pCurrentNew,
                pCurrentHeap, pNewHeap) )
        {
            return NULL;
        }

        pCurrentNew++;
    }

    return (LPMEMORY)pCurrentNew;
}

//*****************************************************************************
//
//  See fastprop.h for documentation
//
//******************************************************************************
BOOL CPropertyLookupTable::MapLimitation(
        IN long lFlags,
        IN CWStringArray* pwsNames,
        OUT CLimitationMapping* pMap)
{
    // This function will cleanup properly if an exception is thrown.  The caller is responsible for
    // catching the exception.

    CFastHeap* pCurrentHeap = GetHeap();

    int nCurrentIndex = 0;
    offset_t nCurrentOffset = 0;

    pMap->Build(GetNumProperties());
    pMap->SetFlags(lFlags);

    BOOL bIncludeKeys = TRUE;
    BOOL bIncludeAll = FALSE;
    if(pwsNames == NULL)
    {
        bIncludeAll = TRUE;
    }
    else if(pwsNames->FindStr(L"__RELPATH", CWStringArray::no_case) ==
                                                CWStringArray::not_found)
    {
        if(pwsNames->FindStr(L"__PATH", CWStringArray::no_case) ==
                                                CWStringArray::not_found)
        {
            bIncludeKeys = FALSE;
        }
    }

    pMap->SetAddChildKeys(bIncludeKeys);

    for(int i = 0; i < GetNumProperties(); i++)
    {
        CPropertyLookup* pCurrent = GetAt(i);

        // Check if this property is excluded
        // ==================================

        if(bIncludeAll ||
           pCurrent->IsIncludedUnderLimitation(pwsNames, pCurrentHeap) ||
           (bIncludeKeys && pCurrent->GetInformation(pCurrentHeap)->IsKey()))
        {
            // Include it. Determine the index and offset for it.
            // ==================================================

            CPropertyInformation* pOldInfo = 
                    pCurrent->GetInformation(pCurrentHeap);

            CPropertyInformation NewInfo;
            NewInfo.nType = pOldInfo->nType;
            NewInfo.nDataIndex = (propindex_t) nCurrentIndex;
            NewInfo.nDataOffset = nCurrentOffset;

            nCurrentOffset += CType::GetLength(pOldInfo->nType);
            nCurrentIndex++;
            
            // Add it to the map
            // =================

            pMap->Map(pOldInfo, &NewInfo, TRUE); // common for all
        }
    }

    pMap->SetVtableLength(nCurrentOffset, TRUE); // common

    return TRUE;
}

LPMEMORY CPropertyLookupTable::CreateLimitedRepresentation(
        IN CLimitationMapping* pMap,
        IN CFastHeap* pNewHeap,
        OUT LPMEMORY pDest,
        BOOL& bRemovedKeys)
{
    // IMPORTANT: THIS FUNCTION ASSUMES THAT THERE IS ENOUGH FREE SPACE ON THE
    // NEW HEAP, THAT pDest will never be moved.
    // =======================================================================

    bRemovedKeys = FALSE;

    CPropertyLookup* pFirstLookup = (CPropertyLookup*)(pDest + sizeof(int));
    CPropertyLookup* pCurrentNew = pFirstLookup;
    CFastHeap* pCurrentHeap = GetHeap();

    int nCurrentIndex = pMap->GetNumMappings();
    offset_t nCurrentOffset = pMap->GetVtableLength();
    BOOL bIncludeKeys = pMap->ShouldAddChildKeys();

    for(int i = 0; i < GetNumProperties(); i++)
    {
        CPropertyLookup* pCurrent = GetAt(i);
        CPropertyInformation* pInfo = pCurrent->GetInformation(pCurrentHeap);

        // Check if this property is excluded
        // ==================================

        CPropertyInformation* pNewInfoHeader = pMap->GetMapped(pInfo);

        if (pNewInfoHeader)
        {
            CLimitationMapping::COnePropertyMapping * pOne = CONTAINING_RECORD(pNewInfoHeader,CLimitationMapping::COnePropertyMapping,m_NewInfo);
            CPropertyInformation* pOldInfoHeader = &pOne->m_OldInfo;
            if (CType::GetActualType(pOldInfoHeader->nType) != CType::GetActualType(pInfo->nType) ||            	
            	pOldInfoHeader->nDataOffset != pInfo->nDataOffset ||
            	pOldInfoHeader->nDataIndex  != pInfo->nDataIndex )
            {
#ifdef DBG            
                DbgPrintfA(0,"Mismatched Class Part\n"
                	         "CLimitationMapping %p Old Info %p Info %p\n",
                	         pMap,pOldInfoHeader,pInfo);
#endif                
            	return NULL;
            }
        }
        
        CPropertyInformation NewInfo;

        if(pNewInfoHeader == NULL && bIncludeKeys && pInfo->IsKey())
        {
            // We need to add all our keys --- __RELPATH was requested
            // =======================================================

            NewInfo.nType = pInfo->nType;
            NewInfo.nDataIndex = (propindex_t) nCurrentIndex;
            NewInfo.nDataOffset = nCurrentOffset;
            pNewInfoHeader = &NewInfo;

            pMap->Map(pInfo, &NewInfo, FALSE); // specific to this class

            nCurrentOffset += CType::GetLength(pInfo->nType);
            nCurrentIndex++;
        }
            
        if(pNewInfoHeader != NULL)
        {
            // Copy the name
            // =============

            // Check for allocation failures
            if ( !CCompressedString::CopyToNewHeap(
                    pCurrent->ptrName, pCurrentHeap, pNewHeap,
                    pCurrentNew->ptrName) )
            {
                return NULL;
            }

            // Check if the qualifiers are needed.
            // ===================================

            CPropertyInformation* pNewInfo;
            if(pMap->GetFlags() & WBEM_FLAG_EXCLUDE_PROPERTY_QUALIFIERS)
            {
                // Just copy the property header with empty qualifiers
                // ===================================================

                int nLength = CPropertyInformation::GetMinLength();
                
                // Check for allocation failures
                if ( !pNewHeap->Allocate(nLength, pCurrentNew->ptrInformation) )
                {
                    return NULL;
                }

                pNewInfo =  pCurrentNew->GetInformation(pNewHeap);
                pNewInfo->SetBasic(pInfo->nType, 
                    pNewInfoHeader->nDataIndex, pNewInfoHeader->nDataOffset,
                    pInfo->nOrigin);
            }
            else
            {
                // Make a complete copy
                // ====================

                // Check for allocation failures
                if ( !CPropertyInformation::CopyToNewHeap(
                            pCurrent->ptrInformation, pCurrentHeap, pNewHeap,
                            pCurrentNew->ptrInformation) )
                {
                    return NULL;
                }

                pNewInfo = pCurrentNew->GetInformation(pNewHeap);
                pNewInfo->nDataIndex = pNewInfoHeader->nDataIndex;
                pNewInfo->nDataOffset = pNewInfoHeader->nDataOffset;
            }
                
            pCurrentNew++;
        }
        else
        {
            if(pInfo->IsKey())
            {
                // Key not included!
                bRemovedKeys = TRUE;
            }
        }
    }

    pMap->SetVtableLength(nCurrentOffset, FALSE); // this class only

    // DEVNOTE:WIN64:SJS - 64-bit pointer values truncated into 
    // signed/unsigned 32-bit value. We do not support length
    // > 0xFFFFFFFF, so cast is ok.

    *(UNALIGNED int*)pDest = (int) ( pCurrentNew - pFirstLookup );

    return (LPMEMORY)pCurrentNew;
}


HRESULT CPropertyLookupTable::ValidateRange(BSTR* pstrName, CDataTable* pData,
                                            CFastHeap* pDataHeap)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    CFastHeap* pHeap = GetHeap();

    for(int i = 0; i < GetNumProperties(); i++)
    {
        CPropertyLookup* pCurrent = GetAt(i);
        CPropertyInformation* pInfo = pCurrent->GetInformation(pHeap);

        // Check for a failure (such as out of memory)
        hr = pInfo->ValidateRange(pHeap, pData, pDataHeap);

        if ( FAILED( hr ) )
        {
            return hr;
        }

        // If we had an invalid property store it's name
        if ( WBEM_S_FALSE == hr )
        {
            if(pstrName)
            {
                *pstrName = 
                    pHeap->ResolveString(pCurrent->ptrName)->CreateBSTRCopy();

                // Check for allocation failures
                if ( NULL == *pstrName )
                {
                    return WBEM_E_OUT_OF_MEMORY;
                }

            }
            return hr;
        }
    }

    return WBEM_S_NO_ERROR;
}
            
    
//***************************************************************************
//***************************************************************************
//***************************************************************************
//***************************************************************************

size_t CDataTable::ValidateBuffer(LPMEMORY start, size_t cbMax, int nProps)
{
	size_t step = CNullnessTable::GetNecessaryBytes(nProps);
	if (step>cbMax) throw CX_Exception();
	return cbMax;
};
//******************************************************************************
//
//  See fastprop.h for documentation
//
//******************************************************************************
BOOL CDataTable::ExtendTo(propindex_t nMaxIndex, offset_t nOffsetBound)
{
    // Check if the nullness table needs expantion
    // ===========================================

    int nTableLenDiff = CNullnessTable::GetNecessaryBytes(nMaxIndex+1) -
        GetNullnessLength();
    if(nTableLenDiff > 0)
    {
        if (!m_pContainer->ExtendDataTableSpace(GetStart(), 
            GetLength(), GetNullnessLength() + nTableLenDiff+nOffsetBound))
            return FALSE;

        // Move the actual data
        // ====================
        memmove(m_pData + nTableLenDiff, m_pData, GetDataLength());
        m_pData += nTableLenDiff;
    }
    else
    {
	     if (!m_pContainer->ExtendDataTableSpace(GetStart(), 
            GetLength(), GetNullnessLength() + nOffsetBound))
            return FALSE;
    }

    m_nProps = nMaxIndex+1;
    m_nLength += nTableLenDiff;

    // Expand the data
    // ===============

    // data table is expanded in the first alloc
    m_nLength = GetNullnessLength() + nOffsetBound;

    return TRUE;
}


//******************************************************************************
//
//  See fastprop.h for documentation
//
//******************************************************************************
void CDataTable::RemoveProperty(propindex_t nIndex, offset_t nOffset, 
                                length_t nLength)
{
    // Remove that index from the bit table (collapsing it)
    // ====================================================

    m_pNullness->RemoveBitBlock(nIndex, GetNullnessLength());
    m_nProps--;
    int nTableLenDiff = 
        GetNullnessLength() - CNullnessTable::GetNecessaryBytes(m_nProps);
    if(nTableLenDiff > 0)
    {
        // Move the data back by one
        // =========================

        memmove(m_pData-nTableLenDiff, m_pData, GetDataLength());
        m_pData -= nTableLenDiff;
        m_nLength -= nTableLenDiff;
    }

    // Collapse the area of memory occupied by the property
    // ====================================================

    memmove(GetOffset(nOffset), GetOffset(nOffset+nLength),
        GetDataLength() - nLength - nOffset);

    // Give space back to container
    // ============================

    m_pContainer->ReduceDataTableSpace(GetStart(), GetLength(), 
        nLength + nTableLenDiff);

    m_nLength -= nLength;
}

//******************************************************************************
//
//  See fastprop.h for documentation
//
//******************************************************************************
LPMEMORY CDataTable::Merge( 
        CDataTable* pParentData, CFastHeap* pParentHeap,
        CDataTable* pChildData, CFastHeap* pChildHeap,
        CPropertyLookupTable* pProperties, LPMEMORY pDest, CFastHeap* pNewHeap)
{
    // IMPORTANT: THIS FUNCTION ASSUMES THAT THERE IS ENOUGH FREE SPACE ON THE
    // NEW HEAP, THAT pDest will never be moved.
    // =======================================================================

    // First of all, copy child's data table to the destination.
    // =========================================================

    memcpy(pDest, pChildData->GetStart(), pChildData->GetLength());

    // (Note, that no heap translation has been performed)

    // Set up a new CDataTable on this copy
    // ====================================

    CDataTable NewData;
    NewData.SetData(pDest, pProperties->GetNumProperties(), 
        pChildData->m_nLength, NULL);

    // Iterate over all the child's properties (the property table is using
    // the NEW heap!!!
    // ====================================================================

    for(int i = 0; i < pProperties->GetNumProperties(); i++)
    {
        CPropertyLookup* pLookup = pProperties->GetAt(i);
        CPropertyInformation* pInfo = pLookup->GetInformation(pNewHeap);
        
        // Check if this property is marked as DEFAULT
        // ===========================================

        if(NewData.IsDefault(pInfo->nDataIndex))
        {
            // Copy it from the parent
            // =======================

            if(pParentData->IsNull(pInfo->nDataIndex))
            {
                NewData.SetNullness(pInfo->nDataIndex, TRUE);
            }
            else
            {
                CStaticPtr Source(
                    (LPMEMORY)(pParentData->GetOffset(pInfo->nDataOffset)));
                CStaticPtr Dest((LPMEMORY)(NewData.GetOffset(pInfo->nDataOffset)));

                // Check for memory allocation failures
                if ( !CUntypedValue::CopyTo(
                        &Source, CType::GetActualType(pInfo->nType),
                        &Dest,
                        pParentHeap, pNewHeap) )
                {
                    return NULL;
                }
            }
        }
        else
        {
            // Translate it from the child
            // ===========================

            if(!NewData.IsNull(pInfo->nDataIndex))
            {                
                CStaticPtr Source(
                    (LPMEMORY)(NewData.GetOffset(pInfo->nDataOffset)));

                // Check for memory allocation failures
                if ( !CUntypedValue::TranslateToNewHeap(
                        &Source, 
                        CType::GetActualType(pInfo->nType),
                        pChildHeap, pNewHeap) )
                {
                    return NULL;
                }

            }   // IF !IsNull()

        }   // if-else IsDefault()

    }   // FOR EnumProperties

    return EndOf(NewData);
}

//******************************************************************************
//
//  See fastprop.h for documentation
//
//******************************************************************************
LPMEMORY CDataTable::Unmerge(CPropertyLookupTable* pLookupTable,
        CFastHeap* pCurrentHeap, LPMEMORY pDest, CFastHeap* pNewHeap)
{
    // IMPORTANT: THIS FUNCTION ASSUMES THAT THERE IS ENOUGH FREE SPACE ON THE
    // NEW HEAP, THAT pDest will never be moved.
    // =======================================================================

    // Start by copying the whole thing
    // ================================

    memcpy(pDest, GetStart(), GetLength());

    // Now copy to the heap overriden values (if pointers)
    // ===================================================

    for(int i = 0; i < pLookupTable->GetNumProperties(); i++)
    {
        CPropertyLookup* pLookup = pLookupTable->GetAt(i);
        CPropertyInformation* pInfo = pLookup->GetInformation(pCurrentHeap);
        
        // Check if this property is marked as DEFAULT
        // ===========================================

        if(!IsDefault(pInfo->nDataIndex))
        {
            // Real value. Translate to the new heap
            // =====================================

            if(!IsNull(pInfo->nDataIndex))
            {
                CStaticPtr Source(pDest + GetNullnessLength() + 
                                    pInfo->nDataOffset);

                // Check for allocation errors
                if ( !CUntypedValue::TranslateToNewHeap(
                        &Source,
                        CType::GetActualType(pInfo->nType),
                        pCurrentHeap, pNewHeap) )
                {
                    return NULL;
                }   // IF !TranslateToNewHeap

            }   // IF !IsNull

        }   // IF !IsDefault

    }   // FOR enumproperties

    return pDest + GetLength();
}

//******************************************************************************
//
//  See fastprop.h for documentation
//
//******************************************************************************
LPMEMORY CDataTable::WritePropagatedVersion(CPropertyLookupTable* pLookupTable,
        CFastHeap* pCurrentHeap, LPMEMORY pDest, CFastHeap* pNewHeap)
{
    // IMPORTANT: THIS FUNCTION ASSUMES THAT THERE IS ENOUGH FREE SPACE ON THE
    // NEW HEAP, THAT pDest will never be moved.
    // =======================================================================

    // Copy the whole thing
    // ====================

    memcpy(pDest, GetStart(), GetLength());

    CNullnessTable* pDestBitTable = (CNullnessTable*)pDest;

    // Copy individual values
    // ======================

    for(int i = 0; i < pLookupTable->GetNumProperties(); i++)
    {
        CPropertyLookup* pLookup = pLookupTable->GetAt(i);
        CPropertyInformation* pInfo = pLookup->GetInformation(pCurrentHeap);
        
        // Translate to the new heap
        // =========================

        if(!IsNull(pInfo->nDataIndex))
        {
            CStaticPtr Source(pDest + GetNullnessLength() + pInfo->nDataOffset);

            // Check for allocation failures
            if ( !CUntypedValue::TranslateToNewHeap(
                    &Source,
                    CType::GetActualType(pInfo->nType),
                    pCurrentHeap, pNewHeap) )
            {
                return NULL;
            }
        }
        
        // Mark as having default value
        // ============================

        pDestBitTable->SetBit(pInfo->nDataIndex, e_DefaultBit, TRUE);
    }

    return pDest + GetLength();
}

//******************************************************************************
//
//  See fastprop.h for documentation
//
//******************************************************************************
BOOL CDataTable::TranslateToNewHeap(CPropertyLookupTable* pLookupTable,
        BOOL bIsClass,
        CFastHeap* pCurrentHeap, CFastHeap* pNewHeap)
{
    // IMPORTANT: THIS FUNCTION ASSUMES THAT THERE IS ENOUGH FREE SPACE ON THE
    // NEW HEAP, THAT pDest will never be moved.
    // =======================================================================

    BOOL    fReturn = TRUE;

    // Copy individual values
    // ======================

    for(int i = 0; i < pLookupTable->GetNumProperties(); i++)
    {
        CPropertyLookup* pLookup = pLookupTable->GetAt(i);
        CPropertyInformation* pInfo = pLookup->GetInformation(
            pLookupTable->GetHeap());
        
        // Make sure this instance sets it to something!
        // =============================================

        if(IsDefault(pInfo->nDataIndex) && !bIsClass) continue;

        // Translate to the new heap
        // =========================

        if(!IsNull(pInfo->nDataIndex))
        {
            CStaticPtr Source(m_pData + pInfo->nDataOffset);

            // Check for allocation failure.
            fReturn = CUntypedValue::TranslateToNewHeap(
                    &Source,
                    CType::GetActualType(pInfo->nType),
                    pCurrentHeap, pNewHeap);

            if ( !fReturn ) 
            {
                break;
            }
        }
    }

    return fReturn;
}

//*****************************************************************************
//
//  See fastprop.h for documentation
//
//******************************************************************************
//        CPropertyLookupTable* pOldTable, CPropertyLookupTable* pNewTable, 
LPMEMORY CDataTable::CreateLimitedRepresentation(
        CLimitationMapping* pMap, BOOL bIsClass,
        CFastHeap* pOldHeap,  CFastHeap* pNewHeap, 
        LPMEMORY pDest)
{
    // IMPORTANT: THIS FUNCTION ASSUMES THAT THERE IS ENOUGH FREE SPACE ON THE
    // NEW HEAP, THAT pDest will never be moved.
    // =======================================================================

    // Figure out the size of the nullness table
    // =========================================

    CNullnessTable* pDestBitTable = (CNullnessTable*)pDest;
    int nNullnessLength = 
        CNullnessTable::GetNecessaryBytes(pMap->GetNumMappings());
    LPMEMORY pData = pDest + nNullnessLength;

    // Enumerate all property mappings
    // ===============================

    pMap->Reset();
    CPropertyInformation NewInfo;
    CPropertyInformation OldInfo;
    while(pMap->NextMapping(&OldInfo, &NewInfo))
    {
        // Copy the nullness data for the property
        // =======================================

        pDestBitTable->SetBit(NewInfo.nDataIndex, e_NullnessBit,
            IsNull(OldInfo.nDataIndex));
        pDestBitTable->SetBit(NewInfo.nDataIndex, e_DefaultBit,
            IsDefault(OldInfo.nDataIndex));

        // Copy the real data for the property
        // ===================================

        if(!IsNull(OldInfo.nDataIndex) && 
            (bIsClass || !IsDefault(OldInfo.nDataIndex)))
        {
            CStaticPtr OldSource((LPMEMORY)GetOffset(OldInfo.nDataOffset));
            CStaticPtr NewSource(pData + NewInfo.nDataOffset);

            // Check for allocation failures
            if ( !CUntypedValue::CopyTo(&OldSource, OldInfo.nType, &NewSource, 
                    pOldHeap, pNewHeap) )
            {
                return NULL;
            }
        }
    }

    return pData + pMap->GetVtableLength();
}

LPMEMORY CDataTable::WriteSmallerVersion(int nNumProps, length_t nDataLen, 
                                            LPMEMORY pMem)
{
    // Calculate the length of the nullness portion
    // ============================================

    length_t nNullnessLength = CNullnessTable::GetNecessaryBytes(nNumProps);
    
    // Copy nullness
    // =============

    LPMEMORY pCurrent = pMem;
    memcpy(pCurrent, (LPMEMORY)m_pNullness, nNullnessLength);
    pCurrent += nNullnessLength;

    // Copy data
    // =========

    memcpy(pCurrent, m_pData, nDataLen - nNullnessLength);
    
    return pCurrent + nDataLen - nNullnessLength;
}

//*****************************************************************************
//*****************************************************************************
//*****************************************************************************

//*****************************************************************************
//
//  See fastprop.h for documentation
//
//******************************************************************************
CLimitationMapping::CLimitationMapping()
    : m_nCurrent(0), m_apOldList(NULL), m_nNumCommon(0), 
#ifdef DEBUG_CLASS_MAPPINGS
        m_pClassObj( NULL ),
#endif
        m_nCommonVtableLength(0)
{
}

//*****************************************************************************
//
//  See fastprop.h for documentation
//
//******************************************************************************

CLimitationMapping::~CLimitationMapping()
{
    for(int i = 0; i < m_aMappings.Size(); i++)
    {
        delete (COnePropertyMapping*)m_aMappings[i];
    }

    delete [] m_apOldList;

#ifdef DEBUG_CLASS_MAPPINGS
    if ( NULL != m_pClassObj )
    {
        m_pClassObj->Release();
    }
#endif
}


//*****************************************************************************
//
//  See fastprop.h for documentation
//
//******************************************************************************
void CLimitationMapping::Build(int nPropIndexBound)
{
    if(m_apOldList)
        delete [] (LPMEMORY)m_apOldList;
    m_apOldList = new CPropertyInformation*[nPropIndexBound];

    if ( NULL == m_apOldList )
    {
        throw CX_MemoryException();
    }

    memset((void*)m_apOldList, 0,
            nPropIndexBound * sizeof(CPropertyInformation*));

    m_nPropIndexBound = nPropIndexBound;
}

//*****************************************************************************
//
//  See fastprop.h for documentation
//
//******************************************************************************
void CLimitationMapping::Map(
        COPY CPropertyInformation* pOldInfo,
        COPY CPropertyInformation* pNewInfo,
        BOOL bCommon)
{
    // Add it to property location map
    // ===============================

    COnePropertyMapping* pOne = new COnePropertyMapping;

    if ( NULL == pOne )
    {
        throw CX_MemoryException();
    }

    CopyInfo(pOne->m_OldInfo, *pOldInfo);
    CopyInfo(pOne->m_NewInfo, *pNewInfo);

    // Check for OOM
    if ( m_aMappings.Add((LPVOID)pOne) != CFlexArray::no_error )
    {
    	 delete pOne;
        throw CX_MemoryException();
    }

    if(bCommon)
        m_nNumCommon = m_aMappings.Size();

    // Add it to the inclusion list
    // ============================

    if(bCommon && m_apOldList)
        m_apOldList[pOldInfo->nDataIndex] = &pOne->m_NewInfo;
}

//*****************************************************************************
//
//  See fastprop.h for documentation
//
//******************************************************************************
BOOL CLimitationMapping::NextMapping(OUT CPropertyInformation* pOldInfo,
                                     OUT CPropertyInformation* pNewInfo)
{
    if(m_nCurrent == m_aMappings.Size()) return FALSE;
    COnePropertyMapping* pOne =
        (COnePropertyMapping*)m_aMappings[m_nCurrent++];
    CopyInfo(*pOldInfo, pOne->m_OldInfo);
    CopyInfo(*pNewInfo, pOne->m_NewInfo);
    return TRUE;
}

//*****************************************************************************
//
//  See fastprop.h for documentation
//
//******************************************************************************
propindex_t CLimitationMapping::GetMapped(
                        IN propindex_t nIndex)
{
    // Look up the data index in the inclusion table
    // =============================================

    if(m_apOldList == NULL)
    {
        // That means everything is included
        // =================================

        return nIndex;
    }

    if(nIndex >= m_nPropIndexBound)
    {
        // out of range of included properties
        // ===================================

        return -1;
    }

    return m_apOldList[nIndex]->nDataIndex;
}

//*****************************************************************************
//
//  See fastprop.h for documentation
//
//******************************************************************************
INTERNAL CPropertyInformation* CLimitationMapping::GetMapped(
                        IN CPropertyInformation* pOldInfo)
{
    // Look up the data index in the inclusion table
    // =============================================

    if(m_apOldList == NULL)
    {
        // That means everything is included
        // =================================

        return pOldInfo;
    }

    int nIndex = pOldInfo->nDataIndex;
    if(nIndex >= m_nPropIndexBound)
    {
        // out of range of included properties
        // ===================================

        return NULL;
    }

    return m_apOldList[nIndex];
}
//*****************************************************************************
//
//  See fastprop.h for documentation
//
//******************************************************************************
void CLimitationMapping::RemoveSpecific()
{
    // Remove all property mappings after m_nNumCommon
    // ===============================================

    while(m_nNumCommon < m_aMappings.Size())
    {
        delete (COnePropertyMapping*)m_aMappings[m_nNumCommon];
        m_aMappings.RemoveAt(m_nNumCommon);
    }

    m_nVtableLength = m_nCommonVtableLength;
}
BOOL CPropertyInformation::IsOverriden(CDataTable* pDataTable)
{
    return !CType::IsParents(nType) ||               // defined locally
           !pDataTable->IsDefault(nDataIndex) ||        // new default value
           CBasicQualifierSet::HasLocalQualifiers(   // new qualifiers
                GetQualifierSetData());
}

#ifdef DEBUG_CLASS_MAPPINGS
void CLimitationMapping::SetClassObject( CWbemClass* pClassObj )
{
    if ( NULL != pClassObj )
    {
        pClassObj->AddRef();
    }

    if ( NULL != m_pClassObj )
    {
        m_pClassObj->Release();
    }

    m_pClassObj = pClassObj;
}

HRESULT CLimitationMapping::ValidateInstance( CWbemInstance* pInst )
{
    if ( NULL == m_pClassObj )
    {
        return WBEM_E_FAILED;
    }

    if ( !pInst->IsInstanceOf( m_pClassObj ) )
    {
        return WBEM_E_FAILED;
    }

    return WBEM_S_NO_ERROR;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\marshalers\coreprox\fastprop.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    FASTPROP.H

Abstract:

  This file defines the classes related to property representation 
  in WbemObjects

  Classes defined: 
      CPropertyInformation    Property type, location and qualifiers
      CPropertyLookup         Property name and information pointers.
      CPropertyLookupTable    Binary search table.
      CDataTable              Property data table
      CDataTableContainer     Anything that has a data table inside of it.

History:

    3/10/97     a-levn  Fully documented
    12//17/98    sanjes -    Partially Reviewed for Out of Memory.

--*/

#ifndef __FAST_PROPERTY__H_
#define __FAST_PROPERTY__H_

// DEVNOTE:TODO - Take this OUT for final release.  It's just here to help us debug stuff
#define DEBUG_CLASS_MAPPINGS

#include "fastheap.h"
#include "fastval.h"
#include "fastqual.h"

//#pragma pack(push, 1)

//*****************************************************************************
//*****************************************************************************
//
//  class CPropertyInformation
//
//  This object represents all the information which comes with the definition
//  of a property, excluding its name and value. The name is stored in
//  CPropertyLookup (below). The value is stored separately in the CDataTable.
//
//  This is one of those classes where the 'this' pointer is pointing directly
//  to the data. The format of the data is:
//
//      Type_t nType            The type of the property (see fastval.h for 
//                              CType). One of the high bits is used to convey
//                              whether this property came from the parent.
//      propindex_t nDataIndex  The index of this property in the v-table for
//                              the class.
//      offset_t nDataOffset    The offset of the data for this property from
//                              the start of the v-table. Since the number of
//                              bytes a property takes up in a v-table is 
//                              defined by its type (strings and such are
//                              stored on the heap) this value does not change.
//
//      Qualifier Set. The data for the property qualifier set follows 
//                              immediately after the other tree fields. See
//                              fastqual.h for qualifier set data layout.
//
//*****************************************************************************
//
//  GetHeaderLength
//
//  RETURN VALUES:
//
//      length_t:   the number of bytes in the structure before the qualifier
//                  set data.
//
//*****************************************************************************
//
//  GetMinLength
//
//  RETURN VALUES:
//
//      length_t:   the number of bytes required for this structure assuming
//                  that the qualifier set is empty.
//
//*****************************************************************************
//
//  SetBasic
//
//  Sets the values of the header parameters and initializes the qualifier set
//  to an empty one. See the class header for parameter descriptions.
//
//  PARAMETERS:
//
//      Type_t _nType                   The type of the property
//      propindex_t _nDataIndex         The index in the v-table.
//      offset_t _nDataOffset           The offset in the v-table.
//
//*****************************************************************************
//
//  GetStart
//
//  RETURN VALUES:
//
//      LPMEMORY:   the start of the memory block
//
//*****************************************************************************
//
//  GetLength
//
//  RETURN VALUES:
//
//      length_t;   the total length of this structure
//
//*****************************************************************************
//
//  GetType
//
//  RETURN VALUES:
//
//      Type_t:     the type of the property
//
//*****************************************************************************
//
//  GetQualifierSetData
//
//  RETURN VALUES:
//
//      LPMEMORY:   the pointer to the qualifier set data (immediately after
//                  the header elements, see class header for details).
//
//*****************************************************************************
//
//  Delete
//
//  Removes any data associated with this structure from the associated heap. 
//  Basically, forwards the call to its qualifier set
//
//  PARAMETERS:
//
//      CFastHeap* pHeap        The heap to remove data from.
//
//*****************************************************************************
//
//  MarkAsParents
//
//  Sets the bit in the nType field which designates this property is one that
//  came from our parent class.
//
//*****************************************************************************
//
//  ComputeNecessarySpaceForPropagation
//
//  Computes how much space this structure will take when propagated to a child
//  class. The difference stems from the fact that not all 
//  qualifiers propagate (see fastqual.h for discussion of propagation). 
//
//  RETURN VALUES:
//
//      length_t: the number of bytes required to represent the propagated 
//                  structure.
//
//*****************************************************************************
//
//  WritePropagatedHeader
//
//  Fills in the header values for the corresponding structure in a child
//  object: an instance or a derived class. Basically, the values are the same
//  except for the fact that the "parent's" bit is set in the type field to
//  indicate that the property came from the parent
//
//  PARAMETERS:
//
//      CPropertyInformation* pDest     The destination structure.
//
//*****************************************************************************
//
//  static WritePropagatedVersion
//
//  Writes a complete propagated version of itself, including the header 
//  adjusted for propagation (see WritePropagatedHeader) and the propagated
//  qualifiers.
//
//  Since 'this' pointer of this class points directly to its memory block and
//  copying a qualifier set may require memory allocations which may in turn
//  move the memory block thus invalidating the 'this' pointer, pointer sources
//  are used instead (see CPtrSource in fastsprt.h).
//
//  PARAMETERS:
//
//      CPtrSource* pThis           The source for the 'this' pointer. 
//      CPtrSource* pDest           The source for the destination pointer.
//      CFastHeap* pOldHeap         The heap where we keep our extra data.
//      CFastHeap* pNewHeap         The heap where the propagated vesion should
//                                  keep its extra data.
//
//*****************************************************************************
//
//  static TranslateToNewHeap
//
//  Moves any data this object has on the heap to a different heap.  The data
//  is NOT freed from the old heap. 
//
//  Since 'this' pointer of this class points directly to its memory block and
//  copying a qualifier set may require memory allocations which may in turn
//  move the memory block thus invalidating the 'this' pointer, pointer sources
//  are used instead (see CPtrSource in fastsprt.h).
//
//  PARAMETERS:
//
//      CPtrSource* pThis           The source for the 'this' pointer. 
//      CFastHeap* pOldHeap         The heap where we keep our extra data.
//      CFastHeap* pNewHeap         The heap where we should keep our extra data
//      
//*****************************************************************************
//
//  static CopyToNewHeap
//
//  As this object almost always lives in a heap itself, this function copies
//  it to a different heap. The operation consists of physically transfering 
//  the bits and then translating internal objects (like qualifiers) to the
//  new heap as well.
//
//  NOTE: the data is not freed form the old heap.
//
//  PARAMETERS:
//
//      heapptr_t ptrInfo           The heap pointer to ourselves on the
//                                  original heap.
//      CFastHeap* pOldHeap         The original heap.
//      CFastHeap* pNewHeap         The heap to copy to.
//
//  RETURN VALUES:
//
//      heapptr_t:  the pointer to our copy on the new heap.
//
//*****************************************************************************
//
//  IsKey
//
//  This function determines if this property is a key by looking for the 'key'
//  qualifier in the qualifier set.
//
//  RETURN VALUES:
//
//      TRUE if the qualfier is there and has the value of TRUE.
//
//*****************************************************************************
//
//  IsIndexed
//
//  Determines if thius property is indexed by looking for the 'index' 
//  qualifier in the qualifier set. 
//
//  PARAMETERS:
//
//      CFastHeap* pHeap        The heap we are based in.
//
//  RETURN VALUES:
//
//      TRUE if the qualifier is there and has the value of TRUE.
//
//*****************************************************************************
//
//  CanBeNull
//
//  A property may not take on a value of NULL if it is marked with a not_null
//  qualifier. This function checks if this qualifier is present.
//
//  PARAMETERS:
//
//      CFastHeap* pHeap        The heap we are based in.
//
//  RETURN VALUES:
//
//      TRUE if the qualifier is NOT there or has the value of FALSE.
//
//*****************************************************************************
//
//  IsRef
//
//  PARAMETERS:
//
//      CFastHeap* pHeap        The heap we are based in.
//
//  RETURN VALUES:
//
//      TRUE iff this property is a reference, i.e. it has a 'syntax' qualifier
//          with a value of "ref" or "ref:<class name>".
//
//*****************************************************************************
//
//  IsOverriden
//
//  Checks if this (parents) property is overriden in this class. A property is
//  considered overriden if its default value has been changed or qualifiers
//  have been added or overriden.
//
//  PARAMETERS:
//
//      CDataTable* pData       The defaults table of this class (see below).
//
//  RETURN VALUES:
//
//      TRUE iff overriden.
//
//*****************************************************************************

// Special case property handles.  These should never happen because our actual maximum offset value
// is 8k (1024 QWORD properties), and we're using a whole 16-bit value for the offest
#define    FASTOBJ_CLASSNAME_PROP_HANDLE        0xFFFFFFFE
#define    FASTOBJ_SUPERCLASSNAME_PROP_HANDLE    0xFFFFFFFD

// Helper macros for IWbemObjetAccess

// Index will be a value from 0 to 1023
#define WBEM_OBJACCESS_HANDLE_GETINDEX(handle) (handle >> 16) & 0x3FF

// Maximum offset in the data table is ( 1024 * 8 ) - 1, whih is 0x18FF
#define WBEM_OBJACCESS_HANDLE_GETOFFSET(handle) handle & 0x1FFF

// 3 unused bits on DataTable offset are used for further type info
#define WBEM_OBJACCESS_ARRAYBIT        0x2000
#define WBEM_OBJACCESS_OBJECTBIT    0x4000
#define WBEM_OBJACCESS_STRINGBIT    0x8000

// Identifies the above bits
#define WBEM_OBJACCESS_HANDLE_ISARRAY(handle)    (BOOL) ( handle & WBEM_OBJACCESS_ARRAYBIT )
#define WBEM_OBJACCESS_HANDLE_ISOBJECT(handle)    (BOOL) ( handle & WBEM_OBJACCESS_OBJECTBIT )
#define WBEM_OBJACCESS_HANDLE_ISSTRING(handle)    (BOOL) ( handle & WBEM_OBJACCESS_STRINGBIT )

// If ARRAY String and Object are set, this is a reserved handle, since these are
// all exclusive of each other
#define WBEM_OBJACCESS_HANDLE_ISRESERVED(handle)    (BOOL)    ( WBEM_OBJACCESS_HANDLE_ISOBJECT(handle) &&\
                                                            WBEM_OBJACCESS_HANDLE_ISSTRING(handle) &&\
                                                            WBEM_OBJACCESS_HANDLE_ISARRAY(handle) )
                                                    
// This does a proper masking of the actual length (no more than 8 bytes)
#define WBEM_OBJACCESS_HANDLE_GETLENGTH(handle) (int) ( ( handle >> 26 ) & 0xF )

// Hi bit is used for IsPointer or not
#define WBEM_OBJACCESS_HANDLE_ISPOINTER(handle) handle & 0x80000000


// The data in this structure is unaligned
#pragma pack(push, 1)
class CPropertyInformation
{
public:
    Type_t nType;
    propindex_t nDataIndex;
    offset_t nDataOffset;
    classindex_t nOrigin;
    // followed by the qualifier set.

public:
    static length_t GetHeaderLength() 
    {
        return sizeof(Type_t) + sizeof(propindex_t) + sizeof(offset_t) +
                sizeof(heapptr_t);
    }

    static length_t GetMinLength() 
    {
        return GetHeaderLength() + CBasicQualifierSet::GetMinLength();
    }

    static CPropertyInformation* GetPointer(CPtrSource* pSource)
        {return (CPropertyInformation*)pSource->GetPointer();}
    void SetBasic(Type_t _nType, propindex_t _nDataIndex,
                            offset_t _nDataOffset, classindex_t _nOrigin)
    {
        nType = _nType;
        nDataIndex = _nDataIndex;
        nDataOffset = _nDataOffset;
        nOrigin = _nOrigin;
        CClassPropertyQualifierSet::SetDataToNone(GetQualifierSetData());
    }

    LPMEMORY GetStart() {return LPMEMORY(this);}
    Type_t GetType() {return nType;}
    LPMEMORY GetQualifierSetData() 
        {return LPMEMORY(this) + GetHeaderLength();}
    length_t GetLength() 
    {
        return GetHeaderLength() + 
            CClassPropertyQualifierSet::GetLengthFromData(
                                            GetQualifierSetData());
    }
    void Delete(CFastHeap* pHeap) 
        {CBasicQualifierSet::Delete(GetQualifierSetData(), pHeap);}

    void MarkAsParents()
        {nType = CType::MakeParents(nType);}

public:
    length_t ComputeNecessarySpaceForPropagation()
    {
        return GetHeaderLength() + 
            CClassPropertyQualifierSet::ComputeNecessarySpaceForPropagation(
                                GetQualifierSetData(), 
                                WBEM_FLAVOR_FLAG_PROPAGATE_TO_DERIVED_CLASS);
    }
    void WritePropagatedHeader(CFastHeap* pOldHeap,
                    CPropertyInformation* pDest, CFastHeap* pNewHeap);

    static BOOL WritePropagatedVersion(CPtrSource* pThis,
                                        CPtrSource* pDest,
                                        CFastHeap* pOldHeap, 
                                        CFastHeap* pNewHeap)
    {
        // No allocations performed by this call
        GetPointer(pThis)->WritePropagatedHeader(pOldHeap,
                                                GetPointer(pDest), pNewHeap);
        CShiftedPtr QSPtrThis(pThis, GetHeaderLength());
        CShiftedPtr QSPtrDest(pDest, GetHeaderLength());

        // Check for possible allocation errors
        return ( CClassPropertyQualifierSet::WritePropagatedVersion(
                        &QSPtrThis, WBEM_FLAVOR_FLAG_PROPAGATE_TO_DERIVED_CLASS, 
                        &QSPtrDest, pOldHeap, pNewHeap) != NULL );
    }

    BOOL ProduceUnmergedVersion(CFastHeap* pCurrentHeap,
                                CFastHeap* pNewHeap, UNALIGNED heapptr_t& ptrResult)
    {
        int nUnmergedSpace = CBasicQualifierSet::ComputeUnmergedSpace(
            GetQualifierSetData());

        // Check for allocation errors
        heapptr_t ptrNew;
        BOOL fReturn = pNewHeap->Allocate(GetHeaderLength()+nUnmergedSpace, ptrNew);

        if ( fReturn )
        {
            CPropertyInformation* pNewInfo = 
                (CPropertyInformation*) pNewHeap->ResolveHeapPointer(ptrNew);

            memcpy(pNewInfo, this, GetHeaderLength());

            // Check for allocation errors
            if ( CBasicQualifierSet::Unmerge(
                    GetQualifierSetData(), 
                    pCurrentHeap,
                    pNewInfo->GetQualifierSetData(), 
                    pNewHeap) != NULL )
            {
                ptrResult = ptrNew;
            }
            else
            {
                fReturn = FALSE;
            }

        }    // IF fReturn

        return fReturn;
    }

    static BOOL TranslateToNewHeap(CPtrSource* pThis,
                                      CFastHeap* pOldHeap, CFastHeap* pNewHeap)
    {
        CShiftedPtr QSPtr(pThis, GetHeaderLength());
        return CClassPropertyQualifierSet::TranslateToNewHeap(
                &QSPtr, pOldHeap, pNewHeap);
    }

    static BOOL CopyToNewHeap(heapptr_t ptrInfo, 
        CFastHeap* pOldHeap, CFastHeap* pNewHeap, UNALIGNED heapptr_t& ptrResult)
    {
        CPropertyInformation* pInfo = (CPropertyInformation*)
            pOldHeap->ResolveHeapPointer(ptrInfo);
        length_t nLen = pInfo->GetLength();

        // Check for allocation failure
        heapptr_t ptrNewInfo;
        BOOL fReturn = pNewHeap->Allocate(nLen, ptrNewInfo);

        if ( fReturn )
        {
            memcpy(
                pNewHeap->ResolveHeapPointer(ptrNewInfo),
                pOldHeap->ResolveHeapPointer(ptrInfo),
                nLen);

            CStaticPtr DestPtr(pNewHeap->ResolveHeapPointer(ptrNewInfo));

            // Check for allocation failure
            fReturn = TranslateToNewHeap(&DestPtr, pOldHeap, pNewHeap);
            if ( fReturn )
            {
                ptrResult = ptrNewInfo;
            }
        }
        
        return fReturn;
    }

    // Helper function to build a handle
    long GetHandle( void )
    {
        // 16-bits for offset
        long lHandle = nDataOffset;

        // 5-bits for length
        // Always set this for the basic type, so that with arrays,
        // we don't need to look up CIMTYPE to know what the size is
        lHandle |= (CType::GetLength(CType::GetBasic(nType))) << 26;

        // 10-bits for index
        lHandle |= (nDataIndex << 16);

        // 1-bit for IsPointer
        if(CType::IsPointerType(nType))
            lHandle |= 0x80000000;

        // For now, just experiment with this here
        Type_t    typeActual = CType::GetActualType(nType);
        Type_t    typeBasic = CType::GetBasic(nType);

        if ( CType::IsArray( typeActual ) )
        {
            lHandle |= WBEM_OBJACCESS_ARRAYBIT;
        }

        if ( CType::IsStringType( typeBasic ) )
        {
            lHandle |= WBEM_OBJACCESS_STRINGBIT;
        }
        else if ( CIM_OBJECT == typeBasic )
        {
            lHandle |= WBEM_OBJACCESS_OBJECTBIT;
        }

        return lHandle;
    }

public:
    BOOL IsKey() 
    {
        return CBasicQualifierSet::GetKnownQualifierLocally(
            GetQualifierSetData(), 
            CKnownStringTable::GetIndexOfKey()) != NULL;
    }

    BOOL IsIndexed(CFastHeap* pHeap) 
    {
        return CBasicQualifierSet::GetRegularQualifierLocally(
            GetQualifierSetData(), pHeap, L"indexed") != NULL;
    }

    BOOL CanBeNull(CFastHeap* pHeap)
    {
        if(IsKey()) return FALSE;
        if(IsIndexed(pHeap)) return FALSE;
        return CBasicQualifierSet::GetRegularQualifierLocally(
            GetQualifierSetData(), pHeap, L"not_null") == NULL;
    }


    BOOL IsRef(CFastHeap* pHeap);
    BOOL IsOverriden(class CDataTable* pDataTable);

    HRESULT ValidateRange(CFastHeap* pHeap, CDataTable* pData, 
                            CFastHeap* pDataHeap);
    HRESULT ValidateStringRange(CCompressedString* pcsValue);
    HRESULT ValidateDateTime(CCompressedString* pcsValue);
    HRESULT ValidateObjectRange(CEmbeddedObject* pEmbObj, LPCWSTR wszClassName);
};
#pragma pack(pop)

//*****************************************************************************
//*****************************************************************************
//
//  class CPropertyLookup
//
//  This simple structure is an element of the property lookup table 
//  (CPropertyLookupTable) described below. It contains the heap pointer to the
//  name of the property (ptrName to CCompressedString (see faststr.h)) and 
//  the heap pointer to the information of the property (ptrInformation to 
//  CPropertyInformation (see above)).
//
//*****************************************************************************
//
//  Delete
//
//  Removes all the information from the heap, namely the name and the
//  information structure (both of which can delete themselves).
//
//  PARAMETERS:
//
//      CFastHeap* pHeap        The heap where the data resides.
//
//*****************************************************************************
//
//  static TranslateToNewHeap
//
//  Moves all the data (the name and the information( to a different heap and
//  changes the structure members to the new heap pointer values.
//
//  Since 'this' pointer of this class points directly to its memory block and
//  copying a qualifier set may require memory allocations which may in turn
//  move the memory block thus invalidating the 'this' pointer, pointer sources
//  are used instead (see CPtrSource in fastsprt.h).
//
//  PARAMETERS:
//
//      CPtrSource* pThis           The source for the 'this' pointer. 
//      CFastHeap* pOldHeap         The heap where we keep our extra data.
//      CFastHeap* pNewHeap         The heap where we should keep our extra data
//      
//*****************************************************************************
//
//  IsIncludedUnderLimitation
//
//  This function determines if this property should be included in an object
//  limited by a "select" criteria.
//
//  PARAMETERS:
//
//      IN CWStringArray* pwsProps  If not NULL, specifies the array of names
//                                  for properties to include. Every other 
//                                  property will be excluded. This includes
//                                  system properties like SERVER and NAMESPACE.
//                                  If RELPATH is specified here, it forces
//                                  inclusion of all key properties. If PATH
//                                  is specified, it forces RELPATH, SERVER and
//                                  NAMESPACE.
//      IN CFastHeap* pCurrentHeap  The heap where our data resides.
//
//  RETURN VALUES:
//
//      BOOL:   TRUE if the property is included
//
//*****************************************************************************

// The data in this structure is unaligned
#pragma pack(push, 1)
struct CPropertyLookup
{
    /* fixed-sized structure for binary search for properties */
    heapptr_t ptrName; // CompressedString
    heapptr_t ptrInformation; // PropertyInformation_t

    static CPropertyLookup* GetPointer(CPtrSource* pSource) 
        {return (CPropertyLookup*)pSource->GetPointer();}
public:
    void Delete(CFastHeap* pHeap)
    {
        pHeap->FreeString(ptrName);
        CPropertyInformation* pInfo = (CPropertyInformation*)
            pHeap->ResolveHeapPointer(ptrInformation);
        pInfo->Delete(pHeap);
        pHeap->Free(ptrInformation, pInfo->GetLength());
    }

    static BOOL TranslateToNewHeap(CPtrSource* pThis,
        CFastHeap* pOldHeap, CFastHeap* pNewHeap)
    {
        BOOL    fReturn = TRUE;

        // Check for allocation failure
        heapptr_t ptrTemp;
        if ( !CCompressedString::CopyToNewHeap(
                GetPointer(pThis)->ptrName, pOldHeap, pNewHeap, ptrTemp) )
        {
            return FALSE;
        }

        GetPointer(pThis)->ptrName = ptrTemp;

        // Check for allocation failure
        if ( !CPropertyInformation::CopyToNewHeap(
                GetPointer(pThis)->ptrInformation, pOldHeap, pNewHeap, ptrTemp) )
        {
            return FALSE;
        }

        GetPointer(pThis)->ptrInformation = ptrTemp;

        return TRUE;
    }

    BOOL WritePropagatedVersion(CPropertyLookup* pDest,
                                        CFastHeap* pOldHeap, 
                                        CFastHeap* pNewHeap)
    {
        // Check for allocation failures
        if ( !CCompressedString::CopyToNewHeap(
                ptrName, pOldHeap, pNewHeap, pDest->ptrName) )
        {
            return FALSE;
        }

        length_t nInfoLen = GetInformation(pOldHeap)->
                                ComputeNecessarySpaceForPropagation();

        // Check for allocation failures
        if ( !pNewHeap->Allocate(nInfoLen, pDest->ptrInformation ) )
        {
            return FALSE;
        }

        CHeapPtr OldInfo(pOldHeap, ptrInformation);
        CHeapPtr NewInfo(pNewHeap, pDest->ptrInformation);

        return CPropertyInformation::WritePropagatedVersion(
                &OldInfo, &NewInfo, pOldHeap, pNewHeap);
    }
        
    CPropertyInformation* GetInformation(CFastHeap* pHeap)
    {
        return (CPropertyInformation*)pHeap->ResolveHeapPointer(ptrInformation);
    }

    BOOL IsIncludedUnderLimitation(
        IN CWStringArray* pwsNames,
        IN CFastHeap* pCurrentHeap);
};  
#pragma pack(pop)

class CLimitationMapping;

//*****************************************************************************
//*****************************************************************************
//
//  class CPropertyTableContainer
//
//  See CPropertyLookupTable class first. 
//
//  This class defines the capabilities required by CPropertyLookupTable of
//  the objects that contain its memory block within thewir own.
//
//*****************************************************************************
//
//  GetHeap
//
//  RETURN VALUES:
//
//      CFastHeap*:     the current heap.
//
//*****************************************************************************
//
//  ExtendPropertyTableSpace
//
//  Called when the property table needs more memory. If no more memory is 
//  avaiable at the end of the current block, the container must reallocate 
//  and move the table, calling Rebase with the new location.
//
//  PARAMETERS:
//
//      LPMEMORY pOld           Current memory block
//      length_t nOldLength     The current length of the block.
//      length_t nNewLength     The new length of the block.
//
//*****************************************************************************
//
//  ReduceProipertyTableSpace
//
//  Called when the property table returns memory to the system. The container
//  may NOT move the table's memory block in response to this call.
//
//  PARAMETERS:
//
//      LPMEMORY pOld           Current memory block
//      length_t nOldLength     The current length of the block.
//      length_t nDecrement     How much memory to return.
//
//*****************************************************************************
//  
//  GetDataTable
//
//  RETURN VALUES:
//
//      CDataTable*: the data table for this object (defaults for a class, 
//                      actual values for an instance).
//
//*****************************************************************************

class CPropertyTableContainer
{
public:
    virtual CFastHeap* GetHeap() = 0;
    virtual BOOL ExtendPropertyTableSpace(LPMEMORY pOld, 
        length_t nOldLength, length_t nNewLength) = 0;
    virtual void ReducePropertyTableSpace(LPMEMORY pOld, 
        length_t nOldLength, length_t nDecrement) = 0;
    virtual class CDataTable* GetDataTable() = 0;
    virtual classindex_t GetCurrentOrigin() = 0;
};

//*****************************************************************************
//*****************************************************************************
//
//  class CPropertyLookupTable
//
//  This is the table mapping property names to their information. Its memory
//  block has the following format: 
//      int nProps:     the number of properties in the table
//      followed by that many CPropertyLookup structures.
//  Since CPropertyLookup structures have fixed length, this class allows 
//  direct access to any property. The structures are sorted alphabetically
//  in a case-insensitive manner, so properties can be looked up using a binary
//  search.
//
//*****************************************************************************
//
//  SetData
//
//  Initializer.
//
//  PARAMETERS:
//
//      LPMEMORY pStart                         The memory block.
//      CPropertyTableContainer* pContainer     Container (see class def).
//
//*****************************************************************************
//
//  GetStart
//
//  RETURN VALUES:
//
//      LPMEMORY:   the pointer to the memory block
//
//*****************************************************************************
//
//  GetLength
//
//  RETURN VALUES:
//
//      length_t:   the length of the memory block
//
//*****************************************************************************
//
//  Skip
//
//  RETURN VALUES:
//
//      LPMEMORY:   the pointer to the first byte after the memory block
//
//*****************************************************************************
//
//  Rebase
//
//  Advises the object that its memory block has moved.
//
//  PARAMETERS:
//
//      LPMEMORY pNew       The new location of the memory block
//
//*****************************************************************************
//
//  GetNumProperties
//
//  RETURN VALUES:
//
//      int:    the number of properties in the table.
//
//*****************************************************************************
//
//  GetAt
//
//  Returns the pointer to the CPropertyLookup structure at a given position.
//  Range validation is not performed.
//
//  Parameters;
//
//      int nIndex      The index of THE STRUCTURE IN THE TABLE. This is NOT
//                      the v-table index of the property.
//  RETURN VALUES:
//
//      CPropertyLookup*    at the given position
//
//*****************************************************************************
//
//  FindProperty
//
//  Main method. Finds the property's CPropertyLookup structure given the name
//  of the property. Performs a binary search.
//
//  Parameters;
//
//      LPCWSTR wszName     The name of the property to find
//
//  RETURN VALUES:
//
//      CPropertyLookup*:   NULL if not found
//
//*****************************************************************************
//
//  FindPropertyByPtr
//
//  Finds the property's CPropertyLookup structure given the heap pointer to
//  the property's name. While binary search is not possible in this case,
//  pointer comparison is so much faster that string comparison that this 
//  method is much more efficient that FindProperty.
//
//  PARAMETERS:
//
//      heapptr_t ptrName       Heap pointer to the name of the property.
//
//  RETURN VALUES:
//
//      CPropertyLookup*:   NULL if not found
//
//*****************************************************************************
//
//  InsertProperty
//
//  Inserts a new property into the lookup table as well as into the 
//  corrseponding data table. First of all, it traverses the lookup table to
//  find the smallest free location in the v-table for this class. Based on
//  that, it creates the property information (CPropertyInformation) structure.
//  Finally, it inserts the appropriate CPropertyLookup structure into the
//  alphabetically appropriate place in the list
//
//  PARAMETERS:
//
//      LPCWSTR wszName     The name of the property
//      Type_t nType        The type of the property (see CType in fastval.h)
//
//  RETURN VALUES:
//
//      int:    the index of the new property in this table (NOT THE INDEX
//                  IN THE V_TABLE!)
//
//*****************************************************************************
//
//  DeleteProperty
//
//  Removes a property from the lookup table as well as from the data table.
//  First of all, it determines how much space the property took in the v-table
//  and collapses that location. This involves updating the indeces and the 
//  offsets of all the properties that came after it. Finally, it removes the
//  CPropertyLookup structure from the lookup table.
//
//  PARAMETERS:
//
//      CPropertyLookup* pLookup        The property to remove
//      int nFlags                      Must be e_UpdateDataTable.
//
//*****************************************************************************
//
//  static GetMinLength
//
//  Returns the minimum space required to hold a property lookup table (for 0
//  properties).
//
//  RETURN VALUES:
//
//      length_t: number of bytes.
//
//*****************************************************************************
//
//  static CreateEmpty
//
//  Creates an empty lookup tahle (for 0 properties) on a given memory block.
//
//  PARAMETERS:
//
//      LPMEMORY pMemory        Where to create
//
//  RETURN VALUES:
//
//      LPMEMORY: the first byte after the table.
//
//*****************************************************************************
//
//  static Merge
//
//  Invoked when a derived-most portion of a class is merged with the parent
//  to create the combined class definition. Only the overriden properties are
//  stored in the database for the derived class, and even then only the info
//  that has actually changed is stored. 
//
//  PARAMETERS:
//
//      CPropertyLookupTable* pParentTable  The parent lookup table.
//      CFastHeap* pParentHeap              The heap where the parent keeps
//                                          extra data.
//      CPropertyLookupTable* pChildTable   The child lookup table.
//      CFastHeap* pChildHeap               The heap where the child keeps
//                                          extra data.
//      LPMEMORY pDest                      Destination memory block. Assumed
//                                          to be large enough to contain the
//                                          merged lookup table.
//      CFastHeap* pNewHeap                 Destinatio heap.ASSUMED TO BE LARGE
//                                          ENOUGH THAT NO ALLOCATION WILL 
//                                          CAUSE IOT TO RELOCATE!
//      BOOL bCheckValidity                 If TRUE, child qualifier overrides
//                                          are checked for not violating 
//                                          parents override restrictions.
//                                          (see fastqual.h)
//  RETURN VALUES:
//
//      LPMEMORY:   the first byte after the merge.
//
//*****************************************************************************
//
//  Unmerge
//
//  Called when a derived class is about to be written into the database. This
//  function extracts the information in the child which is different from the
//  parent, i.e. only those properties that are overriden (see IsOverriden in
//  CProeprtyInformation). The result can later be Merge'd with the parent
//  class to recreate the complete definition.
//
//  PARAMETERS:
//
//      CDataTable* pDataTable      The data table wher the property data is
//                                  stored. It is used to check if a property
//                                  has been overriden.
//      CFastHeap* pCurrentHeap     The heap where we keep extra data.
//      LPMEMORY pDest              Destination memoty block. Assumed  to be 
//                                  large enough to hold the result. 
//      CFastHeap* pNewHeap         Destination heap. ASSUMED TO BE LARGE 
//                                  ENOUGH THAT NO ALLOCATION WILL CAUSE IT
//                                  TO RELOCATE!
//  RETURN VALUES:
//
//      LPMEMORY:   the first byte after the unmerge.
//
//*****************************************************************************
//
//  WritePropagatedVersion
//
//  Invoked when a new derived class is created. Writes a propagated version
//  of all the properties to the destination memory block: all marked as
//  parent's and with only propagating qualifiers included.
//
//  PARAMETERS:
//
//      CFastHeap* pCurrentHeap     The heap where we keep the data.
//      LPMEMORY pDest              Destination memory block. Assumed  to be 
//                                  large enough to hold the result. 
//      CFastHeap* pNewHeap         Destination heap. ASSUMED TO BE LARGE 
//                                  ENOUGH THAT NO ALLOCATION WILL CAUSE IT
//                                  TO RELOCATE!
//  RETURN VALUES:
//
//      LPMEMORY:   the first byte after the propagated version
//
//*****************************************************************************
//
//  CreateLimitedRepresentation
//
//  Creates a limited representation of this table on a given block of 
//  memory as described in EstimateLimitedRepresentationLength in fastobj.h.
//  Basically, it removes all the excluded properties and optionally removes
//  the qualifiers.
//
//  PARAMETERS:
//
//      IN long lFlags              The flags specifying what information to 
//                                  exclude. Can be any combination of these:
//                                  WBEM_FLAG_EXCLUDE_OBJECT_QUALIFIERS:
//                                      No class or instance qualifiers.
//                                  WBEM_FLAG_EXCLUDE_PROPERTY_QUALIFIERS:
//                                      No property qualifiers
//
//      IN CWStringArray* pwsProps  If not NULL, specifies the array of names
//                                  for properties to include. Every other 
//                                  property will be excluded. This includes
//                                  system properties like SERVER and NAMESPACE.
//                                  If RELPATH is specified here, it forces
//                                  inclusion of all key properties. If PATH
//                                  is specified, it forces RELPATH, SERVER and
//                                  NAMESPACE.
//      IN CFastHeap* pNewHeap      The heap to use for all out-of-table data.
//      OUT LPMEMORY pDest          Destination for the representation. Must
//                                  be large enough to contain all the data ---
//                                  see EstimateLimitedRepresentationSpace.
//      OUT CPropertyMapping* pMap  If not NULL, property mappings are placed
//                                  into this object. See CPropertyMapping for 
//                                  details.
//  RETURN VALUES:
//
//      LPMEMORY:   NULL on failure, pointer to the first byte after the data
//                  written on success.
//
//*****************************************************************************

class COREPROX_POLARITY CPropertyLookupTable
{
protected:
    PUNALIGNEDINT m_pnProps; // beginning of the structure
    CPropertyTableContainer* m_pContainer;
public:
    void SetData(LPMEMORY pStart, CPropertyTableContainer* pContainer)
    {
        m_pnProps = (PUNALIGNEDINT)pStart;
        m_pContainer = pContainer;
    }

	static size_t ValidateBuffer(LPMEMORY start, size_t cbSize);
	
    LPMEMORY GetStart() {return LPMEMORY(m_pnProps);}
    int GetLength() 
        {return sizeof(int) + sizeof(CPropertyLookup)* *m_pnProps;}
    LPMEMORY Skip() {return GetStart() + GetLength();}
    void Rebase(LPMEMORY pNewMemory) {m_pnProps = (PUNALIGNEDINT)pNewMemory;}

public:
    int GetNumProperties() {return *m_pnProps;}
    CPropertyLookup* GetAt(int nIndex) 
    {
        // DEVNOTE:WIN64:SANJ - 
        //
        // Original code:
        // return (CPropertyLookup*)
        //            (GetStart() + sizeof(int) + sizeof(CPropertyLookup)* nIndex);
        //
        // This is NOT portable to WIN64 if nIndex is ever negative, in which case
        // since the sizeof() operands are unsigned, nIndex is treated as unsigned
        // which is a large 32-bit value, which when added unsigned to GetStart()
        // which in Win64 is a 64-bit pointer, generates a very large 64-bit value.
        //
        // This compiles with no problems, so to fix it, I cast the entire 32-bit
        // portion of this statement as an int, so the compiler knows that the
        // final value is signed.
        //

        return (CPropertyLookup*)
            ( GetStart() + (int) ( sizeof(int) + sizeof(CPropertyLookup) * nIndex ) );
    }

    CFastHeap* GetHeap() {return m_pContainer->GetHeap();}
    CPropertyLookup* FindProperty(LPCWSTR wszName)
    {
        CFastHeap* pHeap = m_pContainer->GetHeap();

        // Only continue if the number of properties is >= 1.

        if ( *m_pnProps >= 1 )
        {
            CPropertyLookup* pLeft = GetAt(0);
            CPropertyLookup* pRight = GetAt(*m_pnProps-1);

            while(pLeft <= pRight)
            {
                CPropertyLookup* pNew = pLeft + (pRight-pLeft)/2;
                int nCompare = pHeap->ResolveString(pNew->ptrName)->
                                    CompareNoCase(wszName);
            
                if(nCompare == 0)
                {
                    return pNew;
                }
                else if(nCompare > 0)
                {
                    pRight = pNew-1;
                }
                else 
                {
                    pLeft = pNew+1;
                }
            }

        }    // IF *m_pnProps >= 1

        return NULL;
    }
    CPropertyLookup* FindPropertyByName(CCompressedString* pcsName)
    {
        CFastHeap* pHeap = m_pContainer->GetHeap();
        CPropertyLookup* pLeft = GetAt(0);
        CPropertyLookup* pRight = GetAt(*m_pnProps-1);
        while(pLeft <= pRight)
        {
            CPropertyLookup* pNew = pLeft + (pRight-pLeft)/2;
            int nCompare = pHeap->ResolveString(pNew->ptrName)->
                                CompareNoCase(*pcsName);
            
            if(nCompare == 0)
            {
                return pNew;
            }
            else if(nCompare > 0)
            {
                pRight = pNew-1;
            }
            else 
            {
                pLeft = pNew+1;
            }
        }

        return NULL;
    }
    
    CPropertyLookup* FindPropertyByPtr(heapptr_t ptrName)
    {
        for(int i = 0; i < *m_pnProps; i++)
        {
            if(GetAt(i)->ptrName == ptrName) 
                return GetAt(i);
        }
        return NULL;
    }

    CPropertyLookup* FindPropertyByOffset(offset_t nOffset)
    {
        CFastHeap* pHeap = GetHeap();
        for(int i = 0; i < *m_pnProps; i++)
        {
            if(GetAt(i)->GetInformation(pHeap)->nDataOffset == nOffset) 
                return GetAt(i);
        }
        return NULL;
    }

    enum {e_DontTouchDataTable, e_UpdateDataTable};

    HRESULT InsertProperty(LPCWSTR wszName, Type_t nType, int& nReturnIndex);
    HRESULT InsertProperty(const CPropertyLookup& Lookup, int& nReturnIndex);
    void DeleteProperty(CPropertyLookup* pLookup, int nFlags);
public:
    static length_t GetMinLength() {return sizeof(int);}
    static LPMEMORY CreateEmpty(LPMEMORY pStart)
    {
        *(PUNALIGNEDINT)pStart = 0;
        return pStart + sizeof(int);
    }
public:
   static LPMEMORY Merge(CPropertyLookupTable* pParentTable, 
       CFastHeap* pParentHeap, 
       CPropertyLookupTable* pChildTable,  CFastHeap* pChildHeap, 
       LPMEMORY pDest, CFastHeap* pNewHeap, BOOL bCheckValidity = FALSE);

   LPMEMORY Unmerge(CDataTable* pDataTable, CFastHeap* pCurrentHeap,
       LPMEMORY pDest, CFastHeap* pNewHeap);

   LPMEMORY WritePropagatedVersion(CFastHeap* pCurrentHeap,
       LPMEMORY pDest, CFastHeap* pNewHeap);

   BOOL MapLimitation(
        IN long lFlags,
        IN CWStringArray* pwsNames,
        IN OUT CLimitationMapping* pMap);

   LPMEMORY CreateLimitedRepresentation(
        IN OUT CLimitationMapping* pMap,
        IN CFastHeap* pNewHeap,
        OUT LPMEMORY pDest,
        BOOL& bRemovedKeys);

    HRESULT ValidateRange(BSTR* pstrName, CDataTable* pData, CFastHeap* pDataHeap);
};

//*****************************************************************************
//*****************************************************************************

// forward definitions
#ifdef DEBUG_CLASS_MAPPINGS
class CWbemClass;
class CWbemInstance;
#endif

class COREPROX_POLARITY CLimitationMapping
{
public:
    struct COnePropertyMapping
    {
        CPropertyInformation m_OldInfo;
        CPropertyInformation m_NewInfo;
    };
protected:
    CFlexArray m_aMappings; // COnePropertyMapping*
    int m_nNumCommon;
    int m_nCurrent;

    offset_t m_nVtableLength;
    offset_t m_nCommonVtableLength;

    long m_lFlags;
    BOOL m_bIncludeServer;
    BOOL m_bIncludeNamespace;
    BOOL m_bIncludeDerivation;

    CPropertyInformation** m_apOldList;
    int m_nPropIndexBound;
    BOOL m_bAddChildKeys;

#ifdef DEBUG_CLASS_MAPPINGS
    CWbemClass*    m_pClassObj;
#endif

protected:
    void CopyInfo(OUT CPropertyInformation& Dest,
                         IN const CPropertyInformation& Source)
    {
        memcpy((LPVOID)&Dest, (LPVOID)&Source, 
            CPropertyInformation::GetHeaderLength());
    }
public:
    CLimitationMapping();
    ~CLimitationMapping();

    void Build(int nPropIndexBound);

    void Map(COPY CPropertyInformation* pOldInfo, 
            COPY CPropertyInformation* pNewInfo,
            BOOL bCommon);

    void Reset() { m_nCurrent = 0; }
    BOOL NextMapping(OUT CPropertyInformation* pOldInfo,
                     OUT CPropertyInformation* pNewInfo);

    int GetNumMappings() {return m_aMappings.Size();}
    void RemoveSpecific();

    void SetVtableLength(offset_t nLen, BOOL bCommon) 
    {
        m_nVtableLength = nLen;
        if(bCommon) m_nCommonVtableLength = nLen;
    }
    offset_t GetVtableLength() {return m_nVtableLength;}

    void SetFlags(long lFlags) {m_lFlags = lFlags;}
    long GetFlags() {return m_lFlags;}

    void SetIncludeServer(BOOL bInclude) {m_bIncludeServer = bInclude;}
    BOOL ShouldIncludeServer() {return m_bIncludeServer;}

    void SetIncludeNamespace(BOOL bInclude) 
        {m_bIncludeNamespace = bInclude;}
    BOOL ShouldIncludeNamespace() {return m_bIncludeNamespace;}

    void SetIncludeDerivation(BOOL bInclude) 
        {m_bIncludeDerivation = bInclude;}
    BOOL ShouldIncludeDerivation() {return m_bIncludeDerivation;}

    void SetAddChildKeys(BOOL bAdd) 
        {m_bAddChildKeys = bAdd;}
    BOOL ShouldAddChildKeys() {return m_bAddChildKeys;}

    BOOL ArePropertiesLimited() {return m_apOldList != NULL;}
    propindex_t GetMapped(propindex_t nPropIndex);
    INTERNAL CPropertyInformation* GetMapped(
                        READ_ONLY CPropertyInformation* pOldInfo);

#ifdef DEBUG_CLASS_MAPPINGS
    void SetClassObject( CWbemClass* pClassObj );
    HRESULT ValidateInstance( CWbemInstance* pInst );
#endif

};

//***************************************************************************
//***************************************************************************
//
//  class CDataTableContainer
//
//  See CDataTable class below first.
//
//  This class encapsulates the functionality required by CDataTable class of
//  any objectwhose memory block contains that of the data table.
//
//***************************************************************************
//
//  GetHeap
//
//  RETURN VALUES:
//
//      CFastHeap*  the heap currently in use.
//
//***************************************************************************
//
//  ExtendDataTableSpace
//
//  Called by the data table when it required more memory for its memory 
//  block. If the container must relocate the memory block in order to grow
//  it, it must inform the data table of the new location by calling Rebase
//
//  PARAMETERS:
//
//      LPMEMORY pOld       The current location of the memory block
//      length_t nLength    The curent length of the memory block
//      length_t nNewLength the desired length of the memory block
//
//***************************************************************************
//
//  ReduceDataTableSpace
//
//  Called by the data table when it wants to return some of its memory to 
//  the container. The container may NOT relocate the memory block in response
//  to this call.
//
//  PARAMETERS:
//
//      LPMEMORY pOld       The current location of the memory block
//      length_t nLength    The curent length of the memory block
//      length_t nDecrement How many bytes to return.
//
//***************************************************************************
class  CDataTableContainer
{
public:
    virtual CFastHeap* GetHeap() = 0;
    virtual BOOL ExtendDataTableSpace(LPMEMORY pOld, 
        length_t nOldLength, length_t nNewLength) = 0;
    virtual void ReduceDataTableSpace(LPMEMORY pOld, 
        length_t nOldLength, length_t nDecrement) = 0;
    //virtual void SetDataLength(length_t nDataLength) = 0;
};

enum
{
    e_NullnessBit = 0,
    e_DefaultBit = 1,

    NUM_PER_PROPERTY_BITS
};

typedef CBitBlockTable<NUM_PER_PROPERTY_BITS> CNullnessTable;

//*****************************************************************************
//*****************************************************************************
//
//  class CDataTable
//
//  This class represents the table containing the values of the properties.
//  It appears both in class definitions, where it represents default values,
//  and in instances, where it represents the actual data, The main part of the
//  data table is arranged as a v-table: all instance of a given class have 
//  exactly the same layout. That is, if property MyProp of class MyClass is
//  at offset 23 in one instance of MyClass, it will be at offset23 in every
//  other instance of MyClass. This is achieved by storing variable-length data
//  on the Heap. The offsets for any given property are found in 
//  CPropertyInformation structures.
//
//  In addition to property values, CDataTable contains several additional bits
//  of information for each property. Currently therre are two such bits;
//  1) Whether or not the property has the value of NULL. If TRUE, the actual
//      data at the property's offset is ignored.
//  2) Whether or not the property value is inherited from a parent. For
//      instance, if an instance does not define the value of a property, that
//      it inherits the default. But if the default value changes after the 
//      instance is created, the change propagates to the instance. This is
//      accomplished using this bit: if it is TRUE, the parent's value is
//      copied over the child's every time this object is created (Merged).
//   
//  These bits are stored in a bit table in the order of property indeces. The
//  index for a given property is found in the nDataIndex field of its 
//  CPropertyInformation structure.
//
//  The layout of the memory block is as follows:
//      1) 2*<number of properties> bits rounded up to the next byte.
//      2) The v-table itself. 
//  The total length of the structure is found in the CClassPart's headet's
//  nDataLength field.
//
//*****************************************************************************
//
//  SetData
//
//  Initialization
//
//  PARAMETERS:
//
//      LPMEMORY pData                      The memory block for the table
//      int nProps                          The number of properties.
//      int nLength                         The total length of the structure
//      CDataTableContainer* m_pContainer   The container (see class).
//
//*****************************************************************************
//
//  GetStart
//
//  RETURN VALUES:
//
//      LPMEMORY:   start of the memory block
//
//*****************************************************************************
//
//  GetLength
//
//  returns:
//
//      length_t:   the length of the memory block
//
//*****************************************************************************
//
//  GetNullnessLength
//
//  RETURN VALUES:
//
//      length_t:   the length of the bit-table part of the memory block.
//
//*****************************************************************************
//
//  GetDataLength
//
//  RETURN VALUES:
//
//      length_t:   the length of the v-table part of the memory block
//
//*****************************************************************************
//
//  Rebase
//
//  Informs the object that its memory block has moved. Updates internal data.
//
//  PARAMETERS:
//
//      LPMEMORY pNewMem        The new location of the memory block
//
//*****************************************************************************
//
//  IsDefault
//
//  Checks if a property at a given index has the inherited value, or its own.
//  
//  PARAMETERS:
//
//      int nIndex          The index of the property(see CPropertyInformation)
//
//  RETURN VALUES:
//
//      BOOL
//
//*****************************************************************************
//
//  SetDefaultness
//
//  Sets the bit responsible for saying whether a given property has the 
//  inherited value, or its own.
//
//  PARAMETERS:
//
//      int nIndex          The index of the property(see CPropertyInformation)
//      BOOL bDefault       The new value of the bit
//
//*****************************************************************************
//
//  IsNull
//
//  Checks if a property at a given index is NULL.
//  
//  PARAMETERS:
//
//      int nIndex          The index of the property(see CPropertyInformation)
//
//  RETURN VALUES:
//
//      BOOL
//
//*****************************************************************************
//
//  SetNullness
//
//  Sets the bit responsible for saying whether a given property is NULL. 
//
//  PARAMETERS:
//
//      int nIndex          The index of the property(see CPropertyInformation)
//      BOOL bNull          The new value of the bit
//
//*****************************************************************************
//
//  GetOffset
//
//  Access the data at a given offset in the v-table as an UntypedValue (see
//  fastval.h for details). No range checking is performed.
//
//  PARAMETERS:
//
//      offset_t nOffset    The offset of the property.
//
//  RETURN VALUES:
//
//      CUntypedValue*  pointing to the data at the given offset.
//
//*****************************************************************************
//
//  SetAllToDefault
//
//  Marks all properties as having the default values
//
//*****************************************************************************
//
//  CopyNullness
//
//  Copies the nullness attributes of all properties from another CDataTable
//  
//  PARAMETERS:
//
//      CDataTable* pSourceTable        The table whose attributes to copy.
//
//*****************************************************************************
//
//  ExtendTo
//
//  Extends the data table to accomodate a given number of properties and and
//  a given area of the v-table. Request more space from the container, if
//  required, then grows the nullness table if required and shifts the v-table
//  if required.
//
//  PARAMETERS:
//
//      propindex_t nMaxIndex       the largest allowed property index.
//      offse_t nOffsetBound        The size of the v-table.
//
//*****************************************************************************
//
//  RemoveProperty
//
//  Removes a property from the data table. This involves cllapsing its bits in
//  the nullness table as well as its area in the v-table. Adjustments still
//  need to be made to the property definitions (see CPropertyLookupTable::
//  DeleteProperty).
//
//  PARAMETERS:
//
//      propindex_t nIndex      The index of the property to remove.
//      offset_t nOffset        The offset of the property to remove.
//      lenght_t nLength        The length of the v-table area occupied by the
//                              property.
//
//*****************************************************************************
//
//  static GetMinLength
//
//  Returns the amount of space required by a data table on 0 properties.
//
//  RETURN VALUES:
//
//      0
//
//*****************************************************************************
//
//  static CreateEmpty
//
//  Creates an empty data table on a block of memory. Since there is no info
//  in such a table, does nothing
//
//  PARAMETERS:
//
//      LPMEMORY pStart         The memory block to create the table on
//
//*****************************************************************************
//
//  static ComputeNecessarySpace
//
//  Computes the amount of space required for a data table with a given number
//  of properties and the size of the v-table (the sum of data sizes for all 
//  properties).
//
//  PARAMETERS:
//
//      int nNumProps           The number of propeties (determines nullness
//                              table size).
//      int nDataSize           The size of the v-table.
//
//  RETURN VALUES:
//
//      length_t:       the number of bytes required for such a table
//
//*****************************************************************************
//
//  Merge
//
//  Merges two data tables, one from parent, one from child. This occurs when
//  an instance or a derived class is being read from the database and merged
//  with its (parent) class. Since some properties may not be defined in the
//  child object (left default), and their values will need to be read from the
//  parent object.
//
//  PARAMETERS:
//
//      CDataTable* pParentData             The parent's data table object
//      CFastHeap* pParentHeap              The parent's heap where string data
//                                          and such is kept.
//      CDataTable* pChildData              The child's data table object
//      CFastHeap* pChildHeap               The child's heap.
//      CPropertyLookupTable* pProperties   The property lookup table for this
//                                          class. It is needed to find
//                                          individual properties.
//      LPMEMORY pDest                      Destination memory block. Assumed
//                                          to be large enough to contain all
//                                          the merge.
//      CFastHeap* pNewHeap                 Destination heap. ASSUMED TO BE
//                                          LARGE ENOUGH THAT NO ALLOCATION 
//                                          WILL CAUSE IT TO RELOCATE!
//  RETURN VALUES:
//
//      LPMEMORY: pointer to the first byte after the merge.
//
//*****************************************************************************
//
//  Unmerge
//
//  Called when it is time to store an instance or a class into the database.
//  Since inherited information (the one that didn't change in this object
//  as compared to its parent) isn't stored in the database, it needs to be
//  removed or unmerged.
//
//  PARAMETERS:
//
//      CPropertyLookupTable* pLookupTable  The property lookup table for this
//                                          class.
//      CFastHeap* pCurrentHeap             The heap where we keep extra data.
//      LPMEMORY pDest                      Destination memory block. Assumed
//                                          to be large enough to contain all
//                                          the unmerge.
//      CFastHeap* pNewHeap                 Destination heap. ASSUMED TO BE
//                                          LARGE ENOUGH THAT NO ALLOCATION 
//                                          WILL CAUSE IT TO RELOCATE!
//  RETURN VALUES:
//
//      LPMEMORY: pointer to the first byte after the unmerge.
//
//*****************************************************************************
//
//  WritePropagatedVersion
//
//  Called when a new instance or a derived class is created. It produces the
//  data table for the child. Copies all the values from the parent's table and
//  marks them all as "default" in the nullness table.
//
//  PARAMETERS:
//
//      CPropertyLookupTable* pLookupTable  The property lookup table for this
//                                          class.
//      CFastHeap* pCurrentHeap             The heap where we keep extra data.
//      LPMEMORY pDest                      Destination memory block. Assumed
//                                          to be large enough to contain all
//                                          the propagated data.
//      CFastHeap* pNewHeap                 Destination heap. ASSUMED TO BE
//                                          LARGE ENOUGH THAT NO ALLOCATION 
//                                          WILL CAUSE IT TO RELOCATE!
//  RETURN VALUES:
//
//      LPMEMORY: pointer to the first byte after the propagated data.
//
//*****************************************************************************
//     
//  TranslateToNewHeap
//
//  Moves all the data we have on the heap to a different heap. Property lookup
//  table is needed here to interpret the proeprties. This function does NOT
//  freee the data from the current heap.
//
//  PARAMETERS:
//
//      CPropertyLookupTable* pLookupTable  The property lookup table for this
//                                          class.
//      BOOL bIsClass                       Whether this is a class defaults 
//                                          table or an instance data table. 
//                                          If it is a class, the data for
//                                          properties which inherit their
//                                          parent's default values is not
//                                          present. 
//      CFastHeap* pCurrentHeap             The heap where we currently keep 
//                                          extra data.
//      CFastHeap* pNewHeap                 The heap where the extra data
//                                          should go.
//
//*****************************************************************************
//
//  CreateLimitedRepresentation
//
//  Copies the data for the properties which are included under the limitation.
//  It uses the old property lookup table and the new one to guide it.
//
//  PARAMETERS:
//
//      CPropertyMapping* pMap      The property mapping to effect, see 
//                                  CPropertyMapping for details.
//      IN BOOL bIsClass            TRUE if this is the defaults table for the
//                                  class, FALSE if data table for an instance
//      IN CFastHeap* pOldHeap      The heap where our extra data is stored.
//      IN CFastHeap* pNewHeap      The heap where the extra data should go to.
//      OUT LPMEMORY pDest          Destination for the representation. Must
//                                  be large enough to contain all the data ---
//                                  see EstimateLimitedRepresentationSpace.
//  RETURN VALUES:
//
//      LPMEMORY:   NULL on failure, pointer to the first byte after the data
//                  written on success.
//
//*****************************************************************************

class  COREPROX_POLARITY CDataTable
{
protected:
    CNullnessTable* m_pNullness;
    LPMEMORY m_pData;
    int m_nLength;
    int m_nProps;
    CDataTableContainer* m_pContainer;

    friend class CWbemObject;
    friend class CWbemClass;
    friend class CWbemInstance;
    friend class CClassPart;

public:
    void SetData(LPMEMORY pData, int nProps, int nLength,
        CDataTableContainer* pContainer)
    {
        m_pNullness = (CNullnessTable*)pData;
        m_pData = pData + CNullnessTable::GetNecessaryBytes(nProps);
        m_nLength = nLength;
        m_nProps = nProps;
        m_pContainer = pContainer;
    }

	static size_t ValidateBuffer(LPMEMORY start, size_t cbMax, int nProps);

    LPMEMORY GetStart() {return LPMEMORY(m_pNullness);}
    length_t GetLength() {return m_nLength;}

    length_t GetNullnessLength()
        // DEVNOTE:WIN64:SJS - 64-bit pointer values truncated into 
        // signed/unsigned 32-bit value.  We do not support length
        // > 0xFFFFFFFF so cast is ok.
        {return (length_t) ( m_pData - LPMEMORY(m_pNullness) );}

    length_t GetDataLength() 
        {return m_nLength-GetNullnessLength();}

    void Rebase(LPMEMORY pNewMemory)
    {
        int nTableLen = GetNullnessLength();
        m_pNullness = (CNullnessTable*)pNewMemory;
        m_pData = pNewMemory + nTableLen;
    }

public:
    BOOL IsDefault(int nProp) 
        {return m_pNullness->GetBit(nProp, e_DefaultBit);}
    void SetDefaultness(int nProp, BOOL bDefault)
        {m_pNullness->SetBit(nProp, e_DefaultBit, bDefault);}
    BOOL IsNull(int nProp)
        {return m_pNullness->GetBit(nProp, e_NullnessBit);}
    void SetNullness(int nProp, BOOL bNull)
        {m_pNullness->SetBit(nProp, e_NullnessBit, bNull);}

    CUntypedValue* GetOffset(offset_t nOffset) 
        {return (CUntypedValue*)(m_pData + nOffset);}

    void SetAllToDefault()
    {
        for(int i = 0; i < m_nProps; i++)
            SetDefaultness(i, TRUE);
    }
    void CopyNullness(CDataTable* pParent)
    {
        for(int i = 0; i < m_nProps; i++)
            SetNullness(i, pParent->IsNull(i));
    }


public:
    BOOL ExtendTo(propindex_t nMaxIndex, offset_t nOffsetBound);
    void RemoveProperty(propindex_t nIndex, offset_t nOffset, length_t nLength);
public:
    static length_t GetMinLength() {return 0;}
    static LPMEMORY CreateEmpty(LPMEMORY pStart) {return pStart;}
    static length_t ComputeNecessarySpace(int nNumProps, int nDataLen)
    {
        return CNullnessTable::GetNecessaryBytes(nNumProps) + nDataLen;
    }

    static LPMEMORY Merge( 
        CDataTable* pParentData, CFastHeap* pParentHeap,
        CDataTable* pChildData, CFastHeap* pChildHeap,
        CPropertyLookupTable* pProperties, LPMEMORY pDest, CFastHeap* pNewHeap);

    LPMEMORY Unmerge(CPropertyLookupTable* pLookupTable,
        CFastHeap* pCurrentHeap, LPMEMORY pDest, CFastHeap* pNewHeap);

    LPMEMORY WritePropagatedVersion(CPropertyLookupTable* pLookupTable,
        CFastHeap* pCurrentHeap, LPMEMORY pDest, CFastHeap* pNewHeap);

    LPMEMORY CreateLimitedRepresentation(
        CLimitationMapping* pMap,
        BOOL bIsClass,
        CFastHeap* pOldHeap, 
        CFastHeap* pNewHeap, LPMEMORY pDest);

    BOOL TranslateToNewHeap(CPropertyLookupTable* pLookupTable, BOOL bIsClass,
        CFastHeap* pCurrentHeap, CFastHeap* pNewHeap);
    
    LPMEMORY WriteSmallerVersion(int nNumProps, length_t nDataLen, 
                                            LPMEMORY pMem);

};

class CDataTablePtr : public CPtrSource
{
protected:
    CDataTable* m_pTable;
    offset_t m_nOffset;
public:
    CDataTablePtr(CDataTable* pTable, offset_t nOffset) 
        : m_pTable(pTable), m_nOffset(nOffset) {}
    LPMEMORY GetPointer() 
        {return (LPMEMORY)m_pTable->GetOffset(m_nOffset);}
};

//***************************************************************************

//#pragma pack(pop)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\marshalers\coreprox\fastprox.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    FASTPROX.CPP

Abstract:

    Object Marshaling

History:

--*/

#include "precomp.h"
#include "fastprox.h"

ULONG CFastProxy::AddRef()
{
    return (ULONG)InterlockedIncrement(&m_lRef);
}

ULONG CFastProxy::Release()
{
    long lNewRef = InterlockedDecrement(&m_lRef);
    if(lNewRef == 0)
    {
        delete this;
    }
    return lNewRef;
}

STDMETHODIMP CFastProxy::QueryInterface(REFIID riid, void** ppv)
{
    if(riid == IID_IUnknown)
    {
        AddRef();
        *ppv = (void*)(IUnknown*)(IMarshal*)this;
        return S_OK;
    }
    if(riid == IID_IMarshal)
    {
        AddRef();
        *ppv = (void*)(IMarshal*)this;
        return S_OK;
    }
    else return E_NOINTERFACE;
}

STDMETHODIMP CFastProxy::GetUnmarshalClass(REFIID riid, void* pv, 
          DWORD dwDestContext, void* pvReserved, DWORD mshlFlags, CLSID* pClsid)
{
    return E_UNEXPECTED;
}

STDMETHODIMP CFastProxy::GetMarshalSizeMax(REFIID riid, void* pv, 
        DWORD dwDestContext, void* pvReserved, DWORD mshlFlags, ULONG* plSize)
{
    return E_UNEXPECTED;
}

STDMETHODIMP CFastProxy::MarshalInterface(IStream* pStream, REFIID riid, 
    void* pv, DWORD dwDestContext, void* pvReserved, DWORD mshlFlags)
{
    return E_UNEXPECTED;
}

STDMETHODIMP CFastProxy::UnmarshalInterface(IStream* pStream, REFIID riid, 
                                            void** ppv)
{
    CWbemObject* pObj = CWbemObject::CreateFromStream(pStream);
    if(pObj == NULL)
        return E_FAIL;

    HRESULT hres = pObj->QueryInterface(riid, ppv);
    pObj->Release();
    return hres;
}

STDMETHODIMP CFastProxy::ReleaseMarshalData(IStream* pStream)
{
    return S_OK;
}

STDMETHODIMP CFastProxy::DisconnectObject(DWORD dwReserved)
{
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\marshalers\coreprox\fastprox.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    FASTPROX.H

Abstract:

    Object Marshaling

History:

--*/

#ifndef __FAST_WRAPPER__H_
#define __FAST_WRAPPER__H_
#pragma warning (disable : 4786)

#include <windows.h>
#include <stdio.h>
#include <wbemidl.h>
#include <clsfac.h>
#include <wbemutil.h>
#include <fastall.h>

class CFastProxy : public IMarshal
{
protected:
    long m_lRef;

public:

    CFastProxy(CLifeControl* pControl) : m_lRef(0){}

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(REFIID riid, LPVOID FAR* ppvObj);
    STDMETHOD_(ULONG, AddRef)();
    STDMETHOD_(ULONG, Release)();

    STDMETHOD(GetUnmarshalClass)(REFIID riid, void* pv, DWORD dwDestContext,
        void* pvReserved, DWORD mshlFlags, CLSID* pClsid);
    STDMETHOD(GetMarshalSizeMax)(REFIID riid, void* pv, DWORD dwDestContext,
        void* pvReserved, DWORD mshlFlags, ULONG* plSize);
    STDMETHOD(MarshalInterface)(IStream* pStream, REFIID riid, void* pv, 
        DWORD dwDestContext, void* pvReserved, DWORD mshlFlags);
    STDMETHOD(UnmarshalInterface)(IStream* pStream, REFIID riid, void** ppv);
    STDMETHOD(ReleaseMarshalData)(IStream* pStream);
    STDMETHOD(DisconnectObject)(DWORD dwReserved);
};

class CClassObjectFactory : public CBaseClassFactory
{
public:

    CClassObjectFactory( CLifeControl* pControl = NULL ) 
    : CBaseClassFactory( pControl ) {} 

    HRESULT CreateInstance( IUnknown* pOuter, REFIID riid, void** ppv )
    {
        if(pOuter)
            return CLASS_E_NOAGGREGATION;
    
        CWbemClass* pNewObj = new CWbemClass;
        
        if ( FAILED( pNewObj->InitEmpty(0) ) )
        {
            return E_FAIL;
        }

        return pNewObj->QueryInterface(riid, ppv);
    }

    HRESULT LockServer( BOOL fLock )
    {
        if(fLock)
            m_pControl->ObjectCreated(NULL);
        else
            m_pControl->ObjectDestroyed(NULL);
        return S_OK;
    }
};        

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\marshalers\coreprox\fastsprt.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    FASTSPRT.CPP

Abstract:

  This file implements supporting classes for Wbem Class/Instance objects.
  See faststr.h for documentation.

  Classes implemented: 
      CBitBlockTable:     a two-dimentional array of bits.

History:

  2/20/97     a-levn  Fully documented

--*/

#include "precomp.h"
//#include <dbgalloc.h>

#include "fastsprt.h"

//*****************************************************************************
//
//  InsertSpace
//
//  Inserts space into a block of memory by moving the tail of the block back
//  by the required amount. It assumes that there is enough room at the end
//  of the block for the insertion.
//
//  Parameters:
//
//      [in] LPMEMORY pMemory           The starting point of the block
//      [in] int nLength                The original length of the block
//      [in] LPMEMORY pInsertionPoint   Points to the insertion point (between
//                                      pMemory and pMemory + nLength
//      [in] int nBytesToInsert         The number of bytes to insert
//
//*****************************************************************************
  
 void InsertSpace(LPMEMORY pMemory, int nLength, 
                        LPMEMORY pInsertionPoint, int nBytesToInsert)
{
    // DEVNOTE:WIN64:SJS - 64-bit pointer values truncated into 
    // signed/unsigned 32-bit value (nLength - (pInsertionPoint - pMemory)).
    // We do not support length > 0xFFFFFFFF, so cast is ok.

    memmove((void*)(pInsertionPoint + nBytesToInsert),
           (void*)pInsertionPoint, 
           nLength - (int) ( (pInsertionPoint - pMemory) ) );
}

/*
static DWORD CBitTable::m_pMasks[32] = 
{
    0x80000000,
    0x40000000,
    0x20000000,
    0x10000000,

    0x08000000,
    0x04000000,
    0x02000000,
    0x01000000,

    0x00800000,
    0x00400000,
    0x00200000,
    0x00100000,

    0x00080000,
    0x00040000,
    0x00020000,
    0x00010000,

    0x00008000,
    0x00004000,
    0x00002000,
    0x00001000,

    0x00000800,
    0x00000400,
    0x00000200,
    0x00000100,

    0x00000080,
    0x00000040,
    0x00000020,
    0x00000010,

    0x00000008,
    0x00000004,
    0x00000002,
    0x00000001
};

*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\marshalers\coreprox\fastqual.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    FASTQUAL.CPP

Abstract:

  This file implements the classes related to qualifier processing in WbeWbemjects
  See fastqual.h for full documentation and fastqual.inc for  function
  implementations.

  Classes implemented:
      CQualifierFlavor                Encapsulates qualifier flavor infor
      CQualifier                      Represents a qualifier
      CBasicQualifierSet              Represents read-only functionality.
      CQualiferSetContainer           What qualifier set container supports.
      CQualifierSet                   Full-blown qualifier set (template)
      CQualifierSetListContainer      What qualifier set list container supports.
      CQualifierSetList               List of qualifier sets.
      CInstanceQualifierSet           Instance qualifier set.
      CClassQualifierSet              Class qualifier set.
      CClassPQSContainer              Class property qualifier set container
      CClassPropertyQualifierSet      Class property qualifier set
      CInstancePQSContainer           Instance proeprty qualifier set container
      CInstancePropertyQualifierSet   Instance property qualifier set

History:

    2/20/97     a-levn  Fully documented
    12//17/98   sanjes -    Partially Reviewed for Out of Memory.

--*/

#include "precomp.h"
#include "wbemutil.h"
#include "fastall.h"
#include "olewrap.h"
#include <arrtempl.h>

#include <assert.h>
#include <scopeguard.h>

WString CQualifierFlavor::GetText()
{
    // DEVNOTE:EXCEPTION:RETVAL - This function has been reviewed and should cleanup properly
    // if an exception is thrown

    WString wsText;
    if(m_byFlavor == 0)
        return wsText;

    wsText = L":";
    BOOL bFirst = TRUE;

    if(!IsOverridable())
    {
        wsText += L" DisableOverride";
        bFirst = FALSE;
    }

    if(DoesPropagateToInstances())
    {
        wsText += L" ToInstance";
        bFirst = FALSE;
    }

    if(DoesPropagateToDerivedClass())
    {
        wsText += L" ToSubClass";
        bFirst = FALSE;
    }

    if ( IsAmended() )
    {
        wsText += L" Amended";
        bFirst = FALSE;
    }

    return wsText;

}

size_t CBasicQualifierSet::ValidateBuffer(LPMEMORY pStart, size_t cbMax)
{
	size_t step = sizeof(length_t);
	if (step > cbMax ) throw CX_Exception();
	if (CBasicQualifierSet::GetLengthFromData(pStart) > cbMax) 
	{
		throw CX_Exception();
	}
	return CBasicQualifierSet::GetLengthFromData(pStart);
}

//******************************************************************************
//
//  See fastqual.h for documentation
//
//******************************************************************************
length_t CBasicQualifierSet::ComputeNecessarySpaceForPropagation(
        LPMEMORY pStart, BYTE byPropagationFlag)
{
    // Start enumeration of qualifiers
    // ===============================

    CQualifier* pEnd = (CQualifier*)(pStart + GetLengthFromData(pStart));
    CQualifier* pQualifier = GetFirstQualifierFromData(pStart);
    length_t nNewLength = GetMinLength();

    while(pQualifier < pEnd)
    {
        // Check if this qualifier propagates as required
        // ==============================================

        if(pQualifier->fFlavor & byPropagationFlag)
        {
            nNewLength += pQualifier->GetLength();
        }
        pQualifier = (CQualifier*)pQualifier->Next();
    }

    return nNewLength;
}

//*****************************************************************************
//*****************************************************************************
//*****************************************************************************

//******************************************************************************
//
//  See execq.h for documentation
//
//******************************************************************************
LPMEMORY CBasicQualifierSet::WritePropagatedVersion(CPtrSource* pThis,
        BYTE byPropagationFlag, CPtrSource* pDest,
        CFastHeap* pOldHeap, CFastHeap* pNewHeap)
{
    // IMPORTANT: THIS FUNCTION ASSUMES THAT THERE IS ENOUGH FREE SPACE ON THE
    // NEW HEAP, THAT pDest will never be moved.

    // Start enumeration of qualifiers
    // ===============================

    CShiftedPtr SourcePtr(pThis, GetMinLength());
    CShiftedPtr EndPtr(pThis, GetLengthFromData(pThis->GetPointer()));
    CShiftedPtr DestPtr(pDest, GetMinLength());

    length_t nNewLength = GetMinLength();

    while(SourcePtr.GetPointer() < EndPtr.GetPointer())
    {
        // Check if this qualifier propagates as required
        // ==============================================

        CQualifier* pSourceQualifier = CQualifier::GetPointer(&SourcePtr);
        if(pSourceQualifier->fFlavor & byPropagationFlag)
        {
            // Copy it to the new localtion (and new heap)
            // ===========================================

            // Check for allocation failures
            if ( !pSourceQualifier->CopyTo(&DestPtr, pOldHeap, pNewHeap) )
            {
                return NULL;
            }

            CQualifier* pDestQualifier = CQualifier::GetPointer(&DestPtr);
            pDestQualifier->fFlavor.SetLocal(FALSE);
            DestPtr += pDestQualifier->GetLength();
        }

        SourcePtr += CQualifier::GetPointer(&SourcePtr)->GetLength();
    }

    // Set length
    // ==========

    *(UNALIGNED length_t*)(pDest->GetPointer()) =
        DestPtr.GetPointer() - pDest->GetPointer();

    return DestPtr.GetPointer();
}

//******************************************************************************
//
//  See fastqual.h for documentation
//
//******************************************************************************
length_t CBasicQualifierSet::ComputeMergeSpace(
                               READ_ONLY LPMEMORY pParentSetData,
                               READ_ONLY CFastHeap* pParentHeap,
                               READ_ONLY LPMEMORY pChildSetData,
                               READ_ONLY CFastHeap* pChildHeap,
                               BOOL bCheckValidity)
{
    // IMPORTANT: THIS FUNCTION ASSUMES THAT THERE IS ENOUGH FREE SPACE ON THE
    // NEW HEAP, THAT pDest will never be moved.
    // =======================================================================

    CBasicQualifierSet ParentSet;
    ParentSet.SetData(pParentSetData, pParentHeap);

    CBasicQualifierSet ChildSet;
    ChildSet.SetData(pChildSetData, pChildHeap);

    // Start with the child set, which will go in its entirety
    // =======================================================

    length_t nTotalLength = ChildSet.GetLength();

    // Examine parent's qualifiers
    // ===========================

    CQualifier* pCurrentQual = ParentSet.GetFirstQualifier();
    CQualifier* pParentEnd = (CQualifier*)ParentSet.Skip();

    while(pCurrentQual < pParentEnd)
    {
        // Check if it propagates to child classes
        // =======================================

        if(pCurrentQual->fFlavor.DoesPropagateToDerivedClass())
        {
            // Check that it is not overriden
            // ==============================

            CQualifier* pChildQual = ChildSet.GetQualifierLocally(
                pParentHeap->ResolveString(pCurrentQual->ptrName));

            if(pChildQual == NULL)
            {
                // Propagating non-overriden qualifier. Count it.
                // ==============================================

                nTotalLength += pCurrentQual->GetLength();
            }
            else  if(bCheckValidity)
            {
                // Check if the parent actually allows overrides
                // =============================================

                if(!pCurrentQual->fFlavor.IsOverridable())
                    return 0xFFFFFFFF;
            }
        }

        pCurrentQual = (CQualifier*)pCurrentQual->Next();
    }

    return nTotalLength;
}

//******************************************************************************
//
//  See fastqual.h for documentation
//
//******************************************************************************

LPMEMORY CBasicQualifierSet::Merge(
                               READ_ONLY LPMEMORY pParentSetData,
                               READ_ONLY CFastHeap* pParentHeap,
                               READ_ONLY LPMEMORY pChildSetData,
                               READ_ONLY CFastHeap* pChildHeap,
                               LPMEMORY pDest,  CFastHeap* pNewHeap,
                               BOOL bCheckValidity)
{
    // IMPORTANT: THIS FUNCTION ASSUMES THAT THERE IS ENOUGH FREE SPACE ON THE
    // NEW HEAP, THAT pDest will never be moved.
    // =======================================================================

    CBasicQualifierSet ParentSet;
    ParentSet.SetData(pParentSetData, pParentHeap);

    CBasicQualifierSet ChildSet;
    ChildSet.SetData(pChildSetData, pChildHeap);

    // First of all, copy child set, since they all go
    // ===============================================

    memcpy(pDest, ChildSet.GetStart(), ChildSet.GetLength());
    CQualifier* pCurrentNew = (CQualifier*)(pDest + ChildSet.GetLength());

    // Translate it to the new heap
    // ============================

    SetDataLength(pDest, LPMEMORY(pCurrentNew)-pDest);

    CStaticPtr DestPtr(pDest);

    // Check for memory allocation failures
    if ( !TranslateToNewHeap(&DestPtr, pChildHeap, pNewHeap) )
    {
        return NULL;
    }

    // Copy parent's qualifiers conditionaly
    // =====================================

    CQualifier* pCurrentQual = ParentSet.GetFirstQualifier();
    CQualifier* pParentEnd = (CQualifier*)ParentSet.Skip();

    while(pCurrentQual < pParentEnd)
    {
        // Check if it propagates to child classes
        // =======================================

        if(pCurrentQual->fFlavor.DoesPropagateToDerivedClass())
        {
            // Check that it is not overriden
            // ==============================

            CQualifier* pChildQual = ChildSet.GetQualifierLocally(
                pParentHeap->ResolveString(pCurrentQual->ptrName));

            if(pChildQual == NULL)
            {
                // Propagating non-overriden qualifier. Copy it.
                // =============================================

                CStaticPtr CurrentNewPtr((LPMEMORY)pCurrentNew);

                // Check for memory allocation failures
                if ( !pCurrentQual->CopyTo(&CurrentNewPtr, pParentHeap, pNewHeap) )
                {
                    return NULL;
                }

                pCurrentNew->fFlavor.SetLocal(FALSE);
                pCurrentNew = (CQualifier*)pCurrentNew->Next();
            }
            else  if(bCheckValidity)
            {
                // Check if the parent actually allows overrides
                // =============================================

                if(!pCurrentQual->fFlavor.IsOverridable())
                    return NULL;
            }
        }

        pCurrentQual = (CQualifier*)pCurrentQual->Next();
    }

    // Set the length appropriately
    // ============================

    SetDataLength(pDest, (LPMEMORY)pCurrentNew - pDest);
    return (LPMEMORY)pCurrentNew;
}

//******************************************************************************
//
//  See fastqual.h for documentation
//
//******************************************************************************
length_t CBasicQualifierSet::ComputeUnmergedSpace(
                          READ_ONLY LPMEMORY pMergedData)
{
    CQualifier* pCurrentMerged = GetFirstQualifierFromData(pMergedData);
    CQualifier* pMergedEnd =
        (CQualifier*)(pMergedData + GetLengthFromData(pMergedData));

    length_t nTotalLength = GetMinLength();

    while(pCurrentMerged < pMergedEnd)
    {
        // Check if it is local or not
        // ===========================

        if(pCurrentMerged->fFlavor.IsLocal())
        {
            // Count it
            // ========

            nTotalLength += pCurrentMerged->GetLength();
        }
        pCurrentMerged = (CQualifier*)pCurrentMerged->Next();
    }

    return nTotalLength;
}


//******************************************************************************
//
//  See fastqual.h for documentation
//
//******************************************************************************

LPMEMORY CBasicQualifierSet::Unmerge(
                          READ_ONLY LPMEMORY pMergedData,
                          READ_ONLY CFastHeap* pMergedHeap,
                          NEW_OBJECT LPMEMORY pDest,
                          MODIFY CFastHeap* pNewHeap)
{
    // IMPORTANT: THIS FUNCTION ASSUMES THAT THERE IS ENOUGH FREE SPACE ON THE
    // NEW HEAP, THAT pDest will never be moved.
    // =======================================================================

    CQualifier* pCurrentMerged = GetFirstQualifierFromData(pMergedData);
    CQualifier* pMergedEnd =
        (CQualifier*)(pMergedData + GetLengthFromData(pMergedData));

    CQualifier* pCurrentNew = GetFirstQualifierFromData(pDest);
    while(pCurrentMerged < pMergedEnd)
    {
        // Check if it is local or not
        // ===========================

        if(pCurrentMerged->fFlavor.IsLocal())
        {
            // Copy yo destination
            // ===================

            CStaticPtr CurrentNewPtr((LPMEMORY)pCurrentNew);

            // Check for allocation failure
            if ( !pCurrentMerged->CopyTo(&CurrentNewPtr, pMergedHeap, pNewHeap) )
            {
                return NULL;
            }

            pCurrentNew = (CQualifier*)pCurrentNew->Next();
        }
        pCurrentMerged = (CQualifier*)pCurrentMerged->Next();
    }

    // Set the length
    // ==============

    SetDataLength(pDest, LPMEMORY(pCurrentNew) - pDest);
    return (LPMEMORY)pCurrentNew;
}


//******************************************************************************
//
//  See fastqual.h for documentation
//
//******************************************************************************

HRESULT CBasicQualifierSet::EnumPrimaryQualifiers(BYTE eFlags, BYTE fFlavorMask,
                                   CFixedBSTRArray& astrMatching,
                                   CFixedBSTRArray& astrNotMatching
                                   )
{
    HRESULT hr = WBEM_S_NO_ERROR;

    // Divide  qualifiers into those matching and not macching the
    // criteria
    // ================================================================

    try
    {
        astrMatching.Create(GetNumUpperBound());
        astrNotMatching.Create(GetNumUpperBound());

        int nMatchingIndex = 0, nNotMatchingIndex = 0;

        CQualifier* pEnd = (CQualifier*)Skip();

        CQualifier* pCurrent = (CQualifier*)m_pOthers;
        while(pCurrent < pEnd)
        {
            // Check that this qualifier is valid
            // ==================================
            if(pCurrent->ptrName == INVALID_HEAP_ADDRESS) 
            	{
            	pCurrent = (CQualifier*)pCurrent->Next();
            	continue;
            	}

            // Resolve the name
            // ================

            CCompressedString* pName = GetHeap()->
                                        ResolveString(pCurrent->ptrName);

            // Check if it matches the propagation mask and the flags
            // ======================================================

            if((pCurrent->fFlavor & fFlavorMask) == fFlavorMask &&
                (eFlags != WBEM_FLAG_LOCAL_ONLY || pCurrent->fFlavor.IsLocal()) &&
                (eFlags != WBEM_FLAG_PROPAGATED_ONLY || !pCurrent->fFlavor.IsLocal())
            )
            {
                astrMatching[nMatchingIndex++] = pName->CreateBSTRCopy();

                // Check for allocation failures
                if ( NULL == astrMatching[nMatchingIndex-1] )
                {
                    hr = WBEM_E_OUT_OF_MEMORY;
                    break;
                }
            }
            else
            {
                astrNotMatching[nNotMatchingIndex++] = pName->CreateBSTRCopy();

                // Check for allocation failures
                if ( NULL == astrNotMatching[nNotMatchingIndex-1] )
                {
                    hr = WBEM_E_OUT_OF_MEMORY;
                    break;
                }

            }

            // Go to the next qualifier
            // ========================

            pCurrent = (CQualifier*)pCurrent->Next();
        }

        if ( SUCCEEDED( hr ) )
        {
            astrMatching.SetLength(nMatchingIndex);
            astrMatching.SortInPlace();
            astrNotMatching.SetLength(nNotMatchingIndex);
            astrNotMatching.SortInPlace();
        }
        else
        {
            // Cleanup if failed
            astrMatching.Free();
            astrNotMatching.Free();
        }

        return hr;
    }
    catch( CX_MemoryException )
    {
        // Cleanup if failed
        astrMatching.Free();
        astrNotMatching.Free();

        return WBEM_E_OUT_OF_MEMORY;
    }
    catch(...)
    {
        // Cleanup if failed
        astrMatching.Free();
        astrNotMatching.Free();

        return WBEM_E_FAILED;
    }

}


HRESULT CBasicQualifierSet::IsValidQualifierSet( void )
{
    HRESULT hr = WBEM_S_NO_ERROR;

    //  Enumerate the qualifiers, and check that names and ptr data
    //  Are inside the heap
    // ================================================================

    LPMEMORY    pHeapStart = m_pHeap->GetHeapData();
    LPMEMORY    pHeapEnd = m_pHeap->GetStart() + m_pHeap->GetLength();

    CQualifier* pEnd = (CQualifier*)Skip();
    CQualifier* pCurrent = (CQualifier*)m_pOthers;
    while(pCurrent < pEnd)
    {
        // Check that this qualifier is valid
        // ==================================

        if(pCurrent->ptrName == INVALID_HEAP_ADDRESS)
        {
            pCurrent = (CQualifier*)pCurrent->Next();
            continue;
        }

        // Resolve the name
        // ================

        LPMEMORY pName = ( CFastHeap::IsFakeAddress( pCurrent->ptrName ) ?
                        NULL : m_pHeap->ResolveHeapPointer(pCurrent->ptrName) );
        
        if ( ( NULL == pName ) ||  ( pName >= pHeapStart && pName < pHeapEnd  ) )
        {

            if ( CType::IsPointerType( pCurrent->Value.GetType() ) )
            {
                LPMEMORY    pData = m_pHeap->ResolveHeapPointer(  pCurrent->Value.AccessPtrData() );

                if ( pData >= pHeapStart && pData < pHeapEnd  )
                {
                    // We could, if an embedded object, validate the object,
                    // or if an array of ptr values, validate those as well

                    if ( pCurrent->Value.GetType().IsArray() )
                    {
                        HRESULT hres = ((CUntypedArray*) pData)->IsArrayValid( pCurrent->Value.GetType(), m_pHeap );

                        if ( FAILED( hres ) )
                        {
                            return hres;
                        }
                    } 
                }
                else
                {
                    _ASSERT( 0, __TEXT("Winmgmt: Bad Qualifier value pointer!") );
                    return WBEM_E_FAILED;
                }

            }

        }
        else
        {
            _ASSERT( 0, __TEXT("Winmgmt: Bad qualifier name pointer!") );
            return WBEM_E_FAILED;
        }

        // Go to the next qualifier
        // ========================

        pCurrent = (CQualifier*)pCurrent->Next();
    }

    return hr;
}

//******************************************************************************
//
//  See fastqual.h for documentation
//
//******************************************************************************
HRESULT CBasicQualifierSet::GetText(READ_ONLY LPMEMORY pData,
                                 READ_ONLY CFastHeap* pHeap,
                                 long lFlags,
                                 NEW_OBJECT OUT WString& wsText)
{
	try
	{
		// DEVNOTE:EXCEPTION:RETVAL - This function has been reviewed and should cleanup properly
		// if an exception is thrown

		BOOL bFirst = TRUE;

		// Loop through the qualifiers
		// ===========================

		CQualifier* pCurrent = GetFirstQualifierFromData(pData);
		CQualifier* pEnd = (CQualifier*)(pData + GetLengthFromData(pData));

		while(pCurrent < pEnd)
		{
			// Make sure it is ours, not inherited
			// ===================================

			BSTR strName = NULL;
			ScopeGuard deleteBSTR = MakeGuard(COleAuto::_SysFreeString, ByRef(strName));

			if(pCurrent->fFlavor.IsLocal())
			{
				// We will throw an exception in case of OOM
				strName = pHeap->ResolveString(pCurrent->ptrName)->
										CreateBSTRCopy();

				if ( NULL == strName )
				{
					throw CX_MemoryException();
				}

				// If this is an in,out value, replace "in" or "out" with
				// "in,out"
				if( ( lFlags & WBEM_FLAG_IS_INOUT )
					&& ( wbem_wcsicmp( strName, L"in" ) == 0
					||   wbem_wcsicmp( strName, L"out" ) == 0 ) )
				{
					// Cleanup the existing value and NULL it out in case another exception is
					// thrown
					COleAuto::_SysReAllocString(&strName, L"in,out" );
				}


				// Make sure it is not 'syntax'
				// Ignore ID if required
				// =====================

				if((lFlags & WBEM_FLAG_IGNORE_IDS) && !wbem_wcsicmp(strName, L"id"))
				{
					// Nothing to do
				}

				// ===========================

				else if(wbem_wcsicmp(strName, TYPEQUAL))
				{
					// Write the separator, if required
					// ================================

					if(!bFirst)
					{
						wsText += L", ";
					}
					else
					{
						wsText += L"[";
						bFirst = FALSE;
					}


					// Write the name
					// ==============

					wsText += strName;

					// Write the value
					// ===============

					if(pCurrent->Value.GetType().GetActualType() == VT_BOOL &&
						pCurrent->Value.GetBool())
					{
						// boolean and true -- no value required
					}
					else
					{
						// We need to make sure we cleanup the BSTR here.
						// CSysFreeMe will even work during an exception
						BSTR strVal = NULL;

						CVar var;

						pCurrent->Value.StoreToCVar(var, pHeap);
						if(pCurrent->Value.GetType().IsArray())
						{
							wsText += L"{";

							strVal = var.GetVarVector()->GetText(0);
							CSysFreeMe sfmVal(strVal);

							// Check for a NULL return
							if ( NULL == strVal )
							{
								return WBEM_E_INVALID_QUALIFIER;
							}

							wsText += strVal;
							wsText += L"}";
						}
						else
						{
							wsText += L"(";

							strVal = var.GetText(0);
							CSysFreeMe sfmVal(strVal);

							// Check for a NULL return
							if ( NULL == strVal )
							{
								return WBEM_E_INVALID_QUALIFIER;
							}

							wsText += strVal;
							wsText += L")";
						}

					}

					if((lFlags & WBEM_FLAG_NO_FLAVORS) == 0)
					{
						// Write the flavor
						// ================

						if(wbem_wcsicmp(strName, L"key"))
						{
							wsText += pCurrent->fFlavor.GetText();
						}
					}

				}

			}

			pCurrent = (CQualifier*)pCurrent->Next();
		}

		if(!bFirst)
			wsText += L"]";

		return WBEM_S_NO_ERROR;
	}
	catch( CX_MemoryException )
	{
		return WBEM_E_OUT_OF_MEMORY;
	}
	catch(...)
	{
		return WBEM_E_CRITICAL_ERROR;
	}

}

//******************************************************************************
//
//  See fastqual.h for documentation.
//
//******************************************************************************
BOOL CBasicQualifierSet::Compare( CBasicQualifierSet& qsThat, BYTE eFlags, LPCWSTR* ppFilters, DWORD dwNumFilters )
{
    BOOL            fReturn = TRUE;

    CFixedBSTRArray astrNamesThis,
                    astrNamesThisFailed,
                    astrNamesThat,
                    astrNamesThatFailed;

    // We will throw exceptions in OOM scenarios

    // Get the names of the qualifiers in each set.

    HRESULT hr = EnumPrimaryQualifiers( eFlags, 0, astrNamesThis, astrNamesThisFailed );
    
    if ( FAILED( hr ) )
    {

        // If we got out of memory, throw an exception
        if ( WBEM_E_OUT_OF_MEMORY == hr )
        {
            throw CX_MemoryException();
        }

        return FALSE;
    }

    hr = qsThat.EnumPrimaryQualifiers( eFlags, 0, astrNamesThat, astrNamesThatFailed );

    if ( FAILED( hr ) )
    {
        // Cleanup
        astrNamesThis.Free();
        astrNamesThisFailed.Free();

        // If we got out of memory, throw an exception
        if ( WBEM_E_OUT_OF_MEMORY == hr )
        {
            throw CX_MemoryException();
        }

        return FALSE;
    }

    // Filter the arrays if we need to
    if ( NULL != ppFilters )
    {
        // Filter out all appropriate values

        // The array should free any "found" elements
        for ( int x = 0; x < dwNumFilters; x++ )
        {
            astrNamesThis.Filter( ppFilters[x], TRUE );
            astrNamesThat.Filter( ppFilters[x], TRUE );
        }

    }

    // Each must have the same number of names
    if ( astrNamesThis.GetLength() == astrNamesThat.GetLength() )
    {
        
        // Enum the qualifiers, checking that names and values
        // match

        for (   int i = 0;
                fReturn && i < astrNamesThis.GetLength();
                i++ )
        {

            // Qualifiers MUST be in the same order, so check that the two names
            // are equal
            if ( wbem_wcsicmp( astrNamesThis[i], astrNamesThat[i] ) == 0 )
            {

                CQualifier* pQualifierThis = GetQualifierLocally( astrNamesThis[i] );
                CQualifier* pQualifierThat = qsThat.GetQualifierLocally( astrNamesThat[i] );

                // Must have qualifier pointers, and flavors MUST match.
                if (    NULL != pQualifierThis
                    &&  NULL != pQualifierThat
                    &&  pQualifierThis->fFlavor == pQualifierThat->fFlavor )
                {
                    CVar    varThis,
                            varThat;

                    // We will throw exceptions in OOM scenarios

                    // Check for allocation failures
                    if ( !pQualifierThis->Value.StoreToCVar( varThis, GetHeap() ) )
                    {
                        throw CX_MemoryException();
                    }

                    // Check for allocation failures
                    if ( fReturn && !pQualifierThat->Value.StoreToCVar( varThat, qsThat.GetHeap() ) )
                    {
                        throw CX_MemoryException();
                    }

                    // Types must match
                    if ( fReturn && pQualifierThis->Value.GetType() == pQualifierThat->Value.GetType() )
                    {
                        // Compare the CVars
                        fReturn = ( varThis == varThat );
                    }
                    else
                    {
                        fReturn = FALSE;
                    }
                }   // IF got qualifiers, flavors and IsLocal match
                else
                {
                    fReturn = FALSE;
                }

            }   // IF names equal
            else
            {
                // Names NOT in exact order
                fReturn = FALSE;
            }

        }   // FOR iterate qualifier names

    }   // bstr Array lengths different
    else
    {
        // We don't have the same number of qualifiers
        fReturn = FALSE;
    }

    // Clear arrays.
    astrNamesThis.Free();
    astrNamesThisFailed.Free();
    astrNamesThat.Free();
    astrNamesThatFailed.Free();

    return fReturn;
}

//******************************************************************************
//
//  See fastqual.h for documentation.
//
//******************************************************************************
BOOL CBasicQualifierSet::CompareLocalizedSet( CBasicQualifierSet& qsThat )
{
    BOOL            fReturn = TRUE;
    
    CWStringArray   wstrFilters;

    CFixedBSTRArray astrNamesThis,
                    astrNamesThisFailed;
    ON_BLOCK_EXIT_OBJ(astrNamesThis, CFixedBSTRArray::Free);
    ON_BLOCK_EXIT_OBJ(astrNamesThisFailed, CFixedBSTRArray::Free);


	    // Get the names of all the qualifiers in each set.
	    HRESULT hr = EnumPrimaryQualifiers( 0, 0, astrNamesThis, astrNamesThisFailed );
	    
	    if ( FAILED( hr ) )
	    {
	        // If we failed because of out of memory, throw an exception.  Otherwise, just
	        // return FALSE

	        if ( WBEM_E_OUT_OF_MEMORY == hr )
	        {
	            throw CX_MemoryException();
	        }

	        return FALSE;
	    }

	    // Now we need to create an array of filters.  To do this, first add the "amendment" and
	    // "locale" qualifiers

	    // Now walk through all of our qualifiers.  For each one we find that meets one of our criteria,
	    // that it is "amendment", "locale", or marked with the IsAmended flavor we should add it to
	    // the filters array

	    for (   int i = 0;
	            fReturn && i < astrNamesThis.GetLength();
	            i++ )
	    {
	        BOOL    fLocalized = FALSE;
	        BOOL    fAdd = FALSE;

	        CQualifier* pQualifierThis = GetQualifierLocally( astrNamesThis[i] );

	        // If we couldn't get a qualifier that was named in our list, we've got
	        // serious problems
	        if ( NULL != pQualifierThis )
	        {
	            // Amendment and locale qualifiers are ALWAYS local
	            if ( wbem_wcsicmp( astrNamesThis[i], L"amendment" ) == 0 )
	            {
	                fLocalized = TRUE;
	            }
	            else if ( wbem_wcsicmp( astrNamesThis[i], L"locale" ) == 0 )
	            {
	                fLocalized = TRUE;
	            }
	            else
	            {
	                // If it's amended, it's a localization value.
	                fLocalized = CQualifierFlavor::IsAmended( pQualifierThis->GetFlavor() );
	            }

	            // If it is localized, see if it's in the other qualifier set.  If so, then
	            // we will check that type and flavor values make sense.  If so, we will
	            // ignore the qualifier.  If it's not in the other set, we should filter it

	            if ( fLocalized )
	            {
	                
	                CQualifier* pQualifierThat = qsThat.GetQualifierLocally( astrNamesThis[i] );

	                if ( NULL != pQualifierThat )
	                {
	                    // Types must match
	                    fReturn = ( pQualifierThis->Value.GetType() == pQualifierThat->Value.GetType() );

	                    if ( fReturn )
	                    {
	                        // Check the flavors after masking out the amended flavor bit
	                        BYTE bThisFlavor = pQualifierThis->GetFlavor() & ~WBEM_FLAVOR_MASK_AMENDED;
	                        BYTE bThatFlavor = pQualifierThat->GetFlavor() & ~WBEM_FLAVOR_MASK_AMENDED;

	                        // We also want to mask out the origin bit, since during localization
	                        // a qualifier from a base class may get tagged onto a derived class.

	                        bThisFlavor &= ~WBEM_FLAVOR_MASK_ORIGIN;
	                        bThatFlavor &= ~WBEM_FLAVOR_MASK_ORIGIN;

	                        // If the two match, we will assume that this qualifier should
	                        // be filtered out.
	                        fAdd = fReturn = ( bThisFlavor == bThatFlavor );
	                    }

	                }
	                else
	                {
	                    // It's in 'this' one but not 'that' one.  Filter it.
	                    fAdd = TRUE;
	                }

	            }   // If it's a localized qualifier

	        }   // IF got this qualifier
	        else
	        {
	            // Hmmm...we didn't find the qualifier even though it was
	            // in our list.
	            fReturn = FALSE;
	        }

	        // If we should add it, do it now
	        if ( fAdd && fReturn )
	        {
	            if ( wstrFilters.Add( astrNamesThis[i] ) != CWStringArray::no_error )
	            {
	                throw CX_MemoryException();
	            }
	        }   // If we should add to the filter list

	    }   // For enumerate names

	    // Now that we have an appropriate filter list, do a regular comparison
	    if ( fReturn )
	    {
	        fReturn = Compare( qsThat, 0L, wstrFilters.GetArrayPtr(), wstrFilters.Size() );
	    }

        return fReturn;
}

//******************************************************************************
//
//  See fastqual.h for documentation.
//
//******************************************************************************
BOOL CBasicQualifierSet::CanBeReconciledWith( CBasicQualifierSet& qsThat )
{
    BOOL            fReturn = TRUE;

    CFixedBSTRArray astrNamesThat,
                    astrNamesThatFailed;

    ON_BLOCK_EXIT_OBJ(astrNamesThat, CFixedBSTRArray::Free);
    ON_BLOCK_EXIT_OBJ(astrNamesThatFailed, CFixedBSTRArray::Free);

    // We will throw exceptions in OOM scenarios

    // Get the names of the qualifiers in each set.

    HRESULT hr = qsThat.EnumPrimaryQualifiers( WBEM_FLAG_LOCAL_ONLY, 0, astrNamesThat, astrNamesThatFailed );
    
    if ( FAILED( hr ) )
    {

        // Throw an exception if OOM
        if ( WBEM_E_OUT_OF_MEMORY == hr )
        {
            throw CX_MemoryException();
        }

        return FALSE;
    }

    // Names in the new set are checked against the old set.
    // Enum the qualifiers, checking that names and values
    // match.

    for (   int i = 0;
            fReturn && i < astrNamesThat.GetLength();
            i++ )
    {

        CQualifier* pQualifierThis = GetQualifierLocally( astrNamesThat[i] );
        CQualifier* pQualifierThat = qsThat.GetQualifierLocally( astrNamesThat[i] );

        // Make sure we got a value from the new set
        if ( NULL != pQualifierThat )
        {
            // We handle things differently depending on whether or
            // not the qualifier exists in the previous version
            if ( NULL != pQualifierThis )
            {

                // Note here that for important qualifiers, we will
                // already have made sure that those values matched up
                // (most are hardcoded anyways).  Reconciliation
                // mostly applies to unimportant qualifiers.

                // If flavors are equal, we're fine.  If not, check for
                // propagation flags.

                if ( pQualifierThat->fFlavor != pQualifierThis->fFlavor )
                {
                
                    if ( CQualifierFlavor::DoesPropagateToInstances(
                            pQualifierThat->fFlavor )
                        || CQualifierFlavor::DoesPropagateToDerivedClass(
                            pQualifierThat->fFlavor ) )
                    {

                        // If it's propagated, then if it is not overrideable
                        // check that the previous value was also not
                        // overrideable.

                        if ( !CQualifierFlavor::IsOverridable(
                                    pQualifierThat->fFlavor ) )
                        {

                            // If the previous value was overrideable,
                            // changing this class could affect existing
                            // instances/derived classes so this will
                            // fail

                            if ( !CQualifierFlavor::IsOverridable(
                                    pQualifierThis->fFlavor ) )
                            {
                                // if it was not overrideable, then the previous
                                // propagation flags MUST match or we will
                                // fail the operation, since we may now be propagating
                                // to an entity to which we were not previously
                                // doing so.

                                fReturn = ( (   CQualifierFlavor::DoesPropagateToInstances(
                                                    pQualifierThis->fFlavor ) ==
                                                CQualifierFlavor::DoesPropagateToInstances(
                                                    pQualifierThat->fFlavor )   )   &&
                                            (   CQualifierFlavor::DoesPropagateToDerivedClass(
                                                    pQualifierThis->fFlavor ) ==
                                                CQualifierFlavor::DoesPropagateToDerivedClass(
                                                    pQualifierThat->fFlavor )   )   );
                            }
                            else
                            {

                                fReturn = FALSE;
                            }

                        }   // IF not overrideable

                    }   // IF propagated

                }   // IF flavors did not match

            }   // IF got that qualifier
            else
            {
                // If we are here, the qualifier is a new one.

                // If the qualifier propagates to instances/
                // derived classes, then we need to check if
                // the qualifier is overrideable.  If not, then
                // we will fail, because existing classes/instances
                // may have unknowingly already overridden this
                // qualifier.

                if ( CQualifierFlavor::DoesPropagateToInstances(
                        pQualifierThat->fFlavor )
                    || CQualifierFlavor::DoesPropagateToDerivedClass(
                        pQualifierThat->fFlavor ) )
                {
                    fReturn = CQualifierFlavor::IsOverridable(
                            pQualifierThat->fFlavor );
                }   // IF qualifier propagated

            }   // ELSE no qualifier in this

        }   // IF NULL != pQualifierThat
        else
        {
            // WHOOPS!  Got a name but no qualifier...something is wrong
            fReturn = FALSE;
        }

    }   // FOR enum qualifiers

    return fReturn;
}

//******************************************************************************
//
//  See fastqual.h for documentation.
//
//******************************************************************************
CQualifierSet::CQualifierSet(int nPropagationFlag, int nStartRef) :
  m_nCurrentIndex(-1), m_nPropagationFlag(nPropagationFlag),
      m_nRef(nStartRef)
{
    ObjectCreated(OBJECT_TYPE_QUALIFIER,this);
}
CQualifierSet::~CQualifierSet()
{
    m_astrCurrentNames.Free();
    ObjectDestroyed(OBJECT_TYPE_QUALIFIER,this);
}

// Like doing a set, but only performs validaton
HRESULT CQualifierSet::ValidateSet(COPY LPCWSTR wszName, 
                     BYTE fFlavor,
                     COPY CTypedValue* pNewValue,
                     BOOL bCheckPermissions,
					 BOOL fValidateName )
{

    // Try to find it first
    // ====================

    HRESULT hr = WBEM_S_NO_ERROR;
    int nKnownIndex;
    CQualifier* pOldQual = GetQualifierLocally(wszName, nKnownIndex);

    // Special case "key"
    // ==================

    if(!wbem_wcsicmp(wszName, L"key"))
    {
        if  ( bCheckPermissions )
        {
            hr = m_pContainer->CanContainKey();

            if ( FAILED( hr ) )
            {
                return hr;
            }
        }

        // Key properties cannnot be dynamic
        if ( NULL != GetQualifier( L"dynamic" ) )
        {
            return WBEM_E_INVALID_QUALIFIER;
        }

        // Must be a BOOLEAN and not an array
        if (    CIM_BOOLEAN !=  pNewValue->GetType().GetActualType()
            ||  pNewValue->GetType().IsArray() )
        {
            return WBEM_E_INVALID_QUALIFIER_TYPE;
        }

        // Flavor values are enforced here.
        fFlavor = ENFORCED_KEY_FLAVOR;
    }

    // Special case "singleton"
    // ========================

    if(!wbem_wcsicmp(wszName, L"singleton"))
    {
        if( bCheckPermissions )
        {
            hr = m_pContainer->CanContainSingleton();

            if ( FAILED( hr ) )
            {
                return hr;
            }
        }

        // Must be a BOOLEAN and not an array
        if (    CIM_BOOLEAN !=  pNewValue->GetType().GetActualType()
            ||  pNewValue->GetType().IsArray() )
        {
            return WBEM_E_INVALID_QUALIFIER_TYPE;
        }

        // Flavor values are enforced here.
        fFlavor = ENFORCED_SINGLETON_FLAVOR;
    }

    // Special case "dynamic"
    // ========================

    if(!wbem_wcsicmp(wszName, L"dynamic"))
    {
        // Check that the container will allow this
        if ( bCheckPermissions )
        {
            hr = m_pContainer->CanContainDynamic();

            if ( FAILED( hr ) )
            {
                return hr;
            }
        }

        // Dynamic properties cannnot be keys
        if ( NULL != GetQualifier( L"key" ) )
        {
            return WBEM_E_INVALID_QUALIFIER;
        }

        // Must be a BOOLEAN and not an array
        if (    CIM_BOOLEAN !=  pNewValue->GetType().GetActualType()
            ||  pNewValue->GetType().IsArray() )
        {
            return WBEM_E_INVALID_QUALIFIER_TYPE;
        }

        fFlavor |= WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE;
    }

    // Special case "indexed"
    // ======================

    if(!wbem_wcsicmp(wszName, L"indexed"))
    {
        // Must be a BOOLEAN and not an array
        if (    CIM_BOOLEAN !=  pNewValue->GetType().GetActualType()
            ||  pNewValue->GetType().IsArray() )
        {
            return WBEM_E_INVALID_QUALIFIER_TYPE;
        }

        // Flavor values are enforced here.
        fFlavor = ENFORCED_INDEXED_FLAVOR;
    }

    // Special case "abstract"
    // ======================

    if(!wbem_wcsicmp(wszName, L"abstract"))
    {
        // Must be a BOOLEAN and not an array
        if (    CIM_BOOLEAN !=  pNewValue->GetType().GetActualType()
            ||  pNewValue->GetType().IsArray() )
        {
            return WBEM_E_INVALID_QUALIFIER_TYPE;
        }

        if( bCheckPermissions )
        {
            hr = m_pContainer->CanContainAbstract( pNewValue->GetBool() );

            if ( FAILED( hr ) )
            {
                return hr;
            }
        }

    }

    // Special case "cimtype"
    // ======================

    if(!wbem_wcsicmp(wszName, L"cimtype"))
    {
        if(bCheckPermissions)
        {
            if(pNewValue->GetType().GetActualType() != CIM_STRING)
                return WBEM_E_INVALID_QUALIFIER;

            // Cleanup the BSTR when we fall out of scope
            BSTR str = GetHeap()->ResolveString(pNewValue->AccessPtrData())->
                            CreateBSTRCopy();
            CSysFreeMe  sfm( str );

            // Check for allocation failures
            if ( NULL == str )
            {
                return WBEM_E_OUT_OF_MEMORY;
            }

            BOOL bValid = m_pContainer->CanHaveCimtype(str);
            if(!bValid)
                return WBEM_E_INVALID_QUALIFIER;
        }
        // Flavor values are enforced here.
        fFlavor = ENFORCED_CIMTYPE_FLAVOR;

    }

    // See if we were successful
    // =========================

    if(pOldQual != NULL)
    {
        // Verify if this property is local or overridable
        // ===============================================

        if(bCheckPermissions &&
            !pOldQual->fFlavor.IsLocal() &&
            !pOldQual->fFlavor.IsOverridable())
        {
            return WBEM_E_OVERRIDE_NOT_ALLOWED;
        }

    }
    else
    {
        // This qualifier was not found.
        // =============================

        // If required, check that our class does not prevent us from
        // overriding this qualifier
        // ==========================================================

        if(bCheckPermissions && !IsComplete())
        {
            if(nKnownIndex >= 0)
            {
                pOldQual = m_pSecondarySet->GetKnownQualifierLocally(nKnownIndex);
            }
            else
            {
                pOldQual = m_pSecondarySet->GetRegularQualifierLocally(wszName);
            }

            // Can't set if qualifier exists in secondary, propagates to us,
            // and marked as non-overridable
            // =============================================================

            if(pOldQual &&
                (pOldQual->fFlavor.GetPropagation() & m_nPropagationFlag) &&
                !pOldQual->fFlavor.IsOverridable())
            {
                return WBEM_E_OVERRIDE_NOT_ALLOWED;
            }
        }

        // Check the name for validity
        // ===========================

        if( fValidateName && !IsValidElementName(wszName,g_IdentifierLimit))
            return WBEM_E_INVALID_PARAMETER;

    }

    return WBEM_NO_ERROR;

}


HRESULT CQualifierSet::
SetQualifierValue(LPCWSTR wszName,
        BYTE fFlavor,
        COPY CTypedValue* pNewValue,
        BOOL bCheckPermissions,
        BOOL fValidateName /* = TRUE */)
{
    // IMPORTANT: Assumes that pNewValue is permanent!!!
    // =================================================

    // Try to find it first
    // ====================

    HRESULT hr = WBEM_S_NO_ERROR;
    int nKnownIndex;
    CQualifier* pOldQual = GetQualifierLocally(wszName, nKnownIndex);

    // Special case "key"
    // ==================

    if(!wbem_wcsicmp(wszName, L"key"))
    {
        if  ( bCheckPermissions )
        {
            hr = m_pContainer->CanContainKey();

            if ( FAILED( hr ) )
            {
                return hr;
            }
        }

        // Key properties cannnot be dynamic
        if ( NULL != GetQualifier( L"dynamic" ) )
        {
            return WBEM_E_INVALID_QUALIFIER;
        }

        // Must be a BOOLEAN and not an array
        if (    CIM_BOOLEAN !=  pNewValue->GetType().GetActualType()
            ||  pNewValue->GetType().IsArray() )
        {
            return WBEM_E_INVALID_QUALIFIER_TYPE;
        }

        // Flavor values are enforced here.
        fFlavor = ENFORCED_KEY_FLAVOR;
    }

    // Special case "singleton"
    // ========================

    if(!wbem_wcsicmp(wszName, L"singleton"))
    {
        if( bCheckPermissions )
        {
            hr = m_pContainer->CanContainSingleton();

            if ( FAILED( hr ) )
            {
                return hr;
            }
        }

        // Must be a BOOLEAN and not an array
        if (    CIM_BOOLEAN !=  pNewValue->GetType().GetActualType()
            ||  pNewValue->GetType().IsArray() )
        {
            return WBEM_E_INVALID_QUALIFIER_TYPE;
        }

        // Flavor values are enforced here.
        fFlavor = ENFORCED_SINGLETON_FLAVOR;
    }

    // Special case "dynamic"
    // ========================

    if(!wbem_wcsicmp(wszName, L"dynamic"))
    {
        // Check that the container will allow this
        if ( bCheckPermissions )
        {
            hr = m_pContainer->CanContainDynamic();

            if ( FAILED( hr ) )
            {
                return hr;
            }
        }

        // Dynamic properties cannnot be keys
        if ( NULL != GetQualifier( L"key" ) )
        {
            return WBEM_E_INVALID_QUALIFIER;
        }

        // Must be a BOOLEAN and not an array
        if (    CIM_BOOLEAN !=  pNewValue->GetType().GetActualType()
            ||  pNewValue->GetType().IsArray() )
        {
            return WBEM_E_INVALID_QUALIFIER_TYPE;
        }

        fFlavor |= WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE;
    }

    // Special case "indexed"
    // ======================

    if(!wbem_wcsicmp(wszName, L"indexed"))
    {
        // Must be a BOOLEAN and not an array
        if (    CIM_BOOLEAN !=  pNewValue->GetType().GetActualType()
            ||  pNewValue->GetType().IsArray() )
        {
            return WBEM_E_INVALID_QUALIFIER_TYPE;
        }

        // Flavor values are enforced here.
        fFlavor = ENFORCED_INDEXED_FLAVOR;
    }

    // Special case "abstract"
    // ======================

    if(!wbem_wcsicmp(wszName, L"abstract"))
    {
        // Must be a BOOLEAN and not an array
        if (    CIM_BOOLEAN !=  pNewValue->GetType().GetActualType()
            ||  pNewValue->GetType().IsArray() )
        {
            return WBEM_E_INVALID_QUALIFIER_TYPE;
        }

        if( bCheckPermissions )
        {
            hr = m_pContainer->CanContainAbstract( pNewValue->GetBool() );

            if ( FAILED( hr ) )
            {
                return hr;
            }
        }

    }

    // Special case "cimtype"
    // ======================

    if(!wbem_wcsicmp(wszName, L"cimtype"))
    {
        if(bCheckPermissions)
        {
            if(pNewValue->GetType().GetActualType() != CIM_STRING)
                return WBEM_E_INVALID_QUALIFIER;

            // Cleanup the BSTR when we fall out of scope
            BSTR str = GetHeap()->ResolveString(pNewValue->AccessPtrData())->
                            CreateBSTRCopy();
            CSysFreeMe  sfm( str );

            // Check for allocation failures
            if ( NULL == str )
            {
                return WBEM_E_OUT_OF_MEMORY;
            }

            BOOL bValid = m_pContainer->CanHaveCimtype(str);
            if(!bValid)
                return WBEM_E_INVALID_QUALIFIER;
        }
        // Flavor values are enforced here.
        fFlavor = ENFORCED_CIMTYPE_FLAVOR;

    }

    // See if we were successful
    // =========================

    if(pOldQual != NULL)
    {
        // Verify if this property is local or overridable
        // ===============================================

        if(bCheckPermissions &&
            !pOldQual->fFlavor.IsLocal() &&
            !pOldQual->fFlavor.IsOverridable())
        {
            return WBEM_E_OVERRIDE_NOT_ALLOWED;
        }

        // See if there is enoung room for the new one
        // ===========================================

        int nNewLen = pNewValue->GetLength();
        int nOldLen = pOldQual->Value.GetLength();

        if(nNewLen > nOldLen)
        {
            int nShift = nNewLen - nOldLen;

            // Request more room from the container.
            // (will copy us there if required)
            // ================================

            int nOldQualOffset = LPMEMORY(pOldQual) - GetStart();
            if (!m_pContainer->ExtendQualifierSetSpace(this,GetLength() + nShift))
            {
                return WBEM_E_OUT_OF_MEMORY;
            }

	        // Delete old value here, since from now on it will work
	        pOldQual->Value.Delete(GetHeap());
            
            pOldQual = (CQualifier*)(GetStart() + nOldQualOffset);

            // Insert necessary space at the end of the old value
            // ==================================================

            InsertSpace(GetStart(), GetLength(), pOldQual->Next(), nShift);
            IncrementLength(nShift);

        }
        else if(nNewLen < nOldLen)
        {
       		// Delete old value here, since from now on it will work
	        pOldQual->Value.Delete(GetHeap());
	        
            // Move the tail back by the difference
            // ====================================

            LPMEMORY pTail = LPMEMORY(pOldQual->Next());
            int nShift = nOldLen - nNewLen;

            memmove((void*)(pTail-nShift), (void*)pTail,
                m_nLength-(pTail-GetStart())
            );

            // Give space back to the container
            // ================================

            m_pContainer->ReduceQualifierSetSpace(this, nShift);

            IncrementLength(-nShift);
        }
        else // nNewLen == nOldLen
        {
       		// Delete old value here, since from now on it will work
	        pOldQual->Value.Delete(GetHeap());        
        };
        // Now that we either had or made enough space, copy the value
        // ===========================================================

        pOldQual->fFlavor = fFlavor;

        // No Heap allocations here.
        pNewValue->CopyTo(&pOldQual->Value);
    }
    else
    {
        // This qualifier was not found.
        // =============================

        // If required, check that our class does not prevent us from
        // overriding this qualifier
        // ==========================================================

        if(bCheckPermissions && !IsComplete())
        {
            if(nKnownIndex >= 0)
            {
                pOldQual = m_pSecondarySet->GetKnownQualifierLocally(nKnownIndex);
            }
            else
            {
                pOldQual = m_pSecondarySet->GetRegularQualifierLocally(wszName);
            }

            // Can't set if qualifier exists in secondary, propagates to us,
            // and marked as non-overridable
            // =============================================================

            if(pOldQual &&
                (pOldQual->fFlavor.GetPropagation() & m_nPropagationFlag) &&
                !pOldQual->fFlavor.IsOverridable())
            {
                return WBEM_E_OVERRIDE_NOT_ALLOWED;
            }
        }

        // Check the name for validity
        // ===========================

        if( fValidateName && !IsValidElementName(wszName,g_IdentifierLimit))
            return WBEM_E_INVALID_PARAMETER;

        // Can add (at the end of the list)
        // ================================

        // Allocate the name on the heap, if not well-known
        // ================================================

        heapptr_t ptrName;
        if(nKnownIndex < 0)
        {

            // Check for memory allocation errors.
            if ( !GetHeap()->AllocateString(wszName, ptrName) )
            {
                return WBEM_E_OUT_OF_MEMORY;
            }

            // NOTE: above could have moved us!!!!
            // ===================================

            if(!SelfRebase())
                return WBEM_E_INVALID_PROPERTY;
        }
        else
        {
            ptrName = CFastHeap::MakeFakeFromIndex(nKnownIndex);
        }


        // Request more room from the container
        // ====================================

        int nShift = CQualifier::GetHeaderLength() + pNewValue->GetLength();

        if (!m_pContainer->ExtendQualifierSetSpace(this, GetLength() + nShift))
        	return WBEM_E_OUT_OF_MEMORY;

        // Place the new qualifier at the end of the list
        // ==============================================

        CQualifier* pNewQual = (CQualifier*)Skip();
        pNewQual->ptrName = ptrName;
        pNewQual->fFlavor = fFlavor;

        // No Heap allocations here.
        pNewValue->CopyTo(&pNewQual->Value);

        // Change list length accordingly
        // ==============================

        IncrementLength(nShift);
    }

    return WBEM_NO_ERROR;
}


//******************************************************************************
//
//  See fastqual.h for documentation.
//
//******************************************************************************
HRESULT CQualifierSet::
DeleteQualifier(READ_ONLY LPCWSTR wszName, BOOL bCheckPermissions)
{
    // Try to find it first
    // ====================

    int nKnownIndex;
    CQualifier* pOldQual = GetQualifierLocally(wszName, nKnownIndex);

    // See if we were successful
    // =========================

    if(pOldQual != NULL)
    {
        // Make sure that it is not a cached parent's value
        // ================================================

        if(bCheckPermissions && !pOldQual->fFlavor.IsLocal())
        {
            return WBEM_E_PROPAGATED_QUALIFIER;
        }

        // Delete the value (if it is a string, for instance)
        // ==================================================

        pOldQual->Delete(GetHeap());

        // Move the tail back by the qualifier size
        // ========================================

        LPMEMORY pTail = LPMEMORY(pOldQual->Next());
        int nShift = pOldQual->GetLength();

        memmove((void*)(pTail-nShift), (void*)pTail,
            m_nLength-(pTail-GetStart())
        );

        // Give space back to the container
        // ================================

        m_pContainer->ReduceQualifierSetSpace(this, nShift);

        IncrementLength(-nShift);

        return WBEM_NO_ERROR;
    }
    else
    {
        // Wasn't there to begin with
        // ==========================

        return WBEM_E_NOT_FOUND;
    }
}

//******************************************************************************
//
//  See fastqual.h for documentation.
//
//******************************************************************************

STDMETHODIMP CQualifierSet::
Get(LPCWSTR Name, LONG lFlags, VARIANT *pVal, long* plFlavor)
{
    try
    {
        CWbemObject::CLock  lock( (CWbemObject*)(IWbemObjectAccess*)  m_pControl );

        if(Name == NULL || wcslen(Name) == 0) return WBEM_E_INVALID_PARAMETER;
        if(lFlags != 0) return WBEM_E_INVALID_PARAMETER;

        if(!SelfRebase()) return WBEM_E_INVALID_PROPERTY;

        BOOL bIsLocal;
        CQualifier* pQualifier = GetQualifier(Name, bIsLocal);
        if(pQualifier == NULL) return WBEM_E_NOT_FOUND;

        // Set the flavor
        // ==============

        if(plFlavor)
        {
            *plFlavor = pQualifier->fFlavor;
            if(!bIsLocal)
            {
                CQualifierFlavor::SetLocal(*(BYTE*)plFlavor, FALSE);
            }
        }

        // Set the value
        // =============

        CVar Var;

        // Check for allocation failures
        if ( !pQualifier->Value.StoreToCVar(Var,
                (bIsLocal)?GetHeap():m_pSecondarySet->GetHeap()) )
        {
            return WBEM_E_OUT_OF_MEMORY;
        }

        if(pVal)
        {
            VariantInit(pVal);
            Var.FillVariant(pVal, TRUE);
        }
        return WBEM_NO_ERROR;

    }
    catch( CX_MemoryException )
    {
        return WBEM_E_OUT_OF_MEMORY;
    }
    catch(...)
    {
        return WBEM_E_FAILED;
    }
}

//******************************************************************************
//
//  See fastqual.h for documentation.
//
//******************************************************************************

HRESULT STDMETHODCALLTYPE CQualifierSet::
Put(LPCWSTR Name, VARIANT *pVal, long lFlavor)
{
    try
    {
        CWbemObject::CLock lock( (CWbemObject*)(IWbemObjectAccess*) m_pControl );

        if(Name == NULL || pVal == NULL)
            return WBEM_E_INVALID_PARAMETER;

        // Verify flavor validity
        // ======================

        if(lFlavor & ~WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE &
            ~WBEM_FLAVOR_FLAG_PROPAGATE_TO_DERIVED_CLASS &
            ~WBEM_FLAVOR_NOT_OVERRIDABLE &
            ~WBEM_FLAVOR_AMENDED)
        {
            // Note: no origin flavor other than local is allowed
            // ==================================================

            return WBEM_E_INVALID_PARAMETER;
        }

        // Verifty that the type is one of allowed ones
        // ============================================

        if(!IsValidQualifierType(V_VT(pVal)))
        {
            return WBEM_E_INVALID_QUALIFIER_TYPE;
        }

        // Verify that the name is not a system one
        // ========================================

        if(Name[0] == L'_')
        {
            return WBEM_E_INVALID_PARAMETER;
        }

        // Other operations could have moved us. Rebase from container
        // ===========================================================

        if(!SelfRebase())
            return WBEM_E_INVALID_PROPERTY;

        // Make sure flavor is valid
        // =========================

        if(!CQualifierFlavor::IsLocal((BYTE)lFlavor))
        {
            return WBEM_E_INVALID_PARAMETER;
        }

        // Construct typed value from the VARIANT
        // ======================================

        CVar Var;
        Var.SetVariant(pVal, TRUE);

        if(Var.IsDataNull())
            return WBEM_E_INVALID_PARAMETER;

        CTypedValue TypedValue;
        CStaticPtr ValuePtr((LPMEMORY)&TypedValue);

        // Check returns from the following calls
        HRESULT hres = CTypedValue::LoadFromCVar(&ValuePtr, Var, GetHeap());

        if ( SUCCEEDED( hres ) )
        {
            if( SelfRebase() )
            {
                // Set it in the primary qualifier set (checking permissions)
                // ==========================================================

                hres = SetQualifierValue(Name, (BYTE)lFlavor, &TypedValue, TRUE);
                EndEnumeration();
            }
            else
            {
                hres = WBEM_E_INVALID_PROPERTY;
            }

        }

        return hres;
    }
    catch( CX_MemoryException )
    {
        return WBEM_E_OUT_OF_MEMORY;
    }
    catch(...)
    {
        return WBEM_E_FAILED;
    }
}

//******************************************************************************
//
//  See fastqual.h for documentation.
//
//******************************************************************************
HRESULT STDMETHODCALLTYPE CQualifierSet::Delete(LPCWSTR Name)
{
    try
    {
        CWbemObject::CLock lock( (CWbemObject*)(IWbemObjectAccess*) m_pControl );

        if(Name == NULL)
            return WBEM_E_INVALID_PARAMETER;

        // Deletion of CIMTYPE qualifier is not allowed.
        // =============================================

        if(!wbem_wcsicmp(Name, TYPEQUAL))
            return WBEM_E_INVALID_PARAMETER;

        if(!SelfRebase())
            return WBEM_E_INVALID_PROPERTY;

        // Delete it from the primary qualifier set (checking permissions)
        // ===============================================================

        HRESULT hres = DeleteQualifier(Name, TRUE);
        EndEnumeration();

        if(hres == WBEM_E_PROPAGATED_QUALIFIER)
        {
            // This means that this qualifier is inherited. Deleting it is a noop
            // ==================================================================

            return WBEM_E_PROPAGATED_QUALIFIER;
        }

        if(!IsComplete())
        {
            // The qualifier may be hiding in the secondary set.
            // =================================================

            CQualifier* pQualifier = m_pSecondarySet->GetQualifierLocally(Name);
            if(pQualifier &&
                (pQualifier->fFlavor.GetPropagation() & m_nPropagationFlag))
            {
                if(hres == WBEM_E_NOT_FOUND)
                    return WBEM_E_PROPAGATED_QUALIFIER;
                else
                    return WBEM_S_RESET_TO_DEFAULT;
            }
        }

        if(hres == WBEM_S_NO_ERROR && IsComplete() && m_pSecondarySet != NULL)
        {
            // If this qualifier exists in our parent and propagates to us, we
            // need to insert the parent's version into our set now
            // ===============================================================

            CQualifier* pParentQualifier =
                m_pSecondarySet->GetQualifierLocally(Name);
            if(pParentQualifier &&
                (pParentQualifier->fFlavor.GetPropagation() & m_nPropagationFlag))
            {
                CQualifierFlavor fParentFlavor = pParentQualifier->fFlavor;
                fParentFlavor.SetLocal(FALSE);

                CTypedValue Value;

                // No Heap allocations here.
                pParentQualifier->Value.CopyTo(&Value);

                CStaticPtr ValuePtr((LPMEMORY)&Value);

                // Check for allocation failures
                if ( !CTypedValue::TranslateToNewHeap(&ValuePtr,
                                                m_pSecondarySet->GetHeap(),
                                                GetHeap()) )
                {
                    return WBEM_E_OUT_OF_MEMORY;
                }

				// NOTE: TranslateToNewHeap may have invalidated our pointers, so we need to rebase.
				SelfRebase();

                SetQualifierValue(Name, fParentFlavor, &Value, FALSE);
                return WBEM_S_RESET_TO_DEFAULT;
            }
        }

        return hres;
    }
    catch( CX_MemoryException )
    {
        return WBEM_E_OUT_OF_MEMORY;
    }
    catch(...)
    {
        return WBEM_E_FAILED;
    }

}

//******************************************************************************
//
//  See fastqual.h for documentation.
//
//******************************************************************************
HRESULT STDMETHODCALLTYPE CQualifierSet::
GetNames(long lFlags, LPSAFEARRAY *pNames)
{
    try
    {
        CWbemObject::CLock lock( (CWbemObject*)(IWbemObjectAccess*)  m_pControl );

        if(pNames == NULL)
            return WBEM_E_INVALID_PARAMETER;
        *pNames = NULL;

        if(lFlags != 0 && lFlags != WBEM_FLAG_LOCAL_ONLY &&
                lFlags != WBEM_FLAG_PROPAGATED_ONLY )
        {
            return WBEM_E_INVALID_PARAMETER;
        }

        if(!SelfRebase())
            return WBEM_E_INVALID_PROPERTY;

        // Get a regular array of them
        // ===========================

        CFixedBSTRArray astrNames;
	 ON_BLOCK_EXIT_OBJ(astrNames, CFixedBSTRArray::Free);                

	 HRESULT hr = EnumQualifiers((BYTE)lFlags, 0, // no propagation restrictions
            astrNames);
	if (FAILED(hr)) return hr;

        CSafeArray saNames(VT_BSTR, CSafeArray::no_delete,  astrNames.GetLength());
        ScopeGuard names = MakeObjGuard(saNames, CSafeArray::Empty);

        for(int i = 0; i < astrNames.GetLength(); i++)
        {
            saNames.AddBSTR(astrNames[i]);
        }

	names.Dismiss();	// Don't call Empty
	*pNames = saNames.GetArray();

        return WBEM_S_NO_ERROR;

    }
    catch( CX_MemoryException )
    {
        return WBEM_E_OUT_OF_MEMORY;
    }
    catch(...)
    {
        return WBEM_E_FAILED;
    }

}

//******************************************************************************
//
//  See fastqual.h for documentation.
//
//******************************************************************************
HRESULT CQualifierSet::
EnumQualifiers(BYTE eFlags, BYTE fFlavorMask, CFixedBSTRArray& astrNames)
{
    try
    {
        CWbemObject::CLock lock( (CWbemObject*) (IWbemObjectAccess*) m_pControl );

        // Divide local qualifiers into those matching and not macching the
        // criteria
        // ================================================================

        CFixedBSTRArray astrPrimaryMatching, astrPrimaryNotMatching;
	 ON_BLOCK_EXIT_OBJ(astrPrimaryMatching, CFixedBSTRArray::Free);
        ON_BLOCK_EXIT_OBJ(astrPrimaryNotMatching, CFixedBSTRArray::Free);

        HRESULT hr = EnumPrimaryQualifiers(eFlags, fFlavorMask,
                    astrPrimaryMatching, astrPrimaryNotMatching);

        if ( FAILED(hr) )
        {
            return hr;
        }

        // Get our parent's qualifiers, if required
        // ========================================

        CFixedBSTRArray astrParentMatching, astrParentNotMatching;
	 ON_BLOCK_EXIT_OBJ(astrParentMatching, CFixedBSTRArray::Free);

        if(!IsComplete() && eFlags != WBEM_FLAG_LOCAL_ONLY)
        {

            hr = m_pSecondarySet->EnumPrimaryQualifiers(
                    0,                      // need both local and propagated ---
                                            // our own flags do not apply, since all
                                            // parent's qualifiers are "propagated"
                                            // from our perspective

                    fFlavorMask |
                    m_nPropagationFlag,    // we need our parent's qualifiers which
                                            // satisfy both: a) it propagates to us and
                                            // b) it propagates as required by our mask
                    astrParentMatching,
                    astrParentNotMatching
                );

            // Check for allocation failures
            if ( FAILED(hr) )
            {
                return hr;
            }
        }

        astrParentNotMatching.Free();

        // Now, we need to produce the following merge: all the elements in the
        // astrLocalMatching, plus all the elements in astrParentMatching which are
        // not in astrLocalNotMatching. The reason for this is that even if our
        // parent thinks that a qualifier propagates as requested, we may have
        // overriden it and changed the propagation rules.
        // ======================================================================

        astrNames.ThreeWayMergeOrdered(astrPrimaryMatching, astrParentMatching,
                            astrPrimaryNotMatching);

        return hr;

    }
    catch( CX_MemoryException )
    {
        return WBEM_E_OUT_OF_MEMORY;
    }
    catch(...)
    {
        return WBEM_E_FAILED;
    }


}

//******************************************************************************
//
//  See fastqual.h for documentation.
//
//******************************************************************************
BOOL CQualifierSet::Compare( CQualifierSet& qualifierset, CFixedBSTRArray* pExcludeNames /* = NULL */,
                                BOOL fCheckOrder /* = TRUE */ )
{
    BOOL            fReturn = TRUE;

    CFixedBSTRArray astrNamesThis,
                    astrNamesThat;

    ON_BLOCK_EXIT_OBJ(astrNamesThis, CFixedBSTRArray::Free);
    ON_BLOCK_EXIT_OBJ(astrNamesThat, CFixedBSTRArray::Free);

    // We will throw exceptions in OOM scenarios
    HRESULT hr = EnumQualifiers( 0, 0, astrNamesThis );
    
    // Get the names of the qualifiers in each set.
    if ( FAILED( hr ) )
    {
        if ( WBEM_E_OUT_OF_MEMORY == hr )
        {
            throw CX_MemoryException();
        }

        return FALSE;
    }

    hr = qualifierset.EnumQualifiers( 0, 0, astrNamesThat );

    if ( FAILED( hr ) )
    {
        if ( WBEM_E_OUT_OF_MEMORY == hr )
        {
            throw CX_MemoryException();
        }

        return FALSE;
    }

    // Each must have the same number of names
    if ( astrNamesThis.GetLength() == astrNamesThat.GetLength() )
    {
        
        // Enum the qualifiers, checking that names and values
        // match

        for (   int i = 0;
                fReturn && i < astrNamesThis.GetLength();
                i++ )
        {
            BOOL    fContinue = TRUE;
            BOOL    fFatal = FALSE;

            // If we got an exclude names array, check to see if the matching qualifier
            // is one we will ignore for this comparison.

            if ( NULL != pExcludeNames )
            {
                //
                for ( int nCtr = 0; fContinue && nCtr < pExcludeNames->GetLength();
                        nCtr++ )
                {
                    // In this case, we only continue if our name does not match any
                    // of the values in the array.  This is not a fatal error.
                    fContinue = ( wbem_wcsicmp( astrNamesThis[i],
                                    pExcludeNames->GetAt(nCtr) ) != 0 );
                }
            }
            else
            {
                if ( fCheckOrder )
                {
                    // In this case we continue only when the two names match
                    // This is a fatal error if it happens.
                    fContinue = ( wbem_wcsicmp( astrNamesThis[i], astrNamesThat[i] ) == 0 );
                    fFatal = !fContinue;
                }
            }

            // Only continue if we are supposed to.
            if ( fContinue )
            {
                BOOL    bIsLocalThis,
                        bIsLocalThat;

                CQualifier* pQualifierThis = GetQualifier( astrNamesThis[i], bIsLocalThis );

                // If order is not important, we just need to verify that the qualifier in
                // this set is also in that set
                CQualifier* pQualifierThat = qualifierset.GetQualifier(
                                ( fCheckOrder ? astrNamesThat[i] : astrNamesThis[i] ),
                                bIsLocalThat );

                // Must have qualifier pointers, flavors and IsLocal must match
                if (    NULL != pQualifierThis
                    &&  NULL != pQualifierThat
                    &&  bIsLocalThis == bIsLocalThat
                    &&  pQualifierThis->fFlavor == pQualifierThat->fFlavor )
                {
                    CVar    varThis,
                            varThat;

                    // Get CVar's from each qualifer

                    // We will throw exceptions in OOM scenarios

                    // Check for allocation failures
                    if ( !pQualifierThis->Value.StoreToCVar( varThis,
                            (bIsLocalThis)?GetHeap():m_pSecondarySet->GetHeap()) )
                    {
                        throw CX_MemoryException();
                    }

                    // Check for allocation failures
                    if ( !pQualifierThat->Value.StoreToCVar( varThat,
                            (bIsLocalThat)?qualifierset.GetHeap():
                            qualifierset.m_pSecondarySet->GetHeap()) )
                    {
                        throw CX_MemoryException();
                    }

                    // Types must match
                    if ( pQualifierThis->Value.GetType() == pQualifierThat->Value.GetType() )
                    {
                        // Compare the CVars
                        fReturn = ( varThis == varThat );
                    }
                    else
                    {
                        fReturn = FALSE;
                    }
                }   // IF got qualifiers, flavors and IsLocal match
                else
                {
                    fReturn = FALSE;
                }

            }   // IF names equal
            else if ( fFatal )
            {
                // fContinue of FALSE is ok if fFatal is not TRUE
                fReturn = FALSE;
            }

        }   // FOR iterate qualifier names

    }   // bstr Array lengths different
    else
    {
        fReturn = FALSE;
    }
    return fReturn;
}

//******************************************************************************
//
//  See fastqual.h for documentation.
//
//******************************************************************************
HRESULT CQualifierSet::Update( CBasicQualifierSet& childSet, long lFlags,
                              CFixedBSTRArray* paExcludeNames )
{
    try
    {
        HRESULT         hr = WBEM_S_NO_ERROR;
        CFixedBSTRArray aMatching, aNotMatching;

	 ON_BLOCK_EXIT_OBJ(aMatching, CFixedBSTRArray::Free);
        ON_BLOCK_EXIT_OBJ(aNotMatching, CFixedBSTRArray::Free);
        
        CVarVector      vectorConflicts( VT_BSTR );
        BOOL            fAddConflicts = FALSE;

        // Checks for allocation failures
        hr = childSet.EnumPrimaryQualifiers( WBEM_FLAG_LOCAL_ONLY, 0, aMatching, aNotMatching);

        for ( int x = 0; SUCCEEDED( hr ) && x < aMatching.GetLength(); x++ )
        {
            BOOL    fIgnore = FALSE;
            CQualifier* pQualifier = childSet.GetQualifierLocally( aMatching[x] );

            // If we got an Exclude Names qualifier, see if
            // we should ignore this qualifier
            if ( NULL != paExcludeNames )
            {
                for ( int i = 0; !fIgnore && i < paExcludeNames->GetLength(); i++ )
                {
                    // See if we should ignore this qualifier
                    fIgnore = ( wbem_wcsicmp( aMatching[x], paExcludeNames->GetAt(i) ) == 0 );
                }
            }

            // Only continue if we have a qualifier and are not supposed
            // to ignore it.
            if ( !fIgnore && NULL != pQualifier )
            {

                CVar    vTemp;
                CTypedValue Value;
                CStaticPtr ValuePtr((LPMEMORY)&Value);


                // Check for an out of memory condition
                if ( !pQualifier->Value.StoreToCVar( vTemp, childSet.GetHeap() ) )
                {
                    hr = WBEM_E_OUT_OF_MEMORY;
                }

                if ( SUCCEEDED( hr ) )
                {
                    // This will return errors as appropriate
                    hr = CTypedValue::LoadFromCVar(&ValuePtr, vTemp, GetHeap());
                }
                
                if( SUCCEEDED( hr ) )
                {
                    // The last call may have moved us --- rebase
                    // ==========================================

                    SelfRebase();

                    // We won't do any name validation if we are working with an Update Conflict
                    // qualifier.

                    BOOL    fValidateName = ( wbem_wcsicmp( aMatching[x], UPDATE_QUALIFIER_CONFLICT ) != 0 );

                    hr = SetQualifierValue( aMatching[x], pQualifier->fFlavor, &Value, TRUE, fValidateName );

                    // If we failed to set the value and we're in Force mode, then
                    // ignore the error

                    if (    FAILED( hr )
                        &&  WBEM_FLAG_UPDATE_FORCE_MODE == ( lFlags & WBEM_MASK_UPDATE_MODE ) )
                    {

                        // We will store all conflicts in an array, then add them
                        // all en masse at the end
                        hr = StoreQualifierConflicts( aMatching[x], vTemp, pQualifier->fFlavor,
                                vectorConflicts );
                        fAddConflicts = TRUE;

                    }   // IF Force Mode

                }   // IF LoadFromCVar

            }   // IF Qualifier and not ignored

        }   // FOR enum qualifiers

        // If we've succeded and encountered any conflicts, we need to account for
        // these now.

        if ( SUCCEEDED( hr ) && fAddConflicts )
        {
            hr = AddQualifierConflicts( vectorConflicts );
        }
        return hr;
    }
    catch( CX_MemoryException )
    {
        return WBEM_E_OUT_OF_MEMORY;
    }
    catch(...)
    {
        return WBEM_E_FAILED;
    }
}

//******************************************************************************
//
//  See fastqual.h for documentation.
//
//******************************************************************************
HRESULT CQualifierSet::CopyLocalQualifiers( CQualifierSet& qsSource )
{
    CFixedBSTRArray astrNamesThisProp,
                    astrNamesThisPropFailed;

	 ON_BLOCK_EXIT_OBJ(astrNamesThisProp, CFixedBSTRArray::Free);
        ON_BLOCK_EXIT_OBJ(astrNamesThisPropFailed, CFixedBSTRArray::Free);

    try
    {
        HRESULT hr = qsSource.EnumPrimaryQualifiers( WBEM_FLAG_LOCAL_ONLY, 0, astrNamesThisProp, astrNamesThisPropFailed );

        if ( SUCCEEDED ( hr ) )
        {
            for ( int i = 0; SUCCEEDED( hr ) && i < astrNamesThisProp.GetLength(); i++ )
            {
                // We know the qualifier is local
                CQualifier* pQualifier = qsSource.GetQualifierLocally( astrNamesThisProp[i] );

                if ( NULL != pQualifier )
                {
                    CVar    varQual;

                    if ( pQualifier->Value.StoreToCVar( varQual, qsSource.GetHeap() ) )
                    {
                        VARIANT v;

                        // DEVNOTE:TODO:SANJ - See if there's an easier way to do this
                        // Initialize the variant
                        VariantInit( &v );
                        varQual.FillVariant( &v, TRUE );	// throws
                         // Okay, put in the new value
                         hr = Put( astrNamesThisProp[i], &v, pQualifier->fFlavor );
             
                        // We Initialized above so call clear
                        VariantClear( &v );
                    }
                    else
                    {
                        hr = WBEM_E_OUT_OF_MEMORY;
                    }
                }
                else
                {
                    hr = WBEM_E_UNEXPECTED;
                }

            }   // FOR emumlocals

        }   // IF EnumedPrimaryQualifiers

        // Clear arrays.
        return hr;

    }
    catch( CX_MemoryException )
    {
        return WBEM_E_OUT_OF_MEMORY;
    }
    catch(...)
    {
        return WBEM_E_FAILED;
    }
}

//******************************************************************************
//
//  See fastqual.h for documentation.
//
//******************************************************************************
HRESULT CQualifierSet::AddQualifierConflicts( CVarVector& vectorConflicts )
{
    try
    {
        HRESULT     hr = WBEM_S_NO_ERROR;
        CVarVector  varArray( VT_BSTR );

        // If the qualifier already exists, we need to append our
        // new values to the existing array.
        CQualifier* pOldQualifier = GetQualifierLocally( UPDATE_QUALIFIER_CONFLICT );

        if ( NULL != pOldQualifier )
        {
            CVar    varOldQualValue;

            // If we got a value for the old qualifier, make sure it is
            // an array, if not, well, it should never have gotten here
            // so we're gonna bail.

            if ( pOldQualifier->Value.StoreToCVar( varOldQualValue, GetHeap() ) )
            {
                if ( varOldQualValue.GetType() == VT_EX_CVARVECTOR )
                {
                    // Copy the array
                    varArray = *(varOldQualValue.GetVarVector());
                }
                else
                {
                    hr = WBEM_E_INVALID_QUALIFIER;
                }
            }
            else
            {
                hr = WBEM_E_OUT_OF_MEMORY;
            }

        }   // IF NULL != pOldQualifier

        // Final check that things are in order
        if ( SUCCEEDED( hr ) )
        {

            // Enum the conflicts array and add these to any preexisting
            // values, then set the final value.

            for ( int x = 0; SUCCEEDED( hr ) && x < vectorConflicts.Size(); x++ )
            {
                if ( CVarVector::no_error != varArray.Add( vectorConflicts.GetAt(x) ) )
                {
                    hr = WBEM_E_OUT_OF_MEMORY;
                }
            }   // FOR enum elements in the array

            // Now we need to set the value.
            CVar    varQualConflictVal;

            // This is a stack variable, so the destination CVar should copy it.
            varQualConflictVal.SetVarVector( &varArray, FALSE );

            CTypedValue qualConflictValue;
            CStaticPtr qualConflictValuePtr((LPMEMORY)&qualConflictValue);

            // This function will return errors directly
            hr = CTypedValue::LoadFromCVar(&qualConflictValuePtr, varQualConflictVal, GetHeap());
            
            if( SUCCEEDED( hr ) )
            {
                // On this call, don't worry about override protection and don't validate
                // the name, since this qualifier is an internally provided system qualifier
                hr = SetQualifierValue( UPDATE_QUALIFIER_CONFLICT, 0, &qualConflictValue,
                        FALSE, FALSE );
            }
        }   // If new qualifier conflict Value ok

        return hr;

    }
    catch( CX_MemoryException )
    {
        return WBEM_E_OUT_OF_MEMORY;
    }
    catch(...)
    {
        return WBEM_E_FAILED;
    }
}

//******************************************************************************
//
//  See fastqual.h for documentation.
//
//******************************************************************************
HRESULT CQualifierSet::StoreQualifierConflicts( LPCWSTR pwcsName, CVar& value,
                            CQualifierFlavor& flavor, CVarVector& vectorConflicts )
{
    // Check for out of memory
    try
    {
        // Pretend everything's ok
        HRESULT hr = WBEM_S_NO_ERROR;

        CVar    varOldValAsText;

        // Start with name and parentheses
        WString wsOldText( pwcsName );
        wsOldText += L"(";

        // Get the variant in Text form.  Free the BSTR when we drop out of scope
        BSTR    bstrOldText = value.GetText(0);
        if(bstrOldText == NULL)
            return WBEM_E_OUT_OF_MEMORY;
	ScopeGuard releaseString = MakeGuard(COleAuto::_SysAllocString, bstrOldText);

        wsOldText += bstrOldText;

        // Add any flavor values
        wsOldText += flavor.GetText();

        // Finish with an RPAREN
        wsOldText += L")";

        // The call to SetBSTR() with the bAcquire value of TRUE will free the
        // BSTR returned by SysAllocString.
        varOldValAsText.SetBSTR( wsOldText);
        releaseString.Dismiss();

        // Only reason I can see this failing is we're out of memory
        if ( CVarVector::no_error != vectorConflicts.Add( varOldValAsText ) )
        {
            hr = WBEM_E_OUT_OF_MEMORY;
        }

        return hr;
    }
    catch (CX_MemoryException)
    {
        return WBEM_E_OUT_OF_MEMORY;
    }
    catch (...)
    {
        return WBEM_E_FAILED;
    }

}

//******************************************************************************
//
//  See fastqual.h for documentation.
//
//******************************************************************************
HRESULT STDMETHODCALLTYPE CQualifierSet::
BeginEnumeration(LONG lFlags)
{
    try
    {
        CWbemObject::CLock lock( (CWbemObject*) (IWbemObjectAccess*) m_pControl );

        if(lFlags != 0 && lFlags != WBEM_FLAG_LOCAL_ONLY &&
            lFlags != WBEM_FLAG_PROPAGATED_ONLY )
        {
            return WBEM_E_INVALID_PARAMETER;
        }

        if(!SelfRebase())
            return WBEM_E_INVALID_PROPERTY;

        // Get all the matching qualifier names into that array
        // ====================================================

        // Check for possible allocation failures
        HRESULT hr = EnumQualifiers((BYTE)lFlags, 0, m_astrCurrentNames);

        // Reset index data
        // ================
        if ( SUCCEEDED(hr) )
        {
            m_nCurrentIndex = 0;
        }

        return hr;
    }
    catch (CX_MemoryException)
    {
        return WBEM_E_OUT_OF_MEMORY;
    }
    catch (...)
    {
        return WBEM_E_FAILED;
    }
}

//******************************************************************************
//
//  See fastqual.h for documentation.
//
//******************************************************************************
HRESULT STDMETHODCALLTYPE CQualifierSet::
Next(LONG lFlags, BSTR *pstrName, VARIANT *pVal, long* plFlavor)
{
    try
    {
        CWbemObject::CLock lock( (CWbemObject*) (IWbemObjectAccess*) m_pControl );

        if(lFlags != 0)
            return WBEM_E_INVALID_PARAMETER;

        if(m_nCurrentIndex == -1)
            return WBEM_E_UNEXPECTED;

        if(m_nCurrentIndex == m_astrCurrentNames.GetLength())
            return WBEM_S_NO_MORE_DATA;

        if(!SelfRebase())
            return WBEM_E_INVALID_PROPERTY;

        // Get the next name
        // =================

        if(pstrName)
            *pstrName = COleAuto::_SysAllocString(m_astrCurrentNames[m_nCurrentIndex]);

        // Get the qualifier data
        // ======================

        HRESULT hr = Get(m_astrCurrentNames[m_nCurrentIndex], 0, pVal, plFlavor);
        if (FAILED(hr)) return hr;
        m_nCurrentIndex++;
        return WBEM_NO_ERROR;
    }
    catch (CX_MemoryException)
    {
        return WBEM_E_OUT_OF_MEMORY;
    }
    catch (...)
    {
        return WBEM_E_FAILED;
    }
}

//******************************************************************************
//
//  See fastqual.h for documentation.
//
//******************************************************************************
HRESULT STDMETHODCALLTYPE CQualifierSet::
EndEnumeration()
{
    try
    {
        CWbemObject::CLock lock( (CWbemObject*) (IWbemObjectAccess*) m_pControl );

        m_nCurrentIndex = -1;
        m_astrCurrentNames.Free();

        return WBEM_NO_ERROR;
    }
    catch (CX_MemoryException)
    {
        return WBEM_E_OUT_OF_MEMORY;
    }
    catch (...)
    {
        return WBEM_E_FAILED;
    }

}

//******************************************************************************
//
//  See fastqual.h for documentation.
//
//******************************************************************************
STDMETHODIMP CQualifierSet::
CompareTo(long lFlags, IWbemQualifierSet* pOther)
{
    try
    {
        HRESULT hres;

        // Get name arrays --- the only reason is to count them, really
        // ============================================================

        SAFEARRAY *psaThisQuals, *psaOtherQuals;
   
        GetNames(0, &psaThisQuals);
        pOther->GetNames(0, &psaOtherQuals);

        ON_BLOCK_EXIT(SafeArrayDestroy, psaThisQuals);

        long lThisNum, lOtherNum;
        SafeArrayGetUBound(psaThisQuals, 1, &lThisNum);
        SafeArrayGetUBound(psaOtherQuals, 1, &lOtherNum);
        SafeArrayDestroy(psaOtherQuals);

        if(lThisNum != lOtherNum)
        {
            return WBEM_S_DIFFERENT;
        }

        // The count is the same. Go through them one by one and compare
        // =============================================================

        for(long i = 0; i <= lThisNum; i++)
        {
            BSTR strName = NULL;

            hres = SafeArrayGetElement(psaThisQuals, &i, &strName);
            if(FAILED(hres))
            {
                return hres;
            }
            
            // Free this BSTR whenever we drop out of scope
            CSysFreeMe  sfm( strName );

            _variant_t vThis, vOther;
            long lThisFlavor, lOtherFlavor;
            hres = Get(strName, 0, &vThis, &lThisFlavor);
            if(FAILED(hres))
            {
                return hres;
            }

            CVar varThis;
            varThis.SetVariant(&vThis);

            hres = pOther->Get(strName, 0, &vOther, &lOtherFlavor);
            if(FAILED(hres))
            {
                if(hres == WBEM_E_NOT_FOUND) return WBEM_S_DIFFERENT;
                else return hres;
            }

            CVar varOther;
            varOther.SetVariant(&vOther);

            if((lFlags & WBEM_FLAG_IGNORE_FLAVOR) == 0)
            {
                if(lThisFlavor != lOtherFlavor)
                {
                    return WBEM_S_DIFFERENT;
                }
            }

            if(!varThis.CompareTo(varOther, lFlags & WBEM_FLAG_IGNORE_CASE))
            {
                return WBEM_S_DIFFERENT;
            }
        }

        return WBEM_S_SAME;
    }
    catch (CX_MemoryException)
    {
        return WBEM_E_OUT_OF_MEMORY;
    }
    catch (...)
    {
        return WBEM_E_FAILED;
    }
}

//*****************************************************************************
//*****************************************************************************
//*****************************************************************************
//*****************************************************************************
//*****************************************************************************

CClassPQSContainer::~CClassPQSContainer()
{
    delete m_pSecondarySet;
}

//******************************************************************************
//
//  See fastqual.h for documentation
//
//******************************************************************************
CFastHeap* CClassPQSContainer::GetHeap()
{
    return &m_pClassPart->m_Heap;
}

//******************************************************************************
//
//  See fastqual.h for documentation
//
//******************************************************************************
IUnknown* CClassPQSContainer::GetWbemObjectUnknown()
{
    return m_pClassPart->GetWbemObjectUnknown();
}

//******************************************************************************
//
//  See fastqual.h for documentation
//
//******************************************************************************
HRESULT CClassPQSContainer::CanContainKey()
{
    if(!m_pClassPart->CanContainKeyedProps()) return WBEM_E_CANNOT_BE_KEY;

    CPropertyInformation* pInfo = GetPropertyInfo();
    if(pInfo == NULL) return WBEM_E_CANNOT_BE_KEY;

    if ( !CType::CanBeKey(pInfo->nType) )
    {
        return WBEM_E_CANNOT_BE_KEY;
    }

    return WBEM_S_NO_ERROR;
}

//******************************************************************************
//
//  See fastqual.h for documentation
//
//******************************************************************************
HRESULT CClassPQSContainer::CanContainSingleton()
{
    return WBEM_E_INVALID_QUALIFIER;
}

//******************************************************************************
//
//  See fastqual.h for documentation
//
//******************************************************************************
HRESULT CClassPQSContainer::CanContainAbstract( BOOL fValue )
{
    return WBEM_E_INVALID_QUALIFIER;
}

//******************************************************************************
//
//  See fastqual.h for documentation
//
//******************************************************************************
HRESULT CClassPQSContainer::CanContainDynamic( void )
{
    return WBEM_S_NO_ERROR;
}

//******************************************************************************
//
//  See fastqual.h for documentation
//
//******************************************************************************
BOOL CClassPQSContainer::CanHaveCimtype(LPCWSTR wszCimtype)
{
    CPropertyInformation* pInfo = GetPropertyInfo();
    if(pInfo == NULL) return FALSE;

    CType Type = CType::GetBasic(pInfo->nType);
    if(Type == CIM_OBJECT)
    {
        if(!wbem_wcsicmp(wszCimtype, L"object") ||
            !wbem_wcsnicmp(wszCimtype, L"object:", 7))
        {
            return TRUE;
        }
        else
        {
            return FALSE;
        }
    }

    if(Type == CIM_REFERENCE)
    {
        if(!wbem_wcsicmp(wszCimtype, L"ref"))
            return TRUE;
        else if (!wbem_wcsnicmp(wszCimtype, L"ref:", 4))
        {
            //We need to check that the class following this is valid..
            if ((wcslen(wszCimtype)> 4) && IsValidElementName2(wszCimtype+4,g_IdentifierLimit, TRUE))
                return TRUE;
            else
                return FALSE;
        }
        else
        {
            return FALSE;
        }
    }

    return (wbem_wcsicmp(wszCimtype, CType::GetSyntax(Type)) == 0);
}

//******************************************************************************
//
//  See fastqual.h for documentation
//
//******************************************************************************
void CClassPQSContainer::SetSecondarySetData()
{
    CClassPart* pParentPart = m_pClassPart->m_pParent;
    if(m_nParentSetOffset == 0)
    {
        // Find the name of our property
        // =============================

        CPropertyLookup* pLookup =
            m_pClassPart->m_Properties.FindPropertyByPtr(m_ptrPropName);
        if(pLookup == NULL) return;

        CCompressedString* pcsName = m_pClassPart->m_Heap.ResolveString(
                                        pLookup->ptrName);

        // Find it in the parent
        // =====================

        pLookup = pParentPart->m_Properties.FindPropertyByName(pcsName);

        if(pLookup == NULL) return;

        CPropertyInformation* pInfo = (CPropertyInformation*)
            pParentPart->m_Heap.ResolveHeapPointer(pLookup->ptrInformation);

        m_nParentSetOffset =
            pInfo->GetQualifierSetData() - pParentPart->GetStart();
    }

    if(m_pSecondarySet == NULL)
    {
        m_pSecondarySet = new CBasicQualifierSet;

        if ( NULL == m_pSecondarySet )
        {
            throw CX_MemoryException();
        }
    }

    m_pSecondarySet->SetData(
        pParentPart->GetStart() + m_nParentSetOffset,
        pParentPart->GetHeap());
}

//******************************************************************************
//
//  See fastqual.h for documentation
//
//******************************************************************************
LPMEMORY CClassPQSContainer::GetQualifierSetStart()
{
    SetSecondarySetData();
    CPropertyInformation* pInfo = GetPropertyInfo();
    if(pInfo == NULL) return NULL;
    return pInfo->GetQualifierSetData();
}

//******************************************************************************
//
//  See fastqual.h for documentation
//
//******************************************************************************
CPropertyInformation* CClassPQSContainer::GetPropertyInfo()
{
    // Find the property all over again
    // ================================

    CPropertyLookup* pLookup =
        m_pClassPart->m_Properties.FindPropertyByPtr(m_ptrPropName);
    if(pLookup == NULL) return NULL;

    return (CPropertyInformation*)
        m_pClassPart->m_Heap.ResolveHeapPointer(pLookup->ptrInformation);
}

//******************************************************************************
//
//  See fastqual.h for documentation
//
//******************************************************************************
BOOL CClassPQSContainer::ExtendQualifierSetSpace(CBasicQualifierSet* pSet,
        length_t nNewLength)
{
    // Find the property all over again
    // ================================

    CPropertyLookup* pLookup =
        m_pClassPart->m_Properties.FindPropertyByPtr(m_ptrPropName);

    // DEVNOTE:TODO:SANJ - Is this right?  We didn't find the value so we really
    // can't extend anything.
    if(pLookup == NULL) return TRUE;

    // Extend CPropertyInformation's space on the heap
    // ===============================================

    // Check for Allocation failure
    heapptr_t ptrNewInfo;
    if ( !m_pClassPart->m_Heap.Reallocate(
        pLookup->ptrInformation,
        CPropertyInformation::GetHeaderLength() + pSet->GetLength(),
        CPropertyInformation::GetHeaderLength() + nNewLength,
        ptrNewInfo) )
    {
        return FALSE;
    }

    // Find the property again --- reallocation may have moved us
    // ==========================================================

    pLookup = m_pClassPart->m_Properties.FindPropertyByPtr(m_ptrPropName);

    // RAJESHR - Fix for prefix bug 144428
    if(pLookup == NULL) return TRUE;

    if(ptrNewInfo != pLookup->ptrInformation)
    {
        // Reset the pointer in the lookup table
        // =====================================

        pLookup->ptrInformation = ptrNewInfo;

        // Compute the new qualifier set data pointer
        // ==========================================

        LPMEMORY pNewMemory =
            m_pClassPart->m_Heap.ResolveHeapPointer(ptrNewInfo) +
            CPropertyInformation::GetHeaderLength();

        pSet->Rebase(pNewMemory);
    }

    // DEVNOTE:TODO:SANJ - Fixup memory checks so return is GOOD
    return TRUE;
}

//******************************************************************************
//
//  See fastqual.h for documentation
//
//******************************************************************************
void CClassPQSContainer::ReduceQualifierSetSpace(CBasicQualifierSet* pSet,
        length_t nDecrement)
{
}

//*****************************************************************************
//*****************************************************************************

length_t mstatic_EmptySet = sizeof(length_t);

//******************************************************************************
//
//  See fastqual.h for documentation
//
//******************************************************************************
void CInstancePQSContainer::SetSecondarySetData()
{
    m_SecondarySet.SetData(
        m_pClassPart->GetStart() + m_nClassSetOffset,
        m_pClassPart->GetHeap());
}

//******************************************************************************
//
//  See fastqual.h for documentation
//
//******************************************************************************
void CInstancePQSContainer::RebaseSecondarySet()
{
    m_SecondarySet.Rebase(m_pClassPart->GetStart() + m_nClassSetOffset);
}

//*****************************************************************************
//*****************************************************************************
//*****************************************************************************
//*****************************************************************************
//*****************************************************************************

//******************************************************************************
//
//  See fastqual.h for documentation
//
//******************************************************************************
HRESULT CQualifierSetList::InsertQualifierSet(int nIndex)
{
    if (!EnsureReal())
    	return WBEM_E_OUT_OF_MEMORY;
	if (GetQualifierSetData(nIndex)==0)
	{
		return WBEM_E_NOT_FOUND;
	}
    // Request extra space from container
    // ==================================

    int nExtraSpace = CBasicQualifierSet::GetMinLength();
    if ( !m_pContainer->ExtendQualifierSetListSpace(
			GetStart(), GetLength(), GetLength() + nExtraSpace) )
	{
		return WBEM_E_OUT_OF_MEMORY;
	}

    // Find the insertion point
    // ========================

	HRESULT	hr = WBEM_S_NO_ERROR;
    LPMEMORY pQualSet = GetQualifierSetData(nIndex);

    // Shift everything by the length of an empty qualifier set
    // ========================================================

	memmove(pQualSet + nExtraSpace, pQualSet,
		m_nTotalLength - (pQualSet-GetStart()));

	// Create empty qualifier set in the space
	// =======================================

	CBasicQualifierSet::SetDataToNone(pQualSet);

	// Adjust cached length
	// ====================

	m_nTotalLength += nExtraSpace;


	return hr;
}

//******************************************************************************
//
//  See fastqual.h for documentation
//
//******************************************************************************
void CQualifierSetList::DeleteQualifierSet(int nIndex)
{
    if(*m_pStart == QSL_FLAG_NO_SETS)
    {
        // No qualifier sets
        // =================
        return;
    }

    // Find the set
    // ============

    LPMEMORY pQualSet = GetQualifierSetData(nIndex);

    // Get its length
    // ==============

    int nLength = CBasicQualifierSet::GetLengthFromData(pQualSet);

    // Delete all its data from the heap
    // =================================

    CBasicQualifierSet::Delete(pQualSet, GetHeap());

    // Shift everything to our right to the left
    // =========================================

    memmove(pQualSet + nLength, pQualSet,
        m_nTotalLength - nLength - (pQualSet - GetStart()));

    // Return the space to the container
    // =================================

    m_pContainer->ReduceQualifierSetListSpace(GetStart(), GetLength(),
        nLength);

    // Adjust our cached length
    // ========================

    m_nTotalLength -= nLength;
}


//******************************************************************************
//
//  See fastqual.h for documentation
//
//******************************************************************************
BOOL CQualifierSetList::ExtendQualifierSetSpace(CBasicQualifierSet* pSet,
                                                length_t nNewLength)
{
    // WARNING: Trusing the caller here to specify a valid address!!!

    int nSetStartOffset = pSet->GetStart() - GetStart();

    // Request extra space from container
    // ==================================

    int nExtraSpace = nNewLength - pSet->GetLength();
    if (!m_pContainer->ExtendQualifierSetListSpace(
        GetStart(), GetLength(), GetLength() + nExtraSpace))
    {
        return FALSE;
    }

    LPMEMORY pSetStart = GetStart() + nSetStartOffset;
    pSet->Rebase(pSetStart);

    // Shift the tail to the right by required amount
    // ==============================================

    memmove(pSetStart + nNewLength, pSetStart + pSet->GetLength(),
        GetLength() - (nSetStartOffset + pSet->GetLength()));

    // Adjust our cached length
    // ========================

    m_nTotalLength += nExtraSpace;

    return TRUE;

}

//******************************************************************************
//
//  See fastqual.h for documentation
//
//******************************************************************************
void CQualifierSetList::ReduceQualifierSetSpace(CBasicQualifierSet* pSet,
                                                offset_t nReduceBy)
{
    // WARNING: Trusing the caller here to specify a valid address!!!

    LPMEMORY pSetEnd = EndOf(*pSet);

    // Shift the tail to the left by required amount
    // =============================================

    memmove(pSetEnd-nReduceBy, pSetEnd, GetLength() - (pSetEnd - GetStart()));

    // Return the space to the container
    // =================================

    m_pContainer->ReduceQualifierSetListSpace(
        GetStart(), GetLength(), nReduceBy);

    // Adjust our cached length
    // ========================

    m_nTotalLength -= nReduceBy;
}

LPMEMORY CQualifierSetList::CreateLimitedRepresentation(
        IN class CLimitationMapping* pMap, IN CFastHeap* pCurrentHeap,
        MODIFIED CFastHeap* pNewHeap, OUT LPMEMORY pWhere)
{
    // Allocate space for the flags
    // ============================

    BYTE* pfFlags = pWhere;
    *pfFlags = QSL_FLAG_NO_SETS;

    LPMEMORY pCurrentNew = pWhere+1;

    if(*m_pStart == QSL_FLAG_NO_SETS)
    {
        // No qualifier sets to start with
        // ===============================
        return pCurrentNew;
    }

    // Go through all our properties and look them up in the map
    // =========================================================

    int nNewIndex = 0;
    CPropertyInformation OldInfo, NewInfo;

    // IMPORTANT: THIS ASSUMES THAT THE MAPPINGS ARE ORDERED BY THE PROPERTY
    // INDEX OF THE NEW INFO!!!
    // =====================================================================
    pMap->Reset();
    while(pMap->NextMapping(&OldInfo, &NewInfo))
    {
        BOOL bCopy = FALSE;
        LPMEMORY pThisSetData = NULL;
        if(*pfFlags == QSL_FLAG_PRESENT)
        {
            // We are not empty --- just copy the set
            // ======================================

            bCopy = TRUE;
        }
        else
        {
            // Check if this set is actually empty
            // ===================================

            pThisSetData = GetQualifierSetData(OldInfo.nDataIndex);
            if(!CBasicQualifierSet::IsEmpty(pThisSetData))
            {
                // Need to create a list of empties for all previous
                // =================================================

                for(int i = 0; i < nNewIndex; i++)
                {
                    pCurrentNew = CBasicQualifierSet::CreateEmpty(pCurrentNew);
                }
                *pfFlags = QSL_FLAG_PRESENT;
                bCopy = TRUE;
            }
        }

        // Copy the qualifier set if required
        // ==================================

        if(bCopy)
        {
            if(pThisSetData == NULL)
                pThisSetData = GetQualifierSetData(OldInfo.nDataIndex);

            int nLength = CBasicQualifierSet::GetLengthFromData(pThisSetData);
            memcpy(pCurrentNew, pThisSetData, nLength);

            CStaticPtr CurrentNewPtr(pCurrentNew);

            // Check for allocation failures
            if ( !CBasicQualifierSet::TranslateToNewHeap(&CurrentNewPtr,
                    pCurrentHeap, pNewHeap) )
            {
                return NULL;
            }

            pCurrentNew += nLength;
        }

        nNewIndex++;
    }

    return pCurrentNew;
}

LPMEMORY CQualifierSetList::WriteSmallerVersion(int nNumSets, LPMEMORY pMem)
{
    if(IsEmpty())
    {
        *pMem = QSL_FLAG_NO_SETS;
        return pMem+1;
    }

    // Find the end of the last included qualifier set
    // ===============================================

    LPMEMORY pLastSet = GetQualifierSetData(nNumSets-1);
    length_t nLastLen = CBasicQualifierSet::GetLengthFromData(pLastSet);
    length_t nTotalLen = (pLastSet - GetStart()) + nLastLen;

    memcpy(pMem, GetStart(), nTotalLen);
    return pMem + nTotalLen;
}


LPMEMORY CInstancePQSContainer::GetQualifierSetStart()
    {
        RebaseSecondarySet();
        LPMEMORY pStart = m_pList->GetQualifierSetData(m_nPropIndex);
        if(pStart == NULL)
        {
            return (LPMEMORY)&mstatic_EmptySet;
        }
        else return pStart;
    }

//******************************************************************************
//
//  See fastqual.h for documentation.
//
//******************************************************************************
 BOOL CBasicQualifierSet::IsValidQualifierType(VARTYPE vt)
{
    switch(vt)
    {
    case VT_I4:
    case VT_BSTR:
    case VT_R8:
    case VT_BOOL:
    case VT_I4 | VT_ARRAY:
    case VT_BSTR | VT_ARRAY:
    case VT_R8 | VT_ARRAY:
    case VT_BOOL | VT_ARRAY:
        return TRUE;
    }

    return FALSE;
}

//******************************************************************************
//
//  See fastqual.h for documentation.
//
//******************************************************************************

 void CBasicQualifierSet::Delete(LPMEMORY pData, CFastHeap* pHeap)
{
    CQualifier* pCurrent = GetFirstQualifierFromData(pData);
    CQualifier* pEnd = (CQualifier*)(pData + GetLengthFromData(pData));

    while(pCurrent < pEnd)
    {
        pCurrent->Delete(pHeap);
        pCurrent = (CQualifier*)pCurrent->Next();
    }
}
//******************************************************************************
//
//  See fastqual.h for documentation.
//
//******************************************************************************
BOOL CBasicQualifierSet::TranslateToNewHeap(CPtrSource* pThis,
                                                   CFastHeap* pOldHeap,
                                                   CFastHeap* pNewHeap)
{
    BOOL    fReturn = TRUE;

    int nCurrentOffset = GetMinLength();
    int nEndOffset = GetLengthFromData(pThis->GetPointer());

    while(nCurrentOffset < nEndOffset)
    {
        CShiftedPtr CurrentPtr(pThis, nCurrentOffset);

        // Check for allocation failures
        fReturn = CQualifier::TranslateToNewHeap(&CurrentPtr, pOldHeap, pNewHeap);

        if ( !fReturn )
        {
            break;
        }

        nCurrentOffset += CQualifier::GetPointer(&CurrentPtr)->GetLength();
    }

    return fReturn;
}


//******************************************************************************
//
//  See fastqual.h for documentation.
//
//******************************************************************************

 INTERNAL CQualifier* CBasicQualifierSet::GetRegularQualifierLocally(
                                     LPMEMORY pData,
                                     CFastHeap* pHeap,
                                     LPCWSTR wszName)
{
    CQualifier* pCurrent = GetFirstQualifierFromData(pData);
    CQualifier* pEnd = (CQualifier*)(pData + GetLengthFromData(pData));

    while(pCurrent < pEnd)
    {
        if(pHeap->ResolveString(pCurrent->ptrName)->CompareNoCase(wszName) == 0)
        {
            return pCurrent;
        }
        else
        {
            pCurrent = (CQualifier*)pCurrent->Next();
        }
    }
    return NULL;
}

//******************************************************************************
//
//  See fastqual.h for documentation.
//
//******************************************************************************
 INTERNAL CQualifier* CBasicQualifierSet::GetKnownQualifierLocally(
                        LPMEMORY pStart,
                        int nStringIndex)
{
    CQualifier* pCurrent = GetFirstQualifierFromData(pStart);
    CQualifier* pEnd = (CQualifier*)(pStart + GetLengthFromData(pStart));

    while(pCurrent < pEnd)
    {
        if(nStringIndex == CFastHeap::GetIndexFromFake(pCurrent->ptrName))
        {
            return pCurrent;
        }
        else
        {
            pCurrent = (CQualifier*)pCurrent->Next();
        }
    }
    return NULL;
}

//******************************************************************************
//
//  See fastqual.h for documentation.
//
//******************************************************************************
 INTERNAL CQualifier* CBasicQualifierSet::GetQualifierLocally(
                                               LPMEMORY pStart,
                                               CFastHeap* pHeap,
                                               LPCWSTR wszName,
                                               int& nKnownIndex)
{
    // IMPORTANT: MUST COMPUTE nKnownIndex NO MATTER WHAT!!!!
    // ======================================================

    nKnownIndex = CKnownStringTable::GetKnownStringIndex(wszName);
    if(nKnownIndex >= 0)
    {
        // It is a well-known property.
        // ============================

        return GetKnownQualifierLocally(pStart, nKnownIndex);
    }
    else
    {
        // It is not a known string
        // ========================

        return GetRegularQualifierLocally(pStart, pHeap, wszName);
    }
}

//******************************************************************************
//
//  See fastqual.h for documentation.
//
//******************************************************************************

 INTERNAL CQualifier* CBasicQualifierSet::GetQualifierLocally(
                                     LPMEMORY pData,
                                     CFastHeap* pHeap,
                                     CCompressedString* pcsName)
{
    CQualifier* pCurrent = GetFirstQualifierFromData(pData);
    CQualifier* pEnd = (CQualifier*)(pData + GetLengthFromData(pData));

    while(pCurrent < pEnd)
    {
        if(pHeap->ResolveString(pCurrent->ptrName)->CompareNoCase(*pcsName)
            == 0)
        {
            return pCurrent;
        }
        else
        {
            pCurrent = (CQualifier*)pCurrent->Next();
        }
    }
    return NULL;
}

//*****************************************************************************
//*****************************************************************************
//*****************************************************************************

//******************************************************************************
//
//  See fastqual.h for documentation.
//
//******************************************************************************
 INTERNAL CQualifier*
CQualifierSet::GetQualifier(
                                                 READ_ONLY LPCWSTR wszName,
                                                 OUT BOOL& bLocal)
{
    // Search the primary set first
    // ============================

    int nKnownIndex;
    CQualifier* pQualifier = GetQualifierLocally(wszName, nKnownIndex);

    if(pQualifier == NULL)
    {
        // Search the secondary set now
        // ============================

        if(!IsComplete())
        {
            if(nKnownIndex >= 0)
            {
                pQualifier = m_pSecondarySet->GetKnownQualifierLocally(
                    nKnownIndex);
            }
            else
            {
                pQualifier = m_pSecondarySet->GetRegularQualifierLocally(
                    wszName);
            }
        }

        // make sure that it propagates to us
        // ==================================

        if(pQualifier == NULL ||
            (pQualifier->GetFlavor() & m_nPropagationFlag) == 0)
            return NULL;

        // Found it in the secondary list
        // ==============================

        bLocal = FALSE;
    }
    else
    {
        // Found it in the primary list,
        // =============================

        bLocal = TRUE;
    }

    return pQualifier;
}

//  Helper function to retrieve a qualifier from local or secondary set as necessary

HRESULT INTERNAL CQualifierSet::GetQualifier( LPCWSTR pwszName, CVar* pVar, long* plFlavor, CIMTYPE* pct )
{

    BOOL bIsLocal;
    CQualifier* pQualifier = GetQualifier(pwszName, bIsLocal);
    if(pQualifier == NULL) return WBEM_E_NOT_FOUND;

    // Set the flavor
    // ==============

    if(plFlavor)
    {
        *plFlavor = pQualifier->fFlavor;
        if(!bIsLocal)
        {
            CQualifierFlavor::SetLocal(*(BYTE*)plFlavor, FALSE);
        }
    }

	// Retrieve the type if requested
	if ( NULL != pct )
	{
		*pct = pQualifier->Value.GetType();
	}

    // Set the value
    // =============

    if ( NULL != pVar )
    {
        // Check for allocation failures
        if ( !pQualifier->Value.StoreToCVar(*pVar,
                (bIsLocal)?GetHeap():m_pSecondarySet->GetHeap()) )
        {
            return WBEM_E_OUT_OF_MEMORY;
        }
    }

    return WBEM_S_NO_ERROR;
}

//  Helper function to retrieve a qualifier from local or secondary set as necessary

HRESULT INTERNAL CQualifierSet::GetQualifier( LPCWSTR pwszName, long* plFlavor, CTypedValue* pTypedValue,
											 CFastHeap** ppHeap, BOOL fValidateSet )
{
	HRESULT	hr = WBEM_S_NO_ERROR;

    BOOL bIsLocal;
    CQualifier* pQualifier = GetQualifier(pwszName, bIsLocal);
    if(pQualifier == NULL) return WBEM_E_NOT_FOUND;

	// Make sure a set will actually work - Ostensibly we are calling this API because we need
	// direct access to a qualifier's underlying data before actually setting (possibly because
	// the qualifier is an array).
	if ( fValidateSet )
	{
		hr = ValidateSet( pwszName, pQualifier->fFlavor, pTypedValue, TRUE, TRUE );
	}

	if ( SUCCEEDED( hr ) )
	{
		if(plFlavor)
		{
			*plFlavor = pQualifier->fFlavor;
			if(!bIsLocal)
			{
				CQualifierFlavor::SetLocal(*(BYTE*)plFlavor, FALSE);
			}
		}

		// Copy out the qualifier data
		// ==============

		pQualifier->Value.CopyTo( pTypedValue );

		// Return the proper heap
		*ppHeap = (bIsLocal)?GetHeap():m_pSecondarySet->GetHeap();
	}

    return hr;
}

//*****************************************************************************
//*****************************************************************************
//*****************************************************************************

//******************************************************************************
//
//  See fastqual.h for documentation.
//
//******************************************************************************
 LPMEMORY CQualifierSetList::CreateListOfEmpties(LPMEMORY pStart,
                                                       int nNumProps)
{
    *pStart = QSL_FLAG_NO_SETS;
    return pStart+1;
}

//******************************************************************************
//
//  See fastqual.h for documentation.
//
//******************************************************************************
BOOL CQualifierSetList::EnsureReal()
{
    if(*m_pStart == QSL_FLAG_PRESENT) return TRUE;
    *m_pStart = QSL_FLAG_PRESENT;

    if (!m_pContainer->ExtendQualifierSetListSpace(m_pStart, GetHeaderLength(),
        ComputeRealSpace(m_nNumSets)))
        return FALSE;

    LPMEMORY pCurrent = m_pStart + GetHeaderLength();
    for(int i = 0; i < m_nNumSets; i++)
    {
        pCurrent = CBasicQualifierSet::CreateEmpty(pCurrent);
    }

    m_nTotalLength = (pCurrent - m_pStart);
    return TRUE;
}

//******************************************************************************
//
//  See fastcls.h for documentation.
//
//******************************************************************************
BOOL CQualifierSetList::TranslateToNewHeap(CFastHeap* pCurrentHeap,
                                                  CFastHeap* pNewHeap)
{
    //NO Sets so we're done
    if(*m_pStart == QSL_FLAG_NO_SETS) return TRUE;

    BOOL    fReturn = TRUE;

    LPMEMORY pCurrent = m_pStart + GetHeaderLength();
    for(int i = 0; i < m_nNumSets; i++)
    {
        CStaticPtr QSPtr(pCurrent);

        // Check for allocation failures
        fReturn = CBasicQualifierSet::TranslateToNewHeap(&QSPtr, pCurrentHeap, pNewHeap);

        if ( !fReturn )
        {
            break;
        }

        pCurrent += CBasicQualifierSet::GetLengthFromData(pCurrent);
    }

    return fReturn;
}

size_t CQualifierSetList::ValidateBuffer(LPMEMORY start, size_t cbSize, int propCount)
{
	if (cbSize < GetHeaderLength()) throw CX_Exception();
	int step = 1;
	if (*start == QSL_FLAG_NO_SETS) return step;
    for(int i = 0; i < propCount; i++)
    {
    	step += CBasicQualifierSet::ValidateBuffer(start+step, cbSize-step);
    }
	return step;	
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\marshalers\coreprox\fastqual.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    FASTQUAL.H

Abstract:

  This file defines the classes related to qualifier processing in WbeWbemjects
  See fastqual.h for full documentation and fastqual.inc for  function
  implementations.

  Classes implemented: 
      CQualifierFlavor                Encapsulates qualifier flavor infor
      CQualifier                      Represents a qualifier
      CBasicQualifierSet              Represents read-only functionality.
      CQualiferSetContainer           What qualifier set container supports.
      CQualifierSet                   Full-blown qualifier set (template)
      CQualifierSetListContainer      What qualifier set list container supports.
      CQualifierSetList               List of qualifier sets.
      CInstanceQualifierSet           Instance qualifier set.
      CClassQualifierSet              Class qualifier set.
      CClassPQSContainer              Class property qualifier set container
      CClassPropertyQualifierSet      Class property qualifier set
      CInstancePQSContainer           Instance proeprty qualifier set container
      CInstancePropertyQualifierSet   Instance property qualifier set

History:

    2/20/97     a-levn  Fully documented
	12//17/98	sanjes -	Partially Reviewed for Out of Memory.

--*/

#ifndef __FAST_QUALIFIER__H_
#define __FAST_QUALIFIER__H_

#include <wbemidl.h>
#include "wstring.h"
#include "fastval.h"

//#pragma pack(push, 1)

//*****************************************************************************
//*****************************************************************************
//
//  class CQualifierFlavor
//
//  This class corresponds to qualifier flavor. It contains one byte which is
//  where the flavor is stored. Because of its simple data storage, most of its
//  member functions have static counterparts which take a BYTE or a BYTE& as 
//  the first parameter. Here, we document only the non-static members where
//  appropriate.
//
//  The flavor consists of four parts:
//
//  1) Origin. Where this qualifier came from. Can be any of these values:
//      WBEM_FLAVOR_ORIGIN_LOCAL:        defined here
//      WBEM_FLAVOR_ORIGIN_PROPAGATED:   inherited from elsewhere
//      WBEM_FLAVOR_ORIGIN_SYSTEM:       unused
//
//  2) Propagation rules. Where this qualifier propagates to. Can be 
//      WBEM_FLAVOR_DONT_PROPAGATE or any combination of these values:
//      WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE
//      WBEM_FLAVOR_FLAG_PROPAGATE_TO_DERIVED_CLASS
//
//  3) Permissions. What the heirs of this qualifier can do with it. Can be
//      one of these:
//      WBEM_FLAVOR_OVERRIDABLE:     heirs may change the value any way the want
//      WBEM_FLAVOR_NOT_OVERRIDABLE: heirs may not change the value.
//
//	4) Amendments: Support for localization in which localized qualifiers
//		are merged in from a localization namespace.
//		WBEM_FLAVOR_AMENDED
//
//  The parts are |'ed together.
//
//*****************************************************************************
//
//  Clear
//
//  Sets the flavor to 0.
//
//*****************************************************************************
//
//  GetPropagation
//
//  Retrieves propagation-related section of the flavor.
//
//  Returns:
//
//      BYTE
//
//*****************************************************************************
//
//  SetPropagation
//
//  Sets the propation-related section of the flavor. The other sections remain
//  untouched.
//
//  Parameters:
//
//      BYTE byPropagation  The propagation section to set. Other sections of
//                          byPropagation are ignored.
//
//*****************************************************************************
//
//  DoesPropagateToInstances
//
//  Returns:
//
//      BOOL    TRUE iff "propagate to instances" flag is set.
//
//*****************************************************************************
//
//  DoesPropagateToDerivedClass
//
//  Returns:
//
//      BOOL    TRUE iff "propagate to dervied class" flag is set.
//
//*****************************************************************************
//
//  GetPermissions
//
//  Returns:
//
//      BYTE:   the permissions section of the flavor (overrides, etc).
//
//*****************************************************************************
//
//  SetPermissions
//
//  Sets the permissions section of the flavor. The other sections remain 
//  untouched.
//
//  Parameters:
//
//      BYTE byPermissions  The permissions to set. The other sections of
//                          byPermissions are ignored.
//
//*****************************************************************************
//
//  IsOverridable
//
//  Returns:
//
//      BOOL:   TRUE iff the qualifier may be overriden by those who inherit it
//
//*****************************************************************************
//
//  SetOverridable
//
//  Sets whether those who inherit this qualifier may override it.
//
//  Parameters:
//
//      BOOL bIs    If TRUE set to overridable, if not set to not overridable.
//
//*****************************************************************************
//
//  GetOrigin
//
//  Returns:
//
//      BYTE: the origin section of the flavor
//
//*****************************************************************************
//
//  SetOrigin
//
//  Sets the origin section of the flavor.
//
//  Parameters:
//
//      BYTE byOrigin   The origin to set. The other sections of byOrigin are
//                      ignored.
//
//*****************************************************************************
//
//  IsLocal
//
//  Returns:
//
//      BOOL:   TRUE iff the origin of this qualifier is local.
//
//*****************************************************************************
//
//  SetLocal
//
//  Sets whether or not the origin of this qualifier is local.
//
//  Parameters:
//
//      BOOL bIs    If TRUE, the origin is set to local. 
//                  If FALSE, to propagated.
//
//*****************************************************************************
//
//  IsAmended
//
//  Returns:
//
//      BOOL:   TRUE if the qualifier is amended
//
//*****************************************************************************
//
//  SetAmended
//
//  Sets whether or not the qualifier is amended
//
//  Parameters:
//
//      BOOL bIs    If TRUE, amended
//                  If FALSE, not amended.
//
//*****************************************************************************


// The data in this structure is unaligned
#pragma pack(push, 1)

class CQualifierFlavor
{
protected:
    BYTE m_byFlavor;
public:
     CQualifierFlavor(BYTE byFlavor) : m_byFlavor(byFlavor) {}
     operator BYTE() {return m_byFlavor;}

	 bool operator ==( const CQualifierFlavor& flavor )
		{ return m_byFlavor == flavor.m_byFlavor; }

     static void Clear(BYTE& byFlavor) {byFlavor = 0;}
     void Clear() {Clear(m_byFlavor);}

     static BYTE GetPropagation(BYTE byFlavor) 
        {return byFlavor & WBEM_FLAVOR_MASK_PROPAGATION;}
     BYTE GetPropagation() {return GetPropagation(m_byFlavor);}

     static void SetPropagation(BYTE& byFlavor, BYTE byPropagation)
    {
        byFlavor &= ~WBEM_FLAVOR_MASK_PROPAGATION;
        byFlavor |= byPropagation;
    }
     void SetPropagation(BYTE byPropagation)
        {SetPropagation(m_byFlavor, byPropagation);}

     static BOOL DoesPropagateToInstances(BYTE byFlavor)
    {
        return (GetPropagation(byFlavor) & 
                WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE);
    }
     BOOL DoesPropagateToInstances()
        {return DoesPropagateToInstances(m_byFlavor);}

     static BOOL DoesPropagateToDerivedClass(BYTE byFlavor)
    {
        return (GetPropagation(byFlavor) & 
                WBEM_FLAVOR_FLAG_PROPAGATE_TO_DERIVED_CLASS);
    }
     BOOL DoesPropagateToDerivedClass()
        {return DoesPropagateToDerivedClass(m_byFlavor);}
    
     static BYTE GetPermissions(BYTE byFlavor) 
        {return byFlavor & WBEM_FLAVOR_MASK_PERMISSIONS;}
     BYTE GetPermissions() {return GetPermissions(m_byFlavor);}

     static void SetPermissions(BYTE& byFlavor, BYTE byPermissions)
    {
        byFlavor &= ~WBEM_FLAVOR_MASK_PERMISSIONS;
        byFlavor |= byPermissions;
    }
     void SetPermissions(BYTE byPermissions)
        {SetPermissions(m_byFlavor, byPermissions);}

     static BOOL IsOverridable(BYTE byFlavor)
    {
        return GetPermissions(byFlavor) == WBEM_FLAVOR_OVERRIDABLE;
    }
     BOOL IsOverridable() {return IsOverridable(m_byFlavor);}

     static void SetOverridable(BYTE& byFlavor, BOOL bIs)
    {
        SetPermissions(byFlavor, bIs?WBEM_FLAVOR_OVERRIDABLE:
                                     WBEM_FLAVOR_NOT_OVERRIDABLE);
    }
     void SetOverridable(BOOL bIs)
        {SetOverridable(m_byFlavor, bIs);}

     static BYTE GetOrigin(BYTE byFlavor) 
        {return byFlavor & WBEM_FLAVOR_MASK_ORIGIN;}
     BYTE GetOrigin() {return GetOrigin(m_byFlavor);}

     static void SetOrigin(BYTE& byFlavor, BYTE byOrigin)
    {
        byFlavor &= ~WBEM_FLAVOR_MASK_ORIGIN;
        byFlavor |= byOrigin;
    }
     void SetOrigin(BYTE byOrigin)
        {SetOrigin(m_byFlavor, byOrigin);}

     static BOOL IsLocal(BYTE byFlavor)
        {return GetOrigin(byFlavor) == WBEM_FLAVOR_ORIGIN_LOCAL;}
     BOOL IsLocal() {return IsLocal(m_byFlavor);}

     static void SetLocal(BYTE& byFlavor, BOOL bIs)
    {
        SetOrigin(byFlavor, bIs?WBEM_FLAVOR_ORIGIN_LOCAL:
                                WBEM_FLAVOR_ORIGIN_PROPAGATED);
    }
     void SetLocal(BOOL bIs) {SetLocal(m_byFlavor, bIs);}

     static BOOL IsAmended(BYTE byFlavor)
        {return byFlavor & WBEM_FLAVOR_MASK_AMENDED;}
     BOOL IsAmended() {return IsAmended(m_byFlavor);}

     static void SetAmended(BYTE& byFlavor, BOOL bIs)
    {
		 byFlavor &= ~WBEM_FLAVOR_MASK_AMENDED;
		 byFlavor |= (bIs ? WBEM_FLAVOR_AMENDED:
							WBEM_FLAVOR_NOT_AMENDED);
    }
     void SetAmended(BOOL bIs) {SetAmended(m_byFlavor, bIs);}

    WString GetText();
};
#pragma pack(pop)

// 'key' qualifier is special cased and must always have this flavor.
#define ENFORCED_KEY_FLAVOR (WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE |      \
                            WBEM_FLAVOR_FLAG_PROPAGATE_TO_DERIVED_CLASS |  \
                            WBEM_FLAVOR_NOT_OVERRIDABLE)
#define ENFORCED_INDEXED_FLAVOR		ENFORCED_KEY_FLAVOR
#define ENFORCED_SINGLETON_FLAVOR	ENFORCED_KEY_FLAVOR
#define ENFORCED_CIMTYPE_FLAVOR		(WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE | \
									WBEM_FLAVOR_FLAG_PROPAGATE_TO_DERIVED_CLASS)

//*****************************************************************************
//*****************************************************************************
//
//  class CQualifier
//
//  Represents a single qualifier, including its name and value. A qualifier
//  is represented in memory by a sequence of:
//
//      heapptr_t ptrName   Contains the heap pointer to the name of the
//                          qualifier. The location of the heap is assumed to
//                          be known to the container. As with all heap 
//                          pointers, this one may be fake if the qualifier\
//                          name is well-known (see fastheap.h and faststr.h)
//      CQualifierFlavor fFlavor
//                          As described above, contains the qualifier flavor.
//      CTypedValue Value   Contains the value of the qualfier, including the
//                          type. As described in fastval.h, the value stores
//                          all variable-length data on the heap. The heap
//                          used here is the same as used for ptrName.
//
//  The 'this' pointer of CQualifier points directly at the structure.
//
//*****************************************************************************
//
//  GetLength
//
//  Returns the total length of the structure (which varies depending on the 
//  type of the value).
//
//  Returns:
//
//      length_t:       the length in bytes.
//
//*****************************************************************************
//
//  Next
//
//  Returns:
//
//      LPMEMORY:   the pointer to the first byte following thie qualifier in
//                  memory.
//
//*****************************************************************************
//
//  static GetHeaderLength
//
//  The number of bytes (constant) consumed by the header of this structure
//  (the part before the value starts).
//
//*****************************************************************************
//
//  GetFlavor
//
//  Returns:
//
//      BYTE:   the flavor.
//
//*****************************************************************************
//
//  Delete
//
//  Frees any data this qualifier may have on the fast heap. Does not touch the
//  qualifier memory block itself.
//
//  Parameters:
//
//      CFastHeap* pHeap    The heap where this qualifier keeps its data.
//
//*****************************************************************************
//
//  static TranslateToNewHeap
//
//  Moves all the data that this qualifier has on the heap to a new heap and
//  updates all internal heap pointers accordingly. 
//
//  When heap allocations are performed, the heap may grow. Such growth may 
//  require reallocation of the object memory block. But the 'this' pointer of
//  CQualifier points inside the object's memory block, and so 'this' pointer
//  would be invalidated. Thus, this function had to be made static, with the
//  'this' pointer provided in a source (see CPtrSource in fastsprt.h).
//
//  Parameters:
//
//      CPtrSource* pThis       Where to get our 'this' pointer.
//      CFastHeap* pOldHeap     The heap where our data currently is.
//      CFastHeap* pNewHeap     The heap where our data must go.
//
//*****************************************************************************
//
//  CopyTo
//
//  Copies the memory block to a new location, in the process translating the
//  data to a new heap. See TranslateToNewHeap for more details. Luckily, we
//  can get away without sourcing our 'this' pointer because we copy data
//  first and tehn translate at the destination.
//
//  Parameters:
//
//      CPtrSource* pThis       The source of our destination pointer.
//      CFastHeap* pOldHeap     The heap where our data currently is.
//      CFastHeap* pNewHeap     The heap where our data must go.
//
//*****************************************************************************

// The data in this structure is unaligned
#pragma pack(push, 1)
struct CQualifier
{
    heapptr_t ptrName;
    CQualifierFlavor fFlavor;
    CTypedValue Value;

    static  CQualifier* GetPointer(CPtrSource* pSource)
        {return (CQualifier*)pSource->GetPointer();}
public:
     static int GetHeaderLength() 
        {return sizeof(heapptr_t) + sizeof(CQualifierFlavor);}

     LPMEMORY GetStart(){ return (LPMEMORY)this;};
     int GetLength() {return GetHeaderLength() + Value.GetLength();}
     LPMEMORY Next() {return Value.Skip();}
public:
    BYTE GetFlavor() {return fFlavor;}

public:
     void Delete(CFastHeap* pHeap) 
        {Value.Delete(pHeap); pHeap->FreeString(ptrName); }
     static BOOL TranslateToNewHeap(CPtrSource* pThis,
                                    CFastHeap* pOldHeap, CFastHeap* pNewHeap)
    {
		 // Check for allocation errors
        heapptr_t ptrNewName;
		if ( !CCompressedString::CopyToNewHeap(
				CQualifier::GetPointer(pThis)->ptrName, pOldHeap, pNewHeap, ptrNewName) )
		{
			return FALSE;
		}

        GetPointer(pThis)->ptrName = ptrNewName;
        CShiftedPtr PtrValue(pThis, GetHeaderLength());

		 // Check for allocation errors
        return CTypedValue::TranslateToNewHeap(&PtrValue, pOldHeap, pNewHeap);
    }
    BOOL CopyTo(CPtrSource* pDest, CFastHeap* pOldHeap, 
                                          CFastHeap* pNewHeap)
    {
        memcpy(pDest->GetPointer(), this, GetLength());
        return CQualifier::TranslateToNewHeap(pDest, pOldHeap, pNewHeap);
    }
};
#pragma pack(pop)

//*****************************************************************************
//*****************************************************************************
//
//  class CBasicQualifierSet
//
//  CBasicQualifierSet encapsulates all the qualifier set functionality that
//  can be implemented without any knowledge of our container. This includes
//  all the read-only functionality and the static methods.
//
//  The layout of a qualifier set in memory is very simple: first comes a 
//  length_t variable containing the total length of the set (including itself)
//  Then come qualifiers, as described in CQualifier above, one after another.
//  It is important to realize that the first item in teh set is the *length*,
//  not the number of qualifiers.
//
//  CBasicQualifierSet has no notion of a parent's qualifier set, so all the
//  qualifiers are retrieved locally.
//
//*****************************************************************************
//************************** static methods ***********************************
//  
//  static SetDataLength
//
//  Sets the length of the set in the set's memory block.
//
//  Properties:
//
//      LPMEMORY pStart     Where the set's memory block starts.
//      length_t nLength    The length to set.
//
//*****************************************************************************
//
//  static GetMinLength
//
//  Returns:
//
//      length_t:   the length of an empty qualifier set.
//
//*****************************************************************************
//
//  static GetLengthFromData
//
//  Returns the length of a qualifier set based on its memory block.
//
//  Parameters:
//
//      LPMEMORY pStart     Where the set's memory block starts.
//
//  Returns:
//
//      length_t:   
//
//*****************************************************************************
//
//  static IsEmpty
//
//  Determines if a given qualifier set is empty based on its memory block.
//
//  Parameters:
//
//      LPMEMORY pStart     Where the set's memory block starts.
//
//  Returns:
//
//      BOOL:   TRUE idd the set is empty.
//
//*****************************************************************************
//
//  static GetFirstQualifierFromData
//
//  Retrieves the pointer to the first qualifier in the set (after that, one
//  can use that CQualifier::Next function to iterate over them).
//
//  Parameters:
//
//      LPMEMORY pStart     Where the set's memory block starts.
//
//  Returns:
//
//      CQualifier*
//
//*****************************************************************************
//
//  static GetRegularQualifierLocally
//
//  Tries to find a qualifier with a given name, where the caller guarantees 
//  that the name is not a well-known string (see faststr,h). 
//
//  Parameters:
//
//      LPMEMORY pData      Points to the set's memory block.
//      CFastHeap* pHeap    Where the extra data (including qualifier names)
//                          is kept.
//      LPCWSTR wszName     The name of the qualifier to find.
//
//  Returns:
//
//      CQualifier* pointing to the qualifier found (not a copy) or NULL if
//          not found.
//
//*****************************************************************************
//
//  static GetKnownQualifierLocally
//
//  Tries to find a qualifier with a given name, where the caller guarantees 
//  that the name is a well-known string (see faststr.h) and provides the 
//  index of that string.
//
//  Parameters:
//
//      LPMEMORY pData      Points to the set's memory block.
//      int nStringIndex    The index of the qualifier's name in the well-known
//                          string table.
//
//  Returns:
//
//      CQualifier* pointing to the qualifier found (not a copy) or NULL if
//          not found.
//
//*****************************************************************************
//
//  static GetQualifierLocally
//
//  Tries to find a qualifier with a given name.
//
//  Parameters:
//
//      LPMEMORY pData      Points to the set's memory block.
//      CFastHeap* pHeap    Where the extra data (including qualifier names)
//                          is kept.
//  Parameters I:
//      LPCWSTR wszName     The name of the qualifier to find.
//      int& nKnownIndex    (Optional). If provided, the function will place
//                          the well-known index of the name here, or 
//                          -1 if not found.
//  Parameters II:
//      CCompressedString* pcsName  The name of the qualifier as a compressed
//                          string. Such a name cannot be well-known (see
//                          string storage on the heap in fastheap.h).
//  Returns:
//
//      CQualifier* pointing to the qualifier found (not a copy) or NULL if
//          not found.
//
//*****************************************************************************
//
//  static IsValidQualifierType
//
//  Not every VARIANT type can server as the type of a qualifier. This function
//  verifies if a given VARIANT type is valid for a qualifier.
//
//  Parameters:
//
//      VARTYPE vt      The type to check.
//
//  Returns:
//
//      BOOL    TRUE iff valid.
//
//*****************************************************************************
//
//  static SetDataToNone
//
//  Empties the qualifier set in a given memory block.
//
//  Parameters:
//
//      LPMEMORY pBlock     The memory block of the qualifier set.
//
//*****************************************************************************
//
//  static CreateEmpty
//
//  Creates an empty qualifier set on a given memory block and returns the
//  pointer to the first byte after it.
//
//  Parameters:
//
//      LPMEMORY pBlock     The memory block of the qualifier set.
//
//  Returns:
//
//      LPMEMORY
//
//*****************************************************************************
//
//  static Delete
//
//  Frees any data that this qualifier set may have on the heap (names, values)
//
//  Parameters:
//
//      LPMEMORY pBlock     The memory block of the qualifier set.
//      CFastHeap* pHeap    The heap where this qualifier set keep extra data.
//
//*****************************************************************************
//
//  static ComputeNecessarySpaceForPropagation
//
//  As described in CQualifierFlavor, only some qualifiers propagate and only
//  to some destinations. This function computes the amount of space that
//  a propagated copy of this set will take.
//
//  Parameters:
//
//      LPMEMORY pBlock         The memory block of the qualifier set.
//      BYTE byPropagationFlag  Identifies the target of the propagation. If
//                              we are propagating to a derived class, it will
//                              be WBEM_FLAVOR_FLAG_PROPAGATE_TO_DERIVED_CLASS.
//                              If we are propagating to an instance, it will
//                              be WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCES.
//  Returns:
//
//      length_t:   the number of bytes necessary for the propagated set.
//
//*****************************************************************************
//
//  static WritePropagatedVersion
//
//  Creates a propagated version of a qualifier set based on the propagation
//  flag (as described in ComputeNecessarySpaceForPropagation). The memory is 
//  assumed to be already allocated and large enough.
//
//  Parameters:
//
//      CPtrSource* pThis       The source of the pointer to the memory block
//                              of the set to propagate. Since the C value of
//                              this pointer may change while we are writing,
//                              due to object reallocation, we must use source
//                              (see fastsprt.h).
//      BYTE byPropagationFlag  The flag describing who we are propagating to
//                              (as descrined in 
//                              ComputeNecessarySpaceForPropagation)
//      CPtrSource* pDest       The source fot the pointer to the destination
//                              memory block.
//      CFastHeap* pOldHeap     The heap where the original qualifier set keeps
//                              extra data.
//      CFastHeap* pNewHeap     The heap where the new qualifier set should 
//                              place extra data.
//
//*****************************************************************************
//
//  static TranslateToNewHeap
//
//  Moves whatever data this qualifier set keeps on the heap to a new heap.
//  The data is NOT deleted from the old heap.
//
//  Parameters:
//
//      CPtrSource* pThis       The source of the pointer to the memory block
//                              of the qualifier set to translate.
//      CFastHeap* pOldHeap     The heap where the qualifier set keeps its data
//                              currently.
//      CFastHeap* pNewHeap     The heap to which the data should be moved.
//
//*****************************************************************************
//
//  static ComputeMergeSpace
//
//  Computes the amount of space required to merge to qualifier sets. The 
//  sets being merged are the "parent" set and the "child" set. For instance,
//  this could be the qualifier set for a property of a class and the qualfier
//  set for that property in a derived class of that class. The merge then 
//  takes all the propagated qualifiers from the parent and the qualifiers
//  in the child and merges them, giving priority the the child.
//
//  NOTE: this function is only applied for classes and their children, not
//  instances. Instances do not merge their qualifier sets with the classes ---
//  they keep them separate and perform to separate lookups.
//
//  Parameters:
//
//      LPMEMORY pParentSet     The memory block of the parent set.
//      CFastHeap* pParentHeap  The heap where the parent set keeps its data.
//      LPMEMORY pChildSet      The memory block of the child set.
//      CFastHeap* pChildHeap   The heap where the child set keeps its data.
//      BOOL bCheckValidity     If TRUE, the function will check that the child
//                              does not violate permissions in overriding
//                              parent's qualifiers. Normally, this is not
//                              necessary, as the check is performed when the
//                              qualifier is added.
//  Returns:
//
//      length_t:   the number of bytes that the merged set will take. This
//                  number is precise, not an estimate.
//
//*****************************************************************************
//
//  static Merge
//
//  Merges a parent's and a child's qualifier sets. See ComputeMergeSpace above
//  for details on this operation. It is assumed that there is:
//
//  1) Enough space at the destination to contain the qualifier set.
//  2) MOST IMPORTANTLY, enough space on the destination heap to contain all
//      the qualifier set data, so that no reallocations will occur.
//  
//  Parameters:
//
//      LPMEMORY pParentSet     The memory block of the parent set.
//      CFastHeap* pParentHeap  The heap where the parent set keeps its data.
//      LPMEMORY pChildSet      The memory block of the child set.
//      CFastHeap* pChildHeap   The heap where the child set keeps its data.
//      LPMEMORY pDestSet       The memory block of the destination set.
//      CFastHeap* pDestHeap    The heap where the destination set should
//                              keep its data.
//      BOOL bCheckValidity     If TRUE, the function will check that the child
//                              does not violate permissions in overriding
//                              parent's qualifiers. Normally, this is not
//                              necessary, as the check is performed when the
//                              qualifier is added.
//
//*****************************************************************************
//
//  static ComputeUnmergeSpace
//
//  As described above, qualifier sets for classes and their parents are merged
//  together. Then, when it is time to change the (modified) version of the
//  child class back, it needs to be unmerged, i.e., we need to obtain just the
//  qualifiers that are new or overriden in the child.
//
//  ComputeUnmergeSpace calculates how much space is needed to represent the
//  result of such an unmerge
//
//  Parameters:
//
//      LPMEMORY pMergedSet     The memory block of the merged qualifier set.
//
//  Returns:
//
//      length_t: the number of bytes required to store the unmerge.
//
//*****************************************************************************
//
//  static Unmerge
//
//  Unmerges the child's part form the merged set, as described in 
//  ComputeUnmergeSpace. This function assumes that there is:
//
//  1) Enough space at the destination to contain the qualifier set.
//  2) MOST IMPORTANTLY, enough space on the destination heap to contain all
//      the qualifier set data, so that no reallocations will occur.
//
//  Parameters:
//
//      LPMEMORY pMergedData        The memory block of the merged set
//      CFastHeap* pMergedHeap      The heap where the merge keeps its data.
//      LPMEMORY pDestData          The destination memory block.
//      CFastHeap* pDestHeap        The heap where the data should be placed.
//
//*****************************************************************************
//
//  static HasLocalQualifiers
//
//  Checks if a qualifier set has any local or overriden qualifiers, i.e., if
//  there is anything new in it as compared to the parent.
//
//  Parameters:
//
//      LPMEMORY pMergedData        The memory block of the merged set.
//
//  Returns:
//
//      BOOL        TRUE iff it has local or overriden qualifiers.
//
//*****************************************************************************
//
//  GetText
//
//  Produces the MOF representation of a given qualifier set.
//
//  Parameters:
//
//      LPMEMORY pData          The memory block of the qualifier set.
//      CFastHeap* pHeap        The heap where it keeps its data.
//      long lFlags             The flags. 
//      WString& wsText         The destination for the textual representation.
//
//*****************************************************************************
//***************************** Dynamic methods *******************************
//
//  Non-static methods of CBasicQualifierSet rely (of course) on the data
//  members. The members are:
//
//  length_t m_nLength          The length of the block.
//  CQualifier* m_pOthers       Points to the firsyt qualifier in the list.
//  CFastHeap* m_pHeap          The heap where the extra data is kept.
//
//  Many of the non-static methods simply call static methods providing the
//  information taken from the member variables. We do not document them, as
//  they are analagous to the static ones. Here is the list of such methods:
//
//  GetStart, GetLength, GetFirstQualifier, Skip, GetHeap, GetText
//  GetRegularQualifierLocally, GetKnownQualifierLocaly, GetQualifierLocally
//  
//*****************************************************************************
//
//  SetData
//
//  Sets up the internal members given the location of the memory block
//
//  Parameters:
//
//      LPMEMORY pStart     The start of the memory block of the set.
//      CFastHeap* pHeap    The heap where this set keeps its data.
//
//*****************************************************************************
//
//  IncrementLength
//
//  Increments the stored length of the qualifier set block both in the member
//  variable and in the block itself.
//
//  Parameters:
//
//      lenght_t nIncrement in bytes
//
//*****************************************************************************
//
//  Rebase
//
//  Updates internal variables when the memory block has moved.
//
//  Parameters:
//
//      LPMEMORY pNewMemory     The new location of the memory block.
//
//*****************************************************************************
//
//  GetNumUpperBound
//
//  A quick way to get an upper boun don the number of qualifiers in the set
//  without traversing it.
//
//  Returns:
//
//      int:    >= the numbed of qualifiers.
//
//*****************************************************************************
//
//  EnumPrimaryQualifiers.
//
//  Given enumeration flags and a flavor mask (below), creates to arrays of
//  qualifier names: those that match the criteria and those that do not.
//
//  Parameters:
//
//      BYTE eFlags                         The flags for enumeration. Can be:
//                                          WBEM_FLAG_LOCAL_ONLY:
//                                              only the qualifiers defined or
//                                              overriden in this set.
//                                          WBEM_FLAG_PROPAGATED_ONLY:
//                                              only the qualifiers inherited
//                                              from the parent (and not
//                                              overriden).
//                                          Any other value:
//                                              no restriction.
//      BYTE fFlavorMask                    Any bit that is set in fFlavorMask
//                                          must be set in the flavor of a 
//                                          qualifier, or it does not match.
//      CFixedBSTRArray& astrMatching       Destination for the names of the
//                                          matching qualifiers. Must not be
//                                          initialized (Create'ed)
//      CFixedBSTRArray& astrNotMatching    Destination for the names of the
//                                          nonmatching qualifiers. Must not be
//                                          initialized (Create'ed)
//
//*****************************************************************************
//
//  CanBeReconciledWith.
//
//  Compares this qualifier set to another one.  Checking whether differences
//	can be reconciled or not.
//
//  Parameters:
//		CBasicQualifierSet& qsThat			Qualifier set to reconcile with.
//
//*****************************************************************************
//
//  Compare.
//
//  Compares this qualifier set to another one, filtering out names if specified.
//
//  Parameters:
//		CBasicQualifierSet& qsThat			Qualifier set to compare to.
//      BYTE eFlags                         The flags for enumeration. Can be:
//                                          WBEM_FLAG_LOCAL_ONLY:
//                                              only the qualifiers defined or
//                                              overriden in this set.
//                                          WBEM_FLAG_PROPAGATED_ONLY:
//                                              only the qualifiers inherited
//                                              from the parent (and not
//                                              overriden).
//                                          Any other value:
//                                              no restriction.
//		LPCWSTR* ppFilters					Names of properties to filter out of
//											comparison.  For example, __UPDATE_CONFLICT
//											qualifiers are informational only and should
//											not cause matching operations to fail.
//		DWORD dwNumFilters					Number of filters in array
//
//*****************************************************************************
//
//  CompareLocalizedSet.
//
//  Compares this qualifier set to another one.  It uses the Compare() function
//	above, but precreates a filter list of all amended qualifiers as well as
//	"amendmendt" and "locale" i.e. all localization qualifiers.
//
//  Parameters:
//		CBasicQualifierSet& qsThat			Qualifier set to compare to.
//
//*****************************************************************************

class COREPROX_POLARITY CBasicQualifierSet
{
    //*************** Static part **************************
protected:
     static void SetDataLength(LPMEMORY pStart, length_t nLength)
        {*(PLENGTHT)pStart = nLength;}
public:
	 static size_t ValidateBuffer(LPMEMORY pStart, size_t cbMax);
     static length_t GetMinLength() {return sizeof(length_t);}
     static length_t GetLengthFromData(LPMEMORY pData)
        {return *(PLENGTHT)pData;}
     static BOOL IsEmpty(LPMEMORY pData) 
        {return GetLengthFromData(pData) == GetMinLength();}
     static CQualifier* GetFirstQualifierFromData(LPMEMORY pData)
        {return (CQualifier*)(pData + GetMinLength());}
public:
    static  INTERNAL CQualifier* GetRegularQualifierLocally(
                    LPMEMORY pData, CFastHeap* pHeap, LPCWSTR wszName);
    static  INTERNAL CQualifier* GetKnownQualifierLocally(
                        LPMEMORY pStart, int nStringIndex);
    static  INTERNAL CQualifier* GetQualifierLocally(
                    LPMEMORY pStart, CFastHeap* pHeap, LPCWSTR wszName,
                    int& nKnownIndex);
    static  INTERNAL CQualifier* GetQualifierLocally(
                    LPMEMORY pStart, CFastHeap* pHeap,  LPCWSTR wszName)
    {
        int nKnownIndex;
        return GetQualifierLocally(pStart, pHeap, wszName, nKnownIndex);
    }
    static  INTERNAL CQualifier* GetQualifierLocally(LPMEMORY pStart, 
        CFastHeap* pHeap, CCompressedString* pcsName);

    static  BOOL IsValidQualifierType(VARTYPE vt);
        
public:
    
     static void SetDataToNone(LPMEMORY pData)
        {*(PLENGTHT)pData = sizeof(length_t);}
     static LPMEMORY CreateEmpty(LPMEMORY pStart)
        {SetDataToNone(pStart); return pStart + sizeof(length_t);}

     static void Delete(LPMEMORY pData, CFastHeap* pHeap);

    static length_t ComputeNecessarySpaceForPropagation(
        LPMEMORY pStart, BYTE byPropagationFlag);

    static LPMEMORY WritePropagatedVersion(CPtrSource* pThis,
        BYTE byPropagationFlag, CPtrSource* pDest,
        CFastHeap* pOldHeap, CFastHeap* pNewHeap);

    static BOOL TranslateToNewHeap(CPtrSource* pThis, 
        CFastHeap* pOldHeap, CFastHeap* pNewHeap);

    static length_t ComputeMergeSpace(
                               READ_ONLY LPMEMORY pParentSetData,
                               READ_ONLY CFastHeap* pParentHeap,
                               READ_ONLY LPMEMORY pChildSetData,
                               READ_ONLY CFastHeap* pChildHeap,
                               BOOL bCheckValidity = FALSE);
    static LPMEMORY Merge(
                          READ_ONLY LPMEMORY pParentSetData,
                          READ_ONLY CFastHeap* pParentHeap,
                          READ_ONLY LPMEMORY pChildSetData,
                          READ_ONLY CFastHeap* pChildHeap,
                          NEW_OBJECT LPMEMORY pDest, 
                          MODIFY CFastHeap* pNewHeap,
                          BOOL bCheckValidity = FALSE);

    static length_t ComputeUnmergedSpace(
                          READ_ONLY LPMEMORY pMergedData);

    static  BOOL HasLocalQualifiers(
                          READ_ONLY LPMEMORY pMergedData)
    {
        return ComputeUnmergedSpace(pMergedData) != GetMinLength();
    }
                        
    static LPMEMORY Unmerge(
                          READ_ONLY LPMEMORY pMergedData,
                          READ_ONLY CFastHeap* pMergedHeap,
                          NEW_OBJECT LPMEMORY pDest,
                          MODIFY CFastHeap* pNewHeap);

    static HRESULT GetText(READ_ONLY LPMEMORY pData, READ_ONLY CFastHeap* pHeap,
        long lFlags, NEW_OBJECT OUT WString& wsText);

    //************************** Dynamic part ************************
protected:
    length_t m_nLength;
    CQualifier* m_pOthers;

    CFastHeap* m_pHeap;

public:
    CBasicQualifierSet(){}
    ~CBasicQualifierSet(){}

     void SetData(LPMEMORY pStart, CFastHeap* pHeap)
    {
        m_nLength = *(PLENGTHT)pStart;
        m_pOthers = (CQualifier*)(pStart + sizeof(length_t));
        m_pHeap = pHeap;
    }

     LPMEMORY GetStart() {return LPMEMORY(m_pOthers) - sizeof(length_t);}
     length_t GetLength() {return m_nLength;}
     BOOL IsEmpty() {return m_nLength == sizeof(length_t);}
     CQualifier* GetFirstQualifier() {return m_pOthers;}
     LPMEMORY Skip() {return GetStart() + m_nLength;}
     void IncrementLength(length_t nIncrement)
    {
        m_nLength += nIncrement;
        *(PLENGTHT)GetStart() = m_nLength;
    }

     void Rebase(LPMEMORY pNewMemory)
    {
        m_pOthers = (CQualifier*)(pNewMemory + sizeof(length_t));
    }

    CFastHeap* GetHeap() {return m_pHeap;}
public:
     int GetNumUpperBound()
        {return m_nLength / CQualifier::GetHeaderLength();}

     INTERNAL CQualifier* GetRegularQualifierLocally(LPCWSTR wszName)
    {
        return GetRegularQualifierLocally(GetStart(), m_pHeap, wszName);
    }
     INTERNAL CQualifier* GetKnownQualifierLocally(int nStringIndex)
        {return GetKnownQualifierLocally(GetStart(), nStringIndex); }

     INTERNAL CQualifier* GetQualifierLocally(LPCWSTR wszName,
                                                  int& nKnownIndex)
    {
        return GetQualifierLocally(GetStart(), m_pHeap, wszName, nKnownIndex);
    }

     INTERNAL CQualifier* GetQualifierLocally(LPCWSTR wszName)
        {int nKnownIndex; return GetQualifierLocally(wszName, nKnownIndex);}

     INTERNAL CQualifier* GetQualifierLocally(CCompressedString* pcsName)
        {return GetQualifierLocally(GetStart(), GetHeap(), pcsName);}


    HRESULT EnumPrimaryQualifiers(BYTE eFlags, BYTE fFlavorMask, 
        CFixedBSTRArray& aMatching, CFixedBSTRArray& aNotMatching);

     HRESULT GetText(long lFlags, NEW_OBJECT OUT WString& wsText)
        { return GetText(GetStart(), GetHeap(), lFlags, wsText);}

	 BOOL Compare( CBasicQualifierSet& qsThat, BYTE eFlags,
			LPCWSTR* ppFilters = NULL, DWORD dwNumFilters = 0 );

	BOOL CompareLocalizedSet( CBasicQualifierSet& qsThat );

	 BOOL CanBeReconciledWith( CBasicQualifierSet& qsThat );

	 HRESULT IsValidQualifierSet( void );

};

//*****************************************************************************
//*****************************************************************************
//
//  class CQualifierSetContainer
//
//  Defines the functionality that a class containing a qualifier set must
//  implement. These classes are CClassPart, CInstancePart, and specialized
//  containers CClassPQSContainer and CInstancePQSContainer defined below.
//
//*****************************************************************************
//
//  PURE GetHeap
//
//  Returns:
//
//      CFastHeap*: the heap that the qualifier set should use.
//
//*****************************************************************************
//
//  GetWbemObjectUnknown
//
//  Returns:
//
//      IUnknown*:   pointer to the IUnknown of the CWbemObject containing the 
//              qualifier set. We need it since qualifier sets are themselves
//              COM objects, but they need to ensure that the containing 
//              CWbemObject survives as long as they do, and so they must
//              propagate their AddRef's and Release's to the CWbemObject.
//
//*****************************************************************************
//
//  GetQualifierSetStart
//
//  Returns:
//
//      LPMEMORY;   The pointer to the memory block of the qualifier set.
//                  Note that the value of this pointer may change even as the
//                  qualifier set remains active due to object reallocations.
//
//*****************************************************************************
//
//  CanContainKey
//
//  Returns:
//
//      HRESULT    S_OK iff this qualifier set is allowed to contain a 'key' 
//              qualifier. Only class property qualifier sets are allowed to
//              do so, and then only those of approved key types.
//
//*****************************************************************************
//
//  CanContainSingleton
//
//  Whether it is legal for this qualifier set to contain a 'singleton' 
//  qualifier.
//
//  Returns:
//
//      HRESULT    S_OK iff this qualifier set is allowed to contain a 'singelton' 
//              qualifier. Only class qualifier sets are allowed to
//              do so, and then only if not derived from keyed classes.
//
//*****************************************************************************
//
//  CanContainAbstract
//
//  Whether it is legal for this qualifier set to contain an 'abstract' 
//  qualifier.
//
//  Returns:
//
//      HRESULT    S_OK iff this qualifier set is allowed to contain an 'abstract' 
//              qualifier. Only class qualifier sets are allowed to
//              do so, and then only if not derived from a non-abstract class
//
//*****************************************************************************
//
//  CanContainDynamic
//
//  Whether it is legal for this qualifier set to contain a 'dynamic' 
//  qualifier.
//
//  Returns:
//
//      HRESULT    S_OK iff this qualifier set is allowed to contain an 'dynamic' 
//              qualifier. Only proeprty and class qualifier sets are allowed to
//              do so.
//
//*****************************************************************************
//
//  ExtendQualifierSetSpace
//
//  Qualifier set calls this method to request that its memory block be
//  extended. The container must comply and either make room at the end of the
//  qualifier set's curent block, or reallocate the set to another location.
//  In the latter case, the container must copy the set's data and call Rebase
//  on the set before returning from this call.
//
//  Parameters:
//
//      CBasicQualifierSet* pSet    Identifies the qualifier set making the
//                                  request.
//      length_t nNewLength         The required length of the memory block.
//
//  Returns:
//
//      void: there is no out-of-memory handling.
//
//*****************************************************************************
//
//  ReduceQualifierSetSpace
//
//  Qualifier set calls this method to inform the container that it no longer
//  needs as much room as it currently has. The container may NOT move the
//  set's memory block in response to this call. 
//
//  Parameters:
//
//      CBasicQualifierSet* pSet    Identifies the qualifier set making the
//                                  request.
//      length_t nDecrement         How much memory is being returned.
//
//*****************************************************************************

class CQualifierSetContainer
{
public:
    virtual CFastHeap* GetHeap() = 0;
    virtual IUnknown* GetWbemObjectUnknown() = 0;
    virtual LPMEMORY GetQualifierSetStart() = 0;
    virtual BOOL ExtendQualifierSetSpace(CBasicQualifierSet* pSet, 
        length_t nNewLength) = 0;
    virtual void ReduceQualifierSetSpace(CBasicQualifierSet* pSet,
        length_t nDecrement) = 0;
    virtual HRESULT CanContainKey() = 0;
    virtual HRESULT CanContainSingleton() = 0;
    virtual HRESULT CanContainAbstract( BOOL fValue ) = 0;
    virtual HRESULT CanContainDynamic() = 0;
    virtual BOOL CanHaveCimtype(LPCWSTR wszCimtype) = 0;
};

class IExtendedQualifierSet : public IWbemQualifierSet
{
public:
    STDMETHOD(CompareTo)(long lFlags, IWbemQualifierSet* pOther) = 0;
};

// qualifier used to indicate conflicts during updates
// Prefixed by double underscore so it can't be added by
// "just anyone"
#define UPDATE_QUALIFIER_CONFLICT L"__UPDATE_QUALIFIER_CONFLICT"

//*****************************************************************************
//*****************************************************************************
//
//  class CQualifierSet
//
//  The real full-blown qualifier set. The most important distinctions from
//  CBasicQualifierSet is that it is cognisant of:
//  1) Its container, which allows it to request more space and thus enables
//      it to perform qualifier addition and deletion related operations.
//  2) Its parent set. For classes, it is the corresponding qualifier set of
//      its parent class. For instance, that of its class. This allows this
//      object to properly obtain propagated qualifiers. See below for
//      class/instance distinctions in handling.
//
//  Qualifier propagation happens in two contexts: from parent class to child
//  class and from class to instance. The mechanisms used in these cases are
//  quite different. In the case of a class, the qualifier sets of the parent
//  and the child are merged (see CBasicQualifierSet::Merge) to produce the
//  qualifier set actually used in the child. For instances, however, they are
//  not merged, thus cutting down the loading and saving time of instances
//  quite significantly (instance data is loaded from disk into memory without
//  any modifications whasoever).
//
//  However, both instance and class qualifier sets need to have a pointer to 
//  their "parent"'s qualifier set in order to function properly. Instances 
//  need this pointer to perform every operation --- even qualifier lookup 
//  needs to happen in both the child and the parent sets. 
//
//  Classes need this pointer only during delete operations: if a qualifier is
//  deleted from the child class, it is possible that the parent's qualifier 
//  which was overriden by the deletee needs to be brought in, since it is now
//  unmasked.
//  
//  Note, that the parent qualifier set has two nice features: it has no 
//  relevant parent itself, and it cannot change. Thus, CBasicQualifierSet is
//  perfectly sufficient to represent it.
//
//  In order to describe the relation between this set and the parent set
//  CQualifierSet uses a template parameter m_nPropagationFlag, which will be
//  WBEM_FLAVOR_FLAG_PROPAGATE_TO_DERIVED_CLASS for child class-parent class 
//  relations and WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE for instance-class
//  relations. 
//
//  The extra difficulty in qualifier sets is that they must exist as stand-
//  alone COM objects. For that and other reasons, they cannot be successfully
//  rebased by their containing CWbemObject every time the object itself is
//  reallocated (this is the case for property qualifier sets). Thus, 
//  qualifier sets always rebase themselves to the new memory block available
//  from their container every time they service a COM call.
//
//*****************************************************************************
//
//  SetData
//
//  Sets up internal members given the initial information about the location
//  of the qualifier set.
//
//  Parameters:
//
//      LPMEMORY pStart                     The qualifier set's memory block.
//      CQualifierSetContainer* pContainer  The container pointer.
//      CBasicQualifierSet* pSecondarySet   The parent qualifier set.
//
//*****************************************************************************
//
//  SelfRebase
//
//  Gets its (new) memory block location from its container and rebases itself
//  to this new block. Done at the beginning of every COM interface call.
//
//*****************************************************************************
//
//  IsComplete
//
//  Returns:
//
//      BOOL:   TRUE iff this qualifier set is "complete" without its parent
//              set. As described in the header, this is true for class sets
//              but not for instance sets.
//
//*****************************************************************************
//
//  GetQualifier
//
//  The ultimate qualifier reader. It will look for the qualifier in the 
//  primary set and, if that is not complete, in the parent set as well 
//  (subject to propagation rules).
//
//  Parameters:
//
//      LPCWSTR wszName     The name of the qualifier to get.
//      BOOL& bLocal        (Optional) If provided, it is set to TRUE if the
//                          qualifier is local ((re)defined in the primary set)
//  Returns:
//
//      CQualifier*:    the pointer to the qualifier or NULL if not found. This
//                      pointer is of course TEMPORARY subject to object 
//                      relocation.
//
//*****************************************************************************
//
//  SetQualifierValue
//
//  Adds a qualifier to the set or changes the value of the qualifier that
//  already exists. The parent set is checked (if appropriate) for permissions.
//  
//  Parameters:
//
//      LPCWSTR wszName         The name of the qualifier to set.
//      BYTE fFlavor            The flavor to assign. Does not check the flavor
//                              for legality.
//      CTypedValue* pValue     The new value of the qualifier. If this value
//                              contains extra data (string, array), it must
//                              be on the heap of this qualifier set.
//      BOOL bCheckPermissions  If TRUE and the qualifier exists in the parent
//                              set, the parent's flavor is checked for
//                              override protection.
//		BOOL fValidateName		If TRUE, we will make sure the name is valid, if
//								FALSE, we don't.  The main reasone we do this
//								is because we may need to add system qualifiers
//								that we don't want a user to have access to.
//  Returns:
//
//      WBEM_NO_ERROR                On Success
//      WBEM_E_OVERRIDE_NOT_ALLOWED  The qualifier is defined in the parent set
//                                  and overrides are not allowed by the flavor
//      WBEM_E_CANNOT_BE_KEY         An attempt was made to introduce a key
//                                  qualifier in a set where it does not belong
//
//*****************************************************************************
//
//  DeleteQualifier
//
//  Deletes a qualifier from the set. 
//
//  Parameters:
//
//      LPCWSTR wszName         The name of the qualifier to delete.
//      BOOL bCheckPermissions  If TRUE, checks if the qualifier is actually
//                              a parent's qualifier propagated to us. (In this
//                              case it cannot be deleted).
//  Returns:
//
//      WBEM_NO_ERROR                The qualifier was deleted.
//      WBEM_S_NOT_FOUND             The qualifier was not there. This is a 
//                                  success value
//      WBEM_E_PROPAGATED_QUALIFIER  It is our parent's qualifier and therefore
//                                  cannot be deleted.
//      WBEM_S_NOT_FOUND             Qualifier not found
//
//*****************************************************************************
//
//  EnumQualifiers
//
//  This function is used for qualifier enumeration. It creates a list of names
//  of all the qualifiers (local or propagated) matching certain criteria. Both
//  the criteria identified by eFlags and that identified by fFlavorMask must
//  be satisfied for a qualifier to be included.
//
//  Paramaters:
//
//      [in] BYTE eFlags                Can be 0 (no restriction) or 
//                                      WBEM_FLAG_LOCAL_ONLY or 
//                                      WBEM_FLAG_PROPAGATED_ONLY
//      [in] BYTE fFlavorMask           Can be 0 (no restriction) or any 
//                                      combination of:
//                                      WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE,
//                                      WBEM_FLAVOR_FLAG_PROPAGATE_TO_DERIVED_CLASS
//                                      in which case those flavor bits must be
//                                      prtesent in the qualifier's flavor.
//      [out] CFixedBSTRArray& aNames   Destination for the array (see
//                                      faststr.h for definitions).
//
//*****************************************************************************
//
//  operator ==()
//
//  This function is used check if two qualifier sets are equal.  To be
//	equal, there must be an equivalent number of parameters, the names
//	must be the same (and in the same order), and the values must be the
//	same
//
//  Parameters:
//
//      [in] CQualifierSet& qualifierset	Qualifier set to compare to.
//
//*****************************************************************************
//
//  Compare
//
//  This function is used check if two qualifier sets are equal as indicated
//	by the == function, however in this case, a caller can specify an array
//	of names which can be safely ignored during the comparison.
//
//  Parameters:
//
//      [in] CQualifierSet& qualifierset	Qualifier set to compare to.
//		[in] CFixedBSTRArray* paExcludeNames Array of names we can exclude
//												during the comparison.	
//		[in] BOOL fCheckOrder - Check the order of the data in the qualifier
//								set.
//
//*****************************************************************************
//
//  Update
//
//  This function is used when we are updating a class, and need to update
//	qualifier sets of derived classes and their properties, methods, etc.
//	In force mode, it will handle conflicts via the AddQualifierConflict
//	function.
//
//  Parameters:
//      [in] CBasicQualifierSet& childSet	original qualifier set.
//		[in] long lFlags - Flags for update (must indicate SAFE or FORCE mode)
//		[in] CFixedBSTRArray* paExcludeNames Array of names we can exclude
//												during the update.	
//
//*****************************************************************************
//
//  StoreQualifierConflict
//
//  This function is used when during an update, we encounter a conflict.  Since
//	a set may contain multiple conflicts, we will store them in a single array
//	then add them en masse.
//
//  Parameters:
//		[in] LPCWSTR pwcsName - Name of the qualifier with which we had a conflict.
//		[in] CVar& value - Value for the qualifier with which we had a conflict.
//		[in] CQualifierFlavor& flavor - falue for the qualifier with which we had
//										a conflict.
//		[in,out] CVerVector& vectorConflicts - Array of qualifier conflicts.
//
//*****************************************************************************
//
//  AddQualifierConflicts
//
//  This function is used when during an update, we encounter a conflict.  In
//	this case, we will add an "__UPDATE_QUALIFIER_CONFLICT" qualifier and store
//	the name, value and flavors for which we encountered the conflict.  Note that
//	we will preserve any preexisting values as necessary.
//
//  Parameters:
//		[in] CVarVector& vectorConflicts - Array of conflict descriptions.
//
//*****************************************************************************
//
//  CopyLocalQualifiers
//
//  This function is used when we want to copy local qualifiers from one set
//	to another.  This assumes we will be able to gro heaps, do fixups and
//	all that other lovely stuff.
//
//  Parameters:
//		[in] CQualifierSet&	qsSourceSet - Source Qualifier Set
//
//*****************************************************************************
//
//  GetQualifier
//
//  Reads local and propagated qualifiers and retrieves values to boot.
//
//  Parameters:
//
//      LPCWSTR wszName     The name of the qualifier to get.
//      long*	plFlavor	(optional) returns the flavor
//		CVar*	pVal		(optional) returns the value
//  Returns:
//
//      WBEM_S_NO_ERROR if success.
//
//*****************************************************************************
//**************************** IUnknown interface *****************************
//
//  CQualifierSet has its own reference count, but since it is a part of an
//  WbemObject, it needs to ensure that the containing object hangs around for
//  at least as long as the qualifier set does. Thus, in addition to keeping
//  its own reference count, the qualifier set forwards AddRef and Release 
//  calls to the containing object.
//
//*****************************************************************************
//************************ IWbemQualifierSet interface *************************
//
//  Documented in help file 
//
//*****************************************************************************
#pragma warning(disable: 4275)

class COREPROX_POLARITY CQualifierSet : public CBasicQualifierSet, 
					  public IExtendedQualifierSet
{
protected:
    int m_nPropagationFlag; // a template parameter, really

    long m_nRef;
    IUnknown* m_pControl;

    CQualifierSetContainer* m_pContainer;
    CBasicQualifierSet* m_pSecondarySet;

    CFixedBSTRArray m_astrCurrentNames;
    int m_nCurrentIndex;

	// Handling for qualifier conflicts during update operations
	HRESULT AddQualifierConflicts( CVarVector& vectorConflicts );
	HRESULT StoreQualifierConflicts( LPCWSTR pwcsName, CVar& value,
				CQualifierFlavor& flavor, CVarVector& vectorConflicts );

public:
    CQualifierSet(int nPropagationFlag, int nStartRef = 0);
    virtual ~CQualifierSet();

     void SetData(LPMEMORY pStart, 
        CQualifierSetContainer* pContainer, 
        CBasicQualifierSet* pSecondarySet = NULL)
    {
        CBasicQualifierSet::SetData(pStart, pContainer->GetHeap());

        m_pContainer = pContainer;
        m_pSecondarySet = pSecondarySet;
        m_pControl = pContainer->GetWbemObjectUnknown();
    }

     BOOL SelfRebase()
    {
        LPMEMORY pStart = m_pContainer->GetQualifierSetStart();
        if(pStart == NULL) return FALSE;
        Rebase(pStart);
        return TRUE;
    }

     BOOL IsComplete() 
    {
        return (m_nPropagationFlag == 
                WBEM_FLAVOR_FLAG_PROPAGATE_TO_DERIVED_CLASS);
    }
                                                         
     CQualifier* GetQualifier(READ_ONLY LPCWSTR wszName, 
                                    OUT BOOL& bLocal);
     CQualifier* GetQualifier(READ_ONLY LPCWSTR wszName)
    {
        BOOL bLocal; 
        return GetQualifier(wszName, bLocal);
    }

    HRESULT SetQualifierValue(COPY LPCWSTR wszName, 
                                     BYTE fFlavor,
                                     COPY CTypedValue* pNewValue,
                                     BOOL bCheckPermissions,
									 BOOL fValidateName = TRUE);

    HRESULT ValidateSet(COPY LPCWSTR wszName, 
                                     BYTE fFlavor,
                                     COPY CTypedValue* pNewValue,
                                     BOOL bCheckPermissions,
									 BOOL fValidateName = TRUE);

    HRESULT DeleteQualifier(READ_ONLY LPCWSTR wszName,
                                   BOOL bCheckPermissions);

    HRESULT EnumQualifiers(BYTE eFlags, BYTE fFlavorMask, 
        CFixedBSTRArray& aNames);

	BOOL operator ==( CQualifierSet& qualifierset )	{ return Compare( qualifierset ); }
	BOOL Compare( CQualifierSet& qualifierset, CFixedBSTRArray* paExcludeNames = NULL, BOOL fCheckOrder = TRUE );

	// Updates 'this' qualifier set from the memory block of the supplied
	// basic qualifer set.

	HRESULT Update( CBasicQualifierSet& childSet, long lFlags, CFixedBSTRArray* paExcludeNames = NULL );

	HRESULT CopyLocalQualifiers( CQualifierSet& qsSource );

	// Helper function to retrieve qualifiers from the set.
	HRESULT GetQualifier( LPCWSTR pwszName, CVar* pVar, long* plFlavor, CIMTYPE* pct = NULL );

	// Helper function to retrieve qualifiers from the set as typed values
	HRESULT GetQualifier( LPCWSTR pwszName, long* plFlavor, CTypedValue* pTypedValue, CFastHeap** ppHeap,
						BOOL fValidateSet );

public:
    /* IUnknown methods */
    STDMETHOD(QueryInterface)(REFIID riid, LPVOID FAR* ppvObj)
    {
        if(riid == IID_IWbemQualifierSet || riid == IID_IUnknown)
        {
            AddRef();
            *ppvObj = (void*)(IWbemQualifierSet*)this;
            return S_OK;
        }
        else return E_NOINTERFACE;
    }
    STDMETHOD_(ULONG, AddRef)(){ InterlockedIncrement( &m_nRef ); return m_pControl->AddRef();}
    STDMETHOD_(ULONG, Release)()
    {
		long lRef = InterlockedDecrement( &m_nRef );
        m_pControl->Release();
        if( lRef == 0)
        {
            delete this;
            return 0;
        }
        else return lRef;
    }

    /* IWbemQualifierSet methods */

    HRESULT STDMETHODCALLTYPE Get( 
        LPCWSTR Name,
        LONG lFlags,
        VARIANT *pVal,
        LONG *plFlavor);
    
    HRESULT STDMETHODCALLTYPE Put( 
        LPCWSTR Name,
        VARIANT *pVal,
        LONG lFlavor);
    
    HRESULT STDMETHODCALLTYPE Delete( 
        LPCWSTR Name);
    
    HRESULT STDMETHODCALLTYPE GetNames( 
        LONG lFlavor,
        LPSAFEARRAY *pNames);
    
    HRESULT STDMETHODCALLTYPE BeginEnumeration(LONG lFlags);
    
    HRESULT STDMETHODCALLTYPE Next( 
        LONG lFlags,
        BSTR *pName,
        VARIANT *pVal,
        LONG *plFlavor);

    HRESULT STDMETHODCALLTYPE EndEnumeration();

	// extra
    STDMETHOD(CompareTo)(long lFlags, IWbemQualifierSet* pOther);
};

//*****************************************************************************
//*****************************************************************************
//
//  class CQualifierSetListContainer
//
//  This pure abstract class defines the functionality required of objects 
//  whose memory block contains that of a qualifier set list (see 
//  CQualifierSetList below).
//
//*****************************************************************************
//
//  GetHeap
//
//  Returns the pointer to the CFastHeap on which the qualifiers should store
//  their variable-sized data (like strings).
//
//  Returns:
//
//      CFastHeap*
//
//*****************************************************************************
//
//  ExtendQualifierSetListspace
//
//  Requests that the size of the memory block alloted for the list be
//  increased. If the container cannot accomplish that without moving the 
//  memory block, it must call Rebase on the List.
//
//  Parameters:
//
//      LPMEMORY pOld           Pointer to the current memory block.
//      length_t nOldLength     Current length of the block.
//      length_t nNewLength     Required length of the block.
//
//  No out-of-memory conditions are supported.
//
//*****************************************************************************
//
//  ReduceQualifierSetListSpace
//
//  Requests that the size of the memory block alloted for this list be reduced
//  The container may NOT move the object's memory block during this operation.
//
//  Parameters:
//
//      LPMEMORY pOld           Current memory block start address
//      length_t nOldLength     Current length of the block
//      length_t nDecrement     How much space to return to the container.
//
//*****************************************************************************
//  
//  GetQualifierSetListStart
//
//  Self-rebasing function. Since the location of the memory block of the list 
//  can change between calls, the list will want to ask the container to point
//  to the current location of the block in the beginning of certain calls.
//
//  Returns:
//
//      LPMEMORY    Current location of the memory block.
//
//*****************************************************************************
//
//  GetWbemObjectUnknown
//
//  Since (as described in IUnknown implementation help above) qualifier sets
//  need to link their reference counts with those of the containing WbemObject,
//  this function is used by the list to obtain the location of the WbemObject's
//  reference count.
//
//  Returns:
//
//      IUnknown*    location of the main object's ref count.
//
//*****************************************************************************

class COREPROX_POLARITY CQualifierSetListContainer
{
public:
    virtual CFastHeap* GetHeap() = 0;
    virtual BOOL ExtendQualifierSetListSpace(LPMEMORY pOld, 
        length_t nOldLength, length_t nNewLength) = 0;
    virtual void ReduceQualifierSetListSpace(LPMEMORY pOld, 
        length_t nOldLength, length_t nDecrement) = 0;
    virtual LPMEMORY GetQualifierSetListStart() = 0;
    virtual IUnknown* GetWbemObjectUnknown() = 0;
};

//*****************************************************************************
//*****************************************************************************
//
//  class CQualifierSetList
//
//  This class represents a list of a fixed number of qualifier set. It is
//  used by WBEM instances (CWbemInstance) to represent instance property
//  qualifier sets. The storage model is optimized for the case where no 
//  instance property qualifiers are present (which is most of the time). 
//
//  The layout of the memory block for the list is as follows.
//  It starts with one BYTE which can be either QSL_FLAG_NO_SETS, in which case
//  that's the end of it, or QSL_FLAG_PRESENT, in which case it is followed by
//  the predefined number of qualifier sets, one after another. 
//
//*****************************************************************************
//
//  SetData
//
//  Informs the list of its position and other information. Initialization.
//
//  Parameters:
//
//      LPMEMORY pStart                         The start of the memory block
//      int nNumSets                            The number of sets.
//      CQualifierSetListContainer* pContainer  The container.
//
//*****************************************************************************
//
//  GetStart
//
//  Returns:
//
//      LPMEMORY    The starting address of the memory block.
//
//*****************************************************************************
//
//  static GetHeaderLength
//
//  The number of bytes before the actual qualifier set data starts (currently
//  1).
//
//*****************************************************************************
//
//  GetLength
//
//  Returns:
//
//      int;    the length of the complete structure.
//
//*****************************************************************************
//
//  static GetLength
//
//  Parameters:
//
//      LPMEMORY pStart     The start of the memory block
//      int nNumSets        The number of sets in the list
//
//  Returns:
//
//      int;    the length of the complete structure.
//
//*****************************************************************************
//
//  Rebase
//
//  Informs the list that its memory block has moved. The object updates
//  internal members pointing to the data.
//
//  Parameters:
//
//      LPMEMORY pStart     The memory block.
//
//*****************************************************************************
//
//  Rebase
//
//  Same as the other Rebase, but gets the pointer to the new memory block
//  from our container. Used for self-rebasing at the beginning of operations.
//
//*****************************************************************************
//
//  GetQualifierSetData
//
//  Returns the address of the data for the qualifier set at a given index.
//
//  Parameters:
//
//      int nIndex      The index of the set to access
//
//  Returns:
//
//      LPMEMORY:   the pointer to the data.
//
//*****************************************************************************
//
//  InsertQualifierSet
//
//  Insers an empty qualifier set into a given location. If the list is not 
//  populated at the moment (is of style QSL_FLAG_NO_SETS) it is converted
//  to a real one (stype QSL_FLAG_PRESENT). 
//
//  This call request extra memory from the container, which may move the
//  list's memory block.
//
//  Parameters:
//
//      int nIndex      The index of the position to insert into.
//
//*****************************************************************************
//
//  DeleteQualifierSet
//
//  Deletes a qualifier set at a given position from the list
// 
//  Parameters:
//
//      int nIndex      The index of the qualifier set to delete
//
//*****************************************************************************
//
//  ExtendQualifierSetSpace
//
//  Extends the amount of space alloted for a given qualifier set by moving
//  the later qualifier sets forward.
//
//  This call request extra memory from the container, which may move the
//  list's memory block.
//
//  Parameters:
//
//      CBasicQualifierSet* pSet        The qualiier set to extend
//      length_t nNewLength             The length required by the set.
//
//*****************************************************************************
//
//  ReduceQualifierSetSpace
//
//  Reduces the amount of space alloted for a given qualifier by moving the
//  later qualifier sets backward.
//
//  Parameters:
//
//      CbaseicQualifierSet* pSet       The qualfiier set to reduce
//      length_t nDecrement             By how much (in bytes).
//
//*****************************************************************************
//
//  static ComputeNecessarySpace
//
//  Computes the number of bytes needed for a qualifier set list with a given
//  number of (empty) sets. Actually, this number is the size of the header, 
//  i.e. 1 byte, since that's how much a completely empty list takes.
//
//  Parameters:
//
//      int nNumSets        The number of qualifier sets. Ignored.
//
//  Returns:
//
//      length_t
//
//*****************************************************************************
//
//  static ComputeRealSpace
//
//  Computes the number of bytes required for a qualifier set list with a given
//  numbed of empty qualifier sets, but with the QSL_FLAG_PRESENT style, i.e.
//  with all the qualifier sets actually written as opposed to a single byte
//  saying that ther aren't any (see ComputeNecessarySpace).
//
//  Parameters:
//
//      int nNumSets        The number of qualifier sets.
//
//  Returns:  
//
//      length_t
//
//*****************************************************************************
//
//  static CreateListOfEmpties
//
//  Creates a qualifier set list on a given piece of memory coresponding to 
//  a given number of empty qualifier sets. It is created in the 
//  QSL_FLAG_NO_SETS style, and thus consists of a single bytes saying "none".
//
//  The block must contain enough space to accomodate the list, see
//  ComputeNecessarySpace.
//
//  Parameters:
//
//      LPMEMORY pMemory        Where to create.
//      int nNumSets            The number of sets to create. Ignored.
//
//  Returns:
//
//      LPMEMORY: points to the next byte after the list's representation.
//
//*****************************************************************************
//
//  EnsureReal
//
//  Ensures that the list is in the QSL_FLAG_PRESENT style. If it is not, the
//  list is converted. Such an operation will request extra memory from the 
//  container and can thus move the memory block of the list.
//
//*****************************************************************************
//
//  TranslateToNewHeap
//
//  Moves any data that the list keeps on the heap to a different heap. This
//  class simply propagates the call to all its member qualifier sets, it any.
//
//  Note: this function does not free the data from the original heap.
//
//  Parameters:
//
//      CFastHeap* pOldHeap     Where the heap data is currently stored
//      CFastHeap* pNewHeap     Where the data should be moved to.  
//
//*****************************************************************************


#define QSL_FLAG_NO_SETS 1
#define QSL_FLAG_PRESENT 2
class COREPROX_POLARITY CQualifierSetList// : public CQualifierSetContainer
{
private:
    int m_nNumSets;
    int m_nTotalLength;
    LPMEMORY m_pStart;
    CQualifierSetListContainer* m_pContainer;
    
public:
     void SetData(LPMEMORY pStart, int nNumSets, 
        CQualifierSetListContainer* pContainer)
    {
        m_nNumSets = nNumSets;
        m_pContainer = pContainer;
        m_pStart = pStart;

        m_nTotalLength = GetLength(pStart, nNumSets);
    }
     LPMEMORY GetStart() {return m_pStart;}
     int GetNumSets(){ return m_nNumSets; };
     static GetHeaderLength() {return sizeof(BYTE);}
     BOOL IsEmpty() {return *m_pStart == QSL_FLAG_NO_SETS;}
     static GetLength(LPMEMORY pStart, int nNumSets)
    {
        if(*pStart == QSL_FLAG_NO_SETS) return GetHeaderLength();
        LPMEMORY pCurrent = pStart + GetHeaderLength();
        for(int i = 0; i < nNumSets; i++)
        {
            pCurrent += CBasicQualifierSet::GetLengthFromData(pCurrent);
        }

		// DEVNOTE:WIN64:SJS - 64-bit pointer values truncated into 
		// signed/unsigned 32-bit value.  We do not support length
		// > 0xFFFFFFFF so cast is ok.

        return (length_t) ( pCurrent - pStart );
    }
     int GetLength() {return m_nTotalLength;}

     static size_t ValidateBuffer(LPMEMORY start, size_t cbSize, int propCount);

     void Rebase(LPMEMORY pNewMemory) { m_pStart = pNewMemory;}
     void Rebase() {Rebase(m_pContainer->GetQualifierSetListStart());}

public:
     static LPMEMORY GetQualifierSetData(LPMEMORY pStart, int nIndex)
    {
        if(*pStart == QSL_FLAG_NO_SETS) return NULL;
        LPMEMORY pCurrent = pStart + GetHeaderLength();
        for(int i = 0; i < nIndex; i++)
        {
            pCurrent += CBasicQualifierSet::GetLengthFromData(pCurrent);
        }
        return pCurrent;
    }
     LPMEMORY GetQualifierSetData(int nIndex)
    {
        return GetQualifierSetData(m_pStart, nIndex);
    }

    HRESULT InsertQualifierSet(int nIndex);
    void DeleteQualifierSet(int nIndex);

public:
    BOOL ExtendQualifierSetSpace(CBasicQualifierSet* pSet,length_t nNewLength);
    void ReduceQualifierSetSpace(CBasicQualifierSet* pSet, length_t nReduceBy);

     CFastHeap* GetHeap() {return m_pContainer->GetHeap();}
    IUnknown* GetWbemObjectUnknown() 
        {return m_pContainer->GetWbemObjectUnknown();}
public:

    static  length_t ComputeNecessarySpace(int nNumSets)
    {
        return GetHeaderLength();
    }
    static  length_t ComputeRealSpace(int nNumSets)
    {
        return nNumSets * CBasicQualifierSet::GetMinLength() + 
            GetHeaderLength();
    }
    static  LPMEMORY CreateListOfEmpties(LPMEMORY pStart,int nNumProps);
     BOOL EnsureReal();
     BOOL TranslateToNewHeap(CFastHeap* pCurrentHeap, 
                                   CFastHeap* pNewHeap);
    
    LPMEMORY CreateLimitedRepresentation(
        IN class CLimitationMapping* pMap, IN CFastHeap* pCurrentHeap, 
        MODIFIED CFastHeap* pNewHeap, OUT LPMEMORY pWhere);
    
    LPMEMORY WriteSmallerVersion(int nNumSets, LPMEMORY pMem);
};

//*****************************************************************************
//
//  class CInstancePropertyQualifierSetList
//
//  This is the class that represents the list of qualifier sets for the 
//  properties of an instance. See CQualifierSetList (above) for the actual
//  descriptions.
//
//*****************************************************************************
typedef CQualifierSetList CInstancePropertyQualifierSetList;

//*****************************************************************************
//
//  class CInstanceQualifierSet
//
//  The qualifier set for the whole instance. It uses the CQualifierSet class
//  template with the propagation parameter (determining which of the parent's
//  qualifiers propagate to us) of WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE.
//
//*****************************************************************************

class COREPROX_POLARITY CInstanceQualifierSet : public CQualifierSet
{
public:
    CInstanceQualifierSet(int nStartRef = 0)
        : CQualifierSet(WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE, nStartRef)
    {}
    STDMETHOD_(ULONG, Release)()
    {
        long lRef = InterlockedDecrement( &m_nRef );
        m_pControl->Release();
        // do not delete ourself, we are embedded
        return lRef;
    }    
};

//*****************************************************************************
//
//  class CClassQualifierSet
//
//  The qualifier set for the whole class. It uses the CQualifierSet class
//  template with the propagation parameter (determining which of the parent's
//  qualifiers propagate to us) of WBEM_FLAVOR_FLAG_PROPAGATE_TO_DERIVED_CLASS.
//
//*****************************************************************************
class COREPROX_POLARITY CClassQualifierSet : public CQualifierSet
{
public:
    CClassQualifierSet(int nStartRef = 0)
        : CQualifierSet(WBEM_FLAVOR_FLAG_PROPAGATE_TO_DERIVED_CLASS, nStartRef)
    {}
    STDMETHOD_(ULONG, Release)()
    {
        long lRef = InterlockedDecrement( &m_nRef );
        m_pControl->Release();
        // do not delete ourself, we are embedded
        return lRef;
    }    
};

//*****************************************************************************
//*****************************************************************************
//
//  class CClassPQSContainer
//
//  Before reading this, it is advisable to read the help for the
//  CClassPropertyQualifierSet class below.
//
//  This class represents the container for a qualifier set of a class 
//  property. Its purpose in life is managing the qualifier set's requests for
//  more memory. The problem is twofold:
//
//  1) As described in CClassPropertyQualifierSet class, several other objects
//  are connected to the qualifier sets and have to be moved with it.
//  2) Since qualifier sets may have a rather long life (they are COM objects 
//  in their own right), other operations on the class can intervene between
//  operations on such a set. But those other operations may, for instance, 
//  insert new properties, etc, causing this set's data to move to a completely
//  different location. Thus, this container needs to be able to "find" the
//  qualifier set's data all over again for every operation.
//
//*****************************************************************************
//
//  Create
//
//  Initializing function, giving this object enough information to always be
//  able to find the set's data.
//
//  Parameters:
//
//      CClassPart* pClassPart      The class part containing the property
//                                  definition (see fastcls.h)
//      heapptr_t ptrPropName       The heap pointer to the name of the
//                                  property (on the heap of pClassPart).
//
//*****************************************************************************
//
//  GetQualifierSetStart
//
//  Finds the data of our qualifier set. Does it by looking up the property
//  in the class part by its name and getting its qualifier set from the 
//  CPropertyInformation structure.
//
//  Returns:
//
//      LPMEMORY:   the memory block. very temporary, of coutse.
//
//*****************************************************************************
//
//  SetSecondarySetData
//
//  Finds the parent qualifier set data and informs our qualifier set of it
//  Does it by looking up our property in the parent's class part (obtained
//  from our class part.
//
//*****************************************************************************
//
//  ExtendQualifierSetSpace
//
//  Processes a request from its qualifier set for more space. Requests more
//  space from the heap that contains us and rebases the qualifier set if
//  reallocation occurs. In this case it moves the entire CPropertyInforamtion
//  structure with it and updates the heap pointer to it in the corresponding
//  CPropertyLookup structure (see fastprop.h) for more info on that.
//
//  Parameters:
//
//      CBasicQualifierSet* pSet        Our qualifier set
//      length_t nNewLength             the required length.
//
//*****************************************************************************
//
//  ReduceQualifierSetSpace
//
//  Processes a request to reduce the amount of space alloted to the set.
//  Currently a noop.
//  
//  Parameters:
//
//      CBasicQualifierSet* pSet        Our qualifier set
//      length_t nDecrement             How many bytes to return.
//
//*****************************************************************************
//
//  CanContainKey
//
//  As required from all qualifier set containers, this function determines if
//  it is legal for this property to contain a 'key' qualifier. The criteria
//  are described in the help file, but property type as well as whether or not
//  the parent class has a key are taken into account here.
//
//  Returns:
//
//      S_OK if key can be legally specified, error otherwise.
//
//*****************************************************************************
//
//  CanContainAbstract
//
//  Whether it is legal for this qualifier set to contain an 'abstract' 
//  qualifier.
//
//  Returns:
//
//      HRESULT    S_OK iff this qualifier set is allowed to contain an 'abstract' 
//              qualifier. Only class qualifier sets are allowed to
//              do so, and then only if not derived from a non-abstract class
//
//*****************************************************************************
//
//  CanContainDynamic
//
//  Whether it is legal for this qualifier set to contain a 'dynamic' 
//  qualifier.
//
//  Returns:
//
//      HRESULT    S_OK iff this qualifier set is allowed to contain an 'dynamic' 
//              qualifier. Only proeprty and class qualifier sets are allowed to
//              do so.
//
//*****************************************************************************

class CClassPart;
class CClassPQSContainer : public CQualifierSetContainer
{
protected:
    CClassPart* m_pClassPart;
    heapptr_t m_ptrPropName;
    offset_t m_nParentSetOffset;

    CBasicQualifierSet* m_pSecondarySet;
    friend class CClassPropertyQualifierSet;
public:
    CClassPQSContainer() : m_pClassPart(NULL), m_pSecondarySet(NULL){}

     void Create(CClassPart* pClassPart, heapptr_t ptrPropName)
    {
        m_pClassPart = pClassPart; m_ptrPropName = ptrPropName;
        m_nParentSetOffset = 0;
        m_pSecondarySet = NULL;
    }

    class CPropertyInformation* GetPropertyInfo();
    LPMEMORY GetQualifierSetStart();
    void SetSecondarySetData();

public:   
    ~CClassPQSContainer();
    CFastHeap* GetHeap();
    BOOL ExtendQualifierSetSpace(CBasicQualifierSet* pSet,length_t nNewlength);
    void ReduceQualifierSetSpace(CBasicQualifierSet* pSet, length_t nReduceBy);
    IUnknown* GetWbemObjectUnknown();
    HRESULT CanContainKey();
    HRESULT CanContainSingleton();
	HRESULT CanContainAbstract( BOOL fValue );
	HRESULT CanContainDynamic();
    BOOL CanHaveCimtype(LPCWSTR wsz);
};

//*****************************************************************************
//*****************************************************************************
//
//  class CClassPropertyQualifierSet
//
//  This class represents the qualifier set for a property. It uses
//  CQualifierSet for most of its functionality, but has a few extra quirks.
//  The problem is that it lives on the heap, as part of the 
//  CPropertyInformation structure for a property. This makes relocation rather
//  complicated: when this qualifier set grows and the container needs to move
//  it to a different location in the heap, rather than just moving the
//  qualifier set it has to move the complete CPropertyInformation object (see
//  fastprop.h for description) as well as update the pointer to it from the
//  CPropertyLookup structure (see same).
//
//  These responsibilities really fall on the qualifier set container object.
//  Hence, this qualifier set uses a very specific implementation, 
//  CClassPropertyPQSContainer to do the job. CClassPropertyQualfieirSet
//  creates the container as its own member and gives it enough information to
//  perform all the reallocations.
//
//*****************************************************************************
//
//  SetData
//
//  Initializes the qualifier set with all the data it needs to survive.
//
//  Parameters:
//
//      LPMEMORY pStart             The location of the memory block for this
//                                  qualifier set (the format of the block is
//                                  described in CBasicQualifierSet).
//      CClassPart* pClassPart      The class part which contains the property
//                                  for which this is a qualifier set (see
//                                  fastcls.h for that).
//      heapptr_t ptrPropName       The heap pointer (on the same heap as the
//                                  set itself) to the name of the property
//                                  we are the qualifier set for.
//      CBasicQualifierSet* pSet    The parent's qualifier set.
//
//*****************************************************************************

class CClassPropertyQualifierSet : public CClassQualifierSet
{
protected:
    CClassPQSContainer m_Container;
public:
     void SetData(LPMEMORY pStart, CClassPart* pClassPart, 
        heapptr_t ptrPropName, CBasicQualifierSet* pSecondarySet = NULL)
    {
        m_Container.Create(pClassPart, ptrPropName);
        m_Container.SetSecondarySetData();
        CClassQualifierSet::SetData(
            pStart, (CQualifierSetContainer*)&m_Container, 
            m_Container.m_pSecondarySet);
    }
    // these guys are free-standing, hence they self delete with the Iunknown::Release
    STDMETHOD_(ULONG, Release)()
    {
        long lRef = InterlockedDecrement( &m_nRef );
        m_pControl->Release();
        if( lRef == 0)
        {
            delete this;
        }
        return lRef;
    }     
};

//*****************************************************************************
//*****************************************************************************
//
//  class CInstancePQSContainer
//
//  This class functions as the qualifier set container for the instance 
//  property qualifier sets. See CInstancePropertyQualifierSet class before
//  reading this help.
//
//  The primary purpose of this class is to contain enough information to 
//  always be able to find the qualifier set data.
//
//*****************************************************************************
//
//  Create
//
//  Initialization function.
//
//  Parameters:
//
//      CInstancePropertyQualifierSetList* pList    The list we are part of.
//      int nPropIndex              The index of our property in the v-table
//      CClassPart* pClassPart      The class part of this instance (fastcls.h)
//      offset_t nClassSetOffset    The offset of the class property qualifier
//                                  set from the class part.
//
//*****************************************************************************
//
//  SetSecondarySetData
//
//  Finds and initializes the parent qualifier set.
//
//*****************************************************************************
//
//  RebaseSecondarySet
//
//  Finds the data of the secondary qualifier set and informs it of the (new)
//  location of its data.
//
//*****************************************************************************
//
//  GetQualifierSetStart
//
//  Finds the qualifier set data and returns the pointer to it.
//  
//  Returns:
//
//      LPMEMORY:   the data of our qualifier set (temporary of course)
//
//*****************************************************************************
//
//  CanContainKey
//
//  The 'key' qualifier cannot be specified on instance, so this function 
//  always
//
//  Returns:
//
//      WBEM_E_INVALID_QUALIFIER
//
//*****************************************************************************
//
//  CanContainAbstract
//
//  Whether it is legal for this qualifier set to contain an 'abstract' 
//  qualifier.
//
//  Returns:
//
//      HRESULT    S_OK iff this qualifier set is allowed to contain an 'abstract' 
//              qualifier. Only class qualifier sets are allowed to
//              do so, and then only if not derived from a non-abstract class
//
//*****************************************************************************
//
//  CanContainDynamic
//
//  Whether it is legal for this qualifier set to contain a 'dynamic' 
//  qualifier.
//
//  Returns:
//
//      HRESULT    S_OK iff this qualifier set is allowed to contain an 'dynamic' 
//              qualifier. Only proeprty and class qualifier sets are allowed to
//              do so.
//
//*****************************************************************************
//
//    
                 
class COREPROX_POLARITY CInstancePQSContainer : public CQualifierSetContainer
{

protected:
    CInstancePropertyQualifierSetList* m_pList;
    int m_nPropIndex;

    CClassPart* m_pClassPart;
    offset_t m_nClassSetOffset;

    CBasicQualifierSet m_SecondarySet;
    friend class CInstancePropertyQualifierSet;
public:
    CInstancePQSContainer() : m_pClassPart(NULL), m_pList(NULL){}

     void Create(CInstancePropertyQualifierSetList* pList, 
                       int nPropIndex,
                       CClassPart* pClassPart,
                       offset_t nClassSetOffset)
    {
        m_pList = pList; m_nPropIndex = nPropIndex;
        m_pClassPart = pClassPart;
        m_nClassSetOffset = nClassSetOffset;
        SetSecondarySetData();
    }

    void SetSecondarySetData();
    void RebaseSecondarySet();
   
    LPMEMORY GetQualifierSetStart();
    
     CFastHeap* GetHeap() {return m_pList->GetHeap();}
     HRESULT CanContainKey() {return WBEM_E_INVALID_QUALIFIER;}
     HRESULT CanContainSingleton() {return WBEM_E_INVALID_QUALIFIER;}
     HRESULT CanContainAbstract( BOOL fValue ) { return WBEM_E_INVALID_QUALIFIER;}
     HRESULT CanContainDynamic() { return WBEM_S_NO_ERROR;}
     BOOL CanHaveCimtype(LPCWSTR) {return FALSE;}
     BOOL ExtendQualifierSetSpace(CBasicQualifierSet* pSet,
        length_t nNewLength)
    {
        if (!m_pList->EnsureReal())
        	return FALSE;
        pSet->Rebase(m_pList->GetQualifierSetData(m_nPropIndex));
        if (!m_pList->ExtendQualifierSetSpace(pSet, nNewLength))
        {
        	return FALSE;
        }
        RebaseSecondarySet();
		
		return TRUE;
    }
     void ReduceQualifierSetSpace(CBasicQualifierSet* pSet,
        length_t nDecrement)
    {
        m_pList->ReduceQualifierSetSpace(pSet, nDecrement);
        RebaseSecondarySet();
    }

    IUnknown* GetWbemObjectUnknown() {return m_pList->GetWbemObjectUnknown();}
};

//*****************************************************************************
//*****************************************************************************
//
//  class CInstancepropertyQualifierSet
//
//  This flavor of CQualifierSet represents a qualifier set of a property of
//  an instance. It uses CQualifierSet for most functionality, but has an
//  additional problem with re-allocation. Since instance property qualifier
//  sets are stored as members of a CQualifierSetList, if one of them needs to
//  grow, the whole list needs to grow, and the whole list may need to relocate
//  and the heap pointer to the list will have to be updated. In addition, 
//  since this qualifier set is an actual COM object, it may live for a long
//  time, and its memory block can be completely moved between operations.
//
//  Hence, a special QualifierSetContainer, CInstancePQSContainer (above) is
//  used. CInstancePropertyQualifierSet stores its container object in itself.
//
//*****************************************************************************
//
//  SetData
//
//  Initializing function supplying enough data for this object to be able
//  to find its data no matter how the instance changes.
//
//  Parameters:
//
//      CInstancePropertyQualifierSetList* pList    The list of which we are
//                                                  a part of.
//      int nPropIndex              The index of our property in the v-table.
//      CClassPart* pClassPart      The class part of the instance (fastcls.h)
//      offset_t nClassSetOffset    The offset of the corresponding class
//                                  property qualifier set off the class part.
//                                  Since the class part of an instance never
//                                  changes, this value is constant.
//
//*****************************************************************************
class CInstancePropertyQualifierSet : public CInstanceQualifierSet
{
protected:
    CInstancePQSContainer m_Container;
public:
     void SetData(CInstancePropertyQualifierSetList* pList, 
        int nPropIndex, CClassPart* pClassPart, offset_t nClassSetOffset)
    {
        m_Container.Create(pList, nPropIndex, pClassPart, nClassSetOffset);
        CInstanceQualifierSet::SetData(m_Container.GetQualifierSetStart(), 
            &m_Container, &m_Container.m_SecondarySet);
    }
    // these guys are free-standing, hence they self delete with the Iunknown::Release
    STDMETHOD_(ULONG, Release)()
    {
        long lRef = InterlockedDecrement( &m_nRef );
        m_pControl->Release();
        if( lRef == 0)
        {
            delete this;
        }
        return lRef;
    }     
     
};

//#pragma pack(pop, 1)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\marshalers\coreprox\fastsprt.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    FASTPRT.H

Abstract:

  This file defines supporting classes for WBEM Class/Instance objects.

  Classes defined: 
      CBitBlockTable:     a two-dimentional array of bits.
      CPtrSource          moving pointer representation base class
          CStaticPtr      static pointer representation
          CShiftedPtr     pointer arithmetic representation.

History:

  2/20/97     a-levn  Fully documented
  12//17/98	sanjes -	Partially Reviewed for Out of Memory.

--*/

//***********************!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
//*************** IMPORTANT *********************************
//
//  1) Memory reallocation (ExtendMemoryBlock) routines may NOT
//      return a forward-overlapping region (say old+1).
//
//**************** IMPORTANT ********************************

#ifndef __FAST_SUPPORT__H_
#define __FAST_SUPPORT__H_

#include "parmdefs.h"
#include "strutils.h"

// pack is necessary since our structures correspond to not necessarily 
// alligned disk data.
#pragma pack(push, 1)

// offset into the object's local heap
typedef DWORD heapptr_t;
// length of a structure
typedef DWORD length_t;
// index of a property in the class v-table
typedef WORD propindex_t;
// offset of the property's data from the v-table start
typedef DWORD offset_t;
// index of the originating class in the derivation chain
typedef DWORD classindex_t;
// identifier length type
typedef length_t idlength_t;
// property type
typedef DWORD Type_t;

typedef UNALIGNED heapptr_t*	PHEAPPTRT;
typedef UNALIGNED length_t*		PLENGTHT;
typedef UNALIGNED propindex_t*	PPROPINDEXT;
typedef UNALIGNED offset_t*		POFFSETT;
typedef UNALIGNED classindex_t*	PCLASSINDEXT;
typedef UNALIGNED idlength_t*	PIDLENGTHT;

typedef UNALIGNED int*			PUNALIGNEDINT;

// arbitrary memory block
typedef BYTE* LPMEMORY;

#define MOST_SIGNIFICANT_BIT_IN_DWORD 0x80000000

typedef __int64 WBEM_INT64;
typedef unsigned __int64 WBEM_UINT64;

// the function like memcpy, but safe for forward copying. memmove will do.
#define MEMRCPY memmove

typedef enum {
    e_Reconcilable, e_ExactMatch, e_DiffClassName, e_DiffParentName, e_DiffNumProperties,
        e_DiffPropertyName, e_DiffPropertyType, e_DiffPropertyLocation,
        e_DiffKeyAssignment, e_DiffIndexAssignment, e_DiffClassQualifier,
		e_DiffPropertyQualifier, e_DiffPropertyValue, e_DiffMethodNames,
		e_DiffMethodFlags, e_DiffMethodOrigin, e_DiffMethodInSignature,
		e_DiffMethodOutSignature, e_DiffMethodQualifier, e_DiffNumMethods,
		e_WbemFailed, e_OutOfMemory} EReconciliation;

//*****************************************************************************
//*****************************************************************************
//
//  TMovable
//
//  This name appears several times in the templates below. Classes that can be
//  used in these templates must represent a block of memory (and most 
//  everything inside a CWbemObject is a blcok of memory). They must implement 
//  all the methods described below. This could be made into a base class with
//  all these functions being pure virtual members, but that would increase 
//  function call overhead and this is critical code; thus the templates are
//  used instead.
//
//*****************************************************************************
//
//  GetStart
//
//  Returns:
//
//      LPMEMORY: the address of the beginning of the memory block
//
//*****************************************************************************
//
//  GetLength
//
//  Returns:
//
//      length_t: the length of the memory block
//
//*****************************************************************************
//
//  Rebase
//
//  This function is called when the memory block of the object in question is
//  moved to a different location. Since some objects cache pointers into their
//  memory blocks, this function is necessary and must update whatever cache 
//  the object has to the new location.
//
//  Parameters:
//
//      [in] LPMEMORY pNewMemory:   points to the starting address of the new
//                                  memory location for the object. The length
//                                  is not needed as the object knows it.
//  
//*****************************************************************************


//*****************************************************************************
//
//  EndOf
//
//  This function template returns the pointer to the first byte following the
//  memory block of a given object (represented by a TMovable, see above).
//
//  Parameters:
//
//      [in, readonly] TMovable& Block  the object whose block is considered.
//                                      The class must be a valid TMovable
//                                      (see above)
//  Returns:
//
//      LPMEMORY:   the pointer to the first byte after the object.
//
//*****************************************************************************
template<class TMovable>
 LPMEMORY EndOf(READ_ONLY TMovable& Block)
{
    return Block.GetStart() + Block.GetLength();
}

//*****************************************************************************
//
//  MoveBlock
//
//  This function template moves an object representing a memory block to a new
//  location. The function uses memmove to copy object's memory block and then
//  advises the object of its new location. 
//
//  Parameters:
//
//      [in] TMovable& Block    The object whose memory block is being moved. 
//                              The class must be a valid TMovable (see above)
//                              It will be advised of its new location.
//                             
//      [in] LPMEMORY pMemory   Points to the beginning of the new memory blcok
//                              It is assumed to be large enough for the object
//
//*****************************************************************************

template<class TMovable>
 void MoveBlock(TMovable& Block, LPMEMORY pNewMemory)
{
    if(pNewMemory != Block.GetStart())
    {
        memmove((void*)pNewMemory, (void*)Block.GetStart(), Block.GetLength());
        Block.Rebase(pNewMemory);
    }
}

//*****************************************************************************
//
//  CopyBlock
//
//  This function is exactly the same as MoveBlock (above), except that it
//  assumes that the new memory is guaranteed not to forward-overlap with the
//  old one, and so uses the more efficient memcpy function to copy the data.
//
//  Parameters:
//
//      [in] TMovable& Block    The object whose memory block is being moved. 
//                              The class must be a valid TMovable (see above)
//                              It will be advised of its new location.
//                             
//      [in] LPMEMORY pMemory   Points to the beginning of the new memory blcok
//                              It is assumed to be large enough for the object
//
//*****************************************************************************
template<class TMovable>
 void CopyBlock(TMovable& Block, LPMEMORY pNewMemory, length_t DestinationSpace )
{    
    if(pNewMemory != Block.GetStart())
    {
        //DbgPrintfA(0,"Start %p Length %x Avail %p\n",Block.GetStart(), Block.GetLength(),DestinationSpace);
        if (DestinationSpace < Block.GetLength()) throw CX_Exception();
            
        memcpy((void*)pNewMemory, (void*)Block.GetStart(), Block.GetLength());
        Block.Rebase(pNewMemory);
    }
}

//*****************************************************************************
//*****************************************************************************
//
//  class CBitBlockTable
//
//  This class template represents a table of an arbitrary number of bit 
//  strings of fixed length. The length of each bit string is t_nNumValues, the
//  template parameter. The number of strings may change, but this class never
//  re-allocates memory, leaving that job to its owner. 
//
//  Like many CWbemObject-related classes, it is a pseudo-class: its 'this'
//  pointer points to the beginning of the data. Thus, *(BYTE*)this, would get
//  us the first eight bits of the table. Instances of this class are never 
//  constructed. Instead, a pointer to CBitBlockTable is created and set to 
//  point to the actual table (found as part of some other memory block).
//
//*************************** public interface ********************************
//
//  static GenNecessaryBytes
//
//  Computes the number of integral bytes necessary to hold a given bit table.
//  Only the number of blocks (strings) is given as a parameter. Recall that
//  the length of each string is a template parameter.
//
//  Parameters:
//
//      int nBitBlocks      the numbed of blocks in the proposed table
//
//  Returns:
//
//      int:    the number of bytes necessary to contain the table.
//
//*****************************************************************************
//
//  GetBit
//
//  Retrieves a given bit from a given string. No bounds checking is performed.
//
//  Parameters:
//
//      int nBitBlock       The index of the string (block) in the table
//      int nValueIndex     The index of the bit in the string.
//
//  Returns:
//
//      BOOL    the value of the bit (1/0).
//
//*****************************************************************************
//
//  SetBit
//
//  Sets a given bit in a given block to a given value. No bounds checking is
//  performed.
//
//  Parameters:
//
//      int nBitBlock       The index of the string (block) in the table
//      int nValueIndex     The index of the bit in the block.
//      BOOL bValue         The value to set.
//
//*****************************************************************************
//
//  RemoveBitBlock
//
//  Removes one of the bit blocks from the table by copying the tail of the 
//  table (after the aforementioned block) forward. No bounds checking is
//  performed and no memory is freed.
//
//  Parameters:
//
//      int nBitBlock       The index of the block to remove.
//      int nTableByteLen   The number of bytes in the table (bytes,not blocks)
//
//*****************************************************************************
template<int t_nNumValues>
class CBitBlockTable
{
protected:
//    static DWORD m_pMasks[32];

     static BOOL GetBitFromDWORD(DWORD dw, int nBit)
    {
        return (dw >> nBit) & 1;
        // return (dw & m_pMasks[nBit]);
    }

     static void SetBitInDWORD( UNALIGNED DWORD& dw, int nBit)
    {
        dw |= ((DWORD)1 << nBit);
        //dw |= m_pMasks[nBit];
    }

     static void ResetBitInDWORD( UNALIGNED DWORD& dw, int nBit)
    {
        dw &= ~((DWORD)1 << nBit);
        //dw &= ~m_pMasks[nBit];
    }

     static void SetBitInDWORD( UNALIGNED DWORD& dw, int nBit, BOOL bValue)
    {
        bValue?SetBitInDWORD(dw, nBit):ResetBitInDWORD(dw, nBit);
    }

    static BOOL GetBit(LPMEMORY pMemory, int nBit)
    {
        return GetBitFromDWORD(
                ((UNALIGNED DWORD*)pMemory)[nBit/32],
                nBit % 32);
    }
    
    static void SetBit(LPMEMORY pMemory, int nBit, BOOL bValue)
    {
        SetBitInDWORD(((UNALIGNED DWORD*)pMemory)[nBit/32], nBit%32, bValue);
    }

public:
    static int GetNecessaryBytes(int nBitBlocks)
    {
        int nTotalBits = nBitBlocks * t_nNumValues;
        return (nTotalBits%8) ? nTotalBits/8 + 1 : nTotalBits/8;
    }
public:

    BOOL GetBit(int nBitBlock, int nValueIndex)
    {
        return GetBit(LPMEMORY(this), nBitBlock*t_nNumValues + nValueIndex);
    }

    void SetBit(int nBitBlock, int nValueIndex, BOOL bValue)
    {
        SetBit(LPMEMORY(this), nBitBlock*t_nNumValues + nValueIndex, bValue);
    }

    void RemoveBitBlock(int nBitBlock, int nTableByteLen)
    {
        for(int i = nBitBlock*t_nNumValues; i < nTableByteLen*8 - t_nNumValues; i++)
        {
            SetBit(LPMEMORY(this), i, GetBit(LPMEMORY(this), i+t_nNumValues));
        }
    }

};

//*****************************************************************************
//*****************************************************************************
//
//  class CPtrSource
//
//  This class has a very sad reason for existence. Imagine that, inside a 
//  certain function, you store a pointer to an internal memory location inside
//  an object's block. Then you call some member function of that object, 
//  causing the object's block to request more space. Doing so may completely
//  reallocate the object, invalidating your pointer. 
//
//  The solution is CPtrSource, a kind of pointer moniker --- it has the
//  knowledge to find your pointer even if the memory block moves. 
//
//*****************************************************************************
//
//  GetPointer() = 0
//
//  Must be implemented by derived classes to return the actual value of the
//  pointer at the moment.
//
//  Returns:
//
//      LPMEMORY:       the pointer
//
//*****************************************************************************
//
//  AccessPtrData
//
//  A helper function, for those occasions when the pointer points to a heap
//  offset. Returns a reference to that offset (heapptr_t&).
//
//  Returns:
//
//      heapptr_t& pointed to by this pointer.
//
//*****************************************************************************

class CPtrSource
{
public:
    virtual LPMEMORY GetPointer() = 0;
    UNALIGNED heapptr_t& AccessPtrData() {return *(UNALIGNED heapptr_t*)GetPointer();}
};

//*****************************************************************************
//
//  class CStaticPtr : public CPtrSource
//
//  A flavor of CPtrSource (above) for those occasions when your pointer is
//  guaranteed not to move, but a function expects a CPtrSource. Contains the
//  actual value of the pointer and always returns it.
//
//*****************************************************************************
//
//  Constructor.
//
//  Parameters:
//
//      LPMEMORY p      The pointer to store and return. Assumed to last at
//                      least as long as the object itself.
//
//*****************************************************************************

class CStaticPtr : public CPtrSource
{
protected:
    LPMEMORY m_p;
public:
    CStaticPtr(LPMEMORY p) : m_p(p) {}
    LPMEMORY GetPointer() {return m_p;}
};

//*****************************************************************************
//
//  class CShiftedPtr : public CPtrSource
//
//  A flavor of CPtrSource for those occasions when you receive a CPtrSource
//  from somebody and need to give somebody a pointer which has the same logic
//  as the one given to you, but plus some constant. 
//
//  When asked for the current pointer value, this class will evaluate its base
//  and add the offset.
//
//*****************************************************************************
//
//  Constructor
//
//  Parameters:
//
//      CPtrSource* pBase       The base. Assumed to last at least as long as
//                              this object.
//      int nOffset             The offset.
//
//*****************************************************************************

class CShiftedPtr : public CPtrSource
{
protected:
    CPtrSource* m_pBase;
    int m_nOffset;
public:
    CShiftedPtr(CPtrSource* pBase, int nOffset) 
        : m_pBase(pBase), m_nOffset(nOffset) {}
    LPMEMORY GetPointer() {return m_pBase->GetPointer() + m_nOffset;}
    void operator+=(int nShift) {m_nOffset += nShift;}
};

 void InsertSpace(LPMEMORY pMemory, int nLength, 
                        LPMEMORY pInsertionPoint, int nBytesToInsert);

#pragma pack(pop)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\marshalers\coreprox\fastsys.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    FASTSYS.H

Abstract:

  This file defines the classes related to system properties.

  Classes defined: 
      CSystemProperties   System property information class.

History:

  2/21/97     a-levn  Fully documented
  12//17/98	sanjes -	Partially Reviewed for Out of Memory.

--*/

#ifndef __FAST_SYSPROP__H_
#define __FAST_SYSPROP__H_

#include "parmdefs.h"
#include <wbemidl.h>
#include "wbemstr.h"

// This is the maximum number of user-defined properties
#define MAXNUM_USERDEFINED_PROPERTIES	1024

//*****************************************************************************
//*****************************************************************************
//
//  class CSystemProperties
//
//  This class contains the information about the names and types of all 
//  system properties. All its data members and methods are static.
//
//*****************************************************************************
//
//  static GetNumSystemProperties
//
//  Returns:
//
//      int: the number of systsm properties currently defined
//
//*****************************************************************************
//
//  static GetNumDecorationIndependentProperties
//
//  Returns:
//
//      int: the number of system properties that do not depend on the object's
//          decoration. For instance, __SERVER is NOT such a property.
//
//*****************************************************************************
//
//  static GetNameAsBSTR
//
//  Retrives a system property name as a newely allocated BSTR.
//
//  Parameters:
//
//      int nIndex      The index of the system property, taken from the 
//                      e_SysProp... list.
//  Returns:
//
//      BSTR: containing the property name. This BSTR MUST be freed 
//              (SysFreeString) by the caller.
//
//*****************************************************************************
//
//  static GetPropertyType
//
//  Returns complete type information for a system property.
//
//  Parameters:
//
//      [in] LPCWSTR wszName        The name of the system property.
//      [out] long* plType          Destination for the type of the property,
//                                  e.g. VT_BSTR. May be NULL if not required.
//      [out] long* plFlavor        Destination for the flavor of the property.
//                                  At this time, all system properties are of
//                                  the WBEM_FLAVOR_ORIGIN_SYSTEM flavor.
//                                  May be NULL if not required.
//  Returns:
//
//      HRESULT:    
//          WBEM_S_NO_ERROR        on success
//          WBEM_E_NOT_FOUND       no such system property.
//                  
//*****************************************************************************
//
//  static FindName
//
//  Returns the index of a system property based on its name
//  
//  Parameters:
//
//      [in] LPCWSTR wszName        The name of the system property.
//      
//  Returns:
//
//      HRESULT:    
//          WBEM_S_NO_ERROR        on success
//          WBEM_E_NOT_FOUND       no such system property.
//                  
//*****************************************************************************

class COREPROX_POLARITY CSystemProperties
{

public:
    enum 
    {
        e_SysProp_Genus = 1,
        e_SysProp_Class,
        e_SysProp_Superclass,
        e_SysProp_Dynasty,
        e_SysProp_Relpath,
        e_SysProp_PropertyCount,
        e_SysProp_Derivation,

        e_SysProp_Server,
        e_SysProp_Namespace,
        e_SysProp_Path

    };

    static int GetNumSystemProperties();
    static int MaxNumProperties();
    static inline int GetNumDecorationIndependentProperties() 
    {
        return 7;
    }

    static SYSFREE_ME BSTR GetNameAsBSTR(int nIndex);

    static int FindName(READ_ONLY LPCWSTR wszName);
    static HRESULT GetPropertyType(READ_ONLY LPCWSTR wszName, 
        OUT CIMTYPE* pctType, OUT long* plFlags)
    {
        int nIndex = FindName(wszName);
        if(nIndex >= 0)
        {
            if(plFlags) 
            {
                *plFlags = WBEM_FLAVOR_ORIGIN_SYSTEM;
            }
            if(pctType)
            {
                if(nIndex == e_SysProp_Genus || 
                    nIndex == e_SysProp_PropertyCount)
                {
                    *pctType = CIM_SINT32;
                }
                else if(nIndex == e_SysProp_Derivation)
                {
                    *pctType = CIM_STRING | CIM_FLAG_ARRAY;
                }
                else
                {
                    *pctType = CIM_STRING;
                }
            }
            return WBEM_S_NO_ERROR;
        }
        else return WBEM_E_NOT_FOUND;
    }

	static BOOL IsPossibleSystemPropertyName(READ_ONLY LPCWSTR wszName);
    static BOOL IsIllegalDerivedClass(READ_ONLY LPCWSTR wszName);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\marshalers\coreprox\faststr.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    FASTSTR.H

Abstract:

  This file defines the classes related to string processing in WbemObjects.

  Classes defined: 
      CCompressedString   Represents an ascii or unicode string.
      CKnownStringTable   The table of strings hard-coded into WINMGMT for
                          compression.
      CFixedBSTRArray     An array of BSTRs capable of sophisticated merges.

History:

  2/20/97     a-levn  Fully documented
  12//17/98	sanjes -	Partially Reviewed for Out of Memory.

--*/

#ifndef __FAST_STRINGS__H_
#define __FAST_STRINGS__H_

#include "corepol.h"
#include "fastsprt.h"
#include <stdio.h>
#include "arena.h"
#include "var.h"
#include "wstring.h"

// see fastsprt.h for explanation
#pragma pack(push, 1)

typedef enum 
{
    /*
        These flags preceed every string on the "heap". Uniqueness is not used
        at this time --- all string are unique
    */
    STRING_FLAG_ASCII = 0,
    STRING_FLAG_UNICODE = 0x1,
} FStringFlags;

#define ASCII_STRING_PREFIX "\000"

class CFastHeap;

//*****************************************************************************
//*****************************************************************************
//
//  class CCompressedString
//
//  The purpose of this class is to compress UNICODE strings which are actually
//  ASCII (and therefore consist of 1/2 zeros). This is done by representing
//  every string by a flag byte followed by either a UNICODE string (if the 
//  flag byte is STRING_FLAG_UNICODE) or an ASCII string (if the flag byte is
//  STRING_FLAG_ASCII).
//
//  As with many other CWbemObject-related classes, its this pointer points to
//  the actual data. Thus the actual characters start immediately after 
//  m_fFlags.
//
//  Here's how one might create such an object:
//
//      WCHAR wszText[] = L"My String";
//      LPMEMORY pBuffer = new BYTE[
//            CCompressedString::ComputeNecessarySpace(wszText)];
//      CCompressedString* pString = (CCompressedString*)pBuffer;
//      pString->SetFromUnicode(wszText);
//
//************************ TMovable interface *********************************
//
//  GetStart
//
//  RETURNS:
//
//      LPMEMORY pointing to the beginning of the memory block (the flags).
//
//*****************************************************************************
//
//  GetLength
//
//  RETURNS:
//
//      int containing the number of bytes in the representation (not the 
//          string length).
//
//************************* Public interface **********************************
//
//  GetStringLength
//
//  RETURNS:
//
//      int the number of characters in the string (whether UNICODE or ASCII).
//
//*****************************************************************************
//
//  CreateBSTRCopy
//
//  RETURNS:
//
//      BSTR containing the string. This BSTR is newely allocated using 
//          SysAllocString and must be SysFreeString'ed by the caller.
//
//*****************************************************************************
//
//  CreateWStringCopy
//
//  RETURNS:
//
//      WString (see wstring.h) containg the string. The object itself is
//          returned, so no freeing is required.
//
//*****************************************************************************
//
//  Compare
//
//  Compares this string to another. It has three calling methods:
//
//  Parameters I:
//
//      [in, readonly] const CCompressedString& Other
//
//  Parameters II:
//
//      [in, readonly] LPSTR szOther
//
//  Parameters III:
//
//      [in, readonly] LPWSTR wszOther
//
//  RETURNS:
//
//      0  of the strings are the same.
//      <0 if this lexicographically preceeds the other
//      >0 if this lexicographically follows the other
//
//*****************************************************************************
//
//  CompareNoCase
//
//  Exactly the same as Compare (above), except that comparison is performed
//  case-insensitively.
//
//*****************************************************************************
//
//  StartsWithNoCase
//
//  Verifies if the given string is a prefix of ours (in a case-inseinsitive
//  way).
//
//  PARAMETERS:
//
//      [in, readonly]
//          LPCWSTR wszOther    the string whose prefixness ww want to check.
//
//  RETURNS:
//
//      BOOL        TRUE iff it is a prefix
//
//*****************************************************************************
//
//  static ComputeNecessarySpace
//
//  Computes the amount of space that will be required to store a given string.
//  This amount depends on whether the string can be compressed into ASCII.
//
//  See SetFromAscii and SetFromUnicode on what to do next.
//
//  Parameters I:
//
//      [in, readonly] LPCWSTR wszString
//
//  Parameters II:
//
//      [in, readonly] LPCSTR szString
//
//  RETURNS:
//
//      int:    the nuumber of bytes required.
//
//*****************************************************************************
//
//  SetFromUnicode
//
//  Stores a UNICODE string into itself. It is assumed that the buffer 'this'
//  is pointing to is large enough to hold the string.
//
//  PARAMETERS:
//
//      [in, readonly] LPCWSTR wszString
//
//*****************************************************************************
//
//  SetFromAscii
//
//  Stores a ASCII string into itself. It is assumed that the buffer 'this'
//  is pointing to is large enough to hold the string.
//
//  PARAMETERS:
//
//      [in, readonly] LPCSTR szString
//
//*****************************************************************************
//
//  MakeLowercase
//
//  Performs an in-place conversion to lower case.
//
//*****************************************************************************
//
//  StoreToCVar
//
//  Transfers its contents into a CVar (var.h). The CVar will have the type of
//  VT_BSTR and will contain a fresh BSTR copy of the string. More efficient
//  mechanism is possible, but requires a change in CVar logic which is not
//  feasible at this time.
//
//  PARAMETERS:
//
//      [in, created] CVar& Var     Destination. Assumed to be empty.
//
//*****************************************************************************
//
//  static CopyToNewHeap
//
//  Given a heap offset a CCompressedString on one heap, makes a copy of the 
//  string on another heap and returns the new offset.
//
//  PARAMETERS:
//
//      [in] heapptr_t ptrOldString     The offset of the string on the old
//                                      heap.
//      [in, readonly] 
//          CFastHeap* pOldHeap         The heap to read from.
//      [in, modified]
//          CFastHeap* pNewHeap         The heap to write to.
//
//  RETURNS:
//
//      heapptr_t   the offset on the pNewHeap where the copy of the string is.
//
//*****************************************************************************
//
//  static CreateEmpty
//
//  Creates an empty string on a given block of memory.
//
//  PARAMETERS:
//
//     LPMEMORY pWhere          Destination block.
// 
//  RETURN VALUES:
//
//      LPMEMORY:   points to the first character after the data written.
//
//*****************************************************************************
//
//  static fast_wcslen
//
//  Performs a wcslen operation but it shouldn't throw an exception
//	or cause an AV on systems that are expecting aligned buffers.
//
//  PARAMETERS:
//
//     WCHAR*	pwszString - String to get length of
// 
//  RETURN VALUES:
//
//     Length of the string without a terminating NULL.
//
//*****************************************************************************
//
//  static fast_wcscpy
//
//  Copies WCHAR string from source buffer to destination buffer.  We have to
//	do this in a way which will not cause faults or exceptions for non-aligned
//	buffers
//
//  PARAMETERS:
//
//		WCHAR*	pwszDestination - Destination buffer.
//		LPCWSTR	pwszSource - Source buffer,
// 
//  RETURN VALUES:
//
//     Pointer to the destination buffer.
//
//*****************************************************************************
//
//  static CreateEmpty
//
//  Creates an empty string on a given block of memory.
//
//  PARAMETERS:
//
//     LPMEMORY pWhere          Destination block.
// 
//  RETURN VALUES:
//
//      LPMEMORY:   points to the first character after the data written.
//
//*****************************************************************************

class COREPROX_POLARITY CCompressedString
{
private:
    BYTE m_fFlags;
    // followed by either a unicode or an ASCII string
    BYTE m_cFirstByte; // just a place holder
public:
    INTERNAL LPMEMORY GetStart() {return LPMEMORY(this);}
    int GetLength() const;
	int ValidateSize(int ccbMax) const;
	bool NValidateSize(int cbMax) const;	
protected:
public:
    int GetStringLength() const;

    SYSFREE_ME BSTR CreateBSTRCopy() const;
    NEW_OBJECT WString CreateWStringCopy() const;

    int Compare(READ_ONLY const CCompressedString& csOther) const;
    int Compare(READ_ONLY LPCWSTR wszOther) const;
    int Compare(READ_ONLY LPCSTR szOther) const;

    int CompareNoCase(READ_ONLY const CCompressedString& csOther) const;
    int CompareNoCase(READ_ONLY LPCWSTR wszOther) const;
    int CompareNoCase(READ_ONLY LPCSTR szOther) const;

    int CheapCompare(READ_ONLY const CCompressedString& csOther) const;

    BOOL StartsWithNoCase(READ_ONLY LPCWSTR wszOther) const;
public:
    static int ComputeNecessarySpace(READ_ONLY LPCWSTR wszString);
    static int ComputeNecessarySpace(READ_ONLY LPCWSTR wszString,BOOL & IsAsciable);    
    static int ComputeNecessarySpace(READ_ONLY LPCSTR szString);

    void SetFromUnicode(COPY LPCWSTR wszString);
    void SetFromUnicode(BOOL IsAsciable,COPY LPCWSTR wszString);
    void SetFromAscii(COPY LPCSTR szString, size_t mySize);
    void MakeLowercase();

    BOOL IsUnicode() const {return (m_fFlags == STRING_FLAG_UNICODE);}
    INTERNAL LPMEMORY GetRawData() const 
        {return (LPMEMORY)&m_cFirstByte;}
public:
    BOOL StoreToCVar(NEW_OBJECT CVar& Var) const;

	// Trap whether or not anyone calls this
    BOOL TranslateToNewHeap(CFastHeap* pOldHeap, CFastHeap* pNewHeap){ return FALSE; }

    static BOOL CopyToNewHeap(heapptr_t ptrOldString,
        READ_ONLY CFastHeap* pOldHeap, MODIFIED CFastHeap* pNewHeap,
		UNALIGNED heapptr_t& ptrResult);
    static LPMEMORY CreateEmpty(LPMEMORY pWhere);

    void ConvertToUnicode(LPWSTR wszDest) const;

	static int fast_wcslen( LPCWSTR wszString );
	static WCHAR* fast_wcscpy( WCHAR* wszDest, LPCWSTR wszSource );
	static WCHAR* fast_wcsncpy( WCHAR* wszDest, LPCWSTR wszSource, int nNumChars );

protected:
    static char LowerByte(WCHAR w) {return w & 0xFF;}
    static char UpperByte(WCHAR w) {return w >> 8;}
    static BOOL IsAsciiable(READ_ONLY LPCWSTR wszString);

    static int CompareUnicodeToAscii( UNALIGNED const wchar_t* wszFirst, 
                                            READ_ONLY LPCSTR szSecond);

    static int CompareUnicodeToAsciiNoCase( UNALIGNED const wchar_t* wszFirst, 
                                                  READ_ONLY LPCSTR szSecond,
                                                    int nMax = 0x7000000);

    friend class CKnownStringTable;
    friend class CFixedBSTRArray;
};




//*****************************************************************************
//*****************************************************************************
//
//  class CKnownStringTable
//
//  This class represents a table of strings hard-coded into WINMGMT. Certain 
//  strings that appear very often are represented in objects simply as indeces
//  into this table, thus saving valuable space.
//
//  All the data and memeber functions in this class are static.
//
//*****************************************************************************
//
//  static Initialize
//
//  While the strings are specified as an array of LPSTR in the source code,
//  they are actually stored as CCompressedString's so as to be able to return 
//  their CCompressedString representations very fast. Initialize performs the
//  conversion (USING INSIDER KNOWLEDGE OF CCompressedString CLASS!)
//
//*****************************************************************************
//
//  static GetKnownStringIndex
//
//  Searches for a (UNICODE) string and returns its index in the table if found.
//  
//  PARAMETERS:
//
//      [in, readonly] LPCWSTR wszString    The string to look for.
//  
//  RETURNS:
//
//      int     If found, it is the index of the string (1 or larger).
//              If not found, it is STRING_INDEX_UNKNOWN (< 0)
//
//*****************************************************************************
//
//  GetIndexOfKey
//
//  Returns the index of "key" in the table.
//
//*****************************************************************************
//
//  GetKnownString
//
//  Returns the string at a given index.
//
//  PARAMETERS:
//
//      [in] int nIndex     The index of the string to retrieve (1 or larger)
//
//  RETURNS:
//
//      CCompressedString*  The pointer to the string. This pointer is internal
//                          and must NOT be deleted or modified by the called.
//
//*****************************************************************************


#define STRING_INDEX_UNKNOWN -1


class COREPROX_POLARITY CKnownStringTable
{

public:
    static void Initialize();
    static int GetKnownStringIndex(READ_ONLY LPCWSTR wszString);

    static int GetIndexOfKey() 
        {return /**!!!!!**/ 1;}
    static INTERNAL CCompressedString& GetKnownString(IN int nIndex);
};

//*****************************************************************************
//*****************************************************************************
//
//  class CReservedWordTable
//
//  This class represents a table of strings hard-coded into WINMGMT. These
//	strings are reserved words which for various reasons we need to verify
//	before allowing users to set.
//
//  All the data and memeber functions in this class are static.
//
//*****************************************************************************
//
//  static Initialize
//
//  Sets up member data
//
//*****************************************************************************
//
//  static IsReservedWord
//
//  Searches for a (UNICODE) string in our list and returns whether or not
//	we found it.
//  
//  RETURNS:
//
//      bool	If found TRUE.
//
//*****************************************************************************


#define STRING_INDEX_UNKNOWN -1


class COREPROX_POLARITY CReservedWordTable
{
private:
	static LPCWSTR	s_apwszReservedWords[];
	static LPCWSTR	s_pszStartingCharsUCase;
	static LPCWSTR	s_pszStartingCharsLCase;

public:
    static BOOL IsReservedWord(READ_ONLY LPCWSTR wszString);

};

//*****************************************************************************
//*****************************************************************************
//
//  class CFixedBSTRArray
//
//  This class represents a fixed-sized array of BSTRs. Its purpose in life
//  is to implement a sophisticated merge function on itself.
//
//*****************************************************************************
//
//  Create
//
//  Creates an array of a given size. The size cannot be changed during the 
//  array's lifetime. 
//
//  PARAMETERS:
//
//      int nSize
//
//*****************************************************************************
//
//  Free
//
//  Destroys the array, deallocating all the BSTRs.
//
//*****************************************************************************
//
//  GetLength
//
//  RETURNS:
//
//      int:    the number of elements in the array
//
//*****************************************************************************
//
//  GetAt
//
//  Retrieves the BSTR at ta given index.
//
//  PARAMETERS:
//
//      int nIndex
//
//  RETURNS:
//
//      BSTR at the desired index. This is NOT a copy, so the caller must NOT
//          deallocate it.
//
//*****************************************************************************
//
//  SortInPlace
//
//  Sorts the array lexicographically in a case-insensitive manner. Bubble-sort
//  is used at this time.
//
//*****************************************************************************
//
//  Filter
//
//  Filters the supplied string from the local BSTR array.  Frees located
//	elements as necessary.
//
//  PARAMETERS:
//
//      wchar_t*	pwcsStr - String to filter out
//		BOOL		fFree - Free string if found (FALSE)
//
//*****************************************************************************
//
//  ThreeWayMergeOrdered
//
//  The reason for this class's existence. Takes three already ordered arrays
//  of BSTRs (acsInculde1, acsInclude2 and acsExclude) and produces (inside
//  itself) an array of all BSTRs A such that:
//
//      ((A appears in ascInclude1) OR (A appears in ascInclude2)) 
//      AND
//      NOT (A appears in acsExclude)
//
//  and does it reasonable fast.
//
//  PARAMETERS:
//
//      CFixedBSTRArray& acsInclude1    Include these strings unless found in
//                                      acsExclude.
//      CFixedBSTRArray& acsInclude2    Include these strings unless found in
//                                      acsExclude.
//      CFixedBSTRArray& acsExclude     Exclude these strings.
//
//*****************************************************************************

class COREPROX_POLARITY CFixedBSTRArray
{
protected:
    int m_nSize;
    BSTR* m_astrStrings;
public:
    CFixedBSTRArray() : m_nSize(0), m_astrStrings(NULL){}
    ~CFixedBSTRArray() {delete [] m_astrStrings;}

    void Free();
    void Create(int nSize);

    int GetLength() {return m_nSize;}
    BSTR& GetAt(int nIndex) {return m_astrStrings[nIndex];}
    BSTR& operator[](int nIndex) {return GetAt(nIndex);}

    void SetLength(int nLength) {m_nSize = nLength;}

public:
    void SortInPlace();
    /*
    void MergeOrdered(CFixedBSTRArray& a1, 
                      CFixedBSTRArray& a2);
    */
    void ThreeWayMergeOrdered(CFixedBSTRArray& acsInclude1, 
                      CFixedBSTRArray& acsInclude2,
                      CFixedBSTRArray& acsExclude);

	void Filter( LPCWSTR pwcsStr, BOOL fFree = FALSE );

};

//*****************************************************************************
//*****************************************************************************
//
//  class CCompressedStringList
//
//*****************************************************************************

class COREPROX_POLARITY CCompressedStringList
{
protected:
    PLENGTHT m_pnLength;
    int m_nNumStrings;

    static length_t GetSeparatorLength() {return sizeof(idlength_t);}
public:
    void SetData(LPMEMORY pData)
    {
        m_pnLength = (PLENGTHT)pData;
        m_nNumStrings = -1;
    }

    static size_t ValidateBuffer(LPMEMORY pData, size_t cbSize);

    bool ValidateLength(int cbMaxSize);

    void Rebase(LPMEMORY pData)
    {
        m_pnLength = (PLENGTHT)pData;
    }
    LPMEMORY GetStart() {return (LPMEMORY)m_pnLength;}
    length_t GetLength() {return *m_pnLength;}
    static length_t GetHeaderLength() {return sizeof(length_t);}

public:
    BOOL IsEmpty()
    {
        return (GetLength() == GetHeaderLength());
    }

    void Reset()
    {
        *m_pnLength = GetHeaderLength();
        m_nNumStrings = 0;
    }

    CCompressedString* GetFirst()
    {
        if(IsEmpty())
            return NULL;
        else
            return (CCompressedString*)(GetStart() + GetHeaderLength());
    }

    CCompressedString* GetNext(CCompressedString* pThis)
    {
        LPMEMORY pNext = EndOf(*pThis) + GetSeparatorLength();
        if(pNext - GetStart() >= (int)GetLength()) 
            return NULL;
        else
            return (CCompressedString*)pNext;
    }

    
    CCompressedString* GetPrevious(CCompressedString* pThis)
    {
        if((LPMEMORY)pThis == GetStart() + GetHeaderLength()) return NULL;
        PIDLENGTHT pnPrevLen =  
            (PIDLENGTHT)(pThis->GetStart() - GetSeparatorLength());
        return (CCompressedString*)((LPMEMORY)pnPrevLen - *pnPrevLen);
    }
        
    CCompressedString* GetLast()
    {
        return GetPrevious((CCompressedString*)EndOf(*this));
    }
        
    CCompressedString* GetAtFromLast(int nIndex)
    {
        int i = 0;
        CCompressedString* pCurrent = GetLast();
        while(i < nIndex && pCurrent)
        {
            pCurrent = GetPrevious(pCurrent);
            i++;
        }
        return pCurrent;
    }

    int GetNumStrings()
    {
        if(m_nNumStrings == -1)
        {
            CCompressedString* pCurrent = GetFirst();
            for(int i = 0; pCurrent != NULL; i++)
                pCurrent = GetNext(pCurrent);
            
            m_nNumStrings = i;
        }
        return m_nNumStrings;
    }

    int Find(LPCWSTR wszString)
    {
        CCompressedString* pCurrent = GetFirst();
        for(int i = 0; pCurrent != NULL; i++)
        {
            if(pCurrent->CompareNoCase(wszString) == 0)
                return i;
            pCurrent = GetNext(pCurrent);
        }
        return -1;
    }
            
    void AddString(LPCWSTR wszString)
    {
        LPMEMORY pEnd = EndOf(*this);
        CCompressedString* pcs = (CCompressedString*)pEnd;
        pcs->SetFromUnicode(wszString);
        *(PLENGTHT)EndOf(*pcs) = pcs->GetLength();
        
		// DEVNOTE:WIN64:SJS - 64-bit pointer values truncated into 
		// signed/unsigned longs.  We do not support length
		// > 0xFFFFFFFF so cast is ok.

        *m_pnLength = (length_t) ( EndOf(*pcs) + sizeof(length_t) - GetStart() );
        if(m_nNumStrings != -1)
            m_nNumStrings++;
    }
        

public:
    static LPMEMORY CreateEmpty(LPMEMORY pDest)
    {
        *(PLENGTHT)pDest = sizeof(length_t);
        return pDest + sizeof(length_t);
    }

    static length_t EstimateExtraSpace(CCompressedString* pcsExtra)
    {
        if(pcsExtra == NULL) 
            return 0;
        else
            return pcsExtra->GetLength() + GetSeparatorLength();
    }

    static length_t EstimateExtraSpace(LPCWSTR wszExtra)
    {
        return CCompressedString::ComputeNecessarySpace(wszExtra) + 
                    GetSeparatorLength();
    }

    length_t ComputeNecessarySpace(CCompressedString* pcsExtra)
    {
        return GetLength() + EstimateExtraSpace(pcsExtra);
    }

    LPMEMORY CopyData(LPMEMORY pDest)
    {
        int nDataLength = GetLength() - GetHeaderLength();
        memcpy(pDest, GetStart() + GetHeaderLength(), nDataLength);
        return pDest + nDataLength;
    }
        
        
    LPMEMORY CreateWithExtra(LPMEMORY pDest, CCompressedString* pcsExtra)
    {
        LPMEMORY pCurrent = pDest + GetHeaderLength();
        if(pcsExtra)
        {
            memcpy(pCurrent, (LPMEMORY)pcsExtra, pcsExtra->GetLength());
            pCurrent += pcsExtra->GetLength();
            *(PIDLENGTHT)pCurrent = pcsExtra->GetLength();
            pCurrent += sizeof(idlength_t);
        }

        pCurrent = CopyData(pCurrent);

		// DEVNOTE:WIN64:SJS - 64-bit pointer values truncated into 
		// signed/unsigned longs.  We do not support length
		// > 0xFFFFFFFF so cast is ok.

        *(PLENGTHT)pDest = (length_t) ( pCurrent - pDest );
        return pCurrent;
    }

};


#pragma pack(pop)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\marshalers\coreprox\fastsys.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    FASTSYS.CPP

Abstract:

  This file implements the classes related to system properties.
  See fastsys.h for all documentation.

  Classes implemented: 
      CSystemProperties   System property information class.

History:

  2/21/97     a-levn  Fully documented

--*/

#include "precomp.h"
//#include <dbgalloc.h>

#include "fastsys.h"
#include "strutils.h"
#include "olewrap.h"
#include "arena.h"

//******************************************************************************
//
//  See fastsys.h for documentation
//
//******************************************************************************
LPWSTR m_awszPropNames[] =
{
    /*0*/ L"", // nothing at index 0
    /*1*/ L"__GENUS",
    /*2*/ L"__CLASS",
    /*3*/ L"__SUPERCLASS",
    /*4*/ L"__DYNASTY",
    /*5*/ L"__RELPATH",
    /*6*/ L"__PROPERTY_COUNT",
    /*7*/ L"__DERIVATION",

    /*8*/ L"__SERVER",
    /*9*/ L"__NAMESPACE",
    /*10*/L"__PATH",
};



// System classes that are allowed to reproduce.

LPWSTR m_awszDerivableSystemClasses[] =
{
	L"__Namespace",
	L"__Win32Provider",
	L"__ExtendedStatus",
	L"__EventConsumer",
	L"__ExtrinsicEvent"
};


//******************************************************************************
//
//  See fastsys.h for documentation
//
//******************************************************************************
int CSystemProperties::GetNumSystemProperties() 
{
    return sizeof(m_awszPropNames) / sizeof(LPWSTR) - 1;
}

SYSFREE_ME BSTR CSystemProperties::GetNameAsBSTR(int nIndex)
{
        return COleAuto::_SysAllocString(m_awszPropNames[nIndex]);
}

int CSystemProperties::FindName(READ_ONLY LPCWSTR wszName)
{
        int nNumProps = GetNumSystemProperties();
        for(int i = 1; i <= nNumProps; i++)
        {
            if(!wbem_wcsicmp(wszName, m_awszPropNames[i])) return i;
        }

        return -1;
}

int CSystemProperties::MaxNumProperties() 
{
    return MAXNUM_USERDEFINED_PROPERTIES; 
}


BOOL CSystemProperties::IsPossibleSystemPropertyName(READ_ONLY LPCWSTR wszName)
{
	return ((*wszName == L'_')); 
}

BOOL CSystemProperties::IsIllegalDerivedClass(READ_ONLY LPCWSTR wszName)
{
    BOOL bRet = FALSE;
    BOOL bFound = FALSE;
    DWORD dwNumSysClasses = sizeof(m_awszDerivableSystemClasses) / sizeof(LPWSTR)-1;

    // If this isn't a system class, skip it.

    if (wszName[0] != L'_')
        bRet = FALSE;
    else
    {
        bRet = TRUE;
        for (int i = 0; i <= dwNumSysClasses; i++)
        {
            if (!wbem_wcsicmp(wszName, m_awszDerivableSystemClasses[i]))
            {
                bFound = TRUE;
                bRet = FALSE;
                break;
            }
        }
    }
    
    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\marshalers\coreprox\makefile.inc ===
!INCLUDE $(_NTDRIVE)$(_NTROOT)\WMI\COMMON\makefile.cmn
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\marshalers\coreprox\fastval.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    FASTVAL.CPP

Abstract:

  This file implements the classes related to value representation.
  Note: inline function implementations are cointained in fastval.inc.
  See fastval.h for all documentation.

  Classes implemented:
      CType               Representing property type
      CUntypedValue       A value with otherwise known type.
      CTypedValue         A value with stored type.
      CUntypedArray       Array of values of otherwise known type.

History:

  2/21/97     a-levn  Fully documented
  12//17/98 sanjes -    Partially Reviewed for Out of Memory.


--*/

#include "precomp.h"
#include "wbemutil.h"
#include <wbemidl.h>
#include "corex.h"
#include "faster.h"
#include "fastval.h"
#include "datetimeparser.h"
#include <genutils.h>
#include "arrtempl.h"
#include <fastall.h>
#include <wbemint.h>


//******************************************************************************
//
//  See fastval.h for documentation
//
//******************************************************************************
length_t m_staticLengths[128] =
{
    /* 0*/ 0, 0, 2, 4, 4, 8, 0, 0, 4, 0,
    /*10*/ 0, 2, 0, 4, 0, 0, 1, 1, 2, 4,
    /*20*/ 8, 8, 0, 0, 0, 0, 0, 0, 0, 0,
    /*30*/ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    /*40*/ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    /*50*/ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    /*60*/ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    /*70*/ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    /*80*/ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    /*90*/ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    /*100*/0, 4, 4, 2, 0, 0, 0, 0, 0, 0,
    /*110*/0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    /*120*/0, 0, 0, 0, 0, 0, 0, 0
};

length_t CType::GetLength(Type_t nType)
{
    if(GetBasic(nType) > 127) return 0;

    if(IsArray(nType)) return sizeof(heapptr_t);
    else return m_staticLengths[GetBasic(nType)];
}

BOOL CType::IsPointerType(Type_t nType)
{
    Type_t nBasic = GetBasic(nType);
    return (nBasic == CIM_STRING || nBasic == CIM_DATETIME ||
        nBasic == CIM_REFERENCE || nBasic == CIM_OBJECT ||
        IsArray(nType));
}

BOOL CType::IsNonArrayPointerType(Type_t nType)
{
    Type_t nBasic = GetBasic(nType);
    return ( !IsArray(nType) &&  
		( nBasic == CIM_STRING || nBasic == CIM_DATETIME ||
        nBasic == CIM_REFERENCE || nBasic == CIM_OBJECT ) );
}

BOOL CType::IsStringType(Type_t nType)
{
    Type_t nBasic = GetBasic(nType);
    return (nBasic == CIM_STRING || nBasic == CIM_DATETIME ||
        nBasic == CIM_REFERENCE );
}

BOOL CType::DoesCIMTYPEMatchVARTYPE(CIMTYPE ct, VARTYPE vt)
{
    // EXCEPTIONS: UINT32 matches STRING, LPWSTR matches string and datetime

    BOOL bCimArray = ((ct & CIM_FLAG_ARRAY) != 0);
    BOOL bVtArray = ((vt & VT_ARRAY) != 0);
	CIMTYPE ctBasic = CType::GetBasic(ct);

    if(bCimArray != bVtArray)
        return FALSE;

    if( ( ct & ~CIM_FLAG_ARRAY ) == CIM_UINT32 &&
        ( vt & ~VT_ARRAY ) == VT_BSTR)
    {
        return TRUE;
    }

    if ( CType::IsStringType( ct ) &&
        (vt & ~VT_ARRAY) == VT_LPWSTR)
    {
        return TRUE;
    }

	// We use strings for 64-bit values as well
    if ( ( ctBasic == CIM_SINT64 || ctBasic == CIM_UINT64 ) &&
        (vt & ~VT_ARRAY) == VT_LPWSTR)
    {
        return TRUE;
    }

    return (vt == GetVARTYPE(ct));
}

BOOL CType::IsMemCopyAble(VARTYPE vtFrom, CIMTYPE ctTo)
{
    if (vtFrom == VT_BSTR)
    {
        if (ctTo == CIM_UINT64 ||
            ctTo == CIM_SINT64 || 
            ctTo == CIM_DATETIME)
        {
            return FALSE;
        }
    }
    else if (vtFrom == VT_I2) 
    {
        if (ctTo == CIM_SINT8)
        {
            return FALSE;
        }
    }
    else if (vtFrom == VT_I4) 
    {
        if (ctTo == CIM_UINT16)
        {
            return FALSE;
        }
    }
    
    return TRUE;
}


 void CUntypedValue::Delete(CType Type, CFastHeap* pHeap)
{
    if(Type.GetActualType() == CIM_STRING ||
        Type.GetActualType() == CIM_REFERENCE ||
        Type.GetActualType() == CIM_DATETIME)
    {
        pHeap->FreeString(AccessPtrData());
        AccessPtrData() = INVALID_HEAP_ADDRESS;
    }
    else if(Type.GetActualType() == CIM_OBJECT)
    {
        CEmbeddedObject* pObj = (CEmbeddedObject*)
            pHeap->ResolveHeapPointer(AccessPtrData());
        int nLen = pObj->GetLength();
        pHeap->Free(AccessPtrData(), nLen);
    }
    else if(Type.IsArray())
    {
        CUntypedArray* pArray = (CUntypedArray*)
            pHeap->ResolveHeapPointer(AccessPtrData());
        int nArrayLen = pArray->GetLengthByType(Type.GetBasic());
        pArray->Delete(Type.GetBasic(), pHeap);
        pHeap->Free(AccessPtrData(), nArrayLen);
    }
}

//******************************************************************************
//
//  See fastval.h for documentation.
//
//******************************************************************************

//******************************************************************************
 // IF YOU SPECIFY fOptimize of TRUE ---
 //
 //	PLEASE ENSURE THAT YOU KNOW WHAT YOU ARE DOING!!!!   IT MAKES ASSUMPTIONS THAT YOU WILL
 //	PERFORM CLEANUP OPERATIONS THAT ARE NORMALLY DONE AUTOMAGICALLY!
//******************************************************************************

BOOL CUntypedValue::StoreToCVar(CType Type, CVar& Var, CFastHeap* pHeap, BOOL fOptimize /* = FALSE */)
{
    // DEVNOTE:EXCEPTION:RETVAL - This function has been reviewed and should cleanup properly
    // if an exception is thrown.  The underlying functions that perform allocations should
    // catch the exception and return a failure.

    int nActual = Type.GetActualType();
    if(Type.IsArray())
    {
        Type_t nBasicType = Type.GetBasic();

        // Find array on the heap
        // ======================

        CUntypedArray* pArray = (CUntypedArray*)pHeap->ResolveHeapPointer(
            AccessPtrData());

        // Have array store itself (making copies of all but strings)
        // into the vector
        // ==========================================================

        CVarVector* pVector = pArray->CreateCVarVector(nBasicType, pHeap);

        if ( NULL != pVector )
        {
            Var.SetVarVector(pVector, TRUE); // acquires the pointer
        }

        return ( NULL != pVector );
    }
    else if(nActual == CIM_STRING || nActual == CIM_REFERENCE ||
        nActual == CIM_DATETIME)
    {
        CCompressedString* pString = pHeap->ResolveString(AccessPtrData());

		if ( fOptimize )
		{
			BSTR	bstr = pString->CreateBSTRCopy();

			if ( NULL != bstr )
			{
				Var.SetRaw( VT_BSTR, (void*) &bstr, sizeof(BSTR) );
				Var.SetCanDelete( FALSE );
			}
			else
			{
				return FALSE;
			}

			return TRUE;
		}
		else
		{
			return pString->StoreToCVar(Var);
		}
    }
    else if(nActual == CIM_OBJECT)
    {
        // No allocations performed here so we should be ok
        CEmbeddedObject* pObj = (CEmbeddedObject*)pHeap->ResolveHeapPointer(
            AccessPtrData());
        pObj->StoreToCVar(Var);
        return TRUE;
    }
    else if(nActual == CIM_SINT64)
    {
        // Max size is 20 chars plus 1 for NULL terminator
        WCHAR wsz[22];

        // NULL terminate in case not enough characters
        StringCchPrintfW(wsz, 22, L"%I64d", *(UNALIGNED WBEM_INT64*)GetRawData());

		if ( fOptimize )
		{
			BSTR	bstr = SysAllocString( wsz );

			if ( NULL != bstr )
			{
				Var.SetRaw( VT_BSTR, (void*) &bstr, sizeof(BSTR) );
				Var.SetCanDelete( FALSE );
			}
			else
			{
				return FALSE;
			}

			return TRUE;
		}
		else
		{
			return Var.SetBSTR(wsz);
		}
    }
    else if(nActual == CIM_UINT64)
    {
        // Max size is 20 chars plus 1 for NULL terminator
        WCHAR wsz[22];

        // NULL terminate in case not enough characters
        StringCchPrintfW(wsz, 22, L"%I64u", *(UNALIGNED WBEM_INT64*)GetRawData());
		if ( fOptimize )
		{
			BSTR	bstr = SysAllocString( wsz );

			if ( NULL != bstr )
			{
				Var.SetRaw( VT_BSTR, (void*) &bstr, sizeof(BSTR) );
				Var.SetCanDelete( FALSE );
			}
			else
			{
				return FALSE;
			}

			return TRUE;
		}
		else
		{
			return Var.SetBSTR(wsz);
		}
    }
    else if(nActual == CIM_UINT16)
    {
        Var.SetLong(*(UNALIGNED unsigned short*)GetRawData());
        return TRUE;
    }
    else if(nActual == CIM_SINT8)
    {
        Var.SetShort(*(char*)GetRawData());
        return TRUE;
    }
    else if(nActual == CIM_UINT32)
    {
        Var.SetLong(*(UNALIGNED unsigned long*)GetRawData());
        return TRUE;
    }
    else if(nActual == CIM_CHAR16)
    {
        Var.SetShort(*(UNALIGNED short*)GetRawData());
        return TRUE;
    }
    else
    {
        // At first glance it doesn't appear memory is allocated here
        Var.SetRaw(Type.GetVARTYPE(), (void*)GetRawData(), Type.GetLength());
        return TRUE;
    }
}

//******************************************************************************
//
//  See fastval.h for documentation.
//
//******************************************************************************
HRESULT CUntypedValue::LoadFromCVar(CPtrSource* pThis, CVar& Var,
                                    CFastHeap* pHeap, Type_t& nReturnType, BOOL bUseOld)
{
    return LoadFromCVar(pThis, Var, Var.GetOleType(), pHeap, nReturnType, bUseOld);
}

BOOL CUntypedValue::DoesTypeNeedChecking(Type_t nInherentType)
{
    switch(nInherentType)
    {
    case CIM_UINT8:
    case CIM_SINT16:
    case CIM_SINT32:
    case CIM_REAL32:
    case CIM_REAL64:
    case CIM_STRING:
    case CIM_REFERENCE:
    case CIM_OBJECT:
        return FALSE;
    default:
        return TRUE;
    }
}

BOOL CUntypedValue::CheckCVar(CVar& Var, Type_t nInherentType)
{
    // Check the type
    // ==============

    if(Var.IsNull())
        return TRUE;

    if(nInherentType == 0)
        nInherentType = CType::VARTYPEToType( (VARTYPE) Var.GetOleType());
    if(!CType::DoesCIMTYPEMatchVARTYPE(nInherentType, (VARTYPE) Var.GetOleType()))
    {
        // Attempt coercion
        // ================

        // Special case: if the type is CIM_CHAR16, we coerce strings
        // differently!
        // ==========================================================

        // Special case: if the type is CIM_UINT32, we coerce strings
        // as a VT_UI4 or we lose half the possible values (our
        // VARType is actually VT_I4
        // ==========================================================

        // This could throw an exception
        try
        {
            if(CType::GetBasic(nInherentType) == CIM_CHAR16)
            {
                if(!Var.ToSingleChar())
                    return FALSE;
            }
            else if(CType::GetBasic(nInherentType) == CIM_UINT32)
            {
                if(!Var.ToUI4())
                    return FALSE;
            }
            else
            {
                if(!Var.ChangeTypeTo(CType::GetVARTYPE(nInherentType)))
                    return FALSE;
            }
        }
        catch(...)
        {
            return FALSE;
        }
    }

    if(Var.GetType() == VT_EX_CVARVECTOR)
    {
        return CUntypedArray::CheckCVarVector(*Var.GetVarVector(),
                                                nInherentType);
    }
    else if(Var.GetType() == VT_LPWSTR || Var.GetType() == VT_BSTR)
    {
        if(nInherentType == CIM_SINT64)
        {
            __int64 i64;
            if(!ReadI64(Var.GetLPWSTR(), i64))
                return FALSE;
        }
        else if(nInherentType == CIM_UINT64)
        {
            unsigned __int64 ui64;
            if(!ReadUI64(Var.GetLPWSTR(), ui64))
            {
                // give last chance with signed
                //__int64 i64;
	            //if(!ReadI64(Var.GetLPWSTR(), i64))
    	            return FALSE;                
            }
        }
        else if(nInherentType == CIM_UINT32)
        {
            __int64 i64;
            if(!ReadI64(Var.GetLPWSTR(), i64))
                return FALSE;

            if(i64 < 0 || i64 > 0xFFFFFFFF)
                return FALSE;
        }
    }
    else if(Var.GetType() == VT_EMBEDDED_OBJECT)
    {
    }
    else if(nInherentType == CIM_SINT8)
    {
        if(Var.GetShort() > 127 || Var.GetShort() < -128)
              return FALSE;
    }
    else if(nInherentType == CIM_UINT16)
    {
        if(Var.GetLong() >= (1 << 16) || Var.GetLong() < 0)
            return FALSE;
    }
    else if(nInherentType == CIM_UINT32)
    {
    }
    else if(nInherentType == CIM_BOOLEAN)
    {
        // GetBool() MUST return 0, -1 or 1
        if ( Var.GetBool() != VARIANT_FALSE && Var.GetBool() != VARIANT_TRUE
            && -(Var.GetBool()) != VARIANT_TRUE )
            return FALSE;

    }
    else if( nInherentType == CIM_DATETIME )
    {
        if ( !CDateTimeParser::CheckDMTFDateTimeFormat( Var.GetLPWSTR() ) )
        {
            return CDateTimeParser::CheckDMTFDateTimeInterval( Var.GetLPWSTR() );
        }
        else
        {
            return TRUE;
        }
    }
    else if(nInherentType == CIM_CHAR16)
    {
    }
    else
    {
        // Normal data
        // ===========
    }

    return TRUE;
}

BOOL CUntypedValue::CheckIntervalDateTime(CVar& Var)
{

    if(Var.GetType() == VT_EX_CVARVECTOR)
    {
        return CUntypedArray::CheckIntervalDateTime( *Var.GetVarVector() );
    }

    if ( Var.GetType() == VT_LPWSTR || Var.GetType() == VT_BSTR )
    {
        return CDateTimeParser::CheckDMTFDateTimeInterval( Var.GetLPWSTR() );
    }

    return FALSE;
}

HRESULT CUntypedValue::LoadFromCVar(CPtrSource* pThis, CVar& Var,
                                    Type_t nInherentType,
                                    CFastHeap* pHeap, Type_t& nReturnType, BOOL bUseOld)
{
    // DEVNOTE:EXCEPTION:RETVAL - This function has been reviewed and should cleanup properly
    // if an exception is thrown.  The underlying functions that perform allocations should
    // catch the exception and return a failure.

    if(Var.GetType() == VT_EX_CVARVECTOR)
    {
        // Examine the vector
        // ==================

        CVarVector* pVector = Var.GetVarVector();
        int nArrayLen = CUntypedArray::CalculateNecessarySpaceByType(
            CType::MakeNotArray(nInherentType), pVector->Size());

        // Allocate appropriate array on the heap
        // ======================================

        heapptr_t ptrArray;
        if(bUseOld)
        {
            CUntypedArray* pArray =
              (CUntypedArray*)pHeap->ResolveHeapPointer(pThis->AccessPtrData());

            // Check for allocation failure
            if ( !pHeap->Reallocate(pThis->AccessPtrData(),
                          pArray->GetLengthByType(CType::MakeNotArray(nInherentType)),
                          nArrayLen,
                          ptrArray) )
            {
                return WBEM_E_OUT_OF_MEMORY;
            }
        }
        else
        {
            // Check for allocation failure
            if ( !pHeap->Allocate(nArrayLen, ptrArray) )
            {
                return WBEM_E_OUT_OF_MEMORY;
            }
        }

		// A boy and his virtual functions.  This is what makes everything work in case
		// the BLOB gets ripped out from underneath us.  The CHeapPtr class has GetPointer
		// overloaded so we can always fix ourselves up to the underlying BLOB.

        CHeapPtr ArrayPtr(pHeap, ptrArray);

        // Copy data
        // =========

        // Check for failures along the way
        Type_t  nType;
        HRESULT hr = CUntypedArray::LoadFromCVarVector(&ArrayPtr, *pVector,
                        nInherentType, pHeap, nType, bUseOld);
        if ( FAILED( hr ) )
        {
            return hr;
        }

        pThis->AccessPtrData() = ptrArray;
        nReturnType = CType::MakeArray(nType);
        return WBEM_S_NO_ERROR;
    }
    else if(Var.GetType() == VT_LPWSTR || Var.GetType() == VT_BSTR)
    {
        if(nInherentType == CIM_SINT64)
        {
            if(!ReadI64(Var.GetLPWSTR(), *(UNALIGNED __int64*)pThis->GetPointer()))
            {
                nReturnType = CIM_ILLEGAL;
            }
            else
            {
                nReturnType = CIM_SINT64;
            }
            return WBEM_S_NO_ERROR;
        }
        else if(nInherentType == CIM_UINT64)
        {
            if(!ReadUI64(Var.GetLPWSTR(),
                    *(UNALIGNED unsigned __int64*)pThis->GetPointer()))
            {
                    nReturnType = CIM_ILLEGAL;
            }
            else
            {
                nReturnType = CIM_UINT64;
            }
            return WBEM_S_NO_ERROR;
        }
        else if(nInherentType == CIM_UINT32)
        {
            __int64 i64;
            if(!ReadI64(Var.GetLPWSTR(), i64))
            {
                nReturnType = CIM_ILLEGAL;
            }
            else if(i64 < 0 || i64 > 0xFFFFFFFF)
            {
                nReturnType = CIM_ILLEGAL;
            }
            else
            {
                *(UNALIGNED DWORD*)pThis->GetPointer() = (DWORD)i64;
                nReturnType = CIM_UINT32;
            }
            return WBEM_S_NO_ERROR;
        }
        else if(nInherentType == CIM_DATETIME)
        {
            // Don't let it through if it doesn't match the proper format
            if ( !CDateTimeParser::CheckDMTFDateTimeFormat( Var.GetLPWSTR() ) )
            {
                if ( !CDateTimeParser::CheckDMTFDateTimeInterval( Var.GetLPWSTR() ) )
                {
                    nReturnType = CIM_ILLEGAL;
                    return WBEM_E_TYPE_MISMATCH;
                }
            }
        }

        // Create compressed string on the heap
        // ====================================

        if(bUseOld && !pHeap->IsFakeAddress(pThis->AccessPtrData()))
        {
            // Check if there is enough space in the old location
            // ==================================================

            CCompressedString* pcsOld =
                pHeap->ResolveString(pThis->AccessPtrData());
            if(pcsOld->GetLength() >=
                CCompressedString::ComputeNecessarySpace(Var.GetLPWSTR()))
            {
                // Reuse old location
                // ==================

                pcsOld->SetFromUnicode(Var.GetLPWSTR());
                nReturnType = nInherentType;
                return WBEM_S_NO_ERROR;
            }
            else
            {
                // Since we were asked to reuse, it is our job to Free
                // ===================================================

                pHeap->FreeString(pThis->AccessPtrData());
            }
        }

        // Check for allocation failure here
        heapptr_t ptrTemp;
        if ( !pHeap->AllocateString(Var.GetLPWSTR(), ptrTemp ) )
        {
            return WBEM_E_OUT_OF_MEMORY;
        }

        pThis->AccessPtrData() = ptrTemp;
        nReturnType = nInherentType;
        return WBEM_S_NO_ERROR;
    }
    else if(Var.GetType() == VT_EMBEDDED_OBJECT)
    {
		// Don't store anything here
		if ( nInherentType == CIM_IUNKNOWN )
		{
			nReturnType = nInherentType;
			return WBEM_S_NO_ERROR;
		}

		// If we can't get a WbemObject out of here, we give up
		IUnknown*	pUnk = Var.GetUnknown();
		CReleaseMe	rm(pUnk);

		CWbemObject*	pWbemObject = NULL;
		HRESULT	hr = CWbemObject::WbemObjectFromCOMPtr( pUnk, &pWbemObject );
		if ( FAILED( hr ) )
		{
			return hr;
		}
		CReleaseMe	rm2( (_IWmiObject*) pWbemObject);
		

        length_t nLength = CEmbeddedObject::EstimateNecessarySpace( pWbemObject );
        heapptr_t ptrTemp;
        if(bUseOld)
        {
            CEmbeddedObject* pOldObj =
                (CEmbeddedObject*)pHeap->ResolveHeapPointer(
                                                pThis->AccessPtrData());
            length_t nOldLength = pOldObj->GetLength();

            // Check for allocation failure
            if ( !pHeap->Reallocate(pThis->AccessPtrData(), nOldLength,
                            nLength, ptrTemp) )
            {
                return WBEM_E_OUT_OF_MEMORY;
            }
        }
        else
        {
            // Check for allocation failure
            if ( !pHeap->Allocate(nLength, ptrTemp) )
            {
                return WBEM_E_OUT_OF_MEMORY;
            }
        }

        CEmbeddedObject* pObj =
            (CEmbeddedObject*)pHeap->ResolveHeapPointer(ptrTemp);
        pObj->StoreEmbedded(nLength, pWbemObject);
        pThis->AccessPtrData() = ptrTemp;
        nReturnType = CIM_OBJECT;
        return WBEM_S_NO_ERROR;
    }
    else if(nInherentType == CIM_SINT8)
    {
        if(Var.GetShort() > 127 || Var.GetShort() < -128)
        {
            nReturnType = CIM_ILLEGAL;
        }
        else
        {
            *(char*)pThis->GetPointer() = (char)Var.GetShort();
            nReturnType = nInherentType;
        }
        return WBEM_S_NO_ERROR;
    }
    else if(nInherentType == CIM_UINT16)
    {
        if(Var.GetLong() >= (1 << 16) || Var.GetLong() < 0)
        {
            nReturnType = CIM_ILLEGAL;
        }
        else
        {
            *(UNALIGNED unsigned short*)pThis->GetPointer() = (unsigned short)Var.GetLong();
            nReturnType = nInherentType;
        }
        return WBEM_S_NO_ERROR;
    }
    else if(nInherentType == CIM_UINT32)
    {
        *(UNALIGNED unsigned long*)pThis->GetPointer() = Var.GetLong();
        nReturnType = nInherentType;
        return WBEM_S_NO_ERROR;
    }
    else if(nInherentType == CIM_BOOLEAN)
    {
        // GetBool() MUST return 0, -1 or 1
        if ( Var.GetBool() != VARIANT_FALSE && Var.GetBool() != VARIANT_TRUE
            && -(Var.GetBool()) != VARIANT_TRUE )
        {
            nReturnType = CIM_ILLEGAL;
        }
        else
        {
            *(UNALIGNED VARIANT_BOOL*)pThis->GetPointer() =
                (Var.GetBool() ? VARIANT_TRUE : VARIANT_FALSE);
            nReturnType = nInherentType;
        }
        return WBEM_S_NO_ERROR;
    }
    else if(nInherentType == CIM_CHAR16)
    {
        *(UNALIGNED short*)pThis->GetPointer() = Var.GetShort();
        nReturnType = nInherentType;
        return WBEM_S_NO_ERROR;
    }
    else
    {
        // Normal data
        // ===========

		LPVOID	pData = pThis->GetPointer();
		LPVOID	pNewData = Var.GetRawData();
		int		nLength = CType::GetLength(Var.GetType());

        memcpy(pThis->GetPointer(), Var.GetRawData(),
            CType::GetLength(Var.GetType()));
        nReturnType = nInherentType;
        return WBEM_S_NO_ERROR;
    }
}

// Loads a user supplied buffer with a CVar
HRESULT CUntypedValue::LoadUserBuffFromCVar( Type_t type, CVar* pVar, ULONG uBuffSize,
											ULONG* puBuffSizeUsed, LPVOID pBuff )
{
	HRESULT	hr = WBEM_S_NO_ERROR;

	if ( CType::IsNonArrayPointerType( type ) )
	{
		if ( CType::IsStringType( type ) )
		{
			ULONG	uLength = ( wcslen( (LPWSTR) *pVar )  + 1 ) * 2;

			// Store the required size
			*puBuffSizeUsed = uLength;

			// Copy the string if we've got the room
			if ( uBuffSize >= uLength && NULL != pBuff )
			{
				StringCchCopyW( (LPWSTR) pBuff, uBuffSize, (LPWSTR) *pVar );
			}
			else
			{
				hr = WBEM_E_BUFFER_TOO_SMALL;
			}
		}
		else
		{

			ULONG	uLength = sizeof(IUnknown*);

			// Store the required size
			*puBuffSizeUsed = uLength;

			// Copy the value if we've got the room
			if ( uBuffSize >= uLength && NULL != pBuff )
			{
				*((IUnknown**) pBuff) = pVar->GetUnknown();
			}
			else
			{
				hr = WBEM_E_BUFFER_TOO_SMALL;
			}
		} 
	}
	else
	{
    	if(CIM_SINT64 == type)
        {
			ULONG	uLength = sizeof(__int64);
			*puBuffSizeUsed = uLength;

			if ( uBuffSize >= uLength && NULL != pBuff )
			{
                __int64 i64;
                if(!ReadI64(pVar->GetLPWSTR(), i64))
                    hr = WBEM_E_ILLEGAL_OPERATION;
                else
				  *((__int64 *)pBuff) = i64;
			}
			else
			{
				hr = WBEM_E_BUFFER_TOO_SMALL;
			}
        }
        else if(CIM_UINT64 == type)
        {
			ULONG	uLength = sizeof(unsigned __int64);
			*puBuffSizeUsed = uLength;

			if ( uBuffSize >= uLength && NULL != pBuff )
			{
                unsigned __int64 ui64;
                if(!ReadUI64(pVar->GetLPWSTR(), ui64))
                    hr = WBEM_E_ILLEGAL_OPERATION;
                else
				  *((unsigned __int64 *)pBuff) = ui64;
			}
			else
			{
				hr = WBEM_E_BUFFER_TOO_SMALL;
			}        
        }		
        else
        {
			ULONG	uLength = CType::GetLength( type );

			// Store the required size
			*puBuffSizeUsed = uLength;

			if ( uBuffSize >= uLength && NULL != pBuff )
			{
				// Copy the raw bytes and we're done
				CopyMemory( pBuff, pVar->GetRawData(), uLength );
			}
			else
			{
				hr = WBEM_E_BUFFER_TOO_SMALL;
			}
        }
	}	// It's a basic type

	return hr;
}

HRESULT CUntypedValue::FillCVarFromUserBuffer( Type_t type, CVar* pVar, ULONG uBuffSize, LPVOID pData )
{
	HRESULT hr = WBEM_S_NO_ERROR;

	// We don't support setting arrays, unless the property is being NULLed out
	if ( CType::IsArray( type ) && NULL != pData  )
	{
		hr = WBEM_E_ILLEGAL_OPERATION;
	}
	else
	{
		CVar	var;

		// Setup the CVar 
		if ( NULL == pData )
		{
			pVar->SetAsNull();
		}
		else if ( CType::IsStringType( type ) )
		{
			// The number of bytes must be divisible by 2, >= 2 and
			// the character in the buffer at the end must be a NULL.
			// This will be faster than doing an lstrlen.

			if (    ( uBuffSize < 2 ) ||
					( uBuffSize % 2 ) ||
					( ((LPWSTR) pData)[uBuffSize/2 - 1] != 0 ) )
				return WBEM_E_INVALID_PARAMETER;

			pVar->SetLPWSTR( (LPWSTR) pData );
		}
		else if ( CIM_OBJECT == type )
		{
			// Validate the buffer seize
			if ( uBuffSize != sizeof(_IWmiObject*) )
			{
				return WBEM_E_INVALID_PARAMETER;
			}

			pVar->SetUnknown( *((IUnknown**) pData) );
		}
		else if ( CIM_UINT64 == type ||
				CIM_SINT64 == type )
		{
			// Validate the buffer size
			if ( uBuffSize != sizeof(__int64) )
			{
				return WBEM_E_INVALID_PARAMETER;
			}

			// We need to convert to a string and set the LPWSTR value
			WCHAR*	pwcsTemp = new WCHAR[128];

			if ( NULL != pwcsTemp )
			{
				if ( CIM_SINT64 == type )
				{
					StringCchPrintfW( pwcsTemp, 128, L"%I64d", *((__int64*) pData) );
				}
				else
				{
					StringCchPrintfW( pwcsTemp, 128, L"%I64u", *((unsigned __int64*) pData) );
				}

				// This will delete the array  when it is cleared
				pVar->SetLPWSTR( pwcsTemp, TRUE );
			}
			else
			{
				hr = WBEM_E_OUT_OF_MEMORY;
			}
		}
		else if ( CIM_SINT8 == type )
		{
			// Validate the buffer size
			if ( uBuffSize != CType::GetLength( type ) )
			{
				return WBEM_E_INVALID_PARAMETER;
			}

			// We must fake up two bytes or subsequent checks may fail
			// If the value is negative we need to add an extra FF

			BYTE	bTemp[2];
			bTemp[0] = *((LPBYTE) pData);

			if ( bTemp[0] > 0x8F )
			{
				bTemp[1] = 0xFF;
			}
			else
			{
				bTemp[1] = 0;
			}

			pVar->SetRaw( VT_I2, bTemp, 2 );
		}
		else
		{
			// Validate the buffer size
			if ( uBuffSize != CType::GetLength( type ) )
			{
				return WBEM_E_INVALID_PARAMETER;
			}

			pVar->SetRaw( CType::GetVARTYPE( type ), pData, CType::GetLength( type ) );
		}

	}

	return hr;
}


//******************************************************************************
//
//  See fastval.h for documentation.
//
//******************************************************************************

BOOL CUntypedValue::TranslateToNewHeap(CPtrSource* pThis,
                                              CType Type, CFastHeap* pOldHeap,
                                              CFastHeap* pNewHeap)
{
    // DEVNOTE:EXCEPTION:RETVAL - This function has been reviewed and should cleanup properly
    // if an exception is thrown.  The underlying functions that perform allocations should
    // catch the exception and return a failure.

    if(Type.IsArray())
    {
        // Check for allocation failure
        heapptr_t ptrTemp;
        if ( !CUntypedArray::CopyToNewHeap(
                  pThis->AccessPtrData(), Type.GetBasic(), pOldHeap, pNewHeap, ptrTemp) )
        {
            return FALSE;
        }

        pThis->AccessPtrData() = ptrTemp;
    }
    else if(Type.GetBasic() == CIM_STRING ||
        Type.GetBasic() == CIM_DATETIME || Type.GetBasic() == CIM_REFERENCE)
    {
        // Check for allocation failures
        heapptr_t ptrTemp;

        if ( !CCompressedString::CopyToNewHeap(
                pThis->AccessPtrData(), pOldHeap, pNewHeap, ptrTemp) )
        {
            return FALSE;
        }

        pThis->AccessPtrData() = ptrTemp;
    }
    else if(Type.GetBasic() == CIM_OBJECT)
    {
        // Check for allocation failures
        heapptr_t ptrTemp;

        if ( !CEmbeddedObject::CopyToNewHeap(
                pThis->AccessPtrData(), pOldHeap, pNewHeap, ptrTemp) )
        {
            return FALSE;
        }

        pThis->AccessPtrData() = ptrTemp;
    }

    return TRUE;
}

//******************************************************************************
//
//  See fastval.h for documentation.
//
//******************************************************************************
BOOL CUntypedValue::CopyTo(CPtrSource* pThis, CType Type,
                                  CPtrSource* pDest,
                                  CFastHeap* pOldHeap, CFastHeap* pNewHeap)
{
    // DEVNOTE:EXCEPTION:RETVAL - This function has been reviewed and should cleanup properly
    // if an exception is thrown.  The underlying functions that perform allocations should
    // catch the exception and return a failure.

    memmove(pDest->GetPointer(), pThis->GetPointer(), Type.GetLength());
    if(pOldHeap != pNewHeap)
    {
        // Check for allocation problems.
        return CUntypedValue::TranslateToNewHeap(pDest, Type, pOldHeap, pNewHeap);
    }

    // Old Heap and New Heap are the same so we "succeeded"
    return TRUE;
}


//******************************************************************************
//
//  See fastval.h for documentation.
//
//******************************************************************************
CVarVector* CUntypedArray::CreateCVarVector(CType Type, CFastHeap* pHeap)
{
    // DEVNOTE:EXCEPTION:RETVAL - This function has been reviewed and should cleanup properly
    // if an exception is thrown.

    CVarVector* pVector = NULL;

    // Allocate CVarVector of the right type and length
    // ================================================

    try
    {
        // Allocation failure will throw an exception
        pVector = new CVarVector();
		
        if ( NULL != pVector )
        {
			// We want the pVector to sit directly on top of a SAFEARRAY, hence it
			// will be optimized.

			VARTYPE	vartype = Type.GetVARTYPE();

			if ( pVector->MakeOptimized( vartype, GetNumElements() ) )
			{
				int nSize = Type.GetLength();
				LPMEMORY pCurrentElement = GetElement(0, nSize);

				// if this is a non-pointer, non-BOOL, non __int64 type, we can do a direct
				// memory copy if the element size and the storage size are the same
				if ( !Type.IsPointerType() &&
					vartype != VT_BSTR &&
					vartype != VT_BOOL &&
					pVector->GetElementSize() == nSize )	// Make sure the storage size and the returned
															// size are the same
				{
					// Set the array directly

					HRESULT	hr = pVector->SetRawArrayData( pCurrentElement, GetNumElements(), nSize );

					if ( FAILED( hr ) )
					{
						delete pVector;
						return NULL;
					}

				}
				else	// We need to go through 1 element at a time
				{
					HRESULT	hr = WBEM_S_NO_ERROR;
					void*	pvData = NULL;
					CUnaccessVarVector	uvv;

					// We'll use direct array access for BSTRs
					// and Embedded Objects
					if ( vartype == VT_BSTR ||
						vartype == VT_UNKNOWN )
					{
						hr = pVector->AccessRawArray( &pvData );
						if ( FAILED( hr ) )
						{
							delete pVector;
							return NULL;
						}
						uvv.SetVV( pVector );
					}

					// For each element, get the CVar, which will perform the
					// appropriate conversions and then place the data in the
					// array using the most appropriate means.

					for(int i = 0; i < GetNumElements(); i++)
					{
						// Cast our element into an untyped value
						// ======================================

						CUntypedValue* pValue = (CUntypedValue*)pCurrentElement;

						// Create a corresponding CVar and add it to the vector
						// ====================================================

						CVar	var;
                
						try
						{
							// When we store to the CVar, since we are using var
							// as a pass-through, we only need to access the data
							// in pass-through fashion, so we will ask for the function
							// to optimize for us.

							// By asking for Optimized Data, we are forcing BSTRs to be allocated directly
							// from Compressed strings so that we can SPLAT them directly into a safe array
							// If this is done properly, the safe array will cleanup the BSTRs when it is
							// deleted.

							if ( !pValue->StoreToCVar(Type, var, pHeap, TRUE) )
							{
								uvv.Unaccess();
								delete pVector;
								pVector = NULL;
								break;
							}

							// We manually splat BSTRs, when the array is destroyed, the
							// BSTR will get freed.
							if ( vartype == VT_BSTR )
							{
								// 
								((BSTR*)pvData)[i] = var.GetLPWSTR();
							}
							else if ( vartype == VT_UNKNOWN )
							{
								// We manually splat Unknown pointers, when the array is destroyed, the
								// object will be released.
								((IUnknown**)pvData)[i] = var.GetUnknown();
							}
							else
							{
								// This will return an error if allocation fails
								if ( pVector->Add( var ) != CVarVector::no_error )
								{
									uvv.Unaccess();
									delete pVector;
									pVector = NULL;
									break;
								}
							}

							// Advance the current element
							// ===========================

							pCurrentElement += nSize;
						}
						catch (...)
						{
							// Cleanup pVector and rethrow the exception
							uvv.Unaccess();
							delete pVector;
							pVector = NULL;

							throw;
						}

						var.Empty();

					}	// FOR enum elements

					// No point in continuing if pVetor is NULL
					if ( NULL != pVector )
					{
						// For Strings and Objects, we need to set the max
						// array size.

						if (	vartype == VT_BSTR ||
								vartype == VT_UNKNOWN )
						{
							pVector->SetRawArraySize( GetNumElements() );
						}

					}	// IF NULL != pVector

				}	// else element by element copy

			}	// IF MakeOptimized
			else
			{
				delete pVector;
				pVector = NULL;
			}

        }   // IF NULL != pVector

        return pVector;
    }
    catch (...)
    {

        // Cleanup the allocated vector
        if ( NULL != pVector )
        {
            delete pVector;
        }

        return NULL;
    }

}

//******************************************************************************
//
//  See fastval.h for documentation.
//
//******************************************************************************

LPMEMORY CUntypedArray::GetElement(int nIndex, int nSize)
{
    return LPMEMORY(this) + sizeof(m_nNumElements) + nSize*nIndex;
}

BOOL CUntypedArray::CheckCVarVector(CVarVector& vv, Type_t nInherentType)
{
    if(!CType::IsArray(nInherentType))
        return FALSE;

    if(vv.Size() == 0)
        return TRUE;

    Type_t nBasic = CType::GetBasic(nInherentType);

    // Since all variables in our array are of the same type, we can use the
    // type of the first one to see if any checking is required
    // =====================================================================

	CVar	v;
	vv.FillCVarAt( 0, v );

    if(CType::DoesCIMTYPEMatchVARTYPE(nBasic, (VARTYPE) v.GetOleType()) &&
        !CUntypedValue::DoesTypeNeedChecking(nBasic))
    {
        return TRUE; // no type-checking required
    }

    for(int i = 0; i < vv.Size(); i++)
    {
		CVar	vTemp;
		vv.FillCVarAt( i, vTemp );

        if(!CUntypedValue::CheckCVar(vTemp, nBasic))
            return FALSE;
    }

    return TRUE;
}

BOOL CUntypedArray::CheckIntervalDateTime( CVarVector& vv )
{
    if(vv.Size() == 0)
        return FALSE;

    // Check each value in the array
    for(int i = 0; i < vv.Size(); i++)
    {
		CVar	v;
		vv.FillCVarAt( i, v );

        if(!CUntypedValue::CheckIntervalDateTime(v))
        {
            return FALSE;
        }
    }

    return TRUE;
}

HRESULT CUntypedArray::LoadFromCVarVector(CPtrSource* pThis,
                                                CVarVector& vv,
                                                Type_t nInherentType,
                                                CFastHeap* pHeap,
                                                Type_t& nReturnType,
                                                BOOL bUseOld)
{
    // DEVNOTE:EXCEPTION:RETVAL - This function has been reviewed and should cleanup properly
    // if an exception is thrown.  The underlying functions that perform allocations should
    // catch the exception and return a failure.

    // Obtain the type and the data size
    // =================================

    int nNumElements = vv.Size();
    CType Type = CType::MakeNotArray(nInherentType);
    int nSize = Type.GetLength();
	VARTYPE vartype = Type.GetVARTYPE();

	// if this is a numeric, non-BOOL type, the types are the same, and this is an optimized
	// array, we can make a direct memory copy

	if ( vartype == vv.GetType() &&
		!Type.IsPointerType() &&
		vartype != VT_BOOL &&
		vv.IsOptimized() &&
		CType::IsMemCopyAble(vartype,Type) &&
		Type.GetLength() == vv.GetElementSize() )
	{
		void*	pvData = NULL;

        CShiftedPtr ElementPtr( pThis, GetHeaderLength() );

		HRESULT	hr = vv.GetRawArrayData( ElementPtr.GetPointer(), nSize * nNumElements );

		if ( FAILED( hr ) )
		{
			return hr;
		}

	}
	else
	{
		CVar	vTemp;
		CUnaccessVarVector	uav;

		HRESULT hr = WBEM_S_NO_ERROR;
		
		// We will use direct access to the array if the vector is optimized
		if ( vv.IsOptimized() )
		{
			hr = vv.InternalRawArrayAccess();

			if ( SUCCEEDED( hr ) )
			{
				uav.SetVV( &vv );
			}
		}

		if ( SUCCEEDED( hr ) )
		{
			for(int i = 0; i < nNumElements; i++)
			{
				// IMPORTANT: this POINTER CAN CHANGE At ANY TIME IN THIS LOOP DUE
				// TO HEAP RELOCATION!!!!!
				// ===============================================================

				// Load it from CVar
				// =================

				CShiftedPtr ElementPtr(pThis, GetHeaderLength() + i*nSize);

				// Check for failures during this operation
				Type_t  nType;

				vv.FillCVarAt( i, vTemp );

				hr = CUntypedValue::LoadFromCVar(&ElementPtr, vTemp, Type, pHeap, nType,
							(bUseOld && i < GetPointer(pThis)->m_nNumElements));
				if ( FAILED( hr ) )
				{
					return hr;
				}

				vTemp.Empty();
			}

		}	// IF we did a raw array access

	}	// Else do element by element copy

    GetPointer(pThis)->m_nNumElements = nNumElements;
    nReturnType = Type;

    return WBEM_S_NO_ERROR;
}

HRESULT CUntypedArray::ReallocArray( CPtrSource* pThis, length_t nLength, CFastHeap* pHeap,
										ULONG uNumNewElements, ULONG* puNumOldElements,
										ULONG* puTotalNewElements, heapptr_t* pNewArrayPtr )
{
	HRESULT	hr = WBEM_S_NO_ERROR;

	// "Discover" the old array so we can make it a new array
	heapptr_t ptrOldArray = pThis->AccessPtrData();

	// If this is an Invalid pointer, the array was NULL, so don't just blindly jump
	// in and access the array.
	*puNumOldElements = 0;
	int nOldArrayLength = 0;

	if ( INVALID_HEAP_ADDRESS != ptrOldArray )
	{
		// Initialize the values properly
		CHeapPtr	OldArrayPtr( pHeap, ptrOldArray );

		CUntypedArray*	pArray = (CUntypedArray*) OldArrayPtr.GetPointer();;
		*puNumOldElements = pArray->GetNumElements();
		nOldArrayLength = pArray->GetLengthByActualLength( nLength );
	}

	// First up, we need to allocate space for a new array
	// --- we'll need space for the old array plus the new elements
	*puTotalNewElements = *puNumOldElements + uNumNewElements;

    int nNewArrayLen = CUntypedArray::CalculateNecessarySpaceByLength( nLength, *puTotalNewElements );

	// Allocate or Realloc as appropriate
	if ( INVALID_HEAP_ADDRESS != ptrOldArray )
	{
		if ( !pHeap->Reallocate(ptrOldArray, nOldArrayLength, nNewArrayLen,  *pNewArrayPtr) )
		{
			hr = WBEM_E_OUT_OF_MEMORY;
		}
	}
	else
	{
		if ( !pHeap->Allocate( nNewArrayLen,  *pNewArrayPtr ) )
		{
			hr = WBEM_E_OUT_OF_MEMORY;
		}
	}

	return hr;
}

// Verifies that the supplied buffer size will hold the elements required.
HRESULT CUntypedArray::CheckRangeSizeForGet( Type_t nInherentType, length_t nLength, ULONG uNumElements,
											ULONG uBuffSize, ULONG* pulBuffRequired )
{
	HRESULT	hr = WBEM_S_NO_ERROR;

	// If it's an object datatype is an IUnknown*, otherwise we need to know how much data to copy into
	// the buffer.

	if ( CIM_OBJECT == nInherentType )
	{
		// We should have uNumElement pointers (We ignore this if only one comes in)
		*pulBuffRequired = uNumElements * sizeof(CWbemObject*);

		if ( *pulBuffRequired > uBuffSize )
		{
			hr = WBEM_E_BUFFER_TOO_SMALL;
		}
	}
	else if ( !CType::IsStringType( nInherentType ) )	// We can't do strings until we get them
	{

		// Buffer Size must account for uNumElements of the appropriate length
		*pulBuffRequired = uNumElements * nLength;

		if ( *pulBuffRequired > uBuffSize )
		{
			hr = WBEM_E_BUFFER_TOO_SMALL;
		}

	}
	else
	{
		// Initialize to 0
		*pulBuffRequired = 0;
	}

	return hr;
}

// Verifies that the specified range and the number of elements correspond to the buffer
// size that was passed into us
HRESULT CUntypedArray::CheckRangeSize( Type_t nInherentType, length_t nLength, ULONG uNumElements,
									  ULONG uBuffSize, LPVOID pData )
{
	HRESULT	hr = WBEM_S_NO_ERROR;

	// If it's an object pData is an IUnknown*, otherwise we need to know how much data to copy into
	// the buffer.

	if ( CType::IsStringType( nInherentType ) )
	{
		// Calculate the total buffer length based on the number of strings
		// passed in:

		ULONG	uTotalSize = 0;
		LPWSTR	pwszTemp = (LPWSTR) pData;

		for ( ULONG	x = 0; x < uNumElements; x++ )
		{
			// Account for the NULL terminator
			ULONG	uLen = wcslen( pwszTemp ) + 1;

			//. Adjust size and then the poin=ter
			uTotalSize += ( uLen * 2 );
			pwszTemp += uLen;
		}

		if ( uTotalSize != uBuffSize )
		{
			hr = WBEM_E_TYPE_MISMATCH;
		}
	}
	else if ( CIM_OBJECT == nInherentType )
	{
		// We should have uNumElement pointers (We ignore this if only one comes in)
		if ( uNumElements != 1 && uNumElements * sizeof(CWbemObject*) != uBuffSize )
		{
			hr = WBEM_E_TYPE_MISMATCH;
		}
	}
	else
	{

		// Buffer Size must account for uNumElements of the appropriate length
		ULONG	uRequiredLength = nLength * uNumElements;

		// Sending us an invalid buffer size
		if ( uBuffSize != uRequiredLength )
		{
			hr = WBEM_E_TYPE_MISMATCH;
		}

	}

	return hr;
}

// Gets a range of elements from an array.  BuffSize must reflect uNumElements of the size of
// element being set.  Strings are converted to WCHAR and separated by NULLs.  Object properties
// are returned as an array of _IWmiObject pointers.  The range MUST be within the bounds
// of the current array
HRESULT CUntypedArray::GetRange( CPtrSource* pThis, Type_t nInherentType, length_t nLength,
								CFastHeap* pHeap, ULONG uStartIndex, ULONG uNumElements, ULONG uBuffSize,
								ULONG* puBuffSizeUsed, LPVOID pData )
{
	// Verify the range data size
	HRESULT	hr = CheckRangeSizeForGet( nInherentType, nLength, uNumElements, uBuffSize, puBuffSizeUsed );

	if ( SUCCEEDED( hr ) )
	{

		CUntypedArray*	pArray = (CUntypedArray*) pThis->GetPointer();
		ULONG			uLastIndex = uStartIndex + uNumElements - 1;

		// Make sure our range is within the bounds of our array
		if ( uStartIndex < pArray->GetNumElements() && uLastIndex < pArray->GetNumElements() )
		{

			// If this is a pointer type, use a CVar to reset values
			if ( CType::IsNonArrayPointerType( nInherentType ) )
			{
				if ( NULL != pData || CType::IsStringType( nInherentType ) )
				{
					LPMEMORY	pbTemp = (LPMEMORY) pData;
					BOOL		fTooSmall = FALSE;

					// Iterate through each element of the range and use a CVar
					// to get these guys onto the heap.
					for ( ULONG uIndex = uStartIndex; SUCCEEDED( hr ) && uIndex <= uLastIndex; uIndex++ )
					{
						// Establishes a pointer to the storage for heap pointer in the
						// array
						CShiftedPtr ElementPtr(pThis, GetHeaderLength() + ( uIndex * nLength) );

						// Set the pointer, and let the magic of fastheap kick in.
						if ( CIM_OBJECT == nInherentType )
						{
							CEmbeddedObject* pEmbedding =
									(CEmbeddedObject*) pHeap->ResolveHeapPointer( ElementPtr.AccessPtrData() );

							CWbemObject*	pObj = pEmbedding->GetEmbedded();

							if ( NULL != pObj )
							{
								*((CWbemObject**) pbTemp) = pObj;
								pbTemp += sizeof(CWbemObject*);
							}
							else
							{
								hr = WBEM_E_OUT_OF_MEMORY;
							}
						}
						else
						{
							// Make sure we dereference from the proper heap
							CCompressedString* pcs =
								pHeap->ResolveString( ElementPtr.AccessPtrData() );

							ULONG	uLength = ( pcs->GetLength() + 1 ) * 2;

							// Grow the required buffer size
							*puBuffSizeUsed += uLength;

							// Make sure the buffer is big enough
							if ( *puBuffSizeUsed > uBuffSize )
							{
								fTooSmall = TRUE;
							}

							// Now copy out as unicode and jump the pointer
							// past the string
							if ( NULL != pbTemp )
							{
								pcs->ConvertToUnicode( (LPWSTR) pbTemp );
								pbTemp += uLength;
							}
						}

					}	// FOR enum elements

					// Record the fact that the buffer was too small if we were dealing with
					// strings
					if ( fTooSmall )
					{
						hr = WBEM_E_BUFFER_TOO_SMALL;
					}

				}	// IF pData is non-NULL or the data type is String
				
			}
			else if ( NULL != pData )
			{
				// Establishes a pointer to the storage for heap pointer in the
				// array
				CShiftedPtr ElementPtr(pThis, GetHeaderLength() + ( uStartIndex * nLength) );

				// Splats data directly from the caller's buffer into our array
				CopyMemory( pData, ElementPtr.GetPointer(), *puBuffSizeUsed );

			}

		}	// If the index is valid
		else
		{
			hr = WBEM_E_INVALID_OPERATION;
		}

	}	// If proper buffer size

	return hr;
}

// Sets a range of elements inside an array.  BuffSize must reflect uNumElements of the size of
// element being set.  Strings must be linear WCHAR strings separated by NULLs.  Object properties
// must consist of an array of _IWmiObject pointers.  The range MUST fit within the bounds
// of the current array
HRESULT CUntypedArray::SetRange( CPtrSource* pThis, long lFlags, Type_t nInherentType, length_t nLength,
								CFastHeap* pHeap, ULONG uStartIndex, ULONG uNumElements, ULONG uBuffSize,
								LPVOID pData )
{
	// Verify the range data size
	HRESULT	hr = CheckRangeSize( nInherentType, nLength, uNumElements, uBuffSize, pData );

	if ( SUCCEEDED( hr ) )
	{
		BOOL		fReallocArray = FALSE;

		if ( lFlags & WMIARRAY_FLAG_ALLELEMENTS )
		{
			ULONG	uNumOldElements = 0,
					uNumNewElements = 0;

			if ( 0 == uStartIndex )
			{
				heapptr_t	ptrArray = pThis->AccessPtrData();

				// If the old array is smaller, we need to realloc.
				if ( INVALID_HEAP_ADDRESS == ptrArray )
				{
					fReallocArray = TRUE;
				}
				else
				{
					CUntypedArray*	pArray = (CUntypedArray*) pHeap->ResolveHeapPointer( ptrArray );
					uNumOldElements = pArray->GetNumElements();

					fReallocArray = ( uNumElements > uNumOldElements );
				}

				// Reallocate, and then if the inherent type implies heap pointers, fill the
				// trailing data with 0xFF bytes, so we don't free string data below
				if ( fReallocArray )
				{
					heapptr_t	ptrNewArray = 0;
					hr = ReallocArray( pThis, nLength, pHeap, uNumElements, &uNumOldElements,
							&uNumNewElements, &ptrNewArray );

					if ( SUCCEEDED( hr ) )
					{
						if ( CType::IsNonArrayPointerType( nInherentType ) )
						{
							CHeapPtr	NewArray( pHeap, ptrNewArray );
							CShiftedPtr ElementPtr(&NewArray, GetHeaderLength() +
									( uNumOldElements * sizeof(heapptr_t)) );

							FillMemory( ElementPtr.GetPointer(), uNumElements * sizeof(heapptr_t), 0xFF );
						}

						// Fixup to the new array
						pThis->AccessPtrData() = ptrNewArray;
					}

				}
				else
				{
					uNumNewElements = uNumElements;

					// Shrink the array 
					if ( uNumNewElements < uNumOldElements )
					{
						CHeapPtr	OldArray( pHeap, pThis->AccessPtrData() );

						hr = RemoveRange( &OldArray, nInherentType, nLength, pHeap, uNumNewElements,
											( uNumOldElements - uNumNewElements ) );
					}
				}
			}
			else
			{
				hr = WBEM_E_INVALID_PARAMETER;
			}
		}

		// Now that we've alloced and realloced as necessary
		if ( SUCCEEDED( hr ) )
		{
			CHeapPtr	CurrentArray( pHeap, pThis->AccessPtrData() );

			CUntypedArray*	pArray = GetPointer(&CurrentArray);
			ULONG			uLastIndex = uStartIndex + uNumElements - 1;

			// Make sure our range is within the bounds of our array.  If the realloc flag
			// is TRUE, then we know we allocated space to store the array - no new data
			// will have been set.  We wait until we store everything before we actually set
			// the num elements in case something fails during the operation
			if ( fReallocArray ||
				( uStartIndex < pArray->GetNumElements() && uLastIndex < pArray->GetNumElements() ) )
			{
				CType Type(nInherentType);

				// If this is a pointer type, use a CVar to reset values
				if ( CType::IsNonArrayPointerType( nInherentType ) )
				{
					// Iterate through each element of the range and use a CVar
					// to get these guys onto the heap.
					for ( ULONG uIndex = uStartIndex; SUCCEEDED( hr ) && uIndex <= uLastIndex; uIndex++ )
					{
						// Establishes a pointer to the storage for heap pointer in the
						// array
						CShiftedPtr ElementPtr(&CurrentArray, GetHeaderLength() + ( uIndex * nLength) );

						CVar	var;

						// Set the pointer, and let the magic of fastheap kick in.
						if ( CIM_OBJECT == nInherentType )
						{
							var.SetEmbeddedObject( *((IUnknown**) pData) );
						}
						else
						{
							var.SetLPWSTR( (LPWSTR) pData );
						}

						// Check for failures during this operation
						Type_t  nType;

						// This will properly set the element even if additional storage is required
						hr = CUntypedValue::LoadFromCVar(&ElementPtr, var, Type, pHeap, nType, TRUE );

						if ( SUCCEEDED( hr ) )
						{
							// Point to the next element
							LPMEMORY	pbTemp = (LPMEMORY) pData;

							if ( CIM_OBJECT == nInherentType )
							{
								// Just jump the size of a pointer
								pbTemp += sizeof( LPVOID);
							}
							else
							{
								// Jumps to the next string
								pbTemp += ( ( wcslen((LPWSTR) pData) + 1 ) * 2 );
							}

							// Cast back - why do I feel like I'm fishing?
							pData = pbTemp;
						}

					}	// IF IsNonArrayPointerType
					
				}
				else
				{
					// Establishes a pointer to the storage for heap pointer in the
					// array
					CShiftedPtr ElementPtr(&CurrentArray, GetHeaderLength() + ( uStartIndex * nLength) );

					// Splats data directly from the caller's buffer into our array
					CopyMemory( ElementPtr.GetPointer(), pData, uBuffSize );

				}

				// If we were setting all elements, then we need to reflect the
				// elements in the array.
				if ( SUCCEEDED( hr ) && ( lFlags & WMIARRAY_FLAG_ALLELEMENTS ) )
				{
					GetPointer(&CurrentArray)->m_nNumElements = uNumElements;
				}

			}	// If the index is valid
			else
			{
				hr = WBEM_E_INVALID_OPERATION;
			}

		}	// IF array is of proper allocation length

	}	// If proper buffer size

	return hr;
}

// Appends a range of elements to the array.  Can cause the array to be reallocated.
// pThis in this case should be a CDataTablePtr
HRESULT CUntypedArray::AppendRange( CPtrSource* pThis, Type_t nInherentType, length_t nLength,
										CFastHeap* pHeap, ULONG uNumElements, ULONG uBuffSize, LPVOID pData )
{
	HRESULT	hr = CheckRangeSize( nInherentType, nLength, uNumElements, uBuffSize, pData );

	// We're OKAY!
	if ( SUCCEEDED( hr ) )
	{

		// If this is an Invalid pointer, the array was NULL, so don't just blindly jump
		// in and access the array.
		ULONG	uOldNumElements = 0,
				nNewArrayNumElements = 0;

		heapptr_t	ptrNewArray = 0;

		hr = ReallocArray( pThis, nLength, pHeap, uNumElements, &uOldNumElements,
							&nNewArrayNumElements, &ptrNewArray );


        if ( SUCCEEDED( hr ) )
		{
			CHeapPtr	NewArrayPtr( pHeap, ptrNewArray );

			// Load it from CVar
			// =================

			// If this is a pointer type, use a CVar to deal with this
			if ( CType::IsNonArrayPointerType( nInherentType ) )
			{
				CType Type(nInherentType);

				for ( ULONG uIndex = uOldNumElements;
						SUCCEEDED( hr ) && uIndex < nNewArrayNumElements; uIndex++ )
				{

					CShiftedPtr ElementPtr(&NewArrayPtr, GetHeaderLength() + ( uIndex * nLength) );

					CVar	var;

					// Set the pointer, and let the magic of fastheap kick in.
					if ( CIM_OBJECT == nInherentType )
					{
						var.SetEmbeddedObject( *((IUnknown**) pData) );
					}
					else
					{
						var.SetLPWSTR( (LPWSTR) pData );
					}

					// Check for failures during this operation
					Type_t  nType;

					// This will properly set the element even if additional storage is required
					// Don't reuse any values here.
					hr = CUntypedValue::LoadFromCVar(&ElementPtr, var, Type, pHeap, nType, FALSE );

					// Point to the next element
					LPMEMORY	pbTemp = (LPMEMORY) pData;

					if ( CIM_OBJECT == nInherentType )
					{
						// Just jump the size of a pointer
						pbTemp += sizeof( LPVOID);
					}
					else
					{
						// Jumps to the next string
						pbTemp += ( ( wcslen((LPWSTR) pData) + 1 ) * 2 );
					}

					// Cast back - why do I feel like I'm fishing?
					pData = pbTemp;
				}
			}
			else
			{
				// Now splat the data at the end of the new array
				CShiftedPtr ElementPtr(&NewArrayPtr, GetHeaderLength() + ( uOldNumElements * nLength ) );

				CopyMemory( ElementPtr.GetPointer(), pData, nLength * uNumElements );
			}

			if ( SUCCEEDED( hr ) )
			{
				// Set the new nummber of elements
				GetPointer(&NewArrayPtr)->m_nNumElements = nNewArrayNumElements;

				// Now store the new array pointer and we are done
				pThis->AccessPtrData() = ptrNewArray;
			}
		}

	}	// If proper buffer size

	return hr;
}

// Removes a range of elements inside an array.  The range MUST fit within the bounds
// of the current array
HRESULT CUntypedArray::RemoveRange( CPtrSource* pThis, Type_t nInherentType, length_t nLength,
								CFastHeap* pHeap, ULONG uStartIndex, ULONG uNumElements )
{
	// Verify the range data size
	HRESULT	hr = WBEM_S_NO_ERROR;

	CUntypedArray*	pArray = (CUntypedArray*) pThis->GetPointer();
	ULONG			uLastIndex = uStartIndex + uNumElements - 1;
	ULONG			uOldNumElements = pArray->GetNumElements();

	// Make sure our range is within the bounds of our array
	if ( uStartIndex < uOldNumElements && uLastIndex < uOldNumElements )
	{
		CType Type(nInherentType);

		// If this is a pointer type, use a CVar to reset values
		if ( CType::IsNonArrayPointerType( nInherentType ) )
		{
			// Iterate through each element of the range and free each heap element
			for ( ULONG uIndex = uStartIndex; uIndex <= uLastIndex; uIndex++ )
			{
				// Establishes a pointer to the storage for heap pointer in the
				// array
				CShiftedPtr ElementPtr(pThis, GetHeaderLength() + ( uIndex * nLength) );

				CVar	var;

				// Set the pointer, and let the magic of fastheap kick in.
				if ( CIM_OBJECT == nInherentType )
				{
					CEmbeddedObject* pOldObj =
						(CEmbeddedObject*)pHeap->ResolveHeapPointer(
														ElementPtr.AccessPtrData());
					length_t nOldLength = pOldObj->GetLength();

					pHeap->Free( ElementPtr.AccessPtrData(), nOldLength );
				}
				else
				{
					pHeap->FreeString( ElementPtr.AccessPtrData() );
				}

			}	// FOR iterate elements in the requested Remove range
			
		}

		// Now we need to copy elements over the ones we want to axe
		if ( SUCCEEDED( hr ) )
		{
			// Reestablish this
			pArray = (CUntypedArray*) pThis->GetPointer();
			ULONG	uEndOfArrayIndex = pArray->GetNumElements() - 1;

			if ( uLastIndex < uEndOfArrayIndex )
			{
				CShiftedPtr StartIndexPtr(pThis, GetHeaderLength() + ( uStartIndex * nLength) );
				CShiftedPtr MoveIndexPtr(pThis, GetHeaderLength() + ( ( uLastIndex + 1 ) * nLength) );

				// Difference between the end of array index and the last index covers how
				// many elements we actually want to move.
				MoveMemory( StartIndexPtr.GetPointer(), MoveIndexPtr.GetPointer(),
							( uEndOfArrayIndex - uLastIndex ) * nLength );
			}

			// Now subtract the number of removed elements from the total number of
			// elements in the array.

			GetPointer( pThis )->m_nNumElements = uOldNumElements - uNumElements;
		}

	}	// If the index is valid
	else
	{
		hr = WBEM_E_INVALID_OPERATION;
	}

	return hr;
}


//******************************************************************************
//
//  See fastval.h for documentation.
//
//******************************************************************************
 void CUntypedArray::Delete(CType Type, CFastHeap* pHeap)
{
    // NOTE: ARRAYS OF ARRAYS ARE NOT SUPPORTED!!!!
    // ============================================

    if(Type.GetBasic() == CIM_STRING || Type.GetBasic() == CIM_DATETIME ||
        Type.GetBasic() == CIM_REFERENCE)
    {
        // Have to delete every pointer
        // ===============================

        PHEAPPTRT pptrCurrent = (PHEAPPTRT)GetElement(sizeof(heapptr_t), 0);
        for(int i = 0; i < GetNumElements(); i++)
        {
            pHeap->FreeString(*pptrCurrent);
            pptrCurrent++;
        }
    }
    else if(Type.GetBasic() == CIM_OBJECT)
    {
        // Have to delete every pointer
        // ===============================

        PHEAPPTRT pptrCurrent = (PHEAPPTRT)GetElement(sizeof(heapptr_t), 0);
        for(int i = 0; i < GetNumElements(); i++)
        {
            CEmbeddedObject* pObj = (CEmbeddedObject*)
                pHeap->ResolveHeapPointer(*pptrCurrent);
            pHeap->Free(*pptrCurrent, pObj->GetLength());
            pptrCurrent++;
        }
    }
}


//******************************************************************************
//
//  See fastval.h for documentation.
//
//******************************************************************************
BOOL CUntypedArray::TranslateToNewHeap(CPtrSource* pThis, CType Type,
                                   CFastHeap* pOldHeap, CFastHeap* pNewHeap)
{
    // DEVNOTE:EXCEPTION:RETVAL - This function has been reviewed and should cleanup properly
    // if an exception is thrown.  The underlying functions that perform allocations should
    // catch the exception and return a failure.

    // NOTE: ARRAYS OF ARRAYS ARE NOT SUPPORTED!!!!
    // ============================================

    if(Type.GetBasic() == CIM_STRING || Type.GetBasic() == CIM_DATETIME ||
        Type.GetBasic() == CIM_REFERENCE)
    {
        // Have to translate every pointer
        // ===============================

        int nOffset = GetHeaderLength();
        int nNumElements = GetPointer(pThis)->GetNumElements();
        for(int i = 0; i < nNumElements; i++)
        {
            heapptr_t ptrOldString =
                *(PHEAPPTRT)(pThis->GetPointer() + nOffset);

            // Check for allocation failure
            heapptr_t ptrNewString;

            if ( !CCompressedString::CopyToNewHeap(
                    ptrOldString, pOldHeap, pNewHeap, ptrNewString) )
            {
                return FALSE;
            }

            *(PHEAPPTRT)(pThis->GetPointer() + nOffset) = ptrNewString;

            nOffset += sizeof(heapptr_t);
        }
    }
    else if(Type.GetBasic() == CIM_OBJECT)
    {
        // Have to translate every pointer
        // ===============================

        int nOffset = GetHeaderLength();
        int nNumElements = GetPointer(pThis)->GetNumElements();
        for(int i = 0; i < nNumElements; i++)
        {
            heapptr_t ptrOldObj =
                *(PHEAPPTRT)(pThis->GetPointer() + nOffset);

            // Check for allocation failure
            heapptr_t ptrNewObj;

            if ( !CEmbeddedObject::CopyToNewHeap(
                    ptrOldObj, pOldHeap, pNewHeap, ptrNewObj) )
            {
                return FALSE;
            }

            *(PHEAPPTRT)(pThis->GetPointer() + nOffset) = ptrNewObj;

            nOffset += sizeof(heapptr_t);
        }
    }
    
    return TRUE;
}

//******************************************************************************
//
//  See fastval.h for documentation.
//
//******************************************************************************
BOOL CUntypedArray::CopyToNewHeap(heapptr_t ptrOld, CType Type,
                                CFastHeap* pOldHeap, CFastHeap* pNewHeap, UNALIGNED heapptr_t& ptrResult)
{
    // DEVNOTE:EXCEPTION:RETVAL - This function has been reviewed and should cleanup properly
    // if an exception is thrown.  The underlying functions that perform allocations should
    // catch the exception and return a failure.

    // Calculate the length
    // ====================

    CUntypedArray* pArray =
        (CUntypedArray*)pOldHeap->ResolveHeapPointer(ptrOld);

    int nLength = pArray->GetLengthByType(Type.GetBasic());

    // Allocate room on the new heap and memcopy the whole thing
    // =========================================================

    // Check for allocation failure
    heapptr_t ptrNew;
    if ( !pNewHeap->Allocate(nLength, ptrNew) )
    {
        return FALSE;
    }

    pArray = NULL; /* pointer may have been invalidated!!! */

    memcpy(pNewHeap->ResolveHeapPointer(ptrNew),
        pOldHeap->ResolveHeapPointer(ptrOld), nLength);

    // Translate all the data (e.g., copy strings)
    // ===========================================

    CHeapPtr NewArray(pNewHeap, ptrNew);

    // Check for allocation failure
    if ( !CUntypedArray::TranslateToNewHeap(&NewArray, Type, pOldHeap, pNewHeap) )
    {
        return FALSE;
    }

    ptrResult = ptrNew;
    return TRUE;
}

HRESULT CUntypedArray::IsArrayValid( CType Type, CFastHeap* pHeap )
{
    // Get the heap data start
    LPMEMORY    pHeapStart = pHeap->GetHeapData();
    LPMEMORY    pHeapEnd = pHeap->GetStart() + pHeap->GetLength();

    if ( CType::IsPointerType( Type.GetBasic() ) )
    {
        int nSize = Type.GetLength();
        LPMEMORY pCurrentElement = GetElement(0, nSize);

        LPMEMORY pEndArray = pCurrentElement + ( m_nNumElements * nSize );

        // Make sure the end of the array is within our heap bounds.
        if ( !( pEndArray >= pHeapStart && pEndArray <= pHeapEnd ) )
        {
            _ASSERT( 0, __TEXT("Winmgmt: Untyped Array past end of heap!") );
            return WBEM_E_FAILED;
        }

        for ( int n = 0; n < m_nNumElements; n++ )
        {
            CUntypedValue* pValue = (CUntypedValue*)pCurrentElement;
            LPMEMORY pData = pHeap->ResolveHeapPointer( pValue->AccessPtrData() );

            if ( !( pData >= pHeapStart && pData < pHeapEnd ) )
            {
                _ASSERT( 0, __TEXT("Winmgmt: Bad heap pointer in array element!") );
                return WBEM_E_FAILED;
            }

            // Advance the current element
            // ===========================

            pCurrentElement += nSize;

        }   // FOR enum elements

    }   // Only if this is a pointer type

    return WBEM_S_NO_ERROR;
}

CType CType::VARTYPEToType(VARTYPE vt)
{
    Type_t nType;
    switch(vt & ~VT_ARRAY)
    {
    case VT_LPSTR:
    case VT_LPWSTR:
    case VT_BSTR:
        nType = CIM_STRING;
        break;
    case VT_UI1:
        nType = CIM_UINT8;
        break;
    case VT_I2:
        nType = CIM_SINT16;
        break;
    case VT_I4:
        nType = CIM_SINT32;
        break;
    case VT_BOOL:
        nType = CIM_BOOLEAN;
        break;
    case VT_R4:
        nType = CIM_REAL32;
        break;
    case VT_R8:
        nType = CIM_REAL64;
        break;
    case VT_EMBEDDED_OBJECT:
        nType = CIM_OBJECT;
        break;
    default:
        nType = CIM_ILLEGAL;
        break;
    }

    if(vt & VT_ARRAY) nType |= CIM_FLAG_ARRAY;

    return nType;
}
VARTYPE CType::GetVARTYPE(Type_t nType)
{
    VARTYPE vt;
    switch(GetBasic(nType))
    {
    case CIM_STRING:
    case CIM_DATETIME:
    case CIM_REFERENCE:
        vt = VT_BSTR;
        break;
    case CIM_OBJECT:
        vt = VT_EMBEDDED_OBJECT;
        break;
    case CIM_SINT64:
    case CIM_UINT64:
        vt = VT_BSTR;
        break;
    case CIM_UINT32:
    case CIM_SINT32:
    case CIM_UINT16:
        vt = VT_I4;
        break;
    case CIM_SINT16:
    case CIM_SINT8:
    case CIM_CHAR16:
        vt = VT_I2;
        break;
    case CIM_UINT8:
        vt = VT_UI1;
        break;
    case CIM_REAL32:
        vt = VT_R4;
        break;
    case CIM_REAL64:
        vt = VT_R8;
        break;
    case CIM_BOOLEAN:
        vt = VT_BOOL;
        break;
    case CIM_IUNKNOWN:
        vt = VT_UNKNOWN;
        break;
    }

    if(IsArray(nType))
        return vt | VT_ARRAY;
    else
        return vt;
}


BOOL CType::CanBeKey(Type_t nType)
{
        Type_t nActual = GetActualType(nType);
        return nActual == CIM_SINT32 || nActual == CIM_SINT16 ||
            nActual == CIM_UINT8 || nActual == CIM_BOOLEAN ||
            nActual == CIM_STRING || nActual == CIM_REFERENCE ||
            nActual == CIM_DATETIME || nActual == CIM_UINT32 ||
            nActual == CIM_UINT16 || nActual == CIM_SINT8 ||
            nActual == CIM_UINT64 || nActual == CIM_SINT64 ||
            nActual == CIM_CHAR16;
}

LPWSTR CType::GetSyntax(Type_t nType)
{
        switch(GetBasic(nType))
        {
            case CIM_SINT32: return L"sint32";
            case CIM_SINT16: return L"sint16";
            case CIM_UINT8: return L"uint8";
            case CIM_UINT32: return L"uint32";
            case CIM_UINT16: return L"uint16";
            case CIM_SINT8: return L"sint8";
            case CIM_UINT64: return L"uint64";
            case CIM_SINT64: return L"sint64";
            case CIM_REAL32: return L"real32";
            case CIM_REAL64: return L"real64";
            case CIM_BOOLEAN: return L"boolean";
            case CIM_OBJECT: return L"object";
            case CIM_STRING: return L"string";
            case CIM_REFERENCE: return L"ref";
            case CIM_DATETIME: return L"datetime";
            case CIM_CHAR16: return L"char16";
			case CIM_IUNKNOWN: return L"IUnknown";
            default: return NULL;
        }
}

void CType::AddPropertyType(WString& wsText, LPCWSTR wszSyntax)
{
    // DEVNOTE:EXCEPTION:RETVAL - This function has been reviewed and should cleanup properly
    // if an exception is thrown

    if(!wbem_wcsicmp(wszSyntax, L"ref"))
    {
        wsText += L"object ref";
    }
    else if(!wbem_wcsicmp(wszSyntax, L"object"))
    {
        wsText += L"object";
    }
    else if(!wbem_wcsnicmp(wszSyntax, L"ref:", 4))
    {
        wsText += wszSyntax + 4;
        wsText += L" ref";
    }
    else if(!wbem_wcsnicmp(wszSyntax, L"object:", 7))
    {
        wsText += wszSyntax + 7;
    }
    else
    {
        wsText += wszSyntax;
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\marshalers\coreprox\faststr.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    FASTSTR.CPP

Abstract:

  This file implements the classes related to string processing in WbemObjects.

  See faststr.h for documentation.

  Classes implemented: 
      CCompressedString   Represents an ascii or unicode string.
      CKnownStringTable   The table of strings hard-coded into WINMGMT for
                          compression.
      CFixedBSTRArray     An array of BSTRs capable of sophisticated merges.

History:

  2/20/97     a-levn  Fully documented
  12//17/98 sanjes -    Partially Reviewed for Out of Memory.

--*/

#include "precomp.h"

#include "faststr.h"
#include "fastheap.h"
#include "olewrap.h"
#include "corex.h"

//*****************************************************************************
//
//  See faststr.h for documentation
//
//*****************************************************************************
BOOL CCompressedString::CopyToNewHeap(
                    heapptr_t ptrOldString, CFastHeap* pOldHeap, CFastHeap* pNewHeap,
                    UNALIGNED heapptr_t& ptrResult )
{
    if(CFastHeap::IsFakeAddress(ptrOldString))
    {
        ptrResult = ptrOldString;
        return TRUE;
    }

    CCompressedString* pString = (CCompressedString*)
        pOldHeap->ResolveHeapPointer(ptrOldString);

    int nLen = pString->GetLength();

    // Check that allocation succeeds
    BOOL fReturn = pNewHeap->Allocate(nLen, ptrResult);
    // can no longer use pString --- the heap might have moved
    
    if ( fReturn )
    {
        memcpy(pNewHeap->ResolveHeapPointer(ptrResult),
            pOldHeap->ResolveHeapPointer(ptrOldString),
            nLen);
    }

    return fReturn;
}
 
//*****************************************************************************
//
//  See faststr.h for documentation
//
//*****************************************************************************
LPMEMORY CCompressedString::CreateEmpty(LPMEMORY pWhere)
{
    pWhere[0] = STRING_FLAG_ASCII;
    pWhere[1] = 0;
    return pWhere + 2;
}

//*****************************************************************************
//************************ Known String Table *********************************
//*****************************************************************************

LPSTR mstatic_aszStrings[] = {
    ASCII_STRING_PREFIX "", // nothing for index 0
    ASCII_STRING_PREFIX "key", 
    ASCII_STRING_PREFIX "",
    ASCII_STRING_PREFIX "read", 
    ASCII_STRING_PREFIX "write",
    ASCII_STRING_PREFIX "volatile",
    ASCII_STRING_PREFIX "provider",
    ASCII_STRING_PREFIX "dynamic",
    ASCII_STRING_PREFIX "cimwin32",
    ASCII_STRING_PREFIX "DWORD",
    ASCII_STRING_PREFIX "CIMTYPE"
};
int mstatic_nNumStrings = 0;

int CKnownStringTable::GetKnownStringIndex(READ_ONLY LPCWSTR wszString)
    {
        if(mstatic_nNumStrings == 0) Initialize();
        for(int i = 1; i < mstatic_nNumStrings; i++)
        {
            if(CCompressedString::CompareUnicodeToAsciiNoCase(
                wszString,
                mstatic_aszStrings[i] + 1) == 0)
            {
                return i;
            }
        }
        return STRING_INDEX_UNKNOWN;
    }

INTERNAL CCompressedString& CKnownStringTable::GetKnownString(IN int nIndex)
    {
        if(mstatic_nNumStrings == 0) Initialize();
        if (nIndex < 0 || nIndex >= LENGTH_OF(mstatic_aszStrings)) throw CX_Exception();
        return *(CCompressedString*)mstatic_aszStrings[nIndex];
    }

void CKnownStringTable::Initialize()
{
    mstatic_nNumStrings =  sizeof(mstatic_aszStrings) / sizeof(LPSTR);
/*
    for(int i = 1; i < mstatic_nNumStrings; i++)
    {
        // Set the first byte to STRING_FLAG_ASCII.
        // ========================================
        mstatic_aszStrings[i][0] = STRING_FLAG_ASCII;
    }
*/
}

//*****************************************************************************
//************************ Reserved Word Table *********************************
//*****************************************************************************

// IMPORTANT!!!!

// When adding new entries to the following list, ENSURE that they are correctly alphabetized
// or the binary searches will not work!

LPCWSTR CReservedWordTable::s_apwszReservedWords[] = {
    L"AMENDED",
    L"CLASS",
    L"DISABLEOVERRIDE",
    L"ENABLEOVERRIDE",
    L"INSTANCE",
    L"NOTTOINSTANCE",
    L"NOTTOSUBCLASS",
    L"OF",
    L"PRAGMA",
    L"QUALIFIER",
    L"RESTRICTED",
    L"TOINSTANCE",
    L"TOSUBCLASS",
};

// IMPORTANT!!!!

// When adding new entries to the following lists, ENSURE that they are correctly alphabetized
// or the binary searches will not work!  Also, be sure to add the new character to BOTH upper
// and lower case lists

LPCWSTR CReservedWordTable::s_pszStartingCharsUCase = L"ACDEINOPQRT";
LPCWSTR CReservedWordTable::s_pszStartingCharsLCase = L"acdeinopqrt";

BOOL CReservedWordTable::IsReservedWord( LPCWSTR pwcsName )
{
    BOOL    fFound = FALSE;

    if ( NULL != pwcsName && NULL != *pwcsName )
    {
        LPCWSTR pwszStartingChars = NULL;

        // See if we're even a character to worry about
        if ( *pwcsName >= 'A' && *pwcsName <= 'Z' )
        {
            pwszStartingChars = CReservedWordTable::s_pszStartingCharsUCase;
        }
        else if ( *pwcsName >= 'a' && *pwcsName <= 'z' )
        {
            pwszStartingChars = CReservedWordTable::s_pszStartingCharsLCase;
        }

        // Well at least it's a possibility, so binary search the list
        if ( NULL != pwszStartingChars )
        {
            int nLeft = 0,
                nRight = lstrlenW( pwszStartingChars )  - 1;

            BOOL    fFoundChar = FALSE;

            // Binary search the characters
            while(  !fFoundChar && nLeft < nRight )
            {
                
                int nNew = ( nLeft + nRight ) / 2;

                fFoundChar = ( pwszStartingChars[nNew] == *pwcsName );

                if ( !fFoundChar )
                {
                
                    // Check for > or <
                    if( pwszStartingChars[nNew] > *pwcsName )
                    {
                        nRight = nNew;
                    }
                    else 
                    {
                        nLeft = nNew + 1;
                    }

                }   // IF fFoundChar

            }   // While looking for character

            if ( !fFoundChar )
            {
                fFoundChar = ( pwszStartingChars[nLeft] == *pwcsName );
            }

            // Only search the list if we found a char
            if ( fFoundChar )
            {
                // Reset these
                nLeft = 0;
                nRight = ( sizeof(CReservedWordTable::s_apwszReservedWords) / sizeof(LPCWSTR) ) - 1;

                // Now Binary search the actual strings

                // Binary search the characters
                while(  !fFound && nLeft < nRight )
                {
                    int nNew = ( nLeft + nRight ) / 2;
                    int nCompare = wbem_wcsicmp(
                            CReservedWordTable::s_apwszReservedWords[nNew], pwcsName );

                    if ( 0 == nCompare )
                    {
                        fFound = TRUE;
                    }
                    else if ( nCompare > 0 )
                    {
                        nRight = nNew;
                    }
                    else 
                    {
                        nLeft = nNew + 1;
                    }

                }   // While looking string

                // Check last slot
                if ( !fFound )
                {
                    fFound = !wbem_wcsicmp(
                            CReservedWordTable::s_apwszReservedWords[nLeft], pwcsName );
                }

            }   // IF found character

        }   // IF we had a potential character set match

    }   // IF we got passed a reasonable string

    return fFound;
}

//*****************************************************************************
//************************ String Array    ************************************
//*****************************************************************************

void CFixedBSTRArray::Free()
{
    for(int i = 0; i < m_nSize; i++)
    {
        COleAuto::_SysFreeString(m_astrStrings[i]);
    }

    delete [] m_astrStrings;
    m_astrStrings = NULL;
    m_nSize = 0;
}

void CFixedBSTRArray::Create( int nSize )
{
    Free();
    
    m_astrStrings = new BSTR[nSize];

    // Check for allocation failure and throw an exception
    if ( NULL == m_astrStrings )
    {
        throw CX_MemoryException();
    }

    ZeroMemory( m_astrStrings, nSize * sizeof(BSTR) );
    
    m_nSize = nSize;
}

void CFixedBSTRArray::SortInPlace()
{
    int nIndex = 0;
    while(nIndex < GetLength()-1)
    {
        if(wbem_wcsicmp(GetAt(nIndex), GetAt(nIndex+1)) > 0)
        {
            BSTR strTemp = GetAt(nIndex);
            GetAt(nIndex) = GetAt(nIndex+1);
            GetAt(nIndex+1) = strTemp;

            if(nIndex > 0) nIndex--;
        }
        else nIndex++;
    }
}

void CFixedBSTRArray::ThreeWayMergeOrdered(
                              CFixedBSTRArray& astrInclude1, 
                              CFixedBSTRArray& astrInclude2,
                              CFixedBSTRArray& astrExclude)
{
    // DEVNOTE:EXCEPTION:RETVAL - This function has been reviewed and should cleanup properly
    // if an exception is thrown

    try
    {
        // Create ourselves with the size which is the sum of theirs
        // =========================================================

        Create(astrInclude1.GetLength() + astrInclude2.GetLength());

        // Merge
        // =====

        int nIndexInc1 = 0, nIndexInc2 = 0, nIndexExc = 0, nIndexNew = 0;

        BSTR strInc;

        BOOL bEndInc1 = (nIndexInc1 == astrInclude1.GetLength());
        BOOL bEndInc2 = (nIndexInc2 == astrInclude2.GetLength());
        BOOL bEndExc = (nIndexExc == astrExclude.GetLength());

        while(!bEndInc1 || !bEndInc2)
        {
            // Find the smaller of the includes
            // ================================

            int nCompare;
            if(bEndInc1)
            {
                strInc = astrInclude2[nIndexInc2];
                nCompare = 1;
            }
            else if(bEndInc2)
            {
                strInc = astrInclude1[nIndexInc1];
                nCompare = -1;
            }
            else
            {
                nCompare = wbem_wcsicmp(astrInclude1[nIndexInc1],
                                  astrInclude2[nIndexInc2]);
                if(nCompare >= 0)
                {
                    strInc = astrInclude2[nIndexInc2];
                }
                else
                {
                    strInc = astrInclude1[nIndexInc1];
                }
            }

            // Check the exclude
            // =================

            while(!bEndExc && wbem_wcsicmp(astrExclude[nIndexExc], strInc) < 0)
            {
                nIndexExc++;
                bEndExc = (nIndexExc >= astrExclude.GetLength());
            }

            if(bEndExc || wbem_wcsicmp(astrExclude[nIndexExc], strInc) > 0)
            {
                // strInc is not excluded
                // ======================

                GetAt(nIndexNew++) = COleAuto::_SysAllocString(strInc);
            }
            else
            {
                // strInc is excluded
                // ==================
            
                nIndexExc++;
                bEndExc = (nIndexExc == astrExclude.GetLength());
            }

            if(nCompare <= 0)
            {
                nIndexInc1++;
                bEndInc1 = (nIndexInc1 == astrInclude1.GetLength());
            }

            if(nCompare >= 0)
            {
                nIndexInc2++;
                bEndInc2 = (nIndexInc2 == astrInclude2.GetLength());
            }
        }

        m_nSize = nIndexNew;
    }
    catch (CX_MemoryException)
    {
        // Cleanup and propagate the exception
        Free();
        throw;
    }
    catch (...)
    {
        // Cleanup and propagate the exception
        Free();
        throw;
    }

}

void CFixedBSTRArray::Filter( LPCWSTR pwcsStr, BOOL fFree /* = FALSE */ )
{

    // Make sure we have an array first
    if ( NULL != m_astrStrings )
    {
        // Walk the array, looking for exact matches to the filter.
        // If we find them we need to shrink the array
        for ( int x = 0; x < m_nSize; x++ )
        {
            if ( wbem_wcsicmp( pwcsStr, m_astrStrings[x] ) == 0 )
            {
                // Free the BSTR if appropriate
                if ( fFree )
                {
                    COleAuto::_SysFreeString( m_astrStrings[x] );
                }

                // Zero the pointer and copy memory from x+1 to the end of the array
                // in one block
                m_astrStrings[x]= NULL;
                CopyMemory( &m_astrStrings[x], &m_astrStrings[x+1],
                            ( m_nSize - x - 1 ) * sizeof(BSTR) );

                // Decrement size and x by 1
                m_nSize--;
                x--;

            }   // IF wbem_wcsicmp

        }   // FOR enum array elements

    }   // IF NULL != m_astrStrings

}

int CCompressedString::GetLength() const
{
    return sizeof(BYTE)+ 
        (GetStringLength()+1) * ((IsUnicode())?2:1);
}

int CCompressedString::ValidateSize(int cbSize) const
{
	int currentLeft = cbSize;

	if (cbSize < 2) throw CX_Exception();	

	int minSize = sizeof(BYTE) + IsUnicode() ? sizeof(L'\0') : sizeof('\0');
	if (currentLeft < minSize) throw CX_Exception();
	currentLeft -= sizeof(BYTE);

	if (IsUnicode()) 
	{

		BYTE * wideString = static_cast<BYTE *>(GetRawData());
	    size_t wideLeft = currentLeft/2;
	    while (wideLeft && 
		  ((*wideString != '\0') || (*(wideString+1) != '\0')))
    	{
        	wideString+=2;
	        currentLeft-=2;
		wideLeft --;
    	}
		if (wideLeft == 0) throw  CX_Exception();
		currentLeft-=sizeof(L'\0');
		return cbSize - currentLeft;
	}
	else
	{
		char * ansiString = reinterpret_cast<char *>(GetRawData());
	    while (currentLeft && (*ansiString != '\0'))
    	{
        	ansiString++;
	        currentLeft--;
    	}
		if (currentLeft == 0) throw  CX_Exception();
		currentLeft-=sizeof('\0');	
		return cbSize - currentLeft ;
	};
}

int CCompressedString::GetStringLength() const
{
    return (IsUnicode()) ? 
        fast_wcslen(LPWSTR(GetRawData())) 
        : strlen(LPSTR(GetRawData()));
}

//*****************************************************************************
//
//  CCompressedString::ConvertToUnicode
//
//  Writes a UNICODE equivalent of self into a pre-allocated buffer
//
//  PARAMETERS:
//
//      [in, modified] LPWSTR wszDest   The buffer. Assumed to be large enough,
//
//*****************************************************************************
 
void CCompressedString::ConvertToUnicode(LPWSTR wszDest) const
{
    if(IsUnicode())
    {
        fast_wcscpy(wszDest, (LPWSTR)GetRawData());
    }
    else
    {
        WCHAR* pwc = wszDest;
        unsigned char* pc = (unsigned char*)LPSTR(GetRawData());
        while(*pc)
        {
            *(pwc++) = (WCHAR)(*(pc++));
        }
        *pwc = 0;
    }
}


WString CCompressedString::CreateWStringCopy() const
{
    if(IsUnicode())
    {
        int nLen = fast_wcslen(LPWSTR(GetRawData())) + 1;

        // This will throw an exception if this fails
        LPWSTR wszText = new WCHAR[nLen];

        if ( NULL == wszText )
        {
            throw CX_MemoryException();
        }

        // Copy using the helper
        fast_wcsncpy( wszText, LPWSTR(GetRawData()), nLen - 1 );

        return WString(wszText, TRUE);
    }
    else
    {
        int nLen = strlen(LPSTR(GetRawData())) + 1;

        // This will throw an exception if this fails
        LPWSTR wszText = new WCHAR[nLen];

        if ( NULL == wszText )
        {
            throw CX_MemoryException();
        }

        ConvertToUnicode(wszText);
        return WString(wszText, TRUE);
    }
}

SYSFREE_ME BSTR CCompressedString::CreateBSTRCopy() const
{
    // We already have LOTS of code that handles NULL returns from
    // here, so catch the exception and return a NULL.

    try
    {
        if(IsUnicode())
        {
            int nLen = fast_wcslen(LPWSTR(GetRawData()));

            BSTR strRet = COleAuto::_SysAllocStringLen(NULL, nLen);

            // Check that the SysAlloc succeeded
            if ( NULL != strRet )
            {
                fast_wcsncpy( strRet, LPWSTR(GetRawData()), nLen );
            }

            return strRet;
        }
        else
        {
            int nLen = strlen(LPSTR(GetRawData()));
            BSTR strRet = COleAuto::_SysAllocStringLen(NULL, nLen);

            // Check that the SysAlloc succeeded
            if ( NULL != strRet )
            {
                ConvertToUnicode(strRet);
            }

            return strRet;
        }
    }
    catch (CX_MemoryException)
    {
        return NULL;
    }
    catch (...)
    {
        return NULL;
    }
}

int CCompressedString::ComputeNecessarySpace(
                                           READ_ONLY LPCSTR szString)
{
    return sizeof(BYTE) + strlen(szString) + 1;
}

int CCompressedString::ComputeNecessarySpace(
                                           READ_ONLY LPCWSTR wszString)
{
    if(IsAsciiable(wszString))
    {
        return sizeof(BYTE) + fast_wcslen(wszString) + 1;
    }
    else
    {
        return sizeof(BYTE) + (fast_wcslen(wszString) + 1) * 2;
    }
}

int CCompressedString::ComputeNecessarySpace(READ_ONLY LPCWSTR wszString,
	                                                                  BOOL & IsAsciable)
{
    if(IsAsciiable(wszString))
    {
        IsAsciable = TRUE;
        return sizeof(BYTE) + fast_wcslen(wszString) + 1;
    }
    else
    {
        IsAsciable = FALSE;
        return sizeof(BYTE) + (fast_wcslen(wszString) + 1) * 2;
    }
}

//*****************************************************************************
//
//  static CCompressedString::IsAsciiable
//
//  Determines if a given UNICODE string is actually ASCII (or, to be more
//  precise, if all characters are between 0 and 255).
//
//  PARAMETERS:
//
//      [in, readonly] LPCWSTR wszString    the string to examine
//
//  RETURNS:
//
//      BOOL    TRUE iff asciiable.
//
//*****************************************************************************

BOOL CCompressedString::IsAsciiable(LPCWSTR wszString)
{
    WCHAR *pwc = (WCHAR*)wszString;
    while(*pwc)
    {
        if(UpperByte(*pwc) != 0) return FALSE;
        pwc++;
    }
    return TRUE;
}

void CCompressedString::SetFromUnicode(COPY LPCWSTR wszString)
{
    if(IsAsciiable(wszString))
    {
        m_fFlags = STRING_FLAG_ASCII;
        const WCHAR* pwc = wszString;
        char* pc = LPSTR(GetRawData());
        while(*pwc)
        {
            *(pc++) = LowerByte(*(pwc++));
        }
        *pc = 0; 
    }
    else
    {
        m_fFlags = STRING_FLAG_UNICODE;
        fast_wcscpy(LPWSTR(GetRawData()), wszString);
    }
}

void CCompressedString::SetFromUnicode(BOOL IsAsciable,
	                                                       COPY LPCWSTR wszString)
{
    if(IsAsciable)
    {
        m_fFlags = STRING_FLAG_ASCII;
        const WCHAR* pwc = wszString;
        char* pc = LPSTR(GetRawData());
        while(*pwc)
        {
            *(pc++) = LowerByte(*(pwc++));
        }
        *pc = 0; 
    }
    else
    {
        m_fFlags = STRING_FLAG_UNICODE;
        fast_wcscpy(LPWSTR(GetRawData()), wszString);
    }
}


void CCompressedString::SetFromAscii(COPY LPCSTR szString, size_t mySize)
{
    m_fFlags = STRING_FLAG_ASCII;
    memcpy(LPSTR(GetRawData()), szString, mySize - 1);
    
}

int CCompressedString::Compare(
              READ_ONLY const CCompressedString& csOther) const
{
    return (csOther.IsUnicode())?
        Compare(LPWSTR(csOther.GetRawData())):
        Compare(LPSTR(csOther.GetRawData()));
}

int CCompressedString::Compare(READ_ONLY LPCWSTR wszOther) const
{
    return (IsUnicode())?
        wcscmp((LPCWSTR)GetRawData(), wszOther):
        - CompareUnicodeToAscii(wszOther, (LPCSTR)GetRawData());
}

int CCompressedString::Compare(READ_ONLY LPCSTR szOther) const
{
    return (IsUnicode())?
        CompareUnicodeToAscii((LPCWSTR)GetRawData(), szOther):
        strcmp((LPCSTR)GetRawData(), szOther);
}

int CCompressedString::CompareUnicodeToAscii( UNALIGNED const wchar_t* wszFirst,
                                                    LPCSTR szSecond)
{
    UNALIGNED const WCHAR* pwc = wszFirst;
    const unsigned char* pc = (const unsigned char*)szSecond;
    while(*pc)
    {        
        if(*pwc != (WCHAR)*pc)
        {
            return (int)*pwc - (int)*pc;
        }
        pc++; pwc++;
    }
    return (*pwc)?1:0;
}

int CCompressedString::CompareNoCase(
                            READ_ONLY const CCompressedString& csOther) const
{
    return (csOther.IsUnicode())?
        CompareNoCase((LPCWSTR)csOther.GetRawData()):
        CompareNoCase((LPCSTR)csOther.GetRawData());
}

int CCompressedString::CompareNoCase(READ_ONLY LPCSTR szOther) const
{
    return (IsUnicode())?
        CompareUnicodeToAsciiNoCase((LPCWSTR)GetRawData(), szOther):
        wbem_ncsicmp((LPCSTR)GetRawData(), szOther);
}

int CCompressedString::CompareNoCase(READ_ONLY LPCWSTR wszOther) const
{
    return (IsUnicode())?
        wbem_unaligned_wcsicmp((LPCWSTR)GetRawData(), wszOther):
        - CompareUnicodeToAsciiNoCase(wszOther, (LPCSTR)GetRawData());
}

int CCompressedString::CheapCompare(
                             READ_ONLY const CCompressedString& csOther) const
{
    if(IsUnicode())
    {
        if(csOther.IsUnicode())
            return wbem_unaligned_wcsicmp((LPCWSTR)GetRawData(), 
                                (LPCWSTR)csOther.GetRawData());
        else
            return CompareUnicodeToAscii((LPCWSTR)GetRawData(), 
                                          (LPCSTR)csOther.GetRawData());
    }
    else
    {
        if(csOther.IsUnicode())
            return -CompareUnicodeToAscii((LPCWSTR)csOther.GetRawData(), 
                                           (LPCSTR)GetRawData());
        else
            return wbem_ncsicmp((LPCSTR)GetRawData(), 
                                (LPCSTR)csOther.GetRawData());
    }
}

int CCompressedString::CompareUnicodeToAsciiNoCase( UNALIGNED const wchar_t* wszFirst,
                                                    LPCSTR szSecond,
                                                    int nMax)
{
    UNALIGNED const WCHAR* pwc = wszFirst;
    const unsigned char* pc = (const unsigned char*)szSecond;
    while(nMax-- && (*pc || *pwc))
    {        
        int diff = wbem_towlower(*pwc) - wbem_towlower(*pc);
        if(diff) return diff;
        pc++; pwc++;
    }
    return 0;
}

BOOL CCompressedString::StartsWithNoCase(READ_ONLY LPCWSTR wszOther) const
{
    if(IsUnicode())
    {
        return wbem_unaligned_wcsnicmp((LPWSTR)GetRawData(), wszOther, 
									fast_wcslen(wszOther)) == 0;
    }
    else
    {
        return CompareUnicodeToAsciiNoCase(wszOther, (LPSTR)GetRawData(), 
                fast_wcslen(wszOther)) == 0;
    }
}


BOOL CCompressedString::StoreToCVar(CVar& Var) const
{
    BSTR    str = CreateBSTRCopy();

    // Check that the allocation does not fail.
    if ( NULL != str )
    {
        return Var.SetBSTR( auto_bstr(str)); // acquire
    }

    return FALSE;
}

void CCompressedString::MakeLowercase()
{
    if(IsUnicode())
    {
        WCHAR* pwc = (LPWSTR)GetRawData();
        while(*pwc)
        {
            *pwc = wbem_towlower(*pwc);
            pwc++;
        }
    }
    else
    {
        char* pc = (LPSTR)GetRawData();
        while(*pc)
        {
            *pc = (char)wbem_towlower(*pc);
            pc++;
        }
    }
}

// The following functions are designed to work even under circumstances
// in which the source and destination strings are not aligned on even
// byte boundaries (which is something that could easily happen with the
// fastobj code).  For now, I'm passing all wchar operations here, although
// we may find that for performance we may need to be abit more selective
// about when we call these functions and when we don't
        
int CCompressedString::fast_wcslen( LPCWSTR wszString )
{
    BYTE*   pbData = (BYTE*) wszString;

    // Walk the string looking for two 0 bytes next to each other.
    for( int i =0; !(!*(pbData) && !*(pbData+1) ); pbData+=2, i++ );

    return i;
}

WCHAR* CCompressedString::fast_wcscpy( WCHAR* wszDest, LPCWSTR wszSource )
{
    int nLen = fast_wcslen( wszSource );

    // Account for the NULL terminator when copying
    CopyMemory( (BYTE*) wszDest, (BYTE*) wszSource, (nLen+1) * 2 );

    return wszDest;
}

WCHAR* CCompressedString::fast_wcsncpy( WCHAR* wszDest, LPCWSTR wszSource, int nNumChars )
{
    // Account for the NULL terminator when copying
    CopyMemory( (BYTE*) wszDest, (BYTE*) wszSource, (nNumChars+1) * 2 );

    return wszDest;
}

    	
size_t CCompressedStringList::ValidateBuffer(LPMEMORY pData, size_t cbSize)
{
	
   if (cbSize < sizeof(length_t)) throw CX_Exception();

    PLENGTHT length = (PLENGTHT)pData;

    if (*length > cbSize ) throw CX_Exception();

    int cbLeft = cbSize - sizeof(length_t);

    CCompressedStringList probe;
    probe.SetData(pData);
    
	for (CCompressedString  * current = probe.GetFirst(); 
		 current != 0; 
		 current = probe.GetNext(current))
	{
		cbLeft -= current->ValidateSize(cbLeft);
		cbLeft -= probe.GetSeparatorLength();
	};
    size_t used = cbSize-cbLeft;
    if (*length < used) throw CX_Exception();
    return *length;
}

bool CCompressedString::NValidateSize(int cbMaxSize) const
{
	int length = 0;
try
{
	ValidateSize(cbMaxSize);
	return true;
}
catch(CX_Exception&)
{
	return  false;
}
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\marshalers\coreprox\hiperfenum.cpp ===
/*++

Copyright (C) 1998-2001 Microsoft Corporation

Module Name:

    HIPERFENUM.CPP

Abstract:

    Hi-Perf Enumerators

History:

--*/

#include "precomp.h"
//#include <objbase.h>
#include <stdio.h>
#include <wbemcli.h>
#include <wbemint.h>
#include <wbemcomn.h>
#include <fastall.h>
#include <cominit.h>
#include "hiperfenum.h"

/////////////////////////////////////////////////////////////////
//
//  Function:
//      CHiPerfEnum::CHiPerfEnum
//
//  Purpose:
//      Class Constructor
//
/////////////////////////////////////////////////////////////////

CHiPerfEnum::CHiPerfEnum()
:   m_aIdToObject(),
    m_aReusable(),
    m_pInstTemplate(NULL),
    m_lRefCount(0),
    m_Lock()
{
}

/////////////////////////////////////////////////////////////////
//
//  Function:
//      CHiPerfEnum::~CHiPerfEnum
//
//  Purpose:
//      Class Destructor
//
//      
/////////////////////////////////////////////////////////////////

CHiPerfEnum::~CHiPerfEnum()
{
    ClearArray();

    // Cleanup the instance
    if ( NULL != m_pInstTemplate )
    {
        m_pInstTemplate->Release();
    }
}

/////////////////////////////////////////////////////////////////
//
//  Function:
//      CHiPerfEnum::QueryInterface
//
//  Purpose:
//      Standard IUnknown Method
//
//  Inputs:
//      REFIID          riid    -   Interface Id
//
//  Outputs:
//      LPVOID FAR*     ppvObj  -   Returned interface pointer
//
//  Returns:
//      S_OK if successful.
//
//  Comments:
//      None.
//      
/////////////////////////////////////////////////////////////////

SCODE CHiPerfEnum::QueryInterface(REFIID riid, LPVOID FAR* ppvObj)
{
    if (NULL == ppvObj) return E_POINTER;
        
    *ppvObj = 0;

    if (IID_IUnknown==riid || IID_IWbemHiPerfEnum == riid)
    {
        *ppvObj = (IWbemHiPerfEnum*)this;
        AddRef();
        return NOERROR;
    }

    return ResultFromScode(E_NOINTERFACE);
}

/////////////////////////////////////////////////////////////////
//
//  Function:
//      CHiPerfEnum::AddRef
//
//  Purpose:
//      Increments Ref Count
//
//  Inputs:
//      None.
//
//  Outputs:
//      None
//
//  Returns:
//      New Ref Count
//
//  Comments:
//      None.
//      
/////////////////////////////////////////////////////////////////

ULONG CHiPerfEnum::AddRef()
{
    return InterlockedIncrement(&m_lRefCount);
}

/////////////////////////////////////////////////////////////////
//
//  Function:
//      CHiPerfEnum::Relese
//
//  Purpose:
//      Decrements Ref Count
//
//  Inputs:
//      None.
//
//  Outputs:
//      None
//
//  Returns:
//      New Ref Count
//
//  Comments:
//      None.
//      
/////////////////////////////////////////////////////////////////

ULONG CHiPerfEnum::Release()
{
    long lRef = InterlockedDecrement(&m_lRefCount);
    if (0 == lRef) delete this;
    return lRef;
}

/////////////////////////////////////////////////////////////////
//
//  Function:
//      CHiPerfEnum::AddObjects
//
//  Purpose:
//      Adds new objects to the enumeration
//
//  Inputs:
//      long            lFlags      -   Flags (must be 0)
//      ULONG           uNumObjects -   Number of Objects
//      long*           apIds       -   Object Ids
//      IWbemObjectAccess** apObj   -   Array of object pointers
//
//  Outputs:
//      None
//
//  Returns:
//      WBEM_S_NO_ERROR if successful
//
//  Comments:
//      Duplicate Ids is an error
//      this method is called by the HiPerf provider
//      
/////////////////////////////////////////////////////////////////

STDMETHODIMP 
CHiPerfEnum::AddObjects( long lFlags, ULONG uNumObjects, long* apIds, IWbemObjectAccess** apObj )
{
    HRESULT hr = WBEM_S_NO_ERROR;

    // Right now, this MUST be 0
    if ( 0L != lFlags ) return WBEM_E_INVALID_PARAMETER;

    CHiPerfLockAccess   lock( m_Lock );
    if ( !lock.IsLocked() ) return WBEM_S_TIMEDOUT;

    // Enum supplied data, allocating data objects and inserting them in order
    // into the array.
    for ( DWORD dwCtr = 0; SUCCEEDED( hr ) && dwCtr < uNumObjects; dwCtr++ )
    {
        CHiPerfEnumData*    pData = GetEnumDataPtr( apIds[dwCtr], apObj[dwCtr] );        
        if ( NULL != pData )
        {
            // Insert the new element.  Cleanup the object
            // if this fails.

            hr = InsertElement( pData );
            if ( FAILED( hr ) ) delete pData;
        }
        else
        {
            hr = WBEM_E_OUT_OF_MEMORY;
        }
    }

    return hr;
}

/////////////////////////////////////////////////////////////////
//
//  Function:
//      CHiPerfEnum::Remove
//
//  Purpose:
//      Removes specified objects from the enumeration
//
//  Inputs:
//      long            lFlags      -   Flags (must be 0)
//      ULONG           uNumObjects -   Number of Objects
//      long*           apIds       -   Object Ids
//
//  Outputs:
//      None
//
//  Returns:
//      WBEM_S_NO_ERROR if successful
//
//  Comments:
//      Invalid Ids is not an error
//      
/////////////////////////////////////////////////////////////////

STDMETHODIMP CHiPerfEnum::RemoveObjects( long lFlags, ULONG uNumObjects, long* apIds )
{
    HRESULT hr = WBEM_S_NO_ERROR;

    // Right now, this MUST be 0
    if ( 0L != lFlags ) return WBEM_E_INVALID_PARAMETER;

    CHiPerfLockAccess   lock( m_Lock );
    if ( !lock.IsLocked() ) return WBEM_S_TIMEDOUT;

    // Enum supplied ids and remove them from the array.
    for ( DWORD dwCtr = 0; SUCCEEDED( hr ) && dwCtr < uNumObjects; dwCtr++ )
    {
        hr = RemoveElement( apIds[dwCtr] );
    }
    
    return hr;
}

/////////////////////////////////////////////////////////////////
//
//  Function:
//      CHiPerfEnum::GetObjects
//
//  Purpose:
//      Retrieves objects from the enumeration
//
//  Inputs:
//      long            lFlags      -   Flags (must be 0)
//      ULONG           uNumObjects -   Number of Objects to get
//      IWbemObjectAccess** apObj   -   Array for pointer storage
//
//  Outputs:
//      ULONG*          puNumReturned - Number of objects returned
//
//  Returns:
//      WBEM_S_NO_ERROR if successful
//
//  Comments:
//      If not enough space, returns an error, with required
//      array size in puNumReturned.
//      
/////////////////////////////////////////////////////////////////

STDMETHODIMP CHiPerfEnum::GetObjects( long lFlags, ULONG uNumObjects, IWbemObjectAccess** apObj, ULONG* puNumReturned )
{
    HRESULT hr = WBEM_S_NO_ERROR;

    // Right now, this MUST be 0
    if ( 0L != lFlags ) return WBEM_E_INVALID_PARAMETER;

    CHiPerfLockAccess   lock( m_Lock );
    if ( !lock.IsLocked() ) return WBEM_S_TIMEDOUT;

    // Store how many objects we have
    *puNumReturned = m_aIdToObject.Size();

    // Make sure we have storage for our elements
    if ( uNumObjects >= m_aIdToObject.Size() )
    {
        DWORD   dwCtr = 0;

        // Write the objects out to the array
        for ( dwCtr = 0; dwCtr < m_aIdToObject.Size(); dwCtr++ )
        {
            apObj[dwCtr] = ((CHiPerfEnumData*) m_aIdToObject[dwCtr])->GetObject();
        }
    }
    else
    {
        hr = WBEM_E_BUFFER_TOO_SMALL;
    }

    return hr;
}

/////////////////////////////////////////////////////////////////
//
//  Function:
//      CHiPerfEnum::RemoveAll
//
//  Purpose:
//      Removes all objects from the enumeration
//
//  Inputs:
//      long            lFlags      -   Flags (must be 0)
//
//  Outputs:
//      None
//
//  Returns:
//      WBEM_S_NO_ERROR if successful
//
//  Comments:
//      Empty list is not an error
//      
/////////////////////////////////////////////////////////////////

STDMETHODIMP CHiPerfEnum::RemoveAll( long lFlags )
{
    HRESULT hr = WBEM_S_NO_ERROR;

    // Right now, this MUST be 0
    if ( 0L != lFlags ) return WBEM_E_INVALID_PARAMETER;

    CHiPerfLockAccess   lock( m_Lock );
    if ( !lock.IsLocked() ) return WBEM_S_TIMEDOUT;
    
    // Clear each pointer in the array and move it to the
    // reusable array
    for ( DWORD dwCtr = 0; dwCtr < m_aIdToObject.Size(); dwCtr++ )
    {
        // Delete non-NULL elements
        if ( NULL != m_aIdToObject[dwCtr] )
        {
            ((CHiPerfEnumData*) m_aIdToObject[dwCtr])->Clear();
            m_aReusable.Add( m_aIdToObject[dwCtr] );
        }
    }
    m_aIdToObject.Empty();
    
    return hr;
}

/////////////////////////////////////////////////////////////////
//
//  Function:
//      CHiPerfEnum::InsertElement
//
//  Purpose:
//      Searches for proper location in array and inserts new
//      element into the array.
//
//  Inputs:
//      CHiPerfEnumData*    pData - Pointer to Obj/Id data
//
//  Outputs:
//      None.
//
//  Returns:
//      WBEM_S_NO_ERROR if successful
//
//  Comments:
//      Performs a binary search
//      
/////////////////////////////////////////////////////////////////

HRESULT CHiPerfEnum::InsertElement( CHiPerfEnumData* pData )
{
    HRESULT hr = WBEM_S_NO_ERROR;

    DWORD   dwLowIndex = 0,
            dwHighIndex = m_aIdToObject.Size();

    // If the id of the object we are hunting for is > the id 
    // of the last id in the array, we can insert at the end

    // Only set pLastData if the high index is greater than 0.  If it is not, then we will
    // automatically pass the following test ( 0 == dwHighIndex ).

    CHiPerfEnumData*    pLastData = ( dwHighIndex > 0 ? (CHiPerfEnumData*) m_aIdToObject[dwHighIndex - 1] : NULL );

    if ( 0 == dwHighIndex || pLastData->GetId() > pData->GetId() )
    {
        // Binary search of the ids to find an index at which to insert
        // If we find our element, this is a failure.

        while ( SUCCEEDED( hr ) && dwLowIndex < dwHighIndex )
        {
            DWORD   dwMid = (dwLowIndex + dwHighIndex) / 2;

            if ( ((CHiPerfEnumData*) m_aIdToObject[dwMid])->GetId() < pData->GetId() )
            {
                dwLowIndex = dwMid + 1;
            }
            else if ( ((CHiPerfEnumData*) m_aIdToObject[dwMid])->GetId() > pData->GetId() )
            {
                dwHighIndex = dwMid;
            }
            else
            {
                // Index already exists
                hr = WBEM_E_FAILED;
            }
        }   // WHILE looking for index
    }
    else if ( 0 != dwHighIndex && pLastData->GetId() == pData->GetId() )
    {
        hr = WBEM_E_FAILED;
    }
    else
    {
        dwLowIndex = dwHighIndex;
    }

    // Stick it in
    if ( SUCCEEDED( hr ) )
    {
        if ( m_aIdToObject.InsertAt( dwLowIndex, pData ) != CFlexArray::no_error )
        {
            hr = WBEM_E_OUT_OF_MEMORY;
        }
    }

    return hr;
}

/////////////////////////////////////////////////////////////////
//
//  Function:
//      CHiPerfEnum::RemoveElement
//
//  Purpose:
//      Searches for specified id in array and removes the element.
//
//  Inputs:
//      long            lId - Id of element to remove
//
//  Outputs:
//      None.
//
//  Returns:
//      WBEM_S_NO_ERROR if successful
//
//  Comments:
//      Performs a binary search
//      
/////////////////////////////////////////////////////////////////

HRESULT CHiPerfEnum::RemoveElement( long lId )
{
    HRESULT hr = WBEM_S_NO_ERROR;

    DWORD   dwLowIndex = 0,
            dwHighIndex = m_aIdToObject.Size() - 1;

    // Don't continue if no elements
    if ( m_aIdToObject.Size() > 0 )
    {
        // Binary search of the ids to find the index at which the
        // object should exist.

        while ( dwLowIndex < dwHighIndex )
        {
            DWORD   dwMid = (dwLowIndex + dwHighIndex) / 2;

            if ( ((CHiPerfEnumData*) m_aIdToObject[dwMid])->GetId() < lId )
            {
                dwLowIndex = dwMid + 1;
            }
            else
            {
                dwHighIndex = dwMid;
            }
        }   // WHILE looking for index

        // If it doesn't exist, it doesn't get removed.  Not a failure condition
        if ( ((CHiPerfEnumData*) m_aIdToObject[dwLowIndex])->GetId() == lId )
        {
            // Clear and move to the reusable array
            ((CHiPerfEnumData*) m_aIdToObject[dwLowIndex])->Clear();

            if ( m_aReusable.Add( m_aIdToObject[dwLowIndex] ) != CFlexArray::no_error )
            {
                hr = WBEM_E_OUT_OF_MEMORY;
            }
            else
            {
                m_aIdToObject.RemoveAt( dwLowIndex );
            }
        }
    }

    return hr;
}

/////////////////////////////////////////////////////////////////
//
//  Function:
//      CHiPerfEnum::ClearArray
//
//  Purpose:
//      Empties out our array
//
//  Inputs:
//      None.
//
//  Outputs:
//      None.
//
//  Returns:
//      None
//
//  Comments:
//      None.
//      
/////////////////////////////////////////////////////////////////

void CHiPerfEnum::ClearArray( void )
{

    // Clear out the all the elements
    m_aIdToObject.Clear();
    m_aReusable.Clear();

    // Now empty the arrays
    m_aIdToObject.Empty();
    m_aReusable.Empty();

}

/////////////////////////////////////////////////////////////////
//
//  Function:
//      CHiPerfEnum::GetEnumDataPtr
//
//  Purpose:
//      Retrieves an HPEnumData pointer from the reusable array
//      or allocates one as necessary.
//
//  Inputs:
//      long                lId - ID of the object
//      IWbemObjectAccess*  pObj - Object to put in data.
//
//  Outputs:
//      None.
//
//  Returns:
//      CHiPerfEnumData*    pData - NULL if error
//
//  Comments:
//      None.
//      
/////////////////////////////////////////////////////////////////

CHiPerfEnumData* CHiPerfEnum::GetEnumDataPtr( long lId, IWbemObjectAccess* pObj )
{

    CHiPerfEnumData*    pData = NULL;

    if ( 0 != m_aReusable.Size() )
    {
        pData = (CHiPerfEnumData*) m_aReusable[ m_aReusable.Size() - 1 ];
        m_aReusable.RemoveAt( m_aReusable.Size() - 1 );
        pData->SetData( lId, pObj );
    }
    else
    {
        pData = new CHiPerfEnumData( lId, pObj );
    }

    return pData;
}

/////////////////////////////////////////////////////////////////
//
//  Function:
//      CHiPerfEnum::SetInstanceTemplate
//
//  Purpose:
//      Saves the instance template we'll use for cloning.
//
//  Inputs:
//      CWbemInstanc*   pInst = NULL.
//
//  Outputs:
//      None.
//
//  Returns:
//      WBEM_S_NO_ERROR if success
//
//  Comments:
//      We will change to a shared class part to conserve
//      memory usage.
//      
/////////////////////////////////////////////////////////////////

HRESULT CHiPerfEnum::SetInstanceTemplate( CWbemInstance* pInst )
{
    HRESULT hr = WBEM_S_NO_ERROR;

    // We convert to a merged instance first to help conserve memory if we use it.
    if ( pInst )
    {
        hr = pInst->ConvertToMergedInstance();
        if (FAILED(hr)) return hr;
        pInst->AddRef();
    }

    // Now, if everything's okay, reset the template
    if ( SUCCEEDED(hr) )
    {
        if ( m_pInstTemplate ) m_pInstTemplate->Release();
        m_pInstTemplate = pInst;
    }

    return hr;
}

// Because we insert and remove elements from the end of the array, the elements
// at the beginning represent the least-recently-used (lru) elements.  Our algorithm
// for cleanup is as follows:

// Cleanup the expired elements (this will be the elements at the front of the array)
// Get the number of elements remaining 
// The number of pending elements becomes the number of expired elements
// subtract the number of pending elements from the number of elements remaining
// the difference is now the number of pending elements.

BOOL CGarbageCollectArray::GarbageCollect( int nNumToGarbageCollect /*= HPENUMARRAY_GC_DEFAULT*/ )
{
    // Make sure our params are okay

    if ( m_fClearFromFront )
    {
        if ( nNumToGarbageCollect != HPENUMARRAY_GC_DEFAULT )
        {
            _ASSERT(0,"Must be default for garbage collection!" );
            return FALSE;
        }

        nNumToGarbageCollect = m_nSize;
    }
    else if ( nNumToGarbageCollect < 0 )
    {
        _ASSERT(0,"Negative number of elements to garbage collect!" );
        return FALSE;
    }

    // This will tell us how many elements were in the array last time
    // we went through this
    int nLastTotal = m_nNumElementsExpired + m_nNumElementsPending;

    // If we had more elements last time than the number free this time,
    // we clear out expired elements, and if any pending elements are
    // left, we move them to expired
    if ( nLastTotal > nNumToGarbageCollect )
    {
        // Get rid of expired elements
        if ( m_nNumElementsExpired > 0 )
        {
            int nNumExpired = min( m_nNumElementsExpired, nNumToGarbageCollect );

            m_nNumElementsExpired = nNumExpired;
            ClearExpiredElements();
            nNumToGarbageCollect -= nNumExpired;
        }

        // The new number of expired elements is the minimum of the number
        // to garbage collect anf the number of remaining elements to
        // garbage collect.
        m_nNumElementsExpired = min( m_nNumElementsPending, nNumToGarbageCollect );

        // Since there were less elements this time than before, we will
        // assume that everything has been accounted for.
        m_nNumElementsPending = 0;
    }
    else
    {
        // Get rid of expired elements 
        ClearExpiredElements();

        // Use the current garbage collection size
        int nNumElToUpdate = nNumToGarbageCollect;

        // If we already have pending elements, these are now expired.
        if ( m_nNumElementsPending > 0 )
        {
            m_nNumElementsExpired = m_nNumElementsPending;
            nNumElToUpdate -= m_nNumElementsPending;
        }

        // The number of elements remaining after we accounted
        // for expired elements is now the number of pending
        // elements.

        m_nNumElementsPending = nNumElToUpdate;
    }

    return TRUE;
}

void CGarbageCollectArray::Clear( int nNumToClear /*= HPENUMARRAY_ALL_ELEMENTS*/ )
{
    nNumToClear = ( nNumToClear == HPENUMARRAY_ALL_ELEMENTS ?
                        m_nSize : nNumToClear );

    // Perform the proper per Element cleanup
    ClearElements( nNumToClear );

    // If we cleared all the elements, set the size to 0
    // otherwise, we'll need to do a fancy memory move
    if ( nNumToClear == m_nSize )
    {
        m_nSize = 0;
    }
    else
    {
        // If we garbage collect from the front, we need to move the memory block, otherwise,
        // we just drop the size.

        if ( m_fClearFromFront )
        {
            // Just shift everything over by nNumToClear elements
            MoveMemory( &m_pArray[0], &m_pArray[nNumToClear], ( ( m_nSize - nNumToClear ) * sizeof(void *) ) );
        }
        m_nSize -= nNumToClear;
    }
}

// Walks the array and cleans up the specified number of elements
void CHPEnumDataArray::ClearElements( int nNumToClear )
{
    for ( int nCtr = 0; nCtr < nNumToClear; nCtr++ )
    {
        CHiPerfEnumData*    pData = (CHiPerfEnumData*) GetAt(nCtr);

        _ASSERT( NULL != pData, "Tried to clear a NULL Element!" );
        if ( NULL != pData )
        {
            delete pData;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\marshalers\coreprox\fastval.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    FASTVAL.H

Abstract:

  This file defines the classes related to value representation

  Classes defined: 
      CType               Representing property type
      CUntypedValue       A value with otherwise known type.
      CTypedValue         A value with stored type.
      CUntypedArray       Array of values of otherwise known type.

History:

  2/21/97     a-levn  Fully documented
  12//17/98	sanjes -	Partially Reviewed for Out of Memory.

--*/

#ifndef __FAST_VALUES__H_
#define __FAST_VALUES__H_

#include "corepol.h"
#include "faststr.h"
#include "fastheap.h"
#include "fastembd.h"

#pragma pack(push, 1)

#define CIMTYPE_EX_ISNULL 0x8000
#define CIMTYPE_EX_PARENTS 0x4000
#define CIMTYPE_BASIC_MASK 0xFFF
#define CIMTYPE_TYPE_MASK  (CIMTYPE_BASIC_MASK | CIM_FLAG_ARRAY)

//*****************************************************************************
//*****************************************************************************
//
//  class CType
//
//  This class encapsulates the notion of a value type. It is based on CIMTYPE
//  but with its higher-order bits (unused by CIMTYPE types) are used to
//  store other information, making the whole thing very ugly, but concise.
//
//  Most member functions of this class exist in two forms: static and 
//  non-static. Since the data store for CType is simply a CIMTYPE it is 
//  convinient to invoke the member functions giving the CIMTYPE (referred to
//  as Type_t) as the first parameter, rather than casting it to CType and then
//  calling the function.
//
//  We document only non-static versions, since the static ones are simply
//  C-versions of same.
//
//*****************************************************************************
//
//  GetLength
//
//  Returns the length of data for this particular type. For instance, for
//  a short integer (CIM_SINT16) the answer is 2, and for a string (CIM_STRING) the
//  answer is 4, since only the pointer is stored. Similarily, arrays take
//  4, since only the pointer is stored.
//
//  Returns:
//
//      length_t
//
//*****************************************************************************
//
//  GetActualType
//
//  Strips the extra information stored in the higher bits and returns the
//  actual CIM_xx value.
//
//  Returns:
//
//      Type_t
//
//*****************************************************************************
//
//  GetBasic
//
//  For arrays, returns the type of the element. For non-arrays, synonimous 
//  with GetActualType.
//
//  Returns:
//
//      Type_t
//
//*****************************************************************************
//
//  IsArray
//
//  Checks if this type represents an array
//
//  Returns:
//
//      BOOL:   TRUE if it is an array
//
//*****************************************************************************
//
//  static MakeArray
//
//  Converts a basic type into the type for array of such types.
//
//  Parameters:
//
//      Type_t nType        Basic type to convert.
//
//  Returns:
//
//      Type_t: resulting array type.
//
//*****************************************************************************
//
//  static MakeNotArray
//
//  Retrieves the element type from an array type.
//
//  Parameters:
//
//      Type_t nType        Array type.
//
//  Returns:
//
//      Type_t: element type.
//
//*****************************************************************************
//
//  IsPointerType
//
//  Checks if the data for this type is represented as a pointer, rather than
//  the data itself (e.g., CIM_STRING, arrays).
//
//  Returns:
//
//      BOOL
//
//*****************************************************************************
//
//  static VARTYPEToType
//
//  Converts an actual VARTYPE to our own type (CIMTYPE)
//
//  Parameters:
//
//      VARTYPE vt      The type to convert.
//
//  Returns:
//
//      Type_t: converted type.
//
//*****************************************************************************
//
//  static CVarToType
//
//  Helper function that extracts *our* type from CVar (using VARTYPEToType).
//
//  Parameters:
//
//      [in, readonly] CVar& v      The CVar to get the type from
//  
//  Returns:
//
//      Type_t: converted type.
//
//*****************************************************************************
//
//  GetVARTYPE
//
//  Creates a type for the VARIANT with which our type can be represented.
//
//  Returns:
//
//      VARTYPE: proper type for a VARIANT.
//
//*****************************************************************************
//
//  CanBeKey
//
//  Determines if a property of this type can serve as a key for a class (for
//  instance, floating point properties may not).
//
//  Returns:
//
//      TRUE if it can, FALSE if it can't.
//
//*****************************************************************************
//
//  IsParents
//
//  Test one of those higher bits in which the information on the property
//  origin is stored. Namely, the bit is set if the property came from a parent
//  class, as opposed to being defined in this class. It is set even if the
//  property is overriden in this class.
//
//  Returns:
//
//      BOOL
//
//*****************************************************************************
//
//  static MakeParents
//
//  Ensures that the "came from parent" bit is set in the type.
//
//  Parameters:
//
//      [in] Type_t nType       Original type.
//
//  Returns:
//
//      Type_t with the parent's bit set.
//
//*****************************************************************************
//
//  static MakeLocal
//
//  Ensures that the "came from parent" bit is not set in the type.
//
//  Parameters:
//
//      [in] Type_t nType       Original type.
//
//  Returns:
//
//      Type_t with the parent's bit reset.
//
//*****************************************************************************

#define MAXIMUM_FIXED_DATA_LENGTH 20


class COREPROX_POLARITY CType
{
private:

protected:
    Type_t m_nType;
public:
    inline CType() : m_nType(CIM_EMPTY) {}
    inline CType(Type_t nType) : m_nType(nType){}
    inline operator Type_t() {return m_nType;}

    static length_t GetLength(Type_t nType);
    inline length_t GetLength() {return GetLength(m_nType);}

    static inline Type_t GetBasic(Type_t nType) {return nType & CIMTYPE_BASIC_MASK;}
    inline Type_t GetBasic() {return GetBasic(m_nType);}

    static inline BOOL IsArray(Type_t nType) {return nType & CIM_FLAG_ARRAY;}
    inline BOOL IsArray() {return IsArray(m_nType);}
    static inline Type_t MakeArray(Type_t nType) {return nType | CIM_FLAG_ARRAY;}
    static inline Type_t MakeNotArray(Type_t nType) {return nType & ~CIM_FLAG_ARRAY;}

    static inline BOOL IsParents(Type_t nType) {return nType & CIMTYPE_EX_PARENTS;}
    inline BOOL IsParents() {return IsParents(m_nType);}
    static inline Type_t MakeParents(Type_t nType) 
        {return nType | CIMTYPE_EX_PARENTS;}
    static inline Type_t MakeLocal(Type_t nType) 
        {return nType & ~CIMTYPE_EX_PARENTS;}

    static BOOL IsPointerType(Type_t nType);
    BOOL IsPointerType() {return IsPointerType(m_nType);}

    static BOOL IsNonArrayPointerType(Type_t nType);
    BOOL IsNonArrayPointerType() {return IsNonArrayPointerType(m_nType);}

    static BOOL IsStringType(Type_t nType);
    BOOL IsStringType() {return IsStringType(m_nType);}

    static inline Type_t GetActualType(Type_t nType) 
        {return nType & CIMTYPE_TYPE_MASK;}
    inline Type_t GetActualType() {return GetActualType(m_nType);}

    static BOOL IsValidActualType(Type_t nType);

    static CType VARTYPEToType(VARTYPE vt);

    static inline CType CVarToType(CVar& v)
    {
        if(v.GetType() == VT_EX_CVARVECTOR)
        {
            return VARTYPEToType( (VARTYPE) v.GetVarVector()->GetType() ) | CIM_FLAG_ARRAY;
        }
        else return VARTYPEToType( (VARTYPE) v.GetType() );
    }

    static VARTYPE GetVARTYPE(Type_t nType);
    
    inline VARTYPE GetVARTYPE()
        {return GetVARTYPE(m_nType);}

    static BOOL DoesCIMTYPEMatchVARTYPE(CIMTYPE ct, VARTYPE vt);

    static BOOL IsMemCopyAble(VARTYPE vtFrom, CIMTYPE ctTo);

    static BOOL CanBeKey(Type_t nType);

    static LPWSTR GetSyntax(Type_t nType);
    inline LPWSTR GetSyntax()
        {return GetSyntax(m_nType);}

    static void AddPropertyType(WString& wsText, LPCWSTR wszSyntax);
};

//*****************************************************************************
//*****************************************************************************
//
//  class CUntypedValue
//
//  This class represents a value whose type is known by external means and is
//  not stores with the value. An example would be the value of a property in
//  an instance --- its type is known from the class definition.
//
//  All values are represented by a fixed number of bytes, determined by the
//  type. Variable length types (like strings and arrays) are allocated on the
//  heap (CFastHeap) and only the heap pointer is stored in a CUntypedValue.
//
//  CUntypedValue is another one of those classes where 'this' pointer points 
//  to the actual data. As such, it has no data members, just the knowledge 
//  that 'this' is where the data starts.
//
//*****************************************************************************
//
//  GetRawData
//
//  Returns a pointer to the beginning of the data.
//
//  Returns:
//
//      LPMEMORY
//
//*****************************************************************************
//
//  AccessPtrData
//
//  Helper function for those types that store a heap pointer in the value and
//  the actual data on the heap. 
//
//  Returns:
//
//      heapptr_t&: a reference to the heapptr_t stored in the value, i.e., the
//                  first 4 bytes after 'this'.
//
//*****************************************************************************
//
//  StoreToCVar
//
//  Transfers its contents into a CVar.
//
//  Parameters:
//
//      [in] CType Type                 The type of the data stored here. 
//      [in, modified] CVar& Var,       Destination.
//      [in, readonly] CFastHeap* pHeap The heap where the actual data may 
//                                      reside (if we contain a heap pointer).
//
//*****************************************************************************
//
//  static LoadFromCVar
//
//  This static function loads the data from a CVar into the specified 
//  CUntypedValue. The reason it is static is weird:
//
//      While transfering the data, we may need to allocate something on the 
//      heap. If there is not enough space, the heap may grow, causing the 
//      whole object to reallocate. But our 'this' pointer points to our data,
//      so if our data moves, our 'this' pointer will have to be changed!!!
//      That's impossible, thus this function is static, and takes a pointer
//      source instead of a pointer.
//
//  Parameters:
//
//      [in] CPtrSource* pThis          The source (see fastsprt.h) of the  
//                                      data pointer. The C value of the data
//                                      pointer may change during the execution
//                                      of this functioin, hence the source.
//      [in, readonly] CVar& Var        Destination.
//      [in, modified] CFastHeap* pHeap The heap where any extra data (like 
//                                      strings or arrays) needs to be
//                                      allocated.
//      [in] BOOL bUseOld               If TRUE, the function will attempt to 
//                                      reuse old memory on the heap. For
//                                      instance, if the data contained a
//                                      string and the new string is shorter
//                                      that the old one, than no new heap
//                                      allocations will be necessary.
//
//*****************************************************************************
//
//  static TranslateToNewHeap
//
//  If the data contained in this value is heap-related (strings, arrays), this
//  function copies those pieces of data from one heap to another and changes
//  the pointer stored in it. It does not copy its own data (the one after 
//  'this' pointer) (see CopyTo for that). It does not Free the data on the old
//  heap (see Delete for that).
//
//  For the reason why this function is static, see LoadFromCVar above.
//
//  Parameters:
//
//      [in] CPtrSource* pThis          The source (see fastsprt.h) of the 
//                                      data pointer. The C value of the data
//                                      pointer may change during the execution
//                                      of this functioin, hence the source.
//      [in] CType Type                 The type of the value.
//      [in, readonly] 
//          CFastHeap* pOldHeap         The heap where the data currently is.
//      [in, modified]
//          CFastHeap* pNewHeap         The heap where the data should go to.
//      
//*****************************************************************************
//
//  static CopyTo
//
//  Copies untyped value from one location to another. For an explanation why
//  this function is static, see LoadFromCVar. Note; in addition to copying
//  its own data, the function will also move any related heap data to the new
//  heap (see TranslateToNewHeap).
//
//  Parameters:
//
//      [in] CPtrSource* pThis          The source (see fastsprt.h) of the 
//                                      data pointer. The C value of the data
//                                      pointer may change during the execution
//                                      of this functioin, hence the source.
//      [in] CType Type                 The type of the value.
//      [in] CPtrSource* pDest          The source of the destination data 
//                                      pointer. The C value of this pointer
//                                      may also change, hence the source.
//      [in, readonly] 
//          CFastHeap* pOldHeap         The heap where the related heap data 
//                                      currently resides
//      [in, modified]
//          CFastHeap* pNewHeap         The heap where the related heap data 
//                                      should go to.
//      
//*****************************************************************************
//
//  Delete
//
//  Frees any related data on the heap (strings, arrays).
//
//  Parameters:
//
//      CType Type          the type of the value
//      CFastHeap* pHeap    the heap where the related heap data is.
//
//*****************************************************************************

class CUntypedValue
{
protected:
    BYTE m_placeholder[MAXIMUM_FIXED_DATA_LENGTH];
public:
     CUntypedValue(){}
     LPMEMORY GetRawData() {return (LPMEMORY)this;}
     UNALIGNED heapptr_t& AccessPtrData() {return *(UNALIGNED heapptr_t*)GetRawData();}
public:
     BOOL StoreToCVar(CType Type, CVar& Var, CFastHeap* pHeap, BOOL fOptimize = FALSE);
     static HRESULT LoadFromCVar(CPtrSource* pThis,
        CVar& Var, Type_t nType, CFastHeap* pHeap, Type_t& nReturnType, BOOL bUseOld = FALSE);
     static HRESULT LoadFromCVar(CPtrSource* pThis,
        CVar& Var, CFastHeap* pHeap, Type_t& nReturnType, BOOL bUseOld = FALSE);

	 static HRESULT LoadUserBuffFromCVar( Type_t type, CVar* pVar, ULONG uBuffSize, ULONG* puBuffSizeUsed,
			LPVOID pBuff );
	static HRESULT FillCVarFromUserBuffer( Type_t type, CVar* pVar, ULONG uBuffSize, LPVOID pData );

public:
     static BOOL TranslateToNewHeap(CPtrSource* pThis,
        CType Type, CFastHeap* pOldHeap, CFastHeap* pNewHeap);
     static BOOL CopyTo(CPtrSource* pThis, CType Type, CPtrSource* pDest,
                        CFastHeap* pOldHeap, CFastHeap* pNewHeap);
     void Delete(CType Type, CFastHeap* pHeap);
    static BOOL CheckCVar(CVar& Var, Type_t nInherentType);
    static BOOL CheckIntervalDateTime(CVar& Var);
    static BOOL DoesTypeNeedChecking(Type_t nInherentType);
};

//*****************************************************************************
//*****************************************************************************
//
//  class CTypedValue
//
//  CTypedValue is exactly the same as CUntypedValue (above) except that the
//  type of the value is stored with the value itself (in fact, the type comes
//  first, followed by the value). This kind of values is used where the type 
//  is not otherwise known, as in the case of qualifiers.
//
//  Most CTypedValue methods are the same as their CUntypedValue counterparts
//  but without the Type parameter.
//
//*****************************************************************************
//
//  GetStart
//
//  Returns:
//
//      LPMEMORY:   the address of the memory block of the value.
//
//*****************************************************************************
//
//  GetLength
//
//  Returns:
//
//      length_t:   the lenght of the block of the value (type and data).
//
//*****************************************************************************
//
//  Skip
//
//  Returns:
//
//      LPMEMORY:   points to the first byte after this value's memory block.
//
//*****************************************************************************
//
//  GetType
//
//  Returns:
//
//      CType&:     reference to the type informtation.
//
//*****************************************************************************
//
//  GetRawData
//
//  Returns:
//
//      LPMEMORY:   the pointer to the raw data in the value, i.e., the first
//                  byte of the data.
//
//*****************************************************************************
//
//  AccessPtrData
//
//  Helper function that assumes that the type is one of the pointer types, i.e
//  that the data contains a heap pointer.
//
//  Returns:
//
//      heapptr_t&: the data in the value interpreted as a heapptr_t.
//
//*****************************************************************************
//
//  GetBool
//
//  Helper function that assumes that the type is CIM_BOOLEAN and gets the 
//  boolean value.
//
//  Returns:
//
//      VARIANT_BOOL:   the data in the value interpreted as VARIANT_BOOL.
//
//*****************************************************************************
//
//  TranslateToNewHeap
//
//  Translates the contents of a typed value to use a different heap. Namely, 
//  if the data in the value represents a heap pointer (as with strings or
//  arrays) the data on the heap is copied to the new heap and the heap pointer
//  is replaced with the new value.
//
//  The reason this function is static can be found in 
//  CUntypedValue::LoacFromCVar comment.
//
//  Parameters:
//
//      CPtrSource* pThis       The source of the pointer to this typed value.
//                              The C value of the pointer can change as we
//                              execute, hence the source is used.
//      CFastHeap* pOldHeap     The heap where the current heap data is found.
//      CFastHeap* pNewHeap     The heap where the heap data should move to.
//
//*****************************************************************************
//
//  CopyTo
//
//  Copies this value to another location. 
//  NOTE: UNLIKE OTHER CopyTo FUNCTIONS, HEAP TRANSLATEION IS NOT PERFORMED.
//  For that, see TranslteToNewHeap. 
//
//  Parameters:
//
//      CTypedValue* pDestination   Destination. Since no heap operations
//                                  occur, this pointer cannot move, and so
//                                  sourcing is not necessary.
//
//*****************************************************************************
//
//  StoreToCVar
//
//  Transfers the contents of a value into a CVar. See 
//  CUntypedValue::StoreToCVar for more information.
//
//  Parameters:
//
//      [in, modified] CVar& Var,       Destination.
//      [in, readonly] CFastHeap* pHeap The heap where the actual data may 
//                                      reside (if we contain a heap pointer).
//
//*****************************************************************************
//
//  static ComputeNecessarySpace
//
//  Computes the size of the memory block needed to hold a typed value
//  representing a given CVar. That size does not include any data that will
//  go on the heap.
//
//  Parameters:
//
//      CVar& Var       The CVar containing the value.
//
//  Returns:
//
//      lenght_t:   the length required for a CTypedValue.
//
//*****************************************************************************
//
//  static LoadFromCVar
//
//  This function loads a CTypedValue from a CVar. For the explanation of why
//  it has to be static, see CUntypedValue::LoadFromCVar.
//
//  Parameters:
//
//      CPtrSource* pThis       The source of the CTypedValue pointer to load
//                              into. Its C value may change during execution,
//                              hence the sourcing.
//      CVar& Var               The CVar to load from.
//      CFastHeap* pHeap        The heap to store extra data (strings, arrays)
//
//*****************************************************************************
//
//  Delete
//
//  Frees whatever data this value has on the heap.
//
//  Parameters:
//
//      CFastHeap* pHeap        The heap where this value stores its extra data
//                              (strings, arrays).
//
//*****************************************************************************
//
//  Compare
//
//  Compares the value stored to a VARIANT.
//
//  Parameters:
//
//      VARIANT* pVariant       The VARIANT to compare to.
//      CFastHeap* pHeap        the heap where this value keeps its extra data
//                              (strings, arrays).
//  Returns:
//
//      0               if the values are the same.
//      0x7FFFFFFF      if the values are incomparable (different types)
//      < 0             if our value is smaller.
//      > 0             if the VARIANT's value is smaller.
//
//*****************************************************************************

class CTypedValue
{
    CType Type;
    CUntypedValue Value; 

public:
     CTypedValue(){}

	 CTypedValue( Type_t nType, LPMEMORY pbData ) : Type( nType )
	 {	CopyMemory( &Value, pbData, Type.GetLength() ); }


     LPMEMORY GetStart() {return (LPMEMORY)this;}
     length_t GetLength() {return sizeof(CType) + Type.GetLength();}
     LPMEMORY Skip() {return GetStart() + GetLength();}

    static  CTypedValue* GetPointer(CPtrSource* pSource)
        {return (CTypedValue*)pSource->GetPointer();}
public:
     LPMEMORY GetRawData() {return Value.GetRawData();}
     UNALIGNED heapptr_t& AccessPtrData() {return Value.AccessPtrData();}
     CType& GetType() {return Type;}

     VARIANT_BOOL GetBool() {return *(UNALIGNED VARIANT_BOOL*)GetRawData();}
public:
     static BOOL TranslateToNewHeap(CPtrSource* pThis,
        CFastHeap* pOldHeap, CFastHeap* pNewHeap)
    {
        CShiftedPtr Shifted(pThis, sizeof(CType));
        return CUntypedValue::TranslateToNewHeap(&Shifted, 
				CTypedValue::GetPointer(pThis)->Type, pOldHeap, pNewHeap);
    }
    
     void CopyTo(CTypedValue* pNewLocation) 
    {
        memcpy((LPVOID)pNewLocation, this, GetLength());
    }
    
     void Delete(CFastHeap* pHeap) {Value.Delete(Type, pHeap);}

public:
    BOOL StoreToCVar(CVar& Var, CFastHeap* pHeap)
    {
        return Value.StoreToCVar(Type, Var, pHeap);
    }
    static  length_t ComputeNecessarySpace(CVar& Var)
    {
        return CType::GetLength(Var.GetType()) + sizeof(CTypedValue); 
    }
     static HRESULT LoadFromCVar(CPtrSource* pThis, CVar& Var, 
        CFastHeap* pHeap)
    {
        CShiftedPtr Shifted(pThis, sizeof(CType));

		// Check for allocation failures
        Type_t nType;
		HRESULT hr = CUntypedValue::LoadFromCVar(&Shifted, Var, pHeap, nType);

		if ( FAILED(hr) )
		{
			return hr;
		}

		// Unable to load because of a type mismatch
        if(nType == CIM_ILLEGAL)
		{
			return WBEM_E_TYPE_MISMATCH;
		}

        ((CTypedValue*)(pThis->GetPointer()))->Type = nType;
        return hr;
    }

};

//*****************************************************************************
//*****************************************************************************
//
//  class CUntypedArray
//
//  This class represents an array of values of a type that is otherwise known.
//  All the items in the array are of the same type and the type is not stored
//  anywhere. In effect, this class is simply an array of CUntypedValues. Since
//  all the values are of the same type and all our types are fixed length 
//  (variable-length data such as strings is stored on the heap), access to any
//  given element is O(1).
//
//  The in-memory layout of the array (pointed to by its 'this' pointer) is:
//
//  int: number of elements
//  followed by that many elements,
//
//*****************************************************************************
//
//  GetNumElements
//
//  Returns:
//
//      int:    the number of elements in the array.
//
//*****************************************************************************
//
//  static GetHeaderLength
//
//  Returns the amount of space taken up by the array's header (currently, the
//  header contains just the number of elements).
//
//*****************************************************************************
//
//  GetElement
//
//  Finds an element of the array by its index.
//
//  Parameters:
//
//      int nIndex      The index of the element to read.
//      int nSize       The size of each element in the array (see 
//                          CType::GetLength to get it).
//
//*****************************************************************************
//
//  GetLength
//
//  Returns the length of the array in bytes.
//
//  Parameters:
//
//      CType Type      Type of elements in the array (it doesn't know).
//
//  Returns:
//
//      length_t: number of bytes.
//
//*****************************************************************************
//
//  CreateCVarVector
//
//  Allocates a new CVarVector (see var.h) and initializes it with the data in
//  the array.
//
//  Parameters:
//
//      CType Type          The type of elements in the array.
//      CFastHeap* pHeap    The heap where extra data (strings) is kept.
//
//  Returns:
//
//      CVarVector*: newely allocated and initialized. The called must delete
//                      this pointer when done.
//
//*****************************************************************************
//
//  static CalculateNecessarySpace
//
//  Calculates the amount of space required for an CUntypedArray with a given
//  number of elements of a given type.
//
//  Parameters:
//
//      VARTYPE vt      The type of elements.
//      int nElements   The numbed of elements.
//
//  Returns:
//
//      length_t: the number of bytes required for such an array.
//
//*****************************************************************************
//
//  LoadFromCVarVector
//
//  Loads the array with data from a CVarVector. Assumes that the array has
//  already been allocated with enough room for all. For explanation of why
//  this function must be static, see CUntypedValue::LoadFromCVar
//
//  Parameters:
//
//      CPtrSource* pThis       The source of the pointer to the CUntypedArray
//                              to load the data into. The C value of this
//                              pointer can change, hence the sourcing.
//      CVarVector& vv          The CVarVector to load from.
//      CFastHeap* pHeap        The heap where additional data (strings) should
//                              be kept.
//
//*****************************************************************************
//
//  static TranslateToNewHeap
//
//  If this array contains heap pointers (as in the case of strings), this
//  function will allocate all the related data on the new heap and adjust all 
//  the data in the array to reflect the new heap pointers. The data on the 
//  old heap is NOT freed.
//
//  Parameters:
//
//      CPtrSource* pThis       The source of the pointer to the CUntypedArray
//                              to translate. The C value of this pointer can
//                              change, hence the sourcing.
//      CType Type              The type of elements in our array.
//      CFastHeap* pOldHeap     The heap where all extra data for this array
//                              is currently stored.
//      CFastHeap* pNewHeap     The heap to which the data should be moved.
//
//*****************************************************************************
//
//  static CopyToNewHeap
//
//  Takes a heap pointer pointing to a CUntypedArray and copies this array to 
//  another heap, returning the heap pointer to the copy. In addition to 
//  copying the array's memory block, it also translates all its internal heap
//  pointers (as in the case of an array of strings) to the new heap (see also
//  TranslateToNewHeap). It is assumed that the extra data for the array is 
//  located on the same heap as the array itself.
//
//  Parameters:
//
//      heapptr_t ptrOld        The heap pointer to the array (on the pOldHeap)
//      CType Type              The type of elements in our array.
//      CFastHeap* pOldHeap     The heap where all extra data for this array
//                              is currently stored.
//      CFastHeap* pNewHeap     The heap to which the data should be moved.
//
//*****************************************************************************

class COREPROX_POLARITY CUntypedArray
{
    int m_nNumElements;
protected:

	// Verifies that the supplied buffer size will hold the elements required.
	static HRESULT CheckRangeSizeForGet( Type_t nInherentType, length_t nLength, ULONG uNumElements,
										ULONG uBuffSize, ULONG* pulBuffRequired );

	// Requires a heap pointer
	static HRESULT ReallocArray( CPtrSource* pThis, Type_t nInherentType, CFastHeap* pHeap,
										ULONG uNumNewElements, ULONG* puNumOldElements,
										ULONG* puTotalNewElements, heapptr_t* pNewArrayPtr );

public:
    int GetNumElements() {return m_nNumElements;}
    static length_t GetHeaderLength() {return sizeof(int);}
#pragma optimize("", off)
     LPMEMORY GetElement(int nIndex, int nSize);

	// Checks that a supplied range is proper for the supplied buffer
	static HRESULT CheckRangeSize( Type_t nInherentType, length_t nLength, ULONG uNumElements,
									ULONG uBuffSize, LPVOID pData );

	// Send a datatable pointer in here.	The function will shrink/grow the array
	// as needed if WMIARRAY_FLAG_ALLELEMENTS is set - otherwise the array must fit
	// in the current array
	 static HRESULT SetRange( CPtrSource* pThis, long lFlags, Type_t nInherentType, length_t nLength,
							CFastHeap* pHeap, ULONG uStartIndex, ULONG uNumElements, ULONG uBuffSize,
							LPVOID pData );

	// Gets a range of elements from an array.  BuffSize must reflect uNumElements of the size of
	// element being set.  Strings are converted to WCHAR and separated by NULLs.  Object properties
	// are returned as an array of _IWmiObject pointers.  The range MUST be within the bounds
	// of the current array. Send a heap pointer in here
	static HRESULT GetRange( CPtrSource* pThis, Type_t nInherentType, length_t nLength,
						CFastHeap* pHeap, ULONG uStartIndex, ULONG uNumElements, ULONG uBuffSize,
						ULONG* puBuffSizeUsed, LPVOID pData );

	 // Send a heap pointer in here
	static HRESULT RemoveRange( CPtrSource* pThis, Type_t nInherentType, length_t nLength,
							CFastHeap* pHeap, ULONG uStartIndex, ULONG uNumElements );

	 // Send a Datatable pointer in here
	static HRESULT AppendRange( CPtrSource* pThis, Type_t nType, length_t nLength,
								CFastHeap* pHeap, ULONG uNumElements, ULONG uBuffSize, LPVOID pData );
#pragma optimize("", on)
     length_t GetLengthByType(CType Type)
    {
        return sizeof(m_nNumElements) + Type.GetLength() * m_nNumElements;
    }

     length_t GetLengthByActualLength(int nLength)
    {
        return sizeof(m_nNumElements) + nLength * m_nNumElements;
    }

    static  CUntypedArray* GetPointer(CPtrSource* pThis)
        { return (CUntypedArray*)(pThis->GetPointer());}

     CVarVector* CreateCVarVector(CType Type, CFastHeap* pHeap);
    static  HRESULT LoadFromCVarVector(CPtrSource* pThis,
        CVarVector& vv, Type_t nType, CFastHeap* pHeap, Type_t& nReturnType, BOOL bUseOld);
    static  length_t CalculateNecessarySpaceByType(CType Type, int nElements)
    {
        return sizeof(int) + nElements * Type.GetLength();
    }
    static  length_t CalculateNecessarySpaceByLength( int nLength, int nElements)
    {
        return sizeof(int) + nElements * nLength;
    }
public:
     void Delete(CType Type, CFastHeap* pHeap);
     static BOOL TranslateToNewHeap(CPtrSource* pThis, 
        CType Type, CFastHeap* pOldHeap, CFastHeap* pNewHeap);
     static BOOL CopyToNewHeap(heapptr_t ptrOld, CType Type, 
                           CFastHeap* pOldHeap, CFastHeap* pNewHeap,
						   UNALIGNED heapptr_t& ptrResult);

    static BOOL CheckCVarVector(CVarVector& vv, Type_t nInherentType);
    static BOOL CheckIntervalDateTime(CVarVector& vv);

	HRESULT IsArrayValid( CType Type, CFastHeap* pHeap );
};

#pragma pack(pop)


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\marshalers\coreprox\hiperfenum.h ===
/*++

Copyright (C) 1998-2001 Microsoft Corporation

Module Name:

    HIPERFENUM.H

Abstract:

    Hi-Perf Enumerators

History:

--*/

#ifndef __HIPERFENUM_H__
#define __HIPERFENUM_H__

#include "shmlock.h"

//
//	Classes CHiPerfEnumData, CHiPerfEnum
//
//	CHiPerfEnumData:
//	This is a simple data holder class that contains data that is manipulated
//	by the CHiPerfEnum class.
//
//	CHiPerfEnum:
//	This class provides an implementation of the IWbemHiPerfEnum interface.
//	It is passed to Refreshers when a client requests a refreshable enumeration.
//	This class provides a repository of data which is copied into an implementation
//	of IEnumWbemClassObject so a client can walk a refreshed enumeration.
//
//

// Holds data for the HiPerfEnum implementation
class CHiPerfEnumData
{
public:
	CHiPerfEnumData( long lId = 0, IWbemObjectAccess* pObj = NULL ):m_lId( lId ),m_pObj( pObj )
	{
		if ( m_pObj ) m_pObj->AddRef();
	}

	~CHiPerfEnumData()
	{
		if ( m_pObj ) m_pObj->Release();
	}

	void Clear( void )
	{
		if ( NULL != m_pObj ) m_pObj->Release();
		m_pObj = NULL;
		m_lId = 0;
	}

	void SetData( long lId, IWbemObjectAccess* pObj )
	{
		// Enusures AddRef/Release all happens
		SetObject( pObj );
		m_lId = lId;
	}

	// Accessors
	void SetObject( IWbemObjectAccess* pObj )
	{
		if ( pObj ) pObj->AddRef();
		if ( m_pObj ) m_pObj->Release();
		m_pObj = pObj;
	}

	void SetId( long lId ){ m_lId = lId; }
	long GetId( void ){ return m_lId; }

	IWbemObjectAccess* GetObject( void )
	{
		if ( m_pObj ) m_pObj->AddRef();
		return m_pObj;
	}

	IWbemObjectAccess*	m_pObj;
	long				m_lId;

};

// The next two classes will perform all of the garbage
// collection we need.  If we need to implement our own
// arrays we can do so here as well.

#define HPENUMARRAY_ALL_ELEMENTS	0xFFFFFFFF
#define HPENUMARRAY_GC_DEFAULT		0xFFFFFFFF

// This guy does all the garbage collection
class CGarbageCollectArray : public CFlexArray
{
protected:

	int		m_nNumElementsPending;
	int		m_nNumElementsExpired;
	BOOL	m_fClearFromFront;

public:

	// Do we garbage collect from front or back?
	CGarbageCollectArray( BOOL fClearFromFront ) :
		CFlexArray(), m_nNumElementsPending( 0 ), m_nNumElementsExpired( 0 ), m_fClearFromFront( fClearFromFront )
	{};
	virtual ~CGarbageCollectArray()
	{
		Empty();
	}

	BOOL GarbageCollect( int nNumToGarbageCollect = HPENUMARRAY_GC_DEFAULT );

	void ClearExpiredElements( void )
	{
		Clear( m_nNumElementsExpired );
		m_nNumElementsExpired = 0;
	}

	void Clear( int nNumToClear = HPENUMARRAY_ALL_ELEMENTS );

	// pure
	virtual void ClearElements( int nNumToClear ) = 0;

};

// All we need to do is implement ClearElements.
class CHPEnumDataArray : public CGarbageCollectArray
{
public:
	CHPEnumDataArray() :
		CGarbageCollectArray( TRUE )
	{};
	~CHPEnumDataArray()
	{
	}

	void ClearElements( int nNumToClear );

};

//
// this class is not directly new-able
//
////////////////////////////////////////////////////////
class CHiPerfEnum : public IWbemHiPerfEnum
{
protected:
	CHiPerfEnum();
public:
	virtual ~CHiPerfEnum();

	//	IUnknown implementations

    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj);
    STDMETHOD_(ULONG, AddRef)(THIS);
    STDMETHOD_(ULONG, Release)(THIS);

	/* IWbemHiPerfEnum */
	STDMETHOD(AddObjects)( long lFlags, ULONG uNumObjects, long* apIds, IWbemObjectAccess** apObj );
	STDMETHOD(RemoveObjects)( long lFlags, ULONG uNumObjects, long* apIds );
	STDMETHOD(GetObjects)( long lFlags, ULONG uNumObjects, IWbemObjectAccess** papObj, ULONG* plNumReturned );
	STDMETHOD(RemoveAll)( long lFlags );

	// Access to the instance template
	HRESULT SetInstanceTemplate( CWbemInstance* pInst );

	CWbemInstance* GetInstanceTemplate( void )
	{
		if (m_pInstTemplate ) m_pInstTemplate->AddRef();
		return m_pInstTemplate;
	}

protected:
	long			m_lRefCount;
	
	CHPEnumDataArray m_aIdToObject;
	CHPEnumDataArray m_aReusable;
	CWbemInstance*	 m_pInstTemplate;
	CHiPerfLock		 m_Lock;

	CHiPerfEnumData* GetEnumDataPtr( long lId, IWbemObjectAccess* pObj );
	HRESULT	InsertElement( CHiPerfEnumData* pData );
	HRESULT	RemoveElement( long lId );
	void ClearArray( void );


};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\marshalers\coreprox\mrshbase.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    MRSHBASE.H

Abstract:

    Marshaling base classes.

History:

--*/

#ifndef __MRSHBASE_H__
#define __MRSHBASE_H__

#include <unk.h>
#include <wbemidl.h>
#include <wbemint.h>
#include <wbemcomn.h>
#include <sync.h>
#include <fastall.h>
#include <wbemclasscache.h>
#include <wbemclasstoidmap.h>
#include <objindpacket.h>
#include <winntsec.h>

//***************************************************************************
//
//  class CBaseProxyBuffer
//
//  DESCRIPTION:
//
//  This class provides a base class implementation for an IRpcProxyBuffer.  As
//	the code necessary for performing this operation isn't necessarily so
//	obvious, but we use it in several places, this encapsulation is intended
//	to try and keep all of this maintainable.
//
//    Trick #1: This object is derived from IRpcProxyBuffer since IRpcProxyBuffer
//    is its "internal" interface --- the interface that does not delegate to the
//    aggregator. (Unlike in normal objects, where that interface is IUnknown)
//
//***************************************************************************

class CBaseProxyBuffer : public IRpcProxyBuffer
{
protected:
    CLifeControl* m_pControl;
    IUnknown* m_pUnkOuter;
	IRpcProxyBuffer*	m_pOldProxy;
    long m_lRef;
	REFIID m_riid;
	bool		m_fRemote;

protected:
    IRpcChannelBuffer* m_pChannel;
	IRpcChannelBuffer* GetChannel( void ) { return m_pChannel; };

	virtual void*	GetInterface( REFIID riid ) = 0;
	virtual void**	GetOldProxyInterfacePtr( void ) = 0;
	virtual void	ReleaseOldProxyInterface( void ) = 0;

public:
    CBaseProxyBuffer(CLifeControl* pControl, IUnknown* pUnkOuter, REFIID riid);
    virtual ~CBaseProxyBuffer();

    ULONG STDMETHODCALLTYPE AddRef();
    ULONG STDMETHODCALLTYPE Release(); 
    HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, void** ppv);
    STDMETHOD(Connect)(IRpcChannelBuffer* pChannel);
    STDMETHOD_(void, Disconnect)();
};

//***************************************************************************
// 
// class CProxySinkSecurity
//
// DESCRIPTION:
//
// facelets use this class to obtain the principal sid of the server 
// they are proxies to.  This is so async callback sinks passed through the
// facelets to the server can be set up to expect only calls from that 
// server identity.  It is intended that facelets construct this instance once
// as part of their state and make calls to it on each method involving a 
// callback sink being handed out. 
//
//***************************************************************************
class CProxySinkSecurity
{
    //
    // Init must be deferred in this class because usually when constructed,
    // the proxy does not yet have an IClientSecurity implementation which is 
    // required by this implementation.   So, we wait until the 
    // EnsureSinkSecurity() call is made to perform init.  
    //
    CCritSec m_cs;
    BOOL m_bInit;
    CNtSid m_PrincipalSid;
    IUnknown* m_pOwnerProxy; // it owns us, so don't hold ref.

    HRESULT EnsureInitialized();

public:

    //
    // users must be aware the CTOR can throw CX_MemoryException (m_cs CTOR)
    //
    CProxySinkSecurity( IUnknown* pOwnerProxy ) 
      : m_bInit( FALSE ), m_pOwnerProxy( pOwnerProxy ) {} 

    //
    // When a callback sink is handed to a facelet, about to be handed off to
    // a server ( e.g. GetObjectAsync ), the facelet ensures that the sink 
    // knows about the server principal its being handed off to so it can 
    // optionally perform access checks on the callback.  This method is a 
    // No-op if the sink does not implement _IWmiObjectSinkSecurity
    //
    HRESULT EnsureSinkSecurity( IWbemObjectSink* pSink );
};


//***************************************************************************
//
//  class CBaseStubBuffer
//
//  DESCRIPTION:
//
//  This class provides the stublet for the IWbemObjectSink interface.
//
//***************************************************************************

// Forward the definition
class CBaseStublet;

class CBaseStubBuffer : public CUnk
{
    friend CBaseStublet;

protected:

	IRpcStubBuffer*	m_pOldStub;

protected:

public:
    CBaseStubBuffer(CLifeControl* pControl, IUnknown* pUnkOuter = NULL)
        : CUnk(pControl, pUnkOuter), m_pOldStub( NULL )
    {}

};

class CBaseStublet : public CImpl<IRpcStubBuffer, CBaseStubBuffer>
{
protected:
	REFIID	m_riid;
	long	m_lConnections;

protected:

	virtual IUnknown*	GetServerInterface( void ) = 0;
	virtual void**	GetServerPtr( void ) = 0;
	virtual void	ReleaseServerPointer( void ) = 0;

	IRpcStubBuffer*	GetOldStub( void )
	{	return m_pObject->m_pOldStub; }

public:
    CBaseStublet(CBaseStubBuffer* pObj, REFIID riid);
    ~CBaseStublet();

    STDMETHOD(Connect)(IUnknown* pUnkServer);
    STDMETHOD_(void, Disconnect)();
    STDMETHOD(Invoke)(RPCOLEMESSAGE* pMessage, IRpcChannelBuffer* pBuffer);
    STDMETHOD_(IRpcStubBuffer*, IsIIDSupported)(REFIID riid);
    STDMETHOD_(ULONG, CountRefs)();
    STDMETHOD(DebugServerQueryInterface)(void** ppv);
    STDMETHOD_(void, DebugServerRelease)(void* pv);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\marshalers\coreprox\mrshbase.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    MRSHBASE.CPP

Abstract:

    Marshaling base classes.

History:

--*/

#include "precomp.h"
#include <stdio.h>
#include "mrshbase.h"
#include <fastall.h>
#include <ntdsapi.h>
#define WBEM_S_NEW_STYLE 0x400FF

//****************************************************************************
//****************************************************************************
//                          PROXY
//****************************************************************************
//****************************************************************************

//***************************************************************************
//
//  CBaseProxyBuffer::CBaseProxyBuffer
//  ~CBaseProxyBuffer::CBaseProxyBuffer
//
//  DESCRIPTION:
//
//  Constructor and destructor.  The main things to take care of are the 
//  old style proxy, and the channel
//
//  RETURN VALUE:
//
//  S_OK                all is well
//
//***************************************************************************

CBaseProxyBuffer::CBaseProxyBuffer(CLifeControl* pControl, IUnknown* pUnkOuter, REFIID riid)
    : m_pControl(pControl), m_pUnkOuter(pUnkOuter), m_lRef(0), 
       m_pChannel(NULL), m_pOldProxy( NULL ), m_riid( riid ), m_fRemote( false )
{
    m_pControl->ObjectCreated(this);
}

CBaseProxyBuffer::~CBaseProxyBuffer()
{
    // Derived class will destruct first, so it should have cleaned up the
    // old interface pointer by now.

    if (m_pOldProxy) m_pOldProxy->Release();

    if(m_pChannel)  m_pChannel->Release();

    m_pControl->ObjectDestroyed(this);
}

ULONG STDMETHODCALLTYPE CBaseProxyBuffer::AddRef()
{
    return InterlockedIncrement(&m_lRef);
}

ULONG STDMETHODCALLTYPE CBaseProxyBuffer::Release()
{
    long lRef = InterlockedDecrement(&m_lRef);
    if(lRef == 0)
        delete this;
    return lRef;
}

HRESULT STDMETHODCALLTYPE CBaseProxyBuffer::QueryInterface(REFIID riid, void** ppv)
{
    if(riid == IID_IUnknown || riid == IID_IRpcProxyBuffer)
    {
        *ppv = (IRpcProxyBuffer*)this;
    }
    else if(riid == m_riid)
    {
        *ppv = GetInterface( riid );
    }
    else return E_NOINTERFACE;

    ((IUnknown*)*ppv)->AddRef();
    return S_OK;
}

//***************************************************************************
//
//  STDMETHODIMP CBaseProxyBuffer::Connect(IRpcChannelBuffer* pChannel)
//
//  DESCRIPTION:
//
//  Called during the initialization of the proxy.  The channel buffer is passed
//  to this routine.
//
//  RETURN VALUE:
//
//  S_OK                all is well
//
//***************************************************************************

STDMETHODIMP CBaseProxyBuffer::Connect(IRpcChannelBuffer* pChannel)
{

    IPSFactoryBuffer*   pIPS;
    HRESULT             hr = S_OK;

    if( NULL == m_pChannel )
    {

        // Establish the marshaling context
        DWORD   dwCtxt = 0;
        pChannel->GetDestCtx( &dwCtxt, NULL );

        m_fRemote = ( dwCtxt == MSHCTX_DIFFERENTMACHINE );

        // This is tricky -- All WBEM Interface Proxy/Stubs are still available
        // in WBEMSVC.DLL, but the CLSID for the PSFactory is the same as
        // IID_IWbemObjectSink.

        // get a pointer to the old interface which is in WBEMSVC.DLL  this allows
        // for backward compatibility

        hr = CoGetClassObject( IID_IWbemObjectSink, CLSCTX_INPROC_HANDLER | CLSCTX_INPROC_SERVER,
                        NULL, IID_IPSFactoryBuffer, (void**) &pIPS );

        // We aggregated it --- WE OWN IT!
        
        if ( SUCCEEDED( hr ) )
        {
            hr = pIPS->CreateProxy( this, m_riid, &m_pOldProxy, GetOldProxyInterfacePtr() );

            if ( SUCCEEDED( hr ) )
            {
                // Save a reference to the channel

                hr = m_pOldProxy->Connect( pChannel );

                m_pChannel = pChannel;
                if(m_pChannel)
                    m_pChannel->AddRef();
            }

            pIPS->Release();
        }

    }
    else
    {
        hr = E_UNEXPECTED;
    }


    return hr;
}

//***************************************************************************
//
//  STDMETHODIMP CBaseProxyBuffer::Disconnect(IRpcChannelBuffer* pChannel)
//
//  DESCRIPTION:
//
//  Called when the proxy is being disconnected.  It just frees various pointers.
//
//  RETURN VALUE:
//
//  S_OK                all is well
//
//***************************************************************************

void STDMETHODCALLTYPE CBaseProxyBuffer::Disconnect()
{
    // Old Proxy code

    if(m_pOldProxy)
        m_pOldProxy->Disconnect();

    // Complete the Disconnect by releasing our references to the
    // old proxy pointers.  The old interfaces MUST be released first.

    ReleaseOldProxyInterface();

    if ( NULL != m_pOldProxy )
    {
        m_pOldProxy->Release();
        m_pOldProxy = NULL;
    }

    if(m_pChannel)
        m_pChannel->Release();
    m_pChannel = NULL;
}

/* 
**ProxySinkSecurity Code 
*/

//
// accepts any valid SPN name for a computer account and converts it to 
// a computer account name.
//
LPWSTR PrincNameToCompAccount( LPCWSTR wszPrincipal )
{
    DWORD dwRes;
    LPWSTR pComputer = NULL;
    WCHAR awchInstanceName[64];
    LPWSTR pInstanceName = awchInstanceName;
    DWORD cInstanceName = 64;

    dwRes = DsCrackSpn( wszPrincipal,
                        NULL,
                        NULL,
                        NULL,
                        NULL,
                        &cInstanceName,
                        pInstanceName,
                        NULL );
    
    if ( dwRes == ERROR_BUFFER_OVERFLOW )
    { 
        pInstanceName = new WCHAR[cInstanceName+1];

        if ( pInstanceName == NULL )
            return NULL;

        dwRes = DsCrackSpn( wszPrincipal,
                        NULL,
                        NULL,
                        NULL,
                        NULL,
                        &cInstanceName,
                        pInstanceName,
                        NULL );
    }

    if ( dwRes == ERROR_SUCCESS )
    {
        //
        // convert the dns name to a computer account name. This is done 
        // by changing the first dot to a @ and adding a $ after the machine
        // name.
        // TODO: here we assume the host name is in dns form.  Not sure 
        // if this will always be the case, but with some initial testing 
        // it looks like it is.
        // 
        PWCHAR pwch = wcschr( pInstanceName, '.' );
        if ( pwch != NULL )
        {
            pComputer = new WCHAR[cInstanceName+2];

            if ( pComputer != NULL )
            {
                *pwch = '\0';
                StringCchCopyW( pComputer, cInstanceName+2, pInstanceName );
                StringCchCatW( pComputer, cInstanceName+2, L"$@" );
                StringCchCatW( pComputer, cInstanceName+2, pwch+1 );
            }
        }
    }        
    else
    {
        //
        // guess we didn't have a valid SPN, so the principal name is 
        // already a computer account name.
        //
        pComputer = Macro_CloneLPWSTR(wszPrincipal);
    }

    if ( pInstanceName != awchInstanceName )
    {
        delete [] pInstanceName;
    }

    return pComputer;
}


HRESULT CProxySinkSecurity::EnsureInitialized() 
{
    HRESULT hr;
    CInCritSec ics( &m_cs );
 
    if ( m_bInit )
        return WBEM_S_FALSE;

    //
    // try to obtain the principal of the server side of our facelet and
    // convert to SID.  This is necessary because later we may need to tell 
    // secure sink implementations about the principal when handing them out 
    // to the server through our facelet.   Obtaining the principal may not 
    // always be successfull in which case our principal sid will be NULL, but
    // we keep going and let the secure sink decide if this is o.k.
    //
    
    DWORD dwAuthnSvc;
    LPWSTR wszPrincipal = NULL;

    hr = CoQueryProxyBlanket( m_pOwnerProxy,
                              &dwAuthnSvc,
                              NULL,
                              &wszPrincipal,
                              NULL,
                              NULL,
                              NULL,
                              NULL );

    if ( SUCCEEDED(hr) && wszPrincipal != NULL )
    {
        LPWSTR wszCompAccount = PrincNameToCompAccount(wszPrincipal);
        
        if ( wszCompAccount != NULL )
        {
            BYTE achSid[64];
            DWORD cSid = 64;
            PBYTE pSid = achSid;
            
            WCHAR awchDomain[64];
            DWORD cDomain = 64;
            
            SID_NAME_USE su;
            
            BOOL bRes = LookupAccountNameW( NULL,
                                            wszCompAccount,
                                            pSid,
                                            &cSid,
                                            awchDomain,
                                            &cDomain,
                                            &su );
            
            if ( !bRes && GetLastError() == ERROR_INSUFFICIENT_BUFFER ) 
            {
                pSid = new BYTE[cSid];
                PWCHAR pDomain = new WCHAR[cDomain];
                
                if ( pSid != NULL && pDomain != NULL )
                {
                    bRes = LookupAccountNameW( NULL,
                                               wszCompAccount,
                                               pSid,
                                               &cSid,
                                               pDomain,
                                               &cDomain,
                                               &su );
                }
                
                delete [] pDomain;
            }
            
            if ( bRes )
            {
                m_PrincipalSid = pSid;
            }
            
            if ( pSid != achSid )
            {
                delete [] pSid;
            }

            delete [] wszCompAccount;
        }
    }
        
    if ( wszPrincipal != NULL )
    {
        CoTaskMemFree( wszPrincipal );
    }

    m_bInit = TRUE;
    return WBEM_S_NO_ERROR;
}

HRESULT CProxySinkSecurity::EnsureSinkSecurity( IWbemObjectSink* pSink )
{
    HRESULT hr;
    _IWmiObjectSinkSecurity* pSec;
    if ( pSink == NULL || 
         FAILED(pSink->QueryInterface( IID__IWmiObjectSinkSecurity, 
                                       (void**)&pSec ) ) )
    {
        //
        // the sink doesn't care about what principals will be calling it,
        // so nothing more for us to do.
        //
        hr = WBEM_S_NO_ERROR;
    }
    else
    {
        hr = EnsureInitialized();

        if ( SUCCEEDED(hr) )
        {
            //
            // the sink may perform access checks on callbacks based on the 
            // principal of the server that we are a proxy facelet to.  We 
            // need to tell it about this principal.  If we never successfully 
            // obtained the principal ( can only do with mutual auth ) in 
            // SetProxy(), then we will be passing a NULL sid here, but we 
            // let the sink decide if this is o.k. or not depending on its 
            // configured security settings.
            //
            hr = pSec->AddCallbackPrincipalSid( (PBYTE)m_PrincipalSid.GetPtr(),
                                                m_PrincipalSid.GetSize() );
            pSec->Release();
        }
    }

    return hr;
}

/*
**  Stub Buffer Code
*/

CBaseStublet::CBaseStublet(CBaseStubBuffer* pObj, REFIID riid) 
    : CImpl<IRpcStubBuffer, CBaseStubBuffer>(pObj), m_lConnections( 0 ), m_riid( riid )
{
}

CBaseStublet::~CBaseStublet() 
{
    // The server pointer will have been cleaned up by the derived class

    if ( NULL != m_pObject->m_pOldStub )
    {
        m_pObject->m_pOldStub->Release();
        m_pObject->m_pOldStub = NULL;
    }
}

//***************************************************************************
//
//  STDMETHODIMP CBaseStubBuffer::Connect(IUnknown* pUnkServer)
//
//  DESCRIPTION:
//
//  Called during the initialization of the stub.  The pointer to the
//  IWbemObject sink object is passed in.
//
//  RETURN VALUE:
//
//  S_OK                all is well
//
//***************************************************************************

STDMETHODIMP CBaseStublet::Connect(IUnknown* pUnkServer)
{
    // Something is wrong
    if( GetServerInterface() )
        return E_UNEXPECTED;

    HRESULT hres = pUnkServer->QueryInterface( m_riid, GetServerPtr() );
    if(FAILED(hres))
        return E_NOINTERFACE;

    // This is tricky --- The old proxys/stub stuff is actually registered under the
    // IID_IWbemObjectSink in wbemcli_p.cpp.  This single class id, is backpointered
    // by ProxyStubClsId32 entries for all the standard WBEM interfaces.

    IPSFactoryBuffer*   pIPS;

    HRESULT hr = CoGetClassObject( IID_IWbemObjectSink, CLSCTX_INPROC_HANDLER | CLSCTX_INPROC_SERVER,
                    NULL, IID_IPSFactoryBuffer, (void**) &pIPS );

    if ( SUCCEEDED( hr ) )
    {
        hr = pIPS->CreateStub( m_riid, GetServerInterface(), &m_pObject->m_pOldStub );

        if ( SUCCEEDED( hr ) )
        {
            // Successful connection
            m_lConnections++;
        }

        pIPS->Release();

    }

    return hr;
}

//***************************************************************************
//
//  void STDMETHODCALLTYPE CBaseStublet::Disconnect()
//
//  DESCRIPTION:
//
//  Called when the stub is being disconnected.  It frees the IWbemObjectSink
//  pointer.
//
//  RETURN VALUE:
//
//  S_OK                all is well
//
//***************************************************************************

void STDMETHODCALLTYPE CBaseStublet::Disconnect()
{
    // Inform the listener of the disconnect
    // =====================================

    HRESULT hres = S_OK;

    if(m_pObject->m_pOldStub)
        m_pObject->m_pOldStub->Disconnect();

    ReleaseServerPointer();

    // Successful disconnect
    m_lConnections--;

}

STDMETHODIMP CBaseStublet::Invoke(RPCOLEMESSAGE* pMessage, 
                                        IRpcChannelBuffer* pChannel)
{
    // SetStatus is a pass through to the old layer

    if ( NULL != m_pObject->m_pOldStub )
    {
        return m_pObject->m_pOldStub->Invoke( pMessage, pChannel );
    }
    else
    {
        return RPC_E_SERVER_CANTUNMARSHAL_DATA;
    }
}

IRpcStubBuffer* STDMETHODCALLTYPE CBaseStublet::IsIIDSupported(
                                    REFIID riid)
{
    if(riid == m_riid)
    {
        // Don't AddRef().  At least that's what the sample on
        // Inside DCOM p.341 does.
        //AddRef(); // ?? not sure
        return this;
    }
    else return NULL;
}
    
ULONG STDMETHODCALLTYPE CBaseStublet::CountRefs()
{
    // See Page 340-41 in Inside DCOM
    return m_lConnections;
}

STDMETHODIMP CBaseStublet::DebugServerQueryInterface(void** ppv)
{
    *ppv = GetServerInterface();

    if ( NULL == *ppv )
    {
        return E_UNEXPECTED;
    }

    return S_OK;
}

void STDMETHODCALLTYPE CBaseStublet::DebugServerRelease(void* pv)
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\marshalers\coreprox\mtgtmrsh.h ===
/*++

Copyright (C) 1998-2001 Microsoft Corporation

Module Name:

    MTGTMRSH.H

Abstract:

    Multi Target Marshaling.

History:

--*/

#include <unk.h>
#include <wbemidl.h>
#include <wbemint.h>
#include <wbemcomn.h>
#include <sync.h>
#include <fastall.h>
#include "wbemclasscache.h"
#include "wbemclasstoidmap.h"
#include "mtgtpckt.h"

//***************************************************************************
//
//  class CMultiTargetFactoryBuffer
//
//  DESCRIPTION:
//
//  This class provides the proxy stub factory so that we can provide custom
//  facelets and stublets for the IWbemObjectSink interface.
//
//***************************************************************************

class CMultiTargetFactoryBuffer : public CUnkInternal
{

    // We don't want to AddRef the life control, but
    // we need to let objects we create AddRef it, so the
    // base class won't keep this pointer, but we will.

    CLifeControl*        m_pLifeControl;

protected:
    class XEnumFactory : public CImpl<IPSFactoryBuffer, CMultiTargetFactoryBuffer>
    {
    public:
        XEnumFactory(CMultiTargetFactoryBuffer* pObj) :
            CImpl<IPSFactoryBuffer, CMultiTargetFactoryBuffer>(pObj)
        {}
        
        STDMETHOD(CreateProxy)(IN IUnknown* pUnkOuter, IN REFIID riid, 
            OUT IRpcProxyBuffer** ppProxy, void** ppv);
        STDMETHOD(CreateStub)(IN REFIID riid, IN IUnknown* pUnkServer, 
            OUT IRpcStubBuffer** ppStub);
    } m_XEnumFactory;
public:
    CMultiTargetFactoryBuffer(CLifeControl* pControl)
        : CUnkInternal(pControl), m_XEnumFactory(this), m_pLifeControl( pControl )
    {
    }
    ~CMultiTargetFactoryBuffer()
    {
    }
    

    void* GetInterface(REFIID riid);

    friend XEnumFactory;
};

//***************************************************************************
//
//  class CMultiTargetProxyBuffer
//
//  DESCRIPTION:
//
//  This class provides the facelet for the IWbemObjectSink interface.
//
//    Trick #1: This object is derived from IRpcProxyBuffer since IRpcProxyBuffer
//    is its "internal" interface --- the interface that does not delegate to the
//    aggregator. (Unlike in normal objects, where that interface is IUnknown)
//
//***************************************************************************

class CMultiTargetProxyBuffer : public IRpcProxyBuffer
{
private:
    IRpcProxyBuffer*              m_pOldProxy;
    IWbemMultiTarget*            m_pOldProxyMultiTarget;
    BOOL                                m_fTriedSmartEnum;
    BOOL                                m_fUseSmartMultiTarget;
    GUID                                 m_guidSmartEnum;
    IWbemSmartMultiTarget*    m_pSmartMultiTarget;
    CCritSec                            m_cs;
    bool                                   m_fRemote;

protected:
    CLifeControl* m_pControl;
    IUnknown* m_pUnkOuter;
    long m_lRef;

protected:
    class XMultiTargetFacelet : public IWbemMultiTarget, IClientSecurity
    {
    protected:
        CMultiTargetProxyBuffer*    m_pObject;
        CWbemClassToIdMap            m_ClassToIdMap;

    public:
        XMultiTargetFacelet(CMultiTargetProxyBuffer* pObject) : m_pObject(pObject){};
        ~XMultiTargetFacelet(){};

        ULONG STDMETHODCALLTYPE AddRef() 
        {return m_pObject->m_pUnkOuter->AddRef();}
        ULONG STDMETHODCALLTYPE Release() 
        {return m_pObject->m_pUnkOuter->Release();}
        HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, void** ppv);

        // IWbemMultiTarget Methods
        STDMETHOD(DeliverEvent)(
            /*[in]*/ DWORD dwNumEvents,
            /*[in]*/ IWbemClassObject** apEvents,
            /*[in]*/ WBEM_REM_TARGETS* aTargets,
            /*[in]*/ long lSDLength,
            /*[in, size_is(lSDLength)]*/ BYTE* pSD);

        STDMETHOD(DeliverStatus)(
            /*[in]*/ long lFlags,
            /*[in]*/ HRESULT hresStatus,
            /*[in, string]*/ LPCWSTR wszStatus,
            /*[in]*/ IWbemClassObject* pErrorObj,
            /*[in]*/ WBEM_REM_TARGETS* pTargets,
            /*[in]*/ long lSDLength,
            /*[in, size_is(lSDLength)]*/ BYTE* pSD);

        // IClientSecurity Methods
        STDMETHOD(QueryBlanket)( IUnknown* pProxy, DWORD* pAuthnSvc, DWORD* pAuthzSvc,
            OLECHAR** pServerPrincName, DWORD* pAuthnLevel, DWORD* pImpLevel,
            void** pAuthInfo, DWORD* pCapabilities );
        STDMETHOD(SetBlanket)( IUnknown* pProxy, DWORD AuthnSvc, DWORD AuthzSvc,
            OLECHAR* pServerPrincName, DWORD AuthnLevel, DWORD ImpLevel,
            void* pAuthInfo, DWORD Capabilities );
        STDMETHOD(CopyProxy)( IUnknown* pProxy, IUnknown** pCopy );

    } m_XMultiTargetFacelet;
    friend XMultiTargetFacelet;

protected:
    IRpcChannelBuffer* m_pChannel;
    IRpcChannelBuffer* GetChannel( void ) { return m_pChannel; };

    // Initialize the smart enumerator
    HRESULT InitSmartMultiTarget( BOOL fSetBlanket = FALSE, DWORD AuthnSvc = RPC_C_AUTHN_WINNT,
            DWORD AuthzSvc = RPC_C_AUTHZ_NONE, OLECHAR* pServerPrincName = NULL,
            DWORD AuthnLevel = RPC_C_AUTHN_LEVEL_DEFAULT, DWORD ImpLevel = RPC_C_IMP_LEVEL_IMPERSONATE,
            void* pAuthInfo = NULL, DWORD Capabilities = EOAC_NONE );

public:
    CMultiTargetProxyBuffer(CLifeControl* pControl, IUnknown* pUnkOuter);
    ~CMultiTargetProxyBuffer();

    ULONG STDMETHODCALLTYPE AddRef();
    ULONG STDMETHODCALLTYPE Release(); 
    HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, void** ppv);
    STDMETHOD(Connect)(IRpcChannelBuffer* pChannel);
    STDMETHOD_(void, Disconnect)();
};

//***************************************************************************
//
//  class CMultiTargetStubBuffer
//
//  DESCRIPTION:
//
//  This class provides the stublet for the IWbemObjectSink interface.
//
//***************************************************************************

class CMultiTargetStubBuffer : public CUnk
{
private:

    IRpcStubBuffer*    m_pOldStub;

protected:
    class XMultiTargetStublet : public CImpl<IRpcStubBuffer, CMultiTargetStubBuffer>
    {
        IWbemObjectSink* m_pServer;
        LONG            m_lConnections;

    public:
        XMultiTargetStublet(CMultiTargetStubBuffer* pObj);
        ~XMultiTargetStublet();

        STDMETHOD(Connect)(IUnknown* pUnkServer);
        STDMETHOD_(void, Disconnect)();
        STDMETHOD(Invoke)(RPCOLEMESSAGE* pMessage, IRpcChannelBuffer* pBuffer);
        STDMETHOD_(IRpcStubBuffer*, IsIIDSupported)(REFIID riid);
        STDMETHOD_(ULONG, CountRefs)();
        STDMETHOD(DebugServerQueryInterface)(void** ppv);
        STDMETHOD_(void, DebugServerRelease)(void* pv);
        
    private:

        friend CMultiTargetStubBuffer;
    } m_XMultiTargetStublet;
    friend XMultiTargetStublet;

public:
    CMultiTargetStubBuffer(CLifeControl* pControl, IUnknown* pUnkOuter = NULL)
        : CUnk(pControl, pUnkOuter), m_XMultiTargetStublet(this), m_pOldStub( NULL )
    {}
    void* GetInterface(REFIID riid);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\marshalers\coreprox\mtgtmrsh.cpp ===
/*++

Copyright (C) 1998-2001 Microsoft Corporation

Module Name:

    MTGTMRSH.CPP

Abstract:

    Multi Target Marshaling.

History:

--*/

#include "precomp.h"
#include <stdio.h>
#include "mtgtmrsh.h"
#include <fastall.h>
#include <cominit.h>

//****************************************************************************
//****************************************************************************
//                          PS FACTORY
//****************************************************************************
//****************************************************************************

//***************************************************************************
//
//  CMultiTargetFactoryBuffer::XEnumFactory::CreateProxy
//
//  DESCRIPTION:
//
//  Creates a facelet.  Also sets the outer unknown since the proxy is going to be 
//  aggregated.
//
//  RETURN VALUE:
//
//  S_OK                all is well
//
//***************************************************************************

STDMETHODIMP CMultiTargetFactoryBuffer::XEnumFactory::CreateProxy(IN IUnknown* pUnkOuter, 
    IN REFIID riid, OUT IRpcProxyBuffer** ppProxy, void** ppv)
{
    if(riid != IID_IWbemMultiTarget)
    {
        *ppProxy = NULL;
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    CMultiTargetProxyBuffer* pProxy = new CMultiTargetProxyBuffer(m_pObject->m_pLifeControl, pUnkOuter);

    SCODE   sc = E_OUTOFMEMORY;

    if ( NULL != pProxy )
    {
        pProxy->QueryInterface(IID_IRpcProxyBuffer, (void**)ppProxy);
        sc = pProxy->QueryInterface(riid, (void**)ppv);
    }

    return sc;
}

//***************************************************************************
//
//  CMultiTargetFactoryBuffer::XEnumFactory::CreateStub
//
//  DESCRIPTION:
//
//  Creates a stublet.  Also passes a pointer to the clients IWbemMultiTarget 
//  interface.
//
//  RETURN VALUE:
//
//  S_OK                all is well
//
//***************************************************************************
    
STDMETHODIMP CMultiTargetFactoryBuffer::XEnumFactory::CreateStub(IN REFIID riid, 
    IN IUnknown* pUnkServer, OUT IRpcStubBuffer** ppStub)
{
    if(riid != IID_IWbemMultiTarget)
    {
        *ppStub = NULL;
        return E_NOINTERFACE;
    }

    CMultiTargetStubBuffer* pStub = new CMultiTargetStubBuffer(m_pObject->m_pLifeControl, NULL);

    if ( NULL != pStub )
    {
        pStub->QueryInterface(IID_IRpcStubBuffer, (void**)ppStub);

        // Pass the pointer to the clients object

        if(pUnkServer)
        {
            HRESULT hres = (*ppStub)->Connect(pUnkServer);
            if(FAILED(hres))
            {
                delete pStub;
                *ppStub = NULL;
            }
            return hres;
        }
        else
        {
            return S_OK;
        }
    }
    else
    {
        return E_OUTOFMEMORY;
    }
}

//***************************************************************************
//
//  void* CMultiTargetFactoryBuffer::GetInterface(REFIID riid)
//
//  DESCRIPTION:
//
//  CMultiTargetFactoryBuffer is derived from CUnk.  Since CUnk handles the QI calls,
//  all classes derived from it must support this function.
//
//  RETURN VALUE:
//
//  S_OK                all is well
//
//***************************************************************************

void* CMultiTargetFactoryBuffer::GetInterface(REFIID riid)
{
    if(riid == IID_IPSFactoryBuffer)
        return &m_XEnumFactory;
    else return NULL;
}
        
//****************************************************************************
//****************************************************************************
//                          PROXY
//****************************************************************************
//****************************************************************************

//***************************************************************************
//
//  CMultiTargetProxyBuffer::CMultiTargetProxyBuffer
//  ~CMultiTargetProxyBuffer::CMultiTargetProxyBuffer
//
//  DESCRIPTION:
//
//  Constructor and destructor.  The main things to take care of are the 
//  old style proxy, and the channel
//
//  RETURN VALUE:
//
//  S_OK                all is well
//
//***************************************************************************

CMultiTargetProxyBuffer::CMultiTargetProxyBuffer(CLifeControl* pControl, IUnknown* pUnkOuter)
    : m_pControl(pControl), m_pUnkOuter(pUnkOuter), m_lRef(0), 
        m_XMultiTargetFacelet(this), m_pChannel(NULL), m_pOldProxy( NULL ), m_pOldProxyMultiTarget( NULL ),
        m_fTriedSmartEnum( FALSE ), m_fUseSmartMultiTarget( FALSE ), 
        m_pSmartMultiTarget( NULL ), m_fRemote( false )
{
    m_pControl->ObjectCreated(this);
}

CMultiTargetProxyBuffer::~CMultiTargetProxyBuffer()
{
    if ( NULL != m_pSmartMultiTarget )
    {
        m_pSmartMultiTarget->Release();
    }

    // This MUST be released before releasing
    // the Proxy pointer
    if ( NULL != m_pOldProxyMultiTarget )
    {
        m_pOldProxyMultiTarget->Release();
    }

    if ( NULL != m_pOldProxy )
    {
        m_pOldProxy->Release();
    }

    if(m_pChannel)
        m_pChannel->Release();

    m_pControl->ObjectDestroyed(this);
}

ULONG STDMETHODCALLTYPE CMultiTargetProxyBuffer::AddRef()
{
    return InterlockedIncrement(&m_lRef);
}

ULONG STDMETHODCALLTYPE CMultiTargetProxyBuffer::Release()
{
    long lRef = InterlockedDecrement(&m_lRef);
    if(lRef == 0)
        delete this;
    return lRef;
}

HRESULT STDMETHODCALLTYPE CMultiTargetProxyBuffer::QueryInterface(REFIID riid, void** ppv)
{
    if(riid == IID_IUnknown || riid == IID_IRpcProxyBuffer)
    {
        *ppv = (IRpcProxyBuffer*)this;
    }
    else if(riid == IID_IWbemMultiTarget)
    {
        *ppv = (IWbemMultiTarget*)&m_XMultiTargetFacelet;
    }
    else return E_NOINTERFACE;

    ((IUnknown*)*ppv)->AddRef();
    return S_OK;
}

//***************************************************************************
//
//  HRESULT STDMETHODCALLTYPE CMultiTargetProxyBuffer::XMultiTargetFacelet::
//                      QueryInterface(REFIID riid, void** ppv)  
//
//  DESCRIPTION:
//
//  Supports querries for interfaces.   The only thing unusual is that
//  this object is aggregated by the proxy manager and so some interface
//  requests are passed to the outer IUnknown interface.
//
//  RETURN VALUE:
//
//  S_OK                all is well
//
//***************************************************************************

HRESULT STDMETHODCALLTYPE CMultiTargetProxyBuffer::XMultiTargetFacelet::
QueryInterface(REFIID riid, void** ppv)
{
    // All other interfaces are delegated to the UnkOuter
    if( riid == IID_IRpcProxyBuffer )
    {
        // Trick #2: this is an internal interface that should not be delegated!
        // ===================================================================

        return m_pObject->QueryInterface(riid, ppv);
    }
    else if ( riid == IID_IClientSecurity )
    {
        // We handle this here in the facelet
        AddRef();
        *ppv = (IClientSecurity*) this;
        return S_OK;
    }
    else
    {
        return m_pObject->m_pUnkOuter->QueryInterface(riid, ppv);
    }
}


//////////////////////////////
//  IClientSecurity Methods //
//////////////////////////////

HRESULT STDMETHODCALLTYPE  CMultiTargetProxyBuffer::XMultiTargetFacelet::
QueryBlanket( IUnknown* pProxy, DWORD* pAuthnSvc, DWORD* pAuthzSvc,
    OLECHAR** pServerPrincName, DWORD* pAuthnLevel, DWORD* pImpLevel,
    void** pAuthInfo, DWORD* pCapabilities )
{
    HRESULT hr = S_OK;

    // Return our security as stored in the pUnkOuter.

    IClientSecurity*    pCliSec;

    // We pass through to the PUNKOuter
    hr = m_pObject->m_pUnkOuter->QueryInterface( IID_IClientSecurity, (void**) &pCliSec );

    if ( SUCCEEDED( hr ) )
    {
        hr = pCliSec->QueryBlanket( pProxy, pAuthnSvc, pAuthzSvc, pServerPrincName,
                pAuthnLevel, pImpLevel, pAuthInfo, pCapabilities );
        pCliSec->Release();
    }

    return hr;
}

HRESULT STDMETHODCALLTYPE  CMultiTargetProxyBuffer::XMultiTargetFacelet::
SetBlanket( IUnknown* pProxy, DWORD AuthnSvc, DWORD AuthzSvc,
            OLECHAR* pServerPrincName, DWORD AuthnLevel, DWORD ImpLevel,
            void* pAuthInfo, DWORD Capabilities )
{
    HRESULT hr = S_OK;

    IClientSecurity*    pCliSec;

    // This will enable us to make calls to QueryInterface(), AddRef()/Release() that
    // may have to go remote

    // Only set the IUnknown blanket if we are remoting and it appears that the authinfo contains
    // credentials
    if (    m_pObject->m_fRemote &&
            DoesContainCredentials( (COAUTHIDENTITY*) pAuthInfo ) )
    {
        // This will enable us to make calls to QueryInterface(), AddRef()/Release() that
        // may have to go remote

        hr = CoSetProxyBlanket( m_pObject->m_pUnkOuter, AuthnSvc, AuthzSvc, pServerPrincName,
                    AuthnLevel, ImpLevel, pAuthInfo, Capabilities );

    }

    if ( SUCCEEDED( hr ) )
    {
        // We pass through to the PUNKOuter
        hr = m_pObject->m_pUnkOuter->QueryInterface( IID_IClientSecurity, (void**) &pCliSec );

        if ( SUCCEEDED( hr ) )
        {
            hr = pCliSec->SetBlanket( pProxy, AuthnSvc, AuthzSvc, pServerPrincName,
                    AuthnLevel, ImpLevel, pAuthInfo, Capabilities );
            pCliSec->Release();
        }

        // Make sure we have a smart enumerator and that we are going to
        // be using it.  If so, make sure the values applied to us are also
        // applied to it's proxy

        if ( SUCCEEDED( m_pObject->InitSmartMultiTarget( TRUE, AuthnSvc, AuthzSvc, pServerPrincName,
                    AuthnLevel, ImpLevel, pAuthInfo, Capabilities ) ) && m_pObject->m_fUseSmartMultiTarget )
        {
            // Now repeat the above operation for the smart enumerator
            // Ignore the IUnknown if we are not remoting
            hr = WbemSetProxyBlanket(  m_pObject->m_pSmartMultiTarget, AuthnSvc, AuthzSvc, pServerPrincName,
                    AuthnLevel, ImpLevel, pAuthInfo, Capabilities, !m_pObject->m_fRemote );

        }   // If initialized smart enumerator

    }   // If Set Blanket on IUnknown

    return hr;
}

HRESULT STDMETHODCALLTYPE  CMultiTargetProxyBuffer::XMultiTargetFacelet::
CopyProxy( IUnknown* pProxy, IUnknown** ppCopy )
{
    HRESULT hr = S_OK;

    IClientSecurity*    pCliSec;

    // We pass through to the PUNKOuter
    hr = m_pObject->m_pUnkOuter->QueryInterface( IID_IClientSecurity, (void**) &pCliSec );

    if ( SUCCEEDED( hr ) )
    {
        hr = pCliSec->CopyProxy( pProxy, ppCopy );
        pCliSec->Release();
    }

    return hr;
}

//////////////////////////////////////////////
//////////////////////////////////////////////

//  IWbemMultiTarget Methods -- Pass Thrus for now

//////////////////////////////////////////////
//////////////////////////////////////////////

HRESULT STDMETHODCALLTYPE CMultiTargetProxyBuffer::XMultiTargetFacelet::
DeliverEvent(DWORD dwNumEvents, IWbemClassObject** apEvents, WBEM_REM_TARGETS* aTargets,
           long lSDLength, BYTE* pSD)
{
    // Also, we will need to queue calls into this proxy, preserving timeouts,
    // so I'm thinking a mutex would come in handy about now...

    HRESULT hr = WBEM_S_NO_ERROR;

    // Make sure we have a smart enumerator if we can get one
    m_pObject->InitSmartMultiTarget();

    // If we have a smart enumerator, go behind everyone's back and use this guy (nobody
    // will be the wiser...

    if ( m_pObject->m_fUseSmartMultiTarget && NULL != m_pObject->m_pSmartMultiTarget )
    {

        // Function MUST be thread safe
        CInCritSec ics(&m_pObject->m_cs);

        // Calculate data length first 
        DWORD dwLength;

        try
        {
            // Allocate arrays for the guid and the flags
            GUID*	pGUIDs = new GUID[dwNumEvents];
            BOOL*	pfSendFullObject = new BOOL[dwNumEvents];

			CVectorDeleteMe<GUID> vdmGUID( pGUIDs );
			CVectorDeleteMe<BOOL> vdmBOOL( pfSendFullObject );

			// Check allocations
			if ( NULL != pGUIDs && NULL != pfSendFullObject )
			{
				CWbemMtgtDeliverEventPacket packet;
				hr = packet.CalculateLength(dwNumEvents, apEvents, &dwLength, 
						m_ClassToIdMap, pGUIDs, pfSendFullObject );

				if ( SUCCEEDED( hr ) )
				{

					// As we could be going cross process/machine, use the
					// COM memory allocator
					LPBYTE pbData = (LPBYTE) CoTaskMemAlloc( dwLength );

					if ( NULL != pbData )
					{

						// Write the objects out to the buffer
						hr = packet.MarshalPacket( pbData, dwLength, dwNumEvents, 
													apEvents, pGUIDs, pfSendFullObject);

						// Copy the values, we're golden.
						if ( SUCCEEDED( hr ) )
						{
							// Now we can send the data to the stub
							hr = m_pObject->m_pSmartMultiTarget->DeliverEvent( dwNumEvents, dwLength, pbData, aTargets, lSDLength, pSD );
						}

						// Because the buffer is an [in] parameter, it lies on our heads
						// to free it up.
						CoTaskMemFree( pbData );
					}
					else
					{
						hr = WBEM_E_OUT_OF_MEMORY;
					}

	            }   // IF CalculateLength()

			}	// IF allocated arrays
			else
			{
				hr = WBEM_E_OUT_OF_MEMORY;
			}
        }
        catch (CX_MemoryException)
        {
            hr = WBEM_E_OUT_OF_MEMORY;
        }
        catch(...)
        {
            hr = WBEM_E_FAILED;
        }

    }   // IF using Smart Enumeration
    else
    {
        // No Smart enumerator (doh!), so use the old one
        hr = m_pObject->m_pOldProxyMultiTarget->DeliverEvent(dwNumEvents, apEvents, aTargets, lSDLength, pSD );
    }

    return hr;
}

HRESULT STDMETHODCALLTYPE CMultiTargetProxyBuffer::XMultiTargetFacelet::
DeliverStatus( long lFlags, HRESULT hresStatus, LPCWSTR wszStatus, IWbemClassObject* pErrorObj,
            WBEM_REM_TARGETS* pTargets, long lSDLength, BYTE* pSD)
{
    // Just pass through to the old sink.
    return m_pObject->m_pOldProxyMultiTarget->DeliverStatus( lFlags, hresStatus, wszStatus, pErrorObj, pTargets, lSDLength, pSD );
}


//***************************************************************************
//
//  STDMETHODIMP CMultiTargetProxyBuffer::Connect(IRpcChannelBuffer* pChannel)
//
//  DESCRIPTION:
//
//  Called during the initialization of the proxy.  The channel buffer is passed
//  to this routine.
//
//  RETURN VALUE:
//
//  S_OK                all is well
//
//***************************************************************************

STDMETHODIMP CMultiTargetProxyBuffer::Connect(IRpcChannelBuffer* pChannel)
{

    // get a pointer to the old sink which is in WBEMSVC.DLL  this allows
    // for backward compatibility

    IPSFactoryBuffer*   pIPS;

    // Establish the marshaling context
    DWORD   dwCtxt = 0;
    pChannel->GetDestCtx( &dwCtxt, NULL );

    m_fRemote = ( dwCtxt == MSHCTX_DIFFERENTMACHINE );

    // This is tricky --- The old proxys/stub stuff is actually registered under the
    // IID_IWbemObjectSink in wbemcli_p.cpp.  This single class id, is backpointered
    // by ProxyStubClsId32 entries for all the standard WBEM interfaces.

    HRESULT hr = CoGetClassObject( IID_IWbemObjectSink, CLSCTX_INPROC_HANDLER | CLSCTX_INPROC_SERVER,
                    NULL, IID_IPSFactoryBuffer, (void**) &pIPS );

	if ( SUCCEEDED( hr ) )
	{
		// We aggregated it --- WE OWN IT!
    
		hr = pIPS->CreateProxy( this, IID_IWbemMultiTarget, &m_pOldProxy, (void**) &m_pOldProxyMultiTarget );
		pIPS->Release();

		if ( SUCCEEDED( hr ) )
		{
			// Connect the old proxy to the channel
			hr = m_pOldProxy->Connect( pChannel );

			if ( SUCCEEDED( hr ) )
			{
				// Save an internal reference to the channel
				if(m_pChannel)
					return E_UNEXPECTED;
    
				m_pChannel = pChannel;
				if(m_pChannel)
					m_pChannel->AddRef();

			}	// IF Connect

		}	// IF CreateProxy

	}	// IF CoGetClassObject

    return hr;
}

//***************************************************************************
//
//  HRESULT CMultiTargetProxyBuffer::InitSmartMultiTarget(void)
//
//  DESCRIPTION:
//
//  Called during the initialization of the proxy.  This function sets up
//  the smart enumerator pointer so we can perform intelligent marshaling.
//  This cannot be called during a Connect operation.
//
//  RETURN VALUE:
//
//  S_OK                all is well
//
//***************************************************************************

HRESULT CMultiTargetProxyBuffer::InitSmartMultiTarget( BOOL fSetBlanket, DWORD AuthnSvc, DWORD AuthzSvc,
            OLECHAR* pServerPrincName, DWORD AuthnLevel, DWORD ImpLevel,
            void* pAuthInfo, DWORD Capabilities )
{
    HRESULT hr = WBEM_S_NO_ERROR;

    // Function MUST be thread safe
    CInCritSec ics(&m_cs);

    // If we haven't tried to estalish smart enumeration, do so now

    // If we haven't tried to get a smart enumerator, try to get one.  If
    // we are able to get one, initialize member data we will use in all
    // operations from this proxy.

    if ( NULL == m_pSmartMultiTarget )
    {

        // We'll only get this interface pointer if the server is a new
        // version that understands this interface.  If it does, the pointer
        // will be marshaled through for us.  To get to this pointer,
        // we go directly through our punkOuter.  From the "fetcher" interface
        // we will then get the actual smart enumerator.  We can then free up
        // the fetcher and release it's lock on the proxy manager.  The
        // smart enumerator will be handled on its own.

        IWbemFetchSmartMultiTarget* pFetchSmartMultiTarget;

        hr = m_pUnkOuter->QueryInterface( IID_IWbemFetchSmartMultiTarget, (void**) &pFetchSmartMultiTarget );

        // Generate a GUID to identify us when we call the smart enumerator
        if ( SUCCEEDED( hr ) )
        {

            // If we need to, set the blanket on the proxy, otherwise, the call to GetSmartEnum
            // may fail.
            if ( fSetBlanket )
            {
                // Ignore the IUnknown if we are not remoting
                hr = WbemSetProxyBlanket( pFetchSmartMultiTarget, AuthnSvc, AuthzSvc, pServerPrincName,
                            AuthnLevel, ImpLevel, pAuthInfo, Capabilities, !m_fRemote );
            }

            if ( SUCCEEDED( hr ) )
            {

                hr = pFetchSmartMultiTarget->GetSmartMultiTarget( &m_pSmartMultiTarget );

                if ( SUCCEEDED( hr ) )
                {
                    // We need a GUID
                    hr = CoCreateGuid( &m_guidSmartEnum );

                }   // IF got Smart MultiTarget

            }   // IF security OK
            
            // Done with the fetcher interface
            pFetchSmartMultiTarget->Release();

        }   // IF QueryInterface
        else
        {
            hr = WBEM_S_NO_ERROR;
        }

    }   // IF NULL == m_pSmartMultiTarget

    return hr;
}

//***************************************************************************
//
//  STDMETHODIMP CMultiTargetProxyBuffer::Disconnect(IRpcChannelBuffer* pChannel)
//
//  DESCRIPTION:
//
//  Called when the proxy is being disconnected.  It just frees various pointers.
//
//  RETURN VALUE:
//
//  S_OK                all is well
//
//***************************************************************************

void STDMETHODCALLTYPE CMultiTargetProxyBuffer::Disconnect()
{
    // Old Proxy code

    if(m_pOldProxy)
        m_pOldProxy->Disconnect();

    // Complete the Disconnect by releasing our references to the
    // old proxy pointers.  The old Proxy Enum MUST be released first.

    if ( NULL != m_pOldProxyMultiTarget )
    {
        m_pOldProxyMultiTarget->Release();
        m_pOldProxyMultiTarget = NULL;
    }

    if ( NULL != m_pOldProxy )
    {
        m_pOldProxy->Release();
        m_pOldProxy = NULL;
    }

    if(m_pChannel)
        m_pChannel->Release();
    m_pChannel = NULL;
}

//****************************************************************************
//****************************************************************************
//                          STUB
//****************************************************************************
//****************************************************************************


//***************************************************************************
//
//  void* CMultiTargetFactoryBuffer::GetInterface(REFIID riid)
//
//  DESCRIPTION:
//
//  CMultiTargetFactoryBuffer is derived from CUnk.  Since CUnk handles the QI calls,
//  all classes derived from this must support this function.
//
//  RETURN VALUE:
//
//  S_OK                all is well
//
//***************************************************************************


void* CMultiTargetStubBuffer::GetInterface(REFIID riid)
{
    if(riid == IID_IRpcStubBuffer)
        return &m_XMultiTargetStublet;
    else
        return NULL;
}

CMultiTargetStubBuffer::XMultiTargetStublet::XMultiTargetStublet(CMultiTargetStubBuffer* pObj) 
    : CImpl<IRpcStubBuffer, CMultiTargetStubBuffer>(pObj), m_pServer(NULL), m_lConnections( 0 )
{
}

CMultiTargetStubBuffer::XMultiTargetStublet::~XMultiTargetStublet() 
{
    if(m_pServer)
        m_pServer->Release();

    if ( NULL != m_pObject->m_pOldStub )
    {
        m_pObject->m_pOldStub->Release();
        m_pObject->m_pOldStub = NULL;
    }
}

//***************************************************************************
//
//  STDMETHODIMP CMultiTargetStubBuffer::Connect(IUnknown* pUnkServer)
//
//  DESCRIPTION:
//
//  Called during the initialization of the stub.  The pointer to the
//  IWbemObject sink object is passed in.
//
//  RETURN VALUE:
//
//  S_OK                all is well
//
//***************************************************************************

STDMETHODIMP CMultiTargetStubBuffer::XMultiTargetStublet::Connect(IUnknown* pUnkServer)
{
    if(m_pServer)
        return E_UNEXPECTED;

    HRESULT hres = pUnkServer->QueryInterface(IID_IWbemMultiTarget, 
                        (void**)&m_pServer);
    if(FAILED(hres))
        return E_NOINTERFACE;

    // get a pointer to the old stub which is in WBEMSVC.DLL  this allows
    // for backward compatibility

    IPSFactoryBuffer*   pIPS;

    // This is tricky --- The old proxys/stub stuff is actually registered under the
    // IID_IWbemObjectSink in wbemcli_p.cpp.  This single class id, is backpointered
    // by ProxyStubClsId32 entries for all the standard WBEM interfaces.

    HRESULT hr = CoGetClassObject( IID_IWbemObjectSink, CLSCTX_INPROC_HANDLER | CLSCTX_INPROC_SERVER,
                    NULL, IID_IPSFactoryBuffer, (void**) &pIPS );
    if (FAILED(hr))
    	return hr;

    hr = pIPS->CreateStub( IID_IWbemMultiTarget, m_pServer, &m_pObject->m_pOldStub );
    pIPS->Release();
    if (FAILED(hr))
    	return hr;    

    // Successful connection

    m_lConnections++;
    return S_OK;
}

//***************************************************************************
//
//  void STDMETHODCALLTYPE CMultiTargetStubBuffer::XMultiTargetStublet::Disconnect()
//
//  DESCRIPTION:
//
//  Called when the stub is being disconnected.  It frees the IWbemMultiTarget
//  pointer.
//
//  RETURN VALUE:
//
//  S_OK                all is well
//
//***************************************************************************

void STDMETHODCALLTYPE CMultiTargetStubBuffer::XMultiTargetStublet::Disconnect()
{
    // Inform the listener of the disconnect
    // =====================================

    HRESULT hres = S_OK;

    if(m_pObject->m_pOldStub)
        m_pObject->m_pOldStub->Disconnect();

    if(m_pServer)
    {
        m_pServer->Release();
        m_pServer = NULL;
    }

    // Successful disconnect
    m_lConnections--;

}


//***************************************************************************
//
//  STDMETHODIMP CMultiTargetStubBuffer::XMultiTargetStublet::Invoke(RPCOLEMESSAGE* pMessage, 
//                                        IRpcChannelBuffer* pChannel)
//
//  DESCRIPTION:
//
//  Called when a method reaches the stublet.  This checks the method id and
//  then branches to specific code for the Indicate, or SetStatus calls.
//
//  RETURN VALUE:
//
//  S_OK                all is well
//
//***************************************************************************

STDMETHODIMP CMultiTargetStubBuffer::XMultiTargetStublet::Invoke(RPCOLEMESSAGE* pMessage, 
                                        IRpcChannelBuffer* pChannel)
{
    // SetStatus is a pass through to the old layer
    return m_pObject->m_pOldStub->Invoke( pMessage, pChannel );
}

IRpcStubBuffer* STDMETHODCALLTYPE CMultiTargetStubBuffer::XMultiTargetStublet::IsIIDSupported(
                                    REFIID riid)
{
    if(riid == IID_IWbemMultiTarget)
    {
        // Don't AddRef().  At least that's what the sample on
        // Inside DCOM p.341 does.
        //AddRef(); // ?? not sure
        return this;
    }
    else return NULL;
}
    
ULONG STDMETHODCALLTYPE CMultiTargetStubBuffer::XMultiTargetStublet::CountRefs()
{
    // See Page 340-41 in Inside DCOM
    return m_lConnections;
}

STDMETHODIMP CMultiTargetStubBuffer::XMultiTargetStublet::DebugServerQueryInterface(void** ppv)
{
    if(m_pServer == NULL)
        return E_UNEXPECTED;

    *ppv = m_pServer;
    return S_OK;
}

void STDMETHODCALLTYPE CMultiTargetStubBuffer::XMultiTargetStublet::DebugServerRelease(void* pv)
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\marshalers\coreprox\mtgtpckt.h ===
/*++

Copyright (C) 1999-2001 Microsoft Corporation

Module Name:

    MTGTPCKT.H

Abstract:

   MultiTarget Packet class

History:

--*/
#ifndef __MULTITARGETPACKET_H__
#define __MULTITARGETPACKET_H__

#include "wbemdatapacket.h"
#include "wbemobjpacket.h"
#include "wbemclasstoidmap.h"
#include "wbemclasscache.h"

// Store the current packing value, then set our own value
#pragma pack( push )
#pragma pack( 1 )

// IWbemMultiTarget::DeliverEvent() Header.  Changing this will
// cause the main version to change
typedef struct tagWBEM_DATAPACKET_MULTITARGET_DELIVEREVENT
{
	DWORD	dwSizeOfHeader;	// Size of the header struct.  Data immediately follows header.
	DWORD	dwDataSize;		// Size of Data following header.
} WBEM_DATAPACKET_MULTITARGET_DELIVEREVENT;

typedef WBEM_DATAPACKET_MULTITARGET_DELIVEREVENT* PWBEM_DATAPACKET_MULTITARGET_DELIVEREVENT;

// restore packing
#pragma pack( pop )

//
//	Class: CWbemMtgtDeliverEventPacket
//
//	This class is designed to wrapper a data packet that describes an
//	IWbemMultiTarget::DeliverEvent() operation.  The data structure of this
//	packet is described above.  It makes use of CWbemObjectPacket,
//	CWbemInstancePacket, CWbemClassPacket and CWbemClasslessInstancePacket
//	to walk and analyze data for each of the IWbemClassObjects that
//	are indicated into the Sink.
//

class COREPROX_POLARITY CWbemMtgtDeliverEventPacket : public CWbemDataPacket
{

protected:

	PWBEM_DATAPACKET_MULTITARGET_DELIVEREVENT	m_pObjSinkIndicate;

public:

	CWbemMtgtDeliverEventPacket( LPBYTE pDataPacket = NULL, DWORD dwPacketLength = 0 );
	~CWbemMtgtDeliverEventPacket();

	HRESULT CalculateLength( LONG lObjectCount, IWbemClassObject** apClassObjects, DWORD* pdwLength, CWbemClassToIdMap& classtoidmap, GUID* pguidClassIds, BOOL* pfSendFullObject );
	HRESULT MarshalPacket( LONG lObjectCount, IWbemClassObject** apClassObjects, GUID* paguidClassIds, BOOL* pfSendFullObject );
	HRESULT UnmarshalPacket( LONG& lObjectCount, IWbemClassObject**& apClassObjects, CWbemClassCache& classcache );

	// inline helper
	HRESULT MarshalPacket( LPBYTE pData, DWORD dwPacketLength, LONG lObjectCount, IWbemClassObject** apClassObjects, GUID* paguidClassIds, BOOL* pfSendFullObject );

	// Change the underlying pointers
	// Override of base class
	void SetData( LPBYTE pDataPacket, DWORD dwPacketLength );

};

inline HRESULT CWbemMtgtDeliverEventPacket::MarshalPacket( LPBYTE pData, DWORD dwPacketLength, LONG lObjectCount, IWbemClassObject** apClassObjects, GUID* paguidClassIds, BOOL* pfSendFullObject )
{
	SetData( pData, dwPacketLength );
	return MarshalPacket( lObjectCount, apClassObjects, paguidClassIds, pfSendFullObject );
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\marshalers\coreprox\mtgtpckt.cpp ===
/*++

Copyright (C) 1999-2001 Microsoft Corporation

Module Name:

    MTGTPCKT.CPP

Abstract:

   MultiTarget Packet class

History:

--*/

#include "precomp.h"
#include <stdio.h>
#include <stdlib.h>
#include <wbemcomn.h>
#include <fastall.h>
#include "mtgtpckt.h"
#include "objarraypacket.h"

///////////////////////////////////////////////////////////////////
//
//  Function:   CWbemMtgtDeliverEventPacket::CWbemMtgtDeliverEventPacket
//  
//  Class Constructor
//
//  Inputs:
//              LPBYTE                      pDataPacket - Memory block.
//              DWORD                       dwPacketLength - Block Length.
//
//  Outputs:
//              None.
//
//  Returns:
//              None.
//
//  Comments:   Data must be supplied to this class for Unmarshaling
//              to succeed.
//
///////////////////////////////////////////////////////////////////

CWbemMtgtDeliverEventPacket::CWbemMtgtDeliverEventPacket( LPBYTE pDataPacket /* = NULL */, DWORD dwPacketLength /* = 0 */ )
:   CWbemDataPacket( pDataPacket, dwPacketLength ),
    m_pObjSinkIndicate( NULL )
{
    if ( NULL != pDataPacket )
    {
        m_pObjSinkIndicate = (PWBEM_DATAPACKET_MULTITARGET_DELIVEREVENT) (pDataPacket + sizeof(WBEM_DATAPACKET_HEADER) );
    }
}

///////////////////////////////////////////////////////////////////
//
//  Function:   CWbemMtgtDeliverEventPacket::~CWbemMtgtDeliverEventPacket
//  
//  Class Destructor
//
//  Inputs:
//              None.
//
//  Outputs:
//              None.
//
//  Returns:
//              None.
//
//  Comments:   None.
//
///////////////////////////////////////////////////////////////////

CWbemMtgtDeliverEventPacket::~CWbemMtgtDeliverEventPacket()
{
}

///////////////////////////////////////////////////////////////////
//
//  Function:   CWbemMtgtDeliverEventPacket::CalculateLength
//  
//  Calculates the length needed to packetize the supplied data.
//
//  Inputs:
//              LONG                lObjectCount - Number of objects
//              IWbemClassObject**  apClassObjects - Array of object pointers.
//
//  Outputs:
//              DWORD*              pdwLength - Calculated Length
//              CWbemClassToIdMap&  classtoidmap - Map of class names to
//                                                  GUIDs.
//              GUID*               pguidClassIds - Array of GUIDs
//              BOOL*               pfSendFullObject - Full object flag array
//
//  Returns:
//              WBEM_S_NO_ERROR if success.
//
//  Comments:   This function uses the classtoidmap to fill out the
//              Class ID and Full Object arrays.  So that the object
//              array can be correctly interpreted by MarshalPacket.
//
///////////////////////////////////////////////////////////////////

HRESULT CWbemMtgtDeliverEventPacket::CalculateLength( LONG lObjectCount, IWbemClassObject** apClassObjects, DWORD* pdwLength, CWbemClassToIdMap& classtoidmap, GUID* pguidClassIds, BOOL* pfSendFullObject )
{
    HRESULT hr = WBEM_S_NO_ERROR;
    DWORD   dwLength = 0;

    // Now get the size of the objects as described by the object array
    CWbemObjectArrayPacket  arrayPacket;

    hr = arrayPacket.CalculateLength( lObjectCount, apClassObjects, &dwLength, classtoidmap, pguidClassIds, pfSendFullObject );

    // Store the length if we're okey-dokey
    if ( SUCCEEDED( hr ) )
    {
        // Account for the header sizes
        *pdwLength = ( dwLength + sizeof( WBEM_DATAPACKET_HEADER ) + sizeof( WBEM_DATAPACKET_MULTITARGET_DELIVEREVENT ) );
    }
    
    return hr;

}

///////////////////////////////////////////////////////////////////
//
//  Function:   CWbemMtgtDeliverEventPacket::MarshalPacket
//  
//  Marshals the supplied data into a buffer.
//
//  Inputs:
//              LONG                lObjectCount - Nmber of objects to marshal.
//              IWbemClassObject**  apClassObjects - Array of objects to write
//              GUID*               paguidClassIds - Array of GUIDs for objects.
//              BOOL*               pfSendFullObject - Full bject flags
//  Outputs:
//              None.
//
//  Returns:
//              WBEM_S_NO_ERROR if success.
//
//  Comments:   The GUID array and the array of flags must be filled
//              out correctly and the buffer must be large enough to
//              handle the marshaling.  The arrays will get filled
//              out correctly by CalculateLength().
//
///////////////////////////////////////////////////////////////////

HRESULT CWbemMtgtDeliverEventPacket::MarshalPacket( LONG lObjectCount, IWbemClassObject** apClassObjects, GUID* paguidClassIds, BOOL* pfSendFullObject )
{
    HRESULT hr = WBEM_E_FAILED;
    
    // Setup the main header first
    hr = SetupDataPacketHeader( m_dwPacketLength - sizeof(WBEM_DATAPACKET_HEADER), WBEM_DATAPACKETTYPE_MULTITARGET_DELIVEREVENT, 0 );

    if ( SUCCEEDED( hr ) )
    {
        // Setup pbData and dwLength so we can walk through our header
        LPBYTE  pbData      =   (LPBYTE) m_pObjSinkIndicate;
        DWORD   dwLength    =   m_dwPacketLength - sizeof(WBEM_DATAPACKET_HEADER);

        // Fill out the Indicate Header
        m_pObjSinkIndicate->dwSizeOfHeader = sizeof(WBEM_DATAPACKET_MULTITARGET_DELIVEREVENT);
        m_pObjSinkIndicate->dwDataSize = dwLength - sizeof(WBEM_DATAPACKET_MULTITARGET_DELIVEREVENT);

        // Account for the indicate header
        pbData += sizeof(WBEM_DATAPACKET_MULTITARGET_DELIVEREVENT);
        dwLength -= sizeof(WBEM_DATAPACKET_MULTITARGET_DELIVEREVENT);

        // Now use the array packet class to marshal the objects into the buffer
        CWbemObjectArrayPacket  arrayPacket( pbData, dwLength );
        hr = arrayPacket.MarshalPacket( lObjectCount, apClassObjects, paguidClassIds, pfSendFullObject );

    }   // IF SetupDataPacketHeader

    return hr;
}

///////////////////////////////////////////////////////////////////
//
//  Function:   CWbemMtgtDeliverEventPacket::UnmarshalPacket
//  
//  Unmarshals data from a buffer into the supplied parameters.
//
//  Inputs:
//              None.
//  Outputs:
//              LONG&               lObjectCount - Number of unmarshaled objects.
//              IWbemClassObject**& apClassObjects - Array of unmarshaled objects,
//              CWbemClassCache&    classCache - Class Cache used to wire up
//                                                  classless instances.
//
//  Returns:
//              WBEM_S_NO_ERROR if success.
//
//  Comments:   If function succeeds, the caller is responsible for cleaning
//              up and freeing the Class Object Array.  The class cache is
//              only used when we are dealing with Instance objects..
//
///////////////////////////////////////////////////////////////////

HRESULT CWbemMtgtDeliverEventPacket::UnmarshalPacket( LONG& lObjectCount, IWbemClassObject**& apClassObjects, CWbemClassCache& classCache )
{
    HRESULT hr = WBEM_E_FAILED;
    LPBYTE  pbData = (LPBYTE) m_pObjSinkIndicate;
    DWORD   dwLength    =   m_dwPacketLength - sizeof(WBEM_DATAPACKET_HEADER);

    // Set the array to NULL.
    apClassObjects = NULL;

    // Check that the underlying BLOB is OK
    hr = IsValid();

    if ( SUCCEEDED( hr ) )
    {
        // Skip past the headers, and use the object array to unmarshal the
        // objects from the buffer

        // Points us at the first object
        pbData += sizeof(WBEM_DATAPACKET_MULTITARGET_DELIVEREVENT);
        dwLength -= sizeof(WBEM_DATAPACKET_MULTITARGET_DELIVEREVENT);

        CWbemObjectArrayPacket  arrayPacket( pbData, dwLength );
        if (arrayPacket.IsValid())
        	hr = arrayPacket.UnmarshalPacket( lObjectCount, apClassObjects, classCache );
        else
        	hr = WBEM_E_FAILED;

    }   // IF IsValid

    return hr;
}

///////////////////////////////////////////////////////////////////
//
//  Function:   CWbemMtgtDeliverEventPacket::SetData
//  
//  Sets buffer to Marshal/Unmarshal to
//
//  Inputs:
//              LPBYTE                      pDataPacket - Memory block.
//              DWORD                       dwPacketLength - Block Length.
//
//  Outputs:
//              None.
//
//  Returns:
//              None.
//
//  Comments:   Data must be supplied to this class for IsValid
//              to succeed.
//
///////////////////////////////////////////////////////////////////

void CWbemMtgtDeliverEventPacket::SetData( LPBYTE pDataPacket, DWORD dwPacketLength )
{
    // Go to our offset in the packet (assuming the packet is valid)
    if ( NULL != pDataPacket )
    {
        m_pObjSinkIndicate = (PWBEM_DATAPACKET_MULTITARGET_DELIVEREVENT) (pDataPacket + sizeof(WBEM_DATAPACKET_HEADER) );
    }
    else
    {
        m_pObjSinkIndicate = NULL;
    }

    // Initialize the base class
    CWbemDataPacket::SetData( pDataPacket, dwPacketLength );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\marshalers\coreprox\objarraypacket.cpp ===
/*++

Copyright (C) 1998-2001 Microsoft Corporation

Module Name:

    OBJARRAYPACKET.CPP

Abstract:

   Object Array Packet class

History:

--*/

#include "precomp.h"
#include <stdio.h>
#include <stdlib.h>
#include <wbemcomn.h>
#include <fastall.h>
#include "objarraypacket.h"

///////////////////////////////////////////////////////////////////
//
//  Function:   CWbemObjectArrayPacket::CWbemObjectArrayPacket
//  
//  Class Constructor
//
//  Inputs:
//              LPBYTE                      pDataPacket - Memory block.
//              DWORD                       dwPacketLength - Block Length.
//
//  Outputs:
//              None.
//
//  Returns:
//              None.
//
//  Comments:   Data must be supplied to this class for Unmarshaling
//              to succeed.
//
///////////////////////////////////////////////////////////////////

CWbemObjectArrayPacket::CWbemObjectArrayPacket( LPBYTE pDataPacket /* = NULL */, DWORD dwPacketLength /* = 0 */ )
:   m_pObjectArrayHeader( (PWBEM_DATAPACKET_OBJECT_ARRAY) pDataPacket ),
    m_dwPacketLength( dwPacketLength )
{
}

///////////////////////////////////////////////////////////////////
//
//  Function:   CWbemObjectArrayPacket::~CWbemObjectArrayPacket
//  
//  Class Destructor
//
//  Inputs:
//              None.
//
//  Outputs:
//              None.
//
//  Returns:
//              None.
//
//  Comments:   None.
//
///////////////////////////////////////////////////////////////////

CWbemObjectArrayPacket::~CWbemObjectArrayPacket()
{
}

///////////////////////////////////////////////////////////////////
//
//  Function:   CWbemObjectArrayPacket::CalculateLength
//  
//  Calculates the length needed to packetize the supplied data.
//
//  Inputs:
//              LONG                lObjectCount - Number of objects
//              IWbemClassObject**  apClassObjects - Array of object pointers.
//
//  Outputs:
//              DWORD*              pdwLength - Calculated Length
//              CWbemClassToIdMap&  classtoidmap - Map of class names to
//                                                  GUIDs.
//              GUID*               pguidClassIds - Array of GUIDs
//              BOOL*               pfSendFullObject - Full object flag array
//
//  Returns:
//              WBEM_S_NO_ERROR if success.
//
//  Comments:   This function uses the classtoidmap to fill out the
//              Class ID and Full Object arrays.  So that the object
//              array can be correctly interpreted by MarshalPacket.
//
///////////////////////////////////////////////////////////////////

HRESULT CWbemObjectArrayPacket::CalculateLength( LONG lObjectCount, IWbemClassObject** apClassObjects, DWORD* pdwLength, CWbemClassToIdMap& classtoidmap, GUID* pguidClassIds, BOOL* pfSendFullObject )
{
    HRESULT hr = WBEM_S_NO_ERROR;

    // Initial length is the size of this header
    DWORD   dwLength = sizeof( WBEM_DATAPACKET_OBJECT_ARRAY );

    // We'll need these in the loop
    CWbemObjectPacket   objectPacket;
    DWORD               dwObjectLength = 0;

    // This is so we only allocate buffers as we need them, and not for every
    // call to GetClassId and AssignClassId.
    CMemBuffer          buff;

    for (   LONG lCtr = 0;
            lCtr < lObjectCount
            && SUCCEEDED( hr );
            lCtr++ )
    {
        CWbemObject*    pWbemObject = (CWbemObject*) apClassObjects[lCtr];

        if ( pWbemObject->IsObjectInstance() == WBEM_S_NO_ERROR )
        {
            // Send the object to the map first trying to get an appropriate
            // class id, and if that fails, then to add the object to the map.

            hr = classtoidmap.GetClassId( pWbemObject, &pguidClassIds[lCtr], &buff );

            if ( FAILED( hr ) )
            {
                hr = classtoidmap.AssignClassId( pWbemObject, &pguidClassIds[lCtr], &buff );
                pfSendFullObject[lCtr] = TRUE;
            }
            else
            {
                // Got an id, so this instance is partial
                pfSendFullObject[lCtr] = FALSE;
            }

        }   // IF IsObjectInstance()
        else
        {
            // It's a class
            pfSendFullObject[lCtr] = TRUE;
            hr = WBEM_S_NO_ERROR;
        }

        if ( SUCCEEDED( hr ) )
        {
            hr = objectPacket.CalculatePacketLength( apClassObjects[lCtr], &dwObjectLength, pfSendFullObject[lCtr]  );

            if ( SUCCEEDED( hr ) )
            {
                dwLength += dwObjectLength;
            }
        }   // IF GOT Length

    }
    
    if ( SUCCEEDED( hr ) )
    {
        *pdwLength = dwLength;
    }
    
    return hr;

}

///////////////////////////////////////////////////////////////////
//
//  Function:   CWbemObjectArrayPacket::MarshalPacket
//  
//  Marshals the supplied data into a buffer.
//
//  Inputs:
//              LONG                lObjectCount - Nmber of objects to marshal.
//              IWbemClassObject**  apClassObjects - Array of objects to write
//              GUID*               paguidClassIds - Array of GUIDs for objects.
//              BOOL*               pfSendFullObject - Full bject flags
//  Outputs:
//              None.
//
//  Returns:
//              WBEM_S_NO_ERROR if success.
//
//  Comments:   The GUID array and the array of flags must be filled
//              out correctly and the buffer must be large enough to
//              handle the marshaling.  The arrays will get filled
//              out correctly by CalculateLength().
//
///////////////////////////////////////////////////////////////////

HRESULT CWbemObjectArrayPacket::MarshalPacket( LONG lObjectCount, IWbemClassObject** apClassObjects, GUID* paguidClassIds, BOOL* pfSendFullObject )
{
    HRESULT hr = WBEM_S_NO_ERROR;
    
    // We must have a buffer to work with

    if ( NULL != m_pObjectArrayHeader )
    {
        // Fill out the array Header
        m_pObjectArrayHeader->dwSizeOfHeader = sizeof(WBEM_DATAPACKET_OBJECT_ARRAY);
        m_pObjectArrayHeader->dwDataSize = m_dwPacketLength - sizeof(WBEM_DATAPACKET_OBJECT_ARRAY);
        m_pObjectArrayHeader->dwNumObjects = lObjectCount;

        // Only makes sense if the object count is greater than 0
        if ( 0 < lObjectCount )
        {
            // Now, setup pbData and dwLength so we can walk through our buffer
            // Account for the header when we do this

            LPBYTE  pbData      =   ((LPBYTE) m_pObjectArrayHeader + m_pObjectArrayHeader->dwSizeOfHeader);
            DWORD   dwLength    =   m_dwPacketLength - m_pObjectArrayHeader->dwSizeOfHeader;

            DWORD                           dwObjectLength = 0;
            CWbemObjectPacket               objectPacket;
            CWbemClassPacket                classPacket;
            CWbemInstancePacket             instancePacket;
            CWbemClasslessInstancePacket    classlessInstancePacket;

            for (   LONG    lCtr = 0;
                    SUCCEEDED( hr ) &&  lCtr < lObjectCount;
                    lCtr++,
                    pbData += dwObjectLength,
                    dwLength -= dwObjectLength )
            {
                CWbemObject* pWbemObject = (CWbemObject*) apClassObjects[lCtr];

                // Send to the appropriate object for streaming
                if ( pWbemObject->IsObjectInstance() == WBEM_S_NO_ERROR )
                {
                    // Either full or classless instance
                    if ( pfSendFullObject[lCtr] )
                    {
                        hr = instancePacket.WriteToPacket( pbData, dwLength, apClassObjects[lCtr], paguidClassIds[lCtr], &dwObjectLength );
                    }
                    else
                    {
                        hr = classlessInstancePacket.WriteToPacket( pbData, dwLength, apClassObjects[lCtr], paguidClassIds[lCtr], &dwObjectLength );
                    }
                }
                else
                {
                    // A class on its own
                    hr = classPacket.WriteToPacket( pbData, dwLength, apClassObjects[lCtr], &dwObjectLength );
                }

            }

        }   // IF lObjectCount

    }   // IF SetupDataPacketHeader
    else
    {
        hr = WBEM_E_INVALID_OPERATION;
    }

    return hr;
}


bool 
CWbemObjectArrayPacket::IsValid()
{
	int objectCount = 0;
	size_t processedSize = sizeof(WBEM_DATAPACKET_OBJECT_ARRAY);
	LPBYTE  pbData = (LPBYTE) m_pObjectArrayHeader;
       pbData += sizeof(WBEM_DATAPACKET_OBJECT_ARRAY);		

	while(processedSize < m_dwPacketLength && objectCount < m_pObjectArrayHeader->dwNumObjects )
		{
              CWbemObjectPacket   objectPacket( pbData, m_dwPacketLength - processedSize );				
		if (!objectPacket.IsValid()) return false;
		size_t nextSize = objectPacket.GetDataSize()+ sizeof(WBEM_DATAPACKET_OBJECT_HEADER);
              switch(objectPacket.GetObjectType())
              	{
              	case WBEMOBJECT_CLASS_FULL:
              		{
    					CWbemClassPacket instancePacket( pbData, nextSize);              		
	    				if (!instancePacket.IsValid()) return false;
	    				break;
              		}
              	case WBEMOBJECT_INSTANCE_FULL:
              		{
    					CWbemInstancePacket instancePacket( pbData, nextSize);              		
	    				if (!instancePacket.IsValid()) return false;
	    				break;
              		}
              	case WBEMOBJECT_INSTANCE_NOCLASS:
              		{
    					CWbemClasslessInstancePacket instancePacket( pbData, nextSize);              		
	    				if (!instancePacket.IsValid()) return false;
	    				break;
              		}
              	default:
              		return false;
              	}

              pbData += sizeof(WBEM_DATAPACKET_OBJECT_HEADER);
              pbData += objectPacket.GetDataSize();
              processedSize += sizeof(WBEM_DATAPACKET_OBJECT_HEADER);
              processedSize += objectPacket.GetDataSize();
              objectCount++;
		};
	if (objectCount == m_pObjectArrayHeader->dwNumObjects && processedSize <= m_dwPacketLength)
		return true;
	else
		return false;

};


///////////////////////////////////////////////////////////////////
//
//  Function:   CWbemObjectArrayPacket::UnmarshalPacket
//  
//  Unmarshals data from a buffer into the supplied parameters.
//
//  Inputs:
//              None.
//  Outputs:
//              LONG&               lObjectCount - Number of unmarshaled objects.
//              IWbemClassObject**& apClassObjects - Array of unmarshaled objects,
//              CWbemClassCache&    classCache - Class Cache used to wire up
//                                                  classless instances.
//
//  Returns:
//              WBEM_S_NO_ERROR if success.
//
//  Comments:   If function succeeds, the caller is responsible for cleaning
//              up and freeing the Class Object Array.  The class cache is
//              only used when we are dealing with Instance objects..
//
///////////////////////////////////////////////////////////////////

HRESULT CWbemObjectArrayPacket::UnmarshalPacket( LONG& lObjectCount, IWbemClassObject**& apClassObjects, CWbemClassCache& classCache )
{
	if (!IsValid()) return WBEM_E_FAILED;
	
	
    HRESULT hr = WBEM_S_NO_ERROR;

    
    LPBYTE  pbData = (LPBYTE) m_pObjectArrayHeader;

    // Set the array to NULL.
    apClassObjects = NULL;

    // Make sure we have a pointer
    if ( NULL != m_pObjectArrayHeader )
    {
        // Store how many objects follow
        lObjectCount = m_pObjectArrayHeader->dwNumObjects;

        if ( lObjectCount > 0 )
        {
            apClassObjects = new IWbemClassObject*[lObjectCount];

            if ( NULL != apClassObjects )
            {
                // Count unmarshaled objects so if an error occurs, we release any objects
                // we did marshal.

                LONG    lUnmarshaledObjects = 0;

                // Points us at the first object
                pbData += sizeof(WBEM_DATAPACKET_OBJECT_ARRAY);

                for (   LONG lCtr = 0;
                        SUCCEEDED( hr ) && lCtr < lObjectCount;
                        lCtr++ )
                {
                    CWbemObjectPacket   objectPacket( pbData );

                    switch ( objectPacket.GetObjectType() )
                    {
                        case WBEMOBJECT_CLASS_FULL:
                        {
                            hr = GetClassObject( objectPacket, &apClassObjects[lCtr] );
                        }
                        break;

                        case WBEMOBJECT_INSTANCE_FULL:
                        {
                            hr = GetInstanceObject( objectPacket, &apClassObjects[lCtr], classCache );
                        }
                        break;

                        case WBEMOBJECT_INSTANCE_NOCLASS:
                        {
                            hr = GetClasslessInstanceObject( objectPacket, &apClassObjects[lCtr], classCache );
                        }
                        break;

                        default:
                        {
                            // What is this?
                            hr = WBEM_E_UNKNOWN_OBJECT_TYPE;
                        }
                    }

                    if ( SUCCEEDED( hr ) )
                    {
                        // Go to the next object, so account for header size and
                        // the actual packet size

                        pbData += sizeof(WBEM_DATAPACKET_OBJECT_HEADER);
                        pbData += objectPacket.GetDataSize();
                        lUnmarshaledObjects++;
                    }

                }   // FOR enum objects

                // IF we failed unmarshaling, make sure we release any marshaled
                // objects.

                if ( FAILED( hr ) )
                {
                    for ( lCtr = 0; lCtr < lUnmarshaledObjects; lCtr++ )
                    {
                        apClassObjects[lCtr]->Release();
                    }

                    // Clean up the array
                    delete [] apClassObjects;
                    apClassObjects = NULL;

                }   // IF unmarshaling failed

            }
            else
            {
                hr = WBEM_E_OUT_OF_MEMORY;
            }

        }   // IF lObjectCount

    }   // IF m_pObjectArrayHeader
    else
    {
        hr = WBEM_E_INVALID_OPERATION;
    }

    return hr;
}

///////////////////////////////////////////////////////////////////
//
//  Function:   CWbemObjectArrayPacket::GetClassObject
//  
//  Unmarshals a class object from the supplid buffer.
//
//  Inputs:
//              CWbemObjectPacket&  objectPacket - Object Packet containing data.
//
//  Outputs:
//              IWbemClassObject**  ppObj - Pointer to unmarshaled object.
//
//  Returns:
//              WBEM_S_NO_ERROR if success.
//
//  Comments:   Object is AddRefed, so it is up to caller to Release it.
//
///////////////////////////////////////////////////////////////////

HRESULT CWbemObjectArrayPacket::GetClassObject( CWbemObjectPacket& objectPacket, IWbemClassObject** ppObj )
{
    CWbemClassPacket    classPacket( objectPacket );
    CWbemClass*         pClass = NULL;

    HRESULT hr = classPacket.GetWbemClassObject( &pClass );

    if ( SUCCEEDED( hr ) )
    {
        *ppObj = (IWbemClassObject*) pClass;
    }
    
    return hr;
}

///////////////////////////////////////////////////////////////////
//
//  Function:   CWbemObjectArrayPacket::GetInstanceObject
//  
//  Unmarshals a full instance object from the supplied buffer.
//
//  Inputs:
//              CWbemObjectPacket&  objectPacket - Object Packet containing data.
//
//  Outputs:
//              IWbemClassObject**  ppObj - Pointer to unmarshaled object.
//              CWbemClassCache&    classCache - Store full instances here.
//
//  Returns:
//              WBEM_S_NO_ERROR if success.
//
//  Comments:   Object is AddRefed, so it is up to caller to Release it.
//              Full Instances are added to the supplied  cache.
//
///////////////////////////////////////////////////////////////////

HRESULT CWbemObjectArrayPacket::GetInstanceObject( CWbemObjectPacket& objectPacket, IWbemClassObject** ppObj, CWbemClassCache& classCache )
{
    CWbemInstancePacket instancePacket( objectPacket );
    CWbemInstance*      pInstance = NULL;
    GUID                guidClassId;

    HRESULT hr = instancePacket.GetWbemInstanceObject( &pInstance, guidClassId );

    if ( SUCCEEDED( hr ) )
    {

        // Now, we need to actually separate out the class part from the
        // instance and place it in its own object so the outside world
        // cannot touch the object.

        DWORD   dwClassObjectLength = 0;

        // Get length should fail with a buffer too small error
        hr = pInstance->GetObjectParts( NULL, 0,
                WBEM_OBJ_DECORATION_PART | WBEM_OBJ_CLASS_PART, &dwClassObjectLength );

        if ( WBEM_E_BUFFER_TOO_SMALL == hr )
        {
            DWORD   dwTempLength;
            LPBYTE  pbData = CBasicBlobControl::sAllocate(dwClassObjectLength);

            if ( NULL != pbData )
            {

                hr = pInstance->GetObjectParts( pbData, dwClassObjectLength,
                        WBEM_OBJ_DECORATION_PART | WBEM_OBJ_CLASS_PART, &dwTempLength );

                if ( SUCCEEDED( hr ) )
                {
                    // Allocate an object to hold the class data and then
                    // stuff in the binary data.

                    CWbemInstance*  pClassData = new CWbemInstance;

                    if ( NULL != pClassData )
                    {
                        pClassData->SetData( pbData, dwClassObjectLength,
                            WBEM_OBJ_DECORATION_PART | WBEM_OBJ_CLASS_PART |
                            WBEM_OBJ_CLASS_PART_INTERNAL );

                        // Add the class data object to the cache
                        hr = classCache.AddObject( guidClassId, pClassData );

                        if ( SUCCEEDED( hr ) )
                        {
                            // Merge the full instance with this object
                            // and we're done

                            hr = pInstance->MergeClassPart( pClassData );

                            if ( SUCCEEDED( hr ) )
                            {
                                *ppObj = (IWbemClassObject*) pInstance;
                            }
                        }

                        // There will be one additional addref on the class data,
                        // object, so release it here.  If the object wasn't
                        // added into the map, this will free it.
                        pClassData->Release();

                    }   // IF pClassData
                    else
                    {
                        hr = WBEM_E_OUT_OF_MEMORY;
                    }

                }   // IF GetObjectParts

            }   // IF pbData
            else
            {
                hr = WBEM_E_OUT_OF_MEMORY;
            }


        }   // IF GetObjectParts

        // Clean up the instance if something went wrong
        if ( FAILED( hr ) )
        {
            pInstance->Release();
        }
    }

    return hr;
}

///////////////////////////////////////////////////////////////////
//
//  Function:   CWbemObjectArrayPacket::GetClasslessInstanceObject
//  
//  Unmarshals a classless instance object from the supplied buffer.
//
//  Inputs:
//              CWbemObjectPacket&  objectPacket - Object Packet containing data.
//
//  Outputs:
//              IWbemClassObject**  ppObj - Pointer to unmarshaled object.
//              CWbemClassCache&    classCache - Hook up instances here.
//
//  Returns:
//              WBEM_S_NO_ERROR if success.
//
//  Comments:   Object is AddRefed, so it is up to caller to Release it.
//              Classless Instances are wired up using data from the
//              the supplied cache.
//
///////////////////////////////////////////////////////////////////

HRESULT CWbemObjectArrayPacket::GetClasslessInstanceObject( CWbemObjectPacket& objectPacket, IWbemClassObject** ppObj, CWbemClassCache& classCache )
{
    CWbemClasslessInstancePacket    classlessinstancePacket( objectPacket );
    CWbemInstance*                  pInstance = NULL;
    GUID                            guidClassId;

    HRESULT hr = classlessinstancePacket.GetWbemInstanceObject( &pInstance, guidClassId );


    if ( SUCCEEDED( hr ) )
    {
        IWbemClassObject*   pObj = NULL;

        // Causes an AddRef
        hr = classCache.GetObject( guidClassId, &pObj );

        if ( SUCCEEDED( hr ) )
        {
            // merge the class part and we're done
            hr = pInstance->MergeClassPart( pObj );

            if ( SUCCEEDED( hr ) )
            {
                *ppObj = (IWbemClassObject*) pInstance;
            }

            // Done with this object
            pObj->Release();
        }

        // Clean up the instance if anything went wrong above
        if ( FAILED( hr ) )
        {
            pInstance->Release();
        }

    }   // IF GotInstance

    return hr;
}

///////////////////////////////////////////////////////////////////
//
//  Function:   CWbemObjectArrayPacket::SetData
//  
//  Sets buffer to Marshal/Unmarshal to
//
//  Inputs:
//              LPBYTE                      pDataPacket - Memory block.
//              DWORD                       dwPacketLength - Block Length.
//
//  Outputs:
//              None.
//
//  Returns:
//              None.
//
//  Comments:   Data must be supplied to this class for IsValid
//              to succeed.
//
///////////////////////////////////////////////////////////////////

void CWbemObjectArrayPacket::SetData( LPBYTE pDataPacket, DWORD dwPacketLength )
{
    // This is our packet (no offset calculations necessary)
    m_pObjectArrayHeader = (PWBEM_DATAPACKET_OBJECT_ARRAY) pDataPacket;
    m_dwPacketLength = dwPacketLength;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\marshalers\coreprox\objarraypacket.h ===
/*++

Copyright (C) 1998-2001 Microsoft Corporation

Module Name:

    OBJARRAYPACKET.H

Abstract:

   Object Array Packet class

History:

--*/

#ifndef __OBJARRAYPACKET_H__
#define __OBJARRAYPACKET_H__

#include "wbemdatapacket.h"
#include "wbemobjpacket.h"
#include "wbemclasstoidmap.h"
#include "wbemclasscache.h"

// Store the current packing value, then set our own value
#pragma pack( push )
#pragma pack( 1 )

// IWbemClassObject Array Header.  Changing this will
// cause the main version to change
typedef struct tagWBEM_DATAPACKET_OBJECT_ARRAY
{
	DWORD	dwSizeOfHeader;	// Size of the header struct.  Data immediately follows header.
	DWORD	dwDataSize;		// Size of Data following header.
	DWORD	dwNumObjects;	// Number of objects in the array
} WBEM_DATAPACKET_OBJECT_ARRAY;

typedef WBEM_DATAPACKET_OBJECT_ARRAY* PWBEM_DATAPACKET_OBJECT_ARRAY;

// restore packing
#pragma pack( pop )

//
//	Class: CWbemObjectArrayPacket
//
//	This class is designed to wrapper an array of IWbemClassObjects.
//	The objects are written out to and read in from a byte array which
//	is supplied to this class by an outside source.
//

class COREPROX_POLARITY CWbemObjectArrayPacket
{
private:
	HRESULT GetClassObject( CWbemObjectPacket& objectPacket, IWbemClassObject** ppObj );
	HRESULT GetInstanceObject( CWbemObjectPacket& objectPacket, IWbemClassObject** ppObj, CWbemClassCache& classCache );
	HRESULT GetClasslessInstanceObject( CWbemObjectPacket& objectPacket, IWbemClassObject** ppObj, CWbemClassCache& classCache );

protected:

	PWBEM_DATAPACKET_OBJECT_ARRAY	m_pObjectArrayHeader;
	DWORD							m_dwPacketLength;

public:

	CWbemObjectArrayPacket( LPBYTE pDataPacket = NULL, DWORD dwPacketLength = 0 );
	~CWbemObjectArrayPacket();

	HRESULT CalculateLength( LONG lObjectCount, IWbemClassObject** apClassObjects, DWORD* pdwLength, CWbemClassToIdMap& classtoidmap, GUID* pguidClassIds, BOOL* pfSendFullObject );
	HRESULT MarshalPacket( LONG lObjectCount, IWbemClassObject** apClassObjects, GUID* paguidClassIds, BOOL* pfSendFullObject );
	HRESULT UnmarshalPacket( LONG& lObjectCount, IWbemClassObject**& apClassObjects, CWbemClassCache& classcache );
	bool IsValid();

	// inline helper
	HRESULT MarshalPacket( LPBYTE pData, DWORD dwPacketLength, LONG lObjectCount, IWbemClassObject** apClassObjects, GUID* paguidClassIds, BOOL* pfSendFullObject );

	// Change the underlying pointers
	virtual void SetData( LPBYTE pDataPacket, DWORD dwPacketLength );

};

inline HRESULT CWbemObjectArrayPacket::MarshalPacket( LPBYTE pData, DWORD dwPacketLength, LONG lObjectCount, IWbemClassObject** apClassObjects, GUID* paguidClassIds, BOOL* pfSendFullObject )
{
	SetData( pData, dwPacketLength );
	return MarshalPacket( lObjectCount, apClassObjects, paguidClassIds, pfSendFullObject );
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\marshalers\coreprox\objindpacket.h ===
/*++

Copyright (C) 1998-2001 Microsoft Corporation

Module Name:

   OBJINDPACKET.H

Abstract:

   Object Sink Indicate packet.

History:

--*/

#ifndef __OBJINDPACKET_H__
#define __OBJINDPACKET_H__

#include "wbemdatapacket.h"
#include "wbemobjpacket.h"
#include "wbemclasstoidmap.h"
#include "wbemclasscache.h"

// Store the current packing value, then set our own value
#pragma pack( push )
#pragma pack( 1 )

// IWbemObjectSink::Indicate() Header.  Changing this will
// cause the main version to change
typedef struct tagWBEM_DATAPACKET_OBJECTSINK_INDICATE
{
	DWORD	dwSizeOfHeader;	// Size of the header struct.  Data immediately follows header.
	DWORD	dwDataSize;		// Size of Data following header.
} WBEM_DATAPACKET_OBJECTSINK_INDICATE;

typedef WBEM_DATAPACKET_OBJECTSINK_INDICATE* PWBEM_DATAPACKET_OBJECTSINK_INDICATE;

// restore packing
#pragma pack( pop )

//
//	Class: CWbemObjSinkIndicatePacket
//
//	This class is designed to wrapper a data packet that describes an
//	IWbemObjectSink::Indicate() operation.  The data structure of this
//	packet is described above.  It makes use of CWbemObjectPacket,
//	CWbemInstancePacket, CWbemClassPacket and CWbemClasslessInstancePacket
//	to walk and analyze data for each of the IWbemClassObjects that
//	are indicated into the Sink.
//

class CWbemObjSinkIndicatePacket : public CWbemDataPacket
{

protected:

	PWBEM_DATAPACKET_OBJECTSINK_INDICATE	m_pObjSinkIndicate;

public:

	CWbemObjSinkIndicatePacket( LPBYTE pDataPacket = NULL, DWORD dwPacketLength = 0 );
	~CWbemObjSinkIndicatePacket();

	HRESULT CalculateLength( LONG lObjectCount, IWbemClassObject** apClassObjects, DWORD* pdwLength, CWbemClassToIdMap& classtoidmap, GUID* pguidClassIds, BOOL* pfSendFullObject );
	HRESULT MarshalPacket( LONG lObjectCount, IWbemClassObject** apClassObjects, GUID* paguidClassIds, BOOL* pfSendFullObject );
	HRESULT UnmarshalPacket( LONG& lObjectCount, IWbemClassObject**& apClassObjects, CWbemClassCache& classcache );

	// inline helper
	HRESULT MarshalPacket( LPBYTE pData, DWORD dwPacketLength, LONG lObjectCount, IWbemClassObject** apClassObjects, GUID* paguidClassIds, BOOL* pfSendFullObject );

	// Change the underlying pointers
	// Override of base class
	void SetData( LPBYTE pDataPacket, DWORD dwPacketLength );

};

inline HRESULT CWbemObjSinkIndicatePacket::MarshalPacket( LPBYTE pData, DWORD dwPacketLength, LONG lObjectCount, IWbemClassObject** apClassObjects, GUID* paguidClassIds, BOOL* pfSendFullObject )
{
	SetData( pData, dwPacketLength );
	return MarshalPacket( lObjectCount, apClassObjects, paguidClassIds, pfSendFullObject );
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\marshalers\coreprox\objindpacket.cpp ===
/*++

Copyright (C) 1998-2001 Microsoft Corporation

Module Name:

   OBJINDPACKET.CPP

Abstract:

   Object Sink Indicate packet.

History:

--*/

#include "precomp.h"
#include <stdio.h>
#include <stdlib.h>
#include <wbemcomn.h>
#include <fastall.h>
#include "objindpacket.h"
#include "objarraypacket.h"

///////////////////////////////////////////////////////////////////
//
//  Function:   CWbemObjSinkIndicatePacket::CWbemObjSinkIndicatePacket
//  
//  Class Constructor
//
//  Inputs:
//              LPBYTE                      pDataPacket - Memory block.
//              DWORD                       dwPacketLength - Block Length.
//
//  Outputs:
//              None.
//
//  Returns:
//              None.
//
//  Comments:   Data must be supplied to this class for Unmarshaling
//              to succeed.
//
///////////////////////////////////////////////////////////////////

CWbemObjSinkIndicatePacket::CWbemObjSinkIndicatePacket( LPBYTE pDataPacket /* = NULL */, DWORD dwPacketLength /* = 0 */ )
:   CWbemDataPacket( pDataPacket, dwPacketLength ),
    m_pObjSinkIndicate( NULL )
{
    if ( NULL != pDataPacket )
    {
        m_pObjSinkIndicate = (PWBEM_DATAPACKET_OBJECTSINK_INDICATE) (pDataPacket + sizeof(WBEM_DATAPACKET_HEADER) );
    }
}

///////////////////////////////////////////////////////////////////
//
//  Function:   CWbemObjSinkIndicatePacket::~CWbemObjSinkIndicatePacket
//  
//  Class Destructor
//
//  Inputs:
//              None.
//
//  Outputs:
//              None.
//
//  Returns:
//              None.
//
//  Comments:   None.
//
///////////////////////////////////////////////////////////////////

CWbemObjSinkIndicatePacket::~CWbemObjSinkIndicatePacket()
{
}

///////////////////////////////////////////////////////////////////
//
//  Function:   CWbemObjSinkIndicatePacket::CalculateLength
//  
//  Calculates the length needed to packetize the supplied data.
//
//  Inputs:
//              LONG                lObjectCount - Number of objects
//              IWbemClassObject**  apClassObjects - Array of object pointers.
//
//  Outputs:
//              DWORD*              pdwLength - Calculated Length
//              CWbemClassToIdMap&  classtoidmap - Map of class names to
//                                                  GUIDs.
//              GUID*               pguidClassIds - Array of GUIDs
//              BOOL*               pfSendFullObject - Full object flag array
//
//  Returns:
//              WBEM_S_NO_ERROR if success.
//
//  Comments:   This function uses the classtoidmap to fill out the
//              Class ID and Full Object arrays.  So that the object
//              array can be correctly interpreted by MarshalPacket.
//
///////////////////////////////////////////////////////////////////

HRESULT CWbemObjSinkIndicatePacket::CalculateLength( LONG lObjectCount, 
                                                                                     IWbemClassObject** apClassObjects, 
                                                                                     DWORD* pdwLength, 
                                                                                     CWbemClassToIdMap& classtoidmap, 
                                                                                     GUID* pguidClassIds, 
                                                                                     BOOL* pfSendFullObject )
{
    HRESULT hr = WBEM_S_NO_ERROR;
    DWORD   dwLength = 0;

    // Now get the size of the objects as described by the object array
    CWbemObjectArrayPacket  arrayPacket;

    hr = arrayPacket.CalculateLength( lObjectCount, apClassObjects, &dwLength, classtoidmap, pguidClassIds, pfSendFullObject );

    // Store the length if we're okey-dokey
    if ( SUCCEEDED( hr ) )
    {
        // Account for the header sizes
        *pdwLength = ( dwLength + sizeof( WBEM_DATAPACKET_HEADER ) + sizeof( WBEM_DATAPACKET_OBJECTSINK_INDICATE ) );
    }
    
    return hr;

}

///////////////////////////////////////////////////////////////////
//
//  Function:   CWbemObjSinkIndicatePacket::MarshalPacket
//  
//  Marshals the supplied data into a buffer.
//
//  Inputs:
//              LONG                lObjectCount - Nmber of objects to marshal.
//              IWbemClassObject**  apClassObjects - Array of objects to write
//              GUID*               paguidClassIds - Array of GUIDs for objects.
//              BOOL*               pfSendFullObject - Full bject flags
//  Outputs:
//              None.
//
//  Returns:
//              WBEM_S_NO_ERROR if success.
//
//  Comments:   The GUID array and the array of flags must be filled
//              out correctly and the buffer must be large enough to
//              handle the marshaling.  The arrays will get filled
//              out correctly by CalculateLength().
//
///////////////////////////////////////////////////////////////////

HRESULT CWbemObjSinkIndicatePacket::MarshalPacket( LONG lObjectCount, IWbemClassObject** apClassObjects, GUID* paguidClassIds, BOOL* pfSendFullObject )
{
    HRESULT hr = WBEM_E_FAILED;
    
    // Setup the main header first
    hr = SetupDataPacketHeader( m_dwPacketLength - sizeof(WBEM_DATAPACKET_HEADER), WBEM_DATAPACKETTYPE_OBJECTSINK_INDICATE, 0 );

    if ( SUCCEEDED( hr ) )
    {
        // Setup pbData and dwLength so we can walk through our header
        LPBYTE  pbData      =   (LPBYTE) m_pObjSinkIndicate;
        DWORD   dwLength    =   m_dwPacketLength - sizeof(WBEM_DATAPACKET_HEADER);

        // Fill out the Indicate Header
        m_pObjSinkIndicate->dwSizeOfHeader = sizeof(WBEM_DATAPACKET_OBJECTSINK_INDICATE);
        m_pObjSinkIndicate->dwDataSize = dwLength - sizeof(WBEM_DATAPACKET_OBJECTSINK_INDICATE);

        // Account for the indicate header
        pbData += sizeof(WBEM_DATAPACKET_OBJECTSINK_INDICATE);
        dwLength -= sizeof(WBEM_DATAPACKET_OBJECTSINK_INDICATE);

        // Now use the array packet class to marshal the objects into the buffer
        CWbemObjectArrayPacket  arrayPacket( pbData, dwLength );
        hr = arrayPacket.MarshalPacket( lObjectCount, apClassObjects, paguidClassIds, pfSendFullObject );

    }   // IF SetupDataPacketHeader

    return hr;
}

///////////////////////////////////////////////////////////////////
//
//  Function:   CWbemObjSinkIndicatePacket::UnmarshalPacket
//  
//  Unmarshals data from a buffer into the supplied parameters.
//
//  Inputs:
//              None.
//  Outputs:
//              LONG&               lObjectCount - Number of unmarshaled objects.
//              IWbemClassObject**& apClassObjects - Array of unmarshaled objects,
//              CWbemClassCache&    classCache - Class Cache used to wire up
//                                                  classless instances.
//
//  Returns:
//              WBEM_S_NO_ERROR if success.
//
//  Comments:   If function succeeds, the caller is responsible for cleaning
//              up and freeing the Class Object Array.  The class cache is
//              only used when we are dealing with Instance objects..
//
///////////////////////////////////////////////////////////////////

HRESULT CWbemObjSinkIndicatePacket::UnmarshalPacket( LONG& lObjectCount, IWbemClassObject**& apClassObjects, CWbemClassCache& classCache )
{
    HRESULT hr = WBEM_E_FAILED;
    LPBYTE  pbData = (LPBYTE) m_pObjSinkIndicate;
    DWORD   dwLength    =   m_dwPacketLength - sizeof(WBEM_DATAPACKET_HEADER);

    // Set the array to NULL.
    apClassObjects = NULL;

    // Check that the underlying BLOB is OK
    hr = IsValid();

    if ( SUCCEEDED( hr ) )
    {
        // Skip past the headers, and use the object array to unmarshal the
        // objects from the buffer

        // Points us at the first object
        pbData += sizeof(WBEM_DATAPACKET_OBJECTSINK_INDICATE);
        dwLength -= sizeof(WBEM_DATAPACKET_OBJECTSINK_INDICATE);

        CWbemObjectArrayPacket  arrayPacket( pbData, dwLength );
        if (arrayPacket.IsValid())
        	hr = arrayPacket.UnmarshalPacket( lObjectCount, apClassObjects, classCache );
        else
        	hr = WBEM_E_FAILED;

    }   // IF IsValid

    return hr;
}

///////////////////////////////////////////////////////////////////
//
//  Function:   CWbemObjSinkIndicatePacket::SetData
//  
//  Sets buffer to Marshal/Unmarshal to
//
//  Inputs:
//              LPBYTE                      pDataPacket - Memory block.
//              DWORD                       dwPacketLength - Block Length.
//
//  Outputs:
//              None.
//
//  Returns:
//              None.
//
//  Comments:   Data must be supplied to this class for IsValid
//              to succeed.
//
///////////////////////////////////////////////////////////////////

void CWbemObjSinkIndicatePacket::SetData( LPBYTE pDataPacket, DWORD dwPacketLength )
{
    // Go to our offset in the packet (assuming the packet is valid)
    if ( NULL != pDataPacket )
    {
        m_pObjSinkIndicate = (PWBEM_DATAPACKET_OBJECTSINK_INDICATE) (pDataPacket + sizeof(WBEM_DATAPACKET_HEADER) );
    }
    else
    {
        m_pObjSinkIndicate = NULL;
    }

    // Initialize the base class
    CWbemDataPacket::SetData( pDataPacket, dwPacketLength );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\marshalers\coreprox\olewrap.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    OLEWRAP.CPP

Abstract:

    Wrapper classes for COM data type functions.  

    If a COM data function is required to allocate memory and fails to do 
    so, then a CX_MemoryException exception is thrown.  All COM data type 
    functions are wrapped, regardless if they allocate memory, for the sake  
    of completeness.

History:

    a-dcrews    19-Mar-99   Created.

--*/

#include "precomp.h"
#include <corex.h>
#include <oleauto.h>

#include "OleWrap.h"
#include "genutils.h"

//***************************************************************************
//
//  SafeArray wrappers
//
//***************************************************************************


SAFEARRAY* COleAuto::_SafeArrayCreate(VARTYPE vt, unsigned int cDims, SAFEARRAYBOUND FAR* rgsabound)
{
    SAFEARRAY*  psa;

    psa = SafeArrayCreate(vt, cDims, rgsabound);
    if (NULL == psa)
    {
        throw CX_MemoryException();
    }

    return psa;
}


HRESULT COleAuto::_SafeArrayDestroy(SAFEARRAY FAR* psa)
{
    return SafeArrayDestroy(psa);
}


UINT COleAuto::_SafeArrayGetDim(SAFEARRAY FAR* psa)
{
    return SafeArrayGetDim(psa);
}

HRESULT COleAuto::_SafeArrayGetElement(SAFEARRAY FAR* psa, long FAR* rgIndices, void FAR* pv)
{
    return SafeArrayGetElement(psa, rgIndices, pv);
}

HRESULT COleAuto::_SafeArrayGetLBound(SAFEARRAY FAR* psa, unsigned int nDim, long FAR* plLbound)
{
    return SafeArrayGetLBound(psa, nDim, plLbound);
}

HRESULT COleAuto::_SafeArrayGetUBound(SAFEARRAY FAR* psa, unsigned int nDim, long FAR* plUbound)
{
    return SafeArrayGetUBound(psa, nDim, plUbound);
}


HRESULT COleAuto::_SafeArrayPutElement(SAFEARRAY FAR* psa, long FAR* rgIndices, void FAR* pv)
{
    return SafeArrayPutElement(psa, rgIndices, pv);
}

HRESULT COleAuto::_SafeArrayRedim(SAFEARRAY FAR* psa, SAFEARRAYBOUND FAR* psaboundNew)
{
    return SafeArrayRedim(psa, psaboundNew);
}

//***************************************************************************
//
//  Variant wrappers
//
//***************************************************************************


HRESULT COleAuto::_WbemVariantChangeType(VARIANTARG FAR* pvargDest, VARIANTARG FAR* pvarSrc, VARTYPE vt)
{
    HRESULT hRes = WbemVariantChangeType(pvargDest, pvarSrc, vt);

    if (E_OUTOFMEMORY == hRes)
    {
        throw CX_MemoryException();
    }

    return hRes;
}

HRESULT COleAuto::_VariantChangeType(VARIANTARG FAR* pvargDest, VARIANTARG FAR* pvarSrc, unsigned short wFlags, VARTYPE vt)
{
    HRESULT hRes = VariantChangeType(pvargDest, pvarSrc, wFlags, vt);

    if (E_OUTOFMEMORY == hRes)
    {
        throw CX_MemoryException();
    }

    return hRes;
}

HRESULT COleAuto::_VariantChangeTypeEx(VARIANTARG FAR* pvargDest, VARIANTARG FAR* pvarSrc, LCID lcid, unsigned short wFlags, VARTYPE vt)
{
    HRESULT hRes = VariantChangeTypeEx(pvargDest, pvarSrc, lcid, wFlags, vt);

    if (E_OUTOFMEMORY == hRes)
    {
        throw CX_MemoryException();
    }

    return hRes;
}

HRESULT COleAuto::_VariantClear(VARIANTARG FAR* pvarg)
{
    return VariantClear(pvarg);
}

HRESULT COleAuto::_VariantCopy(VARIANTARG FAR* pvargDest, VARIANTARG FAR* pvargSrc)
{
    HRESULT hRes = VariantCopy(pvargDest, pvargSrc);

    if (E_OUTOFMEMORY == hRes)
    {
        throw CX_MemoryException();
    }

    return hRes;
}

HRESULT COleAuto::_VariantCopyInd(VARIANT FAR* pvarDest, VARIANTARG FAR* pvargSrc)
{
    HRESULT hRes = VariantCopyInd(pvarDest, pvargSrc);

    if (E_OUTOFMEMORY == hRes)
    {
        throw CX_MemoryException();
    }

    return hRes;
}

void COleAuto::_VariantInit(VARIANTARG FAR* pvarg)
{
    VariantInit(pvarg);
}


//***************************************************************************
//
//  BSTR wrappers
//
//***************************************************************************


BSTR COleAuto::_SysAllocString(const OLECHAR* sz)
{
    BSTR bstr = SysAllocString(sz);

    if (NULL == bstr)
    {
        throw CX_MemoryException();
    }

    return bstr;
}

BSTR COleAuto::_SysAllocStringByteLen(LPCSTR psz, UINT len)
{
    BSTR bstr = SysAllocStringByteLen(psz, len);

    if (NULL == bstr)
    {
        throw CX_MemoryException();
    }

    return bstr;
}

BSTR COleAuto::_SysAllocStringLen(const OLECHAR* pch, UINT cch)
{
    BSTR bstr = SysAllocStringLen(pch, cch);

    if (NULL == bstr)
    {
        throw CX_MemoryException();
    }

    return bstr;
}

void COleAuto::_SysFreeString(BSTR bstr)
{
    SysFreeString(bstr);
}

HRESULT COleAuto::_SysReAllocString(BSTR* pbstr, const OLECHAR* sz)
{
    HRESULT hRes = SysReAllocString(pbstr, sz);

    if (FAILED(hRes))
    {
        throw CX_MemoryException();
    }

    return hRes;
}

HRESULT COleAuto::_SysReAllocStringLen(BSTR* pbstr, const OLECHAR* pch, UINT cch)
{
    HRESULT hRes = SysReAllocStringLen(pbstr, pch, cch);

    if (FAILED(hRes))
    {
        throw CX_MemoryException();
    }

    return hRes;
}

HRESULT COleAuto::_SysStringByteLen(BSTR bstr)
{
    return SysStringByteLen(bstr);
}

HRESULT COleAuto::_SysStringLen(BSTR bstr)
{
    return SysStringLen(bstr);
}


//***************************************************************************
//
//  Conversion wrappers
//
//***************************************************************************


HRESULT COleAuto::_VectorFromBstr (BSTR bstr, SAFEARRAY ** ppsa)
{
    HRESULT hRes = VectorFromBstr(bstr, ppsa);

    if (E_OUTOFMEMORY == hRes)
    {
        throw CX_MemoryException();
    }

    return hRes;
}

HRESULT COleAuto::_BstrFromVector (SAFEARRAY *psa, BSTR *pbstr)
{
    HRESULT hRes = BstrFromVector(psa, pbstr);

    if (E_OUTOFMEMORY == hRes)
    {
        throw CX_MemoryException();
    }

    return hRes;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\marshalers\coreprox\olewrap.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    OLEWRAP.H

Abstract:

    Wrapper classes for COM data type functions.  

	If a COM data function is required to allocate memory and fails to do 
	so, then a CX_MemoryException exception is thrown.  All COM data type 
	functions are wrapped, regardless if they allocate memory, for the sake  
	of completeness.

History:

	a-dcrews	19-Mar-99	Created.

--*/

#ifndef _OLEWRAP_H_
#define _OLEWRAP_H_

class COleAuto
{
public:

	// Safe array methods
	// ==================

	static SAFEARRAY* _SafeArrayCreate(VARTYPE vt, unsigned int cDims, SAFEARRAYBOUND* rgsabound);
	static HRESULT _SafeArrayDestroy(SAFEARRAY* psa);
	static UINT _SafeArrayGetDim(SAFEARRAY* psa);
	static HRESULT _SafeArrayGetElement(SAFEARRAY* psa, long* rgIndices, void* pv);
	static UINT _SafeArrayGetElemsize(SAFEARRAY* psa);
	static HRESULT _SafeArrayGetLBound(SAFEARRAY* psa, unsigned int nDim, long* plLbound);
	static HRESULT _SafeArrayGetUBound(SAFEARRAY* psa, unsigned int nDim, long* plUbound);
	static HRESULT _SafeArrayPutElement(SAFEARRAY* psa, long* rgIndices, void* pv);
	static HRESULT _SafeArrayRedim(SAFEARRAY* psa, SAFEARRAYBOUND* psaboundNew);

	// Variant methods
	// ===============

	static HRESULT _WbemVariantChangeType(VARIANTARG* pvargDest, VARIANTARG* pvarSrc, VARTYPE vt);
	static HRESULT _VariantChangeType(VARIANTARG* pvargDest, VARIANTARG* pvarSrc, unsigned short wFlags, VARTYPE vt);
	static HRESULT _VariantChangeTypeEx(VARIANTARG* pvargDest, VARIANTARG* pvarSrc, LCID lcid, unsigned short wFlags, VARTYPE vt);
	static HRESULT _VariantClear(VARIANTARG* pvarg);
	static HRESULT _VariantCopy(VARIANTARG* pvargDest, VARIANTARG* pvargSrc);
	static HRESULT _VariantCopyInd(VARIANT* pvarDest, VARIANTARG* pvargSrc);
	static void _VariantInit(VARIANTARG* pvarg);

	// BSTR methods
	// ============

	static BSTR _SysAllocString(const OLECHAR* sz);
	static BSTR _SysAllocStringByteLen(LPCSTR psz, UINT len);
	static BSTR _SysAllocStringLen(const OLECHAR* pch, UINT cch);
	static void _SysFreeString(BSTR bstr);
	static HRESULT _SysReAllocString(BSTR* pbstr, const OLECHAR* sz);
	static HRESULT _SysReAllocStringLen(BSTR* pbstr, const OLECHAR* pch, UINT cch);
	static HRESULT _SysStringByteLen(BSTR bstr);
	static HRESULT _SysStringLen(BSTR bstr);

	// Conversion methods
	// ==================

	static HRESULT _VectorFromBstr (BSTR bstr, SAFEARRAY ** ppsa);
	static HRESULT _BstrFromVector (SAFEARRAY *psa, BSTR *pbstr);
};

#endif	//_OLEWRAP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\marshalers\coreprox\provinit.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    PROVINIT.CPP

Abstract:

  This file implements the provider init sink

History:

--*/

#include "precomp.h"
#include <wbemint.h>
#include <wbemcomn.h>
#include "provinit.h"

ULONG STDMETHODCALLTYPE CProviderInitSink::AddRef()
{
    return InterlockedIncrement(&m_lRef);
}

ULONG STDMETHODCALLTYPE CProviderInitSink::Release()
{
    ULONG lRet = InterlockedDecrement(&m_lRef);
    if(0 == lRet) delete this;
    return lRet;
}

HRESULT STDMETHODCALLTYPE CProviderInitSink::QueryInterface(REFIID riid, 
                                                            void** ppv)
{
    if (NULL == ppv) return E_POINTER;
    
    if(riid == IID_IUnknown || riid == IID_IWbemProviderInitSink)
    {
        *ppv = (IWbemProviderInitSink*)this;
        AddRef();
        return S_OK;
    }
    else 
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
}

HRESULT STDMETHODCALLTYPE CProviderInitSink::SetStatus(long lStatus, 
                                                            long lFlags)
{
    if(lFlags != 0) return WBEM_E_INVALID_PARAMETER;

    if(SUCCEEDED(lStatus) && lStatus != WBEM_S_INITIALIZED)
    {
        return WBEM_S_NO_ERROR;
    }

    m_lStatus = lStatus;
    SetEvent(m_hEvent);

    return WBEM_S_NO_ERROR;
}

CProviderInitSink::CProviderInitSink() : m_lRef(0)
{
    m_hEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
    if (NULL == m_hEvent) throw CX_MemoryException();
}

CProviderInitSink::~CProviderInitSink()
{
    CloseHandle(m_hEvent);
}

HRESULT CProviderInitSink::WaitForCompletion()
{
    DWORD dwRes = WaitForSingleObject(m_hEvent, 2*60*1000);

    if(dwRes != WAIT_OBJECT_0)
    {    
        return WBEM_E_PROVIDER_LOAD_FAILURE;
    }

    return m_lStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\marshalers\coreprox\provinit.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    PROVINIT.H

Abstract:

  This file implements the provider init sink

History:

--*/

#ifndef __WBEM_PROVINIT__H_
#define __WBEM_PROVINIT__H_

class CProviderInitSink : public IWbemProviderInitSink
{
protected:
    long m_lRef;
    long m_lStatus;
    HANDLE m_hEvent;

public:
    ULONG STDMETHODCALLTYPE AddRef();
    ULONG STDMETHODCALLTYPE Release();
    HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, void** ppv);

    HRESULT STDMETHODCALLTYPE SetStatus(long lStatus, long lFlags);

public:
    CProviderInitSink();
    ~CProviderInitSink();

    HRESULT WaitForCompletion();
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\marshalers\coreprox\precomp.h ===
/*++

Copyright (C) 1999-2001 Microsoft Corporation

Module Name:

    ADDRESLV.H

Abstract:

History:

--*/
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#define WIN32_NO_STATUS

#pragma warning (disable : 4786)
#include <ole2.h>
#include <windows.h>
#include <comdef.h>
#include <strsafe.h>
#include <helper.h>
#define COREPROX_POLARITY __declspec( dllexport )
#include <autoptr.h>
#include <scopeguard.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\marshalers\coreprox\proxmain.cpp ===
/*++

Copyright (C) 1998-2001 Microsoft Corporation

Module Name:

    PROXMAIN.CPP

Abstract:

    Main DLL entry points

History:

--*/

#include "precomp.h"
#include "fastprox.h"
#include <context.h>
#include <commain.h>
#include <clsfac.h>
#include <wbemcomn.h>
#include "fastall.h"
#include "hiperfenum.h"
#include "refrcli.h"
#include "sinkmrsh.h"
#include "enummrsh.h"
#include "ubskmrsh.h"
#include "mtgtmrsh.h"
#include "wmiobftr.h"
#include "wmiobtxt.h"
#include "svcmrsh.h"
#include "callsec.h"
#include "refrsvc.h"
#include "refrcach.h"
#include "smrtenum.h"
#include "refmghlp.h"

//***************************************************************************
//
//  CLASS NAME:
//
//  CGenFactory
//
//  DESCRIPTION:
//
//  Class factory for the CWbemClass .
//
//***************************************************************************


typedef LPVOID * PPVOID;
template<class TObject>
class CGenFactory : public CBaseClassFactory
{

public:
    CGenFactory( CLifeControl* pControl = NULL )
    : CBaseClassFactory( pControl ) {}

    HRESULT CreateInstance( IUnknown* pOuter, REFIID riid, void** ppv )
    {
        if(pOuter)
            return CLASS_E_NOAGGREGATION;

        // Lock
        if(m_pControl && !m_pControl->ObjectCreated(NULL))
        {
            // Shutting down
            // =============
            return CO_E_SERVER_STOPPING;
        }

        // Create
        TObject* pObject = new TObject;

        // Unlock
        if(m_pControl)
            m_pControl->ObjectDestroyed(NULL);

        // Get the interface
        if(pObject == NULL)
            return E_FAIL;

        // Setup the class all empty, etc.

        if ( FAILED( pObject->InitEmpty() ) )
        {
            return E_FAIL;
        }

        HRESULT hr = pObject->QueryInterface(riid, ppv);

        // These objects have an initial refcount of 1
        pObject->Release();

        return hr;
    }

    HRESULT LockServer( BOOL fLock )
    {
        if(fLock)
            m_pControl->ObjectCreated(NULL);
        else
            m_pControl->ObjectDestroyed(NULL);
        return S_OK;
    }
};

// {71285C44-1DC0-11d2-B5FB-00104B703EFD}
const CLSID CLSID_IWbemObjectSinkProxyStub = { 0x71285c44, 0x1dc0, 0x11d2, { 0xb5, 0xfb, 0x0, 0x10, 0x4b, 0x70, 0x3e, 0xfd } };

// {1B1CAD8C-2DAB-11d2-B604-00104B703EFD}
const CLSID CLSID_IEnumWbemClassObjectProxyStub = { 0x1b1cad8c, 0x2dab, 0x11d2, { 0xb6, 0x4, 0x0, 0x10, 0x4b, 0x70, 0x3e, 0xfd } };

// {29B5828C-CAB9-11d2-B35C-00105A1F8177}
const CLSID CLSID_IWbemUnboundObjectSinkProxyStub = { 0x29b5828c, 0xcab9, 0x11d2, { 0xb3, 0x5c, 0x0, 0x10, 0x5a, 0x1f, 0x81, 0x77 } };

// {7016F8FA-CCDA-11d2-B35C-00105A1F8177}
static const CLSID CLSID_IWbemMultiTargetProxyStub = { 0x7016f8fa, 0xccda, 0x11d2, { 0xb3, 0x5c, 0x0, 0x10, 0x5a, 0x1f, 0x81, 0x77 } };

// {D68AF00A-29CB-43fa-8504-CE99A996D9EA}
static const CLSID CLSID_IWbemServicesProxyStub = { 0xd68af00a, 0x29cb, 0x43fa, { 0x85, 0x4, 0xce, 0x99, 0xa9, 0x96, 0xd9, 0xea } };

// {D71EE747-F455-4804-9DF6-2ED81025F2C1}
static const CLSID CLSID_IWbemComBindingProxyStub =
{ 0xd71ee747, 0xf455, 0x4804, { 0x9d, 0xf6, 0x2e, 0xd8, 0x10, 0x25, 0xf2, 0xc1 } };

// Signature to use when marshaling pointers across threads
unsigned __int64 g_ui64PointerSig = 0;

class CMyServer : public CComServer
{
public:
    HRESULT Initialize()
    {
        AddClassInfo(CLSID_WbemClassObjectProxy,
            new CSimpleClassFactory<CFastProxy>(GetLifeControl()),
            __TEXT("WbemClassObject Marshalling proxy"), TRUE);

        AddClassInfo(CLSID_WbemContext,
            new CSimpleClassFactory<CWbemContext>(GetLifeControl()),
            __TEXT("Call Context"), TRUE);

		AddClassInfo(CLSID_WbemRefresher,
			new CClassFactory<CUniversalRefresher>(GetLifeControl()),
			__TEXT("Universal Refresher"), TRUE);

        AddClassInfo(CLSID_WbemClassObject,
            new CGenFactory<CWbemClass>(GetLifeControl()),
            __TEXT("WBEM Class Object"), TRUE);

        AddClassInfo(CLSID__WmiObjectFactory,
            new CSimpleClassFactory<CWmiObjectFactory>(GetLifeControl()),
            __TEXT("WMI Object Factory"), TRUE);

        AddClassInfo(CLSID_WbemObjectTextSrc,
            new CSimpleClassFactory<CWmiObjectTextSrc>(GetLifeControl()),
            __TEXT("WMI Object Factory"), TRUE);

        AddClassInfo(CLSID_IWbemObjectSinkProxyStub,
            new CSinkFactoryBuffer(GetLifeControl()),
            __TEXT("(non)Standard Marshaling for IWbemObjectSink"), TRUE);

        AddClassInfo(CLSID_IEnumWbemClassObjectProxyStub,
            new CEnumFactoryBuffer(GetLifeControl()),
            __TEXT("(non)Standard Marshaling for IEnumWbemClassObject"), TRUE);

        AddClassInfo(CLSID_IWbemUnboundObjectSinkProxyStub,
            new CUnboundSinkFactoryBuffer(GetLifeControl()),
            __TEXT("(non)Standard Marshaling for IWbemUnboundObjectSink"), TRUE);

        AddClassInfo(CLSID_IWbemMultiTargetProxyStub,
            new CMultiTargetFactoryBuffer(GetLifeControl()),
            __TEXT("(non)Standard Marshaling for IWbemMultiTarget"), TRUE);

        AddClassInfo(CLSID_IWbemServicesProxyStub,
            new CSvcFactoryBuffer(GetLifeControl()),
            __TEXT("(non)Standard Marshaling for IWbemServices"), TRUE);

        AddClassInfo(CLSID__IWbemCallSec,
            new CSimpleClassFactory<CWbemCallSecurity>(GetLifeControl()),
            __TEXT("_IWmiCallSec Call Security Factory"), TRUE);
        
        AddClassInfo( CLSID__WbemConfigureRefreshingSvcs,
            new CClassFactory<CWbemRefreshingSvc>(GetLifeControl()),
            __TEXT("_IWbemConfigureRefreshingSvc Configure Refreshing Services Factory"), TRUE);

        AddClassInfo( CLSID__WbemRefresherMgr,
            new CClassFactory<CRefresherCache>(GetLifeControl()),
            __TEXT("_IWbemRefresherMgr Refresher Cache Factory"), TRUE);


        AddClassInfo( CLSID__WbemEnumMarshaling,
            new CClassFactory<CWbemEnumMarshaling>(GetLifeControl()),
            __TEXT("_IWbemEnumMarshaling Enumerator Helper"), TRUE);

        // This guy is truly free threaded
        AddClassInfo( CLSID__WbemFetchRefresherMgr,
            new CClassFactory<CWbemFetchRefrMgr>(GetLifeControl()),
            __TEXT("_WbemFetchRefresherMgr Proxy Helper"), TRUE, TRUE);

        // Signature to use when marshaling pointers across threads
        LARGE_INTEGER   li;
        QueryPerformanceCounter( &li );

        g_ui64PointerSig = li.QuadPart;

        return S_OK;
    }
    void Uninitialize()
    {
        CUniversalRefresher::Flush();
    }
    void Register()
    {
        RegisterInterfaceMarshaler(IID_IWbemObjectSink, CLSID_IWbemObjectSinkProxyStub,
                __TEXT("IWbemObjectSink"), 5, IID_IUnknown);
        RegisterInterfaceMarshaler(IID_IEnumWbemClassObject, CLSID_IEnumWbemClassObjectProxyStub,
                __TEXT("IEnumWbemClassObject"), 5, IID_IUnknown);
        // This guy only has 4 methods
        RegisterInterfaceMarshaler(IID_IWbemUnboundObjectSink, CLSID_IWbemUnboundObjectSinkProxyStub,
                __TEXT("IWbemUnboundObjectSink"), 4, IID_IUnknown);
        // This guy only has 4 methods
        RegisterInterfaceMarshaler(IID_IWbemMultiTarget, CLSID_IWbemMultiTargetProxyStub,
                __TEXT("IWbemMultiTarget"), 5, IID_IUnknown);

        RegisterInterfaceMarshaler(IID_IWbemServices, CLSID_IWbemServicesProxyStub,
                __TEXT("IWbemServices"), 40, IID_IUnknown);

        // this is for FastProx to be used as a marshaler even if NO_CUSTOM_MARSHAL is set
        HKEY hKey;
        if(ERROR_SUCCESS == RegCreateKey(HKEY_LOCAL_MACHINE,
            TEXT("software\\classes\\CLSID\\{4590F812-1D3A-11D0-891F-00AA004B2E24}\\")
            TEXT("Implemented Categories\\{00000003-0000-0000-C000-000000000046}"),
            &hKey))
        {
            RegCloseKey(hKey);
            hKey = NULL;
        }
        // this is for IWbemContext
        if (ERROR_SUCCESS == RegCreateKey(HKEY_LOCAL_MACHINE,
            TEXT("software\\classes\\CLSID\\{674B6698-EE92-11D0-AD71-00C04FD8FDFF}\\")
            TEXT("Implemented Categories\\{00000003-0000-0000-C000-000000000046}"),            
            &hKey))
        {
            RegCloseKey(hKey);
            hKey = NULL;        
        }

    }
    void Unregister()
    {
        UnregisterInterfaceMarshaler(IID_IWbemObjectSink);
        UnregisterInterfaceMarshaler(IID_IEnumWbemClassObject);
        UnregisterInterfaceMarshaler(IID_IWbemUnboundObjectSink);
        UnregisterInterfaceMarshaler(IID_IWbemMultiTarget);
        UnregisterInterfaceMarshaler(IID_IWbemServices);
    }
    void PostUninitialize();

} Server;

void CMyServer::PostUninitialize()
{
    // This is called during DLL shutdown. Normally, we wouldn't want to do
    // anything here, but Windows 95 has an unfortunate bug in that in its
    // CoUninitize it first unloads all COM server DLLs that it has and *then*
    // attempts to release any error object that may be outstanding at that
    // time. This, obviously, causes a crash, since Release code is no longer
    // there. Hence, during our dll unload (DllCanUnloadNow is not called on
    // shutdown), we check if an error object of ours is outstanding and clear
    // it if so.

    IErrorInfo* pInfo = NULL;
    if(SUCCEEDED(GetErrorInfo(0, &pInfo)) && pInfo != NULL)
    {
        IWbemClassObject* pObj;
        if(SUCCEEDED(pInfo->QueryInterface(IID_IWbemClassObject,
                                            (void**)&pObj)))
        {
            // Our error object is outstanding at the DLL shutdown time.
            // Release it
            // =========================================================

            pObj->Release();
            pInfo->Release();
        }
        else
        {
            // It's not ours
            // =============

            SetErrorInfo(0, pInfo);
            pInfo->Release();
        }
    }
}

static LONG g_lDebugObjCount = 0;

void ObjectCreated(DWORD dwType,IUnknown * pThis)
{
    InterlockedIncrement(&g_lDebugObjCount);
    Server.GetLifeControl()->ObjectCreated(pThis);
}

void ObjectDestroyed(DWORD dwType,IUnknown * pThis)
{
    InterlockedDecrement(&g_lDebugObjCount);
    Server.GetLifeControl()->ObjectDestroyed(pThis);
}

extern "C" _declspec(dllexport)
LONG WINAPI GetObjectCount() { return g_lDebugObjCount; }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\marshalers\coreprox\refmghlp.h ===
/*++

Copyright (C) 2000-2001 Microsoft Corporation

Module Name:

    REFMGHLP.H

Abstract:

  CWbemFetchRefrMgr Definition.

  Standard definition for _IWbemFetchRefresherMgr.

History:

  07-Sep-2000	sanjes    Created.

--*/

#ifndef _REFMGHLP_H_
#define _REFMGHLP_H_

#include "corepol.h"
#include <arena.h>
#include <unk.h>
#include <sync.h>
#include <statsync.h>

//***************************************************************************
//
//  class CWbemFetchRefrMgr
//
//  Implementation of _IWbemFetchRefresherMgr Interface
//
//***************************************************************************

class COREPROX_POLARITY CWbemFetchRefrMgr : public CUnk
{
protected:
	static _IWbemRefresherMgr*		s_pRefrMgr;
	static CStaticCritSec			s_cs;
public:
    CWbemFetchRefrMgr(CLifeControl* pControl, IUnknown* pOuter = NULL);
	~CWbemFetchRefrMgr(); 

	/* _IWbemFetchRefresherMgr methods */
    HRESULT Get( _IWbemRefresherMgr** ppMgr );
	HRESULT Init( _IWmiProvSS* pProvSS, IWbemServices* pSvc );
	HRESULT Uninit( void );

	// Specifies everything we could possibly want to know about the creation of
	// an object and more.

    class COREPROX_POLARITY XFetchRefrMgr : public CImpl<_IWbemFetchRefresherMgr, CWbemFetchRefrMgr>
    {
    public:
        XFetchRefrMgr(CWbemFetchRefrMgr* pObject) : 
            CImpl<_IWbemFetchRefresherMgr, CWbemFetchRefrMgr>(pObject)
        {}

		STDMETHOD(Get)( _IWbemRefresherMgr** ppMgr );
		STDMETHOD(Init)( _IWmiProvSS* pProvSS, IWbemServices* pSvc );
		STDMETHOD(Uninit)( void );

    } m_XFetchRefrMgr;
    friend XFetchRefrMgr;


protected:
    void* GetInterface(REFIID riid);
	
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\marshalers\coreprox\refmghlp.cpp ===
/*++

Copyright (C) 2000-2001 Microsoft Corporation

Module Name:

    REFMGHLP.CPP

Abstract:

  CWbemFetchRefrMgr implementation.

  Implements the _IWbemFetchRefresherMgr interface.

History:

  07-Sep-2000    sanjes    Created.

--*/

#include "precomp.h"
#include <stdio.h>
#include <corex.h>
#include "fastall.h"
#include "refmghlp.h"
#include "arrtempl.h"
#include <corex.h>

_IWbemRefresherMgr*        CWbemFetchRefrMgr::s_pRefrMgr = NULL;
CStaticCritSec            CWbemFetchRefrMgr::s_cs;

//***************************************************************************
//
//  CWbemFetchRefrMgr::~CWbemFetchRefrMgr
//
//***************************************************************************
// ok
CWbemFetchRefrMgr::CWbemFetchRefrMgr( CLifeControl* pControl, IUnknown* pOuter )
:    CUnk(pControl, pOuter),
    m_XFetchRefrMgr( this )
{
}
    
//***************************************************************************
//
//  CWbemFetchRefrMgr::~CWbemFetchRefrMgr
//
//***************************************************************************
// ok
CWbemFetchRefrMgr::~CWbemFetchRefrMgr()
{
}

// Override that returns us an interface
void* CWbemFetchRefrMgr::GetInterface( REFIID riid )
{
    if(riid == IID_IUnknown || riid == IID__IWbemFetchRefresherMgr)
        return &m_XFetchRefrMgr;
    else
        return NULL;
}

/* _IWbemFetchRefresherMgr methods */

HRESULT CWbemFetchRefrMgr::XFetchRefrMgr::Get( _IWbemRefresherMgr** ppMgr )
{
    return m_pObject->Get( ppMgr );
}

STDMETHODIMP CWbemFetchRefrMgr::XFetchRefrMgr::Init( _IWmiProvSS* pProvSS, IWbemServices* pSvc )
{
    return m_pObject->Init( pProvSS, pSvc );
}

STDMETHODIMP CWbemFetchRefrMgr::XFetchRefrMgr::Uninit( void )
{
    return m_pObject->Uninit();
}

// Specifies everything we could possibly want to know about the creation of
// an object and more.
HRESULT CWbemFetchRefrMgr::Get( _IWbemRefresherMgr** ppMgr )
{
    HRESULT    hr = WBEM_S_NO_ERROR;

    try
    {
        CInCritSec    ics( &s_cs );

        // If this hasn't been created, then we need to use Core Services to create this
        if ( NULL == s_pRefrMgr )
        {
            _IWmiCoreServices*    pSvc = NULL;

            hr = CoCreateInstance( CLSID_IWmiCoreServices, NULL, CLSCTX_INPROC_SERVER, IID__IWmiCoreServices, (void**) &pSvc );    
            CReleaseMe    rm( pSvc );

            if ( SUCCEEDED( hr ) )
            {
                hr = pSvc->InitRefresherMgr( 0L );

                if ( SUCCEEDED( hr ) )
                {
                    if ( NULL != s_pRefrMgr )
                    {
                        *ppMgr = s_pRefrMgr;
                        s_pRefrMgr = NULL ;
                    }
                    else
                    {
                        hr = WBEM_E_FAILED;
                    }

                }    // IF InitRefresherMgr

            }    // IF CCI

        }
        else
        {
            s_pRefrMgr->AddRef();
            *ppMgr = s_pRefrMgr;
        }

        return hr;

    }
    catch ( CX_MemoryException )
    {
        return WBEM_E_OUT_OF_MEMORY;
    }
    catch ( ... )
    {
        return WBEM_E_CRITICAL_ERROR;
    }

}

HRESULT CWbemFetchRefrMgr::Init( _IWmiProvSS* pProvSS, IWbemServices* pSvc )
{
    CInCritSec    ics( &s_cs );

    if ( NULL == pProvSS || NULL == pSvc )
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    HRESULT    hr = WBEM_S_NO_ERROR;

    if ( NULL == s_pRefrMgr )
    {
        hr = pProvSS->CreateRefresherManager(
        pSvc,
        0,                              // lFlags
        NULL,
        IID__IWbemRefresherMgr,
        (LPVOID *) &s_pRefrMgr
        );
    }

    return hr;

}

HRESULT CWbemFetchRefrMgr::Uninit( void )
{
    s_cs.Enter();

    if ( NULL != s_pRefrMgr )
    {
        // We don't want to release inside the critical section, so copy the pointer
        // into a local variable, NULL out the pointer, leave the crit sec and then
        // release it.

        _IWbemRefresherMgr*    pRefrMgr = s_pRefrMgr;
        s_pRefrMgr = NULL;

        s_cs.Leave();

        // Now safe to release it
        pRefrMgr->Release();

    }
    else
    {
        s_cs.Leave();
    }

    return WBEM_S_NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\marshalers\coreprox\refrcach.h ===
/*++

Copyright (C) 2000-2001 Microsoft Corporation

Module Name:

    REFRCACH.H

Abstract:

  CRefresherCache Definition.

  Standard definition for _IWbemRefresherMgr.

History:

  27-Apr-2000	sanjes    Created.

--*/

#ifndef _REFRCACHE_H_
#define _REFRCACHE_H_

#include "corepol.h"
#include <arena.h>
#include "rfchercd.h"

//***************************************************************************
//
//  class CRefresherCache
//
//  Implementation of _IWbemRefresherMgr Interface
//
//***************************************************************************

class CRefresherCache : public CUnk
{
private:
	//TODO: How will we get this?
	_IWmiProvSS *m_pProvSS;
    CUniquePointerArray<CRefresherRecord> m_apRefreshers;
    CUniquePointerArray<CHiPerfPrvRecord> m_apProviders;
	CCritSec	m_cs;

public:
    CRefresherCache(CLifeControl* pControl, IUnknown* pOuter = NULL);
	virtual ~CRefresherCache(); 

protected:

	// COM interface implementatioms
    class XWbemRefrCache : public CImpl<_IWbemRefresherMgr, CRefresherCache>
    {
    public:
        XWbemRefrCache(CRefresherCache* pObject) : 
            CImpl<_IWbemRefresherMgr, CRefresherCache>(pObject)
        {}

		STDMETHOD(AddObjectToRefresher)( IWbemServices* pNamespace, 
			                           LPCWSTR pwszServerName, 
			                           LPCWSTR pwszNamespace, 
			                           IWbemClassObject* pClassObject, 
			                           WBEM_REFRESHER_ID* pDestRefresherId,
									   IWbemClassObject* pInstTemplate, long lFlags, 
									   IWbemContext* pContext, 
									   IUnknown* pLockMgr,
									   WBEM_REFRESH_INFO* pInfo );

		STDMETHOD(AddEnumToRefresher)( IWbemServices* pNamespace, 
			                           LPCWSTR pwszServerName, 
			                           LPCWSTR pwszNamespace, 
			                           IWbemClassObject* pClassObject,
									   WBEM_REFRESHER_ID* pDestRefresherId, 
									   IWbemClassObject* pInstTemplate, 
									   LPCWSTR wszClass, long lFlags, 
									   IWbemContext* pContext, 
									   IUnknown* pLockMgr,
									   WBEM_REFRESH_INFO* pInfo );

		STDMETHOD(GetRemoteRefresher)( WBEM_REFRESHER_ID* pRefresherId, long lFlags, BOOL fAddRefresher, IWbemRemoteRefresher** ppRemRefresher, IUnknown* pLockMgr,
										GUID* pGuid );

		STDMETHOD(Startup)(	long lFlags , IWbemContext *pCtx , _IWmiProvSS* pProvSS );

		STDMETHOD(LoadProvider)( IWbemServices* pNamespace, 
		                         LPCWSTR pwszProviderName, 
		                         LPCWSTR pwszNamespace, 
		                         IWbemContext * pContext,
		                         IWbemHiPerfProvider** ppProv,
								 _IWmiProviderStack** ppProvStack );


    } m_XWbemRefrCache;
    friend XWbemRefrCache;

    class XWbemShutdown : public CImpl<IWbemShutdown, CRefresherCache>
    {
    public:
        XWbemShutdown(CRefresherCache* pObject) : 
            CImpl<IWbemShutdown, CRefresherCache>(pObject)
        {}

		STDMETHOD(Shutdown)( LONG a_Flags , ULONG a_MaxMilliSeconds , IWbemContext *a_Context ) ;

    } m_XWbemShutdown;
    friend XWbemShutdown;

protected:

	virtual HRESULT AddObjectToRefresher( IWbemServices* pNamespace, LPCWSTR pwszServerName, LPCWSTR pwszNamespace, IWbemClassObject* pClassObject,
								WBEM_REFRESHER_ID* pDestRefresherId, IWbemClassObject* pInstTemplate, long lFlags, IWbemContext* pContext, IUnknown* pLockMgr,
								WBEM_REFRESH_INFO* pInfo );

	virtual HRESULT AddEnumToRefresher( IWbemServices* pNamespace, LPCWSTR pwszServerName, LPCWSTR pwszNamespace, IWbemClassObject* pClassObject,
									WBEM_REFRESHER_ID* pDestRefresherId, IWbemClassObject* pInstTemplate, LPCWSTR wszClass,
									long lFlags, IWbemContext* pContext, IUnknown* pLockMgr, WBEM_REFRESH_INFO* pInfo );

	virtual HRESULT GetRemoteRefresher( WBEM_REFRESHER_ID* pRefresherId, long lFlags, BOOL fAddRefresher, IWbemRemoteRefresher** ppRemRefresher,
										IUnknown* pLockMgr, GUID* pGuid );

	virtual HRESULT Startup( long lFlags , IWbemContext *pCtx , _IWmiProvSS* pProvSS );

	virtual HRESULT Shutdown( LONG a_Flags , ULONG a_MaxMilliSeconds , IWbemContext *a_Context ) ;

	virtual HRESULT LoadProvider( IWbemServices* pNamespace, 
	                              LPCWSTR pwszProviderName, 
	                              LPCWSTR pwszNamespace, 
	                              IWbemContext * pContext,
	                              IWbemHiPerfProvider** ppProv,
								 _IWmiProviderStack** ppProvStack );

protected:
    void* GetInterface(REFIID riid);

public:

	// Dummy function for the aggregable class factory template
	BOOL Initialize( void ) { return TRUE; }

	// Workhorse helper functions
    BOOL RemoveRefresherRecord(CRefresherRecord* pRecord);
    BOOL RemoveProviderRecord(CHiPerfPrvRecord* pRecord);

    static HRESULT GetDestinationContext(MSHCTX &, CRefresherId* pRefresherId);

    HRESULT CreateObjectInfoForProvider(CRefresherId* pDestRefresherId,
                    CHiPerfPrvRecord*	pProvRecord,
					LPCWSTR pwszServerName, LPCWSTR pwszNamespace,
					IWbemServices* pNamespace,
                    CWbemObject* pInstTemplate, long lFlags, 
                    IWbemContext* pContext,
                    CRefreshInfo* pInfo,
					IUnknown* pLockMgr);

    HRESULT CreateEnumInfoForProvider(CRefresherId* pDestRefresherId,
                    CHiPerfPrvRecord*	pProvRecord,
					LPCWSTR pwszServerName, LPCWSTR pwszNamespace,
					IWbemServices* pNamespace,
                    CWbemObject* pInstTemplate,
					LPCWSTR wszClass, long lFlags, 
                    IWbemContext* pContext,
                    CRefreshInfo* pInfo,
					IUnknown* pLockMgr);

    HRESULT FindRefresherRecord( CRefresherId* pRefresherId, BOOL bCreate,
								IUnknown* pLockMgr, CRefresherRecord** ppRecord );

	HRESULT FindProviderRecord( LPCWSTR pwszProviderName, LPCWSTR pszNamespace, IWbemServices* pSvc, CHiPerfPrvRecord** ppRecord );
	
	HRESULT GetProviderInfo( IWbemServices* pSvc, LPCWSTR pwszProviderName, 
	                      CLSID & Clsid, CLSID & ClientClsid );

	HRESULT LoadProviderInner( LPCWSTR pwszProviderName, 
	                      LPCWSTR pszNamespace, 
	                      IWbemServices* pSvc, 
	                      IWbemContext * pContext,
	                      IWbemHiPerfProvider** ppProv,
							_IWmiProviderStack** ppStack );

	HRESULT GetProviderName( IWbemClassObject*	pObj, CVar & ProviderName, BOOL & fStatic );

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\marshalers\coreprox\refrcach.cpp ===
/*++

Copyright (C) 2000-2001 Microsoft Corporation

Module Name:

    REFRCACHE.CPP

Abstract:

  CRefresherCache implementation.

  Implements the _IWbemRefresherMgr interface.

History:

  24-Apr-2000    sanjes    Created.

--*/

#include "precomp.h"
#include <stdio.h>
#include "fastall.h"
#include <corex.h>
#include "strutils.h"
#include <unk.h>
#include "refrhelp.h"
#include "refrcach.h"
#include "arrtempl.h"
#include "reg.h"
#include <autoptr.h>

//***************************************************************************
//
//  CRefresherCache::CRefresherCache
//
//***************************************************************************
// ok
CRefresherCache::CRefresherCache( CLifeControl* pControl, IUnknown* pOuter )
:    CUnk( pControl, pOuter ),
    m_pProvSS ( NULL ),
    m_XWbemRefrCache( this ) ,
    m_XWbemShutdown( this )
{
}
    
//***************************************************************************
//
//  CRefresherCache::~CRefresherCache
//
//***************************************************************************
// ok
CRefresherCache::~CRefresherCache()
{
    if ( NULL != m_pProvSS )
    {
        m_pProvSS->Release();
    }
}

// Override that returns us an interface
void* CRefresherCache::GetInterface( REFIID riid )
{
    if(riid == IID_IUnknown || riid == IID__IWbemRefresherMgr)
        return &m_XWbemRefrCache;
    else if(riid == IID_IWbemShutdown)
        return &m_XWbemShutdown;
    else
        return NULL;
}

// Pass thru _IWbemRefresherMgr implementation
STDMETHODIMP CRefresherCache::XWbemRefrCache::AddObjectToRefresher( IWbemServices* pNamespace, LPCWSTR pwszServerName, LPCWSTR pwszNamespace, IWbemClassObject* pClassObject,
                                                                  WBEM_REFRESHER_ID* pDestRefresherId, IWbemClassObject* pInstTemplate,
                                                                  long lFlags, IWbemContext* pContext, IUnknown* pLockMgr, WBEM_REFRESH_INFO* pInfo )
{
    return m_pObject->AddObjectToRefresher( pNamespace, pwszServerName, pwszNamespace, pClassObject, pDestRefresherId, pInstTemplate, lFlags, pContext, pLockMgr, pInfo );
}

STDMETHODIMP CRefresherCache::XWbemRefrCache::AddEnumToRefresher( IWbemServices* pNamespace, LPCWSTR pwszServerName, LPCWSTR pwszNamespace, IWbemClassObject* pClassObject,
                                                                WBEM_REFRESHER_ID* pDestRefresherId, IWbemClassObject* pInstTemplate,
                                                                LPCWSTR wszClass, long lFlags, IWbemContext* pContext, IUnknown* pLockMgr, WBEM_REFRESH_INFO* pInfo )
{
    return m_pObject->AddEnumToRefresher( pNamespace, pwszServerName, pwszNamespace, pClassObject, pDestRefresherId, pInstTemplate, wszClass, lFlags, pContext, pLockMgr, pInfo );
}

STDMETHODIMP CRefresherCache::XWbemRefrCache::GetRemoteRefresher( WBEM_REFRESHER_ID* pRefresherId, long lFlags, BOOL fAddRefresher, IWbemRemoteRefresher** ppRemRefresher,
                                                                  IUnknown* pLockMgr, GUID* pGuid )
{
    return m_pObject->GetRemoteRefresher( pRefresherId, lFlags, fAddRefresher, ppRemRefresher, pLockMgr, pGuid );
}

STDMETHODIMP CRefresherCache::XWbemRefrCache::Startup(    long lFlags , IWbemContext *pCtx , _IWmiProvSS *pProvSS )
{
    return m_pObject->Startup( lFlags , pCtx, pProvSS );
}

STDMETHODIMP CRefresherCache::XWbemRefrCache::LoadProvider( IWbemServices* pNamespace, LPCWSTR pwszServerName, LPCWSTR pwszNamespace,IWbemContext * pContext, IWbemHiPerfProvider** ppProv, _IWmiProviderStack** ppProvStack )
{
    return m_pObject->LoadProvider( pNamespace, pwszServerName, pwszNamespace, pContext, ppProv, ppProvStack  );
}


STDMETHODIMP CRefresherCache::XWbemShutdown::Shutdown( LONG a_Flags , ULONG a_MaxMilliSeconds , IWbemContext *a_Context )
{
    return m_pObject->Shutdown( a_Flags , a_MaxMilliSeconds , a_Context  );
}

/* _IWbemRefresherMgr implemetation */
HRESULT 
CRefresherCache::AddObjectToRefresher( IWbemServices* pNamespace, 
                                   LPCWSTR pwszServerName, 
                                   LPCWSTR pwszNamespace, 
                                   IWbemClassObject* pClassObject,
                                   WBEM_REFRESHER_ID* pDestRefresherId, 
                                   IWbemClassObject* pInstTemplate, 
                                   long lFlags,
                                   IWbemContext* pContext, 
                                   IUnknown* pLockMgr, 
                                   WBEM_REFRESH_INFO* pInfo )
{
    if (NULL == pDestRefresherId || NULL == pDestRefresherId->m_szMachineName)
        return WBEM_E_INVALID_PARAMETER;

    CHiPerfPrvRecord*    pProvRecord = NULL;

    CVar    vProviderName;
    BOOL    fStatic = FALSE;


    RETURN_ON_ERR(GetProviderName( pClassObject, vProviderName, fStatic ));

    HRESULT    hr = S_OK;
    if ( !fStatic )
    {
        hr = FindProviderRecord( vProviderName.GetLPWSTR(), pwszNamespace, pNamespace, &pProvRecord );
    }

    if ( SUCCEEDED( hr ) )
    {
        // Impersonate before continuing.  If this don't succeed, we no workee
        hr = CoImpersonateClient();

        if ( SUCCEEDED( hr ) )
        {
            // Setup the refresher info, inculding a remote refresher record as appropriate
            hr = CreateObjectInfoForProvider((CRefresherId*) pDestRefresherId,
                                        pProvRecord,
                                        pwszServerName,
                                        pwszNamespace,
                                        pNamespace,
                                        (CWbemObject*) pInstTemplate,
                                        lFlags, 
                                        pContext,
                                        (CRefreshInfo*) pInfo,
                                        pLockMgr);

            CoRevertToSelf();

        }

        if ( NULL != pProvRecord )
        {
            pProvRecord->Release();
        }

    }    // IF FindProviderRecord



    return hr;
}

HRESULT 
CRefresherCache::AddEnumToRefresher( IWbemServices* pNamespace, 
                                   LPCWSTR pwszServerName, 
                                   LPCWSTR pwszNamespace, 
                                   /* in  */ IWbemClassObject* pClassObject,
                                   WBEM_REFRESHER_ID* pDestRefresherId, 
                                   IWbemClassObject* pInstTemplate, 
                                   LPCWSTR wszClass,
                                   long lFlags, 
                                   IWbemContext* pContext, 
                                   IUnknown* pLockMgr, 
                                   /* out */ WBEM_REFRESH_INFO* pInfo )
{
    if (NULL == pDestRefresherId || NULL == pDestRefresherId->m_szMachineName)
        return WBEM_E_INVALID_PARAMETER;
    
    CHiPerfPrvRecord*    pProvRecord = NULL;

    CVar    vProviderName;
    BOOL    fStatic = FALSE;

    RETURN_ON_ERR(GetProviderName( pClassObject, vProviderName, fStatic ));

    HRESULT    hr = S_OK;
    if ( !fStatic )
    {
        hr = FindProviderRecord( vProviderName.GetLPWSTR(), pwszNamespace, pNamespace, &pProvRecord );
    }

    if ( SUCCEEDED( hr ) )
    {
        // Impersonate before continuing.  If this don't succeed, we no workee
        hr = CoImpersonateClient();

        if ( SUCCEEDED( hr ) )
        {
            // Setup the refresher info, inculding a remote refresher record as appropriate
            hr = CreateEnumInfoForProvider((CRefresherId*) pDestRefresherId,
                                        pProvRecord,
                                        pwszServerName,
                                        pwszNamespace,
                                        pNamespace,
                                        (CWbemObject*) pInstTemplate,
                                        wszClass,
                                        lFlags, 
                                        pContext,
                                        (CRefreshInfo*) pInfo,
                                        pLockMgr);

            CoRevertToSelf();

        }

        if ( NULL != pProvRecord )
        {
            pProvRecord->Release();
        }

    }    // IF FindProviderRecord
    
    return hr;
}

HRESULT 
CRefresherCache::GetRemoteRefresher( /* in */ WBEM_REFRESHER_ID* pRefresherId, 
                                  long lFlags, 
                                  BOOL fAddRefresher, 
                                  /* out */ IWbemRemoteRefresher** ppRemRefresher,
                                  IUnknown* pLockMgr, 
                                  /* out */ GUID* pGuid )
{
    if (NULL == pRefresherId || NULL == pRefresherId->m_szMachineName)
        return WBEM_E_INVALID_PARAMETER;
    
    CRefresherRecord*    pRefrRecord = NULL;

    //
    // This is a simple look-up into an array with a given REFRESHER_ID
    // since the data (AKA the CRecord) is in memory, there is no point
    // in impersonating and reverting for looking-up a value in memory
    //

    // We may not always want to force a record to be created
    HRESULT hr = FindRefresherRecord( (CRefresherId*) pRefresherId, fAddRefresher, pLockMgr, &pRefrRecord );
    CReleaseMe  rm( (IWbemRemoteRefresher*) pRefrRecord );

    if ( SUCCEEDED( hr ) && pRefrRecord)
    {
        if(!pRefrRecord ->m_Security.AccessCheck())
        {
            DEBUGTRACE((LOG_PROVSS,"attempt to obtain a non owned WBEM_REFRESHER_ID\n"));
                return WBEM_E_ACCESS_DENIED;
        }

        // Get the GUID here as well
        hr = pRefrRecord->QueryInterface( IID_IWbemRemoteRefresher, (void**) ppRemRefresher );
        pRefrRecord->GetGuid( pGuid );
    }

    return hr;
}

//
//  take ownership of provss
//
///////////////////////////////////////////
HRESULT CRefresherCache::Startup( long lFlags , 
                               IWbemContext *pCtx , 
                               _IWmiProvSS *pProvSS )
{
    if ( pProvSS )
    {
        if (NULL == m_pProvSS)
        {
            m_pProvSS = pProvSS;
            m_pProvSS->AddRef ();
        }
        return WBEM_S_NO_ERROR ;
    }
    else
    {
        return WBEM_E_INVALID_PARAMETER ;
    }
}

HRESULT 
CRefresherCache::LoadProvider( IWbemServices* pNamespace, 
                            LPCWSTR pwszProviderName, 
                            LPCWSTR pwszNamespace, 
                            IWbemContext * pContext, 
                            IWbemHiPerfProvider** ppProv, 
                            _IWmiProviderStack** ppProvStack )
{
    return LoadProviderInner( pwszProviderName, 
                          pwszNamespace, 
                          pNamespace, 
                          pContext, 
                          ppProv, 
                          ppProvStack );
}

HRESULT CRefresherCache::Shutdown( LONG a_Flags , ULONG a_MaxMilliSeconds , IWbemContext *a_Context  )
{
    HRESULT hres = WBEM_S_NO_ERROR;

    // Enters and exits using scoping
    CInCritSec  ics( &m_cs );

    // Shutdown Refresher Records first
    if ( m_apRefreshers.GetSize() > 0 )
    {
        CRefresherRecord**    apRecords = new CRefresherRecord*[m_apRefreshers.GetSize()];

        if ( NULL != apRecords )
        {
            int    nSize = m_apRefreshers.GetSize();

            // AddRef each of the records then release them.  This
            // ensures that if any remote refreshers are outstanding we 
            // don't mess with them.

            // We'll probably want to shutdown each record, by having it release
            // all it's stuff.
            for( int i = 0; i < nSize; i++ )
            {
                apRecords[i] = m_apRefreshers[i];
                apRecords[i]->AddRef();
            }

            for( i = 0; i < nSize; i++ )
            {
                apRecords[i]->Release();
            }

            delete [] apRecords;

        }
    }

    // Now shutdown Provider Records
    if ( m_apProviders.GetSize() > 0 )
    {
        CHiPerfPrvRecord**    apRecords = new CHiPerfPrvRecord*[m_apProviders.GetSize()];

        if ( NULL != apRecords )
        {
            int    nSize = m_apProviders.GetSize();

            // AddRef each of the records then release them.  This
            // will force them out of the cache if nobody else is
            // referencing them.

            // We'll probably want to shutdown each record, by having it release
            // all it's stuff.
            for( int i = 0; i < nSize; i++ )
            {
                apRecords[i] = m_apProviders[i];
                apRecords[i]->AddRef();
            }

            for( i = 0; i < nSize; i++ )
            {
                apRecords[i]->Release();
            }

            delete [] apRecords;
        }

    }

    return WBEM_S_NO_ERROR ;
}


HRESULT 
CRefresherCache::CreateObjectInfoForProvider(CRefresherId* pDestRefresherId,
                                   CHiPerfPrvRecord*    pProvRecord,
                                   LPCWSTR pwszServerName, 
                                   LPCWSTR pwszNamespace,
                                   IWbemServices* pNamespace,
                                   CWbemObject* pInstTemplate, long lFlags, 
                                   IWbemContext* pContext,
                                   CRefreshInfo* pInfo,
                                   IUnknown* pLockMgr)
{
	MSHCTX dwDestContext;
    HRESULT hres = GetDestinationContext(dwDestContext, pDestRefresherId);

    if (FAILED(hres))
    {
		return hres;
    }

    // By decorating the object, we will store namespace and
    // server info in the object

    hres = pInstTemplate->SetDecoration( pwszServerName, pwszNamespace );

    if ( FAILED( hres ) )
    {
        return hres;
    }

    // If no hiperf provider, this is non-hiperf refreshing
    if ( NULL == pProvRecord )
    {
        hres = pInfo->SetNonHiPerf( pwszNamespace, pInstTemplate );
    }
    // If this is In-Proc or Local, we'll just let the normal
    // client loadable logic handle it
    else if( dwDestContext == MSHCTX_LOCAL ||  dwDestContext == MSHCTX_INPROC )
    {
        // Set the info appropriately now baseed on whether we are local to
        // the machine or In-Proc to WMI

        if ( dwDestContext == MSHCTX_INPROC )
        {
            // We will use the hiperf provider interface
            // we already have loaded.

            hres = pInfo->SetDirect( pProvRecord->GetClientLoadableClsid(), 
                                  pwszNamespace, 
                                  pProvRecord->GetProviderName(), 
                                  pInstTemplate, 
                                  &m_XWbemRefrCache );
        }
        else // dwDestContext == MSHCTX_LOCAL
        {
            hres = pInfo->SetClientLoadable( pProvRecord->GetClientLoadableClsid(), 
                                         pwszNamespace, 
                                         pInstTemplate );
        }
    }
    else // MSHCTX_DIFFERENTMACHINE ???
    {

        // Ensure that we will indeed have a refresher record.
        CRefresherRecord* pRecord = NULL;
        hres = FindRefresherRecord(pDestRefresherId, TRUE, pLockMgr, &pRecord);
        CReleaseMe rmRecord((IWbemRemoteRefresher *)pRecord);

        if ( SUCCEEDED ( hres ) )
        {
            IWbemHiPerfProvider*    pHiPerfProvider = NULL;

            // Look for the actual provider record.  If we can't find it, we need to load
            // the provider.  If we can find it, then we will use the provider currently being
            // used by the refresher record.

            pRecord->FindProviderRecord( pProvRecord->GetClsid(), &pHiPerfProvider );

            // We'll need this to properly addref the provider
            _IWmiProviderStack*    pProvStack = NULL;

            if ( NULL == pHiPerfProvider )
            {
                hres = LoadProviderInner( pProvRecord->GetProviderName(), pwszNamespace, pNamespace, pContext, &pHiPerfProvider, &pProvStack );
            }

            CReleaseMe    rm( pHiPerfProvider );
            CReleaseMe    rmStack( pProvStack );

            if ( SUCCEEDED( hres ) )
            {
                // Now let the record take care of getting the object inside itself
                hres = pRecord->AddObjectRefresher( pProvRecord, 
                                                 pHiPerfProvider, 
                                                 pProvStack,
                                                 pNamespace, 
                                                 pwszServerName, 
                                                 pwszNamespace,
                                                 pInstTemplate, 
                                                 lFlags, 
                                                 pContext, 
                                                 pInfo );
            }
        }


    }

    return hres;
}

HRESULT 
CRefresherCache::CreateEnumInfoForProvider(CRefresherId* pDestRefresherId,
                                        CHiPerfPrvRecord*    pProvRecord,
                                        LPCWSTR pwszServerName, 
                                        LPCWSTR pwszNamespace,
                                        IWbemServices* pNamespace,
                                        CWbemObject* pInstTemplate,
                                        LPCWSTR wszClass, 
                                        long lFlags, 
                                        IWbemContext* pContext,
                                        CRefreshInfo* pInfo,
                                        IUnknown* pLockMgr)
{
    MSHCTX dwDestContext;
    HRESULT hres = GetDestinationContext(dwDestContext, pDestRefresherId);

    if (FAILED(hres))
    {
		return hres;
    }

    // By decorating the object, we will store namespace and
    // server info so that a client can auto-reconnect to
    // us if necessary

    hres = pInstTemplate->SetDecoration( pwszServerName, pwszNamespace );

    if ( FAILED( hres ) )
    {
        return hres;
    }

    // If no hiperf provider, this is non-hiperf refreshing
    if ( NULL == pProvRecord )
    {
        RETURN_ON_ERR(pInfo->SetNonHiPerf( pwszNamespace, pInstTemplate ));
    }
    // If this is In-Proc or Local, we'll just let the normal
    // client loadable logic handle it ( if we have no hi-perf
    // provider record, then we'll assume remote in order to
    // 
    else if ( dwDestContext == MSHCTX_LOCAL ||dwDestContext == MSHCTX_INPROC )
    {
        // Set the info appropriately now baseed on whether we are local to
        // the machine or In-Proc to WMI

        if ( dwDestContext == MSHCTX_INPROC )
        {
            // We will use the hiperf provider interface
            // we already have loaded.

            RETURN_ON_ERR(pInfo->SetDirect(pProvRecord->GetClientLoadableClsid(), pwszNamespace, pProvRecord->GetProviderName(), pInstTemplate, &m_XWbemRefrCache ));
        }
        else // MSHCTX_LOCAL
        {
            RETURN_ON_ERR(pInfo->SetClientLoadable(pProvRecord->GetClientLoadableClsid(), pwszNamespace, pInstTemplate));
                
        }

    }
    else // MSHCTX_DIFFERENTMACHINE ???
    {    

        // Ensure that we will indeed have a refresher record.
        CRefresherRecord* pRecord = NULL;
        hres = FindRefresherRecord(pDestRefresherId, TRUE, pLockMgr, &pRecord);
        CReleaseMe rmRecord((IWbemRemoteRefresher *)pRecord);

        if ( SUCCEEDED(hres) )
        {
            IWbemHiPerfProvider*    pHiPerfProvider = NULL;

            // Look for the actual provider record.  If we can't find it, we need to load
            // the provider.  If we can find it, then we will use the provider currently being
            // used by the refresher record.

            pRecord->FindProviderRecord( pProvRecord->GetClsid(), &pHiPerfProvider );

            // We'll need this to properly addref the provider
            _IWmiProviderStack*    pProvStack = NULL;

            if ( NULL == pHiPerfProvider )
            {
                hres = LoadProviderInner( pProvRecord->GetProviderName(), 
                                     pwszNamespace, pNamespace,
                                     pContext, &pHiPerfProvider, &pProvStack );
            }

            CReleaseMe    rm( pHiPerfProvider );
            CReleaseMe    rmProvStack( pProvStack );

            if ( SUCCEEDED( hres ) )
            {
                // Add an enumeration to the Refresher
                hres = pRecord->AddEnumRefresher(pProvRecord, 
                                               pHiPerfProvider, 
                                               pProvStack, 
                                               pNamespace, 
                                               pInstTemplate, 
                                               wszClass, 
                                               lFlags, 
                                               pContext, 
                                               pInfo );
            }
        }
    }

    return hres;
}


HRESULT CRefresherCache::GetDestinationContext(MSHCTX& context, CRefresherId* pRefresherId)
{
    // If set, allows us to force remote refreshing in the provider host
#ifdef DBG
    DWORD dwVal = 0;
    Registry rCIMOM(WBEM_REG_WINMGMT);
    if (rCIMOM.GetDWORDStr( TEXT("DebugRemoteRefresher"), &dwVal ) == Registry::no_error)
    {
        if ( dwVal )
        {
            context =  MSHCTX_DIFFERENTMACHINE;
            return WBEM_S_NO_ERROR;
        }
    }
#endif

    char szBuffer[MAX_COMPUTERNAME_LENGTH + 1];
    DWORD dwLen = MAX_COMPUTERNAME_LENGTH + 1;
    if (!GetComputerNameA(szBuffer, &dwLen))
    {
		return HRESULT_FROM_WIN32(GetLastError());
    };

    if(wbem_stricmp(szBuffer, pRefresherId->GetMachineName()))
    {
        context =  MSHCTX_DIFFERENTMACHINE;
        return WBEM_S_NO_ERROR;
    }

    if(pRefresherId->GetProcessId() != GetCurrentProcessId())
        context =   MSHCTX_LOCAL;
    else
        context =   MSHCTX_INPROC;
    return WBEM_S_NO_ERROR;
}

HRESULT CRefresherCache::FindRefresherRecord(CRefresherId* pRefresherId, 
                                          BOOL bCreate,
                                          IUnknown* pLockMgr, 
                                          CRefresherRecord** ppRecord )
{
    if (NULL == ppRecord) return WBEM_E_INVALID_PARAMETER;


    // Enters and exits using scoping
    CInCritSec  ics( &m_cs );

    // We always AddRef() the record before returning so multiple requests will keep the
    // refcount correct so we won't remove and delete a record that another thread wants to
    // use (Remove blocks on the same critical section).

    // Look for it
    // ===========

    for(int i = 0; i < m_apRefreshers.GetSize(); i++)
    {
        if(m_apRefreshers[i]->GetId() == *pRefresherId)
        {
            m_apRefreshers[i]->AddRef();
            *ppRecord = m_apRefreshers[i];
            return WBEM_S_NO_ERROR;
        }
    }

    // If we weren't told to create it, then this is not an error
    if(!bCreate)
    {
        *ppRecord = NULL;
        return WBEM_S_FALSE;
    }

    // Watch for memory exceptions
    try
    {
        wmilib::auto_ptr<CRefresherRecord> pNewRecord( new CRemoteRecord(*pRefresherId, this, pLockMgr));
        if (NULL == pNewRecord.get()) return WBEM_E_OUT_OF_MEMORY;
        if ( m_apRefreshers.Add(pNewRecord.get()) < 0 ) return WBEM_E_OUT_OF_MEMORY;
        pNewRecord->AddRef();
        *ppRecord = pNewRecord.release();
        return WBEM_S_NO_ERROR;
    }
    catch( CX_MemoryException )
    {
        return WBEM_E_OUT_OF_MEMORY;
    }
}


BOOL CRefresherCache::RemoveRefresherRecord(CRefresherRecord* pRecord)
{

    // Enters and exits using scoping
    CInCritSec  ics( &m_cs );

    // Check that the record is actually released, in case another thread successfully requested
    // the record from FindRefresherRecord() which will have AddRef'd the record again.

    if ( pRecord->IsReleased() )
    {
        for(int i = 0; i < m_apRefreshers.GetSize(); i++)
        {
            if(m_apRefreshers[i] == pRecord)
            {
                //
                // the Array itself is a manager, and the manager will call operator delete on the object
                //                
                m_apRefreshers.RemoveAt(i);
                return TRUE;
            }
        }

    }

    return FALSE;
}


//
//  Builds a record without adding to the cache and without loading
//

HRESULT CRefresherCache::FindProviderRecord( LPCWSTR pwszProviderName, 
                                         LPCWSTR pszNamespace, 
                                         IWbemServices* pSvc, 
                                         CHiPerfPrvRecord** ppRecord )
{
    if (NULL == ppRecord) return WBEM_E_INVALID_PARAMETER;
    *ppRecord = NULL;

    // We need to get the GUID of the name corresponding to IWbemServices
    CLSID    clsid;
    CLSID    clientclsid;
    HRESULT hr = GetProviderInfo( pSvc, pwszProviderName, clsid, clientclsid );

    // Enters and exits using scoping
    CInCritSec  ics( &m_cs );

    if ( SUCCEEDED( hr ) )
    {
        // Try to find the provider's class id
        for( int i = 0; i < m_apProviders.GetSize(); i++)
        {
            if ( m_apProviders[i]->GetClsid() == clsid )
            {
                *ppRecord = m_apProviders[i];
                (*ppRecord)->AddRef();        
                return WBEM_S_NO_ERROR;
            }
        }

        // If the record was not found, we must add one
        if (IID_NULL == clientclsid) return WBEM_S_NO_ERROR;
        
        try 
        {
            wmilib::auto_ptr<CHiPerfPrvRecord> pRecord( new CHiPerfPrvRecord( pwszProviderName, clsid, clientclsid, this ));
            if ( NULL == pRecord.get() ) return WBEM_E_OUT_OF_MEMORY;
            if ( m_apProviders.Add( pRecord.get() ) < 0 ) return WBEM_E_OUT_OF_MEMORY;
            pRecord->AddRef();
            *ppRecord = pRecord.release();
            hr = WBEM_S_NO_ERROR;
        }
        catch( CX_MemoryException )
        {
            hr = WBEM_E_OUT_OF_MEMORY;
        }

    }

    return hr;
}

BOOL CRefresherCache::RemoveProviderRecord(CHiPerfPrvRecord* pRecord)
{

    // Enters and exits using scoping
    CInCritSec  ics( &m_cs );

    // Check that the record is actually released, in case another thread successfully requested
    // the record from FindRefresherRecord() which will have AddRef'd the record again.

    if ( pRecord->IsReleased() )
    {
        for(int i = 0; i < m_apProviders.GetSize(); i++)
        {
            if(m_apProviders[i] == pRecord)
            {
                //
                // the Array itself is a manager, and the manager will call operator delete on the object
                //
                m_apProviders.RemoveAt(i);
                return TRUE;
            }
        }

    }

    return FALSE;
}



//
// given the provider name, it returns the TWO clais from the registration
//
/////////////////////////////////////////////////////
HRESULT CRefresherCache::GetProviderInfo( IWbemServices* pSvc, 
                                      LPCWSTR pwszProviderName, 
                                      /* out */ CLSID & Clsid, 
                                      /* out */ CLSID & ClientClsid )
{
    HRESULT    hr = WBEM_S_NO_ERROR;

    try
    {
        // Create the path
        WString    strPath( L"__Win32Provider.Name=\"" );

        strPath += pwszProviderName;
        strPath += ( L"\"" );

        BSTR    bstrPath = SysAllocString( (LPCWSTR) strPath );
        if ( NULL == bstrPath ) return WBEM_E_OUT_OF_MEMORY;
        CSysFreeMe    sfm(bstrPath);

        IWbemClassObject*    pObj = NULL;
        hr = pSvc->GetObject( bstrPath, 0L, NULL, &pObj, NULL );
        CReleaseMe    rm( pObj );

        if ( SUCCEEDED( hr ) )
        {
            CWbemInstance*    pInst = (CWbemInstance*) pObj;

            CVar    var;

            hr = pInst->GetProperty( L"CLSID", &var );

            if ( SUCCEEDED( hr ) )
            {
                // Convert string to a GUID.
                hr = CLSIDFromString( var.GetLPWSTR(), &Clsid );

                if ( SUCCEEDED( hr ) )
                {
                    var.Empty();

                    hr = pInst->GetProperty( L"ClientLoadableCLSID", &var );

                    if ( SUCCEEDED( hr ) )
                    {
                        // Convert string to a GUID.
                        hr = CLSIDFromString( var.GetLPWSTR(), &ClientClsid );
                    }
                    else
                    {
                        ClientClsid = IID_NULL;
                        hr = WBEM_S_NO_ERROR;
                    }

                }    // IF CLSID from String

            }    // IF GetCLSID

        }    // IF GetObject

    }
    catch( CX_MemoryException )
    {
        hr = WBEM_E_OUT_OF_MEMORY;
    }
    catch(...)
    {
        hr = WBEM_E_CRITICAL_ERROR;
    }

    return hr;
}

//
// this call will run inside wmiprvse and will do:
// obtain the proxy to the BindingFactory in winMgmt
// call the factory to obtain a proxy to a CInterceptor_IWbemProvider
// call the DownLevel methos on the proxy to obtain the CInterceptor_IWbemSyncProvider
//
//////////////////////////////////////////////////////////////////////
HRESULT 
CRefresherCache::LoadProviderInner(LPCWSTR pwszProviderName, 
                              LPCWSTR pszNamespace, 
                              IWbemServices* pSvc, 
                              IWbemContext * pCtx,
                              IWbemHiPerfProvider** ppProv,
                              _IWmiProviderStack** ppStack )
{
    _IWmiProviderFactory *pFactory = NULL;
    HRESULT hRes = m_pProvSS->Create(pSvc,
                                         0,    // lFlags
                                         pCtx,    // pCtx
                                         pszNamespace, // Path
                                         IID__IWmiProviderFactory,
                                         (LPVOID *) &pFactory);

    if ( SUCCEEDED ( hRes ) )
    {
        _IWmiProviderStack *pStack = NULL ;

        hRes = pFactory->GetHostedProvider(0L,
                                           pCtx,
                                           NULL,
                                           NULL,
                                           NULL,
                                           NULL,
                                           pwszProviderName, 
                                           e_Hosting_SharedNetworkServiceHost,
                                           L"DefaultNetworkServiceHost",
                                           IID__IWmiProviderStack,
                                           (void**) &pStack);

        if ( SUCCEEDED ( hRes ) )
        {
            IUnknown *t_Unknown = NULL ;
            hRes = pStack->DownLevel(0 ,
                                       NULL ,
                                       IID_IUnknown,
                                       ( void ** ) & t_Unknown);

            if ( SUCCEEDED ( hRes ) )
            {
                hRes = t_Unknown->QueryInterface( IID_IWbemHiPerfProvider , ( void ** ) ppProv );

                // We got what we wanted.  If appropriate, copy the Provider Stack
                // Interface pointer
                if ( SUCCEEDED( hRes ) && NULL != ppStack )
                {
                    *ppStack = pStack;
                    pStack->AddRef();
                }

                t_Unknown->Release();
            }

            pStack->Release();
        }

        pFactory->Release();
    }

    return hRes ;

}

//
// Gets the provider of an IWbemClassObejct from the qualifier
//
////////////////////////////////////////////////////////
HRESULT CRefresherCache::GetProviderName( /* in  */ IWbemClassObject*    pClassObj, 
                                        /* out */ CVar & ProviderName, 
                                        /* out */ BOOL & fStatic )
{
    fStatic = FALSE;

    _IWmiObject*    pWmiObject = NULL;
    HRESULT    hr = pClassObj->QueryInterface( IID__IWmiObject, (void**) &pWmiObject );
    CReleaseMe    rmObj( pWmiObject );

    if ( SUCCEEDED( hr ) )
    {
        CWbemObject*    pObj = (CWbemObject*)pWmiObject;
        hr = pObj->GetQualifier(L"provider", &ProviderName);

        // Must be a dynamically provided class.  If it's static, or the variant type is wrong, that's still okay
        // we just need to record this information
        if(FAILED(hr))
        {
            if ( WBEM_E_NOT_FOUND == hr )
            {
                fStatic = TRUE;
                return WBEM_S_NO_ERROR;
            }

            return WBEM_E_INVALID_OPERATION;
        }
        else if ( ProviderName.GetType() != VT_BSTR )
        {
            fStatic = TRUE;
            return WBEM_S_NO_ERROR;
        }
    }    // If got WMIObject interface

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\marshalers\coreprox\refrcli.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    REFRCLI.CPP

Abstract:

    Refresher Client Side Code.

History:

--*/

#include "precomp.h"
#include <stdio.h>
#include <process.h>
#include "fastall.h"
#include "hiperfenum.h"
#include "refrcli.h"
#include <sync.h>
#include <provinit.h>
#include <cominit.h>
#include <wbemint.h>
#include <autoptr.h>
#include <objbase.h>
#include <corex.h>

//*****************************************************************************
//*****************************************************************************
//                              XCREATE
//*****************************************************************************
//*****************************************************************************

STDMETHODIMP 
CUniversalRefresher::XConfigure::AddObjectByPath(IWbemServices* pNamespace, 
                                            LPCWSTR wszPath,
                                            long lFlags, 
                                            IWbemContext* pContext, 
                                            IWbemClassObject** ppRefreshable, 
                                            long* plId)
{
    HRESULT hres = WBEM_S_NO_ERROR;

    // Check for invalid parameters
    if ( NULL == pNamespace || NULL == wszPath || NULL == ppRefreshable || NULL == *wszPath )
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    // Validate flags
    if ( ( lFlags & ~WBEM_FLAG_USE_AMENDED_QUALIFIERS ) )
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    // Make sure we are able to acquire the spinlock.
    // The destructor will unlock us if we get access

    CHiPerfLockAccess   lock( m_pObject->m_Lock );
    if ( !lock.IsLocked() ) return WBEM_E_REFRESHER_BUSY;

    // Acquire internal connection to WINMGMT
    // ====================================

    IWbemRefreshingServices* pRefServ = NULL;

    // Storage for security settings we will need in order to propagate
    // down to our internal interfaces.

    COAUTHINFO  CoAuthInfo;
    ZeroMemory( &CoAuthInfo, sizeof(CoAuthInfo) );

    hres = CUniversalRefresher::GetRefreshingServices( pNamespace, &pRefServ, &CoAuthInfo );
    if (FAILED(hres)) return hres;
    CReleaseMe rm(pRefServ);
    
    // This guarantees this will be freed when we drop out of scope.  If we store
    // it we will need to allocate an internal copy.

    CMemFreeMe  mfm( CoAuthInfo.pwszServerPrincName );

    // Forward this request
    // ====================

    CRefreshInfo Info;
    DWORD       dwRemoteRefrVersion = 0;

    hres = pRefServ->AddObjectToRefresher(&m_pObject->m_Id, 
                                       wszPath, lFlags,
                                       pContext, WBEM_REFRESHER_VERSION, 
                                       &Info, &dwRemoteRefrVersion);
    if (FAILED(hres)) return hres;        

    // Act on the information
    // ======================

    switch(Info.m_lType)
    {
        case WBEM_REFRESH_TYPE_CLIENT_LOADABLE:
            hres = m_pObject->AddClientLoadableObject(Info.m_Info.m_ClientLoadable, 
                        pNamespace, pContext, ppRefreshable, plId);
            break;

        case WBEM_REFRESH_TYPE_DIRECT:
            hres = m_pObject->AddDirectObject(Info.m_Info.m_Direct, 
                        pNamespace, pContext, ppRefreshable, plId);
            break;

        case WBEM_REFRESH_TYPE_REMOTE:
            
            hres = m_pObject->AddRemoteObject( pRefServ, Info.m_Info.m_Remote, wszPath,
                        Info.m_lCancelId, ppRefreshable, plId, &CoAuthInfo);
            break;

        case WBEM_REFRESH_TYPE_NON_HIPERF:
            hres = m_pObject->AddNonHiPerfObject(Info.m_Info.m_NonHiPerf, 
                        pNamespace, wszPath, ppRefreshable, plId, CoAuthInfo);
            break;

        default:
            hres = WBEM_E_INVALID_OPERATION;
    }
    

    return hres;
}

STDMETHODIMP 
CUniversalRefresher::XConfigure::AddObjectByTemplate(IWbemServices* pNamespace, 
                                                IWbemClassObject* pTemplate,
                                                long lFlags, 
                                                IWbemContext* pContext, 
                                                IWbemClassObject** ppRefreshable, 
                                                long* plId)
{

    // Check for invalid parameters
    if ( NULL == pNamespace || NULL == pTemplate || NULL == ppRefreshable || 0L != lFlags )
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    // Check that this is an instance object
    if ( ! ((CWbemObject*)pTemplate)->IsInstance() )
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    CVar vPath;
    HRESULT hRes = ((CWbemObject*)pTemplate)->GetRelPath(&vPath);
    if (FAILED(hRes)) return hRes;
    
    hRes = AddObjectByPath(pNamespace, 
                         vPath.GetLPWSTR(), 
                         lFlags, 
                         pContext,
                         ppRefreshable, 
                         plId);
    return hRes;
}

STDMETHODIMP 
CUniversalRefresher::XConfigure::AddRefresher(IWbemRefresher* pRefresher, 
                                         long lFlags, 
                                         long* plId)
{

    HRESULT hres = WBEM_S_NO_ERROR;

    // Check for invalid parameters
    if ( NULL == pRefresher || 0L != lFlags )
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    // Make sure we are able to acquire the spinlock.
    // The destructor will unlock us if we get access

    CHiPerfLockAccess   lock( m_pObject->m_Lock );
    if ( ! lock.IsLocked() ) return WBEM_E_REFRESHER_BUSY;

    hres = m_pObject->AddRefresher( pRefresher, lFlags, plId );
    return hres;

}

STDMETHODIMP CUniversalRefresher::XConfigure::Remove(long lId, long lFlags)
{
    HRESULT hres = WBEM_S_NO_ERROR;

    // Check for invalid flag values
    if ( ( lFlags & ~WBEM_FLAG_REFRESH_NO_AUTO_RECONNECT ) )
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    // Make sure we are able to acquire the spinlock.
    // The destructor will unlock us if we get access
    CHiPerfLockAccess   lock( m_pObject->m_Lock );
    if ( !lock.IsLocked() ) return WBEM_E_REFRESHER_BUSY;

    hres = m_pObject->Remove(lId, lFlags);
    return hres;
}

HRESULT CUniversalRefresher::XConfigure::AddEnum( IWbemServices* pNamespace, LPCWSTR wszClassName,
                                               long lFlags, 
                                               IWbemContext* pContext, 
                                               IWbemHiPerfEnum** ppEnum,
                                               long* plId)
{
    HRESULT hres = WBEM_S_NO_ERROR;

    // Check for invalid parameters
    if ( NULL == pNamespace || NULL == wszClassName || NULL == ppEnum || NULL == *wszClassName )
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    // Validate flags
    if ( ( lFlags & ~WBEM_FLAG_USE_AMENDED_QUALIFIERS ) )
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    // Make sure we are able to acquire the spinlock.
    // The destructor will unlock us if we get access

    CHiPerfLockAccess   lock( m_pObject->m_Lock );
    if ( !lock.IsLocked() ) return WBEM_E_REFRESHER_BUSY;

    // Create a parser if we need one
    if ( NULL == m_pObject->m_pParser )
    {
        hres = CoCreateInstance( CLSID_WbemDefPath, NULL, 
                              CLSCTX_INPROC_SERVER, 
                              IID_IWbemPath, (void**) &m_pObject->m_pParser );
        if (FAILED(hres)) return hres;

    }

    // Set the path, and verify that it is a class path.  If not, we
    // fail the operation.

    hres = m_pObject->m_pParser->SetText( WBEMPATH_CREATE_ACCEPT_ALL, wszClassName );
    
    if (FAILED(hres)) return hres;


    ULONGLONG    uResponse = 0L;
    hres = m_pObject->m_pParser->GetInfo(0, &uResponse);
    if (FAILED(hres)) return hres;        
    if ( ( uResponse & WBEMPATH_INFO_IS_CLASS_REF ) == 0 ) return WBEM_E_INVALID_OPERATION;

    // reset the parser here
    m_pObject->m_pParser->SetText(WBEMPATH_CREATE_ACCEPT_ALL, NULL);

    // Acquire internal connection to WINMGMT
    IWbemRefreshingServices* pRefServ = NULL;

    // Storage for security settings we will need in order to propagate
    // down to our internal interfaces.
    COAUTHINFO  CoAuthInfo;
    ZeroMemory( &CoAuthInfo, sizeof(CoAuthInfo) );

    hres = CUniversalRefresher::GetRefreshingServices( pNamespace, &pRefServ, &CoAuthInfo );
    if (FAILED(hres)) return hres;       
    
    CReleaseMe rm(pRefServ);
    CMemFreeMe  mfm( CoAuthInfo.pwszServerPrincName );

    // Forward this request
    // ====================

    CRefreshInfo Info;
    DWORD       dwRemoteRefrVersion = 0;

    hres = pRefServ->AddEnumToRefresher(&m_pObject->m_Id, 
                                        wszClassName, lFlags,
                                        pContext, WBEM_REFRESHER_VERSION, &Info, &dwRemoteRefrVersion);
    if (FAILED(hres)) return hres;
    
    // Act on the information
    switch(Info.m_lType)
    {
        case WBEM_REFRESH_TYPE_CLIENT_LOADABLE:
            hres = m_pObject->AddClientLoadableEnum(Info.m_Info.m_ClientLoadable, 
                                                    pNamespace, wszClassName, pContext, 
                                                    ppEnum, plId);
            break;

        case WBEM_REFRESH_TYPE_DIRECT:
            hres = m_pObject->AddDirectEnum(Info.m_Info.m_Direct, 
                        pNamespace, wszClassName, pContext,
                        ppEnum, plId);
            break;

        case WBEM_REFRESH_TYPE_REMOTE:
            hres = m_pObject->AddRemoteEnum( pRefServ, Info.m_Info.m_Remote, wszClassName,
                        Info.m_lCancelId, pContext, ppEnum, 
                        plId, &CoAuthInfo );
            break;

        case WBEM_REFRESH_TYPE_NON_HIPERF:
            hres = m_pObject->AddNonHiPerfEnum(Info.m_Info.m_NonHiPerf, 
                        pNamespace, wszClassName, pContext,
                        ppEnum, plId, CoAuthInfo);
            break;

        default:
            hres = WBEM_E_INVALID_OPERATION;
            break;
    }

    

    return hres;
}

//*****************************************************************************
//*****************************************************************************
//                              XREFRESHER
//*****************************************************************************
//*****************************************************************************
STDMETHODIMP CUniversalRefresher::XRefresher::Refresh(long lFlags)
{
    HRESULT hres = WBEM_S_NO_ERROR;

    // Check for invalid flag values
    if ( ( lFlags & ~WBEM_FLAG_REFRESH_NO_AUTO_RECONNECT ) )
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    // Make sure we are able to acquire the spinlock.
    // The destructor will unlock us if we get access
    CHiPerfLockAccess   lock( m_pObject->m_Lock );
    if ( !lock.IsLocked() ) return WBEM_E_REFRESHER_BUSY;

    hres = m_pObject->Refresh(lFlags);

    return hres;
}


//*****************************************************************************
//*****************************************************************************
//                          UNIVERSAL REFRESHER
//*****************************************************************************
//*****************************************************************************

CClientLoadableProviderCache CUniversalRefresher::mstatic_Cache;
long CUniversalRefresher::mstatic_lLastId = 0;

long CUniversalRefresher::GetNewId()
{
    return InterlockedIncrement(&mstatic_lLastId);
}

CUniversalRefresher::~CUniversalRefresher()
{
    // Release the path parser if we are holding onto one
    if ( NULL != m_pParser )
    {
        m_pParser->Release();
    }

    // When we are destructed, we need to make sure that any remote refreshers
    // that may still be trying to reconnect on separate threads are silenced

    for ( long lCtr = 0; lCtr < m_apRemote.GetSize(); lCtr++ )
    {
        CRemote* pRemote = m_apRemote.GetAt( lCtr );
        if ( pRemote ) pRemote->Quit();
    } 
}


void* CUniversalRefresher::GetInterface(REFIID riid)
{
    if(riid == IID_IUnknown || riid == IID_IWbemRefresher)
        return &m_XRefresher;
    else if(riid == IID_IWbemConfigureRefresher)
        return &m_XConfigure;
    else
        return NULL;
}

HRESULT 
CUniversalRefresher::GetRefreshingServices( IWbemServices* pNamespace,
                                      IWbemRefreshingServices** ppRefSvc,
                                      COAUTHINFO* pCoAuthInfo )
{
    // Acquire internal connection to WINMGMT
    // ====================================

    HRESULT hres = pNamespace->QueryInterface(IID_IWbemRefreshingServices, 
                                    (void**) ppRefSvc);

    if ( SUCCEEDED( hres ) )
    {
        // We will query the namespace for its security settings so we can propagate
        // those settings onto our own internal interfaces.

        hres = CoQueryProxyBlanket( pNamespace, 
                                 &pCoAuthInfo->dwAuthnSvc, 
                                 &pCoAuthInfo->dwAuthzSvc,
                                 &pCoAuthInfo->pwszServerPrincName, 
                                 &pCoAuthInfo->dwAuthnLevel,
                                 &pCoAuthInfo->dwImpersonationLevel, 
                                 (RPC_AUTH_IDENTITY_HANDLE*) &pCoAuthInfo->pAuthIdentityData,
                                 &pCoAuthInfo->dwCapabilities );

        if ( SUCCEEDED( hres ) )
        {
            hres = WbemSetProxyBlanket( *ppRefSvc, 
                                      pCoAuthInfo->dwAuthnSvc, 
                                      pCoAuthInfo->dwAuthzSvc,
                                      COLE_DEFAULT_PRINCIPAL, 
                                      pCoAuthInfo->dwAuthnLevel,
                                      pCoAuthInfo->dwImpersonationLevel, 
                                      pCoAuthInfo->pAuthIdentityData,
                                      pCoAuthInfo->dwCapabilities );
        }
        else if ( E_NOINTERFACE == hres )
        {
            // If we are in-proc to WMI, then CoQueryProxyBlanket can fail, but this
            // is not really an error, per se, so we will fake it.
            hres = WBEM_S_NO_ERROR;
        }

        if ( FAILED( hres ) )
        {
            (*ppRefSvc)->Release();
            *ppRefSvc = NULL;
        }

    }   // IF QI

    return hres;
}

HRESULT 
CUniversalRefresher::AddInProcObject(CHiPerfProviderRecord* pProvider,
                                 IWbemObjectAccess* pTemplate,
                                 IWbemServices* pNamespace,
                                 IWbemContext * pContext,
                                 IWbemClassObject** ppRefreshable, long* plId)
{
    HRESULT hres = WBEM_S_NO_ERROR;

    // Look for a provider record with this provider pointer
    // =====================================================

    CDirect* pFoundRec = NULL;
    for(int i = 0; i < m_apDirect.GetSize(); i++)
    {
        CDirect* pDirectRec = m_apDirect[i];
        if(pDirectRec->GetProvider() == pProvider)
        {
            pFoundRec = pDirectRec;
            break;
        }
    }

    if(pFoundRec == NULL)
    {
        // ask the Hi-Perf provider to give us a new refresher
        IWbemRefresher* pRefresher = NULL;

        try
        {
            hres = pProvider->m_pProvider->CreateRefresher(pNamespace, 0, &pRefresher);
        }
        catch(...)
        {
            // Provider threw an exception, so get out of here ASAP
            hres = WBEM_E_PROVIDER_FAILURE;
        }
        if(FAILED(hres)) return hres;
        CReleaseMe rmRefr(pRefresher);

        wmilib::auto_ptr<CDirect> pTmp(new CDirect(pProvider, pRefresher));
        if (NULL == pTmp.get()) return WBEM_E_OUT_OF_MEMORY;
        if (-1 == m_apDirect.Add(pTmp.get())) return WBEM_E_OUT_OF_MEMORY;
        pFoundRec = pTmp.release();
    }

    // Add request in provider
    // =======================

    IWbemObjectAccess* pProviderObject = NULL;
    long lProviderId;

    // If the user specified the WBEM_FLAG_USE_AMENDED_QUALIFIERS flag, then
    // IWbemRefreshingServices::AddObjectToRefresher will return a localized
    // instance definition.  Since localized stuff should all be in the class
    // definition, the provider doesn't really "need" toknow  that we're sneaking
    // this in.  To protect our object, we'll clone it BEFORE we pass it to
    // the provider.  The instance that is returned by the provider BETTER be of
    // the same class type we are, however.

    CWbemInstance*  pClientInstance = NULL;

    hres = pTemplate->Clone( (IWbemClassObject**) &pClientInstance );
    if ( FAILED( hres ) ) return hres;
    CReleaseMe rmCInst((IWbemClassObject*)pClientInstance);


    try
    {
        hres = pProvider->m_pProvider->CreateRefreshableObject(pNamespace, 
                                                          pTemplate, 
                                                          pFoundRec->GetRefresher(), 
                                                          0, pContext, 
                                                          &pProviderObject, 
                                                          &lProviderId);
    }
    catch(...)
    {
        // Provider threw an exception, so get out of here ASAP
        hres = WBEM_E_PROVIDER_FAILURE;
    }
    if(FAILED(hres)) return hres;
    CReleaseMe rmProvOb(pProviderObject);

    // Now copy the provider returned instance data.
    hres = pClientInstance->CopyBlobOf( (CWbemInstance*) pProviderObject );
    if(FAILED(hres)) return hres;    

    hres = pFoundRec->AddObjectRequest((CWbemObject*)pProviderObject, 
                                pClientInstance, 
                                lProviderId,
                                ppRefreshable, 
                                plId);

    return hres;
}

HRESULT 
CUniversalRefresher::AddInProcEnum(CHiPerfProviderRecord* pProvider,
                                IWbemObjectAccess* pTemplate,
                                IWbemServices* pNamespace, 
                                LPCWSTR wszClassName,
                                IWbemContext * pCtx,
                                IWbemHiPerfEnum** ppEnum, long* plId)
{
    HRESULT hres = WBEM_S_NO_ERROR;

    // Look for a provider record with this provider pointer
    // =====================================================

    CDirect* pFoundRec = NULL;
    for(int i = 0; i < m_apDirect.GetSize(); i++)
    {
        CDirect* pDirectRec = m_apDirect[i];
        if(pDirectRec->GetProvider() == pProvider)
        {
            pFoundRec = pDirectRec;
            break;
        }
    }

    if(pFoundRec == NULL)
    {
        // ask the Hi-Perf provider to give us a new refresher
        IWbemRefresher* pRefresher = NULL;

        try
        {
            hres = pProvider->m_pProvider->CreateRefresher(pNamespace, 0, &pRefresher);
        }
        catch(...)
        {
            // Provider threw an exception, so get out of here ASAP
            hres = WBEM_E_PROVIDER_FAILURE;
        }
        if(FAILED(hres)) return hres;
        CReleaseMe rmRefr(pRefresher);

        wmilib::auto_ptr<CDirect> pTmp(new CDirect(pProvider, pRefresher));
        if (NULL == pTmp.get()) return WBEM_E_OUT_OF_MEMORY;
        if (-1 == m_apDirect.Add(pTmp.get())) return WBEM_E_OUT_OF_MEMORY;
        pFoundRec = pTmp.release();
    }

    // Add request in provider
    // =======================

    CClientLoadableHiPerfEnum*  pHPEnum = new CClientLoadableHiPerfEnum( m_pControl );
    if ( NULL == pHPEnum ) return WBEM_E_OUT_OF_MEMORY;
    
    pHPEnum->AddRef();
    CReleaseMe  rmEnum( pHPEnum );

    long lProviderId;

    // If the user specified the WBEM_FLAG_USE_AMENDED_QUALIFIERS flag, then
    // IWbemRefreshingServices::AddEnumToRefresher will return a localized
    // instance definition.  Since localized stuff should all be in the class
    // definition, the provider doesn't really "need" toknow  that we're sneaking
    // this in.

    hres = pHPEnum->SetInstanceTemplate( (CWbemInstance*) pTemplate );
    if ( FAILED(hres)) return hres;


    try
    {
        hres = pProvider->m_pProvider->CreateRefreshableEnum(pNamespace, 
                                                          (LPWSTR) wszClassName, 
                                                            pFoundRec->GetRefresher(), 
                                                            0, 
                                                            pCtx, 
                                                            (IWbemHiPerfEnum*) pHPEnum, 
                                                            &lProviderId );
    }
    catch(...)
    {
        // Provider threw an exception, so get out of here ASAP
        hres = WBEM_E_PROVIDER_FAILURE;
    }

    if(FAILED(hres)) return hres;

    hres = pFoundRec->AddEnumRequest( pHPEnum, lProviderId,
                                     ppEnum, plId, m_pControl );


    return hres;
}

HRESULT CUniversalRefresher::AddClientLoadableObject(
                                const WBEM_REFRESH_INFO_CLIENT_LOADABLE& Info,
                                IWbemServices* pNamespace,
                                IWbemContext * pContext,
                                IWbemClassObject** ppRefreshable, long* plId)
{
    // Get this provider pointer from the cache
    // ========================================

    CHiPerfProviderRecord* pProvider = NULL;
    HRESULT hres = GetProviderCache()->FindProvider(Info.m_clsid, 
                        Info.m_wszNamespace, pNamespace,pContext, &pProvider);
    if(FAILED(hres) || pProvider == NULL) return hres;

    // Now use the helper function to do the rest of the work
    hres = AddInProcObject( pProvider, Info.m_pTemplate, pNamespace, pContext, ppRefreshable, plId );

    pProvider->Release();
    return hres;

}
    
HRESULT CUniversalRefresher::AddClientLoadableEnum(
                                const WBEM_REFRESH_INFO_CLIENT_LOADABLE& Info,
                                IWbemServices* pNamespace, LPCWSTR wszClassName,
                                IWbemContext * pCtx,
                                IWbemHiPerfEnum** ppEnum, long* plId)
{
    // Get this provider pointer from the cache
    // ========================================

    CHiPerfProviderRecord* pProvider = NULL;
    HRESULT hres = GetProviderCache()->FindProvider(Info.m_clsid, 
                        Info.m_wszNamespace, pNamespace, pCtx, &pProvider);
    if(FAILED(hres) || pProvider == NULL) return hres;

    // Now use the helper function to do the rest of the work
    hres = AddInProcEnum( pProvider, Info.m_pTemplate, pNamespace, wszClassName, pCtx, ppEnum, plId );

    pProvider->Release();
    return hres;

}

HRESULT CUniversalRefresher::AddDirectObject(
                                const WBEM_REFRESH_INFO_DIRECT& Info,
                                IWbemServices* pNamespace,
                                IWbemContext * pContext,
                                IWbemClassObject** ppRefreshable, long* plId)
{
    // Get this provider pointer from the cache
    // ========================================

    IWbemHiPerfProvider*    pProv = NULL;
    _IWmiProviderStack*        pProvStack = NULL;

    HRESULT    hres = Info.m_pRefrMgr->LoadProvider( pNamespace, Info.m_pDirectNames->m_wszProviderName, Info.m_pDirectNames->m_wszNamespace, NULL, &pProv, &pProvStack );
    CReleaseMe    rmTest( pProv );
    CReleaseMe    rmProvStack( pProvStack );
    if ( FAILED( hres ) ) return hres;

    CHiPerfProviderRecord* pProvider = NULL;
    hres = GetProviderCache()->FindProvider(Info.m_clsid, pProv, pProvStack, Info.m_pDirectNames->m_wszNamespace, &pProvider);
    if(FAILED(hres) || pProvider == NULL) return hres;

    // Now use the helper function to do the rest of the work
    hres = AddInProcObject( pProvider, Info.m_pTemplate, pNamespace, pContext, ppRefreshable, plId );

    pProvider->Release();

    return hres;
}
    
HRESULT 
CUniversalRefresher::AddDirectEnum(const WBEM_REFRESH_INFO_DIRECT& Info,
                                IWbemServices* pNamespace, 
                                LPCWSTR wszClassName, 
                                IWbemContext * pContext,
                                IWbemHiPerfEnum** ppEnum, 
                                long* plId)
{
    // Get this provider pointer from the cache
    // ========================================

    IWbemHiPerfProvider*    pProv = NULL;
    _IWmiProviderStack*        pProvStack = NULL;

    HRESULT    hres = Info.m_pRefrMgr->LoadProvider( pNamespace, Info.m_pDirectNames->m_wszProviderName, Info.m_pDirectNames->m_wszNamespace, pContext, &pProv, &pProvStack );
    CReleaseMe    rmTest( pProv );
    CReleaseMe    rmProvStack( pProvStack );

    if (FAILED( hres ) ) return hres;

    CHiPerfProviderRecord* pProvider = NULL;
    hres = GetProviderCache()->FindProvider(Info.m_clsid, pProv, pProvStack, Info.m_pDirectNames->m_wszNamespace, &pProvider);
    if(FAILED(hres) || pProvider == NULL) return hres;

    // Now use the helper function to do the rest of the work
    hres = AddInProcEnum( pProvider, Info.m_pTemplate, pNamespace, wszClassName, pContext, ppEnum, plId );

    pProvider->Release();

    return hres;
}

HRESULT 
CUniversalRefresher::AddNonHiPerfObject( const WBEM_REFRESH_INFO_NON_HIPERF& Info,
                                    IWbemServices* pNamespace, 
                                    LPCWSTR pwszPath,
                                    IWbemClassObject** ppRefreshable, 
                                    long* plId,
                                    COAUTHINFO & CoAuthInfo )
{
    HRESULT hres = WBEM_S_NO_ERROR;

    // Look for a Non Hi-Perf Record for this namespace
    // =====================================================

    CNonHiPerf* pFoundRec = NULL;
    for(int i = 0; i < m_apNonHiPerf.GetSize(); i++)
    {
        CNonHiPerf* pDirectRec = m_apNonHiPerf[i];
        if( wbem_wcsicmp( pDirectRec->GetNamespace(), Info.m_wszNamespace ) == 0 )
        {
            pFoundRec = pDirectRec;
            break;
        }
    }

    if(pFoundRec == NULL)
    {
        // Create a new one

        IWbemServices*    pSvcEx = NULL;
        hres = pNamespace->QueryInterface( IID_IWbemServices, (void**) &pSvcEx );
        CReleaseMe    rmSvcEx( pSvcEx );
        if (FAILED(hres)) return hres;

        // Secure it here
        WbemSetProxyBlanket( pSvcEx, CoAuthInfo.dwAuthnSvc, CoAuthInfo.dwAuthzSvc,
                        COLE_DEFAULT_PRINCIPAL, CoAuthInfo.dwAuthnLevel, CoAuthInfo.dwImpersonationLevel,
                        (RPC_AUTH_IDENTITY_HANDLE) CoAuthInfo.pAuthIdentityData, CoAuthInfo.dwCapabilities );

        try
        {
            wmilib::auto_ptr<CNonHiPerf> pTmp( new CNonHiPerf( Info.m_wszNamespace, pSvcEx ));
            if (NULL == pTmp.get()) return WBEM_E_OUT_OF_MEMORY;
            if (-1 == m_apNonHiPerf.Add(pTmp.get())) return WBEM_E_OUT_OF_MEMORY;

            pFoundRec = pTmp.release();
        }
        catch( CX_MemoryException )
        {
            return WBEM_E_OUT_OF_MEMORY;
        }
    }    // IF not found

    // If the user specified the WBEM_FLAG_USE_AMENDED_QUALIFIERS flag, then
    // IWbemRefreshingServices::AddObjectToRefresher will return a localized
    // instance definition.  Since localized stuff should all be in the class
    // definition, the provider doesn't really "need" toknow  that we're sneaking
    // this in.  To protect our object, we'll clone it BEFORE we pass it to
    // the provider.  The instance that is returned by the provider BETTER be of
    // the same class type we are, however.

    CWbemInstance*  pClientInstance = NULL;

    hres = Info.m_pTemplate->Clone( (IWbemClassObject**) &pClientInstance );
    if (FAILED(hres)) return hres;
    CReleaseMe rmCliInst((IWbemClassObject *)pClientInstance);

    hres = pFoundRec->AddObjectRequest((CWbemObject*)Info.m_pTemplate, pClientInstance, pwszPath, ppRefreshable, plId);

    return hres;
}

HRESULT 
CUniversalRefresher::AddNonHiPerfEnum( const WBEM_REFRESH_INFO_NON_HIPERF& Info,
                                   IWbemServices* pNamespace, 
                                   LPCWSTR wszClassName,
                                   IWbemContext * pContext,
                                   IWbemHiPerfEnum** ppEnum, 
                                   long* plId,
                                   COAUTHINFO & CoAuthInfo )
{
    HRESULT hres = WBEM_S_NO_ERROR;

    // Look for a Non Hi-Perf Record for this namespace
    // =====================================================

    CNonHiPerf* pFoundRec = NULL;
    for(int i = 0; i < m_apNonHiPerf.GetSize(); i++)
    {
        CNonHiPerf* pDirectRec = m_apNonHiPerf[i];
        if( wbem_wcsicmp( pDirectRec->GetNamespace(), Info.m_wszNamespace ) == 0 )
        {
            pFoundRec = pDirectRec;
            break;
        }
    }

    if(pFoundRec == NULL)
    {
        // Create a new one

        IWbemServices*    pSvcEx = NULL;
        hres = pNamespace->QueryInterface( IID_IWbemServices, (void**) &pSvcEx );
        CReleaseMe    rmSvcEx( pSvcEx );
        if (FAILED(hres)) return hres;

        // Secure it here
        WbemSetProxyBlanket( pSvcEx, CoAuthInfo.dwAuthnSvc, CoAuthInfo.dwAuthzSvc,
                        COLE_DEFAULT_PRINCIPAL, CoAuthInfo.dwAuthnLevel, CoAuthInfo.dwImpersonationLevel,
                        (RPC_AUTH_IDENTITY_HANDLE) CoAuthInfo.pAuthIdentityData, CoAuthInfo.dwCapabilities );

        try
        {
            wmilib::auto_ptr<CNonHiPerf> pTmp(new CNonHiPerf( Info.m_wszNamespace, pSvcEx ));
            if (NULL == pTmp.get()) return WBEM_E_OUT_OF_MEMORY;
            if (-1 == m_apNonHiPerf.Add(pTmp.get()))  return WBEM_E_OUT_OF_MEMORY;

            pFoundRec = pTmp.release();
        }
        catch( CX_MemoryException )
        {
            return WBEM_E_OUT_OF_MEMORY;
        }
    }    // IF not found

    // Add request in provider
    // =======================

    CClientLoadableHiPerfEnum*  pHPEnum = new CClientLoadableHiPerfEnum( m_pControl );

    if ( NULL == pHPEnum ) return WBEM_E_OUT_OF_MEMORY;

    pHPEnum->AddRef();
    CReleaseMe  rmEnum( pHPEnum );

    long lProviderId;

    // If the user specified the WBEM_FLAG_USE_AMENDED_QUALIFIERS flag, then
    // IWbemRefreshingServices::AddEnumToRefresher will return a localized
    // instance definition.  Since localized stuff should all be in the class
    // definition, the provider doesn't really "need" toknow  that we're sneaking
    // this in.

    hres = pHPEnum->SetInstanceTemplate( (CWbemInstance*) Info.m_pTemplate );
    if (FAILED(hres)) return hres;

    hres = pFoundRec->AddEnumRequest( pHPEnum, wszClassName, ppEnum, plId, m_pControl );

    return hres;
}

HRESULT CUniversalRefresher::FindRemoteEntry(const WBEM_REFRESH_INFO_REMOTE& Info,
                                         COAUTHINFO* pAuthInfo,
                                         CRemote** ppRemoteRecord )
{

    // We will identify remote enumerations by server and namespace
    CVar    varNameSpace;

    HRESULT hr = ((CWbemObject*) Info.m_pTemplate)->GetServerAndNamespace( &varNameSpace );
    
    if (FAILED(hr)) return hr;
    if ( NULL == varNameSpace.GetLPWSTR()) return WBEM_E_FAILED;

    // Look for this remote connection in our list
    // ===========================================

    CRemote* pFoundRec = NULL;
    for(int i = 0; i < m_apRemote.GetSize(); i++)
    {
        CRemote* pRec = m_apRemote[i];
        if (pRec)
        {
            if ( wbem_wcsicmp( varNameSpace.GetLPWSTR(), pRec->GetNamespace() ) == 0 )
            {
                pFoundRec = pRec;                
                pFoundRec->AddRef();
                break;
            }
        }
    }

    if(pFoundRec == NULL)
    {
        // Create a new one
        // ================

        // Watch for errors, and do appropriate cleanup
        try
        {
            // Get the server info from the object.  If this returns a NULL, it just
            // means that we will be unable to reconnect

            CVar    varServer;
            hr = ((CWbemObject*) Info.m_pTemplate)->GetServer( &varServer );
            if (FAILED(hr)) return hr;

            CRemote * pTmp = new CRemote(Info.m_pRefresher, 
                                         pAuthInfo, 
                                         &Info.m_guid,
                                         varNameSpace.GetLPWSTR(), 
                                         varServer.GetLPWSTR(), this );
            if (NULL == pTmp) return WBEM_E_OUT_OF_MEMORY;
            OnDeleteObjIf0<CUniversalRefresher::CRemote,
                          ULONG(__stdcall CUniversalRefresher::CRemote:: *)(void),
                          &CUniversalRefresher::CRemote::Release> rmTmp(pTmp);

            // Set the scurity appropriately
            hr = pTmp->ApplySecurity();
            if (FAILED(hr)) return hr;            
            if (-1 == m_apRemote.Add(pTmp)) return WBEM_E_OUT_OF_MEMORY;

            rmTmp.dismiss();
            pFoundRec = pTmp;
        }
        catch(CX_Exception )
        {
            return WBEM_E_OUT_OF_MEMORY;
        }
    }   // IF NULL == pFoundRec

    *ppRemoteRecord = pFoundRec;

    return hr;
}
        
HRESULT 
CUniversalRefresher::AddRemoteObject( IWbemRefreshingServices* pRefServ, 
                                  const WBEM_REFRESH_INFO_REMOTE& Info,
                                  LPCWSTR pwcsRequestName, 
                                  long lCancelId, 
                                  IWbemClassObject** ppRefreshable,
                                  long* plId, 
                                  COAUTHINFO* pAuthInfo )
{
    // Look for this remote connection in our list
    // ===========================================

    CRemote* pFoundRec = NULL;

    HRESULT hr = FindRemoteEntry( Info, pAuthInfo, &pFoundRec );

    if ( SUCCEEDED( hr ) )
    {

        if ( !pFoundRec->IsConnected() )
        {
            hr = pFoundRec->Rebuild( pRefServ, Info.m_pRefresher, &Info.m_guid );
        }

        if ( SUCCEEDED( hr ) )
        {
            // Add a request to it
            // ===================

            IWbemObjectAccess* pAccess = Info.m_pTemplate;
            CWbemObject* pObj = (CWbemObject*)pAccess;

            hr =  pFoundRec->AddObjectRequest(pObj, pwcsRequestName, lCancelId, ppRefreshable, plId);

        }

        // Release the record
        pFoundRec->Release();
    }

    return hr;
}

HRESULT CUniversalRefresher::AddRemoteEnum( IWbemRefreshingServices* pRefServ,
                                        const WBEM_REFRESH_INFO_REMOTE& Info, LPCWSTR pwcsRequestName,
                                        long lCancelId, IWbemContext * pContext,
                                        IWbemHiPerfEnum** ppEnum, long* plId, COAUTHINFO* pAuthInfo )

{
    // Look for this remote connection in our list
    // ===========================================

    CRemote* pFoundRec = NULL;

    HRESULT hr = FindRemoteEntry( Info, pAuthInfo, &pFoundRec );

    if ( SUCCEEDED( hr ) )
    {
        if ( !pFoundRec->IsConnected() )
        {
            hr = pFoundRec->Rebuild( pRefServ, Info.m_pRefresher, &Info.m_guid );
        }

        if ( SUCCEEDED( hr ) )
        {
            // Add a request to it

            IWbemObjectAccess* pAccess = Info.m_pTemplate;
            CWbemObject* pObj = (CWbemObject*)pAccess;

            hr =  pFoundRec->AddEnumRequest(pObj, pwcsRequestName, lCancelId, ppEnum, plId, m_pControl );

        }

        // Release the record
        pFoundRec->Release();
    }

    return hr;
}

HRESULT CUniversalRefresher::AddRefresher( IWbemRefresher* pRefresher, long lFlags, long* plId )
{
    HRESULT hr = WBEM_S_NO_ERROR;

    if ( NULL == pRefresher || 0L != lFlags ) return WBEM_E_INVALID_PARAMETER;

    wmilib::auto_ptr<CNestedRefresher> pNested( new CNestedRefresher( pRefresher ));

    if ( NULL == pNested.get() ) return WBEM_E_OUT_OF_MEMORY;

    if (plId ) *plId = pNested->GetId();

    if (-1 == m_apNestedRefreshers.Add( pNested.get() )) return WBEM_E_OUT_OF_MEMORY;

    pNested.release(); // the array took ownership
    
    return hr;
}

HRESULT CUniversalRefresher::Remove(long lId, long lFlags)
{
    HRESULT hres;

    // Search through them all
    // =======================

    int i;
    for(i = 0; i < m_apRemote.GetSize(); i++)
    {
        hres = m_apRemote[i]->Remove(lId, lFlags, this);
        if(hres == WBEM_S_NO_ERROR)
            return WBEM_S_NO_ERROR;
        else if(FAILED(hres))
            return hres;
    }

    for(i = 0; i < m_apDirect.GetSize(); i++)
    {
        hres = m_apDirect[i]->Remove(lId, this);
        if(hres == WBEM_S_NO_ERROR)
            return WBEM_S_NO_ERROR;
        else if(FAILED(hres))
            return hres;
    }
    
    for(i = 0; i < m_apNonHiPerf.GetSize(); i++)
    {
        hres = m_apNonHiPerf[i]->Remove(lId, this);
        if(hres == WBEM_S_NO_ERROR)
            return WBEM_S_NO_ERROR;
        else if(FAILED(hres))
            return hres;
    }
    
    // Check for a nested refresher
    for ( i = 0; i < m_apNestedRefreshers.GetSize(); i++ )
    {
        if ( m_apNestedRefreshers[i]->GetId() == lId )
        {
            CNestedRefresher*   pNested = m_apNestedRefreshers[i];
            // This will delete the pointer
            m_apNestedRefreshers.RemoveAt( i );
            return WBEM_S_NO_ERROR;
        }
    }

    return WBEM_S_FALSE;
}

HRESULT CUniversalRefresher::Refresh(long lFlags)
{
    HRESULT hres = WBEM_S_NO_ERROR;

    BOOL    fPartialSuccess = FALSE;

    // Search through them all
    // =======================

    // Keep track of how many different refresh calls we actually make.
    int i;
    HRESULT hrFirstRefresh = WBEM_S_NO_ERROR;
    BOOL    fOneSuccess = FALSE;
    BOOL    fOneRefresh = FALSE;

    for(i = 0; i < m_apRemote.GetSize(); i++)
    {
        hres = m_apRemote[i]->Refresh(lFlags);

        // Always keep the first return code.  We also need to track
        // whether or not we had at least one success, as well as if
        // the partial flag should be set.

        if ( !fOneRefresh )
        {
            fOneRefresh = TRUE;
            hrFirstRefresh = hres;
        }

        // All other codes indicate something went awry
        if ( WBEM_S_NO_ERROR == hres )
        {
            fOneSuccess = TRUE;

            // A prior refresh may have failed, a later one didn't
            if ( fOneRefresh && WBEM_S_NO_ERROR != hrFirstRefresh )
            {
                fPartialSuccess = TRUE;
            }
        }
        else if ( fOneSuccess )
        {
            // We must have had at least one success for the partial success
            // flag to be set.

            fPartialSuccess = TRUE;
        }

    }

    for(i = 0; i < m_apDirect.GetSize(); i++)
    {
        hres = m_apDirect[i]->Refresh(lFlags);

        // Always keep the first return code.  We also need to track
        // whether or not we had at least one success, as well as if
        // the partial flag should be set.

        if ( !fOneRefresh )
        {
            fOneRefresh = TRUE;
            hrFirstRefresh = hres;
        }

        // All other codes indicate something went awry
        if ( WBEM_S_NO_ERROR == hres )
        {
            fOneSuccess = TRUE;

            // A prior refresh may have failed, a later one didn't
            if ( fOneRefresh && WBEM_S_NO_ERROR != hrFirstRefresh )
            {
                fPartialSuccess = TRUE;
            }
        }
        else if ( fOneSuccess )
        {
            // We must have had at least one success for the partial success
            // flag to be set.

            fPartialSuccess = TRUE;
        }
    }

    // Refresh Non-HiPerf Requests
    for(i = 0; i < m_apNonHiPerf.GetSize(); i++)
    {
        hres = m_apNonHiPerf[i]->Refresh(lFlags);

        // Always keep the first return code.  We also need to track
        // whether or not we had at least one success, as well as if
        // the partial flag should be set.

        if ( !fOneRefresh )
        {
            fOneRefresh = TRUE;
            hrFirstRefresh = hres;
        }

        // All other codes indicate something went awry
        if ( WBEM_S_NO_ERROR == hres )
        {
            fOneSuccess = TRUE;

            // A prior refresh may have failed, a later one didn't
            if ( fOneRefresh && WBEM_S_NO_ERROR != hrFirstRefresh )
            {
                fPartialSuccess = TRUE;
            }
        }
        else if ( fOneSuccess )
        {
            // We must have had at least one success for the partial success
            // flag to be set.

            fPartialSuccess = TRUE;
        }

    }

    // Refresh nested refreshers too
    for ( i = 0; i < m_apNestedRefreshers.GetSize(); i++ )
    {
        hres = m_apNestedRefreshers[i]->Refresh( lFlags );

        // Always keep the first return code.  We also need to track
        // whether or not we had at least one success, as well as if
        // the partial flag should be set.

        if ( !fOneRefresh )
        {
            fOneRefresh = TRUE;
            hrFirstRefresh = hres;
        }

        // All other codes indicate something went awry
        if ( WBEM_S_NO_ERROR == hres )
        {
            fOneSuccess = TRUE;

            // A prior refresh may have failed, a later one didn't
            if ( fOneRefresh && WBEM_S_NO_ERROR != hrFirstRefresh )
            {
                fPartialSuccess = TRUE;
            }
        }
        else if ( fOneSuccess )
        {
            // We must have had at least one success for the partial success
            // flag to be set.

            fPartialSuccess = TRUE;
        }
    }

    // At this point, if the partial success flag is set, that will
    // be our return.  If we didn't have at least one success,  then
    // the return code will be the first one we got back. Otherwise,
    // hres should contain the proper value

    if ( fPartialSuccess )
    {
        hres = WBEM_S_PARTIAL_RESULTS;
    }
    else if ( !fOneSuccess )
    {
        hres = hrFirstRefresh;
    }

    return hres;
}

//
// static function called when fastprox is unloaded
//
//////////////////////////////////////////////
void CUniversalRefresher::Flush()
{
    GetProviderCache()->Flush();
}



//*****************************************************************************
//*****************************************************************************
//                            CLIENT REQUEST
//*****************************************************************************
//*****************************************************************************


CUniversalRefresher::CClientRequest::CClientRequest(CWbemObject* pTemplate)
    : m_pClientObject(NULL), m_lClientId(0)
{
    if(pTemplate)
    {
        pTemplate->AddRef();
        m_pClientObject = (CWbemObject*)pTemplate;
    }

    m_lClientId = CUniversalRefresher::GetNewId();
}

CUniversalRefresher::CClientRequest::~CClientRequest()
{
    if(m_pClientObject)
        m_pClientObject->Release();
}

void CUniversalRefresher::CClientRequest::GetClientInfo(
                       RELEASE_ME IWbemClassObject** ppRefreshable, long* plId)
{
    *ppRefreshable = m_pClientObject;
    if(m_pClientObject)
        m_pClientObject->AddRef();

    if ( NULL != plId )
    {
        *plId = m_lClientId;
    }
}

//*****************************************************************************
//*****************************************************************************
//                            DIRECT PROVIDER
//*****************************************************************************
//*****************************************************************************


CUniversalRefresher::CDirect::CDirect(CHiPerfProviderRecord* pProvider,
                                        IWbemRefresher* pRefresher)
    : m_pRefresher(pRefresher), m_pProvider(pProvider)
{
    if(m_pRefresher)
        m_pRefresher->AddRef();
    if(m_pProvider)
        m_pProvider->AddRef();
}

CUniversalRefresher::CDirect::~CDirect()
{
    if(m_pRefresher)
        m_pRefresher->Release();
    if(m_pProvider)
        m_pProvider->Release();
}

HRESULT CUniversalRefresher::CDirect::AddObjectRequest(CWbemObject* pRefreshedObject, CWbemObject* pClientInstance,
                         long lCancelId, IWbemClassObject** ppRefreshable, long* plId)
{
    CObjectRequest* pRequest = NULL;

    try
    {
        wmilib::auto_ptr<CObjectRequest> pRequest( new CObjectRequest(pRefreshedObject, pClientInstance, lCancelId));
        if (NULL == pRequest.get()) return WBEM_E_OUT_OF_MEMORY;
        if (-1 == m_apRequests.Add(pRequest.get())) return WBEM_E_OUT_OF_MEMORY;        
        pRequest->GetClientInfo(ppRefreshable, plId);
        pRequest.release();
    }
    catch(CX_Exception &)
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    return WBEM_S_NO_ERROR;
}

//
// pHEnum is guarantee not NULL in CUniversalRefresher::AddInProcEnum
//
////////////////////////////////////////////////////////////////
HRESULT 
CUniversalRefresher::CDirect::AddEnumRequest(CClientLoadableHiPerfEnum* pHPEnum,
                                         long lCancelId, 
                                         IWbemHiPerfEnum** ppEnum, 
                                         long* plId, 
                                         CLifeControl* pLifeControl )
{
    HRESULT hr = WBEM_S_NO_ERROR;

    try
    {
        // We get away with this through inheritance and polymorphism
        wmilib::auto_ptr<CEnumRequest> pEnumRequest( new CEnumRequest(pHPEnum, lCancelId, pLifeControl));
        if (NULL == pEnumRequest.get()) return WBEM_E_OUT_OF_MEMORY;
        if (-1 == m_apRequests.Add((CObjectRequest*) pEnumRequest.get())) return WBEM_E_OUT_OF_MEMORY;
        
        hr = pEnumRequest->GetClientInfo(ppEnum, plId);
        pEnumRequest.release(); // the array took ownership
    }
    catch(CX_Exception &)
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    return hr;
}
    
HRESULT CUniversalRefresher::CDirect::Refresh(long lFlags)
{
    HRESULT hres;
    if(m_pRefresher)
    {
        try
        {
            hres = m_pRefresher->Refresh(0L);
        }
        catch(...)
        {
            // Provider threw an exception, so get out of here ASAP
            hres = WBEM_E_PROVIDER_FAILURE;
        }

        if(FAILED(hres)) return hres;
    }

    int nSize = m_apRequests.GetSize();
    for(int i = 0; i < nSize; i++)
    {
        m_apRequests[i]->Copy();
    }

    return WBEM_S_NO_ERROR;
}

HRESULT CUniversalRefresher::CDirect::Remove(long lId, CUniversalRefresher* pContainer)
{
    int nSize = m_apRequests.GetSize();
    for(int i = 0; i < nSize; i++)
    {
        CObjectRequest* pRequest = m_apRequests[i];
        if(pRequest->GetClientId() == lId)
        {
            pRequest->Cancel(this);
            m_apRequests.RemoveAt(i);
            return WBEM_S_NO_ERROR;
        }
    }

    return WBEM_S_FALSE;
}
    

CUniversalRefresher::CDirect::CObjectRequest::CObjectRequest( CWbemObject* pProviderObject,
                                                CWbemObject* pClientInstance,
                                                long lProviderId )
    : CClientRequest(pClientInstance), m_pProviderObject(pProviderObject),
        m_lProviderId(lProviderId)
{
    if(m_pProviderObject)
        m_pProviderObject->AddRef();
}

HRESULT CUniversalRefresher::CDirect::CObjectRequest::Cancel(
        CUniversalRefresher::CDirect* pDirect)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    if(pDirect->GetProvider())
    {
        try
        {
            hr = pDirect->GetProvider()->m_pProvider->StopRefreshing(pDirect->GetRefresher(),
                m_lProviderId, 0);
        }
        catch(...)
        {
            // Provider threw an exception, so get out of here ASAP
            return WBEM_E_PROVIDER_FAILURE;
        }

    }

    return hr;
}
    
CUniversalRefresher::CDirect::CObjectRequest::~CObjectRequest()
{
    if(m_pProviderObject)
        m_pProviderObject->Release();
}
    

void CUniversalRefresher::CDirect::CObjectRequest::Copy()
{
    m_pClientObject->CopyBlobOf(m_pProviderObject);
}
    

CUniversalRefresher::CDirect::CEnumRequest::CEnumRequest(CClientLoadableHiPerfEnum* pHPEnum, 
                                                long lProviderId, CLifeControl* pLifeControl )
    : CObjectRequest( NULL, NULL, lProviderId ), m_pHPEnum(pHPEnum),m_pClientEnum(NULL)
{
     m_pHPEnum->AddRef();

    CWbemInstance* pInst = pHPEnum->GetInstanceTemplate();
    if (NULL == pInst) return;
    CReleaseMe rmInst((IWbemClassObject *)pInst);

    // We'll need an enumerator for the client to retrieve objects
    wmilib::auto_ptr<CReadOnlyHiPerfEnum> pTmp(new CReadOnlyHiPerfEnum( pLifeControl ));
    if (NULL == pTmp.get()) return;

    if (FAILED(pTmp->SetInstanceTemplate( pInst ))) return;

    m_pClientEnum = pTmp.release();
    m_pClientEnum->AddRef();
}

CUniversalRefresher::CDirect::CEnumRequest::~CEnumRequest()
{
    m_pHPEnum->Release();
    if (m_pClientEnum ) m_pClientEnum->Release();
}
    

void CUniversalRefresher::CDirect::CEnumRequest::Copy()
{
    // Tell the refresher enumerator to copy its objects from
    // the HiPerf Enumerator
    if ( NULL != m_pClientEnum )
    {
        m_pClientEnum->Copy( m_pHPEnum );
    }

}
    
HRESULT 
CUniversalRefresher::CDirect::CEnumRequest::GetClientInfo( RELEASE_ME IWbemHiPerfEnum** ppEnum, 
                                                    long* plId)
{
    // We best have enumerators to hook up here
    if ( NULL != m_pClientEnum )
    {
        // Store the client id, then do a QI

        if ( NULL != plId ) *plId = m_lClientId;

        return m_pClientEnum->QueryInterface( IID_IWbemHiPerfEnum, (void**) ppEnum );
    }
    else
    {
        return WBEM_E_FAILED;
    }
}

//*****************************************************************************
//*****************************************************************************
//                          NON HI PERF
//*****************************************************************************
//*****************************************************************************

CUniversalRefresher::CNonHiPerf::CNonHiPerf( LPCWSTR pwszNamespace, IWbemServices* pSvcEx )
    : m_wsNamespace(pwszNamespace), m_pSvcEx(pSvcEx)
{
    if(m_pSvcEx)
        m_pSvcEx->AddRef();
}

CUniversalRefresher::CNonHiPerf::~CNonHiPerf()
{
    if(m_pSvcEx)
        m_pSvcEx->Release();
}

HRESULT 
CUniversalRefresher::CNonHiPerf::AddObjectRequest(CWbemObject* pRefreshedObject, 
                                             CWbemObject* pClientInstance,
                                             LPCWSTR pwszPath, 
                                             IWbemClassObject** ppRefreshable, 
                                             long* plId)
{


    try
    {
        wmilib::auto_ptr<CObjectRequest> pRequest(new CObjectRequest(pRefreshedObject, pClientInstance, pwszPath));
        if (NULL == pRequest.get()) return WBEM_E_OUT_OF_MEMORY;
        if (-1 == m_apRequests.Add(pRequest.get())) return WBEM_E_OUT_OF_MEMORY;
        pRequest->GetClientInfo(ppRefreshable, plId);
        pRequest.release(); // array took ownership
    }
    catch(CX_Exception &)
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    return WBEM_S_NO_ERROR;
}

HRESULT CUniversalRefresher::CNonHiPerf::AddEnumRequest(CClientLoadableHiPerfEnum* pHPEnum, LPCWSTR pwszClassName, 
                                                        IWbemHiPerfEnum** ppEnum, long* plId, CLifeControl* pLifeControl )
{
    HRESULT hr = WBEM_S_NO_ERROR;



    try
    {
        // We get away with this through inheritance and polymorphism
        wmilib::auto_ptr<CEnumRequest> pEnumRequest(new CEnumRequest(pHPEnum, pwszClassName, pLifeControl));
        if (NULL == pEnumRequest.get()) return WBEM_E_OUT_OF_MEMORY;
        if (-1 == m_apRequests.Add((CObjectRequest*) pEnumRequest.get())) return WBEM_E_OUT_OF_MEMORY;
        hr = pEnumRequest->GetClientInfo(ppEnum, plId);
        pEnumRequest.release();
    }
    catch(CX_Exception &)
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    return hr;
}
    
HRESULT CUniversalRefresher::CNonHiPerf::Refresh(long lFlags)
{
    HRESULT hres = WBEM_S_NO_ERROR;

    // Tell each request to refresh itself (we have to do this manually)
    if ( NULL != m_pSvcEx )
    {
        int nSize = m_apRequests.GetSize();
        for(int i = 0; i < nSize; i++)
        {
            hres = m_apRequests[i]->Refresh( this );
        }
    }

    return hres;

}


HRESULT CUniversalRefresher::CNonHiPerf::Remove(long lId, CUniversalRefresher* pContainer)
{
    int nSize = m_apRequests.GetSize();
    
    for(int i = 0; i < nSize; i++)
    {
        CObjectRequest* pRequest = m_apRequests[i];
        if(pRequest->GetClientId() == lId)
        {
            pRequest->Cancel(this);
            m_apRequests.RemoveAt(i);
            return WBEM_S_NO_ERROR;
        }
    }

    return WBEM_S_FALSE;

}

// Requests
CUniversalRefresher::CNonHiPerf::CObjectRequest::CObjectRequest( CWbemObject* pProviderObject, 
                                               CWbemObject* pClientInstance, 
                                               LPCWSTR pwszPath )
    : CClientRequest(pClientInstance), m_pProviderObject( pProviderObject ), m_strPath( NULL )
{
    if ( NULL != pwszPath )
    {
        m_strPath = SysAllocString( pwszPath );
        if ( NULL == m_strPath ) throw CX_MemoryException();
    }
    if ( m_pProviderObject )  m_pProviderObject->AddRef();
}

HRESULT CUniversalRefresher::CNonHiPerf::CObjectRequest::Cancel(
        CUniversalRefresher::CNonHiPerf* pNonHiPerf)
{
    return WBEM_S_NO_ERROR;
}

HRESULT CUniversalRefresher::CNonHiPerf::CObjectRequest::Refresh(
            CUniversalRefresher::CNonHiPerf* pNonHiPerf)
{
    IWbemClassObject*    pObj = NULL;

    // Get the object and update the BLOB
    HRESULT    hr = pNonHiPerf->GetServices()->GetObject( m_strPath, 0L, NULL, &pObj, NULL );
    CReleaseMe    rmObj( pObj );

    if ( SUCCEEDED( hr ) )
    {
        _IWmiObject*    pWmiObject = NULL;

        hr = pObj->QueryInterface( IID__IWmiObject, (void**) &pWmiObject );
        CReleaseMe    rmWmiObj( pWmiObject );

        if ( SUCCEEDED( hr ) )
        {
            hr = m_pClientObject->CopyInstanceData( 0L, pWmiObject );
        }
    }

    return hr;
}

CUniversalRefresher::CNonHiPerf::CObjectRequest::~CObjectRequest()
{
    if ( NULL != m_pProviderObject )
    {
        m_pProviderObject->Release();
    }

    SysFreeString( m_strPath );
}
    

void CUniversalRefresher::CNonHiPerf::CObjectRequest::Copy()
{
    m_pClientObject->CopyBlobOf(m_pProviderObject);
}
    

CUniversalRefresher::CNonHiPerf::CEnumRequest::CEnumRequest( CClientLoadableHiPerfEnum* pHPEnum, 
                                                LPCWSTR pwszClassName, CLifeControl* pLifeControl )
    : CObjectRequest( NULL, NULL, pwszClassName ), m_pHPEnum(pHPEnum), m_pClientEnum(NULL)
{
    if( m_pHPEnum )
        m_pHPEnum->AddRef();

    CWbemInstance* pInst = pHPEnum->GetInstanceTemplate();
    if (NULL == pInst) return;

    // We'll need an enumerator for the client to retrieve objects
    wmilib::auto_ptr<CReadOnlyHiPerfEnum> pTmp(new CReadOnlyHiPerfEnum( pLifeControl ));
    if (NULL == pTmp.get()) return;
    if (FAILED(pTmp->SetInstanceTemplate( pInst ) )) return;
    m_pClientEnum = pTmp.release();
    m_pClientEnum->AddRef();    
}

CUniversalRefresher::CNonHiPerf::CEnumRequest::~CEnumRequest()
{
    if(m_pHPEnum)
        m_pHPEnum->Release();

    if ( NULL != m_pClientEnum )
    {
        m_pClientEnum->Release();
    }

}
    

HRESULT CUniversalRefresher::CNonHiPerf::CEnumRequest::Refresh(
            CUniversalRefresher::CNonHiPerf* pNonHiPerf)
{
    IEnumWbemClassObject*    pEnum = NULL;

    // Do a semi-sync enumeration. 
    HRESULT hr = pNonHiPerf->GetServices()->CreateInstanceEnum( m_strPath,
                                                                WBEM_FLAG_FORWARD_ONLY | WBEM_FLAG_RETURN_IMMEDIATELY,
                                                                NULL,
                                                                &pEnum );
    if (FAILED(hr)) return hr;
    CReleaseMe    rmEnum( pEnum );    

   COAUTHINFO CoAuthInfo;
   memset(&CoAuthInfo,0,sizeof(CoAuthInfo));

    hr = CoQueryProxyBlanket( pNonHiPerf->GetServices(), 
                             &CoAuthInfo.dwAuthnSvc, 
                             &CoAuthInfo.dwAuthzSvc,
                             &CoAuthInfo.pwszServerPrincName, 
                             &CoAuthInfo.dwAuthnLevel,
                             &CoAuthInfo.dwImpersonationLevel, 
                             (RPC_AUTH_IDENTITY_HANDLE*) &CoAuthInfo.pAuthIdentityData,
                             &CoAuthInfo.dwCapabilities );
    
    if (E_NOINTERFACE == hr) hr = S_OK; // the non-proxy case
    if (FAILED( hr ) ) return hr;

    hr = WbemSetProxyBlanket(pEnum, 
                              CoAuthInfo.dwAuthnSvc, 
                              CoAuthInfo.dwAuthzSvc,
                              COLE_DEFAULT_PRINCIPAL, 
                              CoAuthInfo.dwAuthnLevel,
                              CoAuthInfo.dwImpersonationLevel, 
                              CoAuthInfo.pAuthIdentityData,
                              CoAuthInfo.dwCapabilities );

    if (E_NOINTERFACE == hr) hr = S_OK; // the non-proxy case
    if (FAILED( hr ) ) return hr;
    
    IWbemClassObject*    apObj[100];
    long                alIds[100];
    long                lId = 0;
    BOOL                fFirst = TRUE;

    while ( WBEM_S_NO_ERROR == hr )
    {
        ULONG    uReturned = 0;

        hr = pEnum->Next( 1000, 100, apObj, &uReturned );

        if ( SUCCEEDED( hr ) && uReturned > 0 )
        {
            IWbemObjectAccess*    apObjAccess[100];

            // Need to conjure up some ids quick
            for ( int x = 0; SUCCEEDED( hr ) && x < uReturned; x++ )
            {
                alIds[x] = lId++;
                hr = apObj[x]->QueryInterface( IID_IWbemObjectAccess, (void**) &apObjAccess[x] );
            }

            if ( SUCCEEDED( hr ) )
            {
                // Replace the contents of the enum
                hr = m_pClientEnum->Replace( fFirst, uReturned, alIds, apObjAccess );

                for ( ULONG uCtr = 0; uCtr < uReturned; uCtr++ )
                {
                    apObj[uCtr]->Release();
                    apObjAccess[uCtr]->Release();
                }

            }

            // Don't need to remove all if this is the first
            fFirst = FALSE;

        }    // IF SUCCEEDED and num returned objects > 0
        else if ( WBEM_S_TIMEDOUT == hr )
        {
            hr = WBEM_S_NO_ERROR;
        }

    }    // WHILE getting objects

    return SUCCEEDED(hr)?WBEM_S_NO_ERROR:hr;
}

void CUniversalRefresher::CNonHiPerf::CEnumRequest::Copy()
{
    // Tell the refresher enumerator to copy its objects from
    // the HiPerf Enumerator
    if ( NULL != m_pClientEnum )
    {
        m_pClientEnum->Copy( m_pHPEnum );
    }

}
    
HRESULT CUniversalRefresher::CNonHiPerf::CEnumRequest::GetClientInfo(  RELEASE_ME IWbemHiPerfEnum** ppEnum, 
                                                                long* plId)
{
    // We best have enumerators to hook up here
    if ( NULL != m_pClientEnum )
    {
        // Store the client id, then do a QI
        if ( NULL != plId ) *plId = m_lClientId;
        
        return m_pClientEnum->QueryInterface( IID_IWbemHiPerfEnum, (void**) ppEnum );
    }
    else
    {
        return WBEM_E_FAILED;
    }
}

//*****************************************************************************
//*****************************************************************************
//                          REMOTE PROVIDER
//*****************************************************************************
//*****************************************************************************

                    

CUniversalRefresher::CRemote::CRemote(IWbemRemoteRefresher* pRemRefresher, 
                                    COAUTHINFO* pCoAuthInfo, 
                                    const GUID* pGuid,
                                    LPCWSTR pwszNamespace, 
                                    LPCWSTR pwszServer, 
                                    CUniversalRefresher* pObject ): 
    m_pRemRefresher(pRemRefresher), 
    m_bstrNamespace( NULL ), 
    m_fConnected( TRUE ), 
    m_pObject( pObject ),
    m_bstrServer( NULL ), 
    m_lRefCount( 1 ), 
    m_pReconnectedRemote( NULL ), 
    m_pReconnectSrv( NULL ), 
    m_fQuit( FALSE )
{
    // Initialize the GUID data members
    ZeroMemory( &m_ReconnectGuid, sizeof(GUID));
    m_RemoteGuid = *pGuid;

    m_CoAuthInfo = *pCoAuthInfo;

    WCHAR * pStr = NULL;
    DWORD dwLen = pCoAuthInfo->pwszServerPrincName?wcslen(pCoAuthInfo->pwszServerPrincName):0;
    if (dwLen)
    {
        pStr = (WCHAR *)CoTaskMemAlloc(sizeof(WCHAR)*(1+dwLen));
        if (NULL == pStr) throw CX_MemoryException();
        StringCchCopyW(pStr,dwLen+1,pCoAuthInfo->pwszServerPrincName);
    }
    OnDeleteIf<VOID *,VOID(*)(VOID *),CoTaskMemFree> fmStr(pStr);

    // Store reconnection data
    BSTR bstrTmpName = NULL;
    if ( pwszNamespace )
    {
        bstrTmpName = SysAllocString( pwszNamespace );
        if (NULL == bstrTmpName) throw CX_MemoryException();
    }
    OnDeleteIf<BSTR,VOID(*)(BSTR),SysFreeString> fmStrName(bstrTmpName);

    BSTR bstrTmpServer = NULL;
    if ( pwszServer )
    {
        bstrTmpServer = SysAllocString( pwszServer );
        if (NULL == bstrTmpServer) throw CX_MemoryException();        
    }
    OnDeleteIf<BSTR,VOID(*)(BSTR),SysFreeString> fmStrServer(bstrTmpServer);    

    fmStr.dismiss();
    m_CoAuthInfo.pwszServerPrincName = pStr;

    fmStrName.dismiss();
    m_bstrNamespace = bstrTmpName;

    fmStrServer.dismiss();
    m_bstrServer = bstrTmpServer;

    if(m_pRemRefresher)
        m_pRemRefresher->AddRef();

}
    
CUniversalRefresher::CRemote::~CRemote()
{
    ClearRemoteConnections();

    CoTaskMemFree(m_CoAuthInfo.pwszServerPrincName);
    SysFreeString( m_bstrNamespace );
    SysFreeString( m_bstrServer );
}

ULONG STDMETHODCALLTYPE CUniversalRefresher::CRemote::AddRef()
{
    return InterlockedIncrement(&m_lRefCount);
}

ULONG STDMETHODCALLTYPE CUniversalRefresher::CRemote::Release()
{
    long lRef = InterlockedDecrement(&m_lRefCount);
    if(lRef == 0)
        delete this;
    return lRef;
}

// Applies appropriate security settings to the proxy
HRESULT CUniversalRefresher::CRemote::ApplySecurity( void )
{
    return WbemSetProxyBlanket( m_pRemRefresher, 
                              m_CoAuthInfo.dwAuthnSvc, 
                              m_CoAuthInfo.dwAuthzSvc,
                              COLE_DEFAULT_PRINCIPAL, 
                              m_CoAuthInfo.dwAuthnLevel, 
                              m_CoAuthInfo.dwImpersonationLevel,
                              (RPC_AUTH_IDENTITY_HANDLE) m_CoAuthInfo.pAuthIdentityData, 
                              m_CoAuthInfo.dwCapabilities );
}

BOOL DuplicateTokenSameAcl(HANDLE hSrcToken,
	                       HANDLE * pDupToken)
{
    SECURITY_IMPERSONATION_LEVEL secImpLevel;

    TOKEN_TYPE TokenType_;
    DWORD dwNeeded = sizeof(TokenType_);
    if (!GetTokenInformation(hSrcToken,TokenType,&TokenType_,sizeof(TokenType_),&dwNeeded)) return FALSE;

    if (TokenPrimary == TokenType_)
    {
        secImpLevel = SecurityImpersonation;
    } 
    else //TokenImpersonation == TokenType_
    {    	
        dwNeeded = sizeof(secImpLevel);
        if (!GetTokenInformation(hSrcToken,TokenImpersonationLevel,&secImpLevel,sizeof(secImpLevel),&dwNeeded)) return FALSE;
    }
    
	DWORD dwSize = 0;
	BOOL bRet = GetKernelObjectSecurity(hSrcToken,
		                    DACL_SECURITY_INFORMATION, // |GROUP_SECURITY_INFORMATION|OWNER_SECURITY_INFORMATION
		                    NULL,
							0,
							&dwSize);

	if(!bRet && (ERROR_INSUFFICIENT_BUFFER == GetLastError()))
	{

		void * pSecDescr = LocalAlloc(LPTR,dwSize);
		if (NULL == pSecDescr)
			return FALSE;
		OnDelete<void *,HLOCAL(*)(HLOCAL),LocalFree> rm(pSecDescr);

		bRet = GetKernelObjectSecurity(hSrcToken,
		                    DACL_SECURITY_INFORMATION, // |GROUP_SECURITY_INFORMATION|OWNER_SECURITY_INFORMATION
		                    pSecDescr,
							dwSize,
							&dwSize);
		if (FALSE == bRet)
			return bRet;

		SECURITY_ATTRIBUTES sa;
		sa.nLength = sizeof(SECURITY_ATTRIBUTES);
		sa.lpSecurityDescriptor = pSecDescr; 
		sa.bInheritHandle = FALSE; 

		return DuplicateTokenEx(hSrcToken, 
			                    TOKEN_QUERY|TOKEN_ADJUST_PRIVILEGES|TOKEN_IMPERSONATE, 
			                    &sa,
				        	    secImpLevel, TokenImpersonation,pDupToken);
		
	}
	return bRet;
}

void CUniversalRefresher::CRemote::CheckConnectionError( HRESULT hr, BOOL fStartReconnect )
{
    if ( IsConnectionError( hr ) && fStartReconnect )
    {    
        HANDLE hToken = NULL;
        // this may fail, and that is taken care below
		if (!OpenThreadToken (GetCurrentThread(), 
			             TOKEN_QUERY|TOKEN_DUPLICATE|TOKEN_IMPERSONATE|TOKEN_READ, 
			             true, &hToken))
		{
    		OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY|TOKEN_DUPLICATE|TOKEN_IMPERSONATE|TOKEN_READ, &hToken);
		}
		OnDeleteIf<HANDLE,BOOL(*)(HANDLE),CloseHandle> cmToken(hToken);
		cmToken.dismiss(NULL == hToken);
		
		HANDLE hDupToken = NULL;
		if (hToken)
		{            
			if (!DuplicateTokenSameAcl(hToken,&hDupToken))
			{
    		    DEBUGTRACE((LOG_WINMGMT,"CUniversalRefresher::CRemote::CheckConnectionError DuplicateToken err %d\n",GetLastError()));
			}

		}
		
		// take ownership
		OnDeleteIf<HANDLE,BOOL(*)(HANDLE),CloseHandle> cmTokenDup(hDupToken);
		cmTokenDup.dismiss(NULL == hDupToken);		

        // We should change the m_fConnected data member to indicate that we are no
        // longer connected, and we need to spin off a thread to try and put us back
        // together again.  To keep things running smoothly, we should AddRef() ourselves
        // so the thread will release us when it is done.

        m_fConnected = FALSE;

        // AddRefs us so we can be passed off to the thread
        AddRef();
        OnDeleteObjIf0<CUniversalRefresher::CRemote,ULONG(__stdcall CUniversalRefresher::CRemote:: *)(),&CUniversalRefresher::CRemote::Release> rm(this);

        DWORD   dwThreadId = NULL;
        HANDLE  hThread = (HANDLE)_beginthreadex( NULL,0, 
        	                                      CRemote::ThreadProc,
        	                                      (void*) this,
                                                  CREATE_SUSPENDED,
                                                  (unsigned int *)&dwThreadId);
        
        if ( NULL == hThread ) return;
        OnDelete<HANDLE,BOOL(*)(HANDLE),CloseHandle> ch(hThread);

        if (hDupToken)
        {
            if (!SetThreadToken(&hThread,hDupToken))
            {
                DEBUGTRACE((LOG_WINMGMT,"SetThreadToken for ReconnectEntry err %d\n",GetLastError()));
            }
        }
        
        if ((DWORD)-1 == ResumeThread(hThread)) return;        
        rm.dismiss();
    }   // If connection error and start reconnect thread

}

HRESULT 
CUniversalRefresher::CRemote::AddObjectRequest(CWbemObject* pTemplate, 
                                           LPCWSTR pwcsRequestName, 
                                           long lCancelId, 
                                           IWbemClassObject** ppRefreshable, long* plId)
{
    HRESULT hr = WBEM_S_NO_ERROR;

    try
    {
        wmilib::auto_ptr<CObjectRequest> pRequest( new CObjectRequest(pTemplate, lCancelId, pwcsRequestName));
        if (NULL == pRequest.get()) return WBEM_E_OUT_OF_MEMORY;
        if (-1 == m_apRequests.Add(pRequest.get())) return WBEM_E_OUT_OF_MEMORY;
        pRequest->GetClientInfo(ppRefreshable, plId);
        pRequest.release();
    }
    catch( CX_Exception & )
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    return hr;
}

HRESULT CUniversalRefresher::CRemote::AddEnumRequest(
                    CWbemObject* pTemplate, LPCWSTR pwcsRequestName, long lCancelId, 
                    IWbemHiPerfEnum** ppEnum, long* plId, CLifeControl* pLifeControl )
{
    HRESULT hr = WBEM_S_NO_ERROR;

    try
    {
        // Make sure the request allocates an enumerator internally

        wmilib::auto_ptr<CEnumRequest> pTmp( new CEnumRequest( pTemplate, lCancelId, pwcsRequestName, pLifeControl ));
        
        if (NULL == pTmp.get()) return WBEM_E_OUT_OF_MEMORY;
        if ( !pTmp->IsOk() ) return WBEM_E_FAILED;
        if (-1 == m_apRequests.Add((CObjectRequest*) pTmp.get())) return WBEM_E_OUT_OF_MEMORY;        

        CEnumRequest * pRequest = pTmp.release();
        //  All we need for the client is the id, so
        //  dummy up a holder for the refreshable object
        //  ( which is really the template for the objects
        //  we will be returning from the enumerator.

        IWbemClassObject*   pObjTemp = NULL;        
        pRequest->GetClientInfo( &pObjTemp, plId );

        if ( NULL != pObjTemp )
        {
            pObjTemp->Release();
        }

        // Get the enumerator
        hr = pRequest->GetEnum( ppEnum );

    }
    catch( CX_Exception )
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    return hr;

}

//
// this function will release the stream anyway
//
//////////////////////////////////////////////////////////
HRESULT CleanupStreamWithInterface(IStream * pStream)
{
    HRESULT hr;
    IUnknown * pTemp = NULL;
    if (SUCCEEDED(hr = CoGetInterfaceAndReleaseStream( pStream, IID_IUnknown,(void**) &pTemp )))
    {
        pTemp->Release();
    }
    else // let's realease the stream ourlsef
    {
        pStream->Release();
    }
    return hr;
}

// Rebuilds a remote refresher
HRESULT CUniversalRefresher::CRemote::Rebuild( IWbemServices* pNamespace )
{
    HRESULT hr = WBEM_S_NO_ERROR;

    // Storage for security settings we will need in order to propagate
    // down to our internal interfaces.

    COAUTHINFO                  CoAuthInfo;
    memset(&CoAuthInfo,0,sizeof(CoAuthInfo));

    // Acquire internal connection to WINMGMT
    // ====================================

    IWbemRefreshingServices* pRefServ = NULL;

    hr = CUniversalRefresher::GetRefreshingServices( pNamespace, &pRefServ, &CoAuthInfo );
    CReleaseMe  rmrs(pRefServ);
    if (FAILED( hr )) return hr;

    // This guarantees this will be freed when we drop out of scope.  If we store
    // it we will need to allocate an internal copy.

    CMemFreeMe  mfm( CoAuthInfo.pwszServerPrincName );

    IWbemRemoteRefresher*   pRemRefresher = NULL;

    // Make sure a remote refresher exists for "this" refresher
    GUID    remoteGuid;
    DWORD   dwRemoteRefrVersion = 0;

    hr = pRefServ->GetRemoteRefresher( m_pObject->GetId(), 0L, 
                                    WBEM_REFRESHER_VERSION, 
                                    &pRemRefresher, 
                                    &remoteGuid, 
                                    &dwRemoteRefrVersion );
    CReleaseMe  rm(pRemRefresher);
    if (FAILED( hr )) return hr;    

    // Will enter and exit the critical section with scoping
    CInCritSec  ics( &m_cs );

    // Check that we're still not connected
    if ( m_fConnected ) return WBEM_S_NO_ERROR;

    // Because the original object mayhave been instantiated in an STA, we will let the Refresh
    // call do the dirty work of actually hooking up this bad boy.  In order for this
    // to work, however, 

    IStream * pStreamRefr = NULL;
    hr = CoMarshalInterThreadInterfaceInStream( IID_IWbemRemoteRefresher, pRemRefresher, &pStreamRefr);
    if (FAILED( hr )) return hr;
    OnDeleteIf<IStream *,HRESULT(*)(IStream *),CleanupStreamWithInterface> rmStream1(pStreamRefr);

    IStream * pStreamSvc = NULL;
    hr = CoMarshalInterThreadInterfaceInStream( IID_IWbemRefreshingServices, pRefServ, &pStreamSvc );
    if (FAILED( hr )) return hr;    
    OnDeleteIf<IStream *,HRESULT(*)(IStream *),CleanupStreamWithInterface> rmStream2(pStreamSvc);    

    // Store the GUID so the refresh will be able to determine the identity
    // of the remote refresher.

    m_ReconnectGuid = remoteGuid;

    rmStream1.dismiss();
    m_pReconnectedRemote = pStreamRefr;

    rmStream2.dismiss();
    m_pReconnectSrv = pStreamSvc;

    return hr;
}

HRESULT 
CUniversalRefresher::CRemote::Rebuild( IWbemRefreshingServices* pRefServ,
                                   IWbemRemoteRefresher* pRemRefresher,
                                   const GUID* pReconnectGuid )
{
    HRESULT hr = WBEM_S_NO_ERROR;

    // Will enter and exit the critical section with scoping
    CInCritSec  ics( &m_cs );

    // Right off, check if we ARE connected, in which case we can assume we had
    // a race condition on this function, and the winner got us all hooked back
    // up again.

    if ( m_fConnected )
    {
        return hr;
    }

    // If these two are equal, we can assume that we reconnected without losing our previous connection.
    // If they are not equal, we will then need to rebuild the remote refresher, however, by calling
    // GetRemoteRefresher() successfully we will have effectively ensured that a remote refresher exists
    // for us up on the server.

    if ( *pReconnectGuid != m_RemoteGuid )
    {
        // We will need these memory buffers to hold individual request data
        wmilib::auto_buffer<WBEM_RECONNECT_INFO>    apReconnectInfo;
        wmilib::auto_buffer<WBEM_RECONNECT_RESULTS> apReconnectResults;
        
        // Only alloc and fill out arrays if we have requests
        if ( m_apRequests.GetSize() > 0 )
        {
            
            apReconnectInfo.reset( new WBEM_RECONNECT_INFO[m_apRequests.GetSize()] );
            apReconnectResults.reset( new WBEM_RECONNECT_RESULTS[m_apRequests.GetSize()] );

            if (NULL == apReconnectInfo.get() || NULL == apReconnectResults.get())
                return WBEM_E_OUT_OF_MEMORY;

            // Enumerate the requests and fill out the arrays
            for ( int i = 0; i < m_apRequests.GetSize(); i++ )
            {
                CObjectRequest*   pRequest = m_apRequests.GetAt( i );

                // Setup each info structure
                apReconnectInfo[i].m_lType = ( pRequest->IsEnum() ? WBEM_RECONNECT_TYPE_ENUM :
                                                WBEM_RECONNECT_TYPE_OBJECT );
                apReconnectInfo[i].m_pwcsPath = pRequest->GetName();

                apReconnectResults[i].m_lId = pRequest->GetRemoteId();
                apReconnectResults[i].m_hr = 0;

            }   // FOR enum requests

            DWORD   dwRemoteRefrVersion = 0;
            hr = pRefServ->ReconnectRemoteRefresher( m_pObject->GetId(), 
                                                  0L, 
                                                  m_apRequests.GetSize(),
                                                  WBEM_REFRESHER_VERSION, 
                                                  apReconnectInfo.get(),
                                                  apReconnectResults.get(), 
                                                  &dwRemoteRefrVersion );
        }

        // Rehook up the object and enumids
        if ( WBEM_S_NO_ERROR == hr )
        {

            // Cleanup the old pointer
            if ( NULL != m_pRemRefresher )
            {
                m_pRemRefresher->Release();
                m_pRemRefresher = NULL;
            }

            // Store the new one and setup the security
            m_pRemRefresher = pRemRefresher;
            hr = ApplySecurity();

            if ( SUCCEEDED( hr ) )
            {
                m_pRemRefresher->AddRef();

                // Redo the ones that succeeded.  Clear the rest
                for( int i = 0; i < m_apRequests.GetSize(); i++ )
                {
                    CObjectRequest*   pRequest = m_apRequests.GetAt( i );

                    if ( SUCCEEDED( apReconnectResults[i].m_hr ) )
                    {
                        pRequest->SetRemoteId( apReconnectResults[i].m_lId );
                    }
                    else
                    {
                        // This means it didn't get hooked up again.  So if the
                        // user tries to remove him, we will just ignore this
                        // id.
                        pRequest->SetRemoteId( INVALID_REMOTE_REFRESHER_ID );
                    }
                }
            }
            else
            {
                // Setting security failed, so just set the pointer to NULL (we haven't
                // AddRef'd it ).
                m_pRemRefresher = NULL;
            }

        }   
        
        // Check that we're good to go
        if ( SUCCEEDED( hr ) )
        {
            // Clear the removed ids array since a new connection was established, hence the
            // old ids are a moot point.
            m_alRemovedIds.Empty();
            m_fConnected = TRUE;
        }
    }   // IF remote refreshers not the same
    else
    {
        // The remote refresher pointers match, so assume that all our old ids are still
        // valid.

        // The refresher we were handed will be automatically released.

        m_fConnected = TRUE;

        // Cleanup the old pointer
        if ( NULL != m_pRemRefresher )
        {
            m_pRemRefresher->Release();
            m_pRemRefresher = NULL;
        }

        // Store the new one and setup the security
        m_pRemRefresher = pRemRefresher;
        hr = ApplySecurity();

        if ( SUCCEEDED( hr ) )
        {
            m_pRemRefresher->AddRef();
        }
        else
        {
            // Setting security failed, so just set the pointer to NULL (we haven't
            // AddRef'd it ).
            m_pRemRefresher = NULL;
        }

        // Delete cached ids if we have any.
        if ( ( SUCCEEDED ( hr ) ) && m_alRemovedIds.Size() > 0 )
        {
            // We will need these memory buffers to hold individual request data
            wmilib::auto_buffer<long> aplIds(new long[m_alRemovedIds.Size()]);

            if (NULL == aplIds.get()) hr = WBEM_E_OUT_OF_MEMORY;

            if ( SUCCEEDED( hr ) )
            {
                // Enumerate the requests and fill out the arrays
                for ( int i = 0; i < m_alRemovedIds.Size(); i++ )
                {
                    // DEVNOTE:WIN64:SANJ - The id's are 32-bit, but on 64-bit platforms,
                    // the flex array will contain 64-bit values, so use PtrToLong
                    // to get a warning free conversion.  On 32-bit platforms,
                    // PtrToLong will do nothing.

                    aplIds[i] = PtrToLong(m_alRemovedIds.GetAt( i ));

                }   // FOR enum requests

                // DEVNOTE:TODO:SANJ - Do we care about this return code?
                hr = m_pRemRefresher->StopRefreshing( i-1, aplIds.get(), 0 );

                // Clear the array
                m_alRemovedIds.Empty();
            }
        }   // If RemoveId list is not empty

    }   // We got the remote refresher

    return hr;

}

unsigned CUniversalRefresher::CRemote::ReconnectEntry( void ) 
{
    // Release the AddRef() on the object from when the thread was created    
    OnDeleteObj0<CUniversalRefresher::CRemote,
                 ULONG(__stdcall CUniversalRefresher::CRemote:: *)(VOID),
                 &CUniversalRefresher::CRemote::Release> Call_Release(this);

    // This guy ALWAYS runs in the MTA
    RETURN_ON_ERR(CoInitializeEx(NULL,COINIT_MULTITHREADED));
    OnDelete0<void(*)(void),CoUninitialize> CoUninit;    

    // Make sure we have a namespace to connect to    
    if ( NULL == m_bstrNamespace ) return WBEM_E_INVALID_PARAMETER;
        
    HRESULT hr = RPC_E_DISCONNECTED;

    IWbemLocator * pWbemLocator = NULL;
    RETURN_ON_ERR(CoCreateInstance( CLSID_WbemLocator, 
                                    NULL, 
                                    CLSCTX_INPROC_SERVER,
                                    IID_IWbemLocator, 
                                    (void**) &pWbemLocator ));
    CReleaseMe rmLocator(pWbemLocator);
    
    // Basically as long as we can't connect, somebody else doesn't connect us, or we are told
    // to quit, we will run this thread.

    while ( FAILED(hr) && !m_fConnected && !m_fQuit )
    {
        // Because COM and RPC seem to have this problem with actually being able to themselves
        // reconnect, we're performing our own low level "ping" of the remote machine, using RegConnectRegistry
        // to verify if the machine is indeed alive.  If it is, then and only then will be deign to use
        // DCOM to follow through the operation.

        // do not use ping
        //IpHelp.IsAlive(m_bstrServer);
        BOOL bAlive = TRUE; // what if RemoteRegistry is DOWN ?
                          // what if IPX/SPX is used instead of TCP ?
                          // let's just try to connect with time-out
         

        if ( bAlive )
        {
            IWbemServices*  pNamespace = NULL;

            // We're gonna default to the system
            hr = pWbemLocator->ConnectServer( m_bstrNamespace,    // NameSpace Name
                                            NULL,           // UserName
                                            NULL,           // Password
                                            NULL,           // Locale
                                            WBEM_FLAG_CONNECT_USE_MAX_WAIT, // Flags
                                            NULL,           // Authority
                                            NULL,           // Wbem Context
                                            &pNamespace     // Namespace
                                                );
            if ( SUCCEEDED( hr ) )
            {
                // Apply security settings to the namespace
                hr = WbemSetProxyBlanket( pNamespace, 
                                        m_CoAuthInfo.dwAuthnSvc,
                                        m_CoAuthInfo.dwAuthzSvc, 
                                        COLE_DEFAULT_PRINCIPAL,
                                        m_CoAuthInfo.dwAuthnLevel,
                                        m_CoAuthInfo.dwImpersonationLevel,
                                        (RPC_AUTH_IDENTITY_HANDLE)m_CoAuthInfo.pAuthIdentityData,
                                        m_CoAuthInfo.dwCapabilities );

                if ( SUCCEEDED( hr ) )
                {
                    hr = Rebuild( pNamespace );
                }
                pNamespace->Release();
            }   // IF ConnectServer
        }   // IF IsAlive()

        // Sleep for a second and retry
        Sleep( 1000 );
    }

    return 0;
}

//
// this function will release the stream anyway
//
//////////////////////////////////////////////////////////
HRESULT CleanupStreamWithInterfaceAndSec(IStream * pStream,
                                       /* in */ COAUTHINFO & CoAuthInfo)
{
    HRESULT hr;
    IUnknown * pUnk = NULL;
    if (SUCCEEDED(hr = CoGetInterfaceAndReleaseStream( pStream, IID_IUnknown,(void**) &pUnk )))
    {
         // We need to reset security on the Refreshing services proxy.
        WbemSetProxyBlanket( pUnk, 
                            CoAuthInfo.dwAuthnSvc,
                            CoAuthInfo.dwAuthzSvc, 
                            COLE_DEFAULT_PRINCIPAL,
                            CoAuthInfo.dwAuthnLevel, 
                            CoAuthInfo.dwImpersonationLevel,
                            (RPC_AUTH_IDENTITY_HANDLE) CoAuthInfo.pAuthIdentityData,
                            CoAuthInfo.dwCapabilities );    
         pUnk->Release();
    }
    else // let's realease the stream ourlsef
    {
        pStream->Release();
    }

    return hr;
}

void CUniversalRefresher::CRemote::ClearRemoteConnections( void )
{
    HRESULT hr = WBEM_S_NO_ERROR;

    IWbemRemoteRefresher*       pRemRefresher = NULL;
    IWbemRefreshingServices*    pRefServ = NULL;

    // Cleanup the IWbemRefreshingServices stream pointer
    if (m_pReconnectSrv)
    {
        CleanupStreamWithInterfaceAndSec(m_pReconnectSrv,m_CoAuthInfo);
        m_pReconnectSrv = NULL;
    }

    // Cleanup the IWbemRemoteRefresher stream pointer
    if (m_pReconnectedRemote )
    {
        CleanupStreamWithInterfaceAndSec(m_pReconnectedRemote,m_CoAuthInfo);
        m_pReconnectedRemote = NULL;
    }

    // Cleanup the IWbemRemoteRefresher pointer
    if ( NULL != m_pRemRefresher )
    {
        m_pRemRefresher->Release();
        m_pRemRefresher = NULL;
    }
}

HRESULT CUniversalRefresher::CRemote::Reconnect( void )
{
    HRESULT hr = RPC_E_DISCONNECTED;

    IWbemRemoteRefresher*       pRemRefresher = NULL;
    IWbemRefreshingServices*    pRefServ = NULL;

    CInCritSec  ics( &m_cs );

    // We will need to unmarshale both the RefreshingServices and the RemoteRefresher pointers,
    // so make sure that the streams we will need to unmarshal these from already exist.

    if ( NULL != m_pReconnectSrv && NULL != m_pReconnectedRemote )
    {
        hr = CoGetInterfaceAndReleaseStream( m_pReconnectSrv, IID_IWbemRefreshingServices, (void**) &pRefServ );
        CReleaseMe  rmrs( pRefServ );

        if ( SUCCEEDED( hr ) )
        {
            // We need to reset security on the Refreshing services proxy.

            hr = WbemSetProxyBlanket( pRefServ, m_CoAuthInfo.dwAuthnSvc,
                        m_CoAuthInfo.dwAuthzSvc, COLE_DEFAULT_PRINCIPAL,
                        m_CoAuthInfo.dwAuthnLevel, m_CoAuthInfo.dwImpersonationLevel,
                        (RPC_AUTH_IDENTITY_HANDLE) m_CoAuthInfo.pAuthIdentityData,
                        m_CoAuthInfo.dwCapabilities );

            if ( SUCCEEDED( hr ) )
            {
                hr = CoGetInterfaceAndReleaseStream( m_pReconnectedRemote, IID_IWbemRemoteRefresher,
                        (void**) &pRemRefresher );
                CReleaseMe  rmrr( pRemRefresher );

                if ( SUCCEEDED( hr ) )
                {
                    // Remote refresher and refreshing services
                    hr = Rebuild( pRefServ, pRemRefresher, &m_ReconnectGuid );
                }
                else
                {
                    // Make sure we release the stream
                    m_pReconnectedRemote->Release();
                }
            }
            else
            {
                // Make sure we release the stream
                m_pReconnectedRemote->Release();
            }

        }   // IF unmarshaled refreshing services pointer
        else
        {
            m_pReconnectSrv->Release();
            m_pReconnectedRemote->Release();
        }

        // NULL out both stream pointers
        m_pReconnectSrv = NULL;
        m_pReconnectedRemote = NULL;

    }

    return hr;
}

HRESULT CUniversalRefresher::CRemote::Refresh(long lFlags)
{
    if(m_pRemRefresher == NULL && IsConnected())
        return WBEM_E_CRITICAL_ERROR;

    WBEM_REFRESHED_OBJECT* aRefreshed = NULL;
    long lNumObjects = 0;

    HRESULT hresRefresh = WBEM_S_NO_ERROR;

    // Make sure we're connected.  If not, and we haven't been told not to, try to reconnect
    if ( !IsConnected() )
    {
        if ( ! (lFlags  & WBEM_FLAG_REFRESH_NO_AUTO_RECONNECT ) )
        {
            hresRefresh = Reconnect();
            if ( FAILED( hresRefresh ) )
            {
                return hresRefresh;
            }
        }
        else
        {
            return RPC_E_DISCONNECTED;
        }
    }

    hresRefresh = m_pRemRefresher->RemoteRefresh(0, &lNumObjects, &aRefreshed);

    // If RemoteRefresh returns a connection type error, Set our state to "NOT" connected
    if(FAILED(hresRefresh))
    {
        // This will kick off a thread to reconnect if the error return was
        // a connection error, and the appropriate "Don't do this" flag is not set
        CheckConnectionError( hresRefresh, !(lFlags  & WBEM_FLAG_REFRESH_NO_AUTO_RECONNECT ) );
        return hresRefresh;
    }

    int nSize = m_apRequests.GetSize();
    HRESULT hresFinal = WBEM_S_NO_ERROR;

    //  DEVNOTE:TODO:SANJ - We could make this much faster if we did some sorting on the
    //  server end

    for(int i = 0; i < lNumObjects; i++)
    {

        long lObjectId = aRefreshed[i].m_lRequestId;
        for(int j = 0; j < nSize; j++)
        {
            CObjectRequest* pRequest = m_apRequests[j];
            if(pRequest->GetRemoteId() == lObjectId)
            {
                // The request will refresh itself
                HRESULT hres = pRequest->Refresh( &aRefreshed[i] );

                // Only copy this value if the refresh failed and we haven't already
                // gotten the value
                if(FAILED(hres) && SUCCEEDED(hresFinal))
                {
                    hresFinal = hres;
                }
                break;
            }
        }

        CoTaskMemFree(aRefreshed[i].m_pbBlob);
    }

    // Free the wrapping BLOB
    CoTaskMemFree( aRefreshed );

    // The final return code should give precedence to the actual remote refresh call if it
    // doesn't contain a NO_ERROR, and hresFinal is NOT an error

    if ( SUCCEEDED( hresFinal ) )
    {
        if ( WBEM_S_NO_ERROR != hresRefresh )
        {
            hresFinal = hresRefresh;
        }
    }

    return hresFinal;
}

HRESULT CUniversalRefresher::CRemote::Remove(long lId,
                            long lFlags,
                            CUniversalRefresher* pContainer)
{
    HRESULT hr = WBEM_S_FALSE;

    int nSize = m_apRequests.GetSize();
    for(int i = 0; i < nSize; i++)
    {
        CObjectRequest* pRequest = m_apRequests[i];
        if(pRequest->GetClientId() == lId)
        {
            if ( IsConnected() )
            {
                // Check that the remote id doesn't indicate an item that
                // failed to be reconstructed.

                if ( pRequest->GetRemoteId() == INVALID_REMOTE_REFRESHER_ID )
                {
                    hr = WBEM_S_NO_ERROR;
                }
                else
                {
                    hr = pRequest->Cancel(this);
                }

                if ( FAILED(hr) && IsConnectionError(hr) )
                {
                    // This will kick off a reconnect thread unless we were told not to
                    CheckConnectionError( hr, !(lFlags  & WBEM_FLAG_REFRESH_NO_AUTO_RECONNECT ) );

                    // We will remove the request from here, but
                    // queue up the id for later deletion
                    hr = WBEM_S_NO_ERROR;
                }
            }

            // DEVNOTE:TODO:SANJ - What about other errors?  For now, we'll lose the local
            // connection.

            if ( SUCCEEDED( hr ) )
            {
                // Retrieves the remote id from the request
                long    lRemoteId = pRequest->GetRemoteId();

                m_apRequests.RemoveAt(i);

                // If we couldn't remove the id remotely, just queue it up in the
                // removed id array so we can clean it up properly if we get
                // reconnected. We will, of course, not need to do anything if the
                // remote id indicates a failed readd during reconnection 

                if ( lRemoteId != INVALID_REMOTE_REFRESHER_ID && !IsConnected() )
                {
                    CInCritSec  ics(&m_cs);

                    // Note that we may have gotten connected on the critical section and
                    // if that is the case, for now, we'll have one extra resource on the
                    // server, but the likelihood of running into contention problems here
                    // is too high.  Plus, if it reconnected via a new remote refresher, if
                    // we retry a remove here, we could remove the "wrong" id.  To protect
                    // against this, we will check that we are still not connected and if
                    // that is not the case, we will just "forget" about the object id.

                    if (!IsConnected())
                    {
                        // SANJ - By casting to __int64 and back to void*, in 32-bit,
                        // this truncates the __int64, and in 64-bit, keeps away warningss.
                        if (CFlexArray::no_error != m_alRemovedIds.Add( (void*) (__int64) lRemoteId ))
                            hr = WBEM_E_OUT_OF_MEMORY;
                    }   // IF Still not connected

                }   // IF Not connected

            }   // IF remote remove ok

            break;

        }   // IF found matching client id

    }   // FOR enum requests

    return hr;
}
            
CUniversalRefresher::CRemote::CObjectRequest::CObjectRequest(CWbemObject* pTemplate, 
                                                 long lRequestId,
                                                 LPCWSTR pwcsRequestName )
    : CClientRequest(pTemplate), m_lRemoteId(lRequestId), m_wstrRequestName( pwcsRequestName )
{
}

HRESULT CUniversalRefresher::CRemote::CObjectRequest::Refresh( WBEM_REFRESHED_OBJECT* pRefrObj )
{
    CWbemInstance* pInst = (CWbemInstance*) GetClientObject();
    return pInst->CopyTransferBlob(
                pRefrObj->m_lBlobType, 
                pRefrObj->m_lBlobLength,
                pRefrObj->m_pbBlob);
                
}

HRESULT CUniversalRefresher::CRemote::CObjectRequest::Cancel(
            CUniversalRefresher::CRemote* pRemote)
{
    if(pRemote->GetRemoteRefresher())
        return pRemote->GetRemoteRefresher()->StopRefreshing( 1, &m_lRemoteId, 0 );
    else
        return WBEM_S_NO_ERROR;
}

CUniversalRefresher::CRemote::CEnumRequest::CEnumRequest(CWbemObject* pTemplate, 
                                                         long lRequestId,
                                                         LPCWSTR pwcsRequestName, 
                                                         CLifeControl* pLifeControl )
    : CObjectRequest(pTemplate, lRequestId, pwcsRequestName), m_pClientEnum(NULL)
{
    m_pClientEnum = new CReadOnlyHiPerfEnum( pLifeControl );

    // AddRef the new enumerator
    if ( NULL != m_pClientEnum )
    {
        // Don't hold onto this guy if we can't set the template
        if ( SUCCEEDED( m_pClientEnum->SetInstanceTemplate( (CWbemInstance*) pTemplate ) ) )
        {
            m_pClientEnum->AddRef();
        }
        else
        {
            // Cleanup
            delete m_pClientEnum;
            m_pClientEnum = NULL;
        }
    }
}

CUniversalRefresher::CRemote::CEnumRequest::~CEnumRequest( void )
{
    if ( NULL != m_pClientEnum )
    {
        m_pClientEnum->Release();
    }
}

HRESULT 
CUniversalRefresher::CRemote::CEnumRequest::Refresh( WBEM_REFRESHED_OBJECT* pRefrObj )
{
    return m_pClientEnum->Copy( pRefrObj->m_lBlobType,
                                pRefrObj->m_lBlobLength,
                                pRefrObj->m_pbBlob );
}

HRESULT CUniversalRefresher::CRemote::CEnumRequest::GetEnum( IWbemHiPerfEnum** ppEnum )
{
    return ( NULL != m_pClientEnum ?
                m_pClientEnum->QueryInterface( IID_IWbemHiPerfEnum, (void**) ppEnum ) :
                WBEM_E_FAILED );
}


//*****************************************************************************
//*****************************************************************************
//                          NESTED REFRESHERS
//*****************************************************************************
//*****************************************************************************

                    

CUniversalRefresher::CNestedRefresher::CNestedRefresher( IWbemRefresher* pRefresher )
    : m_pRefresher(pRefresher)
{
    if ( m_pRefresher )
        m_pRefresher->AddRef();

    // Assign a unique id
    m_lClientId = CUniversalRefresher::GetNewId();
}
    
CUniversalRefresher::CNestedRefresher::~CNestedRefresher()
{
    if ( m_pRefresher )
        m_pRefresher->Release();
}

HRESULT CUniversalRefresher::CNestedRefresher::Refresh( long lFlags )
{
    // Make sure we have an internal refresher pointer
    return ( NULL != m_pRefresher ? m_pRefresher->Refresh( lFlags ) : WBEM_E_FAILED );
}

//*****************************************************************************
//*****************************************************************************
//                          PROVIDER CACHE
//*****************************************************************************
//*****************************************************************************

CHiPerfProviderRecord::CHiPerfProviderRecord(REFCLSID rclsid, 
                                        LPCWSTR wszNamespace,
                                        IWbemHiPerfProvider* pProvider, 
                                        _IWmiProviderStack* pProvStack): 
    m_clsid(rclsid), 
    m_wsNamespace(wszNamespace), 
    m_pProvider(pProvider), 
    m_pProvStack( pProvStack ),
    m_lRef( 0 )
{
    if(m_pProvider) m_pProvider->AddRef();
    if (m_pProvStack ) m_pProvStack->AddRef();
}

CHiPerfProviderRecord::~CHiPerfProviderRecord()
{
    if(m_pProvider) m_pProvider->Release();
    if (m_pProvStack ) m_pProvStack->Release();
}

long CHiPerfProviderRecord::Release()
{
    long lRef = InterlockedDecrement( &m_lRef );

    // Removing us from the cache will delete us
    if ( 0 == lRef )
    {
        CUniversalRefresher::GetProviderCache()->RemoveRecord( this );
    }

    return lRef;
}

//
//
//  the client-side Hi-Perf provider cache
//
/////////////////////////////////////////////////////////////////

HRESULT 
CClientLoadableProviderCache::FindProvider(REFCLSID rclsid, 
                                      LPCWSTR wszNamespace, 
                                      IUnknown* pNamespace,
                                      IWbemContext * pContext,
                                      CHiPerfProviderRecord** ppProvider)
{
    CInCritSec ics(&m_cs);

    *ppProvider = NULL;
    HRESULT hres;

    for(int i = 0; i < m_apRecords.GetSize(); i++)
    {
        CHiPerfProviderRecord* pRecord = m_apRecords.GetAt( i );
        if(pRecord->m_clsid == rclsid && 
            pRecord->m_wsNamespace.EqualNoCase(wszNamespace))
        {
            *ppProvider = pRecord;
            (*ppProvider)->AddRef();
            return WBEM_S_NO_ERROR;
        }
    }

    // Prepare an namespace pointer
    // ============================

    IWbemServices* pServices = NULL;
    hres = pNamespace->QueryInterface(IID_IWbemServices, (void**)&pServices);
    if(FAILED(hres))
        return hres;
    CReleaseMe rm1(pServices);

    // Create 
    // ======

    IUnknown* pUnk = NULL;
    hres = CoCreateInstance(rclsid, NULL, CLSCTX_INPROC_SERVER,
                        IID_IUnknown, (void**)&pUnk);
    CReleaseMe rm2(pUnk);
    if(FAILED(hres))
        return hres;

    // Initialize
    // ==========

    IWbemProviderInit* pInit = NULL;
    hres = pUnk->QueryInterface(IID_IWbemProviderInit, (void**)&pInit);
    if(FAILED(hres))
        return hres;
    CReleaseMe rm3(pInit);

    CProviderInitSink* pSink = new CProviderInitSink;
    if (NULL == pSink) return WBEM_E_OUT_OF_MEMORY;
    pSink->AddRef();
    CReleaseMe rm4(pSink);

    try
    {
        hres = pInit->Initialize(NULL, 0, (LPWSTR)wszNamespace, NULL, 
                                 pServices, pContext, pSink);
    }
    catch(...)
    {
        hres = WBEM_E_PROVIDER_FAILURE;
    }

    if(FAILED(hres))
        return hres;

    hres = pSink->WaitForCompletion();
    if(FAILED(hres))
        return hres;

    // Ask for the right interface
    // ===========================

    IWbemHiPerfProvider*    pProvider = NULL;

    hres = pUnk->QueryInterface(IID_IWbemHiPerfProvider, (void**)&pProvider);
    if(FAILED(hres))
        return hres;
    CReleaseMe rm5(pProvider);

    // Create a record
    // ===============

    // No provider stack here since we are loading the provider ourselves
    wmilib::auto_ptr<CHiPerfProviderRecord> pRecord( new CHiPerfProviderRecord(rclsid, wszNamespace, pProvider, NULL));
    if (NULL == pRecord.get()) return WBEM_E_OUT_OF_MEMORY;
    if (-1 == m_apRecords.Add(pRecord.get())) return WBEM_E_OUT_OF_MEMORY;

    // AddRef the record
    pRecord->AddRef();
    *ppProvider = pRecord.release();    

    return WBEM_S_NO_ERROR;
}

HRESULT 
CClientLoadableProviderCache::FindProvider(REFCLSID rclsid,
                                      IWbemHiPerfProvider* pProvider, 
                                      _IWmiProviderStack* pProvStack,
                                      LPCWSTR wszNamespace, 
                                      CHiPerfProviderRecord** ppProvider)
{
    CInCritSec ics(&m_cs);

    *ppProvider = NULL;

    for(int i = 0; i < m_apRecords.GetSize(); i++)
    {
        CHiPerfProviderRecord* pRecord = m_apRecords.GetAt( i );
        if(pRecord->m_clsid == rclsid && 
            pRecord->m_wsNamespace.EqualNoCase(wszNamespace))
        {
            *ppProvider = pRecord;
            (*ppProvider)->AddRef();
            return WBEM_S_NO_ERROR;
        }
    }

    // We already have provider pointer so we can just create a record
    // ===============

    wmilib::auto_ptr<CHiPerfProviderRecord> pRecord( new CHiPerfProviderRecord(rclsid, wszNamespace, pProvider, pProvStack ));
    if (NULL == pRecord.get()) return WBEM_E_OUT_OF_MEMORY;
    if (-1 == m_apRecords.Add(pRecord.get())) return WBEM_E_OUT_OF_MEMORY;

    // AddRef the record
    pRecord->AddRef();
    *ppProvider = pRecord.release();

    return WBEM_S_NO_ERROR;
}

void CClientLoadableProviderCache::RemoveRecord( CHiPerfProviderRecord* pRecord )
{
    CInCritSec ics(&m_cs);

    // Make sure the record didn't get accessed on another thread.
    // If not, go ahead and look for our record, and remove it
    // from the array.  When we remove it, the record will be
    // deleted.

    if ( pRecord->IsReleased() )
    {

        for(int i = 0; i < m_apRecords.GetSize(); i++)
        {
            if ( pRecord == m_apRecords.GetAt( i ) )
            {
                // This will delete the record
                m_apRecords.RemoveAt( i );
                break;
            }
        }   // FOR search records

    }   // IF record is released

}

void CClientLoadableProviderCache::Flush()
{
    CInCritSec ics(&m_cs);
    
    m_apRecords.RemoveAll();
}

CClientLoadableProviderCache::~CClientLoadableProviderCache( void )
{
    // This is a static list, so if we're going away and something
    // fails here because people didn't release pointers properly,
    // chances are something will fail, so since we're being dropped
    // from memory, if the provider list is not empty, don't clean
    // it up.  This is really a bad client-created leak anyways.
    _DBG_ASSERT(0 == m_apRecords.GetSize())

}

CClientLoadableProviderCache::CClientLoadableProviderCache( void )
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\marshalers\coreprox\refrcli.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    REFRCLI.H

Abstract:

	Refresher Client Side Code.

History:

--*/

#ifndef __UNIVERSAL_REFRESHER__H_
#define __UNIVERSAL_REFRESHER__H_

#include <unk.h>
#include "refrhelp.h"
#include <cloadhpenum.h>
#include <statsync.h>

class CHiPerfProviderRecord
{
public:
    long m_lRef;

    CLSID m_clsid;
    WString m_wsNamespace;
    IWbemHiPerfProvider* m_pProvider;

	// If we pull the provider back from the provider subsystem, then we
	// need to AddRef() the provider stack to ensure that the provider stays
	// loaded in the cache.
	_IWmiProviderStack* m_pProvStack;

public:
    CHiPerfProviderRecord(REFCLSID rclsid, LPCWSTR wszNamespace, 
                        IWbemHiPerfProvider* pProvider, _IWmiProviderStack* pProvStack);
    ~CHiPerfProviderRecord();
    long AddRef() {return InterlockedIncrement(&m_lRef);}
    long Release();

	BOOL IsReleased( void ) { return 0 == m_lRef; }

};


class CClientLoadableProviderCache
{
protected:
    CUniquePointerArray<CHiPerfProviderRecord>	m_apRecords;
    CStaticCritSec                              m_cs;    // this is a static/global object
public:
    CClientLoadableProviderCache();
	~CClientLoadableProviderCache();

    HRESULT FindProvider(REFCLSID rclsid, 
    	               LPCWSTR wszNamespace, 
                       IUnknown* pNamespace,
                       IWbemContext * pContext,
                       CHiPerfProviderRecord** ppProvider);
    HRESULT FindProvider(REFCLSID rclsid, 
    	               IWbemHiPerfProvider* pProvider,
      				   _IWmiProviderStack* pProvStack, 
      				   LPCWSTR wszNamespace,
				       CHiPerfProviderRecord** ppProvider);
    void Flush();

	void RemoveRecord( CHiPerfProviderRecord* pRecord );

};



class CUniversalRefresher : public CUnk
{
protected:
    static CClientLoadableProviderCache mstatic_Cache;

public:
    static CClientLoadableProviderCache* GetProviderCache() 
        {return &mstatic_Cache;}

    //
    // base class for all the requests Direct-ClientLoad-Direct-Remote
    //
    class CClientRequest
    {
    protected:
        CWbemObject* m_pClientObject;
        long m_lClientId;
    public:
        CClientRequest(CWbemObject* pTemplate = NULL);
        virtual ~CClientRequest();

        void GetClientInfo(RELEASE_ME IWbemClassObject** ppRefresher, 
                            long* plId);

        long GetClientId() {return m_lClientId;}
        INTERNAL CWbemObject* GetClientObject() {return m_pClientObject;}
    };
    
    class CDirect
    {
    public:
        class CObjectRequest : public CClientRequest
        {
        protected:
            long m_lProviderId;
            CWbemObject* m_pProviderObject;
        public:
            CObjectRequest(CWbemObject* pProviderObject, CWbemObject* pClientObject, long lProviderId);
            ~CObjectRequest();
            virtual void Copy();
            HRESULT Cancel(CDirect* pDirect);
        };

		class CEnumRequest : public CObjectRequest
		{
			protected:
				CClientLoadableHiPerfEnum*	m_pHPEnum;
				CReadOnlyHiPerfEnum*		m_pClientEnum;

			public:
				CEnumRequest(CClientLoadableHiPerfEnum* pHPEnum, long lProviderId, CLifeControl* pLifeControl);
				~CEnumRequest();

				HRESULT GetClientInfo(RELEASE_ME IWbemHiPerfEnum** ppEnum, 
									long* plId);
				void Copy();
		};

    protected:
        CHiPerfProviderRecord* m_pProvider;
        IWbemRefresher* m_pRefresher;

        CUniquePointerArray<CObjectRequest> m_apRequests;
    public:
        INTERNAL CHiPerfProviderRecord* GetProvider() {return m_pProvider;}
        INTERNAL IWbemRefresher* GetRefresher() {return m_pRefresher;}
    public:
        CDirect(CHiPerfProviderRecord* pProvider, IWbemRefresher* pRefresher);
        ~CDirect();
        HRESULT AddObjectRequest(CWbemObject* pRefreshedObject, CWbemObject* pClientObject,
					long lCancelId, IWbemClassObject** ppRefresher, long* plId);

        HRESULT AddEnumRequest(CClientLoadableHiPerfEnum* pHPEnum, long lCancelId,
					IWbemHiPerfEnum** ppEnum, long* plId,
					CLifeControl* pLifeControl );

        HRESULT Refresh(long lFlags);
        HRESULT Remove(long lId, CUniversalRefresher* pContainer);
    };
        
    class CRemote
    {
    public:
        class CObjectRequest : public CClientRequest
        {
        protected:
            long		m_lRemoteId;
			WString		m_wstrRequestName;

        public:
            CObjectRequest(CWbemObject* pTemplate, long lRemoteId, LPCWSTR pwcsRequestName);
            ~CObjectRequest(){}

            HRESULT Cancel(CRemote* pDirect);
            long GetRemoteId() {return m_lRemoteId;}
			void SetRemoteId( long lId ) { m_lRemoteId = lId; }
			LPCWSTR GetName( void ) { return m_wstrRequestName; }

			virtual BOOL IsEnum( void ) { return FALSE; }
			virtual HRESULT Refresh( WBEM_REFRESHED_OBJECT* pRefrObj );

        };

		class CEnumRequest : public CObjectRequest
		{
        protected:
            long						m_lRemoteId;
			CReadOnlyHiPerfEnum*		m_pClientEnum;
        public:
            CEnumRequest( CWbemObject* pTemplate, long lRemoteId, LPCWSTR pwcsRequestName,
						CLifeControl* pLifeControl );
            ~CEnumRequest();

			BOOL	IsOk( void ) { return ( NULL != m_pClientEnum ); }
			HRESULT GetEnum( IWbemHiPerfEnum** ppEnum );

			virtual BOOL IsEnum( void ) { return TRUE; }
			// Override for enumerators
			HRESULT Refresh( WBEM_REFRESHED_OBJECT* pRefrObj );

		};
        
    protected:
		// The actual remote refresher
        IWbemRemoteRefresher*	m_pRemRefresher;
		// Remote Refresher GUID
		GUID					m_RemoteGuid;
		// Security Info
		COAUTHINFO				m_CoAuthInfo;
		// Namespace and server for reconnect
		BSTR					m_bstrNamespace;
		// Server for Reconnect workaround
		BSTR					m_bstrServer;
		// Are we connected
		BOOL					m_fConnected;
		// Flag tells us to quit if reconnecting
		BOOL					m_fQuit;
		// Requests
        CUniquePointerArray<CObjectRequest>	m_apRequests;
		// Cache of ids we removed.
		CFlexArray						m_alRemovedIds;
		// Our wrapper object
		CUniversalRefresher*	m_pObject;
		// Internal Critical Section
		CCritSec				m_cs;
		// For marshaling/unmarshaling across apartment-models
		// during the reconnect phase
		IStream*				m_pReconnectedRemote;
		IStream*				m_pReconnectSrv;
		GUID					m_ReconnectGuid;

		long					m_lRefCount;

	protected:

/*
		// Helper workaround for COM/RPC inadequacies.
		HRESULT IsAlive( void );
*/		

		static unsigned __stdcall ThreadProc( void * pThis )
		{
			return ((CRemote*) pThis)->ReconnectEntry();
		}

		unsigned ReconnectEntry( void );

		// Cleans up all the remote connections we may be holding onto
		void ClearRemoteConnections( void );

    public:
        CRemote( IWbemRemoteRefresher* pRemRefresher, COAUTHINFO* pACoAuthInfo, const GUID* pGuid,
					LPCWSTR pwszNamespace, LPCWSTR pwszServer, CUniversalRefresher* pObject );
        ~CRemote();

		ULONG STDMETHODCALLTYPE AddRef();
		ULONG STDMETHODCALLTYPE Release(); 

        HRESULT AddObjectRequest(CWbemObject* pTemplate, LPCWSTR pwcsRequestName, long lCancelId,
                    IWbemClassObject** ppRefresher, long* plId );
        HRESULT AddEnumRequest(CWbemObject* pTemplate, LPCWSTR pwcsRequestName, long lCancelId,
					IWbemHiPerfEnum** ppEnum, long* plId,
					CLifeControl* pLifeControl );

        HRESULT Refresh(long lFlags);
        HRESULT Remove(long lId, long lFlags, CUniversalRefresher* pContainer);
		HRESULT ApplySecurity( void );

		HRESULT Rebuild( IWbemServices* pNamespace );
		HRESULT Rebuild( IWbemRefreshingServices* pRefServ, IWbemRemoteRefresher* pRemRefresher,
							const GUID* pReconnectGuid );

		HRESULT Reconnect( void );
		BOOL IsConnectionError( HRESULT hr )
		{
			return ( RPC_S_SERVER_UNAVAILABLE == HRESULT_CODE(hr) || RPC_E_DISCONNECTED == hr ||
						RPC_S_CALL_FAILED == HRESULT_CODE(hr) );
		}
		void CheckConnectionError( HRESULT, BOOL fStartReconnect = FALSE );
		BOOL IsConnected( void )
		{
			return m_fConnected;
		}

		LPCWSTR GetNamespace( void )
		{
			return m_bstrNamespace;
		}

		void Quit( void )
		{
			m_fQuit = TRUE;
		}

    public:
        INTERNAL IWbemRemoteRefresher* GetRemoteRefresher() 
            {return m_pRemRefresher;}
    };


    class CNonHiPerf
    {

    public:
        class CObjectRequest : public CClientRequest
        {
        protected:
            CWbemObject* m_pProviderObject;
			BSTR		 m_strPath;
        public:
            CObjectRequest( CWbemObject* m_pProviderObject, CWbemObject* pClientObject, LPCWSTR pwszPath);
            ~CObjectRequest();
            virtual void Copy();
            virtual HRESULT Refresh( CNonHiPerf* pNonHiPerf );
            HRESULT Cancel(CNonHiPerf* pNonHiPerf);
        };

		class CEnumRequest : public CObjectRequest
		{
			protected:
				CClientLoadableHiPerfEnum*	m_pHPEnum;
				CReadOnlyHiPerfEnum*		m_pClientEnum;

			public:
				CEnumRequest(CClientLoadableHiPerfEnum* pHPEnum, LPCWSTR pwszClassName, CLifeControl* pLifeControl);
				~CEnumRequest();

				HRESULT GetClientInfo(RELEASE_ME IWbemHiPerfEnum** ppEnum, 
									long* plId);
				void Copy();
	            HRESULT Refresh( CNonHiPerf* pNonHiPerf );
		};

    protected:
		WString				m_wsNamespace;
        IWbemServices*	m_pSvcEx;
        CUniquePointerArray<CObjectRequest> m_apRequests;

    public:
    public:
        CNonHiPerf( LPCWSTR pwszNamespace, IWbemServices* pSvcEx );
        ~CNonHiPerf();

		LPCWSTR GetNamespace( void ) { return m_wsNamespace; }
        IWbemServices* GetServices( void ) { return m_pSvcEx; }

        HRESULT AddObjectRequest(CWbemObject* pRefreshedObject, CWbemObject* pClientObject,
					LPCWSTR pwszPath, IWbemClassObject** ppRefresher, long* plId);

        HRESULT AddEnumRequest(CClientLoadableHiPerfEnum* pHPEnum, LPCWSTR pwszClassName, IWbemHiPerfEnum** ppEnum, long* plId,
					CLifeControl* pLifeControl );

        HRESULT Refresh(long lFlags);
        //
        HRESULT Remove(long lId, CUniversalRefresher* pContainer);

    };


	class CNestedRefresher
	{
	public:
		CNestedRefresher( IWbemRefresher* pRefresher );
		~CNestedRefresher();

		HRESULT Refresh( long lFlags );
		long GetId( void )
		{ return m_lClientId; }

	private:

		IWbemRefresher*	m_pRefresher;
		long			m_lClientId;
	};

protected:
    CUniquePointerArray<CDirect> m_apDirect;
    CUniquePointerArray<CNonHiPerf> m_apNonHiPerf;
    CRefedPointerArray<CRemote> m_apRemote;
    CUniquePointerArray<CNestedRefresher> m_apNestedRefreshers;
    
    CRefresherId	m_Id;
	CHiPerfLock		m_Lock;

	IWbemPath*		m_pParser;

    static long mstatic_lLastId;
protected:
    class XRefresher : public CImpl<IWbemRefresher, CUniversalRefresher>
    {
    public:
        XRefresher(CUniversalRefresher* pObject) : 
            CImpl<IWbemRefresher, CUniversalRefresher>(pObject)
        {}

        STDMETHOD(Refresh)(long lFlags);
    } m_XRefresher;
    friend XRefresher;

    class XConfigure : public CImpl<IWbemConfigureRefresher, CUniversalRefresher>
    {
    public:
        XConfigure(CUniversalRefresher* pObject) : 
            CImpl<IWbemConfigureRefresher, CUniversalRefresher>(pObject)
        {}

        STDMETHOD(AddObjectByPath)(IWbemServices* pNamespace, LPCWSTR wszPath,
            long lFlags, IWbemContext* pContext, 
            IWbemClassObject** ppRefreshable, long* plId);

        STDMETHOD(AddObjectByTemplate)(IWbemServices* pNamespace, 
            IWbemClassObject* pTemplate,
            long lFlags, IWbemContext* pContext, 
            IWbemClassObject** ppRefreshable, long* plId);

        STDMETHOD(AddRefresher)(IWbemRefresher* pRefresher, long lFlags,
            long* plId);

        STDMETHOD(Remove)(long lId, long lFlags);

		STDMETHOD(AddEnum)(	IWbemServices*	pNamespace, LPCWSTR wscClassName,
			long lFlags, IWbemContext* pContext, IWbemHiPerfEnum** ppEnum,
			long* plId );
							
    } m_XConfigure;
    friend XConfigure;

protected:
    void* GetInterface(REFIID riid);

	HRESULT AddInProcObject(	CHiPerfProviderRecord* pProvider,
								IWbemObjectAccess* pTemplate,
								IWbemServices* pNamespace,
								IWbemContext * pContext,
								IWbemClassObject** ppRefreshable, long* plId);

	HRESULT AddInProcEnum(		CHiPerfProviderRecord* pProvider,
								IWbemObjectAccess* pTemplate,
								IWbemServices* pNamespace, LPCWSTR wszClassName,
								IWbemContext * pContext,
								IWbemHiPerfEnum** ppEnum, long* plId);


    HRESULT AddClientLoadableObject(const WBEM_REFRESH_INFO_CLIENT_LOADABLE& Info,
                                IWbemServices* pNamespace,
                                IWbemContext * pContext,
                                IWbemClassObject** ppRefreshable, long* plId);

	HRESULT AddClientLoadableEnum(	const WBEM_REFRESH_INFO_CLIENT_LOADABLE& Info,
									IWbemServices* pNamespace, LPCWSTR wszClassName, IWbemContext * pContext,
									IWbemHiPerfEnum** ppEnum, long* plId);

    HRESULT AddDirectObject(const WBEM_REFRESH_INFO_DIRECT& Info,
                                IWbemServices* pNamespace,
                                IWbemContext * pContext,
                                IWbemClassObject** ppRefreshable, long* plId);

	HRESULT AddDirectEnum(	const WBEM_REFRESH_INFO_DIRECT& Info,
									IWbemServices* pNamespace, LPCWSTR wszClassName, IWbemContext * pContext,
									IWbemHiPerfEnum** ppEnum, long* plId);

	HRESULT FindRemoteEntry(	const WBEM_REFRESH_INFO_REMOTE& Info,
								COAUTHINFO* pAuthInfo,
								CRemote** ppRemoteRecord );

    HRESULT AddRemoteObject( IWbemRefreshingServices* pRefServ, const WBEM_REFRESH_INFO_REMOTE& Info,
						LPCWSTR pwcsRequestName, long lCancelId, IWbemClassObject** ppRefreshable, long* plId,
						COAUTHINFO* pCoAuthInfo );
    HRESULT AddRemoteEnum ( IWbemRefreshingServices* pRefServ, const WBEM_REFRESH_INFO_REMOTE& Info,
								LPCWSTR pwcsRequestName, long lCancelId, IWbemContext * pContext,
								IWbemHiPerfEnum** ppEnum,
								long* plId, COAUTHINFO* pCoAuthInfo );

    HRESULT AddRefresher( IWbemRefresher* pRefresher, long lFlags, long* plId );

    HRESULT AddNonHiPerfObject(const WBEM_REFRESH_INFO_NON_HIPERF& Info,
                        IWbemServices* pNamespace, LPCWSTR pwszPath,
                        IWbemClassObject** ppRefreshable, long* plId,
						COAUTHINFO & CoAuthInfo );
	HRESULT AddNonHiPerfEnum(	const WBEM_REFRESH_INFO_NON_HIPERF& Info,
								IWbemServices* pNamespace, LPCWSTR wszClassName,
								IWbemContext * pContext,
								IWbemHiPerfEnum** ppEnum, long* plId, 
								COAUTHINFO & CoAuthInfo );


    HRESULT Remove(long lId, long lFlags);
    HRESULT Refresh(long lFlags);

public:
    CUniversalRefresher(CLifeControl* pControl, IUnknown* pOuter = NULL) 
        : CUnk(pControl, pOuter), m_XRefresher(this), m_XConfigure(this),
		m_pParser( NULL )
    {}
	~CUniversalRefresher();

	static HRESULT GetRefreshingServices( IWbemServices* pNamespace,
				                     IWbemRefreshingServices** ppRefSvc,
                     				 COAUTHINFO* pCoAuthInfo );

    HRESULT FindProvider(REFCLSID rclsid, LPCWSTR wszNamespace, 
                IWbemHiPerfProvider** ppProvider);

    INTERNAL CRefresherId* GetId() {return &m_Id;}
    static long GetNewId();
    static void Flush();

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\marshalers\coreprox\refrhelp.cpp ===
/*++

Copyright (C) 1998-2001 Microsoft Corporation

Module Name:

    REFRHELP.CPP

Abstract:

    Refresher helpers

History:

--*/

#include "precomp.h"
#include <stdio.h>

#include <wbemint.h>
#include <refrhelp.h>
#include <wbemcomn.h>
#include <fastobj.h>
#include <corex.h>
#include <autoptr.h>

CRefresherId::CRefresherId()
{
    unsigned long lLen = MAX_COMPUTERNAME_LENGTH + 1;
    m_szMachineName = (LPSTR)CoTaskMemAlloc(lLen);
    if (m_szMachineName)
        GetComputerNameA(m_szMachineName, &lLen);
    else
        throw CX_MemoryException();
    m_dwProcessId = GetCurrentProcessId();
    CoCreateGuid(&m_guidRefresherId);
}
    
CRefresherId::CRefresherId(const WBEM_REFRESHER_ID& Other)
{
    m_szMachineName = (LPSTR)CoTaskMemAlloc(MAX_COMPUTERNAME_LENGTH + 1);
    if (m_szMachineName)
        StringCchCopyA(m_szMachineName, MAX_COMPUTERNAME_LENGTH + 1, Other.m_szMachineName);
    else
        throw CX_MemoryException();
    m_dwProcessId = Other.m_dwProcessId;
    m_guidRefresherId = Other.m_guidRefresherId;
}
    
CRefresherId::~CRefresherId()
{
    CoTaskMemFree(m_szMachineName);
}


CRefreshInfo::CRefreshInfo()
{
    memset(this,0,sizeof(WBEM_REFRESH_INFO));
    m_lType = WBEM_REFRESH_TYPE_INVALID;
}
    
CRefreshInfo::~CRefreshInfo()
{
    if(m_lType == WBEM_REFRESH_TYPE_DIRECT)
    {
        WBEM_REFRESH_INFO_DIRECT& ThisInfo = m_Info.m_Direct;

        if(ThisInfo.m_pRefrMgr)
            ThisInfo.m_pRefrMgr->Release();

		// Free all allocated memory
        CoTaskMemFree(ThisInfo.m_pDirectNames->m_wszNamespace);
        CoTaskMemFree(ThisInfo.m_pDirectNames->m_wszProviderName);
        CoTaskMemFree(ThisInfo.m_pDirectNames);

        if(ThisInfo.m_pTemplate)
           ThisInfo.m_pTemplate->Release();
    }
    else if(m_lType == WBEM_REFRESH_TYPE_CLIENT_LOADABLE)
    {
        CoTaskMemFree(m_Info.m_ClientLoadable.m_wszNamespace);
        if(m_Info.m_ClientLoadable.m_pTemplate)
           m_Info.m_ClientLoadable.m_pTemplate->Release();
    }
    else if(m_lType == WBEM_REFRESH_TYPE_REMOTE)
    {
        if(m_Info.m_Remote.m_pRefresher)
           m_Info.m_Remote.m_pRefresher->Release();
        if(m_Info.m_Remote.m_pTemplate)
           m_Info.m_Remote.m_pTemplate->Release();
    }
    else if(m_lType == WBEM_REFRESH_TYPE_CONTINUOUS)
    {
        CoTaskMemFree(m_Info.m_Continuous.m_wszSharedMemoryName);
    }
    else if(m_lType == WBEM_REFRESH_TYPE_SHARED)
    {
        CoTaskMemFree(m_Info.m_Shared.m_wszSharedMemoryName);
        if(m_Info.m_Shared.m_pRefresher)
            m_Info.m_Shared.m_pRefresher->Release();
    }
    else if(m_lType == WBEM_REFRESH_TYPE_NON_HIPERF)
    {
        CoTaskMemFree(m_Info.m_NonHiPerf.m_wszNamespace);
        if(m_Info.m_NonHiPerf.m_pTemplate)
            m_Info.m_NonHiPerf.m_pTemplate->Release();
    }
}

HRESULT CRefreshInfo::SetRemote(IWbemRemoteRefresher* pRemRef, long lRequestId,
                                IWbemObjectAccess* pTemplate, GUID* pGuid)
{
    m_lType = WBEM_REFRESH_TYPE_REMOTE;
    m_lCancelId = lRequestId;
    m_Info.m_Remote.m_pRefresher = pRemRef;
    if(pRemRef)
        pRemRef->AddRef();
    m_Info.m_Remote.m_pTemplate = pTemplate;
    m_Info.m_Remote.m_guid = *pGuid;
    if(pTemplate)
        pTemplate->AddRef();
    return S_OK;
}

HRESULT CRefreshInfo::SetClientLoadable(REFCLSID rClientClsid, 
                      LPCWSTR wszNamespace, IWbemObjectAccess* pTemplate)
{
    WBEM_WSTR cloned = WbemStringCopy(wszNamespace);
    if (NULL == cloned) return WBEM_E_OUT_OF_MEMORY;
    
    m_lType = WBEM_REFRESH_TYPE_CLIENT_LOADABLE;
    m_lCancelId = 0;
    m_Info.m_ClientLoadable.m_clsid = rClientClsid;
    m_Info.m_ClientLoadable.m_wszNamespace = cloned;
    m_Info.m_ClientLoadable.m_pTemplate = pTemplate;
    if(pTemplate)
        pTemplate->AddRef();
    return S_OK;
}

HRESULT CRefreshInfo::SetDirect(REFCLSID rClientClsid, 
                             LPCWSTR wszNamespace, 
                             LPCWSTR wszProviderName,
                             IWbemObjectAccess* pTemplate,
                             _IWbemRefresherMgr* pMgr )
{
    WBEM_REFRESH_DIRECT_NAMES* pNames = (WBEM_REFRESH_DIRECT_NAMES*) CoTaskMemAlloc( sizeof(WBEM_REFRESH_DIRECT_NAMES) );
    if (NULL == pNames) return WBEM_E_OUT_OF_MEMORY;
    OnDeleteIf<VOID *,VOID(*)(VOID*),CoTaskMemFree> fm1(pNames);

    WBEM_WSTR pTmpNameSpace = (WBEM_WSTR)WbemStringCopy(wszNamespace);
    if (NULL == pTmpNameSpace) return WBEM_E_OUT_OF_MEMORY;
    OnDeleteIf<VOID *,VOID(*)(VOID*),CoTaskMemFree> fm2(pTmpNameSpace);
    
    WBEM_WSTR pTmpProvider = (WBEM_WSTR)WbemStringCopy(wszProviderName);
    if (NULL == pTmpProvider) return WBEM_E_OUT_OF_MEMORY;
    OnDeleteIf<VOID *,VOID(*)(VOID*),CoTaskMemFree> fm3(pTmpProvider);

    fm1.dismiss();
    fm2.dismiss();
    fm3.dismiss();    
        
    m_lType = WBEM_REFRESH_TYPE_DIRECT;
    m_lCancelId = 0;
    m_Info.m_Direct.m_clsid = rClientClsid;
    m_Info.m_Direct.m_pDirectNames = pNames;
    m_Info.m_Direct.m_pDirectNames->m_wszNamespace = pTmpNameSpace;
    m_Info.m_Direct.m_pDirectNames->m_wszProviderName = pTmpProvider;

    m_Info.m_Direct.m_pTemplate = pTemplate;
    m_Info.m_Direct.m_pRefrMgr = pMgr;
    if(pTemplate) pTemplate->AddRef();
    if(pMgr) pMgr->AddRef();

    return S_OK;
}

    
HRESULT CRefreshInfo::SetNonHiPerf(LPCWSTR wszNamespace, IWbemObjectAccess* pTemplate)
{
    WBEM_WSTR pTmp = WbemStringCopy(wszNamespace);
    if (NULL == pTmp) WBEM_E_OUT_OF_MEMORY;
        
    m_lType = WBEM_REFRESH_TYPE_NON_HIPERF;
    m_lCancelId = 0;
    m_Info.m_NonHiPerf.m_wszNamespace = pTmp;
    m_Info.m_NonHiPerf.m_pTemplate = pTemplate;
    if(pTemplate)
        pTemplate->AddRef();
    return S_OK;
}

void CRefreshInfo::SetInvalid()
{
    memset(this,0,sizeof(WBEM_REFRESH_INFO));
    m_lType = WBEM_REFRESH_TYPE_INVALID;
}

/*
fnIcmpCreateFile CIPHelp::IcmpCreateFile_;
fnIcmpCloseHandle CIPHelp::IcmpCloseHandle_;
fnIcmpSendEcho CIPHelp::IcmpSendEcho_;

CIPHelp::CIPHelp():
    bWSAInit(FALSE),
    hIpHlpApi(NULL)
{
    WSADATA wsaData;
    WORD wVersionRequested = MAKEWORD( 2, 2 );

    if (0 != WSAStartup(wVersionRequested,&wsaData)) return;
    bWSAInit = TRUE;

    HMODULE hTmpIpHlpApi = LoadLibraryEx(L"iphlpapi.dll",0,0);
    if (NULL == hTmpIpHlpApi) return;
    OnDeleteIf<HMODULE,BOOL(*)(HMODULE),FreeLibrary> fm(hTmpIpHlpApi);

    IcmpCreateFile_ = (fnIcmpCreateFile)GetProcAddress(hTmpIpHlpApi,"IcmpCreateFile");
    IcmpCloseHandle_ = (fnIcmpCloseHandle)GetProcAddress(hTmpIpHlpApi,"IcmpCloseHandle");
    IcmpSendEcho_= (fnIcmpSendEcho)GetProcAddress(hTmpIpHlpApi,"IcmpSendEcho");

    if (!(IcmpCreateFile_ && IcmpCloseHandle_ && IcmpSendEcho_)) return;
    fm.dismiss();
    hIpHlpApi = hTmpIpHlpApi;    
}

CIPHelp::~CIPHelp()
{
    if (hIpHlpApi) FreeLibrary(hIpHlpApi);
    if (bWSAInit) WSACleanup();
}

BOOL CIPHelp::IsAlive(WCHAR * pMachineName)
{
    if (NULL == hIpHlpApi) return FALSE;
    if (NULL == pMachineName) return FALSE;
    
    DWORD dwLen = wcslen(pMachineName);
    wmilib::auto_buffer<char> pAnsi(new char[1+dwLen]);
    if (NULL == pAnsi.get()) return FALSE;
    
    WideCharToMultiByte(CP_ACP,0,pMachineName,-1,pAnsi.get(),1+dwLen,0,0);
    
    struct hostent * pEnt = gethostbyname(pAnsi.get());
    if (NULL == pEnt) return FALSE;

    in_addr MachineIp;
    memcpy(&MachineIp,pEnt->h_addr,sizeof(MachineIp));

    //char * pString = inet_ntoa(MachineIp);
    // DbgPrintfA(0,"IP: %s\n",pString);

    HANDLE hIcmpFile = IcmpCreateFile_();
    if (INVALID_HANDLE_VALUE == hIcmpFile) return FALSE;
    OnDelete<HANDLE,BOOL(*)(HANDLE),IcmpCloseHandle_> cm(hIcmpFile);

    struct IcmpReplay : ICMP_ECHO_REPLY
    {
        char _data[0x20];
    } TmpIcmpReplay;

    for (int i=0;i<0x20;i++) TmpIcmpReplay._data[i] = 'a'+i;
    
    DWORD nRepl = IcmpSendEcho_(hIcmpFile,
                                MachineIp.S_un.S_addr,
                                &TmpIcmpReplay._data[0],
                                0x20,
                                NULL,
                                &TmpIcmpReplay,
                                sizeof(TmpIcmpReplay),
                                5000);
    if (nRepl > 0 ) return TRUE;
    
    return FALSE;
}

*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\marshalers\coreprox\rfchercd.cpp ===
/*++

Copyright (C) 2000-2001 Microsoft Corporation

Module Name:

    RFCHERCD.CPP

Abstract:

  Refresher cache record implementations.

History:

  24-Apr-2000    sanjes    Created.

--*/

#include "precomp.h"
#include <stdio.h>
#include "fastall.h"
#include <corex.h>
#include "strutils.h"
#include <unk.h>
#include "refrhelp.h"
#include "rfchercd.h"
#include "refrcach.h"
#include "arrtempl.h"
#include <autoptr.h>

// HiPerf Provider record stuff
CHiPerfPrvRecord::CHiPerfPrvRecord( LPCWSTR wszName, 
                                CLSID clsid, 
                                CLSID clsidClient, 
                                CRefresherCache* pRefrCache ):    
    m_wsProviderName( wszName ),
    m_clsid( clsid ),
    m_clsidClient( clsidClient ),
    m_pRefresherCache( pRefrCache ),
    m_lRef( 0 )
{
    if ( NULL != m_pRefresherCache )
    {
        m_pRefresherCache->AddRef();
    }
}

CHiPerfPrvRecord::~CHiPerfPrvRecord( void )
{
    if ( NULL != m_pRefresherCache )
    {
        m_pRefresherCache->Release();
    }
}

long CHiPerfPrvRecord::AddRef( void )
{
    return InterlockedIncrement( &m_lRef );
}

long CHiPerfPrvRecord::Release( void )
{
    long lRef = InterlockedDecrement(&m_lRef);
    if(lRef == 0)
    {
        // The remove call will check that this guy has really been released
        // before axing him.  All functions go through FindRefresherRecord()
        // to get a record, which blocks on the same critical section as
        // remove.  Since it AddRef()s the record before it returns, we
        // are ensured that if a client requests the same record
        // twice and one operation fails, releasing its object, before the
        // other has returned from a Find, that the ref count will get
        // bumped up again, so IsReleased() will fail, and the record won't
        // really be removed.

        m_pRefresherCache->RemoveProviderRecord(this); // deletes
    }
    return lRef;
}

// Provider Record kept inside referesher records
CProviderRecord::CProviderRecord( CHiPerfPrvRecord* pHiPerfRecord, 
                               IWbemHiPerfProvider* pProvider, 
                               IWbemRefresher* pRefresher,
                               _IWmiProviderStack* pProvStack ):
    m_pProvider( pProvider ),
    m_pInternalRefresher( pRefresher ),
    m_pHiPerfRecord( pHiPerfRecord ),
    m_pProvStack( pProvStack ),
    m_lRef(0)
{
    if ( m_pProvider ) m_pProvider->AddRef();
    if ( m_pHiPerfRecord ) m_pHiPerfRecord->AddRef();
    if ( m_pInternalRefresher ) m_pInternalRefresher->AddRef();
    if ( m_pProvStack ) m_pProvStack->AddRef();
}

CProviderRecord::~CProviderRecord( void )
{
    if ( m_pInternalRefresher ) m_pInternalRefresher->Release();
    if ( m_pProvider ) m_pProvider->Release();
    if ( m_pHiPerfRecord ) m_pHiPerfRecord->Release();
    if ( m_pProvStack ) m_pProvStack->Release();
}

long CProviderRecord::AddRef( void )
{
    return InterlockedIncrement( &m_lRef );
}

long CProviderRecord::Release( void )
{
    long    lReturn = InterlockedIncrement( &m_lRef );
    if ( 0 == lReturn ) delete this;
    return lReturn;
}

HRESULT CProviderRecord::AddObjectRequest(
            CWbemObject* pRefreshedObject, long lProviderRequestId, long lNewId)
{
    // Locks and Unlocks going into and coming out of scope
    CInCritSec  ics( &m_cs );

    wmilib::auto_ptr<CObjectRequestRecord> pRequest(new CObjectRequestRecord(lNewId, pRefreshedObject, lProviderRequestId));
    if (NULL == pRequest.get()) return WBEM_E_OUT_OF_MEMORY;
    if ( -1 == m_apRequests.Add(pRequest.get())) return WBEM_E_OUT_OF_MEMORY;
    pRequest.release(); // array took ownership

    return WBEM_S_NO_ERROR;
}

HRESULT CProviderRecord::AddEnumRequest(
            CRemoteHiPerfEnum* pHPEnum, long lProviderRequestId, long lNewId )
{
    // Locks and Unlocks going into and coming out of scope
    CInCritSec  ics( &m_cs );

    wmilib::auto_ptr<CEnumRequestRecord> pRequest(new CEnumRequestRecord(lNewId, pHPEnum, lProviderRequestId));
    if (NULL == pRequest.get()) return WBEM_E_OUT_OF_MEMORY;    
    if ( -1 == m_apEnumRequests.Add(pRequest.get())) return WBEM_E_OUT_OF_MEMORY;
    pRequest.release();

    return WBEM_S_NO_ERROR;
}
    
HRESULT CProviderRecord::Remove(long lId, BOOL* pfIsEnum )
{
    HRESULT hres = WBEM_S_NO_ERROR;

    // Locks and Unlocks going into and coming out of scope
    CInCritSec  ics( &m_cs );

    // Need to know if we axed an enumerator or an actual object
    *pfIsEnum = FALSE;

    // Check object requests, then enum requests
    for(int i = 0; i < m_apRequests.GetSize(); i++)
    {
        CObjectRequestRecord* pRequest = m_apRequests[i];
        if(pRequest->GetExternalRequestId() == lId)
        {
            hres = pRequest->Cancel(this);
            m_apRequests.RemoveAt(i);
            return hres;
        }
    }

    for(i = 0; i < m_apEnumRequests.GetSize(); i++)
    {
        CEnumRequestRecord* pRequest = m_apEnumRequests[i];
        if(pRequest->GetExternalRequestId() == lId)
        {
            hres = pRequest->Cancel(this);
            m_apEnumRequests.RemoveAt(i);
            *pfIsEnum = TRUE;
            return hres;
        }
    }

    return WBEM_S_FALSE;
}

HRESULT CProviderRecord::Find( long lId )
{
    // Locks and Unlocks going into and coming out of scope
    CInCritSec  ics( &m_cs );

    // Check object requests, then enum requests
    for(int i = 0; i < m_apRequests.GetSize(); i++)
    {
        CObjectRequestRecord* pRequest = m_apRequests[i];
        if(pRequest->GetExternalRequestId() == lId)
        {
            return WBEM_S_NO_ERROR;
        }
    }

    for(i = 0; i < m_apEnumRequests.GetSize(); i++)
    {
        CEnumRequestRecord* pRequest = m_apEnumRequests[i];
        if(pRequest->GetExternalRequestId() == lId)
        {
            return WBEM_S_NO_ERROR;
        }
    }

    return WBEM_S_FALSE;
}

HRESULT CProviderRecord::Cancel(long lId)
{
    // Locks and Unlocks going into and coming out of scope
    CInCritSec  ics( &m_cs );

    if(m_pHiPerfRecord)
    {
        // Watch for any exceptions that may get thrown
        try
        {
            return m_pProvider->StopRefreshing(m_pInternalRefresher, lId, 0);
        }
        catch(...)
        {
            return WBEM_E_PROVIDER_FAILURE;
        }
    }

    return WBEM_S_FALSE;
}

HRESULT CProviderRecord::Refresh(long lFlags)
{
    // Locks and Unlocks going into and coming out of scope
    CInCritSec  ics( &m_cs );

    if(m_pInternalRefresher)
    {
        try
        {
            return m_pInternalRefresher->Refresh(0L);
        }
        catch(...)
        {
            // The provider threw an exception.  Just return and let scoping
            // release anything we may be holding onto.

            return WBEM_E_PROVIDER_FAILURE;
        }
    }
    else 
        return WBEM_S_NO_ERROR;
}

HRESULT CProviderRecord::Store(
            WBEM_REFRESHED_OBJECT* aObjects, long* plIndex)
{
    HRESULT hres = WBEM_S_NO_ERROR;

    // Locks and Unlocks going into and coming out of scope
    CInCritSec  ics( &m_cs );

    // Error out if anything beefs

    // First handle the single objects, then we'll get the
    // enumerations
    for(int i = 0; SUCCEEDED( hres ) && i < m_apRequests.GetSize(); i++)
    {
        CObjectRequestRecord* pRequest = m_apRequests[i];
        CWbemInstance* pInst = (CWbemInstance*)pRequest->GetRefreshedObject();
        WBEM_REFRESHED_OBJECT* pRefreshed = aObjects + *plIndex;

        hres = pInst->GetTransferBlob(&(pRefreshed->m_lBlobType), 
                &(pRefreshed->m_lBlobLength), &(pRefreshed->m_pbBlob));

        if ( SUCCEEDED( hres ) )
        {
            pRefreshed->m_lRequestId = pRequest->GetExternalRequestId();
            (*plIndex)++;
        }
        else
        {
            // Clear all data in case of failure
            ZeroMemory( pRefreshed, sizeof(WBEM_REFRESHED_OBJECT) );
        }
    }

    // Now handle the enumerations.  Each enum will create an array
    // of BLOBs
    for( i = 0; SUCCEEDED( hres ) && i < m_apEnumRequests.GetSize(); i++)
    {
        CEnumRequestRecord* pRequest = m_apEnumRequests[i];

        WBEM_REFRESHED_OBJECT* pRefreshed = aObjects + *plIndex;
        hres = pRequest->GetEnum()->GetTransferArrayBlob( &(pRefreshed->m_lBlobType), 
                    &(pRefreshed->m_lBlobLength), &(pRefreshed->m_pbBlob) );

        if ( SUCCEEDED( hres ) )
        {
            pRefreshed->m_lRequestId = pRequest->GetExternalRequestId();
            (*plIndex)++;
        }
        else
        {
            // Clear all data in case of failure
            ZeroMemory( pRefreshed, sizeof(WBEM_REFRESHED_OBJECT) );
        }

    }

    // We need to cleanup any allocated sub-blobs now
    if ( FAILED( hres ) )
    {
        for ( int x = 0; x < *plIndex; x++ )
        {
            WBEM_REFRESHED_OBJECT* pRefreshed = aObjects + x;

            if ( NULL != pRefreshed->m_pbBlob )
            {
                CoTaskMemFree( pRefreshed->m_pbBlob );
                pRefreshed->m_pbBlob = NULL;
            }

        }   // FOR x

    }   // IF FAILED(hres


    return hres;
}

//*****************************************************************************
//                         OBJECT REQUEST RECORD
//*****************************************************************************
//*****************************************************************************

CObjectRequestRecord::CObjectRequestRecord(
        long lExternalRequestId,
        CWbemObject* pRefreshedObject,
        long lProviderRequestId)
    : 
        CRequestRecord(lExternalRequestId), 
        m_pRefreshedObject(pRefreshedObject),
        m_lInternalRequestId(lProviderRequestId)
{
    if(m_pRefreshedObject)
        m_pRefreshedObject->AddRef();
}
        
HRESULT CObjectRequestRecord::Cancel(
                                CProviderRecord* pContainer)
{
    return pContainer->Cancel(m_lInternalRequestId);
}

CObjectRequestRecord::~CObjectRequestRecord()
{
    if(m_pRefreshedObject)
        m_pRefreshedObject->Release();
}

//*****************************************************************************
//*****************************************************************************
//                         ENUM REQUEST RECORD
//*****************************************************************************
//*****************************************************************************

CEnumRequestRecord::CEnumRequestRecord(
        long lExternalRequestId,
        CRemoteHiPerfEnum* pHPEnum,
        long lProviderRequestId)
    : 
        CRequestRecord(lExternalRequestId), 
        m_pHPEnum(pHPEnum),
        m_lInternalRequestId(lProviderRequestId)
{
    if(m_pHPEnum)
        m_pHPEnum->AddRef();
}
        
HRESULT CEnumRequestRecord::Cancel( CProviderRecord* pContainer)
{
    return pContainer->Cancel(m_lInternalRequestId);
}

CEnumRequestRecord::~CEnumRequestRecord()
{
    if(m_pHPEnum)
        m_pHPEnum->Release();
}

//*****************************************************************************
//*****************************************************************************
//                         REMOTE HIPERF ENUM SUPPORT
//*****************************************************************************
//*****************************************************************************

CRemoteHiPerfEnum::CRemoteHiPerfEnum()
{
}

CRemoteHiPerfEnum::~CRemoteHiPerfEnum()
{
}

HRESULT CRemoteHiPerfEnum::GetTransferArrayBlob( long *plBlobType, long *plBlobLen, BYTE** ppBlob)
{
    // This is the correct BLOB type.  Beware 800 series was sending WBEM_BLOB_TYPE_ENUM for everything
    *plBlobType = WBEM_BLOB_TYPE_ENUM;

    HRESULT hr = WBEM_S_NO_ERROR;
    long    lBuffSize = 0,
            lLastBuffSize = 0,
            lNumObjects = 0;
    BYTE*   pData = NULL;

    // initial values
    *ppBlob = pData;
    *plBlobLen = lBuffSize;

     // Get through the lock first
    CHiPerfLockAccess   lock( m_Lock );
    if ( !lock.IsLocked() ) return WBEM_S_TIMEDOUT;
        
    // Make sure we have objects to enumerate
    if ( m_aIdToObject.Size() > 0 )
    {
        // Enumerate the objects in the array and add up the size of the
        // buffer we will have to allocate
        for ( DWORD dwCtr = 0; dwCtr < m_aIdToObject.Size(); dwCtr++ )
        {
            CWbemInstance*  pInst = (CWbemInstance*) ((CHiPerfEnumData*) m_aIdToObject[dwCtr])->m_pObj;;

            // Buffer Size
            lLastBuffSize = pInst->GetTransferArrayBlobSize();

            // Skip zero length
            if ( 0 != lLastBuffSize )
            {
                lBuffSize += lLastBuffSize;
                lNumObjects++;
            }
        }

        // Make sure we have a size to work with
        if ( lBuffSize > 0 )
        {
            long    lTempBuffSize = lBuffSize;

            // Entire buffer is prepended by a number of objects and a version
            lBuffSize += CWbemInstance::GetTransferArrayHeaderSize();

            // May require CoTaskMemAlloc()
            pData = (BYTE*) CoTaskMemAlloc( lBuffSize );

            if ( NULL != pData )
            {
                BYTE*   pTemp = pData;

                // Now write the header
                CWbemInstance::WriteTransferArrayHeader( lNumObjects, &pTemp );

                // Now enumerate the objects and transfer into the array BLOB
                for ( dwCtr = 0; SUCCEEDED(hr) && dwCtr < m_aIdToObject.Size(); dwCtr++ )
                {
                    CWbemInstance*  pInst = (CWbemInstance*) ((CHiPerfEnumData*) m_aIdToObject[dwCtr])->m_pObj;

                    lLastBuffSize = pInst->GetTransferArrayBlobSize();

                    if ( lLastBuffSize > 0 )
                    {
                        long    lUsedSize;
                        hr = pInst->GetTransferArrayBlob( lTempBuffSize, &pTemp, &lUsedSize );

#ifdef _DEBUG
                        // During DEBUG HeapValidate our BLOB
                        HeapValidate( GetProcessHeap(), 0, pData );
#endif

                        // Account for BLOB size used

                        if ( SUCCEEDED( hr ) )
                        {
                            lTempBuffSize -= lUsedSize;
                        }
                    }

                }   // FOR dwCtr

                // Cleanup if things exploded, otherwise perform garbage collection
                if ( FAILED( hr ) )
                {
                    CoTaskMemFree( pData );
                    pData = NULL;
                    lBuffSize = 0;
                }
                else
                {
                    // if everything is okay, go ahead and do any necessary garbage collection on
                    // our arrays.

                    m_aReusable.GarbageCollect();
                }
            }
            else
            {
                hr = WBEM_E_OUT_OF_MEMORY;
            }

        }   // IF lBuffSize > 0

    }   // IF Size() > 0
        
    // Make sure we store appropriate data
    *ppBlob = pData;
    *plBlobLen = lBuffSize;

    return hr;

}

//*****************************************************************************
//*****************************************************************************
//                          REFRESHER RECORD
//*****************************************************************************
//*****************************************************************************

CRefresherRecord::CRefresherRecord(const WBEM_REFRESHER_ID& Id, CRefresherCache* pRefrCache,
                                IUnknown* pLockMgr )
    : m_Id(Id), m_lRefCount(0), m_lNumObjects(0), m_lNumEnums(0), m_lLastId( 0 ),
    m_pRefresherCache( pRefrCache ), m_pLockMgr( pLockMgr )
{
    // We need a guid to uniquely identify this bad boy for remote auto-connect
    CoCreateGuid( &m_Guid );

    if ( NULL != m_pRefresherCache )
    {
        m_pRefresherCache->AddRef();
    }

    if ( NULL != m_pLockMgr )
    {
        m_pLockMgr->AddRef();
    }
}

CRefresherRecord::~CRefresherRecord( void )
{
    if ( NULL != m_pRefresherCache )
    {
        m_pRefresherCache->Release();
    }

    if ( NULL != m_pLockMgr )
    {
        m_pLockMgr->Release();
    }

}

INTERNAL HRESULT 
CRefresherRecord::AddProvider( CHiPerfPrvRecord* pHiPerfRecord,
                            IWbemHiPerfProvider* pProvider,
                            IWbemRefresher* pRefresher,
                            _IWmiProviderStack* pProvStack,
                            CProviderRecord** ppRecord )
{
    if (NULL == ppRecord) return WBEM_E_INVALID_PARAMETER;
    // Locks and Unlocks going into and coming out of scope
    CInCritSec  ics( &m_cs );

    wmilib::auto_ptr<CProviderRecord> pProvRecord(new CProviderRecord( pHiPerfRecord, pProvider, pRefresher, pProvStack ));
    if (NULL == pProvRecord.get()) return WBEM_E_OUT_OF_MEMORY;
    if ( m_apProviders.Add( pProvRecord.get() ) < 0 ) return WBEM_E_OUT_OF_MEMORY;
    
    *ppRecord = pProvRecord.release();
    return WBEM_S_NO_ERROR;
}

INTERNAL CProviderRecord* 
CRefresherRecord::FindProviderRecord( CLSID clsid, IWbemHiPerfProvider** ppProvider /* = NULL */ )
{
    // Locks and Unlocks going into and coming out of scope
    CInCritSec  ics( &m_cs );

    for(int i = 0; i < m_apProviders.GetSize(); i++)
    {
        CProviderRecord* pProvRecord = m_apProviders[i];
        if(pProvRecord->GetClsid() == clsid)
        {
            if (ppProvider ) *ppProvider = pProvRecord->GetProvider();
            return pProvRecord;
        }
    }
    if (ppProvider) *ppProvider = NULL;
    return NULL;
}
    

HRESULT CRefresherRecord::Remove(long lId)
{
    // Locks and Unlocks going into and coming out of scope
    CInCritSec  ics( &m_cs );

    // Find it first
    // =============

    for(int i = 0; i < m_apProviders.GetSize(); i++)
    {
        CProviderRecord* pProvRecord = m_apProviders[i];
        BOOL    fIsEnum = FALSE;
        HRESULT hres = pProvRecord->Remove( lId, &fIsEnum );

        if(hres == WBEM_S_FALSE) continue;
        if(FAILED(hres)) return hres;
    
        // Found it
        // ========

        if(pProvRecord->IsEmpty())
            m_apProviders.RemoveAt(i);

        // Decrememt the proper counter
        if ( fIsEnum )
        {
            m_lNumEnums--;
        }
        else
        {
            m_lNumObjects--;
        }

        return WBEM_S_NO_ERROR;
    }
    return WBEM_S_FALSE;
}
    
ULONG STDMETHODCALLTYPE CRefresherRecord::AddRef()
{
    int x = 1;
    return InterlockedIncrement(&m_lRefCount);
}

ULONG STDMETHODCALLTYPE CRefresherRecord::Release()
{
    long lRef = InterlockedDecrement(&m_lRefCount);
    if(lRef == 0)
    {
        // The remove call will check that this guy has really been released
        // before axing him.  All functions go through FindRefresherRecord()
        // to get a record, which blocks on the same critical section as
        // remove.  Since it AddRef()s the record before it returns, we
        // are ensured that if a client requests the same record
        // twice and one operation fails, releasing its object, before the
        // other has returned from a Find, that the ref count will get
        // bumped up again, so IsReleased() will fail, and the record won't
        // really be removed.

        m_pRefresherCache->RemoveRefresherRecord(this); // deletes
    }
    return lRef;
}

STDMETHODIMP CRefresherRecord::QueryInterface(REFIID riid, 
                                                            void** ppv)
{
    if(riid == IID_IUnknown || riid == IID_IWbemRemoteRefresher)
    {
        AddRef();
        *ppv = (IWbemRemoteRefresher*)this;
        return S_OK;
    }
    else if(riid == IID_IWbemRefresher)
    {
        AddRef();
        *ppv = (IWbemRefresher*)this;
        return S_OK;
    }
    else 
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
}

STDMETHODIMP CRefresherRecord::Refresh(long lFlags)
{
    // Locks and Unlocks going into and coming out of scope
    CInCritSec  ics( &m_cs );

    // Go through all our providers and refresh them
    // =============================================

    long lObjectIndex = 0;
    HRESULT hres;
    for(int i = 0; i < m_apProviders.GetSize(); i++)  
    {
        CProviderRecord* pProvRecord = m_apProviders[i];
        hres = pProvRecord->Refresh(lFlags);
        if(FAILED(hres)) return hres;
    }

    return WBEM_S_NO_ERROR;
}

STDMETHODIMP CRefresherRecord::RemoteRefresh(
                                    long lFlags, long* plNumObjects, 
                                    WBEM_REFRESHED_OBJECT** paObjects)
{
    HRESULT hres = WBEM_S_NO_ERROR;

    // Locks and Unlocks going into and coming out of scope
    CInCritSec  ics( &m_cs );

    // Use CoTaskMemAlloc()?
    if(paObjects)
    {
        // Original code
        //*paObjects = new WBEM_REFRESHED_OBJECT[m_lNumObjects];
        *paObjects = (WBEM_REFRESHED_OBJECT*) CoTaskMemAlloc( ( m_lNumObjects + m_lNumEnums ) * sizeof(WBEM_REFRESHED_OBJECT));

        if ( NULL != *paObjects )
        {
            // Zero out the BLOB
            ZeroMemory( *paObjects, ( m_lNumObjects + m_lNumEnums ) * sizeof(WBEM_REFRESHED_OBJECT) );
        }
        else
        {
            return WBEM_E_OUT_OF_MEMORY;
        }
    }

    // This value needs to reflect the number of objects as well as the number of enumerators we are shipping
    // back to the client.

    if(plNumObjects)
    {
        *plNumObjects = m_lNumObjects + m_lNumEnums;
    }

    // Go through all our providers and refresh them
    // =============================================

    long    lObjectIndex = 0;
    HRESULT hrFirstRefresh = WBEM_S_NO_ERROR;
    BOOL    fOneSuccess = FALSE;
    BOOL    fOneRefresh = FALSE;
    BOOL    fPartialSuccess = FALSE;

    for(int i = 0; i < m_apProviders.GetSize(); i++)  
    {
        CProviderRecord* pProvRecord = m_apProviders[i];
        hres = pProvRecord->Refresh(lFlags);
    
        if ( SUCCEEDED( hres ) )
        {
            if(paObjects)
            {
                // Store the result
                // ================

                hres = pProvRecord->Store(*paObjects, &lObjectIndex);

                // If this fails, we will consider this catastrophic, since the
                // only reason this would fail is under out of memory conditions,
                // and in that case, since we are remoting, all sorts of things
                // could go wrong, so if this breaks, just cleanup and bail out.

                if ( FAILED( hres ) )
                {
                    if ( *paObjects )
                    {
                        CoTaskMemFree( *paObjects );
                        *paObjects = NULL;
                    }
                    
                    *plNumObjects = 0;

                    return hres;
                }

            }   // IF NULL != paObjects

        }   // IF Refresh Succeeded

        // Always keep the first return code.  We also need to track
        // whether or not we had at least one success, as well as if
        // the partial flag should be set.

        if ( !fOneRefresh )
        {
            fOneRefresh = TRUE;
            hrFirstRefresh = hres;
        }

        // All other codes indicate something went awry
        if ( WBEM_S_NO_ERROR == hres )
        {
            fOneSuccess = TRUE;

            // A prior refresh may have failed, a later one didn't
            if ( fOneRefresh && WBEM_S_NO_ERROR != hrFirstRefresh )
            {
                fPartialSuccess = TRUE;
            }
        }
        else if ( fOneSuccess )
        {
            // We must have had at least one success for the partial success
            // flag to be set.

            fPartialSuccess = TRUE;
        }

    }   // FOR enum providers

    // At this point, if the partial success flag is set, that will
    // be our return.  If we didn't have at least one success,  then
    // the return code will be the first one we got back. Otherwise,
    // hres should contain the proper value

    if ( fPartialSuccess )
    {
        hres = WBEM_S_PARTIAL_RESULTS;
    }
    else if ( !fOneSuccess )
    {
        hres = hrFirstRefresh;
    }

    // Finally, if the object index is less than the number of array elements we "thought"
    // we would be sending back, make sure we reflect this.  If it is zero, just delete the
    // elements (we wouldn't have allocated any sub-buffers anyway).  Since
    // *plNumObjects is a sizeof, only *plNumObjects elements will be sent back, although
    // CoTaskMemFree() should cleanup the entire array buffer.

    if ( lObjectIndex != *plNumObjects )
    {
        *plNumObjects = lObjectIndex;

        if ( 0 == lObjectIndex )
        {
            if ( *paObjects )
            {
                CoTaskMemFree( *paObjects );
                *paObjects = NULL;
            }

        }

    }

    return hres;
}
            
STDMETHODIMP CRefresherRecord::StopRefreshing(
                        long lNumIds, long* aplIds, long lFlags)
{
    // Locks and Unlocks going into and coming out of scope
    CInCritSec  ics( &m_cs );

    HRESULT hr = WBEM_S_NO_ERROR;
    HRESULT hrFirst = WBEM_S_NO_ERROR;
    BOOL    fOneSuccess = FALSE;
    BOOL    fOneRemove = FALSE;
    BOOL    fPartialSuccess = FALSE;

    for ( long lCtr = 0; lCtr < lNumIds; lCtr++ )
    {
        hr = Remove( aplIds[lCtr] );

        if ( !fOneRemove )
        {
            hrFirst = hr;
            fOneRemove = TRUE;
        }

        // Record the fact we got at least one success if we got one
        // All other codes indicate something went awry
        if ( WBEM_S_NO_ERROR == hr )
        {
            fOneSuccess = TRUE;

            // A prior refresh may have failed, a later one didn't
            if ( fOneRemove && WBEM_S_NO_ERROR != hrFirst )
            {
                fPartialSuccess = TRUE;
            }
        }
        else if ( fOneSuccess )
        {
            // We must have had at least one success for the partial success
            // flag to be set.

            fPartialSuccess = TRUE;
        }

    }   // FOR enum ids

    // At this point, if the partial success flag is set, that will
    // be our return.  If we didn't have at least one success,  then
    // the return code will be the first one we got back. Otherwise,
    // hres should contain the proper value

    if ( fPartialSuccess )
    {
        hr = WBEM_S_PARTIAL_RESULTS;
    }
    else if ( !fOneSuccess )
    {
        hr = hrFirst;
    }

    return hr;
}

STDMETHODIMP CRefresherRecord::GetGuid(
                        long lFlags, GUID* pGuid )
{
    
    if ( 0L != lFlags || NULL == pGuid )
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    *pGuid = m_Guid;

    return WBEM_S_NO_ERROR;

}

//*****************************************************************************
//*****************************************************************************
//                              REMOTE RECORD
//*****************************************************************************
//*****************************************************************************

CRemoteRecord::CRemoteRecord( const WBEM_REFRESHER_ID& Id, 
                             CRefresherCache* pRefrCache,
                             IUnknown* pLockMgr )
    : CRefresherRecord( Id, pRefrCache, pLockMgr )
{
}

CRemoteRecord::~CRemoteRecord()
{
}

HRESULT CRemoteRecord::GetProviderRefreshInfo(
                                CHiPerfPrvRecord* pHiPerfRecord,
                                IWbemHiPerfProvider* pProvider,
                                IWbemServices* pNamespace,
                                CProviderRecord** ppProvRecord,
                                IWbemRefresher** ppRefresher )
{
    HRESULT hres = WBEM_S_NO_ERROR;

    // Get a refresher from the provider, unless already available
    // ===========================================================

    *ppProvRecord = FindProviderRecord( pHiPerfRecord->GetClsid() );

    // We couldn't find the record so make sure we are able to get a refresher
    if ( NULL == *ppProvRecord )
    {
        try
        {
            hres = pProvider->CreateRefresher( pNamespace, 0, ppRefresher );

            if ( SUCCEEDED(hres) && NULL == *ppRefresher )
            {
                hres = WBEM_E_PROVIDER_FAILURE;
            }
        }
        catch(...)
        {
            // The provider threw an exception.  Just return and let scoping
            // release anything we may be holding onto.

            return WBEM_E_PROVIDER_FAILURE;
        }
    }
    else
    {
        // Get the refresher pointer and AddRef it
        *ppRefresher = (*ppProvRecord)->GetInternalRefresher();
        if(*ppRefresher)
        {
            (*ppRefresher)->AddRef();
        }
    }

    return hres;
}

HRESULT 
CRemoteRecord::AddObjectRefresher(
                    CHiPerfPrvRecord* pHiPerfRecord,
                    IWbemHiPerfProvider* pProvider,
                    _IWmiProviderStack* pProvStack,
                    IWbemServices* pNamespace,
                    LPCWSTR pwszServerName, LPCWSTR pwszNamespace,
                    CWbemObject* pInstTemplate, long lFlags, 
                    IWbemContext* pContext,
                    CRefreshInfo* pInfo)
{
    // Enters and Leaves as a byproduct of scoping
    CInCritSec  ics(&m_cs);

    // Get a refresher from the provider, unless already available
    // ===========================================================

    IWbemRefresher* pProvRefresher = NULL;
    CProviderRecord* pProvRecord = NULL;

    HRESULT hres = GetProviderRefreshInfo( pHiPerfRecord, pProvider, pNamespace, &pProvRecord, &pProvRefresher );

    // Always release going out of scope
    CReleaseMe  rmRefresh( pProvRefresher );

    if ( SUCCEEDED( hres ) )
    {
        // Call provider for information
        // =============================

        IWbemObjectAccess* pRefreshedOA = NULL;
        long lProvRequestId;

        // Now try to add the object

        try
        {
            hres = pProvider->CreateRefreshableObject(
                    pNamespace, pInstTemplate, pProvRefresher,
                    0, pContext, &pRefreshedOA,
                    &lProvRequestId);
        }
        catch(...)
        {
            // The provider threw an exception.  Just return and let scoping
            // release anything we may be holding onto.

            return WBEM_E_PROVIDER_FAILURE;
        }

        // Always release going out of scope
        CReleaseMe  rmRefreshed( pRefreshedOA );

        CWbemObject* pRefreshedObject = (CWbemObject*)pRefreshedOA;
        CWbemObject* pClientObject = NULL;

        if ( SUCCEEDED( hres ) )
        {

            // The object we return to the client, since we are remote, should
            // contain amended qualifiers if we are using localization, so to make
            // sure of this, we will clone an object off of the pInstTemplate and
            // the copy the instance data from the object the provider returned
            // to us. The provider can refresh the object it gave to us, since
            // we will only be sending the instance part

            hres = pInstTemplate->Clone( (IWbemClassObject**) &pClientObject );

            if ( SUCCEEDED( hres ) )
            {
                hres = pClientObject->CopyBlobOf( pRefreshedObject );

                if ( SUCCEEDED( hres ) )
                {
                    hres = pClientObject->SetDecoration( pwszServerName, pwszNamespace );
                }

            }   // IF Clones

        }   // IF Object Created

        // Release going out of scope
        CReleaseMe  rmClient( (IWbemClassObject*) pClientObject );

        if ( SUCCEEDED( hres ) )
        {
            // Add a new provider record if necessary
            if(pProvRecord == NULL)
            {
                hres = AddProvider( pHiPerfRecord, pProvider,
                                    pProvRefresher, pProvStack,
                                    &pProvRecord );
            }

            // Now we will add the actual request
            if ( SUCCEEDED( hres ) )
            {

                // Generate the new id from our datamember
                long    lNewId = GetNewRequestId();

                hres = pProvRecord->AddObjectRequest(pRefreshedObject, lProvRequestId, lNewId );

                if ( SUCCEEDED( hres ) )
                {
                    m_lNumObjects++;
                    pInfo->SetRemote(this, lNewId, pClientObject, &m_Guid);
                }

            }   // IF we have a provider record

        }   // IF created a client object


    }   // IF Got refresher


    return hres;
}

HRESULT CRemoteRecord::AddEnumRefresher(
                    CHiPerfPrvRecord* pHiPerfRecord,
                    IWbemHiPerfProvider* pProvider,
                    _IWmiProviderStack* pProvStack,
                    IWbemServices* pNamespace,
                    CWbemObject* pInstTemplate,
                    LPCWSTR wszClass, long lFlags, 
                    IWbemContext* pContext,
                    CRefreshInfo* pInfo)
{
    // Enters and Leaves as a byproduct of scoping
    CInCritSec  ics(&m_cs);

    // Get a refresher from the provider, unless already available
    // ===========================================================

    IWbemRefresher* pProvRefresher = NULL;
    CProviderRecord* pProvRecord = NULL;

    HRESULT hres = GetProviderRefreshInfo( pHiPerfRecord, pProvider, pNamespace, &pProvRecord, &pProvRefresher );

    // Always release going out of scope
    CReleaseMe  rmRefresh( pProvRefresher );

    if ( SUCCEEDED( hres ) )
    {
        // Call provider for information
        // =============================

        // Create a HiPerf Enumerator (We know we will need one
        // of these since we will only be in this code when we
        // go remote).
        CRemoteHiPerfEnum*  pHPEnum = new CRemoteHiPerfEnum;
        if (NULL == pHPEnum) return WBEM_E_OUT_OF_MEMORY;

        // Bump up the RefCount
        pHPEnum->AddRef();

        // Release this pointer when we drop out of scope
        CReleaseMe  rm( pHPEnum );

        // The enumerator will need to know this
        hres = pHPEnum->SetInstanceTemplate( (CWbemInstance*) pInstTemplate );

        if ( FAILED(hres) ) return hres;

        long lProvRequestId = 0;
        try
        {
            hres = pProvider->CreateRefreshableEnum(
                    pNamespace, wszClass, pProvRefresher,
                    0, pContext, pHPEnum, &lProvRequestId);
        }
        catch(...)
        {
            // The provider threw an exception.  Just return and let scoping
            // release anything we may be holding onto.

            return WBEM_E_PROVIDER_FAILURE;
        }

        // Add a new provider record if we need one
        if( SUCCEEDED( hres ) && ( pProvRecord == NULL ) )
        {
            hres = AddProvider( pHiPerfRecord, pProvider,
                               pProvRefresher, pProvStack,
                               &pProvRecord);
        }

        // Now we will add the actual request
        if ( SUCCEEDED( hres ) )
        {

            // Generate the new id from our datamember
            long    lNewId = GetNewRequestId();

            hres = pProvRecord->AddEnumRequest( pHPEnum, lProvRequestId, lNewId );

            if ( SUCCEEDED( hres ) )
            {
                m_lNumEnums++;
                hres = pInfo->SetRemote(this, lNewId, pInstTemplate, &m_Guid);
            }

        }   // IF we have a provider record
    }   // IF Got Refresher

    return hres;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\marshalers\coreprox\shmlock.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    SHMLOCK.H

Abstract:

    Shared Memory Lock

History:

--*/

#ifndef __SHARED_MEMORY_LOCK__H_
#define __SHARED_MEMORY_LOCK__H_

struct  COREPROX_POLARITY SHARED_LOCK_DATA
{
    long m_lLock;
    long m_lLockCount;
    DWORD m_dwThreadId;

    SHARED_LOCK_DATA() : m_lLock(-1), m_dwThreadId(0), m_lLockCount(0){}
};

class COREPROX_POLARITY CSharedLock
{
protected:
    volatile SHARED_LOCK_DATA* m_pData;
public:
    inline BOOL Lock(DWORD dwTimeout = 0xFFFFFFFF)
    {
        int        nSpin = 0;
        BOOL    fAcquiredLock = FALSE,
                fIncDec = FALSE;

        // Only do this once
        DWORD    dwCurrentThreadId = GetCurrentThreadId();

        // Check if we are the current owning thread.  We can do this here because
        // this test will ONLY succeed in the case where we have a Nested Lock(),
        // AND because we are zeroing out the thread id when the lock count hits
        // 0.

        if( dwCurrentThreadId == m_pData->m_dwThreadId )
        {
            // It's us - Bump the lock count
            // =============================

            // Don't need to use InterlockedInc/Dec here because
            // this will ONLY happen on m_pData->m_dwThreadId.

            ++(m_pData->m_lLockCount);
            return TRUE;
        }

    DWORD dwFirstTick = 0;
        while( !fAcquiredLock )
        {

            // We only increment/decrement when m_pData->m_lLock is -1
            if ( m_pData->m_lLock == -1 )
            {
                fIncDec = TRUE;

                // Since only one thread will get the 0, it is this thread that
                // actually acquires the lock.
                fAcquiredLock = ( InterlockedIncrement( &(m_pData->m_lLock) ) == 0 );
            }
            else
            {

                fIncDec = FALSE;
            }

            // Only spins if we don't acquire the lock
            if ( !fAcquiredLock )
            {

                // Clean up our Incremented value only if we actually incremented
                // it to begin with
                if ( fIncDec )
                    InterlockedDecrement(&(m_pData->m_lLock));

                // to spin or not to spin
                if(nSpin++ == 10000)
                {
                    // Check for timeout
                    // DEVNOTE:TODO:SANJ - What if tick count rollsover??? a timeout will occur.
                    // not too critical.

                    if ( dwTimeout != 0xFFFFFFFF)
                    {
                        if ( dwFirstTick != 0 )
                        {
                            if ( ( GetTickCount() - dwFirstTick ) > dwTimeout )
                            {
                                return FALSE;    // Timed Out
                            }else if (GetTickCount() < dwFirstTick) 
                            {
                                dwTimeout -=(0xFFFFFFFF - dwFirstTick);
                                dwFirstTick = 0;
                            }
                            
                        }
                        else
                        {
                            dwFirstTick = GetTickCount();
                        }
                    }
                    // We've been spinning long enough --- yield
                    // =========================================
                    Sleep(0);
                    nSpin = 0;
                }

                // The rule is that if this is switched out it must ONLY be done with
                // a new data block and not one that has been used for locking elsewhere.

            }    // IF !fAcquiredLock

        }    // WHILE !fAcquiredLock

        // We got the lock so increment the lock count.  Again, we are not
        // using InterlockedInc/Dec since this should all only occur on a
        // single thread.

        ++(m_pData->m_lLockCount);
            m_pData->m_dwThreadId = dwCurrentThreadId;

        return TRUE;
    }

    inline BOOL Unlock()
    {
        // SINCE we assume this is happening on a single thread, we can do this
        // without calling InterlockedInc/Dec.  When the value hits zero, at that
        // time we are done with the lock and can zero out the thread id and
        // decrement the actual lock test value.

        if ( --(m_pData->m_lLockCount) == 0 )
        {
            m_pData->m_dwThreadId = 0;
            InterlockedDecrement((long*)&(m_pData->m_lLock));
        }

        return TRUE;
    }

    void SetData(SHARED_LOCK_DATA* pData)
    {
        m_pData = pData;
    }
};


//    CHiPerfLock:
//    This is a simple spinlock we are using for hi performance synchronization of
//    IWbemHiPerfProvider, IWbemHiPerfEnum, IWbemRefresher and IWbemConfigureRefresher
//    interfaces.  The important thing here is that the Lock uses InterlockedIncrement()
//    and InterlockedDecrement() to handle its lock as opposed to a critical section.
//    It does have a timeout, which currently defaults to 10 seconds.

#define    HIPERF_DEFAULT_TIMEOUT    10000

class COREPROX_POLARITY CHiPerfLock
{
    SHARED_LOCK_DATA  m_pData;
    CSharedLock    theLock;
public:
    CHiPerfLock() { theLock.SetData(&m_pData);}
    BOOL Lock( DWORD dwTimeout = HIPERF_DEFAULT_TIMEOUT )
    {
        return theLock.Lock(dwTimeout );
    }

	BOOL Unlock()
	{
		return theLock.Unlock();
	}
};


class CHiPerfLockAccess
{
public:

    CHiPerfLockAccess( CHiPerfLock & Lock , DWORD dwTimeout = HIPERF_DEFAULT_TIMEOUT )
        :    m_Lock( Lock ), m_bIsLocked( FALSE )
    {
           m_bIsLocked = m_Lock.Lock( dwTimeout );
    }

    ~CHiPerfLockAccess()
    {
        if (IsLocked())   m_Lock.Unlock();
    }

    BOOL IsLocked( void ) {  return m_bIsLocked;}
private:
    CHiPerfLock &    m_Lock;
    BOOL            m_bIsLocked;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\marshalers\coreprox\refrsvc.cpp ===
/*++

Copyright (C) 2000-2001 Microsoft Corporation

Module Name:

    REFRSVC.CPP

Abstract:

  CWbemRefreshingSvc implementation.

  Implements the IWbemRefreshingServices interface.

History:

  24-Apr-2000    sanjes    Created.

--*/

#include "precomp.h"
#include <stdio.h>
#include "fastall.h"
#include <corex.h>
#include "strutils.h"
#include <unk.h>
#include "refrhelp.h"
#include "refrsvc.h"
#include "arrtempl.h"
#include "scopeguard.h"

//***************************************************************************
//
//  CWbemRefreshingSvc::CWbemRefreshingSvc
//
//***************************************************************************
// ok
CWbemRefreshingSvc::CWbemRefreshingSvc( CLifeControl* pControl, IUnknown* pOuter )
:    CUnk( pControl, pOuter ),
    m_pSvcEx( NULL ),
    m_pstrMachineName( NULL ),
    m_pstrNamespace( NULL ),
    m_XWbemRefrSvc( this ),
    m_XCfgRefrSrvc(this)
{
    if ( NULL != pOuter )
    {
        if ( SUCCEEDED( pOuter->QueryInterface( IID_IWbemServices, (void**) &m_pSvcEx ) ) )
        {
            // It's aggregated us, so we shouldn't keep it Addref'd lest we cause
            // a circular reference.
            m_pSvcEx->Release();
        }

    }

    // Establish the refresher manager pointer now

}
    
//***************************************************************************
//
//  CWbemRefreshingSvc::~CWbemRefreshingSvc
//
//***************************************************************************
// ok
CWbemRefreshingSvc::~CWbemRefreshingSvc()
{
    // Cleanup.  Don't worry about the Svc Ex pointer, since this
    // will be aggregating us
    SysFreeString( m_pstrMachineName );
    SysFreeString( m_pstrNamespace );
}

// Override that returns us an interface
void* CWbemRefreshingSvc::GetInterface( REFIID riid )
{
    if(riid == IID_IUnknown || riid == IID_IWbemRefreshingServices)
        return &m_XWbemRefrSvc;
    else if ( riid == IID__IWbemConfigureRefreshingSvcs )
        return &m_XCfgRefrSrvc;
    else
        return NULL;
}

// Pass thru _IWbemConfigureRefreshingSvc implementation
STDMETHODIMP CWbemRefreshingSvc::XCfgRefrSrvc::SetServiceData( BSTR pwszMachineName, BSTR pwszNamespace )
{
    return m_pObject->SetServiceData( pwszMachineName, pwszNamespace );
}

STDMETHODIMP CWbemRefreshingSvc::XWbemRefrSvc::AddEnumToRefresher( WBEM_REFRESHER_ID* pRefresherId, LPCWSTR wszClass, long lFlags,
            IWbemContext* pContext, DWORD dwClientRefrVersion, WBEM_REFRESH_INFO* pInfo, DWORD* pdwSvrRefrVersion)
{
    return m_pObject->AddEnumToRefresher( pRefresherId, wszClass, lFlags, pContext, dwClientRefrVersion,
                                            pInfo, pdwSvrRefrVersion );
}

// Pass thru IWbemRefreshingServices implementation
STDMETHODIMP CWbemRefreshingSvc::XWbemRefrSvc::AddObjectToRefresher( WBEM_REFRESHER_ID* pRefresherId, LPCWSTR wszPath, long lFlags,
            IWbemContext* pContext, DWORD dwClientRefrVersion, WBEM_REFRESH_INFO* pInfo, DWORD* pdwSvrRefrVersion)
{
    return m_pObject->AddObjectToRefresher( pRefresherId, wszPath, lFlags, pContext, dwClientRefrVersion,
                                            pInfo, pdwSvrRefrVersion);
}

STDMETHODIMP CWbemRefreshingSvc::XWbemRefrSvc::AddObjectToRefresherByTemplate( WBEM_REFRESHER_ID* pRefresherId, IWbemClassObject* pTemplate,
            long lFlags, IWbemContext* pContext, DWORD dwClientRefrVersion, WBEM_REFRESH_INFO* pInfo, DWORD* pdwSvrRefrVersion)
{
    return m_pObject->AddObjectToRefresherByTemplate( pRefresherId, pTemplate, lFlags, pContext,
                                                        dwClientRefrVersion, pInfo, pdwSvrRefrVersion);
}

STDMETHODIMP CWbemRefreshingSvc::XWbemRefrSvc::RemoveObjectFromRefresher( WBEM_REFRESHER_ID* pRefresherId, long lId, long lFlags,
            DWORD dwClientRefrVersion, DWORD* pdwSvrRefrVersion)
{
    return m_pObject->RemoveObjectFromRefresher( pRefresherId, lId, lFlags, dwClientRefrVersion,
                                                pdwSvrRefrVersion );
}

STDMETHODIMP CWbemRefreshingSvc::XWbemRefrSvc::GetRemoteRefresher( WBEM_REFRESHER_ID* pRefresherId, long lFlags, DWORD dwClientRefrVersion,
            IWbemRemoteRefresher** ppRemRefresher, GUID* pGuid, DWORD* pdwSvrRefrVersion)
{
    return m_pObject->GetRemoteRefresher( pRefresherId, lFlags, dwClientRefrVersion, ppRemRefresher, pGuid,
                                            pdwSvrRefrVersion );
}

STDMETHODIMP CWbemRefreshingSvc::XWbemRefrSvc::ReconnectRemoteRefresher( WBEM_REFRESHER_ID* pRefresherId, long lFlags, long lNumObjects,
            DWORD dwClientRefrVersion, WBEM_RECONNECT_INFO* apReconnectInfo, WBEM_RECONNECT_RESULTS* apReconnectResults, DWORD* pdwSvrRefrVersion)
{
    return m_pObject->ReconnectRemoteRefresher( pRefresherId, lFlags, lNumObjects, dwClientRefrVersion,
                                            apReconnectInfo, apReconnectResults, pdwSvrRefrVersion);
}

/* IWbemRefreshingServices implemetation */

//
// given the refresher id (GUID,PID,MACHINENAME)
// and the object path, returns a "cookie" REFRESH_INFO for refreshing that object
//
/////////////////////////////////////////////////////////////////
HRESULT 
CWbemRefreshingSvc::AddObjectToRefresher( WBEM_REFRESHER_ID* pRefresherId, 
                                       LPCWSTR wszObjectPath, 
                                       long lFlags,
                                       IWbemContext* pContext, 
                                       DWORD dwClientRefrVersion, 
                                       WBEM_REFRESH_INFO* pInfo, 
                                       DWORD* pdwSvrRefrVersion)
{
    // Validate parameters
    // ===================

    if(wszObjectPath == NULL || pInfo == NULL || pdwSvrRefrVersion == NULL || pRefresherId == NULL)
        return WBEM_E_INVALID_PARAMETER;

    // If the client process is Winmgmt, we refuse the operation
    if ( IsWinmgmt( pRefresherId ) )
    {
        return WBEM_E_INVALID_OPERATION;
    }

    // Set the version for return --- add client version checking logic here
    // For now, this is really just swaps numbers
    *pdwSvrRefrVersion = WBEM_REFRESHER_VERSION;

    ((CRefreshInfo*)pInfo)->SetInvalid();

    IWbemClassObject*   pInst = NULL;

    // Use the helper function create the template
    HRESULT hres = CreateRefreshableObjectTemplate( wszObjectPath, lFlags, &pInst );
    CReleaseMe  rm(pInst);

    if ( SUCCEEDED( hres ) )
    {
        hres = AddObjectToRefresher_( ( dwClientRefrVersion >= WBEM_REFRESHER_VERSION ),
                                    pRefresherId, (CWbemObject*)pInst, lFlags,
                                    pContext, pInfo);
    }

    return hres;
}

//
// Similar to the previous one, but there is no need to parse the path and create a template
//
//////////////////////////////////////////////////////////////////////////
HRESULT 
CWbemRefreshingSvc::AddObjectToRefresherByTemplate( WBEM_REFRESHER_ID* pRefresherId, 
                                                 IWbemClassObject* pTemplate,
                                                 long lFlags, 
                                                 IWbemContext* pContext, 
                                                 DWORD dwClientRefrVersion, 
                                                 WBEM_REFRESH_INFO* pInfo, 
                                                 DWORD* pdwSvrRefrVersion)
{
    // Validate parameters
    // ===================

    if(pTemplate == NULL || pInfo == NULL || pdwSvrRefrVersion == NULL || pRefresherId == NULL)
        return WBEM_E_INVALID_PARAMETER;

    // If the client process is Winmgmt, we refuse the operation
    if ( IsWinmgmt( pRefresherId ) )
    {
        return WBEM_E_INVALID_OPERATION;
    }

    // Set the version for return --- add client version checking logic here
    // For now, this really just swaps numbers
    *pdwSvrRefrVersion = WBEM_REFRESHER_VERSION;

    ((CRefreshInfo*)pInfo)->SetInvalid();

    HRESULT hres = AddObjectToRefresher_( ( dwClientRefrVersion >= WBEM_REFRESHER_VERSION ),
                                    pRefresherId, (CWbemObject*)pTemplate, lFlags,
                                    pContext, pInfo);
    return hres;
}

//
//
//
////////////////////////////////////////////////////////////
HRESULT 
CWbemRefreshingSvc::AddEnumToRefresher( WBEM_REFRESHER_ID* pRefresherId, 
                                       LPCWSTR wszClass, 
                                       long lFlags,
                                       IWbemContext* pContext, 
                                       DWORD dwClientRefrVersion, 
                                       WBEM_REFRESH_INFO* pInfo, 
                                       DWORD* pdwSvrRefrVersion)
{


    // Validate parameters
    // ===================

    if(wszClass == NULL || pInfo == NULL || pdwSvrRefrVersion == NULL || pRefresherId == NULL)
        return WBEM_E_INVALID_PARAMETER;

    // If the client process is Winmgmt, we refuse the operation
    if ( IsWinmgmt( pRefresherId ) )
    {
        return WBEM_E_INVALID_OPERATION;
    }

    // Set the version for return --- add client version checking logic here
    // For now, this is really just swaps numbers
    *pdwSvrRefrVersion = WBEM_REFRESHER_VERSION;

    ((CRefreshInfo*)pInfo)->SetInvalid();

    // Get the class
    // =============

    IWbemClassObject* pClass = NULL;

    // Note that WBEM_FLAG_USE_AMENDED_QUALIFIERS is a valid flag.

    // Must use a BSTR in case the call gets marshaled
    BSTR    bstrClass = SysAllocString( wszClass );
    if ( NULL == bstrClass ) return WBEM_E_OUT_OF_MEMORY;
    CSysFreeMe    sfm( bstrClass );

    HRESULT hres = m_pSvcEx->GetObject( bstrClass, lFlags, NULL, &pClass, NULL);
    CReleaseMe  rmClass( pClass );
    if(FAILED(hres)) return WBEM_E_INVALID_CLASS;

    // Spawn an instance and decorate it
    IWbemClassObject* pInst = NULL;
    hres = pClass->SpawnInstance(0, &pInst);
    CReleaseMe  rmInst( pInst );

    _IWmiObject* pWmiObj = NULL;
    RETURN_ON_ERR(pInst->QueryInterface(IID__IWmiObject,(void **)&pWmiObj));
    CReleaseMe  rmWmiObj( pWmiObj );

    if ( SUCCEEDED( hres ) )
    {
        // Make sure the object has a namespace
        hres = pWmiObj->SetDecoration( m_pstrMachineName, m_pstrNamespace );

        if ( SUCCEEDED( hres ) )
        {
            // Delegate to object aware function
            // ================================

            hres = AddEnumToRefresher_( ( dwClientRefrVersion >= WBEM_REFRESHER_VERSION ),
                                        pRefresherId, 
                                        (CWbemObject*) pWmiObj,
                                        wszClass, lFlags,
                                        pContext, 
                                        pInfo);
        }

    }

    return hres;

}

//
// really a nop implementation
//
//////////////////////////////////////////////////////////////////////
HRESULT 
CWbemRefreshingSvc::RemoveObjectFromRefresher( WBEM_REFRESHER_ID* pRefresherId, 
                                             long lId, 
                                             long lFlags,
                                             DWORD dwClientRefrVersion, 
                                             DWORD* pdwSvrRefrVersion)
{

    if(pdwSvrRefrVersion == NULL)
        return WBEM_E_INVALID_PARAMETER;

    // If the client process is Winmgmt, we refuse the operation
    if ( IsWinmgmt( pRefresherId ) )
    {
        return WBEM_E_INVALID_OPERATION;
    }

    // Set the version for return --- add client version checking logic here
    // For now, this is really just swaps numbers
    *pdwSvrRefrVersion = WBEM_REFRESHER_VERSION;

    return WBEM_E_NOT_AVAILABLE;
}

HRESULT 
CWbemRefreshingSvc::GetRemoteRefresher( WBEM_REFRESHER_ID* pRefresherId, 
                                      long lFlags, 
                                      DWORD dwClientRefrVersion,
                                      IWbemRemoteRefresher** ppRemRefresher, 
                                      GUID* pGuid, 
                                      DWORD* pdwSvrRefrVersion)
{

    HRESULT hres = WBEM_S_NO_ERROR;

    if ( NULL == ppRemRefresher || 0L != lFlags || NULL == pGuid || NULL == pdwSvrRefrVersion || pRefresherId == NULL)
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    // If the client process is Winmgmt, we refuse the operation
    if ( IsWinmgmt( pRefresherId ) )
    {
        return WBEM_E_INVALID_OPERATION;
    }

    // Set the version for return --- add client version checking logic here
    // For now, this is really just swaps numbers

    _IWbemRefresherMgr*    pRefrMgr = NULL;
    hres = GetRefrMgr( &pRefrMgr );
    CReleaseMe    rm( pRefrMgr );

    if ( SUCCEEDED( hres ) )
    {
        *pdwSvrRefrVersion = WBEM_REFRESHER_VERSION;

        // Pass pRefrMgr as the IUnknown for pLockMgr.  This way, if a remote refresher
        // is created, then we will AddRef the refrmgr in the provider cache and
        // keep it from getting prematurely unloaded.

        // This should add a remote refresher if it does not exist
        hres = pRefrMgr->GetRemoteRefresher( pRefresherId, 0L, TRUE, ppRemRefresher, pRefrMgr, pGuid );

        // If the client version number is too small, then we need to wrap the remote refresher
        // through Winmgmt.

        if ( SUCCEEDED( hres ) && dwClientRefrVersion < WBEM_REFRESHER_VERSION )
        {
            hres = WrapRemoteRefresher( ppRemRefresher );
        }
    }    // IF GetRefrMgr

    return hres;
}

HRESULT 
CWbemRefreshingSvc::ReconnectRemoteRefresher( WBEM_REFRESHER_ID* pRefresherId, 
                                            long lFlags, 
                                            long lNumObjects,
                                            DWORD dwClientRefrVersion, 
                                            WBEM_RECONNECT_INFO* apReconnectInfo, 
                                            WBEM_RECONNECT_RESULTS* apReconnectResults, 
                                            DWORD* pdwSvrRefrVersion)
{

    HRESULT hr = WBEM_S_NO_ERROR;

    if (0l != lFlags || NULL == apReconnectResults || NULL == apReconnectInfo || NULL == pdwSvrRefrVersion || pRefresherId == NULL)
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    // If the client process is Winmgmt, we refuse the operation
    if ( IsWinmgmt( pRefresherId ) )
    {
        return WBEM_E_INVALID_OPERATION;
    }

    // Set the version for return --- add client version checking logic here
    // For now, this is really just swaps numbers
    *pdwSvrRefrVersion = WBEM_REFRESHER_VERSION;

    _IWbemRefresherMgr*    pRefrMgr = NULL;
    hr = GetRefrMgr( &pRefrMgr );
    CReleaseMe    rm( pRefrMgr );

    // If we can get a remote refresher refresher, then we will need to walk
    // our list of objects and manually re-add them.  If we can't get the remote,
    // then something is badly wrong, so we cannot continue with this operation.

    IWbemRemoteRefresher*    pRemRefr = NULL;

    if ( SUCCEEDED( hr )  )
    {
        GUID                    guid;

        // Pass pRefrMgr as the IUnknown for pLockMgr.  This way, if a remote refresher
        // is created, then we will AddRef the refrmgr in the provider cache and
        // keep it from getting prematurely unloaded.

        // Need to change this to NOT add a refresher if it doesn't exist
        hr = pRefrMgr->GetRemoteRefresher( pRefresherId, 0L, FALSE, &pRemRefr, pRefrMgr, &guid );
    }

    CReleaseMe    rm2( pRemRefr );

    if ( WBEM_S_NO_ERROR == hr )
    {
        // We need to manually walk the list and get ids, return codes and a remote refresher

        // Make sure we have no NULLs, and all types are valid (e.g. must specify either
        // an object or an enum.
        for ( long lCtr = 0; ( SUCCEEDED(hr) && lCtr < lNumObjects ); lCtr++ )
        {
            if ( NULL == apReconnectInfo[lCtr].m_pwcsPath ||
                apReconnectInfo[lCtr].m_lType >= WBEM_RECONNECT_TYPE_LAST )
            {
                hr = WBEM_E_INVALID_PARAMETER;
            }
        }

        if ( SUCCEEDED( hr ) )
        {
            for ( lCtr = 0; lCtr < lNumObjects; lCtr++ )
            {
                DWORD           dwDummyVersion;
                CRefreshInfo    Info;

                // Well, it's either an object or an enumerator.

                if ( WBEM_RECONNECT_TYPE_OBJECT == apReconnectInfo[lCtr].m_lType )
                {
                    hr = AddObjectToRefresher( (CRefresherId*) pRefresherId, apReconnectInfo[lCtr].m_pwcsPath,
                            0L, NULL, dwClientRefrVersion, &Info, &dwDummyVersion );
                }
                else
                {
                    hr = AddEnumToRefresher( (CRefresherId*) pRefresherId, apReconnectInfo[lCtr].m_pwcsPath,
                            0L, NULL, dwClientRefrVersion, &Info, &dwDummyVersion );
                }

                // Store the hresult
                apReconnectResults[lCtr].m_hr = hr;

                // If the add succeeds, store the id and if we haven't already, the remote
                // refresher

                if ( SUCCEEDED( hr ) )
                {
                    apReconnectResults[lCtr].m_lId = Info.m_lCancelId;
                }   // IF Add succeeded

            }   // FOR Enum Counters

        }   // If valid string array

    }
    else
    {
        hr = WBEM_E_INVALID_OPERATION;
    }

    return hr;
}

//
// the NON COM-interface method 
//
///////////////////////////////////////////
HRESULT 
CWbemRefreshingSvc::AddObjectToRefresher_( BOOL fVersionMatch, 
                                       WBEM_REFRESHER_ID* pRefresherId, 
                                       CWbemObject* pInstTemplate, 
                                       long lFlags, 
                                       IWbemContext* pContext,
                                       WBEM_REFRESH_INFO* pInfo)
{
    if(!pInstTemplate->IsInstance())
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    HRESULT hres;

    // Get the class definition
    // ========================

    CVar vClassName;
    if (FAILED(hres = pInstTemplate->GetClassName(&vClassName))) return hres;

    // Must use a BSTR in case the call gets marshaled
    BSTR    bstrClass = SysAllocString( vClassName.GetLPWSTR() );
    if ( NULL == bstrClass ) return WBEM_E_OUT_OF_MEMORY;
    CSysFreeMe    sfm( bstrClass );

    IWbemClassObject* pObj = NULL;
    hres = m_pSvcEx->GetObject( bstrClass, 0, NULL, &pObj, NULL );
    if(FAILED(hres)) return WBEM_E_INVALID_CLASS;    
    CReleaseMe    rmClass( pObj );

    // Get the refresher from that provider (or a surrogate)
    // =====================================================

    // We need to have full impersonation for this to work

    _IWbemRefresherMgr*    pRefrMgr = NULL;
    hres = GetRefrMgr( &pRefrMgr );
    CReleaseMe    rm( pRefrMgr );

    if ( SUCCEEDED( hres ) )
    {
        // Impersonate before making a x-process call.
        hres = CoImpersonateClient();

        if ( SUCCEEDED( hres ) || ( hres == E_NOINTERFACE ) )
        {
            // Pass pRefrMgr as the IUnknown for pLockMgr.  This way, if a remote refresher
            // is created, then we will AddRef the refrmgr in the provider cache and
            // keep it from getting prematurely unloaded.

            hres = pRefrMgr->AddObjectToRefresher( m_pSvcEx, m_pstrMachineName, m_pstrNamespace, pObj,
                                                    pRefresherId, pInstTemplate, lFlags, pContext, pRefrMgr, pInfo );

            // Reset portions of the RefreshInfo structure as appropriate
            if ( SUCCEEDED( hres ) && !fVersionMatch )
            {
                hres = ResetRefreshInfo( pInfo );
            }

            CoRevertToSelf();

        }    // If CoImpersonateClient

    }    // IF GetRefrMgr

    return hres;

}

//
// give an object path as a string, get the class, spawn the instance
//
//////////////////////////////////////////////////////////////
HRESULT 
CWbemRefreshingSvc::CreateRefreshableObjectTemplate( LPCWSTR wszObjectPath, 
                                                 long lFlags, 
                                                 IWbemClassObject** ppInst )
{
    // Validate parameters
    // ===================

    if( NULL == wszObjectPath || NULL == ppInst )
        return WBEM_E_INVALID_PARAMETER;

    // Parse the path
    // ==============
    ParsedObjectPath* pOutput = 0;

    CObjectPathParser p;
    int nStatus = p.Parse((LPWSTR)wszObjectPath,  &pOutput);

    if (nStatus != 0 || !pOutput->IsInstance())
    {
        // Cleanup the output pointer if it was allocated
        if ( NULL != pOutput )
        {
            p.Free(pOutput);
        }

        return WBEM_E_INVALID_OBJECT_PATH;
    }

    ON_BLOCK_EXIT_OBJ(p, (void (CObjectPathParser::*)(ParsedObjectPath *))CObjectPathParser::Free, pOutput);

    // =============================
    // TBD: check the namespace part
    // =============================

    // Get the class
    // =============

    IWbemClassObject* pClass = NULL;

    // Must use a BSTR in case the call gets marshaled
    BSTR    bstrClass = SysAllocString( pOutput->m_pClass );
    if ( NULL == bstrClass ) return WBEM_E_OUT_OF_MEMORY;
    CSysFreeMe    sfm( bstrClass );

    // Note that WBEM_FLAG_USE_AMENDED_QUALIFIERS is a valid flag
    HRESULT hres = m_pSvcEx->GetObject( bstrClass, lFlags, NULL, &pClass, NULL);
    if(FAILED(hres)) return WBEM_E_INVALID_CLASS;
    CReleaseMe rmClass(pClass);

    // Spawn and fill the instance
    // ===========================

    IWbemClassObject* pInst = NULL;
    hres = pClass->SpawnInstance(0, &pInst);    
    if (FAILED(hres)) return hres;
    CReleaseMe rmInst(pInst);

    for(DWORD i = 0; i < pOutput->m_dwNumKeys; i++)
    {
        KeyRef* pKeyRef = pOutput->m_paKeys[i];

        WString wsPropName;
        if(pKeyRef->m_pName == NULL)
        {
            // No key name --- get the key.
            // ============================

            CWStringArray awsKeys;
            ((CWbemInstance*)pInst)->GetKeyProps(awsKeys);
            if(awsKeys.Size() != 1)
            {
                return WBEM_E_INVALID_OBJECT;
            }
            wsPropName = awsKeys[0];
        }
        else 
        {
            wsPropName = pKeyRef->m_pName;
        }

        // Compute variant type of the property
        // ====================================

        CIMTYPE ctPropType;
        hres = pInst->Get(wsPropName, 0, NULL, &ctPropType, NULL);
        if(FAILED(hres)) return WBEM_E_INVALID_PARAMETER;

        VARTYPE vtVariantType = CType::GetVARTYPE(ctPropType);

        // Set the value into the instance
        // ===============================

        if(vtVariantType != V_VT(&pKeyRef->m_vValue))
        {
            hres = VariantChangeType(&pKeyRef->m_vValue, &pKeyRef->m_vValue, 0,
                        vtVariantType);
        }
        if(FAILED(hres)) return WBEM_E_INVALID_PARAMETER;


        hres = pInst->Put(wsPropName, 0, &pKeyRef->m_vValue, 0);
        if(FAILED(hres)) return WBEM_E_INVALID_PARAMETER;
    }

    // Caller must free this guy up
    rmInst.dismiss();
    *ppInst = pInst;

    return hres;
}

//
// the NON COM-interface method that does the real work
//
///////////////////////////////////////////////////
HRESULT 
CWbemRefreshingSvc::AddEnumToRefresher_(BOOL fVersionMatch, 
                                      WBEM_REFRESHER_ID* pRefresherId,
                                      CWbemObject* pInstTemplate, 
                                      LPCWSTR wszClass, 
                                      long lFlags,
                                      IWbemContext* pContext, 
                                      WBEM_REFRESH_INFO* pInfo)
{

    HRESULT hres;

    // Get the class definition
    // ========================

    // Must use a BSTR in case the call gets marshaled
    BSTR    bstrClass = SysAllocString( wszClass );
    if ( NULL == bstrClass ) return WBEM_E_OUT_OF_MEMORY;
    CSysFreeMe    sfm( bstrClass );

    IWbemClassObject* pObj = NULL;
    hres = m_pSvcEx->GetObject( bstrClass, 0, NULL, &pObj, NULL);
    if(FAILED(hres)) return WBEM_E_INVALID_CLASS;    
    CReleaseMe    rmClass( pObj );

    // Get the refresher from that provider (or a surrogate)
    // =====================================================

    // We need to have full impersonation for this to work

    _IWbemRefresherMgr*    pRefrMgr = NULL;
    hres = GetRefrMgr( &pRefrMgr );
    CReleaseMe    rm( pRefrMgr );

    if ( SUCCEEDED( hres ) )
    {
        // Impersonate before making a x-process call.
        hres = CoImpersonateClient();

        if ( SUCCEEDED( hres ) || ( hres ==  E_NOINTERFACE ) )
        {

            // Pass pRefrMgr as the IUnknown for pLockMgr.  This way, if a remote refresher
            // is created, then we will AddRef the refrmgr in the provider cache and
            // keep it from getting prematurely unloaded.
            hres = pRefrMgr->AddEnumToRefresher( m_pSvcEx, m_pstrMachineName, m_pstrNamespace, pObj,
                                                    pRefresherId, pInstTemplate, wszClass,
                                                    lFlags, pContext, pRefrMgr, pInfo );

            // Reset portions of the RefreshInfo structure as appropriate
            if ( SUCCEEDED( hres ) && !fVersionMatch )
            {
                hres = ResetRefreshInfo( pInfo );
            }

            CoRevertToSelf();
        }    

    }    // IF GetRefrMgr

    return hres;

}

//
//   Actual _IWbemConfigureRefreshingSvc implementation
//   Disallow re-configuration
//
//////////////////////////////////////////////////////////
HRESULT CWbemRefreshingSvc::SetServiceData( BSTR pwszMachineName, BSTR pwszNamespace )
{
    // We're in deep kimchee already
    if ( NULL == m_pSvcEx  )
    {
        return WBEM_E_FAILED;
    }

    if ( NULL == pwszMachineName || NULL == pwszNamespace )
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    if ( NULL == m_pstrMachineName )
    {
        m_pstrMachineName = SysAllocString( pwszMachineName );
    }

    if ( NULL == m_pstrNamespace )
    {
        m_pstrNamespace = SysAllocString( pwszNamespace );
    }

    // Cleanup and error out
    if ( NULL == m_pstrMachineName || NULL == m_pstrNamespace )
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    return WBEM_S_NO_ERROR;
}

BOOL CWbemRefreshingSvc::IsWinmgmt( WBEM_REFRESHER_ID* pRefresherId )
{
    // For now, we assume that this code is only instantiated inside Winmgmt, so we only check the
    // refresher id for its process id an compare it to the current process id.  If they match, this
    // means that a provider in-proc to Winmgmt is using a refresher.  This is not allowed, hence
    // this call will return TRUE and the request will be refused

    return ( pRefresherId->m_dwProcessId == GetCurrentProcessId() );
    
}

//
// here we assume that wbemcore and the refreshing services interface are in-proc
//
/////////////////////////////////////////////////////////////////
HRESULT    CWbemRefreshingSvc::GetRefrMgr( _IWbemRefresherMgr** ppMgr )
{
    // Grabs a refresher manager fetcher each time we need one, and returns
    // a refresher manager pointer.  This ensures that we only create this when
    // it is required, AND that the manager is appropriate to the apartment
    // we are being called on.

    _IWbemFetchRefresherMgr*    pFetchRefrMgr = NULL;

    HRESULT    hr = CoCreateInstance(CLSID__WbemFetchRefresherMgr, 
                                   NULL, 
                                   CLSCTX_INPROC_SERVER,
                                   IID__IWbemFetchRefresherMgr, 
                                   (void**) &pFetchRefrMgr );
    CReleaseMe    rm( pFetchRefrMgr );

    if ( SUCCEEDED( hr ) )
    {
        hr = pFetchRefrMgr->Get( ppMgr );
    }

    return hr;
}

HRESULT CWbemRefreshingSvc::ResetRefreshInfo( WBEM_REFRESH_INFO* pRefreshInfo )
{
    HRESULT    hr = WBEM_S_NO_ERROR;

    if ( pRefreshInfo->m_lType == WBEM_REFRESH_TYPE_REMOTE )
    {
        hr = WrapRemoteRefresher( &pRefreshInfo->m_Info.m_Remote.m_pRefresher );
    }    // IF Remote Refreshing

    return hr;
}

HRESULT CWbemRefreshingSvc::WrapRemoteRefresher( IWbemRemoteRefresher** ppRemoteRefresher )
{
    HRESULT    hr = WBEM_S_NO_ERROR;

    CWbemRemoteRefresher*    pRemRefr = new CWbemRemoteRefresher( m_pControl,
                                                                *ppRemoteRefresher );

    if (pRemRefr)
    {
        IWbemRemoteRefresher*    pTempRefr = *ppRemoteRefresher;

        hr = pRemRefr->QueryInterface( IID_IWbemRemoteRefresher, (void**) ppRemoteRefresher );

        // Release the original interface
        if ( NULL != pTempRefr )
        {
            pTempRefr->Release();
        }

        if ( FAILED( hr ) )
        {
            *ppRemoteRefresher = NULL;
            delete pRemRefr;
        }

    } 
    else
        hr = WBEM_E_OUT_OF_MEMORY;

    return hr;
}

//***************************************************************************
//
//  CWbemRemoteRefresher::CWbemRemoteRefresher
//
//***************************************************************************
// ok
CWbemRemoteRefresher::CWbemRemoteRefresher( CLifeControl* pControl, IWbemRemoteRefresher* pRemRefr, IUnknown* pOuter )
:    CUnk( pControl, pOuter ),
    m_pRemRefr( pRemRefr ),
    m_XWbemRemoteRefr( this )
{
    if ( NULL != m_pRemRefr )
    {
        m_pRemRefr->AddRef();
    }
}
    
//***************************************************************************
//
//  CWbemRemoteRefresher::~CWbemRemoteRefresher
//
//***************************************************************************
// ok
CWbemRemoteRefresher::~CWbemRemoteRefresher()
{
    if ( NULL != m_pRemRefr )
    {
        m_pRemRefr->Release();
    }
}

// Override that returns us an interface
void* CWbemRemoteRefresher::GetInterface( REFIID riid )
{
    if(riid == IID_IUnknown || riid == IID_IWbemRemoteRefresher)
        return &m_XWbemRemoteRefr;
    else
        return NULL;
}

// Pass thru IWbemRemoteRefresher implementation
STDMETHODIMP CWbemRemoteRefresher::XWbemRemoteRefr::RemoteRefresh( long lFlags, long* plNumObjects, WBEM_REFRESHED_OBJECT** paObjects )
{
    return m_pObject->RemoteRefresh( lFlags, plNumObjects, paObjects );
}

STDMETHODIMP CWbemRemoteRefresher::XWbemRemoteRefr::StopRefreshing( long lNumIds, long* aplIds, long lFlags)
{
    return m_pObject->StopRefreshing( lNumIds, aplIds, lFlags);
}

STDMETHODIMP CWbemRemoteRefresher::XWbemRemoteRefr::GetGuid( long lFlags, GUID*  pGuid )
{
    return m_pObject->GetGuid( lFlags, pGuid );
}

// Actual Implementation code
HRESULT CWbemRemoteRefresher::RemoteRefresh( long lFlags, long* plNumObjects, WBEM_REFRESHED_OBJECT** paObjects )
{
    // Impersonate before making a x-process call.
    HRESULT hres = CoImpersonateClient();

    if ( SUCCEEDED( hres ) )
    {
        hres = CoSetProxyBlanket( m_pRemRefr, RPC_C_AUTHN_DEFAULT, RPC_C_AUTHZ_DEFAULT, COLE_DEFAULT_PRINCIPAL, RPC_C_AUTHN_LEVEL_DEFAULT, 
                                RPC_C_IMP_LEVEL_IMPERSONATE, COLE_DEFAULT_AUTHINFO, EOAC_DYNAMIC_CLOAKING );

        if ( SUCCEEDED( hres ) )
        {
            hres = m_pRemRefr->RemoteRefresh( lFlags, plNumObjects, paObjects );
        }

        CoRevertToSelf();
    }

    return hres;
}

HRESULT CWbemRemoteRefresher::StopRefreshing( long lNumIds, long* aplIds, long lFlags)
{
    // Impersonate before making a x-process call.
    HRESULT hres = CoImpersonateClient();

    if ( SUCCEEDED( hres ) )
    {
        hres = CoSetProxyBlanket( m_pRemRefr, RPC_C_AUTHN_DEFAULT, RPC_C_AUTHZ_DEFAULT, COLE_DEFAULT_PRINCIPAL, RPC_C_AUTHN_LEVEL_DEFAULT, 
                                RPC_C_IMP_LEVEL_IMPERSONATE, COLE_DEFAULT_AUTHINFO, EOAC_DYNAMIC_CLOAKING );

        if ( SUCCEEDED( hres ) )
        {
            hres = m_pRemRefr->StopRefreshing( lNumIds, aplIds, lFlags );
        }

        CoRevertToSelf();
    }

    return hres;
}

HRESULT CWbemRemoteRefresher::GetGuid( long lFlags, GUID*  pGuid )
{
    // Impersonate before making a x-process call.
    HRESULT hres = CoImpersonateClient();

    if ( SUCCEEDED( hres ) )
    {
        hres = CoSetProxyBlanket( m_pRemRefr, RPC_C_AUTHN_DEFAULT, RPC_C_AUTHZ_DEFAULT, COLE_DEFAULT_PRINCIPAL, RPC_C_AUTHN_LEVEL_DEFAULT, 
                                RPC_C_IMP_LEVEL_IMPERSONATE, COLE_DEFAULT_AUTHINFO, EOAC_DYNAMIC_CLOAKING );

        if ( SUCCEEDED( hres ) )
        {
            hres = m_pRemRefr->GetGuid( lFlags, pGuid );
        }

        CoRevertToSelf();
    }

    return hres;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\marshalers\coreprox\rfchercd.h ===
/*++

Copyright (C) 2000-2001 Microsoft Corporation

Module Name:

    RFCHERCD.H

Abstract:

  Refresher cache record Definitions.

History:

  27-Apr-2000	sanjes    Created.

--*/

#ifndef __RFCHERCD_H__
#define __RFCHERCD_H__

#include "corepol.h"
#include <arena.h>
#include "sync.h"
#include "arrtempl.h"
#include "hiperfenum.h"
#include "callsec.h"

// Special Remote Hi-Perf Enumerator
class CRemoteHiPerfEnum : public CHiPerfEnum
{
public:

	CRemoteHiPerfEnum(void);
	~CRemoteHiPerfEnum();

	// Arranges BLOB contents from an enumeration
	HRESULT GetTransferArrayBlob(long *plBlobType, long *plBlobLen, BYTE** ppBlob);

};

// Forward Declarations
class	CRefresherCache;
class CProviderRecord;

// Request records
class CRequestRecord
{
	protected:
		long m_lExternalRequestId;
	public:
		CRequestRecord(long lExternalRequestId = 0) 
			: m_lExternalRequestId(lExternalRequestId){}
		virtual ~CRequestRecord(){}
		long GetExternalRequestId() {return m_lExternalRequestId;}
};

class CObjectRequestRecord : public CRequestRecord
{
public:
    CWbemObject* m_pRefreshedObject;
    long m_lInternalRequestId;
public:
    CObjectRequestRecord(long lExternalRequestId, 
                            CWbemObject* pRefreshedObject, 
                            long lProviderRequestId);
    ~CObjectRequestRecord();
    HRESULT Cancel(CProviderRecord* pContainer);
public:
    long GetInternalRequestId() {return m_lInternalRequestId;}
    INTERNAL CWbemObject* GetRefreshedObject() {return m_pRefreshedObject;}
};

class CEnumRequestRecord : public CRequestRecord
{
public:
    CRemoteHiPerfEnum* m_pHPEnum;
    long m_lInternalRequestId;

public:
    CEnumRequestRecord(long lExternalRequestId, 
                            CRemoteHiPerfEnum* pHPEnum, 
                            long lProviderRequestId);
    ~CEnumRequestRecord();
    HRESULT Cancel(CProviderRecord* pContainer);
public:
    long GetInternalRequestId() {return m_lInternalRequestId;}
    INTERNAL CRemoteHiPerfEnum* GetEnum() {return m_pHPEnum;}
};

//***************************************************************************
//
//  class CHiPerfPrvRecord
//
//***************************************************************************

class CHiPerfPrvRecord
{
protected:
    long m_lRef;

    WString					m_wsProviderName;
    CLSID					m_clsid;
    CLSID					m_clsidClient;
	CRefresherCache*		m_pRefresherCache;

public:
    CHiPerfPrvRecord( LPCWSTR wszName, CLSID clsid, CLSID clsidClient, CRefresherCache* pRefrCache );
    virtual ~CHiPerfPrvRecord();

    long AddRef();
    long Release();

    long GetRefCount() {return m_lRef;}

    LPCWSTR GetProviderName() const {return m_wsProviderName;}
    REFCLSID GetClsid() {return m_clsid;}
    REFCLSID GetClientLoadableClsid() {return m_clsidClient;}

	BOOL IsReleased( void ) { return ( m_lRef == 0L ); }
};

//***************************************************************************
//
//  class CProviderRecord
//
//
//***************************************************************************

class CProviderRecord
{
protected:
    long m_lRef;

	IWbemHiPerfProvider*	m_pProvider;
	_IWmiProviderStack*		m_pProvStack;
	IWbemRefresher*			m_pInternalRefresher;
	CHiPerfPrvRecord*		m_pHiPerfRecord;
	CCritSec				m_cs;

    CUniquePointerArray<CObjectRequestRecord> m_apRequests;
    CUniquePointerArray<CEnumRequestRecord>	m_apEnumRequests;

public:
    CProviderRecord( CHiPerfPrvRecord* pHiPerfRecord, IWbemHiPerfProvider* pProvider, IWbemRefresher* pRefresher,
					_IWmiProviderStack* pProvStack );
    virtual ~CProviderRecord();

    long AddRef();
    long Release();

    long GetRefCount() {return m_lRef;}

    LPCWSTR GetProviderName() const {return m_pHiPerfRecord->GetProviderName();}
    REFCLSID GetClsid() {return m_pHiPerfRecord->GetClsid();}
    REFCLSID GetClientLoadableClsid() {return m_pHiPerfRecord->GetClientLoadableClsid();}

    HRESULT Remove(long lId, BOOL* pfIsEnum);
    HRESULT Find(long lId);
    HRESULT Refresh(long lFlags);
    HRESULT Store(WBEM_REFRESHED_OBJECT* aObjects, long* plIndex);
    BOOL IsEmpty() {return (m_apRequests.GetSize() == 0) && m_apEnumRequests.GetSize() == 0;}
    INTERNAL IWbemHiPerfProvider* GetProvider() { if ( NULL != m_pProvider ) m_pProvider->AddRef(); return m_pProvider;}
    INTERNAL IWbemRefresher* GetInternalRefresher( void )
	{ return m_pInternalRefresher; }

    HRESULT AddObjectRequest(CWbemObject* pRefreshedObject, 
                            long lProviderRequestId,
							long lNewId );

    HRESULT AddEnumRequest(CRemoteHiPerfEnum* pHPEnum, 
                            long lProviderRequestId,
							long lNewId);

    HRESULT Cancel(long lId);
};

// The actual refresher record - one is created for each remote refresher
class CRefresherRecord : public IWbemRemoteRefresher, public IWbemRefresher
{
protected:
    long m_lRefCount;
    CRefresherId m_Id;
    CUniquePointerArray<CProviderRecord> m_apProviders;
    long m_lNumObjects;
	long m_lNumEnums;
	long	m_lLastId;
	GUID	m_Guid;
	CRefresherCache*	m_pRefresherCache;
	IUnknown*			m_pLockMgr;
	CCritSec	m_cs;

public:
    CRefresherRecord(const WBEM_REFRESHER_ID& Id, CRefresherCache* pRefresherCache, IUnknown* pLockMgr);
    virtual ~CRefresherRecord();

    STDMETHOD_(ULONG, AddRef)();
    STDMETHOD_(ULONG, Release)();
    STDMETHOD(QueryInterface)(REFIID riid, void** ppv);
    STDMETHOD(RemoteRefresh)(long lFlags, long* plNumObjects,
        WBEM_REFRESHED_OBJECT** paObjects);
	STDMETHOD(StopRefreshing)( long lNumIds, long* aplIds, long lFlags);
	STDMETHOD(GetGuid)( long lFlags, GUID* pGuid );

    STDMETHOD(Refresh)(long lFlags);

    CRefresherId& GetId() {return m_Id;}
    const CRefresherId& GetId() const {return m_Id;}

    INTERNAL CProviderRecord* FindProviderRecord(
                         CLSID clsid,
						 IWbemHiPerfProvider** ppProvider = NULL);

    INTERNAL HRESULT AddProvider(
                        CHiPerfPrvRecord* pHiPerfRecord,
						IWbemHiPerfProvider* pProvider,
						IWbemRefresher* pRefresher,
						_IWmiProviderStack* pProvStack,
						CProviderRecord** ppRecord );

	// Retrieves a new id for this remote refresher
	long GetNewRequestId( void )
	{
		return InterlockedIncrement( &m_lLastId );
	}

	virtual HRESULT AddObjectRefresher(
						CHiPerfPrvRecord* pHiPerfRecord,
						IWbemHiPerfProvider* pProvider,
						_IWmiProviderStack* pProvStack,
						IWbemServices* pNamespace,
						LPCWSTR pwszServerName, LPCWSTR pwszNamespace,
						CWbemObject* pInstTemplate, long lFlags, 
						IWbemContext* pContext,
						CRefreshInfo* pInfo) = 0;

	virtual HRESULT AddEnumRefresher(
						CHiPerfPrvRecord* pHiPerfRecord,
						IWbemHiPerfProvider* pProvider,
						_IWmiProviderStack* pProvStack,
						IWbemServices* pNamespace,
						CWbemObject* pInstTemplate,
						LPCWSTR wszClass, long lFlags, 
						IWbemContext* pContext,
						CRefreshInfo* pInfo) = 0;

    HRESULT Remove(long lRequestId);

	void GetGuid( GUID* pGuid ){ *pGuid = m_Guid; }

	BOOL IsReleased( void ) { return ( m_lRefCount == 0L ); }

	CIdentitySec m_Security;
};

class CRemoteRecord : public CRefresherRecord
{
protected:

	HRESULT GetProviderRefreshInfo( CHiPerfPrvRecord* pHiPerfRecord,
									IWbemHiPerfProvider* pProvider,
									IWbemServices* pNamespace,
									CProviderRecord** ppProvRecord,
									IWbemRefresher** ppRefresher );

public:
    CRemoteRecord(const WBEM_REFRESHER_ID& Id, CRefresherCache* pRefresherCache, IUnknown* pLockMgr);
    ~CRemoteRecord();

	HRESULT AddObjectRefresher(
						CHiPerfPrvRecord* pHiPerfRecord,
						IWbemHiPerfProvider* pProvider,
						_IWmiProviderStack* pProvStack,
						IWbemServices* pNamespace,
						LPCWSTR pwszServerName, LPCWSTR pwszNamespace,
						CWbemObject* pInstTemplate, long lFlags, 
						IWbemContext* pContext,
						CRefreshInfo* pInfo);

	HRESULT AddEnumRefresher(
						CHiPerfPrvRecord* pHiPerfRecord,
						IWbemHiPerfProvider* pProvider,
						_IWmiProviderStack* pProvStack,
						IWbemServices* pNamespace,
						CWbemObject* pInstTemplate,
						LPCWSTR wszClass, long lFlags, 
						IWbemContext* pContext,
						CRefreshInfo* pInfo);

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\marshalers\coreprox\sinkmrsh.cpp ===
/*++

Copyright (C) 1998-2001 Microsoft Corporation

Module Name:

    SINKMRSH.CPP

Abstract:

    IWbemObjectSink marshaling

History:

--*/

#include "precomp.h"
#include <stdio.h>
#include "sinkmrsh.h"
#include <fastall.h>
#include <fastobj.h>

#define WBEM_S_NEW_STYLE 0x400FF

//****************************************************************************
//****************************************************************************
//                          PS FACTORY
//****************************************************************************
//****************************************************************************

//***************************************************************************
//
//  CSinkFactoryBuffer::XSinkFactory::CreateProxy
//
//  DESCRIPTION:
//
//  Creates a facelet.  Also sets the outer unknown since the proxy is going to be 
//  aggregated.
//
//  RETURN VALUE:
//
//  S_OK                all is well
//
//***************************************************************************

STDMETHODIMP CSinkFactoryBuffer::XSinkFactory::CreateProxy(IN IUnknown* pUnkOuter, 
    IN REFIID riid, OUT IRpcProxyBuffer** ppProxy, void** ppv)
{
    if(riid != IID_IWbemObjectSink)
    {
        *ppProxy = NULL;
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    CSinkProxyBuffer* pProxy = new CSinkProxyBuffer(m_pObject->m_pLifeControl, pUnkOuter);

    SCODE   sc = E_OUTOFMEMORY;

    if ( NULL != pProxy )
    {
        pProxy->QueryInterface(IID_IRpcProxyBuffer, (void**)ppProxy);
        sc = pProxy->QueryInterface(riid, (void**)ppv);
    }

    return sc;
}

//***************************************************************************
//
//  CSinkFactoryBuffer::XSinkFactory::CreateStub
//
//  DESCRIPTION:
//
//  Creates a stublet.  Also passes a pointer to the clients IWbemObjectSink 
//  interface.
//
//  RETURN VALUE:
//
//  S_OK                all is well
//
//***************************************************************************
    
STDMETHODIMP CSinkFactoryBuffer::XSinkFactory::CreateStub(IN REFIID riid, 
    IN IUnknown* pUnkServer, OUT IRpcStubBuffer** ppStub)
{
    if(riid != IID_IWbemObjectSink)
    {
        *ppStub = NULL;
        return E_NOINTERFACE;
    }

    try // CWbemClassCache throws
    {
	    CSinkStubBuffer* pStub = new CSinkStubBuffer(m_pObject->m_pLifeControl, NULL);

	    if ( NULL != pStub )
	    {
	        pStub->QueryInterface(IID_IRpcStubBuffer, (void**)ppStub);

	        // Pass the pointer to the clients object

	        if(pUnkServer)
	        {
	            HRESULT hres = (*ppStub)->Connect(pUnkServer);
	            if(FAILED(hres))
	            {
	                delete pStub;
	                *ppStub = NULL;
	            }
	            return hres;
	        }
	        else
	        {
	            return S_OK;
	        }
	    }
	    else
	    {
	        return E_OUTOFMEMORY;
	    }
   	}
    catch (CX_Exception &)
    {
        return E_OUTOFMEMORY;
    }
}

//***************************************************************************
//
//  void* CSinkFactoryBuffer::GetInterface(REFIID riid)
//
//  DESCRIPTION:
//
//  CSinkFactoryBuffer is derived from CUnk.  Since CUnk handles the QI calls,
//  all classes derived from it must support this function.
//
//  RETURN VALUE:
//
//  S_OK                all is well
//
//***************************************************************************

void* CSinkFactoryBuffer::GetInterface(REFIID riid)
{
    if(riid == IID_IPSFactoryBuffer)
        return &m_XSinkFactory;
    else return NULL;
}
        
//****************************************************************************
//****************************************************************************
//                          PROXY
//****************************************************************************
//****************************************************************************

//***************************************************************************
//
//  CSinkProxyBuffer::CSinkProxyBuffer
//  ~CSinkProxyBuffer::CSinkProxyBuffer
//
//  DESCRIPTION:
//
//  Constructor and destructor.  The main things to take care of are the 
//  old style proxy, and the channel
//
//  RETURN VALUE:
//
//  S_OK                all is well
//
//***************************************************************************

CSinkProxyBuffer::CSinkProxyBuffer(CLifeControl* pControl, IUnknown* pUnkOuter)
    : CBaseProxyBuffer( pControl, pUnkOuter, IID_IWbemObjectSink ), 
        m_XSinkFacelet(this), m_pOldProxySink( NULL )
{
    m_StubType = UNKNOWN;
}

CSinkProxyBuffer::~CSinkProxyBuffer()
{
    // This should be cleaned up here

    if ( NULL != m_pOldProxySink )
    {
        m_pOldProxySink->Release();
    }

}

void* CSinkProxyBuffer::GetInterface( REFIID riid )
{
    if(riid == IID_IWbemObjectSink)
        return &m_XSinkFacelet;
    else return NULL;
}

void** CSinkProxyBuffer::GetOldProxyInterfacePtr( void )
{
    return (void**) &m_pOldProxySink;
}

void CSinkProxyBuffer::ReleaseOldProxyInterface( void )
{
    // We only keep a single reference to this
    if ( NULL != m_pOldProxySink )
    {
        m_pOldProxySink->Release();
        m_pOldProxySink = NULL;
    }
}

//***************************************************************************
//
//  HRESULT STDMETHODCALLTYPE CSinkProxyBuffer::XSinkFacelet::
//                      QueryInterface(REFIID riid, void** ppv)  
//
//  DESCRIPTION:
//
//  Supports querries for interfaces.   The only thing unusual is that
//  this object is aggregated by the proxy manager and so some interface
//  requests are passed to the outer IUnknown interface.
//
//  RETURN VALUE:
//
//  S_OK                all is well
//
//***************************************************************************

HRESULT STDMETHODCALLTYPE CSinkProxyBuffer::XSinkFacelet::
QueryInterface(REFIID riid, void** ppv)
{
    // All other interfaces are delegated to the UnkOuter
    if( riid == IID_IRpcProxyBuffer )
    {
        // Trick #2: this is an internal interface that should not be delegated!
        // ===================================================================

        return m_pObject->QueryInterface(riid, ppv);
    }
    else
    {
        return m_pObject->m_pUnkOuter->QueryInterface(riid, ppv);
    }
}

//***************************************************************************
//
//  HRESULT STDMETHODCALLTYPE CSinkProxyBuffer::XSinkFacelet::
//                      Indicate( LONG lObjectCount, IWbemClassObject** ppObjArray )  
//
//  DESCRIPTION:
//
//  Proxies the IWbemObjectSink::Indicate calls.  Note that if the stub is an
//  old style, then the old proxy/stub pair in wbemsvc.dll is used for backward
//  compatibility.
//
//  RETURN VALUE:
//
//  S_OK                all is well
//
//***************************************************************************

HRESULT STDMETHODCALLTYPE CSinkProxyBuffer::XSinkFacelet::
Indicate( LONG lObjectCount, IWbemClassObject** ppObjArray )
{
    HRESULT hr = S_OK;

    // Make sure the lObjectCount parameter and the array pointer make sense

    if ( lObjectCount < 0 )
    {
        return WBEM_E_INVALID_PARAMETER;
    }
    else if ( lObjectCount == 0 && NULL != ppObjArray )
    {
        return WBEM_E_INVALID_PARAMETER;
    }
    else if ( lObjectCount > 0 && NULL == ppObjArray )
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    LockGuard<CriticalSection> gl(m_csSafe);
    if(gl.locked() == false)
        return WBEM_E_OUT_OF_MEMORY;

    // If the stublet is an old style, just let the old proxy handle it

    if(m_pObject->m_StubType == OLD) 
        return m_pObject->m_pOldProxySink->Indicate( lObjectCount, ppObjArray );

    // If the stublet is unknown, send just the first object and check the return
    // code to determine what is on the other side. 

    if(m_pObject->m_StubType == UNKNOWN) 
    {
        hr = m_pObject->m_pOldProxySink->Indicate( 1, ppObjArray );

        // bump up pointer to the next object so that it isnt sent more than once
    
        lObjectCount--;
        ppObjArray++;

        if(FAILED(hr))
            return hr;
        if(hr == WBEM_S_NEW_STYLE)
        {
            m_pObject->m_StubType = NEW;
        }
        else
        {
            // We have an old client, set the stub type and send any remaining objects

            m_pObject->m_StubType = OLD;
            if(lObjectCount > 0)
                hr = m_pObject->m_pOldProxySink->Indicate( lObjectCount, ppObjArray );
            return hr;
        }
    }

    if(lObjectCount < 1)
        return S_OK;            // if all done, then just return.

    // Create a packet and some data for it to use.  Then calculate 
    // the length of the packet

    DWORD dwLength = 0;
    GUID* pguidClassIds = new GUID[lObjectCount];
    BOOL* pfSendFullObject = new BOOL[lObjectCount];

    // arrays will be deleted when we drop out of scope.
    CVectorDeleteMe<GUID>   delpguidClassIds( pguidClassIds );
    CVectorDeleteMe<BOOL>   delpfSendFullObject( pfSendFullObject );

    if ( NULL == pguidClassIds || NULL == pfSendFullObject )
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    CWbemObjSinkIndicatePacket packet;
    hr = packet.CalculateLength(lObjectCount, ppObjArray, &dwLength, 
            m_pObject->m_ClassToIdMap, pguidClassIds, pfSendFullObject );
    if (FAILED(hr))
    {
	DBG_PRINTFA(( pBuff, "CSinkProxyBuffer::XSinkFacelet::Indicate %08x\n",hr));
    	return hr;
    }

    // Declare the message structure

    RPCOLEMESSAGE msg;
    memset(&msg, 0, sizeof(msg));
    msg.cbBuffer = dwLength;

    // This is the id of the Invoke function.  This MUST be set before calling GetBuffer, or 
    // it will fail.

    msg.iMethod = 3;

    // allocate the channel buffer and marshal the data into it

    HRESULT hres = m_pObject->GetChannel()->GetBuffer(&msg, IID_IWbemObjectSink);
    if(FAILED(hres)) return hres;

#ifdef DBG
    BYTE * pCheckTail = (BYTE *)CBasicBlobControl::sAllocate(dwLength+8);
    if (!pCheckTail)
    	return WBEM_E_OUT_OF_MEMORY;

    BYTE * pTail = pCheckTail+dwLength;
    memcpy(pTail,"TAILTAIL",8);


    hr = packet.MarshalPacket(  pCheckTail, dwLength, lObjectCount, ppObjArray, 
                                             pguidClassIds, pfSendFullObject);

    if (0 != memcmp(pTail,"TAILTAIL",8))
    	DebugBreak();
    
    memcpy(msg.Buffer,pCheckTail,dwLength);
    
    CBasicBlobControl::sDelete(pCheckTail);
#else
    // Setup the packet for marshaling
    hr = packet.MarshalPacket(  (LPBYTE)msg.Buffer, dwLength, lObjectCount, ppObjArray, 
                                 pguidClassIds, pfSendFullObject);
#endif /* DBG*/

    // Send the data to the stub only if the marshaling was successful

    if ( SUCCEEDED( hr ) )
    {

        DWORD dwRes;
        hr = m_pObject->GetChannel()->SendReceive(&msg, &dwRes);
        if(FAILED(hr))
        {
            if(msg.Buffer)
                m_pObject->GetChannel()->FreeBuffer(&msg);
            return dwRes;
        }

        // We appear to be ok, so get HRESULT

        LPBYTE pbData = (LPBYTE) msg.Buffer;
        hr = *((HRESULT*) pbData);
        m_pObject->GetChannel()->FreeBuffer(&msg);

    }
    else
    {
        // Clean up the buffer -- Marshaling the packet failed
        if(msg.Buffer)
            m_pObject->GetChannel()->FreeBuffer(&msg);
    }

    return hr;
}

//***************************************************************************
//
//  HRESULT STDMETHODCALLTYPE CSinkProxyBuffer::XSinkFacelet::
//     SetStatus( LONG lFlags, HRESULT hResult, BSTR strParam, IWbemClassObject* pObjParam )  
//
//  DESCRIPTION:
//
//  Proxies the IWbemObjectSink::SetStatus calls.  Note that if the stub is an
//  old style, then the old proxy/stub pair in wbemsvc.dll is used for backward
//  compatibility.
//
//  RETURN VALUE:
//
//  S_OK                all is well
//
//***************************************************************************

HRESULT STDMETHODCALLTYPE CSinkProxyBuffer::XSinkFacelet::
      SetStatus( LONG lFlags, HRESULT hResult, BSTR strParam, IWbemClassObject* pObjParam )
{

    // Just pass through to the old sink.
    HRESULT hr = RPC_E_DISCONNECTED;
    try {
        if (m_pObject->m_pOldProxySink)
        {
            hr = m_pObject->m_pOldProxySink->SetStatus( lFlags, hResult, strParam, pObjParam );
        }
    } catch(...) {
        
    }
    return hr;

}

//****************************************************************************
//****************************************************************************
//                          STUB
//****************************************************************************
//****************************************************************************


//***************************************************************************
//
//  void* CSinkFactoryBuffer::GetInterface(REFIID riid)
//
//  DESCRIPTION:
//
//  CSinkFactoryBuffer is derived from CUnk.  Since CUnk handles the QI calls,
//  all classes derived from this must support this function.
//
//  RETURN VALUE:
//
//  S_OK                all is well
//
//***************************************************************************


void* CSinkStubBuffer::GetInterface(REFIID riid)
{
    if(riid == IID_IRpcStubBuffer)
        return &m_XSinkStublet;
    else
        return NULL;
}

CSinkStubBuffer::XSinkStublet::XSinkStublet(CSinkStubBuffer* pObj) 
    : CBaseStublet(pObj, IID_IWbemObjectSink), m_pServer(NULL)
{
    m_bFirstIndicate = true;
}

CSinkStubBuffer::XSinkStublet::~XSinkStublet() 
{
    if(m_pServer)
        m_pServer->Release();
}

IUnknown* CSinkStubBuffer::XSinkStublet::GetServerInterface( void )
{
    return m_pServer;
}

void** CSinkStubBuffer::XSinkStublet::GetServerPtr( void )
{
    return (void**) &m_pServer;
}

void CSinkStubBuffer::XSinkStublet::ReleaseServerPointer( void )
{
    // We only keep a single reference to this
    if ( NULL != m_pServer )
    {
        m_pServer->Release();
        m_pServer = NULL;
    }
}

//***************************************************************************
//
//  STDMETHODIMP CSinkStubBuffer::XSinkStublet::Invoke(RPCOLEMESSAGE* pMessage, 
//                                        IRpcChannelBuffer* pChannel)
//
//  DESCRIPTION:
//
//  Called when a method reaches the stublet.  This checks the method id and
//  then branches to specific code for the Indicate, or SetStatus calls.
//
//  RETURN VALUE:
//
//  S_OK                all is well
//
//***************************************************************************

STDMETHODIMP CSinkStubBuffer::XSinkStublet::Invoke(RPCOLEMESSAGE* pMessage, 
                                        IRpcChannelBuffer* pChannel)
{
    // SetStatus is a pass through to the old layer

    if ( pMessage->iMethod == 3 )
        return Indicate_Stub( pMessage, pChannel );
    else if ( pMessage->iMethod == 4 )
        return GetOldStub()->Invoke( pMessage, pChannel );
    else
        return RPC_E_SERVER_CANTUNMARSHAL_DATA;

}

//***************************************************************************
//
//  HRESULT CSinkStubBuffer::XSinkStublet::Indicate_Stub( RPCOLEMESSAGE* pMessage, 
//                                                        IRpcChannelBuffer* pBuffer )
//
//  DESCRIPTION:
//
//  Handles the Indicate function in the stublet.
//
//  RETURN VALUE:
//
//  S_OK                all is well
//
//***************************************************************************

HRESULT CSinkStubBuffer::XSinkStublet::Indicate_Stub( RPCOLEMESSAGE* pMessage, IRpcChannelBuffer* pBuffer )
{
    HRESULT             hr = RPC_E_SERVER_CANTUNMARSHAL_DATA;
    SCODE sc;

    // Determine if an old style, or new style packet has arrived

    CWbemObjSinkIndicatePacket packet( (LPBYTE) pMessage->Buffer, pMessage->cbBuffer);
    sc = packet.IsValid();
    bool bOldStyle = (S_OK != packet.IsValid());

    if(bOldStyle)
    {
        // Pass the call in using the old style stub

        hr = GetOldStub()->Invoke( pMessage, pBuffer );

		// Invoke must return S_OK, m_bFirstIndicate must be true and the actual return
		// code from the implementation code must be S_OK.

        if( hr == S_OK && m_bFirstIndicate && *(( HRESULT __RPC_FAR * )pMessage->Buffer) == S_OK )
        {
            // Let proxy know that we can handle the new style by returning a special return code.
        
            *(( HRESULT __RPC_FAR * )pMessage->Buffer) = WBEM_S_NEW_STYLE;
            m_bFirstIndicate = false;
            return hr;
        }
        return hr;
    }
    m_bFirstIndicate = false;

    // Got some new style data.  Unmarshall it.

    long lObjectCount; 
    IWbemClassObject ** pObjArray;
    sc = packet.UnmarshalPacket( lObjectCount, pObjArray, m_ClassCache );

    // Only continue if the Unmarshaling succeeded.  If it failed, we still want
    // the sc to go back to the other side

    if ( SUCCEEDED( sc ) )
    {

        // Call the acual sink

        sc = m_pServer->Indicate( lObjectCount, pObjArray );


        for ( int nCtr = 0; nCtr < lObjectCount; nCtr++ )
        {
            pObjArray[nCtr]->Release();
        }
    
        delete [] pObjArray;

    }

    // Send the results back

    pMessage->cbBuffer = sizeof(HRESULT);

    hr = pBuffer->GetBuffer( pMessage, IID_IWbemObjectSink );

    if ( SUCCEEDED( hr ) )
    {
        ((HRESULT*)pMessage->Buffer)[0] = sc;
    }
    else
    {
        hr = sc;
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\marshalers\coreprox\refrhelp.h ===
/*++

Copyright (C) 1998-2001 Microsoft Corporation

Module Name:

    REFRHELP.H

Abstract:

    Refresher helpers

History:

--*/

#ifndef __REFRESH_HELPER__H_
#define __REFRESH_HELPER__H_

#include <wbemint.h>
#include "corepol.h"
#include "parmdefs.h"
#include <winsock2.h>
#include <ipexport.h>


// Use this id if we try to readd anobject or enum during a remote reconnection
// and this fails.

#define INVALID_REMOTE_REFRESHER_ID 0xFFFFFFFF

// NO VTABLE!!!
class CRefresherId : public WBEM_REFRESHER_ID
{
private:

public:
    CRefresherId();
    CRefresherId(const WBEM_REFRESHER_ID& Other);	    
    ~CRefresherId();

    INTERNAL LPCSTR GetMachineName() {return m_szMachineName;}
    DWORD GetProcessId() {return m_dwProcessId;}
    const GUID& GetId() {return m_guidRefresherId;}

    BOOL operator==(const CRefresherId& Other) 
        {return m_guidRefresherId == Other.m_guidRefresherId;}
};

// NO VTABLE!!!
class CWbemObject;
class CRefreshInfo : public WBEM_REFRESH_INFO
{
private:
    CRefreshInfo(const WBEM_REFRESH_INFO& Other){};	
public:
    CRefreshInfo();
    ~CRefreshInfo();

    HRESULT SetRemote(IWbemRemoteRefresher* pRemRef, long lRequestId,
                    IWbemObjectAccess* pTemplate, GUID* pGuid);
    HRESULT SetClientLoadable(REFCLSID rClientClsid, LPCWSTR wszNamespace,
                    IWbemObjectAccess* pTemplate);
    HRESULT SetDirect(REFCLSID rClientClsid, LPCWSTR wszNamespace, LPCWSTR wszProviderName,
                    IWbemObjectAccess* pTemplate, _IWbemRefresherMgr* pMgr);
	HRESULT SetNonHiPerf(LPCWSTR wszNamespace, IWbemObjectAccess* pTemplate);
    void SetInvalid();
};

/*

typedef HANDLE (WINAPI * fnIcmpCreateFile)(VOID);

typedef BOOL (WINAPI * fnIcmpCloseHandle)(HANDLE);

typedef DWORD (WINAPI * fnIcmpSendEcho)(HANDLE                                IcmpHandle,
                                      IPAddr                   DestinationAddress,
                                      LPVOID                   RequestData,
                                      WORD                     RequestSize,
                                      PIP_OPTION_INFORMATION   RequestOptions,
                                      LPVOID                   ReplyBuffer,
                                      DWORD                    ReplySize,
                                      DWORD                    Timeout);

class CIPHelp
{
private:
	BOOL bWSAInit;
    static fnIcmpCreateFile IcmpCreateFile_;
    static fnIcmpCloseHandle IcmpCloseHandle_;
    static fnIcmpSendEcho IcmpSendEcho_;
    HMODULE hIpHlpApi;
public:
	CIPHelp();
	~CIPHelp();	
    BOOL IsAlive(WCHAR * pMachineName);	
};

*/

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\marshalers\coreprox\refrsvc.h ===
/*++

Copyright (C) 2000-2001 Microsoft Corporation

Module Name:

    REFRSVC.H

Abstract:

  CWbemRefreshingSvc Definition.

  Standard definition for IWbemObjectTextSrc.

History:

  24-Apr-2000	sanjes    Created.

--*/

#ifndef _REFRSVC_H_
#define _REFRSVC_H_

#include "corepol.h"
#include <arena.h>

// Update this for server side refresher code.  Make sure to update client
// version in refrcli.h as well.
#define WBEM_REFRESHER_VERSION 1

//***************************************************************************
//
//  class CWbemRefreshingSvc
//
//  Implementation of _IWmiObjectFactory Interface
//
//***************************************************************************

class COREPROX_POLARITY CWbemRefreshingSvc : public CUnk
{
private:
	IWbemServices*		m_pSvcEx;
	BSTR					m_pstrMachineName;
	BSTR					m_pstrNamespace;

public:
    CWbemRefreshingSvc(CLifeControl* pControl, IUnknown* pOuter = NULL);
	virtual ~CWbemRefreshingSvc(); 

protected:


    class COREPROX_POLARITY XWbemRefrSvc : public CImpl<IWbemRefreshingServices, CWbemRefreshingSvc>
    {
    public:
        XWbemRefrSvc(CWbemRefreshingSvc* pObject) : 
            CImpl<IWbemRefreshingServices, CWbemRefreshingSvc>(pObject)
        {}

		STDMETHOD(AddObjectToRefresher)( WBEM_REFRESHER_ID* pRefresherId, LPCWSTR wszPath, long lFlags,
					IWbemContext* pContext, DWORD dwClientRefrVersion, WBEM_REFRESH_INFO* pInfo,
					DWORD* pdwSvrRefrVersion);

		STDMETHOD(AddObjectToRefresherByTemplate)( WBEM_REFRESHER_ID* pRefresherId, IWbemClassObject* pTemplate,
					long lFlags, IWbemContext* pContext, DWORD dwClientRefrVersion, WBEM_REFRESH_INFO* pInfo,
					DWORD* pdwSvrRefrVersion);

		STDMETHOD(AddEnumToRefresher)( WBEM_REFRESHER_ID* pRefresherId, LPCWSTR wszClass, long lFlags,
					IWbemContext* pContext, DWORD dwClientRefrVersion, WBEM_REFRESH_INFO* pInfo,
					DWORD* pdwSvrRefrVersion);

		STDMETHOD(RemoveObjectFromRefresher)( WBEM_REFRESHER_ID* pRefresherId, long lId, long lFlags,
					DWORD dwClientRefrVersion, DWORD* pdwSvrRefrVersion);

		STDMETHOD(GetRemoteRefresher)( WBEM_REFRESHER_ID* pRefresherId, long lFlags, DWORD dwClientRefrVersion,
					IWbemRemoteRefresher** ppRemRefresher, GUID* pGuid, DWORD* pdwSvrRefrVersion);

		STDMETHOD(ReconnectRemoteRefresher)( WBEM_REFRESHER_ID* pRefresherId, long lFlags, long lNumObjects,
					DWORD dwClientRefrVersion, WBEM_RECONNECT_INFO* apReconnectInfo,
					WBEM_RECONNECT_RESULTS* apReconnectResults, DWORD* pdwSvrRefrVersion);

    } m_XWbemRefrSvc;
    friend XWbemRefrSvc;

    class COREPROX_POLARITY XCfgRefrSrvc : public CImpl<_IWbemConfigureRefreshingSvcs, CWbemRefreshingSvc>
    {
    public:
        XCfgRefrSrvc(CWbemRefreshingSvc* pObject) : 
            CImpl<_IWbemConfigureRefreshingSvcs, CWbemRefreshingSvc>(pObject)
        {}

		STDMETHOD(SetServiceData)( BSTR pwszMachineName, BSTR pwszNamespace );
    } m_XCfgRefrSrvc;
    friend XCfgRefrSrvc;

protected:

	virtual HRESULT AddObjectToRefresher( WBEM_REFRESHER_ID* pRefresherId, LPCWSTR wszPath, long lFlags,
				IWbemContext* pContext, DWORD dwClientRefrVersion, WBEM_REFRESH_INFO* pInfo,
				DWORD* pdwSvrRefrVersion);

	virtual HRESULT AddObjectToRefresherByTemplate( WBEM_REFRESHER_ID* pRefresherId, IWbemClassObject* pTemplate,
				long lFlags, IWbemContext* pContext, DWORD dwClientRefrVersion, WBEM_REFRESH_INFO* pInfo,
				DWORD* pdwSvrRefrVersion);

	virtual HRESULT AddEnumToRefresher( WBEM_REFRESHER_ID* pRefresherId, LPCWSTR wszClass, long lFlags,
				IWbemContext* pContext, DWORD dwClientRefrVersion, WBEM_REFRESH_INFO* pInfo,
				DWORD* pdwSvrRefrVersion);

	virtual HRESULT RemoveObjectFromRefresher( WBEM_REFRESHER_ID* pRefresherId, long lId, long lFlags,
				DWORD dwClientRefrVersion, DWORD* pdwSvrRefrVersion);

	virtual HRESULT GetRemoteRefresher( WBEM_REFRESHER_ID* pRefresherId, long lFlags, DWORD dwClientRefrVersion,
				IWbemRemoteRefresher** ppRemRefresher, GUID* pGuid, DWORD* pdwSvrRefrVersion);

	virtual HRESULT ReconnectRemoteRefresher( WBEM_REFRESHER_ID* pRefresherId, long lFlags, long lNumObjects,
				DWORD dwClientRefrVersion, WBEM_RECONNECT_INFO* apReconnectInfo,
				WBEM_RECONNECT_RESULTS* apReconnectResults, DWORD* pdwSvrRefrVersion);

	virtual HRESULT SetServiceData( BSTR pwszMachineName, BSTR pwszNamespace );

	HRESULT ResetRefreshInfo( WBEM_REFRESH_INFO* pRefreshInfo );

	HRESULT WrapRemoteRefresher( IWbemRemoteRefresher** ppRemoteRefresher );

protected:
    void* GetInterface(REFIID riid);

	// Helper functions
	HRESULT AddObjectToRefresher_( BOOL fVersionMatch, WBEM_REFRESHER_ID* pRefresherId, CWbemObject* pInstTemplate, long lFlags, IWbemContext* pContext,
									WBEM_REFRESH_INFO* pInfo);

	HRESULT CreateRefreshableObjectTemplate( LPCWSTR wszObjectPath, long lFlags, IWbemClassObject** ppInst );

	HRESULT AddEnumToRefresher_( BOOL fVersionMatch, WBEM_REFRESHER_ID* pRefresherId, CWbemObject* pInstTemplate, LPCWSTR wszClass,
								long lFlags, IWbemContext* pContext, WBEM_REFRESH_INFO* pInfo);

	BOOL IsWinmgmt( WBEM_REFRESHER_ID* pRefresherId );

	HRESULT	GetRefrMgr( _IWbemRefresherMgr** ppMgr );

public:

	BOOL Initialize( void ) { return TRUE; }

};

class CWbemRemoteRefresher : public CUnk
{
private:
	IWbemRemoteRefresher*		m_pRemRefr;

public:
    CWbemRemoteRefresher(CLifeControl* pControl, IWbemRemoteRefresher* pRemRefr, IUnknown* pOuter = NULL);
	virtual ~CWbemRemoteRefresher(); 

protected:


    class COREPROX_POLARITY XWbemRemoteRefr : public CImpl<IWbemRemoteRefresher, CWbemRemoteRefresher>
    {
    public:
        XWbemRemoteRefr(CWbemRemoteRefresher* pObject) : 
            CImpl<IWbemRemoteRefresher, CWbemRemoteRefresher>(pObject)
        {}

		STDMETHOD(RemoteRefresh)( long lFlags, long* plNumObjects, WBEM_REFRESHED_OBJECT** paObjects );
		STDMETHOD(StopRefreshing)( long lNumIds, long* aplIds, long lFlags);
		STDMETHOD(GetGuid)( long lFlags, GUID*  pGuid );

    } m_XWbemRemoteRefr;
    friend XWbemRemoteRefr;

protected:

	virtual HRESULT RemoteRefresh( long lFlags, long* plNumObjects, WBEM_REFRESHED_OBJECT** paObjects );
	virtual HRESULT StopRefreshing( long lNumIds, long* aplIds, long lFlags);
	virtual HRESULT GetGuid( long lFlags, GUID*  pGuid );

protected:
    void* GetInterface(REFIID riid);

public:

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\marshalers\coreprox\sinkmrsh.h ===
/*++

Copyright (C) 1998-2001 Microsoft Corporation

Module Name:

    SINKMRSH.H

Abstract:

    IWbemObjectSink marshaling

History:

--*/

#include <unk.h>
#include <wbemidl.h>
#include <wbemint.h>
#include <wbemcomn.h>
#include <sync.h>
#include <fastall.h>
#include <wbemclasscache.h>
#include <wbemclasstoidmap.h>
#include <objindpacket.h>
#include <lockst.h>
#include "mrshbase.h"

//***************************************************************************
//
//  class CSinkFactoryBuffer
//
//  DESCRIPTION:
//
//  This class provides the proxy stub factory so that we can provide custom
//  facelets and stublets for the IWbemObjectSink interface.
//
//***************************************************************************

class CSinkFactoryBuffer : public CUnkInternal
{
	IRpcProxyBuffer*	m_pOldProxy;
	IRpcStubBuffer*		m_pOldStub;

	// We don't want to AddRef the life control, but
	// we need to let objects we create AddRef it, so the
	// base class won't keep this pointer, but we will.

	CLifeControl*		m_pLifeControl;

protected:
    class XSinkFactory : public CImpl<IPSFactoryBuffer, CSinkFactoryBuffer>
    {
    public:
        XSinkFactory(CSinkFactoryBuffer* pObj) :
            CImpl<IPSFactoryBuffer, CSinkFactoryBuffer>(pObj)
        {}
        
        STDMETHOD(CreateProxy)(IN IUnknown* pUnkOuter, IN REFIID riid, 
            OUT IRpcProxyBuffer** ppProxy, void** ppv);
        STDMETHOD(CreateStub)(IN REFIID riid, IN IUnknown* pUnkServer, 
            OUT IRpcStubBuffer** ppStub);
    } m_XSinkFactory;
public:
    CSinkFactoryBuffer(CLifeControl* pControl)
        : CUnkInternal(pControl), m_pLifeControl( pControl ), m_XSinkFactory(this)
    {
    }
    ~CSinkFactoryBuffer()
    {
    }    

    void* GetInterface(REFIID riid);

	friend XSinkFactory;
};

//***************************************************************************
//
//  class CSinkProxyBuffer
//
//  DESCRIPTION:
//
//  This class provides the facelet for the IWbemObjectSink interface.
//
//    Trick #1: This object is derived from IRpcProxyBuffer since IRpcProxyBuffer
//    is its "internal" interface --- the interface that does not delegate to the
//    aggregator. (Unlike in normal objects, where that interface is IUnknown)
//
//***************************************************************************

class CSinkProxyBuffer : public CBaseProxyBuffer
{
private:
    enum {OLD, NEW, UNKNOWN} m_StubType;
    CWbemClassToIdMap m_ClassToIdMap;

protected:
	IWbemObjectSink*	m_pOldProxySink;

protected:
    class XSinkFacelet : public IWbemObjectSink
    {
    protected:
        CSinkProxyBuffer* m_pObject;
        CriticalSection m_csSafe;        

    public:
        XSinkFacelet(CSinkProxyBuffer* pObject) : m_pObject(pObject), m_csSafe(false){};

        ULONG STDMETHODCALLTYPE AddRef() 
        {return m_pObject->m_pUnkOuter->AddRef();}
        ULONG STDMETHODCALLTYPE Release() 
        {return m_pObject->m_pUnkOuter->Release();}
        HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, void** ppv);
        HRESULT STDMETHODCALLTYPE Indicate( LONG lObjectCount, IWbemClassObject** ppObjArray );
		HRESULT STDMETHODCALLTYPE SetStatus( LONG lFlags, HRESULT hResult, BSTR strParam, IWbemClassObject* pObjParam );
    } m_XSinkFacelet;
    friend XSinkFacelet;

protected:

	// Pure Virtuals from base class
	void*	GetInterface( REFIID riid );
	void**	GetOldProxyInterfacePtr( void );
	void	ReleaseOldProxyInterface( void );

public:
    CSinkProxyBuffer(CLifeControl* pControl, IUnknown* pUnkOuter);
    ~CSinkProxyBuffer();
};

//***************************************************************************
//
//  class CSinkStubBuffer
//
//  DESCRIPTION:
//
//  This class provides the stublet for the IWbemObjectSink interface.
//
//***************************************************************************

class CSinkStubBuffer : public CBaseStubBuffer
{

protected:
    class XSinkStublet : public CBaseStublet
    {
        IWbemObjectSink* m_pServer;
        CWbemClassCache m_ClassCache;
        bool m_bFirstIndicate;

	protected:

		virtual IUnknown*	GetServerInterface( void );
		virtual void**	GetServerPtr( void );
		virtual void	ReleaseServerPointer( void );

    public:
        XSinkStublet(CSinkStubBuffer* pObj);
        ~XSinkStublet();

        STDMETHOD(Invoke)(RPCOLEMESSAGE* pMessage, IRpcChannelBuffer* pBuffer);
        
	private:
		HRESULT Indicate_Stub( RPCOLEMESSAGE* pMessage, IRpcChannelBuffer* pBuffer );
        friend CSinkStubBuffer;
    } m_XSinkStublet;
    friend XSinkStublet;

public:
    CSinkStubBuffer(CLifeControl* pControl, IUnknown* pUnkOuter = NULL)
        : CBaseStubBuffer( pControl, pUnkOuter ), m_XSinkStublet(this)
    {}
    void* GetInterface(REFIID riid);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\marshalers\coreprox\smrtenum.h ===
/*++

Copyright (C) 2000-2001 Microsoft Corporation

Module Name:

    SMRTENUM.H

Abstract:

  CWbemEnumMarshaling Definition.

  Standard definition for _IWbemEnumMarshaling.

History:

  22-Feb-2000	sanjes    Created.

--*/

#ifndef _SMRTENUM_H_
#define _SMRTENUM_H_

#include "corepol.h"
#include <arena.h>
#include <unk.h>
#include <sync.h>

// Marshaling Packet definitions
#include <wbemclasscache.h>
#include <wbemclasstoidmap.h>
#include <wbemguidtoclassmap.h>
#include <smartnextpacket.h>

//***************************************************************************
//
//  class CWbemEnumMarshaling
//
//  Implementation of _IWbemEnumMarshaling Interface
//
//***************************************************************************

class COREPROX_POLARITY CWbemEnumMarshaling : public CUnk
{
protected:
	// Maintains per proxy class maps
	CWbemGuidToClassMap	m_GuidToClassMap;
	CCritSec			m_cs;

public:
    CWbemEnumMarshaling(CLifeControl* pControl, IUnknown* pOuter = NULL);
	~CWbemEnumMarshaling(); 

	/* _IWbemEnumMarshaling methods */
    HRESULT GetMarshalPacket( REFGUID proxyGUID, ULONG uCount, IWbemClassObject** apObjects,
								ULONG* pdwBuffSize, byte** pBuffer );

    class COREPROX_POLARITY XEnumMarshaling : public CImpl<_IWbemEnumMarshaling, CWbemEnumMarshaling>
    {
    public:
        XEnumMarshaling(CWbemEnumMarshaling* pObject) : 
            CImpl<_IWbemEnumMarshaling, CWbemEnumMarshaling>(pObject)
        {}

		STDMETHOD(GetMarshalPacket)( REFGUID proxyGUID, ULONG uCount, IWbemClassObject** apObjects,
									ULONG* pdwBuffSize, byte** pBuffer );

    } m_XEnumMarshaling;
    friend XEnumMarshaling;


protected:
    void* GetInterface(REFIID riid);
	
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\marshalers\coreprox\smartnextpacket.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    SMARTNEXTPACKET.H

Abstract:

    Smart Next Packets

History:


--*/

#ifndef __SMARTNEXTPACKET_H__
#define __SMARTNEXTPACKET_H__

#include "wbemdatapacket.h"
#include "wbemobjpacket.h"
#include "wbemclasstoidmap.h"
#include "wbemclasscache.h"

// Store the current packing value, then set our own value
#pragma pack( push )
#pragma pack( 1 )

// IWbemWCOSmartEnum::Next() Header.  Changing this will
// cause the main version to change
typedef struct tagWBEM_DATAPACKET_SMARTENUM_NEXT
{
	DWORD	dwSizeOfHeader;	// Size of the header struct.  Data immediately follows header.
	DWORD	dwDataSize;		// Size of Data following header.
} WBEM_DATAPACKET_SMARTENUM_NEXT;

typedef WBEM_DATAPACKET_SMARTENUM_NEXT* PWBEM_DATAPACKET_SMARTENUM_NEXT;

// restore packing
#pragma pack( pop )

//
//	Class: CWbemSmartEnumNextPacket
//
//	This class is designed to wrapper a data packet that describes data
//	for IWbemWCOSmartEnum::Next.  Basically, it sits in front of an oject
//	array packet that describes 1..n IWbemClassObject packets.
//

class COREPROX_POLARITY CWbemSmartEnumNextPacket : public CWbemDataPacket
{

protected:

	PWBEM_DATAPACKET_SMARTENUM_NEXT	m_pSmartEnumNext;

public:

	CWbemSmartEnumNextPacket( LPBYTE pDataPacket = NULL, DWORD dwPacketLength = 0 );
	~CWbemSmartEnumNextPacket();

	HRESULT CalculateLength( LONG lObjectCount, IWbemClassObject** apClassObjects, DWORD* pdwLength, CWbemClassToIdMap& classtoidmap, GUID* pguidClassIds, BOOL* pfSendFullObject );
	HRESULT MarshalPacket( LONG lObjectCount, IWbemClassObject** apClassObjects, GUID* paguidClassIds, BOOL* pfSendFullObject );
	HRESULT UnmarshalPacket( LONG& lObjectCount, IWbemClassObject**& apClassObjects, CWbemClassCache& classcache );

	// inline helper
	HRESULT MarshalPacket( LPBYTE pData, DWORD dwPacketLength, LONG lObjectCount, IWbemClassObject** apClassObjects, GUID* paguidClassIds, BOOL* pfSendFullObject );

	// Change the underlying pointers
	// Override of base class
	void SetData( LPBYTE pDataPacket, DWORD dwPacketLength );

};

inline HRESULT CWbemSmartEnumNextPacket::MarshalPacket( LPBYTE pData, DWORD dwPacketLength, LONG lObjectCount, IWbemClassObject** apClassObjects, GUID* paguidClassIds, BOOL* pfSendFullObject )
{
	SetData( pData, dwPacketLength );
	return MarshalPacket( lObjectCount, apClassObjects, paguidClassIds, pfSendFullObject );
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\marshalers\coreprox\svcmrsh.h ===
/*++

Copyright (C) 2000-2001 Microsoft Corporation

Module Name:

    SVCMRSH.H

Abstract:

    IWbemServices marshaling

History:

--*/

#include <unk.h>
#include <wbemidl.h>
#include <wbemint.h>
#include <wbemcomn.h>
#include "mrshbase.h"
#include "svcwrap.h"

//***************************************************************************
//
//  class CSvcFactoryBuffer
//
//  DESCRIPTION:
//
//  This class provides the proxy stub factory so that we can provide custom
//  facelets and stublets for the IWbemService interface.
//
//***************************************************************************

class CSvcFactoryBuffer : public CUnkInternal
{
	IRpcProxyBuffer*	m_pOldProxy;
	IRpcStubBuffer*		m_pOldStub;

	// We don't want to AddRef the life control, but
	// we need to let objects we create AddRef it, so the
	// base class won't keep this pointer, but we will.

	CLifeControl*		m_pLifeControl;

protected:
    class XSvcFactory : public CImpl<IPSFactoryBuffer, CSvcFactoryBuffer>
    {
    public:
        XSvcFactory(CSvcFactoryBuffer* pObj) :
            CImpl<IPSFactoryBuffer, CSvcFactoryBuffer>(pObj)
        {}
        
        STDMETHOD(CreateProxy)(IN IUnknown* pUnkOuter, IN REFIID riid, 
            OUT IRpcProxyBuffer** ppProxy, void** ppv);
        STDMETHOD(CreateStub)(IN REFIID riid, IN IUnknown* pUnkServer, 
            OUT IRpcStubBuffer** ppStub);
    } m_XSvcFactory;
public:
    CSvcFactoryBuffer(CLifeControl* pControl)
        : CUnkInternal(pControl), m_pLifeControl( pControl ), m_XSvcFactory(this)
    {
    }
    ~CSvcFactoryBuffer()
    {
    }    
    

    void* GetInterface(REFIID riid);

	friend XSvcFactory;
};

//***************************************************************************
//
//  class CSvcProxyBuffer
//
//  DESCRIPTION:
//
//  This class provides the facelet for the IWbemServices interface.
//
//    Trick #1: This object is derived from IRpcProxyBuffer since IRpcProxyBuffer
//    is its "internal" interface --- the interface that does not delegate to the
//    aggregator. (Unlike in normal objects, where that interface is IUnknown)
//
//***************************************************************************

class CSvcProxyBuffer : public CBaseProxyBuffer
{
protected:
	IWbemServices*	m_pOldProxySvc;
	CWbemSvcWrapper*	m_pWrapperProxy;

protected:

	// Pure Virtuals from base class
	void*	GetInterface( REFIID riid );
	void**	GetOldProxyInterfacePtr( void );
	void	ReleaseOldProxyInterface( void );

	// Special overrides
    STDMETHOD(Connect)(IRpcChannelBuffer* pChannel);
    STDMETHOD_(void, Disconnect)();

public:
    CSvcProxyBuffer(CLifeControl* pControl, IUnknown* pUnkOuter);
    ~CSvcProxyBuffer();

	HRESULT Init( void );
};

//***************************************************************************
//
//  class CSvcStubBuffer
//
//  DESCRIPTION:
//
//  This class provides the stublet for the IWbemServices interface.
//
//***************************************************************************

class CSvcStubBuffer : public CBaseStubBuffer
{

protected:
    class XSvcStublet : public CBaseStublet
    {
        IWbemServices* m_pServer;

	protected:

		virtual IUnknown*	GetServerInterface( void );
		virtual void**	GetServerPtr( void );
		virtual void	ReleaseServerPointer( void );

    public:
        XSvcStublet(CSvcStubBuffer* pObj);
        ~XSvcStublet();

	private:
        friend CSvcStubBuffer;
    } m_XSvcStublet;
    friend XSvcStublet;

public:
    CSvcStubBuffer(CLifeControl* pControl, IUnknown* pUnkOuter = NULL)
        : CBaseStubBuffer( pControl, pUnkOuter ), m_XSvcStublet(this)
    {}
    void* GetInterface(REFIID riid);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\marshalers\coreprox\smrtenum.cpp ===
/*++

Copyright (C) 2000-2001 Microsoft Corporation

Module Name:

    SMRTENUM.CPP

Abstract:

  CWbemEnumMarshling implementation.

  Implements the _IWbemEnumMarshaling interface.

History:

  20-Feb-2000	sanjes    Created.

--*/

#include "precomp.h"
#include <stdio.h>
#include <wbemcomn.h>
#include "fastall.h"
#include "smrtenum.h"
#include <corex.h>

//***************************************************************************
//
//  CWbemEnumMarshaling::~CWbemEnumMarshaling
//
//***************************************************************************
// ok
CWbemEnumMarshaling::CWbemEnumMarshaling( CLifeControl* pControl, IUnknown* pOuter )
:	CUnk(pControl, pOuter),
	m_XEnumMarshaling( this )
{
}
    
//***************************************************************************
//
//  CWbemEnumMarshaling::~CWbemEnumMarshaling
//
//***************************************************************************
// ok
CWbemEnumMarshaling::~CWbemEnumMarshaling()
{
}

// Override that returns us an interface
void* CWbemEnumMarshaling::GetInterface( REFIID riid )
{
    if(riid == IID_IUnknown || riid == IID__IWbemEnumMarshaling)
        return &m_XEnumMarshaling;
    else
        return NULL;
}

/* _IWbemEnumMarshaling methods */

HRESULT CWbemEnumMarshaling::XEnumMarshaling::GetMarshalPacket( REFGUID proxyGUID, ULONG uCount, IWbemClassObject** apObjects,
																ULONG* pdwBuffSize, byte** pBuffer )
{
	return m_pObject->GetMarshalPacket( proxyGUID, uCount, apObjects, pdwBuffSize, pBuffer );
}


// Specifies everything we could possibly want to know about the creation of
// an object and more.
HRESULT CWbemEnumMarshaling::GetMarshalPacket( REFGUID proxyGUID, ULONG uCount, IWbemClassObject** apObjects,
												ULONG* pdwBuffSize, byte** pBuffer )
{
	HRESULT	hr = WBEM_S_NO_ERROR;

	try
	{
		CInCritSec	ics( &m_cs );

		// Look for the GUID in the cache.  If we don't find it, it's new so add it
		CWbemClassToIdMap*		pClassToId = NULL;
		CGUID					guid( proxyGUID );

		hr = m_GuidToClassMap.GetMap( guid, &pClassToId );

		if ( FAILED( hr ) )
		{
			hr = m_GuidToClassMap.AddMap( guid, &pClassToId );
		}

		// Only continue if we have a cache to work with
		if ( SUCCEEDED( hr ) )
		{

			// Only marshal data if we need to
			if ( uCount > 0 )
			{
				// Calculate data length first
				DWORD dwLength = 0;
				GUID* pguidClassIds = new GUID[uCount];
				BOOL* pfSendFullObject = new BOOL[uCount];
				CWbemSmartEnumNextPacket packet;

				// Auto cleanup
				CVectorDeleteMe<GUID>	vdm1( pguidClassIds );
				CVectorDeleteMe<BOOL>	vdm2( pfSendFullObject );

                if(pguidClassIds && pfSendFullObject)
				{
    				hr = packet.CalculateLength(uCount, apObjects, &dwLength,
						*pClassToId, pguidClassIds, pfSendFullObject );
				}
                else
				{
					hr = WBEM_E_OUT_OF_MEMORY;
				}

				if ( SUCCEEDED( hr ) )
				{

					// As we could be going cross process/machine, use the
					// COM memory allocator
					LPBYTE pbData = (LPBYTE) CoTaskMemAlloc( dwLength );

					if ( NULL != pbData )
					{
						// hr contains the actual proper return code, so let's not overwrite
						// that valu unless something goes wrong during marshaling.

						// Write the objects out to the buffer
						hr = packet.MarshalPacket( pbData, dwLength, uCount, apObjects,
													 pguidClassIds, pfSendFullObject);

						// Copy the values, we're golden.
						if ( SUCCEEDED( hr ) )
						{
							*pdwBuffSize = dwLength;
							*pBuffer = pbData;
						}
						else
						{
							// Clean up the memory --- something went wrong
							CoTaskMemFree( pbData );
						}
					}
					else
					{
						hr = WBEM_E_OUT_OF_MEMORY;
					}

				}	// IF CalculateLength()

			}	// IF *puReturned > 0
			else
			{
				// NULL these out
				*pdwBuffSize = 0;
				*pBuffer = NULL;
			}


		}

		return hr;
	}
	catch ( CX_MemoryException )
	{
		return WBEM_E_OUT_OF_MEMORY;
	}
	catch ( ... )
	{
		return WBEM_E_CRITICAL_ERROR;
	}

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\marshalers\coreprox\strm.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    STRM.H

Abstract:

  CMemStream implementation.

  CMemStream implementation for WBEM.

  This is a thread-safe generic data stream which can be used
  with memory objects, pipes, mailslots, or files.  This is the basic
  object for interface & call marshaling.

  a-raymcc    04-Apr-96   Created.
  a-raymcc    06-Jun-96   CArena support.
  a-raymcc    11-Sep-96   Support NULL pointers

  Supported types:
      VT_NULL

      VT_UI1, VT_I1, VT_UI2, VT_I2, VT_UI4, VT_I4, VT_I8, VT_UI8
      VT_R4, VT_R8, VT_BOOL

      VT_LPSTR, VT_LPWSTR, VT_BSTR

      VT_CLSID, VT_UNKNOWN, VT_FILETIME, VT_ERROR, VT_BLOB, VT_PTR

      VT_EMPTY = End of stream

      VT_USERDEFINED      
          VT_EX_VAR
          VT_EX_VARVECTOR

History:

--*/


#ifndef _STRM_H_
#define _STRM_H_
#include "corepol.h"

#include <arena.h>
#include <var.h>
#include <wbemutil.h>

#define SIGNATURE_STREAM            0x80F6A003

#pragma warning(disable: 4275)

class COREPROX_POLARITY CMemStream : public IStream
{
protected:

    // Types, constants.
    // =================
    enum { stack_size = 32 };

    struct STREAM_HEADER
    {
        DWORD dwSignature;
        DWORD dwLength;

        STREAM_HEADER() { dwSignature = SIGNATURE_STREAM; }
        BOOL Verify() { return SIGNATURE_STREAM == dwSignature; }
    };

    // Member variables.
    // =================
    int     m_nStatus;
    DWORD   m_dwSize;
    DWORD   m_dwGrowBy;
    DWORD   m_dwCurrentPos;
    DWORD   m_dwEndOfStream;
    BYTE    *m_pBuffer;
    int     m_nFlags;
    DWORD   m_dwStack[stack_size];
    int     m_nStackPtr;
    
    long    m_lRef;

    // protected functions.
    // ==================
    void Empty();
    int Resize(DWORD dwNewSize);
    void UpdateHdr() { ((STREAM_HEADER *)m_pBuffer)->dwLength = m_dwEndOfStream; }
            
public:
    enum { no_error, failed, type_mismatch, end_of_stream, 
           out_of_memory, critical_error, invalid_parameter , timeout };
        
    enum { auto_delete, no_delete };
    
    CMemStream(
        int nFlags = auto_delete, 
        int nInitialSize = 512, 
        int nGrowBy = 512
        );

    CMemStream(
        LPVOID pBindingAddress,
        int nFlags = auto_delete, 
        int nGrowBy = 512
        );
        
    CMemStream(CMemStream &Src);
    CMemStream &operator =(CMemStream &Src);
   ~CMemStream();
        // Releases the arena

    void Push() { m_dwStack[++m_nStackPtr] = m_dwCurrentPos; }
    void Pop(BOOL bDiscard);
    
    void Unbind() { m_nFlags = no_delete; }
            
    int Append(CMemStream *pSrc);
    
    int Deserialize(HANDLE hFile);
    int Deserialize(FILE *fStream);
    int Deserialize(LPBYTE pBlock, DWORD dwSize); 
    
    int Serialize(HANDLE hFile);
    int Serialize(FILE *fStream);
    int Serialize(BYTE **pBlock, DWORD *pdwSize);
         // Use HeapFree() if no arena present

    void    Trim() { UpdateHdr(); Resize(m_dwEndOfStream); }     // Reduce excess of internal block.
             
    int     Status() { return m_nStatus; }
    DWORD   GetCurrentPos() { return m_dwCurrentPos; }
    void    SetCurrentPos(DWORD dwPos) { m_dwCurrentPos = dwPos; }
    DWORD   Size() { return m_dwEndOfStream; }
    DWORD   BufferSize() { return m_dwSize; }
    LPVOID  GetPtr() { UpdateHdr(); return m_pBuffer; }    
    void    Reset() { m_dwCurrentPos = sizeof(STREAM_HEADER); }
    int     NextType();

    int WriteType(DWORD dwType) { return WriteBytes(&dwType, sizeof(DWORD)); }
                               
    // Write operations.
    // ==================
    
    int WriteBytes(LPVOID, DWORD);

    int WriteNull() { return WriteType(VT_NULL); }

    int WriteChar(IN char c);
    int WriteByte(IN BYTE b);
    int WriteShort(IN SHORT iVal);
    int WriteWORD(IN WORD wVal);
    int WriteLong(IN LONG l);
    int WriteDWORD(IN DWORD dwVal);
    int WriteFloat(IN float fltVal);
    int WriteDouble(IN double dblVal);
    int WriteBool(IN VARIANT_BOOL b);
    
    int WriteLPSTR(IN LPSTR pStr);
    int WriteLPWSTR(IN LPWSTR pStr);
    int WriteBSTR(IN BSTR pStr);

    int WriteCLSID(IN CLSID *pClsId);
    int WriteUnknown(IN IUnknown *pObj);
    int WriteFILETIME(IN FILETIME *pTime);
    int WriteError(IN SCODE sVal);        
    int WriteBlob(IN BLOB *pBlob);
    int WritePtr(IN LPVOID p);

    int WriteCVar(IN CVar *pObj);
    int WriteCVarVector(IN CVarVector *pObj);

    // Read operations.
    // ================
                    
    int ReadBytes(LPVOID, DWORD);

    int ReadNull();
    int ReadByte(OUT BYTE *pByte);
    int ReadChar(OUT char *pc);
    int ReadShort(OUT SHORT *piVal);
    int ReadWORD(OUT WORD *pwVal);
    int ReadLong(OUT LONG *plVal);
    int ReadDWORD(OUT DWORD *pdwVal);
    int ReadFloat(OUT float *pfltVal);
    int ReadDouble(OUT double *pdlbVal);    
    int ReadBool(OUT VARIANT_BOOL *pBool);
    
    int ReadLPSTR(OUT LPSTR *pStr);
    int ReadLPWSTR(OUT LPWSTR *pStr);
    int ReadBSTR(OUT BSTR *pStr);

    int ReadCLSID(OUT CLSID *pClsId);
    int ReadUnknown(IUnknown **pObj);
    int ReadFILETIME(OUT FILETIME *pTime);
    int ReadError(OUT SCODE *pVal);
    int ReadBlob(OUT BLOB *pBlob);
    int ReadPtr(OUT LPVOID *p);

    int ReadCVar(OUT CVar **pObj);    
    int ReadCVarVector(OUT CVarVector **pObj);

    int ReadType();  

    BOOL EndOfStream() { return m_dwCurrentPos == m_dwEndOfStream; }

    // IStream implementation
    STDMETHOD_(ULONG, AddRef)()
    {
        return InterlockedIncrement(&m_lRef);
    }

    STDMETHOD_(ULONG, Release)()
    {
        long lRef = InterlockedDecrement(&m_lRef);
        if(lRef == 0) delete this;
        return lRef;
    }
    STDMETHOD(QueryInterface)(REFIID riid, void** ppv);

    STDMETHOD(Read)(
         void *pv,
         ULONG cb,
         ULONG *pcbRead);

    STDMETHOD(Write)(
         const void *pv,
         ULONG cb,
         ULONG *pcbWritten);

    STDMETHOD(Seek)(
         LARGE_INTEGER dlibMove,
         DWORD dwOrigin,
         ULARGE_INTEGER *plibNewPosition);

    STDMETHOD(SetSize)(
         ULARGE_INTEGER libNewSize);

    STDMETHOD(CopyTo)(
         IStream *pstm,
         ULARGE_INTEGER cb,
         ULARGE_INTEGER *pcbRead,
         ULARGE_INTEGER *pcbWritten);

    STDMETHOD(Commit)(
         DWORD grfCommitFlags);

    STDMETHOD(Revert)( void);

    STDMETHOD(LockRegion)(
         ULARGE_INTEGER libOffset,
         ULARGE_INTEGER cb,
         DWORD dwLockType);

    STDMETHOD(UnlockRegion)(
         ULARGE_INTEGER libOffset,
         ULARGE_INTEGER cb,
         DWORD dwLockType);

    STDMETHOD(Stat)(
         STATSTG *pstatstg,
         DWORD grfStatFlag);

    STDMETHOD(Clone)(
         IStream **ppstm);
};
                            
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\marshalers\coreprox\smartnextpacket.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    SMARTNEXTPACKET.CPP

Abstract:

    Smart Next Packets

History:


--*/

#include "precomp.h"
#include <stdio.h>
#include <stdlib.h>
#include <wbemcomn.h>
#include <fastall.h>
#include "smartnextpacket.h"
#include "objarraypacket.h"

///////////////////////////////////////////////////////////////////
//
//  Function:   CWbemSmartEnumNextPacket::CWbemSmartEnumNextPacket
//  
//  Class Constructor
//
//  Inputs:
//              LPBYTE                      pDataPacket - Memory block.
//              DWORD                       dwPacketLength - Block Length.
//
//  Outputs:
//              None.
//
//  Returns:
//              None.
//
//  Comments:   Data must be supplied to this class for Unmarshaling
//              to succeed.
//
///////////////////////////////////////////////////////////////////

CWbemSmartEnumNextPacket::CWbemSmartEnumNextPacket( LPBYTE pDataPacket /* = NULL */, DWORD dwPacketLength /* = 0 */ )
:   CWbemDataPacket( pDataPacket, dwPacketLength ),
    m_pSmartEnumNext( NULL )
{
    if ( NULL != pDataPacket )
    {
        m_pSmartEnumNext = (PWBEM_DATAPACKET_SMARTENUM_NEXT) (pDataPacket + sizeof(WBEM_DATAPACKET_HEADER) );
    }
}

///////////////////////////////////////////////////////////////////
//
//  Function:   CWbemSmartEnumNextPacket::~CWbemSmartEnumNextPacket
//  
//  Class Destructor
//
//  Inputs:
//              None.
//
//  Outputs:
//              None.
//
//  Returns:
//              None.
//
//  Comments:   None.
//
///////////////////////////////////////////////////////////////////

CWbemSmartEnumNextPacket::~CWbemSmartEnumNextPacket()
{
}

///////////////////////////////////////////////////////////////////
//
//  Function:   CWbemSmartEnumNextPacket::CalculateLength
//  
//  Calculates the length needed to packetize the supplied data.
//
//  Inputs:
//              LONG                lObjectCount - Number of objects
//              IWbemClassObject**  apClassObjects - Array of object pointers.
//
//  Outputs:
//              DWORD*              pdwLength - Calculated Length
//              CWbemClassToIdMap&  classtoidmap - Map of class names to
//                                                  GUIDs.
//              GUID*               pguidClassIds - Array of GUIDs
//              BOOL*               pfSendFullObject - Full object flag array
//
//  Returns:
//              WBEM_S_NO_ERROR if success.
//
//  Comments:   This function uses the classtoidmap to fill out the
//              Class ID and Full Object arrays.  So that the object
//              array can be correctly interpreted by MarshalPacket.
//
///////////////////////////////////////////////////////////////////

HRESULT CWbemSmartEnumNextPacket::CalculateLength( LONG lObjectCount, IWbemClassObject** apClassObjects, DWORD* pdwLength, CWbemClassToIdMap& classtoidmap, GUID* pguidClassIds, BOOL* pfSendFullObject )
{
    HRESULT hr = WBEM_S_NO_ERROR;
    DWORD   dwLength = 0;

    // Now get the size of the objects as described by the object array
    CWbemObjectArrayPacket  arrayPacket;

    hr = arrayPacket.CalculateLength( lObjectCount, apClassObjects, &dwLength, classtoidmap, pguidClassIds, pfSendFullObject );

    // Store the length if we're okey-dokey
    if ( SUCCEEDED( hr ) )
    {
        // Account for the header sizes
        *pdwLength = ( dwLength + sizeof( WBEM_DATAPACKET_HEADER ) + sizeof( WBEM_DATAPACKET_SMARTENUM_NEXT ) );
    }
    
    return hr;

}

///////////////////////////////////////////////////////////////////
//
//  Function:   CWbemSmartEnumNextPacket::MarshalPacket
//  
//  Marshals the supplied data into a buffer.
//
//  Inputs:
//              LONG                lObjectCount - Nmber of objects to marshal.
//              IWbemClassObject**  apClassObjects - Array of objects to write
//              GUID*               paguidClassIds - Array of GUIDs for objects.
//              BOOL*               pfSendFullObject - Full bject flags
//  Outputs:
//              None.
//
//  Returns:
//              WBEM_S_NO_ERROR if success.
//
//  Comments:   The GUID array and the array of flags must be filled
//              out correctly and the buffer must be large enough to
//              handle the marshaling.  The arrays will get filled
//              out correctly by CalculateLength().
//
///////////////////////////////////////////////////////////////////

HRESULT CWbemSmartEnumNextPacket::MarshalPacket( LONG lObjectCount, IWbemClassObject** apClassObjects, GUID* paguidClassIds, BOOL* pfSendFullObject )
{
    if (m_pSmartEnumNext==0) return WBEM_E_CRITICAL_ERROR; 

    HRESULT hr = WBEM_E_FAILED;
    // Setup the main header first
    hr = SetupDataPacketHeader( m_dwPacketLength - sizeof(WBEM_DATAPACKET_HEADER), WBEM_DATAPACKETTYPE_SMARTENUM_NEXT, 0 );

    if ( SUCCEEDED( hr ) )
    {
        // Setup pbData and dwLength so we can walk through our header
        LPBYTE  pbData      =   (LPBYTE) m_pSmartEnumNext;
        DWORD   dwLength    =   m_dwPacketLength - sizeof(WBEM_DATAPACKET_HEADER);

        // Fill out the packet Header
        m_pSmartEnumNext->dwSizeOfHeader = sizeof(WBEM_DATAPACKET_SMARTENUM_NEXT);
        m_pSmartEnumNext->dwDataSize = dwLength - sizeof(WBEM_DATAPACKET_SMARTENUM_NEXT);

        // Account for the indicate header
        pbData += sizeof(WBEM_DATAPACKET_SMARTENUM_NEXT);
        dwLength -= sizeof(WBEM_DATAPACKET_SMARTENUM_NEXT);

        // Now use the array packet class to marshal the objects into the buffer
        CWbemObjectArrayPacket  arrayPacket( pbData, dwLength );
        hr = arrayPacket.MarshalPacket( lObjectCount, apClassObjects, paguidClassIds, pfSendFullObject );

    }   // IF SetupDataPacketHeader

    return hr;
}

///////////////////////////////////////////////////////////////////
//
//  Function:   CWbemSmartEnumNextPacket::UnmarshalPacket
//  
//  Unmarshals data from a buffer into the supplied parameters.
//
//  Inputs:
//              None.
//  Outputs:
//              LONG&               lObjectCount - Number of unmarshaled objects.
//              IWbemClassObject**& apClassObjects - Array of unmarshaled objects,
//              CWbemClassCache&    classCache - Class Cache used to wire up
//                                                  classless instances.
//
//  Returns:
//              WBEM_S_NO_ERROR if success.
//
//  Comments:   If function succeeds, the caller is responsible for cleaning
//              up and freeing the Class Object Array.  The class cache is
//              only used when we are dealing with Instance objects..
//
///////////////////////////////////////////////////////////////////

HRESULT CWbemSmartEnumNextPacket::UnmarshalPacket( LONG& lObjectCount, IWbemClassObject**& apClassObjects, CWbemClassCache& classCache )
{
    if (m_pSmartEnumNext==0) return WBEM_E_CRITICAL_ERROR;    

    HRESULT hr = WBEM_E_FAILED;
    
    LPBYTE  pbData = (LPBYTE) m_pSmartEnumNext;
    DWORD   dwLength    =   m_dwPacketLength - sizeof(WBEM_DATAPACKET_HEADER);

    // Set the array to NULL.
    apClassObjects = NULL;

    // Check that the underlying BLOB is OK
    hr = IsValid();

    if ( SUCCEEDED( hr ) )
    {
        // Skip past the headers, and use the object array to unmarshal the
        // objects from the buffer

        // Points us at the first object
        pbData += sizeof(WBEM_DATAPACKET_SMARTENUM_NEXT);
        dwLength -= sizeof(WBEM_DATAPACKET_SMARTENUM_NEXT);

        CWbemObjectArrayPacket  arrayPacket( pbData, dwLength );
        hr = arrayPacket.UnmarshalPacket( lObjectCount, apClassObjects, classCache );

    }   // IF IsValid

    return hr;
}

///////////////////////////////////////////////////////////////////
//
//  Function:   CWbemSmartEnumNextPacket::SetData
//  
//  Sets buffer to Marshal/Unmarshal to
//
//  Inputs:
//              LPBYTE                      pDataPacket - Memory block.
//              DWORD                       dwPacketLength - Block Length.
//
//  Outputs:
//              None.
//
//  Returns:
//              None.
//
//  Comments:   Data must be supplied to this class for IsValid
//              to succeed.
//
///////////////////////////////////////////////////////////////////

void CWbemSmartEnumNextPacket::SetData( LPBYTE pDataPacket, DWORD dwPacketLength )
{
    // Go to our offset in the packet (assuming the packet is valid)
    if ( NULL != pDataPacket )
    {
        m_pSmartEnumNext = (PWBEM_DATAPACKET_SMARTENUM_NEXT) (pDataPacket + sizeof(WBEM_DATAPACKET_HEADER) );
    }
    else
    {
        m_pSmartEnumNext = NULL;
    }

    // Initialize the base class
    CWbemDataPacket::SetData( pDataPacket, dwPacketLength );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\marshalers\coreprox\svcmrsh.cpp ===
/*++

Copyright (C) 2000-2001 Microsoft Corporation

Module Name:

    SVCMRSH.CPP

Abstract:

    IWbemServices marshaling

History:

--*/

#include "precomp.h"
#include <stdio.h>
#include "Svcmrsh.h"
#include <fastall.h>

#define WBEM_S_NEW_STYLE 0x400FF

//****************************************************************************
//****************************************************************************
//                          PS FACTORY
//****************************************************************************
//****************************************************************************

//***************************************************************************
//
//  CSvcFactoryBuffer::XSvcFactory::CreateProxy
//
//  DESCRIPTION:
//
//  Creates a facelet.  Also sets the outer unknown since the proxy is going to be 
//  aggregated.
//
//  RETURN VALUE:
//
//  S_OK                all is well
//
//***************************************************************************

STDMETHODIMP CSvcFactoryBuffer::XSvcFactory::CreateProxy(IN IUnknown* pUnkOuter, 
    IN REFIID riid, OUT IRpcProxyBuffer** ppProxy, void** ppv)
{
    if(riid != IID_IWbemServices)
    {
        *ppProxy = NULL;
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    CSvcProxyBuffer* pProxy = new CSvcProxyBuffer(m_pObject->m_pLifeControl, pUnkOuter);

    SCODE   sc = E_OUTOFMEMORY;

    if ( NULL != pProxy )
    {
		sc = pProxy->Init();

		if ( SUCCEEDED( sc ) )
		{
			pProxy->QueryInterface(IID_IRpcProxyBuffer, (void**)ppProxy);
			sc = pProxy->QueryInterface(riid, (void**)ppv);
		}
		else
		{
			delete pProxy;
		}

    }

    return sc;
}

//***************************************************************************
//
//  CSvcFactoryBuffer::XSvcFactory::CreateStub
//
//  DESCRIPTION:
//
//  Creates a stublet.  Also passes a pointer to the clients IWbemServices 
//  interface.
//
//  RETURN VALUE:
//
//  S_OK                all is well
//
//***************************************************************************
    
STDMETHODIMP CSvcFactoryBuffer::XSvcFactory::CreateStub(IN REFIID riid, 
    IN IUnknown* pUnkServer, OUT IRpcStubBuffer** ppStub)
{
    if(riid != IID_IWbemServices)
    {
        *ppStub = NULL;
        return E_NOINTERFACE;
    }

    CSvcStubBuffer* pStub = new CSvcStubBuffer(m_pObject->m_pLifeControl, NULL);

    if ( NULL != pStub )
    {
        pStub->QueryInterface(IID_IRpcStubBuffer, (void**)ppStub);

        // Pass the pointer to the clients object

        if(pUnkServer)
        {
            HRESULT hres = (*ppStub)->Connect(pUnkServer);
            if(FAILED(hres))
            {
                delete pStub;
                *ppStub = NULL;
            }
            return hres;
        }
        else
        {
            return S_OK;
        }
    }
    else
    {
        return E_OUTOFMEMORY;
    }
}

//***************************************************************************
//
//  void* CSvcFactoryBuffer::GetInterface(REFIID riid)
//
//  DESCRIPTION:
//
//  CSvcFactoryBuffer is derived from CUnk.  Since CUnk handles the QI calls,
//  all classes derived from it must support this function.
//
//  RETURN VALUE:
//
//  S_OK                all is well
//
//***************************************************************************

void* CSvcFactoryBuffer::GetInterface(REFIID riid)
{
    if(riid == IID_IPSFactoryBuffer)
        return &m_XSvcFactory;
    else return NULL;
}
        
//****************************************************************************
//****************************************************************************
//                          PROXY
//****************************************************************************
//****************************************************************************

//***************************************************************************
//
//  CSvcProxyBuffer::CSvcProxyBuffer
//  ~CSvcProxyBuffer::CSvcProxyBuffer
//
//  DESCRIPTION:
//
//  Constructor and destructor.  The main things to take care of are the 
//  old style proxy, and the channel
//
//  RETURN VALUE:
//
//  S_OK                all is well
//
//***************************************************************************

CSvcProxyBuffer::CSvcProxyBuffer(CLifeControl* pControl, IUnknown* pUnkOuter)
    : CBaseProxyBuffer( pControl, pUnkOuter, IID_IWbemServices ), 
        m_pWrapperProxy( NULL ), m_pOldProxySvc( NULL )
{
}

CSvcProxyBuffer::~CSvcProxyBuffer()
{
    // This should be cleaned up here

    if ( NULL != m_pOldProxySvc )
    {
        m_pOldProxySvc->Release();
    }

	if ( NULL != m_pWrapperProxy )
	{
		m_pWrapperProxy->Release();
	}

}

HRESULT CSvcProxyBuffer::Init( void )
{
    m_pWrapperProxy = new CWbemSvcWrapper( m_pControl, m_pUnkOuter );

	if ( NULL == m_pWrapperProxy )
	{
		return E_OUTOFMEMORY;
	}

	m_pWrapperProxy->AddRef();

	return S_OK;
}

void* CSvcProxyBuffer::GetInterface( REFIID riid )
{
    if( riid == IID_IWbemServices )
	{
		void*	pvData = NULL;

		// This will AddRef the UnkOuter, so we need to release, and
		// then we'll return pvoid, which will get Addref'd again
		// isn't aggregation wonderful

		m_pWrapperProxy->QueryInterface( riid, &pvData );
		((IUnknown*) pvData)->Release();

		return pvData;
	}

    else return NULL;
}

void** CSvcProxyBuffer::GetOldProxyInterfacePtr( void )
{
    return (void**) &m_pOldProxySvc;
}

void CSvcProxyBuffer::ReleaseOldProxyInterface( void )
{
    // We only keep a single reference to this
    if ( NULL != m_pOldProxySvc )
    {
        m_pOldProxySvc->Release();
        m_pOldProxySvc = NULL;
    }
}

//***************************************************************************
//
//  STDMETHODIMP CSvcProxyBuffer::Connect(IRpcChannelBuffer* pChannel)
//
//  DESCRIPTION:
//
//  Called during the initialization of the proxy.  The channel buffer is passed
//  to this routine.  We let the base class initialize first, then pass the
//	base proxy into the delegator
//
//  RETURN VALUE:
//
//  S_OK                all is well
//
//***************************************************************************

STDMETHODIMP CSvcProxyBuffer::Connect(IRpcChannelBuffer* pChannel)
{

    HRESULT             hr = CBaseProxyBuffer::Connect(pChannel);

	if ( SUCCEEDED( hr ) )
	{
		m_pWrapperProxy->SetProxy( m_pOldProxySvc );
	}

    return hr;
}

//***************************************************************************
//
//  STDMETHODIMP CSvcProxyBuffer::Disconnect(IRpcChannelBuffer* pChannel)
//
//  DESCRIPTION:
//
//  Called when the proxy is being disconnected.  It just frees various pointers.
//	We cleanup before the base cleans up, or things can and will beef
//
//  RETURN VALUE:
//
//  S_OK                all is well
//
//***************************************************************************

void STDMETHODCALLTYPE CSvcProxyBuffer::Disconnect()
{
	// Disconnect the wrapper proxy.  We should release the actual Wrapper
	// when we destruct
	if ( NULL != m_pWrapperProxy )
	{
		m_pWrapperProxy->Disconnect();
	}

	CBaseProxyBuffer::Disconnect();

}

//****************************************************************************
//****************************************************************************
//                          STUB
//****************************************************************************
//****************************************************************************


//***************************************************************************
//
//  void* CSvcFactoryBuffer::GetInterface(REFIID riid)
//
//  DESCRIPTION:
//
//  CSvcFactoryBuffer is derived from CUnk.  Since CUnk handles the QI calls,
//  all classes derived from this must support this function.
//
//  RETURN VALUE:
//
//  S_OK                all is well
//
//***************************************************************************


void* CSvcStubBuffer::GetInterface(REFIID riid)
{
    if(riid == IID_IRpcStubBuffer)
        return &m_XSvcStublet;
    else
        return NULL;
}

CSvcStubBuffer::XSvcStublet::XSvcStublet(CSvcStubBuffer* pObj) 
    : CBaseStublet(pObj, IID_IWbemServices), m_pServer(NULL)
{
}

CSvcStubBuffer::XSvcStublet::~XSvcStublet() 
{
    if(m_pServer)
        m_pServer->Release();
}

IUnknown* CSvcStubBuffer::XSvcStublet::GetServerInterface( void )
{
    return m_pServer;
}

void** CSvcStubBuffer::XSvcStublet::GetServerPtr( void )
{
    return (void**) &m_pServer;
}

void CSvcStubBuffer::XSvcStublet::ReleaseServerPointer( void )
{
    // We only keep a single reference to this
    if ( NULL != m_pServer )
    {
        m_pServer->Release();
        m_pServer = NULL;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\marshalers\coreprox\svcwrap.cpp ===
/*++

Copyright (C) 2000-2001 Microsoft Corporation

Module Name:

    SVCWRAP.CPP

Abstract:

    IWbemServices Delegator

History:

--*/

#include "precomp.h"
#include <stdio.h>
#include <fastall.h>
#include "svcwrap.h"

#define BAIL_IF_DISCONN() if (!m_pObject->m_pRealWbemSvcProxy) return RPC_E_DISCONNECTED;

//***************************************************************************
//
//  CWbemSvcWrapper::CWbemSvcWrapper
//  ~CWbemSvcWrapper::CWbemSvcWrapper
//
//  DESCRIPTION:
//
//  Constructor and destructor.  The main things to take care of are the 
//  old style proxy, and the channel
//
//  RETURN VALUE:
//
//  S_OK                all is well
//
//***************************************************************************

CWbemSvcWrapper::CWbemSvcWrapper( CLifeControl* pControl, IUnknown* pUnkOuter )
    : CUnk( pControl, pUnkOuter ), 
    m_XWbemServices(this), 
    m_pRealWbemSvcProxy( NULL ),
    m_SinkSecurity( pUnkOuter )
{
}

CWbemSvcWrapper::~CWbemSvcWrapper()
{
    // This should be cleaned up here

    if ( NULL != m_pRealWbemSvcProxy )
    {
        m_pRealWbemSvcProxy->Release();
    }

}

void* CWbemSvcWrapper::GetInterface( REFIID riid )
{
    if(riid == IID_IWbemServices)
        return &m_XWbemServices;
    else return NULL;
}

void CWbemSvcWrapper::SetProxy( IWbemServices* pProxy )
{
    // Release the current proxy and AddRef the new one
    if ( m_pRealWbemSvcProxy != NULL )
    {
        // This should never happen!
        m_pRealWbemSvcProxy->Release();
    }
    
    m_pRealWbemSvcProxy = pProxy;
    m_pRealWbemSvcProxy->AddRef();    
}


HRESULT CWbemSvcWrapper::Disconnect( void )
{
    if ( NULL != m_pRealWbemSvcProxy )
    {
        m_pRealWbemSvcProxy->Release();
		m_pRealWbemSvcProxy = NULL;
    }

	return WBEM_S_NO_ERROR;
}

/* IWbemServicesEx methods implemented as pass-throughs */

STDMETHODIMP CWbemSvcWrapper::XWbemServices::OpenNamespace(
		const BSTR Namespace, LONG lFlags, IWbemContext* pContext, IWbemServices** ppNewNamespace,
		IWbemCallResult** ppResult
		)
{
    BAIL_IF_DISCONN();
    
	BSTR	bstrTemp = NULL;

	HRESULT	hr = WrapBSTR( Namespace, &bstrTemp );
	CSysFreeMe	sfm(	bstrTemp );

	if ( SUCCEEDED( hr  ) )
	{
		// Just pass through to the old SvcEx.
		hr = m_pObject->m_pRealWbemSvcProxy->OpenNamespace( bstrTemp, lFlags, pContext, ppNewNamespace, ppResult );
	}

	return hr;
}


STDMETHODIMP CWbemSvcWrapper::XWbemServices::CancelAsyncCall(IWbemObjectSink* pSink)
{
    BAIL_IF_DISCONN();
    // Just pass through to the old SvcEx.
    return m_pObject->m_pRealWbemSvcProxy->CancelAsyncCall( pSink );
}

STDMETHODIMP CWbemSvcWrapper::XWbemServices::QueryObjectSink(long lFlags, IWbemObjectSink** ppResponseHandler)
{
    BAIL_IF_DISCONN();
    // Just pass through to the old SvcEx.
    return m_pObject->m_pRealWbemSvcProxy->QueryObjectSink( lFlags, ppResponseHandler );
}

STDMETHODIMP CWbemSvcWrapper::XWbemServices::GetObject(const BSTR ObjectPath, long lFlags, IWbemContext* pContext,
	IWbemClassObject** ppObject, IWbemCallResult** ppResult)
{
    BAIL_IF_DISCONN();
    
	BSTR	bstrTemp = NULL;

	HRESULT	hr = WrapBSTR( ObjectPath, &bstrTemp );
	CSysFreeMe	sfm( bstrTemp );
	IWbemClassObject*	pNewObj = NULL;

	// Per docs, we ALWAYS NULL out.  Technically we should release, but due to provider based backwards
	// compatibility issues #337798, we are not doing so.  We may cause "strange" client code written
	// in the past to leak, however it was causing Winmgmt to leak, so we just moved the leak into their
	// process.

	if ( NULL != ppObject )
	{
		*ppObject = NULL;
	}

	if ( SUCCEEDED( hr  ) )
	{
		// Just pass through to the old SvcEx.
		hr = m_pObject->m_pRealWbemSvcProxy->GetObject( bstrTemp, lFlags, pContext, ppObject, ppResult );
	}

	return hr;
}

STDMETHODIMP CWbemSvcWrapper::XWbemServices::GetObjectAsync(const BSTR ObjectPath, long lFlags,
	IWbemContext* pContext, IWbemObjectSink* pResponseHandler)
{
    BAIL_IF_DISCONN();
    
	BSTR	bstrTemp = NULL;

	HRESULT	hr = WrapBSTR( ObjectPath, &bstrTemp );
	CSysFreeMe	sfm( bstrTemp );

        if ( SUCCEEDED(hr) )
        {
            hr = m_pObject->EnsureSinkSecurity( pResponseHandler );
        }

	if ( SUCCEEDED( hr  ) )
	{
		// Just pass through to the old SvcEx.
		hr = m_pObject->m_pRealWbemSvcProxy->GetObjectAsync( bstrTemp, lFlags, pContext, pResponseHandler );
	}

	return hr;
}

STDMETHODIMP CWbemSvcWrapper::XWbemServices::PutClass(IWbemClassObject* pObject, long lFlags,
	IWbemContext* pContext, IWbemCallResult** ppResult)
{
    BAIL_IF_DISCONN();
    // Just pass through to the old SvcEx.
    return m_pObject->m_pRealWbemSvcProxy->PutClass( pObject, lFlags, pContext, ppResult );
}

STDMETHODIMP CWbemSvcWrapper::XWbemServices::PutClassAsync(IWbemClassObject* pObject, long lFlags,
	IWbemContext* pContext, IWbemObjectSink* pResponseHandler)
{
    BAIL_IF_DISCONN();
    // Just pass through to the old SvcEx.

    HRESULT hr = m_pObject->EnsureSinkSecurity( pResponseHandler );
    if ( FAILED(hr) )
        return hr;

    return m_pObject->m_pRealWbemSvcProxy->PutClassAsync( pObject, lFlags, pContext, pResponseHandler );
}

STDMETHODIMP CWbemSvcWrapper::XWbemServices::DeleteClass(const BSTR Class, long lFlags, IWbemContext* pContext,
	IWbemCallResult** ppResult)
{
    BAIL_IF_DISCONN();
	BSTR	bstrTemp = NULL;

	HRESULT	hr = WrapBSTR( Class, &bstrTemp );
	CSysFreeMe	sfm( bstrTemp );

	if ( SUCCEEDED( hr  ) )
	{
		// Just pass through to the old SvcEx.
		hr = m_pObject->m_pRealWbemSvcProxy->DeleteClass( bstrTemp, lFlags, pContext, ppResult );
	}

	return hr;
}

STDMETHODIMP CWbemSvcWrapper::XWbemServices::DeleteClassAsync(const BSTR Class, long lFlags, IWbemContext* pContext,
	IWbemObjectSink* pResponseHandler)
{
    BAIL_IF_DISCONN();
	BSTR	bstrTemp = NULL;

	HRESULT	hr = WrapBSTR( Class, &bstrTemp );
	CSysFreeMe	sfm( bstrTemp );

        if ( SUCCEEDED(hr) )
        {
            hr = m_pObject->EnsureSinkSecurity( pResponseHandler );
        }

	if ( SUCCEEDED( hr  ) )
	{
		// Just pass through to the old SvcEx.
		hr = m_pObject->m_pRealWbemSvcProxy->DeleteClassAsync( bstrTemp, lFlags, pContext, pResponseHandler );
	}

	return hr;
}

STDMETHODIMP CWbemSvcWrapper::XWbemServices::CreateClassEnum(const BSTR Superclass, long lFlags,
	IWbemContext* pContext, IEnumWbemClassObject** ppEnum)
{
    BAIL_IF_DISCONN();
	// This is an invalid parameter - cannot be processed by the stub
	// returning RPC_X_NULL_REF_POINTER for backwards compatibility
	if ( NULL == ppEnum )
	{
		return MAKE_HRESULT( SEVERITY_ERROR, FACILITY_WIN32, RPC_X_NULL_REF_POINTER );
	}

	BSTR	bstrTemp = NULL;

	HRESULT	hr = WrapBSTR( Superclass, &bstrTemp );
	CSysFreeMe	sfm( bstrTemp );

	if ( SUCCEEDED( hr  ) )
	{
		// Just pass through to the old SvcEx.
		hr = m_pObject->m_pRealWbemSvcProxy->CreateClassEnum( bstrTemp, lFlags, pContext, ppEnum );
	}

	return hr;

}

STDMETHODIMP CWbemSvcWrapper::XWbemServices::CreateClassEnumAsync(const BSTR Superclass, long lFlags,
	IWbemContext* pContext, IWbemObjectSink* pResponseHandler)
{
    BAIL_IF_DISCONN();
	BSTR	bstrTemp = NULL;

	HRESULT	hr = WrapBSTR( Superclass, &bstrTemp );
	CSysFreeMe	sfm( bstrTemp );

        if ( SUCCEEDED(hr) )
        {
            hr = m_pObject->EnsureSinkSecurity( pResponseHandler );
        }

	if ( SUCCEEDED( hr  ) )
	{
		// Just pass through to the old SvcEx.
		hr = m_pObject->m_pRealWbemSvcProxy->CreateClassEnumAsync( bstrTemp, lFlags, pContext, pResponseHandler );
	}

	return hr;
}

STDMETHODIMP CWbemSvcWrapper::XWbemServices::PutInstance(IWbemClassObject* pInst, long lFlags,
	IWbemContext* pContext, IWbemCallResult** ppResult)
{
    BAIL_IF_DISCONN();
    // Just pass through to the old SvcEx.
    return m_pObject->m_pRealWbemSvcProxy->PutInstance( pInst, lFlags, pContext, ppResult );
}

STDMETHODIMP CWbemSvcWrapper::XWbemServices::PutInstanceAsync(IWbemClassObject* pInst, long lFlags,
	IWbemContext* pContext, IWbemObjectSink* pResponseHandler)
{
    BAIL_IF_DISCONN();

    HRESULT hr = m_pObject->EnsureSinkSecurity( pResponseHandler );
    if ( FAILED(hr) )
        return hr;

    // Just pass through to the old SvcEx.
    return m_pObject->m_pRealWbemSvcProxy->PutInstanceAsync( pInst, lFlags, pContext, pResponseHandler );
}

STDMETHODIMP CWbemSvcWrapper::XWbemServices::DeleteInstance(const BSTR ObjectPath, long lFlags,
	IWbemContext* pContext, IWbemCallResult** ppResult)
{
    BAIL_IF_DISCONN();
	BSTR	bstrTemp = NULL;

	HRESULT	hr = WrapBSTR( ObjectPath, &bstrTemp );
	CSysFreeMe	sfm( bstrTemp );

	if ( SUCCEEDED( hr  ) )
	{
		// Just pass through to the old SvcEx.
		hr = m_pObject->m_pRealWbemSvcProxy->DeleteInstance( bstrTemp, lFlags, pContext, ppResult );
	}

	return hr;
}

STDMETHODIMP CWbemSvcWrapper::XWbemServices::DeleteInstanceAsync(const BSTR ObjectPath, long lFlags,
	IWbemContext* pContext, IWbemObjectSink* pResponseHandler)
{
    BAIL_IF_DISCONN();
	BSTR	bstrTemp = NULL;

	HRESULT	hr = WrapBSTR( ObjectPath, &bstrTemp );
	CSysFreeMe	sfm( bstrTemp );

        if ( SUCCEEDED(hr) )
        {
            hr = m_pObject->EnsureSinkSecurity( pResponseHandler );
        }

	if ( SUCCEEDED( hr  ) )
	{
		// Just pass through to the old SvcEx.
		hr = m_pObject->m_pRealWbemSvcProxy->DeleteInstanceAsync( bstrTemp, lFlags, pContext, pResponseHandler );
	}

	return hr;
}

STDMETHODIMP CWbemSvcWrapper::XWbemServices::CreateInstanceEnum(const BSTR Class, long lFlags,
	IWbemContext* pContext, IEnumWbemClassObject** ppEnum)
{
    BAIL_IF_DISCONN();
	// This is an invalid parameter - cannot be processed by the stub
	// returning RPC_X_NULL_REF_POINTER for backwards compatibility
	if ( NULL == ppEnum )
	{
		return MAKE_HRESULT( SEVERITY_ERROR, FACILITY_WIN32, RPC_X_NULL_REF_POINTER );
	}

	BSTR	bstrTemp = NULL;

	HRESULT	hr = WrapBSTR( Class, &bstrTemp );
	CSysFreeMe	sfm( bstrTemp );

	if ( SUCCEEDED( hr  ) )
	{
		// Just pass through to the old SvcEx.
		hr = m_pObject->m_pRealWbemSvcProxy->CreateInstanceEnum( bstrTemp, lFlags, pContext, ppEnum );
	}

	return hr;

}

STDMETHODIMP CWbemSvcWrapper::XWbemServices::CreateInstanceEnumAsync(const BSTR Class, long lFlags,
	IWbemContext* pContext, IWbemObjectSink* pResponseHandler)
{
    BAIL_IF_DISCONN();
	BSTR	bstrTemp = NULL;

	HRESULT	hr = WrapBSTR( Class, &bstrTemp );
	CSysFreeMe	sfm( bstrTemp );

        if ( SUCCEEDED(hr) )
        {
            hr = m_pObject->EnsureSinkSecurity( pResponseHandler );
        }

	if ( SUCCEEDED( hr  ) )
	{
		// Just pass through to the old SvcEx.
		hr = m_pObject->m_pRealWbemSvcProxy->CreateInstanceEnumAsync( bstrTemp, lFlags, pContext, pResponseHandler );
	}

	return hr;
}

STDMETHODIMP CWbemSvcWrapper::XWbemServices::ExecQuery(const BSTR QueryLanguage, const BSTR Query, long lFlags,
	IWbemContext* pContext, IEnumWbemClassObject** ppEnum)
{
    BAIL_IF_DISCONN();
	// This is an invalid parameter - cannot be processed by the stub
	// returning RPC_X_NULL_REF_POINTER for backwards compatibility
	if ( NULL == ppEnum )
	{
		return MAKE_HRESULT( SEVERITY_ERROR, FACILITY_WIN32, RPC_X_NULL_REF_POINTER );
	}

	BSTR	bstrTemp1 = NULL;

	HRESULT	hr = WrapBSTR( QueryLanguage, &bstrTemp1 );
	CSysFreeMe	sfm( bstrTemp1 );

	if ( SUCCEEDED( hr  ) )
	{
		BSTR	bstrTemp2 = NULL;

		hr = WrapBSTR( Query, &bstrTemp2 );
		CSysFreeMe	sfm2( bstrTemp2 );

		if ( SUCCEEDED( hr ) )
		{
			// Just pass through to the old SvcEx.
			hr = m_pObject->m_pRealWbemSvcProxy->ExecQuery( bstrTemp1, bstrTemp2, lFlags, pContext, ppEnum );

		}
	}

	return hr;
}

 STDMETHODIMP CWbemSvcWrapper::XWbemServices::ExecQueryAsync(const BSTR QueryFormat, const BSTR Query, long lFlags,
	IWbemContext* pContext, IWbemObjectSink* pResponseHandler)
{
    BAIL_IF_DISCONN();
	BSTR	bstrTemp1 = NULL;

	HRESULT	hr = WrapBSTR( QueryFormat, &bstrTemp1 );
	CSysFreeMe	sfm( bstrTemp1 );

	if ( SUCCEEDED( hr  ) )
	{
		BSTR	bstrTemp2 = NULL;

		hr = WrapBSTR( Query, &bstrTemp2 );
		CSysFreeMe	sfm2( bstrTemp2 );

                if ( SUCCEEDED(hr) )
                {
                    hr = m_pObject->EnsureSinkSecurity( pResponseHandler );
                }


		if ( SUCCEEDED( hr ) )
		{
			// Just pass through to the old SvcEx.

			hr = m_pObject->m_pRealWbemSvcProxy->ExecQueryAsync( bstrTemp1, bstrTemp2, lFlags, pContext, pResponseHandler );

		}
	}

	return hr;
}

STDMETHODIMP CWbemSvcWrapper::XWbemServices::ExecNotificationQuery(const BSTR QueryLanguage, const BSTR Query,
	long lFlags, IWbemContext* pContext, IEnumWbemClassObject** ppEnum)
{
    BAIL_IF_DISCONN();
	// This is an invalid parameter - cannot be processed by the stub
	// returning RPC_X_NULL_REF_POINTER for backwards compatibility
	if ( NULL == ppEnum )
	{
		return MAKE_HRESULT( SEVERITY_ERROR, FACILITY_WIN32, RPC_X_NULL_REF_POINTER );
	}

	BSTR	bstrTemp1 = NULL;

	HRESULT	hr = WrapBSTR( QueryLanguage, &bstrTemp1 );
	CSysFreeMe	sfm( bstrTemp1 );

	if ( SUCCEEDED( hr  ) )
	{
		BSTR	bstrTemp2 = NULL;

		hr = WrapBSTR( Query, &bstrTemp2 );
		CSysFreeMe	sfm2( bstrTemp2 );

		if ( SUCCEEDED( hr ) )
		{
			// Just pass through to the old SvcEx.
			hr = m_pObject->m_pRealWbemSvcProxy->ExecNotificationQuery( bstrTemp1, bstrTemp2, lFlags, pContext, ppEnum );

		}
	}

	return hr;

}

STDMETHODIMP CWbemSvcWrapper::XWbemServices::ExecNotificationQueryAsync(const BSTR QueryFormat, const BSTR Query,
	long lFlags, IWbemContext* pContext, IWbemObjectSink* pResponseHandler)
{
    BAIL_IF_DISCONN();
	BSTR	bstrTemp1 = NULL;

	HRESULT	hr = WrapBSTR( QueryFormat, &bstrTemp1 );
	CSysFreeMe	sfm( bstrTemp1 );

	if ( SUCCEEDED( hr  ) )
	{
		BSTR	bstrTemp2 = NULL;

		hr = WrapBSTR( Query, &bstrTemp2 );
		CSysFreeMe	sfm2( bstrTemp2 );

                if ( SUCCEEDED(hr) )
                {
                    hr = m_pObject->EnsureSinkSecurity( pResponseHandler );
                }

		if ( SUCCEEDED( hr ) )
		{
			// Just pass through to the old SvcEx.
			hr = m_pObject->m_pRealWbemSvcProxy->ExecNotificationQueryAsync( bstrTemp1, bstrTemp2, lFlags, pContext, pResponseHandler );

		}
	}

	return hr;
}

STDMETHODIMP CWbemSvcWrapper::XWbemServices::ExecMethod(const BSTR ObjectPath, const BSTR MethodName, long lFlags,
	IWbemContext *pCtx, IWbemClassObject *pInParams,
	IWbemClassObject **ppOutParams, IWbemCallResult  **ppCallResult)
{
    BAIL_IF_DISCONN();
	BSTR	bstrTemp1 = NULL;

	HRESULT	hr = WrapBSTR( ObjectPath, &bstrTemp1 );
	CSysFreeMe	sfm( bstrTemp1 );

	if ( SUCCEEDED( hr  ) )
	{
		BSTR	bstrTemp2 = NULL;

		hr = WrapBSTR( MethodName, &bstrTemp2 );
		CSysFreeMe	sfm2( bstrTemp2 );

		if ( SUCCEEDED( hr ) )
		{
			// Just pass through to the old SvcEx.
			hr = m_pObject->m_pRealWbemSvcProxy->ExecMethod( bstrTemp1, bstrTemp2, lFlags, pCtx, pInParams, ppOutParams, ppCallResult );

		}
	}

	return hr;
}

STDMETHODIMP CWbemSvcWrapper::XWbemServices::ExecMethodAsync(const BSTR ObjectPath, const BSTR MethodName, long lFlags,
	IWbemContext *pCtx, IWbemClassObject *pInParams,
	IWbemObjectSink* pResponseHandler)
{
    BAIL_IF_DISCONN();
	BSTR	bstrTemp1 = NULL;

	HRESULT	hr = WrapBSTR( ObjectPath, &bstrTemp1 );
	CSysFreeMe	sfm( bstrTemp1 );

	if ( SUCCEEDED( hr  ) )
	{
		BSTR	bstrTemp2 = NULL;

		hr = WrapBSTR( MethodName, &bstrTemp2 );
		CSysFreeMe	sfm2( bstrTemp2 );

                if ( SUCCEEDED(hr) )
                {
                    hr = m_pObject->EnsureSinkSecurity( pResponseHandler );
                }

		if ( SUCCEEDED( hr ) )
		{
			// Just pass through to the old SvcEx.
			hr = m_pObject->m_pRealWbemSvcProxy->ExecMethodAsync( bstrTemp1, bstrTemp2, lFlags, pCtx, pInParams, pResponseHandler );

		}
	}

	return hr;
}

//	Helper function to wrap supplied BSTRs in case we were called with
//	LPCWSTRs - basically a helper for people who used to be in-proc to winmgmt
//	who were relying on the fact that they could use LPWSTRs instead of
//	BSTRs since they were in-proc and no-marshaling was taking place.

HRESULT CWbemSvcWrapper::XWbemServices::WrapBSTR( BSTR bstrSrc, BSTR* pbstrDest )
{
	HRESULT	hr = WBEM_S_NO_ERROR;

	if ( NULL != bstrSrc )
	{
		*pbstrDest = SysAllocString( bstrSrc );

		if ( NULL == *pbstrDest )
		{
			hr = WBEM_E_OUT_OF_MEMORY;
		}
	}
	else
	{
		*pbstrDest = bstrSrc;
	}

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\marshalers\coreprox\txtscmgr.h ===
/*++

Copyright (C) 2000-2001 Microsoft Corporation

Module Name:

    TXTSCMGR.H

Abstract:

  CTextSourceMgr Definition.

  Class to manage Text Source Encoder/Decoder objects

History:

  22-Feb-2000	sanjes    Created.

--*/

#ifndef _TXTSRCMGR_H_
#define _TXTSRCMGR_H_

#include "corepol.h"
#include "wmitxtsc.h"
#include "sync.h"
#include <arena.h>

//***************************************************************************
//
//  class CTextSourceMgr
//
//    Helper class to manage Text Source Encoder/Decoder objects
//
//***************************************************************************

class CTextSourceMgr
{
private:
	CCritSec				m_cs;
	CWmiTextSourceArray		m_TextSourceArray;

public:
    CTextSourceMgr();
	virtual ~CTextSourceMgr(); 

private:
	HRESULT Add( ULONG ulId, CWmiTextSource** pNewTextSource );

public:
    HRESULT Find( ULONG ulId, CWmiTextSource** pTextSource );

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\marshalers\coreprox\ubskmrsh.h ===
/*++

Copyright (C) 1998-2001 Microsoft Corporation

Module Name:

    UBSKMRSH.H

Abstract:

    Unbound Sink Marshaling

History:

--*/

#include <unk.h>
#include <wbemidl.h>
#include <wbemint.h>
#include <wbemcomn.h>
#include <sync.h>
#include <fastall.h>
#include <wbemclasscache.h>
#include <wbemclasstoidmap.h>
#include "ubskpckt.h"

//***************************************************************************
//
//  class CUnboundSinkFactoryBuffer
//
//  DESCRIPTION:
//
//  This class provides the proxy stub factory so that we can provide custom
//  facelets and stublets for the IWbemUnboundObjectSink interface.
//
//***************************************************************************

class CUnboundSinkFactoryBuffer : public CUnkInternal
{
	IRpcProxyBuffer*	m_pOldProxy;
	IRpcStubBuffer*		m_pOldStub;

	// We don't want to AddRef the life control, but
	// we need to let objects we create AddRef it, so the
	// base class won't keep this pointer, but we will.

	CLifeControl*		m_pLifeControl;

protected:
    class XUnboundSinkFactory : public CImpl<IPSFactoryBuffer, CUnboundSinkFactoryBuffer>
    {
    public:
        XUnboundSinkFactory(CUnboundSinkFactoryBuffer* pObj) :
            CImpl<IPSFactoryBuffer, CUnboundSinkFactoryBuffer>(pObj)
        {}
        
        STDMETHOD(CreateProxy)(IN IUnknown* pUnkOuter, IN REFIID riid, 
            OUT IRpcProxyBuffer** ppProxy, void** ppv);
        STDMETHOD(CreateStub)(IN REFIID riid, IN IUnknown* pUnkServer, 
            OUT IRpcStubBuffer** ppStub);
    } m_XUnboundSinkFactory;
public:
    CUnboundSinkFactoryBuffer(CLifeControl* pControl)
        : CUnkInternal(pControl), m_XUnboundSinkFactory(this), m_pLifeControl( pControl )
    {
    }
    ~CUnboundSinkFactoryBuffer()
    {
    }    

    void* GetInterface(REFIID riid);

	friend XUnboundSinkFactory;
};

//***************************************************************************
//
//  class CUnboundSinkProxyBuffer
//
//  DESCRIPTION:
//
//  This class provides the facelet for the IWbemUnboundObjectSink interface.
//
//    Trick #1: This object is derived from IRpcProxyBuffer since IRpcProxyBuffer
//    is its "internal" interface --- the interface that does not delegate to the
//    aggregator. (Unlike in normal objects, where that interface is IUnknown)
//
//***************************************************************************

class CUnboundSinkProxyBuffer : public IRpcProxyBuffer
{
private:
	IRpcProxyBuffer*	m_pOldProxy;
	IWbemUnboundObjectSink*	m_pOldProxyUnboundSink;
    enum {OLD, NEW, UNKNOWN} m_StubType;
    CWbemClassToIdMap m_ClassToIdMap;
	bool		m_fRemote;

protected:
    CLifeControl* m_pControl;
    IUnknown* m_pUnkOuter;
    long m_lRef;

protected:
    class XUnboundSinkFacelet : public IWbemUnboundObjectSink, IClientSecurity
    {
    protected:
        CUnboundSinkProxyBuffer* m_pObject;
        CCritSec m_cs;        

    public:
        XUnboundSinkFacelet(CUnboundSinkProxyBuffer* pObject) : m_pObject(pObject){};
        ~XUnboundSinkFacelet(){};

        ULONG STDMETHODCALLTYPE AddRef() 
        {return m_pObject->m_pUnkOuter->AddRef();}
        ULONG STDMETHODCALLTYPE Release() 
        {return m_pObject->m_pUnkOuter->Release();}
        HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, void** ppv);
        HRESULT STDMETHODCALLTYPE IndicateToConsumer( IWbemClassObject* pLogicalConsumer, LONG lObjectCount, IWbemClassObject** ppObjArray );

		// IClientSecurity Methods
		STDMETHOD(QueryBlanket)( IUnknown* pProxy, DWORD* pAuthnSvc, DWORD* pAuthzSvc,
			OLECHAR** pServerPrincName, DWORD* pAuthnLevel, DWORD* pImpLevel,
			void** pAuthInfo, DWORD* pCapabilities );
		STDMETHOD(SetBlanket)( IUnknown* pProxy, DWORD AuthnSvc, DWORD AuthzSvc,
			OLECHAR* pServerPrincName, DWORD AuthnLevel, DWORD ImpLevel,
			void* pAuthInfo, DWORD Capabilities );
		STDMETHOD(CopyProxy)( IUnknown* pProxy, IUnknown** pCopy );

    } m_XUnboundSinkFacelet;
    friend XUnboundSinkFacelet;

protected:
    IRpcChannelBuffer* m_pChannel;
	IRpcChannelBuffer* GetChannel( void ) { return m_pChannel; };

public:
    CUnboundSinkProxyBuffer(CLifeControl* pControl, IUnknown* pUnkOuter);
    ~CUnboundSinkProxyBuffer();

    ULONG STDMETHODCALLTYPE AddRef();
    ULONG STDMETHODCALLTYPE Release(); 
    HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, void** ppv);
    STDMETHOD(Connect)(IRpcChannelBuffer* pChannel);
    STDMETHOD_(void, Disconnect)();
};

//***************************************************************************
//
//  class CUnboundSinkStubBuffer
//
//  DESCRIPTION:
//
//  This class provides the stublet for the IWbemUnboundObjectSink interface.
//
//***************************************************************************

class CUnboundSinkStubBuffer : public CUnk
{
private:

	IRpcStubBuffer*	m_pOldStub;

protected:
    class XUnboundSinkStublet : public CImpl<IRpcStubBuffer, CUnboundSinkStubBuffer>
    {
        IWbemUnboundObjectSink* m_pServer;
		LONG			m_lConnections;
        CWbemClassCache m_ClassCache;
        bool m_bFirstIndicate;
    public:
        XUnboundSinkStublet(CUnboundSinkStubBuffer* pObj);
        ~XUnboundSinkStublet();

        STDMETHOD(Connect)(IUnknown* pUnkServer);
        STDMETHOD_(void, Disconnect)();
        STDMETHOD(Invoke)(RPCOLEMESSAGE* pMessage, IRpcChannelBuffer* pBuffer);
        STDMETHOD_(IRpcStubBuffer*, IsIIDSupported)(REFIID riid);
        STDMETHOD_(ULONG, CountRefs)();
        STDMETHOD(DebugServerQueryInterface)(void** ppv);
        STDMETHOD_(void, DebugServerRelease)(void* pv);
        
	private:

		HRESULT IndicateToConsumer_Stub( RPCOLEMESSAGE* pMessage, IRpcChannelBuffer* pBuffer );
        friend CUnboundSinkStubBuffer;
    } m_XUnboundSinkStublet;
    friend XUnboundSinkStublet;

public:
    CUnboundSinkStubBuffer(CLifeControl* pControl, IUnknown* pUnkOuter = NULL)
        : CUnk(pControl, pUnkOuter), m_XUnboundSinkStublet(this), m_pOldStub( NULL )
    {}
    void* GetInterface(REFIID riid);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\marshalers\coreprox\ubskmrsh.cpp ===
/*++

Copyright (C) 1998-2001 Microsoft Corporation

Module Name:

    UBSKMRSH.CPP

Abstract:

    Unbound Sink Marshaling

History:

--*/

#include "precomp.h"
#include <stdio.h>
#include "ubskmrsh.h"
#include <fastall.h>
#include <cominit.h>

#define WBEM_S_NEW_STYLE 0x400FF

//****************************************************************************
//****************************************************************************
//                          PS FACTORY
//****************************************************************************
//****************************************************************************

//***************************************************************************
//
//  CUnboundSinkFactoryBuffer::XUnboundSinkFactory::CreateProxy
//
//  DESCRIPTION:
//
//  Creates a facelet.  Also sets the outer unknown since the proxy is going to be 
//  aggregated.
//
//  RETURN VALUE:
//
//  S_OK                all is well
//
//***************************************************************************

STDMETHODIMP CUnboundSinkFactoryBuffer::XUnboundSinkFactory::CreateProxy(IN IUnknown* pUnkOuter, 
    IN REFIID riid, OUT IRpcProxyBuffer** ppProxy, void** ppv)
{
    if(riid != IID_IWbemUnboundObjectSink)
    {
        *ppProxy = NULL;
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    CUnboundSinkProxyBuffer* pProxy = new CUnboundSinkProxyBuffer(m_pObject->m_pLifeControl, pUnkOuter);

    SCODE   sc = E_OUTOFMEMORY;

    if ( NULL != pProxy )
    {
        pProxy->QueryInterface(IID_IRpcProxyBuffer, (void**)ppProxy);
        sc = pProxy->QueryInterface(riid, (void**)ppv);
    }

    return sc;
}

//***************************************************************************
//
//  CUnboundSinkFactoryBuffer::XUnboundSinkFactory::CreateStub
//
//  DESCRIPTION:
//
//  Creates a stublet.  Also passes a pointer to the clients IWbemUnboundObjectSink 
//  interface.
//
//  RETURN VALUE:
//
//  S_OK                all is well
//
//***************************************************************************
    
STDMETHODIMP CUnboundSinkFactoryBuffer::XUnboundSinkFactory::CreateStub(IN REFIID riid, 
    IN IUnknown* pUnkServer, OUT IRpcStubBuffer** ppStub)
{
    if(riid != IID_IWbemUnboundObjectSink)
    {
        *ppStub = NULL;
        return E_NOINTERFACE;
    }

    try // CWbemClassCache throws
    {
	    CUnboundSinkStubBuffer* pStub = new CUnboundSinkStubBuffer(m_pObject->m_pLifeControl, NULL);

	    if ( NULL != pStub )
	    {
	        pStub->QueryInterface(IID_IRpcStubBuffer, (void**)ppStub);
	        // Pass the pointer to the clients object
	        if(pUnkServer)
	        {
	            HRESULT hres = (*ppStub)->Connect(pUnkServer);
	            if(FAILED(hres))
	            {
	                delete pStub;
	                *ppStub = NULL;
	            }
	            return hres;
	        }
	        else
	        {
	            return S_OK;
	        }
	    }
	    else
	    {
	        return E_OUTOFMEMORY;
	    }
   	}
    catch (CX_Exception &)
    {
        return E_OUTOFMEMORY;    
    }
}

//***************************************************************************
//
//  void* CUnboundSinkFactoryBuffer::GetInterface(REFIID riid)
//
//  DESCRIPTION:
//
//  CUnboundSinkFactoryBuffer is derived from CUnk.  Since CUnk handles the QI calls,
//  all classes derived from it must support this function.
//
//  RETURN VALUE:
//
//  S_OK                all is well
//
//***************************************************************************

void* CUnboundSinkFactoryBuffer::GetInterface(REFIID riid)
{
    if(riid == IID_IPSFactoryBuffer)
        return &m_XUnboundSinkFactory;
    else return NULL;
}
        
//****************************************************************************
//****************************************************************************
//                          PROXY
//****************************************************************************
//****************************************************************************

//***************************************************************************
//
//  CUnboundSinkProxyBuffer::CUnboundSinkProxyBuffer
//  ~CUnboundSinkProxyBuffer::CUnboundSinkProxyBuffer
//
//  DESCRIPTION:
//
//  Constructor and destructor.  The main things to take care of are the 
//  old style proxy, and the channel
//
//  RETURN VALUE:
//
//  S_OK                all is well
//
//***************************************************************************

CUnboundSinkProxyBuffer::CUnboundSinkProxyBuffer(CLifeControl* pControl, IUnknown* pUnkOuter)
    : m_pControl(pControl), m_pUnkOuter(pUnkOuter), m_lRef(0), 
        m_XUnboundSinkFacelet(this), m_pChannel(NULL), m_pOldProxy( NULL ), m_pOldProxyUnboundSink( NULL ),
        m_fRemote( false )
{
    m_pControl->ObjectCreated(this);
    m_StubType = UNKNOWN;

}

CUnboundSinkProxyBuffer::~CUnboundSinkProxyBuffer()
{
    // This MUST be released first

    if ( NULL != m_pOldProxyUnboundSink )
    {
        m_pOldProxyUnboundSink->Release();
    }

    if ( NULL != m_pOldProxy )
    {
        m_pOldProxy->Release();
    }

    if(m_pChannel)
        m_pChannel->Release();
    m_pControl->ObjectDestroyed(this);

}

ULONG STDMETHODCALLTYPE CUnboundSinkProxyBuffer::AddRef()
{
    return InterlockedIncrement(&m_lRef);
}

ULONG STDMETHODCALLTYPE CUnboundSinkProxyBuffer::Release()
{
    long lRef = InterlockedDecrement(&m_lRef);
    if(lRef == 0)
        delete this;
    return lRef;
}

HRESULT STDMETHODCALLTYPE CUnboundSinkProxyBuffer::QueryInterface(REFIID riid, void** ppv)
{
    if(riid == IID_IUnknown || riid == IID_IRpcProxyBuffer)
    {
        *ppv = (IRpcProxyBuffer*)this;
    }
    else if(riid == IID_IWbemUnboundObjectSink)
    {
        *ppv = (IWbemUnboundObjectSink*)&m_XUnboundSinkFacelet;
    }
    else return E_NOINTERFACE;

    ((IUnknown*)*ppv)->AddRef();
    return S_OK;
}

//***************************************************************************
//
//  HRESULT STDMETHODCALLTYPE CUnboundSinkProxyBuffer::XUnboundSinkFacelet::
//                      QueryInterface(REFIID riid, void** ppv)  
//
//  DESCRIPTION:
//
//  Supports querries for interfaces.   The only thing unusual is that
//  this object is aggregated by the proxy manager and so some interface
//  requests are passed to the outer IUnknown interface.
//
//  RETURN VALUE:
//
//  S_OK                all is well
//
//***************************************************************************

HRESULT STDMETHODCALLTYPE CUnboundSinkProxyBuffer::XUnboundSinkFacelet::
QueryInterface(REFIID riid, void** ppv)
{
    // All other interfaces are delegated to the UnkOuter
    if( riid == IID_IRpcProxyBuffer )
    {
        // Trick #2: this is an internal interface that should not be delegated!
        // ===================================================================

        return m_pObject->QueryInterface(riid, ppv);
    }
    else if ( riid == IID_IClientSecurity )
    {
        // We handle this here in the facelet
        AddRef();
        *ppv = (IClientSecurity*) this;
        return S_OK;
    }
    else
    {
        return m_pObject->m_pUnkOuter->QueryInterface(riid, ppv);
    }
}

//////////////////////////////
//  IClientSecurity Methods //
//////////////////////////////

HRESULT STDMETHODCALLTYPE  CUnboundSinkProxyBuffer::XUnboundSinkFacelet::
QueryBlanket( IUnknown* pProxy, DWORD* pAuthnSvc, DWORD* pAuthzSvc,
    OLECHAR** pServerPrincName, DWORD* pAuthnLevel, DWORD* pImpLevel,
    void** pAuthInfo, DWORD* pCapabilities )
{
    HRESULT hr = S_OK;

    // Return the security as stored in the pUnkOuter.

    IClientSecurity*    pCliSec;

    // We pass through to the PUNKOuter
    hr = m_pObject->m_pUnkOuter->QueryInterface( IID_IClientSecurity, (void**) &pCliSec );

    if ( SUCCEEDED( hr ) )
    {
        hr = pCliSec->QueryBlanket( pProxy, pAuthnSvc, pAuthzSvc, pServerPrincName,
                pAuthnLevel, pImpLevel, pAuthInfo, pCapabilities );
        pCliSec->Release();
    }

    return hr;
}

HRESULT STDMETHODCALLTYPE  CUnboundSinkProxyBuffer::XUnboundSinkFacelet::
SetBlanket( IUnknown* pProxy, DWORD AuthnSvc, DWORD AuthzSvc,
            OLECHAR* pServerPrincName, DWORD AuthnLevel, DWORD ImpLevel,
            void* pAuthInfo, DWORD Capabilities )
{
    HRESULT hr = S_OK;

    IClientSecurity*    pCliSec;

    // First set the security explicitly on our IUnknown, then we will Set the blanket
    // on ourselves using the punkOuter (It's tricky but it works...uh...we think).
    
    // This will enable us to make calls to QueryInterface(), AddRef()/Release() that
    // may have to go remote

    // Only set the IUnknown blanket if we are remoting and it appears that the authinfo contains
    // credentials
    if (    m_pObject->m_fRemote &&
            DoesContainCredentials( (COAUTHIDENTITY*) pAuthInfo ) )
    {
        // This will enable us to make calls to QueryInterface(), AddRef()/Release() that
        // may have to go remote

        hr = CoSetProxyBlanket( m_pObject->m_pUnkOuter, AuthnSvc, AuthzSvc, pServerPrincName,
                    AuthnLevel, ImpLevel, pAuthInfo, Capabilities );

    }

    if ( SUCCEEDED( hr ) )
    {
        // We pass through to the PUNKOuter
        hr = m_pObject->m_pUnkOuter->QueryInterface( IID_IClientSecurity, (void**) &pCliSec );

        if ( SUCCEEDED( hr ) )
        {
            hr = pCliSec->SetBlanket( pProxy, AuthnSvc, AuthzSvc, pServerPrincName,
                    AuthnLevel, ImpLevel, pAuthInfo, Capabilities );
            pCliSec->Release();
        }

    }   // If Set Blanket on IUnknown

    return hr;
}

HRESULT STDMETHODCALLTYPE  CUnboundSinkProxyBuffer::XUnboundSinkFacelet::
CopyProxy( IUnknown* pProxy, IUnknown** ppCopy )
{
    HRESULT hr = S_OK;

    IClientSecurity*    pCliSec;

    // We pass through to the PUNKOuter
    hr = m_pObject->m_pUnkOuter->QueryInterface( IID_IClientSecurity, (void**) &pCliSec );

    if ( SUCCEEDED( hr ) )
    {
        hr = pCliSec->CopyProxy( pProxy, ppCopy );
        pCliSec->Release();
    }

    return hr;
}

//***************************************************************************
//
//  HRESULT STDMETHODCALLTYPE CUnboundSinkProxyBuffer::XUnboundSinkFacelet::
//                      Indicate( LONG lObjectCount, IWbemClassObject** ppObjArray )  
//
//  DESCRIPTION:
//
//  Proxies the IWbemUnboundObjectSink::Indicate calls.  Note that if the stub is an
//  old style, then the old proxy/stub pair in wbemsvc.dll is used for backward
//  compatibility.
//
//  RETURN VALUE:
//
//  S_OK                all is well
//
//***************************************************************************

HRESULT STDMETHODCALLTYPE CUnboundSinkProxyBuffer::XUnboundSinkFacelet::
IndicateToConsumer( IWbemClassObject* pLogicalConsumer, LONG lObjectCount, IWbemClassObject** ppObjArray )
{
    HRESULT hr = S_OK;

    // Make sure the lObjectCount parameter and the array pointer make sense

    if ( lObjectCount < 0 )
    {
        return WBEM_E_INVALID_PARAMETER;
    }
    else if ( lObjectCount == 0 && NULL != ppObjArray )
    {
        return WBEM_E_INVALID_PARAMETER;
    }
    else if ( lObjectCount > 0 && NULL == ppObjArray )
    {
        return WBEM_E_INVALID_PARAMETER;
    }


    CInCritSec ics(&m_cs);

    // If the stublet is an old style, just let the old proxy handle it

    if(m_pObject->m_StubType == OLD) 
        return m_pObject->m_pOldProxyUnboundSink->IndicateToConsumer( pLogicalConsumer, lObjectCount, ppObjArray );

    // If the stublet is unknown, send just the first object and check the return
    // code to determine what is on the other side. 

    if(m_pObject->m_StubType == UNKNOWN) 
    {
        hr = m_pObject->m_pOldProxyUnboundSink->IndicateToConsumer( pLogicalConsumer, 1, ppObjArray );

        // bump up pointer to the next object so that it isnt sent more than once
    
        lObjectCount--;
        ppObjArray++;

        if(hr == WBEM_S_NEW_STYLE)
        {
            m_pObject->m_StubType = NEW;
        }
        else
        {
            // We have an old client, set the stub type and send any remaining objects

            m_pObject->m_StubType = OLD;
            if(lObjectCount > 0)
                hr = m_pObject->m_pOldProxyUnboundSink->IndicateToConsumer( pLogicalConsumer, lObjectCount, ppObjArray );
            return hr;
        }
    }


    if(lObjectCount < 1)
        return S_OK;            // if all done, then just return.

    // Create a packet and some data for it to use.  Then calculate 
    // the length of the packet

    DWORD dwLength = 0;
    GUID* pguidClassIds = new GUID[lObjectCount];
    BOOL* pfSendFullObject = new BOOL[lObjectCount];

    // arrays will be deleted when we drop out of scope.
    CVectorDeleteMe<GUID>   delpguidClassIds( pguidClassIds );
    CVectorDeleteMe<BOOL>   delpfSendFullObject( pfSendFullObject );

    if (!pguidClassIds || !pfSendFullObject)
    	return WBEM_E_OUT_OF_MEMORY;

    CWbemUnboundSinkIndicatePacket packet;
    hr = packet.CalculateLength( pLogicalConsumer, lObjectCount, ppObjArray, &dwLength, 
            m_pObject->m_ClassToIdMap, pguidClassIds, pfSendFullObject );
    if (FAILED(hr))
    {
	 DBG_PRINTFA((pBuff, "CUnboundSinkProxyBuffer::XUnboundSinkFacelet::IndicateToConsumer %08x\n",hr));
        return hr;
    }


    // Declare the message structure

    RPCOLEMESSAGE msg;
    memset(&msg, 0, sizeof(msg));
    msg.cbBuffer = dwLength;

    // This is the id of the Invoke function.  This MUST be set before calling GetBuffer, or 
    // it will fail.

    msg.iMethod = 3;

    // allocate the channel buffer and marshal the data into it

    HRESULT hres = m_pObject->GetChannel()->GetBuffer(&msg, IID_IWbemUnboundObjectSink);
    if(FAILED(hres)) return hres;

#ifdef DBG
    BYTE * pCheckTail = (BYTE *)CBasicBlobControl::sAllocate(dwLength+8);
    if (!pCheckTail)
    	return WBEM_E_OUT_OF_MEMORY;

    BYTE * pTail = pCheckTail+dwLength;
    memcpy(pTail,"TAILTAIL",8);

    hr = packet.MarshalPacket( pCheckTail, dwLength, pLogicalConsumer, lObjectCount, ppObjArray, 
                                 pguidClassIds, pfSendFullObject);

    if (0 != memcmp(pTail,"TAILTAIL",8))
    	DebugBreak();
    
    memcpy(msg.Buffer,pCheckTail,dwLength);
    
    CBasicBlobControl::sDelete(pCheckTail);
#else
    // Setup the packet for marshaling
    hr = packet.MarshalPacket(  (LPBYTE)msg.Buffer, dwLength, pLogicalConsumer, lObjectCount, ppObjArray, 
                                 pguidClassIds, pfSendFullObject);
#endif /* ifdef DBG*/

    // Send the data to the stub only if the marshaling was successful

    if ( SUCCEEDED( hr ) )
    {

        DWORD dwRes;
        hr = m_pObject->GetChannel()->SendReceive(&msg, &dwRes);
        if(FAILED(hr))
        {
            if(msg.Buffer)
                m_pObject->GetChannel()->FreeBuffer(&msg);
            return dwRes;
        }

        // We appear to be ok, so get HRESULT

        LPBYTE pbData = (LPBYTE) msg.Buffer;
        hr = *((HRESULT*) pbData);
        m_pObject->GetChannel()->FreeBuffer(&msg);

    }
    else
    {
        // Clean up the buffer -- Marshaling the packet failed
        if(msg.Buffer)
            m_pObject->GetChannel()->FreeBuffer(&msg);
    }

    return hr;

}

//***************************************************************************
//
//  STDMETHODIMP CUnboundSinkProxyBuffer::Connect(IRpcChannelBuffer* pChannel)
//
//  DESCRIPTION:
//
//  Called during the initialization of the proxy.  The channel buffer is passed
//  to this routine.
//
//  RETURN VALUE:
//
//  S_OK                all is well
//
//***************************************************************************

STDMETHODIMP CUnboundSinkProxyBuffer::Connect(IRpcChannelBuffer* pChannel)
{

    // get a pointer to the old UnboundSink which is in WBEMSVC.DLL  this allows
    // for backward compatibility

    IPSFactoryBuffer*   pIPS;

    // Establish the marshaling context
    DWORD   dwCtxt = 0;
    pChannel->GetDestCtx( &dwCtxt, NULL );

    m_fRemote = ( dwCtxt == MSHCTX_DIFFERENTMACHINE );

    // This is tricky --- The old proxys/stub stuff is actually registered under the
    // IID_IWbemObjectSink in wbemcli_p.cpp.  This single class id, is backpointered
    // by ProxyStubClsId32 entries for all the standard WBEM interfaces.


    HRESULT hr = CoGetClassObject( IID_IWbemObjectSink, CLSCTX_INPROC_HANDLER | CLSCTX_INPROC_SERVER,
                    NULL, IID_IPSFactoryBuffer, (void**) &pIPS );
    if (FAILED(hr))
    	return hr;

    // We aggregated it --- WE OWN IT!
    
    hr = pIPS->CreateProxy( this, IID_IWbemUnboundObjectSink, &m_pOldProxy, (void**) &m_pOldProxyUnboundSink );
    pIPS->Release();
    if (FAILED(hr))
    	return hr;    

    // Save a reference to the channel

    hr = m_pOldProxy->Connect( pChannel );

    if(m_pChannel)
        return E_UNEXPECTED;
    
    m_pChannel = pChannel;
    if(m_pChannel)
        m_pChannel->AddRef();

    return S_OK;
}

//***************************************************************************
//
//  STDMETHODIMP CUnboundSinkProxyBuffer::Disconnect(IRpcChannelBuffer* pChannel)
//
//  DESCRIPTION:
//
//  Called when the proxy is being disconnected.  It just frees various pointers.
//
//  RETURN VALUE:
//
//  S_OK                all is well
//
//***************************************************************************

void STDMETHODCALLTYPE CUnboundSinkProxyBuffer::Disconnect()
{
    // Old Proxy code

    if(m_pOldProxy)
        m_pOldProxy->Disconnect();

    // Complete the Disconnect by releasing our references to the
    // old proxy pointers.  The old Proxy UnboundSink MUST be released first.

    if ( NULL != m_pOldProxyUnboundSink )
    {
        m_pOldProxyUnboundSink->Release();
        m_pOldProxyUnboundSink = NULL;
    }

    if ( NULL != m_pOldProxy )
    {
        m_pOldProxy->Release();
        m_pOldProxy = NULL;
    }

    if(m_pChannel)
        m_pChannel->Release();
    m_pChannel = NULL;
}

//****************************************************************************
//****************************************************************************
//                          STUB
//****************************************************************************
//****************************************************************************


//***************************************************************************
//
//  void* CUnboundSinkFactoryBuffer::GetInterface(REFIID riid)
//
//  DESCRIPTION:
//
//  CUnboundSinkFactoryBuffer is derived from CUnk.  Since CUnk handles the QI calls,
//  all classes derived from this must support this function.
//
//  RETURN VALUE:
//
//  S_OK                all is well
//
//***************************************************************************


void* CUnboundSinkStubBuffer::GetInterface(REFIID riid)
{
    if(riid == IID_IRpcStubBuffer)
        return &m_XUnboundSinkStublet;
    else
        return NULL;
}

CUnboundSinkStubBuffer::XUnboundSinkStublet::XUnboundSinkStublet(CUnboundSinkStubBuffer* pObj) 
    : CImpl<IRpcStubBuffer, CUnboundSinkStubBuffer>(pObj), m_pServer(NULL), m_lConnections( 0 )
{
    m_bFirstIndicate = true;
}

CUnboundSinkStubBuffer::XUnboundSinkStublet::~XUnboundSinkStublet() 
{
    if(m_pServer)
        m_pServer->Release();

    if ( NULL != m_pObject->m_pOldStub )
    {
        m_pObject->m_pOldStub->Release();
        m_pObject->m_pOldStub = NULL;
    }
}

//***************************************************************************
//
//  STDMETHODIMP CUnboundSinkStubBuffer::Connect(IUnknown* pUnkServer)
//
//  DESCRIPTION:
//
//  Called during the initialization of the stub.  The pointer to the
//  IWbemObject UnboundSink object is passed in.
//
//  RETURN VALUE:
//
//  S_OK                all is well
//
//***************************************************************************

STDMETHODIMP CUnboundSinkStubBuffer::XUnboundSinkStublet::Connect(IUnknown* pUnkServer)
{
    if(m_pServer)
        return E_UNEXPECTED;

    HRESULT hres = pUnkServer->QueryInterface(IID_IWbemUnboundObjectSink, 
                        (void**)&m_pServer);
    if(FAILED(hres))
        return E_NOINTERFACE;

    // get a pointer to the old stub which is in WBEMSVC.DLL  this allows
    // for backward compatibility

    IPSFactoryBuffer*   pIPS;

    // This is tricky --- The old proxys/stub stuff is actually registered under the
    // IID_IWbemObjectSink in wbemcli_p.cpp.  This single class id, is backpointered
    // by ProxyStubClsId32 entries for all the standard WBEM interfaces.


    HRESULT hr = CoGetClassObject( IID_IWbemObjectSink, CLSCTX_INPROC_HANDLER | CLSCTX_INPROC_SERVER,
                    NULL, IID_IPSFactoryBuffer, (void**) &pIPS );
    if (FAILED(hr))
    	return hr;    

    hr = pIPS->CreateStub( IID_IWbemUnboundObjectSink, m_pServer, &m_pObject->m_pOldStub );
    pIPS->Release();
    if (FAILED(hr))
    	return hr;

    // Successful connection

    m_lConnections++;
    return S_OK;
}

//***************************************************************************
//
//  void STDMETHODCALLTYPE CUnboundSinkStubBuffer::XUnboundSinkStublet::Disconnect()
//
//  DESCRIPTION:
//
//  Called when the stub is being disconnected.  It frees the IWbemUnboundObjectSink
//  pointer.
//
//  RETURN VALUE:
//
//  S_OK                all is well
//
//***************************************************************************

void STDMETHODCALLTYPE CUnboundSinkStubBuffer::XUnboundSinkStublet::Disconnect()
{
    // Inform the listener of the disconnect
    // =====================================

    HRESULT hres = S_OK;

    if(m_pObject->m_pOldStub)
        m_pObject->m_pOldStub->Disconnect();

    if(m_pServer)
    {
        m_pServer->Release();
        m_pServer = NULL;
    }

    // Successful disconnect
    m_lConnections--;

}


//***************************************************************************
//
//  STDMETHODIMP CUnboundSinkStubBuffer::XUnboundSinkStublet::Invoke(RPCOLEMESSAGE* pMessage, 
//                                        IRpcChannelBuffer* pChannel)
//
//  DESCRIPTION:
//
//  Called when a method reaches the stublet.  This checks the method id and
//  then branches to specific code for the Indicate, or SetStatus calls.
//
//  RETURN VALUE:
//
//  S_OK                all is well
//
//***************************************************************************

STDMETHODIMP CUnboundSinkStubBuffer::XUnboundSinkStublet::Invoke(RPCOLEMESSAGE* pMessage, 
                                        IRpcChannelBuffer* pChannel)
{
    // SetStatus is a pass through to the old layer

    if ( pMessage->iMethod == 3 )
        return IndicateToConsumer_Stub( pMessage, pChannel );
    else
        return RPC_E_SERVER_CANTUNMARSHAL_DATA;

}

//***************************************************************************
//
//  HRESULT CUnboundSinkStubBuffer::XUnboundSinkStublet::IndicateToConsumer_Stub( RPCOLEMESSAGE* pMessage, 
//                                                        IRpcChannelBuffer* pBuffer )
//
//  DESCRIPTION:
//
//  Handles the Indicate function in the stublet.
//
//  RETURN VALUE:
//
//  S_OK                all is well
//
//***************************************************************************

HRESULT CUnboundSinkStubBuffer::XUnboundSinkStublet::IndicateToConsumer_Stub( RPCOLEMESSAGE* pMessage, IRpcChannelBuffer* pBuffer )
{
    HRESULT             hr = RPC_E_SERVER_CANTUNMARSHAL_DATA;
    SCODE sc;

    // Determine if an old style, or new style packet has arrived

    CWbemUnboundSinkIndicatePacket packet( (LPBYTE) pMessage->Buffer, pMessage->cbBuffer);
    sc = packet.IsValid();
    bool bOldStyle = (S_OK != packet.IsValid());

    if(bOldStyle)
    {
        // Pass the call in using the old style stub

        hr = m_pObject->m_pOldStub->Invoke( pMessage, pBuffer );

		// Invoke must return S_OK, m_bFirstIndicate must be true and the actual return
		// code from the implementation code must be S_OK.

        if( hr == S_OK && m_bFirstIndicate && *(( HRESULT __RPC_FAR * )pMessage->Buffer) == S_OK )
        {
            // Let proxy know that we can handle the new style by returning a special return code.
        
            *(( HRESULT __RPC_FAR * )pMessage->Buffer) = WBEM_S_NEW_STYLE;
            m_bFirstIndicate = false;
            return hr;
        }
        return hr;
    }

    m_bFirstIndicate = false;

    // Got some new style data.  Unmarshall it.

    long lObjectCount = 0; 
    IWbemClassObject*   pLogicalConsumer = NULL;
    IWbemClassObject ** pObjArray = NULL;
    sc = packet.UnmarshalPacket( pLogicalConsumer, lObjectCount, pObjArray, m_ClassCache );

    // Only continue if the Unmarshaling succeeded.  If it failed, we still want
    // the sc to go back to the other side

    if ( SUCCEEDED( sc ) )
    {

        // Call the acual UnboundSink
        sc = m_pServer->IndicateToConsumer( pLogicalConsumer, lObjectCount, pObjArray );

        for ( int nCtr = 0; nCtr < lObjectCount; nCtr++ )
        {
            pObjArray[nCtr]->Release();
        }
    
        delete [] pObjArray;

        // Done with the logical consumer
        if ( NULL != pLogicalConsumer )
        {
            pLogicalConsumer->Release();
        }

    }

    // Send the results back

    pMessage->cbBuffer = sizeof(HRESULT);

    hr = pBuffer->GetBuffer( pMessage, IID_IWbemUnboundObjectSink );

    if ( SUCCEEDED( hr ) )
    {
        ((HRESULT*)pMessage->Buffer)[0] = sc;
    }
    else
    {
        hr = sc;
    }
    return hr;

}

IRpcStubBuffer* STDMETHODCALLTYPE CUnboundSinkStubBuffer::XUnboundSinkStublet::IsIIDSupported(
                                    REFIID riid)
{
    if(riid == IID_IWbemUnboundObjectSink)
    {
        // Don't AddRef().  At least that's what the sample on
        // Inside DCOM p.341 does.
        //AddRef(); // ?? not sure
        return this;
    }
    else return NULL;
}
    
ULONG STDMETHODCALLTYPE CUnboundSinkStubBuffer::XUnboundSinkStublet::CountRefs()
{
    // See Page 340-41 in Inside DCOM
    return m_lConnections;
}

STDMETHODIMP CUnboundSinkStubBuffer::XUnboundSinkStublet::DebugServerQueryInterface(void** ppv)
{
    if(m_pServer == NULL)
        return E_UNEXPECTED;

    *ppv = m_pServer;
    return S_OK;
}

void STDMETHODCALLTYPE CUnboundSinkStubBuffer::XUnboundSinkStublet::DebugServerRelease(void* pv)
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\marshalers\coreprox\svcwrap.h ===
/*++

Copyright (C) 2000-2001 Microsoft Corporation

Module Name:

    SVCWRAP.H

Abstract:

    IWbemServices delegator

History:

--*/

#ifndef __SVCWRAP_H__
#define __SVCWRAP_H__

#include <unk.h>
#include <wbemidl.h>
#include <wbemint.h>
#include <wbemcomn.h>
#include "mrshbase.h"

//***************************************************************************
//
//  class CWbemSvcWrapper
//
//  DESCRIPTION:
//
//  This class wraps an IWbemServices interface and can be used
//	to act as a delegator on method calls.
//
//***************************************************************************

class  CWbemSvcWrapper : public CUnk
{
protected:

    IWbemServices* m_pRealWbemSvcProxy;
    CProxySinkSecurity m_SinkSecurity;

public:
    CWbemSvcWrapper( CLifeControl* pControl, IUnknown* pOuter = NULL );
	virtual ~CWbemSvcWrapper(); 

    HRESULT EnsureSinkSecurity( IWbemObjectSink* pSink )
        { return m_SinkSecurity.EnsureSinkSecurity( pSink ); }

protected:

    class  XWbemServices : public CImpl<IWbemServices, CWbemSvcWrapper>
    {
    public:
        XWbemServices(CWbemSvcWrapper* pObject) : 
            CImpl<IWbemServices, CWbemSvcWrapper>(pObject)
        {}

		STDMETHOD(OpenNamespace)(
				const BSTR Namespace,
				LONG lFlags,
				IWbemContext* pContext,
				IWbemServices** ppNewNamespace,
				IWbemCallResult** ppResult
				);

		STDMETHOD(CancelAsyncCall)(IWbemObjectSink* pSink);
		STDMETHOD(QueryObjectSink)(long lFlags, IWbemObjectSink** ppResponseHandler);

		STDMETHOD(GetObject)(const BSTR ObjectPath, long lFlags, IWbemContext* pContext,
			IWbemClassObject** ppObject, IWbemCallResult** ppResult);
		STDMETHOD(GetObjectAsync)(const BSTR ObjectPath, long lFlags,
			IWbemContext* pContext, IWbemObjectSink* pResponseHandler);

		STDMETHOD(PutClass)(IWbemClassObject* pObject, long lFlags,
			IWbemContext* pContext, IWbemCallResult** ppResult);
		STDMETHOD(PutClassAsync)(IWbemClassObject* pObject, long lFlags,
			IWbemContext* pContext, IWbemObjectSink* pResponseHandler);

		STDMETHOD(DeleteClass)(const BSTR Class, long lFlags, IWbemContext* pContext,
			IWbemCallResult** ppResult);
		STDMETHOD(DeleteClassAsync)(const BSTR Class, long lFlags, IWbemContext* pContext,
			IWbemObjectSink* pResponseHandler);

		STDMETHOD(CreateClassEnum)(const BSTR Superclass, long lFlags,
			IWbemContext* pContext, IEnumWbemClassObject** ppEnum);
		STDMETHOD(CreateClassEnumAsync)(const BSTR Superclass, long lFlags,
			IWbemContext* pContext, IWbemObjectSink* pResponseHandler);

		STDMETHOD(PutInstance)(IWbemClassObject* pInst, long lFlags,
			IWbemContext* pContext, IWbemCallResult** ppResult);
		STDMETHOD(PutInstanceAsync)(IWbemClassObject* pInst, long lFlags,
			IWbemContext* pContext, IWbemObjectSink* pResponseHandler);

		STDMETHOD(DeleteInstance)(const BSTR ObjectPath, long lFlags,
			IWbemContext* pContext, IWbemCallResult** ppResult);
		STDMETHOD(DeleteInstanceAsync)(const BSTR ObjectPath, long lFlags,
			IWbemContext* pContext, IWbemObjectSink* pResponseHandler);

		STDMETHOD(CreateInstanceEnum)(const BSTR Class, long lFlags,
			IWbemContext* pContext, IEnumWbemClassObject** ppEnum);
		STDMETHOD(CreateInstanceEnumAsync)(const BSTR Class, long lFlags,
			IWbemContext* pContext, IWbemObjectSink* pResponseHandler);

		STDMETHOD(ExecQuery)(const BSTR QueryLanguage, const BSTR Query, long lFlags,
			IWbemContext* pContext, IEnumWbemClassObject** ppEnum);
		STDMETHOD(ExecQueryAsync)(const BSTR QueryFormat, const BSTR Query, long lFlags,
			IWbemContext* pContext, IWbemObjectSink* pResponseHandler);

		STDMETHOD(ExecNotificationQuery)(const BSTR QueryLanguage, const BSTR Query,
			long lFlags, IWbemContext* pContext, IEnumWbemClassObject** ppEnum);
		STDMETHOD(ExecNotificationQueryAsync)(const BSTR QueryFormat, const BSTR Query,
			long lFlags, IWbemContext* pContext, IWbemObjectSink* pResponseHandler);

		STDMETHOD(ExecMethod)(const BSTR ObjectPath, const BSTR MethodName, long lFlags,
			IWbemContext *pCtx, IWbemClassObject *pInParams,
			IWbemClassObject **ppOutParams, IWbemCallResult  **ppCallResult);
		STDMETHOD(ExecMethodAsync)(const BSTR ObjectPath, const BSTR MethodName, long lFlags,
			IWbemContext *pCtx, IWbemClassObject *pInParams,
			IWbemObjectSink* pResponseHandler);

		HRESULT WrapBSTR( BSTR bstrSrc, BSTR* pbstrDest );

    } m_XWbemServices;
    friend XWbemServices;

protected:
    void* GetInterface(REFIID riid);

public:
	void SetProxy( IWbemServices* pProxy );

	HRESULT Disconnect( void );

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\marshalers\coreprox\txtscmgr.cpp ===
/*++

Copyright (C) 2000-2001 Microsoft Corporation

Module Name:

    TXTSCMGR.CPP

Abstract:

  CTextSourceMgr implementation.

  Helper class for maintaining text source objects.

History:

  20-Feb-2000	sanjes    Created.

--*/

#include "precomp.h"
#include <stdlib.h>
#include <stdio.h>
#include "fastall.h"
#include "wmiobftr.h"
#include <corex.h>
#include "strutils.h"
#include <reg.h>
#include "txtscmgr.h"

//***************************************************************************
//
//  CTextSourceMgr::~CTextSourceMgr
//
//***************************************************************************
// ok
CTextSourceMgr::CTextSourceMgr()
:	m_cs(),
	m_TextSourceArray()
{
}
    
//***************************************************************************
//
//  CTextSourceMgr::~CTextSourceMgr
//
//***************************************************************************
// ok
CTextSourceMgr::~CTextSourceMgr()
{
}

// Protected Helpers
HRESULT CTextSourceMgr::Add( ULONG ulId, CWmiTextSource** pNewTextSource )
{
	HRESULT	hr = WBEM_S_NO_ERROR;

	// Always created with a ref count of 1
	CWmiTextSource*	pTextSource = new CWmiTextSource;
	CTemplateReleaseMe<CWmiTextSource>	rm( pTextSource );

	if ( NULL != pTextSource )
	{
		hr = pTextSource->Init( ulId );

		if ( SUCCEEDED( hr ) )
		{
			if ( m_TextSourceArray.Add( pTextSource ) < 0 )
			{
				hr = WBEM_E_OUT_OF_MEMORY;
			}
			else
			{
				// Copy out the new guy
				pTextSource->AddRef();
				*pNewTextSource = pTextSource;
			}
		}	//IF Initialized

	}	// IF alloc succeeded

	return hr;
}

//Implementation functions

// Adds if it cannot find an id
HRESULT CTextSourceMgr::Find( ULONG ulId, CWmiTextSource** pSrc )
{
	HRESULT	hr = WBEM_S_NO_ERROR;

	// This must be thread-safe
	CInCritSec	ics( &m_cs );

	// Keep track of the object we are pointing at
	CWmiTextSource*	pTextSource = NULL;

	for( int x = 0; x < m_TextSourceArray.GetSize(); x++ )
	{
		CWmiTextSource*	pTmpSource = m_TextSourceArray.GetAt( x );
		
		if ( pTmpSource->GetId() == ulId )
		{
			// AddRef for the return
			pTextSource = pTmpSource;
			pTextSource->AddRef();
			break;
		}
	}

	// See if we found it
	if ( NULL == pTextSource ) 
	{
		hr = Add( ulId, pSrc );
	}
	else
	{
		*pSrc = pTextSource;
	}

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\marshalers\coreprox\ubskpckt.cpp ===
/*++

Copyright (C) 1998-2001 Microsoft Corporation

Module Name:

    UBSKPCKT.CPP

Abstract:

    Unbound Sink Packet

History:

--*/

#include "precomp.h"
#include <stdio.h>
#include <stdlib.h>
#include <wbemcomn.h>
#include <fastall.h>
#include "ubskpckt.h"
#include "objarraypacket.h"

///////////////////////////////////////////////////////////////////
//
//  Function:   CWbemUnboundSinkIndicatePacket::CWbemUnboundSinkIndicatePacket
//  
//  Class Constructor
//
//  Inputs:
//              LPBYTE                      pDataPacket - Memory block.
//              DWORD                       dwPacketLength - Block Length.
//
//  Outputs:
//              None.
//
//  Returns:
//              None.
//
//  Comments:   Data must be supplied to this class for Unmarshaling
//              to succeed.
//
///////////////////////////////////////////////////////////////////

CWbemUnboundSinkIndicatePacket::CWbemUnboundSinkIndicatePacket( LPBYTE pDataPacket /* = NULL */, DWORD dwPacketLength /* = 0 */ )
:   CWbemDataPacket( pDataPacket, dwPacketLength ),
    m_pUnboundSinkIndicate( NULL )
{
    if ( NULL != pDataPacket )
    {
        m_pUnboundSinkIndicate = (PWBEM_DATAPACKET_UNBOUNDSINK_INDICATE) (pDataPacket + sizeof(WBEM_DATAPACKET_HEADER) );
    }
}

///////////////////////////////////////////////////////////////////
//
//  Function:   CWbemUnboundSinkIndicatePacket::~CWbemUnboundSinkIndicatePacket
//  
//  Class Destructor
//
//  Inputs:
//              None.
//
//  Outputs:
//              None.
//
//  Returns:
//              None.
//
//  Comments:   None.
//
///////////////////////////////////////////////////////////////////

CWbemUnboundSinkIndicatePacket::~CWbemUnboundSinkIndicatePacket()
{
}

///////////////////////////////////////////////////////////////////
//
//  Function:   CWbemUnboundSinkIndicatePacket::CalculateLength
//  
//  Calculates the length needed to packetize the supplied data.
//
//  Inputs:
//              IWbemClassObject*   pLogicalConsumer - Consumer Object
//              LONG                lObjectCount - Number of objects
//              IWbemClassObject**  apClassObjects - Array of object pointers.
//
//  Outputs:
//              DWORD*              pdwLength - Calculated Length
//              CWbemClassToIdMap&  classtoidmap - Map of class names to
//                                                  GUIDs.
//              GUID*               pguidClassIds - Array of GUIDs
//              BOOL*               pfSendFullObject - Full object flag array
//
//  Returns:
//              WBEM_S_NO_ERROR if success.
//
//  Comments:   This function uses the classtoidmap to fill out the
//              Class ID and Full Object arrays.  So that the object
//              array can be correctly interpreted by MarshalPacket.
//
///////////////////////////////////////////////////////////////////

HRESULT CWbemUnboundSinkIndicatePacket::CalculateLength( IWbemClassObject* pLogicalConsumer, LONG lObjectCount,
                                                        IWbemClassObject** apClassObjects, DWORD* pdwLength,
                                                        CWbemClassToIdMap& classtoidmap, GUID* pguidClassIds,
                                                        BOOL* pfSendFullObject )
{
    HRESULT hr = WBEM_S_NO_ERROR;
    DWORD   dwObjectLength = 0;

    // Get the size of the logical consumer object.  If it doesn't exist, obviously
    // its size is 0

    if ( NULL != pLogicalConsumer )
    {
        _IWmiObject* pObjInternals = NULL;

        hr = pLogicalConsumer->QueryInterface( IID__IWmiObject, (void**) &pObjInternals );

        if ( SUCCEEDED( hr ) )
        {

            // We need enough room to store the logical consumer object
            hr = pObjInternals->GetObjectMemory( NULL, 0, &dwObjectLength );

            // This is not an error
            if ( WBEM_E_BUFFER_TOO_SMALL == hr )
            {
                hr = WBEM_S_NO_ERROR;
            }

            // Cleanup the AddRef
            pObjInternals->Release();

        }   // IF QI

    }   // IF pLogicalConsumer

    // Now factor in the actual array
    if ( SUCCEEDED( hr ) )
    {
        DWORD   dwArrayLength = 0;

        // Now get the size of the objects as described by the object array
        CWbemObjectArrayPacket  arrayPacket;

        hr = arrayPacket.CalculateLength( lObjectCount, apClassObjects, &dwArrayLength, classtoidmap, pguidClassIds, pfSendFullObject );

        // Store the length if we're okey-dokey
        if ( SUCCEEDED( hr ) )
        {
            // Account for the header sizes
            *pdwLength = ( dwArrayLength + dwObjectLength + sizeof( WBEM_DATAPACKET_HEADER ) + sizeof( WBEM_DATAPACKET_UNBOUNDSINK_INDICATE ) );
        }

    }   // IF Got Object Length

    
    return hr;

}

///////////////////////////////////////////////////////////////////
//
//  Function:   CWbemUnboundSinkIndicatePacket::MarshalPacket
//  
//  Marshals the supplied data into a buffer.
//
//  Inputs:
//              IWbemClassObject*   pLogicalConsumer - Consumer Object
//              LONG                lObjectCount - Nmber of objects to marshal.
//              IWbemClassObject**  apClassObjects - Array of objects to write
//              GUID*               paguidClassIds - Array of GUIDs for objects.
//              BOOL*               pfSendFullObject - Full bject flags
//  Outputs:
//              None.
//
//  Returns:
//              WBEM_S_NO_ERROR if success.
//
//  Comments:   The GUID array and the array of flags must be filled
//              out correctly and the buffer must be large enough to
//              handle the marshaling.  The arrays will get filled
//              out correctly by CalculateLength().
//
///////////////////////////////////////////////////////////////////

HRESULT CWbemUnboundSinkIndicatePacket::MarshalPacket( IWbemClassObject* pLogicalConsumer, LONG lObjectCount,
                                                      IWbemClassObject** apClassObjects, GUID* paguidClassIds,
                                                      BOOL* pfSendFullObject )
{
    HRESULT hr = WBEM_E_FAILED;
    
    // Setup the main header first
    hr = SetupDataPacketHeader( m_dwPacketLength - sizeof(WBEM_DATAPACKET_HEADER), WBEM_DATAPACKETTYPE_UNBOUNDSINK_INDICATE, 0 );

    if ( SUCCEEDED( hr ) )
    {
        DWORD   dwUnboundObjectLength = 0;

        // Setup pbData and dwLength so we can walk through our header
        LPBYTE  pbData      =   (LPBYTE) m_pUnboundSinkIndicate;
        DWORD   dwLength    =   m_dwPacketLength - sizeof(WBEM_DATAPACKET_HEADER);

        // Fill out the Indicate Header
        m_pUnboundSinkIndicate->dwSizeOfHeader = sizeof(WBEM_DATAPACKET_UNBOUNDSINK_INDICATE);
        m_pUnboundSinkIndicate->dwDataSize = dwLength - sizeof(WBEM_DATAPACKET_UNBOUNDSINK_INDICATE);

        // Account for the indicate header
        pbData += sizeof(WBEM_DATAPACKET_UNBOUNDSINK_INDICATE);
        dwLength -= sizeof(WBEM_DATAPACKET_UNBOUNDSINK_INDICATE);

        if ( NULL != pLogicalConsumer )
        {

            // Now we will get the object memory and copy it into the buffer,
            // remembering that we will be filling the LogicalConsumerLength in
            // the header with the proper object buffer size.

            _IWmiObject*   pObjInternals = NULL;

            hr = pLogicalConsumer->QueryInterface( IID__IWmiObject, (void**) &pObjInternals );

            if ( SUCCEEDED( hr ) )
            {

                // We need enough room to store the logical consumer object
                DWORD dwTemp;

                hr = pObjInternals->GetObjectMemory( pbData, dwLength, &dwTemp);
                m_pUnboundSinkIndicate->dwLogicalConsumerSize = dwTemp;
                // Cleanup QI AddRef
                pObjInternals->Release();
                
            }   // IF QI

        }   // IF NULL != pLogicalConsumer
        else
        {
            // No consumer, so the length must be 0
            m_pUnboundSinkIndicate->dwLogicalConsumerSize = 0;
        }

        // Now marshal the array packet
        if ( SUCCEEDED( hr ) )
        {
            // Adjust for the logical consumer object then package up the rest of the array
            pbData += m_pUnboundSinkIndicate->dwLogicalConsumerSize;
            dwLength -= m_pUnboundSinkIndicate->dwLogicalConsumerSize;

            // Now use the array packet class to marshal the objects into the buffer
            CWbemObjectArrayPacket  arrayPacket( pbData, dwLength );
            hr = arrayPacket.MarshalPacket( lObjectCount, apClassObjects, paguidClassIds, pfSendFullObject );

        }   // IF GetObjectMemory



    }   // IF SetupDataPacketHeader

    return hr;
}

///////////////////////////////////////////////////////////////////
//
//  Function:   CWbemUnboundSinkIndicatePacket::UnmarshalPacket
//  
//  Unmarshals data from a buffer into the supplied parameters.
//
//  Inputs:
//              None.
//  Outputs:
//              IWbemClassObject*&  pLogicalConsumer - Consumer Object
//              LONG&               lObjectCount - Number of unmarshaled objects.
//              IWbemClassObject**& apClassObjects - Array of unmarshaled objects,
//              CWbemClassCache&    classCache - Class Cache used to wire up
//                                                  classless instances.
//
//  Returns:
//              WBEM_S_NO_ERROR if success.
//
//  Comments:   If function succeeds, the caller is responsible for cleaning
//              up and freeing the Class Object Array.  The class cache is
//              only used when we are dealing with Instance objects..
//
///////////////////////////////////////////////////////////////////

HRESULT CWbemUnboundSinkIndicatePacket::UnmarshalPacket( IWbemClassObject*& pLogicalConsumer, LONG& lObjectCount,
                                                        IWbemClassObject**& apClassObjects,
                                                        CWbemClassCache& classCache )
{
    HRESULT hr = WBEM_E_FAILED;
    LPBYTE  pbData = (LPBYTE) m_pUnboundSinkIndicate;
    DWORD   dwLength    =   m_dwPacketLength - sizeof(WBEM_DATAPACKET_HEADER);

    // Set the array to NULL.
    apClassObjects = NULL;

    // Check that the underlying BLOB is OK
    hr = IsValid();

    if ( SUCCEEDED( hr ) )
    {
        // Skip past the headers, and try to construct the logical consumer from memory.

        // Points us at the logical consumer object
        pbData += sizeof(WBEM_DATAPACKET_UNBOUNDSINK_INDICATE);
        dwLength -= sizeof(WBEM_DATAPACKET_UNBOUNDSINK_INDICATE);

        // Only need to handle the logical consumer if there was one.  If there wasn't then
        // the size will be 0.

        if ( m_pUnboundSinkIndicate->dwLogicalConsumerSize > 0 )
        {
	     if (m_pUnboundSinkIndicate->dwLogicalConsumerSize > dwLength) return WBEM_E_FAILED;

            // Allocate a buffer big enough to hold the memory blob, copy out the data and then
            // create us an object from the memory

            LPBYTE  pbObjData = g_CBasicBlobControl.Allocate(m_pUnboundSinkIndicate->dwLogicalConsumerSize);

            if ( NULL != pbObjData )
            {
                // Copy the bytes (this is VERY IMPORTANT)
                memcpy( pbObjData, pbData, m_pUnboundSinkIndicate->dwLogicalConsumerSize );

                DWORD dwTemp = m_pUnboundSinkIndicate->dwLogicalConsumerSize;
                pLogicalConsumer = CWbemObject::CreateFromMemory( pbObjData, dwTemp , TRUE, g_CBasicBlobControl);

                if ( NULL == pLogicalConsumer )
                {
                    hr = WBEM_E_OUT_OF_MEMORY;
                }

            }
            else
            {
                hr = WBEM_E_OUT_OF_MEMORY;
            }

        }   // IF logical cosumer size is > 0
        else
        {
            // No consumer to worry ourselves over
            pLogicalConsumer = NULL;
        }

        // Unmarshal the object array
        if ( SUCCEEDED( hr ) )
        {
            // Now skip over the object and try to unwind the object array
            pbData += m_pUnboundSinkIndicate->dwLogicalConsumerSize;
            dwLength -= m_pUnboundSinkIndicate->dwLogicalConsumerSize;

            // Unwind the array
            CWbemObjectArrayPacket  arrayPacket( pbData, dwLength );
            hr = arrayPacket.UnmarshalPacket( lObjectCount, apClassObjects, classCache );
        }

    }   // IF IsValid

    return hr;
}

///////////////////////////////////////////////////////////////////
//
//  Function:   CWbemUnboundSinkIndicatePacket::SetData
//  
//  Sets buffer to Marshal/Unmarshal to
//
//  Inputs:
//              LPBYTE                      pDataPacket - Memory block.
//              DWORD                       dwPacketLength - Block Length.
//
//  Outputs:
//              None.
//
//  Returns:
//              None.
//
//  Comments:   Data must be supplied to this class for IsValid
//              to succeed.
//
///////////////////////////////////////////////////////////////////

void CWbemUnboundSinkIndicatePacket::SetData( LPBYTE pDataPacket, DWORD dwPacketLength )
{
    // Go to our offset in the packet (assuming the packet is valid)
    if ( NULL != pDataPacket )
    {
        m_pUnboundSinkIndicate = (PWBEM_DATAPACKET_UNBOUNDSINK_INDICATE) (pDataPacket + sizeof(WBEM_DATAPACKET_HEADER) );
    }
    else
    {
        m_pUnboundSinkIndicate = NULL;
    }

    // Initialize the base class
    CWbemDataPacket::SetData( pDataPacket, dwPacketLength );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\marshalers\coreprox\ubskpckt.h ===
/*++

Copyright (C) 1998-2001 Microsoft Corporation

Module Name:

    UBSKPCKT.H

Abstract:

    Unbound Sink Packet

History:

--*/

#ifndef __UBSINKPACKET_H__
#define __UBSINKPACKET_H__

#include "wbemdatapacket.h"
#include "wbemobjpacket.h"
#include "wbemclasstoidmap.h"
#include "wbemclasscache.h"

// Store the current packing value, then set our own value
#pragma pack( push )
#pragma pack( 1 )

// IWbemObjectSink::Indicate() Header.  Changing this will
// cause the main version to change
typedef struct tagWBEM_DATAPACKET_UNBOUNDSINK_INDICATE
{
	DWORD	dwSizeOfHeader;	// Size of the header struct.  Data immediately follows header.
	DWORD	dwDataSize;		// Size of Data following header.
	DWORD	dwLogicalConsumerSize;	// Size of Logical Consumer Object
} WBEM_DATAPACKET_UNBOUNDSINK_INDICATE;

#ifdef _WIN64
typedef UNALIGNED WBEM_DATAPACKET_UNBOUNDSINK_INDICATE * PWBEM_DATAPACKET_UNBOUNDSINK_INDICATE;
#else
typedef WBEM_DATAPACKET_UNBOUNDSINK_INDICATE * PWBEM_DATAPACKET_UNBOUNDSINK_INDICATE;
#endif

// restore packing
#pragma pack( pop )

//
//	Class: CWbemUnboundSinkIndicatePacket
//
//	This class is designed to wrapper a data packet that describes an
//	IWbemUnbopundObjectSink::IndicateToConsumer() operation.  The data
//	structure of this packet is described above.  It makes use of
//	CWbemObjectPacket, CWbemInstancePacket, CWbemClassPacket and
//	CWbemClasslessInstancePacket to walk and analyze data for each of
//	the IWbemClassObjects that are indicated into the Sink.
//

class CWbemUnboundSinkIndicatePacket : public CWbemDataPacket
{

protected:

	PWBEM_DATAPACKET_UNBOUNDSINK_INDICATE	m_pUnboundSinkIndicate;

public:

	CWbemUnboundSinkIndicatePacket( LPBYTE pDataPacket = NULL, DWORD dwPacketLength = 0 );
	~CWbemUnboundSinkIndicatePacket();

	HRESULT CalculateLength( IWbemClassObject* pLogicalConsumer, LONG lObjectCount,
				IWbemClassObject** apClassObjects, DWORD* pdwLength, CWbemClassToIdMap& classtoidmap, GUID* pguidClassIds, BOOL* pfSendFullObject );
	HRESULT MarshalPacket( IWbemClassObject* pLogicalConsumer, LONG lObjectCount,
				IWbemClassObject** apClassObjects, GUID* paguidClassIds, BOOL* pfSendFullObject );
	HRESULT UnmarshalPacket( IWbemClassObject*& pLogicalConsumer, LONG& lObjectCount,
							IWbemClassObject**& apClassObjects, CWbemClassCache& classcache );

	// inline helper
	HRESULT MarshalPacket( LPBYTE pData, DWORD dwPacketLength, IWbemClassObject* pLogicalConsumer, 
				LONG lObjectCount, IWbemClassObject** apClassObjects, GUID* paguidClassIds,
				BOOL* pfSendFullObject );

	// Change the underlying pointers
	// Override of base class
	void SetData( LPBYTE pDataPacket, DWORD dwPacketLength );

};

inline HRESULT CWbemUnboundSinkIndicatePacket::MarshalPacket( LPBYTE pData, DWORD dwPacketLength,
															 IWbemClassObject* pLogicalConsumer,
															 LONG lObjectCount,
															 IWbemClassObject** apClassObjects,
															 GUID* paguidClassIds, BOOL* pfSendFullObject )
{
	SetData( pData, dwPacketLength );
	return MarshalPacket( pLogicalConsumer, lObjectCount, apClassObjects, paguidClassIds, pfSendFullObject );
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\marshalers\coreprox\wbemclasscache.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    WBEMCLASSCACHE.CPP

Abstract:

  WBEM Class Cache

History:

--*/

#include "precomp.h"
#include <stdio.h>
#include <stdlib.h>
#include <wbemcomn.h>
#include <fastall.h>
#include <sync.h>
#include "wbemclasscache.h"

///////////////////////////////////////////////////////////////////
//
//  Function:   CWbemClassCache::CWbemClassCache
//  
//  Default class constructor.
//
//  Inputs:
//              DWORD   dwBlockSize -   Block Size to resize cache
//                                      with.
//
//  Outputs:
//              None.
//
//  Returns:
//              None.
//
//  Comments:
//
///////////////////////////////////////////////////////////////////

CWbemClassCache::CWbemClassCache( DWORD dwBlockSize /* WBEMCLASSCACHE_DEFAULTBLOCKSIZE */ )
:   m_GuidToObjCache(),
    m_dwBlockSize( dwBlockSize )
{
}

///////////////////////////////////////////////////////////////////
//
//  Function:   CWbemClassCache::~CWbemClassCache
//  
//  Class destructor.
//
//  Inputs:
//              DWORD   dwBlockSize -   Block Size to resize cache
//                                      with.
//
//  Outputs:
//              None.
//
//  Returns:
//              None.
//
//  Comments:
//
///////////////////////////////////////////////////////////////////

CWbemClassCache::~CWbemClassCache()
{
    // Dump out our internal data
    Clear();
}

///////////////////////////////////////////////////////////////////
//
//  Function:   CWbemClassCache::Clear
//  
//  Empties out the cache.
//
//  Inputs:
//              None.
//
//  Outputs:
//              None.
//
//  Returns:
//              None.
//
//  Comments:
//
///////////////////////////////////////////////////////////////////

void CWbemClassCache::Clear( void )
{
    // Be careful here
    CInCritSec autoCS( &m_cs );

    // Walk the map and release all objects we find.
    for (   WBEMGUIDTOOBJMAPITER    iter = m_GuidToObjCache.begin();
            iter != m_GuidToObjCache.end();
            iter++ )
    {
        iter->second->Release();
    }

    m_GuidToObjCache.erase( m_GuidToObjCache.begin(), m_GuidToObjCache.end() );
}

///////////////////////////////////////////////////////////////////
//
//  Function:   CWbemClassCache::AddObject
//  
//  Associates a GUID with an IWbemClassObject and places them
//  in the cache.
//
//  Inputs:
//              GUID&               guid - GUID to associate with pObj.
//              IWbemClassObject*   pObj - Object to associate with guid.
//
//  Outputs:
//              None.
//
//  Returns:
//              None.
//
//  Comments:   The object will be AddRef()'d.
//
///////////////////////////////////////////////////////////////////

HRESULT CWbemClassCache::AddObject( GUID& guid, IWbemClassObject* pObj )
{
    HRESULT hr = WBEM_S_NO_ERROR;

    if ( NULL != pObj )
    {
        CGUID   guidInst( guid );

        // Must be threadsafe
        CInCritSec autoCS( &m_cs );

        // Add the object to the cache, if it doesn't already exist
        WBEMGUIDTOOBJMAPITER    iter;

        // If we found the guid, return an error (this shouldn't happen) 
        if( ( iter = m_GuidToObjCache.find( guidInst ) ) == m_GuidToObjCache.end() )
        {
            try
            {
                m_GuidToObjCache[guidInst] = pObj;
                pObj->AddRef();
            }
            catch( CX_Exception  &)
            {
                hr = WBEM_E_OUT_OF_MEMORY;
            }
        }
        else
        {
            // We've got duplicate GUIDs.  Why did this happen?
            hr = WBEM_E_FAILED;
        }

    }   // NULL != pObj
    else
    {
        hr = WBEM_E_INVALID_PARAMETER;
    }

    return hr;
}

///////////////////////////////////////////////////////////////////
//
//  Function:   CWbemClassCache::GetObject
//  
//  Searches the cache for the supplied GUID, and returns the associated
//  object to the caller.
//
//  Inputs:
//              GUID&               guid - GUID to look for
//
//  Outputs:
//              IWbemClassObject**  ppObj - Object that guid refers to.
//
//  Returns:
//              None.
//
//  Comments:   The IWbemClassObject::AddRef() will be called before
//              the function returns.  Caller must Release() the
//              object.
//
///////////////////////////////////////////////////////////////////

HRESULT CWbemClassCache::GetObject( GUID& guidClassId, IWbemClassObject** ppObj )
{
    HRESULT hr = WBEM_E_FAILED;

    if ( NULL != ppObj )
    {
        CGUID   guidTemp( guidClassId );

        // Must be threadsafe
        CInCritSec autoCS( &m_cs );
        
        // Add the object to the cache, if it doesn't already exist
        WBEMGUIDTOOBJMAPITER    iter;

        // If we found the guid, return an error (this shouldn't happen) 
        if( ( iter = m_GuidToObjCache.find( guidTemp ) ) != m_GuidToObjCache.end() )
        {
	        *ppObj = iter->second;
	        (*ppObj)->AddRef();
	        hr = WBEM_S_NO_ERROR;
        }
        else
        {
            // We got problems!
            hr = WBEM_E_NOT_FOUND;
        }

    }   // NULL != pObj
    else
    {
        hr = WBEM_E_INVALID_PARAMETER;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\marshalers\coreprox\wbemclasscache.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    WBEMCLASSCACHE.H

Abstract:

    Class Cache for marshaling

History:

--*/

#ifndef __WBEMCLASSCACHE_H__
#define __WBEMCLASSCACHE_H__

#include "wbemguid.h"
#include <vector>
#include "wstlallc.h"


//
//    Class:    CWbemClassCache
//
//    This class is intended to provide an easy to use interface for relating
//    GUIDs to IWbemClassObject pointers.  Its primary use is during Unmarshaling
//    of object pointers for WBEM operations in which we intend to share data
//    pieces between many individual IWbemClassObjects.
//
//

// Default Block Size for the class object array
#define    WBEMCLASSCACHE_DEFAULTBLOCKSIZE    64

typedef std::map<CGUID,IWbemClassObject*,less<CGUID>,wbem_allocator<IWbemClassObject*> >                WBEMGUIDTOOBJMAP;
typedef std::map<CGUID,IWbemClassObject*,less<CGUID>,wbem_allocator<IWbemClassObject*> >::iterator        WBEMGUIDTOOBJMAPITER;

#pragma warning(disable:4251)   // benign warning in this instance

class COREPROX_POLARITY CWbemClassCache
{
private:

    CCritSec     m_cs;
    WBEMGUIDTOOBJMAP    m_GuidToObjCache;
    DWORD                m_dwBlockSize;

    void Clear(void);

public:

    CWbemClassCache( DWORD dwBlockSize = WBEMCLASSCACHE_DEFAULTBLOCKSIZE );
    ~CWbemClassCache();

    // AddRefs the object if placed in the map.  Released on destruction
    HRESULT AddObject( GUID& guid, IWbemClassObject* pObj );

    // If object is found, it is AddRefd before it is returned
    HRESULT GetObject( GUID& guid, IWbemClassObject** pObj );
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\marshalers\coreprox\wbemclasstoidmap.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    WBEMCLASSTOIDMAP.CPP

Abstract:

  Class to id map for marshaling.

History:

--*/

///////////////////////////////////////////////////////////////////
//
//  Todo:       Create a new helper method to allocate and fetch
//              the object part.  Remove multiple maintenance 
//              points from AssignClassId and GetClassId
//
//
///////////////////////////////////////////////////////////////////

#include "precomp.h"
#include <stdio.h>
#include <stdlib.h>
#include <wbemcomn.h>
#include <fastall.h>
#include <sync.h>
#include "wbemclasstoidmap.h"

///////////////////////////////////////////////////////////////////
//
//  Function:   CWbemClassToIdMap::CWbemClassToIdMap
//  
//  Default Class Constructor
//
//  Inputs:
//              None.
//
//  Outputs:
//              None.
//
//  Returns:
//              None.
//
//  Comments:   None.
//
///////////////////////////////////////////////////////////////////

CWbemClassToIdMap::CWbemClassToIdMap()
:   m_ClassToIdMap()
{
}

///////////////////////////////////////////////////////////////////
//
//  Function:   CWbemClassToIdMap::~CWbemClassToIdMap
//  
//  Class Destructor
//
//  Inputs:
//              None.
//
//  Outputs:
//              None.
//
//  Returns:
//              None.
//
//  Comments:   None.
//
///////////////////////////////////////////////////////////////////

CWbemClassToIdMap::~CWbemClassToIdMap()
{
}

///////////////////////////////////////////////////////////////////
//
//  Function:   CWbemClassToIdMap::GetClassId
//  
//  Searches the map for the supplied object's class part and returns
//  the corresponding class id.
//
//  Inputs:
//              CWbemObject*    pObj - Pointer to Object
//              CMemBuffer*     pCacheBuffer - Object with a buffer to
//                              help minimize allocs.
//
//  Outputs:
//              GUID*           pguidClassId - Class Id we found.
//
//  Returns:
//              None.
//
//  Comments:   None.
//
///////////////////////////////////////////////////////////////////

HRESULT CWbemClassToIdMap::GetClassId( CWbemObject* pObj, GUID* pguidClassId, CMemBuffer* pCacheBuffer /* = NULL */ )
{
    HRESULT hr = WBEM_S_NO_ERROR;

    if ( NULL != pObj && NULL != pguidClassId )
    {
        // Obtain class part data from the supplied instance
        DWORD                   dwLength,
                                dwLengthCopied;

        hr = pObj->GetObjectParts( NULL, 0, WBEM_OBJ_CLASS_PART, &dwLength );

        if ( WBEM_E_BUFFER_TOO_SMALL == hr )
        {
            // OOM: Local memory - will be cleaned up automatically
            CMemBuffer  buff;
            BOOL        fGotMem = FALSE;

            // If we got passed in a cache buffer, we can use this to
            // store data for multiple operations, and just set its pointers
            // and length in the stack buffer.  Otherwise do our own allocation
            if ( NULL != pCacheBuffer )
            {
                // Only alloc if the buffer is to small
                if ( pCacheBuffer->GetLength() < dwLength )
                {
                    // OOM: Up to the calling method to clean up
                    fGotMem = pCacheBuffer->Alloc( dwLength );
                }
                else
                {
                    fGotMem = TRUE;
                }

                // SetData means that buff won't free it.  Also the length
                // we're interested in here is the length of the data, not
                // the length of the buffer, since we already know it's big
                // enough.

                buff.SetData( pCacheBuffer->GetData(), dwLength );
            }
            else
            {
                // OOM: Up to the calling method to clean up
                // Must allocate buffer now.
                fGotMem = buff.Alloc( dwLength );
            }

            // Now, if we've got a buffer of the appropriate length, copy out the data
            if ( fGotMem )
            {
                hr = pObj->GetObjectParts( buff.GetData(), buff.GetLength(), 
                                            WBEM_OBJ_CLASS_PART, &dwLengthCopied );

                if ( SUCCEEDED( hr ) )
                {
                    WBEMCLASSTOIDMAPITER    iter;

                    CInCritSec autoCS( &m_cs );

                    // Store the id if we are able to find  a match for the buffer
                    if( ( iter = m_ClassToIdMap.find( buff ) ) != m_ClassToIdMap.end() )
                    {
                        *pguidClassId = iter->second;
                    }
                    else
                    {
                        hr = WBEM_E_FAILED;
                    }

                }   // IF GetObjectParts\

            }   // IF buff.Alloc()
            else
            {
                hr = WBEM_E_OUT_OF_MEMORY;
            }

        }   // Buffer too small error

    }   // IF pointers valid
    else
    {
        hr = WBEM_E_INVALID_PARAMETER;
    }

    return hr;
}

///////////////////////////////////////////////////////////////////
//
//  Function:   CWbemClassToIdMap::AssignClassId
//  
//  Adds the supplied object's class data to the map, assigning a newly
//  created GUID to the name.
//
//  Inputs:
//              CWbemObject*    pObj - Pointer to Object
//              CMemBuffer*     pCacheBuffer - Object with a buffer to
//                              help minimize allocs.
//
//  Outputs:
//              GUID*       pguidClassId - Class Id we obtained.
//
//  Returns:
//              None.
//
//  Comments:   For speed sake, we may which to use a cache of
//              GUIDs, as CoCreateGuid apparently uses a system
//              wide mutex to do its dirty work.
//
///////////////////////////////////////////////////////////////////

HRESULT CWbemClassToIdMap::AssignClassId( CWbemObject* pObj, GUID* pguidClassId, CMemBuffer* pCacheBuffer /* = NULL */ )
{
    HRESULT hr = WBEM_S_NO_ERROR;

    if ( NULL != pObj && NULL != pguidClassId )
    {
        // Obtain class part data from the supplied instance
        DWORD                   dwLength,
                                dwLengthCopied;

        hr = pObj->GetObjectParts( NULL, 0, WBEM_OBJ_CLASS_PART, &dwLength );

        if ( WBEM_E_BUFFER_TOO_SMALL == hr )
        {
            // OOM: Local memory - will be cleaned up automatically
            CMemBuffer  buff;
            BOOL        fGotMem = FALSE;

            // If we got passed in a cache buffer, we can use this to
            // store data for multiple operations, and just set its pointers
            // and length in the stack buffer.  Otherwise do our own allocation
            if ( NULL != pCacheBuffer )
            {
                // Only alloc if the buffer is to small
                if ( pCacheBuffer->GetLength() < dwLength )
                {
                    // OOM: Up to the calling method to clean up
                    fGotMem = pCacheBuffer->Alloc( dwLength );
                }
                else
                {
                    fGotMem = TRUE;
                }

                // SetData means that buff won't free it.  Also the length
                // we're interested in here is the length of the data, not
                // the length of the buffer, since we already know it's big
                // enough.

                buff.SetData( pCacheBuffer->GetData(), dwLength );
            }
            else
            {
                // OOM: Up to the calling method to clean up
                // Must allocate buffer now
                fGotMem = buff.Alloc( dwLength );
            }

            // Now, if we've got a buffer of the appropriate length, copy out the data
            if ( fGotMem )
            {
                hr = pObj->GetObjectParts( buff.GetData(), buff.GetLength(), 
                                            WBEM_OBJ_CLASS_PART, &dwLengthCopied );

                if ( SUCCEEDED( hr ) )
                {

                    WBEMCLASSTOIDMAPITER    iter;

                    CInCritSec autoCS( &m_cs );

                    // If we are unable to locate our key in the map, then we should
                    // add a new entry.
                    if( ( iter = m_ClassToIdMap.find( buff ) ) == m_ClassToIdMap.end() )
                    {
                        // Store the next id, then bump it up one.
                        GUID    guid;

                        hr = CoCreateGuid( &guid );

                        if ( SUCCEEDED( hr ) )
                        {
                            // Call CopyData on buff using its internal pointers if we
                            // are using a cache buffer, since we want the buffer to
                            // be stored locally at this point.  Otherwise there is no
                            // need to copy the buffer

                            if ( NULL == pCacheBuffer
                                || buff.CopyData( buff.GetData(), buff.GetLength() ) )
                            {
                                // At this point, buff only holds the pointers.  Force a copy
                                // of the data to be made before we store the data.
                                try
                                {
                                    m_ClassToIdMap[buff] = guid;
                                    *pguidClassId = guid;
                                }
                                catch( CX_Exception &)
                                {
                                    hr = WBEM_E_OUT_OF_MEMORY;
                                }
                            }
                            else
                            {
                                hr = WBEM_E_OUT_OF_MEMORY;
                            }
                        }

                    }   // IF found
                    else
                    {
                        hr = WBEM_E_FAILED;
                    }

                }   // IF GetObjectParts\

            }   // IF buff.Alloc()
            else
            {
                hr = WBEM_E_OUT_OF_MEMORY;
            }

        }   // Buffer too small error

    }   // IF pointers valid
    else
    {
        hr = WBEM_E_INVALID_PARAMETER;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\marshalers\coreprox\wbemdatapacket.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    WBEMDATAPACKET.CPP

Abstract:

    Base Data packet class

History:

--*/

#include "precomp.h"
#include <stdio.h>
#include <stdlib.h>
#include <wbemcomn.h>
#include <fastall.h>
#include "wbemdatapacket.h"

BYTE CWbemDataPacket::s_abSignature[WBEM_DATAPACKET_SIZEOFSIGNATURE] = WBEM_DATAPACKET_SIGNATURE;

///////////////////////////////////////////////////////////////////
//
//  Function:   CWbemDataPacket::CWbemDataPacket
//  
//  Class Constructor
//
//  Inputs:
//              LPBYTE                      pDataPacket - Memory block.
//              DWORD                       dwPacketLength - Block Length.
//
//  Outputs:
//              None.
//
//  Returns:
//              None.
//
//  Comments:   Data must be supplied to this class for IsValid
//              to succeed.
//
///////////////////////////////////////////////////////////////////

CWbemDataPacket::CWbemDataPacket( LPBYTE pDataPacket /* = NULL */, DWORD dwPacketLength /* = 0 */ )
:   m_pDataPacket( (PWBEM_DATAPACKET_HEADER) pDataPacket ),
    m_dwPacketLength( dwPacketLength )
{
}

///////////////////////////////////////////////////////////////////
//
//  Function:   CWbemDataPacket::~CWbemDataPacket
//  
//  Class Destructor
//
//  Inputs:
//              None.
//
//  Outputs:
//              None.
//
//  Returns:
//              None.
//
//  Comments:   None.
//
///////////////////////////////////////////////////////////////////

CWbemDataPacket::~CWbemDataPacket()
{
}

///////////////////////////////////////////////////////////////////
//
//  Function:   CWbemDataPacket::IsValid
//  
//  Checks the underlying memory for known byte patterns and values
//  in the header to make the determination as to whether or not
//  the packet is a valid header.
//
//  Inputs:
//              None.
//
//  Outputs:
//              None.
//
//  Returns:
//              WBEM_S_NO_ERROR if success.
//
//  Comments:   None.
//
///////////////////////////////////////////////////////////////////

HRESULT CWbemDataPacket::IsValid( void )
{
    HRESULT hr = WBEM_E_INVALID_OPERATION;

    // We must have a data packet
    if ( NULL != m_pDataPacket )
    {
        // The packet MUST be of at least the minimum size
        if ( m_dwPacketLength >= WBEM_DATAPACKET_HEADER_MINSIZE ) 
        {

            // The packet MUST start with one of the valid byte ordering values
            // immediately followed by the supplied signature
            if (    (   m_pDataPacket->dwByteOrdering == WBEM_DATAPACKET_LITTLEENDIAN
                    ||  m_pDataPacket->dwByteOrdering == WBEM_DATAPACKET_BIGENDIAN  )
                &&  memcmp( m_pDataPacket->abSignature, s_abSignature, WBEM_DATAPACKET_SIZEOFSIGNATURE ) == 0 )
            {
                // The packet type MUST be recognized
                if ( WBEM_DATAPACKETTYPE_LAST > m_pDataPacket->bPacketType )
                {

                    // Version must be <= to the current version or we in big trouble
                    if ( m_pDataPacket->bVersion <= WBEM_DATAPACKET_HEADER_CURRENTVERSION )
                    {
                        hr = WBEM_S_NO_ERROR;
                    }
                    else
                    {
                        hr = WBEM_E_MARSHAL_VERSION_MISMATCH;
                    }
                }
                else
                {
                    hr = WBEM_E_UNKNOWN_PACKET_TYPE;
                }

            }   // IF Check Signature
            else
            {
                hr = WBEM_E_MARSHAL_INVALID_SIGNATURE;
            }

        }   // IF length too small
        else
        {
            hr = WBEM_E_BUFFER_TOO_SMALL;
        }

    }   // IF buffer pointer invalid

    return hr;

}

///////////////////////////////////////////////////////////////////
//
//  Function:   CWbemDataPacket::SetupDataPacketHeader
//  
//  Places the supplied data in the supplied buffer in a format that
//  will identify the buffer as a Wbem data packet.
//
//  Inputs:
//              DWORD                   dwDataSize - Size of Data following header.
//              BYTE                    bPacketType - Our packet type.
//              DWORD                   dwFlags - Flag values.
//              DWORD                   dwByteOrdering - Byte ordering.
//
//  Outputs:
//              None.
//
//  Returns:
//              WBEM_S_NO_ERROR if success.
//
//  Comments:   dwByteOrdering should be either WBEM_DATAPACKET_LITTLEENDIAN or
//              WBEM_DATAPACKET_BIGENDIAN.
//
///////////////////////////////////////////////////////////////////

HRESULT CWbemDataPacket::SetupDataPacketHeader( DWORD dwDataSize, BYTE bPacketType, DWORD dwFlags, DWORD dwByteOrdering /* = WBEM_DATAPACKET_LITTLEENDIAN */ )
{
    HRESULT hr = WBEM_E_INVALID_PARAMETER;

    // Pointer and length must be valid
    if ( NULL != m_pDataPacket )
    {

        if ( m_dwPacketLength >= ( sizeof(WBEM_DATAPACKET_HEADER) + dwDataSize ) )
        {

            // Clear out memory, then fill out the packet
            ZeroMemory( m_pDataPacket, sizeof(WBEM_DATAPACKET_HEADER) );

            m_pDataPacket->dwByteOrdering = dwByteOrdering;
            memcpy( m_pDataPacket->abSignature, s_abSignature, WBEM_DATAPACKET_SIZEOFSIGNATURE );
            m_pDataPacket->dwSizeOfHeader = sizeof(WBEM_DATAPACKET_HEADER);
            m_pDataPacket->dwDataSize = dwDataSize;
            m_pDataPacket->bVersion = WBEM_DATAPACKET_HEADER_CURRENTVERSION;
            m_pDataPacket->bPacketType = bPacketType;
            m_pDataPacket->dwFlags = dwFlags;

            hr = WBEM_S_NO_ERROR;

        }   // IF length is valid
        else
        {
            hr = WBEM_E_BUFFER_TOO_SMALL;
        }

    }   // IF NULL != pData

    return hr;

}

///////////////////////////////////////////////////////////////////
//
//  Function:   CWbemDataPacket::SetData
//  
//  Sets buffer to Marshal/Unmarshal to
//
//  Inputs:
//              LPBYTE                      pDataPacket - Memory block.
//              DWORD                       dwPacketLength - Block Length.
//
//  Outputs:
//              None.
//
//  Returns:
//              None.
//
//  Comments:   Data must be supplied to this class for IsValid
//              to succeed.
//
///////////////////////////////////////////////////////////////////

void CWbemDataPacket::SetData( LPBYTE pDataPacket, DWORD dwPacketLength )
{
    m_pDataPacket = (PWBEM_DATAPACKET_HEADER) pDataPacket;
    m_dwPacketLength = dwPacketLength;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\marshalers\coreprox\wbemdatapacket.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	WBEMDATAPACKET.H

Abstract:

  Base class for data packets.

History:

--*/

#ifndef __WBEMDATAPACKET_H__
#define __WBEMDATAPACKET_H__

// All Datapackets preceded by these values.

// One of these values comes first
#define	WBEM_DATAPACKET_LITTLEENDIAN	0x00000000
#define	WBEM_DATAPACKET_BIGENDIAN		0xFFFFFFFF

// Then comes the signature bytes
#define	WBEM_DATAPACKET_SIGNATURE	{ 0x57, 0x42, 0x45, 0x4D, 0x44, 0x41, 0x54, 0x41 }

// We use an 8 byte signature
#define WBEM_DATAPACKET_SIZEOFSIGNATURE	8

// As DataPacketType is actually a byte, this gives us 255 of these effectively
typedef enum
{
	WBEM_DATAPACKETYPE_FIRST = 0,
	WBEM_DATAPACKETTYPE_OBJECTSINK_INDICATE = 0,
	WBEM_DATAPACKETTYPE_SMARTENUM_NEXT = 1,
	WBEM_DATAPACKETTYPE_UNBOUNDSINK_INDICATE = 2,
	WBEM_DATAPACKETTYPE_MULTITARGET_DELIVEREVENT = 3,
	WBEM_DATAPACKETTYPE_LAST
} WBEM_DATAPACKETTYPE;

// Define any packet specific flags here (we're looking at BitMasks here)
typedef enum
{
	WBEM_DATAPACKETFLAGS_COMPRESSED = 1
} WBEM_DATAPACKETFLAGS;

// Store the current packing value, then set our own value
#pragma pack( push )
#pragma pack( 1 )

// Version 1 data packet
// Add data to these structures at the bottom to ensure backwards compatibility
typedef struct tagWBEM_DATAPACKET_HEADER1
{
	DWORD	dwByteOrdering;	// Big or Little Endian?
	BYTE	abSignature[WBEM_DATAPACKET_SIZEOFSIGNATURE];	// Set to the signature value defined above
	DWORD	dwSizeOfHeader;	// Size of the header struct.  Data immediately follows header.
	DWORD	dwDataSize;		// Size of Data following header.
	DWORD	dwFlags;		// Compression, encryption, etc.
	BYTE	bVersion;		// Version Number of Header.  Starting Version is 1.
	BYTE	bPacketType;	// Type of packet this is
} WBEM_DATAPACKET_HEADER1;

typedef WBEM_DATAPACKET_HEADER1*	PWBEM_DATAPACKET_HEADER1;

// Version Information

// As the packet format changes, change these to stay current
#define WBEM_DATAPACKET_HEADER_CURRENTVERSION	1
#define WBEM_DATAPACKET_HEADER					WBEM_DATAPACKET_HEADER1
#define PWBEM_DATAPACKET_HEADER					PWBEM_DATAPACKET_HEADER1

// Minimum packet size
#define	WBEM_DATAPACKET_HEADER_MINSIZE			sizeof(WBEM_DATAPACKET_HEADER1)

// restore packing
#pragma pack( pop )

// Accessor class for making packets from objects and turning packets
// into objects.

//
//	Class: CWbemDataPacket
//
//	This class is designed to provide a single point of access for working
//	with Wbem Data Packets.  Base classes should inherit from this class
//	and implement functions that:
//
//	1>	Return a precalculated length.
//	2>	Build a packet (including this header) from supplied data.
//	3>	Read an existing packet and supply appropriate data from it.
//
//	Derived classes are responsible for their own formats.  It is assumed that
//	a Wbem Data Packet is a large BLOB, which will always begin with this
//	header.
//
//	This class will not FREE up any memory it is sitting on top of.  It is
//	up to the supplier of said memory to clean up after themselves.
//

class COREPROX_POLARITY CWbemDataPacket
{
private:
protected:

	static BYTE				s_abSignature[WBEM_DATAPACKET_SIZEOFSIGNATURE];
	PWBEM_DATAPACKET_HEADER	m_pDataPacket;
	DWORD					m_dwPacketLength;

	// Packet Building Functions
	HRESULT SetupDataPacketHeader( DWORD dwDataSize, BYTE bPacketType, DWORD dwFlags, DWORD dwByteOrdering = WBEM_DATAPACKET_LITTLEENDIAN );

public:

	CWbemDataPacket( LPBYTE pDataPacket = NULL, DWORD dwPacketLength = 0 );
	~CWbemDataPacket();

	DWORD GetMinHeaderSize( void );

	// Packet Validation
	virtual HRESULT IsValid( void );

	// Change the underlying pointers
	virtual void SetData( LPBYTE pDataPacket, DWORD dwPacketLength );

};

inline DWORD CWbemDataPacket::GetMinHeaderSize( void )
{
	return WBEM_DATAPACKET_HEADER_MINSIZE;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\marshalers\coreprox\wbemclasstoidmap.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    WBEMCLASSTOIDMAP.H

Abstract:

  Class to id map for marshaling.

History:

--*/

#ifndef __WBEMCLASSTOIDMAP_H__
#define __WBEMCLASSTOIDMAP_H__

#include <map>
#include "wstlallc.h"

//
//    Class:    CMemBuffer
//
//    The intent of this class is to provide a packager for a memory buffer
//    so we can use the buffer in STL implementations of standard data structures
//    such as maps, vectors, lists, etc.
//
//

class  CMemBuffer
{
public:

    CMemBuffer( LPBYTE pbData = NULL, DWORD dwLength = 0 );
    CMemBuffer( const CMemBuffer& buff );
    ~CMemBuffer();

    BOOL Alloc( DWORD dwLength );
    BOOL ReAlloc( DWORD dwLength );
    void Free( void );

    LPBYTE GetData( void );
    DWORD GetLength( void );
    BOOL CopyData( LPBYTE pbData, DWORD dwLength );
    void SetData( LPBYTE pbData, DWORD dwLength );

    CMemBuffer& operator=( const CMemBuffer& buff );
    bool operator<( const CMemBuffer& buff ) const;
    bool operator==( const CMemBuffer& buff ) const;

private:

    LPBYTE    m_pbData;    // Pointer to buffer
    DWORD    m_dwLength;    // Length of buffer
    BOOL    m_fOwned;    // Is the buffer owned internally?
};

///////////////////////////////////////////////////////////////////
//
//    Function:    CMemBuffer::CMemBuffer
//    
//     Class Constructor
//
//    Inputs:
//                LPBYTE        pbData - Data Buffer
//                DWORD        dwLength - Length of Buffer
//
//    Outputs:
//                None.
//
//    Returns:
//                None.
//
//    Comments:    None.
//
///////////////////////////////////////////////////////////////////

inline CMemBuffer::CMemBuffer( LPBYTE pbData /* = NULL */, DWORD dwLength /* = 0 */ )
:    m_pbData( pbData ),
    m_dwLength( dwLength ),
    m_fOwned( FALSE )
{
}

///////////////////////////////////////////////////////////////////
//
//    Function:    CMemBuffer::~CMemBuffer
//    
//     Class Destructor
//
//    Inputs:
//                None.
//
//    Outputs:
//                None.
//
//    Returns:
//                None.
//
//    Comments:    None.
//
///////////////////////////////////////////////////////////////////

inline CMemBuffer::~CMemBuffer()
{
    Free();
}

///////////////////////////////////////////////////////////////////
//
//    Function:    CMemBuffer::CMemBuffer
//    
//     Class Copy Constructor
//
//    Inputs:
//                const CMemBuffer& buff - Bufffer object to copy.
//
//    Outputs:
//                None.
//
//    Returns:
//                None.
//
//    Comments:    None.
//
///////////////////////////////////////////////////////////////////

inline CMemBuffer::CMemBuffer( const CMemBuffer& buff )
:    m_pbData( NULL ),
    m_dwLength( 0 ),
    m_fOwned( FALSE )
{
    // Perform Copy or set based on whether or not the buffer
    // we are copying owns its data or not.

    if ( buff.m_fOwned )
    {
        CopyData( buff.m_pbData, buff.m_dwLength );
    }
    else
    {
        SetData( buff.m_pbData, buff.m_dwLength );
    }
}

///////////////////////////////////////////////////////////////////
//
//    Function:    CMemBuffer::GetData
//    
//    Retrieves a pointer to the internal data.
//
//    Inputs:
//                None.
//
//    Outputs:
//                None.
//
//    Returns:
//                LPBYTE m_pbData.
//
//    Comments:    None.
//
///////////////////////////////////////////////////////////////////

inline LPBYTE CMemBuffer::GetData( void )
{
    return m_pbData;
}

///////////////////////////////////////////////////////////////////
//
//    Function:    CMemBuffer::GetLength
//    
//    Retrieves the length value.
//
//    Inputs:
//                None.
//
//    Outputs:
//                None.
//
//    Returns:
//                DWORD m_dwLength.
//
//    Comments:    None.
//
///////////////////////////////////////////////////////////////////

inline DWORD CMemBuffer::GetLength( void )
{
    return m_dwLength;
}

///////////////////////////////////////////////////////////////////
//
//    Function:    CMemBuffer::Alloc
//    
//    Allocates a buffer to the specified length.
//
//    Inputs:
//                DWORD        dwLength - Length of buffer to allocate
//
//    Outputs:
//                None.
//
//    Returns:
//                TRUE/FALSE    - Success/Failure
//
//    Comments:    Previous data is cleared.
//
///////////////////////////////////////////////////////////////////

inline BOOL CMemBuffer::Alloc( DWORD dwLength )
{
    Free();
    m_pbData = new BYTE[dwLength];

    if ( NULL != m_pbData )
    {
        m_dwLength = dwLength;
        m_fOwned = TRUE;
    }

    return NULL != m_pbData;
}

///////////////////////////////////////////////////////////////////
//
//    Function:    CMemBuffer::ReAlloc
//    
//    Reallocs our buffer, copying data as necessary.
//
//    Inputs:
//                DWORD        dwLength - Length of buffer to allocate
//
//    Outputs:
//                None.
//
//    Returns:
//                TRUE/FALSE    - Success/Failure
//
//    Comments:    Previous data is copied into new buffer.
//
///////////////////////////////////////////////////////////////////

inline BOOL CMemBuffer::ReAlloc( DWORD dwLength )
{
    LPBYTE    pbData = new BYTE[dwLength];

    if ( NULL != pbData )
    {
        CopyMemory( pbData, m_pbData, min( dwLength, m_dwLength ) );
        Free();
        m_pbData = pbData;
        m_dwLength = dwLength;
        m_fOwned = TRUE;
    }

    return ( NULL != pbData );
}

///////////////////////////////////////////////////////////////////
//
//    Function:    CMemBuffer::Free
//    
//    Clears data.
//
//    Inputs:
//                None.
//
//    Outputs:
//                None.
//
//    Returns:
//                None.
//
//    Comments:    Data buffer is only freed if it is owned
//
///////////////////////////////////////////////////////////////////

inline void CMemBuffer::Free( void )
{
    if ( NULL != m_pbData && m_fOwned )
    {
        delete [] m_pbData;
    }
    m_pbData = NULL;
    m_dwLength = 0;
    m_fOwned = FALSE;
}

///////////////////////////////////////////////////////////////////
//
//    Function:    CMemBuffer::CopyData
//    
//    Copies supplied data internally.
//
//    Inputs:
//                LPBYTE        pbData - Data Buffer to copy
//                DWORD        dwLength - Length of buffer
//
//    Outputs:
//                None.
//
//    Returns:
//                TRUE/FALSE    - Success/Failure
//
//    Comments:    Previous data is freed.
//
///////////////////////////////////////////////////////////////////

inline BOOL CMemBuffer::CopyData( LPBYTE pbData, DWORD dwLength )
{
    BOOL fReturn = Alloc( dwLength );

    if ( fReturn )
    {
        CopyMemory( m_pbData, pbData, dwLength );
    }

    return fReturn;
}

///////////////////////////////////////////////////////////////////
//
//    Function:    CMemBuffer::SetData
//    
//    Sets internal pointers, but does not allocate data.
//
//    Inputs:
//                LPBYTE        pbData - Data Buffer to set
//                DWORD        dwLength - Length of buffer
//
//    Outputs:
//                None.
//
//    Returns:
//                TRUE/FALSE    - Success/Failure
//
//    Comments:    Previous data is freed.
//
///////////////////////////////////////////////////////////////////

inline void CMemBuffer::SetData( LPBYTE pbData, DWORD dwLength )
{
    Free();
    m_pbData = pbData;
    m_dwLength = dwLength;
    m_fOwned = FALSE;
}

///////////////////////////////////////////////////////////////////
//
//    Function:    CMemBuffer::operator=
//    
//    Copies supplied Memory Buffer
//
//    Inputs:
//                CMemBuffer&    buff - Buffer object to copy.
//
//    Outputs:
//                None.
//
//    Returns:
//                CMemBuffer&    *this
//
//    Comments:    CopyData() or SetData() called based on whether
//                the supplied buffer owns its data.
//
///////////////////////////////////////////////////////////////////

inline CMemBuffer& CMemBuffer::operator=( const CMemBuffer& buff )
{
    if ( buff.m_fOwned )
    {
        CopyData( buff.m_pbData, buff.m_dwLength );
    }
    else
    {
        SetData( buff.m_pbData, buff.m_dwLength );
    }

    return *this;
}

///////////////////////////////////////////////////////////////////
//
//    Function:    CMemBuffer::operator==
//    
//    Checks supplied Memory Buffer for equality
//
//    Inputs:
//                const CMemBuffer&    buff - Buffer object to copy.
//
//    Outputs:
//                None.
//
//    Returns:
//                TRUE/FALSE - Equals or not equals
//
//    Comments:    Compares data in this and that buffer.
//
///////////////////////////////////////////////////////////////////

inline bool CMemBuffer::operator==( const CMemBuffer& buff ) const
{
    if ( m_dwLength == buff.m_dwLength )
    {
        return ( memcmp( m_pbData, buff.m_pbData, m_dwLength ) == 0);
    }
    else
    {
        return false;
    }
}

///////////////////////////////////////////////////////////////////
//
//    Function:    CMemBuffer::operator<
//    
//    Checks supplied Memory Buffer for equality
//
//    Inputs:
//                const CMemBuffer&    buff - Buffer object to copy.
//
//    Outputs:
//                None.
//
//    Returns:
//                TRUE/FALSE - Is Less Than
//
//    Comments:    Compares data in this and that buffer.
//
///////////////////////////////////////////////////////////////////

inline bool CMemBuffer::operator<( const CMemBuffer& buff ) const
{
    if ( m_dwLength == buff.m_dwLength  )
    {
        return ( memcmp( m_pbData, buff.m_pbData, m_dwLength ) < 0 );
    }
    else
    {
        return ( m_dwLength < buff.m_dwLength );
    }
}

//
//    Class:    CWbemClassToIdMap
//
//    This Class is intended to provide a simple interface for relating a classname
//    to a GUID.  It uses an STL map to accomplish this.  Because the class name
//    is a string, we convert it to a DWORD using a hash function.  The interface
//    to this function should be string based for ease of use.  The underlying
//    mechanism can be modified as needed should speed become an issue.
//


typedef    std::map<CMemBuffer,GUID,less<CMemBuffer>,wbem_allocator<GUID> >                WBEMCLASSTOIDMAP;
typedef    std::map<CMemBuffer,GUID,less<CMemBuffer>,wbem_allocator<GUID> >::iterator    WBEMCLASSTOIDMAPITER;

#pragma warning(disable:4251)   // benign warning in this case

class  CWbemClassToIdMap
{
private:

    CCritSec    m_cs;
    WBEMCLASSTOIDMAP    m_ClassToIdMap;

public:

    CWbemClassToIdMap();
    ~CWbemClassToIdMap();

    HRESULT GetClassId( CWbemObject* pObj, GUID* pguidClassId, CMemBuffer* pCacheBuffer = NULL );
    HRESULT AssignClassId( CWbemObject* pObj, GUID* pguidClassId, CMemBuffer* pCacheBuffer = NULL );
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\marshalers\coreprox\wbemguidtoclassmap.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    WBEMGUIDTOCLASSMAP.H

Abstract:

    GUID to class map for marshaling.

History:

--*/

#ifndef __WBEMGUIDTOCLASSMAP_H__
#define __WBEMGUIDTOCLASSMAP_H__

#include "wbemguid.h"
#include "wbemclasstoidmap.h"
#include <map>
#include "wstlallc.h"

//
//    Class:    CWbemGuidToClassMap
//
//    This Class is intended to provide a simple interface for relating a GUID
//    to a class to id map.  It uses an STL map to accomplish this.  In cases where we
//    need to keep multiple caches for unique instances, this map provides an
//    easy interface for doing so.
//

typedef    std::map<CGUID,CWbemClassToIdMap*,less<CGUID>,wbem_allocator<CWbemClassToIdMap*> >                WBEMGUIDTOCLASSMAP;
typedef    std::map<CGUID,CWbemClassToIdMap*,less<CGUID>,wbem_allocator<CWbemClassToIdMap*> >::iterator    WBEMGUIDTOCLASSMAPITER;

#pragma warning(disable:4251)   // benign warning in this instance

class COREPROX_POLARITY CWbemGuidToClassMap
{
private:
    CCritSec    m_cs;
    WBEMGUIDTOCLASSMAP    m_GuidToClassMap;
    void Clear( void );

public:
    CWbemGuidToClassMap();
    ~CWbemGuidToClassMap();
    HRESULT GetMap( CGUID& guid, CWbemClassToIdMap** ppCache );
    HRESULT AddMap( CGUID& guid, CWbemClassToIdMap** pppCache );
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\marshalers\coreprox\wbemguidtoclassmap.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    WBEMGUIDTOCLASSMAP.CPP

Abstract:

    GUID to class map for marshaling.

History:

--*/

#include "precomp.h"
#include <stdio.h>
#include <stdlib.h>
#include <wbemcomn.h>
#include <fastall.h>
#include <sync.h>
#include "wbemguidtoclassmap.h"

///////////////////////////////////////////////////////////////////
//
//  Function:   CWbemGuidToClassMap::CWbemGuidToClassMap
//  
//  Default Class Constructor
//
//  Inputs:
//              None.
//
//  Outputs:
//              None.
//
//  Returns:
//              None.
//
//  Comments:   None.
//
///////////////////////////////////////////////////////////////////

CWbemGuidToClassMap::CWbemGuidToClassMap()
:   m_GuidToClassMap()
{
}

///////////////////////////////////////////////////////////////////
//
//  Function:   CWbemGuidToClassMap::~CWbemGuidToClassMap
//  
//  Class Destructor
//
//  Inputs:
//              None.
//
//  Outputs:
//              None.
//
//  Returns:
//              None.
//
//  Comments:   None.
//
///////////////////////////////////////////////////////////////////

CWbemGuidToClassMap::~CWbemGuidToClassMap()
{
    Clear();
}

///////////////////////////////////////////////////////////////////
//
//  Function:   CWbemGuidToClassMap::Clear
//  
//  Empties out the cache.
//
//  Inputs:
//              None.
//
//  Outputs:
//              None.
//
//  Returns:
//              None.
//
//  Comments:
//
///////////////////////////////////////////////////////////////////

void CWbemGuidToClassMap::Clear( void )
{
    CInCritSec ics( &m_cs );

    // Walk the map and release all objects we find.
    for (   WBEMGUIDTOCLASSMAPITER  iter = m_GuidToClassMap.begin();
            iter != m_GuidToClassMap.end();
            iter++ )
    {
        delete iter->second;
    }

    m_GuidToClassMap.erase( m_GuidToClassMap.begin(), m_GuidToClassMap.end() );
}


///////////////////////////////////////////////////////////////////
//
//  Function:   CWbemGuidToClassMap::GetMap
//  
//  Searches the map for the supplied guid name and returns the
//  corresponding map.
//
//  Inputs:
//              CGUD&       guid - GUID to find
//
//  Outputs:
//              CWbemClassToIdMap** ppMap - Storage for pointer
//
//  Returns:
//              WBEM_S_NO_ERROR of successful.
//
//  Comments:   None.
//
///////////////////////////////////////////////////////////////////

HRESULT CWbemGuidToClassMap::GetMap( CGUID& guid, CWbemClassToIdMap** ppMap )
{
    HRESULT hr = WBEM_S_NO_ERROR;

    if ( NULL != ppMap )
    {
        WBEMGUIDTOCLASSMAPITER  iter;
        CInCritSec ics( &m_cs );
        // Store the pointer if we can find our GUID
        if( ( iter = m_GuidToClassMap.find( guid ) ) != m_GuidToClassMap.end() )
        {
            *ppMap = iter->second;
        }
        else
        {
            hr = WBEM_E_FAILED;
        }
    }

    return hr;
}

///////////////////////////////////////////////////////////////////
//
//  Function:   CWbemGuidToClassMap::AddMap
//  
//  Adds the supplied guid to the map, assigning a new class to
//  ID map  to the GUID.
//
//  Inputs:
//              CGUID&      guid - Guid to add
//
//  Outputs:
//              CWbemClassToIdMap** ppMap - Map to assign to GUID.
//
//  Returns:
//              None.
//
//  Comments:   None.
//
///////////////////////////////////////////////////////////////////

HRESULT CWbemGuidToClassMap::AddMap( CGUID& guid, CWbemClassToIdMap** ppMap )
{
    HRESULT hr = WBEM_S_NO_ERROR;

    if ( NULL == ppMap ) return WBEM_E_INVALID_PARAMETER;

    WBEMGUIDTOCLASSMAPITER  iter;

    // Must be threadsafe
    CInCritSec autoCS( &m_cs );
    // If we are unable to locate our guid in the map, then we should
    // add a new entry.
    if( ( iter = m_GuidToClassMap.find( guid ) ) == m_GuidToClassMap.end() )
    {
        // Allocate and store a new map
        CWbemClassToIdMap*  pMap = new CWbemClassToIdMap;
        if ( NULL == pMap ) return WBEM_E_OUT_OF_MEMORY;

        try
        {
            m_GuidToClassMap[guid] = pMap;
            *ppMap = pMap;
        }
        catch( CX_Exception & )
        {
            hr = WBEM_E_OUT_OF_MEMORY;
        }
    }
    else
    {
        hr = WBEM_E_FAILED;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\marshalers\coreprox\wbemguid.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	WBEMGUID.H

Abstract:

	GUID wrapper class

History:

--*/

#ifndef __GUID_H__
#define __GUID_H__

//
//	Class:	CGUID
//
//	The intent of this class is to provide a packager for a GUID so we can
//	us the GUID in STL implementations of standard data structures such
//	as maps, vectors, lists, etc.
//
//

class CGUID
{
private:
	GUID	m_guid;

public:

	CGUID();
	CGUID( const GUID& guid );
	CGUID( const CGUID& guid );
	~CGUID();

	void SetGUID( const GUID& guid );
	void GetGUID( GUID& guid );
	CGUID& operator=( const CGUID& guid );
	bool operator<( const CGUID& guid ) const ;
	bool operator==( const CGUID& guid ) const ;


};

///////////////////////////////////////////////////////////////////
//
//	Function:	CGUID::CGUID
//	
//	Default Class Constructor
//
//	Inputs:
//				None.
//
//	Outputs:
//				None.
//
//	Returns:
//				None.
//
//	Comments:	None.
//
///////////////////////////////////////////////////////////////////

inline CGUID::CGUID()
{
}

///////////////////////////////////////////////////////////////////
//
//	Function:	CGUID::CGUID
//	
//	Class Constructor
//
//	Inputs:
//				const GUID&	guid - Initializes from a raw GUID
//
//	Outputs:
//				None.
//
//	Returns:
//				None.
//
//	Comments:	None.
//
///////////////////////////////////////////////////////////////////

inline CGUID::CGUID( const GUID& guid )
{
	m_guid = guid;
}

///////////////////////////////////////////////////////////////////
//
//	Function:	CGUID::CGUID
//	
//	Class Copy Constructor
//
//	Inputs:
//				const CGUID&	guid - instance to copy
//
//	Outputs:
//				None.
//
//	Returns:
//				None.
//
//	Comments:	None.
//
///////////////////////////////////////////////////////////////////

inline CGUID::CGUID( const CGUID& guid )
{
	m_guid = guid.m_guid;
}

///////////////////////////////////////////////////////////////////
//
//	Function:	CGUID::~CGUID
//	
//	Class Destructor
//
//	Inputs:
//				None.
//
//	Outputs:
//				None.
//
//	Returns:
//				None.
//
//	Comments:	None.
//
///////////////////////////////////////////////////////////////////

inline CGUID::~CGUID()
{
}

///////////////////////////////////////////////////////////////////
//
//	Function:	CGUID::SetGUID
//	
//	GUID Accessor.
//
//	Inputs:
//				const GUID&	guid - Guid to set to.
//
//	Outputs:
//				None.
//
//	Returns:
//				None.
//
//	Comments:	None.
//
///////////////////////////////////////////////////////////////////

inline void CGUID::SetGUID( const GUID& guid )
{
	m_guid = guid;
}

///////////////////////////////////////////////////////////////////
//
//	Function:	CGUID::GetGUID
//	
//	GUID Accessor.
//
//	Inputs:
//				GUID&	guid - Storage for GUID
//
//	Outputs:
//				None.
//
//	Returns:
//				None.
//
//	Comments:	None.
//
///////////////////////////////////////////////////////////////////

inline void CGUID::GetGUID( GUID& guid )
{
	m_guid = guid;
}

///////////////////////////////////////////////////////////////////
//
//	Function:	CGUID::operator=
//	
//	Equals Operator
//
//	Inputs:
//				const CGUID&	guid - instance to compare to
//
//	Outputs:
//				None.
//
//	Returns:
//				CGUID& this
//
//	Comments:	None.
//
///////////////////////////////////////////////////////////////////

inline CGUID& CGUID::operator=( const CGUID& guid )
{
	m_guid = guid.m_guid;
	return *this;
}

///////////////////////////////////////////////////////////////////
//
//	Function:	CGUID::operator<
//	
//	Less than operator
//
//	Inputs:
//				const CGUID&	guid - instance to compare to
//
//	Outputs:
//				None.
//
//	Returns:
//				bool	TRUE/FALSE
//
//	Comments:	None.
//
///////////////////////////////////////////////////////////////////

inline bool CGUID::operator<( const CGUID& guid ) const
{
	return ( memcmp( &m_guid, &guid.m_guid, sizeof(GUID) ) < 0 );
}

///////////////////////////////////////////////////////////////////
//
//	Function:	CGUID::operator==
//	
//	Comparison operator
//
//	Inputs:
//				const CGUID&	guid - instance to compare to
//
//	Outputs:
//				None.
//
//	Returns:
//				bool	TRUE/FALSE
//
//	Comments:	None.
//
///////////////////////////////////////////////////////////////////

inline bool CGUID::operator==( const CGUID& guid ) const
{
	return ( memcmp( &m_guid, &guid.m_guid, sizeof(GUID) ) == 0 );
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\marshalers\coreprox\wbemstr.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    WBEMSTR.CPP

Abstract:

    String helpers.

History:

--*/

#include "precomp.h"
#include "wbemstr.h"
#include <wbemutil.h>
#include <algorithm>

COREPROX_POLARITY void WbemStringFree(WBEM_WSTR String)
{
    CoTaskMemFree(String);
}

COREPROX_POLARITY WBEM_WSTR WbemStringCopy(const WCHAR* String)
{
    if(String == NULL) return NULL;
    size_t sourceLen = wcslen(String)+1;
    WBEM_WSTR NewString = (WBEM_WSTR)CoTaskMemAlloc( (sizeof WCHAR)* sourceLen);
    if(NewString == NULL) return NULL;
    StringCchCopyW(NewString, sourceLen, String);
    return NewString;
}

//******************************************************************************
//******************************************************************************
//                  INTERNAL STRING
//******************************************************************************
//******************************************************************************
CInternalString::CInternalString(LPCWSTR wsz)
{
    m_pcs = (CCompressedString*)new BYTE[
                    CCompressedString::ComputeNecessarySpace(wsz)];
    if (m_pcs)
        m_pcs->SetFromUnicode(wsz);
}

CInternalString::CInternalString(const CInternalString& Other) 
    : m_pcs(NULL)
{
    if (Other.m_pcs)
    {
        int nLen = Other.m_pcs->GetLength();
	 m_pcs = (CCompressedString*)new BYTE[nLen];
	 if(m_pcs == NULL)
	     throw CX_MemoryException();       
	 memcpy((void*)m_pcs, (void*)Other.m_pcs, nLen);
    }
}

CInternalString & CInternalString::operator=(const CInternalString& Other)
{    
    CInternalString temp(Other);
    std::swap(m_pcs,temp.m_pcs);
    return *this;
}

BOOL CInternalString::operator=(CCompressedString* pcs)
{
    delete [] (BYTE*)m_pcs;
    if(pcs)
    {
        int nLen = pcs->GetLength();
        m_pcs = (CCompressedString*)new BYTE[nLen];
        if(m_pcs == NULL)
            return FALSE;
        memcpy((void*)m_pcs, (void*)pcs, nLen);
    }
    else
    {
        m_pcs = NULL;
    }

    return TRUE;
}

BOOL CInternalString::operator=(LPCWSTR wsz)
{
    delete [] (BYTE*)m_pcs;
    m_pcs = (CCompressedString*)new BYTE[CCompressedString::ComputeNecessarySpace(wsz)];
    if(m_pcs == NULL)
        return FALSE;
    m_pcs->SetFromUnicode(wsz);
    return TRUE;
}

LPWSTR CInternalString::CreateLPWSTRCopy() const
{
    return m_pcs->CreateWStringCopy().UnbindPtr();
}


CInternalString::operator WString() const
{
    return m_pcs->CreateWStringCopy();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\marshalers\coreprox\wbemobjpacket.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    WBEMOBJPACKET.CPP

Abstract:

    Object packet classes.

History:

--*/

#include "precomp.h"
#include <stdio.h>
#include <stdlib.h>
#include <wbemcomn.h>
#include <fastall.h>
#include "wbemobjpacket.h"

// IWbemClassObject Base Packet Classes

///////////////////////////////////////////////////////////////////
//
//  Function:   CWbemObjectPacket::CWbemObjectPacket
//  
//  Class Constructor
//
//  Inputs:
//              LPBYTE                          pObjectPacket - Memory block.
//              DWORD                           dwPacketLength - Block Length.
//
//  Outputs:
//              None.
//
//  Returns:
//              None.
//
//  Comments:   Data must be supplied to this class for Unmarshaling
//              to succeed.
//
///////////////////////////////////////////////////////////////////

CWbemObjectPacket::CWbemObjectPacket( LPBYTE pObjectPacket, DWORD dwPacketLength )
:   m_pObjectPacket( (PWBEM_DATAPACKET_OBJECT_HEADER) pObjectPacket ),
    m_dwPacketLength( dwPacketLength )
{
}

///////////////////////////////////////////////////////////////////
//
//  Function:   CWbemObjectPacket::CWbemObjectPacket
//  
//  Class Copy Constructor
//
//  Inputs:
//              CWbemObjectPacket&      objectPacket - Object to copy.
//
//  Outputs:
//              None.
//
//  Returns:
//              None.
//
//  Comments:   Data must be supplied to this class for Unmarshaling
//              to succeed.
//
///////////////////////////////////////////////////////////////////

CWbemObjectPacket::CWbemObjectPacket( CWbemObjectPacket& objectPacket )
:   m_pObjectPacket( objectPacket.m_pObjectPacket ),
    m_dwPacketLength( objectPacket.m_dwPacketLength )
{
}

///////////////////////////////////////////////////////////////////
//
//  Function:   CWbemObjectPacket::~CWbemObjectPacket
//  
//  Class Destructor
//
//  Inputs:
//              None.
//
//  Outputs:
//              None.
//
//  Returns:
//              None.
//
//  Comments:   None.
//
///////////////////////////////////////////////////////////////////

CWbemObjectPacket::~CWbemObjectPacket()
{
}

///////////////////////////////////////////////////////////////////
//
//  Function:   CWbemObjectPacket::SetupObjectPacketHeader
//  
//  Helper function that writes appropriate data into an Object
//  Packet header.
//
//  Inputs:
//              DWORD       dwDataSize - Size of Data following header.
//              BYTE        bObjectType - Type of object following header.
//
//  Outputs:
//              None.
//
//  Returns:
//              WBEM_S_NO_ERROR if successful.
//
//  Comments:   None.
//
///////////////////////////////////////////////////////////////////

HRESULT CWbemObjectPacket::SetupObjectPacketHeader( DWORD dwDataSize, BYTE bObjectType )
{
    HRESULT hr = WBEM_E_FAILED;

    // Pointer and length must be valid
    if ( NULL != m_pObjectPacket )
    {

        if ( m_dwPacketLength >= ( sizeof(WBEM_DATAPACKET_OBJECT_HEADER) + dwDataSize ) )
        {
            // Clear out memory, then fill out the packet
            ZeroMemory( m_pObjectPacket, sizeof(WBEM_DATAPACKET_OBJECT_HEADER) );

            m_pObjectPacket->dwSizeOfHeader = sizeof(WBEM_DATAPACKET_OBJECT_HEADER);
            m_pObjectPacket->dwSizeOfData = dwDataSize;
            m_pObjectPacket->bObjectType = bObjectType;

            hr = WBEM_S_NO_ERROR;
        }
        else
        {
            hr = WBEM_E_BUFFER_TOO_SMALL;
        }
    }
    else
    {
        hr = WBEM_E_INVALID_PARAMETER;
    }

    return hr;

}

///////////////////////////////////////////////////////////////////
//
//  Function:   CWbemObjectPacket::CalculatePacketLength
//  
//  Determines number of bytes needed to marshal the packet into.
//
//  Inputs:
//              IWbemClassObject*   pObj - Object to calculate size for
//              BOOL                fFull - Write out full object (may be
//                                          false for Instances).
//
//  Outputs:
//              DWORD*              pdwLength - Number of bytes needed
//                                              to describe the object.
//
//  Returns:
//              WBEM_S_NO_ERROR if successful.
//
//  Comments:   None.
//
///////////////////////////////////////////////////////////////////

HRESULT CWbemObjectPacket::CalculatePacketLength( IWbemClassObject* pObj, DWORD* pdwLength, BOOL fFull /* = TRUE */ )
{
    HRESULT hr = WBEM_S_NO_ERROR;

    if (0 == pdwLength) return WBEM_E_INVALID_PARAMETER;

    // Pointer and length must be valid
    if ( NULL != pObj )
    {
        DWORD       dwObjectLength = 0;

        // Check for an _IWmiObject interface
		_IWmiObject*	pWmiObject = NULL;

		hr = pObj->QueryInterface( IID__IWmiObject, (void**) &pWmiObject );

		if ( SUCCEEDED( hr ) )
		{
			*pdwLength = sizeof(WBEM_DATAPACKET_OBJECT_HEADER);

			// It's an instance or a class
			if ( pWmiObject->IsObjectInstance() == WBEM_S_NO_ERROR )
			{
				*pdwLength += sizeof( WBEM_DATAPACKET_INSTANCE_HEADER );

				// Retrieve info differently based on whether or not we want
				// a full or lobotomized instance
				if ( !fFull )
				{
					hr = pWmiObject->GetObjectParts( NULL, 0, WBEM_OBJ_DECORATION_PART | WBEM_OBJ_INSTANCE_PART, &dwObjectLength );
				}
				else
				{
					// We want all parts, but be aware that the object could be decoupled
					// and part of a pass through

					hr = pWmiObject->GetObjectParts( NULL, 0, WBEM_INSTANCE_ALL_PARTS, &dwObjectLength );
				}
			}
			else
			{
				// We want the WHOLE class
				*pdwLength += sizeof( WBEM_DATAPACKET_CLASS_HEADER );
				hr = pWmiObject->GetObjectMemory( NULL, 0, &dwObjectLength );
			}

			pWmiObject->Release();

		}	// IF QI'd _IWmiObject

        // If we're okey-dokey, then factor in the object length (we expect
        // the buffer too small return here).
        if ( FAILED( hr ) && WBEM_E_BUFFER_TOO_SMALL == hr )
        {
            *pdwLength += dwObjectLength;
            hr = WBEM_S_NO_ERROR;
        }
    }
    else
    {
        // Length is just this header size
        *pdwLength = sizeof(WBEM_DATAPACKET_OBJECT_HEADER);
    }

    return hr;

}

///////////////////////////////////////////////////////////////////
//
//  Function:   CWbemObjectPacket::SetData
//  
//  Sets buffer to Marshal/Unmarshal to
//
//  Inputs:
//              LPBYTE                      pObjectPacket - Memory block.
//              DWORD                       dwPacketLength - Block Length.
//
//  Outputs:
//              None.
//
//  Returns:
//              None.
//
//  Comments:   Data must be supplied to this class to marshal/unmarshal
//              objects.
//
///////////////////////////////////////////////////////////////////

void CWbemObjectPacket::SetData( LPBYTE pObjectPacket, DWORD dwPacketLength )
{
    m_pObjectPacket = (PWBEM_DATAPACKET_OBJECT_HEADER) pObjectPacket;
    m_dwPacketLength = dwPacketLength;
}


///////////////////////////////////////////////////////////////////
//
//  Function:   CWbemClassPacket::CWbemClassPacket
//  
//  Class Constructor
//
//  Inputs:
//              LPBYTE                          pObjectPacket - Memory block.
//              DWORD                           dwPacketLength - Block Length.
//
//  Outputs:
//              None.
//
//  Returns:
//              None.
//
//  Comments:   Data must be supplied to this class for Unmarshaling
//              to succeed.
//
///////////////////////////////////////////////////////////////////

CWbemClassPacket::CWbemClassPacket( LPBYTE pObjectPacket, DWORD dwPacketLength )
:   CWbemObjectPacket( pObjectPacket, dwPacketLength ),
    m_pWbemClassData( NULL )
{
    // Point class data appropriately
    if ( NULL != pObjectPacket )
    {
        m_pWbemClassData = (PWBEM_DATAPACKET_CLASS_FULL) (pObjectPacket + ((PWBEM_DATAPACKET_OBJECT_HEADER) pObjectPacket)->dwSizeOfHeader);
    }
}

///////////////////////////////////////////////////////////////////
//
//  Function:   CWbemClassPacket::CWbemClassPacket
//  
//  Class Copy Constructor
//
//  Inputs:
//              CWbemObjectPacket&      objectPacket - Object to copy.
//
//  Outputs:
//              None.
//
//  Returns:
//              None.
//
//  Comments:   Data must be supplied to this class for Unmarshaling
//              to succeed.
//
///////////////////////////////////////////////////////////////////

CWbemClassPacket::CWbemClassPacket( CWbemObjectPacket& objectPacket )
:   CWbemObjectPacket( objectPacket ),
    m_pWbemClassData( NULL )
{
    // Point class data appropriately
    if ( NULL != m_pObjectPacket )
    {
        m_pWbemClassData = (PWBEM_DATAPACKET_CLASS_FULL) ( (LPBYTE) m_pObjectPacket + ((PWBEM_DATAPACKET_OBJECT_HEADER) m_pObjectPacket)->dwSizeOfHeader);
    }
}

///////////////////////////////////////////////////////////////////
//
//  Function:   CWbemClassPacket::~CWbemClassPacket
//  
//  Class Destructor
//
//  Inputs:
//              None.
//
//  Outputs:
//              None.
//
//  Returns:
//              None.
//
//  Comments:   None.
//
///////////////////////////////////////////////////////////////////

CWbemClassPacket::~CWbemClassPacket()
{
}

///////////////////////////////////////////////////////////////////
//
//  Function:   CWbemClassPacket::WriteToPacket
//  
//  Writes data out to the supplied buffer.
//
//  Inputs:
//              LPBYTE              pData - Buffer to write into.
//              DWORD               dwBufferLength - Size of buffer
//              IWbemClassObject*   pObj - Object to write out.
//
//  Outputs:
//              DWORD*              pdwLengthUsed - Num bytes used.
//
//  Returns:
//              WBEM_S_NO_ERROR if successful.
//
//  Comments:   None.
//
///////////////////////////////////////////////////////////////////

HRESULT CWbemClassPacket::WriteToPacket( IWbemClassObject* pObj, DWORD* pdwLengthUsed )
{
    if (0 == pdwLengthUsed) return WBEM_E_INVALID_PARAMETER;

    CWbemObject*    pWbemObject = (CWbemObject*) pObj;
    DWORD           dwObjectSize = 0;

    HRESULT hr = WBEM_E_FAILED;

    /// Discover how big the object is
    hr = pWbemObject->GetObjectMemory( NULL, 0, &dwObjectSize );

    // Expecting an error here, since we just wanted the BLOB length
    if ( FAILED( hr ) && WBEM_E_BUFFER_TOO_SMALL == hr )
    {
        hr = WBEM_S_NO_ERROR;

        // Calculate the size needed for our object and header
        DWORD   dwDataSize = sizeof(WBEM_DATAPACKET_CLASS_FULL) + dwObjectSize;

        // Now init the Object Header
        hr = SetupObjectPacketHeader( dwDataSize, WBEMOBJECT_CLASS_FULL );

        if ( SUCCEEDED( hr ) )
        {
            // Setup the Class object header (use our member variable)
            LPBYTE  pTempData = (LPBYTE) m_pWbemClassData;

            m_pWbemClassData->ClassHeader.dwSizeOfHeader = sizeof(WBEM_DATAPACKET_CLASS_HEADER);
            m_pWbemClassData->ClassHeader.dwSizeOfData = dwObjectSize;

            // Put in the actual object data
            pTempData += sizeof(WBEM_DATAPACKET_CLASS_HEADER);

            DWORD   dwSizeUsed = 0;

            hr = pWbemObject->GetObjectMemory( pTempData, dwObjectSize, &dwSizeUsed );

            if ( SUCCEEDED( hr ) )
            {
                *pdwLengthUsed = sizeof(WBEM_DATAPACKET_OBJECT_HEADER) + sizeof(WBEM_DATAPACKET_CLASS_FULL) + dwObjectSize;
            }

        }   // IF object header initialized

    }   // If got object length

    return hr;
}

///////////////////////////////////////////////////////////////////
//
//  Function:   CWbemClassPacket::GetWbemClassObject
//  
//  Retrieves a Wbem Class Object from a previously marshaled
//  packet.
//
//  Inputs:
//              None.
//
//  Outputs:
//              CWbemClass**    ppWbemClass - Class we read in.
//
//  Returns:
//              WBEM_S_NO_ERROR if successful.
//
//  Comments:   Caller is responsible for RELEASING the object.
//
///////////////////////////////////////////////////////////////////

HRESULT CWbemClassPacket::GetWbemClassObject( CWbemClass** ppWbemClass )
{
    if (0 == ppWbemClass) return WBEM_E_INVALID_PARAMETER;

    HRESULT hr = WBEM_E_OUT_OF_MEMORY;

    if ( NULL != m_pWbemClassData )
    {
        // Get a class object
        CWbemClass* pClass = new CWbemClass;

        if ( NULL != pClass )
        {
            CReleaseMe releaseClass((_IWmiObject*)pClass);

//           	CWbemClass::ValidateBuffer((LPMEMORY) m_pWbemClassData, m_pWbemClassData->ClassHeader.dwSizeOfData);
            
            LPBYTE pbData = CBasicBlobControl::sAllocate(m_pWbemClassData->ClassHeader.dwSizeOfData);
           
            if ( NULL != pbData )
            {
                // Copy the memory into the new buffer and initialize a Wbem Class with it.
                CopyMemory( pbData, ((LPBYTE) m_pWbemClassData) + m_pWbemClassData->ClassHeader.dwSizeOfHeader, m_pWbemClassData->ClassHeader.dwSizeOfData );

                // Initialize the Instance using the BLOB
                // By default the memory is owned
                pClass->SetData( pbData, m_pWbemClassData->ClassHeader.dwSizeOfData );

		   
                *ppWbemClass = pClass;
                pClass->AddRef();
                hr = WBEM_S_NO_ERROR;
            }
        }   // IF NULL != pClass

    }   // IF internal data available
    else
    {
        // We can't do this if we have no buffer
        hr = WBEM_E_INVALID_OPERATION;
    }

    return hr;
}

///////////////////////////////////////////////////////////////////
//
//  Function:   CWbemClassPacket::SetData
//  
//  Sets buffer to Marshal/Unmarshal to
//
//  Inputs:
//              LPBYTE                      pObjectPacket - Memory block.
//              DWORD                       dwPacketLength - Block Length.
//
//  Outputs:
//              None.
//
//  Returns:
//              None.
//
//  Comments:   Data must be supplied to this class for Marshal/Unmarshal
//              to work.
//
///////////////////////////////////////////////////////////////////

void CWbemClassPacket::SetData( LPBYTE pObjectPacket, DWORD dwPacketLength )
{
    // Go to our offset in the packet (assuming the packet is valid)
    if ( NULL != pObjectPacket )
    {
        m_pWbemClassData = (PWBEM_DATAPACKET_CLASS_FULL) ( pObjectPacket + sizeof(WBEM_DATAPACKET_OBJECT_HEADER) );
    }
    else
    {
        m_pWbemClassData = NULL;
    }

    // Initialize the base class
    CWbemObjectPacket::SetData( pObjectPacket, dwPacketLength );
}

///////////////////////////////////////////////////////////////////
//
//  Function:   CWbemInstancePacket::CWbemInstancePacket
//  
//  Class Constructor
//
//  Inputs:
//              LPBYTE                          pObjectPacket - Memory block.
//              DWORD                           dwPacketLength - Block Length.
//
//  Outputs:
//              None.
//
//  Returns:
//              None.
//
//  Comments:   Data must be supplied to this class for Unmarshaling
//              to succeed.
//
///////////////////////////////////////////////////////////////////

CWbemInstancePacket::CWbemInstancePacket( LPBYTE pObjectPacket, DWORD dwPacketLength )
:   CWbemObjectPacket( pObjectPacket, dwPacketLength ),
    m_pWbemInstanceData( NULL )
{
    // Point Instance data appropriately
    if ( NULL != pObjectPacket )
    {
        m_pWbemInstanceData = (PWBEM_DATAPACKET_INSTANCE_HEADER) ( pObjectPacket + ((PWBEM_DATAPACKET_OBJECT_HEADER) pObjectPacket)->dwSizeOfHeader );
    }
}

///////////////////////////////////////////////////////////////////
//
//  Function:   CWbemInstancePacket::CWbemInstancePacket
//  
//  Class Copy Constructor
//
//  Inputs:
//              CWbemObjectPacket&      objectPacket - Object to copy.
//
//  Outputs:
//              None.
//
//  Returns:
//              None.
//
//  Comments:   Data must be supplied to this class for Unmarshaling
//              to succeed.
//
///////////////////////////////////////////////////////////////////

CWbemInstancePacket::CWbemInstancePacket( CWbemObjectPacket& objectPacket )
:   CWbemObjectPacket( objectPacket ),
    m_pWbemInstanceData( NULL )
{
    // Point Instance data appropriately
    if ( NULL != m_pObjectPacket )
    {
        m_pWbemInstanceData = (PWBEM_DATAPACKET_INSTANCE_HEADER) ( (LPBYTE) m_pObjectPacket + ((PWBEM_DATAPACKET_OBJECT_HEADER) m_pObjectPacket)->dwSizeOfHeader);
    }
}

///////////////////////////////////////////////////////////////////
//
//  Function:   CWbemInstancePacket::~CWbemInstancePacket
//  
//  Class Destructor
//
//  Inputs:
//              None.
//
//  Outputs:
//              None.
//
//  Returns:
//              None.
//
//  Comments:   None.
//
///////////////////////////////////////////////////////////////////

CWbemInstancePacket::~CWbemInstancePacket()
{
}

///////////////////////////////////////////////////////////////////
//
//  Function:   CWbemInstancePacket::GetInstanceType
//  
//  Returns instance type data for the packet.
//
//  Inputs:
//              None.
//
//  Outputs:
//              None.
//
//  Returns:
//              WBEMOBJECT_INSTANCE_FULL
//
//  Comments:   Override to return a different type.
//
///////////////////////////////////////////////////////////////////

BYTE CWbemInstancePacket::GetInstanceType( void )
{
    return WBEMOBJECT_INSTANCE_FULL;
}

///////////////////////////////////////////////////////////////////
//
//  Function:   CWbemInstancePacket::GetObjectMemory
//  
//  Copies internal object memory into the supplied buffer.
//
//  Inputs:
//              CWbemObject*    pObj - Object whose memory to retrieve.
//              LPBYTE          pbData - Buffer to place data in.
//              DWORD           dwDataSize - Size of buffer.
//
//  Outputs:
//              DWORD*          pdwDataUsed - Amount of data used.
//
//  Returns:
//              WBEM_S_NO_ERROR if successful.
//
//  Comments:   Override to retrieve data in other fashions.
//
///////////////////////////////////////////////////////////////////

HRESULT CWbemInstancePacket::GetObjectMemory( CWbemObject* pObj, LPBYTE pbData, DWORD dwDataSize, DWORD* pdwDataUsed )
{
    // We want all parts, but be aware that the object could be decoupled
    // and part of a pass through

    return pObj->GetObjectParts( pbData, dwDataSize, WBEM_INSTANCE_ALL_PARTS, pdwDataUsed );

}

///////////////////////////////////////////////////////////////////
//
//  Function:   CWbemInstancePacket::SetObjectMemory
//  
//  Sets internal object memory in the supplied instance to point
//  to the supplied buffer.
//
//  Inputs:
//              CWbemInstance*  pInstance - Instance to set memory in.
//              LPBYTE          pbData - Buffer to Set Memory from.
//              DWORD           dwDataSize - Size of buffer.
//
//  Outputs:
//              None.
//
//  Returns:
//              WBEM_S_NO_ERROR if successful.
//
//  Comments:   Override to set data in other ways.  Note that the
//              instance object will delete the buffer when it is
//              freed up.
//
///////////////////////////////////////////////////////////////////

void CWbemInstancePacket::SetObjectMemory( CWbemInstance* pInstance, LPBYTE pbData, DWORD dwDataSize )
{
//  	CWbemClass::ValidateBuffer((LPBYTE) pbData,dwDataSize );
    pInstance->SetData( pbData, dwDataSize );
}

///////////////////////////////////////////////////////////////////
//
//  Function:   CWbemInstancePacket::WriteToPacket
//  
//  Determines number of bytes needed to marshal the packet into.
//
//  Inputs:
//              IWbemClassObject*   pObj - Object to write out.
//
//  Outputs:
//              DWORD*              pdwLengthUsed - Num bytes used.
//
//  Returns:
//              WBEM_S_NO_ERROR if successful.
//
//  Comments:   None.
//
///////////////////////////////////////////////////////////////////

HRESULT CWbemInstancePacket::WriteToPacket( IWbemClassObject* pObj, GUID& guidClassId, DWORD* pdwLengthUsed )
{
    if (0 == pdwLengthUsed) return WBEM_E_INVALID_PARAMETER;

    CWbemObject*    pWbemObject = (CWbemObject*) pObj;
    DWORD           dwObjectSize = 0;

    HRESULT hr = WBEM_E_FAILED;

    /// Discover how big the object is
    hr = GetObjectMemory( pWbemObject, NULL, 0, &dwObjectSize );

    // Expecting an error here, since we just wanted the BLOB length
    if ( FAILED( hr ) && WBEM_E_BUFFER_TOO_SMALL == hr )
    {
        hr = WBEM_S_NO_ERROR;

        // Calculate the size needed for our object and header
        DWORD   dwDataSize = sizeof(WBEM_DATAPACKET_INSTANCE_HEADER) + dwObjectSize;

        // Now init the Object Header
        hr = SetupObjectPacketHeader( dwDataSize, GetInstanceType() );

        if ( SUCCEEDED( hr ) )
        {
            // Initialize from our member data
            LPBYTE  pTempData = (LPBYTE) m_pWbemInstanceData;

            m_pWbemInstanceData->dwSizeOfHeader = sizeof(WBEM_DATAPACKET_INSTANCE_HEADER);
            m_pWbemInstanceData->dwSizeOfData = dwObjectSize;
            m_pWbemInstanceData->guidClassId = guidClassId;

            // Put in the actual object data
            pTempData += sizeof(WBEM_DATAPACKET_INSTANCE_HEADER);

            DWORD   dwSizeUsed = 0;

            hr = GetObjectMemory( pWbemObject, pTempData, dwObjectSize, &dwSizeUsed );

            if ( SUCCEEDED( hr ) )
            {
                *pdwLengthUsed = sizeof(WBEM_DATAPACKET_OBJECT_HEADER) + sizeof(WBEM_DATAPACKET_INSTANCE_HEADER) + dwObjectSize;
            }

        }   // IF object header initialized

    }   // If got object length

    return hr;
}

///////////////////////////////////////////////////////////////////
//
//  Function:   CWbemClassPacket::GetWbemInstanceObject
//  
//  Retrieves a Wbem Instance Object from a previously marshaled
//  packet.
//
//  Inputs:
//              None.
//
//  Outputs:
//              CWbemInstance** ppWbemInstance - Instance we read in.
//              GUID&           guidClassId - Class Id for instance
//                                          caching.
//
//  Returns:
//              WBEM_S_NO_ERROR if successful.
//
//  Comments:   Caller is responsible for RELEASING the object.  The
//              class id can be used to cache the instance, or if
//              it is classless, hook up the instance with a previously
//              cached instance.
//
///////////////////////////////////////////////////////////////////

HRESULT CWbemInstancePacket::GetWbemInstanceObject( CWbemInstance** ppWbemInstance, GUID& guidClassId )
{
    if (0 == ppWbemInstance) return WBEM_E_INVALID_PARAMETER;

    HRESULT hr = WBEM_E_OUT_OF_MEMORY;

    if ( NULL != m_pWbemInstanceData )
    {
        // Get a Instance object
        CWbemInstance*  pInstance = new CWbemInstance;

        if ( NULL != pInstance )
        {
             CReleaseMe releaseInstance((_IWmiObject*)pInstance);
             
             LPBYTE pbData = CBasicBlobControl::sAllocate(m_pWbemInstanceData->dwSizeOfData);
            
            if ( NULL != pbData )
            {
                // Copy the memory into the new buffer and initialize a Wbem Instance with it.
                CopyMemory( pbData, ((LPBYTE) m_pWbemInstanceData) + m_pWbemInstanceData->dwSizeOfHeader, m_pWbemInstanceData->dwSizeOfData );

                // Initialize the Instance using the BLOB
                // and own it
                SetObjectMemory( pInstance, pbData, m_pWbemInstanceData->dwSizeOfData );

                // Object is already AddRef'd so we be done
                guidClassId = m_pWbemInstanceData->guidClassId;
                *ppWbemInstance = pInstance;
                pInstance->AddRef();
                hr = WBEM_S_NO_ERROR;
            }
        }   // IF NULL != pInstance

    }   // IF internal data available
    else
    {
        // We can't do this if we have no buffer
        hr = WBEM_E_INVALID_OPERATION;
    }

    return hr;
}

///////////////////////////////////////////////////////////////////
//
//  Function:   CWbemInstancePacket::SetData
//  
//  Sets buffer to Marshal/Unmarshal to
//
//  Inputs:
//              LPBYTE                      pObjectPacket - Memory block.
//              DWORD                       dwPacketLength - Block Length.
//
//  Outputs:
//              None.
//
//  Returns:
//              None.
//
//  Comments:   Data must be supplied to this class for Marshal/Unmarshal
//              to work.
//
///////////////////////////////////////////////////////////////////

void CWbemInstancePacket::SetData( LPBYTE pObjectPacket, DWORD dwPacketLength )
{
    // Go to our offset in the packet (assuming the packet is valid)
    if ( NULL != pObjectPacket )
    {
        m_pWbemInstanceData = (PWBEM_DATAPACKET_INSTANCE_HEADER) ( pObjectPacket + sizeof(WBEM_DATAPACKET_OBJECT_HEADER) );
    }
    else
    {
        m_pWbemInstanceData = NULL;
    }

    // Initialize the base class
    CWbemObjectPacket::SetData( pObjectPacket, dwPacketLength );
}

///////////////////////////////////////////////////////////////////
//
//  Function:   CWbemClasslessInstancePacket::CWbemClasslessInstancePacket
//  
//  Class Constructor
//
//  Inputs:
//              LPBYTE                          pObjectPacket - Memory block.
//              DWORD                           dwPacketLength - Block Length.
//
//  Outputs:
//              None.
//
//  Returns:
//              None.
//
//  Comments:   Data must be supplied to this class for Unmarshaling
//              to succeed.
//
///////////////////////////////////////////////////////////////////

CWbemClasslessInstancePacket::CWbemClasslessInstancePacket( LPBYTE pObjectPacket, DWORD dwPacketLength )
:   CWbemInstancePacket( pObjectPacket, dwPacketLength )
{
}

///////////////////////////////////////////////////////////////////
//
//  Function:   CWbemClasslessInstancePacket::CWbemClasslessInstancePacket
//  
//  Class Copy Constructor
//
//  Inputs:
//              CWbemObjectPacket&      objectPacket - Object to copy.
//
//  Outputs:
//              None.
//
//  Returns:
//              None.
//
//  Comments:   Data must be supplied to this class for Unmarshaling
//              to succeed.
//
///////////////////////////////////////////////////////////////////

CWbemClasslessInstancePacket::CWbemClasslessInstancePacket( CWbemObjectPacket& objectPacket )
:   CWbemInstancePacket( objectPacket )
{
}

///////////////////////////////////////////////////////////////////
//
//  Function:   CWbemClasslessInstancePacket::~CWbemClasslessInstancePacket
//  
//  Class Destructor
//
//  Inputs:
//              None.
//
//  Outputs:
//              None.
//
//  Returns:
//              None.
//
//  Comments:   None.
//
///////////////////////////////////////////////////////////////////

CWbemClasslessInstancePacket::~CWbemClasslessInstancePacket()
{
}

///////////////////////////////////////////////////////////////////
//
//  Function:   CWbemInstancePacket::GetInstanceType
//  
//  Returns instance type data for the packet.
//
//  Inputs:
//              None.
//
//  Outputs:
//              None.
//
//  Returns:
//              WBEMOBJECT_INSTANCE_FULL
//
//  Comments:   Override to return a different type.
//
///////////////////////////////////////////////////////////////////

BYTE CWbemClasslessInstancePacket::GetInstanceType( void )
{
    return WBEMOBJECT_INSTANCE_NOCLASS;
}

///////////////////////////////////////////////////////////////////
//
//  Function:   CWbemInstancePacket::GetObjectMemory
//  
//  Copies internal object memory into the supplied buffer.
//
//  Inputs:
//              CWbemObject*    pObj - Object whose memory to retrieve.
//              LPBYTE          pbData - Buffer to place data in.
//              DWORD           dwDataSize - Size of buffer.
//
//  Outputs:
//              DWORD*          pdwDataUsed - Amount of data used.
//
//  Returns:
//              WBEM_S_NO_ERROR if successful.
//
//  Comments:   Override to retrieve data in other fashions.
//
///////////////////////////////////////////////////////////////////

HRESULT CWbemClasslessInstancePacket::GetObjectMemory( CWbemObject* pObj, LPBYTE pbData, DWORD dwDataSize, DWORD* pdwDataUsed )
{
    return pObj->GetObjectParts( pbData, dwDataSize, WBEM_OBJ_DECORATION_PART | WBEM_OBJ_INSTANCE_PART, pdwDataUsed );
}

///////////////////////////////////////////////////////////////////
//
//  Function:   CWbemInstancePacket::SetObjectMemory
//  
//  Sets internal object memory in the supplied instance to point
//  to the supplied buffer.
//
//  Inputs:
//              CWbemInstance*  pInstance - Instance to set memory in.
//              LPBYTE          pbData - Buffer to Set Memory from.
//              DWORD           dwDataSize - Size of buffer.
//
//  Outputs:
//              None.
//
//  Returns:
//              WBEM_S_NO_ERROR if successful.
//
//  Comments:   Override to set data in other ways.  Note that the
//              instance object will delete the buffer when it is
//              freed up.
//
///////////////////////////////////////////////////////////////////

void CWbemClasslessInstancePacket::SetObjectMemory( CWbemInstance* pInstance, LPBYTE pbData, DWORD dwDataSize )
{
	//CWbemInstance::ValidateBuffer(pbData, dwDataSize, WBEM_OBJ_DECORATION_PART | WBEM_OBJ_INSTANCE_PART);
    pInstance->SetData( pbData, dwDataSize, WBEM_OBJ_DECORATION_PART | WBEM_OBJ_INSTANCE_PART );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\marshalers\coreprox\wbemobjpacket.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	WBEMOBJPACKET.H

Abstract:

	Object packet classes.

History:

--*/

#ifndef __WBEMOBJPACKET_H__
#define __WBEMOBJPACKET_H__

// Store the current packing value, then set our own value
#pragma pack( push )
#pragma pack( 1 )

// Define any IWbemClassObject Packet Types
typedef enum
{
	WBEMOBJECT_FIRST			= 0,	
	WBEMOBJECT_NONE				= 0,	
	WBEMOBJECT_CLASS_FULL		= 1,
	WBEMOBJECT_INSTANCE_FULL	= 2,
	WBEMOBJECT_INSTANCE_NOCLASS	= 3,
	WBEMOBJECT_LAST
} WBEMOBJECT_PACKETTYPE;

// Add Data at the bottom of this structure to ensure backwards compatibility.
// If this or any of the subsequent structures changes, bump up version
// information above

typedef struct tagWBEM_DATAPACKET_OBJECT_HEADER
{
	DWORD	dwSizeOfHeader;	// Size Of Header
	DWORD	dwSizeOfData;	// Size Of Data following Header
	BYTE	bObjectType;	// Value from WBEMOBJECT_PACKETTYPE
} WBEM_DATAPACKET_OBJECT_HEADER;

typedef WBEM_DATAPACKET_OBJECT_HEADER* PWBEM_DATAPACKET_OBJECT_HEADER;

// Add Data at the bottom of this structure to ensure backwards compatibility.
// If this or any of the subsequent structures changes, bump up version
// information above

typedef struct tagWBEM_DATAPACKET_CLASS_HEADER
{
	DWORD	dwSizeOfHeader;	// Size Of Header
	DWORD	dwSizeOfData;	// Size Of Data following Header
} WBEM_DATAPACKET_CLASS_HEADER;

typedef WBEM_DATAPACKET_CLASS_HEADER* PWBEM_DATAPACKET_CLASS_HEADER;

typedef struct tagWBEM_DATAPACKET_CLASS_FULL
{
	WBEM_DATAPACKET_CLASS_HEADER	ClassHeader;		// Header information	
} WBEM_DATAPACKET_CLASS_FULL;

typedef WBEM_DATAPACKET_CLASS_FULL* PWBEM_DATAPACKET_CLASS_FULL;

// Add Data at the bottom of this structure to ensure backwards compatibility.
// If this or any of the subsequent structures changes, bump up version
// information above

typedef struct tagWBEM_DATAPACKET_INSTANCE_HEADER
{
	DWORD	dwSizeOfHeader;	// Size Of Header
	DWORD	dwSizeOfData;	// Size Of Data following Header
	GUID	guidClassId;	// Class Id for caching
} WBEM_DATAPACKET_INSTANCE_HEADER;

typedef WBEM_DATAPACKET_INSTANCE_HEADER* PWBEM_DATAPACKET_INSTANCE_HEADER;

// Following the header in the following structures, will be the actual data in
// byte format.

typedef struct tagWBEM_DATAPACKET_INSTANCE_FULL
{
	WBEM_DATAPACKET_INSTANCE_HEADER	InstanceHeader;		// Header information	
} WBEM_DATAPACKET_INSTANCE_FULL;

typedef WBEM_DATAPACKET_INSTANCE_FULL*	PWBEM_DATAPACKET_INSTANCE_FULL;

typedef struct tagWBEM_DATAPACKET_INSTANCE_NOCLASS
{
	WBEM_DATAPACKET_INSTANCE_HEADER	InstanceHeader;		// Header information	
} WBEM_DATAPACKET_INSTANCE_NOCLASS;

typedef WBEM_DATAPACKET_INSTANCE_NOCLASS*	PWBEM_DATAPACKET_INSTANCE_NOCLASS;

// restore packing
#pragma pack( pop )

// Accessor class for making packets from objects and turning packets
// into objects.

// Forward Class References
class CWbemInstance;

//
//	Class: CWbemObjectPacket
//
//	This class is designed to wrapper a data packet that describes an
//	IWbemClassObject pointer.  As these objects are actually divided into
//	classes and instances, this class is designed to be a base class for
//	the classes that actually perform the packetizing/unpacketizing of the
//	data.
//

class CWbemObjectPacket
{
private:
protected:

	PWBEM_DATAPACKET_OBJECT_HEADER	m_pObjectPacket;
	DWORD							m_dwPacketLength;

	// Packet Building Functions
	HRESULT SetupObjectPacketHeader( DWORD dwDataSize, BYTE bPacketType );

public:

	CWbemObjectPacket( LPBYTE pObjPacket = NULL, DWORD dwPacketLength = 0 );
	CWbemObjectPacket( CWbemObjectPacket& objectPacket );
	~CWbemObjectPacket();

	HRESULT	CalculatePacketLength( IWbemClassObject* pObj, DWORD* pdwLength, BOOL fFull = TRUE  );

	BYTE	GetObjectType( void );
	DWORD	GetDataSize( void );
	bool IsValid() { return (m_dwPacketLength  > sizeof(WBEM_DATAPACKET_OBJECT_HEADER) &&
						m_pObjectPacket != 0 &&
						m_pObjectPacket->dwSizeOfData + sizeof(WBEM_DATAPACKET_OBJECT_HEADER) <=  m_dwPacketLength);}

	HRESULT WriteEmptyHeader( void );

	// Change the underlying pointers
	virtual void SetData( LPBYTE pObjectPacket, DWORD dwPacketLength );
};

inline BYTE CWbemObjectPacket::GetObjectType( void )
{
	return ( NULL == m_pObjectPacket ? WBEMOBJECT_FIRST : m_pObjectPacket->bObjectType );
}

inline DWORD CWbemObjectPacket::GetDataSize( void )
{
	return ( NULL == m_pObjectPacket ? 0 : m_pObjectPacket->dwSizeOfData );
}

inline HRESULT CWbemObjectPacket::WriteEmptyHeader( void )
{
	return SetupObjectPacketHeader( 0, WBEMOBJECT_NONE );
}

//
//	Class: CWbemClassPacket
//
//	This class is designed to wrapper a data packet that describes an
//	IWbemClassObject that is a class.  It is responsible for reading and
//	writing these objects to and from memory.
//

class CWbemClassPacket : public CWbemObjectPacket
{
private:
protected:

	PWBEM_DATAPACKET_CLASS_FULL	m_pWbemClassData;

public:

	CWbemClassPacket( LPBYTE pObjPacket = NULL, DWORD dwPacketLength = 0 );
	CWbemClassPacket( CWbemObjectPacket& objectPacket );
	~CWbemClassPacket();

	bool IsValid() { return CWbemObjectPacket::IsValid() && 
						  CWbemObjectPacket::GetDataSize()  >=sizeof(WBEM_DATAPACKET_CLASS_FULL) &&
						  CWbemObjectPacket::GetDataSize() == sizeof(WBEM_DATAPACKET_CLASS_FULL)+ m_pWbemClassData->ClassHeader.dwSizeOfData; };

	HRESULT GetWbemClassObject( CWbemClass** pWbemClass );
	HRESULT WriteToPacket( IWbemClassObject* pObj, DWORD* pdwLengthUsed );

	// Helper function
	HRESULT WriteToPacket( LPBYTE pData, DWORD dwBufferLength, IWbemClassObject* pObj, DWORD* pdwLengthUsed );
	DWORD	GetClassSize( void );

	// Change the underlying pointers
	void SetData( LPBYTE pObjectPacket, DWORD dwPacketLength );
};

inline DWORD CWbemClassPacket::GetClassSize( void )
{
	return ( NULL == m_pWbemClassData ? 0 : m_pWbemClassData->ClassHeader.dwSizeOfData );
}

inline HRESULT CWbemClassPacket::WriteToPacket( LPBYTE pData, DWORD dwBufferLength, IWbemClassObject* pObj, DWORD* pdwLengthUsed )
{
	SetData( pData, dwBufferLength );
	return WriteToPacket( pObj, pdwLengthUsed );
}

//
//	Class: CWbemInstancePacket
//
//	This class is designed to wrapper a data packet that describes an
//	IWbemClassObject that is an instance.  It is responsible for reading
//	and writing these objects to and from memory.  Please note that
//	it acts as a base class for Classless Instance objects.
//

class CWbemInstancePacket : public CWbemObjectPacket
{
private:
protected:

	PWBEM_DATAPACKET_INSTANCE_HEADER	m_pWbemInstanceData;

	virtual BYTE GetInstanceType( void );
	virtual HRESULT GetObjectMemory( CWbemObject* pObj, LPBYTE pbData, DWORD dwDataSize, DWORD* pdwDataUsed );
	virtual void SetObjectMemory( CWbemInstance* pInstance, LPBYTE pbData, DWORD dwDataSize );

public:

	CWbemInstancePacket( LPBYTE pObjPacket = NULL, DWORD dwPacketLength = 0 );
	CWbemInstancePacket( CWbemObjectPacket& objectPacket );
	~CWbemInstancePacket();

	bool IsValid() { return CWbemObjectPacket::IsValid() && 
						  CWbemObjectPacket::GetDataSize()  >=sizeof(WBEM_DATAPACKET_INSTANCE_HEADER) &&
						  CWbemObjectPacket::GetDataSize() == sizeof(WBEM_DATAPACKET_INSTANCE_HEADER)+ m_pWbemInstanceData->dwSizeOfData; };

	HRESULT GetWbemInstanceObject( CWbemInstance** pWbemInstance, GUID& guidClassId );
	HRESULT WriteToPacket( IWbemClassObject* pObj, GUID& guidClassId, DWORD* pdwLengthUsed );

	// Helper function
	HRESULT WriteToPacket( LPBYTE pData, DWORD dwBufferLength, IWbemClassObject* pObj, GUID& guidClassId, DWORD* pdwLengthUsed );
	DWORD	GetInstanceSize( void );

	// Change the underlying pointers
	void SetData( LPBYTE pObjectPacket, DWORD dwPacketLength );
};

inline DWORD CWbemInstancePacket::GetInstanceSize( void )
{
	return ( NULL == m_pWbemInstanceData ? 0 : m_pWbemInstanceData->dwSizeOfData );
}

inline HRESULT CWbemInstancePacket::WriteToPacket( LPBYTE pData, DWORD dwBufferLength, IWbemClassObject* pObj, GUID& guidClassId, DWORD* pdwLengthUsed )
{
	SetData( pData, dwBufferLength );
	return WriteToPacket( pObj, guidClassId, pdwLengthUsed );
}

//
//	Class: CWbemClasslessInstancePacket
//
//	This class is designed to wrapper a data packet that describes an
//	IWbemClassObject that is a classless instance.  These are instances
//	that we have decided should NOT contain class information when written
//	out, and read back in.  Once read back in, however, these objects
//	will need to have class data passed in, or merged in, before they will
//	work properly.
//

class  CWbemClasslessInstancePacket : public CWbemInstancePacket
{
private:
protected:

	virtual BYTE GetInstanceType( void );
	virtual HRESULT GetObjectMemory( CWbemObject* pObj, LPBYTE pbData, DWORD dwDataSize, DWORD* pdwDataUsed );
	virtual void SetObjectMemory( CWbemInstance* pInstance, LPBYTE pbData, DWORD dwDataSize );

public:

	CWbemClasslessInstancePacket( LPBYTE pObjPacket = NULL, DWORD dwPacketLength = 0 );
	CWbemClasslessInstancePacket( CWbemObjectPacket& objectPacket );
	~CWbemClasslessInstancePacket();
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\marshalers\coreprox\wmiarray.cpp ===
/*++

Copyright (C) 2000-2001 Microsoft Corporation

Module Name:

    WMIARRAY.CPP

Abstract:

  CWmiArray implementation.

  Implements a standard interface for accessing arrays.

History:

  20-Feb-2000	sanjes    Created.

--*/

#include "precomp.h"
#include <stdio.h>
#include "fastall.h"
#include "wmiarray.h"
#include <corex.h>
#include "strutils.h"
#include <wbemutil.h>

//***************************************************************************
//
//  CWmiArray::~CWmiArray
//
//***************************************************************************
// ok
CWmiArray::CWmiArray()
:	m_ct(0),
	m_pObj(NULL),
	m_lHandle(0),
	m_lRefCount(0),
	m_fIsQualifier( FALSE ),
	m_fHasPrimaryName( FALSE ),
	m_wsPrimaryName(),
	m_wsQualifierName(),
	m_fIsMethodQualifier( FALSE )
{
    ObjectCreated(OBJECT_TYPE_WMIARRAY,this);
}
    
//***************************************************************************
//
//  CWmiArray::~CWmiArray
//
//***************************************************************************
// ok
CWmiArray::~CWmiArray()
{
	if ( NULL != m_pObj )
	{
		m_pObj->Release();
	}

    ObjectDestroyed(OBJECT_TYPE_WMIARRAY,this);
}

// Initializes the object to point at an _IWmiObject for an array property.
HRESULT CWmiArray::InitializePropertyArray( _IWmiObject* pObj, LPCWSTR pwszPropertyName )
{
	HRESULT			hr = WBEM_S_NO_ERROR;

	// Release a prexisting object
	if ( NULL != m_pObj )
	{
		m_pObj->Release();
		m_pObj = 0;
	}


	if ( SUCCEEDED( hr ) )
	{
		hr =( (CWbemObject*) pObj)->GetPropertyHandleEx( pwszPropertyName, 0L, &m_ct, &m_lHandle );

		try
		{
			m_wsPrimaryName = pwszPropertyName;
			
			m_fIsQualifier = FALSE;
			m_fHasPrimaryName = FALSE;
			m_pObj = (CWbemObject*) pObj;
			m_pObj->AddRef();
			
		}
		catch(CX_MemoryException)
		{
			hr = WBEM_E_OUT_OF_MEMORY;
		}
		catch(...)
		{
			hr = WBEM_E_FAILED;
		}
	}

	return hr;
}

// Initializes the object to point at an _IWmiObject for an array qualifier (property or object).
HRESULT CWmiArray::InitializeQualifierArray( _IWmiObject* pObj, LPCWSTR pwszPrimaryName, 
											LPCWSTR pwszQualifierName, CIMTYPE ct, BOOL fIsMethodQualifier )
{
	HRESULT			hr = WBEM_S_NO_ERROR;

	// Release a prexisting object
	if ( NULL != m_pObj )
	{
		m_pObj->Release();
		m_pObj = 0;
	}

	// Now AddRef the object and get its property handle
	if ( SUCCEEDED( hr ) )
	{
		try
		{
			if ( NULL != pwszPrimaryName )
			{
				m_wsPrimaryName = pwszPrimaryName;
				m_fIsMethodQualifier = fIsMethodQualifier;
				m_fHasPrimaryName = TRUE;
			}
			
			m_wsQualifierName = pwszQualifierName;
			m_fIsQualifier = TRUE;
			m_ct = ct;

			m_pObj = (CWbemObject*) pObj;
			m_pObj->AddRef();
		}
		catch(CX_MemoryException)
		{
			hr = WBEM_E_OUT_OF_MEMORY;
		}
		catch(...)
		{
			hr = WBEM_E_FAILED;
		}
	}

	return hr;
}

/*	IUnknown Methods */

STDMETHODIMP CWmiArray::QueryInterface(REFIID riid, LPVOID FAR* ppvObj)
{
	if ( riid == IID_IUnknown )
	{
		*ppvObj = (LPVOID**) this;
	}
	else if ( riid == IID__IWmiArray )
	{
		*ppvObj = (LPVOID**) this;
	}
	else
	{
		return E_NOINTERFACE;
	}

    ((IUnknown*)*ppvObj)->AddRef();
    return S_OK;
}

ULONG CWmiArray::AddRef()
{
    return InterlockedIncrement((long*)&m_lRefCount);
}

ULONG CWmiArray::Release()
{
    long lRef = InterlockedDecrement((long*)&m_lRefCount);
    _ASSERT(lRef >= 0, __TEXT("Reference count on _IWmiArray went below 0!"))

    if(lRef == 0)
        delete this;
    return lRef;
}

/* _IWmiArray methods */

//	Initializes the array.  Number of initial elements as well
//	as the type (determines the size of each element)
STDMETHODIMP CWmiArray::Initialize( long lFlags, CIMTYPE cimtype, ULONG uNumElements )
{
	// Check flags
	if ( lFlags != 0L )
	{
		return WBEM_E_INVALID_PARAMETER;
	}

	// We don't let people do anything here
	return WBEM_E_INVALID_OPERATION;
}

//	Returns CIMTYPE and Number of elements.
STDMETHODIMP CWmiArray::GetInfo( long lFlags, CIMTYPE* pcimtype, ULONG* puNumElements )
{

	// Check flags
	if ( lFlags != 0L )
	{
		return WBEM_E_INVALID_PARAMETER;
	}

	// Lock using the current object
	CWbemObject::CLock	lock( m_pObj );

	HRESULT	hr = WBEM_S_NO_ERROR;

	if ( IsQualifier() )
	{
		LPCWSTR	pwcsPrimaryName = (LPCWSTR) ( HasPrimaryName() ? (LPCWSTR) m_wsPrimaryName : NULL );

		// Get qualifier array info
		hr = m_pObj->GetQualifierArrayInfo( pwcsPrimaryName, m_wsQualifierName, m_fIsMethodQualifier,
										0L, pcimtype, puNumElements );
	}
	else
	{
		// Get array property info
		hr =  m_pObj->GetArrayPropInfoByHandle( m_lHandle, 0L, NULL, pcimtype, puNumElements );
	}

	return hr;
}

//	Clears out the array
STDMETHODIMP CWmiArray::Empty( long lFlags )
{
	// Check flags
	if ( lFlags != 0L )
	{
		return WBEM_E_INVALID_PARAMETER;
	}

	// Lock using the current object
	CWbemObject::CLock	lock( m_pObj );

	HRESULT	hr = WBEM_S_NO_ERROR;

	// Just remove the range of all elements starting at 0
	if ( IsQualifier() )
	{
		LPCWSTR	pwcsPrimaryName = (LPCWSTR) ( HasPrimaryName() ? (LPCWSTR) m_wsPrimaryName : NULL );

		// Get qualifier array info
		hr = m_pObj->RemoveQualifierArrayRange( pwcsPrimaryName, m_wsQualifierName, m_fIsMethodQualifier,
												WMIARRAY_FLAG_ALLELEMENTS, 0, 0 );
	}
	else
	{
		// Get array property info
		hr =  m_pObj->RemoveArrayPropRangeByHandle( m_lHandle, WMIARRAY_FLAG_ALLELEMENTS, 0, 0 );
	}

	return hr;
}

// Returns the requested elements.  Buffer must be large enough to hold
// the element.  Embedded objects returned as AddRef'd _IWmiObject pointers.
// Strings are copied directly into the specified buffer and null-terminatead. UNICODE only.
STDMETHODIMP CWmiArray::GetAt( long lFlags, ULONG uStartIndex, ULONG uNumElements, ULONG uBuffSize,
								ULONG* puNumElements, ULONG* puBuffSizeUsed, LPVOID pDest )
{
	// Lock using the current object
	CWbemObject::CLock	lock( m_pObj );

	HRESULT	hr = WBEM_S_NO_ERROR;

	// Set the requested range of elements
	if ( IsQualifier() )
	{
		LPCWSTR	pwcsPrimaryName = (LPCWSTR) ( HasPrimaryName() ? (LPCWSTR) m_wsPrimaryName : NULL );

		hr = m_pObj->GetQualifierArrayRange( pwcsPrimaryName, m_wsQualifierName, m_fIsMethodQualifier,
											lFlags, uStartIndex, uNumElements, uBuffSize,
											puNumElements, puBuffSizeUsed, pDest );
	}
	else
	{
		hr =  m_pObj->GetArrayPropRangeByHandle( m_lHandle, lFlags, uStartIndex, uNumElements, uBuffSize,
						puNumElements, puBuffSizeUsed, pDest );
	}

	return hr;
}

// Sets the specified elements.  Buffer must supply data matching the CIMTYPE
// of the Array.  Embedded objects set as _IWmiObject pointers.
// Strings accessed as LPCWSTRs and the 2-byte null is copied.
STDMETHODIMP CWmiArray::SetAt( long lFlags, ULONG uStartIndex, ULONG uNumElements, ULONG uBuffSize,
								LPVOID pDest )
{
	// Check flags
	if ( lFlags != 0L )
	{
		return WBEM_E_INVALID_PARAMETER;
	}

	HRESULT	hr = WBEM_S_NO_ERROR;

	// Lock using the current object
	CWbemObject::CLock	lock( m_pObj );

	// Set the requested range of elements
	if ( IsQualifier() )
	{
		LPCWSTR	pwcsPrimaryName = (LPCWSTR) ( HasPrimaryName() ? (LPCWSTR) m_wsPrimaryName : NULL );

		hr = m_pObj->SetQualifierArrayRange( pwcsPrimaryName, m_wsQualifierName, m_fIsMethodQualifier,
											lFlags, ARRAYFLAVOR_USEEXISTING, m_ct, uStartIndex,
											uNumElements, uBuffSize, pDest );
	}
	else
	{
		hr =  m_pObj->SetArrayPropRangeByHandle( m_lHandle, lFlags, uStartIndex, uNumElements, uBuffSize, pDest );
	}

	return hr;

}

// Appends the specified elements.  Buffer must supply data matching
// the CIMTYPE of the Array.  Embedded objects set as _IWmiObject pointers.
// Strings accessed as LPCWSTRs and the 2-byte null is copied.
STDMETHODIMP CWmiArray::Append( long lFlags, ULONG uNumElements, ULONG uBuffSize, LPVOID pDest )
{
	// Check flags
	if ( lFlags != 0L )
	{
		return WBEM_E_INVALID_PARAMETER;
	}

	HRESULT	hr = WBEM_S_NO_ERROR;

	// Lock using the current object
	CWbemObject::CLock	lock( m_pObj );

	// Set the requested range of elements
	if ( IsQualifier() )
	{
		LPCWSTR	pwcsPrimaryName = (LPCWSTR) ( HasPrimaryName() ? (LPCWSTR) m_wsPrimaryName : NULL );

		hr = m_pObj->AppendQualifierArrayRange( pwcsPrimaryName, m_wsQualifierName, m_fIsMethodQualifier,
												lFlags, m_ct, uNumElements, uBuffSize, pDest );
	}
	else
	{
		hr =  m_pObj->AppendArrayPropRangeByHandle( m_lHandle, lFlags, uNumElements, uBuffSize, pDest );
	}

	return hr;
}

// Removes the specified elements from the array.  Subseqent elements are copied back
// to the starting point
STDMETHODIMP CWmiArray::RemoveAt( long lFlags, ULONG uStartIndex, ULONG uNumElements )
{
	// Lock using the current object
	CWbemObject::CLock	lock( m_pObj );

	HRESULT	hr = WBEM_S_NO_ERROR;

	// Remove the requested range of elements
	if ( IsQualifier() )
	{
		LPCWSTR	pwcsPrimaryName = (LPCWSTR) ( HasPrimaryName() ? (LPCWSTR) m_wsPrimaryName : NULL );

		hr = m_pObj->RemoveQualifierArrayRange( pwcsPrimaryName, m_wsQualifierName, m_fIsMethodQualifier,
												lFlags, uStartIndex, uNumElements );
	}
	else
	{
		hr =  m_pObj->RemoveArrayPropRangeByHandle( m_lHandle, lFlags, uStartIndex, uNumElements );
	}

	return hr;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\marshalers\coreprox\wbemstr.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    WBEMSTR.H

Abstract:

    String helpers.

History:

--*/

#ifndef __WBEM_STR__H_
#define __WBEM_STR__H_

#include <wbemidl.h>
#include "corepol.h"
#include "faststr.h"
#include <functional>

COREPROX_POLARITY void WbemStringFree(WBEM_WSTR String);

COREPROX_POLARITY WBEM_WSTR WbemStringCopy(const WCHAR* String);

class COREPROX_POLARITY CInternalString
{
protected:
    CCompressedString* m_pcs;
public:
    CInternalString() : m_pcs(NULL){}
    CInternalString(LPCWSTR wsz);
    CInternalString(const CInternalString& Other);
    ~CInternalString() {delete [] (BYTE*)m_pcs;}
private:    
    operator CCompressedString*() {return m_pcs;}
    operator CCompressedString*() const {return m_pcs;}
public:    
    void Empty() {delete [] (BYTE*)m_pcs; m_pcs = NULL;}
    bool IsEmpty() {return (m_pcs == NULL);}
    //
    // this is an implementation of the assignement operator against the semantic
    //
    BOOL operator=(LPCWSTR wsz);
    BOOL operator=(CCompressedString* pcs);        
    CInternalString & operator=(const CInternalString& Other);    	
    void AcquireCompressedString(CCompressedString* pcs)
        {delete [] (BYTE*)m_pcs; m_pcs = pcs;}
    void Unbind() {m_pcs = NULL;}
    LPWSTR CreateLPWSTRCopy() const;
    operator WString() const;
    int GetLength() const {return m_pcs->GetStringLength();}
    bool operator==(LPCWSTR wsz) const
        {return m_pcs->CompareNoCase(wsz) == 0;}
    bool operator==(const CInternalString& Other) const
        {return m_pcs->CompareNoCase(*Other.m_pcs) == 0;}
    bool operator!=(const CInternalString& Other) const
        {return m_pcs->CompareNoCase(*Other.m_pcs) != 0;}
    bool operator<(const CInternalString& Other) const
        {return m_pcs->CompareNoCase(*Other.m_pcs) < 0;}
    bool operator>(const CInternalString& Other) const
        {return m_pcs->CompareNoCase(*Other.m_pcs) > 0;}

    int Compare(const CInternalString& Other) const
        {return m_pcs->CompareNoCase(*Other.m_pcs);}
    int Compare(LPCWSTR wsz) const
        {return m_pcs->CompareNoCase(wsz);}

    LPCSTR GetText() const {return ((LPCSTR)m_pcs) + 1;}
};

class CInternalLess : 
           public std::binary_function<CInternalString*, CInternalString*, bool>
{
public:
    bool operator()(const CInternalString*& pis1, const CInternalString*& pis2) 
            const
        {return *pis1 < *pis2;}
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\marshalers\coreprox\wmiarray.h ===
/*++

Copyright (C) 2000-2001 Microsoft Corporation

Module Name:

    WMIARRAY.H

Abstract:

  CWmiArray definition.

  Standard interface for accessing arrays.

History:

  20-Feb-2000	sanjes    Created.

--*/

#ifndef _WMIARRAY_H_
#define _WMIARRAY_H_

#include "shmlock.h"
#include "corepol.h"
#include <arena.h>

#define	WMIARRAY_UNINITIALIZED	0xFFFFFFFF

#define	WMIARRAY_GROWBY_DEFAULT	0x40

//***************************************************************************
//
//  class CWmiArray
//
//  Implementation of _IWmiArray Interface
//
//***************************************************************************

class CWmiArray : public _IWmiArray
{
protected:
	CIMTYPE			m_ct;
	CWbemObject*	m_pObj;
	long			m_lHandle;
	long			m_lRefCount;
	WString			m_wsPrimaryName;
	WString			m_wsQualifierName;
	BOOL			m_fIsQualifier;
	BOOL			m_fHasPrimaryName;
	BOOL			m_fIsMethodQualifier;

	BOOL IsQualifier( void ) { return m_fIsQualifier; }
	BOOL HasPrimaryName( void ) { return m_fHasPrimaryName; }

public:
    CWmiArray();
	virtual ~CWmiArray(); 

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(REFIID riid, LPVOID FAR* ppvObj);
    STDMETHOD_(ULONG, AddRef)();
    STDMETHOD_(ULONG, Release)();

	/* _IWmiArray methods */
    STDMETHOD(Initialize)( long lFlags, CIMTYPE	cimtype, ULONG uNumElements );
	//	Initializes the array.  Number of initial elements as well
	//	as the type (determines the size of each element) and dimension
	//	currently only 1 is supported.

    STDMETHOD(GetInfo)( long lFlags, CIMTYPE* pcimtype, ULONG* puNumElements );
	//	Initializes the array.  Number of initial elements as well
	//	as the type (determines the size of each element).

    STDMETHOD(Empty)( long lFlags );
	//	Clears the array as well as internal data.

	STDMETHOD(GetAt)( long lFlags, ULONG uStartIndex, ULONG uNumElements, ULONG uBuffSize,
						ULONG* puNumReturned, ULONG* puBuffSizeUsed, LPVOID pDest );
	// Returns the requested elements.  Buffer must be large enough to hold
	// the element.  Embedded objects returned as AddRef'd _IWmiObject pointers.
	// Strings are copied directly into the specified buffer and null-terminatead. UNICODE only.

	STDMETHOD(SetAt)( long lFlags, ULONG uStartIndex, ULONG uNumElements, ULONG uBuffSize, LPVOID pDest );
	// Sets the specified elements.  Buffer must supply data matching the CIMTYPE
	// of the Array.  Embedded objects set as _IWmiObject pointers.
	// Strings accessed as LPCWSTRs and the 2-byte null is copied.

    STDMETHOD(Append)( long lFlags, ULONG uNumElements, ULONG uBuffSize, LPVOID pDest );
	// Appends the specified elements.  Buffer must supply data matching
	// the CIMTYPE of the Array.  Embedded objects set as _IWmiObject pointers.
	// Strings accessed as LPCWSTRs and the 2-byte null is copied.

    STDMETHOD(RemoveAt)( long lFlags, ULONG uStartIndex, ULONG uNumElements );
	// Removes the specified elements from the array.  Subseqent elements are copied back
	// to the starting point

public:

	// CWmiArray specific methods
	// Sets the object to work with a property array
	HRESULT InitializePropertyArray( _IWmiObject* pObj, LPCWSTR pwszPropertyName );

	// Sets the object to work with a qualifier array (property or object level)
	HRESULT InitializeQualifierArray( _IWmiObject* pObj, LPCWSTR pwszPrimaryName, 
									LPCWSTR pwszQualifierName, CIMTYPE ct, BOOL fIsMethodQual = FALSE );
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\marshalers\coreprox\wmiobftr.cpp ===
/*++

Copyright (C) 2000-2001 Microsoft Corporation

Module Name:

    WMIOBFTR.CPP

Abstract:

  CWmiObjectFactory implementation.

  Implements the _IWmiObjectFactory interface.

History:

  20-Feb-2000	sanjes    Created.

--*/

#include "precomp.h"
#include <stdio.h>
#include "fastall.h"
#include "wmiobftr.h"
#include <corex.h>
#include "strutils.h"
#include <arrtempl.h>


//***************************************************************************
//
//  CWmiObjectFactory::~CWmiObjectFactory
//
//***************************************************************************
// ok
CWmiObjectFactory::CWmiObjectFactory( CLifeControl* pControl, IUnknown* pOuter )
:	CUnk(pControl, pOuter),
	m_XObjectFactory( this )
{
}
    
//***************************************************************************
//
//  CWmiObjectFactory::~CWmiObjectFactory
//
//***************************************************************************
// ok
CWmiObjectFactory::~CWmiObjectFactory()
{
}

// Override that returns us an interface
void* CWmiObjectFactory::GetInterface( REFIID riid )
{
    if(riid == IID_IUnknown || riid == IID__IWmiObjectFactory)
        return &m_XObjectFactory;
    else
        return NULL;
}

/* _IWmiObjectFactory methods */

HRESULT CWmiObjectFactory::XObjectFactory::Create( IUnknown* pUnkOuter, ULONG ulFlags, REFCLSID rclsid,
										REFIID riid, LPVOID* ppObj )
{
	return m_pObject->Create( pUnkOuter, ulFlags, rclsid, riid, ppObj );
}


// Specifies everything we could possibly want to know about the creation of
// an object and more.
HRESULT CWmiObjectFactory::Create( IUnknown* pUnkOuter, ULONG ulFlags, REFCLSID rclsid,
									REFIID riid, LPVOID* ppObj )
{
	HRESULT	hr = WBEM_S_NO_ERROR;

	try
	{		
              if ( CLSID__WmiWbemClass == rclsid )
		{
			// Cannot be aggregated
			if ( NULL == pUnkOuter )
			{
				// Create a new class object and
				// initialize it.

				CWbemClass*	pObject = new CWbemClass;
				// Already AddRef'd
				CReleaseMe	rm( (IWbemClassObject*) pObject );

				if ( NULL != pObject )
				{
					hr = pObject->InitEmpty();

					if ( SUCCEEDED( hr ) )
					{
						hr = pObject->QueryInterface( riid, ppObj );
					}

				}
				else
				{
					hr = WBEM_E_OUT_OF_MEMORY;
				}

			}
			else
			{
	            hr = CLASS_E_NOAGGREGATION;
			}

		}
		else if ( CLSID__WbemEmptyClassObject == rclsid )
		{
			// Cannot be aggregated
			if ( NULL == pUnkOuter )
			{
				// Create a new class object and
				// initialize it.

				CWbemClass*	pObject = new CWbemClass;
				// Already AddRef'd
				CReleaseMe	rm( (IWbemClassObject*) pObject );

				if ( NULL != pObject )
				{
					// When we initialize this class object, we don't want base
					// system properties to be created
					hr = pObject->InitEmpty( 0, FALSE );

					if ( SUCCEEDED( hr ) )
					{
						hr = pObject->QueryInterface( riid, ppObj );
					}
				}
				else
				{
					hr = WBEM_E_OUT_OF_MEMORY;
				}

			}
			else
			{
	            hr = CLASS_E_NOAGGREGATION;
			}
		}
		else if ( CLSID__WmiWbemInstance == rclsid )
		{
			// Cannot be aggregated
			if ( NULL == pUnkOuter )
			{

				// Create a new instance object, caller won't
				// be able to do much with it other than set object
				// parts

				CWbemInstance*	pObject = new CWbemInstance;
				// Already AddRef'd
				CReleaseMe	rm( (IWbemClassObject*) pObject );

				if ( NULL != pObject )
				{
					hr = pObject->QueryInterface( riid, ppObj );
				}
				else
				{
					hr = WBEM_E_OUT_OF_MEMORY;
				}

			}

		}

		return hr;

	}
	catch ( CX_MemoryException )
	{
		return WBEM_E_OUT_OF_MEMORY;
	}
	catch ( ... )
	{
		return WBEM_E_CRITICAL_ERROR;
	}

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\marshalers\coreprox\wmiobtxt.cpp ===
/*++

Copyright (C) 2000-2001 Microsoft Corporation

Module Name:

    WMIOBTXT.CPP

Abstract:

  CWmiObjectTextSrc implementation.

  Implements the IWbemObjectTextSrc interface.

History:

  20-Feb-2000	sanjes    Created.

--*/

#include "precomp.h"
#include <stdio.h>
#include "fastall.h"
#include "wmiobftr.h"
#include <corex.h>
#include "strutils.h"
#include <unk.h>
#include "wmiobtxt.h"

//***************************************************************************
//
//  CWmiObjectTextSrc::CWmiObjectTextSrc
//
//***************************************************************************
// ok
CWmiObjectTextSrc::CWmiObjectTextSrc( CLifeControl* pControl, IUnknown* pOuter )
:	CUnk( pControl, pOuter ),
	m_XObjectTextSrc( this )
{
}
    
//***************************************************************************
//
//  CWmiObjectTextSrc::~CWmiObjectTextSrc
//
//***************************************************************************
// ok
CWmiObjectTextSrc::~CWmiObjectTextSrc()
{
}

// Override that returns us an interface
void* CWmiObjectTextSrc::GetInterface( REFIID riid )
{
    if(riid == IID_IUnknown || riid == IID_IWbemObjectTextSrc)
        return &m_XObjectTextSrc;
    else
        return NULL;
}

// Pass-through helpers
HRESULT CWmiObjectTextSrc::GetText( long lFlags, IWbemClassObject *pObj, ULONG uObjTextFormat,
									IWbemContext *pCtx, BSTR *strText )
{
	if ( lFlags != NULL )
	{
		return WBEM_E_INVALID_PARAMETER;
	}

	CWmiTextSource*	pSource = NULL;
	HRESULT	hr = m_TextSourceMgr.Find( uObjTextFormat, &pSource );
	CTemplateReleaseMe<CWmiTextSource>	rm( pSource );

	if ( SUCCEEDED( hr ) )
	{
		hr = pSource->ObjectToText( 0L, pCtx, pObj, strText );
	}
	 
	return hr;
}

HRESULT CWmiObjectTextSrc::CreateFromText( long lFlags, BSTR strText, ULONG uObjTextFormat,
										IWbemContext *pCtx, IWbemClassObject **pNewObj )
{
	if ( lFlags != NULL )
	{
		return WBEM_E_INVALID_PARAMETER;
	}

	CWmiTextSource*	pSource = NULL;
	HRESULT	hr = m_TextSourceMgr.Find( uObjTextFormat, &pSource );
	CTemplateReleaseMe<CWmiTextSource>	rm( pSource );

	if ( SUCCEEDED( hr ) )
	{
		hr = pSource->TextToObject( 0L, pCtx, strText, pNewObj );
	}
	 
	return hr;
}

// Actual IWbemObjectTextSrc implementation
STDMETHODIMP CWmiObjectTextSrc::XObjectTextSrc::GetText( long lFlags, IWbemClassObject *pObj, ULONG uObjTextFormat,
														IWbemContext *pCtx, BSTR *strText )
{
	return m_pObject->GetText( lFlags, pObj, uObjTextFormat, pCtx, strText );
}

STDMETHODIMP CWmiObjectTextSrc::XObjectTextSrc::CreateFromText( long lFlags, BSTR strText, ULONG uObjTextFormat,
															   IWbemContext *pCtx, IWbemClassObject **pNewObj )
{
	return m_pObject->CreateFromText( lFlags, strText, uObjTextFormat, pCtx, pNewObj );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\marshalers\coreprox\wmiobftr.h ===
/*++

Copyright (C) 2000-2001 Microsoft Corporation

Module Name:

    WMIOBFTR.H

Abstract:

  CWmiObjectFactory Definition.

  Standard definition for _IWmiObjectFactory.

History:

  22-Feb-2000	sanjes    Created.

--*/

#ifndef _WMIOBFTR_H_
#define _WMIOBFTR_H_

#include "corepol.h"
#include <arena.h>
#include <unk.h>

//***************************************************************************
//
//  class CWmiObjectFactory
//
//  Implementation of _IWmiObjectFactory Interface
//
//***************************************************************************

class COREPROX_POLARITY CWmiObjectFactory : public CUnk
{

public:
    CWmiObjectFactory(CLifeControl* pControl, IUnknown* pOuter = NULL);
	~CWmiObjectFactory(); 

	/* _IWmiObjectFactory methods */
    HRESULT Create( IUnknown* pUnkOuter, ULONG ulFlags, REFCLSID rclsid, REFIID riid, LPVOID* ppObj );
	// Specifies everything we could possibly want to know about the creation of
	// an object and more.

    class COREPROX_POLARITY XObjectFactory : public CImpl<_IWmiObjectFactory, CWmiObjectFactory>
    {
    public:
        XObjectFactory(CWmiObjectFactory* pObject) : 
            CImpl<_IWmiObjectFactory, CWmiObjectFactory>(pObject)
        {}

		STDMETHOD(Create)( IUnknown* pUnkOuter, ULONG ulFlags, REFCLSID rclsid, REFIID riid, LPVOID* ppObj );

    } m_XObjectFactory;
    friend XObjectFactory;


protected:
    void* GetInterface(REFIID riid);
	
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\marshalers\coreprox\wmiobtxt.h ===
/*++

Copyright (C) 2000-2001 Microsoft Corporation

Module Name:

    WMIOBTXT.H

Abstract:

  CWmiObjectTextSrc Definition.

  Standard definition for IWbemObjectTextSrc.

History:

  22-Feb-2000	sanjes    Created.

--*/

#ifndef _WMIOBTXT_H_
#define _WMIOBTXT_H_

#include "corepol.h"
#include "txtscmgr.h"
#include <arena.h>

//***************************************************************************
//
//  class CWmiObjectTextSrc
//
//  Implementation of _IWmiObjectFactory Interface
//
//***************************************************************************

class  CWmiObjectTextSrc : public CUnk
{
private:
	CTextSourceMgr	m_TextSourceMgr;

public:
    CWmiObjectTextSrc(CLifeControl* pControl, IUnknown* pOuter = NULL);
	virtual ~CWmiObjectTextSrc(); 

protected:

	HRESULT GetText( long lFlags, IWbemClassObject *pObj, ULONG uObjTextFormat, IWbemContext *pCtx, BSTR *strText );
	HRESULT CreateFromText( long lFlags, BSTR strText, ULONG uObjTextFormat, IWbemContext *pCtx,
								IWbemClassObject **pNewObj );

    class COREPROX_POLARITY XObjectTextSrc : public CImpl<IWbemObjectTextSrc, CWmiObjectTextSrc>
    {
    public:
        XObjectTextSrc(CWmiObjectTextSrc* pObject) : 
            CImpl<IWbemObjectTextSrc, CWmiObjectTextSrc>(pObject)
        {}

		STDMETHOD(GetText)( long lFlags, IWbemClassObject *pObj, ULONG uObjTextFormat, IWbemContext *pCtx, BSTR *strText );
		STDMETHOD(CreateFromText)( long lFlags, BSTR strText, ULONG uObjTextFormat, IWbemContext *pCtx,
									IWbemClassObject **pNewObj );

    } m_XObjectTextSrc;
    friend XObjectTextSrc;

protected:
    void* GetInterface(REFIID riid);

public:
	
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\marshalers\server2\precomp.h ===
/*++

Copyright (C) 1999-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/

#pragma warning (disable : 4786)
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#define WIN32_NO_STATUS
#include <ole2.h>
#include <windows.h>
#define COREPOL_HEADERFILE_IS_INCLUDED

#define COREPROX_POLARITY __declspec( dllimport )

#define COREPOL_HEADERFILE_IS_INCLUDED
#define POLARITY_HEADERFILE_IS_INCLUDED
#define POLARITY __declspec( dllimport )

#include <comdef.h>
#include <strsafe.h>
#include "arena.h"
#include <helper.h>
#include <autoptr.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\marshalers\coreprox\wmitxtsc.h ===
/*++

Copyright (C) 2000-2001 Microsoft Corporation

Module Name:

    WMITXTSC.H

Abstract:

  CWmiTextSource Definition.

  Class to encapsulate Text Source Encoder/Decoder Dlls

History:

  22-Feb-2000	sanjes    Created.

--*/

#ifndef _WMITXTSRC_H_
#define _WMITXTSRC_H_

#include "corepol.h"
#include "arrtempl.h"
#include <arena.h>

// Our very own subkey
#define WBEM_REG_WBEM_TEXTSRC __TEXT("Software\\Microsoft\\WBEM\\TextSource")
#define WBEM_REG_WBEM_TEXTSRCDLL __TEXT("TextSourceDll")

// Header definitions for Open/Close/ObjectToText/TextToObject functions
typedef HRESULT (WMIOBJTEXTSRC_OPEN) ( long, ULONG );
typedef HRESULT (WMIOBJTEXTSRC_CLOSE) ( long, ULONG );
typedef HRESULT (WMIOBJTEXTSRC_OBJECTTOTEXT) ( long, ULONG, void*, void*, BSTR* );
typedef HRESULT (WMIOBJTEXTSRC_TEXTTOOBJECT) ( long, ULONG, void*, BSTR, void** );

typedef WMIOBJTEXTSRC_OPEN*			PWMIOBJTEXTSRC_OPEN;
typedef WMIOBJTEXTSRC_CLOSE*		PWMIOBJTEXTSRC_CLOSE;
typedef WMIOBJTEXTSRC_OBJECTTOTEXT*	PWMIOBJTEXTSRC_OBJECTTOTEXT;
typedef WMIOBJTEXTSRC_TEXTTOOBJECT*	PWMIOBJTEXTSRC_TEXTTOOBJECT;

// A conveniently invalid value
#define WMITEXTSC_INVALIDID			0xFFFFFFFF

//***************************************************************************
//
//  class CWmiTextSource
//
//	Maintains information regarding the text source DLLs we will be
//	loading and unloading.	
//
//***************************************************************************
class CWmiTextSource
{
protected:
	// We want this to be refcounted
	long							m_lRefCount;
	
	// Our id and other state variables
	ULONG							m_ulId;
	bool							m_fOpened;

	// The DLL handle
	HINSTANCE						m_hDll;

	// These are the function definitions
	PWMIOBJTEXTSRC_OPEN				m_pOpenTextSrc;
	PWMIOBJTEXTSRC_CLOSE			m_pCloseTextSrc;
	PWMIOBJTEXTSRC_OBJECTTOTEXT		m_pObjectToText;
	PWMIOBJTEXTSRC_TEXTTOOBJECT		m_pTextToObject;

public:

	// Constructor/Destructor
	CWmiTextSource();
	~CWmiTextSource();

	//AddRef/Release
	ULONG	AddRef( void );
	ULONG	Release( void );

	// Initialization helper
	HRESULT	Init( ULONG lId );

	// Pass through to the actual dll
	HRESULT OpenTextSource( long lFlags );
	HRESULT CloseTextSource( long lFlags );
	HRESULT ObjectToText( long lFlags, IWbemContext* pCtx, IWbemClassObject* pObj, BSTR* pbText );
	HRESULT TextToObject( long lFlags, IWbemContext* pCtx, BSTR pText, IWbemClassObject** ppObj );

	ULONG GetId( void )	{ return m_ulId; }
};


// Workaround for import/export issues
class COREPROX_POLARITY CWmiTextSourceArray : public CRefedPointerArray<CWmiTextSource>
{
public:
	CWmiTextSourceArray() {};
	~CWmiTextSourceArray() {};
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\marshalers\coreprox\wmitxtsc.cpp ===
/*++

Copyright (C) 2000-2001 Microsoft Corporation

Module Name:

    WMITXTSC.CPP

Abstract:

  CWmiTextSource implementation.

  Helper class for maintaining text source objects.

History:

  20-Feb-2000	sanjes    Created.

--*/

#include "precomp.h"
#include <stdio.h>
#include "fastall.h"
#include "wmiobftr.h"
#include <corex.h>
#include "strutils.h"
#include "reg.h"
#include "wmitxtsc.h"

//***************************************************************************
//
//  CWmiTextSource::~CWmiTextSource
//
//***************************************************************************
// ok
CWmiTextSource::CWmiTextSource()
:	m_lRefCount( 1 ),	// Always have to be released
	m_ulId( WMITEXTSC_INVALIDID ),
	m_hDll( NULL ),
	m_pOpenTextSrc( NULL ),
	m_pCloseTextSrc( NULL ),
	m_pObjectToText( NULL ),
	m_pTextToObject( NULL ),
	m_fOpened( FALSE )
{
}
    
//***************************************************************************
//
//  CWmiTextSource::~CWmiTextSource
//
//***************************************************************************
// ok
CWmiTextSource::~CWmiTextSource()
{
	if ( m_fOpened )
	{
		CloseTextSource( 0L );
	}

	if ( NULL != m_hDll )
	{
		FreeLibrary( m_hDll );
	}
}

// AddRef/Release
ULONG CWmiTextSource::AddRef( void )
{
	return InterlockedIncrement( &m_lRefCount );
}

ULONG CWmiTextSource::Release( void )
{
	long lReturn = InterlockedDecrement( &m_lRefCount );

	if ( 0L == lReturn )
	{
		delete this;
	}

	return lReturn;
}

// Initialization helper
HRESULT	CWmiTextSource::Init( ULONG lId )
{
	HRESULT	hr = WBEM_S_NO_ERROR;

	wchar_t	szSubKey[64];
	_ultow( lId, szSubKey, 10 );

	wchar_t	szRegKey[256];
	
	StringCchCopyW( szRegKey, 256, WBEM_REG_WBEM_TEXTSRC );
	StringCchCatW( szRegKey, 256, __TEXT("\\") );
	StringCchCatW( szRegKey, 256, szSubKey );

	// We only need read privileges
	Registry	reg( HKEY_LOCAL_MACHINE, KEY_READ, szRegKey );

	if (reg.GetLastError() == ERROR_SUCCESS )
	{
		TCHAR*	pszDllPath = NULL;

		// Now query the dllname
		if ( reg.GetStr( WBEM_REG_WBEM_TEXTSRCDLL, &pszDllPath ) == Registry::no_error )
		{
			HINSTANCE	hInst = LoadLibraryEx( pszDllPath, NULL, LOAD_WITH_ALTERED_SEARCH_PATH );

			if ( NULL != hInst )
			{
				// Now load our proc addresses
				m_pOpenTextSrc = (PWMIOBJTEXTSRC_OPEN) GetProcAddress( hInst, "OpenWbemTextSource" );
				m_pCloseTextSrc = (PWMIOBJTEXTSRC_CLOSE) GetProcAddress( hInst, "CloseWbemTextSource" );
				m_pObjectToText = (PWMIOBJTEXTSRC_OBJECTTOTEXT) GetProcAddress( hInst, "WbemObjectToText" );
				m_pTextToObject = (PWMIOBJTEXTSRC_TEXTTOOBJECT) GetProcAddress( hInst, "TextToWbemObject" );

				if (	NULL != m_pOpenTextSrc		&&
						NULL != m_pCloseTextSrc		&&
						NULL != m_pObjectToText		&&
						NULL !=	m_pTextToObject	)
				{
					// Set the Id
					m_ulId = lId;

					// Finally, call the open function
					hr = OpenTextSource( 0L );

					if ( SUCCEEDED( hr ) )
					{
						m_hDll = hInst;
						m_fOpened = true;
					}
					else
					{
						FreeLibrary( hInst );
					}
				}
				else
				{

					hr = WBEM_E_FAILED;

				}	// Failed to get a proc address

			}
			else
			{

				hr = WBEM_E_FAILED;

			}	// Failed to load the library

			// Cleanup
			delete [] pszDllPath;
		}
		else
		{

			hr = WBEM_E_NOT_FOUND;

		}	// Failed to get the dll path
	}
	else
	{
		hr = WBEM_E_NOT_FOUND;
	}

	return hr;

}

// Pass-through functions
HRESULT CWmiTextSource::OpenTextSource( long lFlags )
{
	if (m_pOpenTextSrc) return m_pOpenTextSrc( lFlags, m_ulId );
	else return WBEM_E_FAILED;
}

HRESULT CWmiTextSource::CloseTextSource( long lFlags )
{
	if (m_pCloseTextSrc) return m_pCloseTextSrc( lFlags, m_ulId );
	else return WBEM_E_FAILED;
	
}

HRESULT CWmiTextSource::ObjectToText( long lFlags, IWbemContext* pCtx, IWbemClassObject* pObj, BSTR* pbText )
{
	if (m_pObjectToText) return m_pObjectToText( lFlags, m_ulId, (void*) pCtx, (void*) pObj, pbText );
	else return WBEM_E_FAILED;
	
}

HRESULT CWmiTextSource::TextToObject( long lFlags, IWbemContext* pCtx, BSTR pText, IWbemClassObject** ppObj )
{
	if (m_pTextToObject) return m_pTextToObject( lFlags, m_ulId, (void*) pCtx, pText, (void**) ppObj );
	else return WBEM_E_FAILED;
	
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\marshalers\server2\servutil.h ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

    SERVUTIL.H

Abstract:

	Declares a set of general purpose service utilitils.

History:

  a-davj  04-Mar-97   Created.

--*/

#ifndef _SERVUTIL_H_
#define _SERVUTIL_H_

BOOL StopService(LPCTSTR pServiceName, DWORD dwMaxWait=0);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\marshalers\server2\strings.h ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

    STRINGS.H

Abstract:

	resource IDs.

History:

	a-davj  04-Mar-97   Created.

--*/

#ifndef _provstub_H_
#define _provstub_H_

#define ID1		101
#define ID2		102
#define ID3		103
#define ID4		104
#define ID5		105
#define ID6		106
#define ID7		107
#define ID8		108
#define ID9		109
#define ID10	110
#define ID11	111
#define ID_LAST 112


#define ID_ERROR_SHORT		200
#define ID_ERROR_LONG		201
#define ID_BACKUP_TITLE		202
#define ID_RESTORE_TITLE	203

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\marshalers\server2\servutil.cpp ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

    SERVUTIL.CPP

Abstract:

	Defines various service utilities.

History:

  a-davj  04-Mar-97   Created.

--*/

#include "precomp.h"
#include "servutil.h"


//***************************************************************************
//
//  BOOL StopService
//
//  DESCRIPTION:
//
//  Stops and then removes the service. 
//
//  PARAMETERS:
//
//  pServiceName        short service name
//  dwMaxWait           max time in seconds to wait
//
//  RETURN VALUE:
//
//  TRUE if it worked
//
//***************************************************************************

BOOL StopService(
                        IN LPCTSTR pServiceName,
                        IN DWORD dwMaxWait)
{
    BOOL bRet = FALSE;
    SC_HANDLE   schService;
    SC_HANDLE   schSCManager;
    DWORD dwCnt;
    SERVICE_STATUS          ssStatus;       // current status of the service

    schSCManager = OpenSCManager(
                        NULL,                   // machine (NULL == local)
                        NULL,                   // database (NULL == default)
                        SC_MANAGER_ALL_ACCESS   // access required
                        );
    if ( schSCManager )
    {
        schService = OpenService(schSCManager, pServiceName, SERVICE_ALL_ACCESS);

        if (schService)
        {
            // try to stop the service
            if ( bRet = ControlService( schService, SERVICE_CONTROL_STOP, &ssStatus ) )
            {
                for(dwCnt=0; dwCnt < dwMaxWait &&
                    QueryServiceStatus( schService, &ssStatus ); dwCnt++)
                {
                    if ( ssStatus.dwCurrentState == SERVICE_STOP_PENDING )
                        Sleep( 1000 );
                    else
                        break;
                }

            }

            CloseServiceHandle(schService);
        }

        CloseServiceHandle(schSCManager);
    }
    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\marshalers\server2\winmgmt.cpp ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

    WINMGMT.CPP

Abstract:

    If started with /kill argument, it will stop any running exes or services.
    If started with /? or /help dumps out information.

History:

    a-davj  04-Mar-97   Created.

--*/

#include "precomp.h"
#include <malloc.h>
#include <Shellapi.h> // for CommandLineToArgvW

#include <wbemidl.h>
#include <reg.h>      // for Registry
#include <wbemutil.h> // for DEBUGTRACE
#include <cominit.h>  // for InitializeCom
#include <genutils.h> // EnablePrivilege
#include <mofcomp.h>
#include <winmgmtr.h>
#include <arrtempl.h>

#include "servutil.h"
#include "WinMgmt.h"
#include "STRINGS.h"


#define BUFF_MAX 200

HINSTANCE ghInstance;

DWORD RegServer();
DWORD UnregServer();
void DoResyncPerf();
void DoClearAdap();
// to accomodate revert-to-alone
DWORD DoSetToAlone(CHAR * pszLevel);
DWORD DoSetToShared(CHAR * pszLevel);
// for Back-up Restore
int DoBackup();
int DoRestore();
void DisplayWbemError(HRESULT hresError, DWORD dwLongFormatString, DWORD dwShortFormatString, DWORD dwTitle);


//***************************************************************************
//
//  void TerminateRunning
//
//  DESCRIPTION:
//
//  Stops another running copy even if it is a service.
//
//***************************************************************************

void TerminateRunning()
{
    StopService(__TEXT("wmiapsrv"), 15);
    StopService(__TEXT("WinMgmt"), 15);
    return;
}

//***************************************************************************
//
//  void DisplayMessage
//
//  DESCRIPTION:
//
//  Displays a usage message box.
//
//***************************************************************************

void DisplayMessage()
{
    //
    //  ISSUE: these might not be enought for certain localized strings
    //
    wchar_t tBuff[BUFF_MAX];
    wchar_t tBig[1024];
    tBig[0] = 0;

    UINT ui;
    for(ui = ID1; ui <= ID9; ui++)
    {
        int iRet = LoadStringW(ghInstance, ui, tBuff, BUFF_MAX);
        if(iRet > 0)
            StringCchCatW(tBig, 1024, tBuff);
    }
    if(lstrlenW(tBig) > 0)
        MessageBoxW(NULL, tBig, L"WinMgmt", MB_OK);

}


//***************************************************************************
//
//  int APIENTRY WinMain
//
//  DESCRIPTION:
//
//  Entry point for windows applications.  If this is running under
//  NT, then this will run as a service, unless the "/EXE" command line
//  argument is used.
//
//  PARAMETERS:
//
//  hInstance           Instance handle
//  hPrevInstance       not used in win32
//  szCmdLine           command line argument
//  nCmdShow            how window is to be shown(ignored)
//
//  RETURN VALUE:
//
//  0
//***************************************************************************

int APIENTRY WinMain(
                        IN HINSTANCE hInstance,
                        IN HINSTANCE hPrevInstance,
                        IN LPSTR szCmdLine,
                        IN int nCmdShow)
{
    // This should not be uninitialized!  It is here to prevent the class factory from being called during
    // shutdown.
    
    ghInstance = hInstance;

    DEBUGTRACE((LOG_WINMGMT,"\nStarting WinMgmt, ProcID = %x, CmdLine = %s", GetCurrentProcessId(), szCmdLine));

    if(szCmdLine && (szCmdLine[0] == '-' || szCmdLine[0] == '/' ))
    {
        if(!wbem_stricmp("RegServer",szCmdLine+1))
            return RegServer();
        else if(!wbem_stricmp("UnregServer",szCmdLine+1))
            return UnregServer();    
        else if(!wbem_stricmp("kill",szCmdLine+1))
        {
            TerminateRunning();
            return 0;
        }
        else if (wbem_strnicmp("backup ", szCmdLine+1, strlen("backup ")) == 0)
        {
            return DoBackup();
        }
        else if (wbem_strnicmp("restore ", szCmdLine+1, strlen("restore ")) == 0)
        {
            return DoRestore();
        }
        else if(wbem_strnicmp("resyncperf", szCmdLine+1, strlen("resyncperf")) == 0)
        {
            DoResyncPerf();
            return 0;
        }
        else if(wbem_strnicmp("clearadap", szCmdLine+1, strlen("clearadap")) == 0)
        {
            DoClearAdap();
            return 0;
        }
        else if (0 == wbem_strnicmp("cncnt",szCmdLine+1,strlen("cnct")))
        {
            CHAR pNumber[16];
            StringCchPrintfA(pNumber, 16, "%d", RPC_C_AUTHN_LEVEL_CONNECT); // our OLD default
            return DoSetToAlone(pNumber);        
        }
        else if (0 == wbem_strnicmp("pkt",szCmdLine+1, strlen("pkt")))
        {
			// NULL means default means PKT
            return DoSetToShared(NULL);            
        }
        else if(0 == wbem_strnicmp("?", szCmdLine+1,strlen("?")))
        {
            DisplayMessage();
            return 0;
        }
    }

    return 0;
}

//***************************************************************************
//
//  int RegServer
//
//  DESCRIPTION:
//
//  Self registers the dll.
//
//***************************************************************************

typedef HRESULT (__stdcall *  pfnDllRegisterServer)(void);

DWORD RegServer()
{
    HMODULE hMod = LoadLibraryExW(SERVICE_DLL,NULL,0);
    DWORD dwRes = 0;
    
    if (hMod)
    {
        pfnDllRegisterServer DllRegisterServer = (pfnDllRegisterServer)GetProcAddress(hMod,"DllRegisterServer");

		if(DllRegisterServer)
		{
			dwRes = DllRegisterServer();
		} 
		else 
		{
            dwRes = GetLastError();
		}

		FreeLibrary(hMod);        
    } 
    else 
    {
        dwRes = GetLastError();
    }

    return dwRes;

}

//***************************************************************************
//
//  int UnregServer
//
//  DESCRIPTION:
//
//  Unregisters the exe.
//
//***************************************************************************

typedef HRESULT (__stdcall *  pfnDllUnregisterServer)(void);

DWORD UnregServer()
{
    HMODULE hMod = LoadLibraryExW(SERVICE_DLL,NULL,0);
    DWORD dwRes = 0;
    
    if (hMod)
    {
        pfnDllUnregisterServer DllUnregisterServer = (pfnDllUnregisterServer)GetProcAddress(hMod,"DllUnregisterServer");

		if(DllUnregisterServer)
		{
			dwRes = DllUnregisterServer();
		} 
		else 
		{
            dwRes = GetLastError();
		}

		FreeLibrary(hMod);        
    } 
    else 
    {
        dwRes = GetLastError();
    }

    return dwRes;
}

//
//
// move in a segregate svchost, to allow OLD connect level
//
///////////////////////////////////////////////////////////


typedef 
void (CALLBACK * pfnMoveToAlone)(HWND hwnd, HINSTANCE hinst, LPSTR lpszCmdLine, int nCmdShow);

DWORD 
DoSetToAlone(CHAR * pszLevel)
{
    HMODULE hMod = LoadLibraryExW(SERVICE_DLL,NULL,0);
    DWORD dwRes = 0;
    
    if (hMod)
    {
        pfnMoveToAlone MoveToAlone = (pfnMoveToAlone)GetProcAddress(hMod,"MoveToAlone");

		if(MoveToAlone)
		{
			MoveToAlone(NULL,hMod,pszLevel,0);
		} 
		else 
		{
            dwRes = GetLastError();
		}

		FreeLibrary(hMod);        
    } 
    else 
    {
        dwRes = GetLastError();
    }

    return dwRes;    
};

//
//
// move in a shares svchost
//
///////////////////////////////////////////////////////////

typedef 
void (CALLBACK * pfnMoveToShared)(HWND hwnd, HINSTANCE hinst, LPSTR lpszCmdLine, int nCmdShow);

DWORD DoSetToShared(char * pszLevel)
{
	HMODULE hMod = LoadLibraryExW(SERVICE_DLL,NULL,0);
    DWORD dwRes = 0;
    
    if (hMod)
    {
        pfnMoveToShared MoveToShared = (pfnMoveToAlone)GetProcAddress(hMod,"MoveToShared");

		if(MoveToShared)
		{
			MoveToShared(NULL,hMod,pszLevel,0);
		} 
		else 
		{
            dwRes = GetLastError();
		}

		FreeLibrary(hMod);        
    } 
    else 
    {
        dwRes = GetLastError();
    }

    return dwRes;    
};

//***************************************************************************
//
//  int DoBackup
//
//  DESCRIPTION:
//
//  Calls into IWbemBackupRestore::Backup to backup the repository.
//
//***************************************************************************
int DoBackup()
{
	int hr = WBEM_S_NO_ERROR;

    //*************************************************
    // Split up command line and validate parameters
    //*************************************************
    wchar_t *wszCommandLine = GetCommandLineW();
    if (wszCommandLine == NULL)
    {
        hr = WBEM_E_OUT_OF_MEMORY;
        DisplayWbemError(hr, ID_ERROR_LONG, ID_ERROR_SHORT, ID_BACKUP_TITLE);
    }

    int nNumArgs = 0;
    wchar_t **wszCommandLineArgv = NULL;

    if (SUCCEEDED(hr))
    {
        wszCommandLineArgv = CommandLineToArgvW(wszCommandLine, &nNumArgs);

        if ((wszCommandLineArgv == NULL) || (nNumArgs != 3))
        {
            hr = WBEM_E_INVALID_PARAMETER;
            DisplayMessage();
        }
    }

    //wszCommandLineArgv[0] = winmgmt.exe
    //wszCommandLineArgv[1] = /backup
    //wszCommandLineArgv[2] = <backup filename>

    if (SUCCEEDED(hr))
    {
        InitializeCom();
        IWbemBackupRestore* pBackupRestore = NULL;
        hr = CoCreateInstance(CLSID_WbemBackupRestore, 0, CLSCTX_LOCAL_SERVER,
                            IID_IWbemBackupRestore, (LPVOID *) &pBackupRestore);
        if (SUCCEEDED(hr))
        {
            EnablePrivilege(TOKEN_PROCESS,SE_BACKUP_NAME);
            hr = pBackupRestore->Backup(wszCommandLineArgv[2], 0);

            if (FAILED(hr))
            {
                DisplayWbemError(hr, ID_ERROR_LONG, ID_ERROR_SHORT, ID_BACKUP_TITLE);
            }

            pBackupRestore->Release();
        }
        else
        {
            DisplayWbemError(hr, ID_ERROR_LONG, ID_ERROR_SHORT, ID_BACKUP_TITLE);
        }
        CoUninitialize();
    }

	return hr;
}

//***************************************************************************
//
//  int DoRestore
//
//  DESCRIPTION:
//
//  Calls into IWbemBackupRestore::Restore to restore the repository.
//
//***************************************************************************
int DoRestore()
{
	int hr = WBEM_S_NO_ERROR;

    //*************************************************
    // Split up command line and validate parameters
    //*************************************************
    wchar_t *wszCommandLine = GetCommandLineW();
    if (wszCommandLine == NULL)
    {
        hr = WBEM_E_OUT_OF_MEMORY;
        DisplayWbemError(hr, ID_ERROR_LONG, ID_ERROR_SHORT, ID_RESTORE_TITLE);
    }

    int nNumArgs = 0;
    wchar_t **wszCommandLineArgv = NULL;

    if (SUCCEEDED(hr))
    {
        wszCommandLineArgv = CommandLineToArgvW(wszCommandLine, &nNumArgs);

        if ((wszCommandLineArgv == NULL) || (nNumArgs != 4))
        {
            hr = WBEM_E_INVALID_PARAMETER;
            DisplayMessage();
        }
    }

    //wszCommandLineArgv[0] = winmgmt.exe
    //wszCommandLineArgv[1] = /restore
    //wszCommandLineArgv[2] = <restore filename>
    //wszcommandLineArgv[3] = <restore options>

    //*****************************************************
    // Validate restore option
    //*****************************************************
    if (SUCCEEDED(hr))
    {
        if ((wcscmp(wszCommandLineArgv[3], L"0") != 0) &&
            (wcscmp(wszCommandLineArgv[3], L"1") != 0))
        {
            hr = WBEM_E_INVALID_PARAMETER;
            DisplayMessage();
        }
    }

    long lFlags = 0;

    //*****************************************************
    // Retrieve restore option
    //*****************************************************
    if (SUCCEEDED(hr))
    {
        lFlags = (long) (*wszCommandLineArgv[3] - L'0');
    }

    //*****************************************************
    // Create the IWbemBackupRestore interface and get that
    // to do the restore for us...
    //*****************************************************
    if (SUCCEEDED(hr))
    {
        InitializeCom();
        IWbemBackupRestore* pBackupRestore = NULL;
        hr = CoCreateInstance(CLSID_WbemBackupRestore, 0, CLSCTX_LOCAL_SERVER,
                            IID_IWbemBackupRestore, (LPVOID *) &pBackupRestore);
        if (SUCCEEDED(hr))
        {
            EnablePrivilege(TOKEN_PROCESS,SE_RESTORE_NAME);
            hr = pBackupRestore->Restore(wszCommandLineArgv[2], lFlags);

            if (FAILED(hr))
            {
                DisplayWbemError(hr, ID_ERROR_LONG, ID_ERROR_SHORT, ID_RESTORE_TITLE);
            }

            pBackupRestore->Release();
        }
        else
        {
            DisplayWbemError(hr, ID_ERROR_LONG, ID_ERROR_SHORT, ID_RESTORE_TITLE);
        }
        CoUninitialize();
    }

    //**************************************************
    //All done!
    //**************************************************
	return hr;
}

void DisplayWbemError(HRESULT hresError, DWORD dwLongFormatString, DWORD dwShortFormatString, DWORD dwTitle)
{
    wchar_t* szError = new wchar_t[2096];
	if (!szError)
		return;
	CVectorDeleteMe<wchar_t> delme1(szError);
	szError[0] = 0;

    wchar_t* szFacility = new wchar_t[2096];
	if (!szFacility)
		return;
	CVectorDeleteMe<wchar_t> delme2(szFacility);
    szFacility[0] = 0;

    wchar_t* szMsg = new wchar_t[2096];
	if (!szMsg)
		return;
	CVectorDeleteMe<wchar_t> delme3(szMsg);
	szMsg[0] = 0;

    wchar_t* szFormat = new wchar_t[100];
	if (!szFormat)
		return;
	CVectorDeleteMe<wchar_t> delme4(szFormat);
	szFormat[0] = 0;

    wchar_t* szTitle = new wchar_t[100];
	if (!szTitle)
		return;
	CVectorDeleteMe<wchar_t> delme5(szTitle);
	szTitle[0] = 0;

    IWbemStatusCodeText * pStatus = NULL;

    SCODE sc = CoCreateInstance(CLSID_WbemStatusCodeText, 0, CLSCTX_INPROC_SERVER,
                                        IID_IWbemStatusCodeText, (LPVOID *) &pStatus);
    
    if(sc == S_OK)
    {
        BSTR bstr = 0;
        sc = pStatus->GetErrorCodeText(hresError, 0, 0, &bstr);
        if(sc == S_OK)
        {
            StringCchCopyW(szError, 2096, bstr);
            SysFreeString(bstr);
            bstr = 0;
        }
        sc = pStatus->GetFacilityCodeText(hresError, 0, 0, &bstr);
        if(sc == S_OK)
        {
            StringCchCopyW(szFacility, 2096, bstr);
            SysFreeString(bstr);
            bstr = 0;
        }
        pStatus->Release();
    }
    if(wcslen(szFacility) == 0 || wcslen(szError) == 0)
    {
        if (LoadStringW(GetModuleHandle(NULL), dwShortFormatString, szFormat, 100))
	        StringCchPrintfW(szMsg, 2096, szFormat, hresError);
    }
    else
    {
        if (LoadStringW(GetModuleHandle(NULL), dwLongFormatString, szFormat, 100))
	        StringCchPrintfW(szMsg, 2095, szFormat, hresError, szFacility, szError);
    }

    LoadStringW(GetModuleHandle(NULL), dwTitle, szTitle, 100);
    MessageBoxW(0, szMsg, szTitle, MB_ICONERROR | MB_OK);
}

void DoResyncPerf()
{
    PROCESS_INFORMATION pi;
    STARTUPINFO si;
    memset(&si, 0, sizeof(si));
    si.cb = sizeof(si);
	si.dwFlags = STARTF_FORCEOFFFEEDBACK;

	// Get the appropriate cmdline and attach the proper command line switches
	LPTSTR	pCmdLine = GetWMIADAPCmdLine( 64 );
	CVectorDeleteMe<TCHAR>	vdm( pCmdLine );

	if ( NULL == pCmdLine )
	{
		return;
	}

	wchar_t pPassedCmdLine[64];
	StringCchCopyW(pPassedCmdLine, 64, L"wmiadap.exe /F");
	
	if ( CreateProcessW( pCmdLine, pPassedCmdLine, NULL, NULL, FALSE, CREATE_NO_WINDOW,
			      NULL, NULL,  &si, &pi ) )
	{
        // Cleanup handles right away
		// ==========================
        CloseHandle( pi.hThread );
        CloseHandle( pi.hProcess );
	}

    return;
}

void DoClearAdap()
{
	PROCESS_INFORMATION pi;
	STARTUPINFO si;
	memset(&si, 0, sizeof(si));
	si.cb = sizeof(si);
    si.dwFlags = STARTF_FORCEOFFFEEDBACK;

	// Get the appropriate cmdline and attach the proper command line switches
	LPTSTR	pCmdLine = GetWMIADAPCmdLine( 64 );
	CVectorDeleteMe<TCHAR>	vdm( pCmdLine );

	if ( NULL == pCmdLine )
	{
		return;
	}

	wchar_t pPassedCmdLine[64];
	StringCchCopyW(pPassedCmdLine, 64, L"wmiadap.exe /C");

	if ( CreateProcessW( pCmdLine, pPassedCmdLine, NULL, NULL, FALSE, CREATE_NO_WINDOW,
				  NULL, NULL,  &si, &pi) )
	{
        // Cleanup handles right away
		// ==========================
        CloseHandle( pi.hThread );
        CloseHandle( pi.hProcess );
	}

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\marshalers\server2\winmgmt.h ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

    WINMGMT.H

Abstract:

	Declares the PROG_RESOURCES stucture, the MyService class and a few
	utility type functions.

History:

--*/

#ifndef _WinMgmt_H_
#define _WinMgmt_H_

#define SERVICE_DLL         L"wmisvc.dll"

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\marshalers\wbemprox\classfac.cpp ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

    CLASSFAC.CPP

Abstract:

    Contains the class factory.  This creates objects when
    connections are requested.

History:

    a-davj  04-Mar-97   Created.

--*/

#include "precomp.h"
#include <wbemidl.h>
#include <wbemint.h>
#include <reg.h>
#include <strsafe.h>
#include "wbemprox.h"
#include "locator.h"
#include "cprovloc.h"
#include "comtrans.h"

//***************************************************************************
//
// CLocatorFactory::CLocatorFactory
//
// DESCRIPTION:
//
// Constructor
//
//***************************************************************************

CLocatorFactory::CLocatorFactory(DWORD dwType)
{
    m_cRef=0L;
    m_dwType = dwType;
    InterlockedIncrement(&g_cObj);
    return;
}

//***************************************************************************
//
// CLocatorFactory::~CLocatorFactory
//
// DESCRIPTION:
//
// Destructor
//
//***************************************************************************

CLocatorFactory::~CLocatorFactory(void)
{
    InterlockedDecrement(&g_cObj);
    return;
}

//***************************************************************************
//
// CLocatorFactory::QueryInterface
// CLocatorFactory::AddRef
// CLocatorFactory::Release
//
// Purpose: Standard Ole routines needed for all interfaces
//
//***************************************************************************


STDMETHODIMP CLocatorFactory::QueryInterface(REFIID riid
    , PPVOID ppv)
{
    *ppv=NULL;

    if (IID_IUnknown==riid || IID_IClassFactory==riid)
        *ppv=this;

    if (NULL!=*ppv)
        {
        ((LPUNKNOWN)*ppv)->AddRef();
        return NOERROR;
        }

    return ResultFromScode(E_NOINTERFACE);
}

STDMETHODIMP_(ULONG) CLocatorFactory::AddRef(void)
{
    InterlockedIncrement(&m_cRef);
    return m_cRef;
}

STDMETHODIMP_(ULONG) CLocatorFactory::Release(void)
{
    long lTemp = InterlockedDecrement(&m_cRef);
    if (0L!=lTemp)
        return m_cRef;

    delete this;
    return 0L;
}

//***************************************************************************
//
//  SCODE CLocatorFactory::CreateInstance
//
//  Description: 
//
//  Instantiates a Provider object returning an interface pointer.
//
//  Parameters:
//
//  pUnkOuter       LPUNKNOWN to the controlling IUnknown if we are
//                  being used in an aggregation.
//  riid            REFIID identifying the interface the caller
//                  desires to have for the new object.
//  ppvObj          PPVOID in which to store the desired
//                  interface pointer for the new object.
//
// Return Value:
//  HRESULT         NOERROR if successful, otherwise E_NOINTERFACE
//                  if we cannot support the requested interface.
//***************************************************************************

STDMETHODIMP CLocatorFactory::CreateInstance(
                        IN LPUNKNOWN pUnkOuter,
                        IN REFIID riid, 
                        OUT PPVOID ppvObj)
{
    IUnknown *   pObj = NULL;
    HRESULT             hr;

    *ppvObj=NULL;
    hr=E_OUTOFMEMORY;

    // This object doesnt support aggregation.

    if (NULL!=pUnkOuter)
        return ResultFromScode(CLASS_E_NOAGGREGATION);

    //Create the object passing function to notify on destruction.
    
    if(m_dwType == LOCATOR)
        pObj=new CLocator();
    else if(m_dwType == ADMINLOC)
        pObj= new CProviderLoc(ADMINLOC);
    else if(m_dwType == AUTHLOC)
        pObj= new CProviderLoc(AUTHLOC);
    else if(m_dwType == UNAUTHLOC)
        pObj= new CProviderLoc(UNAUTHLOC);

    if (NULL==pObj)
        return hr;

    hr=pObj->QueryInterface(riid, ppvObj);

    //Kill the object if initial creation or Init failed.
    if (FAILED(hr))
        delete pObj;
    return hr;
}

//***************************************************************************
//
//  SCODE CLocatorFactory::LockServer
//
//  Description:
//
//  Increments or decrements the lock count of the DLL.  If the
//  lock count goes to zero and there are no objects, the DLL
//  is allowed to unload.  See DllCanUnloadNow.
//
//  Parameters:
//
//  fLock           BOOL specifying whether to increment or
//                  decrement the lock count.
//
//  Return Value:
// 
//  HRESULT         NOERROR always.
//***************************************************************************


STDMETHODIMP CLocatorFactory::LockServer(IN BOOL fLock)
{
    if (fLock)
        InterlockedIncrement((long *)&g_cLock);
    else
        InterlockedDecrement((long *)&g_cLock);

    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\marshalers\wbemprox\comtrans.cpp ===
/*++

Copyright (C) 1998-2001 Microsoft Corporation

Module Name:

    COMTRANS.CPP

Abstract:

    Connects via COM

History:

    a-davj  13-Jan-98   Created.

--*/

#include "precomp.h"
#include <wbemidl.h>
#include <wbemint.h>
#include <reg.h>
#include <wbemutil.h>
#include <objidl.h>
#include <cominit.h>
#include "wbemprox.h"
#include "comtrans.h"
#include <winntsec.h>
#include <genutils.h>
#include <arrtempl.h>
#include <wmiutils.h>
#include <strsafe.h>
#include <winsock2.h>
#include <autoptr.h>

// The following should not be changed since 9x boxes to not support privacy.
#define AUTH_LEVEL RPC_C_AUTHN_LEVEL_DEFAULT   

class CSocketInit
{
    private:
        bool m_bInitDone;
    public:
        CSocketInit() : m_bInitDone(false){};
        int Init();
        ~CSocketInit(){if(m_bInitDone) WSACleanup ();};
};

int CSocketInit::Init()
{
    WORD wVersionRequested;
    WSADATA wsaData;
    int err;
    wVersionRequested = MAKEWORD( 2, 2 );
    int iRet = WSAStartup (wVersionRequested, & wsaData);
    if(iRet == 0)
        m_bInitDone = true;
    return iRet;
}

BOOL bGotDot(char * pTest)
{
    if(pTest == NULL)
        return FALSE;
    for(;*pTest && *pTest != '.'; pTest++);  // intentional semi
    if(*pTest == '.')
        return TRUE;
    else
        return FALSE;
 }
 
struct hostent * GetFQDN(WCHAR * pServer)
{
    SIZE_T Len = wcslen(pServer);
    SIZE_T LenAnsi = 4*Len;
    wmilib::auto_buffer<CHAR> pAnsiServerName(new CHAR[LenAnsi+1]);
    ULONG BytesCopyed = 0;
    //
    // Use the same routine that RPCRT4 uses
    //
    NTSTATUS Status = RtlUnicodeToMultiByteN(pAnsiServerName.get(),LenAnsi,&BytesCopyed,pServer,Len*sizeof(WCHAR));
    if (0 != Status) return NULL;
    pAnsiServerName[BytesCopyed] = 0;
    
    // if it is an ip string

    long lIP = inet_addr(pAnsiServerName.get());
    if(lIP != INADDR_NONE)
    {
        struct hostent * pRet = gethostbyaddr((char *)&lIP, 4, AF_INET );
        if(pRet && pRet->h_name)
        {
            // search the returned name for at least one dot.  Sometimes, gethostbyaddr will just return
            // the lanman name and not the fqdn.

            if(bGotDot(pRet->h_name))
                return pRet;            // normal case, all is well!

            // try passing the short name to get the fqdn version

            DWORD dwLen = lstrlenA(pRet->h_name) + 1;
            char * pNew = new char[dwLen];
            if(pNew == NULL)
                return NULL;
            CVectorDeleteMe<char> dm2(pNew);
            StringCchCopyA(pNew, dwLen, pRet->h_name);
            pRet = gethostbyname(pNew);
            if(pRet && bGotDot(pRet->h_name))
                return pRet;            // normal case, all is well!
        }
    }
    return gethostbyname(pAnsiServerName.get());  
}

#define PREFIXSTR L"RPCSS/"

HRESULT BuildReturnString(WCHAR * pFQDN, WCHAR ** ppResult)
{
    if(pFQDN == NULL)
        return WBEM_E_INVALID_PARAMETER;
    DWORD dwBuffLen = wcslen(pFQDN) + wcslen(PREFIXSTR) + 1;
    *ppResult = new WCHAR[dwBuffLen];
    if(*ppResult == NULL)
        return WBEM_E_OUT_OF_MEMORY;
    StringCchCopy(*ppResult, dwBuffLen, PREFIXSTR);
    StringCchCat(*ppResult, dwBuffLen, pFQDN);
    return S_OK;
}

HRESULT GetPrincipal(WCHAR * pServerMachine, WCHAR ** ppResult, BOOL &bLocal, CSocketInit & sock)
{

    DWORD dwLocalFQDNLen = 0;
    DWORD dwBuffLen;
    WCHAR * pwsCurrentCompFQDN = NULL;
    bLocal = FALSE;
    *ppResult = NULL;
    
    // Get the current computer name in FQDN format

    BOOL bRet = GetComputerNameEx(ComputerNameDnsFullyQualified, NULL, &dwLocalFQDNLen);
    if(bRet || GetLastError() != ERROR_MORE_DATA)
        return MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32,GetLastError());
    dwLocalFQDNLen++;                // add one for the null
    pwsCurrentCompFQDN = new WCHAR[dwLocalFQDNLen];
    if(pwsCurrentCompFQDN == NULL)
        return WBEM_E_OUT_OF_MEMORY;
    CVectorDeleteMe<WCHAR> dm(pwsCurrentCompFQDN);
    bRet = GetComputerNameEx(ComputerNameDnsFullyQualified, pwsCurrentCompFQDN, &dwLocalFQDNLen);
    if(!bRet)
        return MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32,GetLastError());
    
    // if the name is "." or equal to the current machine, no need to do much fancy work here
    
    if(bAreWeLocal ( pServerMachine ))
    {
        bLocal = TRUE;
        return BuildReturnString(pwsCurrentCompFQDN, ppResult);
    }
  
    // probably not local.  Use sockets to establish the FQDN of the server

    if(0 != sock.Init())
        return MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32,GetLastError());
   
    struct hostent * pEnt = GetFQDN(pServerMachine);
    if(pEnt == NULL || pEnt->h_name == NULL)
    {
        // we failed.  just return the best we can
        return BuildReturnString(pServerMachine, ppResult);
    }

    // all is well.  Convert the host name to WCHAR.
    
    DWORD dwHostLen = lstrlenA(pEnt->h_name) + 1;
    WCHAR * pwsHostFQDN = new WCHAR[dwHostLen];
    if(pwsHostFQDN == NULL)
        return WBEM_E_OUT_OF_MEMORY;
    CVectorDeleteMe<WCHAR> dm2(pwsHostFQDN);
    mbstowcs(pwsHostFQDN, pEnt->h_name, dwHostLen);

    // now there is the possibility that they specified the ip of the local machine.
    // In that case, set the bLocal in case caller needs to know this
    
    if(wbem_wcsicmp(pwsHostFQDN, pwsCurrentCompFQDN) == 0)
        bLocal = TRUE;

    // now, make the actual string.

    return BuildReturnString(pwsHostFQDN, ppResult);
}

//***************************************************************************
//
//  CDCOMTrans::CDCOMTrans
//
//  DESCRIPTION:
//
//  Constructor.
//
//***************************************************************************

CDCOMTrans::CDCOMTrans()
{
    m_cRef=0;
    m_pLevel1 = NULL;
    InterlockedIncrement(&g_cObj);
    m_bInitialized = TRUE;
}

//***************************************************************************
//
//  CDCOMTrans::~CDCOMTrans
//
//  DESCRIPTION:
//
//  Destructor.
//
//***************************************************************************

CDCOMTrans::~CDCOMTrans(void)
{
    if(m_pLevel1)
        m_pLevel1->Release();
    InterlockedDecrement(&g_cObj);
}

//***************************************************************************
// HRESULT CDCOMTrans::QueryInterface
// long CDCOMTrans::AddRef
// long CDCOMTrans::Release
//
// DESCRIPTION:
//
// Standard Com IUNKNOWN functions.
//
//***************************************************************************

STDMETHODIMP CDCOMTrans::QueryInterface (

    IN REFIID riid,
    OUT PPVOID ppv
)
{
    *ppv=NULL;


    if (m_bInitialized && (IID_IUnknown==riid || riid == IID_IWbemClientTransport))
        *ppv=(IWbemClientTransport *)this;

    if (NULL!=*ppv)
    {
        ((LPUNKNOWN)*ppv)->AddRef();
        return NOERROR;
    }

    return ResultFromScode(E_NOINTERFACE);
}

bool IsImpersonating(SECURITY_IMPERSONATION_LEVEL &impLevel)
{
    HANDLE hThreadToken;
    bool bImpersonating = false;
    if(OpenThreadToken(GetCurrentThread(), TOKEN_QUERY, TRUE,
                                &hThreadToken))
    {

        DWORD dwBytesReturned = 0;
        if(GetTokenInformation(
            hThreadToken,
            TokenImpersonationLevel,
            &impLevel,
            sizeof(DWORD),
            &dwBytesReturned
            ) && ((SecurityImpersonation == impLevel) ||
                   (SecurityDelegation == impLevel)))
                bImpersonating = true;
        CloseHandle(hThreadToken);
    }
    return bImpersonating;
}

//***************************************************************************
//
//  IsLocalConnection(IWbemLevel1Login * pLogin)
//
//  DESCRIPTION:
//
//  Querries the server to see if this is a local connection.  This is done
//  by creating a event and asking the server to set it.  This will only work
//  if the server is the same box.
//
//  RETURN VALUE:
//
//  true if the server is the same box.
//
//***************************************************************************


BOOL IsLocalConnection(IUnknown * pInterface)
{
    IRpcOptions *pRpcOpt = NULL;
    ULONG_PTR dwProperty = 0;
    HRESULT hr = pInterface->QueryInterface(IID_IRpcOptions, (void**)&pRpcOpt);
    //DbgPrintfA(0,"QueryInterface(IID_IRpcOptions) hr = %08x\n",hr);
    if (SUCCEEDED(hr))
    {
        hr = pRpcOpt->Query(pInterface, COMBND_SERVER_LOCALITY, &dwProperty);
        pRpcOpt->Release();
        if (SUCCEEDED(hr))
            return (SERVER_LOCALITY_REMOTE == dwProperty)?FALSE:TRUE;
    } 
    else if (E_NOINTERFACE == hr) // real pointer, not a proxy
    {
        return TRUE;
    }
    return FALSE;
}

//***************************************************************************
//
//  SetClientIdentity
//
//  DESCRIPTION:
//
//  Passes the machine name and process id to the server.  Failure is not
//  serious since this is debugging type info in any case.
//
//***************************************************************************

void  SetClientIdentity(IUnknown * pLogin, bool bSet, BSTR PrincipalArg, DWORD dwAuthenticationLevel,
             COAUTHIDENTITY *pauthident, DWORD dwCapabilities, DWORD dwAuthnSvc)
{
    bool bRet = false;
    IWbemLoginClientID * pLoginHelper = NULL;
    SCODE sc = pLogin->QueryInterface(IID_IWbemLoginClientID, (void **)&pLoginHelper);
    if(sc != S_OK)
        return;

    if(bSet)
        sc = WbemSetProxyBlanket(
                            pLoginHelper,
                            dwAuthnSvc,
                            RPC_C_AUTHZ_NONE,
                            PrincipalArg,
                            dwAuthenticationLevel,
                            RPC_C_IMP_LEVEL_IMPERSONATE,
                            pauthident,
                            dwCapabilities);

    CReleaseMe rm(pLoginHelper);
    TCHAR tcMyName[MAX_COMPUTERNAME_LENGTH + 1];
    DWORD dwSize = MAX_COMPUTERNAME_LENGTH + 1;
    if(!GetComputerName(tcMyName,&dwSize))
        return;
    long lProcID = GetCurrentProcessId();
    pLoginHelper->SetClientInfo(tcMyName, lProcID, 0); 
}

SCODE CDCOMTrans::DoConnection(         
            BSTR NetworkResource,               
            BSTR User,
            BSTR Password,
            BSTR Locale,
            long lFlags,                 
            BSTR Authority,                  
            IWbemContext *pCtx,                 
            IWbemServices **pInterface)
{
    HRESULT hr = DoActualConnection(NetworkResource, User, Password, Locale,
            lFlags, Authority, pCtx, pInterface);

    if(hr == 0x800706be)
    {
        ERRORTRACE((LOG_WBEMPROX,"Initial connection failed with 0x800706be, retrying\n"));
        Sleep(5000);
        hr = DoActualConnection(NetworkResource, User, Password, Locale,
            lFlags, Authority, pCtx, pInterface);
    }
    return hr;
}

SCODE CDCOMTrans::DoActualConnection(         
            BSTR NetworkResource,               
            BSTR User,
            BSTR Password,
            BSTR Locale,
            long lFlags,                 
            BSTR Authority,                  
            IWbemContext *pCtx,                 
            IWbemServices **pInterface)
{

    BSTR AuthArg = NULL, UserArg = NULL;
    
    // this is the pricipal as extracted from the optional Authority argument
    BSTR PrincipalArg = NULL;                               

    // this is the pricipal which is calculated from the server name in the path
    WCHAR * pwCalculatedPrincipal = NULL;         

    bool bAuthenticate = true;
    bool bSet = false;
    CSocketInit sock;
    
    SCODE sc = WBEM_E_FAILED;

    sc = DetermineLoginTypeEx(AuthArg, UserArg, PrincipalArg, Authority, User);
    if(sc != S_OK)
    {
        ERRORTRACE((LOG_WBEMPROX, "Cannot determine Login type, Authority = %S, User = %S\n",Authority, User));
        return sc;
    }
    CSysFreeMe fm1(AuthArg);
    CSysFreeMe fm2(UserArg);
    CSysFreeMe fm3(PrincipalArg);

    // Determine if it is local

    WCHAR *t_ServerMachine = ExtractMachineName ( NetworkResource ) ;
    if ( t_ServerMachine == NULL )
    {
        ERRORTRACE((LOG_WBEMPROX, "Cannot extract machine name -%S-\n", NetworkResource));
        return WBEM_E_INVALID_PARAMETER ;
    }
    CVectorDeleteMe<WCHAR> dm(t_ServerMachine);

    BOOL t_Local;
    if(PrincipalArg == NULL)
    {
        sc = GetPrincipal(t_ServerMachine, &pwCalculatedPrincipal, t_Local, sock);
        if(FAILED(sc))
        {
            t_Local = bAreWeLocal(t_ServerMachine);
            ERRORTRACE((LOG_WBEMPROX, "GetPrincipal(%S) hr = %08x\n",t_ServerMachine,sc));
        }
        else
        {
            DEBUGTRACE((LOG_WBEMPROX, "Using the principal -%S-\n", pwCalculatedPrincipal));
        }
    }
    else
        t_Local = bAreWeLocal(t_ServerMachine);
        
    CVectorDeleteMe<WCHAR> dm2(pwCalculatedPrincipal);

    SECURITY_IMPERSONATION_LEVEL impLevel = SecurityImpersonation;
    bool bImpersonatingThread = IsImpersonating (impLevel);
    bool bCredentialsSpecified = (UserArg || AuthArg || Password);

    // Setup the authentication structures

    COSERVERINFO si;
    si.pwszName = t_ServerMachine;
    si.dwReserved1 = 0;
    si.dwReserved2 = 0;
    si.pAuthInfo = NULL;

    COAUTHINFO ai;
    si.pAuthInfo = &ai;

    ai.dwAuthzSvc = RPC_C_AUTHZ_NONE;
    if(PrincipalArg)
    {
        ai.dwAuthnSvc = RPC_C_AUTHN_GSS_KERBEROS;    
        ai.pwszServerPrincName = PrincipalArg;
    }
    else if (pwCalculatedPrincipal)
    {
        ai.dwAuthnSvc = RPC_C_AUTHN_GSS_NEGOTIATE;
        ai.pwszServerPrincName = pwCalculatedPrincipal;        
    } 
    else
    {
        ai.dwAuthnSvc = RPC_C_AUTHN_WINNT;
        ai.pwszServerPrincName = NULL;        
    }
    ai.dwAuthnLevel = AUTH_LEVEL;
    ai.dwImpersonationLevel = RPC_C_IMP_LEVEL_IMPERSONATE;
    ai.dwCapabilities = 0;

    COAUTHIDENTITY authident;

    if(bCredentialsSpecified)
    {
        // Load up the structure.
        memset((void *)&authident,0,sizeof(COAUTHIDENTITY));
        if(UserArg)
        {
            authident.UserLength = wcslen(UserArg);
            authident.User = (LPWSTR)UserArg;
        }
        if(AuthArg)
        {
            authident.DomainLength = wcslen(AuthArg);
            authident.Domain = (LPWSTR)AuthArg;
        }
        if(Password)
        {
            authident.PasswordLength = wcslen(Password);
            authident.Password = (LPWSTR)Password;
        }
        authident.Flags = SEC_WINNT_AUTH_IDENTITY_UNICODE;
        ai.pAuthIdentityData = &authident;
    }
    else
        ai.pAuthIdentityData = NULL;
    
    // Get the IWbemLevel1Login pointer

    sc = DoCCI(&si ,t_Local, lFlags);

    if((sc == 0x800706d3 || sc == 0x800706ba) && !t_Local)
    {
        // If we are going to a stand alone dcom box, try again with the authentication level lowered

        ai.dwAuthnLevel = RPC_C_AUTHN_LEVEL_NONE;
        SCODE hr = DoCCI(&si ,t_Local, lFlags);
        if(hr == S_OK)
        {
            sc = S_OK;
            bAuthenticate = false;
        }
    }

    if(sc != S_OK)
        return sc;

    // Set the values  used for CoSetProxyBlanket calls.  If the principal was passed in via the Authority 
    // argument, then it is used and kerberos is forced.  Otherwise, the values will be set based on 
    // querying the Proxy it will be either NULL (if NTLM is used) or COLE_DEFAULT_PRINCIPAL.  
    
    DWORD dwAuthnSvc = RPC_C_AUTHN_WINNT;
    WCHAR * pwCSPBPrincipal = NULL;          
    if(PrincipalArg)
    {
        dwAuthnSvc = RPC_C_AUTHN_GSS_KERBEROS;
        pwCSPBPrincipal = PrincipalArg;
    }      
    else
    {

        DWORD dwQueryAuthnLevel, dwQueryImpLevel, dwQueryCapabilities;
        HRESULT hr = CoQueryProxyBlanket(
                                                m_pLevel1,      //Location for the proxy to query
                                                &dwAuthnSvc,      //Location for the current authentication service
                                                NULL,      //Location for the current authorization service
                                                NULL,      //Location for the current principal name
                                                &dwQueryAuthnLevel,    //Location for the current authentication level
                                                &dwQueryImpLevel,      //Location for the current impersonation level
                                                NULL,
                                                &dwQueryCapabilities   //Location for flags indicating further capabilities of the proxy
                                                );

        if(SUCCEEDED(hr) && dwAuthnSvc != RPC_C_AUTHN_WINNT)
        {
            pwCSPBPrincipal = COLE_DEFAULT_PRINCIPAL;
        }
        else
        {
            dwAuthnSvc = RPC_C_AUTHN_WINNT;
            pwCSPBPrincipal = NULL;          
        }
    }
    
    // The authentication level is set based on having to go to a share level box or not.  The 
    // capabilities are set based on if we are an impersonating thread or not

    DWORD dwAuthenticationLevel, dwCapabilities;
    if(bAuthenticate)
        dwAuthenticationLevel = AUTH_LEVEL;
    else
        dwAuthenticationLevel = RPC_C_AUTHN_LEVEL_NONE;

    if(bImpersonatingThread && !UserArg) 
        dwCapabilities = EOAC_STATIC_CLOAKING;
    else
        dwCapabilities = EOAC_NONE;
    
    // Do the security negotiation

    if(!t_Local)
    {
        // Suppress the SetBlanket call if we are on a Win2K delegation-level thread with implicit credentials
        if (!(bImpersonatingThread && !bCredentialsSpecified && (SecurityDelegation == impLevel)))
        {
            // Note that if we are on a Win2K impersonating thread with no user specified
            // we should allow DCOM to use whatever EOAC capabilities are set up for this
            // application.  This allows remote connections with NULL User/Password but
            // non-NULL authority to succeed.

            sc = WbemSetProxyBlanket(
                            m_pLevel1,
                            dwAuthnSvc,
                            RPC_C_AUTHZ_NONE,
                            pwCSPBPrincipal,
                            dwAuthenticationLevel,
                            RPC_C_IMP_LEVEL_IMPERSONATE,
                            (bCredentialsSpecified) ? &authident : NULL,
                            dwCapabilities);

            bSet = true;
            if(sc != S_OK)
            {
                ERRORTRACE((LOG_WBEMPROX,"Error setting Level1 login interface security pointer, return code is 0x%x\n", sc));
                return sc;
            }
        }
    }
    else                                // LOCAL case
    {
        // if impersonating set cloaking

        if(bImpersonatingThread)
        {
            sc = WbemSetProxyBlanket(
                        m_pLevel1,
                        RPC_C_AUTHN_WINNT,
                        RPC_C_AUTHZ_NONE,
                        NULL,
                        dwAuthenticationLevel,
                        RPC_C_IMP_LEVEL_IMPERSONATE,
                        NULL,
                        EOAC_STATIC_CLOAKING);
            if(sc != S_OK && sc != 0x80004002)  // no such interface is ok since you get that when
                                                // called inproc!
            {
                ERRORTRACE((LOG_WBEMPROX,"Error setting Level1 login interface security pointer, return code is 0x%x\n", sc));
                return sc;
            }
        }

    }

    SetClientIdentity(m_pLevel1, bSet, PrincipalArg, 
                             dwAuthenticationLevel, 
                             &authident, 
                             dwCapabilities, 
                             dwAuthnSvc);
    if(bCredentialsSpecified && IsLocalConnection(m_pLevel1))
    {
        ERRORTRACE((LOG_WBEMPROX,"Credentials were specified for a local connections\n"));
        return WBEM_E_LOCAL_CREDENTIALS;
     }

    // The MAX_WAIT flag only applies to CoCreateInstanceEx, get rid of it
    
    lFlags = lFlags & ~WBEM_FLAG_CONNECT_USE_MAX_WAIT;
    sc = m_pLevel1->NTLMLogin(NetworkResource, Locale, lFlags, pCtx,(IWbemServices**) pInterface);

    if(sc == 0x800706d3 && !t_Local) // RPC_S_UNKNOWN_AUTHN_SERVICE
    {
        // If we are going to a stand alone dcom box, try again with the authentication level lowered
        ERRORTRACE((LOG_WBEMPROX,"Attempt to connect to %S returned RPC_S_UNKNOWN_AUTHN_SERVICE\n",NetworkResource));
        HRESULT hr;
        hr = SetInterfaceSecurityAuth(m_pLevel1, &authident, false);
        if (SUCCEEDED(hr))
                hr = m_pLevel1->NTLMLogin(NetworkResource, Locale, lFlags, pCtx, (IWbemServices**)pInterface);
        if(hr == S_OK)
        {
             SetInterfaceSecurityAuth((IUnknown *)*pInterface, &authident, false);
        }
    }
    else
        if(SUCCEEDED(sc) && bAuthenticate == false &&  !t_Local)
        {

            // this is used to support share level boxs.  The scripting code is written to expect that
            // the IWbemServices pointer is ready to use and so it must be lowered before returning.
            
            WbemSetProxyBlanket(*pInterface, RPC_C_AUTHN_WINNT, RPC_C_AUTHZ_NONE, NULL,
                RPC_C_AUTHN_LEVEL_NONE, RPC_C_IMP_LEVEL_IDENTIFY, NULL, EOAC_NONE);
        }

    if(FAILED(sc))
            ERRORTRACE((LOG_WBEMPROX,"NTLMLogin resulted in hr = 0x%x\n", sc));
    return sc;
}




struct WaitThreadArg
{
    DWORD m_dwThreadId;
    HANDLE m_hTerminate;
};

DWORD WINAPI TimeoutThreadRoutine(LPVOID lpParameter)
{

    WaitThreadArg * pReq = (WaitThreadArg *)lpParameter;
    DWORD dwRet = WaitForSingleObject(pReq->m_hTerminate, 60000);
    if(dwRet == WAIT_TIMEOUT)
    {
        HRESULT hr = CoInitializeEx(NULL,COINIT_MULTITHREADED ); 
        if(FAILED(hr))
           return 1;
        ICancelMethodCalls * px = NULL;
        hr = CoGetCancelObject(pReq->m_dwThreadId, IID_ICancelMethodCalls,
            (void **)&px);
        if(SUCCEEDED(hr))
        {
            hr = px->Cancel(0);
            px->Release();
        }
        CoUninitialize();
    }
    return 0;
}

//***************************************************************************
//
//  DoCCI
//
//  DESCRIPTION:
//
//  Connects up to WBEM via DCOM.  But before making the call, a thread cancel
//  thread may be created to handle the case where we try to connect up
//  to a box which is hanging
//
//  PARAMETERS:
//
//  NetworkResource     Namespze path
//  ppLogin             set to Login proxy
//  bLocal              Indicates if connection is local
//  lFlags				Mainly used for WBEM_FLAG_CONNECT_USE_MAX_WAIT flag
//
//  RETURN VALUE:
//
//  S_OK                all is well
//  else error listed in WBEMSVC.H
//
//***************************************************************************

SCODE CDCOMTrans::DoCCI (IN COSERVERINFO * psi, IN BOOL bLocal, long lFlags )
{

    if(lFlags & WBEM_FLAG_CONNECT_USE_MAX_WAIT)
    {
        // special case.  we want to spawn off a thread that will kill of our
        // request if it takes too long

        WaitThreadArg arg;
        arg.m_hTerminate = CreateEvent(NULL, FALSE, FALSE, NULL);
        if(arg.m_hTerminate == NULL)
            return WBEM_E_OUT_OF_MEMORY;
        CCloseMe cm(arg.m_hTerminate);
        arg.m_dwThreadId = GetCurrentThreadId();

        DWORD dwIDLikeIcare;
        HRESULT hr = CoEnableCallCancellation(NULL);
        if(FAILED(hr))
            return hr;
        HANDLE hThread = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)TimeoutThreadRoutine, 
                                     (LPVOID)&arg, 0, &dwIDLikeIcare);
        if(hThread == NULL)
        {
            CoDisableCallCancellation(NULL);
            return WBEM_E_OUT_OF_MEMORY;
        }
        CCloseMe cm2(hThread);
        hr = DoActualCCI (psi, bLocal, 
                        lFlags & ~WBEM_FLAG_CONNECT_USE_MAX_WAIT );
        CoDisableCallCancellation(NULL);
        SetEvent(arg.m_hTerminate);
        WaitForSingleObject(hThread, INFINITE);
        return hr;
    }
    else
        return DoActualCCI (psi, bLocal, lFlags );
}

//***************************************************************************
//
//  DoActualCCI
//
//  DESCRIPTION:
//
//  Connects up to WBEM via DCOM.
//
//  PARAMETERS:
//
//  NetworkResource     Namespze path
//  ppLogin             set to Login proxy
//  bLocal              Indicates if connection is local
//  lFlags				Not used
//
//  RETURN VALUE:
//
//  S_OK                all is well
//  else error listed in WBEMSVC.H
//
//***************************************************************************

SCODE CDCOMTrans::DoActualCCI (IN COSERVERINFO * psi, IN BOOL bLocal, long lFlags )
{
    HRESULT t_Result ;
    MULTI_QI   mqi;

    mqi.pIID = &IID_IWbemLevel1Login;
    mqi.pItf = 0;
    mqi.hr = 0;

    t_Result = CoCreateInstanceEx (
        CLSID_WbemLevel1Login,
        NULL,
        CLSCTX_LOCAL_SERVER | CLSCTX_REMOTE_SERVER,
        ( bLocal ) ? NULL : psi ,
        1,
        &mqi
    );

    if ( t_Result == S_OK )
    {
        m_pLevel1 = (IWbemLevel1Login*) mqi.pItf ;
        DEBUGTRACE((LOG_WBEMPROX,"ConnectViaDCOM, CoCreateInstanceEx resulted in hr = 0x%x\n", t_Result ));
    }
    else
    {
        ERRORTRACE((LOG_WBEMPROX,"ConnectViaDCOM, CoCreateInstanceEx resulted in hr = 0x%x\n", t_Result ));
    }

    return t_Result ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\marshalers\wbemprox\comtrans.h ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

    COMTRANS.H

Abstract:

    Declares the COM based transport class.

History:

	a-davj  04-Mar-97   Created.

--*/

#ifndef _DCOMTran_H_
#define _DCOMTran_H_

typedef void ** PPVOID;

//***************************************************************************
//
//  CLASS NAME:
//
//  CDCOMTran
//
//  DESCRIPTION:
//
//  Implements the DCOM version of CCOMTrans class.
//
//***************************************************************************

class CDCOMTrans : IUnknown
{
protected:
        long            m_cRef;         //Object reference count
        IWbemLevel1Login * m_pLevel1;
        BOOL m_bInitialized;
    
public:
    CDCOMTrans();
    ~CDCOMTrans();

    SCODE DoCCI (
        IN COSERVERINFO *psi ,
        IN BOOL a_Local,
        long lFlags);

    SCODE DoActualCCI (
        IN COSERVERINFO *psi ,
        IN BOOL a_Local,
        long lFlags);

    SCODE DoConnection(         
            BSTR NetworkResource,               
            BSTR User,
            BSTR Password,
            BSTR Locale,
            long lSecurityFlags,                 
            BSTR Authority,                  
            IWbemContext *pCtx,                 
            IWbemServices **pInterface);
            
    SCODE DoActualConnection(         
            BSTR NetworkResource,               
            BSTR User,
            BSTR Password,
            BSTR Locale,
            long lSecurityFlags,                 
            BSTR Authority,                  
            IWbemContext *pCtx,                 
            IWbemServices **pInterface);

    //Non-delegating object IUnknown
    STDMETHODIMP         QueryInterface(REFIID, PPVOID);
    STDMETHODIMP_(ULONG) AddRef(void)
    {
        InterlockedIncrement(&m_cRef);
        return m_cRef;
    }

    STDMETHODIMP_(ULONG) Release(void)
    {
        long lTemp = InterlockedDecrement(&m_cRef);
        if (0!= lTemp)
            return lTemp;
        delete this;
        return 0;
    }

};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\marshalers\wbemprox\makefile.inc ===
!INCLUDE $(_NTDRIVE)$(_NTROOT)\WMI\COMMON\makefile.cmn
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\marshalers\wbemprox\cprovloc.cpp ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

    CPROVLOC.CPP

Abstract:

    Defines the CProviderLoc object

History:

    davj  30-Oct-00   Created.

--*/

#include "precomp.h"
#include <wbemidl.h>
#include <wbemint.h>
#include <reg.h>
#include <wbemutil.h>
#include <wbemprox.h>
#include <flexarry.h>
#include <strsafe.h>
#include "cprovloc.h"
#include "comtrans.h"
#include <arrtempl.h>

#define IsSlash(x) (x == L'\\' || x== L'/')

//***************************************************************************
//
//  CProviderLoc::CProviderLoc
//
//  DESCRIPTION:
//
//  Constructor.
//
//***************************************************************************

CProviderLoc::CProviderLoc(DWORD dwType)
{
    m_cRef=0;
    InterlockedIncrement(&g_cObj);
    m_dwType = dwType;
}

//***************************************************************************
//
//  CProviderLoc::~CProviderLoc
//
//  DESCRIPTION:
//
//  Destructor.
//  
//***************************************************************************

CProviderLoc::~CProviderLoc(void)
{
    InterlockedDecrement(&g_cObj);
}

//***************************************************************************
// HRESULT CProviderLoc::QueryInterface
//
// DESCRIPTION:
//
// Standard Com IUNKNOWN functions.
//
//***************************************************************************

STDMETHODIMP CProviderLoc::QueryInterface (

    IN REFIID riid,
    OUT PPVOID ppv
)
{
    *ppv=NULL;

    if (IID_IUnknown==riid || riid == IID_IWbemLocator)
        *ppv=this;

    if (NULL!=*ppv)
    {
        ((LPUNKNOWN)*ppv)->AddRef();
        return NOERROR;
    }

    return ResultFromScode(E_NOINTERFACE);
}


//***************************************************************************
//
//  SCODE CProviderLoc::ConnectServer
//
//  DESCRIPTION:
//
//  Connects up to either local or remote WBEM Server.  Returns
//  standard SCODE and more importantly sets the address of an initial
//  stub pointer.
//
//  PARAMETERS:
//
//  NetworkResource     Namespace path
//  User                User name
//  Password            password
//  LocaleId            language locale
//  lFlags              flags
//  Authority           domain
//  ppProv              set to provdider proxy
//
//  RETURN VALUE:
//
//  S_OK                all is well
//  else error listed in WBEMSVC.H
//
//***************************************************************************

SCODE CProviderLoc::ConnectServer (
    IN const BSTR NetworkResource,
    IN const BSTR User,
    IN const BSTR Password,
    IN const BSTR LocaleId,
    IN long lFlags,
    IN const BSTR Authority,
    IWbemContext __RPC_FAR *pCtx,
    OUT IWbemServices FAR* FAR* ppProv
)
{
    SCODE sc = S_OK;
    BOOL bOutOfProc = FALSE;            // Set below
    IWbemLocator * pActualLocator = NULL;
    IWbemLevel1Login * pLevel1 = NULL;
    if(NetworkResource == NULL || ppProv == NULL)
        return WBEM_E_INVALID_PARAMETER;

    // make sure they are not specifying a server

    LPWSTR ObjectPath = NetworkResource;
    if (IsSlash(ObjectPath[0]) && IsSlash(ObjectPath[1]))
    {
        if(!IsSlash(ObjectPath[3]) || ObjectPath[2] != L'.')
            return WBEM_E_INVALID_PARAMETER;
    }

    // Get the normal login pointer.

    sc = CoCreateInstance(CLSID_WbemLevel1Login, NULL, 
           CLSCTX_LOCAL_SERVER | CLSCTX_INPROC_SERVER, IID_IWbemLevel1Login,(void **)&pLevel1);
    
    if(FAILED(sc))
        return sc;
    CReleaseMe rm(pLevel1);

    // determine if winmgmt is inproc.  Do so by checking if there is an IClientSecurity interface

    IClientSecurity * pCliSec = NULL;
    sc = pLevel1->QueryInterface(IID_IClientSecurity, (void **)&pCliSec);
    if(SUCCEEDED(sc) && pCliSec)
    {
        // We are out of proc, then use the current dcomtrans logic

        pCliSec->Release();
        CDCOMTrans * pDcomTrans = new CDCOMTrans;
        if(pDcomTrans == NULL)
            return WBEM_E_OUT_OF_MEMORY;
        pDcomTrans->AddRef();
        sc = pDcomTrans->DoConnection(NetworkResource, User, Password, LocaleId, lFlags,                 
                Authority, pCtx, ppProv);
        pDcomTrans->Release();
        return sc;
    }

    // If we are inproc, get the class from wbemcore.dll and forward the call on to it.

    switch(m_dwType)
    {
    case ADMINLOC:
        sc = CoCreateInstance(CLSID_ActualWbemAdministrativeLocator, NULL, 
                    CLSCTX_INPROC_SERVER, IID_IWbemLocator,(void **)&pActualLocator);
        break;
    case AUTHLOC:
        sc = CoCreateInstance(CLSID_ActualWbemAuthenticatedLocator, NULL, 
                    CLSCTX_INPROC_SERVER, IID_IWbemLocator,(void **)&pActualLocator);
        break;
    case UNAUTHLOC:
        sc = CoCreateInstance(CLSID_ActualWbemUnauthenticatedLocator, NULL, 
                    CLSCTX_INPROC_SERVER, IID_IWbemLocator,(void **)&pActualLocator);
        break;
    default:
        return WBEM_E_FAILED;
    }

    if(FAILED(sc))
        return sc;
    CReleaseMe rm3(pActualLocator);
    sc = pActualLocator->ConnectServer(NetworkResource, User, Password, LocaleId,
                                lFlags, Authority, pCtx, ppProv);
    return sc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\marshalers\wbemprox\cprovloc.h ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

    CPROVLOC.H

Abstract:

	Declares the CProviderLoc class.

History:

	davj  30-Oct-00   Created.

--*/

#ifndef _cprovloc_H_
#define _cprovloc_H_

typedef void ** PPVOID;


//***************************************************************************
//
//  CLASS NAME:
//
//  CProviderLoc
//
//  DESCRIPTION:
//
//  Implements the IWbemLocator interface.  This support the formally inproc
//  logins used by providers.  
//
//***************************************************************************

class CProviderLoc : public IWbemLocator
    {
    protected:
        long            m_cRef;         //Object reference count
        DWORD           m_dwType;
    public:
    
    CProviderLoc(DWORD dwType);
    ~CProviderLoc(void);

    //Non-delegating object IUnknown
    STDMETHODIMP         QueryInterface(REFIID, PPVOID);
    STDMETHODIMP_(ULONG) AddRef(void)
	{
		InterlockedIncrement(&m_cRef);
		return m_cRef;
	}
    STDMETHODIMP_(ULONG) Release(void)
	{
		long lTemp = InterlockedDecrement(&m_cRef);
		if (0L!=lTemp)
			return lTemp;
		delete this;
		return 0;
	}
 
	/* iWbemLocator methods */
	STDMETHOD(ConnectServer)(THIS_ const BSTR NetworkResource, const BSTR User, 
     const BSTR Password, const BSTR lLocaleId, long lFlags, const BSTR Authority,
     IWbemContext __RPC_FAR *pCtx,
     IWbemServices FAR* FAR* ppNamespace);

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\mc\makefile.inc ===
!INCLUDE $(_NTDRIVE)$(_NTROOT)\WMI\COMMON\makefile.cmn
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\marshalers\wbemprox\locator.cpp ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

    LOCATOR.CPP

Abstract:

    Defines the Locator object

History:

    a-davj  15-Aug-96   Created.

--*/

#include "precomp.h"
#include <wbemidl.h>
#include <wbemint.h>
#include <reg.h>
#include <wbemutil.h>
#include <wbemprox.h>
#include <flexarry.h>
#include "locator.h"
#include "comtrans.h"
#include <arrtempl.h>
#include <helper.h>
#include <strsafe.h>

//***************************************************************************
//
//  CLocator::CLocator
//
//  DESCRIPTION:
//
//  Constructor.
//
//***************************************************************************

CLocator::CLocator()
{
    m_cRef=0;
    InterlockedIncrement(&g_cObj);
}

//***************************************************************************
//
//  CLocator::~CLocator
//
//  DESCRIPTION:
//
//  Destructor.
//  
//***************************************************************************

CLocator::~CLocator(void)
{
    InterlockedDecrement(&g_cObj);
}

//***************************************************************************
// HRESULT CLocator::QueryInterface
//
// DESCRIPTION:
//
// Standard Com IUNKNOWN functions.
//
//***************************************************************************

STDMETHODIMP CLocator::QueryInterface (

    IN REFIID riid,
    OUT PPVOID ppv
)
{
    *ppv=NULL;

    if (IID_IUnknown==riid || riid == IID_IWbemLocator)
        *ppv=this;

    if (NULL!=*ppv)
    {
        ((LPUNKNOWN)*ppv)->AddRef();
        return NOERROR;
    }

    return ResultFromScode(E_NOINTERFACE);
}

///////////////////////////////////////////////

BOOL IsWinMgmtShutdown(void)
{
    HMODULE hMudule = NULL;
    if (GetModuleHandleEx(0,L"wmisvc.dll",&hMudule))
    {
        OnDelete<HMODULE,BOOL(*)(HMODULE),FreeLibrary> FreeMe(hMudule);

        BOOL (WINAPI * fnIsWinMgmtDown)(VOID);
        fnIsWinMgmtDown = (BOOL (WINAPI *)(VOID))GetProcAddress(hMudule,"IsShutDown");
        if (fnIsWinMgmtDown) return fnIsWinMgmtDown();
    }
    return FALSE;
}


//***************************************************************************
//
//  SCODE CLocator::ConnectServer
//
//  DESCRIPTION:
//
//  Connects up to either local or remote WBEM Server.  Returns
//  standard SCODE and more importantly sets the address of an initial
//  stub pointer.
//
//  PARAMETERS:
//
//  NetworkResource     Namespace path
//  User                User name
//  Password            password
//  LocaleId            language locale
//  lFlags              flags
//  Authority           domain
//  ppProv              set to provdider proxy
//
//  RETURN VALUE:
//
//  S_OK                all is well
//  else error listed in WBEMSVC.H
//
//***************************************************************************

SCODE CLocator::ConnectServer (

    IN const BSTR NetworkResource,
    IN const BSTR User,
    IN const BSTR Password,
    IN const BSTR LocaleId,
    IN long lFlags,
    IN const BSTR Authority,
    IWbemContext __RPC_FAR *pCtx,
    OUT IWbemServices FAR* FAR* ppProv
)
{
    if (IsWinMgmtShutdown()) return CO_E_SERVER_STOPPING;


    long lRes;
    SCODE sc = WBEM_E_TRANSPORT_FAILURE;
    
    // Verify the arguments

    if(NetworkResource == NULL || ppProv == NULL)
        return WBEM_E_INVALID_PARAMETER;

    CDCOMTrans * pComTrans = new CDCOMTrans();
    if(pComTrans == NULL)
        return WBEM_E_OUT_OF_MEMORY;
    pComTrans->AddRef();
    sc = pComTrans->DoConnection(NetworkResource, User, Password, LocaleId, lFlags, Authority, 
            pCtx, ppProv);
    pComTrans->Release();
    return sc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\marshalers\wbemprox\maindll.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    MAINDLL.CPP

Abstract:

    Contains DLL entry points.  Also has code that controls
    when the DLL can be unloaded by tracking the number of
    objects and locks.

History:

    a-davj  15-Aug-96   Created.

--*/

#include "precomp.h"
#include <wbemidl.h>
#include <wbemutil.h>
#include <genutils.h>
#include <cominit.h>
#include <reg.h>
#include "wbemprox.h"
#include <initguid.h>
#include <wbemint.h>
#include <strsafe.h>


//Count number of objects and number of locks.

long       g_cObj=0;
ULONG       g_cLock=0;
HMODULE ghModule;


//***************************************************************************
//
//  BOOL WINAPI DllMain
//
//  DESCRIPTION:
//
//  Entry point for DLL.  Good place for initialization.
//
//  PARAMETERS:
//
//  hInstance           instance handle
//  ulReason            why we are being called
//  pvReserved          reserved
//
//  RETURN VALUE:
//
//  TRUE if OK.
//
//***************************************************************************

BOOL WINAPI DllMain(
                        IN HINSTANCE hInstance,
                        IN ULONG ulReason,
                        LPVOID pvReserved)
{
    if(ghModule == NULL)
    {
        ghModule = hInstance;
        DisableThreadLibraryCalls ( hInstance ) ;
    }
    if (DLL_PROCESS_DETACH==ulReason)
    {
        return TRUE;
    }
    else
    {
        if (DLL_PROCESS_ATTACH!=ulReason)
        {
        }
    }

    return TRUE;
}

//***************************************************************************
//
//  STDAPI DllGetClassObject
//
//  DESCRIPTION:
//
//  Called when Ole wants a class factory.  Return one only if it is the sort
//  of class this DLL supports.
//
//  PARAMETERS:
//
//  rclsid              CLSID of the object that is desired.
//  riid                ID of the desired interface.
//  ppv                 Set to the class factory.
//
//  RETURN VALUE:
//
//  S_OK                all is well
//  E_FAILED            not something we support
//  
//***************************************************************************

STDAPI DllGetClassObject(
                        IN REFCLSID rclsid,
                        IN REFIID riid,
                        OUT PPVOID ppv)
{
    HRESULT hr;
    CLocatorFactory *pObj = NULL;

    if (CLSID_WbemLocator == rclsid)
        pObj=new CLocatorFactory(LOCATOR);
    else if(CLSID_WbemAdministrativeLocator == rclsid)
        pObj=new CLocatorFactory(ADMINLOC);
    else if(CLSID_WbemAuthenticatedLocator == rclsid)
        pObj=new CLocatorFactory(AUTHLOC);
    else if(CLSID_WbemUnauthenticatedLocator == rclsid)
        pObj=new CLocatorFactory(UNAUTHLOC);

    if(pObj == NULL)
        return E_FAIL;

    if (NULL==pObj)
        return ResultFromScode(E_OUTOFMEMORY);

    hr=pObj->QueryInterface(riid, ppv);

    if (FAILED(hr))
        delete pObj;

    return hr;
}

//***************************************************************************
//
//  STDAPI DllCanUnloadNow
//
//  DESCRIPTION:
//
//  Answers if the DLL can be freed, that is, if there are no
//  references to anything this DLL provides.
//
//  RETURN VALUE:
//
//  S_OK                if it is OK to unload
//  S_FALSE             if still in use
//  
//***************************************************************************

STDAPI DllCanUnloadNow(void)
{
    SCODE   sc;

    //It is OK to unload if there are no objects or locks on the
    // class factory.

    sc=(0L==g_cObj && 0L==g_cLock) ? S_OK : S_FALSE;
    return ResultFromScode(sc);
}

//***************************************************************************
//
// DllRegisterServer
//
// Purpose: Called during setup or by regsvr32.
//
// Return:  NOERROR if registration successful, error otherwise.
//***************************************************************************

#define LocatorPROGID __TEXT("WBEMComLocator")
#define ConnectionPROGID __TEXT("WBEMComConnection")

STDAPI DllRegisterServer(void)
{ 
   RegisterDLL(ghModule, CLSID_WbemLocator, __TEXT("WBEM Locator"), __TEXT("Both"), LocatorPROGID);
   RegisterDLL(ghModule, CLSID_WbemAdministrativeLocator, __TEXT(""), __TEXT("Both"), NULL);
   RegisterDLL(ghModule, CLSID_WbemAuthenticatedLocator, __TEXT(""), __TEXT("Both"), NULL);
   RegisterDLL(ghModule, CLSID_WbemUnauthenticatedLocator, __TEXT(""), __TEXT("Both"), NULL);
   return S_OK;
}

//***************************************************************************
//
// DllUnregisterServer
//
// Purpose: Called when it is time to remove the registry entries.
//
// Return:  NOERROR if registration successful, error otherwise.
//***************************************************************************

STDAPI DllUnregisterServer(void)
{
    UnRegisterDLL(CLSID_WbemLocator,LocatorPROGID);
    UnRegisterDLL(CLSID_WbemAdministrativeLocator, NULL);
    UnRegisterDLL(CLSID_WbemAuthenticatedLocator, NULL);
    UnRegisterDLL(CLSID_WbemUnauthenticatedLocator, NULL);
    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\marshalers\wbemprox\locator.h ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

    LOCATOR.H

Abstract:

    Declares the CLocator class.

History:

    a-davj  04-Mar-97   Created.

--*/

#ifndef _locator_H_
#define _locator_H_

typedef void ** PPVOID;

//***************************************************************************
//
//  CLASS NAME:
//
//  CLocator
//
//  DESCRIPTION:
//
//  Implements the IWbemLocator interface.  This class is what the client gets
//  when it initially hooks up to the Wbemprox.dll.  The ConnectServer function
//  is what get the communication between client and server started.
//
//***************************************************************************

class CLocator : public IWbemLocator
    {
    protected:
        long            m_cRef;         //Object reference count
    public:
    
    CLocator();
    ~CLocator(void);

    BOOL Init(void);

    //Non-delegating object IUnknown
    STDMETHODIMP         QueryInterface(REFIID, PPVOID);
    STDMETHODIMP_(ULONG) AddRef(void)
    {
        InterlockedIncrement(&m_cRef);
        return m_cRef;
    }
    STDMETHODIMP_(ULONG) Release(void)
    {
        long lTemp = InterlockedDecrement(&m_cRef);
        if (0L!=lTemp)
            return lTemp;
        delete this;
        return 0;
    }
 
    /* iWbemLocator methods */
    STDMETHOD(ConnectServer)(THIS_ const BSTR NetworkResource, const BSTR User, 
     const BSTR Password, const BSTR lLocaleId, long lFlags, const BSTR Authority,
     IWbemContext __RPC_FAR *pCtx,
     IWbemServices FAR* FAR* ppNamespace);

};



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\minimfc\makefile.inc ===
!INCLUDE $(_NTDRIVE)$(_NTROOT)\WMI\COMMON\makefile.cmn
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\marshalers\wbemprox\wbemprox.h ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

    WBEMPROX.H

Abstract:

    Genral purpose include file.

History:

	a-davj  04-Mar-97   Created.

--*/

#ifndef _WBEMPROX_H_
#define _WBEMPROX_H_

typedef LPVOID * PPVOID;

// These variables keep track of when the module can be unloaded

extern long       g_cObj;
extern ULONG       g_cLock;

// This enumerator defines objects created and destroyed by this dll.

enum OBJTYPE{CLASS_FACTORY = 0, LOCATOR,  ADMINLOC,
             AUTHLOC, UNAUTHLOC, MAX_CLIENT_OBJECT_TYPES};

#define GUID_SIZE 39


//***************************************************************************
//
//  CLASS NAME:
//
//  CLocatorFactory
//
//  DESCRIPTION:
//
//  Class factory for the CLocator class.
//
//***************************************************************************

class CLocatorFactory : public IClassFactory
    {
    protected:
        long           m_cRef;
        DWORD          m_dwType;
    public:
        CLocatorFactory(DWORD dwType);
        ~CLocatorFactory(void);

        //IUnknown members
        STDMETHODIMP         QueryInterface(REFIID, PPVOID);
        STDMETHODIMP_(ULONG) AddRef(void);
        STDMETHODIMP_(ULONG) Release(void);

        //IClassFactory members
        STDMETHODIMP         CreateInstance(LPUNKNOWN, REFIID
                                 , PPVOID);
        STDMETHODIMP         LockServer(BOOL);
    };

    
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\marshalers\wbemprox\precomp.h ===
/*++

Copyright (C) 1999-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#define WIN32_NO_STATUS

#pragma warning (disable : 4786)
#include <ole2.h>
#include <windows.h>
#include <comdef.h>
#include <strsafe.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\minimfc\array_p.cpp ===
/*++

Copyright (C) 1992-2001 Microsoft Corporation

Module Name:

    ARRAY_P.CPP

Abstract:

History:

--*/


// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1993 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and Microsoft
// QuickHelp and/or WinHelp documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

/////////////////////////////////////////////////////////////////////////////
//
// Implementation of parameterized Array
//
/////////////////////////////////////////////////////////////////////////////
// NOTE: we allocate an array of 'm_nMaxSize' elements, but only
//  the current size 'm_nSize' contains properly constructed
//  objects.


#include "precomp.h"

#define ASSERT_VALID(x)
#define ASSERT(x)


/////////////////////////////////////////////////////////////////////////////

CPtrArray::CPtrArray()
{
    m_pData = NULL;
    m_nSize = m_nMaxSize = m_nGrowBy = 0;
}

CPtrArray::~CPtrArray()
{
    ASSERT_VALID(this);

    delete (BYTE*) m_pData;
}

BOOL CPtrArray::SetSize(int nNewSize, int nGrowBy /* = -1 */)
{
    ASSERT_VALID(this);
    ASSERT(nNewSize >= 0);

    if (nGrowBy != -1)
        m_nGrowBy = nGrowBy;  // set new size

    if (nNewSize == 0)
    {
        // shrink to nothing
        delete (BYTE *) m_pData;
        m_pData = NULL;
        m_nSize = m_nMaxSize = 0;
    }
    else if (m_pData == NULL)
    {
        // create one with exact size
#ifdef SIZE_T_MAX
        ASSERT((long)nNewSize * sizeof(void*) <= SIZE_T_MAX);  // no overflow
#endif
        m_pData = (void**) new BYTE[nNewSize * sizeof(void*)];
        if(m_pData == NULL)
            return FALSE;

        memset(m_pData, 0, nNewSize * sizeof(void*));  // zero fill

        m_nSize = m_nMaxSize = nNewSize;
    }
    else if (nNewSize <= m_nMaxSize)
    {
        // it fits
        if (nNewSize > m_nSize)
        {
            // initialize the new elements

            memset(&m_pData[m_nSize], 0, (nNewSize-m_nSize) * sizeof(void*));

        }

        m_nSize = nNewSize;
    }
    else
    {
        // Otherwise grow array
        int nNewMax;
        if (nNewSize < m_nMaxSize + m_nGrowBy)
            nNewMax = m_nMaxSize + m_nGrowBy;  // granularity
        else
            nNewMax = nNewSize;  // no slush

#ifdef SIZE_T_MAX
        ASSERT((long)nNewMax * sizeof(void*) <= SIZE_T_MAX);  // no overflow
#endif
        void** pNewData = (void**) new BYTE[nNewMax * sizeof(void*)];
        if(pNewData == NULL)
            return FALSE;

        // copy new data from old
        memcpy(pNewData, m_pData, m_nSize * sizeof(void*));

        // construct remaining elements
        ASSERT(nNewSize > m_nSize);

        memset(&pNewData[m_nSize], 0, (nNewSize-m_nSize) * sizeof(void*));


        // get rid of old stuff (note: no destructors called)
        delete (BYTE*)m_pData;
        m_pData = pNewData;
        m_nSize = nNewSize;
        m_nMaxSize = nNewMax;
    }
    return TRUE;
}

void CPtrArray::FreeExtra()
{
    ASSERT_VALID(this);

    if (m_nSize != m_nMaxSize)
    {
        // shrink to desired size
#ifdef SIZE_T_MAX
        ASSERT((long)m_nSize * sizeof(void*) <= SIZE_T_MAX);  // no overflow
#endif
        void** pNewData = NULL;
        if (m_nSize != 0)
        {
            pNewData = (void**) new BYTE[m_nSize * sizeof(void*)];
            // copy new data from old
            memcpy(pNewData, m_pData, m_nSize * sizeof(void*));
        }

        // get rid of old stuff (note: no destructors called)
        delete (BYTE*)m_pData;
        m_pData = pNewData;
        m_nMaxSize = m_nSize;
    }
}

/////////////////////////////////////////////////////////////////////////////

BOOL CPtrArray::SetAtGrow(int nIndex, void* newElement)
{
    ASSERT_VALID(this);
    ASSERT(nIndex >= 0);

    if (nIndex >= m_nSize)
    {
        if(!SetSize(nIndex+1))
            return FALSE;
    }
    m_pData[nIndex] = newElement;
    return TRUE;
}

void CPtrArray::InsertAt(int nIndex, void* newElement, int nCount /*=1*/)
{
    ASSERT_VALID(this);
    ASSERT(nIndex >= 0);    // will expand to meet need
    ASSERT(nCount > 0);     // zero or negative size not allowed

    if (nIndex >= m_nSize)
    {
        // adding after the end of the array
        SetSize(nIndex + nCount);  // grow so nIndex is valid
    }
    else
    {
        // inserting in the middle of the array
        int nOldSize = m_nSize;
        SetSize(m_nSize + nCount);  // grow it to new size
        // shift old data up to fill gap
        memmove(&m_pData[nIndex+nCount], &m_pData[nIndex],
            (nOldSize-nIndex) * sizeof(void*));

        // re-init slots we copied from

        memset(&m_pData[nIndex], 0, nCount * sizeof(void*));

    }

    // insert new value in the gap
    ASSERT(nIndex + nCount <= m_nSize);
    while (nCount--)
        m_pData[nIndex++] = newElement;
}

void CPtrArray::RemoveAt(int nIndex, int nCount /* = 1 */)
{
    ASSERT_VALID(this);
    ASSERT(nIndex >= 0);
    ASSERT(nCount >= 0);
    ASSERT(nIndex + nCount <= m_nSize);

    // just remove a range
    int nMoveCount = m_nSize - (nIndex + nCount);

    if (nMoveCount)
        memcpy(&m_pData[nIndex], &m_pData[nIndex + nCount],
            nMoveCount * sizeof(void*));
    m_nSize -= nCount;
}

void CPtrArray::InsertAt(int nStartIndex, CPtrArray* pNewArray)
{
    ASSERT_VALID(this);
    ASSERT(pNewArray != NULL);
    ASSERT(pNewArray->IsKindOf(RUNTIME_CLASS(CPtrArray)));
    ASSERT_VALID(pNewArray);
    ASSERT(nStartIndex >= 0);

    if (pNewArray->GetSize() > 0)
    {
        InsertAt(nStartIndex, pNewArray->GetAt(0), pNewArray->GetSize());
        for (int i = 0; i < pNewArray->GetSize(); i++)
            SetAt(nStartIndex + i, pNewArray->GetAt(i));
    }
}

/////////////////////////////////////////////////////////////////////////////
// Serialization


/////////////////////////////////////////////////////////////////////////////
// Diagnostics

/* 
#ifdef _DEBUG
void CPtrArray::Dump(CDumpContext& dc) const
{
    ASSERT_VALID(this);

#define MAKESTRING(x) #x
    AFX_DUMP1(dc, "a " MAKESTRING(CPtrArray) " with ", m_nSize);
    AFX_DUMP0(dc, " elements");
#undef MAKESTRING
    if (dc.GetDepth() > 0)
    {
        AFX_DUMP0(dc, "\n");
        for (int i = 0; i < m_nSize; i++)
        {
            AFX_DUMP1(dc, "\n\t[", i);
            AFX_DUMP1(dc, "] = ", m_pData[i]);
        }
    }
}

void CPtrArray::AssertValid() const
{
    CObject::AssertValid();
    if (m_pData == NULL)
    {
        ASSERT(m_nSize == 0);
        ASSERT(m_nMaxSize == 0);
    }
    else
    {
        ASSERT(m_nSize >= 0);
        ASSERT(m_nMaxSize >= 0);
        ASSERT(m_nSize <= m_nMaxSize);
        ASSERT(AfxIsValidAddress(m_pData, m_nMaxSize * sizeof(void*)));
    }
}
#endif //_DEBUG
*/
/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\minimfc\array_d.cpp ===
/*++

Copyright (C) 1994-2001 Microsoft Corporation

Module Name:

    ARRAY_D.CPP

Abstract:

    MiniAFX implementation.  09/25/94 TSE.

History:

--*/


#include "precomp.h"

#define ASSERT(x)
#define ASSERT_VALID(x)


/////////////////////////////////////////////////////////////////////////////

CDWordArray::CDWordArray()
{
    m_pData = NULL;
    m_nSize = m_nMaxSize = m_nGrowBy = 0;
}

CDWordArray::~CDWordArray()
{
    ASSERT_VALID(this);

    delete (BYTE*)m_pData;
}

void CDWordArray::SetSize(int nNewSize, int nGrowBy /* = -1 */)
{
    ASSERT_VALID(this);
    ASSERT(nNewSize >= 0);

    if (nGrowBy != -1)
        m_nGrowBy = nGrowBy;  // set new size

    if (nNewSize == 0)
    {
        // shrink to nothing
        delete (BYTE*)m_pData;
        m_pData = NULL;
        m_nSize = m_nMaxSize = 0;
    }
    else if (m_pData == NULL)
    {
        // create one with exact size
#ifdef SIZE_T_MAX
        ASSERT((long)nNewSize * sizeof(DWORD) <= SIZE_T_MAX);  // no overflow
#endif
        m_pData = (DWORD*) new BYTE[nNewSize * sizeof(DWORD)];

        memset(m_pData, 0, nNewSize * sizeof(DWORD));  // zero fill

        m_nSize = m_nMaxSize = nNewSize;
    }
    else if (nNewSize <= m_nMaxSize)
    {
        // it fits
        if (nNewSize > m_nSize)
        {
            // initialize the new elements

            memset(&m_pData[m_nSize], 0, (nNewSize-m_nSize) * sizeof(DWORD));

        }

        m_nSize = nNewSize;
    }
    else
    {
        // Otherwise grow array
        int nNewMax;
        if (nNewSize < m_nMaxSize + m_nGrowBy)
            nNewMax = m_nMaxSize + m_nGrowBy;  // granularity
        else
            nNewMax = nNewSize;  // no slush

#ifdef SIZE_T_MAX
        ASSERT((long)nNewMax * sizeof(DWORD) <= SIZE_T_MAX);  // no overflow
#endif
        DWORD* pNewData = (DWORD*) new BYTE[nNewMax * sizeof(DWORD)];

        // copy new data from old
        memcpy(pNewData, m_pData, m_nSize * sizeof(DWORD));

        // construct remaining elements
        ASSERT(nNewSize > m_nSize);

        memset(&pNewData[m_nSize], 0, (nNewSize-m_nSize) * sizeof(DWORD));


        // get rid of old stuff (note: no destructors called)
        delete (BYTE*)m_pData;
        m_pData = pNewData;
        m_nSize = nNewSize;
        m_nMaxSize = nNewMax;
    }
}

void CDWordArray::FreeExtra()
{
    ASSERT_VALID(this);

    if (m_nSize != m_nMaxSize)
    {
        // shrink to desired size
#ifdef SIZE_T_MAX
        ASSERT((long)m_nSize * sizeof(DWORD) <= SIZE_T_MAX);  // no overflow
#endif
        DWORD* pNewData = NULL;
        if (m_nSize != 0)
        {
            pNewData = (DWORD*) new BYTE[m_nSize * sizeof(DWORD)];
            // copy new data from old
            memcpy(pNewData, m_pData, m_nSize * sizeof(DWORD));
        }

        // get rid of old stuff (note: no destructors called)
        delete (BYTE*)m_pData;
        m_pData = pNewData;
        m_nMaxSize = m_nSize;
    }
}

/////////////////////////////////////////////////////////////////////////////

void CDWordArray::SetAtGrow(int nIndex, DWORD newElement)
{
    ASSERT_VALID(this);
    ASSERT(nIndex >= 0);

    if (nIndex >= m_nSize)
        SetSize(nIndex+1);
    m_pData[nIndex] = newElement;
}

void CDWordArray::InsertAt(int nIndex, DWORD newElement, int nCount /*=1*/)
{
    ASSERT_VALID(this);
    ASSERT(nIndex >= 0);    // will expand to meet need
    ASSERT(nCount > 0);     // zero or negative size not allowed

    if (nIndex >= m_nSize)
    {
        // adding after the end of the array
        SetSize(nIndex + nCount);  // grow so nIndex is valid
    }
    else
    {
        // inserting in the middle of the array
        int nOldSize = m_nSize;
        SetSize(m_nSize + nCount);  // grow it to new size
        // shift old data up to fill gap
        memmove(&m_pData[nIndex+nCount], &m_pData[nIndex],
            (nOldSize-nIndex) * sizeof(DWORD));

        // re-init slots we copied from

        memset(&m_pData[nIndex], 0, nCount * sizeof(DWORD));

    }

    // insert new value in the gap
    ASSERT(nIndex + nCount <= m_nSize);
    while (nCount--)
        m_pData[nIndex++] = newElement;
}

void CDWordArray::RemoveAt(int nIndex, int nCount /* = 1 */)
{
    ASSERT_VALID(this);
    ASSERT(nIndex >= 0);
    ASSERT(nCount >= 0);
    ASSERT(nIndex + nCount <= m_nSize);

    // just remove a range
    int nMoveCount = m_nSize - (nIndex + nCount);

    if (nMoveCount)
        memcpy(&m_pData[nIndex], &m_pData[nIndex + nCount],
            nMoveCount * sizeof(DWORD));
    m_nSize -= nCount;
}

void CDWordArray::InsertAt(int nStartIndex, CDWordArray* pNewArray)
{
    ASSERT_VALID(this);
    ASSERT(pNewArray != NULL);
    ASSERT(pNewArray->IsKindOf(RUNTIME_CLASS(CDWordArray)));
    ASSERT_VALID(pNewArray);
    ASSERT(nStartIndex >= 0);

    if (pNewArray->GetSize() > 0)
    {
        InsertAt(nStartIndex, pNewArray->GetAt(0), pNewArray->GetSize());
        for (int i = 0; i < pNewArray->GetSize(); i++)
            SetAt(nStartIndex + i, pNewArray->GetAt(i));
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\minimfc\array_s.cpp ===
/*++

Copyright (C) 1992-2001 Microsoft Corporation

Module Name:

    ARRAY_S.CPP

Abstract:

History:

--*/


// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1993 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and Microsoft
// QuickHelp and/or WinHelp documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

/////////////////////////////////////////////////////////////////////////////
//
// Implementation of parameterized Array
//
/////////////////////////////////////////////////////////////////////////////
// NOTE: we allocate an array of 'm_nMaxSize' elements, but only
//  the current size 'm_nSize' contains properly constructed
//  objects.


#include "precomp.h"

#define ASSERT_VALID(x)
#define ASSERT(x)


#include "elements.h"  // used for special creation

static void  ConstructElements(CString* pNewData, int nCount)
{
    ASSERT(nCount >= 0);

    while (nCount--)
    {
        ConstructElement(pNewData);
        pNewData++;
    }
}

static void  DestructElements(CString* pOldData, int nCount)
{
    ASSERT(nCount >= 0);

    while (nCount--)
    {
        pOldData->Empty();
        pOldData++;
    }
}

/////////////////////////////////////////////////////////////////////////////

CStringArray::CStringArray()
{
    m_pData = NULL;
    m_nSize = m_nMaxSize = m_nGrowBy = 0;
}

CStringArray::~CStringArray()
{
    ASSERT_VALID(this);


    DestructElements(m_pData, m_nSize);
    delete (BYTE*)m_pData;
}

void CStringArray::SetSize(int nNewSize, int nGrowBy /* = -1 */)
{
    ASSERT_VALID(this);
    ASSERT(nNewSize >= 0);

    if (nGrowBy != -1)
        m_nGrowBy = nGrowBy;  // set new size

    if (nNewSize == 0)
    {
        // shrink to nothing

        DestructElements(m_pData, m_nSize);
        delete (BYTE*)m_pData;
        m_pData = NULL;
        m_nSize = m_nMaxSize = 0;
    }
    else if (m_pData == NULL)
    {
        // create one with exact size
#ifdef SIZE_T_MAX
        ASSERT((long)nNewSize * sizeof(CString) <= SIZE_T_MAX);  // no overflow
#endif
        m_pData = (CString*) new BYTE[nNewSize * sizeof(CString)];

        ConstructElements(m_pData, nNewSize);

        m_nSize = m_nMaxSize = nNewSize;
    }
    else if (nNewSize <= m_nMaxSize)
    {
        // it fits
        if (nNewSize > m_nSize)
        {
            // initialize the new elements

            ConstructElements(&m_pData[m_nSize], nNewSize-m_nSize);

        }

        else if (m_nSize > nNewSize)  // destroy the old elements
            DestructElements(&m_pData[nNewSize], m_nSize-nNewSize);

        m_nSize = nNewSize;
    }
    else
    {
        // Otherwise grow array
        int nNewMax;
        if (nNewSize < m_nMaxSize + m_nGrowBy)
            nNewMax = m_nMaxSize + m_nGrowBy;  // granularity
        else
            nNewMax = nNewSize;  // no slush

#ifdef SIZE_T_MAX
        ASSERT((long)nNewMax * sizeof(CString) <= SIZE_T_MAX);  // no overflow
#endif
        CString* pNewData = (CString*) new BYTE[nNewMax * sizeof(CString)];

        // copy new data from old
        memcpy(pNewData, m_pData, m_nSize * sizeof(CString));

        // construct remaining elements
        ASSERT(nNewSize > m_nSize);

        ConstructElements(&pNewData[m_nSize], nNewSize-m_nSize);


        // get rid of old stuff (note: no destructors called)
        delete (BYTE*)m_pData;
        m_pData = pNewData;
        m_nSize = nNewSize;
        m_nMaxSize = nNewMax;
    }
}

void CStringArray::FreeExtra()
{
    ASSERT_VALID(this);

    if (m_nSize != m_nMaxSize)
    {
        // shrink to desired size
#ifdef SIZE_T_MAX
        ASSERT((long)m_nSize * sizeof(CString) <= SIZE_T_MAX);  // no overflow
#endif
        CString* pNewData = NULL;
        if (m_nSize != 0)
        {
            pNewData = (CString*) new BYTE[m_nSize * sizeof(CString)];
            // copy new data from old
            memcpy(pNewData, m_pData, m_nSize * sizeof(CString));
        }

        // get rid of old stuff (note: no destructors called)
        delete (BYTE*)m_pData;
        m_pData = pNewData;
        m_nMaxSize = m_nSize;
    }
}

/////////////////////////////////////////////////////////////////////////////

void CStringArray::SetAtGrow(int nIndex, const char* newElement)
{
    ASSERT_VALID(this);
    ASSERT(nIndex >= 0);

    if (nIndex >= m_nSize)
        SetSize(nIndex+1);
    m_pData[nIndex] = newElement;
}

void CStringArray::InsertAt(int nIndex, const char* newElement, int nCount /*=1*/)
{
    ASSERT_VALID(this);
    ASSERT(nIndex >= 0);    // will expand to meet need
    ASSERT(nCount > 0);     // zero or negative size not allowed

    if (nIndex >= m_nSize)
    {
        // adding after the end of the array
        SetSize(nIndex + nCount);  // grow so nIndex is valid
    }
    else
    {
        // inserting in the middle of the array
        int nOldSize = m_nSize;
        SetSize(m_nSize + nCount);  // grow it to new size
        // shift old data up to fill gap
        memmove(&m_pData[nIndex+nCount], &m_pData[nIndex],
            (nOldSize-nIndex) * sizeof(CString));

        // re-init slots we copied from

        ConstructElements(&m_pData[nIndex], nCount);

    }

    // insert new value in the gap
    ASSERT(nIndex + nCount <= m_nSize);
    while (nCount--)
        m_pData[nIndex++] = newElement;
}

void CStringArray::RemoveAt(int nIndex, int nCount /* = 1 */)
{
    ASSERT_VALID(this);
    ASSERT(nIndex >= 0);
    ASSERT(nCount >= 0);
    ASSERT(nIndex + nCount <= m_nSize);

    // just remove a range
    int nMoveCount = m_nSize - (nIndex + nCount);

    DestructElements(&m_pData[nIndex], nCount);

    if (nMoveCount)
        memcpy(&m_pData[nIndex], &m_pData[nIndex + nCount],
            nMoveCount * sizeof(CString));
    m_nSize -= nCount;
}

void CStringArray::InsertAt(int nStartIndex, CStringArray* pNewArray)
{
    ASSERT_VALID(this);
    ASSERT(pNewArray != NULL);
    ASSERT(pNewArray->IsKindOf(RUNTIME_CLASS(CStringArray)));
    ASSERT_VALID(pNewArray);
    ASSERT(nStartIndex >= 0);

    if (pNewArray->GetSize() > 0)
    {
        InsertAt(nStartIndex, pNewArray->GetAt(0), pNewArray->GetSize());
        for (int i = 0; i < pNewArray->GetSize(); i++)
            SetAt(nStartIndex + i, pNewArray->GetAt(i));
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\minimfc\array_w.cpp ===
/*++

Copyright (C) 1992-2001 Microsoft Corporation

Module Name:

    ARRAY_W.CPP

Abstract:

History:

--*/


// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1993 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and Microsoft
// QuickHelp and/or WinHelp documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

/////////////////////////////////////////////////////////////////////////////
//
// Implementation of parameterized Array
//
/////////////////////////////////////////////////////////////////////////////
// NOTE: we allocate an array of 'm_nMaxSize' elements, but only
//  the current size 'm_nSize' contains properly constructed
//  objects.

#include "precomp.h"

#define ASSERT(x)
#define ASSERT_VALID(x)



/////////////////////////////////////////////////////////////////////////////

CWordArray::CWordArray()
{
    m_pData = NULL;
    m_nSize = m_nMaxSize = m_nGrowBy = 0;
}

CWordArray::~CWordArray()
{
    ASSERT_VALID(this);

    delete (BYTE*)m_pData;
}

void CWordArray::SetSize(int nNewSize, int nGrowBy /* = -1 */)
{
    ASSERT_VALID(this);
    ASSERT(nNewSize >= 0);

    if (nGrowBy != -1)
        m_nGrowBy = nGrowBy;  // set new size

    if (nNewSize == 0)
    {
        // shrink to nothing
        delete (BYTE*)m_pData;
        m_pData = NULL;
        m_nSize = m_nMaxSize = 0;
    }
    else if (m_pData == NULL)
    {
        // create one with exact size
#ifdef SIZE_T_MAX
        ASSERT((long)nNewSize * sizeof(WORD) <= SIZE_T_MAX);  // no overflow
#endif
        m_pData = (WORD*) new BYTE[nNewSize * sizeof(WORD)];

        memset(m_pData, 0, nNewSize * sizeof(WORD));  // zero fill

        m_nSize = m_nMaxSize = nNewSize;
    }
    else if (nNewSize <= m_nMaxSize)
    {
        // it fits
        if (nNewSize > m_nSize)
        {
            // initialize the new elements

            memset(&m_pData[m_nSize], 0, (nNewSize-m_nSize) * sizeof(WORD));

        }

        m_nSize = nNewSize;
    }
    else
    {
        // Otherwise grow array
        int nNewMax;
        if (nNewSize < m_nMaxSize + m_nGrowBy)
            nNewMax = m_nMaxSize + m_nGrowBy;  // granularity
        else
            nNewMax = nNewSize;  // no slush

#ifdef SIZE_T_MAX
        ASSERT((long)nNewMax * sizeof(WORD) <= SIZE_T_MAX);  // no overflow
#endif
        WORD* pNewData = (WORD*) new BYTE[nNewMax * sizeof(WORD)];

        // copy new data from old
        memcpy(pNewData, m_pData, m_nSize * sizeof(WORD));

        // construct remaining elements
        ASSERT(nNewSize > m_nSize);

        memset(&pNewData[m_nSize], 0, (nNewSize-m_nSize) * sizeof(WORD));


        // get rid of old stuff (note: no destructors called)
        delete (BYTE*)m_pData;
        m_pData = pNewData;
        m_nSize = nNewSize;
        m_nMaxSize = nNewMax;
    }
}

void CWordArray::FreeExtra()
{
    ASSERT_VALID(this);

    if (m_nSize != m_nMaxSize)
    {
        // shrink to desired size
#ifdef SIZE_T_MAX
        ASSERT((long)m_nSize * sizeof(WORD) <= SIZE_T_MAX);  // no overflow
#endif
        WORD* pNewData = NULL;
        if (m_nSize != 0)
        {
            pNewData = (WORD*) new BYTE[m_nSize * sizeof(WORD)];
            // copy new data from old
            memcpy(pNewData, m_pData, m_nSize * sizeof(WORD));
        }

        // get rid of old stuff (note: no destructors called)
        delete (BYTE*)m_pData;
        m_pData = pNewData;
        m_nMaxSize = m_nSize;
    }
}

/////////////////////////////////////////////////////////////////////////////

void CWordArray::SetAtGrow(int nIndex, WORD newElement)
{
    ASSERT_VALID(this);
    ASSERT(nIndex >= 0);

    if (nIndex >= m_nSize)
        SetSize(nIndex+1);
    m_pData[nIndex] = newElement;
}

void CWordArray::InsertAt(int nIndex, WORD newElement, int nCount /*=1*/)
{
    ASSERT_VALID(this);
    ASSERT(nIndex >= 0);    // will expand to meet need
    ASSERT(nCount > 0);     // zero or negative size not allowed

    if (nIndex >= m_nSize)
    {
        // adding after the end of the array
        SetSize(nIndex + nCount);  // grow so nIndex is valid
    }
    else
    {
        // inserting in the middle of the array
        int nOldSize = m_nSize;
        SetSize(m_nSize + nCount);  // grow it to new size
        // shift old data up to fill gap
        memmove(&m_pData[nIndex+nCount], &m_pData[nIndex],
            (nOldSize-nIndex) * sizeof(WORD));

        // re-init slots we copied from

        memset(&m_pData[nIndex], 0, nCount * sizeof(WORD));

    }

    // insert new value in the gap
    ASSERT(nIndex + nCount <= m_nSize);
    while (nCount--)
        m_pData[nIndex++] = newElement;
}

void CWordArray::RemoveAt(int nIndex, int nCount /* = 1 */)
{
    ASSERT_VALID(this);
    ASSERT(nIndex >= 0);
    ASSERT(nCount >= 0);
    ASSERT(nIndex + nCount <= m_nSize);

    // just remove a range
    int nMoveCount = m_nSize - (nIndex + nCount);

    if (nMoveCount)
        memcpy(&m_pData[nIndex], &m_pData[nIndex + nCount],
            nMoveCount * sizeof(WORD));
    m_nSize -= nCount;
}

void CWordArray::InsertAt(int nStartIndex, CWordArray* pNewArray)
{
    ASSERT_VALID(this);
    ASSERT(pNewArray != NULL);
    ASSERT(pNewArray->IsKindOf(RUNTIME_CLASS(CWordArray)));
    ASSERT_VALID(pNewArray);
    ASSERT(nStartIndex >= 0);

    if (pNewArray->GetSize() > 0)
    {
        InsertAt(nStartIndex, pNewArray->GetAt(0), pNewArray->GetSize());
        for (int i = 0; i < pNewArray->GetSize(); i++)
            SetAt(nStartIndex + i, pNewArray->GetAt(i));
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\minimfc\plex.h ===
/*++

Copyright (C) 1992-2001 Microsoft Corporation

Module Name:

    PLEX.H

Abstract:

History:

--*/

// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1993 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and Microsoft
// QuickHelp and/or WinHelp documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#ifndef __PLEX_H__
#define __PLEX_H__

struct CPlex    // warning variable length structure
{
	CPlex* pNext;
	UINT nMax;
	UINT nCur;
	/* BYTE data[maxNum*elementSize]; */

	void* data() { return this+1; }

	static CPlex* Create(CPlex*& head, UINT nMax, UINT cbElement);
			// like 'calloc' but no zero fill
			// may throw memory exceptions

	void FreeDataChain();       // free this one and links
};


#endif //__PLEX_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\minimfc\plex.cpp ===
/*++

Copyright (C) 1992-2001 Microsoft Corporation

Module Name:

    PLEX.CPP

Abstract:

History:

--*/

// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1993 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and Microsoft
// QuickHelp and/or WinHelp documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "precomp.h"

#define ASSERT(x)
#define ASSERT_VALID(x)

#include "plex.h"


CPlex* CPlex::Create(CPlex*& pHead, UINT nMax, UINT cbElement)
{
    ASSERT(nMax > 0 && cbElement > 0);
    CPlex* p = (CPlex*) new BYTE[sizeof(CPlex) + nMax * cbElement];
            // may throw exception
    p->nMax = nMax;
    p->nCur = 0;
    p->pNext = pHead;
    pHead = p;  // change head (adds in reverse order for simplicity)
    return p;
}

void CPlex::FreeDataChain()     // free this one and links
{
    CPlex* p = this;
    while (p != NULL)
    {
        BYTE* bytes = (BYTE*) p;
        CPlex* pNext = p->pNext;
        delete bytes;
        p = pNext;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\minimfc\elements.h ===
/*++

Copyright (C) 1992-2001 Microsoft Corporation

Module Name:

    ELEMENTS.H

Abstract:

History:

--*/

// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1993 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and Microsoft
// QuickHelp documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

// Collection implementation helpers

/*
* The short story:
*   this file contains inline functions that make up the building blocks
*   for implementing the string versions of standard parameterized
*   collection shapes
*
* The long story:
*   Because the implementation of collection classes moves objects around
*   in various ways, it is very inefficient to use only generic C++ constructs.
*   For example, in order to grow an array of FOO objects by one element,
*   you would be forced to allocate a new array of appropriate size, calling
*   the FOO constructor on every element.  Then copy the original array, element
*   by element using a possibly overloaded assignment operator.  Finally destroy
*   the original array element by element.
*   For built-in data types (WORD, DWORD, pointer types), this is complete
*   overkill.  For non-trivial classes (eg: CString in particular) this is
*   a terrible implementation.
*
*   The bottom line: we have to special routines for doing construction
*   and destruction of arrays of special elements - in particular CStrings.
*   The standard templates are parameterized on 'HAS_CREATE' which is
*   non-zero if the collection implementation requires a special
*   construct and destruct function.
*
*   Please note that these are inline overloaded operators, and do not have
*   any form of runtime polymorphism (i.e. nothing is 'virtual').
*/

/////////////////////////////////////////////////////////////////////////////
// Special implementations for CStrings
// it is faster to bit-wise copy a CString than to call an official
//   constructor - since an empty CString can be bit-wise copied

extern const CString afxEmptyString;

static inline void ConstructElement(CString* pNewData)
{
	memcpy(pNewData, &afxEmptyString, sizeof(CString));
}

static inline void DestructElement(CString* pOldData)
{
	pOldData->Empty();
}

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\mofcompiler\makefile.inc ===
!INCLUDE $(_NTDRIVE)$(_NTROOT)\WMI\COMMON\makefile.cmn
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\minimfc\miniafx.h ===
/*++

Copyright (C) 1992-2001 Microsoft Corporation

Module Name:

    MINIAFX.H

Abstract:

History:

--*/


///////////////////////////////////////////////////////////////////////////
//
//  MINIAFX.H
//
//  MFC Subset declarations.
//
//  CString, CWordArray, CDWordArray, CPtrArray, CStringArray, CPtrList
//
//  09/25/94    TSE
//
///////////////////////////////////////////////////////////////////////////

#ifndef _MINIAFX_H_
#define _MINIAFX_H_

#include <stdio.h>
#include <string.h>


typedef void*      POSITION;   // abstract iteration position

#ifndef DWORD
  typedef unsigned char  BYTE;   // 8-bit unsigned entity
  typedef unsigned short WORD;   // 16-bit unsigned number
  typedef unsigned int   UINT;   // machine sized unsigned number (preferred)
  typedef long           LONG;   // 32-bit signed number
  typedef unsigned long  DWORD;  // 32-bit unsigned number
  typedef int            BOOL;   // BOOLean (0 or !=0)
  typedef char *      LPSTR;  // far pointer to a string
  typedef const char * LPCSTR; // far pointer to a read-only string
#endif

#ifndef NULL
#define NULL 0
#endif

#ifndef TRUE
#define TRUE 1
#endif

#ifndef FALSE
#define FALSE 0
#endif



////////////////////////////////////////////////////////////////////////////

class CString
{
public:

// Constructors
	CString();
	CString(const CString& stringSrc);
	CString(char ch, int nRepeat = 1);
	CString(const char* psz);
	CString(const char* pch, int nLength);
   ~CString();

// Attributes & Operations

	// as an array of characters
	int GetLength() const { return m_nDataLength; }

	BOOL IsEmpty() const;
	void Empty();                       // free up the data

	char GetAt(int nIndex) const;       // 0 based
	char operator[](int nIndex) const;  // same as GetAt
	void SetAt(int nIndex, char ch);
	operator const char*() const       // as a C string
	{ return (const char*)m_pchData; }

	// overloaded assignment
	const CString& operator=(const CString& stringSrc);
	const CString& operator=(char ch);
	const CString& operator=(const char* psz);

	// string concatenation
	const CString& operator+=(const CString& string);
	const CString& operator+=(char ch);
	const CString& operator+=(const char* psz);

	friend CString  operator+(const CString& string1,
			const CString& string2);
	friend CString  operator+(const CString& string, char ch);
	friend CString  operator+(char ch, const CString& string);
	friend CString  operator+(const CString& string, const char* psz);
	friend CString  operator+(const char* psz, const CString& string);

	// string comparison
	int Compare(const char* psz) const;         // straight character
	int CompareNoCase(const char* psz) const;   // ignore case
	int Collate(const char* psz) const;         // NLS aware

	// simple sub-string extraction
	CString Mid(int nFirst, int nCount) const;
	CString Mid(int nFirst) const;
	CString Left(int nCount) const;
	CString Right(int nCount) const;

	CString SpanIncluding(const char* pszCharSet) const;
	CString SpanExcluding(const char* pszCharSet) const;

	// upper/lower/reverse conversion
	void MakeUpper();
	void MakeLower();
	void MakeReverse();

	// searching (return starting index, or -1 if not found)
	// look for a single character match
	int Find(char ch) const;                    // like "C" strchr
	int ReverseFind(char ch) const;
	int FindOneOf(const char* pszCharSet) const;

	// look for a specific sub-string
	int Find(const char* pszSub) const;         // like "C" strstr

	// Windows support

#ifdef _WINDOWS
	BOOL LoadString(UINT nID);          // load from string resource
										// 255 chars max
	// ANSI<->OEM support (convert string in place)
	void AnsiToOem();
	void OemToAnsi();
#endif //_WINDOWS

	// Access to string implementation buffer as "C" character array
	char* GetBuffer(int nMinBufLength);
	void ReleaseBuffer(int nNewLength = -1);
	char* GetBufferSetLength(int nNewLength);

// Implementation
public:
	int GetAllocLength() const;
protected:
	// lengths/sizes in characters
	//  (note: an extra character is always allocated)
	char* m_pchData;            // actual string (zero terminated)
	int m_nDataLength;          // does not include terminating 0
	int m_nAllocLength;         // does not include terminating 0

	// implementation helpers
	void Init();
	void AllocCopy(CString& dest, int nCopyLen, int nCopyIndex, int nExtraLen) const;
	void AllocBuffer(int nLen);
	void AssignCopy(int nSrcLen, const char* pszSrcData);
	void ConcatCopy(int nSrc1Len, const char* pszSrc1Data, int nSrc2Len, const char* pszSrc2Data);
	void ConcatInPlace(int nSrcLen, const char* pszSrcData);
	static void SafeDelete(char* pch);
	static int SafeStrlen(const char* psz);
};


// Compare helpers
BOOL  operator==(const CString& s1, const CString& s2);
BOOL  operator==(const CString& s1, const char* s2);
BOOL  operator==(const char* s1, const CString& s2);
BOOL  operator!=(const CString& s1, const CString& s2);
BOOL  operator!=(const CString& s1, const char* s2);
BOOL  operator!=(const char* s1, const CString& s2);
BOOL  operator<(const CString& s1, const CString& s2);
BOOL  operator<(const CString& s1, const char* s2);
BOOL  operator<(const char* s1, const CString& s2);
BOOL  operator>(const CString& s1, const CString& s2);
BOOL  operator>(const CString& s1, const char* s2);
BOOL  operator>(const char* s1, const CString& s2);
BOOL  operator<=(const CString& s1, const CString& s2);
BOOL  operator<=(const CString& s1, const char* s2);
BOOL  operator<=(const char* s1, const CString& s2);
BOOL  operator>=(const CString& s1, const CString& s2);
BOOL  operator>=(const CString& s1, const char* s2);
BOOL  operator>=(const char* s1, const CString& s2);


////////////////////////////////////////////////////////////////////////////

class CDWordArray
{
public:

// Construction
	CDWordArray();

// Attributes
	int GetSize() const { return m_nSize; }
	int GetUpperBound() const;
	void SetSize(int nNewSize, int nGrowBy = -1);

// Operations
	// Clean up
	void FreeExtra();
	void RemoveAll();

	// Accessing elements
	DWORD GetAt(int nIndex) const { return m_pData[nIndex]; }

	void SetAt(int nIndex, DWORD newElement)
	   {	m_pData[nIndex] = newElement; }
           
	DWORD& ElementAt(int nIndex);

	// Potentially growing the array
	void SetAtGrow(int nIndex, DWORD newElement);
	int Add(DWORD newElement);

	// overloaded operator helpers
	DWORD operator[](int nIndex) const;
	DWORD& operator[](int nIndex);

	// Operations that move elements around
	void InsertAt(int nIndex, DWORD newElement, int nCount = 1);
	void RemoveAt(int nIndex, int nCount = 1);
	void InsertAt(int nStartIndex, CDWordArray* pNewArray);

// Implementation
protected:
	DWORD* m_pData;   // the actual array of data
	int m_nSize;     // # of elements (upperBound - 1)
	int m_nMaxSize;  // max allocated
	int m_nGrowBy;   // grow amount

public:
	~CDWordArray();
};


////////////////////////////////////////////////////////////////////////////

class CPtrArray
{
public:

// Construction
	CPtrArray();

// Attributes
	int GetSize() const { return m_nSize; }
	int GetUpperBound() const;
	BOOL SetSize(int nNewSize, int nGrowBy = -1);

// Operations
	// Clean up
	void FreeExtra();
	void RemoveAll();

	// Accessing elements
	void* GetAt(int nIndex) const { return m_pData[nIndex]; }

	void SetAt(int nIndex, void* newElement)
	{ m_pData[nIndex] = newElement; }
        
	void*& ElementAt(int nIndex);

	// Potentially growing the array
	BOOL SetAtGrow(int nIndex, void* newElement);

    // returns -1 if failure

	int Add(void* newElement)
	  { int nIndex = m_nSize;
		if(SetAtGrow(nIndex, newElement))
    		return nIndex; 
        else
            return -1;
    }

	// overloaded operator helpers
	void* operator[](int nIndex) const;
	void*& operator[](int nIndex);

	// Operations that move elements around
	void InsertAt(int nIndex, void* newElement, int nCount = 1);
	void RemoveAt(int nIndex, int nCount = 1);
	void InsertAt(int nStartIndex, CPtrArray* pNewArray);

// Implementation
protected:
	void** m_pData;   // the actual array of data
	int m_nSize;     // # of elements (upperBound - 1)
	int m_nMaxSize;  // max allocated
	int m_nGrowBy;   // grow amount

public:
	~CPtrArray();
};


////////////////////////////////////////////////////////////////////////////

class CStringArray 
{

public:

// Construction
	CStringArray();

// Attributes
	int GetSize() const { return m_nSize; }
	int GetUpperBound() const;
	void SetSize(int nNewSize, int nGrowBy = -1);

// Operations
	// Clean up
	void FreeExtra();
	void RemoveAll();


	// Accessing elements
	CString GetAt(int nIndex) const { return m_pData[nIndex]; }

	void SetAt(int nIndex, const char* newElement)
	{ m_pData[nIndex] = newElement; }

	CString& ElementAt(int nIndex)
	{ return m_pData[nIndex]; }
        
	// Potentially growing the array
	void SetAtGrow(int nIndex, const char* newElement);
	int Add(const char* newElement)
	{ int nIndex = m_nSize;
	      SetAtGrow(nIndex, newElement);
		  return nIndex; }

	// overloaded operator helpers
	CString operator[](int nIndex) const
	{ return GetAt(nIndex); }
        
	CString& operator[](int nIndex)
      	{ return ElementAt(nIndex); }

	// Operations that move elements around
	void InsertAt(int nIndex, const char* newElement, int nCount = 1);
	void RemoveAt(int nIndex, int nCount = 1);
	void InsertAt(int nStartIndex, CStringArray* pNewArray);

// Implementation
protected:
	CString* m_pData;   // the actual array of data
	int m_nSize;     // # of elements (upperBound - 1)
	int m_nMaxSize;  // max allocated
	int m_nGrowBy;   // grow amount

public:
	~CStringArray();
};

////////////////////////////////////////////////////////////////////////////

class CWordArray 
{
public:

// Construction
	CWordArray();

// Attributes
	int GetSize() const { return m_nSize; }
	int GetUpperBound() const;
	void SetSize(int nNewSize, int nGrowBy = -1);

// Operations
	// Clean up
	void FreeExtra();
	void RemoveAll();

	// Accessing elements
	WORD GetAt(int nIndex) const { return m_pData[nIndex]; }
	void SetAt(int nIndex, WORD newElement)
     	{ m_pData[nIndex] = newElement; }
	WORD& ElementAt(int nIndex);

	// Potentially growing the array
	void SetAtGrow(int nIndex, WORD newElement);
	int Add(WORD newElement);

	// overloaded operator helpers
	WORD operator[](int nIndex) const;
	WORD& operator[](int nIndex);

	// Operations that move elements around
	void InsertAt(int nIndex, WORD newElement, int nCount = 1);
	void RemoveAt(int nIndex, int nCount = 1);
	void InsertAt(int nStartIndex, CWordArray* pNewArray);

// Implementation
protected:
	WORD* m_pData;   // the actual array of data
	int m_nSize;     // # of elements (upperBound - 1)
	int m_nMaxSize;  // max allocated
	int m_nGrowBy;   // grow amount

public:
	~CWordArray();
};



/////////////////////////////////////////////////////////////////////////////

class CPtrList
{
protected:
	struct CNode
	{
		CNode* pNext;
		CNode* pPrev;
		void* data;
	};
public:

// Construction
	CPtrList(int nBlockSize=10);

// Attributes (head and tail)
	// count of elements
	int GetCount() const;
	BOOL IsEmpty() const;

	// peek at head or tail
	void*& GetHead();
	void* GetHead() const;
	void*& GetTail();
	void* GetTail() const;

// Operations
	// get head or tail (and remove it) - don't call on empty list !
	void* RemoveHead();
	void* RemoveTail();

	// add before head or after tail
	POSITION AddHead(void* newElement);
	POSITION AddTail(void* newElement);

	// add another list of elements before head or after tail
	void AddHead(CPtrList* pNewList);
	void AddTail(CPtrList* pNewList);

	// remove all elements
	void RemoveAll();

	// iteration
	POSITION GetHeadPosition() const;
	POSITION GetTailPosition() const;
	void*& GetNext(POSITION& rPosition); // return *Position++
	void* GetNext(POSITION& rPosition) const; // return *Position++
	void*& GetPrev(POSITION& rPosition); // return *Position--
	void* GetPrev(POSITION& rPosition) const; // return *Position--

	// getting/modifying an element at a given position
	void*& GetAt(POSITION position);
	void* GetAt(POSITION position) const;
	void SetAt(POSITION pos, void* newElement);
	void RemoveAt(POSITION position);

	// inserting before or after a given position
	POSITION InsertBefore(POSITION position, void* newElement);
	POSITION InsertAfter(POSITION position, void* newElement);

	// helper functions (note: O(n) speed)
	POSITION Find(void* searchValue, POSITION startAfter = NULL) const;
						// defaults to starting at the HEAD
						// return NULL if not found
	POSITION FindIndex(int nIndex) const;
						// get the 'nIndex'th element (may return NULL)

// Implementation
protected:
	CNode* m_pNodeHead;
	CNode* m_pNodeTail;
	int m_nCount;
	CNode* m_pNodeFree;
	struct CPlex* m_pBlocks;
	int m_nBlockSize;

	CNode* NewNode(CNode*, CNode*);
	void FreeNode(CNode*);

public:
	~CPtrList();
};



//-----------------------------------------------------------------
// Inlines from AFX.INL and AFXCOLL.INL
//

#define _AFX_INLINE inline
#define _AFXCOLL_INLINE inline

// CString

_AFX_INLINE int CString::GetAllocLength() const
	{ return m_nAllocLength; }
_AFX_INLINE BOOL CString::IsEmpty() const
	{ return m_nDataLength == 0; }
//_AFX_INLINE int CString::SafeStrlen(const char* psz)
//	{ return (psz == NULL) ? NULL : strlen(psz); }

#ifndef _WINDOWS
_AFX_INLINE int CString::Compare(const char* psz) const
	{ return strcmp(m_pchData, psz); }
_AFX_INLINE int CString::CompareNoCase(const char* psz) const
	{ return stricmp(m_pchData, psz); }
_AFX_INLINE int CString::Collate(const char* psz) const
	{ return strcoll(m_pchData, psz); }
_AFX_INLINE void CString::MakeUpper()
	{ strupr(m_pchData); }
_AFX_INLINE void CString::MakeLower()
	{ strlwr(m_pchData); }
// Windows version in AFXWIN.H
#endif //!_WINDOWS

_AFX_INLINE void CString::MakeReverse()
	{ strrev(m_pchData); }
_AFX_INLINE char CString::GetAt(int nIndex) const
	{
		return m_pchData[nIndex];
	}
_AFX_INLINE char CString::operator[](int nIndex) const
	{
		return m_pchData[nIndex];
	}
_AFX_INLINE void CString::SetAt(int nIndex, char ch)
	{
		m_pchData[nIndex] = ch;
	}

_AFX_INLINE BOOL  operator==(const CString& s1, const CString& s2)
	{ return s1.Compare(s2) == 0; }

_AFX_INLINE BOOL  operator==(const CString& s1, const char* s2)
	{ return s1.Compare(s2) == 0; }

_AFX_INLINE BOOL  operator==(const char* s1, const CString& s2)
	{ return s2.Compare(s1) == 0; }

_AFX_INLINE BOOL  operator!=(const CString& s1, const CString& s2)
	{ return s1.Compare(s2) != 0; }

_AFX_INLINE BOOL  operator!=(const CString& s1, const char* s2)
	{ return s1.Compare(s2) != 0; }

_AFX_INLINE BOOL  operator!=(const char* s1, const CString& s2)
	{ return s2.Compare(s1) != 0; }

_AFX_INLINE BOOL  operator<(const CString& s1, const CString& s2)
	{ return s1.Compare(s2) < 0; }
_AFX_INLINE BOOL  operator<(const CString& s1, const char* s2)
	{ return s1.Compare(s2) < 0; }
_AFX_INLINE BOOL  operator<(const char* s1, const CString& s2)
	{ return s2.Compare(s1) > 0; }
_AFX_INLINE BOOL  operator>(const CString& s1, const CString& s2)
	{ return s1.Compare(s2) > 0; }
_AFX_INLINE BOOL  operator>(const CString& s1, const char* s2)
	{ return s1.Compare(s2) > 0; }
_AFX_INLINE BOOL  operator>(const char* s1, const CString& s2)
	{ return s2.Compare(s1) < 0; }
_AFX_INLINE BOOL  operator<=(const CString& s1, const CString& s2)
	{ return s1.Compare(s2) <= 0; }
_AFX_INLINE BOOL  operator<=(const CString& s1, const char* s2)
	{ return s1.Compare(s2) <= 0; }
_AFX_INLINE BOOL  operator<=(const char* s1, const CString& s2)
	{ return s2.Compare(s1) >= 0; }
_AFX_INLINE BOOL  operator>=(const CString& s1, const CString& s2)
	{ return s1.Compare(s2) >= 0; }
_AFX_INLINE BOOL  operator>=(const CString& s1, const char* s2)
	{ return s1.Compare(s2) >= 0; }
_AFX_INLINE BOOL  operator>=(const char* s1, const CString& s2)
	{ return s2.Compare(s1) <= 0; }

/////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////

_AFXCOLL_INLINE int CWordArray::GetUpperBound() const
	{ return m_nSize-1; }
_AFXCOLL_INLINE void CWordArray::RemoveAll()
	{ SetSize(0); }
_AFXCOLL_INLINE WORD& CWordArray::ElementAt(int nIndex)
	{ return m_pData[nIndex]; }
_AFXCOLL_INLINE int CWordArray::Add(WORD newElement)
	{ int nIndex = m_nSize;
		SetAtGrow(nIndex, newElement);
		return nIndex; }
_AFXCOLL_INLINE WORD CWordArray::operator[](int nIndex) const
	{ return GetAt(nIndex); }
_AFXCOLL_INLINE WORD& CWordArray::operator[](int nIndex)
	{ return ElementAt(nIndex); }


////////////////////////////////////////////////////////////////////////////

_AFXCOLL_INLINE int CDWordArray::GetUpperBound() const
	{ return m_nSize-1; }
_AFXCOLL_INLINE void CDWordArray::RemoveAll()
	{ SetSize(0); }
_AFXCOLL_INLINE DWORD& CDWordArray::ElementAt(int nIndex)
	{ return m_pData[nIndex]; }
_AFXCOLL_INLINE int CDWordArray::Add(DWORD newElement)
	{ int nIndex = m_nSize;
		SetAtGrow(nIndex, newElement);
		return nIndex; }
_AFXCOLL_INLINE DWORD CDWordArray::operator[](int nIndex) const
	{ return GetAt(nIndex); }
_AFXCOLL_INLINE DWORD& CDWordArray::operator[](int nIndex)
	{ return ElementAt(nIndex); }


////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////

_AFXCOLL_INLINE int CPtrArray::GetUpperBound() const
	{ return m_nSize-1; }
_AFXCOLL_INLINE void CPtrArray::RemoveAll()
	{ SetSize(0); }
_AFXCOLL_INLINE void*& CPtrArray::ElementAt(int nIndex)
	{ return m_pData[nIndex]; }
_AFXCOLL_INLINE void* CPtrArray::operator[](int nIndex) const
	{ return GetAt(nIndex); }
_AFXCOLL_INLINE void*& CPtrArray::operator[](int nIndex)
	{ return ElementAt(nIndex); }


////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////

_AFXCOLL_INLINE int CStringArray::GetUpperBound() const
	{ return m_nSize-1; }
_AFXCOLL_INLINE void CStringArray::RemoveAll()
	{ SetSize(0); }


////////////////////////////////////////////////////////////////////////////


_AFXCOLL_INLINE int CPtrList::GetCount() const
	{ return m_nCount; }
_AFXCOLL_INLINE BOOL CPtrList::IsEmpty() const
	{ return m_nCount == 0; }
_AFXCOLL_INLINE void*& CPtrList::GetHead()
	{ return m_pNodeHead->data; }
_AFXCOLL_INLINE void* CPtrList::GetHead() const
	{ return m_pNodeHead->data; }
_AFXCOLL_INLINE void*& CPtrList::GetTail()
	{ return m_pNodeTail->data; }

_AFXCOLL_INLINE void* CPtrList::GetTail() const
	{ return m_pNodeTail->data; }

_AFXCOLL_INLINE POSITION CPtrList::GetHeadPosition() const
	{ return (POSITION) m_pNodeHead; }

_AFXCOLL_INLINE POSITION CPtrList::GetTailPosition() const
	{ return (POSITION) m_pNodeTail; }

_AFXCOLL_INLINE void*& CPtrList::GetNext(POSITION& rPosition) // return *Position++
	{ CNode* pNode = (CNode*) rPosition;
		rPosition = (POSITION) pNode->pNext;
		return pNode->data; }

_AFXCOLL_INLINE void* CPtrList::GetNext(POSITION& rPosition) const // return *Position++
	{ CNode* pNode = (CNode*) rPosition;
		rPosition = (POSITION) pNode->pNext;
		return pNode->data; }

_AFXCOLL_INLINE void*& CPtrList::GetPrev(POSITION& rPosition) // return *Position--
	{ CNode* pNode = (CNode*) rPosition;
		rPosition = (POSITION) pNode->pPrev;
		return pNode->data; }

_AFXCOLL_INLINE void* CPtrList::GetPrev(POSITION& rPosition) const // return *Position--
	{ CNode* pNode = (CNode*) rPosition;
		rPosition = (POSITION) pNode->pPrev;
		return pNode->data; }

_AFXCOLL_INLINE void*& CPtrList::GetAt(POSITION position)
	{ CNode* pNode = (CNode*) position;
		return pNode->data; }

_AFXCOLL_INLINE void* CPtrList::GetAt(POSITION position) const
	{ CNode* pNode = (CNode*) position;
		return pNode->data; }

_AFXCOLL_INLINE void CPtrList::SetAt(POSITION pos, void* newElement)
	{ CNode* pNode = (CNode*) pos;
		pNode->data = newElement; }



////////////////////////////////////////////////////////////////////////////


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\minimfc\precomp.h ===
/*++

Copyright (C) 1992-2001 Microsoft Corporation

Module Name:

    MINIAFX.H

Abstract:

  MFC Subset declarations.

  CString, CWordArray, CDWordArray, CPtrArray, CStringArray, CPtrList

History:

  09/25/94    TSE

--*/

#ifndef _MINIAFX_H_
#define _MINIAFX_H_

#include <stdio.h>
#include <string.h>

typedef void*      POSITION;   // abstract iteration position

#ifndef DWORD
  typedef unsigned char  BYTE;   // 8-bit unsigned entity
  typedef unsigned short WORD;   // 16-bit unsigned number
  typedef unsigned int   UINT;   // machine sized unsigned number (preferred)
  typedef long           LONG;   // 32-bit signed number
  typedef unsigned long  DWORD;  // 32-bit unsigned number
  typedef int            BOOL;   // BOOLean (0 or !=0)
  typedef char *      LPSTR;  // far pointer to a string
  typedef const char * LPCSTR; // far pointer to a read-only string
#endif

#ifndef NULL
#define NULL 0
#endif

#ifndef TRUE
#define TRUE 1
#endif

#ifndef FALSE
#define FALSE 0
#endif



////////////////////////////////////////////////////////////////////////////

class CString
{
public:

// Constructors
	CString();
	CString(const CString& stringSrc);
	CString(char ch, int nRepeat = 1);
	CString(const char* psz);
	CString(const char* pch, int nLength);
   ~CString();

// Attributes & Operations

	// as an array of characters
	int GetLength() const { return m_nDataLength; }

	BOOL IsEmpty() const;
	void Empty();                       // free up the data

	char GetAt(int nIndex) const;       // 0 based
	char operator[](int nIndex) const;  // same as GetAt
	void SetAt(int nIndex, char ch);
	operator const char*() const       // as a C string
	{ return (const char*)m_pchData; }

	// overloaded assignment
	const CString& operator=(const CString& stringSrc);
	const CString& operator=(char ch);
	const CString& operator=(const char* psz);

	// string concatenation
	const CString& operator+=(const CString& string);
	const CString& operator+=(char ch);
	const CString& operator+=(const char* psz);

	friend CString  operator+(const CString& string1,
			const CString& string2);
	friend CString  operator+(const CString& string, char ch);
	friend CString  operator+(char ch, const CString& string);
	friend CString  operator+(const CString& string, const char* psz);
	friend CString  operator+(const char* psz, const CString& string);

	// string comparison
	int Compare(const char* psz) const;         // straight character
	int CompareNoCase(const char* psz) const;   // ignore case
	int Collate(const char* psz) const;         // NLS aware

	// simple sub-string extraction
	CString Mid(int nFirst, int nCount) const;
	CString Mid(int nFirst) const;
	CString Left(int nCount) const;
	CString Right(int nCount) const;

	CString SpanIncluding(const char* pszCharSet) const;
	CString SpanExcluding(const char* pszCharSet) const;

	// upper/lower/reverse conversion
	void MakeUpper();
	void MakeLower();
	void MakeReverse();

	// searching (return starting index, or -1 if not found)
	// look for a single character match
	int Find(char ch) const;                    // like "C" strchr
	int ReverseFind(char ch) const;
	int FindOneOf(const char* pszCharSet) const;

	// look for a specific sub-string
	int Find(const char* pszSub) const;         // like "C" strstr

	// Windows support

#ifdef _WINDOWS
	BOOL LoadString(UINT nID);          // load from string resource
										// 255 chars max
	// ANSI<->OEM support (convert string in place)
	void AnsiToOem();
	void OemToAnsi();
#endif //_WINDOWS

	// Access to string implementation buffer as "C" character array
	char* GetBuffer(int nMinBufLength);
	void ReleaseBuffer(int nNewLength = -1);
	char* GetBufferSetLength(int nNewLength);

// Implementation
public:
	int GetAllocLength() const;
protected:
	// lengths/sizes in characters
	//  (note: an extra character is always allocated)
	char* m_pchData;            // actual string (zero terminated)
	int m_nDataLength;          // does not include terminating 0
	int m_nAllocLength;         // does not include terminating 0

	// implementation helpers
	void Init();
	void AllocCopy(CString& dest, int nCopyLen, int nCopyIndex, int nExtraLen) const;
	void AllocBuffer(int nLen);
	void AssignCopy(int nSrcLen, const char* pszSrcData);
	void ConcatCopy(int nSrc1Len, const char* pszSrc1Data, int nSrc2Len, const char* pszSrc2Data);
	void ConcatInPlace(int nSrcLen, const char* pszSrcData);
	static void SafeDelete(char* pch);
	static int SafeStrlen(const char* psz);
};


// Compare helpers
BOOL  operator==(const CString& s1, const CString& s2);
BOOL  operator==(const CString& s1, const char* s2);
BOOL  operator==(const char* s1, const CString& s2);
BOOL  operator!=(const CString& s1, const CString& s2);
BOOL  operator!=(const CString& s1, const char* s2);
BOOL  operator!=(const char* s1, const CString& s2);
BOOL  operator<(const CString& s1, const CString& s2);
BOOL  operator<(const CString& s1, const char* s2);
BOOL  operator<(const char* s1, const CString& s2);
BOOL  operator>(const CString& s1, const CString& s2);
BOOL  operator>(const CString& s1, const char* s2);
BOOL  operator>(const char* s1, const CString& s2);
BOOL  operator<=(const CString& s1, const CString& s2);
BOOL  operator<=(const CString& s1, const char* s2);
BOOL  operator<=(const char* s1, const CString& s2);
BOOL  operator>=(const CString& s1, const CString& s2);
BOOL  operator>=(const CString& s1, const char* s2);
BOOL  operator>=(const char* s1, const CString& s2);


////////////////////////////////////////////////////////////////////////////

class CDWordArray
{
public:

// Construction
	CDWordArray();

// Attributes
	int GetSize() const { return m_nSize; }
	int GetUpperBound() const;
	void SetSize(int nNewSize, int nGrowBy = -1);

// Operations
	// Clean up
	void FreeExtra();
	void RemoveAll();

	// Accessing elements
	DWORD GetAt(int nIndex) const { return m_pData[nIndex]; }

	void SetAt(int nIndex, DWORD newElement)
	   {	m_pData[nIndex] = newElement; }

	DWORD& ElementAt(int nIndex);

	// Potentially growing the array
	void SetAtGrow(int nIndex, DWORD newElement);
	int Add(DWORD newElement);

	// overloaded operator helpers
	DWORD operator[](int nIndex) const;
	DWORD& operator[](int nIndex);

	// Operations that move elements around
	void InsertAt(int nIndex, DWORD newElement, int nCount = 1);
	void RemoveAt(int nIndex, int nCount = 1);
	void InsertAt(int nStartIndex, CDWordArray* pNewArray);

// Implementation
protected:
	DWORD* m_pData;   // the actual array of data
	int m_nSize;     // # of elements (upperBound - 1)
	int m_nMaxSize;  // max allocated
	int m_nGrowBy;   // grow amount

public:
	~CDWordArray();
};


////////////////////////////////////////////////////////////////////////////

class CPtrArray
{
public:

// Construction
	CPtrArray();

// Attributes
	int GetSize() const { return m_nSize; }
	int GetUpperBound() const;
	BOOL SetSize(int nNewSize, int nGrowBy = -1);

// Operations
	// Clean up
	void FreeExtra();
	void RemoveAll();

	// Accessing elements
	void* GetAt(int nIndex) const { return m_pData[nIndex]; }

	void SetAt(int nIndex, void* newElement)
	{ m_pData[nIndex] = newElement; }

	void*& ElementAt(int nIndex);

	// Potentially growing the array
	BOOL SetAtGrow(int nIndex, void* newElement);

	int Add(void* newElement)
	{ int nIndex = m_nSize;
		if(SetAtGrow(nIndex, newElement))
    		return nIndex; 
        else
            return -1;
    }

	// overloaded operator helpers
	void* operator[](int nIndex) const;
	void*& operator[](int nIndex);

	// Operations that move elements around
	void InsertAt(int nIndex, void* newElement, int nCount = 1);
	void RemoveAt(int nIndex, int nCount = 1);
	void InsertAt(int nStartIndex, CPtrArray* pNewArray);

// Implementation
protected:
	void** m_pData;   // the actual array of data
	int m_nSize;     // # of elements (upperBound - 1)
	int m_nMaxSize;  // max allocated
	int m_nGrowBy;   // grow amount

public:
	~CPtrArray();
};


////////////////////////////////////////////////////////////////////////////

class CStringArray
{

public:

// Construction
	CStringArray();

// Attributes
	int GetSize() const { return m_nSize; }
	int GetUpperBound() const;
	void SetSize(int nNewSize, int nGrowBy = -1);

// Operations
	// Clean up
	void FreeExtra();
	void RemoveAll();


	// Accessing elements
	CString GetAt(int nIndex) const { return m_pData[nIndex]; }

	void SetAt(int nIndex, const char* newElement)
	{ m_pData[nIndex] = newElement; }

	CString& ElementAt(int nIndex)
	{ return m_pData[nIndex]; }

	// Potentially growing the array
	void SetAtGrow(int nIndex, const char* newElement);
	int Add(const char* newElement)
	{ int nIndex = m_nSize;
	      SetAtGrow(nIndex, newElement);
		  return nIndex; }

	// overloaded operator helpers
	CString operator[](int nIndex) const
	{ return GetAt(nIndex); }

	CString& operator[](int nIndex)
      	{ return ElementAt(nIndex); }

	// Operations that move elements around
	void InsertAt(int nIndex, const char* newElement, int nCount = 1);
	void RemoveAt(int nIndex, int nCount = 1);
	void InsertAt(int nStartIndex, CStringArray* pNewArray);

// Implementation
protected:
	CString* m_pData;   // the actual array of data
	int m_nSize;     // # of elements (upperBound - 1)
	int m_nMaxSize;  // max allocated
	int m_nGrowBy;   // grow amount

public:
	~CStringArray();
};

////////////////////////////////////////////////////////////////////////////

class CWordArray
{
public:

// Construction
	CWordArray();

// Attributes
	int GetSize() const { return m_nSize; }
	int GetUpperBound() const;
	void SetSize(int nNewSize, int nGrowBy = -1);

// Operations
	// Clean up
	void FreeExtra();
	void RemoveAll();

	// Accessing elements
	WORD GetAt(int nIndex) const { return m_pData[nIndex]; }
	void SetAt(int nIndex, WORD newElement)
     	{ m_pData[nIndex] = newElement; }
	WORD& ElementAt(int nIndex);

	// Potentially growing the array
	void SetAtGrow(int nIndex, WORD newElement);
	int Add(WORD newElement);

	// overloaded operator helpers
	WORD operator[](int nIndex) const;
	WORD& operator[](int nIndex);

	// Operations that move elements around
	void InsertAt(int nIndex, WORD newElement, int nCount = 1);
	void RemoveAt(int nIndex, int nCount = 1);
	void InsertAt(int nStartIndex, CWordArray* pNewArray);

// Implementation
protected:
	WORD* m_pData;   // the actual array of data
	int m_nSize;     // # of elements (upperBound - 1)
	int m_nMaxSize;  // max allocated
	int m_nGrowBy;   // grow amount

public:
	~CWordArray();
};



/////////////////////////////////////////////////////////////////////////////

class CPtrList
{
protected:
	struct CNode
	{
		CNode* pNext;
		CNode* pPrev;
		void* data;
	};
public:

// Construction
	CPtrList(int nBlockSize=10);

// Attributes (head and tail)
	// count of elements
	int GetCount() const;
	BOOL IsEmpty() const;

	// peek at head or tail
	void*& GetHead();
	void* GetHead() const;
	void*& GetTail();
	void* GetTail() const;

// Operations
	// get head or tail (and remove it) - don't call on empty list !
	void* RemoveHead();
	void* RemoveTail();

	// add before head or after tail
	POSITION AddHead(void* newElement);
	POSITION AddTail(void* newElement);

	// add another list of elements before head or after tail
	void AddHead(CPtrList* pNewList);
	void AddTail(CPtrList* pNewList);

	// remove all elements
	void RemoveAll();

	// iteration
	POSITION GetHeadPosition() const;
	POSITION GetTailPosition() const;
	void*& GetNext(POSITION& rPosition); // return *Position++
	void* GetNext(POSITION& rPosition) const; // return *Position++
	void*& GetPrev(POSITION& rPosition); // return *Position--
	void* GetPrev(POSITION& rPosition) const; // return *Position--

	// getting/modifying an element at a given position
	void*& GetAt(POSITION position);
	void* GetAt(POSITION position) const;
	void SetAt(POSITION pos, void* newElement);
	void RemoveAt(POSITION position);

	// inserting before or after a given position
	POSITION InsertBefore(POSITION position, void* newElement);
	POSITION InsertAfter(POSITION position, void* newElement);

	// helper functions (note: O(n) speed)
	POSITION Find(void* searchValue, POSITION startAfter = NULL) const;
						// defaults to starting at the HEAD
						// return NULL if not found
	POSITION FindIndex(int nIndex) const;
						// get the 'nIndex'th element (may return NULL)

// Implementation
protected:
	CNode* m_pNodeHead;
	CNode* m_pNodeTail;
	int m_nCount;
	CNode* m_pNodeFree;
	struct CPlex* m_pBlocks;
	int m_nBlockSize;

	CNode* NewNode(CNode*, CNode*);
	void FreeNode(CNode*);

public:
	~CPtrList();
};



//-----------------------------------------------------------------
// Inlines from AFX.INL and AFXCOLL.INL
//

#define _AFX_INLINE inline
#define _AFXCOLL_INLINE inline

// CString

_AFX_INLINE int CString::GetAllocLength() const
	{ return m_nAllocLength; }
_AFX_INLINE BOOL CString::IsEmpty() const
	{ return m_nDataLength == 0; }
//_AFX_INLINE int CString::SafeStrlen(const char* psz)
//	{ return (psz == NULL) ? NULL : strlen(psz); }

#ifndef _WINDOWS
_AFX_INLINE int CString::Compare(const char* psz) const
	{ return strcmp(m_pchData, psz); }
_AFX_INLINE int CString::CompareNoCase(const char* psz) const
	{ return stricmp(m_pchData, psz); }
_AFX_INLINE int CString::Collate(const char* psz) const
	{ return strcoll(m_pchData, psz); }
_AFX_INLINE void CString::MakeUpper()
	{ strupr(m_pchData); }
_AFX_INLINE void CString::MakeLower()
	{ strlwr(m_pchData); }
// Windows version in AFXWIN.H
#endif //!_WINDOWS

_AFX_INLINE void CString::MakeReverse()
	{ strrev(m_pchData); }
_AFX_INLINE char CString::GetAt(int nIndex) const
	{
		return m_pchData[nIndex];
	}
_AFX_INLINE char CString::operator[](int nIndex) const
	{
		return m_pchData[nIndex];
	}
_AFX_INLINE void CString::SetAt(int nIndex, char ch)
	{
		m_pchData[nIndex] = ch;
	}

_AFX_INLINE BOOL  operator==(const CString& s1, const CString& s2)
	{ return s1.Compare(s2) == 0; }

_AFX_INLINE BOOL  operator==(const CString& s1, const char* s2)
	{ return s1.Compare(s2) == 0; }

_AFX_INLINE BOOL  operator==(const char* s1, const CString& s2)
	{ return s2.Compare(s1) == 0; }

_AFX_INLINE BOOL  operator!=(const CString& s1, const CString& s2)
	{ return s1.Compare(s2) != 0; }

_AFX_INLINE BOOL  operator!=(const CString& s1, const char* s2)
	{ return s1.Compare(s2) != 0; }

_AFX_INLINE BOOL  operator!=(const char* s1, const CString& s2)
	{ return s2.Compare(s1) != 0; }

_AFX_INLINE BOOL  operator<(const CString& s1, const CString& s2)
	{ return s1.Compare(s2) < 0; }
_AFX_INLINE BOOL  operator<(const CString& s1, const char* s2)
	{ return s1.Compare(s2) < 0; }
_AFX_INLINE BOOL  operator<(const char* s1, const CString& s2)
	{ return s2.Compare(s1) > 0; }
_AFX_INLINE BOOL  operator>(const CString& s1, const CString& s2)
	{ return s1.Compare(s2) > 0; }
_AFX_INLINE BOOL  operator>(const CString& s1, const char* s2)
	{ return s1.Compare(s2) > 0; }
_AFX_INLINE BOOL  operator>(const char* s1, const CString& s2)
	{ return s2.Compare(s1) < 0; }
_AFX_INLINE BOOL  operator<=(const CString& s1, const CString& s2)
	{ return s1.Compare(s2) <= 0; }
_AFX_INLINE BOOL  operator<=(const CString& s1, const char* s2)
	{ return s1.Compare(s2) <= 0; }
_AFX_INLINE BOOL  operator<=(const char* s1, const CString& s2)
	{ return s2.Compare(s1) >= 0; }
_AFX_INLINE BOOL  operator>=(const CString& s1, const CString& s2)
	{ return s1.Compare(s2) >= 0; }
_AFX_INLINE BOOL  operator>=(const CString& s1, const char* s2)
	{ return s1.Compare(s2) >= 0; }
_AFX_INLINE BOOL  operator>=(const char* s1, const CString& s2)
	{ return s2.Compare(s1) <= 0; }

/////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////

_AFXCOLL_INLINE int CWordArray::GetUpperBound() const
	{ return m_nSize-1; }
_AFXCOLL_INLINE void CWordArray::RemoveAll()
	{ SetSize(0); }
_AFXCOLL_INLINE WORD& CWordArray::ElementAt(int nIndex)
	{ return m_pData[nIndex]; }
_AFXCOLL_INLINE int CWordArray::Add(WORD newElement)
	{ int nIndex = m_nSize;
		SetAtGrow(nIndex, newElement);
		return nIndex; }
_AFXCOLL_INLINE WORD CWordArray::operator[](int nIndex) const
	{ return GetAt(nIndex); }
_AFXCOLL_INLINE WORD& CWordArray::operator[](int nIndex)
	{ return ElementAt(nIndex); }


////////////////////////////////////////////////////////////////////////////

_AFXCOLL_INLINE int CDWordArray::GetUpperBound() const
	{ return m_nSize-1; }
_AFXCOLL_INLINE void CDWordArray::RemoveAll()
	{ SetSize(0); }
_AFXCOLL_INLINE DWORD& CDWordArray::ElementAt(int nIndex)
	{ return m_pData[nIndex]; }
_AFXCOLL_INLINE int CDWordArray::Add(DWORD newElement)
	{ int nIndex = m_nSize;
		SetAtGrow(nIndex, newElement);
		return nIndex; }
_AFXCOLL_INLINE DWORD CDWordArray::operator[](int nIndex) const
	{ return GetAt(nIndex); }
_AFXCOLL_INLINE DWORD& CDWordArray::operator[](int nIndex)
	{ return ElementAt(nIndex); }


////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////

_AFXCOLL_INLINE int CPtrArray::GetUpperBound() const
	{ return m_nSize-1; }
_AFXCOLL_INLINE void CPtrArray::RemoveAll()
	{ SetSize(0); }
_AFXCOLL_INLINE void*& CPtrArray::ElementAt(int nIndex)
	{ return m_pData[nIndex]; }
_AFXCOLL_INLINE void* CPtrArray::operator[](int nIndex) const
	{ return GetAt(nIndex); }
_AFXCOLL_INLINE void*& CPtrArray::operator[](int nIndex)
	{ return ElementAt(nIndex); }


////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////

_AFXCOLL_INLINE int CStringArray::GetUpperBound() const
	{ return m_nSize-1; }
_AFXCOLL_INLINE void CStringArray::RemoveAll()
	{ SetSize(0); }


////////////////////////////////////////////////////////////////////////////


_AFXCOLL_INLINE int CPtrList::GetCount() const
	{ return m_nCount; }
_AFXCOLL_INLINE BOOL CPtrList::IsEmpty() const
	{ return m_nCount == 0; }
_AFXCOLL_INLINE void*& CPtrList::GetHead()
	{ return m_pNodeHead->data; }
_AFXCOLL_INLINE void* CPtrList::GetHead() const
	{ return m_pNodeHead->data; }
_AFXCOLL_INLINE void*& CPtrList::GetTail()
	{ return m_pNodeTail->data; }

_AFXCOLL_INLINE void* CPtrList::GetTail() const
	{ return m_pNodeTail->data; }

_AFXCOLL_INLINE POSITION CPtrList::GetHeadPosition() const
	{ return (POSITION) m_pNodeHead; }

_AFXCOLL_INLINE POSITION CPtrList::GetTailPosition() const
	{ return (POSITION) m_pNodeTail; }

_AFXCOLL_INLINE void*& CPtrList::GetNext(POSITION& rPosition) // return *Position++
	{ CNode* pNode = (CNode*) rPosition;
		rPosition = (POSITION) pNode->pNext;
		return pNode->data; }

_AFXCOLL_INLINE void* CPtrList::GetNext(POSITION& rPosition) const // return *Position++
	{ CNode* pNode = (CNode*) rPosition;
		rPosition = (POSITION) pNode->pNext;
		return pNode->data; }

_AFXCOLL_INLINE void*& CPtrList::GetPrev(POSITION& rPosition) // return *Position--
	{ CNode* pNode = (CNode*) rPosition;
		rPosition = (POSITION) pNode->pPrev;
		return pNode->data; }

_AFXCOLL_INLINE void* CPtrList::GetPrev(POSITION& rPosition) const // return *Position--
	{ CNode* pNode = (CNode*) rPosition;
		rPosition = (POSITION) pNode->pPrev;
		return pNode->data; }

_AFXCOLL_INLINE void*& CPtrList::GetAt(POSITION position)
	{ CNode* pNode = (CNode*) position;
		return pNode->data; }

_AFXCOLL_INLINE void* CPtrList::GetAt(POSITION position) const
	{ CNode* pNode = (CNode*) position;
		return pNode->data; }

_AFXCOLL_INLINE void CPtrList::SetAt(POSITION pos, void* newElement)
	{ CNode* pNode = (CNode*) pos;
		pNode->data = newElement; }



////////////////////////////////////////////////////////////////////////////


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\minimfc\strcore2.cpp ===
/*++

Copyright (C) 1992-2001 Microsoft Corporation

Module Name:

    STRCORE2.CPP

Abstract:

History:

--*/

// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1993 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and Microsoft
// QuickHelp and/or WinHelp documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.


#include "precomp.h"

#define ASSERT(x)
#define ASSERT_VALID(x)


#define SafeStrlen strlen

//////////////////////////////////////////////////////////////////////////////
// concatenate in place

void CString::ConcatInPlace(int nSrcLen, const char* pszSrcData)
{
    //  -- the main routine for += operators

    // if the buffer is too small, or we have a width mis-match, just
    //   allocate a new buffer (slow but sure)
    if (m_nDataLength + nSrcLen > m_nAllocLength)
    {
        // we have to grow the buffer, use the Concat in place routine
        char* pszOldData = m_pchData;
        ConcatCopy(m_nDataLength, pszOldData, nSrcLen, pszSrcData);
        ASSERT(pszOldData != NULL);
        SafeDelete(pszOldData);
    }
    else
    {
        // fast concatenation when buffer big enough
        memcpy(&m_pchData[m_nDataLength], pszSrcData, nSrcLen);
        m_nDataLength += nSrcLen;
    }
    ASSERT(m_nDataLength <= m_nAllocLength);
    m_pchData[m_nDataLength] = '\0';
}

const CString& CString::operator +=(const char* psz)
{
    ConcatInPlace(SafeStrlen(psz), psz);
    return *this;
}

const CString& CString::operator +=(char ch)
{
    ConcatInPlace(1, &ch);
    return *this;
}

const CString& CString::operator +=(const CString& string)
{
    ConcatInPlace(string.m_nDataLength, string.m_pchData);
    return *this;
}

///////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\minimfc\strcore1.cpp ===
/*++

Copyright (C) 1992-2001 Microsoft Corporation

Module Name:

    STRCORE1.CPP

Abstract:

History:

--*/

// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1993 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and Microsoft
// QuickHelp and/or WinHelp documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "precomp.h"

#define ASSERT(x)
#define ASSERT_VALID(x)



/////////////////////////////////////////////////////////////////////////////
// static class data, special inlines

char  _afxChNil = '\0';

// For an empty string, m_???Data will point here
// (note: avoids a lot of NULL pointer tests when we call standard
//  C runtime libraries

extern const CString  afxEmptyString;
        // for creating empty key strings
const CString  afxEmptyString;

void CString::Init()
{
    m_nDataLength = m_nAllocLength = 0;
    m_pchData = (char*)&_afxChNil;
}

// declared static
void CString::SafeDelete(char* pch)
{
    if (pch != (char*)&_afxChNil)
        delete pch;
}

//////////////////////////////////////////////////////////////////////////////
// Construction/Destruction

CString::CString()
{
    Init();
}

CString::CString(const CString& stringSrc)
{
    // if constructing a CString from another CString, we make a copy of the
    // original string data to enforce value semantics (i.e. each string
    // gets a copy of its own

    stringSrc.AllocCopy(*this, stringSrc.m_nDataLength, 0, 0);
}

void CString::AllocBuffer(int nLen)
 // always allocate one extra character for '\0' termination
 // assumes [optimistically] that data length will equal allocation length
{
    ASSERT(nLen >= 0);
    ASSERT(nLen <= INT_MAX - 1);    // max size (enough room for 1 extra)

    if (nLen == 0)
    {
        Init();
    }
    else
    {
        m_pchData = new char[nLen+1];       // may throw an exception
        m_pchData[nLen] = '\0';
        m_nDataLength = nLen;
        m_nAllocLength = nLen;
    }
}

void CString::Empty()
{
    SafeDelete(m_pchData);
    Init();
    ASSERT(m_nDataLength == 0);
    ASSERT(m_nAllocLength == 0);
}

CString::~CString()
 //  free any attached data
{
    SafeDelete(m_pchData);
}

//////////////////////////////////////////////////////////////////////////////
// Helpers for the rest of the implementation

void CString::AllocCopy(CString& dest, int nCopyLen, int nCopyIndex,
     int nExtraLen) const
{
    // will clone the data attached to this string
    // allocating 'nExtraLen' characters
    // Places results in uninitialized string 'dest'
    // Will copy the part or all of original data to start of new string

    int nNewLen = nCopyLen + nExtraLen;

    if (nNewLen == 0)
    {
        dest.Init();
    }
    else
    {
        dest.AllocBuffer(nNewLen);
        memcpy(dest.m_pchData, &m_pchData[nCopyIndex], nCopyLen);
    }
}

//////////////////////////////////////////////////////////////////////////////
// More sophisticated construction

CString::CString(const char* psz)
{
    int nLen;
    if ((nLen = strlen(psz)) == 0)
        Init();
    else
    {
        AllocBuffer(nLen);
        memcpy(m_pchData, psz, nLen);
    }
}

//////////////////////////////////////////////////////////////////////////////
// Diagnostic support
/*
#ifdef _DEBUG
CDumpContext&  operator <<(CDumpContext& dc, const CString& string)
{
    dc << string.m_pchData;
    return dc;
}
#endif //_DEBUG
*/
//////////////////////////////////////////////////////////////////////////////
// Assignment operators
//  All assign a new value to the string
//      (a) first see if the buffer is big enough
//      (b) if enough room, copy on top of old buffer, set size and type
//      (c) otherwise free old string data, and create a new one
//
//  All routines return the new string (but as a 'const CString&' so that
//      assigning it again will cause a copy, eg: s1 = s2 = "hi there".
//

void CString::AssignCopy(int nSrcLen, const char* pszSrcData)
{
    // check if it will fit
    if (nSrcLen > m_nAllocLength)
    {
        // it won't fit, allocate another one
        Empty();
        AllocBuffer(nSrcLen);
    }
    if (nSrcLen != 0)
        memcpy(m_pchData, pszSrcData, nSrcLen);
    m_nDataLength = nSrcLen;
    m_pchData[nSrcLen] = '\0';
}

const CString& CString::operator =(const CString& stringSrc)
{
    AssignCopy(stringSrc.m_nDataLength, stringSrc.m_pchData);
    return *this;
}

const CString& CString::operator =(const char* psz)
{
    AssignCopy(strlen(psz), psz);
    return *this;
}


//////////////////////////////////////////////////////////////////////////////
// concatenation

// NOTE: "operator +" is done as friend functions for simplicity
//      There are three variants:
//          CString + CString
// and for ? = char, const char*
//          CString + ?
//          ? + CString

void CString::ConcatCopy(int nSrc1Len, const char* pszSrc1Data,
        int nSrc2Len, const char* pszSrc2Data)
{
  // -- master concatenation routine
  // Concatenate two sources
  // -- assume that 'this' is a new CString object

    int nNewLen = nSrc1Len + nSrc2Len;
    AllocBuffer(nNewLen);
    memcpy(m_pchData, pszSrc1Data, nSrc1Len);
    memcpy(&m_pchData[nSrc1Len], pszSrc2Data, nSrc2Len);
}

CString  operator +(const CString& string1, const CString& string2)
{
    CString s;
    s.ConcatCopy(string1.m_nDataLength, string1.m_pchData,
        string2.m_nDataLength, string2.m_pchData);
    return s;
}

CString  operator +(const CString& string, const char* psz)
{
    CString s;
    s.ConcatCopy(string.m_nDataLength, string.m_pchData, strlen(psz), psz);
    return s;
}


CString  operator +(const char* psz, const CString& string)
{
    CString s;
    s.ConcatCopy(strlen(psz), psz, string.m_nDataLength, string.m_pchData);
    return s;
}

///////////////////////////////////////////////////////////////////////////////
// Advanced direct buffer access

char* CString::GetBuffer(int nMinBufLength)
{
    ASSERT(nMinBufLength >= 0);

    if (nMinBufLength > m_nAllocLength)
    {
        // we have to grow the buffer
        char* pszOldData = m_pchData;
        int nOldLen = m_nDataLength;        // AllocBuffer will tromp it

        AllocBuffer(nMinBufLength);
        memcpy(m_pchData, pszOldData, nOldLen);
        m_nDataLength = nOldLen;
        m_pchData[m_nDataLength] = '\0';

        SafeDelete(pszOldData);
    }

    // return a pointer to the character storage for this string
    ASSERT(m_pchData != NULL);
    return m_pchData;
}

void CString::ReleaseBuffer(int nNewLength)
{
    if (nNewLength == -1)
        nNewLength = strlen(m_pchData); // zero terminated

    ASSERT(nNewLength <= m_nAllocLength);
    m_nDataLength = nNewLength;
    m_pchData[m_nDataLength] = '\0';
}

char* CString::GetBufferSetLength(int nNewLength)
{
    ASSERT(nNewLength >= 0);

    GetBuffer(nNewLength);
    m_nDataLength = nNewLength;
    m_pchData[m_nDataLength] = '\0';
    return m_pchData;
}

///////////////////////////////////////////////////////////////////////////////
// Commonly used routines (rarely used routines in STREX.CPP)

int CString::Find(char ch) const
{
    // find first single character
    char* psz;
#ifdef _WINDOWS
    if (afxData.bDBCS)
    {
        LPSTR lpsz = _AfxStrChr(m_pchData, ch);
        return (lpsz == NULL) ? -1
            : (int)((char*)_AfxGetPtrFromFarPtr(lpsz) - m_pchData);
    }
    else
#endif
        psz = strchr(m_pchData, ch);

    // return -1 if not found and index otherwise
    return (psz == NULL) ? -1 : (int)(psz - m_pchData);
}

int CString::FindOneOf(const char* pszCharSet) const
{
    ASSERT(pszCharSet != NULL);
#ifdef _WINDOWS
    if (afxData.bDBCS)
    {
        for (char* psz = m_pchData; *psz != '\0'; psz = _AfxAnsiNext(psz))
        {
            for (const char* pch = pszCharSet; *pch != '\0'; pch = _AfxAnsiNext(pch))
            {
                if (*psz == *pch &&     // Match SBC or Lead byte
                   (!_AfxIsDBCSLeadByte(*psz) || psz[1] == pch[1]))
                {
                    return (int)(psz - m_pchData);
                }
            }
        }
        return -1;  // not found
    }
    else
#endif
    {
        char* psz = (char*) strpbrk(m_pchData, pszCharSet);
        return (psz == NULL) ? -1 : (int)(psz - m_pchData);
    }
}

///////////////////////////////////////////////////////////////////////////////
// Additional constructors for far string data

#ifdef _DATA
CString::CString(LPCSTR lpsz)
{
    int nLen;
    if (lpsz == NULL || (nLen = lstrlen(lpsz)) == 0)
    {
        Init();
    }
    else
    {
        AllocBuffer(nLen);
        _fmemcpy(m_pchData, lpsz, nLen);
    }
}
#endif //_DATA
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\minimfc\strex.cpp ===
/*++

Copyright (C) 1992-2001 Microsoft Corporation

Module Name:

    STREX.CPP

Abstract:

History:

--*/

// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1993 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and Microsoft
// QuickHelp and/or WinHelp documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.


#include "precomp.h"

#define ASSERT(x)
#define ASSERT_VALID(x)

//////////////////////////////////////////////////////////////////////////////
// More sophisticated construction

CString::CString(char ch, int nLength)
{
    ASSERT(!_AfxIsDBCSLeadByte(ch));    // can't create a lead byte string
    if (nLength < 1)
        // return empty string if invalid repeat count
        Init();
    else
    {
        AllocBuffer(nLength);
        memset(m_pchData, ch, nLength);
    }
}


CString::CString(const char* pch, int nLength)
{
    if (nLength == 0)
        Init();
    else
    {
        ASSERT(pch != NULL);
        AllocBuffer(nLength);
        memcpy(m_pchData, pch, nLength);
    }
}

//////////////////////////////////////////////////////////////////////////////
// Additional constructors for far string data

#ifdef _NEARDATA

CString::CString(LPCSTR lpch, int nLen)
{
    if (nLen == 0)
        Init();
    else
    {
        AllocBuffer(nLen);
        _fmemcpy(m_pchData, lpch, nLen);
    }
}

#endif //_NEARDATA

//////////////////////////////////////////////////////////////////////////////
// Assignment operators

const CString& CString::operator =(char ch)
{
    ASSERT(!_AfxIsDBCSLeadByte(ch));    // can't set single lead byte
    AssignCopy(1, &ch);
    return *this;
}

//////////////////////////////////////////////////////////////////////////////
// less common string expressions

CString  operator +(const CString& string1, char ch)
{
    CString s;
    s.ConcatCopy(string1.m_nDataLength, string1.m_pchData, 1, &ch);
    return s;
}


CString  operator +(char ch, const CString& string)
{
    CString s;
    s.ConcatCopy(1, &ch, string.m_nDataLength, string.m_pchData);
    return s;
}

//////////////////////////////////////////////////////////////////////////////
// Very simple sub-string extraction

CString CString::Mid(int nFirst) const
{
    return Mid(nFirst, m_nDataLength - nFirst);
}

CString CString::Mid(int nFirst, int nCount) const
{
    ASSERT(nFirst >= 0);
    ASSERT(nCount >= 0);

    // out-of-bounds requests return sensible things
    if (nFirst + nCount > m_nDataLength)
        nCount = m_nDataLength - nFirst;
    if (nFirst > m_nDataLength)
        nCount = 0;

    CString dest;
    AllocCopy(dest, nCount, nFirst, 0);
    return dest;
}

CString CString::Right(int nCount) const
{
    ASSERT(nCount >= 0);

    if (nCount > m_nDataLength)
        nCount = m_nDataLength;

    CString dest;
    AllocCopy(dest, nCount, m_nDataLength-nCount, 0);
    return dest;
}

CString CString::Left(int nCount) const
{
    ASSERT(nCount >= 0);

    if (nCount > m_nDataLength)
        nCount = m_nDataLength;

    CString dest;
    AllocCopy(dest, nCount, 0, 0);
    return dest;
}

// strspn equivalent
CString CString::SpanIncluding(const char* pszCharSet) const
{
    ASSERT(pszCharSet != NULL);
    return Left(strspn(m_pchData, pszCharSet));
}

// strcspn equivalent
CString CString::SpanExcluding(const char* pszCharSet) const
{
    ASSERT(pszCharSet != NULL);
    return Left(strcspn(m_pchData, pszCharSet));
}

//////////////////////////////////////////////////////////////////////////////
// Finding

int CString::ReverseFind(char ch) const
{
    char* psz;
#ifdef _WINDOWS
    if (afxData.bDBCS)
    {
        // compare forward remembering the last match
        char* pszLast = NULL;
        psz = m_pchData;
        while (*psz != '\0')
        {
            if (*psz == ch)
                pszLast = psz;
            psz = _AfxAnsiNext(psz);
        }
        psz = pszLast;
    }
    else
#endif
        psz = (char*)strrchr(m_pchData, ch);

    return (psz == NULL) ? -1 : (int)(psz - m_pchData);
}

// find a sub-string (like strstr)
int CString::Find(const char* pszSub) const
{
    ASSERT(pszSub != NULL);
    char* psz;

#ifdef _WINDOWS
    if (afxData.bDBCS)
    {
        for (psz = m_pchData; TRUE; psz = _AfxAnsiNext(psz))
        {
            // stop looking if at end of string
            if (*psz == '\0')
            {
                psz = NULL;
                break;
            }

            // compare the substring against current position
            const char* psz1 = psz;
            const char* psz2 = pszSub;
            while (*psz2 == *psz1 && *psz2 != '\0')
                ++psz1, ++psz2;

            // continue looking unless there was a match
            if (*psz2 == '\0')
                break;
        }
    }
    else
#endif
        psz = (char*)strstr(m_pchData, pszSub);

    // return -1 for not found, distance from beginning otherwise
    return (psz == NULL) ? -1 : (int)(psz - m_pchData);
}

///////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\mofcompiler\mofcomp.cpp ===
//depot/private/wmi_branch2/admin/wmi/wbem/Winmgmt/mofcompiler/mofcomp.cpp#7 - edit change 38018 (text)
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

    MOFCOMP.CPP

Abstract:

    Entry points for the WBEM MOF compiler.

History:

    a-davj  12-April-97   Added WMI support.

--*/

#include "precomp.h"
#include <stdio.h>
#include <locale.h>
#include <initguid.h>
#include <wbemidl.h>
#include <winver.h>
#include <cominit.h>
#include <wbemutil.h>
#include <wbemcli.h>
#include <mofcomp.h>
#include <cominit.h>
#include <objidl.h>
#include "mofutils.h"
#include "strings.h"
#include <strutils.h>

char cFileName[MAX_PATH];
WCHAR wFileName[MAX_PATH+1];
WCHAR wTempFileName[MAX_PATH];
WCHAR wBMOFFileName[MAX_PATH];
WCHAR wResourceName[MAX_PATH];

int __cdecl main(int argc, char** argv)
{ 
    BOOL bExtractResource = FALSE;
    BOOL bUseLocal = FALSE;
    WORD wLocaleId = 0;
    cFileName[0] = 0;
    wFileName[0] = 0;
    wTempFileName[0] = 0;
    wBMOFFileName[0]= 0;
    wResourceName[0] = 0;
    bool bBmofSet = false;

    // Set locale so that strings are correctly processed.
    // ===================================================
    setlocale(LC_ALL, "");    

    HRESULT hres;
    SCODE sc;

    // Parse command line arguments
    // ============================
    WCHAR UserName[MAX_PATH];
    WCHAR Password[MAX_PATH];
    WCHAR * pPassword = NULL;
    WCHAR Authority[MAX_PATH];
    WCHAR wszDefault[MAX_PATH];

    TCHAR pVersion[100];
    BOOL bRet = GetVerInfo(TEXT("ProductVersion"), pVersion, 100); 
    if(bRet)
    Trace(false, LONGVERSION, pVersion);
    else
    Trace(false, SHORTVERSION);
    Trace(false, COPYRIGHT);
    if(argc < 2)
    {
        PrintUsage();
        return 1;
    }

    // Set locale so that strings are correctly processed.
    // ===================================================
    setlocale(LC_ALL, "");    

    // Init buffers for command line args.
    // ===================================
    UserName[0] = 0;
    Password[0] = 0;
    Authority[0] = 0;
    wszDefault[0] = 0;
    long lLoginFlags = 0;

    // This scope is defined so that the local variables, such as the PARSE 
    // object are destroyed before CoUninitialize is called.

    char cBMOFOutputName[MAX_PATH] = "";

    // Parse command line arguments
    // ============================

    bool bClassFlagsHardcoded = false;
    bool bInstanceFlagsHardcoded = false;
    long lClassFlags = 0;
    long lInstanceFlags = 0;
    long lOptionFlags = WBEM_FLAG_CONSOLE_PRINT;
    char * pTemp;
    
    for(int i = 1; i < argc-1; i++)
    {
        char *pcCurrArg = argv[i] + 1; 
        if(argv[i][0] != '-' && argv[i][0] != '/')
        {
            PrintUsage();
            return 1;
        }
        if(!wbem_stricmp(pcCurrArg, "check"))
        {
            lOptionFlags |= WBEM_FLAG_CHECK_ONLY;
        }
        else if(!wbem_stricmp(pcCurrArg, "AUTORECOVER"))
        {
            lOptionFlags |= WBEM_FLAG_AUTORECOVER;
        }
        else if(!wbem_strnicmp(pcCurrArg, "er:", 3))
        {
            if(strlen(pcCurrArg) <=3)
            {
                PrintUsage();
                return 1;
            }
            bExtractResource = true;
            mbstowcs(wResourceName, pcCurrArg+3, MAX_PATH);
        }
        else if(toupper(pcCurrArg[0]) == 'L' && pcCurrArg[1] == ':')
        {
            bUseLocal = TRUE;
            wLocaleId = (WORD)atoi(&pcCurrArg[2]);
        }
        else if(!wbem_stricmp(pcCurrArg, "WMI"))
        {
            HINSTANCE hLib  = LoadLibraryEx(TEXT("wmimofck.exe"), NULL, LOAD_LIBRARY_AS_DATAFILE);
            if(hLib == NULL)
            {
                Trace(true, WMI_NOT_SETUP);
                return 1;
            }
            else FreeLibrary(hLib);
            lOptionFlags |= WBEM_FLAG_WMI_CHECK;
        }
        else if(!wbem_stricmp(pcCurrArg, "class:updateonly"))
        {
            lClassFlags |= WBEM_FLAG_UPDATE_ONLY;
        }
        else if(!wbem_stricmp(pcCurrArg, "class:createonly"))
        {
            lClassFlags |= WBEM_FLAG_CREATE_ONLY;
        }
        else if(!wbem_stricmp(pcCurrArg, "class:safeupdate"))
        {
            lClassFlags |= WBEM_FLAG_UPDATE_SAFE_MODE;
        }
        else if(!wbem_stricmp(pcCurrArg, "class:forceupdate"))
        {
            lClassFlags |= WBEM_FLAG_UPDATE_FORCE_MODE;
        }
        else if(!wbem_stricmp(pcCurrArg, "instance:updateonly"))
        {
            if(lInstanceFlags != 0)
            {
            PrintUsage();
            return 1;
            }
            lInstanceFlags = WBEM_FLAG_UPDATE_ONLY;
        }
        else if(!wbem_stricmp(pcCurrArg, "instance:createonly"))
        {
            if(lInstanceFlags != 0)
            {
            PrintUsage();
            return 1;
            }
            lInstanceFlags = WBEM_FLAG_CREATE_ONLY;
        }
        else if(!wbem_strnicmp(pcCurrArg, "Amendment:", 10))
        {
            if(strlen(pcCurrArg) <=10)
            {
                PrintUsage();
                return 1;
            }
            strcat(cBMOFOutputName, ",a");
            strcat(cBMOFOutputName, pcCurrArg+10);
            mbstowcs(wBMOFFileName, cBMOFOutputName, MAX_PATH);
            lOptionFlags |= WBEM_FLAG_SPLIT_FILES;
        }
        else if(!wbem_strnicmp(pcCurrArg, "mof:", 4))
        {
            if(strlen(pcCurrArg) <=4)
            {
                PrintUsage();
                return 1;
            }
            strcat(cBMOFOutputName, ",n");
            strcat(cBMOFOutputName, pcCurrArg+4);
            mbstowcs(wBMOFFileName, cBMOFOutputName, MAX_PATH);
            lOptionFlags |= WBEM_FLAG_SPLIT_FILES;
        }
        else if(!wbem_strnicmp(pcCurrArg, "mfl:", 4))
        {
            if(strlen(pcCurrArg) <=4)
            {
                PrintUsage();
                return 1;
            }
            strcat(cBMOFOutputName, ",l");
            strcat(cBMOFOutputName, pcCurrArg+4);
            mbstowcs(wBMOFFileName, cBMOFOutputName, MAX_PATH);
            lOptionFlags |= WBEM_FLAG_SPLIT_FILES;
        }
        else if(toupper(pcCurrArg[0]) == 'C' && pcCurrArg[1] == ':')
        {
            if(lClassFlags != 0)
            {
            PrintUsage();
            return 1;
            }
                bClassFlagsHardcoded = true;
            lClassFlags = atol(&pcCurrArg[2]);
        }
        else if(toupper(pcCurrArg[0]) == 'I' && pcCurrArg[1] == ':')
        {
            if(lInstanceFlags != 0)
            {
            PrintUsage();
            return 1;
            }
                bInstanceFlagsHardcoded = true;
            lInstanceFlags = atol(&pcCurrArg[2]);
        }
        else if(toupper(*pcCurrArg) == 'N')
        {
            if(!bGetString(argv[i]+2, wszDefault))
            return 1;
        }
        else if(toupper(*pcCurrArg) == 'B')
        {
            if(strlen(argv[i]) <=3 || argv[i][2] != ':' || wcslen(wBMOFFileName))
            {
                PrintUsage();
                return 1;
            }
            strcpy(cBMOFOutputName, argv[i]+3);
            mbstowcs(wBMOFFileName, cBMOFOutputName, MAX_PATH);
            bBmofSet = true;
        }
        else if(toupper(*pcCurrArg) == 'U')
        {
            if(!bGetString(argv[i]+2, UserName))
            return 1;
        }
        else if(toupper(*pcCurrArg) == 'P')
        {
            // Allow for blank password
    
            char * pArg = argv[i];
            if(pArg[2] != ':' || pArg[3] != 0)         // Dont use bGetString for empty password case
            if(!bGetString(argv[i]+2, Password))
                return 1;
            pPassword = Password;
        }
        else if(toupper(*pcCurrArg) == 'A')
        {
            if(!bGetString(argv[i]+2, Authority))
            return 1;
        }

        else
        {
            PrintUsage();
            return 1;
        }
    }


    // Do a sanity check of the flags chosen

    if((bClassFlagsHardcoded == false && !ValidFlags(true, lClassFlags)) || 
       (bInstanceFlagsHardcoded == false && !ValidFlags(false, lInstanceFlags)))
    {
        PrintUsage();
        return 1;
    }

    if((lOptionFlags & WBEM_FLAG_WMI_CHECK) && strlen(cBMOFOutputName) < 1)
    {
        Trace(true, WMI_ARG_ERROR);
        return 1;
    }

    pTemp = argv[argc-1];
    if((pTemp[0] == '-' || pTemp[0] == '/') && pTemp[1] == '?' && pTemp[2] == 0)
    {
        PrintUsage();
        return 1;
    }
    if((lOptionFlags & WBEM_FLAG_SPLIT_FILES) && bBmofSet)
    {
        PrintUsage();
        return 1;
    }
    

    // display the file name and make sure it is a valid file

    strcpy(cFileName, argv[argc-1]);
    mbstowcs(wTempFileName, argv[argc-1], MAX_PATH);
	DWORD nRes = ExpandEnvironmentStrings(wTempFileName,
										  wFileName,
										  FILENAME_MAX);
    if(nRes == 0)
        lstrcpy(wFileName, wTempFileName);

    if(GetFileAttributesW(wFileName) == 0xFFFFFFFF)
    {
        Trace(true, FILE_NOT_FOUND, wFileName);
        return 1;
    }


    hres = InitializeCom();
    if(FAILED(hres))
    {
        Trace(true, COMINIT_ERROR, hres);
        return 3;
    }

    WBEM_COMPILE_STATUS_INFO info;
    hres = InitializeSecurity(NULL, -1, NULL, NULL, 
                                RPC_C_AUTHN_LEVEL_DEFAULT, 
                                RPC_C_IMP_LEVEL_IDENTIFY, 
                                NULL, EOAC_NONE, 0);

    IMofCompiler * pCompiler = NULL;
    sc = CoCreateInstance(CLSID_MofCompiler, 0, CLSCTX_INPROC_SERVER,
                                    IID_IMofCompiler, (LPVOID *) &pCompiler);
    
    // special fix that will self register the mofd.dll if it isnt already registered

    if(sc != S_OK)
    {
        HRESULT (STDAPICALLTYPE *pFunc)(void);
        HINSTANCE hLib = LoadLibrary(TEXT("mofd.dll"));
        if(hLib)
        {
            pFunc = (HRESULT (STDAPICALLTYPE *)(void))GetProcAddress(hLib, "DllRegisterServer");
            if(pFunc)
            {
                pFunc();
                sc = CoCreateInstance(CLSID_MofCompiler, 0, CLSCTX_INPROC_SERVER,
                                    IID_IMofCompiler, (LPVOID *) &pCompiler);
            }
            FreeLibrary(hLib);
        }
    }
    
    if(sc == S_OK)
    {
        if(strlen(cBMOFOutputName) > 0)
            sc = pCompiler->CreateBMOF( wFileName, wBMOFFileName, wszDefault,
                        lOptionFlags, lClassFlags,
                            lInstanceFlags, &info);
        else if (bExtractResource)
            sc = ExtractFromResource(pCompiler, wResourceName, wFileName, wszDefault, 
                            UserName, Authority, pPassword, lOptionFlags, lClassFlags,
                            lInstanceFlags, &info,
                            bUseLocal,
                            wLocaleId);
        else
            sc = pCompiler->CompileFile(wFileName, wszDefault, UserName, 
                            Authority, pPassword, lOptionFlags, lClassFlags,
                            lInstanceFlags, &info);
        if(sc != S_OK)
            Trace(true, COMPILER_ERROR, info.hRes);

        pCompiler->Release();
        
    }
    else
    {
        Trace(true, CCI_ERROR, sc);
        return 3;
    }

    CoUninitialize();

    if(sc == S_OK)
    {
        Trace(true, DONE);
        return 0;
    }
    else
        return info.lPhaseError;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\mofcompiler\mofutils.cpp ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

    MOFUTILSD.CPP

Abstract:

    Support of trace output and internationalized strings.

History:

    a-davj  13-July-97   Created.

--*/

#include "precomp.h"
#include <reg.h>
#include "strings.h"
#include <stdio.h>
#include <stdarg.h>
#include <wbemutil.h>
#include <wbemcli.h>
#include <mrciclass.h>
#include <arrtempl.h>
#include <scopeguard.h>
#include "mofutils.h"

TCHAR JustInCase = 0;
 
//***************************************************************************
//
//  int Trace
//
//  DESCRIPTION:
//
//  Allows for the output function (printf in this case) to be overridden.
//
//  PARAMETERS:
//
//  *fmt                format string.  Ex "%s hello %d"
//  ...                 argument list.  Ex cpTest, 23
//
//  RETURN VALUE:
//
//  size of output in characters.
//***************************************************************************

int Trace(bool bError, DWORD dwID, ...)
{

    IntString is(dwID);
    TCHAR * fmt = is;

    TCHAR *buffer = new TCHAR[2048];
    if(buffer == NULL)
        return 0;
    char *buffer2 = new char[4096];
    if(buffer2 == NULL)
    {
        delete buffer;
        return 0;
    }

    va_list argptr;
    int cnt;
    va_start(argptr, dwID);

#ifdef UNICODE
    cnt = _vsnwprintf(buffer, 2048, fmt, argptr);
#else
    cnt = _vsnprintf(buffer, 2048, fmt, argptr);
#endif
    va_end(argptr);
    CharToOem(buffer, buffer2);

    printf("%s", buffer2);
    if(bError)
        ERRORTRACE((LOG_MOFCOMP,"%s", buffer2));
    else
        DEBUGTRACE((LOG_MOFCOMP,"%s", buffer2));

    delete buffer;
    delete buffer2;
    return cnt;
}

void PrintUsage()
{
    Trace(false, USAGE1);
    Trace(false, USAGE1A);
    Trace(false, USAGE1B);
    Trace(false, USAGE1C);
    Trace(false, USAGE1D);
    Trace(false, USAGE1E);
    Trace(false, USAGE1F);
    Trace(false, USAGE1G);
    Trace(false, USAGE2);
    Trace(false, USAGE3);
    Trace(false, USAGE4);
    Trace(false, USAGE4a);
    Trace(false, USAGE4b);
    Trace(false, USAGE5);
    Trace(false, USAGE6);
    Trace(false, USAGE7);
    Trace(false, USAGE8);
    Trace(false, USAGE9);
    Trace(false, USAGE10);
    Trace(false, USAGE11);
    Trace(false, USAGE12);
    Trace(false, USAGE12A);
    Trace(false, USAGE12B);
    Trace(false, USAGE12C);
    Trace(false, USAGE12D);
    Trace(false, USAGE12E);
    Trace(false, USAGE12F);
    Trace(false, USAGE12G);
    Trace(false, USAGE13);
    Trace(false, USAGE14);
}
//******************************************************************************
//
//  See GETVER.H for documentation
//
//******************************************************************************
BOOL GetVerInfo(TCHAR * pResStringName, 
                        TCHAR * pRes, DWORD dwResSize)
{
    // Extract Version informatio

    DWORD dwTemp, dwSize = MAX_PATH;
    TCHAR cName[MAX_PATH+1];
    BOOL bRet = FALSE;
    cName[MAX_PATH] = 0;
    HINSTANCE hInst = GetModuleHandle(NULL);
    long lSize = GetModuleFileName(hInst, cName, MAX_PATH); 
    if(lSize == 0)
        return FALSE;
    lSize = GetFileVersionInfoSize(cName, &dwTemp);
    if(lSize < 1)
        return FALSE;
    
    BYTE * pBlock = new BYTE[lSize];
    if(pBlock != NULL)
    {
        bRet = GetFileVersionInfo(cName, NULL, lSize, pBlock);

        if(bRet)
        {
            TCHAR lpSubBlock[MAX_PATH];
            TCHAR * lpBuffer = NULL;
            UINT wBuffSize = MAX_PATH;

            short * piStuff; 
            bRet = VerQueryValue(pBlock, TEXT("\\VarFileInfo\\Translation") , (void**)&piStuff, &wBuffSize);
            if(bRet)
            {
                wsprintf(lpSubBlock,TEXT("\\StringFileInfo\\%04x%04x\\%ls"),piStuff[0], piStuff[1],L"ProductVersion");
                bRet = VerQueryValue(pBlock, lpSubBlock, (void**)&lpBuffer, &wBuffSize);
            }
            if(bRet == FALSE)
            {
                // Try again in english
                wsprintf(lpSubBlock,TEXT("\\StringFileInfo\\040904E4\\%ls"),pResStringName);                        
                bRet = VerQueryValue(pBlock, lpSubBlock,(void**)&lpBuffer, &wBuffSize);
            }
            if(bRet)
                lstrcpyn(pRes, lpBuffer, dwResSize);
        }

        delete pBlock;
    }
    return bRet;
}


IntString::IntString(DWORD dwID)
{
    DWORD dwSize, dwRet;

    for(dwSize = 128; dwSize < 4096; dwSize *= 2)
    {
        m_pString = new TCHAR[dwSize];
        if(m_pString == NULL)
        {
            m_pString = &JustInCase;     // should never happen!
            return; 
        }
        dwRet = LoadString( GetModuleHandle(NULL), dwID, m_pString, dwSize);

        // Check for failure to load

        if(dwRet == 0)
        {
            delete m_pString;
			m_pString = &JustInCase;     // should never happen!
            return; 
        }
        // Check for the case where the buffer was too small

        if((dwRet + 1) >= dwSize)
            delete m_pString;
        else
            return;             // all is well!
    }
}

IntString::~IntString()
{
    if(m_pString != &JustInCase)
        delete(m_pString);
}
 
//***************************************************************************
//
//  BOOL bGetString
//
//  DESCRIPTION:
//
//  Converts a command line argument into a WCHAR string.  Note that the arugment is 
//  of the form /X:stuff.  This is passed a pointer to the colon.
//
//  PARAMETERS:
//
//  pArg                Input, pointer to the colon
//  pOut                Points the the output buffer where the data is to be copied.
//                      IT IS ASSUMED THAT pOut points to a buffer of MAX_PATH length
//
//
//  RETURN VALUE:
//
//  TRUE if OK
//
//***************************************************************************

BOOL bGetString(char * pIn, WCHAR * pOut)
{
    if(pIn == NULL)
        return FALSE;
    if(*pIn != ':')
    {
        PrintUsage();
        return FALSE;
    }
    pIn++;          // skip passed the colon
    int iLen = mbstowcs(NULL, pIn, strlen(pIn)+1);
    if(iLen > MAX_PATH-1)
    {
        PrintUsage();
        return FALSE;
    }
    
    int iRet = mbstowcs(pOut, pIn, MAX_PATH-1);
    if(iRet < 1)
    {
        PrintUsage();
        return FALSE;
    }
    return TRUE;
}
//***************************************************************************
//
//  ValidFlags.
//
//***************************************************************************

bool ValidFlags(bool bClass, long lFlags)
{
    if(bClass)
        return  ((lFlags == WBEM_FLAG_CREATE_OR_UPDATE) ||
             (lFlags == WBEM_FLAG_UPDATE_ONLY) ||
             (lFlags == WBEM_FLAG_CREATE_ONLY) ||
             (lFlags == WBEM_FLAG_UPDATE_SAFE_MODE) ||
             (lFlags == WBEM_FLAG_UPDATE_FORCE_MODE) ||
             (lFlags == (WBEM_FLAG_UPDATE_ONLY | WBEM_FLAG_UPDATE_SAFE_MODE)) ||
             (lFlags == (WBEM_FLAG_UPDATE_ONLY | WBEM_FLAG_UPDATE_FORCE_MODE)));
    else
        return 
        ((lFlags == WBEM_FLAG_CREATE_OR_UPDATE) ||
             (lFlags == WBEM_FLAG_UPDATE_ONLY) ||
             (lFlags == WBEM_FLAG_CREATE_ONLY));
}

HRESULT ExtractFromResource(
    IMofCompiler * pCompiler,
        LPWSTR pwsResourceName,
        [in, string] LPWSTR FileName,
        [in, string] LPWSTR ServerAndNamespace,
        [in, string] LPWSTR User,
        [in, string] LPWSTR Authority,
        [in, string] LPWSTR Password,
        [in] LONG lOptionFlags,             // autocomp, check, etc
        [in] LONG lClassFlags,
        [in] LONG lInstanceFlags,
        [in, out] WBEM_COMPILE_STATUS_INFO * pInfo,
        BOOL bUseLocal,
        WORD wLocaleId        
        )
{

    pInfo->lPhaseError = 1;        // 0, 1, 2, or 3 matching current return value
    pInfo->hRes = 0;            // Actual error
    pInfo->ObjectNum = 0;
    pInfo->FirstLine = 0;
    pInfo->LastLine = 0;
    pInfo->dwOutFlags = 0;

    // load the driver that has the resource

    HRESULT hr; 
    HINSTANCE hInst;
    HRSRC hSrc = NULL;
    HGLOBAL hResource;

    // load up the library as a datafile
    
    hInst = LoadLibraryEx(FileName,NULL,LOAD_LIBRARY_AS_DATAFILE);
    if( hInst == NULL )
    {
        pInfo->hRes = GetLastError();
        return pInfo->hRes;
    }

    ON_BLOCK_EXIT(FreeLibrary, hInst);
    
    // Get the handle to the resource

    if( bUseLocal)
    {
        hSrc = FindResourceEx(hInst,pwsResourceName, L"MOFDATA",wLocaleId);
    }
    else
    {
        hSrc = FindResource(hInst,pwsResourceName, L"MOFDATA");
    }
    if( hSrc == NULL )
    {
        pInfo->hRes = GetLastError();
        return pInfo->hRes;
    }

    // Get a pointer to the resource
    hResource = LoadResource( hInst,hSrc);
    if(hResource == NULL)
    {
        pInfo->hRes = GetLastError();
        return pInfo->hRes;
    }
    
    BYTE * pRes = (BYTE *)LockResource(hResource);
    DWORD dwSize = SizeofResource(hInst,hSrc);
    if(pRes == NULL)
    {
        pInfo->hRes = GetLastError();
        return pInfo->hRes;
    }

    // finally do the actual compile
    
    hr = pCompiler->CompileBuffer(
                                                        dwSize,
                                                        pRes,
                                                        ServerAndNamespace,
                                                        User,
                                                        Authority,
                                                        Password,
                                                        lOptionFlags,
                                                        lClassFlags,
                                                        lInstanceFlags,
                                                       pInfo);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\mofcompiler\mofutils.h ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

    MOFUTILS.H

Abstract:

	Declares the MOFUTILS functions.

History:

	a-davj  13-July-97   Created.

--*/

#ifndef __MOFUTILS__H_
#define __MOFUTILS__H_


int Trace(bool bError, DWORD dwID, ...);
void PrintUsage();
BOOL GetVerInfo(TCHAR * pResStringName, TCHAR * pRes, DWORD dwResSize);
BOOL bGetString(char * pIn, WCHAR * pOut);
bool ValidFlags(bool bClass, long lFlags);

class IntString
{
    TCHAR *m_pString;
public:
	 IntString(DWORD dwID);
	~IntString();
    operator TCHAR *() { return m_pString; } 
};

HRESULT ExtractFromResource(
    IMofCompiler * pCompiler,
    LPWSTR pwsResourceName,
    LPWSTR FileName,
    LPWSTR ServerAndNamespace,
    LPWSTR User,
    LPWSTR Authority,
    LPWSTR Password,
    LONG lOptionFlags,             // autocomp, check, etc
    LONG lClassFlags,
    LONG lInstanceFlags,
    WBEM_COMPILE_STATUS_INFO * pInfo,
    BOOL bUseLocale,
    WORD wLocaleId        
        );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\mofcompiler\precomp.h ===
//depot/private/wmi_branch2/admin/wmi/wbem/Winmgmt/mofcompiler/precomp.h#2 - integrate change 14733 (text)
/*++

Copyright (C) 1999-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/
#pragma warning (disable : 4786)
#include <ole2.h>
#include <windows.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\mofcompiler\strings.h ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

    STRINGS.H

Abstract:

	Resource definitions

History:

--*/


#define USAGE1 0
#define USAGE1A USAGE1+1
#define USAGE1B USAGE1A+1
#define USAGE1C USAGE1B+1
#define USAGE1D USAGE1C+1
#define USAGE1E USAGE1D+1
#define USAGE1G  USAGE1E+1
#define USAGE2  USAGE1G+1
#define USAGE3  USAGE2+1
#define USAGE4  USAGE3+1
#define USAGE4a  USAGE4+1
#define USAGE4b  USAGE4a+1
#define USAGE5  USAGE4b+1
#define USAGE6  USAGE5+1
#define USAGE7  USAGE6+1
#define USAGE8  USAGE7+1
#define USAGE9  USAGE8+1
#define USAGE10 USAGE9+1
#define USAGE11 USAGE10+1
#define USAGE12  USAGE11+1
#define USAGE12A  USAGE12+1
#define USAGE12B  USAGE12A+1
#define USAGE12C  USAGE12B+1
#define USAGE12D  USAGE12C+1
#define USAGE12E  USAGE12D+1

#define USAGE13  USAGE12E+1
#define USAGE14  USAGE13+1
#define WMI_ARG_ERROR  USAGE14+1
#define PARSING_MSG     WMI_ARG_ERROR+1
#define FILE_NOT_FOUND  PARSING_MSG+1
#define WMI_NOT_SETUP FILE_NOT_FOUND+1

#define  SUCCESS WMI_NOT_SETUP+1
#define  DONE SUCCESS+1
#define  WMI_LAUNCH_ERROR DONE+1
#define LONGVERSION WMI_LAUNCH_ERROR+1
#define SHORTVERSION LONGVERSION+1
#define COPYRIGHT SHORTVERSION+1
#define CCI_ERROR   COPYRIGHT+1
#define COMINIT_ERROR CCI_ERROR+1
#define COMPILER_ERROR COMINIT_ERROR+1
#define USAGE1F  COMPILER_ERROR+1
#define USAGE12F  USAGE1F+1
#define USAGE12G  USAGE12F+1
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\mofcomp_dll\bmofchck.cpp ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

    BMOFCHCK.CPP

Abstract:

    Has test to determine if a binary mof is valid.  Note that the file has
    not been tested and is not currently a part of mofcomp.  This exists as a
    backup in case the current fixes are not bullet proof.
    
History:

    davj  27-Nov-00   Created.


--*/
 
#include "precomp.h"
#include <wbemutil.h>
#include <genutils.h>
#include "trace.h"
#include "bmof.h"

BYTE *  CheckObject(BYTE * pObj, BYTE * pToFar, DWORD dwSizeOfObj);
DWORD CheckString(BYTE * pStr,BYTE * pToFar);
void CheckClassOrInst(WBEM_Object * pObject, BYTE * pToFar);
enum EFailureType
{
    UNALIGNED_PTR = 0,
    BAD_OBJECT,
    BAD_SIZE,
    BAD_STRING,
    BAD_ARRAY_DATA,
    BAD_SCALAR_DATA,
    BAD_FLAVOR_TABLE
};

class CGenException
{
private:
    EFailureType m_eType;

public:

    CGenException( EFailureType eType ){ m_eType =eType ;}
    EFailureType GetErrorCode() { return m_eType; }
};


#ifdef _WIN64
#define RETURN_IF_UNALIGN64() return FALSE;
#else
#define RETURN_IF_UNALIGN64()
#endif

void CheckAlignment(DWORD dwToCheck)
{
    if(dwToCheck & 3)
    {
        ERRORTRACE((LOG_MOFCOMP,"CheckAlignment\n"));
#ifdef _WIN64
        throw CGenException( UNALIGNED_PTR );
#endif
    }
}

DWORD CheckSimpleValue(BYTE *pData, BYTE *pToFar, DWORD dwType, BOOL bQualifier)
{
    DWORD dwTypeSize = iTypeSize(dwType);
    if(dwTypeSize == 0)
        throw CGenException( BAD_SCALAR_DATA );
        
    if(dwType == VT_DISPATCH)
    {
        WBEM_Object * pObject;
        pObject = (WBEM_Object *)pData;
        CheckClassOrInst(pObject, pToFar);
        return pObject->dwLength;            
    }
    else if(dwType == VT_BSTR)
    {
        DWORD dwNumChar = CheckString(pData ,pToFar);
        return (dwNumChar+1) * sizeof(WCHAR);
    }
    if(pData + dwTypeSize >= pToFar)
        throw CGenException( BAD_SCALAR_DATA );
    return dwTypeSize;
}

void CheckValue(BYTE * pData, BYTE * pToFar, DWORD dwType, BOOL bQualifier)
{
    DWORD * pArrayInfo, dwNumObj, dwCnt;
    if(pData >= pToFar)
        throw CGenException( BAD_OBJECT );
    CheckAlignment((DWORD)pData);
    if(dwType & VT_ARRAY)
    {
        CheckObject(pData, pToFar, 4*sizeof(DWORD));
        DWORD dwSimpleType = dwType & ~VT_ARRAY & ~VT_BYREF;
        pArrayInfo = (DWORD *)pData;
        // check the number of rows.  Currently only 1 is supported

        pArrayInfo++;
        if(*pArrayInfo != 1)
        {
           throw CGenException( BAD_ARRAY_DATA );
        }

        // Get the number of objects

        pArrayInfo++;
        dwNumObj = *pArrayInfo;

        // Start into the row.  It starts off with the total size

        pArrayInfo++;
        CheckAlignment(*pArrayInfo);

        // Test each object

        pArrayInfo++;       // now points to first object

        BYTE * pSingleData = (BYTE *)pArrayInfo;
        for(dwCnt = 0; dwCnt < dwNumObj; dwCnt++)
        {
            DWORD dwSize = CheckSimpleValue(pSingleData, pToFar, dwSimpleType, bQualifier);
            pSingleData += dwSize;
        }
    }
    else
        CheckSimpleValue(pData, pToFar, dwType, bQualifier);
}

BYTE *  CheckObject(BYTE * pObj, BYTE * pToFar, DWORD dwSizeOfObj)
{
    if(pObj + dwSizeOfObj >= pToFar)
        throw CGenException( BAD_OBJECT );
    CheckAlignment((DWORD)pObj);

    // these always start off with the size, make sure that is OK
    
    DWORD * pdw = (DWORD *)pObj;
        
    if(*pdw + pObj >= pToFar)
        throw CGenException( BAD_SIZE );
    return *pdw + pObj + 1;
}
DWORD CheckString(BYTE * pStr,BYTE * pToFar)
{
    DWORD dwNumChar = 0;
    if(pStr >= pToFar)
        throw CGenException( BAD_STRING );
    CheckAlignment((DWORD)pStr);
    WCHAR * pwc;
    for(pwc = (WCHAR *)pStr; *pwc && pwc < (WCHAR*)pToFar; pwc++, dwNumChar++);   // intentional semi
    if(pwc >= (WCHAR *)pToFar)
        throw CGenException( BAD_STRING );
    return dwNumChar;
}

void CheckQualifier(WBEM_Qualifier *pQual, BYTE * pToFar)
{
    BYTE * pByteInfo = (BYTE *)pQual;
    pByteInfo += sizeof(WBEM_Qualifier);
    pToFar = CheckObject((BYTE *)pQual, pToFar, sizeof(WBEM_Qualifier));
    CheckString(pByteInfo + pQual->dwOffsetName, pToFar);
    CheckValue(pByteInfo + pQual->dwOffsetValue, pToFar, pQual->dwType, TRUE);
    return;
}

void CheckQualList(WBEM_QualifierList *pQualList, BYTE * pToFar)
{
    DWORD dwNumQual, dwCnt;
    WBEM_Qualifier *pQual;

    pToFar = CheckObject((BYTE *)pQualList, pToFar, sizeof(WBEM_QualifierList));

    dwNumQual = pQualList->dwNumQualifiers;
    if(dwNumQual == 0)
        return;
    pQual = (WBEM_Qualifier *)((PBYTE)pQualList + sizeof(WBEM_QualifierList));

    for(dwCnt = 0; dwCnt < dwNumQual; dwCnt++)
    {
        CheckQualifier(pQual, pToFar);
        pQual = (WBEM_Qualifier *)((BYTE *)pQual + pQual->dwLength);
    }
    return;
}

void CheckProperty(WBEM_Property *pProperty, BOOL bProperty, BYTE * pToFar)
{
    WBEM_QualifierList *pQualList;
    BYTE * pValue;
    pToFar = CheckObject((BYTE *)pProperty, pToFar, sizeof(WBEM_Property));
    if(pProperty->dwOffsetName != 0xffffffff)
    {
        BYTE * pStr =  ((BYTE *)pProperty +
                                    sizeof(WBEM_Property) +
                                    pProperty->dwOffsetName);
        CheckString(pStr, pToFar);
    }

    if(pProperty->dwOffsetQualifierSet != 0xffffffff)
    {
        pQualList = (WBEM_QualifierList *)((BYTE *)pProperty +
                            sizeof(WBEM_Property) +
                            pProperty->dwOffsetQualifierSet);
        CheckQualList(pQualList, pToFar);
    }

    if(pProperty->dwOffsetValue != 0xffffffff)
    {
        CheckAlignment(pProperty->dwOffsetValue & 3);
        pValue = ((BYTE *)pProperty +
                            sizeof(WBEM_Property) +
                            pProperty->dwOffsetValue);

        CheckValue(pValue, pToFar, pProperty->dwType, FALSE);
    }   
    return;
}

void CheckPropList(WBEM_PropertyList *pPropList, BOOL bProperty, BYTE * pToFar)
{
    DWORD dwNumProp, dwCnt;
    WBEM_Property *pProperty;

    pToFar = CheckObject((BYTE *)pPropList, pToFar, sizeof(WBEM_PropertyList));

    dwNumProp = pPropList->dwNumberOfProperties;
    if(dwNumProp == 0)
        return;
    pProperty = (WBEM_Property *)((PBYTE)pPropList + sizeof(WBEM_PropertyList));

    for(dwCnt = 0; dwCnt < dwNumProp; dwCnt++)
    {
        CheckProperty(pProperty, bProperty, pToFar);
        pProperty = (WBEM_Property *)((BYTE *)pProperty + pProperty->dwLength);
    }
    return;
}

void CheckClassOrInst(WBEM_Object * pObject, BYTE * pToFar)
{
    WBEM_QualifierList *pQualList;
    WBEM_PropertyList * pPropList;
    WBEM_PropertyList * pMethodList;
    
    pToFar = CheckObject((BYTE *)pObject, pToFar, sizeof(WBEM_Object));
    if(pObject->dwType != 0 && pObject->dwType != 1)
        throw CGenException( BAD_OBJECT );

    // Check the qualifier list
    
    if(pObject->dwOffsetQualifierList != 0xffffffff)
    {
        pQualList = (WBEM_QualifierList *)((BYTE *)pObject +
                            sizeof(WBEM_Object) +
                            pObject->dwOffsetQualifierList);
        CheckQualList(pQualList, pToFar);
    }

    // check the property list

    if(pObject->dwOffsetPropertyList != 0xffffffff)
    {
        pPropList = (WBEM_PropertyList *)((BYTE *)pObject +
                            sizeof(WBEM_Object) +
                            pObject->dwOffsetPropertyList);
        CheckPropList(pPropList, TRUE, pToFar);
    }

    // check the method list

    if(pObject->dwOffsetMethodList != 0xffffffff)
    {
        
        pMethodList = (WBEM_PropertyList *)((BYTE *)pObject +
                            sizeof(WBEM_Object) +
                            pObject->dwOffsetMethodList);
        CheckPropList(pMethodList, FALSE, pToFar);
    }
    return;
}

void CheckBMOFQualFlavor(BYTE * pBinaryMof, BYTE *  pToFar)
{
    UNALIGNED DWORD * pdwTemp;
    BYTE * pFlavorBlob;
    DWORD dwNumPairs;
    UNALIGNED DWORD * pOffset;
    DWORD dwMyOffset;
    DWORD dwCnt;
    DWORD dwOrigBlobSize = 0;

    // Calculate the pointer of the start of the flavor data

    pdwTemp = (DWORD * )pBinaryMof;
    pdwTemp++;                            // point to the original blob size
    dwOrigBlobSize = *pdwTemp;
    pFlavorBlob = pBinaryMof + dwOrigBlobSize;

    // Dont even try past the end of memory

    if(pFlavorBlob + 20 >= pToFar)
        return;

    // Check if the flavor blob is valid, it should start off with the 
    // characters "BMOFQUALFLAVOR11"

    if(memcmp(pFlavorBlob, "BMOFQUALFLAVOR11", 16))
        return;                               // Not really a problem since it may be old file
    
    // The flavor part of the file has the format 
    // DWORD dwNumPair, followed by pairs of dwords;
    // offset, flavor

    // Determine the number of pairs

    pFlavorBlob+= 16;                           // skip past signature
    pdwTemp = (DWORD *)pFlavorBlob;
    dwNumPairs = *pdwTemp;              // Number of offset/value pairs
    if(dwNumPairs < 1)
        return;

    // Given the number of pairs, make sure there is enough memory

    if((pFlavorBlob + sizeof(DWORD) +  (dwNumPairs * 2 * sizeof(DWORD)))>= pToFar)
        throw CGenException( BAD_FLAVOR_TABLE );

    // point to the first offset/flavor pair

    pOffset = pdwTemp+1;

    // go through the offset/flavor list.  Ignore the flavors, but make sure the
    // offsets are valid

    for(dwCnt = 0; dwCnt < dwNumPairs; dwCnt++)
    {
        if(*pOffset >= dwOrigBlobSize)
            throw CGenException( BAD_FLAVOR_TABLE );
        pOffset += 2;
    }
    

}

//***************************************************************************
//
//  IsValidBMOF.
//
//  DESCRIPTION:
//
//  Checks to make sure that a binary mof is properly aligned on
//  4 byte boundaries.  Note that this is not really necessary for
//  32 bit windows.
//
//  PARAMETERS:
//
//  pBuffer               Pointer to uncompressed binary mof data.
//
//  RETURN:
//
//  TRUE if all is well.
//
//***************************************************************************

BOOL IsValidBMOF(BYTE * pData, BYTE * pToFar)
{
    WBEM_Binary_MOF * pBinaryMof;
    DWORD dwNumObj, dwCnt;
    WBEM_Object * pObject;
    if(pData == NULL || pToFar == NULL || pData >= pToFar)
        return FALSE;
    try
    {

        pBinaryMof = (WBEM_Binary_MOF *)pData;
        CheckObject(pData, pToFar, sizeof(WBEM_Binary_MOF));
        if(pBinaryMof->dwSignature != BMOF_SIG)
            return FALSE;
        dwNumObj = pBinaryMof->dwNumberOfObjects;
        if(dwNumObj == 0)
            return TRUE;
        pObject = (WBEM_Object *)(pData + sizeof(WBEM_Binary_MOF));
        for(dwCnt = 0; dwCnt < dwNumObj; dwCnt++)
        {
            CheckClassOrInst(pObject, pToFar);
            pObject = (WBEM_Object *)((PBYTE *)pObject + pObject->dwLength);
        }
        CheckBMOFQualFlavor(pData, pToFar);
    }
    catch(CGenException)
    {
        ERRORTRACE((LOG_MOFCOMP,"BINARY MOF had exception\n"));
        return FALSE; 
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\mofcomp_dll\bmofhelp.cpp ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

    BMOFHELP.CPP

Abstract:

    Creates the object list from the binary mof file

History:

	a-davj  14-April-97   Created.

--*/

#include "precomp.h"
#include <stdio.h>
#include <float.h>
#include <mofout.h>
#include <mofparse.h>
#include <moflex.h>
#include <mofdata.h>

#include <typehelp.h>

#include <io.h>
#include <fcntl.h>
#include <stdio.h>
#include <sys/stat.h>
//#include <corepol.h>
#include <wbemutil.h>
#include <genutils.h>

#include "bmof.h"
#include "cbmofout.h"
#include "bmofhelp.h"
#include "trace.h"
#include "strings.h"
#include "mrcicode.h"
#include <autoptr.h>
#include <arrtempl.h>


long lObjectNumber = 0;
class CFreeMe
{
private:
    VARIANT * m_pVar;
public:
    CFreeMe(VARIANT * pVar){m_pVar = pVar;};
    ~CFreeMe();

};

CFreeMe::~CFreeMe()
{
    if(m_pVar)
    {
        VARTYPE vt = m_pVar->vt & ~VT_ARRAY;
        try
        {
            if(vt == VT_BSTR)
                VariantClear(m_pVar);
            else if(m_pVar->vt & VT_ARRAY)
                SafeArrayDestroyDescriptor(m_pVar->parray);
            m_pVar->vt = VT_EMPTY;


        }
        catch(...)
        {}
    }
    
}

//***************************************************************************
//
//  CMoQualifierArray *  CreateQual
//
//  DESCRIPTION:
//
//  Creates a CMoQualifierArray by using a CBMOFQualList object.
//
//  RETURN VALUE:
//
//  Pointer to new object, NULL if error.
//
//***************************************************************************

CMoQualifierArray *  CreateQual(CMofData * pOutput, CBMOFQualList * pql, CMObject * pObj,LPCWSTR wszPropName, PDBG pDbg)
{
    ResetQualList(pql);

    WCHAR * pName = NULL;
    DWORD dwFlavor= 0;
    CBMOFDataItem Data;
    VARIANT var;
    VariantInit(&var);
	CMoQualifierArray * pRet = new CMoQualifierArray(pDbg);
    if(pRet == NULL)
        return NULL;
    while(NextQualEx(pql, &pName, &Data, &dwFlavor, pOutput->GetBmofBuff(), pOutput->GetBmofToFar()))
    {
        BOOL bAliasRef;
        VariantInit(&var);
        BMOFToVariant(pOutput, &Data, &var, bAliasRef,FALSE, pDbg);
        CFreeMe fm(&var);
        wmilib::auto_ptr<CMoQualifier> pQual(new CMoQualifier(pDbg));
        if(pQual.get() == NULL)
            return NULL;
        if(pName == NULL || FAILED(pQual->SetQualName(pName)))
            return NULL;
        if(dwFlavor)
        {
            if(dwFlavor & WBEM_FLAVOR_AMENDED)
            {
                pQual->SetAmended(true);
            }
            else
                pQual->SetAmended(false);
            pQual->SetFlavor(dwFlavor);
        }
		BOOL bArray = var.vt & VT_ARRAY;
        if(bAliasRef && !bArray)
        {
            CMoValue & Value = pQual->AccessValue();
            if(FAILED(AddAliasReplaceValue(Value, var.bstrVal)))
                return NULL;
        }
		else if(bAliasRef && bArray)
		{
			SAFEARRAY* psaSrc = var.parray;
			long lLBound, lUBound;
			SafeArrayGetLBound(psaSrc, 1, &lLBound);
			SafeArrayGetUBound(psaSrc, 1, &lUBound);
			CMoValue & Value = pQual->AccessValue();

	        for(long lIndex = lLBound; lIndex <= lUBound; lIndex++)
		    {
			    // Load the initial data element into a VARIANT
				// ============================================

				BSTR bstr;
				SCODE sc = SafeArrayGetElement(psaSrc, &lIndex, &bstr);
				if(FAILED(sc))
					return NULL;
				CSysFreeMe FM(bstr);
				if(bstr[0] == L'$')
				{
        			sc = Value.AddAlias(&bstr[1], lIndex);	// skip the leading $
					if(FAILED(sc))
						return NULL;
	                GUID guid;
					CoCreateGuid(&guid);

					WCHAR wszGuidBuffer[100];
					StringFromGUID2(guid, wszGuidBuffer, 100);

					BSTR bstrNew = SysAllocString(wszGuidBuffer);
					if(bstrNew == NULL)
						return NULL;
					sc = SafeArrayPutElement(psaSrc, &lIndex, bstrNew);
					SysFreeString(bstrNew);
					if(FAILED(sc))
						return NULL;
				}
			}
			SCODE sc = WbemVariantChangeType(pQual->GetpVar(), &var, var.vt);
		}
        else
        {
            SCODE sc = WbemVariantChangeType(pQual->GetpVar(), &var, var.vt);
        }
//        VariantClear(&var);
        free(pName);
        if (pRet->Add(pQual.get()))
        {
            pQual.release();
        }
    }
    pRet->RegisterAliases(pObj,wszPropName);
    return pRet;
}

//***************************************************************************
//
//  SCODE ConvertValue
//
//  DESCRIPTION:
//
//  Creates a CMoQualifierArray by using a CBMOFQualList object.
//
//  RETURN VALUE:
//
//  Pointer to new object, NULL if error.
//
//***************************************************************************

SCODE ConvertValue(CMoProperty * pProp, VARIANT * pSrc, BOOL bAliasRef)
{
    VARIANT * pDest;
    pDest = pProp->GetpVar();
	if((pSrc->vt & ~VT_ARRAY) == VT_EMBEDDED_OBJECT)
	{
		pDest->vt = pSrc->vt;
		pDest->punkVal = pSrc->punkVal;		// also works if this is parrayVal!
        pSrc->vt = VT_EMPTY;                // DONT CLEAR THIS since destination is taking ownership
		return S_OK;
	}
    if(!bAliasRef)
        return WbemVariantChangeType(pProp->GetpVar(), pSrc, pSrc->vt);
    if(pSrc->vt == VT_BSTR)
    {
        CMoValue & Value = pProp->AccessValue();
        return AddAliasReplaceValue(Value, pSrc->bstrVal);
    }
    if(pSrc->vt == (VT_BSTR | VT_ARRAY))
    {
        SAFEARRAY* psaSrc = V_ARRAY(pSrc);

        long lLBound, lUBound;
        SafeArrayGetLBound(psaSrc, 1, &lLBound);
        SafeArrayGetUBound(psaSrc, 1, &lUBound);

        // Stuff the individual data pieces
        // ================================

        for(long lIndex = lLBound; lIndex <= lUBound; lIndex++)
        {
            // Load the initial data element into a VARIANT
            // ============================================

            BSTR bstr;
            SafeArrayGetElement(psaSrc, &lIndex, &bstr);

            if(bstr[0] == L' ')
            {
                BSTR bstrNew = SysAllocString(&bstr[1]);
                if(bstrNew == NULL)
                	return WBEM_E_OUT_OF_MEMORY;
                SCODE sc2 = SafeArrayPutElement(psaSrc, &lIndex, bstrNew);
                SysFreeString(bstrNew);
                if(FAILED(sc2))
                	return sc2;
            }
            else
            {
        
                CMoValue & Value = pProp->AccessValue();
                HRESULT hr2 = Value.AddAlias(&bstr[1],lIndex);  // skip over the $ used it indcate alias
                if(FAILED(hr2))
                    return hr2;

                // Create a unique value and put it in there
                // =========================================

                GUID guid;
                CoCreateGuid(&guid);

                WCHAR wszGuidBuffer[100];
                StringFromGUID2(guid, wszGuidBuffer, 100);

                BSTR bstrNew = SysAllocString(wszGuidBuffer);
                if(bstrNew == NULL)
                	return WBEM_E_OUT_OF_MEMORY;
                SCODE sc2 = SafeArrayPutElement(psaSrc, &lIndex, bstrNew);
                SysFreeString(bstrNew);
                if(FAILED(sc2))
                	return sc2;
            }
        }

        return WbemVariantChangeType(pProp->GetpVar(), pSrc, pSrc->vt);

    }
    else
        return WBEM_E_FAILED;
}

//***************************************************************************
//
//  BOOL ConvertBufferIntoIntermediateForm()
//
//  DESCRIPTION:
//
//  Creates a CMObject (the parse object format) from a CBMOFObj (binary mof format)
//  object.
//
//  PARAMETERS:
//
//  pOutput				Pointer to object that will hold the intermediate data.
//  pBuff				Binary mof data.
//
//  RETURN VALUE:
//
//  TRUE if OK.
//
//***************************************************************************

BOOL ConvertBufferIntoIntermediateForm(CMofData * pOutput, BYTE * pBuff, PDBG pDbg, BYTE * pBmofToFar)
{

	CBMOFObj * po;
	BOOL bRet;
    // Create a ObjList object

    pOutput->SetBmofBuff(pBuff);
    pOutput->SetBmofToFar(pBmofToFar);
    CBMOFObjList * pol = CreateObjList(pBuff);
    ResetObjList(pol);
    OnDelete<void *,void(__cdecl *)(void *),free> fm(pol);

    lObjectNumber = 0;
    while(po = NextObj(pol))
    {
        if(!BMOFParseObj(pOutput, po, NULL, FALSE, pDbg))
        {
            free(po);
            return FALSE;
        }
        free(po);
        lObjectNumber++;
    }
    bRet = TRUE;            // Got all the way through with no errors.

    return bRet;
}


//***************************************************************************
//
//  BOOL BMOFParseObj
//
//  DESCRIPTION:
//
//  Creates a CMObject (the parse object format) from a CBMOFObj (binary mof format)
//  object.
//
//  PARAMETERS:
//
//  pObj				pointer to binary mof object.
//	pVar				poninter to a variant which will point to the resulting 
//						object.  If this is NULL, then the object is a top level
//						(not embedded) object and it will be added to the main
//						object list.
//
//  RETURN VALUE:
//
//  TRUE if OK.
//
//***************************************************************************

BOOL BMOFParseObj(CMofData * pOutput, CBMOFObj * po, VARIANT * pVar, BOOL bMethArg, PDBG pDbg)
{
	VARIANT var;
    CBMOFDataItem Data;
    WCHAR * pClassName;
    BOOL bAliasRef;
    CMoQualifierArray * paQualifiers;
    wmilib::auto_ptr<CMObject> pObject;


    // Check the type.  This is a sanity check for weeding out old format files!

    DWORD dwType = GetType(po);
    if(dwType != 0 && dwType != 1)
    {
        Trace(true,pDbg,INVALID_BMOF_OBJECT_TYPE);
        return FALSE;
    }

    // Create either the new class of instance object

    if(!GetName(po, &pClassName))
    {
        Trace(true,pDbg, CANT_FIND_CLASS_NAME);
        return FALSE;
    }
    
    if(GetType(po) == 0)
    {
        if(FindProp(po, L"__SuperClass", &Data))
        {
            BMOFToVariant(pOutput, &Data, &var, bAliasRef, FALSE, pDbg);

            pObject.reset(new CMoClass( var.bstrVal, pClassName, pDbg));
            VariantClear(&var);
        }
        else
            pObject.reset(new CMoClass( NULL, pClassName, pDbg));
    }
    else
    {
        pObject.reset(new CMoInstance(pClassName, pDbg));
    }
    free(pClassName);
    if(pObject.get() == NULL)
        return FALSE;
    if(pObject->IsOK() == false)
        return FALSE;

    // Get the namespace and add it

    if(FindProp(po, L"__Namespace", &Data))
    {
        BMOFToVariant(pOutput, &Data, &var, bAliasRef, FALSE, pDbg);
        HRESULT hr = pObject->SetNamespace(var.bstrVal);
        VariantClear(&var);
        if(FAILED(hr))
            return FALSE;
    }

    // Add other pragma values

    long lClass = 0;
    long lInstance = 0;
    if(FindProp(po, L"__ClassFlags", &Data))
	{
        BMOFToVariant(pOutput, &Data, &var, bAliasRef, FALSE, pDbg);
		lClass = var.lVal;
		VariantClear(&var);
	}
    if(FindProp(po, L"__InstanceFlags", &Data))
	{
        BMOFToVariant(pOutput, &Data, &var, bAliasRef, FALSE, pDbg);
		lInstance = var.lVal;
		VariantClear(&var);
	}
    pObject->SetOtherDefaults(lClass, lInstance);


    if(FindProp(po, L"__ALIAS", &Data))
    {
        BMOFToVariant(pOutput, &Data, &var, bAliasRef, FALSE, pDbg);
        HRESULT hr2 = pObject->SetAlias(var.bstrVal);
        VariantClear(&var);
        if(FAILED(hr2))
        {
            return FALSE;
        }
    }

    CBMOFQualList * pql = GetQualList(po);
	if(pql)
	{
		paQualifiers = CreateQual(pOutput, pql, pObject.get(), NULL, pDbg);
		if(paQualifiers)
			pObject->SetQualifiers(paQualifiers);
			
        free(pql);
	}

    ResetObj(po);

    WCHAR * pPropName = NULL;

    while(NextProp(po, &pPropName, &Data))
    {
        VariantInit(&var);
        BOOL bGotValue = BMOFToVariant(pOutput, &Data, &var, bAliasRef, FALSE, pDbg);
        CFreeMe fm(&var);
            
        // ignore these special properties

        if(!wbem_wcsicmp(pPropName,L"__Class") || 
           !wbem_wcsicmp(pPropName,L"__SuperClass") ||
           !wbem_wcsicmp(pPropName,L"__ALIAS") ||
           !wbem_wcsicmp(pPropName,L"__CLASSFLAGS") ||
           !wbem_wcsicmp(pPropName,L"__INSTANCEFLAGS") ||
           !wbem_wcsicmp(pPropName,L"__NameSpace"))
        {
            free(pPropName);
            continue;
        }


        wmilib::auto_ptr<CValueProperty> pProp( new CValueProperty(NULL, pDbg));
        if(pProp.get() == NULL)
            return FALSE;
        if(FAILED(pProp->SetPropName(pPropName)))
            return FALSE;

	    pql = GetPropQualList(po, pPropName);
        paQualifiers = NULL;
		if(pql)
		{
			if(paQualifiers = CreateQual(pOutput, pql, pObject.get(), pPropName, pDbg))
				pProp->SetQualifiers(paQualifiers);
                    free(pql);
                    if(paQualifiers == NULL)
                        return FALSE;
		}
		if(bGotValue)
        {
			SCODE sc = ConvertValue(pProp.get(), &var, bAliasRef);
        }
		else
		{
			VARIANT * t_pVar = pProp->GetpVar();
			t_pVar->vt = VT_NULL;
			t_pVar->lVal = 0;
		}

        // Set the type.  Note that numeric types are stored as strings and so it is necessary to
        // get the type from the cimtype qualifier

        CMoValue* pValue = NULL;
        if(paQualifiers)
            pValue = paQualifiers->Find(L"CIMTYPE");
        if(pValue)
        {
            CMoType Type(pDbg);
            VARIANT& varRef = pValue->AccessVariant();
            if(varRef.vt == VT_BSTR && varRef.bstrVal)
            {
                HRESULT hr2 = Type.SetTitle(varRef.bstrVal);
                if(FAILED(hr2))
                {
                    return FALSE;
                }
                VARTYPE vt = Type.GetCIMType();
                if(Data.m_dwType & VT_ARRAY)
                    vt |= VT_ARRAY;
                pProp->SetType(vt);
            }
        }
        else
            pProp->SetType((VARTYPE)Data.m_dwType);

        if (pObject->AddProperty(pProp.get()))
        {
            pProp->RegisterAliases(pObject.get());           
            if(bMethArg)
                pProp->SetAsArg(); 
            pProp.release();             
        }

        free(pPropName);
        pPropName = NULL;
    }

    // Get the methods
    
    WCHAR * pMethName = NULL;

    while(NextMeth(po, &pMethName, &Data))
    {
        VariantClear(&var);
		BOOL bGotValue = BMOFToVariant(pOutput, &Data, &var, bAliasRef, TRUE, pDbg);
        CFreeMe fm(&var);
        wmilib::auto_ptr<CMethodProperty> pMeth( new CMethodProperty(NULL, pDbg, TRUE));
        if(pMeth.get() == NULL)
            return FALSE;
        if(FAILED(pMeth->SetPropName(pMethName)))
            return FALSE;

	    pql = GetMethQualList(po, pMethName);
        paQualifiers = NULL;
		if(pql)
		{
			if(paQualifiers = CreateQual(pOutput, pql, pObject.get(), pMethName, pDbg))
				pMeth->SetQualifiers(paQualifiers);
            free(pql);
		}
		if(bGotValue)
        {
			SCODE sc = ConvertValue(pMeth.get(), &var, bAliasRef);

            long lLower, lUpper, lCnt;
            sc = SafeArrayGetLBound(var.parray, 1, &lLower);
            sc = SafeArrayGetUBound(var.parray, 1, &lUpper);
			CMoInstance * pTemp;

            for(lCnt = lLower; lCnt <= lUpper; lCnt++)
            {
                pTemp = NULL;
			    sc = SafeArrayGetElement(var.parray, &lCnt, &pTemp);
                if(sc == S_OK && pTemp)
                {
                    // If there are two objects, then the first is inputs and the second outputs.  If there
                    // is just one, examine the object 

                    if(lLower != lUpper && lCnt == lLower)
                        pMeth->SetIn(pTemp);
                    else if(lLower != lUpper && lCnt == lUpper)
                        pMeth->SetOut(pTemp);
                    else if(pTemp->IsInput())
                        pMeth->SetIn(pTemp);
                    else 
                        pMeth->SetOut(pTemp);
                }
            }
        }
		else
		{
			VARIANT * t_pVar = pMeth->GetpVar();
			t_pVar->vt = VT_NULL;
			t_pVar->lVal = 0;
		}
        pMeth->SetType((VARTYPE)Data.m_dwType);

        if (pObject->AddProperty(pMeth.get()))
        {
            pMeth->RegisterAliases(pObject.get());
            pMeth.release();
        }
        free(pMethName);
    }


	if(pVar)
	{
            pVar->punkVal = (IUnknown *)pObject.get();
	}
	else
		pOutput->AddObject(pObject.get());
       pObject.release();
	return TRUE;
}

//***************************************************************************
//
//  BOOL BMOFToVariant
//
//  DESCRIPTION:
//
//  Converts a bmof data object into a variant
//
//***************************************************************************

BOOL BMOFToVariant(CMofData * pOutput, CBMOFDataItem * pData, VARIANT * pVar, BOOL & bAliasRef, BOOL bMethodArg, PDBG pDbg)
{
    SCODE sc;
    VariantInit(pVar);
	DWORD dwSimpleType = pData->m_dwType & ~VT_ARRAY & ~VT_BYREF;
    bAliasRef = pData->m_dwType & VT_BYREF;

    long lFirstDim;
    VARIANT vTemp;  

	long lNumDim = GetNumDimensions(pData);
	if(lNumDim == -1)
		return FALSE;

    pVar->vt = (WORD)pData->m_dwType & ~VT_BYREF;

    if(lNumDim == 0)
    {
        memset((BYTE *)&(vTemp.lVal),0,8);
		if(!GetData(pData, (BYTE *)&(vTemp.lVal), NULL))
        {
            pVar->vt = VT_EMPTY;
			return FALSE;
        }
        if(dwSimpleType == VT_BSTR)
        {
            pVar->bstrVal = SysAllocString(vTemp.bstrVal);
            BMOFFree(vTemp.bstrVal);
            if(pVar->bstrVal == NULL)
                return FALSE;
        }
		else if(dwSimpleType == VT_EMBEDDED_OBJECT)
		{
			CBMOFObj * pObj;
			pObj = (CBMOFObj *)vTemp.bstrVal;
			BMOFParseObj(pOutput, pObj, pVar, bMethodArg, pDbg);
            BMOFFree(pObj);
			return TRUE;
		}
        else
            memcpy((void *)&(pVar->bstrVal), (void *)&(vTemp.bstrVal),8); 

        return TRUE;
    }
	    
    
	lFirstDim = GetNumElements(pData, 0);

    
    DWORD ulLower, ulUpper;
    
    SAFEARRAY * psa;
    SAFEARRAYBOUND rgsabound[1];
    long ix[2] = {0,0};
    ulLower = 0;
    ulUpper = lFirstDim-1;
    rgsabound[0].lLbound = ulLower;
    rgsabound[0].cElements = ulUpper - ulLower +1;

#ifdef _WIN64
	VARTYPE vtTemp = (dwSimpleType == VT_EMBEDDED_OBJECT) ? VT_R8 : (VARTYPE)dwSimpleType;
#else
	VARTYPE vtTemp = (dwSimpleType == VT_EMBEDDED_OBJECT) ? VT_I4 : (VARTYPE)dwSimpleType;
#endif
    psa = SafeArrayCreate(vtTemp,1,rgsabound);
    for(ix[0] = ulLower; ix[0] <= (long)ulUpper; ix[0]++) 
    {

        memset((BYTE *)&(vTemp.lVal),0,8);

		GetData(pData, (BYTE *)&(vTemp.lVal), ix);	
        if(dwSimpleType == VT_BSTR)
        {
            BSTR bstr = SysAllocString(vTemp.bstrVal);
            free(vTemp.bstrVal);
            vTemp.vt = VT_EMPTY;
            if(bstr == NULL)
            {
                pVar->vt = VT_EMPTY;
                return FALSE;
            }
            sc = SafeArrayPutElement(psa,ix,(void *)bstr);
            SysFreeString(bstr);
            if(FAILED(sc))
            	return FALSE;
        }
		else if(dwSimpleType == VT_EMBEDDED_OBJECT)
		{
			CBMOFObj * pObj;
			VARIANT vConv;
			VariantInit(&vConv);
			pObj = (CBMOFObj *)vTemp.punkVal;
			BMOFParseObj(pOutput, pObj, &vConv, bMethodArg, pDbg);
            free(pObj);
            sc = SafeArrayPutElement(psa,ix,(void *)&vConv.lVal);
            if(FAILED(sc))
            	return FALSE;
		}
        else
        {
            memcpy((void *)&(pVar->bstrVal), (void *)&(vTemp.bstrVal),8); 
            sc = SafeArrayPutElement(psa,ix,(void *)&(vTemp.lVal));
            if(FAILED(sc))
            	return FALSE;
        }
    
 //       VariantClear(&vTemp);
    }
    pVar->parray = psa;
    return TRUE;

}

//***************************************************************************
//
//  void AddAliasReplaceValue
//
//  DESCRIPTION:
//
//  Used when a Value has an alias.
//
//  RETURN VALUE:
//
//  TRUE if the file is a binary mof
//
//***************************************************************************

HRESULT AddAliasReplaceValue(CMoValue & Value, const WCHAR * pAlias)
{
    
    HRESULT hr = Value.AddAlias(pAlias);
    if(FAILED(hr))
        return hr;
    V_VT(&Value.AccessVariant()) = VT_BSTR;

        // Create a unique value and put it in there
        // =========================================

    GUID guid;
    CoCreateGuid(&guid);

    WCHAR wszGuidBuffer[100];
    StringFromGUID2(guid, wszGuidBuffer, 100);

    BSTR bstr = SysAllocString(wszGuidBuffer);
    if(bstr == NULL)
        return WBEM_E_OUT_OF_MEMORY;
    V_BSTR(&Value.AccessVariant()) = bstr;
    return S_OK;
}

extern "C" void * BMOFAlloc(size_t Size)
{
    return malloc(Size);
}
extern "C" void BMOFFree(void * pFree)
{
    free(pFree);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\mofcomp_dll\comobj.cpp ===
/*++

Copyright (C) 1998-2001 Microsoft Corporation

Module Name:

    COMOBJ.CPP

Abstract:

    Implements mofcomp com objects.

History:

    a-davj  17-Sept-98       Created.

--*/

#include "precomp.h"
#include "commain.h"
#include "wbemcli.h"
#include "wbemprov.h"
#include "wbemint.h"
#include "comobj.h"
#include "mofout.h"
#include "mofparse.h"
#include "dllcalls.h"
#include "datasrc.h"

SCODE Compile(CMofParser & Parser, IWbemServices *pOverride, IWbemContext * pCtx, long lOptionFlags, long lClassFlags, long lInstanceFlags,
                WCHAR * wszDefault, WCHAR *UserName, WCHAR *pPassword , WCHAR *Authority, 
                WCHAR * wszBmof, bool bInProc, WBEM_COMPILE_STATUS_INFO *pInfo);

void ClearStatus(WBEM_COMPILE_STATUS_INFO  *pInfo)
{
    if(pInfo)
    {
    pInfo->lPhaseError = 0;        // 0, 1, 2, or 3 matching current return value
    pInfo->hRes = 0;            // Actual error
    pInfo->ObjectNum = 0;
    pInfo->FirstLine = 0;
    pInfo->LastLine = 0;
    pInfo->dwOutFlags = 0;
    }
}

HRESULT APIENTRY  CompileFileViaDLL( 
            /* [in] */ LPWSTR FileName,
            /* [in] */ LPWSTR ServerAndNamespace,
            /* [in] */ LPWSTR User,
            /* [in] */ LPWSTR Authority,
            /* [in] */ LPWSTR Password,
            /* [in] */ LONG lOptionFlags,
            /* [in] */ LONG lClassFlags,
            /* [in] */ LONG lInstanceFlags,
            /* [out][in] */ WBEM_COMPILE_STATUS_INFO __RPC_FAR *pInfo)
{
    SCODE sc;
    if(FileName == NULL)
        return WBEM_E_INVALID_PARAMETER;

    TCHAR cFile[MAX_PATH];
    ClearStatus(pInfo);
    TCHAR * pFile = NULL;
    if(FileName)
    {
        CopyOrConvert(cFile, FileName, MAX_PATH);
        pFile = cFile;
    }

    try
    {
        DebugInfo dbg((lOptionFlags & WBEM_FLAG_CONSOLE_PRINT) != 0);
        CMofParser Parser(pFile, &dbg);

        sc = Compile(Parser, NULL, NULL, lOptionFlags, lClassFlags, lInstanceFlags,
                    ServerAndNamespace, User, Password, Authority, 
                    NULL, false, pInfo);
    }
    catch (GenericException ge)
    {
        sc = ge.GetHRESULT();
    }
    return sc;

}

HRESULT APIENTRY  CreateBMOFViaDLL( 
            /* [in] */ LPWSTR TextFileName,
            /* [in] */ LPWSTR BMOFFileName,
            /* [in] */ LPWSTR ServerAndNamespace,
            /* [in] */ LONG lOptionFlags,
            /* [in] */ LONG lClassFlags,
            /* [in] */ LONG lInstanceFlags,
            /* [out][in] */ WBEM_COMPILE_STATUS_INFO __RPC_FAR *pInfo)
{
    SCODE sc;
    TCHAR cFile[MAX_PATH];

    if(TextFileName == NULL || BMOFFileName == NULL)
        return WBEM_E_INVALID_PARAMETER;

    ClearStatus(pInfo);
    TCHAR * pFile = NULL;
    if(TextFileName)
    {
        CopyOrConvert(cFile, TextFileName, MAX_PATH);
        pFile = cFile;
    }
    try
    {

        DebugInfo dbg((lOptionFlags & WBEM_FLAG_CONSOLE_PRINT) != 0);
        CMofParser Parser(pFile, &dbg);

        sc = Compile(Parser, NULL, NULL, lOptionFlags, lClassFlags, lInstanceFlags,
                    ServerAndNamespace, NULL, NULL, NULL, 
                    BMOFFileName, false, pInfo);
    }
    catch (GenericException ge)
    {
        sc = ge.GetHRESULT();
    }
    return sc;

}


HRESULT CMofComp::CompileFile( 
            /* [in] */ LPWSTR FileName,
            /* [in] */ LPWSTR ServerAndNamespace,
            /* [in] */ LPWSTR User,
            /* [in] */ LPWSTR Authority,
            /* [in] */ LPWSTR Password,
            /* [in] */ LONG lOptionFlags,
            /* [in] */ LONG lClassFlags,
            /* [in] */ LONG lInstanceFlags,
            /* [out][in] */ WBEM_COMPILE_STATUS_INFO __RPC_FAR *pInfo)
{
    SCODE sc;
    if(FileName == NULL)
        return WBEM_E_INVALID_PARAMETER;

    TCHAR cFile[MAX_PATH];
    ClearStatus(pInfo);
    TCHAR * pFile = NULL;
    if(FileName)
    {
        CopyOrConvert(cFile, FileName, MAX_PATH);
        pFile = cFile;
    }

    try
    {
        DebugInfo dbg((lOptionFlags & WBEM_FLAG_CONSOLE_PRINT) != 0);
        CMofParser Parser(pFile, &dbg);
        if((lOptionFlags & WBEM_FLAG_CHECK_ONLY) && (lOptionFlags & WBEM_FLAG_CONSOLE_PRINT))
            Parser.SetToDoScopeCheck();

        sc = Compile(Parser, NULL, NULL, lOptionFlags, lClassFlags, lInstanceFlags,
                    ServerAndNamespace, User, Password, Authority, 
                    NULL, false, pInfo);
    }
    catch (GenericException ge)
    {
        sc = ge.GetHRESULT();
    }
    return sc;

}
        
HRESULT CMofComp::CompileBuffer( 
            /* [in] */ long BuffSize,
            /* [size_is][in] */ BYTE __RPC_FAR *pBuffer,
            /* [in] */ LPWSTR ServerAndNamespace,
            /* [in] */ LPWSTR User,
            /* [in] */ LPWSTR Authority,
            /* [in] */ LPWSTR Password,
            /* [in] */ LONG lOptionFlags,
            /* [in] */ LONG lClassFlags,
            /* [in] */ LONG lInstanceFlags,
            /* [out][in] */ WBEM_COMPILE_STATUS_INFO __RPC_FAR *pInfo)
{

    SCODE sc;
    if(pBuffer == NULL || BuffSize == 0)
        return WBEM_E_INVALID_PARAMETER;
    DebugInfo dbg((lOptionFlags & WBEM_FLAG_CONSOLE_PRINT) != 0);
    CMofParser Parser(&dbg);
    try
    {

        Parser.SetBuffer((char *)pBuffer, BuffSize);
        sc = Compile(Parser, NULL, NULL, lOptionFlags, lClassFlags, lInstanceFlags,
                ServerAndNamespace, User, Password, Authority, 
                NULL, false, pInfo);
    }
    catch(...)
    {
        sc = WBEM_E_FAILED;
    }
    return sc;
}
        
HRESULT CMofComp::CreateBMOF( 
            /* [in] */ LPWSTR TextFileName,
            /* [in] */ LPWSTR BMOFFileName,
            /* [in] */ LPWSTR ServerAndNamespace,
            /* [in] */ LONG lOptionFlags,
            /* [in] */ LONG lClassFlags,
            /* [in] */ LONG lInstanceFlags,
            /* [out][in] */ WBEM_COMPILE_STATUS_INFO __RPC_FAR *pInfo)
{
    SCODE sc;
    TCHAR cFile[MAX_PATH];

    if(TextFileName == NULL || BMOFFileName == NULL)
        return WBEM_E_INVALID_PARAMETER;

    ClearStatus(pInfo);
    TCHAR * pFile = NULL;
    if(TextFileName)
    {
        CopyOrConvert(cFile, TextFileName, MAX_PATH);
        pFile = cFile;
    }

    try
    {
        DebugInfo dbg((lOptionFlags & WBEM_FLAG_CONSOLE_PRINT) != 0);
        CMofParser Parser(pFile, &dbg);

        sc = Compile(Parser, NULL, NULL, lOptionFlags, lClassFlags, lInstanceFlags,
                    ServerAndNamespace, NULL, NULL, NULL, 
                    BMOFFileName, false, pInfo);
    }
    catch (GenericException ge)
    {
        sc = ge.GetHRESULT();
    }
    return sc;
}

HRESULT CWinmgmtMofComp::WinmgmtCompileFile( 
            /* [in] */ LPWSTR FileName,
            /* [in] */ LPWSTR ServerAndNamespace,
            /* [in] */ LONG lOptionFlags,
            /* [in] */ LONG lClassFlags,
            /* [in] */ LONG lInstanceFlags,
            /* [in] */ IWbemServices __RPC_FAR *pOverride,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out][in] */ WBEM_COMPILE_STATUS_INFO __RPC_FAR *pInfo)
{
    SCODE sc;
    TCHAR cFile[MAX_PATH];
    if(FileName == NULL)
        return WBEM_E_INVALID_PARAMETER;
    ClearStatus(pInfo);
    TCHAR * pFile = NULL;
    if(FileName)
    {
        CopyOrConvert(cFile, FileName, MAX_PATH);
        pFile = cFile;
    }

    try
    {
        DebugInfo dbg((lOptionFlags & WBEM_FLAG_CONSOLE_PRINT) != 0);
        CMofParser Parser(pFile, &dbg);

        sc = Compile(Parser, pOverride, pCtx, lOptionFlags, lClassFlags, lInstanceFlags,
                    ServerAndNamespace, NULL, NULL, NULL, 
                    NULL, true, pInfo);
    }
    catch (GenericException ge)
    {
        sc = ge.GetHRESULT();
    }
    return sc;
}
        
HRESULT CWinmgmtMofComp::WinmgmtCompileBuffer( 
            /* [in] */ long BuffSize,
            /* [size_is][in] */ BYTE __RPC_FAR *pBuffer,
            /* [in] */ LONG lOptionFlags,
            /* [in] */ LONG lClassFlags,
            /* [in] */ LONG lInstanceFlags,
            /* [in] */ IWbemServices __RPC_FAR *pOverride,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out][in] */ WBEM_COMPILE_STATUS_INFO __RPC_FAR *pInfo)
{

    if(pBuffer == NULL || BuffSize == 0)
        return WBEM_E_INVALID_PARAMETER;

    DebugInfo dbg((lOptionFlags & WBEM_FLAG_CONSOLE_PRINT) != 0);
    CMofParser Parser(&dbg);
    try
    {

        Parser.SetBuffer((char *)pBuffer, BuffSize);
        SCODE sc = Compile(Parser, pOverride, pCtx, lOptionFlags, lClassFlags, lInstanceFlags, 
                    NULL, NULL, NULL, NULL, NULL, true, pInfo); 
        return sc;
    }
    catch(...)
    {
        return S_FALSE;
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\mofcomp_dll\cbmofout.h ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

    CBMOFOUT.H

Abstract:

	Declares the CBMOFOut class.

History:

	a-davj  06-April-97   Created.

--*/

#ifndef __CBMOFOUT__H_
#define __CBMOFOUT__H_

#include "cout.h"
#include <WBEMIDL.H>

//***************************************************************************
//
//  CLASS NAME:
//
//  CBMOFOut
//
//  DESCRIPTION:
//
//  Provides an easy way for outputting class information into a binary mof
//  file.  Users will create an instance, passing the eventual file name, and
//  then just add classes.
//
//***************************************************************************

class CBMOFOut {
  public:
    CBMOFOut(LPTSTR BMOFFileName, PDBG pDbg);
    ~CBMOFOut();
    DWORD AddClass(CMObject * pObject, BOOL bEmbedded);
    BOOL WriteFile();

  private:
    DWORD AddQualSet(CMoQualifierArray * pQualifierSet);
    DWORD AddPropSet(CMObject * pWbemObject);
    DWORD AddMethSet(CMObject * pWbemObject);
    DWORD AddQualifier(BSTR bstr, VARIANT * pvar, CMoQualifier * pQual);
    DWORD AddProp(BSTR bstr, VARIANT * pvar, CMoQualifierArray * pQual,DWORD dwType, CMoProperty * pProp);
    DWORD AddVariant(VARIANT * pvar, CMoValue * pVal);
    DWORD AddSimpleVariant(VARIANT * pvar, int iIndex, CMoValue * pValue);
    COut m_OutBuff;
    TCHAR * m_pFile;
    WBEM_Binary_MOF m_BinMof;
	PDBG m_pDbg;
};



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\mofcomp_dll\bmofhelp.h ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

    BMOFHELP.H

Abstract:

	Defines some helper functions for compiling binarary mofs.

History:

	a-davj  13-JULY-97   Created.

--*/

#ifndef _bmofhelp_H_
#define _bmofhelp_H_

#include "trace.h"

BOOL ConvertBufferIntoIntermediateForm(CMofData * pOutput, BYTE * pBuff, PDBG pDbg, BYTE * pBmofToFar);

// These are not typically used by any code except that in BMOFHELP.CPP

BOOL BMOFParseObj(CMofData * pOutput, CBMOFObj * pObj, VARIANT * pVar, BOOL bMethodArg, PDBG pDbg);
BOOL BMOFToVariant(CMofData * pOutput, CBMOFDataItem * pData, VARIANT * pVar, BOOL & bAliasRef, BOOL bMethodArg, PDBG pDbg);
CMoQualifierArray *  CreateQual(CMofData * pOutput, CBMOFQualList * pql, CMObject * pObj,LPCWSTR wszPropName, PDBG pDbg);
SCODE ConvertValue(CMoProperty * pProp, VARIANT * pSrc, BOOL bAliasRef);
HRESULT AddAliasReplaceValue(CMoValue & Value, const WCHAR * pAlias);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\mofcomp_dll\comobj.h ===
/*++

Copyright (C) 1998-2001 Microsoft Corporation

Module Name:

    COMOBJ.H

Abstract:

	This file defines the classes related to class representation
	of mofcomp objects.

History:

	9/16/98     a-davj      Created

--*/

#ifndef __COMOBJ__H_
#define __COMOBJ__H_

//***************************************************************************
//
//  CLASS NAME:
//
//  CGenFactory
//
//  DESCRIPTION:
//
//  Class factory template.
//
//***************************************************************************


typedef LPVOID * PPVOID;
void ObjectCreated();
void ObjectDestroyed();

template<class TObj>
class CGenFactory : public IClassFactory
    {
    protected:
        long           m_cRef;
    public:
        CGenFactory(void)
        {
            m_cRef=0L;
            ObjectCreated();
            return;
        };

        ~CGenFactory(void)
        {
            ObjectDestroyed();
            return;
        }

        //IUnknown members
        STDMETHODIMP         QueryInterface(REFIID riid, PPVOID ppv)
        {
            *ppv=NULL;

            if (IID_IUnknown==riid || IID_IClassFactory==riid)
                *ppv=this;

            if (NULL!=*ppv)
            {
                AddRef();
                return NOERROR;
            }

            return ResultFromScode(E_NOINTERFACE);
        };

        STDMETHODIMP_(ULONG) AddRef(void)
        {    
            return ++m_cRef;
        };
        STDMETHODIMP_(ULONG) Release(void)
        {
            long lRet = InterlockedDecrement(&m_cRef);
            if (0 ==lRet)
                delete this;
            return lRet;
        };

        //IClassFactory members
        STDMETHODIMP CreateInstance(IN LPUNKNOWN pUnkOuter, IN REFIID riid, OUT PPVOID ppvObj)
        {
            HRESULT hr;

            *ppvObj=NULL;
            hr=E_OUTOFMEMORY;

            // This object doesnt support aggregation.

            if (NULL!=pUnkOuter)
                return CLASS_E_NOAGGREGATION;

            //Create the object passing function to notify on destruction.
    
            TObj * pObj = new TObj();

            if (NULL==pObj)
                return hr;

            // Setup the class all empty, etc.

            hr=pObj->QueryInterface(riid, ppvObj);
            pObj->Release();
            return hr;
            
        };
        STDMETHODIMP         LockServer(BOOL fLock)
        {
            if (fLock)
                InterlockedIncrement((long *)&g_cLock);
            else
                InterlockedDecrement((long *)&g_cLock);
            return NOERROR;
        };
    };


//***************************************************************************
//
//  CLASS NAME:
//
//  CMofComp
//
//  DESCRIPTION:
//
//  Supports mofcomp functions for clients.
//
//***************************************************************************

class CMofComp : IMofCompiler
{
    protected:
        long           m_cRef;
    public:
        CMofComp(void)
        {
            m_cRef=1L;
            ObjectCreated();
            return;
        };

        ~CMofComp(void)
        {
            ObjectDestroyed();
            return;
        }

        //IUnknown members
        STDMETHODIMP         QueryInterface(REFIID riid, PPVOID ppv)
        {
            *ppv=NULL;

            if (IID_IUnknown==riid || IID_IMofCompiler==riid)
                *ppv=this;

            if (NULL!=*ppv)
            {
                AddRef();
                return NOERROR;
            }

            return E_NOINTERFACE;
        };

        STDMETHODIMP_(ULONG) AddRef(void)
        {    
            return ++m_cRef;
        };
        STDMETHODIMP_(ULONG) Release(void)
        {
            long lRef = InterlockedDecrement(&m_cRef);
            if (0L == lRef)
                delete this;
            return lRef;
        };

        // IMofCompiler functions

        HRESULT STDMETHODCALLTYPE CompileFile( 
            /* [in] */ LPWSTR FileName,
            /* [in] */ LPWSTR ServerAndNamespace,
            /* [in] */ LPWSTR User,
            /* [in] */ LPWSTR Authority,
            /* [in] */ LPWSTR Password,
            /* [in] */ LONG lOptionFlags,
            /* [in] */ LONG lClassFlags,
            /* [in] */ LONG lInstanceFlags,
            /* [out][in] */ WBEM_COMPILE_STATUS_INFO __RPC_FAR *pInfo);
        
        HRESULT STDMETHODCALLTYPE CompileBuffer( 
            /* [in] */ long BuffSize,
            /* [size_is][in] */ BYTE __RPC_FAR *pBuffer,
            /* [in] */ LPWSTR ServerAndNamespace,
            /* [in] */ LPWSTR User,
            /* [in] */ LPWSTR Authority,
            /* [in] */ LPWSTR Password,
            /* [in] */ LONG lOptionFlags,
            /* [in] */ LONG lClassFlags,
            /* [in] */ LONG lInstanceFlags,
            /* [out][in] */ WBEM_COMPILE_STATUS_INFO __RPC_FAR *pInfo);
        
        HRESULT STDMETHODCALLTYPE CreateBMOF( 
            /* [in] */ LPWSTR TextFileName,
            /* [in] */ LPWSTR BMOFFileName,
            /* [in] */ LPWSTR ServerAndNamespace,
            /* [in] */ LONG lOptionFlags,
            /* [in] */ LONG lClassFlags,
            /* [in] */ LONG lInstanceFlags,
            /* [out][in] */ WBEM_COMPILE_STATUS_INFO __RPC_FAR *pInfo);
};

//***************************************************************************
//
//  CLASS NAME:
//
//  CWinmgmtMofComp
//
//  DESCRIPTION:
//
//  Provides mofcomp functions for internal use.
//
//***************************************************************************

class CWinmgmtMofComp : IWinmgmtMofCompiler
{
    protected:
        long           m_cRef;
    public:
        CWinmgmtMofComp(void)
        {
            m_cRef=1L;
            ObjectCreated();
            return;
        };

        ~CWinmgmtMofComp(void)
        {
            ObjectDestroyed();
            return;
        }

        //IUnknown members
        STDMETHODIMP         QueryInterface(REFIID riid, PPVOID ppv)
        {
            *ppv=NULL;

            if (IID_IUnknown==riid || IID_IWinmgmtMofCompiler==riid)
                *ppv=this;

            if (NULL!=*ppv)
            {
                AddRef();
                return NOERROR;
            }

            return E_NOINTERFACE;
        };

        STDMETHODIMP_(ULONG) AddRef(void)
        {    
            return ++m_cRef;
        };
        STDMETHODIMP_(ULONG) Release(void)
        {
            long lRef = InterlockedDecrement(&m_cRef);
            if (0L == lRef)
                delete this;
            return lRef;
        };

        // IWinmgmtMofCompiler functions

        HRESULT STDMETHODCALLTYPE WinmgmtCompileFile( 
            /* [in] */ LPWSTR FileName,
            /* [in] */ LPWSTR ServerAndNamespace,
            /* [in] */ LONG lOptionFlags,
            /* [in] */ LONG lClassFlags,
            /* [in] */ LONG lInstanceFlags,
            /* [in] */ IWbemServices __RPC_FAR *pOverride,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out][in] */ WBEM_COMPILE_STATUS_INFO __RPC_FAR *pInfo);
        
        HRESULT STDMETHODCALLTYPE WinmgmtCompileBuffer( 
            /* [in] */ long BuffSize,
            /* [size_is][in] */ BYTE __RPC_FAR *pBuffer,
            /* [in] */ LONG lOptionFlags,
            /* [in] */ LONG lClassFlags,
            /* [in] */ LONG lInstanceFlags,
            /* [in] */ IWbemServices __RPC_FAR *pOverride,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out][in] */ WBEM_COMPILE_STATUS_INFO __RPC_FAR *pInfo);
};

class CMofCompOOP : public CWinmgmtMofComp
{
public:
        STDMETHODIMP         QueryInterface(REFIID riid, PPVOID ppv)
        {
            *ppv=NULL;

            if (IID_IUnknown==riid) 
                *ppv=this;
            else if (IID_IWinmgmtMofCompiler == riid)
                *ppv=this;
            else if (IID_IWinmgmtMofCompilerOOP == riid)
                *ppv=this;
            
            if (NULL != *ppv)
            {
                AddRef();
                return NOERROR;
            }

            return E_NOINTERFACE;
        };
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\mofcomp_dll\cout.h ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

    COUT.H

Abstract:

	Declares the COut class.

History:

	a-davj  06-April-97   Created.

--*/

#ifndef __COUT__H_
#define __COUT__H_


#define INIT_SIZE 4096
#define ADDITIONAL_SIZE 4096
#include "trace.h"

//***************************************************************************
//
//  CLASS NAME:
//
//  COut
//
//  DESCRIPTION:
//
//  Provides an automatically resizing buffer for ouput.  Writting is done
//  to offsets and the buffer also writes itself to a file.
//
//***************************************************************************

#include <flexarry.h>

class COut {
  public:
    COut(PDBG pDbg);
    ~COut();
    BOOL WriteToFile(LPSTR pFile);
    DWORD WriteBytes(DWORD dwOffset, BYTE * pSrc, DWORD dwSize);
    DWORD AppendBytes(BYTE * pSrc, DWORD dwSize);
    DWORD WriteBSTR(BSTR bstr);
    DWORD GetOffset(void){return m_dwCurr;};
    BOOL AddFlavor(long lFlavor);
    void SetPadMode(BOOL bPad){m_bPadString = bPad;};
  private:
	PDBG m_pDbg;
    BYTE * m_pMem;
    DWORD  m_dwSize;
    DWORD m_dwCurr;
    CFlexArray m_Offsets;
    CFlexArray m_Flavors;
    BOOL m_bPadString;

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\mofcomp_dll\cbmofout.cpp ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

    CBMOFOUT.CPP

Abstract:

    Declares the CBMOFOut class.

History:

    a-davj  06-April-97   Created.

--*/

#include "precomp.h"
#include "wstring.h"
#include "mofout.h"
#include "mofdata.h"
#include "bmof.h"
#include "cbmofout.h"
#include "trace.h"
#include "strings.h"
#include <wbemutil.h>

//***************************************************************************
//
//  CBMOFOut::CBMOFOut
//
//  DESCRIPTION:
//
//  Constructor.  Save the eventual destination name and writes the initial
//  structure out to the buffer.  NOTE THAT TYPICALLY THE BMOFFileName will
//  be NULL and this object will not do anything.  That deals with the 99%
//  of mofs that are not WMI!
//
//  PARAMETERS:
//
//  BMOFFileName        Name of file to eventually write to.
//
//***************************************************************************

CBMOFOut::CBMOFOut(
                   IN LPTSTR BMOFFileName, PDBG pDbg) : m_OutBuff(pDbg)
{
    m_pDbg = pDbg;
    m_BinMof.dwSignature = BMOF_SIG;              // spells BMOF
    m_BinMof.dwLength = sizeof(WBEM_Binary_MOF);     // updated at end
    m_BinMof.dwVersion = 1;            // 0x1
    m_BinMof.dwEncoding = 1;           // 0x1 = little endian, DWORD-aligned, no compression
    m_BinMof.dwNumberOfObjects = 0;    // Total classes and instances in MOF


    if(BMOFFileName && lstrlen(BMOFFileName) > 0)
    {
        DWORD dwLen = lstrlen(BMOFFileName) + 1;
        m_pFile = new TCHAR[dwLen];
        if(m_pFile)
        {
            StringCchCopyW(m_pFile, dwLen, BMOFFileName);
            m_OutBuff.AppendBytes((BYTE *)&m_BinMof, sizeof(WBEM_Binary_MOF));
        }
    }
    else 
        m_pFile = NULL;


}
//***************************************************************************
//
//  CBMOFOut::~CBMOFOut
//
//  DESCRIPTION:
//
//  Destructor.
//
//***************************************************************************

CBMOFOut::~CBMOFOut()
{
    if(m_pFile)
        delete m_pFile;
}


//***************************************************************************
//
//  DWORD CBMOFOut::AddClass
//
//  DESCRIPTION:
//
//  Adds a class to the BMOF buffer.
//
//  PARAMETERS:
//
//  pObject             pointer to class object.  
//  bEmbedded           TRUE if object is embedded.
//
//  RETURN VALUE:
//
//  Number of bytes written.
//
//***************************************************************************

DWORD CBMOFOut::AddClass(
                        IN CMObject * pObject,
                        IN BOOL bEmbedded)
{
    DWORD dwStartingOffset = m_OutBuff.GetOffset();
    CMoQualifierArray * pQualifierSet = NULL;
    if(!m_pFile)
        return 0;
    WBEM_Object wo;

    wo.dwLength = sizeof(WBEM_Object);       // updated later
    wo.dwOffsetQualifierList = 0xffffffff;
    wo.dwOffsetPropertyList = 0xffffffff;
    wo.dwOffsetMethodList = 0xffffffff;
    wo.dwType = (pObject->IsInstance()) ? 1 : 0;   // 0 = class, 1 = instance

    m_OutBuff.AppendBytes((BYTE *)&wo, sizeof(WBEM_Object));
    DWORD dwStartInfoOffset = m_OutBuff.GetOffset();


    // Write class qualifier

    pQualifierSet = pObject->GetQualifiers();
    if(pQualifierSet)
    {
        wo.dwOffsetQualifierList = m_OutBuff.GetOffset() - dwStartInfoOffset;
        AddQualSet(pQualifierSet);
    }

    wo.dwOffsetPropertyList = m_OutBuff.GetOffset() - dwStartInfoOffset;
    AddPropSet(pObject);

    wo.dwOffsetMethodList = m_OutBuff.GetOffset() - dwStartInfoOffset;
    AddMethSet(pObject);

    wo.dwLength = m_OutBuff.GetOffset() - dwStartingOffset;
    m_OutBuff.WriteBytes(dwStartingOffset, (BYTE *)&wo, sizeof(WBEM_Object));

    // If the object is not embedded, update the structure that keeps track 
    // of top level objects.

    if(!bEmbedded)
    {
        m_BinMof.dwNumberOfObjects++;
        m_BinMof.dwLength = m_OutBuff.GetOffset();
        m_OutBuff.WriteBytes(0, (BYTE *)&m_BinMof, 
                            sizeof(WBEM_Binary_MOF));
    }

    return wo.dwLength;
}

//***************************************************************************
//
//  DWORD CBMOFOut::AddQualSet
//
//  DESCRIPTION:
//
//  Adds a qualifier set to the BMOF buffer.
//
//  PARAMETERS:
//
//  pQualifierSet       pointer to qualifier object. 
//
//  RETURN VALUE:
//
//  Number of bytes written.
//
//***************************************************************************

DWORD CBMOFOut::AddQualSet(
                        IN CMoQualifierArray * pQualifierSet)
{
    DWORD dwStartingOffset = m_OutBuff.GetOffset();
    WBEM_QualifierList ql;
    ql.dwLength = sizeof(WBEM_QualifierList);
    ql.dwNumQualifiers = 0;

    m_OutBuff.AppendBytes((BYTE *)&ql, sizeof(WBEM_QualifierList));
    BSTR bstr = NULL;
    VARIANT var;
    VariantInit(&var);

    int i;
    for(i = 0; i < pQualifierSet->GetSize(); i++)
    {
        CMoQualifier * pQual = pQualifierSet->GetAt(i);
        if(pQual)
        {
            ql.dwNumQualifiers++;
            AddQualifier(pQual->GetName(), pQual->GetpVar(), pQual);
        }
    }
    
    ql.dwLength = m_OutBuff.GetOffset() - dwStartingOffset;
    m_OutBuff.WriteBytes(dwStartingOffset, (BYTE *)&ql, 
                                    sizeof(WBEM_QualifierList));
    return ql.dwLength;
}

//***************************************************************************
//
//  DWORD CBMOFOut::AddPropSet
//
//  DESCRIPTION:
//
//  Adds the property set to the BMOF buffer.
//
//  PARAMETERS:
//
//  pObject          pointer to class object.
//
//  RETURN VALUE:
//
//  Number of bytess written
//
//***************************************************************************

DWORD CBMOFOut::AddPropSet(
                        IN CMObject * pObject)
{
    DWORD dwStartingOffset = m_OutBuff.GetOffset();
    WBEM_PropertyList pl;

    BSTR bstr = NULL;
    VARIANT var;
    VariantInit(&var);
    IWbemQualifierSet* pQual = NULL;

    pl.dwLength = sizeof(WBEM_PropertyList);       // updated later
    pl.dwNumberOfProperties = 0;
    m_OutBuff.AppendBytes((BYTE *)&pl, sizeof(WBEM_PropertyList));

    // Loop through the properties

    int i;
    for(i = 0; i < pObject->GetNumProperties(); i++)
    {
        CMoProperty * pProp = pObject->GetProperty(i);
        if(pProp && pProp->IsValueProperty())
        {
            pl.dwNumberOfProperties++;
            CMoQualifierArray * pQual = pProp->GetQualifiers();
            AddProp(pProp->GetName(), pProp->GetpVar(), pQual,pProp->GetType(),pProp);
        }
    }
    
    // Store the class name and possibly the parent name as properties.

    VariantInit(&var);
    var.vt = VT_BSTR;
    var.bstrVal = SysAllocString(pObject->GetClassName()); 
    AddProp(L"__CLASS", &var, NULL,VT_BSTR,NULL);
    pl.dwNumberOfProperties++;
    VariantClear(&var);

    if(pObject->GetNamespace() && wcslen(pObject->GetNamespace()) > 0)
    {
        VariantInit(&var);
        var.vt = VT_BSTR;
        var.bstrVal = SysAllocString(pObject->GetNamespace()); 
        AddProp(L"__NAMESPACE", &var, NULL,VT_BSTR,NULL);
        pl.dwNumberOfProperties++;
        VariantClear(&var);
    }

    if(pObject->GetClassFlags() != 0)
    {
        VariantInit(&var);
        var.vt = VT_I4;
        var.lVal = pObject->GetClassFlags(); 
        AddProp(L"__CLASSFLAGS", &var, NULL,VT_I4,NULL);
        pl.dwNumberOfProperties++;
        VariantClear(&var);
    }
    if(pObject->GetInstanceFlags() != 0)
    {
        VariantInit(&var);
        var.vt = VT_I4;
        var.lVal = pObject->GetInstanceFlags(); 
        AddProp(L"__INSTANCEFLAGS", &var, NULL,VT_I4,NULL);
        pl.dwNumberOfProperties++;
        VariantClear(&var);
    }

    if(pObject->GetAlias() && wcslen(pObject->GetAlias()) > 0)
    {
        VariantInit(&var);
        var.vt = VT_BSTR;
        var.bstrVal = SysAllocString(pObject->GetAlias()); 
        AddProp(L"__ALIAS", &var, NULL,VT_BSTR,NULL);
        pl.dwNumberOfProperties++;
        VariantClear(&var);
    }

    if(!pObject->IsInstance())
    {
        CMoClass * pClass = (CMoClass * )pObject;
        var.vt = VT_BSTR;
        if(pClass->GetParentName() && wcslen(pClass->GetParentName()) > 0)
        {
            var.bstrVal = SysAllocString(pClass->GetParentName()); 
            AddProp(L"__SUPERCLASS", &var, NULL,VT_BSTR,NULL);
            pl.dwNumberOfProperties++;
            VariantClear(&var);
        }
    };

    
    pl.dwLength = m_OutBuff.GetOffset() - dwStartingOffset;
    m_OutBuff.WriteBytes(dwStartingOffset, (BYTE *)&pl, 
                                    sizeof(WBEM_PropertyList));
    return pl.dwLength;
}

//***************************************************************************
//
//  DWORD CBMOFOut::AddMethSet
//
//  DESCRIPTION:
//
//  Adds the method set to the BMOF buffer.
//
//  PARAMETERS:
//
//  pObject          pointer to class object.
//
//  RETURN VALUE:
//
//  Number of bytess written
//
//***************************************************************************

DWORD CBMOFOut::AddMethSet(
                        IN CMObject * pObject)
{
    DWORD dwStartingOffset = m_OutBuff.GetOffset();
    WBEM_PropertyList ml;
    SCODE sc;

    IWbemQualifierSet* pQual = NULL;

    ml.dwLength = sizeof(WBEM_PropertyList);       // updated later
    ml.dwNumberOfProperties = 0;
    m_OutBuff.AppendBytes((BYTE *)&ml, sizeof(WBEM_PropertyList));

    // Loop through the properties

    int i;
    for(i = 0; i < pObject->GetNumProperties(); i++)
    {
        CMoProperty * pProp = pObject->GetProperty(i);
        if(pProp && !pProp->IsValueProperty())
        {
            ml.dwNumberOfProperties++;
            CMoQualifierArray * pQual = pProp->GetQualifiers();

            // Create a variant that has an array of embedded object for each of out
            // input and output arg sets

            CMethodProperty * pMeth = (CMethodProperty *)pProp;
            VARIANT vSet;
            if(pMeth->GetInObj() || pMeth->GetOutObj())
            {
                vSet.vt = VT_ARRAY | VT_EMBEDDED_OBJECT;

                SAFEARRAYBOUND aBounds[1];
                
                // Note the you might have either inputs, or ouputs, or both

                if(pMeth->GetInObj() && pMeth->GetOutObj())
                    aBounds[0].cElements = 2;
                else
                    aBounds[0].cElements = 1;
                aBounds[0].lLbound = 0;
#ifdef _WIN64
                vSet.parray = SafeArrayCreate(VT_R8, 1, aBounds);
#else
                vSet.parray = SafeArrayCreate(VT_I4, 1, aBounds);
#endif
                if(vSet.parray == NULL)
                    return FALSE;
                long lIndex = 0;
                VARIANT var;

                if(pMeth->GetInObj())
                {
                    var.punkVal = (IUnknown *)pMeth->GetInObj();
                    sc = SafeArrayPutElement(vSet.parray, &lIndex, &var.punkVal);
                    lIndex = 1;
                }
                if(pMeth->GetOutObj())
                {
                    var.punkVal = (IUnknown *)pMeth->GetOutObj();
                    sc = SafeArrayPutElement(vSet.parray, &lIndex, &var.punkVal);
                }
            }
            else
                vSet.vt = VT_NULL;
            AddProp(pProp->GetName(), &vSet, pQual,pProp->GetType(),pProp);
        }
    }
    
    ml.dwLength = m_OutBuff.GetOffset() - dwStartingOffset;
    m_OutBuff.WriteBytes(dwStartingOffset, (BYTE *)&ml, 
                                    sizeof(WBEM_PropertyList));
    return ml.dwLength;
}

//***************************************************************************
//
//  DWORD CBMOFOut::AddProp
//
//  DESCRIPTION:
//
//  Adds a single property to the BMOF buffer.
//
//  PARAMETERS:
//
//  bstr                property name
//  pvar                variant containing value
//  pQual               pointer to qualifier set if any.  Caller will release.
//  dwType              data type.  Note that the variant might have type
//                      VT_NULL if the property doesnt have a value.
//  RETURN VALUE:
//
//  Number of bytes written
//
//***************************************************************************

DWORD CBMOFOut::AddProp(
                        IN BSTR bstr, 
                        IN VARIANT * pvar, 
                        IN CMoQualifierArray * pQual,
                        IN DWORD dwType,
                        IN CMoProperty * pProp)
{
    DWORD dwStartingOffset = m_OutBuff.GetOffset();
    WBEM_Property prop;
    prop.dwLength = sizeof(WBEM_Property);
    if(pvar->vt == VT_NULL || pvar->vt == VT_EMPTY)
        prop.dwType = dwType;
    else
        prop.dwType = pvar->vt;

    prop.dwOffsetName = 0xffffffff;
    prop.dwOffsetValue = 0xffffffff;
    prop.dwOffsetQualifierSet = 0xffffffff;
    m_OutBuff.AppendBytes((BYTE *)&prop, sizeof(WBEM_Property));

    DWORD dwStartInfoOffset =  m_OutBuff.GetOffset();

    if(bstr)
    {
        prop.dwOffsetName = m_OutBuff.GetOffset() - dwStartInfoOffset;
        m_OutBuff.WriteBSTR(bstr);
    }
    
    if(pvar->vt != VT_EMPTY && pvar->vt != VT_NULL)
    {
        prop.dwOffsetValue = m_OutBuff.GetOffset() - dwStartInfoOffset;
        if(pProp)
        {
            CMoValue& Value = pProp->AccessValue();
            AddVariant(pvar, &Value);
            prop.dwType = pvar->vt;
        }
        else 
            AddVariant(pvar, NULL);
    }

    if(pQual)
    {
        prop.dwOffsetQualifierSet = m_OutBuff.GetOffset() - dwStartInfoOffset;
        AddQualSet(pQual);
    }

    prop.dwLength = m_OutBuff.GetOffset() - dwStartingOffset;
    m_OutBuff.WriteBytes(dwStartingOffset, (BYTE *)&prop, 
                                    sizeof(WBEM_Property));
    return 1;

}


//***************************************************************************
//
//  DWORD CBMOFOut::AddQualifier
//
//  DESCRIPTION:
//
//  Adds a qualifier to the BMOF buffer.
//
//  PARAMETERS:
//
//  bstr                qualifer name
//  pvar                qualifier value
//
//  RETURN VALUE:
//
//  Number of bytes written.
//
//***************************************************************************

DWORD CBMOFOut::AddQualifier(
                        IN BSTR bstr, 
                        IN VARIANT * pvar,
                        CMoQualifier * pQual)
{
    WBEM_Qualifier qu;
    DWORD dwStartingOffset = m_OutBuff.GetOffset();
    
    long lFlavor = pQual->GetFlavor();
    if(pQual->IsAmended())
        lFlavor |= WBEM_FLAVOR_AMENDED;
    if(lFlavor)
        m_OutBuff.AddFlavor(lFlavor);
    qu.dwLength = sizeof(WBEM_Qualifier);           // filled in later
    qu.dwType = pvar->vt;
    qu.dwOffsetName = 0xffffffff;
    qu.dwOffsetValue = 0xffffffff;
    m_OutBuff.AppendBytes((BYTE *)&qu, sizeof(WBEM_Qualifier));
    DWORD dwStartInfoOffset = m_OutBuff.GetOffset();

    // Write the qualifier name and data

    if(bstr)
    {
        qu.dwOffsetName = m_OutBuff.GetOffset() - dwStartInfoOffset;
        m_OutBuff.WriteBSTR(bstr);
    }

    if(pvar->vt != VT_EMPTY && pvar->vt != VT_NULL)
    {
        CMoValue& Value = pQual->AccessValue();

        qu.dwOffsetValue = m_OutBuff.GetOffset() - dwStartInfoOffset;
        

        AddVariant(pvar, &Value);
        qu.dwType = pvar->vt;
    }
    qu.dwLength = m_OutBuff.GetOffset() - dwStartingOffset;
    m_OutBuff.WriteBytes(dwStartingOffset, (BYTE *)&qu, 
                                    sizeof(WBEM_Qualifier));

    return 0;
}

//***************************************************************************
//
//  DWORD CBMOFOut::AddVariant
//
//  DESCRIPTION:
//
//  Adds a value to the BMOF buffer.
//
//  PARAMETERS:
//
//  pvar                value to add.
//
//  RETURN VALUE:
//
//  Total bytes written
//
//***************************************************************************

DWORD CBMOFOut::AddVariant(VARIANT * pvar, CMoValue * pValue)
{

    if(pValue && pValue->GetNumAliases() > 0)
        pvar->vt |= VT_BYREF;

    VARTYPE vtSimple = pvar->vt & ~VT_ARRAY  & ~VT_BYREF;

    if(pvar->vt & VT_ARRAY)
    {
        DWORD dwStartingOffset = m_OutBuff.GetOffset();
        DWORD dwSize = 0;
        m_OutBuff.AppendBytes((BYTE *)&dwSize, sizeof(DWORD));

        DWORD dwTotal = 0;
        SCODE sc;
        SAFEARRAY * psa;
        long ix[2] = {0,0};
        long uLower, uUpper;
        psa = pvar->parray;
        sc = SafeArrayGetLBound(psa,1,&uLower);
        sc |= SafeArrayGetUBound(psa,1,&uUpper);
        if(sc != S_OK)
            return 0;
        
        // write the number of dimensions and the size of each
        
        DWORD dwNumDim = 1;                                     // for now!!!
        m_OutBuff.AppendBytes((BYTE *)&dwNumDim, sizeof(long)); // Number of dimensions
        DWORD dwNumElem = uUpper - uLower + 1;
        m_OutBuff.AppendBytes((BYTE *)&dwNumElem, sizeof(long));

        // Write out the row size

        DWORD dwStartingRowOffset = m_OutBuff.GetOffset();
        DWORD dwRowSize = 0;
        m_OutBuff.AppendBytes((BYTE *)&dwRowSize, sizeof(DWORD));

        // Get each element and write it

        for(ix[0] = uLower; ix[0] <= uUpper && sc == S_OK; ix[0]++) 
        {
            VARIANT var;
            VariantInit(&var);
            var.vt = vtSimple;
            sc = SafeArrayGetElement(psa,ix,&var.bstrVal);
            if(sc != S_OK)
            {
                Trace(true, m_pDbg, SAFE_ARRAY_ERROR);
            }
            if(ix[0] < uUpper)
                m_OutBuff.SetPadMode(FALSE);
            else
                m_OutBuff.SetPadMode(TRUE);
            dwTotal += AddSimpleVariant(&var, ix[0], pValue);
            if(var.vt != VT_EMBEDDED_OBJECT)    // Our dispatch is actual a CMObject *
                VariantClear(&var);
        }

        // Update the size of the property and the row.  Note that having a separate size
        // is for possible future support of multi dimensional arrays.

        dwRowSize = m_OutBuff.GetOffset() - dwStartingRowOffset;
        m_OutBuff.WriteBytes(dwStartingRowOffset, (BYTE *)&dwRowSize, 
                                    sizeof(DWORD));

        dwSize = m_OutBuff.GetOffset() - dwStartingOffset;
        m_OutBuff.WriteBytes(dwStartingOffset, (BYTE *)&dwSize, 
                                    sizeof(DWORD));

        return dwTotal;
 
    }
    else
        return AddSimpleVariant(pvar, -1, pValue);
}

//***************************************************************************
//
//  DWORD CBMOFOut::AddSimpleVariant
//
//  DESCRIPTION:
//
//  Adds a non array variant to the BMOF buffer.
//
//  PARAMETERS:
//
//  pvar                value to add.
//  iIndex              set to -1 if property in scalar, or if array, has
//                      the index of this element.  Note that arrays are
//                      broken up into simple variants.
//  
//
//  RETURN VALUE:
//
//  Bytes written
//***************************************************************************

DWORD CBMOFOut::AddSimpleVariant(VARIANT * pvar, int iIndex, CMoValue * pValue)
{
    DWORD dwSize = iTypeSize(pvar->vt & ~VT_BYREF);
    VARTYPE vtSimple = pvar->vt & ~VT_BYREF;
    if(pValue && pValue->GetNumAliases() && (vtSimple == VT_BSTR))
    {
        WCHAR * wszAlias = NULL;
        int iTry, iAlIndex = -1;
                
        if(iIndex == -1)
            pValue->GetAlias(0, wszAlias, iAlIndex);
        else
        {
            for(iTry = 0; iTry < pValue->GetNumAliases(); iTry++)
            {
                pValue->GetAlias(iTry, wszAlias, iAlIndex);
                if(iIndex == iAlIndex)
                    break;
            }
            if(iTry == pValue->GetNumAliases())
                wszAlias = NULL;
        }
        if(wszAlias && iIndex == -1)
                pvar->bstrVal = SysAllocString(wszAlias);
        
        else if(wszAlias && iIndex != -1)
        {
            DWORD dwLen = wcslen(wszAlias)+2;
            WCHAR * pTemp = new WCHAR[dwLen];
            if(pTemp == NULL)
                return 0;
            pTemp[0]= L'$';
            StringCchCopyW(pTemp+1, dwLen-1, wszAlias);
            pvar->bstrVal = SysAllocString(pTemp);
            delete pTemp;
        }
        else if(wszAlias == NULL && iIndex != -1)
        {
            DWORD dwLen = wcslen(pvar->bstrVal)+2;
            WCHAR * pTemp = new WCHAR[dwLen];
            if(pTemp == NULL)
                return 0;
            pTemp[0]= L' ';
            StringCchCopyW(pTemp+1, dwLen-1,  pvar->bstrVal);
            pvar->bstrVal = SysAllocString(pTemp);
            delete pTemp;
        }


    }
    if(vtSimple == VT_BSTR)
        return m_OutBuff.WriteBSTR(pvar->bstrVal);
    else if(vtSimple == VT_EMBEDDED_OBJECT)
    {
        CMObject * pObj = (CMObject *)pvar->punkVal;
        return AddClass(pObj, TRUE);
    }
    else
        return m_OutBuff.AppendBytes((BYTE *)&pvar->bstrVal, dwSize);
}

//***************************************************************************
//
//  BOOL CBMOFOut::WriteFile
//
//  DESCRIPTION:
//
//  Writes the buffer out to the file.
//
//***************************************************************************

BOOL CBMOFOut::WriteFile()
{
    BOOL bRet = FALSE;
    if(m_pFile)
    {
        m_BinMof.dwLength = m_OutBuff.GetOffset();
        m_OutBuff.WriteBytes(0, (BYTE *)&m_BinMof, sizeof(WBEM_Binary_MOF));
#ifdef  UNICODE
        char cFile[MAX_PATH];
        wcstombs(cFile, m_pFile, MAX_PATH);
        bRet = m_OutBuff.WriteToFile(cFile);
#else
        bRet = m_OutBuff.WriteToFile(m_pFile);
#endif
    }
    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\mofcomp_dll\makefile.inc ===
!INCLUDE $(_NTDRIVE)$(_NTROOT)\WMI\COMMON\makefile.cmn
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\mofcomp_dll\cout.cpp ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

    COUT.CPP

Abstract:

    Declares the COut class.

History:

    a-davj  06-April-97   Created.

--*/

#include "precomp.h"
#include <io.h>
#include <fcntl.h>
#include <stdio.h>
#include <sys/stat.h>
#include <arrtempl.h>

#include "cout.h"
#include "trace.h"
#include "strings.h"
#include "mrciclass.h"
#include "bmof.h"

//***************************************************************************
//
//  COut::COut
//
//  DESCRIPTION:
//
//  Constructor.  Allocates initial buffer.
//
//***************************************************************************

COut::COut(PDBG pDbg)
{
    m_pDbg = pDbg;
    m_dwSize = INIT_SIZE;
    m_pMem = (BYTE *)malloc(m_dwSize);
    m_dwCurr = 0;
    m_bPadString = TRUE;
}

//***************************************************************************
//
//  COut::~COut
//
//  DESCRIPTION:
//
//  Destructor.  Frees the buffer.
//
//***************************************************************************

COut::~COut()
{
    if(m_pMem)
        free(m_pMem);
}

//***************************************************************************
//
//  void COut::WriteToFile
//
//  DESCRIPTION:
//
//  Creates a file and writes the buffer to it.  Like other compilers, it
//  overwrites any existing files.
//
//  PARAMETERS:
//
//  pFile               File name to write to.
//
//***************************************************************************

BOOL COut::WriteToFile(
                        IN LPSTR pFile)
{
    BOOL bRet = FALSE;
    BYTE * pCompressed = NULL;
    DWORD one = 1;
    DWORD dwSize;
    int iRet;
    DWORD dwCompressedSize;
    DWORD dwSignature = BMOF_SIG;
    CMRCICompression * pCompress = new CMRCICompression;
    if(pCompress == NULL)
        return FALSE;
    CDeleteMe<CMRCICompression> dm(pCompress);

    // Test if there are flavors

    if(m_Flavors.Size() > 0)
    {
        // write out the flavor information

        void * lOffSet;
        void * lFlavor; 
        AppendBytes((BYTE *)"BMOFQUALFLAVOR11", 16);
        long lNum = m_Flavors.Size();
        AppendBytes( (BYTE *)&lNum, 4);

        for(long lCnt = 0; lCnt < lNum; lCnt++)
        {
            lOffSet = m_Offsets.GetAt(lCnt);
            lFlavor = m_Flavors.GetAt(lCnt);
            AppendBytes( (BYTE *)&lOffSet, 4);
            AppendBytes( (BYTE *)&lFlavor, 4);
        }


    }


    int fh = NULL;
    if(pFile == NULL)
        return FALSE;

    fh = _open(pFile, _O_BINARY | O_RDWR | _O_TRUNC | _O_CREAT, _S_IREAD |_S_IWRITE);
    if(fh == -1)
    {
        Trace(true, m_pDbg, FILE_CREATE_FAILED, pFile, errno);
        goto Cleanup;
    }


    // Create a compressed version of the blob

    dwSize = (m_dwCurr > 0x7000) ? m_dwCurr : 0x7000;

    pCompressed = new BYTE[dwSize];
    if(pCompressed == NULL)
        return FALSE;

    dwCompressedSize = pCompress->Mrci1MaxCompress( m_pMem, m_dwCurr, pCompressed, dwSize);

    if(dwCompressedSize == 0xffffffff || dwCompressedSize == 0)
    {
        Trace(true, m_pDbg, COMPRESSION_FAILED);
        goto Cleanup;
    }

    // write the decomression signature, the decompressed size, and the compressed size

    iRet = _write(fh, (BYTE *)&dwSignature, sizeof(DWORD));
    if(iRet != sizeof(DWORD))
    {
        Trace(true, m_pDbg, FILE_WRITE_FAILED, pFile, errno);
        goto Cleanup;
    }

    iRet = _write(fh, (BYTE *)&one, sizeof(DWORD));
    iRet = _write(fh, (BYTE *)&dwCompressedSize, sizeof(DWORD));
    iRet = _write(fh, (BYTE *)&m_dwCurr, sizeof(DWORD));

    // write the compressed data and then free the buffer

    iRet = _write(fh, pCompressed, dwCompressedSize);
    
    if((DWORD)iRet != dwCompressedSize)
        Trace(true, m_pDbg, FILE_WRITE_FAILED, pFile, errno);
    else
        bRet = TRUE;

Cleanup:

    if(fh != NULL)
        _close(fh);
    if(pCompressed)
        delete pCompressed;
    return bRet;
    
}

//***************************************************************************
//
//  DWORD COut::AppendBytes
//
//  DESCRIPTION:
//
//  Adds bytes to the end of the buffer.
//
//  PARAMETERS:
//
//  pSrc                Pointer to data source.
//  dwSize              Number of bytes to add.
//
//  RETURN VALUE:
//
//  Number of bytes added.
//
//***************************************************************************

DWORD COut::AppendBytes(
                        IN BYTE * pSrc, 
                        IN DWORD dwSize)
{
    char * pZero = "\0\0\0\0\0\0\0";
    DWORD dwRet = WriteBytes(m_dwCurr, pSrc, dwSize);
    m_dwCurr += dwRet;
    DWORD dwLeftOver = dwSize & 3;
    if(dwLeftOver && m_bPadString)
    {
        dwRet = WriteBytes(m_dwCurr, (BYTE *)pZero, dwLeftOver);
        m_dwCurr += dwLeftOver;
    }
    return dwRet;
}

//***************************************************************************
//
//  DWORD COut::WriteBSTR
//
//  DESCRIPTION:
//
//  Adds a bstr to the buffer.  Quite simple for now, by might be enhanced
//  later on to compress.
//
//  PARAMETERS:
//
//  bstr                bstr to add.
//
//  RETURN VALUE:
//
//  Number of bytes added.
//
//***************************************************************************

DWORD COut::WriteBSTR(
                        IN BSTR bstr)
{
    return AppendBytes((BYTE *)bstr, 2*(wcslen(bstr) + 1));
}


//***************************************************************************
//
//  DWORD COut::WriteBytes
//
//  DESCRIPTION:
//
//  writes some bytes to the buffer, or possibly adds to the end.
//
//  PARAMETERS:
//
//  dwOffset            Offset in buffer where bytes should go
//  pSrc                points to source data
//  dwSize              number of bytes to copy
//
//  RETURN VALUE:
//
//  Number of bytes copied
//
//***************************************************************************

DWORD COut::WriteBytes(
                        IN DWORD dwOffset, 
                        IN BYTE * pSrc, 
                        IN DWORD dwSize)
{
    if(m_pMem == NULL)
        return 0;

    // check if reallocation is needed!

    if(dwOffset + dwSize > m_dwSize)
    {
        DWORD dwAddSize = ADDITIONAL_SIZE;
        if(dwSize > dwAddSize)
            dwAddSize = dwSize;
        BYTE * pNew = (BYTE *)realloc(m_pMem, m_dwSize + dwAddSize);
        if(pNew == NULL)
        {
            free(m_pMem);
            m_pMem = NULL;
            return 0;
        }
        else
        {
            m_pMem = pNew;
            m_dwSize += dwAddSize;
        }
    }

    memcpy(m_pMem+dwOffset, pSrc, dwSize);
    return dwSize;
}

//***************************************************************************
//
//  DWORD COut::AddFlavor
//
//  DESCRIPTION:
//
//  Save the flavor value for the current offset.
//
//  PARAMETERS:
//
//  long                flavor to be saved
//
//  RETURN VALUE:
//
//  TRUE if OK;
//
//***************************************************************************

BOOL COut::AddFlavor(IN long lFlavor)
{
#ifdef _WIN64
    m_Offsets.Add((void *)IntToPtr(m_dwCurr));
    m_Flavors.Add((void *)IntToPtr(lFlavor));
#else
    m_Offsets.Add((void *)m_dwCurr);
    m_Flavors.Add((void *)lFlavor);
#endif	
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\mofcomp_dll\datasrc.cpp ===
/*++

Copyright (C) 1998-2001 Microsoft Corporation

Module Name:

    DataSrc.CPP

Abstract:

    Implements DataSrc objects.

History:

    a-davj  21-Dec-99       Created.

--*/

#include "precomp.h"
#include "DataSrc.h"
#include <wbemcli.h>
#include <malloc.h>
#include <autoptr.h>

#define  HR_LASTERR  MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32, GetLastError() )

FileDataSrc::FileDataSrc(TCHAR * pFileName)
{
    m_fp = NULL;
    m_pFileName = NULL;
    m_iFilePos = -1;        // forces a read
    m_iToFar = 0;
    if(pFileName == NULL)
    {
        m_iStatus = WBEM_E_INVALID_PARAMETER;
        return;
    }
    DWORD dwLen = lstrlen(pFileName) + 1;
    wmilib::auto_buffer<WCHAR> pTmpFileName( new TCHAR[dwLen]);
    if(NULL == pTmpFileName.get())
    {
        m_iStatus = WBEM_E_OUT_OF_MEMORY;
        return;
    }
    StringCchCopyW(pTmpFileName.get(), dwLen, pFileName);

    m_fp = _wfopen( pFileName, L"rb");
    OnDeleteIf<FILE *,int(__cdecl *)(FILE *),fclose> closeme(m_fp);
    if(m_fp == NULL)
    {
        m_iStatus = WBEM_E_OUT_OF_MEMORY;
        return;
    }

    // calculate the file size.  Note that the number is the size in unicode words, not bytes.

    int ret = fseek(m_fp, 0, SEEK_END);
    if(ret)  throw GenericException(ret);

    m_iSize = ftell(m_fp)/2; // add a bit extra for ending space and null NULL
      
    ret = fseek(m_fp, 0, SEEK_SET);
    if( ret )  throw GenericException(ret);

    m_iPos = -1;

    closeme.dismiss();
    m_pFileName = pTmpFileName.release();    
}
FileDataSrc::~FileDataSrc()
{

    if(m_fp)
        fclose(m_fp);
    DeleteFile(m_pFileName);
    delete m_pFileName;
}

wchar_t FileDataSrc::GetAt(int nOffset)
{
    wchar_t tRet;
    int iPos = m_iPos + nOffset;
    if(iPos >= m_iFilePos && iPos < m_iToFar)
        return m_Buff[iPos - m_iFilePos];
    Move(nOffset);
    tRet = m_Buff[m_iPos - m_iFilePos];
    Move(-nOffset);
    return tRet;
}

void FileDataSrc::Move(int n)
{
    m_iPos += n;
    
    // if m_iPos is in range, then all is well

    if(m_iPos >= m_iFilePos && m_iPos < m_iToFar && m_iFilePos >= 0)
        return;

    // if m_iPos is not even in the file, bail out

    if(m_iPos >= 0 && m_iPos < m_iSize)
        UpdateBuffer();
    return;
}

int FileDataSrc::MoveToPos(int n)
{
    m_iPos = n;
    
    // if m_iPos is in range, then all is well

    if(m_iPos >= m_iFilePos && m_iPos < m_iToFar && m_iFilePos >= 0)
        return -1;

    // if m_iPos is not even in the file, bail out

    if(m_iPos >= 0 && m_iPos < m_iSize)
        UpdateBuffer();
    return n;
}

void FileDataSrc::UpdateBuffer()
{

    int numRead, ret;
    
    // buffer needs to be read.  Determine the starting and ending points

    m_iFilePos = m_iPos - 1000;
    if(m_iFilePos < 0)
        m_iFilePos = 0;

    int iReadLen = 10000;
    if(iReadLen + m_iFilePos > m_iSize)
        iReadLen =  m_iSize - m_iFilePos;

    ret = fseek(m_fp, 2*m_iFilePos, SEEK_SET);
    if(ret)
        throw GenericException(ret);
    numRead = fread(m_Buff, 2, iReadLen, m_fp);
    if(numRead != iReadLen)
        throw GenericException(ferror( m_fp ));
    m_iToFar = m_iFilePos + iReadLen;
    return;
}

int FileDataSrc::MoveToStart()
{
    int ret = fseek(m_fp, 0, SEEK_SET);
    if( ret )
        throw GenericException(ret);

    m_iPos = -1;
    return 0;
}

#ifdef USE_MMF_APPROACH

FileDataSrc1::FileDataSrc1(TCHAR * pFileName)
{
    m_pFileName = NULL;

    m_hFile = INVALID_HANDLE_VALUE;
    m_hFileMapSrc = NULL;
    m_pData = NULL;
    
    if(pFileName == NULL)
    {
        m_iStatus = WBEM_E_INVALID_PARAMETER;
        return;
    }
    DWORD dwLen = lstrlen(pFileName) + 1;
    m_pFileName = new TCHAR[dwLen];
    if(m_pFileName == NULL)
    {
        m_iStatus = WBEM_E_OUT_OF_MEMORY;
        return;
    }
    StringCchCopyW(m_pFileName, dwLen, pFileName);
    
    m_hFile = CreateFile(pFileName,GENERIC_READ,FILE_SHARE_READ,NULL,OPEN_EXISTING,0,NULL);
    if (INVALID_HANDLE_VALUE == m_hFile)
    {
        m_iStatus = HR_LASTERR;
        return;
    }
    
    DWORD dwSize = GetFileSize(m_hFile,NULL);
    m_hFileMapSrc = CreateFileMapping(m_hFile,
                                       NULL,
                                       PAGE_READONLY,
                                       0,0,  // the entire file
                                       NULL);
    if (NULL == m_hFileMapSrc)
    {
        m_iStatus = HR_LASTERR;
        return;
    }

    m_pData = (WCHAR *)MapViewOfFile(m_hFileMapSrc,FILE_MAP_READ,0,0,0);
    if (NULL == m_pData)
    {
        m_iStatus = HR_LASTERR;
        return;        
    }
    
    m_iSize = dwSize/sizeof(WCHAR);
    MoveToStart();
}

FileDataSrc1::~FileDataSrc1()
{
    if (m_pData) UnmapViewOfFile(m_pData);
    if (m_hFileMapSrc) CloseHandle(m_hFileMapSrc);
    if (INVALID_HANDLE_VALUE != m_hFile) CloseHandle(m_hFile);
    if (m_pFileName) DeleteFile(m_pFileName);
    delete m_pFileName;
}

wchar_t FileDataSrc1::GetAt(int nOffset)
{
    int iPos = m_iPos + nOffset;
    if(iPos < 0 || iPos > m_iSize)
        return -1;
    else
        return m_pData[iPos];    
}

void FileDataSrc1::Move(int n)
{
    m_iPos += n;
    return;
}

int FileDataSrc1::MoveToPos(int n)
{
    if(n < 0 || n > m_iSize)
        return -1;
    else
        return m_iPos = n;
}


int FileDataSrc1::MoveToStart()
{
    m_iPos = -1;
    return 0;
}

#endif

BufferDataSrc::BufferDataSrc(long lSize, char *  pMemSrc)
{
    m_Data = new WCHAR[lSize+1];
    if(m_Data)
    {

        memset(m_Data, 0, (lSize+1) * sizeof(WCHAR));
        m_iSize = mbstowcs(m_Data, pMemSrc, lSize);
    }
    MoveToStart();
}

BufferDataSrc::~BufferDataSrc()
{
    delete [] m_Data;
}

wchar_t BufferDataSrc::GetAt(int nOffset)
{
    int iPos = m_iPos + nOffset;
    if(iPos < 0 || iPos > m_iSize)
        return -1;
    return m_Data[m_iPos + nOffset];
}

void BufferDataSrc::Move(int n)
{
    m_iPos += n;
}

int BufferDataSrc::MoveToStart()
{
    m_iPos = -1;
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\mofcomp_dll\datasrc.h ===
/*++

Copyright (C) 1995-2001 Microsoft Corporation

Module Name:

    DataSrc.H

Abstract:

	Declares DataSrc objects.

History:

	a-davj  21-Dec-99       Created.

--*/


#ifndef _DataSrc_H_
#define _DataSrc_H_

#include "stdio.h"
#include <helper.h>

/*-----------------------------------------------------------------------
  GenericException
  -----------------------------------------------------------------------*/

class GenericException
{
    DWORD m_errorCode;
public:

    GenericException() : m_errorCode(GetLastError()) {}
    GenericException( DWORD errorCode ) : m_errorCode(errorCode) {}
    DWORD GetErrorCode() const { return m_errorCode; }
    HRESULT GetHRESULT() const {return HRESULT_FROM_WIN32(m_errorCode);}
};


class DataSrc
{
public:
	DataSrc(): m_iPos(0), m_iSize(0), m_iStatus(0){};
	virtual ~DataSrc(){return;};
	virtual wchar_t GetAt(int nOffset) = 0;
	virtual void Move(int n) = 0;
	int GetPos(){return m_iPos;};
	int GetStatus(){return m_iStatus;};
	bool PastEnd(){return m_iPos >= m_iSize;};
	bool WouldBePastEnd(int iOffset){return (m_iPos+iOffset) >= m_iSize;};
	virtual int MoveToStart() = 0;
	virtual int MoveToPos(int iPos)=0;
	virtual TCHAR * GetFileName(){ return NULL; };
protected:
	int m_iPos;
	int m_iSize;
	int m_iStatus;
};

class FileDataSrc : public DataSrc
{
public:
	FileDataSrc(TCHAR * pFileName);
	~FileDataSrc();
	wchar_t GetAt(int nOffset);
	void Move(int n);
	int MoveToStart();
	int MoveToPos(int iPos);
	TCHAR * GetFileName(){ return m_pFileName; };

private:
	void UpdateBuffer();
	FILE * m_fp;
	TCHAR * m_pFileName;
	int m_iFilePos;
	int m_iToFar;
	wchar_t m_Buff[10000];
};

#ifdef USE_MMF_APPROACH
class FileDataSrc1 : public DataSrc
{

public:
	FileDataSrc1(TCHAR * pFileName);
	~FileDataSrc1();
	wchar_t GetAt(int nOffset);
	void Move(int n);
	int MoveToStart();
	int MoveToPos(int iPos);
	TCHAR * GetFileName(){ return m_pFileName; };

private:
	HANDLE m_hFile;
       HANDLE m_hFileMapSrc;
       WCHAR * m_pData;	
	TCHAR * m_pFileName;
};
#endif

class BufferDataSrc : public DataSrc
{
public:
	BufferDataSrc(long lSize, char *  pMemSrc);
	~BufferDataSrc();
	wchar_t GetAt(int nOffset);
	void Move(int n);
	int MoveToStart();
	int MoveToPos(int iPos){m_iPos = iPos; return iPos;};

private:
	wchar_t * m_Data;	    // only used if type is BUFFER

};

class BMOFDataSrc : public DataSrc
{
private:
	TCHAR m_FileName[MAX_PATH+1];
public:
	BMOFDataSrc(TCHAR * szFileName){ StringCchCopy(m_FileName,LENGTH_OF(m_FileName),szFileName); };
	TCHAR * GetFileName(){ return &m_FileName[0]; };
	wchar_t GetAt(int nOffset){  return 0; };
	void Move(int n){  };
	int MoveToStart(){ return 0; };
	int MoveToPos(int iPos){ return 0; };
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\mofcomp_dll\dllcalls.h ===
/*++

Copyright (C) 1998-2001 Microsoft Corporation

Module Name:

    DLLCALLS.H

Abstract:

	This file defines the entry points for calling this as a dll rather than a com object.

History:

	3/20/00     a-davj      Created

--*/

#ifndef __DLLCALLS__H_
#define __DLLCALLS__H_

HRESULT APIENTRY  CompileFileViaDLL( 
            /* [in] */ LPWSTR FileName,
            /* [in] */ LPWSTR ServerAndNamespace,
            /* [in] */ LPWSTR User,
            /* [in] */ LPWSTR Authority,
            /* [in] */ LPWSTR Password,
            /* [in] */ LONG lOptionFlags,
            /* [in] */ LONG lClassFlags,
            /* [in] */ LONG lInstanceFlags,
            /* [out][in] */ WBEM_COMPILE_STATUS_INFO __RPC_FAR *pInfo);

HRESULT APIENTRY  CreateBMOFViaDLL( 
            /* [in] */ LPWSTR TextFileName,
            /* [in] */ LPWSTR BMOFFileName,
            /* [in] */ LPWSTR ServerAndNamespace,
            /* [in] */ LONG lOptionFlags,
            /* [in] */ LONG lClassFlags,
            /* [in] */ LONG lInstanceFlags,
            /* [out][in] */ WBEM_COMPILE_STATUS_INFO __RPC_FAR *pInfo);


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\mofcomp_dll\localloc.cpp ===
/*++

Copyright (C) 1999-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/

#include "precomp.h"
#include <arena.h>
#include <align.h>

class CGetHeap
{
private:
    HANDLE m_hHeap;
    BOOL   m_bNewHeap;
public:
    CGetHeap();
    ~CGetHeap();

    operator HANDLE(){ return m_hHeap; };
};

CGetHeap g_Heap;

CGetHeap::CGetHeap():m_bNewHeap(FALSE)
{
#ifdef DBG
    DWORD dwUsePrivateHeap = 1;
#else
    DWORD dwUsePrivateHeap = 0;
#endif
    HKEY hKey;
    LONG lRet = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                             __TEXT("Software\\Microsoft\\WBEM\\CIMOM"),
                             NULL,
                             KEY_READ,
                             &hKey);

    if (ERROR_SUCCESS == lRet)
    {
        DWORD dwType;
        DWORD dwSize = sizeof(DWORD);
        lRet = RegQueryValueEx(hKey,
                               __TEXT("EnablePrivateMofdHeap"),
                               NULL,
                               &dwType,
                               (BYTE *)&dwUsePrivateHeap,
                               &dwSize);
        RegCloseKey(hKey);
    }
    
    if (dwUsePrivateHeap)
    {
        m_hHeap = HeapCreate(0,0,0);
        if (m_hHeap)
            m_bNewHeap = TRUE;
    }
    else
    {
        m_hHeap = CWin32DefaultArena::GetArenaHeap();
    }
    if (NULL == m_hHeap)
        m_hHeap = GetProcessHeap();
};

CGetHeap::~CGetHeap()
    {
        if (m_bNewHeap)
        {
            HeapDestroy(m_hHeap);
        }
    };



void* __cdecl operator new ( size_t size )
{
    void * p =  HeapAlloc(g_Heap,0,size);
    return p;
}
    
void __cdecl operator delete ( void* pv )
{
    HeapFree(g_Heap,0,pv);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\mofcomp_dll\mofcomp.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    MOFCOMP.H

Abstract:

	Declarations exports for the mof compiler dll.

History:

--*/

#ifndef _mofcomp_H_
#define _mofcomp_H_

#define DONT_ADD_TO_AUTORECOVER 1

#define AUTORECOVERY_REQUIRED 1

// Usage notes;  Both functions invoke the inprocess mofcompiler, with the only difference being that the
// first function takes a file name while the second takes a buffer and a size.  
// The bDoPrintf argument should be set to true if you want printfs to happen.  That isnt generally needed
// as the output goes into the log no matter what.
// The LocatorGUID should be set to CLSID_WbemAdministrativeLocator for providers and core.
// The argc and argv arguements are probably not needed, but if need be, are standard mofcomp arguments.


extern "C" SCODE APIENTRY CompileFile(LPSTR pFileName, BOOL bDoPrintf, GUID LocatorGUID, IWbemContext * pCtx, 
		int argc, char ** argv);

extern "C" SCODE APIENTRY CompileFileEx(LPSTR pFileName, BOOL bDoPrintf, GUID LocatorGUID, IWbemContext * pCtx, 
		DWORD dwFlagsIn, DWORD *pdwFlagsOut, int argc, char ** argv);

extern "C" SCODE APIENTRY CompileBuffer(BYTE * pBuffer, DWORD dwBuffSize, BOOL bDoPrintf, GUID LocatorGUID, IWbemServices * pOverride, IWbemContext * pCtx, 
		int argc, char ** argv);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\mofcomp_dll\maindll.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    MAINDLL.CPP

Abstract:

    Contains DLL entry points.  Also has code that controls
    when the DLL can be unloaded by tracking the number of
    objects and locks.

History:

    a-davj  15-Aug-96   Created.

--*/

#include "precomp.h"
#include <initguid.h>
#include <wbemidl.h>
#include <winver.h>
#include <cominit.h>
#include <wbemutil.h>
#include <wbemprov.h>
#include <wbemint.h>
#include <stdio.h>
#include <reg.h>
#include <genutils.h>
#include "comobj.h"
#include "mofout.h"
#include "mofcomp.h"
#include "mofparse.h"
#include "mofdata.h"
#include "bmof.h"
#include "cbmofout.h"
#include "trace.h"
#include "strings.h"
#include <arrtempl.h>

#include <helper.h>
#include <autoptr.h>

HINSTANCE ghModule;

//***************************************************************************
//
//  BOOL WINAPI DllMain
//
//  DESCRIPTION:
//
//  Entry point for DLL.  Good place for initialization.
//
//  PARAMETERS:
//
//  hInstance           instance handle
//  ulReason            why we are being called
//  pvReserved          reserved
//
//  RETURN VALUE:
//
//  TRUE if OK.
//
//***************************************************************************

BOOL WINAPI DllMain(
                        IN HINSTANCE hInstance,
                        IN ULONG ulReason,
                        LPVOID pvReserved)
{
    if (DLL_PROCESS_DETACH == ulReason)
    {

    }
    else if (DLL_PROCESS_ATTACH == ulReason)
    {
        ghModule = hInstance;
    }

    return TRUE;
}

static ULONG g_cObj = 0;
ULONG g_cLock = 0;

void ObjectCreated()
{
    InterlockedIncrement((LONG *) &g_cObj);
}

void ObjectDestroyed()
{
    InterlockedDecrement((LONG *) &g_cObj);
}


//***************************************************************************
//
//  STDAPI DllGetClassObject
//
//  DESCRIPTION:
//
//  Called when Ole wants a class factory.  Return one only if it is the sort
//  of class this DLL supports.
//
//  PARAMETERS:
//
//  rclsid              CLSID of the object that is desired.
//  riid                ID of the desired interface.
//  ppv                 Set to the class factory.
//
//  RETURN VALUE:
//
//  S_OK                all is well
//  E_FAILED            not something we support
//  
//***************************************************************************

STDAPI DllGetClassObject(
                        IN REFCLSID rclsid,
                        IN REFIID riid,
                        OUT LPVOID * ppv)
{
    HRESULT hr = WBEM_E_FAILED;

    IClassFactory * pFactory = NULL;
    if (CLSID_WinmgmtMofCompiler == rclsid)
        pFactory = new CGenFactory<CWinmgmtMofComp>();
    else if (CLSID_MofCompiler == rclsid)
        pFactory = new CGenFactory<CMofComp>();
    else if (CLSID_MofCompilerOOP == rclsid)
        pFactory = new CGenFactory<CMofCompOOP>();
    

    if(pFactory == NULL)
        return E_FAIL;
    hr=pFactory->QueryInterface(riid, ppv);

    if (FAILED(hr))
        delete pFactory; 

    return hr;
}


//***************************************************************************
//
//  STDAPI DllCanUnloadNow
//
//  DESCRIPTION:
//
//  Answers if the DLL can be freed, that is, if there are no
//  references to anything this DLL provides.
//
//  RETURN VALUE:
//
//  S_OK                if it is OK to unload
//  S_FALSE             if still in use
//  
//***************************************************************************

STDAPI DllCanUnloadNow(void)
{
    SCODE   sc;

    //It is OK to unload if there are no objects or locks on the
    // class factory.

    sc=(0L==g_cObj && 0L==g_cLock) ? S_OK : S_FALSE;
    return sc;
}

//***************************************************************************
//
// DllRegisterServer
//
// Purpose: Called during setup or by regsvr32.
//
// Return:  NOERROR if registration successful, error otherwise.
//***************************************************************************

STDAPI DllRegisterServer(void)
{ 
    RegisterDLL(ghModule, CLSID_MofCompiler, __TEXT("MOF Compiler"), __TEXT("Both"), NULL);
    RegisterDLL(ghModule, CLSID_WinmgmtMofCompiler, __TEXT("Winmgmt MOF Compiler"), __TEXT("Both"), NULL);
    RegisterDllAppid(ghModule,CLSID_MofCompilerOOP,__TEXT("Winmgmt MOF Compiler OOP"),
                             __TEXT("Both"),
                             __TEXT("O:SYG:SYD:(D;;0x1;;;BU)(A;;0x1;;;SY)"),
                             __TEXT("O:SYG:SYD:(D;;0x1;;;BU)(A;;0x1;;;SY)"));
    return NOERROR;
}

//***************************************************************************
//
// DllUnregisterServer
//
// Purpose: Called when it is time to remove the registry entries.
//
// Return:  NOERROR if registration successful, error otherwise.
//***************************************************************************

STDAPI DllUnregisterServer(void)
{
    UnRegisterDLL(CLSID_MofCompiler,NULL);
    UnRegisterDLL(CLSID_WinmgmtMofCompiler,NULL);
    UnregisterDllAppid(CLSID_MofCompilerOOP);
    return NOERROR;
}

//***************************************************************************
//
//  bool IsValidMulti
//
//  DESCRIPTION:
//
//  Does a sanity check on a multstring.
//
//  PARAMETERS:
//
//  pMultStr        Multistring to test.
//  dwSize          size of multistring
//
//  RETURN:
//
//  true if OK
//
//***************************************************************************

bool IsValidMulti(TCHAR * pMultStr, DWORD dwSize)
{
    if(pMultStr && dwSize >= 2 && pMultStr[dwSize-2]==0 && pMultStr[dwSize-1]==0)
        return true;
    return false;
}

//***************************************************************************
//
//  bool IsStringPresent
//
//  DESCRIPTION:
//
//  Searches a multstring for the presense of a string.
//
//  PARAMETERS:
//
//  pTest           String to look for.
//  pMultStr        Multistring to test.
//
//  RETURN:
//
//  true if string is found
//
//***************************************************************************

bool IsStringPresent(TCHAR * pTest, TCHAR * pMultStr)
{
    TCHAR * pTemp;
    for(pTemp = pMultStr; *pTemp; pTemp += lstrlen(pTemp) + 1)
        if(!lstrcmpi(pTest, pTemp))
            return true;
    return false;
}

//***************************************************************************
//
//  void AddToAutoRecoverList
//
//  DESCRIPTION:
//
//  Adds the file to the autocompile list, if it isnt already on it.
//
//  PARAMETERS:
//
//  pFileName           File to add
//
//***************************************************************************

void AddToAutoRecoverList(TCHAR * pFileName)
{
    TCHAR cFullFileName[MAX_PATH+1];
    TCHAR * lpFile;
    DWORD dwSize;
    TCHAR * pNew = NULL;
    TCHAR * pTest;
    DWORD dwNewSize = 0;
    DWORD dwNumChar = 0;

    // Get the full file name

    long lRet = GetFullPathName(pFileName, MAX_PATH, cFullFileName, &lpFile);
    if(lRet == 0)
        return;

    bool bFound = false;
    Registry r(WBEM_REG_WINMGMT);
    TCHAR *pMulti = r.GetMultiStr(TEXT("Autorecover MOFs"), dwSize);
    dwNumChar = dwSize / sizeof(TCHAR);
    
    // Ignore the empty string case

    if(dwSize == 1)
    {
        delete pMulti;
        pMulti = NULL;
    }
    if(pMulti)
    {
        CDeleteMe<TCHAR> dm(pMulti);
        if(!IsValidMulti(pMulti, dwNumChar))
        {
            return;             // bail out, messed up multistring
        }
        bFound = IsStringPresent(cFullFileName, pMulti);
        if(!bFound)
            {

            // The registry entry does exist, but doesnt have this name
            // Make a new multistring with the file name at the end

            dwNewSize = dwNumChar + lstrlen(cFullFileName) + 1;
            pNew = new TCHAR[dwNewSize];
            if(!pNew)
                return;
            memcpy(pNew, pMulti, dwSize);

            // Find the double null

            for(pTest = pNew; pTest[0] || pTest[1]; pTest++);     // intentional semi

            // Tack on the path and ensure a double null;

            pTest++;
            StringCchCopyW(pTest, dwNewSize - (pTest - pNew), cFullFileName);
            pTest+= lstrlen(cFullFileName)+1;
            *pTest = 0;         // add second numm
        }
    }
    else
    {
        // The registry entry just doesnt exist.  Create it with a value equal to our name 

        dwNewSize = lstrlen(cFullFileName) + 2;    // note extra char for double null
        pNew = new TCHAR[dwNewSize];
        if(!pNew)
            return;
        StringCchCopyW(pNew, dwNewSize, cFullFileName);        
        pTest = pNew + lstrlen(pNew) + 1;
        *pTest = 0;         // add second null
    }

    if(pNew)
    {
        r.SetMultiStr(TEXT("Autorecover MOFs"), pNew, dwNewSize*sizeof(TCHAR));
        delete pNew;
    }

    FILETIME ftCurTime;
    LARGE_INTEGER liCurTime;
    TCHAR szBuff[50];
    GetSystemTimeAsFileTime(&ftCurTime);
    liCurTime.LowPart = ftCurTime.dwLowDateTime;
    liCurTime.HighPart = ftCurTime.dwHighDateTime;
    _ui64tow(liCurTime.QuadPart, szBuff, 10);
    r.SetStr(TEXT("Autorecover MOFs timestamp"), szBuff);

}


//
//
////////////////////////////////////////////////

VOID inline Hex2Char(BYTE Byte,TCHAR * &pOut)
{
    BYTE HiNibble = (Byte&0xF0) >> 4;
    BYTE LoNibble = Byte & 0xF;

    *pOut = (HiNibble<10)?(__TEXT('0')+HiNibble):(__TEXT('A')+HiNibble-10);
    pOut++;
    *pOut = (LoNibble<10)?(__TEXT('0')+LoNibble):(__TEXT('A')+LoNibble-10);
    pOut++;
}

// returns "string" representation of a buffer as a HEX number

VOID Buffer2String(BYTE * pStart,DWORD dwSize,TCHAR * pOut)
{
    for (DWORD i=0;i<dwSize;i++) Hex2Char(pStart[i],pOut);
}

//
// given the pathname d:\folder1\folder2\foo.mof
// it returns
// ppHash        = MD5 Hash of the UPPERCASE UNICODE Path + '.mof'
// call delete [] on return values
//
//////////////////////////////////////////////

DWORD ComposeName(WCHAR * pFullLongName, WCHAR **ppHash)
{
    if (NULL == ppHash ) return ERROR_INVALID_PARAMETER;

    DWORD dwLen = wcslen(pFullLongName);  

    WCHAR * pConvert = pFullLongName;
    for (DWORD i=0;i<dwLen;i++) pConvert[i] = wbem_towupper(pConvert[i]);

    wmilib::auto_buffer<WCHAR> pHash(new WCHAR[32 + 4 + 1]);
    if (NULL == pHash.get()) return ERROR_OUTOFMEMORY;

    MD5	md5;
    BYTE aSignature[16];
    md5.Transform( pFullLongName, dwLen * sizeof(WCHAR), aSignature );
    Buffer2String(aSignature,16,pHash.get());

    StringCchCopy(&pHash[32],5 ,__TEXT(".mof"));

    *ppHash = pHash.release();
    return ERROR_SUCCESS;
}


DWORD g_FileSD[] = {
0x80040001, 0x00000000, 0x00000000, 0x00000000,
0x00000014, 0x00340002, 0x00000002, 0x00140000, 
FILE_ALL_ACCESS, 0x00000101, 0x05000000, 0x00000012, 
0x00180000, FILE_ALL_ACCESS, 0x00000201, 0x05000000, 
0x00000020, 0x00000220 
};


//
//
// pFileName is already assumed to be the full path
//
/////////////////////////////////////////////////////
DWORD 
CopyFileToAutorecover(TCHAR * pFileNameRegistry, TCHAR * pFileNameAutoRecover,BOOL bIsBMOF)
{
    // get the AutoRecover
    HKEY hKey;
    LONG lRet;
    lRet = RegOpenKeyExW(HKEY_LOCAL_MACHINE,WBEM_REG_WINMGMT,0,
                       KEY_READ,&hKey);
    if (ERROR_SUCCESS != lRet) return lRet;
    OnDelete<HKEY,LONG(*)(HKEY),RegCloseKey> cmReg(hKey);

    DWORD dwType;
    DWORD dwReq = 0;
    lRet = RegQueryValueExW(hKey,L"Working Directory",0,
                           &dwType,NULL,&dwReq);
    if (!(ERROR_SUCCESS == lRet && REG_EXPAND_SZ == dwType)) return lRet;
    if (0 == dwReq ) return lRet;

    wmilib::auto_buffer<WCHAR> pWorkDir(new WCHAR[dwReq /sizeof(WCHAR)]);
    if (NULL == pWorkDir.get()) return ERROR_OUTOFMEMORY;

    lRet = RegQueryValueExW(hKey,L"Working Directory",0,
                           &dwType,(BYTE *)pWorkDir.get(),&dwReq);
    if (ERROR_SUCCESS != lRet || REG_EXPAND_SZ != dwType) return lRet;
    DWORD cchReq = ExpandEnvironmentStrings(pWorkDir.get(),NULL,0);

    size_t cchTot = cchReq + sizeof("\\AutoRecover\\") + 4 + 32 + 1;
    wmilib::auto_buffer<WCHAR> pWorkDirExpand(new WCHAR[cchTot]);
    if (NULL == pWorkDirExpand.get()) return ERROR_OUTOFMEMORY;    

    ExpandEnvironmentStrings(pWorkDir.get(),pWorkDirExpand.get(),cchTot);

    WCHAR * pHashedName = NULL;
    lRet = ComposeName(pFileNameRegistry,&pHashedName);
    if (ERROR_SUCCESS != lRet) return lRet;
    wmilib::auto_buffer<WCHAR> DelMe(pHashedName);

    StringCchCat(pWorkDirExpand.get(),cchTot,L"\\AutoRecover\\");
    StringCchCat(pWorkDirExpand.get(),cchTot,pHashedName);    
    
    HANDLE hSrcFile = CreateFile(pFileNameAutoRecover,GENERIC_READ,FILE_SHARE_READ,NULL,
                              OPEN_EXISTING,0,NULL);
    if (INVALID_HANDLE_VALUE == hSrcFile) return GetLastError();
    OnDelete<HANDLE,BOOL(*)(HANDLE),CloseHandle> cmSrc(hSrcFile);

    DWORD dwSize = GetFileSize(hSrcFile,NULL);
    HANDLE hFileMapSrc = CreateFileMapping(hSrcFile,
                                       NULL,
                                       PAGE_READONLY,
                                       0,0,  // the entire file
                                       NULL);
    if (NULL == hFileMapSrc) return GetLastError();
    OnDelete<HANDLE,BOOL(*)(HANDLE),CloseHandle> cmMapSrc(hFileMapSrc);

    VOID * pData = MapViewOfFile(hFileMapSrc,FILE_MAP_READ,0,0,0);
    if (NULL == pData) return GetLastError();
    OnDelete<PVOID,BOOL(*)(LPCVOID),UnmapViewOfFile> UnMap(pData);

    SECURITY_ATTRIBUTES SecAttr = {sizeof(SecAttr),g_FileSD,FALSE};
    HANDLE hDest = CreateFile(pWorkDirExpand.get(),GENERIC_WRITE,0,&SecAttr,
                           CREATE_ALWAYS,0,NULL);
    if (INVALID_HANDLE_VALUE == hDest) return GetLastError();
    OnDelete<HANDLE,BOOL(*)(HANDLE),CloseHandle> cmDest(hDest);

    DWORD dwWritten;
    if (!bIsBMOF)
    {
        WORD UnicodeSign = 0xFEFF;
        if (FALSE == WriteFile(hDest,&UnicodeSign,sizeof(UnicodeSign),&dwWritten,NULL)) return GetLastError();    
    }
    if (FALSE == WriteFile(hDest,pData,dwSize,&dwWritten,NULL)) return GetLastError();

    return ERROR_SUCCESS;
}

//***************************************************************************
//
//  void AddToAutoRecoverList2
//
//  DESCRIPTION:
//
//  The intent is to add to the AutoRecover List
//  first of all, create a copy of the pre-processed file into the AutoRecover Folder
//  the file name will the the MD5 hash of the uppercase FULL name
//  Adds the file to the autocompile list, if it isnt already on it.
//  
//
//  PARAMETERS:
//
//  pFileName           File to add
//
//***************************************************************************

void AddToAutoRecoverList2(TCHAR * pFileName,
                        TCHAR * pAutoRecoverFileName,
                        BOOL CopyFileOnly,
                        BOOL bIsBMOF)
{
    TCHAR cFullFileName[MAX_PATH+1];
    TCHAR * lpFile;
    DWORD dwSize;
    TCHAR * pNew = NULL;
    TCHAR * pTest;
    DWORD dwNewSize = 0;
    DWORD dwNumChar = 0;

    // Get the full file name

    long lRet = GetFullPathName(pFileName, MAX_PATH, cFullFileName, &lpFile);
    if(lRet == 0)
        return;

    if (ERROR_SUCCESS != (lRet = CopyFileToAutorecover(cFullFileName,pAutoRecoverFileName,bIsBMOF)))
    {
        ERRORTRACE((LOG_MOFCOMP,"Error %d adding file %S to AutoRecover",lRet,pFileName));
        return;
    }

    if (CopyFileOnly) return;

    bool bFound = false;
    Registry r(WBEM_REG_WINMGMT);
    TCHAR *pMulti = r.GetMultiStr(TEXT("Autorecover MOFs"), dwSize);
    dwNumChar = dwSize / sizeof(TCHAR);
    
    // Ignore the empty string case

    if(dwSize == 1)
    {
        delete pMulti;
        pMulti = NULL;
    }
    if(pMulti)
    {
        CDeleteMe<TCHAR> dm(pMulti);
        if(!IsValidMulti(pMulti, dwNumChar))
        {
            return;             // bail out, messed up multistring
        }
        bFound = IsStringPresent(cFullFileName, pMulti);
        if(!bFound)
        {

            // The registry entry does exist, but doesnt have this name
            // Make a new multistring with the file name at the end

            dwNewSize = dwNumChar + lstrlen(cFullFileName) + 1;
            pNew = new TCHAR[dwNewSize];
            if(!pNew)
                return;
            memcpy(pNew, pMulti, dwSize);

            // Find the double null

            for(pTest = pNew; pTest[0] || pTest[1]; pTest++);     // intentional semi

            // Tack on the path and ensure a double null;

            pTest++;
            StringCchCopy(pTest,dwNewSize - (pTest - pNew),cFullFileName);
            pTest+= lstrlen(cFullFileName)+1;
            *pTest = 0;         // add second numm

        }
    }
    else
    {
        // The registry entry just doesnt exist.  Create it with a value equal to our name 

        dwNewSize = lstrlen(cFullFileName) + 2;    // note extra char for double null
        pNew = new TCHAR[dwNewSize];
        if(!pNew)
            return;
        StringCchCopy(pNew,dwNewSize,cFullFileName);
        pTest = pNew + lstrlen(pNew) + 1;
        *pTest = 0;         // add second null
         
    }

    if(pNew)
    {
        r.SetMultiStr(TEXT("Autorecover MOFs"), pNew, dwNewSize*sizeof(TCHAR));
        delete pNew;
    }

    FILETIME ftCurTime;
    LARGE_INTEGER liCurTime;
    TCHAR szBuff[50];
    GetSystemTimeAsFileTime(&ftCurTime);
    liCurTime.LowPart = ftCurTime.dwLowDateTime;
    liCurTime.HighPart = ftCurTime.dwHighDateTime;
    _ui64tow(liCurTime.QuadPart, szBuff, 10);
    r.SetStr(TEXT("Autorecover MOFs timestamp"), szBuff);

}


//***************************************************************************
//
//  int Trace
//
//  DESCRIPTION:
//
//  Allows for the output function (printf in this case) to be overridden.
//
//  PARAMETERS:
//
//  *fmt                format string.  Ex "%s hello %d"
//  ...                 argument list.  Ex cpTest, 23
//
//  RETURN VALUE:
//
//  size of output in characters.
//***************************************************************************

int Trace(bool bError, PDBG pDbg,DWORD dwID, ...)
{

    IntString is(dwID);
    TCHAR * fmt = is;

    TCHAR *buffer = new TCHAR[2048];
    if(buffer == NULL)
        return 0;
    char *buffer2 = new char[4096];
    if(buffer2 == NULL)
    {
        delete buffer;
        return 0;
    }

    va_list argptr;
    int cnt;
    va_start(argptr, dwID);
    cnt = StringCchVPrintfW(buffer, 2048, fmt, argptr);    
    va_end(argptr);
    CharToOem(buffer, buffer2);

    if(pDbg && pDbg->m_bPrint)
        printf("%s", buffer2);
    if(bError)
        ERRORTRACE((LOG_MOFCOMP,"%s", buffer2));
    else
        DEBUGTRACE((LOG_MOFCOMP,"%s", buffer2));

    delete buffer;
    delete buffer2;
    return cnt;

}


//***************************************************************************
//
//  HRESULT StoreBMOF
//
//  DESCRIPTION:
//
//  This stores the intermediate data as a BINARY MOF instead of storing it to
//  the WBEM database.
//
//  PARAMETERS:
//
//  pObjects            The intermediate data
//  bWMICheck           If true, the the wmi checker program is automatically started
//  BMOFFileName        file name to store the data to.
//
//  RETURN VALUE:
//
//  0 if OK, otherwise an error code
//
//***************************************************************************

HRESULT StoreBMOF(CMofParser & Parser, CPtrArray * pObjects, BOOL bWMICheck, LPTSTR BMOFFileName, PDBG pDbg)
{
    int i;
    {
        CBMOFOut BMof(BMOFFileName, pDbg);

        // Go through all the objects and add them to the database
        // =======================================================

        for(i = 0; i < pObjects->GetSize(); i++)
        {
            CMObject* pObject = (CMObject*)(*pObjects)[i];
            pObject->Reflate(Parser);
            BMof.AddClass(pObject, FALSE);  // possibly add to the BMOF output buffer
            pObject->Deflate(false);
        }
        if(!BMof.WriteFile())
        {
            return WBEM_E_FAILED;
        }
    }


    if(bWMICheck)
    {
        PROCESS_INFORMATION pi;
        STARTUPINFO si;
        si.cb = sizeof(si);
        si.lpReserved = 0;
        si.lpDesktop = NULL;
        si.lpTitle = NULL;
        si.dwFlags = 0;
        si.cbReserved2 = 0;
        si.lpReserved2 = 0;
        TCHAR App[MAX_PATH];
        StringCchCopyW(App, MAX_PATH, TEXT("wmimofck "));
        StringCchCatW(App, MAX_PATH, BMOFFileName);

        BOOL bRes = CreateProcess(NULL,
                                 App,
                            NULL,
                            NULL,
                            FALSE,
                            0,
                            NULL,
                            NULL,
                            &si,
                            &pi);
        if(bRes == 0)
        {
            DWORD dwError = GetLastError();
            Trace(true, pDbg, WMI_LAUNCH_ERROR, dwError);
            return dwError;
        }
    }
    return WBEM_NO_ERROR;

}


void SetInfo(WBEM_COMPILE_STATUS_INFO *pInfo, long lPhase, HRESULT hRes)
{
    if(pInfo)
    {
        pInfo->lPhaseError = lPhase;
        pInfo->hRes = hRes;
    }
}


HRESULT ExtractAmendment(CMofParser & Parser, WCHAR * wszBmof)
{
    // if this is being used for splitting, then possibly get the amendment value
    // It would be passed in the wszBmof string and would be found after
    // the characters ",a".  For example, the string might be ",aMS_409,fFileName.mof"

    if(wszBmof == NULL || wszBmof[0] != L',')
        return S_OK;                                 // not a problem, is usual case

    // make a copy of the string

    DWORD dwLen = wcslen(wszBmof)+1;
    WCHAR *pTemp = new WCHAR[dwLen];    
    if(pTemp == NULL)
        return WBEM_E_OUT_OF_MEMORY;

    CDeleteMe<WCHAR> dm1(pTemp);
    StringCchCopyW(pTemp, dwLen, wszBmof);

    // use wcstok to do a seach

    WCHAR * token = wcstok( pTemp, L"," );
    while( token != NULL )   
    {
        if(token[0] == L'a')
        {
            return Parser.SetAmendment(token+1);
        }
        token = wcstok( NULL, L"," );   
    }
    return S_OK;
}

SCODE Compile(CMofParser & Parser, IWbemServices *pOverride, IWbemContext * pCtx, 
              long lOptionFlags, long lClassFlags, long lInstanceFlags,
                WCHAR * wszDefault, WCHAR *UserName, WCHAR *pPassword , WCHAR *Authority, 
                WCHAR * wszBmof, bool bInProc, WBEM_COMPILE_STATUS_INFO *pInfo)
{

    // do flag validity check

    if((lOptionFlags & WBEM_FLAG_DONT_ADD_TO_LIST) && (lOptionFlags & WBEM_FLAG_AUTORECOVER))
    {
        SetInfo(pInfo, 1, WBEM_E_INVALID_PARAMETER);
        return S_FALSE;
    }
    long lValid = WBEM_FLAG_DONT_ADD_TO_LIST | WBEM_FLAG_AUTORECOVER | 
                       WBEM_FLAG_CHECK_ONLY | WBEM_FLAG_WMI_CHECK | 
                       WBEM_FLAG_SPLIT_FILES | WBEM_FLAG_CONSOLE_PRINT |
                       WBEM_FLAG_CONNECT_REPOSITORY_ONLY | WBEM_FLAG_CONNECT_PROVIDERS; 
    if(lOptionFlags & ~lValid)
    {
        SetInfo(pInfo, 1, WBEM_E_INVALID_PARAMETER);
        return S_FALSE;
    }

    // Init buffers for command line args.
    // ===================================

    HRESULT hres;

    // This scope is defined so that the local variables, such as the PARSE 
    // object are destroyed before CoUninitialize is called.

    TCHAR cBMOFOutputName[MAX_PATH] = TEXT("");
    if(wszBmof)
        CopyOrConvert(cBMOFOutputName, wszBmof, MAX_PATH);

    // Parse command line arguments
    // ============================

    BOOL bCheckOnly = lOptionFlags & WBEM_FLAG_CHECK_ONLY;
    BOOL bWMICheck = lOptionFlags & WBEM_FLAG_WMI_CHECK;
    bool bAutoRecover = (lOptionFlags & WBEM_FLAG_AUTORECOVER) != 0;

    if(wszDefault && wcslen(wszDefault) > 0)
    {
        hres = Parser.SetDefaultNamespace(wszDefault);
        if(FAILED(hres))
            return hres;
    }

    hres = ExtractAmendment(Parser, wszBmof);
    if(FAILED(hres))
        return hres;

    Parser.SetOtherDefaults(lClassFlags, lInstanceFlags, bAutoRecover);
    if(!Parser.Parse())
    {
        int nLine = 0, nCol = 0, nError;
        TCHAR Msg[1000];
        WCHAR * pErrorFile = NULL;

        if(Parser.GetErrorInfo(Msg, 1000, &nLine, &nCol, &nError, &pErrorFile))
            Trace(true, Parser.GetDbg(), ERROR_SYNTAX, pErrorFile, nLine, nError, //nLine+1,
                Msg);
        SetInfo(pInfo, 2, nError);
        return S_FALSE;
    }
    Parser.SetToNotScopeCheck();
    // Autorecover is not compatible with certain flags
    
    if( ((lOptionFlags & WBEM_FLAG_DONT_ADD_TO_LIST) == 0 ) &&
      (Parser.GetAutoRecover() || bAutoRecover) && 
      ((lInstanceFlags & ~WBEM_FLAG_OWNER_UPDATE) || (lClassFlags & ~WBEM_FLAG_OWNER_UPDATE) || 
      (wszDefault && wszDefault[0] != 0) || Parser.GetRemotePragmaPaths()))
    {
        Trace(true, Parser.GetDbg(), INVALID_AUTORECOVER);
        SetInfo(pInfo, 1, 0);
        return S_FALSE;
    }

    Trace(false, Parser.GetDbg(), SUCCESS);

    if(bCheckOnly)
    {
        Trace(false, Parser.GetDbg(), SYNTAX_CHECK_COMPLETE);
        SetInfo(pInfo, 0, 0);
        return S_OK;
    }
    

    CMofData* pData = Parser.AccessOutput();

    if((lstrlen(cBMOFOutputName) > 0 && (lOptionFlags & WBEM_FLAG_SPLIT_FILES)) || 
        Parser.GetAmendment())
    {
        hres = pData->Split(Parser, wszBmof, pInfo, Parser.IsUnicode(), Parser.GetAutoRecover(),
            Parser.GetAmendment());
        if(hres != S_OK)
        {
            SetInfo(pInfo, 3, hres);
            return S_FALSE;
        }
        else
        {
            SetInfo(pInfo, 0, 0);
            return S_OK;
        }

    }
    else if(lstrlen(cBMOFOutputName))
    {
        if(Parser.IsntBMOFCompatible())
        {
            Trace(true, Parser.GetDbg(), BMOF_INCOMPATIBLE);
            SetInfo(pInfo, 3, WBEM_E_INVALID_PARAMETER);
            return S_FALSE;
        }
        
        Trace(false, Parser.GetDbg(), STORING_BMOF, cBMOFOutputName);
        
        CPtrArray * pObjArray = pData->GetObjArrayPtr(); 
        
        SCODE sc = StoreBMOF(Parser, pObjArray, bWMICheck, cBMOFOutputName, Parser.GetDbg());
        
        if(sc != S_OK)
        {
            SetInfo(pInfo, 3, sc);
            return S_FALSE;
        }
        else
        {
            SetInfo(pInfo, 0, 0);
            return S_OK;
        }
    }

    IWbemLocator* pLocator = NULL;
    hres = CoCreateInstance(
            (bInProc) ? CLSID_WbemAdministrativeLocator : CLSID_WbemLocator,
            NULL, CLSCTX_ALL, IID_IWbemLocator,
            (void**)&pLocator);

    if(FAILED(hres))
    {
        SetInfo(pInfo, 3, hres);
        return S_FALSE;
    }


    Trace(false, Parser.GetDbg(), STORING_DATA);

    hres = pData->Store(Parser, pLocator, pOverride, TRUE,UserName, pPassword , Authority, pCtx,
                                   (bInProc) ? CLSID_WbemAdministrativeLocator : CLSID_WbemLocator,
                                   pInfo,
                                   lClassFlags & WBEM_FLAG_OWNER_UPDATE,
                                   lInstanceFlags & WBEM_FLAG_OWNER_UPDATE,
                                   lOptionFlags & (WBEM_FLAG_CONNECT_PROVIDERS|WBEM_FLAG_CONNECT_REPOSITORY_ONLY));
    if(pLocator != NULL)
        pLocator->Release();
    if(hres != S_OK)
    {
        SetInfo(pInfo, 3, hres);
        return S_FALSE;
    }
    else
    {
        if(Parser.GetFileName() && wcslen(Parser.GetFileName()))
            ERRORTRACE((LOG_MOFCOMP,"Finished compiling file:%ls\n", Parser.GetFileName()));

        _variant_t VarDoStore = false;
        BOOL OverrideAutoRecover = FALSE;
        if (pCtx)  pCtx->GetValue(L"__MOFD_DO_STORE",0,&VarDoStore);
        if (VT_BOOL == V_VT(&VarDoStore) && (VARIANT_TRUE == V_BOOL(&VarDoStore)))
        {
            OverrideAutoRecover = TRUE;
        }
        
        if(Parser.GetAutoRecover() || OverrideAutoRecover)
        {
            if(lOptionFlags & WBEM_FLAG_DONT_ADD_TO_LIST)
            {
                if(pInfo)
                    pInfo->dwOutFlags |= AUTORECOVERY_REQUIRED;                                   
            }

            //Call MOF Compiler with (pszMofs);
            _variant_t Var = false;
            if (pCtx)  pCtx->GetValue(L"__MOFD_NO_STORE",0,&Var);
            if (VT_BOOL == V_VT(&Var) && (VARIANT_TRUE == V_BOOL(&Var)))
            {
            }
            else
            {            
                AddToAutoRecoverList2(Parser.GetFileName(),
                                Parser.GetAutoRecoverFileName(),
                                lOptionFlags & WBEM_FLAG_DONT_ADD_TO_LIST,
                                Parser.IsBMOF());            
            }
        }

        SetInfo(pInfo, 0, 0);
        return S_OK;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\mofcomp_dll\mofdata.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    MOFDATA.CPP

Abstract:

	Entry points for the WBEM MOF compiler.

History:

	a-davj  12-April-97   Added WMI support.

--*/

#include "precomp.h"
#include <cominit.h>
#include "mofout.h"
#include "mofdata.h"
#include "typehelp.h"
#include "bmof.h"
#include "cbmofout.h"
#include "trace.h"
#include "strings.h"
#include "arrtempl.h"
#include <genutils.h>

#define TEMP_BUF 128

WCHAR * Macro_CloneStr(LPCWSTR pFr)
{
    if(pFr == NULL)
        return NULL;
    DWORD dwLen = wcslen(pFr) + 1;
    WCHAR * pTo = new WCHAR[dwLen];
    if(pTo)
    {
        StringCchCopyW(pTo, dwLen, pFr);
        return pTo;
    }
    return NULL;
}

HRESULT MofdSetInterfaceSecurity(IUnknown * pInterface, LPWSTR pAuthority, LPWSTR pUser, 
                                                                                LPWSTR pPassword)
{
    SCODE sc;
    BOOL bUseAuthInfo = FALSE;

    DWORD dwQueryAuthnLevel, dwQueryImpLevel, dwQueryCapabilities;
    DWORD dwAuthnSvc = RPC_C_AUTHN_GSS_NEGOTIATE;
    WCHAR * pwCSPBPrincipal = NULL;          

    HRESULT hr = CoQueryProxyBlanket(
                                                pInterface,      //Location for the proxy to query
                                                &dwAuthnSvc,      //Location for the current authentication service
                                                NULL,      //Location for the current authorization service
                                                NULL,      //Location for the current principal name
                                                &dwQueryAuthnLevel,    //Location for the current authentication level
                                                &dwQueryImpLevel,      //Location for the current impersonation level
                                                NULL,
                                                &dwQueryCapabilities   //Location for flags indicating further capabilities of the proxy
                                                );
    if(SUCCEEDED(hr) && dwAuthnSvc != RPC_C_AUTHN_WINNT)
    {
        pwCSPBPrincipal = COLE_DEFAULT_PRINCIPAL;
    }
    else
    {
        dwAuthnSvc = RPC_C_AUTHN_WINNT;
        pwCSPBPrincipal = NULL;          
    }


    
    // If we are doing trivial case, just pass in a null authenication structure which is used
    // if the current logged in user's credentials are OK.

    if((pAuthority == NULL || wcslen(pAuthority) < 1) && 
        (pUser == NULL || wcslen(pUser) < 1) && 
        (pPassword == NULL || wcslen(pPassword) < 1))
    {
        return WbemSetProxyBlanket(pInterface, dwAuthnSvc, RPC_C_AUTHZ_NONE, 
            pwCSPBPrincipal, 
            RPC_C_AUTHN_LEVEL_DEFAULT, RPC_C_IMP_LEVEL_IMPERSONATE, 
            NULL,
            EOAC_STATIC_CLOAKING);
    }

    // If user, or Authority was passed in, the we need to create an authority argument for the login
    
    COAUTHIDENTITY  authident;
    BSTR AuthArg = NULL, UserArg = NULL, PrincipalArg = NULL;
    sc = DetermineLoginTypeEx(AuthArg, UserArg, PrincipalArg, pAuthority, pUser);
    if(sc != S_OK)
        return sc;
    CSysFreeMe fm1(UserArg), fm2(AuthArg), fm3(PrincipalArg);
    
    memset((void *)&authident,0,sizeof(COAUTHIDENTITY));
    if(UserArg)
    {
        authident.UserLength = wcslen(UserArg);
        authident.User = (LPWSTR)UserArg;
        bUseAuthInfo = TRUE;
    }
    if(AuthArg)
    {
        authident.DomainLength = wcslen(AuthArg);
        authident.Domain = (LPWSTR)AuthArg;
        bUseAuthInfo = TRUE;
    }
    if(pPassword)
    {
        authident.PasswordLength = wcslen(pPassword);
        authident.Password = (LPWSTR)pPassword;
        bUseAuthInfo = TRUE;
    }
    authident.Flags = SEC_WINNT_AUTH_IDENTITY_UNICODE;

    sc = WbemSetProxyBlanket(pInterface, 
        (PrincipalArg) ? RPC_C_AUTHN_GSS_KERBEROS : dwAuthnSvc, 
        RPC_C_AUTHZ_NONE, 
        (PrincipalArg) ? PrincipalArg : pwCSPBPrincipal,
        RPC_C_AUTHN_LEVEL_DEFAULT, RPC_C_IMP_LEVEL_IMPERSONATE, 
        (bUseAuthInfo) ? &authident : NULL,
        (bUseAuthInfo) ? 0 : EOAC_STATIC_CLOAKING
        );
    return sc;
}

CNamespaceCache::CNamespaceRecord::CNamespaceRecord(
                                             COPY LPCWSTR wszName,
                                             ADDREF IWbemServices* pNamespace)
{
    m_wszName = Macro_CloneStr(wszName);
    m_pNamespace = pNamespace;
    m_pNamespace->AddRef();
}

CNamespaceCache::CNamespaceRecord::~CNamespaceRecord()
{
    delete [] m_wszName;
    if(m_pNamespace) m_pNamespace->Release();
}

//*****************************************************************************

CNamespaceCache::CNamespaceCache(ADDREF IWbemLocator* pLocator)
{
    if(pLocator)
        pLocator->AddRef();
    m_pLocator = pLocator;
}

CNamespaceCache::~CNamespaceCache()
{
    if(m_pLocator) m_pLocator->Release();
    for(int i = 0; i < m_aRecords.GetSize(); i++)
    {
        delete (CNamespaceRecord*)m_aRecords[i];
    }
}

RELEASE_ME IWbemServices* CNamespaceCache::GetNamespace(COPY LPCWSTR wszName, SCODE & scRet, 
                                                       WCHAR * pUserName, WCHAR * pPassword , WCHAR * pAuthority,
                                                       IWbemContext * pCtx, GUID LocatorGUID, LONG fConnectFlags)
{
    // Check if it is the cache
    // ========================

	scRet = S_OK;

    for(int i = 0; i < m_aRecords.GetSize(); i++)
    {
        CNamespaceRecord* pRecord = (CNamespaceRecord*)m_aRecords[i];
        if(!wbem_wcsicmp(pRecord->m_wszName, wszName))
        {
            // Found it
            // ========

            pRecord->m_pNamespace->AddRef();
            return pRecord->m_pNamespace;
        }
    }

    // Not found --- open it
    // =====================

    IWbemServices* pNamespace;

    if(wszName == NULL)
        return NULL;

    LPOLESTR pwszName;
    pwszName = SysAllocString(wszName);
    if(pwszName == NULL)
        return NULL;
    CSysFreeMe fm0(pwszName);
    
    LPOLESTR bstrPassword = NULL;
    LPOLESTR bstrUserName = NULL;
    LPOLESTR bstrAuthority = NULL;
    if(pUserName && wcslen(pUserName) > 0)
    {
            bstrUserName = SysAllocString(pUserName);
            if(bstrUserName == NULL)
                return NULL;
    }
    CSysFreeMe fm1(bstrUserName);
        
    if(pPassword)
    {
        bstrPassword = SysAllocString(pPassword);
        if(bstrPassword == NULL)
            return NULL;
    }
    CSysFreeMe fm2(bstrPassword);
    if(pAuthority && wcslen(pAuthority) > 0)
    {
        bstrAuthority = SysAllocString(pAuthority);
        if(bstrAuthority == NULL)
            return NULL;
     }
    CSysFreeMe fm3(bstrAuthority);

    // Determine if the connection is to the regular locator, or to one of the special inproc ones 
    // used for autocompile.  If it is inproc, then remote connections are not valid.

    bool bInProc = false;
    if(LocatorGUID != CLSID_WbemLocator)
        bInProc = true;

    if(bInProc)
    {
        WCHAR * pMachine = ExtractMachineName(pwszName);
        if(pMachine)
        {
            BOOL bLocal = bAreWeLocal(pMachine);
            delete pMachine;
            if(!bLocal)
            {
                scRet = WBEM_E_INVALID_NAMESPACE;
                ERRORTRACE((LOG_MOFCOMP,"Error, tried to do a remote connect during autocomp\n"));
            }
        }
    }

    // Connect up to namespace.  //TODO, PASS AUTHORITY IN THE CONTEXT

    if(scRet == S_OK)
        scRet = m_pLocator->ConnectServer((LPWSTR)pwszName,
            bstrUserName, bstrPassword, 
            NULL, fConnectFlags, 
            pAuthority, pCtx, &pNamespace);
    
    if(scRet == S_OK && !bInProc)
    {

        // Set the impersonation level up so that puts to providers can be done

        DWORD dwAuthLevel, dwImpLevel;
        SCODE sc  = GetAuthImp( pNamespace, &dwAuthLevel, &dwImpLevel);
        if(sc != S_OK || dwAuthLevel != RPC_C_AUTHN_LEVEL_NONE)
            sc = MofdSetInterfaceSecurity(pNamespace, bstrAuthority, bstrUserName, bstrPassword);

    }

    if(FAILED(scRet)) return NULL;

    // Add it to the cache
    // ===================

    CNamespaceRecord * pNew = new CNamespaceRecord(wszName, pNamespace);
    if(pNew)
        m_aRecords.Add(pNew); // AddRef'ed

    return pNamespace;
}






//*****************************************************************************
//*****************************************************************************

void CMofData::SetQualifierDefault(ACQUIRE CMoQualifier* pDefault)
{
    // Search for this qualifier in the defaults list
    // ==============================================

    for(int i = 0; i < m_aQualDefaults.GetSize(); i++)
    {
        CMoQualifier* pOrig = (CMoQualifier*)m_aQualDefaults[i];

        if(wbem_wcsicmp(pOrig->GetName(), pDefault->GetName()) == 0)
        {
            // Found it. Replace
            // =================

            delete pOrig;
            m_aQualDefaults[i] = (void*)pDefault;
            return;
        }
    }
    
    // Not found. Add
    // ==============

    m_aQualDefaults.Add((void*)pDefault);
}

HRESULT CMofData::SetDefaultFlavor(MODIFY CMoQualifier& Qual, bool bTopLevel, QUALSCOPE qs, PARSESTATE ps)
{
    
    HRESULT hr;

    // Search for this qualifier in the defaults list
    // ==============================================

    for(int i = 0; i < m_aQualDefaults.GetSize(); i++)
    {
        CMoQualifier* pOrig = (CMoQualifier*)m_aQualDefaults[i];

        if(wbem_wcsicmp(pOrig->GetName(), Qual.GetName()) == 0)
        {
            // Found it. SetFlavor
            // ===================
            
            if(pOrig->IsCimDefault())
            {
                // dont bother if the parse state is the initial scan

                if(ps == INITIAL)
                    continue;
                if(Qual.IsUsingDefaultValue())
                {

                    // see if the scope matches what we have here

                    DWORD dwScope = pOrig->GetScope();
                    bool bInScope = false;
                    if((dwScope & SCOPE_CLASS) || (dwScope & SCOPE_INSTANCE))
                        if(qs == CLASSINST_SCOPE)
                            bInScope = true;
                    if(dwScope & SCOPE_PROPERTY)
                        if(qs == PROPMETH_SCOPE)
                            bInScope = true;

                    if(bInScope)
                    {
                        CMoValue& Src = pOrig->AccessValue();
                        CMoValue& Dest = Qual.AccessValue();
                        Dest.SetType(Src.GetType());
                        VARIANT & varSrc = Src.AccessVariant();
                        VARIANT & varDest = Dest.AccessVariant();
                        hr = VariantCopy(&varDest, &varSrc);
                        if(FAILED(hr))
                            return hr;
                        Qual.SetFlavor(pOrig->GetFlavor());
                        Qual.SetAmended(pOrig->IsAmended());
                    }
                }
            }
            else
            {
                Qual.SetFlavor(pOrig->GetFlavor());
                Qual.SetAmended(pOrig->IsAmended());
            }
            return S_OK;
        }
    }
    return S_OK;
}

BOOL CMofData::IsAliasInUse(READ_ONLY LPWSTR wszAlias)
{
    for(int i = 0; i < m_aObjects.GetSize(); i++)
    {
        CMObject* pObject = (CMObject*)m_aObjects[i];
        if(pObject->GetAlias() && !wbem_wcsicmp(pObject->GetAlias(), wszAlias))
        {
            return TRUE;
        }
    }

    return FALSE;
}

BOOL IsGuid(LPWSTR pTest)
{
    int i;
    int iSoFar = 0;

#define HEXCHECK(n)                 \
    for (i = 0; i < n; i++)         \
        if (!iswxdigit(*pTest++))   \
            return FALSE;

#define HYPHENCHECK()     \
    if (*pTest++ != L'-') \
        return FALSE;

    if(*pTest++ != L'{')
        return FALSE;

    HEXCHECK(8);
    HYPHENCHECK();
    HEXCHECK(4);
    HYPHENCHECK();
    HEXCHECK(4);
    HYPHENCHECK();
    HEXCHECK(4);
    HYPHENCHECK();
    HEXCHECK(12);

    if(*pTest++ != L'}')
        return FALSE;

    return TRUE;

}

INTERNAL LPCWSTR CMofData::FindAliasee(READ_ONLY LPWSTR wszAlias)
{
    for(int i = 0; i < m_aObjects.GetSize(); i++)
    {
        CMObject* pObject = (CMObject*)m_aObjects[i];
        if(pObject->GetAlias() && !wbem_wcsicmp(pObject->GetAlias(), wszAlias))
        {
            IWbemClassObject * pTemp;
            pTemp = pObject->GetWbemObject();

            // check for unresolved aliases in keys
            
            if(pTemp && pObject->IsDone() == FALSE)
            {

                SCODE sc = pTemp->BeginEnumeration(WBEM_FLAG_KEYS_ONLY | WBEM_FLAG_REFS_ONLY);
                if(sc != S_OK)
                    return NULL;
        
                VARIANT var;
                VariantInit(&var);
                while ((sc = pTemp->Next(0, NULL, &var, NULL, NULL)) == S_OK)
                {
                    if(var.vt == VT_BSTR && IsGuid(var.bstrVal))
                    {
                        VariantClear(&var);
                        return NULL;
                    }
                    VariantClear(&var);
                }
            }
            return pObject->GetFullPath();
        }
    }

    return NULL;
}


HRESULT CMofData::Store(CMofParser & Parser, OLE_MODIFY IWbemLocator* pLocator,IWbemServices *pOverride,BOOL bRollbackable,
                        WCHAR * pUserName, WCHAR * pPassword, WCHAR * pAuthority, 
                        IWbemContext * pCtx, GUID LocatorGUID, WBEM_COMPILE_STATUS_INFO *pInfo,
                        BOOL bClassOwnerUpdate, 
                        BOOL bInstanceOwnerUpdate,
                        LONG fConnectFlags)
{
    HRESULT hres = WBEM_E_FAILED;
    int i;
    CNamespaceCache Cache(pLocator);
	BOOL bMakingProgress = TRUE;
    long lClassFlags = 0;
    long lInstanceFlags = 0; 

    
    while(bMakingProgress)
    {
		bMakingProgress = FALSE;
		for(i = 0; i< m_aObjects.GetSize(); i++)
		{
	        CMObject* pObject = (CMObject*)m_aObjects[i];
       
            if(pObject->IsDone())
                continue;
            lClassFlags = pObject->GetClassFlags();
            lInstanceFlags = pObject->GetInstanceFlags(); 
            if(bClassOwnerUpdate)
            {
                lClassFlags |= WBEM_FLAG_OWNER_UPDATE;
            }
            if(bInstanceOwnerUpdate)
            {
	                lInstanceFlags |= WBEM_FLAG_OWNER_UPDATE;
	     }
            // Get a namespace pointer for this object.

            SCODE scRet;
            IWbemServices* pNamespace = NULL;
            if(pOverride && !wbem_wcsicmp(L"root\\default", pObject->GetNamespace()))
			{
				// AddRef() the namespace pointer, since we will be Releasing
				// it below
				pOverride->AddRef();
                pNamespace = pOverride;
			}
            else
			{
				// This will return an AddRef'd pointer
                pNamespace = Cache.GetNamespace(pObject->GetNamespace(), scRet,
                                                pUserName, pPassword ,pAuthority, pCtx, 
                                                LocatorGUID, fConnectFlags);
			}

            if(pNamespace == NULL)
            {
                int iMsg = (GotLineNumber(i)) ? ERROR_OPENING : ERROR_OPENING_NO_LINES;
                PrintError(i, iMsg, scRet, pInfo);
                return scRet;
            }

			// Ensures we release the namespace pointer when we go out of scope
			CReleaseMe	rmns( pNamespace );

            // If there isnt a wbem object, try to get one.  This will fail if this is a 
            // instance for which the class hasn't been saved just yet.

            if(pObject->GetWbemObject() == NULL)
            {

                IWbemClassObject* pWbemObject = NULL;
                hres = pObject->CreateWbemObject(pNamespace, &pWbemObject,pCtx);
                if(hres != S_OK)
                    if(pObject->IsInstance())
                        continue;
                    else
                    {
                        PrintError(i,
                            (GotLineNumber(i)) ? ERROR_CREATING : ERROR_CREATING_NO_LINES,
                            hres, pInfo);
                        return WBEM_E_FAILED;
                    }
                bMakingProgress = TRUE;
                pObject->Reflate(Parser);
                pObject->SetWbemObject(pWbemObject);

                if(!pObject->ApplyToWbemObject(pWbemObject, pNamespace,pCtx))
                {
                    hres = m_pDbg->hresError;
                    PrintError(i,
                        (GotLineNumber(i)) ? ERROR_CREATING : ERROR_CREATING_NO_LINES,
                        hres, pInfo);
            		return WBEM_E_FAILED;
                }

            }
        
		    // If there are no unresolved aliases, save it!

            if(pObject->GetNumAliasedValues() == 0 ||
                S_OK == pObject->ResolveAliasesInWbemObject(pObject->GetWbemObject(),
                    (CMofAliasCollection*)this))
            {

                // Save this into WinMgmt
                // ==================

                hres = pObject->StoreWbemObject(pObject->GetWbemObject(), lClassFlags, lInstanceFlags,
                                            pNamespace, pCtx, pUserName, pPassword ,pAuthority);
                if(hres != S_OK)
                {
                    PrintError(i,
                        (GotLineNumber(i)) ? ERROR_STORING : ERROR_STORING_NO_LINES,
                        hres, pInfo);
		            return WBEM_E_FAILED;
                }
                pObject->FreeWbemObjectIfPossible();
                pObject->Deflate(false);
                pObject->SetDone();
                bMakingProgress = TRUE;
            }

        }
	}

	// If there is one or more objects that cant be resolved, print and bail

	for(i = 0; i < m_aObjects.GetSize(); i++)
    {
        CMObject* pObject = (CMObject*)m_aObjects[i];
		if(pObject && !pObject->IsDone()) 
        {
            PrintError(i,
                (GotLineNumber(i)) ? ERROR_RESOLVING : ERROR_RESOLVING_NO_LINES,
                hres, pInfo);
		    return WBEM_E_FAILED;
        }
    } 
    return S_OK;
}



HRESULT CMofData::RollBack(int nObjects)
{
    return WBEM_E_FAILED;
}

BOOL CMofData::GotLineNumber(int nIndex)
{
    CMObject* pObject = (CMObject*)m_aObjects[nIndex];
    if(pObject == NULL || (pObject->GetFirstLine() == 0 && pObject->GetLastLine() == 0))
        return FALSE;
    else
        return TRUE;
}
void CMofData::PrintError(int nIndex, long lMsgNum, HRESULT hres, WBEM_COMPILE_STATUS_INFO  *pInfo)
{
    CMObject* pObject = (CMObject*)m_aObjects[nIndex];
    TCHAR szMsg[500];
	bool bErrorFound = false;

	if(pInfo)
		pInfo->ObjectNum = nIndex+1;
    if(!GotLineNumber(nIndex))
        Trace(true, m_pDbg, lMsgNum, nIndex+1);
    else
	{
        Trace(true, m_pDbg, lMsgNum, nIndex+1, pObject->GetFirstLine(), 
                                        pObject->GetLastLine(), pObject->GetFileName());
		if(pInfo)
		{
			pInfo->FirstLine = pObject->GetFirstLine();
			pInfo->LastLine = pObject->GetLastLine();
		}
	}
	if(hres)
	{

		// A few error messages are retrived from the local resources.  This is so that the name can be
		// injected into the name.

        if(hres == WBEM_E_NOT_FOUND || hres == WBEM_E_TYPE_MISMATCH || hres == WBEM_E_OVERRIDE_NOT_ALLOWED ||
			hres == WBEM_E_PROPAGATED_QUALIFIER || hres == WBEM_E_VALUE_OUT_OF_RANGE)
        {
		    Trace(true, m_pDbg, ERROR_FORMAT, hres);
            Trace(true, m_pDbg, hres, m_pDbg->GetString());
			bErrorFound = true;
        }
        else
        {
            // Get the error from the standard error facility

			IWbemStatusCodeText * pStatus = NULL;
			SCODE sc = CoCreateInstance(CLSID_WbemStatusCodeText, 0, CLSCTX_INPROC_SERVER,
												IID_IWbemStatusCodeText, (LPVOID *) &pStatus);
	
			if(sc == S_OK)
			{
				BSTR bstrError = 0;
				BSTR bstrFacility = 0;
				sc = pStatus->GetErrorCodeText(hres, 0, 0, &bstrError);
				if(sc == S_OK)
				{
					sc = pStatus->GetFacilityCodeText(hres, 0, 0, &bstrFacility);
					if(sc == S_OK)
					{
						IntString is(ERROR_FORMAT_LONG);
						StringCchPrintfW(szMsg, 500,  is, hres, bstrFacility, bstrError);
						bErrorFound = true;
						SysFreeString(bstrFacility);
					}
					SysFreeString(bstrError);
				}
				pStatus->Release();
			}

			// if all else fails, just use the generic error message

			if(!bErrorFound)
			{
				IntString is(ERROR_FORMATEX);
				StringCchPrintfW(szMsg, 500 ,is, hres);
			}

			// Print the error message

			if(m_pDbg->m_bPrint)
	            printf("%S", szMsg);
			ERRORTRACE((LOG_MOFCOMP,"%S", szMsg));

		}	// ELSE get error from standard facility

	}	// IF hres

}


//***************************************************************************
//
//  GetFileNames
//
//  DESCRIPTION:
//
//  The amendment local, the localized and neutral file names are passed
//  in using the BMOF string.  These values are separated by commas and 
//  a single letter which indicates what follows.  An example string
//  would be ",aMS_409,nNEUTRAL.MOF,lLocalMof"  Notice that the amendment
//  substring starts with an 'a', the neutral starts with 'n', and the 
//  locale starts with 'l'.
//
//  While the neutral name is required, the locale version isnt.  If not
//  supplied, it will be created.  The two character inputs are ASSUMED to
//  point to preallocated buffers of MAX_PATH size!
//
//***************************************************************************

HRESULT GetFileNames(TCHAR * pcNeutral, TCHAR * pcLocale, LPWSTR pwszBMOF)
{
    WCHAR * pNeutral=NULL;
    WCHAR * pLocale=NULL;
    
    if(pwszBMOF == NULL)
        return WBEM_E_INVALID_PARAMETER;

    // make a copy of the string

    DWORD dwLen = wcslen(pwszBMOF)+1;
    WCHAR *pTemp = new WCHAR[dwLen];
    if(pTemp == NULL)
        return WBEM_E_OUT_OF_MEMORY;

    CDeleteMe<WCHAR> dm1(pTemp);
    StringCchCopyW(pTemp, dwLen, pwszBMOF);

    // use wcstok to do a seach

    WCHAR * token = wcstok( pTemp, L"," );
    while( token != NULL )   
    {
        if(token[0] == L'n')
        {
            pNeutral = token+1;
            CopyOrConvert(pcNeutral, pNeutral, MAX_PATH);
        }
        else if(token[0] == L'l')
        {
            pLocale = token+1;
            CopyOrConvert(pcLocale, pLocale, MAX_PATH);
        }
        token = wcstok( NULL, L"," );
    }

    // If the neutral name was not specified, that is an error

    if(pNeutral == NULL)
        return WBEM_E_INVALID_PARAMETER;

    // If the local name was not specified, create it and make it the
    // same as the neutral name except for changing the mfl extension
    
    if(pLocale == NULL)
    {
        TCHAR * pFr = pcNeutral,* pTo = pcLocale;
        for(; *pFr && *pFr != '.'; pTo++, pFr++)
            *pTo = *pFr;
        *pTo=0;
        StringCchCatW(pcLocale, MAX_PATH, TEXT(".mfl"));
    }

    // make sure that the locale and neutral names are not the same

    if(!lstrcmpi(pcLocale, pcNeutral))
        return WBEM_E_INVALID_PARAMETER;

    return S_OK;
}

//***************************************************************************
//
//  GetLocale
//
//  DESCRIPTION:
//
//  Converts the amendment string to a local number.  An example string
//  would be "MS_409"
//
//***************************************************************************

HRESULT GetLocale(long * plLocale, WCHAR * pwszAmendment)
{
    if(pwszAmendment == NULL || wcslen(pwszAmendment) != 6)
        return WBEM_E_INVALID_PARAMETER;
    *plLocale = 0;
    swscanf(pwszAmendment+3,L"%x", plLocale);
    return (*plLocale != 0) ? S_OK : WBEM_E_INVALID_PARAMETER;
}

//***************************************************************************
//
//  RecursiveSetAmended
//
//  DESCRIPTION:
//
//  Sets the boolean indicating that an object is to be amended and all of
//  its parents
//
//***************************************************************************

void CMofData::RecursiveSetAmended(CMObject * pObj)
{

    // If the object is already amended, then its parents are already set.
    // In that case, our job is done here!

    if(pObj->IsAmended())
        return;

    // If the object hasnt been set yet, set it and also set its parents

    pObj->SetAmended(true);
 
    // Look for the parent and do the same

    if(pObj->IsInstance() || pObj->IsDelete())
        return;                 // run away now if this is a instance!

    CMoClass * pClass = (CMoClass *)pObj;
    const WCHAR *pClassName = pClass->GetParentName();
    if(pClassName == NULL)
        return;

    // Find the parent and recursively set it!

	for(int i = 0; i< m_aObjects.GetSize(); i++)
	{
	    CMObject* pObject = (CMObject*)m_aObjects[i];
		if(pObject && pObject->GetClassName() && 
            !wbem_wcsicmp(pClassName, pObject->GetClassName()))
        {
            RecursiveSetAmended(pObject);
        }
	}

}

//***************************************************************************
//
//  CMofData::Split
//
//  DESCRIPTION:
//
//  Creates a neutral and locale specific mof.
//
//  Parameters:
//  pwszBMOF        See the GetFileNames() comments
//  pInfo           usual error info
//  bUnicode        if true, then the orignal file was unicode and so the
//                  new files will also be unicode
//  bAutoRecovery   Need to add this pragma if true
//  pwszAmendment   See the GetLocale() comments
//
//***************************************************************************

HRESULT CMofData::Split(CMofParser & Parser, LPWSTR pwszBMOF, WBEM_COMPILE_STATUS_INFO *pInfo, BOOL bUnicode, 
                          BOOL bAutoRecovery, LPWSTR pwszAmendment)
{
    int i;
    TCHAR cNeutral[MAX_PATH];
    TCHAR cLocale[MAX_PATH];
    
    // Determine the file names and locale

    HRESULT hRes = GetFileNames(cNeutral, cLocale, pwszBMOF);
    if(hRes != S_OK)
        return S_OK;

    long lLocale;
    hRes = GetLocale(&lLocale, pwszAmendment);
    if(hRes != S_OK)
        return S_OK;

    // Create the output objects

	COutput Neutral(cNeutral, NEUTRAL, bUnicode, bAutoRecovery, lLocale);
	COutput Local(cLocale, LOCALIZED, bUnicode, bAutoRecovery, lLocale);
	if(!Neutral.IsOK() || !Local.IsOK())
		return WBEM_E_INVALID_PARAMETER;

    // Start by determining what is amended

	for(i = 0; i< m_aObjects.GetSize(); i++)
	{
	    CMObject* pObject = (CMObject*)m_aObjects[i];
        pObject->Reflate(Parser);
		if(pObject->CheckIfAmended())
        {
            RecursiveSetAmended(pObject);
        }
	}


    // Create the neutral output and the localized output.
    // These two loops could have been combined, but are
    // separate for debugging purposes

	for(i = 0; i< m_aObjects.GetSize(); i++)
	{
	    CMObject* pObject = (CMObject*)m_aObjects[i];
		pObject->Split(Neutral);
	}
	for(i = 0; i< m_aObjects.GetSize(); i++)
	{
	    CMObject* pObject = (CMObject*)m_aObjects[i];
		pObject->Split(Local);
	}

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\mofcomp_dll\mofdata.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    MOFDATA.H

Abstract:

	Defines MOF compiler classes related to complete MOF file representation
	and transfer of data into WinMgmt. Division of labor between these and
	the classes defined in MOFPROP.H/CPP is not clear-cut.

History:

	11/27/96    a-levn      Compiles.

--*/

#ifndef _MCAUX_H_
#define _MCAUX_H_

#include <windows.h>
#include <wbemidl.h>
#include <miniafx.h>

#include <mofprop.h>

//******************************************************************************
//******************************************************************************
//
//  class CNamespaceCache
//
//  Represents the cache of pointers to the various namespaces MOF compiler
//  has connection to.
//
//******************************************************************************
//
//  Constructor.
//
//  Constructs the cache given the IWbemLocator pointer to WinMgmt. This class will
//  use this pointer to connect to whatever namespace is required.
//
//  PARAMETERS:
//
//      ADDREF IWbemLocator* pLocator    Locator pointer. This function AddRefs
//                                      it. It is Released in destructor.
//
//******************************************************************************
//
//  Destructor
//
//  Releases the locator pointer we were given in the constructor.
//  Releases all cached namespace pointers.
//
//******************************************************************************
//
//  GetNamespace
//
//  Retrieves a pointer to a given namespace. If in cache, the cached copy is
//  returned. If not, a new connection is established and cached.
//
//  PARAMETERS:
//
//      COPY LPCWSTR wszName    Full name of the namespace to connect to.
//
//  RETURN VALUES:
//
//      IWbemServices*:  NULL if an error occurs. If not NULL, the caller must
//                      release this pointer when no longer necessary.
//
//******************************************************************************

class CNamespaceCache
{
private:
    IWbemLocator* m_pLocator;

    struct CNamespaceRecord
    {
        LPWSTR m_wszName;
        IWbemServices* m_pNamespace;

        CNamespaceRecord(COPY LPCWSTR wszName, ADDREF IWbemServices* pNamespace);
        ~CNamespaceRecord();
    };

    CPtrArray m_aRecords; // CNamespaceRecord*

public:
    CNamespaceCache(ADDREF IWbemLocator* pLocator);
    ~CNamespaceCache();
    RELEASE_ME IWbemServices* GetNamespace(COPY LPCWSTR wszName, SCODE & scRet, 
                                           WCHAR * pUserName, WCHAR * pPassword, 
                                           WCHAR * pAuthority,IWbemContext * pCtx,
                                           GUID LocatorGUID, LONG fConnectFlags);
};

//*****************************************************************************
//*****************************************************************************
//
//  class CMofData
//
//  Represents an entire MOF file, basically --- a collection of objects. See
//  CMObject in mofprop.h for details of object representation.
//
//  Capable of storing its data into WinMgmt.
//
//******************************************************************************
//
//  AddObject
//
//  Adds another object to the store.
//
//  PARAMETERS:
//
//      ACQUIRE CMObject* pObject   The object to add. The class acquires this
//                                  object and will delete it on destruction.
//
//******************************************************************************
//
//  GetNumObjects
//
//  RETURN VALUES:
//
//      int:    the number of objects in the store.
//
//******************************************************************************
//
//  GetObject
//
//  Returns the object stored at a given index
//
//  PARAMETERS:
//
//      int nIndex  The index to retrieve the object at. 
//
//  RETURN VALUES:
//
//      CMObject*:  NULL if nIndex is out of range. Otherwise, an INTERNAL 
//                  pointer which is NOT to be deleted by the caller.
//
//******************************************************************************
//
//  Store
//
//  Transfers all the data to WinMgmt.
//
//  PARAMETERS:
//
//      OLE_MODIFY IWbemLocator* pLocator   WinMgmt locator pointer to store into.
//      long lClassFlags                    WBEM_FLAG_CREATE_OR_UPATE, 
//                                          WBEM_FLAG_CREAYE_ONLY, or
//                                          WBEM_FLAG_UPDATE_ONLY to apply to 
//                                          class operations.
//      long lInstanceFlags                 Same as lClassFlags, but for 
//                                          instance operations.
//      BOOL bRollBackable                  Not implemented. Must be TRUE.
//

class CMofParser;

class CMofData : private CMofAliasCollection
{
private:
    CPtrArray m_aObjects; // CMObject*
    CPtrArray m_aQualDefaults; // CMoQualifier*
    BYTE * m_pBmofData;
    BYTE * m_pBmofToFar;
    HRESULT RollBack(int nObjects);

    INTERNAL LPCWSTR FindAliasee(READ_ONLY LPWSTR wszAlias);
    friend CMObject;
	PDBG m_pDbg;

    BOOL GotLineNumber(int nIndex);

    void PrintError(int nIndex, long lMsgNum, HRESULT hres, WBEM_COMPILE_STATUS_INFO  *pInfo);
public:
    void SetBmofBuff(BYTE * pData){m_pBmofData = pData;};
    BYTE * GetBmofBuff(){return m_pBmofData;};
    void SetBmofToFar(BYTE * pData){m_pBmofToFar = pData;};
    BYTE * GetBmofToFar(){return m_pBmofToFar;};
    BOOL CMofData::IsAliasInUse(READ_ONLY LPWSTR wszAlias);
    void AddObject(ACQUIRE CMObject* pObject) {m_aObjects.Add(pObject);}
    int GetNumObjects() {return m_aObjects.GetSize();}
    CPtrArray * GetObjArrayPtr(){return &m_aObjects;}; 

    INTERNAL CMObject* GetObject(int nIndex) 
        {return (CMObject*)m_aObjects[nIndex];}

    void SetQualifierDefault(ACQUIRE CMoQualifier* pDefault);
    HRESULT SetDefaultFlavor(MODIFY CMoQualifier& Qual, bool bTopLevel, QUALSCOPE qs, PARSESTATE ps);
    int GetNumDefaultQuals(){return m_aQualDefaults.GetSize();};
    CMoQualifier* GetDefaultQual(int nIndex){return (CMoQualifier*)m_aQualDefaults.GetAt(nIndex);}; 

	CMofData(PDBG pDbg){m_pDbg = pDbg;};
    ~CMofData()
    {
        int i;
        for(i = 0; i < m_aObjects.GetSize(); i++) 
            delete (CMObject*)m_aObjects[i];
        for(i = 0; i < m_aQualDefaults.GetSize(); i++) 
            delete (CMoQualifier*)m_aQualDefaults[i];
    }

    HRESULT Store(CMofParser & Parser, OLE_MODIFY IWbemLocator* pLocator, IWbemServices *pOverride, 
    	                    BOOL bRollBackable, WCHAR * pUserName, WCHAR * pPassword, WCHAR *pAuthority,
    	                    IWbemContext * pCtx, GUID LocatorGUID, 
    	                    WBEM_COMPILE_STATUS_INFO *pInfo, 
    	                    BOOL bClassOwnerUpdate,    	                    
    	                    BOOL bInstanceOwnerUpdate,
                           LONG fConnectFlags);

    HRESULT Split(CMofParser & Parser, LPWSTR BMOFFileName, WBEM_COMPILE_STATUS_INFO *pInfo, BOOL bUnicode, 
                    BOOL bAutoRecovery,LPWSTR pwszAmendment);
    
    void RecursiveSetAmended(CMObject * pObj);


};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\mofcomp_dll\moflex.cpp ===
/*++

Copyright (C) 1995-2001 Microsoft Corporation

Module Name:

    MOFLEX.CPP

Abstract:

	Implementation for class CMofLexer, which tokenizes MOF files.
	ANSI, DBCS and UNICODE are supported.

History:

	a-raymcc    11-Oct-95   Created.
	a-raymcc    27-Jan-96   Update for aliasing.
	a-davj       6-June-96  Added support for octal, hex and binary constants
						  and line stitching, comment concatenation, escape
						  characters and old style comments.

--*/

#include "precomp.h"
#include <bmof.h>
#include <stdio.h>
#include <errno.h>
#include <arrtempl.h>
#include "mrciclass.h"

#include "datasrc.h"
#include "moflex.h"
#include "preproc.h"
#include "trace.h"
#include "strings.h"
#include "wbemcli.h"

#define INIT_ALLOC          512
#define ADDITIONAL_ALLOC    10000
#define MAX_ALLOC           1000000
#define UUIDLEN             36

// The following is the table of tokens consisting of a 
// single character.
// =====================================================

typedef struct
{
    wchar_t cToken;
    int nSymbol;
}   SingleTok;

SingleTok SingleTokenMap[] =
{
    L'{',   TOK_OPEN_BRACE,
    L'}',   TOK_CLOSE_BRACE,
    L'[',   TOK_OPEN_BRACKET,
    L']',   TOK_CLOSE_BRACKET,
    L'(',   TOK_OPEN_PAREN,
    L')',   TOK_CLOSE_PAREN,
    L',',   TOK_COMMA,
    L'=',   TOK_EQUALS,
    L';',   TOK_SEMI,
    L'&',   TOK_AMPERSAND,
    L':',   TOK_COLON,
    L'#',   TOK_POUND,
    L'$',   TOK_DOLLAR_SIGN,
    L'+',   TOK_PLUS
};

#define NUM_SINGLE_TOKENS   (sizeof(SingleTokenMap)/sizeof(SingleTok))

// The following is the table of keywords which look like normal
// identifiers.
// =============================================================

typedef struct
{
    OLECHAR *pKeyword;
    int nToken;
}   Keyword;

static Keyword MofKeywords[] =
{
    L"class",        TOK_CLASS,
    L"instance",     TOK_INSTANCE,
    L"null",         TOK_KEYWORD_NULL,
    L"external",     TOK_EXTERNAL,
    L"as",           TOK_AS,
    L"ref",          TOK_REF,
    L"of",           TOK_OF,
//    L"object",       TOK_OBJECT,
    L"typedef",      TOK_TYPEDEF,
    L"subrange",     TOK_SUBRANGE,
    L"pragma",      TOK_PRAGMA,
    L"define",      TOK_DEFINE,
    L"ifdef",       TOK_IFDEF,
    L"include",     TOK_INCLUDE,
    L"endif",       TOK_ENDIF,
    L"ifndef",      TOK_IFNDEF,
    L"enum",         TOK_ENUM,
    L"AUTORECOVER",  TOK_AUTORECOVER,
    L"true",         TOK_TRUE,
    L"false",        TOK_FALSE,
    L"interface",    TOK_INTERFACE,
	L"ToInstance",	 TOK_TOINSTANCE,
	L"ToSubClass", TOK_TOSUBCLASS,
	L"EnableOverride",  TOK_ENABLEOVERRIDE,
	L"DisableOverride", TOK_DISABLEOVERRIDE,
	L"NotToInstance",	 TOK_NOTTOINSTANCE,
	L"Amended", TOK_AMENDED,
	L"NotToSubClass", TOK_NOTTOSUBCLASS,
	L"Restricted", TOK_RESTRICTED,
	L"qualifier", TOK_QUALIFIER,
    L"ClassFlags", TOK_CLASSFLAGS,
    L"InstanceFlags", TOK_INSTANCEFLAGS,
    L"Amendment", TOK_AMENDMENT,
    L"void", TOK_VOID,
    L"deleteclass", TOK_DELETECLASS,
    L"FAIL", TOK_FAIL,
    L"NOFAIL", TOK_NOFAIL
};

#define NUM_KEYWORDS  (sizeof(MofKeywords)/sizeof(Keyword))
BOOL iswodigit(wchar_t wcTest);

//***************************************************************************
//
//  SingleCharToken()
//
//  This examines a single character of input and scans the table to
//  determine if it is one of the single-character tokens.
//
//  Parameters:
//      c = The character being tested.
//  Return value:
//      Zero if no match, otherwise the TOK_ constant which identifies      
//      the token.
// 
//***************************************************************************

static int SingleCharToken(wchar_t c)
{
    for (int i = 0; i < NUM_SINGLE_TOKENS; i++)
        if (SingleTokenMap[i].cToken == c)
            return SingleTokenMap[i].nSymbol;

    return 0;
}

//***************************************************************************
//
//  BOOL iswwbemalpha
//
//  Used to test if a wide character is suitable for identifiers.
//
//  Parameters:
//      c = The character being tested.
//  Return value:
//      TRUE if OK.
// 
//***************************************************************************
BOOL iswwbemalpha(wchar_t c)
{
    if(c == 0x5f || (0x41 <= c && c <= 0x5a) ||
       (0x61  <= c && c <= 0x7a) || (0x80  <= c && c <= 0xfffd))
        return TRUE;
    else
        return FALSE;
}

//***************************************************************************
//
//  KeywordFilter()
//
//  This function examines an identifier string to determine if it is
//  in fact a keyword.
//
//  Parameters:
//      pTokStr = a pointer to the string to be examined.
//
//  Return value:
//      TOK_SIMPLE_IDENT if no match and no '_', or else the correct TOK_ value
//      for the keyword.
//
//***************************************************************************

static int KeywordFilter(wchar_t *pTokStr)
{
    for (int i = 0; i < NUM_KEYWORDS; i++)
        if (wbem_wcsicmp(MofKeywords[i].pKeyword, pTokStr) == 0)
            return MofKeywords[i].nToken;

    wchar_t * pEnd;
    pEnd = pTokStr + wcslen(pTokStr) -1;

    if(*pTokStr != L'_' && *pEnd != L'_')
        return TOK_SIMPLE_IDENT;
    else
        return TOK_SYSTEM_IDENT;
}

//***************************************************************************
//
//  ValidGuid()
//
//  Examines a character string to determine if it constitutes a valid
//  GUID.
//
//  Return value:
//      TRUE if the string is a GUID, FALSE if not.
//
//***************************************************************************

BOOL CMofLexer::ValidGuid()
{
    int i;
    int iSoFar = 0;

#define HEXCHECK(n)                 \
    for (i = 0; i < n; i++)         \
        if (!iswxdigit(GetChar(iSoFar++)))   \
            return FALSE;

#define HYPHENCHECK()     \
    if (GetChar(iSoFar++) != L'-') \
        return FALSE;

    HEXCHECK(8);
    HYPHENCHECK();
    HEXCHECK(4);
    HYPHENCHECK();
    HEXCHECK(4);
    HYPHENCHECK();
    HEXCHECK(4);
    HYPHENCHECK();
    HEXCHECK(12);

    return TRUE;
}

//***************************************************************************
//
//  CMofLexer::Init()
//
//  Helper for first state of construction; inializing variables.
//
//***************************************************************************

void CMofLexer::Init()
{
    m_nLine = 1; 
	m_nStartOfLinePos = 0;
    m_bBMOF = false;
    m_wFile[0] = 0;
    m_nWorkBufSize = INIT_ALLOC;
    m_pWorkBuf = new wchar_t[m_nWorkBufSize];
	m_pDataSrc = NULL;
    m_pBuff = NULL;                             // set in the constructors
	m_pToFar = NULL;
    m_nErrorCode = (m_pWorkBuf) ? no_error : memory_failure ;
}

//***************************************************************************
//
//  CMofLexer::BuildBuffer()
//
//  Helper for last stage of construction; build the unicode buffer.  Note 
//  that this can be used by either the file or memory based constructor.
//
//***************************************************************************

void CMofLexer::BuildBuffer(long lSize, TCHAR * pFileName, char *  pMemSrc, char * pMemToFar)
{
    if(m_nErrorCode != no_error)
        return;                     // already failed!

	if(pFileName)
#ifdef USE_MMF_APPROACH	    
		m_pDataSrc = new FileDataSrc1(pFileName);
#else
		m_pDataSrc = new FileDataSrc(pFileName);
#endif
	else
		m_pDataSrc = new BufferDataSrc(lSize, pMemSrc);

	if(m_pDataSrc == NULL)
        m_nErrorCode = memory_failure;
	else if(m_pDataSrc->GetStatus() != 0)
        m_nErrorCode = file_io_error;
        return;
}


//***************************************************************************
//
//  Constructor for in-memory parsing.
//
//***************************************************************************

CMofLexer::CMofLexer(PDBG pDbg)
{
	m_bUnicode = false;
	m_pDbg = pDbg;
    Init();
}

HRESULT CMofLexer::SetBuffer(char *pMemory, DWORD dwMemSize)
{

    DWORD dwCompressedSize, dwExpandedSize;

    if(IsBMOFBuffer((BYTE *)pMemory, dwCompressedSize, dwExpandedSize))
    {
        bool bRet = CreateBufferFromBMOF((BYTE *)pMemory + 16, dwCompressedSize, dwExpandedSize);
        if(bRet == false)
            m_nErrorCode = invalid_source_buffer;
    }
    else
    {

    	m_bUnicode = false;
        BuildBuffer(dwMemSize+4, NULL, pMemory, pMemory+dwMemSize);
    }

    if(m_nErrorCode == no_error)
        return S_OK;
    else
        return WBEM_E_FAILED;
}

//***************************************************************************
//
//  Checks if the file contains a binarary mof and if it does, decompresses 
//  the binary data.
//
//***************************************************************************

bool CMofLexer::ProcessBMOFFile(FILE *fp,TCHAR * szFilename)
{

    // read the first 20 bytes

    BYTE Test[TEST_SIZE];
    int iRet = fread(Test, 1, TEST_SIZE, fp);
    if(iRet != TEST_SIZE)
    {
        // if we cant read even the header, it must not be a BMOF
        return false;
    }

    DWORD dwCompressedSize, dwExpandedSize;

    // Test if the mof is binary

    if(!IsBMOFBuffer(Test, dwCompressedSize, dwExpandedSize))
    {
        // not a binary mof.  This is the typical case
        return false;
    }

    // get the compression type, and the sizes

    if( 0 != fseek(fp, 0, SEEK_SET)) return false;

    DWORD dwSig, dwCompType;
    iRet = fread(&dwSig, sizeof(DWORD), 1, fp);
    iRet = fread(&dwCompType, sizeof(DWORD), 1, fp);
    iRet = fread(&dwCompressedSize, sizeof(DWORD), 1, fp);
    iRet = fread(&dwExpandedSize, sizeof(DWORD), 1, fp);

    // Make sure the compression type is one we understand!

    if(dwCompType != 0 && dwCompType != 1)
    {
        return FALSE;
    }


    m_pDataSrc = new BMOFDataSrc(szFilename);
    if (NULL == m_pDataSrc) return false;

    // If there was no compression, just read the data

    if(dwCompType == 0)
    {
        m_pBuff = (WCHAR *)new BYTE[dwExpandedSize];
        if(m_pBuff == NULL)
        {
            return false;
        }
        iRet = fread(m_pBuff, dwExpandedSize, 1, fp);
        m_bBMOF = true;
		m_pToFar = (BYTE *)m_pBuff + dwExpandedSize;
        return true;
    }

    // Allocate storage for the compressed data

    BYTE * pCompressed = new BYTE[dwCompressedSize];
    if(pCompressed == NULL)
    {
        return false;
    }

    // Read the compressed data.

    iRet = fread(pCompressed, 1, dwCompressedSize,fp);
    if((DWORD)iRet != dwCompressedSize)
    {
        delete pCompressed;
        return false;
    }

    // Convert from compress into something we can use later

    bool bRet = CreateBufferFromBMOF(pCompressed, dwCompressedSize, dwExpandedSize);
    delete pCompressed;
    return bRet;
}



//***************************************************************************
//
//  Creates the working buffer from a compressed binary mof buffer.
//
//***************************************************************************

bool CMofLexer::CreateBufferFromBMOF(byte * pCompressed, DWORD dwCompressedSize, DWORD dwExpandedSize)
{
    if(m_pBuff)
        delete m_pBuff;

    m_pBuff = (WCHAR *)new BYTE[dwExpandedSize];
    if(m_pBuff == NULL)
    {
        return false;
    }
	m_pToFar = (BYTE *)m_pBuff + dwExpandedSize;

	// Decompress the data

    CMRCICompression * pCompress = new CMRCICompression;
    if(pCompress == NULL)
        return FALSE;
    CDeleteMe<CMRCICompression> dm(pCompress);
    DWORD dwResSize = pCompress->Mrci1Decompress(pCompressed, dwCompressedSize,
        (BYTE *)m_pBuff, dwExpandedSize);
     
    bool bRet = dwResSize == dwExpandedSize;
    if(bRet)
        m_bBMOF = true;

    return bRet;

}


//***************************************************************************
//
//  Constructor for file-based parsing.
//
//***************************************************************************

CMofLexer::CMofLexer(const TCHAR *pFilePath, PDBG pDbg)
{
	m_bUnicode = FALSE;
	m_pDbg = pDbg;
    Init();
    FILE *fp;
    BOOL bBigEndian = FALSE;

    if(pFilePath == NULL)
    {
        m_nErrorCode = file_not_found;
        return;
    }
    TCHAR szExpandedFilename[MAX_PATH+1];
	DWORD nRes = ExpandEnvironmentStrings(pFilePath,
										  szExpandedFilename,
										  FILENAME_MAX);
    if(nRes == 0)
        StringCchCopyW(szExpandedFilename, MAX_PATH+1, pFilePath);

    // Make sure the file exists and can be opened

    if(pFilePath && lstrlen(szExpandedFilename))
    {
        Trace(true, pDbg, PARSING_MSG, szExpandedFilename);
    }

#ifdef UNICODE
    fp = _wfopen(szExpandedFilename, L"rb");
#else
    fp = fopen(szExpandedFilename, "rb");
#endif

    if (!fp)
    {
        if (errno == ENOENT)
            m_nErrorCode = file_not_found;
        if (errno == EACCES)
            m_nErrorCode = access_denied;
        else
            m_nErrorCode = file_io_error;
        return;
    }
    else
    {   

        CfcloseMe cm(fp);

        // If the file contains a binary mof, handle it here

        if(ProcessBMOFFile(fp,szExpandedFilename))
        {
            return;
        }
    }

    // Create a temp file name

    TCHAR cTempFileName[MAX_PATH+1];
    TCHAR cTempPath[MAX_PATH+1];
    if( 0 == GetTempPath(MAX_PATH+1, cTempPath))
    {
        m_nErrorCode = problem_creating_temp_file;
        return ;
    }
    if( 0 == GetTempFileName(cTempPath, TEXT("tmp"), 0, cTempFileName))
    {
        m_nErrorCode = problem_creating_temp_file;
        return ;
    }

    // Create the temp file

    FILE *fpTemp;
#ifdef UNICODE
    fpTemp = _wfopen(cTempFileName, L"wb+");
#else
    fpTemp = fopen(cTempFileName, "wb+");
#endif
    if(fpTemp == 0)
    {
        m_nErrorCode = problem_creating_temp_file;
        return;
    }
    else
    {

        CFlexArray sofar;   // used to make sure we dont get into an infinite loop

        SCODE sc = WriteFileToTemp(szExpandedFilename, fpTemp, sofar, pDbg, this);
		fclose(fpTemp);
        for(int iCnt = 0; iCnt < sofar.Size(); iCnt++)
        {
            char * pTemp = (char * )sofar.GetAt(iCnt);
            delete pTemp;
        }

        if(sc != S_OK)
        {
			if(m_nErrorCode == no_error)
				m_nErrorCode = preprocessor_error;
		    DeleteFile(cTempFileName);
            return;
        }
    
            // Determine the size of the file
        // ==============================
    
        fseek(fpTemp, 0, SEEK_END);
        long lSize = ftell(fpTemp) + 6; // add a bit extra for ending space and null NULL
        fseek(fpTemp, 0, SEEK_SET);

        // The temp file will be little endian unicode

        lSize /= 2;
        m_bUnicode = TRUE;
        bBigEndian = FALSE;

		// This will create a DataSrc object which will clean up the temp file
        BuildBuffer(lSize,cTempFileName ,NULL,NULL);
    }   
    


}

//***************************************************************************
//
//  Destructor.
//
//***************************************************************************

CMofLexer::~CMofLexer()
{
    if (m_pBuff)
        delete m_pBuff;
    if (m_pWorkBuf)
        delete m_pWorkBuf;
	delete m_pDataSrc;
}


//***************************************************************************
//
//  iswodigit
//
//  Returns TRUE if it is a valid octal character.  '0' to '7'.
//
//***************************************************************************

BOOL iswodigit(wchar_t wcTest)
{
    if(wbem_iswdigit(wcTest) && wcTest != L'8' && wcTest != L'9')
        return TRUE;
    else
        return FALSE;
}

//***************************************************************************
//
//  CMofLexer::OctalConvert
//
//  Converts an octal escape sequence into a character and returns the number
//  of digits converted.  Only a max of 3 digits is converted and if it isnt
//  a wchar, the digits cant add up to more that 0377
//
//***************************************************************************

int CMofLexer::OctalConvert(wchar_t *pResult, LexState lsCurr)
{
    int iNum = 0; 
    wchar_t wcTest;
    *pResult = 0;
    for(wcTest = GetChar(iNum+1); iswodigit(wcTest) && iNum < 3;
                    iNum++, wcTest = GetChar(iNum+1)) 
    {
        *pResult *= 8;
        *pResult += wcTest - L'0';
    }
    if((lsCurr == wstring || lsCurr == wcharacter) && *pResult >0xff)
        m_bBadString = TRUE;
    return iNum;
}

//***************************************************************************
//
//  CMofLexer::HexConvert
//
//  Converts a hex escape sequence into a character and returns the number
//  of digits converted.
//
//***************************************************************************

int CMofLexer::HexConvert(wchar_t *pResult, LexState lsCurr)
{
    int iNum = 0; 
    wchar_t wcTest;
    *pResult = 0;
    int iMax = (lsCurr == wstring||lsCurr == wcharacter) ? 4 : 2;
    for(wcTest = GetChar(iNum+2); iswxdigit(wcTest) && iNum < iMax;
                    iNum++, wcTest = GetChar(iNum+2)) 
    {
        *pResult *= 16;     
        if(wbem_iswdigit(wcTest))          // sscanf(xx,"%1x",int) also works!
            *pResult += wcTest - L'0';
        else
            *pResult += towupper(wcTest) - L'A' + 10;
    }
    if(iNum == 0)
        return -1;      // error, nothing was converted!
    return iNum+1;      // num converted plus the 'x' char!
}

//***************************************************************************
//
//  CMofLexer::ConvertEsc
//
//  Processes escape characters.  Returns size of sequence, a -1 indicates an 
//  error.  Also, the *pResult is set upon success.
//
//***************************************************************************

int CMofLexer::ConvertEsc(wchar_t * pResult, LexState lsCurr)
{
    // like C, case sensitive

    switch(GetChar(1)) {
        case L'n':
            *pResult = 0xa;
            break;
        case L't':
            *pResult = 0x9;
            break;
        case L'v':
            *pResult = 0xb;
            break;
        case L'b':
            *pResult = 0x8;
            break;
        case L'r':
            *pResult = 0xd;
            break;
        case L'f':
            *pResult = 0xc;
            break;
        case L'a':
            *pResult = 0x7;
            break;
        case L'\\':
            *pResult = L'\\';
            break;
        case L'?':
            *pResult = L'?';
            break;
        case L'\'':
            *pResult = L'\'';
            break;
        case L'\"':
            *pResult = L'\"';
            break;
        case L'x': 
            return HexConvert(pResult,lsCurr);
            break;
        default:
            if(iswodigit(GetChar(1)))
                return OctalConvert(pResult,lsCurr);
            return -1;  // error!
            break;
        }
    return 1;    
}

//***************************************************************************
//
//  ProcessStr
//
//  Processes new characters once we are in the string state.
// 
//  Return "stop" if end of string.
//
//***************************************************************************

LexState CMofLexer::ProcessStr(wchar_t * pNewChar, LexState lsCurr, int * piRet)
{


    // Check for end of string if we are a wstring state

    if (GetChar() == L'"' && lsCurr == wstring)
    {
        // search for the next non white space character.  If it is another
        // string then these strings need to be combined.

        int iCnt = 1;
        int iMinMove = 0;
        wchar_t wcTest;
        for(wcTest = GetChar(iCnt); wcTest != NULL; iCnt++, wcTest=GetChar(iCnt))
        {   
            if(m_pDataSrc->WouldBePastEnd(iCnt))
            {
				// dont go past eof!!

                *piRet = (m_bBadString) ? TOK_ERROR : TOK_LPWSTR;
                return stop;        // last string in the file
				
            }
            if(wcTest == L'"' && GetChar(iCnt+1) == L'"')
            {
                iCnt++;
                iMinMove = iCnt;
                continue;
            }
            if(!iswspace(wcTest))
                break;
        }
        // a-levn: no ascii strings are supported. "abc" means unicode.

        if(lsCurr == wstring)
        {            
            if(wcTest == L'/')
            {
                // might be an intervening comment
                // ===============================
                if (GetChar(iCnt+1) == L'/') 
                {
                    m_bInString = TRUE;
                    MovePtr(iCnt+1);
                    return new_style_comment;
                }
                else if (GetChar(iCnt+1) == L'*') 
                {
                    m_bInString = TRUE;
                    MovePtr(iCnt+1);             // skip an extra so not to be fooled by 
                    return old_style_comment;
                }
            }
            if(wcTest != L'"')
			{
                *piRet = (m_bBadString) ? TOK_ERROR : TOK_LPWSTR;
                MovePtr(iMinMove); // skip over '"'
                return stop;        // normal way for string to end
            }
            else
                MovePtr(iCnt + 1); // skip over '"'
        }
    }

    // If we are in character state, check for end

    if (GetChar(0) == L'\'' && lsCurr == wcharacter)
    {

        if(m_bBadString || m_pDataSrc->PastEnd() || 
            (m_pDataSrc->GetAt(-1) == L'\'') && m_pDataSrc->GetAt(-2) != L'\\')
            *piRet = TOK_ERROR;
        else
            *piRet = TOK_WCHAR;
        return stop;
    }

    // Not at end, get the character, possibly converting escape sequences

    if(GetChar(0) == L'\\')
    {
        int iSize = ConvertEsc(pNewChar,lsCurr);
		m_i8 = *pNewChar;
        if(iSize < 1)
            m_bBadString = TRUE;
        else
        {
            MovePtr(iSize);
            if(lsCurr == wcharacter && GetChar(1) != L'\'')
            {
                *piRet = TOK_ERROR;
                return stop;
            }

        }
    }
    else if(GetChar(0) == '\n')
    {
        m_bBadString = TRUE;
        MovePtr(-1);
        return stop;
    }
    else
    {
        *pNewChar = GetChar(0);
		m_i8 = *pNewChar;
        if(*pNewChar == 0 || *pNewChar > 0xfffeu || (GetChar(1) != L'\'' && lsCurr == wcharacter))
        {
            *piRet = TOK_ERROR;
            return stop;
        }
    }
    return lsCurr;
}

//***************************************************************************
//
//  BinaryToInt
//
//  Converts a character representation of a binary, such as "101b" into
//  an integer.  
//
//***************************************************************************

BOOL BinaryToInt(wchar_t * pConvert, __int64& i64Res)
{
    BOOL bNeg = FALSE;
    __int64 iRet = 0;
    WCHAR * pStart;
    if(*pConvert == L'-' || *pConvert == L'+')
    {
        if(*pConvert == L'-')
            bNeg = TRUE;
        pConvert++;
    }
    for(pStart = pConvert;*pConvert && (*pConvert == L'0' || *pConvert == L'1'); pConvert++)
    {
        if(pConvert - pStart > 63)
            return FALSE;               // Its too long
        iRet *= 2;
        if(*pConvert == L'1')
            iRet += 1;
    }

	if(towupper(*pConvert) != L'B')
		return FALSE;

    if(bNeg)
        iRet = -iRet;

    i64Res = iRet;
	return TRUE;
}

BOOL GetInt(WCHAR *pData, WCHAR * pFormat, __int64 * p64)
{
    static WCHAR wTemp[100];
    if(swscanf(pData, pFormat, p64) != 1)
        return FALSE;

    // Make sure the data is ok.  When comparing, make sure that leading 0's are skipped

    StringCchPrintfW(wTemp, 100, pFormat, *p64);
    WCHAR * pTemp;
    for(pTemp = pData; *pTemp == L'0' && pTemp[1]; pTemp++);
    if(wbem_wcsicmp(wTemp, pTemp))
        return FALSE;
    return TRUE;
}

//***************************************************************************
//
//  CMofLexer::iGetNumericType()
//
//  Return value:
//      What type of numeric constant the current pointer is pointing to.
//
//***************************************************************************

int CMofLexer::iGetNumericType(void)
{

#define isuorl(x) (towupper(x) == L'U' || towupper(x) == L'L')

    wchar_t * pTemp;
    BOOL bBinary = FALSE;
    wchar_t * pStart;   // first charcter not including leading - or +
    int iNumBinaryDigit = 0;
    int iNumDigit = 0;
    int iNumOctalDigit = 0;
    int iNumDot = 0;
    int iNumE = 0;

    wchar_t * pEnd = m_pWorkBuf + wcslen(m_pWorkBuf) - 1;

    if(*m_pWorkBuf == L'-' || *m_pWorkBuf == L'+')
        pStart = m_pWorkBuf+1;
    else 
        pStart = m_pWorkBuf;
    int iLen = wcslen(pStart);      // length not including leading '-' or '+'


    BOOL bHex = (pStart[0] == L'0' && towupper(pStart[1]) == L'X');

    // loop through and count the number of various digit types, decimal points, etc.
    // ==============================================================================

    for(pTemp = pStart; *pTemp; pTemp++)
    {
        // Check for 'U' or 'l' characters at the end.  They are an error
        // if the number is a float, or not in the last two characters, or
        // if a 'u' is present along with a '-' in the first character
        // ===============================================================

        if (isuorl(*pTemp))
        { 
            if(pTemp < pEnd -1 || !isuorl(*pEnd) || iNumDot || iNumE)
                return TOK_ERROR;
            if(towupper(*pTemp) == L'U' && *m_pWorkBuf == L'-')
                return TOK_ERROR;
            iLen--;
            continue;
        } 
           
        // If we previously hit the binary indicator, the only thing that 
        // should be after the b is U or L characters.
        // ==============================================================

        if(bBinary)
            return TOK_ERROR;

        // If in hex mode, only allow for x in second digit and hex numbers.
        // anything else is an error.
        // =================================================================

        if(bHex)
        {
            if(pTemp < pStart+2)        // ignore the 0X
                continue;
            if(!iswxdigit(*pTemp))
                return TOK_ERROR;
            iNumDigit++;
            continue;
        }        

        // Number is either a non hex integer or a float.
        // Do a count of various special digit types, decimal points, etc.
        // ===============================================================

        if(*pTemp == L'0' || *pTemp == L'1')
            iNumBinaryDigit++;
        if(iswodigit(*pTemp))
            iNumOctalDigit++;

        // each character should fall into one of the following catagories

        if(wbem_iswdigit(*pTemp))
            iNumDigit++;
        else if(*pTemp == L'.')
        {
            iNumDot++;
            if(iNumDot > 1 || iNumE > 0)
                return TOK_ERROR;
        }
        else if(towupper(*pTemp) == L'E') 
        {
            if(iNumDigit == 0 || iNumE > 0)
                return TOK_ERROR;
            iNumDigit=0;            // to ensure at least one digit after the 'e'
            iNumE++;
        }
        else if(*pTemp == L'-' || *pTemp == L'+')  // ok if after 'E'
        {
            if(pTemp > pStart && towupper(pTemp[-1]) == L'E')
                continue;
            else
                return TOK_ERROR; 
        }
        else if (towupper(*pTemp) == L'B')
            bBinary = TRUE;
        else 
            return TOK_ERROR;
    }

    // Make sure there are enough digits
    // =================================

    if(iNumDigit < 1)
        return TOK_ERROR;

    // take care of integer case.
    // ==========================

    if(bHex || bBinary || iNumDigit == iLen)
    {
        __int64 i8 = 0;
        if(bHex)
        {
            if(!GetInt(m_pWorkBuf+2, L"%I64x", &i8))
                return TOK_ERROR;
        }
        else if(bBinary)
		{
            if(!BinaryToInt(m_pWorkBuf, i8))
				return TOK_ERROR;
		}
    
        
        else if(pStart[0] != L'0' || wcslen(pStart) == 1)
        {
            if(*m_pWorkBuf == '-')
            {
                if(!GetInt(m_pWorkBuf, L"%I64i", &i8))
                    return TOK_ERROR;
            }
            else
            {
                if(!GetInt(m_pWorkBuf, L"%I64u", &i8))
                    return TOK_ERROR;
            }
        }
        else if(iNumDigit == iNumOctalDigit)
        {
            if(!GetInt(m_pWorkBuf+1, L"%I64o", &i8))
                return TOK_ERROR;
        }
        else return TOK_ERROR;

        // Make sure the number isnt too large
        // ===================================

        m_i8 = i8;
        if(*m_pWorkBuf == L'-')
            return TOK_SIGNED64_NUMERIC_CONST; 
		else
            return TOK_UNSIGNED64_NUMERIC_CONST;
    }

    // must be a floating point, no conversion needed.

    return TOK_FLOAT_VALUE;
}

//***************************************************************************
//
//  CMofLexer::MovePtr
//
//  Moves pointer farther into the buffer.  Note that the farthest it will go 
//  is one past the last valid WCHAR which is the location of an extra NULL
//
//***************************************************************************

void CMofLexer::MovePtr(int iNum)
{
    int iSoFar = 0;
    int iChange = (iNum > 0) ? 1 : -1;
    int iNumToDo = (iNum > 0) ? iNum : -iNum;

    while(iSoFar < iNumToDo) 
    {

		if(iChange == 1)
		{

			// going forward, update the pointer and make sure it 
			// is still in an acceptable range.
			// ==================================================
			m_pDataSrc->Move(iChange);
			if(m_pDataSrc->PastEnd())     // points to the NULL
				return;


			// If going forward and a slash cr is hit, do an extra skip.

            WCHAR wCurr = m_pDataSrc->GetAt(0);
			if(wCurr == L'\\' && m_pDataSrc->GetAt(1) == L'\n')
			{
				m_nLine++;
				m_pDataSrc->Move(1);     // extra increment
				m_nStartOfLinePos = m_pDataSrc->GetPos();
				continue;
			}
			else if(wCurr == L'\\' && m_pDataSrc->GetAt(1) == L'\r' 
                                   && m_pDataSrc->GetAt(2) == L'\n')
			{
				m_nLine++;
				m_pDataSrc->Move(2);     // extra increment
				m_nStartOfLinePos = m_pDataSrc->GetPos();
				continue;
			}
			else if (wCurr == L'\n')
			{
				m_nLine++;
				m_nStartOfLinePos = m_pDataSrc->GetPos();
			}
		}
		else
		{

			// If going backward and a cr is left, then decrement the line

			if (m_pDataSrc->GetAt(0) == L'\n' && 
				m_pDataSrc->GetPos() > 0 )
			{
					m_nLine--;
					m_nStartOfLinePos = m_pDataSrc->GetPos();
			}
		
			// Update the pointer and make sure it is still in an 
			// acceptable range.
			// ==================================================
			m_pDataSrc->Move(iChange);
			if(m_pDataSrc->GetPos() < 0)
			{
				m_pDataSrc->MoveToStart();
				return;
			}

			// If going backward and a slash cr is hit, do an extra skip.

            WCHAR wCurr = m_pDataSrc->GetAt(0);
			if( wCurr == L'\n' && m_pDataSrc->GetAt(-1) == L'\\')
			{
				m_nLine--;
				m_nStartOfLinePos = m_pDataSrc->GetPos();
				m_pDataSrc->Move(-1);     // extra decrement
				continue;
			}
            else if( wCurr == L'\n' && m_pDataSrc->GetAt(-1) == L'\r' &&
                                       m_pDataSrc->GetAt(-2) == L'\\')
			{
				m_nLine--;
				m_nStartOfLinePos = m_pDataSrc->GetPos();
				m_pDataSrc->Move(-2);     // extra decrement
				continue;
			}

		}

        iSoFar++;
    }
}

//***************************************************************************
//
//  CMofLexer::GetChar()
//
//  Returns a character at an offset from the current character pointer.
//
//***************************************************************************

wchar_t CMofLexer::GetChar(int iNum)
{
    if(iNum == 0)
        return m_pDataSrc->GetAt(0);
	else if(iNum == 1)
	{
		wchar_t tRet = m_pDataSrc->GetAt(1);
		if(tRet != L'\\' && tRet != '\n')
			return tRet;
	}  
    MovePtr(iNum);
    wchar_t wcRet = m_pDataSrc->GetAt(0);
    MovePtr(-iNum);
    return wcRet;
}

//***************************************************************************
//
//  CMofLexer::iGetColumn()
//
//  Gets the current column value.  Counts back to the previous Cr or the 
//  start of buffer.
//
//***************************************************************************

int CMofLexer::iGetColumn()
{
	return  m_pDataSrc->GetPos() - m_nStartOfLinePos;
}

//***************************************************************************
//
//  CMofLexer::bOKNumericAddition()
//
//  Returns true if the test character could be added to numeric buffer.
//  Note that it returns true if an alphanumeric, or a + or - and the last
//  character in the working buffer is an 'E'
//
//***************************************************************************

BOOL CMofLexer::bOKNumericAddition(wchar_t cTest)
{
    if(wbem_iswalnum(cTest) || cTest == L'.')
        return TRUE;
    int iLen = wcslen(m_pWorkBuf);
    if(iLen > 0)
        if(towupper(m_pWorkBuf[iLen-1]) == L'E' &&
            (cTest == L'+' || cTest == L'-') &&
            towupper(m_pWorkBuf[1]) != L'X')
                return TRUE;
    return FALSE;
}

//***************************************************************************
//
//  CMofLexer::SpaceAvailable()
//
//  Returns TRUE if there is enuough space in the working buffer to add.
//  another character.  It will expand the buffer if need be.
//
//***************************************************************************

BOOL CMofLexer::SpaceAvailable()
{
    // most common case is that there is already space available

    int iNumWChar = m_pEndOfText-m_pWorkBuf+1;
    if(iNumWChar < m_nWorkBufSize)
        return TRUE;

    if(m_nWorkBufSize > MAX_ALLOC)     // programs need limits!
        return FALSE;

    // Allocate a bigger buffer and copy the old stuff into it
    // =======================================================

    long nNewSize = m_nWorkBufSize + ADDITIONAL_ALLOC;
    wchar_t * pNew = new wchar_t[nNewSize];
    if(pNew == FALSE)
        return FALSE;
    memcpy(pNew, m_pWorkBuf, m_nWorkBufSize*2);
    delete m_pWorkBuf;
    m_nWorkBufSize = nNewSize;
    m_pWorkBuf = pNew;
    m_pEndOfText  = m_pWorkBuf + iNumWChar - 1;
    return TRUE;
}

//***************************************************************************
//
//  NextToken()
//
//  This function contains the DFA recognizer for MOF tokens.  It works
//  entirely in UNICODE characters, so the NextChar() function is expected
//  to pretranslate ANSI or DBCS source streams into wide characters.
//
//  Return value:
//      One of the TOK_ constants, or TOK_EOF when the end of the input
//      stream has been reached.  If the user calls PushBack(), then
//      this will return the symbol which was pushed back onto the input
//      stream.  Only one level of push back is supported.
//
//***************************************************************************
int CMofLexer::NextToken(bool bDontAllowWhitespace) 
{
    int nToken = TOK_ERROR;
    LexState eState = start;
    m_bBadString = FALSE;
    
    *m_pWorkBuf = 0;
    m_pEndOfText = m_pWorkBuf;
    m_bInString = FALSE;

#define CONSUME(c)  \
    if (!SpaceAvailable()) return TOK_ERROR;\
    *m_pEndOfText++ = (c), *m_pEndOfText = 0;

    wchar_t c;
    
    for (MovePtr(1); m_nErrorCode == no_error && !m_pDataSrc->PastEnd(); MovePtr(1))
    {
        c = GetChar();

        // *************************************************************************
        // General 'start' state entry.
        // ============================

        if (eState == start)
        {
            m_nTokCol = iGetColumn();
            m_nTokLine = m_nLine;
            // If a non-newline whitespace and we are in 'start', then just strip it.
            // =======================================================================

            if (iswspace(c) || c == L'\n')
                if(bDontAllowWhitespace)
                    return TOK_ERROR;
                else
                    continue;


            // Check for string continuation
            // =============================

            if(m_bInString)
            {
                if(c == '"')
                {
                    eState = wstring;
                    continue;
                }
                else
                {
                    // string ended after all

                    MovePtr(-1);
                    return TOK_LPWSTR;
                }
            }

            // Handle all single character tokens.
            // ===================================

            if (nToken = SingleCharToken(c))
                return nToken;

            // Start of comment, we have to get either another / or a *.  
            // The style of comment depends on what you get.  To get 
            // neither is an error
            // ======================================================

            if (c == L'/')
            {
                if (GetChar(1) == L'/') 
                {
                    eState = new_style_comment;
                    continue;
                }
                else if (GetChar(1) == L'*') 
                {
                    eState = old_style_comment;
                    MovePtr(1);             // skip an extra so not to be fooled by /*/
                    continue;
                }
                else
                    return TOK_ERROR;
            }

            // Check for strings or characters. Like C, 'L' is case sensitive
            // ================================

            if (c == L'"' || c == L'\'')
            {
                eState = (c == L'"') ? wstring : wcharacter;
                continue;
            }

            // Tokens beginning with these letters might be a uuid.   
            // ====================================================

            if (iswxdigit(c) && ValidGuid())
            {
                eState = uuid;
                CONSUME(c);
                continue;
            }

                
            // Check for identifiers which start with either a letter or _
            // ===========================================================

            if (iswwbemalpha(c) || c == L'_')
            {
                eState = ident;
                CONSUME(c);
                continue;
            }

            // Check for a leading minus sign or digits.  Either indicates
            // a numeric constant
            // ===========================================================

            if (wbem_iswdigit(c) || c == L'-') 
            {
                eState = numeric;
                CONSUME(c);
                continue;
            }

            // If the first character was a '.', then it might be a
            // float or a single byte token.
            // ====================================================

            if (c == L'.')
            {
                if (wbem_iswdigit(GetChar(1)))
                {
                    eState = numeric;
                    CONSUME(c);
                    continue;
                }
            return TOK_DOT;
            }

            // If here, an unknown token.
            // ==========================

            break;
        } // end of if (eState == start)

        // ************************************************************
        // Some state other than start


        // If we are in a quoted string or character.
        // ==========================================

        if (eState == wstring || eState == wcharacter)
        {
            wchar_t wTemp;      // might be converted esc sequence
            int iRet;
            LexState lsNew = ProcessStr(&wTemp,eState,&iRet);
            if(stop == lsNew)
            {
                return iRet;
            }
            else 
            {
                eState = lsNew;
            }

            if(eState == wstring || eState == wcharacter)
            {
                CONSUME(wTemp);
            }
            // else we stepped out of the string and into a comment.
            continue;
        }


        // numeric state, undetermined numeric constant.
        // =============================================

        if (eState == numeric)
        {
            if(bOKNumericAddition(c)) 
            {
                CONSUME(c);
                continue;
            }

            MovePtr(-1);
            return iGetNumericType();
        }


        // If we are getting an identifer, we continue
        // until a nonident char is hit.
        // ============================================

        if (eState == ident)
        {
            if (wbem_iswdigit(c) || iswwbemalpha(c) || c == L'_')
            {
                CONSUME(c);
                continue;
            }

            MovePtr(-1);
            return KeywordFilter(m_pWorkBuf);
        }

        // GUIDs are already verified, just load up the proper length
        // ==========================================================

        if (eState == uuid)
        {
            CONSUME(c);
            if(wcslen(m_pWorkBuf) >= UUIDLEN)
                return TOK_UUID;
            else
                continue;
        }

        // Take care of comment states.  New style comments "//" are 
        // terminated by a new line while old style end with "*/"
        // =========================================================

        if (eState == new_style_comment)
        {
            if (c == L'\n')
            {
                eState = start;
            }
            continue;
        }

        if (eState == old_style_comment) 
        {
            if (c == L'*')
                if(GetChar(1) == L'/') 
                {
                    MovePtr(1);
                    eState = start;
                }
            continue;
        }
        break;      // this is bad, got into strange state
    }

    // If we ended and the last thing was a string, the we are ok.  This takes care
    // of the case where the last token in a file is a string.

    if ((eState == start || eState == new_style_comment) && m_bInString)
    {
          return TOK_LPWSTR;
    }

    // return eof if we never got started, ex, bad file name

    if(m_nErrorCode != no_error)
        return 0;
    if(m_pDataSrc->PastEnd() && 
			(eState == start || eState == new_style_comment))
        return 0; 
    else
    {
        if(eState == old_style_comment)
            Trace(true, m_pDbg, UNEXPECTED_EOF, m_nTokLine);
		if(c == L'*' && GetChar(1) == L'/')
            Trace(true, m_pDbg, COMMENT_ERROR, m_nTokLine);

        return TOK_ERROR;
    }
}

//***************************************************************************
//
//  GetText
//
//***************************************************************************

const OLECHAR *CMofLexer::GetText(int *pLineDeclared)
{
    if (pLineDeclared)
        *pLineDeclared = m_nTokLine;

    return m_pWorkBuf;
}

void CMofLexer::SetLexPosition(ParseState * pPos)
{
	m_pDataSrc->MoveToPos(pPos->m_iPos); 
}

void CMofLexer::GetLexPosition(ParseState * pPos)
{
	pPos->m_iPos = m_pDataSrc->GetPos(); 
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\mofcomp_dll\mofout.h ===
/*++

Copyright (C) 1999-2001 Microsoft Corporation

Module Name:

    MOFOUT.H

Abstract:

Class and code used to output split files.

History:

	2/4/99    a-davj      Compiles.

--*/

#ifndef _MOFOUT_H_
#define _MOFOUT_H_

#include <windows.h>
#include <wbemidl.h>
#include <miniafx.h>

typedef enum {NEUTRAL, LOCALIZED} OutputType;
class COutput
{
    HANDLE m_hFile;     // file being output to
    OutputType m_Type;  // indicates neutral/localized
    BOOL m_bUnicode;    // true if unicode
    int m_Level;        // 0 indicates normal object, higher numbers
                        // indicate that current object is embedded
    long m_lClassFlags; // last class flags 
    long m_lInstanceFlags; // last instance flags
    WCHAR m_wszNamespace[MAX_PATH+1]; // last namespace
    bool m_bSplitting;      // indicates if current instance has a "locale" qual.
    long m_lLocale;
public:
    COutput(TCHAR * pName, OutputType ot, BOOL bUnicode, BOOL bAutoRecovery, long lLocale);
    ~COutput();
    void WritePragmasForAnyChanges(long lClassFlags, long lInstanceFlags, 
        LPWSTR pwsNamespace, long lLocale);
    void IncLevel(){m_Level++;};
    void DecLevel(){m_Level--;};
    int GetLevel(){return m_Level;};
    long GetLocale(){return m_lLocale;};
    bool IsSplitting(){return m_bSplitting;};
    void SetSplitting(bool bVal){m_bSplitting = bVal;};
    BOOL IsOK(){return (m_hFile != INVALID_HANDLE_VALUE);};
    OutputType GetType(){return m_Type;};
    bool WriteLPWSTR(WCHAR const * pOutput);
    bool WriteVARIANT(VARIANT & var);
    bool NewLine(int iIndent);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\mofcomp_dll\mofout.cpp ===
/*++

Copyright (C) 1999-2001 Microsoft Corporation

Module Name:

    MOFOUT.CPP

Abstract:

	Class and code used to output split files.  This is used so that a 
	single mof file can be split into a localized and non localized versions.

History:

	2/4/99    a-davj      Compiles.

--*/

#include "precomp.h"
#include <cominit.h>
#include <wbemcli.h>
#include "mofout.h"
#include <genutils.h>
#include <var.h>
#include "mofprop.h"


//***************************************************************************
//
//  COutput::COutput
//
//  DESCRIPTION:
//
//  Constructor.  This object is used to serialize output to a file
//
//***************************************************************************

COutput::COutput(TCHAR * pName, OutputType ot, BOOL bUnicode, BOOL bAutoRecovery, long lLocale) : m_lLocale(lLocale)
{
    m_bUnicode = true;
    m_Level = 0;
    m_lClassFlags = 0;
    m_lInstanceFlags = 0;
    m_bSplitting = false;
    if(ot == NEUTRAL)
        StringCchCopyW(m_wszNamespace, MAX_PATH+1, L"root\\default");
    else
        StringCchCopyW(m_wszNamespace, MAX_PATH+1, L"_?");
    m_hFile = CreateFile(pName, GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ, NULL,
        CREATE_ALWAYS, 0, NULL);
    if(bUnicode && m_hFile != INVALID_HANDLE_VALUE)
    {
        unsigned char cUnicodeHeader[2] = {0xff, 0xfe};
        DWORD dwWrite;
        WriteFile(m_hFile, cUnicodeHeader, 2, &dwWrite, NULL);
    }

    m_Type = ot;
    if(bAutoRecovery)
        WriteLPWSTR(L"#pragma autorecover\r\n");

}

//***************************************************************************
//
//  COutput::~COutput()
//
//  DESCRIPTION:
//
//  Destructor.
//
//***************************************************************************

COutput::~COutput()
{
    if(m_hFile != INVALID_HANDLE_VALUE)
        CloseHandle(m_hFile);
}

//***************************************************************************
//
//  COutput::WriteLPWSTR(WCHAR const * pOutput)
//
//  DESCRIPTION:
//
//  Writes a string to the file.  If the original file was not unicode, then
//  this converts the text back into mbs.
//
//***************************************************************************

bool COutput::WriteLPWSTR(WCHAR const * pOutput)
{

    DWORD dwLen, dwWrite;
    if(pOutput == NULL || m_hFile == INVALID_HANDLE_VALUE)
        return false;
    if(m_bUnicode)
    {
        dwLen = 2 * (wcslen(pOutput));
        WriteFile(m_hFile, pOutput, dwLen, &dwWrite, NULL);
    }
    else
    {
        int iLen = 2 * (wcslen(pOutput) + 1);
        char * pTemp = new char[iLen];
        if(pTemp == NULL)
            return false;
        wcstombs(pTemp, pOutput, iLen);
        dwLen = strlen(pTemp);
        WriteFile(m_hFile, pTemp, dwLen, &dwWrite, NULL);
        delete [] pTemp;
    }
    if(dwWrite == dwLen)
        return true;
    else
        return false;
}

//***************************************************************************
//
//  COutput::WriteVARIANT(VARIANT & varIn)
//
//  DESCRIPTION:
//
//  Serialized a variant out to the file.  This relies on the CVar class so
//  as to be compatible with GetObjectText().
//
//***************************************************************************

bool COutput::WriteVARIANT(VARIANT & varIn)
{
    CVar X(&varIn);    
    BSTR b = X.GetText(0,0);
    if(b)
    {
        WriteLPWSTR(b);
        SysFreeString(b);
        return true;
    }
    else
        return false;
}

//***************************************************************************
//
//  bool COutput::NewLine(int iIndent)
//
//  DESCRIPTION:
//
//  Starts a new line.  In addition to the cr\lf, this also indents based on
//  the argument and the level of subobject.  I.e.  if we are inside a 
//  subobject to a subobject, we would indent 10 characters.  
//
//***************************************************************************

bool COutput::NewLine(int iIndent)
{
    WriteLPWSTR(L"\r\n");
    int iExtra = iIndent + m_Level * 4;
    for (int i = 0; i < iExtra; i++)
    {
        WriteLPWSTR(L" ");
    }
    return true;
}

//***************************************************************************
//
//  COutput::WritePragmasForAnyChanges()
//
//  DESCRIPTION:
//
//  This is called at the start of each class or instance object.  If the
//  class flags, instance flags, or namespace have changed, then this outputs
//  the appropriate pragmas.  The lLocale argument is used if we are 
//  outputting to the localized file.  In that case the lLocale is added to
//  the namespace path. 
//
//***************************************************************************

void COutput::WritePragmasForAnyChanges(long lClassFlags, long lInstanceFlags, 
                                        LPWSTR pwsNamespace, long lLocale)
{
    if(m_Level > 0)
        return;         // ignore for embedded objects;

    if(lClassFlags != m_lClassFlags)
    {
        WCHAR wTemp[40];
        m_lClassFlags = lClassFlags;
        StringCchPrintfW(wTemp, 40, L"#pragma classflags(%d)\r\n", m_lClassFlags);
        WriteLPWSTR(wTemp);
    }
    if(lInstanceFlags != m_lInstanceFlags)
    {
        WCHAR wTemp[40];
        m_lInstanceFlags = lInstanceFlags;
        StringCchPrintfW(wTemp, 40, L"#pragma instanceflags(%d)\r\n", m_lInstanceFlags);
        WriteLPWSTR(wTemp);
    }
    if(wbem_wcsicmp(m_wszNamespace, pwsNamespace))
    {
        // copy the namespace into the buffer.

        wcsncpy(m_wszNamespace, pwsNamespace, MAX_PATH);
        m_wszNamespace[MAX_PATH] = 0;

        // before writting this out, each slash needs to be doubled up.  Also,
        // the path may need the machine part.

        WCHAR wTemp[MAX_PATH*2];
        WCHAR * pTo = wTemp, * pFrom = pwsNamespace;
        if(pwsNamespace[0] != L'\\')
        {
            StringCchCopyW(pTo, MAX_PATH*2, L"\\\\\\\\.\\\\");
            pTo+= 7;
        }
        while(*pFrom)
        {
            if(*pFrom == L'\\')
            {
                *pTo = L'\\';
                pTo++;
            }
            *pTo = *pFrom;
            pTo++;
            pFrom++;
        }
        *pTo = 0;
        
        WriteLPWSTR(L"#pragma namespace(\"");
        WriteLPWSTR(wTemp);
        WriteLPWSTR(L"\")\r\n");
        
        // For localized, we need to create the namespace and then to modify the pragma
        // Example, if the namespace is root, we need to write
        // #pragma ("root")
        // instance of __namespace{name="ms_409";};
        // #pragma ("root\ms_409")

        if(m_Type == LOCALIZED)
        {
            WCHAR wMSLocale[10];
            StringCchPrintfW(wMSLocale, 10, L"ms_%x", lLocale);
        
            WriteLPWSTR(L"instance of __namespace{ name=\"");
            WriteLPWSTR(wMSLocale);
            WriteLPWSTR(L"\";};\r\n");

            WriteLPWSTR(L"#pragma namespace(\"");
            WriteLPWSTR(wTemp);
            WriteLPWSTR(L"\\\\");
            WriteLPWSTR(wMSLocale);
            WriteLPWSTR(L"\")\r\n");
        }

    }
}

//***************************************************************************
//
//  CMoValue::Split(COutput &out)
//
//  DESCRIPTION:
//
//  Serialize a CMoValue.  In general, the standard converted is used, but
//  we must special case alias values.
//
//***************************************************************************

BOOL CMoValue::Split(COutput &out)
{

    int iNumAlias = GetNumAliases();
    LPWSTR wszAlias = NULL; int nArrayIndex;

    // This is the normal case of all but references!!!!

    if(iNumAlias == 0)
        return out.WriteVARIANT(m_varValue);
    
    if(m_varValue.vt == VT_BSTR)
    {
        // simple case, single alias

        out.WriteLPWSTR(L"$");
        GetAlias(0, wszAlias, nArrayIndex);
        out.WriteLPWSTR(wszAlias);
        return TRUE;
    }
    else
    {

        out.WriteLPWSTR(L"{");

        // For each string from the safe array

        SAFEARRAY* psaSrc = V_ARRAY(&m_varValue);
        if(psaSrc == NULL)
            return FALSE;
        SAFEARRAYBOUND aBounds[1];
        long lLBound;
        SCODE sc = SafeArrayGetLBound(psaSrc, 1, &lLBound);
        long lUBound;
        sc |= SafeArrayGetUBound(psaSrc, 1, &lUBound);
        if(sc != S_OK)
            return FALSE;

        aBounds[0].cElements = lUBound - lLBound + 1;
        aBounds[0].lLbound = lLBound;

        for(long lIndex = lLBound; lIndex <= lUBound; lIndex++)
        {

            // Determine if this is an alias
            
            int iTest;
            for(iTest = 0; iTest < iNumAlias; iTest++)
            {
                if(GetAlias(iTest, wszAlias, nArrayIndex))
                    if(nArrayIndex == lIndex)
                        break;
            }

            // If so, the output the alias value

            if(iTest < iNumAlias)
            {
                out.WriteLPWSTR(L"$");
                out.WriteLPWSTR(wszAlias);
            }
            else
            {
                // else output the string

                BSTR bstr;
                if(S_OK == SafeArrayGetElement(psaSrc, &lIndex, &bstr))
                {
                    out.WriteLPWSTR(L"\"");
                    out.WriteLPWSTR(bstr);
                    SysFreeString(bstr);
                    out.WriteLPWSTR(L"\"");
                }
            }
            
            // possibly output a comma

            if(lUBound != lLBound && lIndex < lUBound)
                out.WriteLPWSTR(L",");
        }
        
        out.WriteLPWSTR(L"}");
        return TRUE;
    }
}

BOOL CMoActionPragma::Split(COutput & out)
{
    // Write flags and namespace pragmas

    long lLocale = out.GetLocale();
    WCHAR * pwszNamespace = m_wszNamespace;
    out.WritePragmasForAnyChanges(m_lDefClassFlags, m_lDefInstanceFlags, pwszNamespace, lLocale);

    out.NewLine(0);
	if(m_bClass)
		out.WriteLPWSTR(L"#pragma deleteclass(");
	else
		out.WriteLPWSTR(L"#pragma deleteinstance(");

    // The class name may have embedded quotes etc.  So convert to variant and
    // output that since that logic automatically puts in the needed escapes

    VARIANT var;    
    var.vt = VT_BSTR;
    var.bstrVal = SysAllocString(m_wszClassName);
    if(var.bstrVal == NULL)
        return FALSE;
    out.WriteVARIANT(var);
    VariantClear(&var);
    
    out.WriteLPWSTR(L",");
    if(m_bFail)
        out.WriteLPWSTR(L"FAIL)");
    else
        out.WriteLPWSTR(L"NOFAIL)");
    out.NewLine(0);
    return TRUE;
}
//***************************************************************************
//
//  CMObject::Split(COutput & out)
//
//  DESCRIPTION:
//
//  Serialize a Class of instance object.
//
//***************************************************************************

BOOL CMObject::Split(COutput & out)
{

    // If this is a top level object, figure out if it has a [locale] qualifier

    long lLocale = out.GetLocale();

    if(out.GetLevel() == 0)
    {
        bool bAmended = m_bAmended;

        if(out.GetType() == LOCALIZED)
        {
            // if this is the localized output and this object doesnt
            // have the locale.

            if(!bAmended)
                return TRUE;
        }
        else
        {
            // if this is the non localized version, then the object
            // may, or may not be split apart.

            out.SetSplitting(bAmended);
        }
    }

	WCHAR * pwszNamespace = m_wszNamespace;

    // Write flags and namespace pragmas

    out.WritePragmasForAnyChanges(m_lDefClassFlags, m_lDefInstanceFlags, pwszNamespace, lLocale);

    // Write the qualifiers

    if(GetQualifiers())
    {
        CMoQualifierArray * pqual = GetQualifiers();
        pqual->Split(out, OBJECT);
    }

    // Write the instance or class declaration

    out.NewLine(0);
    if(IsInstance())
    {
        out.WriteLPWSTR(L"Instance of ");
        out.WriteLPWSTR(GetClassName());
        CMoInstance * pInst = (CMoInstance *)this;
        if(pInst->GetAlias())
        {
            out.WriteLPWSTR(L" as $");
            out.WriteLPWSTR(GetAlias());
        }
    }
    else
    {
        out.WriteLPWSTR(L"class ");
        out.WriteLPWSTR(GetClassName());
        CMoClass * pClass = (CMoClass *)this;
        if(pClass->GetAlias())
        {
            out.WriteLPWSTR(L" as $");
            out.WriteLPWSTR(GetAlias());
        }
        if(pClass->GetParentName())
        {
            out.WriteLPWSTR(L" : ");
            out.WriteLPWSTR(pClass->GetParentName());
        }
    }
    out.NewLine(0);
    out.WriteLPWSTR(L"{");

    // Output the properties and methods
    
    for(int i = 0; i < GetNumProperties(); i++)
    {
        if(!GetProperty(i)->Split(out)) return FALSE;
    }

    out.NewLine(0);

    // if this is a top level object, add the semicolon and an extra 
    if(out.GetLevel() == 0)
    {
        out.WriteLPWSTR(L"};");
        out.NewLine(0);
    }
    else
        out.WriteLPWSTR(L"}");

    return TRUE;
}

//***************************************************************************
//
//  CValueProperty::Split(COutput & out)
//
//  DESCRIPTION:
//
//  Serializes value properties
//
//***************************************************************************

BOOL CValueProperty::Split(COutput & out)
{
    // Write the qualifiers

    if(GetQualifiers())
    {
        CMoQualifierArray * pqual = GetQualifiers();
        if(out.GetType() == LOCALIZED && !pqual->HasAmended() && !m_bIsArg)
            return TRUE;
        pqual->Split(out, (m_bIsArg) ? ARG : PROP);
    }
    else
        if(out.GetType() == LOCALIZED && !m_bIsArg)
            return TRUE;

    // determine if this is an array value

    VARTYPE vt = m_Value.GetType();
    BOOL bArray = vt & VT_ARRAY;
    if(m_bIsArg && bArray == FALSE && vt == 0)
    {
        VARTYPE vtInner = m_Value.GetVarType();
        bArray = vtInner & VT_ARRAY;
    }

    // Possibly output the type, such as "sint32"

    if(m_wszTypeTitle)
    {
        out.WriteLPWSTR(m_wszTypeTitle);
        VARTYPE vt = m_Value.GetType();
        vt = vt & (~CIM_FLAG_ARRAY);
        if(vt == CIM_REFERENCE)
            out.WriteLPWSTR(L" Ref");
        out.WriteLPWSTR(L" ");
    }

    // Output the property name

    out.WriteLPWSTR(m_wszName);
    if(bArray)
        out.WriteLPWSTR(L"[]");

    // In general, the value is output via CMoValue, but the
    // glaring exception is embedded objects and arrays of 
    // embedded objects

    vt = m_Value.GetVarType();
    if(vt != VT_NULL && out.GetType() == NEUTRAL )
    {
        out.WriteLPWSTR(L" = ");
        if(vt == VT_UNKNOWN)
        {
            // got an embedded object

            VARIANT & var = m_Value.AccessVariant(); 
            CMObject * pObj = (CMObject *)var.punkVal;
            out.IncLevel();     // indicate embedding
            pObj->Split(out);
            out.DecLevel();
        }
        else if (vt == (VT_ARRAY | VT_UNKNOWN))
        {
            // got an embedded object array

            SCODE sc ;
            out.WriteLPWSTR(L"{");
            VARIANT & var = m_Value.AccessVariant(); 
            SAFEARRAY * psaSrc = var.parray;
            if(psaSrc == NULL)
                return FALSE;
            long lLBound, lUBound;
            sc = SafeArrayGetLBound(psaSrc, 1, &lLBound);
            sc |= SafeArrayGetUBound(psaSrc, 1, &lUBound);
            if(sc != S_OK)
                return FALSE; 

            for(long lIndex = lLBound; lIndex <= lUBound; lIndex++)
            {
                CMObject * pObj = NULL;

                SCODE sc = SafeArrayGetElement(psaSrc, &lIndex, &pObj);
                if(sc == S_OK && pObj)
                {
                    out.IncLevel();     // indicate embedding
                    pObj->Split(out);
                    out.DecLevel();
                }
                if(lLBound != lUBound && lIndex < lUBound)
                    out.WriteLPWSTR(L",");
            }
            out.WriteLPWSTR(L"}");
        }
        else
            m_Value.Split(out);         // !!! Typical case
    }

    // Note that property objects are used as argmuments in methods.  If this
    // is one of these, then dont output a ';'

    if(!m_bIsArg)
        out.WriteLPWSTR(L";");

    return TRUE;
}

//***************************************************************************
//
//  CMethodProperty::IsDisplayable(COutput & out)
//
//  DESCRIPTION:
//
//  Serializes methods
//
//***************************************************************************

BOOL CMethodProperty::IsDisplayable(COutput & out)
{
    // if we are neutral, then always.

    if(out.GetType() == NEUTRAL)
        return TRUE;

    // Write the qualifiers

    if(GetQualifiers())
    {
        CMoQualifierArray * pqual = GetQualifiers();
        if(pqual->HasAmended())
            return TRUE;
    }

    int iSize = m_Args.GetSize();
    for(int i = 0; i < iSize; i++)
    {
        CValueProperty * pProp = (CValueProperty *)m_Args.GetAt(i);
        if(pProp)
        {
            CMoQualifierArray * pqual = pProp->GetQualifiers();
            if(pqual->HasAmended())
                return TRUE;
        }
    }

    return FALSE;
}

//***************************************************************************
//
//  CMethodProperty::Split(COutput & out)
//
//  DESCRIPTION:
//
//  Serializes methods
//
//***************************************************************************

BOOL CMethodProperty::Split(COutput & out)
{
    if(!IsDisplayable(out))
        return TRUE;

    // Write the qualifiers

    if(GetQualifiers())
    {
        CMoQualifierArray * pqual = GetQualifiers();
        pqual->Split(out, PROP);
    }

    // Output the method's return value type and name

    if(m_wszTypeTitle)
    {
        if(wbem_wcsicmp(L"NULL", m_wszTypeTitle))
            out.WriteLPWSTR(m_wszTypeTitle);
        else
            out.WriteLPWSTR(L"void");
        out.WriteLPWSTR(L" ");
    }
    out.WriteLPWSTR(m_wszName);

    // output the arguements between the parenthesis

    out.WriteLPWSTR(L"(");
    int iSize = m_Args.GetSize();
    for(int i = 0; i < iSize; i++)
    {
        CValueProperty * pProp = (CValueProperty *)m_Args.GetAt(i);
        if(pProp)
        {
            pProp->SetAsArg();
            pProp->Split(out);
        }
        if(iSize > 0 && i < (iSize-1))
            out.WriteLPWSTR(L",");
    }

    out.WriteLPWSTR(L");");

    return TRUE;
}

//***************************************************************************
//
//  CMoQualifier::IsDisplayable(COutput & out, QualType qt)
//
//  DESCRIPTION:
//
//  Determines if a qualifier is to be written.
//
//***************************************************************************

BOOL CMoQualifier::IsDisplayable(COutput & out, QualType qt)
{

    if(!wbem_wcsicmp(L"cimtype", m_wszName))   // never!
        return FALSE;
    if(!wbem_wcsicmp(L"KEY", m_wszName))       // always!
        return TRUE;
    if(!wbem_wcsicmp(L"LOCALE", m_wszName) && qt == OBJECT)
        if(out.GetType() == LOCALIZED)
            return FALSE;
        else
            return TRUE;
    if(!wbem_wcsicmp(L"ID", m_wszName) && qt == ARG)
        return FALSE;
    if(!wbem_wcsicmp(L"IN", m_wszName) && qt == ARG)
        return TRUE;
    if(!wbem_wcsicmp(L"OUT", m_wszName) && qt == ARG)
        return TRUE;

    if(out.GetType() == LOCALIZED)
    {
        return (m_bAmended) ? TRUE : FALSE;
    }
    else
    {
        if(out.IsSplitting() == FALSE)
            return TRUE;
        if(m_bAmended == FALSE)
            return TRUE;
        return FALSE;
    }
}

//***************************************************************************
//
//  PrintSeparator(COutput & out, bool bFirst)
//
//  DESCRIPTION:
//
//  Outputs space or colon when dumping flavors.
//
//***************************************************************************

void PrintSeparator(COutput & out, bool bFirst)
{
    if(bFirst)
        out.WriteLPWSTR(L" : ");
    else
        out.WriteLPWSTR(L" ");
}

//***************************************************************************
//
//  CMoQualifier::Split(COutput & out)
//
//  DESCRIPTION:
//
//  Serializes CMoQualifiers.
//
//***************************************************************************

BOOL CMoQualifier::Split(COutput & out)
{
    
    // Always write the name

    out.WriteLPWSTR(m_wszName);
    VARIANT & var = m_Value.AccessVariant();

    // If the type is other than a true bool, dump it out

    if(var.vt != VT_BOOL || var.boolVal != VARIANT_TRUE)
    {
        VARTYPE vt = m_Value.GetVarType();
    
        // If this is an array, then the lower level dumping
        // code will enclose the values in {}
        
        if((vt & VT_ARRAY) == 0)
            out.WriteLPWSTR(L"(");
        
        m_Value.Split(out);
        
        if((vt & VT_ARRAY) == 0)
            out.WriteLPWSTR(L")");
    }

	return SplitFlavors( out );
}

//***************************************************************************
//
//  CMoQualifier::Split(COutput & out)
//
//  DESCRIPTION:
//
//  Serializes CMoQualifiers Flavors
//
//***************************************************************************

BOOL CMoQualifier::SplitFlavors(COutput & out)
{
    
    // Dump out the flavors

    bool bFirst = true;
    if(m_bAmended)
    {
        PrintSeparator(out, bFirst);
        out.WriteLPWSTR(L"Amended");
        bFirst = false;
    }
    if(m_lFlavor & WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE)
    {
        PrintSeparator(out, bFirst);
        out.WriteLPWSTR(L"ToInstance");
        bFirst = false;
    }
    if(m_lFlavor & WBEM_FLAVOR_FLAG_PROPAGATE_TO_DERIVED_CLASS)
    {
        PrintSeparator(out, bFirst);
        out.WriteLPWSTR(L"ToSubclass");
        bFirst = false;
    }
    if(m_lFlavor & WBEM_FLAVOR_NOT_OVERRIDABLE)
    {
        PrintSeparator(out, bFirst);
        out.WriteLPWSTR(L"DisableOverride");
        bFirst = false;
    }

    return TRUE;
}


//***************************************************************************
//
//  CMoQualifierArray::Split(COutput & out, QualType qt)
//
//  DESCRIPTION:
//
//  Serializes the qualifier array.
//
//***************************************************************************

BOOL CMoQualifierArray::Split(COutput & out, QualType qt)
{

    bool bTopLevelLocalizedObj = ( qt == OBJECT && out.GetType() == LOCALIZED && 
                                    out.GetLevel() == 0);

    // count the number that need to be serialized.

    int iNumOutput = 0, i;
    for(i = 0; i < GetSize(); i++)
    {

        CMoQualifier * pQual = GetAt(i);
        if(pQual && pQual->IsDisplayable(out, qt))      
            iNumOutput++;
    }

    // If this is a top level object in a localized object, then the local is foced out
    // along with the amended qualifier

    if(bTopLevelLocalizedObj)
        iNumOutput += 2;

    // If this is for anything other than an argument, then
    // dump a new line.  Note that properties get an extra
    // two characters of indent

    if(qt == PROP)
        out.NewLine(2);
    else if (qt == OBJECT && iNumOutput > 0)
        out.NewLine(0);
    if(iNumOutput == 0)     // perfectly normal
        return TRUE;

	// We'll need to out put the flavors special for this in the
	// split off file
	CMoQualifier*	pLocaleQual = NULL;

    // Serialize the individual qualifiers
    out.WriteLPWSTR(L"[");
    int iNumSoFar = 0;
    for(i = 0; i < GetSize(); i++)
    {

        CMoQualifier * pQual = GetAt(i);
        if(pQual == NULL || !pQual->IsDisplayable(out, qt))     
		{
			if ( pQual->IsLocaleQual() )
			{
				pLocaleQual = pQual;
			}
            continue;
		}
        iNumSoFar++;
        pQual->Split(out);

        if(iNumSoFar < iNumOutput)
            out.WriteLPWSTR(L",");
    }

    // If this is a top level object in a localized object, then the local is foced out
    // along with the amended qualifier

    if(bTopLevelLocalizedObj)
    {
        WCHAR Buff[50];
        StringCchPrintfW(Buff, 50, L"AMENDMENT, LOCALE(0x%03x)", out.GetLocale());
        out.WriteLPWSTR(Buff);

		// If we have a locale qualifier in the array, then we should output
		// the flavors now.
		if ( NULL != pLocaleQual )
		{
			pLocaleQual->SplitFlavors( out );
		}

    }

    out.WriteLPWSTR(L"] ");

    return TRUE;
}

//***************************************************************************
//
//  CMObject::CheckIfAmended()
//
//  DESCRIPTION:
//
//  returns true if the object has one or more Amended qualifiers.
//
//***************************************************************************

bool CMObject::CheckIfAmended()
{
    if(m_bAmended)
        return true;

    // true if this is a __namespace object

    if(IsInstance())
    {
        if(!wbem_wcsicmp(GetClassName(), L"__namespace"))
            return false;
    }

    // Deletes always get displayed

    if(IsDelete())
        return TRUE;

    // Check if the main qualifier list has an amended qualifier
    
    if(m_paQualifiers->HasAmended())
        return true;

    // check if any of the properties has an amended qualifier

	for(int i = 0; i < GetNumProperties(); i++)
	{
		CMoProperty * pProp = GetProperty(i);
		if(pProp)
		{
            CMoQualifierArray* pPropQualList = pProp->GetQualifiers();
            if(pPropQualList->HasAmended())
                return true;
		}
	}
    return false;
}

//***************************************************************************
//
//  CMoQualifierArray::HasAmended()
//
//  DESCRIPTION:
//
//  Returns true if one of more of the qualifiers is amended.
//
//***************************************************************************

bool CMoQualifierArray::HasAmended()
{
    int iCnt, iSize = m_aQualifiers.GetSize();
    for(iCnt = 0; iCnt < iSize; iCnt++)
    {
        CMoQualifier * pQual = (CMoQualifier *)m_aQualifiers.GetAt(iCnt);
        if(pQual)
            if(pQual->IsAmended())
                return true;
    }
    return false;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\mofcomp_dll\moflex.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    MOFLEX.H

Abstract:

	Declarations for class CMofLexer, which tokenizes MOF files.  
	ANSI, DBCS and UNICODE are supported.

History:

	a-raymcc    11-Oct-95   Created.
	a-raymcc    27-Jan-96   Update for aliasing.
	a-davj       6-June-96  Added support for octal, hex and binary constants
						  and line stitching, comment concatenation, escape
						  characters and old style comments.

--*/

#ifndef _MOFLEX_H_
#define _MOFLEX_H_

#include <windows.h>
#include <stdio.h>
#include "trace.h"
#include <datasrc.h>
#include <md5wbem.h>

// Terminal tokens required by the parser.
// =======================================

#define TOK_NULL                     0
#define TOK_ERROR                   -1

#define TOK_CLASS                           256
#define TOK_SIMPLE_IDENT                    257
#define TOK_OPEN_BRACE                      258
#define TOK_CLOSE_BRACE                     259
#define TOK_SEMI                            260
#define TOK_COLON                           261
#define TOK_INTERFACE                       262
#define TOK_REF                             263
#define TOK_OPEN_BRACKET                    264
#define TOK_CLOSE_BRACKET                   265
#define TOK_EQUALS                          266
#define TOK_INSTANCE                        267
#define TOK_AS                              268
#define TOK_COMMA                           269
#define TOK_EXTERNAL                        270
#define TOK_OPEN_PAREN                      271
#define TOK_CLOSE_PAREN                     272
#define TOK_LPWSTR                          274
#define TOK_UUID                            277
#define TOK_KEYWORD_NULL                    278
#define TOK_FLOAT_VALUE                     279
#define TOK_AMPERSAND                       280
#define TOK_DOT                             281
#define TOK_DOLLAR_SIGN                     282
#define TOK_HEX_CONST                       283
#define TOK_OCTAL_CONST                     284
#define TOK_LINE                            285
#define TOK_OF                              286
#define TOK_OBJECT                          287
#define TOK_TYPEDEF                         288
#define TOK_SUBRANGE                        289
#define TOK_PRAGMA                          290
#define TOK_DEFINE                          291
#define TOK_IFDEF                           292
#define TOK_INCLUDE                         293
#define TOK_ENDIF                           294
#define TOK_IFNDEF                          295
#define TOK_WCHAR                           296
#define TOK_ENUM                            300
#define TOK_AUTORECOVER                     301
#define TOK_NAMESPACE                       302
#define TOK_POUND                           303
#define TOK_TRUE                            304
#define TOK_FALSE                           305
#define TOK_TOINSTANCE                      306
#define TOK_TOSUBCLASS                      307
#define TOK_ENABLEOVERRIDE                  308
#define TOK_DISABLEOVERRIDE                 309
#define TOK_NOTTOINSTANCE                   310
#define TOK_NOTTOSUBCLASS                   311
#define TOK_QUALIFIER                       312
#define TOK_INSTANCEFLAGS                   313
#define TOK_CLASSFLAGS                      314
#define TOK_SIGNED64_NUMERIC_CONST          315
#define TOK_UNSIGNED64_NUMERIC_CONST        316
#define TOK_VOID                            317
#define TOK_AMENDMENT                       318
#define TOK_RESTRICTED                      319
#define TOK_SYSTEM_IDENT                    320
#define TOK_AMENDED							321
#define TOK_DELETECLASS						322
#define TOK_FAIL                            323
#define TOK_NOFAIL                          324
#define TOK_DELETEINSTANCE                  326
#define TOK_LOCALE                          327
#define TOK_PLUS	             		    328
#define TOK_INSTANCELOCALE                  329
#define TOK_NONLOCAL                        330
#define TOK_NONLOCALTYPE                    331
#define TOK_SOURCE                          332
#define TOK_SOURCETYPE                      333


// This type is used to describe the state of the lexer state machine.
// ====================================================================

typedef enum {  start,
                new_style_comment,          // ie, "//" comments
                old_style_comment,          // ie, "/* ... */" comments
                wstring,
                wcharacter,
                uuid,
                ident,
                numeric,
                lexerror,
                stop
            }   LexState;

class CMofLexer
{
	PDBG m_pDbg;
    int   m_nLine;
    int   m_nTokCol;
	int   m_nStartOfLinePos;
    int   m_nTokLine;
    int   m_nErrorCode;
	BOOL  m_bUnicode;
    wchar_t  *m_pBuff;            // holds the data to be parsed
	BYTE *m_pToFar;
//todo    wchar_t *m_pCurrWChar;       // points to the current character
//todo    wchar_t *m_pLastWChar;       // points to the last valid character
	DataSrc * m_pDataSrc;
    wchar_t *m_pWorkBuf;         // Holds the current token string
    int   m_nWorkBufSize;        // number of WCHARs working buff holds
    wchar_t *m_pEndOfText;       // points to null terminator of working buff
    BOOL m_bInString;
    BOOL m_bBadString;
    bool m_bBMOF;
    WCHAR m_wFile[MAX_PATH];
    __int64 m_i8;

    void Init();
    BOOL SpaceAvailable();
    void BuildBuffer(long lSize, TCHAR * pFileName,char *  pMemSrc, char * pMemToFar);
    void MovePtr(int iNum);
    wchar_t GetChar(int iNum = 0);
    int iGetColumn();
    int iGetNumericType(void);
    LexState ProcessStr(wchar_t * pNewChar, LexState lsCurr, int *piRet);
    int ConvertEsc(wchar_t * pResult, LexState lsCurr);
    int OctalConvert(wchar_t *pResult, LexState lsCurr);
    int HexConvert(wchar_t *pResult, LexState lsCurr);
    BOOL bOKNumericAddition(wchar_t cTest);
    BOOL ValidGuid();
    bool ProcessBMOFFile(FILE *fp,TCHAR * szFilename);
    bool CreateBufferFromBMOF(byte * pIn, DWORD dwCompressedSize, DWORD dwExpandedSize);    

public:
    enum {
            no_error,
            file_not_found,
            memory_failure,
            access_denied,
            file_io_error,
            unrecognized_token,
            token_too_long,
            invalid_source_file,
            invalid_source_buffer,
            problem_creating_temp_file,
            preprocessor_error,
			invalid_include_file
         };
    
    CMofLexer(PDBG pDbg);
    CMofLexer(const TCHAR *pFilePath, PDBG pDbg);    
    ~CMofLexer();
    HRESULT SetBuffer(char *pSrcMemory, DWORD dwMemSize);
	BOOL IsUnicode(){return m_bUnicode;};

    int NextToken(bool bDontAllowWhitespace = false);    // Returns 0 on end of file

    __int64 GetLastInt(){return m_i8;};
    const OLECHAR *GetText(int *pLineDeclared = 0);

    int GetLineNumber() { return m_nLine; }
    void SetLineNumber(int iNew) {m_nLine = iNew-1;};   // the -1 accounts for the cr/lf at eol
    WCHAR * GetErrorFile(){return m_wFile;};
    void SetErrorFile(const WCHAR * pNew){wcsncpy(m_wFile, pNew, MAX_PATH-1);};
    int GetColumn() { return m_nTokCol; }
    int GetError() { return m_nErrorCode; }
    void SetError(int iError) { m_nErrorCode = iError; }
    bool IsBMOF(){return m_bBMOF;};
    BYTE * GetBuff(){return (BYTE *)m_pBuff;};
    BYTE * GetToFar(){return (BYTE *)m_pToFar;};


    void SetLexPosition(ParseState * pPos);
    void GetLexPosition(ParseState * pPos);

    TCHAR * GetFileName(){ return m_pDataSrc?m_pDataSrc->GetFileName():NULL; };

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\mofcomp_dll\mofprop.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    MOFPROP.CPP

Abstract:

History:

--*/

#include "precomp.h"
#include <wbemidl.h>
//#include "corepol.h"
#include "wstring.h"
#include "mofout.h"
#include "mofprop.h"
#include "typehelp.h"
#include "trace.h"
#include "strings.h"
#include "cwbemtime.h"
#include <genutils.h>
#include <wbemutil.h>
#include <cominit.h>
#include <arrtempl.h>
#include "moflex.h"
#include "mofparse.h"
#include <memory>
HRESULT MofdSetInterfaceSecurity(IUnknown * pInterface, LPWSTR pAuthority, 
                                                                    LPWSTR pUser, LPWSTR pPassword);

BOOL BinaryToInt(wchar_t * pConvert, __int64& i64Res);

void assign(WCHAR * &pTo, LPCWSTR pFrom)
{
    if(pTo)
    {
        delete pTo;
        pTo = NULL;
    }
    if(pFrom)
    {
        DWORD dwLen = wcslen(pFrom)+1;
        pTo = new WCHAR[dwLen];
        if(pTo)
            StringCchCopyW(pTo, dwLen, pFrom);
    }
}

BOOL ConvertAndTry(WCHAR * pFormat, WCHAR *pData, WCHAR *pCheck, unsigned __int64 & ui8)
{
    static WCHAR wTemp[100];
    if(swscanf(pData, pFormat, &ui8) != 1)
        return FALSE;
    StringCchPrintfW(wTemp, 100, pFormat, ui8);
    return !wbem_wcsicmp(wTemp, pCheck);
}


CMoValue::CAlias::CAlias(COPY LPCWSTR wszAlias, int nArrayIndex)
{
    m_nArrayIndex = nArrayIndex;
    m_wszAlias = Macro_CloneStr(wszAlias);
}

CMoValue::CAlias::~CAlias()

{
    delete [] m_wszAlias;
}


CMoValue::CMoValue(PDBG pDbg)
{
	m_pDbg = pDbg;
    m_vType = 0;
    VariantInit(&m_varValue);
}

CMoValue::~CMoValue()
{
	if(m_varValue.vt == VT_EMBEDDED_OBJECT)
	{
#ifdef _WIN64
		CMObject * pObj = (CMObject *)m_varValue.llVal;
#else
		CMObject * pObj = (CMObject *)m_varValue.lVal;
#endif
		if(pObj)
			delete pObj;
		m_varValue.vt = VT_NULL;
	}
	else if(m_varValue.vt == (VT_EMBEDDED_OBJECT | VT_ARRAY))
	{
		SCODE sc ;
		SAFEARRAY * psaSrc = m_varValue.parray;
		if(psaSrc == NULL)
			return;
        long lLBound, lUBound;
        sc = SafeArrayGetLBound(psaSrc, 1, &lLBound);
        sc |= SafeArrayGetUBound(psaSrc, 1, &lUBound);
		if(sc != S_OK)
			return; 

        for(long lIndex = lLBound; lIndex <= lUBound; lIndex++)
        {
            // Load the initial data element into a VARIANT
            // ============================================
			CMObject * pObj;

             sc = SafeArrayGetElement(psaSrc, &lIndex, &pObj);
			if(sc == S_OK && pObj)
				delete pObj;
		}
		SafeArrayDestroy(psaSrc);
		m_varValue.vt = VT_NULL;

	}
    if((m_varValue.vt & ~	VT_ARRAY) != VT_EMBEDDED_OBJECT)
        VariantClear(&m_varValue);

    for(int i = 0; i < m_aAliases.GetSize(); i++)
    {
        delete (CAlias*)m_aAliases[i];
    }
}

BOOL CMoValue::GetAlias(IN int nAliasIndex,
                        OUT INTERNAL LPWSTR& wszAlias,
                        OUT int& nArrayIndex)
{
    if(nAliasIndex >= m_aAliases.GetSize()) return FALSE;

    CAlias* pAlias = (CAlias*)m_aAliases[nAliasIndex];
    wszAlias = pAlias->m_wszAlias;
    nArrayIndex = pAlias->m_nArrayIndex;

    return TRUE;
}

HRESULT CMoValue::AddAlias(COPY LPCWSTR wszAlias, int nArrayIndex)
{
    std::auto_ptr<CAlias> pAlias(new CAlias(wszAlias, nArrayIndex));

    if(pAlias.get() == NULL)
        return WBEM_E_OUT_OF_MEMORY;
    if(pAlias->m_wszAlias == NULL && wszAlias != NULL)
    {
        return WBEM_E_OUT_OF_MEMORY;
    }
    m_aAliases.Add(pAlias.get());
    pAlias.release();

    return S_OK;
}

//*****************************************************************************

CMoProperty::CMoProperty(CMoQualifierArray * paQualifiers, PDBG pDbg) : m_Value(pDbg)
{
	m_pDbg = pDbg;
    m_wszName = NULL;
	m_wszTypeTitle = NULL;
    m_paQualifiers = paQualifiers;
}

HRESULT CMoProperty::SetPropName(COPY LPCWSTR wszName)
{
    delete [] m_wszName;
    m_wszName = Macro_CloneStr(wszName);
    if(m_wszName == NULL && wszName != NULL )
        return WBEM_E_OUT_OF_MEMORY;
    else
        return S_OK;
}
HRESULT CMoProperty::SetTypeTitle(COPY LPCWSTR wszName)
{
	delete [] m_wszTypeTitle;
    m_wszTypeTitle = Macro_CloneStr(wszName);
    if(m_wszTypeTitle == NULL && wszName != NULL)
        return WBEM_E_OUT_OF_MEMORY;
    else
        return S_OK;
}

void CMoProperty::SetQualifiers(ACQUIRE CMoQualifierArray* pQualifiers)
{
    delete m_paQualifiers;
    m_paQualifiers = pQualifiers;
}

IWbemClassObject * CMoProperty::GetInstPtr(const WCHAR * pClassName,  IWbemServices* pNamespace, CMObject * pMo, 
                                           IWbemContext * pCtx)
{
	IWbemClassObject *pInst = NULL;
    SCODE sc;

  	BSTR bstr = SysAllocString(pClassName);
    if(bstr == NULL)
	    return NULL;
	CSysFreeMe fm(bstr);
    if(!wbem_wcsicmp(L"__PARAMETERS", pClassName))
    {
        sc = pNamespace->GetObject(bstr, 0, pCtx, &pInst, NULL);
    }
    else if(pMo->IsInstance())
    {
    	IWbemClassObject *pClass = NULL;
	    sc = pNamespace->GetObject(bstr, 0, pCtx, &pClass, NULL);
	    if(sc != S_OK)
		    return NULL;
	    sc = pClass->SpawnInstance(0, &pInst);
        pClass->Release();
    }
	else
	{
		// got a class, not an instance!

        CMoClass * pClass = (CMoClass * )pMo;
        if(pClass->GetParentName() && wcslen(pClass->GetParentName()) > 0)
        {
            IWbemClassObject * pParent = NULL;
            BSTR bstrParent = SysAllocString(pClass->GetParentName());
            if(bstrParent == NULL)
                return NULL;
            CSysFreeMe fm2(bstrParent);
	        sc = pNamespace->GetObject(bstrParent, 0, pCtx, &pParent, NULL);
            if(FAILED(sc))
                return NULL;
            CReleaseMe rm(pParent);
            sc = pParent->SpawnDerivedClass(0, &pInst);
            if(FAILED(sc))
                return NULL;
        }
        else
	        sc = pNamespace->GetObject(NULL, 0, pCtx, &pInst, NULL);
	    if(sc != S_OK)
		    return NULL;
		VARIANT var;
		var.vt = VT_BSTR;
		var.bstrVal = bstr;
		pInst->Put(L"__CLASS", 0, &var, 0);
	}
    if(sc != S_OK)
		    return NULL;

	BOOL bOK = pMo->ApplyToWbemObject(pInst,pNamespace,pCtx);

    if(bOK)
        return pInst;
    else
    {
        pInst->Release();
        return NULL;
    }

}

BOOL CValueProperty::AddEmbeddedObject(OLE_MODIFY IWbemClassObject* pObject, IWbemServices* pNamespace, IWbemContext * pCtx)
{
    VARIANT & var = m_Value.AccessVariant();
	VARIANT vSet;
	IWbemClassObject * pInst = NULL;

	if(var.vt & VT_ARRAY)
	{
		vSet.vt = VT_EMBEDDED_OBJECT | VT_ARRAY;
        SAFEARRAYBOUND aBounds[1];

        long lLBound, lUBound;
        SafeArrayGetLBound(var.parray, 1, &lLBound);
        SafeArrayGetUBound(var.parray, 1, &lUBound);

        aBounds[0].cElements = lUBound - lLBound + 1;
        aBounds[0].lLbound = lLBound;

        vSet.parray = SafeArrayCreate(VT_EMBEDDED_OBJECT & ~VT_ARRAY, 1, aBounds);
		if(vSet.parray == NULL)
			return FALSE;

        // Stuff the individual data pieces
        // ================================

        for(long lIndex = lLBound; lIndex <= lUBound; lIndex++)
        {
            // Load the initial data element into a VARIANT
            // ============================================
			
			CMObject * pTemp;
            SCODE hres = SafeArrayGetElement(var.parray, &lIndex, &pTemp);
          	if(FAILED(hres) || pTemp == FALSE) 
            {
                SafeArrayDestroy(vSet.parray);
                return FALSE;
            }
            // Cast it to the new type
            // =======================

			pInst = GetInstPtr(pTemp->GetClassName(), pNamespace, pTemp, pCtx);
       		if(pInst == NULL) 
			{
				Trace(true, m_pDbg, ALIAS_PROP_ERROR, m_wszName);
                SafeArrayDestroy(vSet.parray);
				return FALSE;
			}

			// Put it into the new array
			// =========================

			hres = SafeArrayPutElement(vSet.parray, &lIndex, pInst);


			pInst->Release();
          	if(FAILED(hres)) 
            {
                SafeArrayDestroy(vSet.parray);
                return FALSE;
            }
        }
	}
	else
	{
		CMObject * pTemp = (CMObject *)var.punkVal;
		pInst = GetInstPtr(pTemp->GetClassName(), pNamespace, pTemp, pCtx);
		if(pInst == NULL)
		{
			Trace(true, m_pDbg, ALIAS_PROP_ERROR, m_wszName);
			return FALSE;
		}
        vSet.punkVal = pInst;
		vSet.vt = VT_EMBEDDED_OBJECT;
	}
	HRESULT hres = pObject->Put(m_wszName, 0, &vSet, 0);

    // Release all the WbemObjects we have created
    // ==========================================

	if(var.vt & VT_ARRAY)
		SafeArrayDestroy(vSet.parray);
    else if(pInst)
		pInst->Release();
	return hres == S_OK;
}

BOOL CValueProperty::AddToObject(OLE_MODIFY IWbemClassObject* pObject, IWbemServices* pNamespace, 
                                 BOOL bClass, IWbemContext * pCtx)
{
    if(m_wszName == NULL) return FALSE;

    m_pDbg->SetString(m_wszName);

    // Get the property value
    // ======================

	VARIANT & var = m_Value.AccessVariant();

	// Determine if this is an embedded object.

	VARTYPE vtSimple = var.vt & ~VT_ARRAY;
	if(vtSimple == VT_NULL)
		vtSimple = m_Value.GetType() & ~VT_ARRAY;

    // If the type is embedded object, make sure the class name is OK.

	if(vtSimple == VT_EMBEDDED_OBJECT)
	{
		// Determine the class name of the embedded object.

		CMoValue * pValue = m_paQualifiers->Find(L"CIMTYPE");
		if(pValue)
		{
			if(var.vt == VT_BSTR && wcslen(var.bstrVal) > wcslen(L"Object:"))
			{

				// Test if this class if valid by doing a GetObject call

				WCHAR * pClassName = var.bstrVal + wcslen(L"Object:");
				IWbemClassObject *pClass = NULL;
				BSTR bstr = SysAllocString(pClassName);
				if(bstr == NULL)
					return FALSE;
				SCODE sc = pNamespace->GetObject(bstr, 0, pCtx,&pClass, NULL);
				SysFreeString(bstr);
				if(sc != S_OK)
				{
					m_pDbg->hresError = WBEM_E_INVALID_PROPERTY_TYPE;
					Trace(true, m_pDbg, BAD_PROP_TYPE, GetName());
					return FALSE;
				}
				pClass->Release();
			}
		}
    }

	// If there is an actual embedded object, store it.

   	if((var.vt & ~VT_ARRAY) == VT_EMBEDDED_OBJECT)
    {
        if(!AddEmbeddedObject(pObject, pNamespace, pCtx))
			return FALSE;
		return GetQualifiers()->AddToPropOrMeth(pObject, m_wszName, bClass, TRUE);
	}

    VARTYPE vNewType = m_Value.GetType();

    // arguments cannot be VT_EMPTY

    if(m_bIsArg && var.vt == VT_EMPTY)
        var.vt = VT_NULL;

    // Set the property value.  Not that reference types are a special case used by binary mofs
    // and so the flag should be eliminated.
    // ======================

    vNewType &= ~VT_BYREF;
    HRESULT hres = pObject->Put(m_wszName, 0, &var, (bClass || m_bIsArg) ? vNewType : 0);
    if(FAILED(hres))
    {
        m_pDbg->hresError = hres;
        return FALSE;
    }

    // Configure the qualifier set
    // ===========================

    if(!GetQualifiers()->AddToPropOrMeth(pObject, m_wszName, bClass, TRUE))
    {
        return FALSE;
    }

    // Get the syntax value
    // ====================


//    VariantClear(&vNew);
//    VariantClear(&v);    
    return TRUE;
}

BOOL CValueProperty::RegisterAliases(MODIFY CMObject* pObject)
{
    // Copy all alias registrations into the object
    // ============================================

	int iNumAlias = m_Value.GetNumAliases();
    for(int i = 0; i < iNumAlias; i++)
    {
        LPWSTR wszAlias;
        int nArrayIndex;
        m_Value.GetAlias(i, wszAlias, nArrayIndex);
        CPropertyLocation * pNew = new CPropertyLocation(m_wszName, nArrayIndex);
        if(pNew == NULL)
            return FALSE;
        if(pNew->IsOK() == false)
        {
            delete pNew;
            return FALSE;
        }
        HRESULT hr = pObject->AddAliasedValue(pNew,  wszAlias);
        if(FAILED(hr))
            return FALSE;
    }

    // Ask the qualifier set to do the same
    // ====================================

    if(m_paQualifiers)
        GetQualifiers()->RegisterAliases(pObject, m_wszName);

    return TRUE;
}

CMoProperty::~CMoProperty()
{
    if(m_paQualifiers)
        delete m_paQualifiers;
    if(m_wszName)
        delete [] m_wszName;
    if(m_wszTypeTitle)
        delete [] m_wszTypeTitle;
}

//*****************************************************************************

CMoQualifier::CMoQualifier(PDBG pDbg) : m_Value(pDbg)
{
    m_pDbg = pDbg;
    m_wszName = NULL;
    m_lFlavor = 0;
    m_bOverrideSet = false;
    m_bNotOverrideSet = false;
    m_bIsRestricted = false;
    m_bNotToInstance = false;
    m_bToInstance = false;
    m_bNotToSubclass = false;
    m_bToSubclass = false;
    m_bAmended = false;
    m_dwScope = 0;
    m_bCimDefaultQual = false;
    m_bUsingDefaultValue = false;

}

CMoQualifier::~CMoQualifier()
{
    if(m_wszName)
        delete [] m_wszName;
}

HRESULT CMoQualifier::SetFlag(int iToken, LPCWSTR pwsText)
{

    if(iToken == TOK_TOINSTANCE)
    {
        if(m_bIsRestricted || m_bNotToInstance)
            return WBEMMOF_E_INCOMPATIBLE_FLAVOR_TYPES2;
        m_lFlavor |= WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE;
        m_bToInstance = true;
    }
    else if(iToken == TOK_TOSUBCLASS)
    {
        if(m_bIsRestricted || m_bNotToSubclass)
            return WBEMMOF_E_INCOMPATIBLE_FLAVOR_TYPES2;
        m_lFlavor |= WBEM_FLAVOR_FLAG_PROPAGATE_TO_DERIVED_CLASS;
        m_bToSubclass = true;
    }
    else if(iToken == TOK_NOTTOINSTANCE)
    {
        if(m_bToInstance)
            return WBEMMOF_E_INCOMPATIBLE_FLAVOR_TYPES2;
        m_lFlavor &= ~WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE;
        m_bNotToInstance = true;
    }
    else if(iToken == TOK_NOTTOSUBCLASS)
    {
        if(m_bToSubclass)
            return WBEMMOF_E_INCOMPATIBLE_FLAVOR_TYPES2;
        m_lFlavor &= ~WBEM_FLAVOR_FLAG_PROPAGATE_TO_DERIVED_CLASS;
        m_bNotToSubclass = true;
    }
    else if(iToken == TOK_ENABLEOVERRIDE)
    {
        if(m_bNotOverrideSet)
            return WBEMMOF_E_INCOMPATIBLE_FLAVOR_TYPES2;
        m_lFlavor &= ~WBEM_FLAVOR_NOT_OVERRIDABLE;
        m_bOverrideSet = true;
    }
    else if(iToken == TOK_DISABLEOVERRIDE)
    {
        if(m_bOverrideSet)
            return WBEMMOF_E_INCOMPATIBLE_FLAVOR_TYPES2;
        m_bNotOverrideSet = true;
        m_lFlavor |= WBEM_FLAVOR_NOT_OVERRIDABLE;
    }
    else if(iToken == TOK_RESTRICTED)
    {      
        if(m_bToInstance || m_bToSubclass)
            return WBEMMOF_E_INCOMPATIBLE_FLAVOR_TYPES2;
        m_bIsRestricted = true;
        m_lFlavor &= ~WBEM_FLAVOR_MASK_PROPAGATION;
    }
    else if(iToken == TOK_AMENDED)
    {      
        m_bAmended = true;
    }
    else if(iToken == TOK_SIMPLE_IDENT && !wbem_wcsicmp(L"translatable", pwsText))
    {
	    return S_OK;    // WBEMMOF_E_UNSUPPORTED_CIMV22_FLAVOR_TYPE;
    }

    else
        return WBEMMOF_E_EXPECTED_FLAVOR_TYPE;
    return S_OK;
}

BOOL CMoQualifier::SetScope(int iToken, LPCWSTR pwsText)
{
    if(iToken == TOK_SIMPLE_IDENT && !wbem_wcsicmp(pwsText, L"ANY"))
    {
        m_dwScope |= 0XFFFFFFFF; 
        return TRUE;
    }
    if(iToken == TOK_SIMPLE_IDENT && !wbem_wcsicmp(pwsText, L"ASSOCIATION"))
    {
        m_dwScope |= SCOPE_ASSOCIATION; 
        return TRUE;
    }
    if(iToken == TOK_CLASS)
    {
        m_dwScope |= SCOPE_CLASS;
        return TRUE;
    }
    if(iToken == TOK_SIMPLE_IDENT && !wbem_wcsicmp(pwsText, L"indication"))
    {
        ERRORTRACE((LOG_MOFCOMP,"Warning, unsupported INDICATION keyword used in scope\n"));
        return TRUE;            // IGNORE THESE
    }
    if(iToken == TOK_SIMPLE_IDENT && !wbem_wcsicmp(pwsText, L"schema"))
    {
        ERRORTRACE((LOG_MOFCOMP,"Warning, unsupported SCHEMA keyword used in scope\n"));
        return TRUE;            // IGNORE THESE
    }
    if(iToken == TOK_INSTANCE)
    {
        m_dwScope |= SCOPE_INSTANCE;
        return TRUE;
    }
    if(iToken == TOK_SIMPLE_IDENT && !wbem_wcsicmp(pwsText, L"METHOD"))
    {
        m_dwScope |= SCOPE_METHOD; 
        return TRUE;
    }
    if(iToken == TOK_SIMPLE_IDENT && !wbem_wcsicmp(pwsText, L"PARAMETER"))
    {
        m_dwScope |= SCOPE_PARAMETER; 
        return TRUE;
    }
    if(iToken == TOK_SIMPLE_IDENT && !wbem_wcsicmp(pwsText, L"PROPERTY"))
    {
        m_dwScope |= SCOPE_PROPERTY;
        return TRUE;
    }
    if(iToken == TOK_SIMPLE_IDENT && !wbem_wcsicmp(pwsText, L"REFERENCE"))
    {
        m_dwScope |= SCOPE_REFERENCE; 
        return TRUE;
    }
    return FALSE;
}

HRESULT CMoQualifier::SetQualName(COPY LPCWSTR wszName)
{
    delete [] m_wszName;
    m_wszName = Macro_CloneStr(wszName);
    if(m_wszName == NULL && wszName != NULL)
        return WBEM_E_OUT_OF_MEMORY;
    else
        return S_OK;
}


BOOL CMoQualifier::AddToSet(OLE_MODIFY IWbemQualifierSet* pQualifierSet,
                            BOOL bClass)
{
    BSTR strName = SysAllocString(m_wszName);
    if(strName == NULL)
    {
        return FALSE;
    }    

    m_pDbg->SetString(strName);

    HRESULT hres = pQualifierSet->Put(
        strName,
        &m_Value.AccessVariant(),GetFlavor());
    if(FAILED(hres))
    {
        m_pDbg->hresError = hres;
        return FALSE;
    }

    SysFreeString(strName);

    return SUCCEEDED(hres);
}


INTERNAL CMoValue* CMoQualifierArray::Find(READ_ONLY LPCWSTR wszName)
{
    for(int i = 0; i < GetSize(); i++)
    {
        CMoQualifier* pQual = GetAt(i);
        if(!wbem_wcsicmp(pQual->GetName(), wszName))
        {
            return &pQual->AccessValue();
        }
    }

    return NULL;
}

BOOL CMoQualifierArray::Add(ACQUIRE CMoQualifier* pQualifier)
{
    // before adding a qualifier, check for a duplicate name.

    if(pQualifier == NULL || pQualifier->GetName() == NULL)
        return FALSE;
    CMoValue * pValue = Find(pQualifier->GetName());
    if(pValue != NULL)
        return FALSE; 

    m_aQualifiers.Add(pQualifier);
    return TRUE;
}
    
//*****************************************************************************

CMoQualifierArray::~CMoQualifierArray()
{
    for(int i = 0; i < GetSize(); i++)
    {
        delete GetAt(i);
    }
}
BOOL CMoQualifierArray::AddToSet(OLE_MODIFY IWbemQualifierSet* pQualifierSet,
                                 BOOL bClass)
{
    // Add all the qualifiers to it
    // ============================
    for(int i = 0; i < GetSize(); i++)
    {
        if(!GetAt(i)->AddToSet(pQualifierSet, bClass)) return FALSE;
    }

    return TRUE;
}

BOOL CMoQualifierArray::RegisterAliases(MODIFY CMObject* pObject,
                                        READ_ONLY LPCWSTR wszPropName)
{
    for(int i = 0; i < GetSize(); i++)
    {
        CMoValue& QualifierValue = GetAt(i)->AccessValue();
        LPCWSTR wszName = GetAt(i)->GetName();

        for(int j = 0; j < QualifierValue.GetNumAliases(); j++)
        {
            LPWSTR wszAlias;
            int nArrayIndex;
            QualifierValue.GetAlias(j, wszAlias, nArrayIndex);
            VARIANT  & Var = QualifierValue.AccessVariant();
            if((Var.vt & VT_ARRAY) == 0)
                nArrayIndex = -1;
            CQualifierLocation * pNew = new CQualifierLocation(wszName, m_pDbg, wszPropName, nArrayIndex);
            if(pNew == NULL)
                return FALSE;
            if(pNew->IsOK() == false)
            {
                delete pNew;
                return FALSE;
            }
            HRESULT hr = pObject->AddAliasedValue(pNew , wszAlias);
            if(FAILED(hr))
                return FALSE;
        }
    }

    return TRUE;
}

BOOL CMoQualifierArray::AddToObject(OLE_MODIFY IWbemClassObject* pObject,
                                    BOOL bClass)
{
    // Get the qualifier set from the object
    // =====================================

    IWbemQualifierSet* pQualifierSet;
    if(FAILED(pObject->GetQualifierSet(&pQualifierSet)))
    {
        return FALSE;
    }

    // Add all qualifiers to it
    // ========================

    BOOL bRes = AddToSet(pQualifierSet, bClass);
    pQualifierSet->Release();

    return bRes;
}

BOOL CMoQualifierArray::AddToPropOrMeth(OLE_MODIFY IWbemClassObject* pObject,
                                      READ_ONLY LPCWSTR wszName,
                                      BOOL bClass, BOOL bProp)
{
    // Get the qualifier set
    // =====================

    BSTR strName = SysAllocString(wszName);
    if(strName == NULL)
    {
        return FALSE;
    }
            
    IWbemQualifierSet* pQualifierSet;
    SCODE sc;
    if(bProp)
        sc = pObject->GetPropertyQualifierSet(strName, &pQualifierSet);
    else
        sc = pObject->GetMethodQualifierSet(strName, &pQualifierSet);
    SysFreeString(strName);

    if(FAILED(sc))
        return FALSE;

    // Add qualifiers to it
    // ====================

    BOOL bRes = AddToSet(pQualifierSet, bClass);
    pQualifierSet->Release();

    return bRes;
}


//*****************************************************************************

CMoType::~CMoType()
{
    delete m_wszTitle;
}

HRESULT CMoType::SetTitle(COPY LPCWSTR wszTitle)
{
    delete [] m_wszTitle;
    m_wszTitle = Macro_CloneStr(wszTitle);
    if(m_wszTitle == NULL && wszTitle != NULL)
        return WBEM_E_OUT_OF_MEMORY;
    else
        return S_OK;
}

VARTYPE CMoType::GetCIMType()
{
    if(IsRef() && IsArray()) return CIM_REFERENCE | VT_ARRAY;
    if(IsRef()) return CIM_REFERENCE;
    if(IsEmbedding() && IsArray()) return VT_EMBEDDED_OBJECT | VT_ARRAY;
    if(IsEmbedding()) return VT_EMBEDDED_OBJECT;

    VARTYPE vt_array = (IsArray())?VT_ARRAY:0;

    // Check if it is even initialized
    // ===============================

    if(m_wszTitle == NULL)
    {
        return VT_BSTR; // HACK! string converts nicely into just about anything
    }

    // VT_UI1

    if(!wbem_wcsicmp(m_wszTitle, L"sint8"))
         return CIM_SINT8 | vt_array;
    if(!wbem_wcsicmp(m_wszTitle, L"uint8"))
         return CIM_UINT8 | vt_array;
    if(!wbem_wcsicmp(m_wszTitle, L"sint16"))
         return CIM_SINT16 | vt_array;
    if(!wbem_wcsicmp(m_wszTitle, L"uint16"))
         return CIM_UINT16 | vt_array;
    if(!wbem_wcsicmp(m_wszTitle, L"sint32"))
         return CIM_SINT32 | vt_array;
    if(!wbem_wcsicmp(m_wszTitle, L"uint32"))
         return CIM_UINT32 | vt_array;
    if(!wbem_wcsicmp(m_wszTitle, L"sint64"))
         return CIM_SINT64 | vt_array;
    if(!wbem_wcsicmp(m_wszTitle, L"uint64"))
         return CIM_UINT64 | vt_array;


    // VT_R4

    if (!wbem_wcsicmp(m_wszTitle, L"real32"))
        return CIM_REAL32 | vt_array;
    if (!wbem_wcsicmp(m_wszTitle, L"real64"))
        return CIM_REAL64 | vt_array;

    // Do other types

    if(!wbem_wcsicmp(m_wszTitle, L"BOOLEAN"))
        return CIM_BOOLEAN | vt_array;


    if(!wbem_wcsicmp(m_wszTitle, L"string"))
        return CIM_STRING | vt_array;

    if(!wbem_wcsicmp(m_wszTitle, L"datetime"))
        return CIM_DATETIME | vt_array;
    if(!wbem_wcsicmp(m_wszTitle, L"REF"))
        return CIM_REFERENCE | vt_array;
    if(!wbem_wcsicmp(m_wszTitle, L"CHAR16"))
        return CIM_CHAR16 | vt_array;
    if(!wbem_wcsicmp(m_wszTitle, L"OBJECT"))
        return CIM_OBJECT | vt_array;

    
    if(!wbem_wcsicmp(m_wszTitle, L"void") || 
        !wbem_wcsicmp(m_wszTitle, L"null"))
        return VT_NULL;

    if(!wbem_wcsnicmp(m_wszTitle, L"REF:", 4))
        return CIM_REFERENCE | vt_array;
    if(!wbem_wcsnicmp(m_wszTitle, L"OBJECT:", 7))
        return CIM_OBJECT | vt_array;

    return VT_ERROR;
}

bool CMoType::IsUnsupportedType()
{
    if(m_wszTitle == NULL)
    {
        return false;
    }

    if(!wbem_wcsicmp(m_wszTitle, L"dt_sint8"))
         return true;
    if(!wbem_wcsicmp(m_wszTitle, L"dt_uint8"))
         return true;
    if(!wbem_wcsicmp(m_wszTitle, L"dt_sint16"))
         return true;
    if(!wbem_wcsicmp(m_wszTitle, L"dt_uint16"))
         return true;
    if(!wbem_wcsicmp(m_wszTitle, L"dt_sint32"))
         return true;
    if(!wbem_wcsicmp(m_wszTitle, L"dt_uint32"))
         return true;
    if(!wbem_wcsicmp(m_wszTitle, L"dt_sint64"))
         return true;
    if(!wbem_wcsicmp(m_wszTitle, L"dt_uint64"))
         return true;
    if (!wbem_wcsicmp(m_wszTitle, L"dt_real32"))
         return true;
    if (!wbem_wcsicmp(m_wszTitle, L"dt_real64"))
         return true;
    if (!wbem_wcsicmp(m_wszTitle, L"dt_char16"))
         return true;
    if(!wbem_wcsicmp(m_wszTitle, L"dt_BOOL"))
         return true;
    if(!wbem_wcsicmp(m_wszTitle, L"dt_str"))
         return true;
    if(!wbem_wcsicmp(m_wszTitle, L"dt_datetime"))
         return true;
    return false;
}

BOOL CMoType::StoreIntoQualifiers(CMoQualifierArray * pQualifiers)
{
    if(pQualifiers == NULL)
        return FALSE;
    if(IsRef() ||IsEmbedding())
    {
        WCHAR * pFormat = (IsRef()) ? L"ref" : L"object";

        if(wbem_wcsicmp(m_wszTitle, L"object") == 0)
        {
            pQualifiers->Add(CreateSyntax(pFormat));
        }
        else
        {
            DWORD dwLen = wcslen(m_wszTitle) + 20;
            LPWSTR wszSyntax = new WCHAR[dwLen];
            if(wszSyntax == NULL)
                return FALSE;
            StringCchPrintfW(wszSyntax, dwLen, L"%s:%s",pFormat, m_wszTitle);

            pQualifiers->Add(CreateSyntax(wszSyntax));
            delete [] wszSyntax;
        }

        return TRUE;
    }

    pQualifiers->Add(CreateSyntax(m_wszTitle));
    return TRUE;
}

DELETE_ME CMoQualifier* CMoType::CreateSyntax(READ_ONLY LPCWSTR wszSyntax)
{
    CMoQualifier* pQualifier = new CMoQualifier(m_pDbg);
    if(pQualifier == NULL)
        return NULL;
    if(FAILED(pQualifier->SetQualName(L"CIMTYPE")))
    {
        delete pQualifier;
        return NULL;
    }
    pQualifier->SetFlavor(WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE |
        WBEM_FLAVOR_FLAG_PROPAGATE_TO_DERIVED_CLASS);

    BSTR bstrVal = SysAllocString(wszSyntax);
    if(bstrVal == NULL)
    {
        delete pQualifier;
        return NULL;
    }
    V_VT(&pQualifier->AccessValue().AccessVariant()) = VT_BSTR;
    V_BSTR(&pQualifier->AccessValue().AccessVariant()) = bstrVal;

    return pQualifier;
}

//*****************************************************************************

HRESULT CValueLocation::SetArrayElement(
                                        MODIFY VARIANT& vArray,
                                        int nIndex,
                                        READ_ONLY VARIANT& vValue)
{
    if(V_VT(&vArray) != (VT_ARRAY | VT_BSTR)) return WBEM_E_FAILED;
  //  if(V_VT(&vArray) != (VT_ARRAY | VT_VARIANT)) return WBEM_E_FAILED;

    SAFEARRAY* pSafeArray = V_ARRAY(&vArray);
    long lLowerBound;
    if(FAILED(SafeArrayGetLBound(pSafeArray, 1, &lLowerBound)))
        return WBEM_E_FAILED;

    long lActualIndex = lLowerBound + nIndex;

    // Set the value in the array
    // ==========================

    if(FAILED(SafeArrayPutElement(pSafeArray,
                                    (long*)&lActualIndex,
                                    (void*)vValue.bstrVal)))
    {
        return WBEM_E_FAILED;
    }

    return WBEM_NO_ERROR;
}

//*****************************************************************************

CPropertyLocation::CPropertyLocation(COPY LPCWSTR wszName, int nArrayIndex)
{
    m_bOK = true;
    m_wszName = Macro_CloneStr(wszName);
    if(m_wszName == NULL && wszName != NULL)
        m_bOK = false;
    m_nArrayIndex = nArrayIndex;
}

CPropertyLocation::~CPropertyLocation()
{
    if(m_wszName)
        delete m_wszName;
}

HRESULT CPropertyLocation::Set(READ_ONLY VARIANT& varValue,
                OLE_MODIFY IWbemClassObject* pObject)
{
    if(m_nArrayIndex == -1)
    {
        // Not an array index. Simply set the property
        // ===========================================

        return pObject->Put(m_wszName, 0, &varValue, 0);
    }
    else
    {
        // Array index. Get the value
        // ==========================

        VARIANT vArray;
        VariantInit(&vArray);
        HRESULT hres = pObject->Get(m_wszName, 0, &vArray, NULL, NULL);
        if(FAILED(hres)) return hres;

        // Set the value
        // =============

        if(FAILED(SetArrayElement(vArray, m_nArrayIndex, varValue)))
            return WBEM_E_FAILED;

        // Store the whole array back into the property
        // ============================================

        hres = pObject->Put(m_wszName, 0, &vArray, 0);
        VariantClear(&vArray);

        return hres;
    }
}

//*****************************************************************************

CQualifierLocation::CQualifierLocation(COPY LPCWSTR wszName,PDBG pDbg,
                                       COPY LPCWSTR wszPropName,
                                       int nArrayIndex)
{
    m_bOK = true;
    m_pDbg = pDbg;
    if(wszName)
        m_wszName = Macro_CloneStr(wszName);
    else
        m_wszName = NULL;
    if(m_wszName == NULL && wszName != NULL)
        m_bOK = false;

    if(wszPropName != NULL) 
        m_wszPropName = Macro_CloneStr(wszPropName);
    else 
        m_wszPropName = NULL;
    if(m_wszPropName == NULL && wszPropName != NULL)
        m_bOK = false;

    m_nArrayIndex = nArrayIndex;
}

CQualifierLocation::~CQualifierLocation()
{
    if(m_wszName)
        delete m_wszName;
    if(m_wszPropName)
        delete m_wszPropName;
}

HRESULT CQualifierLocation::Set(READ_ONLY VARIANT& varValue,
                                OLE_MODIFY IWbemClassObject* pObject)
{
    HRESULT hres;
    long lOrigFlavor= 0;

    if(pObject == NULL)
        return WBEM_E_INVALID_PARAMETER;

    // Get the qualifier set for either the property or the object
    // ===========================================================

    IWbemQualifierSet* pQualifierSet;
    if(m_wszPropName == NULL)
    {
        hres = pObject->GetQualifierSet(&pQualifierSet);
    }
    else
    {
        hres = pObject->GetPropertyQualifierSet(m_wszPropName, &pQualifierSet);
    }

    if(FAILED(hres)) 
        return hres;

    // Get the qualifier value (need it for the type in either case)
    // =============================================================

    VARIANT vQualifierVal;
    VariantInit(&vQualifierVal);

    hres = pQualifierSet->Get(m_wszName, 0, &vQualifierVal, &lOrigFlavor);
    if(FAILED(hres)) return hres;

    // Check if array is involved
    // ==========================

    if(m_nArrayIndex == -1)
    {
        // Just set the qualifier value
        // ============================

        hres = pQualifierSet->Put(m_wszName, &varValue, lOrigFlavor);
    }
    else
    {
        // Set the appropriate array element
        // =================================

        if(FAILED(SetArrayElement(vQualifierVal, m_nArrayIndex, varValue)))
            return WBEM_E_FAILED;

        // Store the value back
        // ====================

        hres = pQualifierSet->Put(m_wszName, &vQualifierVal, lOrigFlavor);
        if(FAILED(hres))
        {
            m_pDbg->hresError = FALSE;
            return hres;
        }
    }

    pQualifierSet->Release();
    VariantClear(&vQualifierVal);
    return hres;
}


//*****************************************************************************

CMObject::CAliasedValue::CAliasedValue(
                                       ACQUIRE CValueLocation* _pLocation,
                                       COPY LPCWSTR _wszAlias)
{
    pLocation = _pLocation;
    wszAlias = Macro_CloneStr(_wszAlias);
}

CMObject::CAliasedValue::~CAliasedValue()
{
    delete pLocation;
    delete [] wszAlias;
}

CMObject::CMObject()
{
    m_wszAlias = NULL;
    m_wszNamespace = NULL;
    m_paQualifiers = NULL;
    m_wszFullPath = NULL;
    m_nFirstLine = 0;
    m_nLastLine = 0;
    m_lDefClassFlags = 0;
    m_lDefInstanceFlags = 0;
    m_bDone = FALSE;
    m_pWbemObj = NULL;
    m_bParameter = false;
    m_bAmended = false;
    m_wFileName = NULL;
    m_bDeflated = false;
    m_bOK =  true;
}

HRESULT CMObject::Deflate(bool bDestruct)
{
    if(!bDestruct && (m_wszAlias || GetNumAliasedValues() > 0))
    {
        return S_OK;
    }
    m_bDeflated = true;
	if(m_paQualifiers)
	{
		for(int i = 0; i < m_paQualifiers->GetSize(); i++)
		{
			CMoQualifier * pQual = (CMoQualifier *) m_paQualifiers->GetAt(i);
			delete pQual;
		}
		m_paQualifiers->RemoveAll();
	}
    for(int i = 0; i < m_aProperties.GetSize(); i++)
    {
        CMoProperty * pProp = (CMoProperty *) m_aProperties[i];

        // If this is an parameter object (in argument or out arguement), dont delete any embedded
        // objects since they will be delete as the CMethodParameter is cleaned out

        if(m_bParameter)
        {
            VARIANT * pVar = pProp->GetpVar();
            if(pVar->vt & VT_UNKNOWN)
                pVar->vt = VT_I4;
        }
        delete pProp;
    }
    m_aProperties.RemoveAll();
    return S_OK;
}

HRESULT CMObject::Reflate(CMofParser & Parser)
{
    if(!m_bDeflated)
        return S_OK;

    if(IsInstance())
        Parser.SetState(REFLATE_INST);
    else
        Parser.SetState(REFLATE_CLASS);

    Parser.SetParserPosition(&m_QualState);
    if (!Parser.qualifier_decl(*m_paQualifiers, true, CLASSINST_SCOPE))
		return WBEM_E_FAILED;

    Parser.SetParserPosition(&m_DataState);
    if(IsInstance())
    {
        Parser.NextToken();
        Parser.prop_init_list(this);
    }
    else
    {
        Parser.NextToken();
        Parser.property_decl_list(this);
    }
    m_bDeflated = false;
    return S_OK;

}


CMObject::~CMObject()
{
    if(m_wszAlias)
        delete [] m_wszAlias;
    if(m_wszNamespace)
        delete [] m_wszNamespace;
    if(m_wszFullPath)
        delete [] m_wszFullPath;
    if(m_pWbemObj)
        m_pWbemObj->Release();
    Deflate(true);
    if(m_paQualifiers)
        delete m_paQualifiers;

    int i;
    for(i = 0; i < m_aAliased.GetSize(); i++)
    {
        delete (CAliasedValue*)m_aAliased[i];
    }

    delete [] m_wFileName;
}

void CMObject::FreeWbemObjectIfPossible()
{
    if(m_wszAlias == NULL && m_pWbemObj)
    {
        m_pWbemObj->Release();
        m_pWbemObj = NULL;
    }
}

HRESULT CMObject::SetAlias(COPY LPCWSTR wszAlias)
{
    delete [] m_wszAlias;
    m_wszAlias = Macro_CloneStr(wszAlias);
    if(m_wszAlias == NULL && wszAlias != NULL)
        return WBEM_E_OUT_OF_MEMORY;
    else
        return S_OK;
}

HRESULT CMObject::SetNamespace(COPY LPCWSTR wszNamespace)
{
    delete [] m_wszNamespace;
    m_wszNamespace = Macro_CloneStr(wszNamespace);
    if(m_wszNamespace == NULL && wszNamespace != NULL)
        return WBEM_E_OUT_OF_MEMORY;
    else
        return S_OK;
}

HRESULT CMObject::SetLineRange(int nFirstLine, int nLastLine, WCHAR * pFileName)
{
    m_nFirstLine = nFirstLine;
    m_nLastLine = nLastLine;
    m_wFileName = Macro_CloneStr(pFileName);
    if(m_wFileName == NULL && pFileName != NULL)
        return WBEM_E_OUT_OF_MEMORY;
    else
        return S_OK;
}

void CMObject::SetQualifiers(ACQUIRE CMoQualifierArray* pQualifiers)
{
    delete m_paQualifiers;
    m_paQualifiers = pQualifiers;
    pQualifiers->RegisterAliases(this, NULL);
}

BOOL CMObject::AddProperty(ACQUIRE CMoProperty* pProperty)
{
    // Check if the property has already been specified
    // ================================================

    for(int i = 0; i < m_aProperties.GetSize(); i++)
    {
        CMoProperty* pCurrentProp = (CMoProperty*)m_aProperties[i];
        if(!wbem_wcsicmp(pCurrentProp->GetName(), pProperty->GetName()))
        {
            return FALSE;
        }
    }
    
    m_aProperties.Add(pProperty);
    pProperty->RegisterAliases(this);
    return TRUE;
}


BOOL CMObject::GetAliasedValue(IN int nIndex,
                              OUT INTERNAL LPWSTR& wszAlias)
{
    if(nIndex >= m_aAliased.GetSize())
    {
        return FALSE;
    }

    CAliasedValue* pValue = (CAliasedValue*)m_aAliased[nIndex];
    wszAlias = pValue->wszAlias;

    return TRUE;
}

BOOL CMObject::ResolveAliasedValue(IN int nIndex,
                                   READ_ONLY LPCWSTR wszPath,
                                   OLE_MODIFY IWbemClassObject* pObject)
{
    CAliasedValue* pValue = (CAliasedValue*)m_aAliased[nIndex];

    // Construct the variant with the value
    // ====================================

    VARIANT v;
    VariantInit(&v);
    V_VT(&v) = VT_BSTR;
    V_BSTR(&v) = SysAllocString(wszPath);
    if(v.bstrVal == NULL)
    {
        return FALSE;
    }
    // Tell the value locator to set it
    // ================================

    BOOL bRes = SUCCEEDED(pValue->pLocation->Set(v, pObject));

    VariantClear(&v);

    return bRes;
}

HRESULT CMObject::AddAliasedValue(ACQUIRE CValueLocation* pLocation,
                                COPY LPCWSTR wszAlias)
{
    if(pLocation)
    {
        std::auto_ptr<CAliasedValue> pValue(new CAliasedValue(pLocation, wszAlias));

        if(pValue.get() == NULL)
        {
            delete pLocation;
            return WBEM_E_OUT_OF_MEMORY;
        }
        if(pValue->wszAlias == NULL && wszAlias != NULL)
        {
            return WBEM_E_OUT_OF_MEMORY;
        }
        m_aAliased.Add(pValue.get());
        pValue.release();
    }
    return S_OK;
}

CMoProperty* CMObject::GetPropertyByName(WCHAR * pwcName)
{
    for(int iCnt = 0; iCnt < m_aProperties.GetSize(); iCnt++)
    {
        CMoProperty* pProp = (CMoProperty*)m_aProperties[iCnt];
        if(pProp && pProp->GetName())
            if(!wbem_wcsicmp(pwcName, pProp->GetName()))
                return pProp;
    }
    return NULL;
}
BOOL CMObject::ApplyToWbemObject(OLE_MODIFY IWbemClassObject* pObject, IWbemServices* pNamespace,
                                BOOL bClass, IWbemContext * pCtx)
{

    if(GetQualifiers() && !GetQualifiers()->AddToObject(pObject, bClass)) return FALSE;

    for(int i = 0; i < GetNumProperties(); i++)
    {
        if(!GetProperty(i)->AddToObject(pObject, pNamespace, bClass, pCtx)) return FALSE;
    }

    // Construct the path for future reference
    // =======================================

    VARIANT v;
    VariantInit(&v);
    SCODE sc = pObject->Get(L"__RELPATH", 0, &v, NULL, NULL);
    if(sc != S_OK || V_VT(&v) != VT_BSTR)
    {
        // This is probably an embedded object. If not, we will fail shortly
        // anyway. For now, just set the path to NULL and continue. // a-levn
        delete [] m_wszFullPath;
        m_wszFullPath = NULL;
        return TRUE;
    }

    SetFullPath(v.bstrVal);
    VariantClear(&v);

    return TRUE;
}

void CMObject::SetFullPath(BSTR bstr)
{
    if(bstr == NULL)
        return;

    if(m_wszFullPath)
        delete [] m_wszFullPath;
    
    int iLen = 20 + wcslen(bstr);
    if(m_wszNamespace)
        iLen += wcslen(m_wszNamespace);

    m_wszFullPath = new WCHAR[iLen];

    if(m_wszFullPath == NULL)
        return;

    // note that if m_wszNamespace is fully qualified, there is no need to 
    // prepend the slashes

    if(m_wszNamespace && m_wszNamespace[0] == L'\\' && m_wszNamespace[1] == L'\\')
        StringCchPrintfW (m_wszFullPath, iLen, L"%s:%s", m_wszNamespace, bstr);
    else
        StringCchPrintfW (m_wszFullPath, iLen, L"\\\\.\\%s:%s", m_wszNamespace, bstr);
}

int CMObject::GetNumAliasedValues()
{
    int iRet = m_aAliased.GetSize();

    // Also check the number of aliases in any embedded objects.

    int iCnt;
    for(iCnt = 0; iCnt < GetNumProperties(); iCnt++)
    {
        CMoProperty* pProp = GetProperty(iCnt);
        if(pProp == NULL)
            break;
        if(!pProp->IsValueProperty())
        {
            // Method properties actually contain one or two embedded instances for holding the
            // arguments.  Use those for the method case.

            CMethodProperty * pMeth = (CMethodProperty *)pProp;
            CMoInstance * pArgListObj = pMeth->GetInObj();
            if(pArgListObj)
                iRet += pArgListObj->GetNumAliasedValues();
            pArgListObj = pMeth->GetOutObj();
            if(pArgListObj)
                iRet += pArgListObj->GetNumAliasedValues();
            continue;
        }
        CMoValue& value = pProp->AccessValue();
        VARIANT & var = value.AccessVariant();

        if(var.vt == VT_EMBEDDED_OBJECT)
        {
            CMObject * pTemp = (CMObject *)var.punkVal;
            if(pTemp)
                iRet += pTemp->GetNumAliasedValues();
        }
        else if(var.vt == (VT_EMBEDDED_OBJECT | VT_ARRAY))
        {
        
            long lLBound, lUBound;
            SafeArrayGetLBound(var.parray, 1, &lLBound);
            SafeArrayGetUBound(var.parray, 1, &lUBound);

            // Check the individual embedded objects.
            // ======================================

            for(long lIndex = lLBound; lIndex <= lUBound; lIndex++)
            {
            
                CMObject * pTemp;
                SCODE hres = SafeArrayGetElement(var.parray, &lIndex, &pTemp);
                  if(FAILED(hres) || pTemp == FALSE) 
                    return iRet;
                iRet += pTemp->GetNumAliasedValues();                
            }
        }
    }
    return iRet;
}

HRESULT CMObject::ResolveAliasesInWbemObject(
        OLE_MODIFY IWbemClassObject* pObject,
        READ_ONLY CMofAliasCollection* pCollection)
{
    int i;
    SCODE sc;

    // Resolve them all using the collection
    // =====================================

    for(i = 0; i < m_aAliased.GetSize(); i++)
    {
        LPWSTR wszAlias;
        GetAliasedValue(i, wszAlias);

        LPCWSTR wszPathToAliasee = pCollection->FindAliasee(wszAlias);
        if(wszPathToAliasee == NULL) return WBEM_E_FAILED;

        if(!ResolveAliasedValue(i, wszPathToAliasee, pObject))
        {
            return WBEM_E_FAILED;
        }
    }

    // Also resolve any embedded objects

    int iCnt;
    for(iCnt = 0; iCnt < GetNumProperties(); iCnt++)
    {
        CMoProperty* pProp = GetProperty(iCnt);
        if(pProp == NULL)
            break;
        CMoValue& value = pProp->AccessValue();
        VARIANT & var = value.AccessVariant();

        if(!pProp->IsValueProperty())
        {
            // Methods contain possibly and input and an output object for storing the arguments.
            // These objects could contain aliases.

            BOOL bChanged = FALSE;
            CMethodProperty * pMeth = (CMethodProperty *)pProp;
            CMoInstance * pArgListObj = pMeth->GetInObj();
            BSTR bstr = SysAllocString(pProp->GetName());
            if(!bstr)
                return WBEM_E_FAILED;
            IWbemClassObject *pIn = NULL;
            IWbemClassObject *pOut = NULL;

            sc = pObject->GetMethod(bstr, 0, &pIn, &pOut);
            if(pArgListObj && pArgListObj->GetNumAliasedValues() && pIn)
            {
                sc = pArgListObj->ResolveAliasesInWbemObject((IWbemClassObject *)pIn,pCollection);
                if(sc == S_OK)
                    bChanged = TRUE;
            }
            pArgListObj = pMeth->GetOutObj();
            if(pArgListObj && pArgListObj->GetNumAliasedValues() && pOut)
            {
                sc = pArgListObj->ResolveAliasesInWbemObject((IWbemClassObject *)pOut,pCollection);
                if(sc == S_OK)
                    bChanged = TRUE;
            }
            if(bChanged)
                sc = pObject->PutMethod(bstr, 0, pIn, pOut);
            if(bstr)
                SysFreeString(bstr);
            if(pIn)
                pIn->Release();
            if(pOut)
                pOut->Release();
            continue;
        }
        
        else if(var.vt == VT_EMBEDDED_OBJECT)
        {
            CMObject * pTemp = (CMObject *)var.punkVal;
            if(pTemp)
            {
                VARIANT varDB;
                VariantInit(&varDB);
                BSTR bstr = SysAllocString(pProp->GetName());
                if(bstr)
                {
                    sc = pObject->Get(bstr, 0, &varDB, NULL, NULL);
                    
                    if(sc == S_OK)
                    {
                        IWbemClassObject * pClass = (IWbemClassObject *)varDB.punkVal;
                        sc = pTemp->ResolveAliasesInWbemObject((IWbemClassObject *)varDB.punkVal,pCollection);
                        if(S_OK == sc)
                            pObject->Put(bstr, 0, &varDB, 0);
                        else
                            return WBEM_E_FAILED;
                        pClass->Release();
                    }
                    SysFreeString(bstr);
                }
                else
                    return WBEM_E_OUT_OF_MEMORY;
            }
        }
        else if(var.vt == (VT_EMBEDDED_OBJECT | VT_ARRAY))
        {
        
            BSTR bstr = SysAllocString(pProp->GetName());
            if(bstr)
            {
                VARIANT varDB;
                VariantInit(&varDB);
                sc = pObject->Get(bstr, 0, &varDB, NULL, NULL);
                if(sc == S_OK)
                {
                    long lLBound, lUBound;
                    SafeArrayGetLBound(var.parray, 1, &lLBound);
                    SafeArrayGetUBound(var.parray, 1, &lUBound);

                    // Check the individual embedded objects.
                    // ======================================

                    for(long lIndex = lLBound; lIndex <= lUBound; lIndex++)
                    {
            
                        CMObject * pTemp;
                        sc = SafeArrayGetElement(var.parray, &lIndex, &pTemp);
                        IWbemClassObject * pWBEMInst = NULL;
                        sc |= SafeArrayGetElement(varDB.parray, &lIndex, &pWBEMInst);
                        
                        if(sc == S_OK && pTemp && pWBEMInst)
                        {
                            if(pTemp->m_aAliased.GetSize() > 0)
                            {
                                sc = pTemp->ResolveAliasesInWbemObject(pWBEMInst,pCollection);
                                if(sc != S_OK)
                                    return WBEM_E_FAILED;
                            }
                        }
                        if(pWBEMInst)
                            pWBEMInst->Release();
                    }
                    sc = pObject->Put(bstr, 0, &varDB, 0);
                    SafeArrayDestroyData(varDB.parray);
                    SafeArrayDestroyDescriptor(varDB.parray);
             
                }
                SysFreeString(bstr);
            }
            else
                return WBEM_E_OUT_OF_MEMORY;
        }
    }
    return WBEM_NO_ERROR;
}


//*****************************************************************************

CMoClass::CMoClass(COPY LPCWSTR wszParentName, COPY LPCWSTR wszClassName, PDBG pDbg,
                    BOOL bUpdateOnly)
{
    m_pDbg = pDbg;
    m_wszParentName = Macro_CloneStr(wszParentName);
    if(m_wszParentName == NULL && wszParentName != NULL)
        m_bOK = false;
    m_wszClassName = Macro_CloneStr(wszClassName);
    if(m_wszClassName == NULL && wszClassName != NULL)
        m_bOK = false;
    m_bUpdateOnly = bUpdateOnly;
}

CMoClass::~CMoClass()
{
    delete [] m_wszParentName;
    delete [] m_wszClassName;
}

HRESULT CMoClass::CreateWbemObject(READ_ONLY IWbemServices* pNamespace,
         RELEASE_ME IWbemClassObject** ppObject, IWbemContext * pCtx)
{
    // Take care of update only case.  In this case, the object is
    // not created, on retrieved for the later put!

    if(m_bUpdateOnly)
    {
        return pNamespace->GetObject(m_wszClassName, 0, pCtx, ppObject, NULL);
    }

    // Get the parent class from WINMGMT
    // ==============================


    BSTR strParentName = NULL;
    if(m_wszParentName)
    {
        strParentName = SysAllocString(m_wszParentName);
        if(strParentName == NULL)
        {
            return WBEM_E_OUT_OF_MEMORY;
        }        
        m_pDbg->SetString(strParentName);
    }

    IWbemClassObject* pParentClass = NULL;
    HRESULT hres = pNamespace->GetObject(strParentName, 0, pCtx, &pParentClass, NULL);
    if(strParentName)
        SysFreeString(strParentName);
    if(FAILED(hres)) return hres;

    if(m_wszParentName && wcslen(m_wszParentName))
    {
        // Create a child
        // ==============

        hres = pParentClass->SpawnDerivedClass(0, ppObject);
        pParentClass->Release();
        if(FAILED(hres)) return hres;
    }
    else
    {
        // Copy the dummy over
        // ===================

        *ppObject = pParentClass;
    }
    
    VARIANT v;
    VariantInit(&v);

    // Set the class name
    // ==================

    V_VT(&v) = VT_BSTR;
    V_BSTR(&v) = SysAllocString(m_wszClassName);
    if(v.bstrVal == NULL)
    {
        return WBEM_E_OUT_OF_MEMORY;
    }    
    (*ppObject)->Put(L"__CLASS", 0, &v, 0);
    VariantClear(&v);

    return hres;
}

HRESULT CMoClass::StoreWbemObject(READ_ONLY IWbemClassObject* pObject,
        long lClassFlags, long lInstanceFlags,
        OLE_MODIFY IWbemServices* pNamespace, IWbemContext * pCtx,
        WCHAR * pUserName, WCHAR * pPassword, WCHAR * pAuthority)
{
    return pNamespace->PutClass(pObject, lClassFlags, pCtx, NULL);
}


//*****************************************************************************

CMoInstance::CMoInstance(COPY LPCWSTR wszClassName, PDBG pDbg, bool bParameter)
{
    m_pDbg = pDbg;
    m_wszClassName = Macro_CloneStr(wszClassName);
    if(m_wszClassName == NULL && wszClassName != NULL)
        m_bOK = false;
   m_bParameter = bParameter;
}

CMoInstance::~CMoInstance()
{
    delete [] m_wszClassName;
}


// *****************************************************************************
// Used to determine if this object is the input arguement list of a method.  
// That can be determined by checking if any of the properties have a "IN" qualifier
// *****************************************************************************

BOOL CMoInstance::IsInput()
{
    for(int iCnt = 0; iCnt < GetNumProperties(); iCnt++)
    {
        CMoProperty* pProp = GetProperty(iCnt);
        CMoQualifierArray* pQual = pProp->GetQualifiers();
        if(pQual->Find(L"IN"))
            return TRUE;
    }
    return FALSE;
        
}


HRESULT CMoInstance::CreateWbemObject(READ_ONLY IWbemServices* pNamespace,
         RELEASE_ME IWbemClassObject** ppObject, IWbemContext * pCtx)
{
    // Get the class from WINMGMT
    // =======================

    IWbemClassObject* pClass = NULL;
    BSTR strClassName = SysAllocString(m_wszClassName);
    if(strClassName == NULL)
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    m_pDbg->SetString(strClassName);

    HRESULT hres = pNamespace->GetObject(strClassName, 0, pCtx, &pClass, NULL);
    SysFreeString(strClassName);
    if(FAILED(hres)) return hres;

    // Spawn a new instance
    // ====================

    hres = pClass->SpawnInstance(0, ppObject);
    pClass->Release();

    return hres;
}

HRESULT CMoInstance::StoreWbemObject(READ_ONLY IWbemClassObject* pObject,
        long lClassFlags, long lInstanceFlags,
        OLE_MODIFY IWbemServices* pNamespace, IWbemContext * pCtx,
        WCHAR * pUserName, WCHAR * pPassword, WCHAR * pAuthority)
{
    IWbemCallResult *pCallResult = NULL;
    SCODE scRet = pNamespace->PutInstance(pObject, lInstanceFlags, pCtx, 
        (m_wszAlias) ? &pCallResult : NULL);

    if(scRet == S_OK && pCallResult)
    {
        BSTR bstr = NULL;
        DWORD dwAuthLevel, dwImpLevel;
        SCODE sc  = GetAuthImp( pNamespace, &dwAuthLevel, &dwImpLevel);
        if(sc == S_OK)
            if(dwAuthLevel !=  RPC_C_AUTHN_LEVEL_NONE)
                sc = MofdSetInterfaceSecurity(
                            pCallResult, 
                            pAuthority, 
                            (pUserName && wcslen(pUserName) > 0) ? pUserName : NULL , 
                            pPassword);
            else
                sc = WbemSetProxyBlanket(pCallResult, RPC_C_AUTHN_WINNT, RPC_C_AUTHZ_NONE, 
                            NULL, RPC_C_AUTHN_LEVEL_NONE, RPC_C_IMP_LEVEL_IMPERSONATE,NULL, 0);

        scRet = pCallResult->GetResultString(9999, &bstr);
        if(sc == S_OK && scRet == S_OK && bstr)
        {
            SetFullPath(bstr);
            SysFreeString(bstr);
        }

        pCallResult->Release();
    }
    return scRet;
}

CMethodProperty::CMethodProperty(CMoQualifierArray * paQualifiers, PDBG pDbg, BOOL bBinary)
                   :CMoProperty(paQualifiers, pDbg)
{
    m_pDbg = pDbg;
    m_pInObj = NULL;
    m_pOutObj = NULL;
    m_IDType = UNSPECIFIED;     // Gets set on first argument
    m_NextAutoID = 0;
	m_bBinaryMof = bBinary;
	
}

CValueProperty::CValueProperty(CMoQualifierArray * paQualifiers, PDBG pDbg)
                   :CMoProperty(paQualifiers, pDbg)
{
    m_pDbg = pDbg;
    m_bIsArg = FALSE;
}


CMethodProperty::~CMethodProperty()
{
    VARIANT & var = m_Value.AccessVariant();
    var.vt = VT_EMPTY;

    if(m_pInObj != NULL)
            delete m_pInObj; 
    if(m_pOutObj != NULL)
            delete m_pOutObj;

    for(int i = 0; i < m_Args.GetSize(); i++)
    {
        CValueProperty * pProp = (CValueProperty *)m_Args[i];
        CMoProperty * pProp2 = (CMoProperty *)m_Args[i];
        delete (CValueProperty *)m_Args[i];
    }
    m_Args.RemoveAll();

}

BOOL CMethodProperty::AddToObject(OLE_MODIFY IWbemClassObject* pObject, IWbemServices* pNamespace, BOOL bClass, IWbemContext * pCtx)
{
    IWbemClassObject * pIn = NULL;
    IWbemClassObject * pOut = NULL;
    if(m_pInObj)
    {
        pIn = GetInstPtr(L"__PARAMETERS", pNamespace, m_pInObj, pCtx);
        if(pIn == NULL)
            return FALSE;
    }
    if(m_pOutObj)
    {
        pOut = GetInstPtr(L"__PARAMETERS", pNamespace, m_pOutObj, pCtx);
        if(pOut == NULL)
            return FALSE;
    }

    SCODE sc = pObject->PutMethod(GetName(), 0, pIn, pOut);
    if(pIn)
        pIn->Release();
    if(pOut)
        pOut->Release();

    if(FAILED(sc))
    {
        m_pDbg->hresError = sc;
        return FALSE;
    }
    if(!GetQualifiers()->AddToPropOrMeth(pObject, m_wszName, bClass, FALSE))
    {
        return FALSE;
    }

    return sc == S_OK;
}

/////////////////////////////////////////////////////////////////////////////////////////////
//
//  Creates a new qualifier set which is a copy of the source. 
//
/////////////////////////////////////////////////////////////////////////////////////////////

CMoQualifierArray * CreateArgQualifierList(BOOL bInput, CMoQualifierArray *pSrcQualifiers, PDBG pDbg)
{
    if(pSrcQualifiers == NULL)
        return NULL;

    std::auto_ptr<CMoQualifierArray> pRet (new CMoQualifierArray (pDbg));
    
    if (pRet.get() == NULL)
        return NULL;

    for(int iCnt = 0; iCnt < pSrcQualifiers->GetSize(); iCnt++)
    {
        CMoQualifier* pSrc = pSrcQualifiers->GetAt(iCnt);
        if(pSrc == NULL)
            continue;

        // If this is for input, dont copy out qualifiers, and vice versa!

        if(bInput && !wbem_wcsicmp(pSrc->GetName(), L"OUT"))
            continue;
        if(!bInput && !wbem_wcsicmp(pSrc->GetName(), L"IN"))
            continue;

        // Create the new qualifier, copy the values from the existing one

	std::auto_ptr<CMoQualifier> pQual (new CMoQualifier(pDbg));
        if(pQual.get() == NULL)
            return NULL;
//        if(pSrc->IsRestricted())
//            pQual->SetRestricted();
        pQual->SetFlavor(pSrc->GetFlavor());
//        if(pSrc->IsOverrideSet())
//            pQual->OverrideSet();
        if(FAILED(pQual->SetQualName(pSrc->GetName())))
            return NULL;
        pQual->SetType(pSrc->GetType());
        VARIANT * pSrcVar = pSrc->GetpVar();
        
	HRESULT hr = WbemVariantChangeType(pQual->GetpVar(), pSrcVar, pSrcVar->vt);

	if (SUCCEEDED (hr))
	{
        // Add the new qualifier to the new set
        pRet->Add (pQual.release());
	}
	else
	{ 
	  return NULL;
	}
    }
    return pRet.release();
}

bool CMethodProperty::IsIDSpecified(CMoQualifierArray * paQualifiers)
{
    int iSize = paQualifiers->GetSize();
    for(int iCnt = 0; iCnt < iSize; iCnt++)
    {
        CMoQualifier* pTest = paQualifiers->GetAt(iCnt);
        if(pTest == NULL || wbem_wcsicmp(pTest->GetName(), L"ID"))
            continue;
        VARIANT * pVar = pTest->GetpVar();
        if(pVar->vt != VT_I4)
            m_IDType = INVALID;
        return true;
    }
    return false;
}

/////////////////////////////////////////////////////////////////////////////////////////////
//
//  This takes a method argument and adds it to either the input or output arguement object
//
/////////////////////////////////////////////////////////////////////////////////////////////

BOOL CMethodProperty::AddIt(WString & sName, CMoType & Type, BOOL bInput, 
                            CMoQualifierArray * paQualifiers, VARIANT * pVar, 
                            CMoValue & Value, BOOL bRetValue, BOOL bSecondPass)
{

    HRESULT hr;

    // Except for the return value, all parameters must have an ID.  We support both the automatic
    // generation of IDs, as well as allowing the explicit settings of IDs.  However, doing both
    // in a method is not allowed

    if(!bRetValue && !bSecondPass)
    {

        // Better have a qual set!

        if(paQualifiers == NULL)
            return FALSE;

        if(IsIDSpecified(paQualifiers))     // find it was explicitly set
        {

            // Explicity set.  Just pass it along to fastprox as is.  Note that if we
        
            if(m_IDType == AUTOMATIC || m_IDType == INVALID)
                return FALSE;
            m_IDType = MANUAL;
        }
        else
        {
            // The IDs must be set automatically

            if(m_IDType == MANUAL || m_IDType == INVALID)
                return FALSE;
            m_IDType = AUTOMATIC;

            // Add a new qualifier to this

            CMoQualifier * pNew = new CMoQualifier(m_pDbg);
            if(pNew == NULL)
                return FALSE;
            if(FAILED(pNew->SetQualName(L"ID")))
            {
                delete pNew;
                return FALSE;
            }
            pNew->SetFlavor(WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE |
                            WBEM_FLAVOR_NOT_OVERRIDABLE);
        
            VARIANT * pVar2 = pNew->GetpVar();
            pVar2->vt = VT_I4;
            pVar2->lVal = m_NextAutoID++;
            paQualifiers->Add(pNew);

        }
    }

    // Get a pointer to either the input or output object.  In either case, the object
    // will need to be created if this is the first property being added to it.

    CMoInstance * pObj = NULL;
    if(bInput)
    {
        if(m_pInObj == NULL)
        {
            m_pInObj = new CMoInstance(L"__PARAMETERS", m_pDbg, true); 
            if(m_pInObj == NULL)
                return FALSE;
            if(m_pInObj->IsOK() == false)
            {
                delete m_pInObj;
                return FALSE;
            }
                
        }
        pObj = m_pInObj;
    }
    else
    {
        if(m_pOutObj == NULL)
        {
            m_pOutObj = new CMoInstance(L"__PARAMETERS", m_pDbg ,true); 
            if(m_pOutObj == NULL)
                return FALSE;
            if(m_pOutObj->IsOK() == false)
            {
                delete m_pOutObj;
                return FALSE;
            }
         }
        pObj = m_pOutObj;
    }
    
    if(pObj == NULL)
        return FALSE;
    // If the property doesnt have a qualifier set, as would be the case for the retvalue,
    // create one

    CMoQualifierArray * pQualifiers = NULL;

    if(paQualifiers == NULL)
        pQualifiers = new CMoQualifierArray(m_pDbg);
    else
        pQualifiers = CreateArgQualifierList(bInput, paQualifiers, m_pDbg);
    if(pQualifiers == NULL)
        return FALSE;

    // Create a new value property

    CValueProperty * pNewProp = new CValueProperty(pQualifiers, m_pDbg);
    if(pNewProp == NULL){
        delete pQualifiers;
        return FALSE;
    }
    VARTYPE vt = Type.GetCIMType();
    if(FAILED(pNewProp->SetPropName(sName)))
    {
        delete pNewProp;
        return FALSE;
    }
    pNewProp->SetAsArg();
    Type.StoreIntoQualifiers(pQualifiers);
    VARIANT * pDest;
    pDest = pNewProp->GetpVar();
    if(pVar && pVar->vt != VT_EMPTY && pVar->vt != VT_NULL)
    {
        VARTYPE vtSimple = pVar->vt & ~VT_ARRAY;
        if(vtSimple != VT_EMBEDDED_OBJECT || pVar->vt == (VT_EMBEDDED_OBJECT | VT_ARRAY))
        {
            hr = VariantCopy(pDest, pVar);
            if(FAILED(hr))
                return FALSE;
        }
        else
        {
            pDest->vt = VT_EMBEDDED_OBJECT;
            pDest->punkVal = pVar->punkVal;
        }
    }

    pNewProp->SetType(vt);

    // If the original value contains some aliases, make sure they get added

    CMoValue & Dest = pNewProp->AccessValue();
    for(int i = 0; i < Value.GetNumAliases(); i++)
    {
        LPWSTR wszAlias;
        int nArrayIndex;
        if(Value.GetAlias(i, wszAlias, nArrayIndex))
        {
            hr = Dest.AddAlias(wszAlias, nArrayIndex);
            if(FAILED(hr))
                return FALSE;
        }
    }


    pObj->AddProperty(pNewProp);

    return TRUE;
}

BOOL CMethodProperty::AddToArgObjects(CMoQualifierArray * paQualifiers, WString & sName, 
                                      CMoType & Type, BOOL bRetValue, int & ErrCtx, VARIANT * pVar,
                                      CMoValue & Value)
{
    
    // if return value and it is null or void, just bail out

    if(Type.IsDefined() == FALSE  && bRetValue)
        return TRUE;


    // Determine which arg list this goes into

    BOOL bGoesIntoInputs = FALSE;
    BOOL bGoesIntoOutputs = FALSE;
    
    if( bRetValue)
        bGoesIntoOutputs = TRUE;
    else
    {
        // Loop through the arg list.

        if(paQualifiers == NULL)
            return FALSE;
        if(paQualifiers->Find(L"IN"))
            bGoesIntoInputs = TRUE;
        if(paQualifiers->Find(L"OUT"))
            bGoesIntoOutputs = TRUE;
    }

    // make sure it isnt already on the list

    if(bGoesIntoInputs && m_pInObj && m_pInObj->GetPropertyByName(sName))
        return FALSE;

    if(bGoesIntoOutputs && m_pOutObj && m_pOutObj->GetPropertyByName(sName))
        return FALSE;

    if(bGoesIntoInputs == FALSE && bGoesIntoOutputs == FALSE)
    {
        ErrCtx = WBEMMOF_E_MUST_BE_IN_OR_OUT;
        return FALSE;
    }
    
    // Create the object(s) if necessary

    if(bGoesIntoInputs)
        if(!AddIt(sName, Type, TRUE, paQualifiers, pVar, Value, bRetValue, FALSE))
            return FALSE;

    if(bGoesIntoOutputs)
        return AddIt(sName, Type, FALSE, paQualifiers, pVar, Value, bRetValue, bGoesIntoInputs);
    else
        return TRUE;
}

CMoActionPragma::CMoActionPragma(COPY LPCWSTR wszClassName, PDBG pDbg, bool bFail, BOOL bClass)
{
    m_pDbg = pDbg;
    m_wszClassName = Macro_CloneStr(wszClassName);
    if(m_wszClassName == NULL && wszClassName != NULL)
        m_bOK = false;
    m_bFail = bFail;
    m_bClass = bClass;
}

CMoActionPragma::~CMoActionPragma()
{
    delete [] m_wszClassName;
}

HRESULT CMoActionPragma::StoreWbemObject(READ_ONLY IWbemClassObject* pObject,
        long lClassFlags, long lInstanceFlags,
        OLE_MODIFY IWbemServices* pNamespace, IWbemContext * pCtx,
        WCHAR * pUserName, WCHAR * pPassword, WCHAR * pAuthority)
{
    if(m_wszClassName == NULL || wcslen(m_wszClassName) < 1)
        return WBEM_E_FAILED;
    BSTR bstr = SysAllocString(m_wszClassName);
    if(bstr)
    {

        SCODE sc;
		if(m_bClass)
			sc = pNamespace->DeleteClass(bstr, 0, NULL, NULL);
		else
			sc = pNamespace->DeleteInstance(bstr, 0, NULL, NULL);

        SysFreeString(bstr);
        if(!m_bFail)
            return S_OK;
        else
        {
            if(FAILED(sc))
                wcsncpy(m_pDbg->m_wcError, m_wszClassName, 99);
            return sc;
        }
    }
    else
        return WBEM_E_OUT_OF_MEMORY;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\mofcomp_dll\mofprop.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    MOFPROP.H

Abstract:

History:

--*/

#ifndef __MOFPROP__H_
#define __MOFPROP__H_

#include <miniafx.h>
#include <wbemidl.h>
#include "wstring.h"
#include "parmdefs.h"
#include <wbemutil.h>
//#include "mofparse.h"
#include "trace.h"
#define VT_EX_EMBEDDED (VT_RESERVED | VT_EMBEDDED_OBJECT)

#define SCOPE_CLASS         1
#define SCOPE_INSTANCE      2
#define SCOPE_PROPERTY      4
#define SCOPE_METHOD        8
#define SCOPE_PARAMETER     0X10
#define SCOPE_ASSOCIATION   0X20
#define SCOPE_REFERENCE     0x40

enum QUALSCOPE{CLASSINST_SCOPE,  PROPMETH_SCOPE};
enum PARSESTATE {INITIAL, REFLATE_INST, REFLATE_CLASS};

class CMObject;
class CMoClass;
class CMofParse;
class ParseState;


class CMoValue
{
protected:
    VARTYPE m_vType;
    VARIANT m_varValue;
    struct CAlias
    {
        LPWSTR m_wszAlias;
        int m_nArrayIndex;

        CAlias() : m_wszAlias(NULL), m_nArrayIndex(-1){}
        CAlias(COPY LPCWSTR wszAlias, int nArrayIndex = -1);
        ~CAlias();
    };
    CPtrArray m_aAliases; // CAlias*
    PDBG m_pDbg;

public:
    CMoValue(PDBG pDbg);
    ~CMoValue();

    INTERNAL VARIANT& AccessVariant() {return m_varValue;}
    VARTYPE GetType() {return m_vType;}
    VARTYPE GetVarType() {return m_varValue.vt;}
    void SetType(VARTYPE vType) {m_vType = vType;}

    int GetNumAliases() {return m_aAliases.GetSize();}
    BOOL GetAlias(IN int nAliasIndeex, 
        OUT INTERNAL LPWSTR& wszAlias, OUT int& nArrayIndex);
    HRESULT AddAlias(COPY LPCWSTR wszAlias, int nArrayIndex = -1);
    BOOL Split(COutput & out);
};

//*****************************************************************************
typedef enum {OBJECT, PROP, ARG} QualType;

class CMoQualifier
{
protected:
    LPWSTR m_wszName;
    CMoValue m_Value;
    PDBG m_pDbg;
    DWORD m_dwScope;
    long m_lFlavor;
    bool m_bNotOverrideSet;
    bool m_bOverrideSet;
    bool m_bIsRestricted;
    bool m_bNotToInstance;
    bool m_bToInstance;
    bool m_bNotToSubclass;
    bool m_bToSubclass;
    bool m_bAmended;
    bool m_bCimDefaultQual;
    bool m_bUsingDefaultValue;
public:
    CMoQualifier(PDBG pDbg);
    ~CMoQualifier();
    BOOL IsRestricted(){return m_bIsRestricted;};
    void SetRestricted(){m_bIsRestricted = TRUE;};
    void SetCimDefault(bool bSet){m_bCimDefaultQual = bSet;};
    bool IsCimDefault(){return m_bCimDefaultQual;};
    void SetUsingDefaultValue(bool bSet){m_bUsingDefaultValue = bSet;};
    bool IsUsingDefaultValue(){return m_bUsingDefaultValue;};

    HRESULT SetQualName(COPY LPCWSTR wszName);
    INTERNAL LPWSTR GetName() {return m_wszName;}
    VARIANT * GetpVar(){return & m_Value.AccessVariant();};
    VARTYPE GetType(){return m_Value.GetType();};
    void SetType(VARTYPE vt){m_Value.SetType(vt);};
    bool IsAmended(){return m_bAmended;};
    void SetAmended(bool bAmended){m_bAmended = bAmended;};

    CMoValue& AccessValue() {return m_Value;}
    void SetFlavor(long lFlavor) { m_lFlavor = lFlavor;};
    long GetFlavor(void) { return m_lFlavor;};
    void OverrideSet(){m_bOverrideSet = TRUE;};
    BOOL IsOverrideSet(){return m_bOverrideSet;};
    HRESULT SetFlag(int iToken, LPCWSTR pwsText);
    BOOL SetScope(int iToken, LPCWSTR pwsText);
    DWORD GetScope(){return m_dwScope;};
    BOOL Split(COutput & out);
	BOOL SplitFlavors( COutput& out );
    BOOL IsDisplayable(COutput & out, QualType qt);

	BOOL IsLocaleQual( void ) { return wbem_wcsicmp( m_wszName, L"Locale" ) == 0; }

private:
    BOOL AddToSet(OLE_MODIFY IWbemQualifierSet* pQualifierSet, BOOL bClass);
    friend class CMoQualifierArray;
    friend class CBMOFOut;
};

//*****************************************************************************

class CMoQualifierArray
{
protected:
    CPtrArray m_aQualifiers;
    PDBG m_pDbg;

public:
    CMoQualifierArray(PDBG pDbg){m_pDbg = pDbg;}
    ~CMoQualifierArray();
	void RemoveAll(){m_aQualifiers.RemoveAll();};
    int GetSize() {return m_aQualifiers.GetSize();}

    INTERNAL CMoQualifier* GetAt(int nIndex) 
        {return (CMoQualifier*) m_aQualifiers[nIndex];}

    INTERNAL CMoQualifier* operator[](int nIndex) {return GetAt(nIndex);}
    INTERNAL CMoValue* Find(READ_ONLY LPCWSTR wszName);

    BOOL Add(ACQUIRE CMoQualifier* pQualifier);

    BOOL RegisterAliases(MODIFY CMObject* pObject,
                         READ_ONLY LPCWSTR wszPropName);

    BOOL AddToSet(OLE_MODIFY IWbemQualifierSet* pQualifierSet, BOOL bClass);
    BOOL AddToObject(OLE_MODIFY IWbemClassObject* pObject, BOOL bClass);
    BOOL AddToPropOrMeth(OLE_MODIFY IWbemClassObject* pObject, 
                    READ_ONLY LPCWSTR wszProperty, BOOL bClass, BOOL bProp);
    BOOL Split(COutput & out, QualType qt);

    bool HasAmended();
};
    
//*****************************************************************************

class CMoProperty
{
protected:
    LPWSTR m_wszName;
    CMoValue m_Value;
    LPWSTR m_wszTypeTitle;
    PDBG m_pDbg;
    CMoQualifierArray* m_paQualifiers;
    IWbemClassObject * GetInstPtr(const WCHAR * pClassName,  IWbemServices* pNamespace, CMObject * pMo, IWbemContext * pCtx);

public:
    CMoProperty(CMoQualifierArray * paQualifiers, PDBG pDbg);
    virtual ~CMoProperty();
    virtual BOOL IsValueProperty(){return TRUE;};

    INTERNAL LPWSTR GetName() {return m_wszName;}
    HRESULT SetPropName(COPY LPCWSTR wszName);
    HRESULT SetTypeTitle(COPY LPCWSTR wszName);

    VARTYPE GetType(){return m_Value.GetType();};
    void SetType(VARTYPE vType){m_Value.SetType(vType);};
    CMoValue& AccessValue() {return m_Value;}
    VARIANT * GetpVar(){return & m_Value.AccessVariant();};
    void SetQualifiers(ACQUIRE CMoQualifierArray* pQualifiers);
    INTERNAL CMoQualifierArray* GetQualifiers() {return m_paQualifiers;}

    virtual BOOL RegisterAliases(MODIFY CMObject* pObject){return TRUE;};
    virtual BOOL AddToObject(OLE_MODIFY IWbemClassObject* pObject, IWbemServices* pNamespace, BOOL bClass, IWbemContext * pCtx) = 0;
    virtual BOOL Split(COutput & out) = 0;

private:
    friend CMObject;
    friend CMoClass;
};

class CValueProperty : public CMoProperty
{
protected:
private:
    BOOL AddEmbeddedObject(OLE_MODIFY IWbemClassObject* pObject, IWbemServices* pNamespace, IWbemContext * pCtx);
    friend CMObject;
    friend CMoClass;
    BOOL m_bIsArg;
    PDBG m_pDbg;
public:

    CValueProperty(CMoQualifierArray * paQualifiers, PDBG pDbg);
    BOOL RegisterAliases(MODIFY CMObject* pObject);
    BOOL AddToObject(OLE_MODIFY IWbemClassObject* pObject, IWbemServices* pNamespace, BOOL bClass, IWbemContext * pCtx);
    void SetAsArg(){m_bIsArg = TRUE;};
    BOOL Split(COutput & out);
};

class CMoType;
class CMoInstance;


class  CMethodProperty : public CMoProperty
{
protected:
    enum ParamIDType {UNSPECIFIED, AUTOMATIC, MANUAL, INVALID};

public:
    BOOL IsValueProperty(){return FALSE;};
    CMethodProperty(CMoQualifierArray * paQualifiers, PDBG pDbg, BOOL bBinary);
    ~CMethodProperty();
    BOOL AddToObject(OLE_MODIFY IWbemClassObject* pObject, IWbemServices* pNamespace, BOOL bClass, IWbemContext * pCtx);
    BOOL AddArg(CValueProperty * pAdd){return m_Args.Add(pAdd);};
    CMoInstance * GetInObj(){return m_pInObj;};
    CMoInstance * GetOutObj(){return m_pOutObj;};
    BOOL AddToArgObjects(CMoQualifierArray * paQualifiers, WString & sName, CMoType & Type, BOOL bRetValue, 
                            int & ErrCtx, VARIANT * pVar, CMoValue & Value);
    void SetIn(CMoInstance * pIn){m_pInObj = pIn;};
    void SetOut(CMoInstance * pOut){m_pOutObj = pOut;};
    bool IsIDSpecified(CMoQualifierArray * paQualifiers);
    BOOL Split(COutput & out);
    BOOL IsDisplayable(COutput & out);


private:
    ParamIDType m_IDType;
    DWORD m_NextAutoID;
    BOOL AddIt(WString & sName, CMoType & Type, BOOL bInput, CMoQualifierArray * paQualifiers, 
        VARIANT * pVar, CMoValue & Value, BOOL bRetValue, BOOL bSecondPass);
    BOOL AddEmbeddedObject(OLE_MODIFY IWbemClassObject* pObject, IWbemServices* pNamespace, IWbemContext * pCtx);
    friend CMObject;
    friend CMoClass;
    CMoInstance * m_pInObj;
    CMoInstance * m_pOutObj;
    CPtrArray m_Args;
    PDBG m_pDbg;
	BOOL m_bBinaryMof;
};

//*****************************************************************************

class CMoType
{
protected:
    BOOL m_bIsRef;
    BOOL m_bIsEmbedding;
    BOOL m_bIsArray;
    LPWSTR m_wszTitle;
    PDBG m_pDbg;
    DELETE_ME CMoQualifier* CreateSyntax(READ_ONLY LPCWSTR wszSyntax);
public:
    CMoType(PDBG pDbg) : m_bIsRef(FALSE), m_bIsEmbedding(FALSE), m_bIsArray(FALSE), 
                m_wszTitle(NULL), m_pDbg(pDbg){}
    ~CMoType();

    HRESULT SetTitle(COPY LPCWSTR wszTitle);
    INTERNAL LPCWSTR GetTitle() {return m_wszTitle;}
    BOOL IsDefined() {return (m_wszTitle != NULL);}
    BOOL IsString() {return !wbem_wcsicmp(m_wszTitle, L"string");};

    void SetIsRef(BOOL bIsRef) {m_bIsRef = bIsRef;}
    BOOL IsRef() {return m_bIsRef;}

    void SetIsEmbedding(BOOL bIsEmbedding) {m_bIsEmbedding = bIsEmbedding;}
    BOOL IsEmbedding() {return m_bIsEmbedding;}

    void SetIsArray(BOOL bIsArray) {m_bIsArray = bIsArray;}
    BOOL IsArray() {return m_bIsArray;}

    VARTYPE GetCIMType();
    bool IsUnsupportedType();
    BOOL StoreIntoQualifiers(CMoQualifierArray * pQualifiers);
};

//*****************************************************************************

class CValueLocation
{
public:
    virtual ~CValueLocation(){}
    virtual HRESULT Set(READ_ONLY VARIANT& varValue,
                OLE_MODIFY IWbemClassObject* pObject) = 0;
protected:
    HRESULT SetArrayElement(
                MODIFY VARIANT& vArray,
                int nIndex,
                READ_ONLY VARIANT& vValue);
};

class CPropertyLocation : public CValueLocation
{
protected:
    LPWSTR m_wszName;
    int m_nArrayIndex;
    bool m_bOK;
public:
    CPropertyLocation(COPY LPCWSTR wszName, int nArrayIndex = -1);
    ~CPropertyLocation();
    virtual HRESULT Set(READ_ONLY VARIANT& varValue,
                OLE_MODIFY IWbemClassObject* pObject);
    bool IsOK(){return m_bOK;};
};

class CQualifierLocation : public CValueLocation
{
protected:
    LPWSTR m_wszName;
    LPWSTR m_wszPropName;
    int m_nArrayIndex;
    PDBG m_pDbg;
    bool m_bOK;
public:
    CQualifierLocation(COPY LPCWSTR wszName, PDBG pDbg, COPY LPCWSTR wszPropName = NULL,
                        int nArrayIndex = -1);
    ~CQualifierLocation();
    virtual HRESULT Set(READ_ONLY VARIANT& varValue,
                OLE_MODIFY IWbemClassObject* pObject);
    bool IsOK(){return m_bOK;};
};

//*****************************************************************************

class CMofAliasCollection
{
public:
    virtual INTERNAL LPCWSTR FindAliasee(READ_ONLY LPWSTR wszAlias) = 0;
};

//*****************************************************************************

class CMofParser;

class CMObject
{
protected:
    CMoQualifierArray* m_paQualifiers;
    CPtrArray m_aProperties; // CMoProperty*

    LPWSTR m_wszAlias;
    LPWSTR m_wszNamespace;
    long m_lDefClassFlags;
    long m_lDefInstanceFlags;
    BOOL m_bDone;
    IWbemClassObject * m_pWbemObj;

    LPWSTR m_wszFullPath;

    struct CAliasedValue
    {
        CValueLocation* pLocation;
        LPWSTR wszAlias;

        CAliasedValue(ACQUIRE CValueLocation* _pLocation,
            COPY LPCWSTR _wszAlias);

        ~CAliasedValue();
    };
    CPtrArray m_aAliased; // CAliasedValue*

    int m_nFirstLine;
    LPWSTR m_wFileName;
    int m_nLastLine;
    bool m_bParameter;
    bool m_bAmended;
    ParseState m_DataState;
    ParseState m_QualState;
    bool m_bDeflated;
    bool m_bOK;
public:
    CMObject();
    virtual ~CMObject();
    bool IsOK(){return m_bOK;};
    ParseState * GetDataState(){return &m_DataState;};
    ParseState * GetQualState(){return &m_QualState;};
	void SetQualState(ParseState * pNew){if(pNew)m_QualState = *pNew;};

    void SetWbemObject(IWbemClassObject *pObj){m_pWbemObj = pObj;};
    IWbemClassObject * GetWbemObject(){return m_pWbemObj;};

    BOOL IsDone(){return m_bDone;};
    void SetDone(){m_bDone = TRUE;};

    virtual INTERNAL LPCWSTR GetClassName() = 0;

    HRESULT SetNamespace(COPY LPCWSTR wszNamespace);
    void SetOtherDefaults(long lClass, long lInst)
        {m_lDefClassFlags = lClass;m_lDefInstanceFlags=lInst;return;};

    void SetFullPath(BSTR bstr);
    INTERNAL LPCWSTR GetNamespace() {return m_wszNamespace;}
    long GetClassFlags(void){return m_lDefClassFlags;};
    long GetInstanceFlags(void){return m_lDefInstanceFlags;};


    HRESULT SetAlias(COPY LPCWSTR wszAlias);
    INTERNAL LPCWSTR GetAlias() {return m_wszAlias;}

    INTERNAL LPCWSTR GetFullPath() {return m_wszFullPath;}

    int GetFirstLine() {return m_nFirstLine;}
    int GetLastLine() {return m_nLastLine;}
    WCHAR * GetFileName() {return m_wFileName;};
    HRESULT SetLineRange(int nFirstLine, int nLastLine, WCHAR * pFileName);

    BOOL AddProperty(ACQUIRE CMoProperty* pProperty);
    int GetNumProperties() {return m_aProperties.GetSize();}
    INTERNAL CMoProperty* GetProperty(int nIndex)
        {return (CMoProperty*)m_aProperties[nIndex];}
    CMoProperty* GetPropertyByName(WCHAR * pwcName);

    int GetNumAliasedValues();
    BOOL GetAliasedValue(
        IN int nIndex, 
        OUT INTERNAL LPWSTR& wszAlias);
    HRESULT AddAliasedValue(ACQUIRE CValueLocation* pLocation,
        COPY LPCWSTR wszAlias);

    void SetQualifiers(ACQUIRE CMoQualifierArray* pQualifiers);
    INTERNAL CMoQualifierArray* GetQualifiers() {return m_paQualifiers;}
    virtual BOOL IsInstance(){return FALSE;};
    virtual BOOL IsDelete(){return FALSE;};

public:
    virtual HRESULT CreateWbemObject(READ_ONLY IWbemServices* pNamespace,
         RELEASE_ME IWbemClassObject** ppObject, IWbemContext * pCtx) = 0;
    virtual BOOL ApplyToWbemObject(OLE_MODIFY IWbemClassObject* pObject,IWbemServices* pNamespace, IWbemContext * pCtx) = 0;
    virtual HRESULT StoreWbemObject(READ_ONLY IWbemClassObject* pObject,
        long lClassFlags, long lInstanceFlags,
        OLE_MODIFY IWbemServices* pNamespace, IWbemContext * pCtx,
        WCHAR * pUserName, WCHAR * pPassword, WCHAR * pAuthority) = 0;

    BOOL ResolveAliasedValue(
        IN int nIndex, READ_ONLY LPCWSTR wszPath,
        OLE_MODIFY IWbemClassObject* pObject);
    HRESULT ResolveAliasesInWbemObject(
        OLE_MODIFY IWbemClassObject* pObject,
        READ_ONLY CMofAliasCollection* pCollection);

    bool CheckIfAmended();
    void SetAmended(bool bVal){m_bAmended = bVal;};
    bool IsAmended(){return m_bAmended;};

    virtual BOOL Split(COutput & out);
    virtual void FreeWbemObjectIfPossible();
    virtual HRESULT Deflate(bool bDestruct);
    virtual HRESULT Reflate(CMofParser & Parser);

protected:
    BOOL ApplyToWbemObject(OLE_MODIFY IWbemClassObject* pObject,IWbemServices* pNamespace, BOOL bClass, IWbemContext * pCtx);
};


class CMoClass : public CMObject
{
protected:
    LPWSTR m_wszParentName;
    LPWSTR m_wszClassName;
    BOOL m_bUpdateOnly;
    PDBG m_pDbg;

public:
    CMoClass(COPY LPCWSTR wszParentName, COPY LPCWSTR wszClassName, PDBG pDbg,
               BOOL bUpdateOnly = FALSE);
    ~CMoClass();

    INTERNAL LPCWSTR GetParentName() {return m_wszParentName;}
    INTERNAL LPCWSTR GetClassName() {return m_wszClassName;}

    HRESULT CreateWbemObject(READ_ONLY IWbemServices* pNamespace, 
         RELEASE_ME IWbemClassObject** ppObject, IWbemContext * pCtx);

    BOOL ApplyToWbemObject(OLE_MODIFY IWbemClassObject* pObject,IWbemServices* pNamespace, IWbemContext * pCtx)
        {return CMObject::ApplyToWbemObject(pObject,pNamespace, TRUE, pCtx); /* class */ }

    HRESULT StoreWbemObject(READ_ONLY IWbemClassObject* pObject,
        long lClassFlags, long lInstanceFlags,
        OLE_MODIFY IWbemServices* pNamespace, IWbemContext * pCtx,
        WCHAR * pUserName, WCHAR * pPassword, WCHAR * pAuthority);
};

class CMoInstance : public CMObject
{
protected:
    LPWSTR m_wszClassName;
    PDBG m_pDbg;
public:
    CMoInstance(COPY LPCWSTR wszClassName, PDBG m_pDbg, bool bParameter = false);
    ~CMoInstance();
    BOOL IsInput();

    INTERNAL LPCWSTR GetClassName() {return m_wszClassName;}

    HRESULT CreateWbemObject(READ_ONLY IWbemServices* pNamespace, 
         RELEASE_ME IWbemClassObject** ppObject, IWbemContext * pCtx);

    BOOL ApplyToWbemObject(OLE_MODIFY IWbemClassObject* pObject,IWbemServices* pNamespace, IWbemContext * pCtx)
        {return CMObject::ApplyToWbemObject(pObject, pNamespace, FALSE, pCtx); /* instance */ }

    HRESULT StoreWbemObject(READ_ONLY IWbemClassObject* pObject,
        long lClassFlags, long lInstanceFlags,
        OLE_MODIFY IWbemServices* pNamespace, IWbemContext * pCtx,
        WCHAR * pUserName, WCHAR * pPassword, WCHAR * pAuthority);

    BOOL IsInstance(){return TRUE;};
};

class CMoActionPragma : public CMObject
{
protected:
    LPWSTR m_wszClassName;
    PDBG m_pDbg;
    BOOL m_bFail;       // if true, the failure of the delete will stop the compile
	BOOL m_bClass;
public:
    CMoActionPragma(COPY LPCWSTR wszClassName, PDBG m_pDbg, bool bFail, BOOL bClass);
    ~CMoActionPragma();

    INTERNAL LPCWSTR GetClassName() {return m_wszClassName;}

    HRESULT CreateWbemObject(READ_ONLY IWbemServices* pNamespace, 
        RELEASE_ME IWbemClassObject** ppObject, IWbemContext * pCtx){return S_OK;};

    BOOL ApplyToWbemObject(OLE_MODIFY IWbemClassObject* pObject,IWbemServices* pNamespace, IWbemContext * pCtx)
        {return TRUE;}

    HRESULT StoreWbemObject(READ_ONLY IWbemClassObject* pObject,
        long lClassFlags, long lInstanceFlags,
        OLE_MODIFY IWbemServices* pNamespace, IWbemContext * pCtx,
        WCHAR * pUserName, WCHAR * pPassword, WCHAR * pAuthority);

    BOOL IsInstance(){return FALSE;};
    BOOL IsDelete(){return TRUE;};
    BOOL Split(COutput & out);

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\mofcomp_dll\mofparse.h ===
/*++

Copyright (C) 1995-2001 Microsoft Corporation

Module Name:

    MOFPARSE.H

Abstract:

	Declarations for MOF Parser class.

History:

	a-raymcc    18-Oct-95   Created.
	a-raymcc    27-Jan-96   Reference & alias support.

--*/

#ifndef _MOFPARSE_H_
#define _MOFPARSE_H_

#include "wstring.h"
#include "parmdefs.h"
#include "moflex.h"
#include "mofprop.h"
#include "mofdata.h"
#include "bmof.h"
#include "bmofhelp.h"
#include "trace.h"

enum SCOPE_CHECK{IN_CLASS, IN_INSTANCE, IN_PROPERTY, IN_PARAM, IN_METHOD};

bool ValidFlags(bool bClass, long lFlags);

class CMofParser
{
    CMofLexer   m_Lexer;
    CMofData    m_Output;

	PDBG m_pDbg;
    LPWSTR m_wszNamespace;
    long m_lDefClassFlags;
    long m_lDefInstanceFlags;
    bool m_bAutoRecover;
    bool m_bNotBMOFCompatible;
    WCHAR * m_wszAmendment;
	bool m_bRemotePragmaPaths;
    bool m_bOK;
    int m_nToken;

    int m_nErrorContext;
    int m_nErrorLineNumber;
    TCHAR m_cFileName[MAX_PATH];
    PARSESTATE m_State;
    bool m_bDoScopeCheck;

    // Internal functions.
    // ===================


    // Nonterminal symbols from productions.
    // =====================================

public:
    void SetToDoScopeCheck(){m_bDoScopeCheck = true;};
    void SetToNotScopeCheck(){m_bDoScopeCheck = false;};

    void SetState(PARSESTATE state){m_State = state;};

    void NextToken(bool bDontAllowWhitespace = false) { m_nToken = m_Lexer.NextToken(bDontAllowWhitespace); }
    BOOL top_level_decl();        // stores in CMofData
    BOOL decl_type();             // stores in CMofData
    BOOL class_decl(ACQUIRE CMoQualifierArray* paAttrs, VARIANT * pValue, ParseState *pQualPosition);  // stores in CMofData
    BOOL class_def(ACQUIRE CMoQualifierArray* paAttrs, BSTR strClassName,
                    int nFirstLine, ParseState * pQualPosition, VARIANT * pValue); 
    BOOL instance_decl(ACQUIRE CMoQualifierArray* paAttrs, VARIANT * pValue, ParseState * QualPosition = NULL);// stores in CMofData

    BOOL qualifier_decl(OUT CMoQualifierArray& aAttrs, bool bTopLevel, QUALSCOPE qs);

    BOOL type(OUT CMoType& Type);                           
    BOOL opt_parent_class(OUT BSTR* pstrParentName);            
    BOOL property_decl_list(MODIFY CMObject* pObject);

    BOOL as_alias(OUT LPWSTR& wszAlias);
    BOOL prop_init_list(MODIFY CMObject* pObject);
    BOOL prop_init(OUT CMoProperty& Prop);

    BOOL alias(OUT LPWSTR& wszAlias);
    BOOL PropOrMeth_decl(OUT CMoProperty **ppProp);              
    BOOL PropOrMeth_decl2(OUT CMoProperty **ppProp, CMoQualifierArray * paQualifiers);
    BOOL finish_PropOrMeth(CMoType & Type, WString & sName, CMoProperty ** ppProp, CMoQualifierArray * paQualifiers);
    BOOL finish_prop(CMoType & Type, WString & sName, CMoProperty ** ppProp, CMoQualifierArray * paQualifiers);
    BOOL finish_meth(CMoType & Type, WString & sName, CMoProperty ** ppProp, CMoQualifierArray * paQualifiers);
    BOOL TypeAndName(MODIFY CMoType& Type, WString & sName);

    BOOL arg_list(CMethodProperty * pMethProp);
    BOOL arg_decl(CMethodProperty * pMethProp);
    BOOL rest_of_args(CMethodProperty * pMethProp);

    BOOL opt_ref(MODIFY CMoType& Type);                  
    BOOL opt_array(MODIFY CMoType& Type, CMoQualifierArray * paQualifiers);
    BOOL opt_array_detail(MODIFY CMoType& Type, CMoQualifierArray * paQualifiers); 
    BOOL default_value(READ_ONLY CMoType& Type, OUT CMoValue& Value);              
    BOOL initializer(MODIFY CMoType& Type, OUT CMoValue& Value);

    BOOL qualifier_list(OUT CMoQualifierArray& aAttrs, bool bTopLevel, QUALSCOPE qs);
    BOOL qualifier(OUT CMoQualifier& Attr, bool bTopLevel, QUALSCOPE qs);                     
    BOOL qualifier_list_rest(MODIFY CMoQualifierArray& aAttrs, bool bTopLevel, QUALSCOPE qs);
    BOOL qualifier_parm(OUT CMoQualifier& Attr, bool bTopLevel, QUALSCOPE qs);
    BOOL qualifier_initializer_list(OUT CMoValue& Value);

    BOOL const_value(MODIFY CMoType& Type, OUT VARIANT& varValue, bool bQualifier);

    BOOL simple_initializer(MODIFY CMoType& Type, OUT CMoValue& Value, bool bQualifier);         
    BOOL initializer_list(MODIFY CMoType& Type, OUT CMoValue& Value, bool bQualifier);

    BOOL preprocessor_command();    // executes
    BOOL pound_include();           // executes
    BOOL pound_define();            // executes
    BOOL pound_pragma();            // executes
	bool flag_list(bool bClass);
	bool string_list(bool bClass, long & lNewValue);
	bool GetFlagValue(long & lNewValue);

    BOOL typedef_(ACQUIRE CMoQualifierArray* paAttrs);
    BOOL complete_type();
    BOOL enum_();
    BOOL enum_data();
    BOOL enum_data_rest();
    BOOL int_enum_data_rest();
    BOOL int_enum_datum();
    BOOL string_enum_data_rest();
    BOOL string_enum_datum();
    BOOL opt_name();
    BOOL opt_subrange();
    BOOL const_int();
    BOOL const_string();
    BOOL const_char();
	BOOL flavor_param(OUT CMoQualifier& Qual, bool bDefaultQual);
	BOOL flavor_list(OUT CMoQualifier& Qual);
	BOOL flavor_list_rest(CMoQualifier& Qual);
	BOOL def_flavor_list(OUT CMoQualifier& Qual);
	BOOL def_flavor_list_rest(CMoQualifier& Qual);
	BOOL flavor_value(CMoQualifier& Qual);
    bool sys_or_regular();

    BOOL qualifier_default();
    BOOL finish_qualifier_default(CMoQualifier& Qual);
    BOOL finish_qualifier_end(CMoQualifier& Qual);
	BOOL scope_list(OUT CMoQualifier& Qual);
	BOOL scope_list_rest(CMoQualifier& Qual);
	BOOL scope_value(CMoQualifier& Qual);

    BOOL FailOrNoFail(bool * pbFail);
    CMofParser(const TCHAR *pFilename, PDBG pdbg);
    CMofParser(PDBG pdbg);

   ~CMofParser();  
   HRESULT SetBuffer(char *pMemory, DWORD dwMemSize){return m_Lexer.SetBuffer(pMemory, dwMemSize);};
    PDBG GetDbg(){return m_pDbg;};

   HRESULT SetDefaultNamespace(LPCWSTR wszDefault);
    void SetOtherDefaults(long lClass, long lInst, bool bAutoRecover){m_lDefClassFlags = lClass;m_lDefInstanceFlags=lInst;
                m_bAutoRecover = bAutoRecover; return;};
    long GetClassFlags(void){return m_lDefClassFlags;};
    long GetInstanceFlags(void){return m_lDefInstanceFlags;};
    bool GetAutoRecover(void){return m_bAutoRecover;};
    HRESULT SetAmendment(LPCWSTR wszDefault);
    WCHAR * GetAmendment(void){return m_wszAmendment;};
    bool GetRemotePragmaPaths(void){return m_bRemotePragmaPaths;};
    BOOL Parse(); 
    bool GetErrorInfo(TCHAR *pBuffer, DWORD dwBufSize, 
        int *pLineNumber, int *pColumn,	int *pError, LPWSTR * pErrorFile);   
	TCHAR * GetFileName(){return m_cFileName;};
	TCHAR * GetAutoRecoverFileName(){return m_Lexer.GetFileName();};
    INTERNAL CMofData *AccessOutput() { return &m_Output; }
	BOOL IsUnicode(){return m_Lexer.IsUnicode();};
    bool IsntBMOFCompatible(){return m_bNotBMOFCompatible;};
    void SetParserPosition(ParseState * pPos){m_Lexer.SetLexPosition(pPos); m_nToken = pPos->m_nToken;};
    void GetParserPosition(ParseState * pPos){m_Lexer.GetLexPosition(pPos); pPos->m_nToken = m_nToken;};
    BOOL CheckScopes(SCOPE_CHECK scope_check, CMoQualifierArray* paQualifiers, CMoProperty * pProperty);
    BOOL IsBMOF(){ return m_Lexer.IsBMOF(); };

};



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\mofcomp_dll\mofparse.cpp ===
/*++

Copyright (C) 1995-2001 Microsoft Corporation

Module Name:

    MOFPARSE.CPP

Abstract:

	This is a recursive descent parser for the MOF syntax.
	It is based on the MOF.BNF file which defines the LL(1) MOF grammar.
	In each production, nonterminals are represented by functions
	with the same name.

	NOTES:
	(a) The lexer is implemented by class CMofLexer.
	(b) Right-recursion in the grammar is consistently implemented
	  directly as a loop for that nonterminal.

	OUTPUT:
	Output is an unchecked list of classes and instances.
	This is contained in the CMofData object.

	Verification of output is done elsewhere, depending on the
	compile context.

History:

	a-raymcc    18-Oct-95   created.
	a-raymcc    25-Oct-95   semantic stack operational
	a-raymcc    27-Jan-96   reference & alias support
	a-levn      18-Oct-96   Rewrote not to use semantic stack.
						  Converted to new mof syntax and new 
						  WINMGMT interfaces.

--*/

#include "precomp.h"
#include <stdio.h>
#include <float.h>
#include "mofout.h"
#include <mofparse.h>
#include <moflex.h>
#include <mofdata.h>
#include <typehelp.h>

#include <io.h>
#include <fcntl.h>
#include <stdio.h>
#include <sys/stat.h>

#include "bmofhelp.h"
#include "trace.h"
#include "strings.h"
#include "moflex.h"
#include <wbemutil.h>
#include <genutils.h>
#include <arrtempl.h>
#include <autoptr.h>

//***************************************************************************
//
//  Global defs
//
//***************************************************************************

static BOOL KnownBoolQualifier(wchar_t *pIdent, DWORD *pdwQualifierVal);


//***************************************************************************
//
//  Useful macros.
//
//***************************************************************************

#define CHECK(tok)  \
    if (m_nToken != tok) return FALSE;  \
    NextToken();

//***************************************************************************
//
//  ValidFlags.
//
//***************************************************************************

bool ValidFlags(bool bClass, long lFlags)
{
	if(bClass)
		return  ((lFlags == WBEM_FLAG_CREATE_OR_UPDATE) ||
			 (lFlags == WBEM_FLAG_UPDATE_ONLY) ||
			 (lFlags == WBEM_FLAG_CREATE_ONLY) ||
			 (lFlags == WBEM_FLAG_UPDATE_SAFE_MODE) ||
			 (lFlags == WBEM_FLAG_UPDATE_FORCE_MODE) ||
			 (lFlags == (WBEM_FLAG_UPDATE_ONLY | WBEM_FLAG_UPDATE_SAFE_MODE)) ||
			 (lFlags == (WBEM_FLAG_UPDATE_ONLY | WBEM_FLAG_UPDATE_FORCE_MODE)));
	else
		return 
		((lFlags == WBEM_FLAG_CREATE_OR_UPDATE) ||
			 (lFlags == WBEM_FLAG_UPDATE_ONLY) ||
			 (lFlags == WBEM_FLAG_CREATE_ONLY));
}

//***************************************************************************
//
//***************************************************************************

CMofParser::CMofParser(const TCHAR *pFileName, PDBG pDbg)
    : m_Lexer(pFileName, pDbg), m_Output(pDbg)
{
    m_nToken = 0;
    m_bOK = true;
	m_pDbg = pDbg;
    m_nErrorContext = 0;
    m_nErrorLineNumber = 0;
    StringCchCopyW(m_cFileName, MAX_PATH, pFileName);
    m_wszNamespace = Macro_CloneStr(L"root\\default");
    if(m_wszNamespace == NULL)
        m_bOK = false;
    m_bAutoRecover = false;
    m_wszAmendment = NULL;
	m_bRemotePragmaPaths = false;
    m_bNotBMOFCompatible = false;
    m_State = INITIAL;
    m_bDoScopeCheck = true;
}

//***************************************************************************
//
//***************************************************************************

CMofParser::CMofParser(PDBG pDbg
    )
    : m_Lexer(pDbg), m_Output(pDbg)
{
    m_bOK = true;
    m_nToken = 0;
    m_nErrorContext = 0;
	m_pDbg = pDbg;
    m_nErrorLineNumber = 0;
    m_bAutoRecover = false;
	m_bRemotePragmaPaths = false;
    m_wszAmendment = NULL;
    m_cFileName[0] = 0;
    m_bNotBMOFCompatible = false;
    m_wszNamespace = Macro_CloneStr(L"root\\default");
    if(m_wszNamespace == NULL)
        m_bOK = false;
    m_State = INITIAL;
    m_bDoScopeCheck = true;
}

//***************************************************************************
//
//***************************************************************************

CMofParser::~CMofParser()
{
    delete [] m_wszNamespace;
    delete [] m_wszAmendment;
}

//***************************************************************************
//
//***************************************************************************

HRESULT CMofParser::SetDefaultNamespace(LPCWSTR wszDefault)
{
    delete [] m_wszNamespace;
    m_wszNamespace = Macro_CloneStr(wszDefault);
    if(m_wszNamespace == NULL && wszDefault != NULL)
        return WBEM_E_OUT_OF_MEMORY;
    else
         return S_OK;
}

HRESULT CMofParser::SetAmendment(LPCWSTR wszDefault)
{
    delete [] m_wszAmendment;
    m_wszAmendment = Macro_CloneStr(wszDefault);
    if(m_wszAmendment == NULL && wszDefault != NULL)
        return WBEM_E_OUT_OF_MEMORY;
    else
         return S_OK;
}


//***************************************************************************
//
//***************************************************************************

bool CMofParser::GetErrorInfo(
    TCHAR *pBuffer,
    DWORD dwBufSize,
    int *pLineNumber,
    int *pColumn,
	int *pError,
    LPWSTR * pErrorFile
    )
{
    if(m_Lexer.IsBMOF())
        return false;
    if (pLineNumber)
        *pLineNumber = m_Lexer.GetLineNumber();
    if (pColumn)
        *pColumn = m_Lexer.GetColumn();
    if (pError)
        *pError = m_nErrorContext;

    TCHAR *pErrText = TEXT("Undefined error");

    IntString Err(m_nErrorContext);
    if(lstrlen(Err) > 0)
        pErrText = Err;
    StringCchCopy(pBuffer, dwBufSize, pErrText);
    *pErrorFile = m_Lexer.GetErrorFile();
    return true;
}


//***************************************************************************
//
//  <Parse> ::= <top_level_decl><Parse>
//  <Parse> ::= <preprocessor_command><Parse>
//  <Parse> ::= <>
//
//***************************************************************************
// v1.10

BOOL CMofParser::Parse()
{

    if(m_bOK == false)
    {
        m_nErrorContext = WBEM_E_OUT_OF_MEMORY;
        return FALSE;
    }
    
    // Check for the special case of the binary mof file.  If it is so, 
    // dont parse, instead get the classes, attributes and props
    // from the file

    if(m_Lexer.IsBMOF())
    {
		return ConvertBufferIntoIntermediateForm(&m_Output,m_Lexer.GetBuff(), m_pDbg,
			m_Lexer.GetToFar());
    }


    if(m_Lexer.GetError() != 0)
    {
        if(CMofLexer::problem_creating_temp_file == m_Lexer.GetError())
            m_nErrorContext = WBEMMOF_E_ERROR_CREATING_TEMP_FILE;
        else if(CMofLexer::invalid_include_file == m_Lexer.GetError())
            m_nErrorContext = WBEMMOF_E_ERROR_INVALID_INCLUDE_FILE;
        else
            m_nErrorContext = WBEMMOF_E_INVALID_FILE;
        return FALSE;
    }

    NextToken();

    BOOL bEnd = FALSE;
    while(!bEnd)
    {
        switch(m_nToken)
        {
            case TOK_POUND:
                if(!preprocessor_command()) 
                    return FALSE;
                break;
            
            case TOK_QUALIFIER:
                if(!qualifier_default())
                    return FALSE;
                break;

            case 0: // nothing left to parse
                bEnd = TRUE;
                break;
            default:
                if (!top_level_decl())
                    return FALSE;
                break;
        }
    }

    return TRUE;
}

//***************************************************************************
//
//  <preprocessor_command> ::= <pound_define>  // not impl
//  <preprocessor_command> ::= TOK_PRAGMA <pound_pragma>
//  <preprocessor_command> ::= TOK_LINE TOK_UNSIGNED_NUMERIC_CONST TOK_LPWSTR
//
//***************************************************************************

BOOL CMofParser::preprocessor_command()
{
    NextToken();
    DWORD dwType = m_nToken;
    if(dwType == TOK_SIMPLE_IDENT && !wbem_wcsicmp(L"line", m_Lexer.GetText()))
        dwType = TOK_LINE;
   
    switch(dwType)
    {
        case TOK_PRAGMA:
            if(!pound_pragma())
                return FALSE;
            break;
        case TOK_LINE:
            NextToken();
            if(m_nToken != TOK_UNSIGNED64_NUMERIC_CONST)
                return false;
            m_Lexer.SetLineNumber((int)m_Lexer.GetLastInt());
            NextToken();
            if(m_nToken != TOK_LPWSTR)
                return false;
            m_Lexer.SetErrorFile(m_Lexer.GetText());
            NextToken();
            return TRUE;
        case TOK_INCLUDE:
        case TOK_DEFINE:
            Trace(true, m_pDbg, PREPROCESSOR);
            return FALSE;
    }
    return TRUE;
}

//***************************************************************************
//
//  <FailOrNoFail> ::= FAIL;
//  <FailOrNoFail> ::= NOFAIL;
//
//***************************************************************************

BOOL CMofParser::FailOrNoFail(bool * pbFail)
{
    NextToken();
    if(m_nToken == TOK_FAIL)
        *pbFail = true;
    else if(m_nToken == TOK_NOFAIL)
        *pbFail = false;
    else return FALSE;
    return TRUE;
}

//***************************************************************************
//
//<pound_pragma> ::= TOK_LPWSTR             // Where string is "namespace"
//                    TOK_OPEN_PAREN TOK_LPWSTR TOK_CLOSE_PAREN;
//
//<pound_pragma> ::= TOK_AMENDMENT 
//                    TOK_OPEN_PAREN TOK_LPWSTR TOK_CLOSE_PAREN;
//
//<pound_pragma> ::= TOK_CLASSFLAGS  
//                    TOK_OPEN_PAREN <flag_list> TOK_CLOSE_PAREN;
//
//<pound_pragma> ::= TOK_INSTANCEFLAGS 
//                    TOK_OPEN_PAREN <flag_list> TOK_CLOSE_PAREN;
//
//<pound_pragma> ::= TOK_AUTORECOVER 
//
//<pound_pragma> ::= TOK_DELETECLASS 
//                    TOK_OPEN_PAREN TOK_LPWSTR TOK_COMMA <FailOrNoFail>  TOK_CLOSE_PAREN;
//
//***************************************************************************

BOOL CMofParser::pound_pragma()
{
    NextToken();

    DWORD dwType = m_nToken;

    if(dwType == TOK_AUTORECOVER)
    {
        m_bAutoRecover = true;
        NextToken();
        return TRUE;
    }

    if(dwType == TOK_SIMPLE_IDENT && !wbem_wcsicmp(L"locale", m_Lexer.GetText()))
    {
        dwType = TOK_LOCALE;
        ERRORTRACE((LOG_MOFCOMP,"Warning, unsupported LOCALE pragma\n"));
    }

    if(dwType == TOK_SIMPLE_IDENT && !wbem_wcsicmp(L"INSTANCELOCALE", m_Lexer.GetText()))
    {
        dwType = TOK_INSTANCELOCALE;
        ERRORTRACE((LOG_MOFCOMP,"Warning, unsupported INSTANCELOCALE pragma\n"));
    }

    if(dwType == TOK_SIMPLE_IDENT && !wbem_wcsicmp(L"NONLOCAL", m_Lexer.GetText()))
    {
        dwType = TOK_NONLOCAL;
        ERRORTRACE((LOG_MOFCOMP,"Warning, unsupported NONLOCAL pragma\n"));
    }

    if(dwType == TOK_SIMPLE_IDENT && !wbem_wcsicmp(L"NONLOCALTYPE", m_Lexer.GetText()))
    {
        dwType = TOK_NONLOCALTYPE;
        ERRORTRACE((LOG_MOFCOMP,"Warning, unsupported NONLOCALTYPE pragma\n"));
    }

    if(dwType == TOK_SIMPLE_IDENT && !wbem_wcsicmp(L"SOURCE", m_Lexer.GetText()))
    {
        dwType = TOK_SOURCE;
        ERRORTRACE((LOG_MOFCOMP,"Warning, unsupported SOURCE pragma\n"));
    }

    if(dwType == TOK_SIMPLE_IDENT && !wbem_wcsicmp(L"SOURCETYPE", m_Lexer.GetText()))
    {
        dwType = TOK_SOURCETYPE;
        ERRORTRACE((LOG_MOFCOMP,"Warning, unsupported SOURCETYPE pragma\n"));
    }


    if(dwType == TOK_SIMPLE_IDENT && !wbem_wcsicmp(L"namespace", m_Lexer.GetText()))
        dwType = TOK_NAMESPACE;
    if(dwType == TOK_SIMPLE_IDENT && !wbem_wcsicmp(L"deleteinstance", m_Lexer.GetText()))
        dwType = TOK_DELETEINSTANCE;
    if(dwType != TOK_NAMESPACE && dwType != TOK_INSTANCEFLAGS && dwType != TOK_CLASSFLAGS && 
        dwType != TOK_AMENDMENT && dwType != TOK_DELETECLASS && dwType != TOK_DELETEINSTANCE &&
        dwType != TOK_LOCALE && dwType != TOK_INSTANCELOCALE && dwType != TOK_NONLOCAL &&
        dwType != TOK_NONLOCALTYPE && dwType != TOK_SOURCE && dwType !=  TOK_SOURCETYPE)
    {
        m_nErrorContext = WBEMMOF_E_INVALID_PRAGMA;
        return FALSE;
    }

    m_nErrorContext = WBEMMOF_E_EXPECTED_OPEN_PAREN;
    NextToken();
    CHECK(TOK_OPEN_PAREN);


    LPWSTR wszNewNamespace;
    BOOL bRet = FALSE;
    WCHAR * pClassName;
	WCHAR *pMachine;
    BOOL bClass;
    switch(dwType)
    {
    case TOK_CLASSFLAGS:
    case TOK_INSTANCEFLAGS:
		if(!flag_list(dwType ==TOK_CLASSFLAGS))
			return FALSE;
		break;

    case TOK_AMENDMENT:
        m_nErrorContext = WBEMMOF_E_INVALID_AMENDMENT_SYNTAX;
        if(m_nToken != TOK_LPWSTR) return FALSE;

        if(m_wszAmendment)
        {
            m_nErrorContext = WBEMMOF_E_INVALID_DUPLICATE_AMENDMENT;
            return FALSE;
        }
        m_wszAmendment = Macro_CloneStr((LPWSTR)m_Lexer.GetText());
        if(m_wszAmendment == NULL && (LPWSTR)m_Lexer.GetText() != NULL)
        {
            m_nErrorContext = WBEM_E_OUT_OF_MEMORY;
            return FALSE;
        }
        break;

    case TOK_DELETEINSTANCE:
    case TOK_DELETECLASS:
        if(TOK_DELETECLASS == dwType)
        {
            bClass = TRUE;
            m_nErrorContext = WBEMMOF_E_INVALID_DELETECLASS_SYNTAX;
        }
        else
        {
            bClass = FALSE;
            m_nErrorContext = WBEMMOF_E_INVALID_DELETEINSTANCE_SYNTAX;
        }

        m_bNotBMOFCompatible = true;
        if(m_nToken != TOK_LPWSTR) 
            return FALSE;
        pClassName = Macro_CloneStr((LPWSTR)m_Lexer.GetText());
        if(pClassName == NULL)
            return FALSE;
        if(wcslen(pClassName) >= 1)
        {
            bool bFail;
            NextToken();
            if(m_nToken == TOK_COMMA)
                if(FailOrNoFail(&bFail))
                {
                    wmilib::auto_ptr<CMoActionPragma> pObject(new CMoActionPragma(pClassName, m_pDbg, bFail, bClass));
                    if(pObject.get() == NULL)
                    {
                        m_nErrorContext = WBEM_E_OUT_OF_MEMORY;
                        return FALSE;
                    }
                    if(pObject->IsOK() == false)
                    {
                        m_nErrorContext = WBEM_E_OUT_OF_MEMORY;
                        return FALSE;
                    }
                    
                    HRESULT hr2 = pObject->SetNamespace(m_wszNamespace);
                    if(FAILED(hr2))
                    {
                        m_nErrorContext = hr2;
                        return FALSE;
                    }
                    pObject->SetOtherDefaults(GetClassFlags(), GetInstanceFlags());
                    m_Output.AddObject(pObject.get());
                    pObject.release();
                    bRet = TRUE;
                }
        }
      
        delete pClassName;
        if(bRet == FALSE)
            return FALSE;
        break;

    case TOK_NAMESPACE:
        m_nErrorContext = WBEMMOF_E_INVALID_NAMESPACE_SYNTAX;
        if(m_nToken != TOK_LPWSTR) return FALSE;
        wszNewNamespace = (LPWSTR)m_Lexer.GetText();
		
		pMachine = ExtractMachineName(wszNewNamespace);
		if(pMachine)
		{
			if(!bAreWeLocal(pMachine))
				m_bRemotePragmaPaths = true;
			delete [] pMachine;
		}
        if(wszNewNamespace[0] == L'\\' || wszNewNamespace[0] == L'/')
        {
            if(wszNewNamespace[1] == L'\\' || wszNewNamespace[1] == L'/')
            {

            }
            else
            {
            // Cut off the slash
            // =================

                wszNewNamespace += 1;
            }

            delete [] m_wszNamespace;
            m_wszNamespace = Macro_CloneStr(wszNewNamespace);
            if(m_wszNamespace == NULL && wszNewNamespace != NULL)
            {
                m_nErrorContext = WBEM_E_OUT_OF_MEMORY;
                return FALSE;
            }

        }
        else
        {
            // Append to the old value
            // =======================

            DWORD dwLen =  wcslen(m_wszNamespace) + 2 + 
                                        wcslen(wszNewNamespace);
            LPWSTR wszFullNamespace = new WCHAR[dwLen];
            if(wszFullNamespace == NULL)
            {
                m_nErrorContext = WBEM_E_OUT_OF_MEMORY;
                return FALSE;
            }
            StringCchPrintfW(wszFullNamespace, dwLen, L"%s\\%s", m_wszNamespace, wszNewNamespace);

            delete [] m_wszNamespace;
            m_wszNamespace = wszFullNamespace;
        }
        break;

    }

    if(dwType != TOK_CLASSFLAGS && dwType != TOK_INSTANCEFLAGS)
		NextToken();

    m_nErrorContext = WBEMMOF_E_EXPECTED_CLOSE_PAREN;
    CHECK(TOK_CLOSE_PAREN);

    return TRUE;
}

//***************************************************************************
//
//  <flag_list> ::= TOK_LPWSTR <string_list_rest>;
//  <flag_list> ::= TOK_UNSIGNED_NUMERIC_CONST;
//  <flag_list> ::= <>;
//
//***************************************************************************

bool CMofParser::GetFlagValue(long & lNewValue)
{
	if(!wbem_wcsicmp(L"createonly", (LPWSTR)m_Lexer.GetText()))
		lNewValue |= WBEM_FLAG_CREATE_ONLY;
	else if(!wbem_wcsicmp(L"updateonly", (LPWSTR)m_Lexer.GetText()))
		lNewValue |= WBEM_FLAG_UPDATE_ONLY;
	else if(!wbem_wcsicmp(L"safeupdate", (LPWSTR)m_Lexer.GetText()))
		lNewValue |= WBEM_FLAG_UPDATE_SAFE_MODE;
	else if(!wbem_wcsicmp(L"forceupdate", (LPWSTR)m_Lexer.GetText()))
		lNewValue |= WBEM_FLAG_UPDATE_FORCE_MODE;
	else
		return false;
	return true;
}

bool CMofParser::flag_list(bool bClass)
{
	long lNewValue = 0;
    m_nErrorContext = WBEMMOF_E_INVALID_FLAGS_SYNTAX;

	if(m_nToken == TOK_UNSIGNED64_NUMERIC_CONST)
	{
		lNewValue = _wtol(m_Lexer.GetText());
		NextToken();
	}
	else if (m_nToken == TOK_CLOSE_PAREN)
		lNewValue = 0;
	else if (m_nToken == TOK_LPWSTR)
	{
		if(!GetFlagValue(lNewValue))
			return false;
		NextToken();
		if(!string_list(bClass, lNewValue))
			return false;
		if(!ValidFlags(bClass, lNewValue))
			return false;
	}
	else
		return false;


	if(bClass)
		m_lDefClassFlags = lNewValue;
	else
		m_lDefInstanceFlags = lNewValue;
	return true;
}

//***************************************************************************
//
//  <string_list> ::= <>;
//  <string_list> ::= TOK_COMMA TOK_LPWSTR <string_list>;
//
//***************************************************************************

bool CMofParser::string_list(bool bClass, long & lNewValue)
{
	if (m_nToken == TOK_COMMA)
	{
		NextToken();
		if (m_nToken != TOK_LPWSTR)
			return false;
		if(!GetFlagValue(lNewValue))
			return false;

		NextToken();
		return string_list(bClass, lNewValue);
	}

	return true;
}

//***************************************************************************
//
//  <top_level_decl> ::= <qualifier_decl> <decl_type>
//
//  Note: <decl_type> is implicit in the switch() statement.
//
//***************************************************************************
// 1.10

BOOL CMofParser::top_level_decl()
{
    std::auto_ptr<CMoQualifierArray> paQualifiers(new CMoQualifierArray(m_pDbg));
	ParseState QualPosition;
	GetParserPosition(&QualPosition);
    if (paQualifiers.get() == NULL || !qualifier_decl(*(paQualifiers.get()), true, CLASSINST_SCOPE))
    {
        return FALSE;
    }
    // Branch to the correct top-level declaration.
    // =============================================

    switch (m_nToken) {
        case TOK_CLASS:
        {
            if(m_bDoScopeCheck && (FALSE == CheckScopes(IN_CLASS, paQualifiers.get(), NULL))){
                return FALSE;
            }

            paQualifiers.release();
            if(!class_decl(paQualifiers.get(), NULL, &QualPosition))
                return FALSE;

            m_nErrorContext = WBEMMOF_E_EXPECTED_SEMI;
			if(m_nToken != TOK_SEMI)
				return FALSE;
			NextToken();

            return TRUE;
        }

        case TOK_INSTANCE:
        {
            if(m_bDoScopeCheck && (FALSE == CheckScopes(IN_INSTANCE, paQualifiers.get(), NULL))){
                return FALSE;
            }

            paQualifiers.release();
            if(!instance_decl(paQualifiers.get(), NULL, &QualPosition))
                return FALSE;

            m_nErrorContext = WBEMMOF_E_EXPECTED_SEMI;
			if(m_nToken != TOK_SEMI)
				return FALSE;
			NextToken();
            return TRUE;
        }
        case TOK_TYPEDEF:
            return typedef_(paQualifiers.get());
        default:
            m_nErrorContext = WBEMMOF_E_UNRECOGNIZED_TOKEN;
        // Syntax error
    }

    return FALSE;
}

//***************************************************************************
//
//  <typedef> ::=  see BNF. Not supported.
//
//***************************************************************************

BOOL CMofParser::typedef_(ACQUIRE CMoQualifierArray* paQualifiers)
{
    m_nErrorContext = WBEMMOF_E_TYPEDEF_NOT_SUPPORTED;

    Trace(true, m_pDbg, NO_TYPEDEFS);
    return FALSE;
}

//***************************************************************************
//
//  <class_decl> ::=
//      TOK_CLASS
//      TOK_SIMPLE_IDENT
//      <class_def>
//
//  Adds the resulting class to the member CMofData
//
//***************************************************************************
// v1.10

BOOL CMofParser::class_decl(ACQUIRE CMoQualifierArray* paQualifiers, VARIANT * pValue, ParseState * pQualPosition)
{
    BSTR strClassName;

    // Begin syntax check.
    // ===================

    m_nErrorContext = WBEMMOF_E_INVALID_CLASS_DECLARATION;
    int nFirstLine = m_Lexer.GetLineNumber();

    if (m_nToken != TOK_CLASS)
    {
        delete paQualifiers;
        return FALSE;
    }
    NextToken();

    // Get the class name.
    // ====================

    if (m_nToken != TOK_SIMPLE_IDENT)
    {
        m_nErrorContext = WBEMMOF_E_EXPECTED_CLASS_NAME;
        delete paQualifiers;
        return FALSE;
    }

    strClassName = SysAllocString((LPWSTR)m_Lexer.GetText());
    if(strClassName == NULL)
    {
        m_nErrorContext = WBEM_E_OUT_OF_MEMORY;
        return FALSE;
    }

    // This finishes up and does the necessary freeing

    return class_def(paQualifiers, strClassName, nFirstLine, pQualPosition, pValue);
    
}


//***************************************************************************
//
//  <class_def> ::=;
//  <class_def> ::=
//      <as_alias>
//      <opt_parent_class>
//      TOK_OPEN_BRACE
//      <property_decl_list>
//      TOK_CLOSE_BRACE;
//
//  Adds the resulting class to the member CMofData
//
//***************************************************************************
// v1.10

BOOL CMofParser::class_def(ACQUIRE CMoQualifierArray* paQualifiers, 
                           BSTR strClassName, int nFirstLine, ParseState * pQualPosition,
						   VARIANT * pVar)
{
    BOOL bRetVal = FALSE;       // Default
    BSTR strParentName = NULL;
    LPWSTR wszAlias = NULL;

    // Begin syntax check.
    // ===================

    NextToken();

    // Check for the case where its just a semi.  That would be the case
    // where the entire line was [qual] class myclass;

    if(m_nToken == TOK_SEMI)
    {
        CMoClass* pObject = new CMoClass(strParentName, strClassName, m_pDbg, TRUE);
        if(pObject == NULL)
            return FALSE;
        if(pObject->IsOK() == false)
        {
            m_nErrorContext = WBEM_E_OUT_OF_MEMORY;
            delete pObject;
            return FALSE;
        }
        HRESULT hr2 = pObject->SetNamespace(m_wszNamespace);
        if(FAILED(hr2))
        {
            m_nErrorContext = hr2;
            delete pObject;
            return FALSE;
        }
        
        pObject->SetOtherDefaults(GetClassFlags(), GetInstanceFlags());

        SysFreeString(strClassName);

        // Apply qualifiers (already parsed)
        // =================================

        pObject->SetQualifiers(paQualifiers);

        m_Output.AddObject(pObject);
        return TRUE;
    }
    
    // Get the alias (if any)
    // ======================

    if(!as_alias(wszAlias))
    {
        delete paQualifiers;
        SysFreeString(strClassName);
        return FALSE;
    }


    // Get the parent type name, if there is one.
    // ===========================================
                                    
    if (!opt_parent_class(&strParentName))
    {
        SysFreeString(strClassName);
        delete paQualifiers;
        return FALSE;
    }

    // Check for the open brace.
    // =========================

    if (m_nToken != TOK_OPEN_BRACE)
    {
        m_nErrorContext = WBEMMOF_E_EXPECTED_OPEN_BRACE;

        SysFreeString(strClassName);
        SysFreeString(strParentName);
        delete paQualifiers;
        return FALSE;
    }


    // Create new object
    // =================

    CMoClass* pObject = new CMoClass(strParentName, strClassName, m_pDbg);
    if(pObject == NULL)
        return FALSE;
    if(pObject->IsOK() == false)
    {
        delete pObject;
        return FALSE;
    }

    GetParserPosition(pObject->GetDataState());
	if(pQualPosition)
		pObject->SetQualState(pQualPosition);
    NextToken();
    HRESULT hr2 = pObject->SetNamespace(m_wszNamespace);
    if(FAILED(hr2))
    {
        m_nErrorContext = hr2;
        return FALSE;
    }
    
    pObject->SetOtherDefaults(GetClassFlags(), GetInstanceFlags());

    SysFreeString(strClassName);
    SysFreeString(strParentName);

    // Apply qualifiers (already parsed)
    // =================================

    pObject->SetQualifiers(paQualifiers);

    // Set alias
    // =========

    if(wszAlias != NULL)
    {
        HRESULT hr2 = pObject->SetAlias(wszAlias);
        delete [] wszAlias;
        if(FAILED(hr2))
        {
            m_nErrorContext = hr2;
            goto Exit;
        }
    }

    // Now get the list properties.
    // ============================


    if (!property_decl_list(pObject))
        goto Exit;

    // Final close brace and semicolon.
    // ================================
    m_nErrorContext = WBEMMOF_E_EXPECTED_BRACE_OR_BAD_TYPE;

    if (m_nToken != TOK_CLOSE_BRACE)
        goto Exit;

    hr2 = pObject->SetLineRange(nFirstLine, m_Lexer.GetLineNumber(), m_Lexer.GetErrorFile());
    if(FAILED(hr2))
    {
        m_nErrorContext = hr2;
        goto Exit;
    }
    NextToken();

    // We have now syntactially recognized a class
    // but done no context-sensitive verification.  This is
    // deferred to whatever module is using the parser output.
    // =======================================================

    if(pVar)
	{
		pVar->vt = VT_EMBEDDED_OBJECT;
        pVar->punkVal = (IUnknown *)pObject;
	}
    else
    {
        pObject->Deflate(false);
        m_Output.AddObject(pObject);
    }
    return TRUE;

Exit:
    delete pObject;
    return FALSE;
}

//***************************************************************************
//
//  <sys_or_regular> ::= TOK_SIMPLE_IDENT;
//  <sys_or_regular> ::= TOK_SYSTEM_IDENT;
//
//***************************************************************************

bool CMofParser::sys_or_regular()
{
    if(m_nToken == TOK_SIMPLE_IDENT || m_nToken == TOK_SYSTEM_IDENT)
        return true;
    else
        return false;
}

//***************************************************************************
//
//  <opt_parent_class> ::= TOK_COLON <SYS_OR_REGULAR>;
//  <opt_parent_class> ::= <>;
//
//***************************************************************************
// v1.10

BOOL CMofParser::opt_parent_class(OUT BSTR* pstrParentName)
{
    // If a colon is present, there is a parent type.
    // ==============================================

    if (m_nToken == TOK_COLON)
    {
        NextToken();

        // Get the parent type identifier.
        // ===============================
        
        if (!sys_or_regular())
        {
            m_nErrorContext = WBEMMOF_E_EXPECTED_CLASS_NAME;
            return FALSE;
        }

        *pstrParentName = SysAllocString((LPWSTR)m_Lexer.GetText());
        if(*pstrParentName == NULL)
        {
            m_nErrorContext = WBEM_E_OUT_OF_MEMORY;
            return FALSE;
        }
        NextToken();
    }
    else *pstrParentName = NULL;

    return TRUE;
}

//***************************************************************************
//
//  <property_decl_list> ::= <PropOrMeth_decl> <property_decl_list>;
//  <property_decl_list> ::= <>;
//
//  Adds the properties to the CMObject passed.
//
//***************************************************************************
// v1.10

BOOL CMofParser::property_decl_list(MODIFY CMObject* pObject)
{
    // Begin parsing.
    // ==============

    while (m_nToken == TOK_SIMPLE_IDENT || m_nToken == TOK_OPEN_BRACKET || 
        m_nToken == TOK_VOID || m_nToken == TOK_SYSTEM_IDENT)
    {
        CMoProperty* pProp = NULL;

        if (!PropOrMeth_decl(&pProp))
        {
            delete pProp;
            return FALSE;
        }

        if(!pObject->AddProperty(pProp))
        {
            // Duplicate property
            // ==================

            m_nErrorContext = WBEMMOF_E_DUPLICATE_PROPERTY;
            return FALSE;
        }
    }
                       
    return TRUE;
}

//***************************************************************************
//
//  <PropOrMeth_decl> ::=                           
//      <qualifier_decl>
//      <PropOrMeth_decl2>;
//
//  Stores itself in the passed CMoProperty object (unintialized)
//
//***************************************************************************
// v1.10

BOOL CMofParser::PropOrMeth_decl(OUT CMoProperty ** ppProp)
{
    

    // Get the qualifiers
    // ==================

    CMoQualifierArray* paQualifiers = new CMoQualifierArray(m_pDbg);
    if (paQualifiers == NULL || !qualifier_decl(*paQualifiers, false, PROPMETH_SCOPE))
        return FALSE;

    

    // Read the rest of the property information
    // =========================================

    if (!PropOrMeth_decl2(ppProp, paQualifiers))
        return FALSE;

    SCOPE_CHECK scheck = IN_METHOD;
    if((*ppProp)->IsValueProperty())
        scheck = IN_PROPERTY;
    if(m_bDoScopeCheck && (FALSE == CheckScopes(scheck, paQualifiers, *ppProp)))
        return FALSE;
    
    return TRUE;
}

//***************************************************************************
//
//  <PropOrMeth_decl2> ::= <TypeAndName> <finish_PropOrMeth>;
//  <PropOrMeth_decl2> ::= TOK_VOID TOK_SIMPLE_IDENT <finish_meth>;
//
//  Modifies the CMoProperty object passed in (the qualifiers are already
//  set by this time).
//
//***************************************************************************
//  v1.10

BOOL CMofParser::PropOrMeth_decl2(MODIFY CMoProperty ** ppProp, CMoQualifierArray* paQualifiers)
{
    if(m_nToken != TOK_VOID)
    {
        CMoType Type(m_pDbg);
        WString sName;
        BOOL bRet = TypeAndName(Type, sName);
        if(bRet)
            bRet = finish_PropOrMeth(Type, sName, ppProp, paQualifiers);
        return bRet;
    }
    else
    {
        CMoType Type(m_pDbg);
        WString sName;
        
        HRESULT hr2 = Type.SetTitle(L"NULL");
        if(FAILED(hr2))
        {
            m_nErrorContext = hr2;
            return FALSE;
        }
        

        // Now get the property name.
        // ==========================

        NextToken();
        if (m_nToken != TOK_SIMPLE_IDENT)
        {
            m_nErrorContext = WBEMMOF_E_EXPECTED_PROPERTY_NAME;
            return FALSE;
        }

        sName = m_Lexer.GetText();
        NextToken();
        return finish_meth(Type, sName, ppProp, paQualifiers);
    }
}

//***************************************************************************
//
//  <finish_PropOrMeth> ::= <finish_prop>;
//  <finish_PropOrMeth> ::= <finish_meth>;
// 
//  examines the string, gets the name and determines if it is a property or
//  method and then calls the appropriate routine to finish.
//
//***************************************************************************

BOOL CMofParser::finish_PropOrMeth(CMoType & Type, WString & sName,MODIFY CMoProperty ** ppProp, 
                                   CMoQualifierArray* paQualifiers)
{
    if(m_nToken == TOK_OPEN_PAREN)
        return finish_meth(Type, sName, ppProp, paQualifiers);
    else
        return finish_prop(Type, sName, ppProp, paQualifiers);
}

//***************************************************************************
//
//  <finish_prop> ::=     <opt_array> <default_value> TOK_SEMI
//
//***************************************************************************

BOOL CMofParser::finish_prop(CMoType & Type, WString & sName, CMoProperty ** ppProp,
                             CMoQualifierArray * paQualifiers)
{

    unsigned uSuggestedSize = 0xffffffff;

    *ppProp = new CValueProperty(paQualifiers, m_pDbg);
    if(*ppProp == NULL)
        return FALSE;

    if(FAILED((*ppProp)->SetPropName((wchar_t *) sName)))
        return FALSE;
    if(FAILED((*ppProp)->SetTypeTitle(Type.GetTitle())))
        return FALSE;

    // Check to see if this is an array type.
    // ======================================

    if (!opt_array(Type, paQualifiers))
        return FALSE;

    // Type parsing complete. Check it
    // ===============================

    VARTYPE vtType = Type.GetCIMType();
    if(vtType == VT_ERROR)
    {
        m_nErrorContext = WBEMMOF_E_UNRECOGNIZED_TYPE;
        return FALSE;
    }

    
    // Get the default value and assign it to the property.
    // ====================================================

    if (!default_value(Type, (*ppProp)->AccessValue()))
        return FALSE;

    // If Type resulted in extra qualifiers (CIMTYPE), add them to the prop
    // ===================================================================

    CMoValue & Val = (*ppProp)->AccessValue();
    Val.SetType(vtType);
    Type.StoreIntoQualifiers(paQualifiers);

    // Check closing semicolon.
    // ========================

    if (m_nToken != TOK_SEMI)
    {
        m_nErrorContext = WBEMMOF_E_EXPECTED_SEMI;
        return FALSE;
    }

    NextToken();

    return TRUE;
}

//***************************************************************************
//
//  <finish_meth> ::=  TOK_OPEN_PAREN <arg_list> TOK_CLOSE_PAREN TOK_SEMI
//
//***************************************************************************

BOOL CMofParser::finish_meth(CMoType & Type, WString & sName, CMoProperty ** ppProp,
                             CMoQualifierArray * paQualifiers)
{

    CMethodProperty * pMeth = new CMethodProperty(paQualifiers, m_pDbg, FALSE); 
    if(pMeth == NULL)
        return FALSE;
    *ppProp = pMeth;

    if(FAILED(pMeth->SetPropName((wchar_t *) sName)))
        return FALSE;
    if(FAILED(pMeth->SetTypeTitle(Type.GetTitle())))
        return FALSE;

    // Check to see if this is an array type.
    // ======================================

    if (!arg_list(pMeth))
        return FALSE;

    // If Type resulted in extra qualifiers (CIMTYPE), add them to the prop
    // ===================================================================

//    Type.StoreIntoQualifiers((*ppProp)->GetQualifiers());

    if (m_nToken != TOK_CLOSE_PAREN)
    {
        m_nErrorContext = WBEMMOF_E_EXPECTED_CLOSE_PAREN;
        return FALSE;
    }

    if(Type.IsArray())
    {
        m_nErrorContext = WBEMMOF_E_NO_ARRAYS_RETURNED;
        return FALSE;
    }
    WString sTemp = L"ReturnValue";
    CMoValue Value(m_pDbg);
    if(wbem_wcsicmp(L"NULL",Type.GetTitle()))
        if(!pMeth->AddToArgObjects(NULL, sTemp, Type, TRUE, m_nErrorContext, NULL, Value))
            return FALSE;

    NextToken();

    // Check closing semicolon.
    // ========================

    if (m_nToken != TOK_SEMI)
    {
        m_nErrorContext = WBEMMOF_E_EXPECTED_SEMI;
        return FALSE;
    }

    NextToken();

    return TRUE;
}

//***************************************************************************
//
//  <arg_list> ::= <arg_decl> <rest_of_args>;
//  <arg_list> ::= <>;
//
//***************************************************************************

BOOL CMofParser::arg_list(CMethodProperty * pMethProp)
{
    NextToken();
    if (m_nToken == TOK_CLOSE_PAREN)
    {
        return TRUE;
    }

    BOOL bRet = arg_decl(pMethProp);
    if(!bRet)
        return FALSE;
    else
        return rest_of_args(pMethProp);
}

//***************************************************************************
//
// <arg_decl> ::= <qualifier_decl><TypeAndName><opt_array>;
//
//***************************************************************************
BOOL CMofParser::arg_decl(CMethodProperty * pMethProp)
{

    CMoQualifierArray * paQualifiers = new CMoQualifierArray(m_pDbg);
    if(paQualifiers == NULL || !qualifier_decl(*paQualifiers,false, PROPMETH_SCOPE))
        return FALSE;
    CValueProperty * pArg =  new CValueProperty(paQualifiers, m_pDbg);
    if(pArg == NULL)
        return FALSE;
    CMoType Type(m_pDbg);
    WString sName;
    if(!TypeAndName(Type, sName))
        return FALSE;

    if(FAILED(pArg->SetPropName(sName)))
        return FALSE;

    if(FAILED(pArg->SetTypeTitle(Type.GetTitle())))
        return FALSE;

    if(!opt_array(Type, paQualifiers))
        return FALSE;

    VARIANT * pVar = pArg->GetpVar();
    if(!default_value(Type, pArg->AccessValue()))
        return FALSE;

    if(m_bDoScopeCheck && (FALSE == CheckScopes(IN_PARAM, paQualifiers, pArg)))
        return FALSE;
    
    m_nErrorContext = WBEM_E_INVALID_PARAMETER;
    if(!pMethProp->AddToArgObjects(paQualifiers, sName, Type, FALSE,  m_nErrorContext, pVar,
        pArg->AccessValue()))
        return FALSE;
    
    // Type parsing complete. Check it
    // ===============================

    if(Type.GetCIMType() == VT_ERROR)
    {
        m_nErrorContext = WBEMMOF_E_UNRECOGNIZED_TYPE;
        return FALSE;
    }


    // If Type resulted in extra qualifiers (CIMTYPE), add them to the prop
    // ===================================================================

    Type.StoreIntoQualifiers(paQualifiers);

    pMethProp->AddArg(pArg);
    return TRUE;

}

//***************************************************************************
//
//  <rest_of_args> ::= TOK_COMMA <arg_decl> <rest_of_args>;
//  <rest_of_args> ::= <>;
//
//***************************************************************************

BOOL CMofParser::rest_of_args(CMethodProperty * pMethProp)
{
    if(m_nToken == TOK_COMMA)
    {
        NextToken();
        BOOL bRet = arg_decl(pMethProp);
        if(!bRet)
            return FALSE;
        return rest_of_args(pMethProp);
    }
    return TRUE;
}

//***************************************************************************
//
//  <TypeAndName> ::= <type> <opt_ref> TOK_SIMPLE_IDENT;
//
//***************************************************************************

BOOL CMofParser::TypeAndName(MODIFY CMoType& Type, WString &sName)
{
    if (!type(Type))
    {
        return FALSE;
    }

    // Check if it is actually a reference to a type
    // =============================================

    if (!opt_ref(Type))
        return FALSE;

    // Now get the property name.
    // ==========================

    if (m_nToken != TOK_SIMPLE_IDENT)
    {
        m_nErrorContext = WBEMMOF_E_EXPECTED_PROPERTY_NAME;
        return FALSE;
    }

    sName = m_Lexer.GetText(); 
    NextToken();
    return TRUE;
}

//***************************************************************************
//
//  <opt_ref> ::= TOK_REF;
//  <opt_ref> ::= <>;
//
//  Modifies the type object to reflect that this is a ref.
//
//***************************************************************************
// v1.10

BOOL CMofParser::opt_ref(MODIFY CMoType& Type)
{
    if (m_nToken == TOK_REF)
    {
        Type.SetIsRef(TRUE);
        Type.SetIsEmbedding(FALSE);
        NextToken();
    }
    else if(Type.GetCIMType() == VT_ERROR)		// Probably a class name
    {
        if(Type.IsUnsupportedType())
        {
    	    m_nErrorContext = WBEMMOF_E_UNSUPPORTED_CIMV22_DATA_TYPE;
            return false;
        }
        Type.SetIsEmbedding(TRUE);
        Type.SetIsRef(FALSE);
    }
    else
    {
        Type.SetIsRef(FALSE);
        Type.SetIsEmbedding(FALSE);
    }
        
    return TRUE;
}

//***************************************************************************
//
//  <opt_array> ::= TOK_OPEN_BRACKET <opt_array_detail>;
//  <opt_array> ::= <>;
//
//
//***************************************************************************
// v1.10

BOOL CMofParser::opt_array(MODIFY CMoType& Type, CMoQualifierArray * paQualifiers)
{

    if (m_nToken == TOK_OPEN_BRACKET)
    {
        return opt_array_detail(Type, paQualifiers);
    }
    else Type.SetIsArray(FALSE);

    return TRUE;
}

//***************************************************************************
//
//  <opt_array_detail> ::= TOK_UNSIGNED64_NUMERIC_CONST TOK_CLOSE_BRACKET;
//  <opt_array_detail> ::= TOK_CLOSE_BRACKET;
//
//***************************************************************************

BOOL CMofParser::opt_array_detail(MODIFY CMoType& Type, CMoQualifierArray * paQualifiers)
{

    Type.SetIsArray(TRUE);

    // check if next token is a unsigned constant

    NextToken();
    if(m_nToken == TOK_UNSIGNED64_NUMERIC_CONST)
    {
        unsigned uSuggestedSize = _wtoi(m_Lexer.GetText());

        // If a max suggested size is set, then add a qualifier named max()
        // ================================================================
    
        CMoQualifier* pNewQualifier = new CMoQualifier(m_pDbg);
        if(pNewQualifier == NULL)
            return FALSE;
        if(FAILED(pNewQualifier->SetQualName(L"MAX")))
            return FALSE;
        VARIANT * pvar = pNewQualifier->GetpVar();
        pvar->vt = VT_I4;
        pvar->lVal = (int)uSuggestedSize;
        if(!paQualifiers->Add(pNewQualifier))
        {
            // Duplicate qualifier
            // ===================

            m_nErrorContext = WBEMMOF_E_DUPLICATE_QUALIFIER;
            return FALSE;
        }

        NextToken();
    }
        
    m_nErrorContext = WBEMMOF_E_EXPECTED_CLOSE_BRACKET;
    CHECK(TOK_CLOSE_BRACKET);
	return TRUE;
}


//***************************************************************************
//
//  <default_value> ::= <>;
//  <default_value> ::= TOK_EQUALS <initializer>;
//
//  This function only applies to class declarations.
//
//***************************************************************************
// v1.10

BOOL CMofParser::default_value(READ_ONLY CMoType& Type,
                               OUT CMoValue& Value)
{
    if (m_nToken == TOK_EQUALS) {
        NextToken();

        // Get the value
        // =============

        return initializer(Type, Value);
    }
    else {

        Value.SetType(Type.GetCIMType());
        VariantClear(&Value.AccessVariant());
        V_VT(&Value.AccessVariant()) = VT_NULL;

        /*
        // HACK!!!! Clear the VARIANT's data field
        // =======================================

        memset(&Value.AccessVariant(), 0, sizeof(VARIANT));

        // No initializer. Set type to whatever we can discern from Type
        // =============================================================

        V_VT(&Value.AccessVariant()) = Type.GetVarType();
        if(V_VT(&Value.AccessVariant()) == VT_BSTR)
        {
            // NULL strings are not well-supported
            // ===================================

            V_BSTR(&Value.AccessVariant()) = SysAllocString(L"");
        }
        */
    }

    return TRUE;
}


//***************************************************************************
//
//  Qualifier parsing
//
//***************************************************************************

//***************************************************************************
//
//  <qualifier_decl>   ::= TOK_OPEN_BRACKET <qualifier_list> TOK_CLOSE_BRACKET;
//  <qualifier_decl>   ::= <>;
//
//
//***************************************************************************
// v1.10
BOOL CMofParser::qualifier_decl(OUT CMoQualifierArray& aQualifiers, bool bTopLevel, QUALSCOPE qs)
{
    if (m_nToken == TOK_OPEN_BRACKET) {
        NextToken();

        if (!qualifier_list(aQualifiers, bTopLevel, qs)) {
            return FALSE;
        }

        // Check closing bracket.
        // ======================

        if (m_nToken != TOK_CLOSE_BRACKET) {
            m_nErrorContext = WBEMMOF_E_EXPECTED_CLOSE_BRACKET;
            return FALSE;
        }
        NextToken();
    }

    return TRUE;
}

//***************************************************************************
//
//  <qualifier_list>   ::= <qualifier><qualifier_list_rest>;
//
//***************************************************************************
// v1.10
BOOL CMofParser::qualifier_list(OUT CMoQualifierArray& aQualifiers, bool bTopLevel, QUALSCOPE qs)
{
    CMoQualifier* pNewQualifier = new CMoQualifier(m_pDbg);
    if(pNewQualifier == NULL)
        return FALSE;

    if (!qualifier(*pNewQualifier, bTopLevel, qs))
    {
        delete pNewQualifier;
        return FALSE;
    }

    // if the qualifier is null, then just ignore it

    VARIANT * pVar = pNewQualifier->GetpVar();
    if(pVar->vt == VT_NULL)
    {
        delete pNewQualifier;
        return qualifier_list_rest(aQualifiers, bTopLevel, qs);
    }

    // Stuff the qualifier into the array
    // ==================================

    if(!aQualifiers.Add(pNewQualifier))
    {
        // Duplicate qualifier
        // ===================

        m_nErrorContext = WBEMMOF_E_DUPLICATE_QUALIFIER;
        return FALSE;
    }

    return qualifier_list_rest(aQualifiers, bTopLevel, qs);
}

//***************************************************************************
//
//  <qualifier_list_rest> ::= TOK_COMMA <qualifier><qualifier_list_rest>;
//  <qualifier_list_rest> ::= <>;
//
//***************************************************************************
// v1.10
BOOL CMofParser::qualifier_list_rest(MODIFY CMoQualifierArray& aQualifiers, bool bTopLevel, QUALSCOPE qs)
{
    while (m_nToken == TOK_COMMA)
    {
        NextToken();

        CMoQualifier* pQualifier = new CMoQualifier(m_pDbg);
        if(pQualifier == NULL)
            return FALSE;

        if (!qualifier(*pQualifier, bTopLevel, qs))
        {
            delete pQualifier;
            return FALSE;
        }

        // if the qualifier is null, then just ignore it

        VARIANT * pVar = pQualifier->GetpVar();
        if(pVar->vt == VT_NULL)
        {
            delete pQualifier;
        }
        else if(!aQualifiers.Add(pQualifier))
        {
            // Duplicate qualifier
            // ===================

            m_nErrorContext = WBEMMOF_E_DUPLICATE_QUALIFIER;
            return FALSE;
        }
    }

    return TRUE;
}

//***************************************************************************
//
//  <qualifier>        ::= TOK_SIMPLE_IDENT <qualifier_parms>;
//
//***************************************************************************
// v1.10

BOOL CMofParser::qualifier(OUT CMoQualifier& Qualifier, bool bTopLevel, QUALSCOPE qs)
{
    m_nErrorContext = WBEMMOF_E_EXPECTED_QUALIFIER_NAME;

    if (m_nToken != TOK_SIMPLE_IDENT && m_nToken != TOK_AMENDMENT)
        return FALSE;

    // Check that this qualifier is not illegal in a MOF
    // =================================================

    if(!wbem_wcsicmp(m_Lexer.GetText(), L"CIMTYPE"))
    {
        m_nErrorContext = WBEMMOF_E_CIMTYPE_QUALIFIER;
        return FALSE;
    }

    if(FAILED(Qualifier.SetQualName(m_Lexer.GetText())))
    {
        m_nErrorContext = WBEM_E_OUT_OF_MEMORY;
        return FALSE;
    }

    NextToken();

    if (!qualifier_parm(Qualifier, bTopLevel, qs))
    {
        return FALSE;
    }

    return TRUE;
}

//***************************************************************************
//
//  <qualifier_parm>  ::= <flavor_param>;
//  <qualifier_parm>  ::= TOK_OPEN_PAREN <qualifier_initializer_list> TOK_CLOSE_PAREN <flavor_param>;
//
//***************************************************************************
// v1.10

BOOL CMofParser::qualifier_parm(OUT CMoQualifier& Qualifier, bool bTopLevel, QUALSCOPE qs)
{

    HRESULT hr;
	CMoValue & Value = Qualifier.AccessValue();

    if (m_nToken == TOK_OPEN_PAREN)
    {
        NextToken();

        // Read the parameter. 
        // ====================
        
        CMoType Type(m_pDbg);
        if (!simple_initializer(Type, Value, true))
            return FALSE;

       m_nErrorContext = WBEMMOF_E_EXPECTED_CLOSE_PAREN;
        CHECK(TOK_CLOSE_PAREN);
    }
    else if (m_nToken == TOK_OPEN_BRACE)
    {
        NextToken();

        // Read the parameters. 
        // ====================

        if (!qualifier_initializer_list(Value))
            return FALSE;

        m_nErrorContext = WBEMMOF_E_EXPECTED_CLOSE_BRACE;
        CHECK(TOK_CLOSE_BRACE);
    }
    else
    {
        // Boolean qualifier: set to TRUE
        // ==============================

        V_VT(&Value.AccessVariant()) = VT_BOOL;
        V_BOOL(&Value.AccessVariant()) = VARIANT_TRUE;
        Qualifier.SetUsingDefaultValue(true);
    }

    // Get the default flavor for this qualifier
    // =========================================

    hr = m_Output.SetDefaultFlavor(Qualifier, bTopLevel, qs, m_State);
    if(FAILED(hr))
        return FALSE;
    return flavor_param(Qualifier, false);
}

//****************************************************************************
//
//  qualifier_initializer_list ::= initializer_list
//
//  Their syntax is the same, but the storage model is different.
//
//***************************************************************************

BOOL CMofParser::qualifier_initializer_list(OUT CMoValue& Value)
{

    // We don't know the type, so create an initialized one
    // ====================================================

    CMoType Type(m_pDbg);
    if(!initializer_list(Type, Value, true))
        return FALSE;

    return TRUE;
}


//***************************************************************************
//
// Basic low-level productions for types, idents, etc.

//***************************************************************************
//
//  <type> ::= TOK_SIMPLE_IDENT;
//
//***************************************************************************
// v1.10

BOOL CMofParser::type(OUT CMoType& Type)
{
    m_nErrorContext = WBEMMOF_E_EXPECTED_TYPE_IDENTIFIER;

    if (!sys_or_regular())
        return FALSE;

    HRESULT hr = Type.SetTitle(m_Lexer.GetText());
    if(FAILED(hr))
    {
        m_nErrorContext = hr;
        return FALSE;
    }

    NextToken();
    return TRUE;
}


//***************************************************************************
//
//  <const_value> ::= TOK_LPSTR;
//  <const_value> ::= TOK_LPWSTR;
//  <const_value> ::= TOK_SIGNED64_NUMERIC_CONST;
//  <const_value> ::= TOK_UNSIGNED64_NUMERIC_CONST;
//  <const_value> ::= TOK_UUID;
//  <const_value> ::= TOK_KEYWORD_NULL;
//
//***************************************************************************
// 1.10



BOOL CMofParser::const_value(MODIFY CMoType& Type, OUT VARIANT& varValue, bool bQualifier)
{
    varValue.lVal = 0;
    VARIANT var;
    SCODE sc;
    m_nErrorContext = WBEMMOF_E_TYPE_MISMATCH;
    __int64 iTemp;
    switch (m_nToken)
    {
	case TOK_PLUS:
	  // Just ignore '+'
	  NextToken();
	  if (m_nToken != TOK_SIGNED64_NUMERIC_CONST &&
	      m_nToken != TOK_UNSIGNED64_NUMERIC_CONST)
	      return FALSE;

        case TOK_SIGNED64_NUMERIC_CONST:
        case TOK_UNSIGNED64_NUMERIC_CONST:
           WCHAR wcTemp[30];
		    iTemp = m_Lexer.GetLastInt();
            if(m_nToken == TOK_SIGNED64_NUMERIC_CONST)
                StringCchPrintfW(wcTemp, 30, L"%I64d", m_Lexer.GetLastInt());
            else
                StringCchPrintfW(wcTemp, 30, L"%I64u", m_Lexer.GetLastInt());
            var.vt = VT_BSTR;
            var.bstrVal =  SysAllocString(wcTemp);
            if(var.bstrVal == NULL)
            {
                m_nErrorContext = WBEM_E_OUT_OF_MEMORY;
                return FALSE;
            }
            sc = WbemVariantChangeType(&varValue, &var, VT_I4);
            VariantClear(&var);
            if(sc != S_OK)
            {
                varValue.vt = VT_BSTR; 
                varValue.bstrVal = SysAllocString(wcTemp);
                if(varValue.bstrVal == NULL)
                {
                    m_nErrorContext = WBEM_E_OUT_OF_MEMORY;
                    return FALSE;
                }
                sc = S_OK;
            }
            break;

        case TOK_KEYWORD_NULL:
            V_VT(&varValue) = VT_NULL;
//            if(bQualifier)
//            {
//                m_nErrorContext = WBEMMOF_E_UNSUPPORTED_CIMV22_QUAL_VALUE;
//                return FALSE;
//            }
            break;

        case TOK_FLOAT_VALUE:
//            if(bQualifier)
//            {
                var.vt = VT_BSTR;
                var.bstrVal =  SysAllocString(m_Lexer.GetText());
                if(var.bstrVal == NULL)
                {
                    m_nErrorContext = WBEM_E_OUT_OF_MEMORY;
                    return FALSE;
                }
                sc = VariantChangeTypeEx(&varValue, &var, 0x409, 0, VT_R8);
                VariantClear(&var);
                if(sc != S_OK)
                    return FALSE;
                break;
 //           }           //intentional lack of a break!!!!
        case TOK_LPWSTR:
        case TOK_UUID:
            V_VT(&varValue) = VT_BSTR; 
            V_BSTR(&varValue) = SysAllocString(m_Lexer.GetText());
            if(varValue.bstrVal == NULL)
            {
                m_nErrorContext = WBEM_E_OUT_OF_MEMORY;
                return FALSE;
            }
            break;

        case TOK_WCHAR:
            varValue.vt = VT_I2;
            varValue.iVal = (short)m_Lexer.GetLastInt();
            if(bQualifier)
            {
                m_nErrorContext = WBEMMOF_E_UNSUPPORTED_CIMV22_QUAL_VALUE;
                return FALSE;
            }
            break;

        case TOK_TRUE:
            V_VT(&varValue) = VT_BOOL;
            V_BOOL(&varValue) = VARIANT_TRUE;
            break;
        case TOK_FALSE:
            V_VT(&varValue) = VT_BOOL;
            V_BOOL(&varValue) = VARIANT_FALSE;
            break;

        default:
            m_nErrorContext = WBEMMOF_E_ILLEGAL_CONSTANT_VALUE;
            return FALSE;
    }

    NextToken();
    return TRUE;
}


//***************************************************************************
//
//  <initializer> ::= <simple_initializer>;
//  <initializer> ::= TOK_EXTERNAL;
//  <initializer> ::= TOK_OPEN_BRACE <initializer_list> TOK_CLOSE_BRACE;
//
//***************************************************************************
//  v1.10

BOOL CMofParser::initializer(MODIFY CMoType& Type, OUT CMoValue& Value)
{
    // A complex initializer list.
    // ===========================

    if (m_nToken == TOK_OPEN_BRACE)
    {
        NextToken();
        if(!initializer_list(Type, Value, false))
        {
            return FALSE;
        }

        m_nErrorContext = WBEMMOF_E_EXPECTED_CLOSE_BRACE;
        CHECK(TOK_CLOSE_BRACE);
    }

    // If the syntax says "prop = external" for MO Provided types...
    // =============================================================

    else if (m_nToken == TOK_EXTERNAL || m_nToken == TOK_KEYWORD_NULL)
    {
        Value.SetType(Type.GetCIMType());
        V_VT(&Value.AccessVariant()) = VT_NULL;
        NextToken();
        return TRUE;
    }

    else if (!simple_initializer(Type, Value, false))
    {
        return FALSE;
    }

    return TRUE;
}

//***************************************************************************
//
//  <simple_initializer> ::= <const_value>;
//  <simple_initializer> ::= <alias>;
//  <simple_initializer> ::= <instance_decl>;
//
//  Semantic stack actions:
//      On TRUE returns an MCST_CONST_VALUE token, an MCST_ALIAS, or
//      an MCST_KEYREF token, depending on which branch is taken.
//
//***************************************************************************
// v1.10

BOOL CMofParser::simple_initializer(MODIFY CMoType& Type, 
                                    OUT CMoValue& Value, bool bQualifier)
{
    if (m_nToken == TOK_DOLLAR_SIGN)
    {
        // It's an alias. Check the type
        // =============================

        if(Type.IsDefined())
        {
            if(!Type.IsRef()) 
            {
                m_nErrorContext = WBEMMOF_E_UNEXPECTED_ALIAS;
                return FALSE;
            }
        }
        else
        {
            // Type unknown at start-up. Set to object ref now
            // ===============================================

            HRESULT hr = Type.SetTitle(L"object");
            if(FAILED(hr))
            {
                m_nErrorContext = hr;
                return FALSE;
            }
            Type.SetIsRef(TRUE);
        }

        NextToken(true);
        m_nErrorContext = WBEMMOF_E_EXPECTED_ALIAS_NAME;
        if (m_nToken != TOK_SIMPLE_IDENT)
            return FALSE;

		AddAliasReplaceValue(Value, m_Lexer.GetText());

    	NextToken();
        return TRUE;
    }
    if (m_nToken == TOK_INSTANCE || m_nToken == TOK_OPEN_BRACKET || m_nToken == TOK_CLASS )
    {    
        VARIANT & var = Value.AccessVariant();
        CMoQualifierArray* paQualifiers = new CMoQualifierArray(m_pDbg);
        if (paQualifiers == NULL || !qualifier_decl(*paQualifiers, false, CLASSINST_SCOPE))
            return FALSE;
		BOOL bClass = (m_nToken == TOK_CLASS);
		if(bClass)
			return class_decl(paQualifiers, &var, NULL);
		else			
			return instance_decl(paQualifiers, &var, NULL);
    }
    else
      return const_value(Type, Value.AccessVariant(),bQualifier);
}

//***************************************************************************
//
//  <initializer_list> ::= <simple_initializer><init_list_2>;
//
//***************************************************************************
// v1.10

BOOL CMofParser::initializer_list(MODIFY CMoType& Type,
                                  OUT CMoValue& Value, bool bQualifier)
{
    HRESULT hres;

    // Check if the type is compatible with array
    // ==========================================

    if(Type.IsDefined())
    {
        if(!Type.IsArray())
        {
            m_nErrorContext = WBEMMOF_E_UNEXPECTED_ARRAY_INIT;
            return FALSE;
        }

    }

    // Get the initializers.
    // =====================

    CPtrArray aValues; // CMoValue*
    BOOL bFirst = TRUE;
    do
    {
        // Allow for the empty array case

        if(m_nToken == TOK_CLOSE_BRACE && bFirst)
            break;

        // Skip the comma, unless it is the first element
        // ==============================================
        if(!bFirst) NextToken();

        // Get single initializer 
        // ======================
        CMoValue* pSimpleValue = new CMoValue(m_pDbg);
        if(pSimpleValue == NULL || !simple_initializer(Type, *pSimpleValue, bQualifier))
            return FALSE;

        // Add it to the list
        // ==================
        aValues.Add(pSimpleValue);
        bFirst = FALSE;
    }
    while(m_nToken == TOK_COMMA);

    // Now, stuff them into a SAFEARRAY and register their aliases
    // ===========================================================

    // Create the SAFEARRAY of appropriate type
    // ========================================


	// start by figuring the type.  If all the entries are of the same
	// type, then use it.  If there is a mix, use BSTR.

    VARTYPE vt = VT_BSTR;
    if(aValues.GetSize() > 0)
    {
        VARIANT& varFirst = ((CMoValue*)aValues[0])->AccessVariant();
        vt = V_VT(&varFirst);		// normally this is what is set!
		for(int ii = 1; ii < aValues.GetSize(); ii++)
		{
			VARIANT& varCur = ((CMoValue*)aValues[ii])->AccessVariant();
			if(vt != V_VT(&varCur))
			{
                // If we just have a mix of i2 and i4, go for i4

                if((vt == VT_I4 || vt == VT_I2) && 
                   (V_VT(&varCur) == VT_I4 || V_VT(&varCur) == VT_I2) )
                     vt = VT_I4;
                else
                {
    			    vt = VT_BSTR;
				    break;
                }
			}
		}
    }


    SAFEARRAYBOUND aBounds[1];
    aBounds[0].lLbound = 0;
    aBounds[0].cElements = aValues.GetSize();

    //SAFEARRAY* pArray = SafeArrayCreateVector(vt, 0, aValues.GetSize());

#ifdef _WIN64
	VARTYPE vtTemp = (vt == VT_EMBEDDED_OBJECT) ? VT_I8 : vt;
#else
	VARTYPE vtTemp = (vt == VT_EMBEDDED_OBJECT) ? VT_I4 : vt;
#endif
	SAFEARRAY* pArray = SafeArrayCreate(vtTemp, 1, aBounds);

    // Stuff the individual data pieces
    // ================================

    for(int nIndex = 0; nIndex < aValues.GetSize(); nIndex++)
    {
        CMoValue* pSimpleValue = (CMoValue*)aValues[nIndex];
        VARIANT& varItem = pSimpleValue->AccessVariant();

        // Cast it to the array type, just in case
        // =======================================

        if((vt & ~VT_ARRAY) != VT_EMBEDDED_OBJECT)
		{
			hres = WbemVariantChangeType(&varItem, &varItem, vt);
			if(FAILED(hres)) return FALSE;
            if(varItem.vt == VT_NULL)
                varItem.llVal = 0;
		}

        if(vt == VT_BSTR)
        {
            hres = SafeArrayPutElement(pArray, (long*)&nIndex, varItem.bstrVal);
        }
		else if (vt == VT_EMBEDDED_OBJECT)
		{
			if(varItem.vt == VT_NULL)
			{
				m_nErrorContext = WBEMMOF_E_NULL_ARRAY_ELEM;
				return FALSE;
			}
			hres = SafeArrayPutElement(pArray, (long*)&nIndex, &varItem.punkVal);
            if(FAILED(hres))
                return FALSE;
		}
        else
        {
            hres = SafeArrayPutElement(pArray, (long*)&nIndex, &V_I1(&varItem));
            if(FAILED(hres))
                return FALSE;
        }

        // Transfer any aliases to the containing value
        // ============================================

        for(int i = 0; i < pSimpleValue->GetNumAliases(); i++)
        {
            LPWSTR wszAlias;
            wszAlias=NULL;
            int nDummy; // SimpleValue cannot contain an array!

            if(pSimpleValue->GetAlias(i, wszAlias, nDummy))
            {
                hres = Value.AddAlias(wszAlias, nIndex);
                if(FAILED(hres))
                {
                    m_nErrorContext = hres;
                    return FALSE;
                 }
             }
        }

		// Since VT_EMBEDDED_OBJECT is actually a pointer to a CMObject, dont
		// delete that since it will be needed later on.

		if((vt & ~VT_ARRAY) == VT_EMBEDDED_OBJECT)
        {
            VARIANT & Var = pSimpleValue->AccessVariant();
            Var.vt = VT_I4;
        }
		delete pSimpleValue;
    }

    // Store that array in the VARIANT
    // ===============================

    V_VT(&Value.AccessVariant()) = VT_ARRAY | vt;
    V_ARRAY(&Value.AccessVariant()) = pArray;

    return TRUE;
}

//***************************************************************************
//
//  Instances.
//
//***************************************************************************

//***************************************************************************
//
//  <instance_decl> ::=
//      TOK_INSTANCE TOK_OF
//      <type>
//      <as_alias>
//      TOK_OPEN_BRACE
//      <prop_init_list>
//      TOK_CLOSE_BRACE;
//
//  This can be called for both top level instances and embedded instances.
//  In the top level case, the pVar will be set to null and the object will
//  be added to the ouput.  In the embedded case, the pVar will be used to 
//  point to the object.
//***************************************************************************

BOOL CMofParser::instance_decl(ACQUIRE CMoQualifierArray* paQualifiers, VARIANT * pVar, ParseState * pQualPosition)
{
    BOOL bRetVal = FALSE;       // Default
    BSTR strClassName;

    // Begin syntax check.
    // ===================

    m_nErrorContext = WBEMMOF_E_INVALID_INSTANCE_DECLARATION;
    int nFirstLine = m_Lexer.GetLineNumber();

    if (m_nToken != TOK_INSTANCE)
    {
        delete paQualifiers;
        return FALSE;
    }
    NextToken();

    if(m_nToken != TOK_OF)
    {
        delete paQualifiers;
        return FALSE;
    }
    NextToken();

    // Get the class name.
    // ====================

    if (!sys_or_regular())
    {
        m_nErrorContext = WBEMMOF_E_EXPECTED_CLASS_NAME;
        delete paQualifiers;
        return FALSE;
    }

    strClassName = SysAllocString((LPWSTR)m_Lexer.GetText());
    if(strClassName == NULL)
    {
        m_nErrorContext = WBEM_E_OUT_OF_MEMORY;
        return FALSE;
    }
    
    NextToken();

    // Create an instance of this class
    // ================================

    CMoInstance* pObject = new CMoInstance(strClassName, m_pDbg);    
    if(pObject == NULL)
    {
        m_nErrorContext = WBEM_E_OUT_OF_MEMORY;
        return FALSE;
    }
    if(pObject->IsOK() == false)
        goto Exit;
        
    HRESULT hr2 = pObject->SetNamespace(m_wszNamespace);
    if(FAILED(hr2))
    {
        m_nErrorContext = hr2;
        goto Exit;
    }
    pObject->SetOtherDefaults(GetClassFlags(), GetInstanceFlags());
    SysFreeString(strClassName);

    // Apply qualifiers (already parsed)
    // =================================

    pObject->SetQualifiers(paQualifiers);
    
    // Check for an alias.  Aliases are only allowed for top level instances.
    // ======================================================================


    if(m_nToken == TOK_AS && pVar)
    {
        m_nErrorContext = WBEMMOF_E_ALIASES_IN_EMBEDDED;
        delete paQualifiers;
        return FALSE;
    }
    LPWSTR wszAlias = NULL;
    if (!as_alias(wszAlias))
        goto Exit;

    if(wszAlias)
    {
        HRESULT hr2 = pObject->SetAlias(wszAlias);
        delete [] wszAlias;
        if(FAILED(hr2))
        {
            m_nErrorContext = hr2;
            goto Exit;
        }
        
    }

    // Check for the open brace.
    // =========================

    m_nErrorContext = WBEMMOF_E_EXPECTED_OPEN_BRACE;

    if (m_nToken != TOK_OPEN_BRACE)
        goto Exit;

    // Now get the list properties.
    // ============================
    GetParserPosition(pObject->GetDataState());
	if(pQualPosition)
	{
		pObject->SetQualState(pQualPosition);
	}
    NextToken();
    if (!prop_init_list(pObject))
        goto Exit;

    // Final close brace.
    // ==================

    m_nErrorContext = WBEMMOF_E_EXPECTED_CLOSE_BRACE;

    if (m_nToken != TOK_CLOSE_BRACE)
        goto Exit;
    hr2 = pObject->SetLineRange(nFirstLine, m_Lexer.GetLineNumber(), m_Lexer.GetErrorFile());
    if(FAILED(hr2))
    {
        m_nErrorContext = hr2;
        goto Exit;
    }
    
    NextToken();

    // We have now syntactially recognized an instance
    // but done no context-sensitive verification.  This is
    // deferred to whatever module is using the parser output.
    // =======================================================

    if(pVar)
	{
		pVar->vt = VT_EMBEDDED_OBJECT;
        pVar->punkVal = (IUnknown *)pObject;
	}
    else
    {
        pObject->Deflate(false);
        m_Output.AddObject(pObject);
    }
    return TRUE;

Exit: