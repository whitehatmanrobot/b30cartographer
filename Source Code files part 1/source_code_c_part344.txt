deoDebugPrint((1, "S3!VgaFindAdapter: "
                            "ConfigInfo->AdapterInterfaceType == PCIBus\n"));

        status = VideoPortGetAccessRanges(HwDeviceExtension,
                                          0,
                                          NULL,
                                          NUM_S3_PCI_ACCESS_RANGES,
                                          &accessRange[LINEAR_FRAME_BUF],
                                          NULL,
                                          NULL,
                                          &Slot);

        //
        // Now we need to determine the Device ID.
        //

        if (status == NO_ERROR) {

            USHORT Id = 0;

            if (VideoPortGetBusData(HwDeviceExtension,
                                    PCIConfiguration,
                                    0,
                                    (PVOID) &Id,
                                    FIELD_OFFSET(
                                        PCI_COMMON_CONFIG,
                                        DeviceID),
                                    sizeof(USHORT)) == 0) {

                //
                // Error getting bus data.
                //
    
                return ERROR_DEV_NOT_EXIST;
            }

            hwDeviceExtension->PCIDeviceID = Id;

            VideoDebugPrint((1, "==> DeviceID = 0x%x\n", Id));

            //
            // I am making the assumption that this driver will only
            // be loaded for legacy class devices.  The INF for
            // newer PCI device should point to the newer driver.
            //

            //
            // If we have an 868 or a 968 then the card requested
            // will request 32 Meg instead of 64 Meg of access ranges.
            // Confirm that the PCI bus enumerator corrected for this.
            //

            if (((Id == 0x8880) || (Id == 0x88F0)) &&
                (accessRange[LINEAR_FRAME_BUF].RangeLength != 0x4000000))
            {
                VideoDebugPrint((1, "This device decodes 64Meg but "
                                    "was only assigned 32Meg.\n"));

                ASSERT(FALSE);
            }

            //
            // We have an additional access range for our linear frame
            // buffer.
            //

            NumAccessRanges++;

        } else {

            //
            // Error getting access ranges.
            //

            return ERROR_DEV_NOT_EXIST;

        }
    }

    //
    // Check to see if there is a hardware resource conflict.
    //

    status = VideoPortVerifyAccessRanges(hwDeviceExtension,
                                         NumAccessRanges,
                                         accessRange);

    if (status != NO_ERROR) {

        VideoDebugPrint((1, "S3: Access Range conflict\n"));

        return status;

    }

    //
    // Get the mapped addresses for the frame buffer, BIOS, and all the
    // registers.  We will not map the linear frame buffer or linear BIOS
    // because the miniport does not need to access it.
    //

    for (i = 0; i < NUM_S3_ACCESS_RANGES_USED; i++) {

        if ( (hwDeviceExtension->MappedAddress[i] =
                  VideoPortGetDeviceBase(hwDeviceExtension,
                                         accessRange[i].RangeStart,
                                         accessRange[i].RangeLength,
                                         accessRange[i].RangeInIoSpace)) == NULL) {

            VideoDebugPrint((1, "S3: DeviceBase mapping failed\n"));
            return ERROR_INVALID_PARAMETER;

        }

    }

    //
    // Is a BIOS available?
    //

    if (VideoPortReadRegisterUshort(hwDeviceExtension->MappedAddress[0])
        == 0xaa55)
    {
        hwDeviceExtension->BiosPresent = TRUE;
    }

    if (ConfigInfo->AdapterInterfaceType != PCIBus)
    {
        //
        // Look for a non-pci S3.
        //

        if (!S3IsaDetection(HwDeviceExtension, &key)) {

            //
            // We failed to find an S3 device, so restore the
            // lock registers.
            //

            if (key) {

                //
                // Only lock the extended registers if
                // we unlocked them.
                //

                LockExtendedRegs(HwDeviceExtension, key);
            }

            return ERROR_DEV_NOT_EXIST;
        }
    }
    else
    {
        //
        // Make sure the chip type we detected is stored in the
        // DeviceExtension.  (We found card on PCI bus.)
        //

        S3RecordChipType(HwDeviceExtension, &key);
    }

    //
    // Get the capabilities, and Chip Name for the detected S3 device.
    //

    S3GetInfo(HwDeviceExtension, &PointerCapability, accessRange);

    //
    // Decide whether the alpha can use sparse or dense space.
    //

    AlphaDetermineMemoryUsage(HwDeviceExtension, accessRange);

    //
    // Get the DAC type.
    //

    S3DetermineDACType(HwDeviceExtension,
                       &PointerCapability);

    //
    // Determine the amount of video memory we have.
    //

    S3DetermineMemorySize(HwDeviceExtension);

    //
    // Determine which Frequency Table to use.
    //

    S3DetermineFrequencyTable(HwDeviceExtension,
                              accessRange,
                              ConfigInfo->AdapterInterfaceType);

    //
    // Determine which modes are valid on this device.
    //

    S3ValidateModes(HwDeviceExtension, &PointerCapability);


    /////////////////////////////////////////////////////////////////////////
    //
    // We have this so that the int10 will also work on the VGA also if we
    // use it in this driver.
    //

    ConfigInfo->VdmPhysicalVideoMemoryAddress.LowPart  = 0x000A0000;
    ConfigInfo->VdmPhysicalVideoMemoryAddress.HighPart = 0x00000000;
    ConfigInfo->VdmPhysicalVideoMemoryLength           = 0x00020000;

    //
    // Clear out the Emulator entries and the state size since this driver
    // does not support them.
    //

    ConfigInfo->NumEmulatorAccessEntries     = 0;
    ConfigInfo->EmulatorAccessEntries        = NULL;
    ConfigInfo->EmulatorAccessEntriesContext = 0;

    //
    // This driver does not do SAVE/RESTORE of hardware state.
    //

    ConfigInfo->HardwareStateSize = 0;

    //
    // Frame buffer and memory-mapped I/O information.
    //

    hwDeviceExtension->PhysicalFrameAddress = accessRange[1].RangeStart;
    hwDeviceExtension->FrameLength          = accessRange[1].RangeLength;

    hwDeviceExtension->PhysicalMmIoAddress  = accessRange[1].RangeStart;
    hwDeviceExtension->MmIoLength           = accessRange[1].RangeLength;
    hwDeviceExtension->MmIoSpace            = accessRange[1].RangeInIoSpace;

    if (hwDeviceExtension->Capabilities & CAPS_NEW_MMIO) {

        //
        // Since we using NEW MMIO, use the values for our linear
        // access ranges.
        //

        hwDeviceExtension->PhysicalFrameAddress = accessRange[LINEAR_FRAME_BUF].RangeStart;
        hwDeviceExtension->FrameLength          = accessRange[LINEAR_FRAME_BUF].RangeLength;

        hwDeviceExtension->PhysicalMmIoAddress  = accessRange[LINEAR_FRAME_BUF].RangeStart;
        hwDeviceExtension->MmIoLength           = accessRange[LINEAR_FRAME_BUF].RangeLength;
        hwDeviceExtension->MmIoSpace            = accessRange[LINEAR_FRAME_BUF].RangeInIoSpace;

        //
        // Adjust the memory map offset so that we can still use our
        // old-style memory-mapped I/O routines, if need be.  Also,
        // fix FrameLength and MmIoLength, since they're both set to
        // 64 MB right now.
        //

        hwDeviceExtension->PhysicalMmIoAddress.LowPart += NEW_MMIO_IO_OFFSET;
        hwDeviceExtension->MmIoLength = NEW_MMIO_IO_LENGTH;
        hwDeviceExtension->FrameLength = hwDeviceExtension->AdapterMemorySize;
    }

    //
    // IO Port information
    // Get the base address, starting at zero and map all registers
    //

    hwDeviceExtension->PhysicalRegisterAddress = accessRange[2].RangeStart;
    hwDeviceExtension->PhysicalRegisterAddress.LowPart &= 0xFFFF0000;

    hwDeviceExtension->RegisterLength = 0x10000;
    hwDeviceExtension->RegisterSpace = accessRange[2].RangeInIoSpace;

    //
    // Free up the ROM since we don't need it anymore.
    //

    VideoPortFreeDeviceBase(hwDeviceExtension,
                            hwDeviceExtension->MappedAddress[0]);

    //
    // Indicate we do not wish to be called over
    //

    *Again = 0;

    //
    // We're done mucking about with the S3 chip, so lock all the registers.
    //

    LockExtendedRegs(HwDeviceExtension, key);

    //
    // Indicate a successful completion status.
    //

    return status;

} // end S3FindAdapter()

ULONG
UnlockExtendedRegs(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    )

/*++

Routine Description:

    This routine unlocks the extended S3 registers.

Arguments:

    hwDeviceExtension - Pointer to the miniport's device extension.

Return Value:

    ULONG used to restore the register values.

--*/

{
    ULONG key;

    //
    // Save the initial value of the S3 lock registers.
    // It's possible a non-s3 bios may expect them in a state
    // defined in POST.
    //

    key = (ULONG) VideoPortReadPortUchar(CRT_ADDRESS_REG);

    key <<= 8;

    VideoPortWritePortUchar(CRT_ADDRESS_REG, 0x38);
    key = (ULONG) VideoPortReadPortUchar(CRT_DATA_REG);

    key <<= 8;

    VideoPortWritePortUchar(CRT_ADDRESS_REG, 0x39);
    key |= (ULONG) VideoPortReadPortUchar(CRT_DATA_REG);

    //
    // Now unlock all the S3 registers, for use in this routine.
    //

    VideoPortWritePortUshort(CRT_ADDRESS_REG, 0x4838);
    VideoPortWritePortUshort(CRT_ADDRESS_REG, 0xA039);

    return key;
}

VOID
LockExtendedRegs(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    ULONG key
    )

/*++

Routine Description:

    This routine restores the contents of the s3 lock registers.

Arguments:

    hwDeviceExtension - Pointer to the miniport's device extension.

Return Value:

    None.

--*/

{
    UCHAR val;

    val = (UCHAR) key;
    key >>= 8;

    VideoPortWritePortUshort(
        CRT_ADDRESS_REG, (USHORT)(((USHORT) val << 8) | 0x39));

    val = (UCHAR) key;
    key >>= 8;

    VideoPortWritePortUshort(
        CRT_ADDRESS_REG, (USHORT)(((USHORT) val << 8) | 0x38));

    val = (UCHAR) key;

    VideoPortWritePortUchar(CRT_ADDRESS_REG, val);
}

VOID
AlphaDetermineMemoryUsage(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    VIDEO_ACCESS_RANGE accessRange[]
    )

/*++

Routine Description:

    This routine determines whether or not the ALPHA can map it's frame
    buffer using dense space.

Arguments:

    hwDeviceExtension - Pointer to the miniport's device extension.

Return Value:

    None.

--*/

{
    PHW_DEVICE_EXTENSION hwDeviceExtension = HwDeviceExtension;
    UCHAR jBus;

    hwDeviceExtension->PhysicalFrameIoSpace = 0;

#if defined(_ALPHA_)

    VideoPortWritePortUchar(CRT_ADDRESS_REG, 0x36);
    jBus = VideoPortReadPortUchar(CRT_DATA_REG) & 0x3;

    if ((jBus == 0x2) &&
        ((hwDeviceExtension->ChipID >= S3_866) ||
         (hwDeviceExtension->SubTypeID == SUBTYPE_765))) {

        //
        // We want to use a dense space mapping of the frame buffer
        // whenever we can on the Alpha, because that will allow us to
        // support DCI and direct GDI access.
        //
        // Unfortunately, dense space mapping isn't really an option
        // with ISA cards because some of the older Alphas don't support
        // it, and it would be terribly slow on the newer Alphas anyway
        // (because any byte- or word-write requires a read/modify/write
        // operation, and the Alpha can only ever do 64-bit reads when
        // in dense mode -- meaning these operations would always require
        // 4 reads and 2 writes on the ISA bus).
        //
        // Any Alpha that supports PCI, though, can support dense space
        // mapping, and because the bus is wider and faster, the
        // read/modify/write case isn't nearly as painful.  But the
        // problem I've found now is that 64- and 32-bit reads eventually
        // lock-up any S3 chip older than the 866/868/968.
        //

        hwDeviceExtension->PhysicalFrameIoSpace = 4;

        //
        // The new DeskStation Alpha machines don't always support
        // dense space.  Therefore, we should try to map the memory
        // at this point as a test.  If the mapping succeeds then
        // we can use dense space, otherwise we'll use sparse space.
        //

        {
            PULONG MappedSpace=0;
            PHYSICAL_ADDRESS FrameBuffer;
            ULONG FrameLength;
            ULONG inIoSpace;

            VideoDebugPrint((1, "Checking to see if we can use dense space...\n"));

            //
            // We want to try to map the dense memory where it will ultimately
            // be mapped anyway.  If LINEAR_FRAME_BUF is valid, then use this
            // info, else use A000_FRAME_BUF.
            //

            if (accessRange[LINEAR_FRAME_BUF].RangeLength != 0)
            {
                FrameBuffer = accessRange[LINEAR_FRAME_BUF].RangeStart;
                FrameLength = accessRange[LINEAR_FRAME_BUF].RangeLength;
            }
            else
            {
                FrameBuffer = accessRange[A000_FRAME_BUF].RangeStart;
                FrameLength = accessRange[A000_FRAME_BUF].RangeLength;
            }

            inIoSpace = hwDeviceExtension->PhysicalFrameIoSpace;

            MappedSpace = (PULONG)VideoPortGetDeviceBase(hwDeviceExtension,
                                            FrameBuffer,
                                            FrameLength,
                                            (UCHAR)inIoSpace);

            if (MappedSpace == NULL)
            {
                //
                // Well, looks like we can't use dense space to map the
                // range.  Lets use sparse space, and let the display
                // driver know.
                //

                VideoDebugPrint((1, "Can't use dense space!\n"));

                hwDeviceExtension->PhysicalFrameIoSpace = 0;

                hwDeviceExtension->Capabilities |= (CAPS_NO_DIRECT_ACCESS |
                                                    CAPS_SPARSE_SPACE);
            }
            else
            {
                //
                // The mapping worked.  However, we were only mapping to
                // see if dense space was supported.  Free the memory.
                //

                VideoDebugPrint((1, "We can use dense space.\n"));

                VideoPortFreeDeviceBase(hwDeviceExtension,
                                        MappedSpace);
            }
        }


    } else {

        //
        // Gotta use a sparse space mapping, so let the display driver
        // know:
        //

        VideoDebugPrint((1, "We must use sparse space.\n"));

        hwDeviceExtension->Capabilities |= (CAPS_NO_DIRECT_ACCESS |
                                            CAPS_SPARSE_SPACE);
    }

    //
    // The 868/968 report to PCI that they decode
    // 32 Meg, while infact, they decode 64 Meg.
    // PCI attempts to work around this by moving
    // resources.  However, this causes us to move
    // into a dense space region.  So, when we try
    // to map our accelerator registers in sparce
    // space they actually end up in dense space.
    //
    // The 868/968 also have a bug such that if you
    // do a read from certain registers such as
    // BEE8, the chip will hang.  In dense space,
    // USHORT writes are implemented as
    // read-modify-write sequences.  This causes us
    // to hang.
    //
    // To work around this, we will disable NEW_MMIO
    // on the 868/968 and fall back to using
    // standard IO routines.
    //

    if ((hwDeviceExtension->SubTypeID == SUBTYPE_868) ||
        (hwDeviceExtension->SubTypeID == SUBTYPE_968)) {

        hwDeviceExtension->PhysicalFrameIoSpace = 0;

        hwDeviceExtension->Capabilities &= ~CAPS_NEW_MMIO;
        hwDeviceExtension->Capabilities |= (CAPS_NO_DIRECT_ACCESS |
                                            CAPS_SPARSE_SPACE);
    }

#endif


}

VOID
S3RecordChipType(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PULONG key
    )

/*++

Routine Description:

    This routine should only be called if we found a PCI S3 card.
    The routine will fill in the ChipType and SubType fields of the
    HwDeviceExtension.

Arguments:

    hwDeviceExtension - Pointer to the miniport's device extension.

Return Value:

    None.

--*/

{
    PHW_DEVICE_EXTENSION hwDeviceExtension = HwDeviceExtension;
    UCHAR jRevision, jChipID, jSecondaryID;

    *key = UnlockExtendedRegs(HwDeviceExtension);

    switch (hwDeviceExtension->PCIDeviceID) {

    case 0x8811:

        //
        // We need to examine IO ports to determine between
        // three chips with the same PCI ID.
        //

        VideoPortWritePortUchar(CRT_ADDRESS_REG, 0x2F);
        jRevision = VideoPortReadPortUchar(CRT_DATA_REG);

        VideoPortWritePortUchar(CRT_ADDRESS_REG, 0x2E);
        jSecondaryID = VideoPortReadPortUchar(CRT_DATA_REG);

        hwDeviceExtension->ChipID = S3_864;     // Treated as an 864

        if (jSecondaryID == 0x10) {

            //
            // This is an S3 732
            //

            VideoDebugPrint((2, "S3: 732 Chip Set\n"));

            hwDeviceExtension->SubTypeID = SUBTYPE_732;

        } else {

            if (jRevision & 0x40) {

                VideoDebugPrint((2, "S3: 765 Chip Set\n"));

                hwDeviceExtension->SubTypeID = SUBTYPE_765;

            } else {

                VideoDebugPrint((2, "S3: 764 Chip Set\n"));

                hwDeviceExtension->SubTypeID = SUBTYPE_764;
            }
        }

        break;

    case 0x8880:

        hwDeviceExtension->ChipID = S3_866;

        VideoDebugPrint((2, "S3: Vision868 Chip Set\n"));

        hwDeviceExtension->SubTypeID = SUBTYPE_868;

        break;

    case 0x8890:

        hwDeviceExtension->ChipID = S3_866;

        VideoDebugPrint((2, "S3: Vision866 Chip Set\n"));

        hwDeviceExtension->SubTypeID = SUBTYPE_866;

        break;

    case 0x88B0:
    case 0x88F0:

        VideoPortWritePortUchar(CRT_ADDRESS_REG, 0x30);
        jChipID = VideoPortReadPortUchar(CRT_DATA_REG);

        if (jChipID == 0xB0) {

            //
            // We found a PCI 928
            //

            VideoDebugPrint((2, "S3: 928 Chip Set\n"));

            hwDeviceExtension->ChipID = S3_928;
            hwDeviceExtension->SubTypeID = SUBTYPE_928;


        } else {

            VideoDebugPrint((2, "S3: Vision968 Chip Set\n"));

            hwDeviceExtension->ChipID = S3_866;
            hwDeviceExtension->SubTypeID = SUBTYPE_968;

        }
        break;

    case 0x88C0:
    case 0x88C1:

        hwDeviceExtension->ChipID = S3_864;

        VideoDebugPrint((2, "S3: 864 Chip Set\n"));

        hwDeviceExtension->SubTypeID = SUBTYPE_864;

        break;

    case 0x88D0:
    case 0x88D1:

        hwDeviceExtension->ChipID = S3_864;

        VideoDebugPrint((2, "S3: 964 Chip Set\n"));

        hwDeviceExtension->SubTypeID = SUBTYPE_964;

        break;

    default:

        //
        // It's an S3 we don't recognize.  Don't assume it's
        // backwards-compatible:
        //

        VideoDebugPrint((2, "S3: Unknown Chip Set\n"));

        break;
    }

    //
    // The IBM Mach machine ships with an 868 but we must treat
    // it as an 864 to avoid hanging problems.
    //

    WorkAroundForMach(hwDeviceExtension);
}

BOOLEAN
S3IsaDetection(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PULONG key
    )

/*++

Routine Description:

    This routine will test for the existance of an S3 card by
    directly poking at IO ports.

    NOTE: It is expected that this routine is called from
          S3FindAdapter, and that the IO ports are mapped.

Arguments:

    hwDeviceExtension - Pointer to the miniport's device extension.

Return Value:

    TRUE - If an S3 card was detected,
    FALSE - Otherwise.

--*/

{
    PHW_DEVICE_EXTENSION hwDeviceExtension = HwDeviceExtension;

    UCHAR jChipID, jRevision;
    ULONG ulSecondaryID;
    UCHAR reg30, reg47, reg49;
    BOOLEAN DetectS3;

    UCHAR jExtendedVideoDacControl;

    //
    // Determine if a BIOS is present.
    //
    // NOTE: At this point we have detected if an S3 was located on the PCI
    // bus.  For other bus types (EISA and ISA) we have not determined
    // yet.  So we do assume that reading from the ROM location will not
    // cause the machine to fault (which could actually happen on the
    // internal bus of RISC machines with no roms).
    //

    if (hwDeviceExtension->BiosPresent == TRUE) {

        //
        // Look for a ROM signature of Trident because our chip detection
        // puts the Trident chip into a sleep state.
        //
        // Search the first 256 bytes of BIOS for signature "TRIDENT"
        //

        if (VideoPortScanRom(HwDeviceExtension,
                             HwDeviceExtension->MappedAddress[0],
                             256,
                             "TRIDENT")) {

            VideoDebugPrint((1, "Trident BIOS found - can not be an S3 !\n"));

            return FALSE;
        }

    }

    *key = UnlockExtendedRegs(HwDeviceExtension);

    //
    // Assume some defaults:
    //

    DetectS3 = TRUE;

    //
    // Make sure we're working with an S3
    // And while were at it, pickup the chip ID
    //

    VideoPortWritePortUchar(CRT_ADDRESS_REG, 0x30);
    jChipID = VideoPortReadPortUchar(CRT_DATA_REG);

    switch(jChipID & 0xf0) {

    case 0x80: // 911 or 924

        //
        // Note: A lot of 911/924 cards have timing problems in fast
        //       machines when doing monochrome expansions.  We simply
        //       slow down every such transfer by setting the
        //       CAPS_SLOW_MONO_EXPANDS flag.
        //
        //       We also ran into problems with the 911 hardware pointer
        //       when using the HGC_DY register to hide the pointer;
        //       since 911 cards are several generations out of date, we
        //       will simply disable the hardware pointer.
        //

        VideoDebugPrint((2, "S3: 911 Chip Set\n"));

        hwDeviceExtension->ChipID = S3_911;
        hwDeviceExtension->SubTypeID = SUBTYPE_911;

        break;

    case 0x90: // 928
    case 0xB0: // 928PCI

        VideoDebugPrint((2, "S3: 928 Chip Set\n"));

        hwDeviceExtension->ChipID = S3_928;
        hwDeviceExtension->SubTypeID = SUBTYPE_928;

        //
        // Note: We don't enable CAPS_MM_IO on the 928 because all the
        //       display driver's memory-mapped I/O routines assume they
        //       can do 32-bit writes to colour and mask registers,
        //       which the 928 can't do.
        //

        break;

    case 0xA0: // 801/805

        if (jChipID >= 0xA8) {

            //
            // It's an 805i, which appears to us to be pretty much a '928'.
            //

            VideoDebugPrint((2, "S3: 805i Chip Set\n"));

            hwDeviceExtension->ChipID = S3_928;
            hwDeviceExtension->SubTypeID = SUBTYPE_805i;

        } else {

            //
            // The 80x rev 'A' and 'B' chips had bugs that prevented them
            // from being able to do memory-mapped I/O.  I'm not enabling
            // memory-mapped I/O on later versions of the 80x because doing
            // so at this point would be a testing problem.
            //

            VideoDebugPrint((2, "S3: 801/805 Chip Set\n"));

            hwDeviceExtension->ChipID = S3_801;
            hwDeviceExtension->SubTypeID = SUBTYPE_80x;

        }

        break;

    case 0xC0: // 864
    case 0xD0: // 964

        hwDeviceExtension->ChipID = S3_864;

        //
        // Note: The first 896/964 revs have a bug dealing with the pattern
        //       hardware, where we have to draw a 1x8 rectangle before
        //       using a pattern already realized in off-screen memory,
        //       so we set the RE_REALIZE_PATTERN flag.
        //

        if ((jChipID & 0xF0) == 0xC0) {

            VideoDebugPrint((2, "S3: 864 Chip Set\n"));

            hwDeviceExtension->SubTypeID = SUBTYPE_864;

        } else {

            VideoDebugPrint((2, "S3: 964 Chip Set\n"));

            hwDeviceExtension->SubTypeID = SUBTYPE_964;

        }

        break;

    case 0xE0: // Newer than 864/964

        //
        // We can treat the newer chips, for the most part, as compatible
        // with the 864, so use that ChipID.  Also assume some basic
        // capabilities.
        //

        hwDeviceExtension->ChipID = S3_866;

        //
        // Look at the secondary chip ID register to determine the chip
        // type.
        //

        VideoPortWritePortUchar(CRT_ADDRESS_REG, 0x2D);
        ulSecondaryID = ((ULONG) VideoPortReadPortUchar(CRT_DATA_REG)) << 8;

        VideoPortWritePortUchar(CRT_ADDRESS_REG, 0x2E);
        ulSecondaryID |= VideoPortReadPortUchar(CRT_DATA_REG);

        VideoPortWritePortUchar(CRT_ADDRESS_REG, 0x2F);
        jRevision = VideoPortReadPortUchar(CRT_DATA_REG);

        switch (ulSecondaryID) {

        case 0x8811:

            hwDeviceExtension->ChipID = S3_864;     // Treated as an 864

            if (jRevision & 0x40) {

                VideoDebugPrint((2, "S3: 765 Chip Set\n"));

                hwDeviceExtension->SubTypeID = SUBTYPE_765;

            } else {

                VideoDebugPrint((2, "S3: 764 Chip Set\n"));

                hwDeviceExtension->SubTypeID = SUBTYPE_764;

                //
                // Our #9 and Diamond 764 boards occasionally fail the HCT
                // tests when we do dword or word reads from the frame buffer.
                // To get on the HCL lists, cards must pass the HCTs, so we'll
                // revert to byte reads for these chips:
                //

            }

            break;

        case 0x8810:

            VideoDebugPrint((2, "S3: 732 Chip Set\n"));

            hwDeviceExtension->ChipID = S3_864;     // Treated as an 864
            hwDeviceExtension->SubTypeID = SUBTYPE_732;

            break;

        case 0x8880:

            VideoDebugPrint((2, "S3: Vision866 Chip Set\n"));

            hwDeviceExtension->SubTypeID = SUBTYPE_866;

            break;

        case 0x8890:

            VideoDebugPrint((2, "S3: Vision868 Chip Set\n"));

            hwDeviceExtension->SubTypeID = SUBTYPE_868;

            break;

        case 0x88B0:
        case 0x88F0:

            VideoDebugPrint((2, "S3: Vision968 Chip Set\n"));

            hwDeviceExtension->SubTypeID = SUBTYPE_968;

            break;

        default:

            //
            // It's an S3 we don't recognize.  Don't assume it's
            // backwards-compatible:
            //

            VideoDebugPrint((2, "S3: Unknown Chip Set\n"));

            //
            // Since we do not know what type of S3 this is, we
            // can't risk letting the driver load!
            //

            DetectS3 = FALSE;

            break;
        }

        break;

    default:

        DetectS3 = FALSE;
        break;
    }

    //
    // The IBM Mach machine ships with an 868 but we must treat
    // it as an 864 to avoid hanging problems.
    //

    WorkAroundForMach(hwDeviceExtension);

    //
    // Windows NT now autodetects the user's video card in Setup by
    // loading and running every video miniport until it finds one that
    // returns success.  Consequently, our detection code has to be
    // rigorous enough that we don't accidentally recognize a wrong
    // board.
    //
    // Simply checking the chip ID is not sufficient for guaranteeing
    // that we are running on an S3 (it makes us think some Weitek
    // boards are S3 compatible).
    //
    // We make doubly sure we're running on an S3 by checking that
    // the S3 cursor position registers exist, and that the chip ID
    // register can't be changed.
    //

    if (DetectS3) {

        DetectS3 = FALSE;

        //
        // First, make sure 'chip ID' register 0x30 is not modifiable:
        //

        VideoPortWritePortUchar(CRT_ADDRESS_REG, 0x30);
        if (VideoPortReadPortUchar(CRT_ADDRESS_REG) == 0x30) {

            reg30 = VideoPortReadPortUchar(CRT_DATA_REG);
            VideoPortWritePortUchar(CRT_DATA_REG, (UCHAR) (reg30 + 7));
            if (VideoPortReadPortUchar(CRT_DATA_REG) == reg30) {

                //
                // Next, make sure 'cursor origin-x' register 0x47 is
                // modifiable:
                //

                VideoPortWritePortUchar(CRT_ADDRESS_REG, 0x47);
                if (VideoPortReadPortUchar(CRT_ADDRESS_REG) == 0x47) {

                    reg47 = VideoPortReadPortUchar(CRT_DATA_REG);
                    VideoPortWritePortUchar(CRT_DATA_REG, 0x55);
                    if (VideoPortReadPortUchar(CRT_DATA_REG) == 0x55) {

                        //
                        // Finally, make sure 'cursor origin-y' register 0x49
                        // is modifiable:
                        //

                        VideoPortWritePortUchar(CRT_ADDRESS_REG, 0x49);
                        if (VideoPortReadPortUchar(CRT_ADDRESS_REG) == 0x49) {

                            reg49 = VideoPortReadPortUchar(CRT_DATA_REG);
                            VideoPortWritePortUchar(CRT_DATA_REG, 0xAA);
                            if (VideoPortReadPortUchar(CRT_DATA_REG) == 0xAA) {

                                DetectS3 = TRUE;
                            }

                            VideoPortWritePortUchar(CRT_DATA_REG, reg49);
                        }
                    }

                    VideoPortWritePortUchar(CRT_ADDRESS_REG, 0x47);
                    VideoPortWritePortUchar(CRT_DATA_REG, reg47);
                }
            }

            VideoPortWritePortUchar(CRT_ADDRESS_REG, 0x30);
            VideoPortWritePortUchar(CRT_DATA_REG, reg30);
        }
    }

    return DetectS3;
}

VOID
S3GetInfo(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    POINTER_CAPABILITY *PointerCapability,
    VIDEO_ACCESS_RANGE accessRange[]
    )

/*++

Routine Description:

    For fill in the capabilities bits for the s3 card, and return an
    wide character string representing the chip.

Arguments:

    HwDeviceExtension - Pointer to the miniport's device extension.

Return Value:

    None.

--*/

{
    PHW_DEVICE_EXTENSION hwDeviceExtension = HwDeviceExtension;
    UCHAR jBus, jChipID;
    PWSTR pwszChip;
    ULONG cbChip;

    //
    // The second register used for setting the refresh rate depends
    // on whether the chip is an 864/964, or newer.  The integrated
    // Trio chips use 41; the other high-end chips use 5B.
    //

    hwDeviceExtension->FrequencySecondaryIndex = 0x5B;

    switch (hwDeviceExtension->SubTypeID) {
    case SUBTYPE_911:

        //
        // Note: A lot of 911/924 cards have timing problems in fast
        //       machines when doing monochrome expansions.  We simply
        //       slow down every such transfer by setting the
        //       CAPS_SLOW_MONO_EXPANDS flag.
        //
        //       We also ran into problems with the 911 hardware pointer
        //       when using the HGC_DY register to hide the pointer;
        //       since 911 cards are several generations out of date, we
        //       will simply disable the hardware pointer.
        //

        VideoDebugPrint((2, "S3: 911 Chip Set\n"));

        pwszChip = L"S3 911/924";
        cbChip = sizeof(L"S3 911/924");

        hwDeviceExtension->Capabilities = (CAPS_SLOW_MONO_EXPANDS  |
                                            CAPS_SW_POINTER);

        break;

    case SUBTYPE_928:

        VideoDebugPrint((2, "S3: 928 Chip Set\n"));

        pwszChip = L"S3 928";
        cbChip = sizeof(L"S3 928");

        //
        // Note: We don't enable CAPS_MM_IO on the 928 because all the
        //       display driver's memory-mapped I/O routines assume they
        //       can do 32-bit writes to colour and mask registers,
        //       which the 928 can't do.
        //

        hwDeviceExtension->Capabilities = (CAPS_HW_PATTERNS        |
                                            CAPS_MM_TRANSFER        |
                                            CAPS_MM_GLYPH_EXPAND    |
                                            CAPS_16_ENTRY_FIFO      |
                                            CAPS_NEW_BANK_CONTROL);

        *PointerCapability = (POINTER_BUILT_IN | POINTER_WORKS_ONLY_AT_8BPP);

        break;

    case SUBTYPE_805i:

        //
        // It's an 805i, which appears to us to be pretty much a '928'.
        //

        VideoDebugPrint((2, "S3: 805i Chip Set\n"));

        pwszChip = L"S3 805i";
        cbChip = sizeof(L"S3 805i");

        hwDeviceExtension->Capabilities = (CAPS_HW_PATTERNS        |
                                            CAPS_MM_TRANSFER        |
                                            CAPS_MM_GLYPH_EXPAND    |
                                            CAPS_16_ENTRY_FIFO      |
                                            CAPS_NEW_BANK_CONTROL);

        *PointerCapability = (POINTER_BUILT_IN | POINTER_WORKS_ONLY_AT_8BPP);

        break;

    case SUBTYPE_80x:

        //
        // The 80x rev 'A' and 'B' chips had bugs that prevented them
        // from being able to do memory-mapped I/O.  I'm not enabling
        // memory-mapped I/O on later versions of the 80x because doing
        // so at this point would be a testing problem.
        //

        VideoDebugPrint((2, "S3: 801/805 Chip Set\n"));

        pwszChip = L"S3 801/805";
        cbChip = sizeof(L"S3 801/805");

        hwDeviceExtension->Capabilities = (CAPS_HW_PATTERNS        |
                                            CAPS_MM_TRANSFER        |
                                            CAPS_NEW_BANK_CONTROL);

        *PointerCapability = (POINTER_BUILT_IN | POINTER_WORKS_ONLY_AT_8BPP);

        break;

    case SUBTYPE_864:

        //
        // Note: The first 896/964 revs have a bug dealing with the pattern
        //       hardware, where we have to draw a 1x8 rectangle before
        //       using a pattern already realized in off-screen memory,
        //       so we set the RE_REALIZE_PATTERN flag.
        //

        hwDeviceExtension->Capabilities = (CAPS_HW_PATTERNS        |
                                            CAPS_MM_TRANSFER        |
                                            CAPS_MM_32BIT_TRANSFER  |
                                            CAPS_MM_IO              |
                                            CAPS_MM_GLYPH_EXPAND    |
                                            CAPS_16_ENTRY_FIFO      |
                                            CAPS_NEWER_BANK_CONTROL |
                                            CAPS_RE_REALIZE_PATTERN);


        VideoDebugPrint((2, "S3: 864 Chip Set\n"));

        pwszChip = L"S3 Vision864";
        cbChip = sizeof(L"S3 Vision864");

        *PointerCapability = (POINTER_BUILT_IN | POINTER_NEEDS_SCALING);

        break;

    case SUBTYPE_964:

        //
        // Note: The first 896/964 revs have a bug dealing with the pattern
        //       hardware, where we have to draw a 1x8 rectangle before
        //       using a pattern already realized in off-screen memory,
        //       so we set the RE_REALIZE_PATTERN flag.
        //

        hwDeviceExtension->Capabilities = (CAPS_HW_PATTERNS        |
                                            CAPS_MM_TRANSFER        |
                                            CAPS_MM_32BIT_TRANSFER  |
                                            CAPS_MM_IO              |
                                            CAPS_MM_GLYPH_EXPAND    |
                                            CAPS_16_ENTRY_FIFO      |
                                            CAPS_NEWER_BANK_CONTROL |
                                            CAPS_RE_REALIZE_PATTERN);

        VideoDebugPrint((2, "S3: 964 Chip Set\n"));

        pwszChip = L"S3 Vision964";
        cbChip = sizeof(L"S3 Vision964");

        break;

    case SUBTYPE_765:

        hwDeviceExtension->Capabilities = (CAPS_HW_PATTERNS        |
                                            CAPS_MM_TRANSFER        |
                                            CAPS_MM_32BIT_TRANSFER  |
                                            CAPS_MM_IO              |
                                            CAPS_MM_GLYPH_EXPAND    |
                                            CAPS_16_ENTRY_FIFO      |
                                            CAPS_NEWER_BANK_CONTROL);

        hwDeviceExtension->FrequencySecondaryIndex = 0x41;

        *PointerCapability = POINTER_BUILT_IN;

        VideoDebugPrint((2, "S3: Trio64V+ Chip Set\n"));

        pwszChip = L"S3 Trio64V+";
        cbChip = sizeof(L"S3 Trio64V+");

        hwDeviceExtension->Capabilities |= (CAPS_NEW_MMIO           |
                                            CAPS_STREAMS_CAPABLE    |
                                            CAPS_PACKED_EXPANDS);

        break;

    case SUBTYPE_764:

        hwDeviceExtension->Capabilities = (CAPS_HW_PATTERNS        |
                                            CAPS_MM_TRANSFER        |
                                            CAPS_MM_32BIT_TRANSFER  |
                                            CAPS_MM_IO              |
                                            CAPS_MM_GLYPH_EXPAND    |
                                            CAPS_16_ENTRY_FIFO      |
                                            CAPS_NEWER_BANK_CONTROL);

        hwDeviceExtension->FrequencySecondaryIndex = 0x41;

        *PointerCapability = POINTER_BUILT_IN;

        VideoDebugPrint((2, "S3: 764 Chip Set\n"));

        pwszChip = L"S3 764";
        cbChip = sizeof(L"S3 764");

        //
        // Our #9 and Diamond 764 boards occasionally fail the HCT
        // tests when we do dword or word reads from the frame buffer.
        // To get on the HCL lists, cards must pass the HCTs, so we'll
        // revert to byte reads for these chips:
        //

        hwDeviceExtension->Capabilities |= CAPS_BAD_DWORD_READS;

        break;

    case SUBTYPE_732:

        hwDeviceExtension->Capabilities = (CAPS_HW_PATTERNS        |
                                            CAPS_MM_TRANSFER        |
                                            CAPS_MM_32BIT_TRANSFER  |
                                            CAPS_MM_IO              |
                                            CAPS_MM_GLYPH_EXPAND    |
                                            CAPS_16_ENTRY_FIFO      |
                                            CAPS_NEWER_BANK_CONTROL);


        VideoDebugPrint((2, "S3: 732 Chip Set\n"));

        pwszChip = L"S3 732";
        cbChip = sizeof(L"S3 732");

        *PointerCapability = POINTER_BUILT_IN;

        hwDeviceExtension->FrequencySecondaryIndex = 0x41;

        break;

    case SUBTYPE_866:

        hwDeviceExtension->Capabilities = (CAPS_HW_PATTERNS        |
                                            CAPS_MM_TRANSFER        |
                                            CAPS_MM_32BIT_TRANSFER  |
                                            CAPS_MM_IO              |
                                            CAPS_MM_GLYPH_EXPAND    |
                                            CAPS_16_ENTRY_FIFO      |
                                            CAPS_NEWER_BANK_CONTROL);

        VideoDebugPrint((2, "S3: Vision866 Chip Set\n"));

        pwszChip = L"S3 Vision866";
        cbChip = sizeof(L"S3 Vision866");

        *PointerCapability = (POINTER_BUILT_IN |
                             POINTER_NEEDS_SCALING);    // Note scaling

        hwDeviceExtension->Capabilities |= (CAPS_NEW_MMIO           |
                                            CAPS_POLYGON            |
                                            CAPS_24BPP              |
                                            CAPS_BAD_24BPP          |
                                            CAPS_PACKED_EXPANDS);
        break;

    case SUBTYPE_868:

        hwDeviceExtension->Capabilities = (CAPS_HW_PATTERNS        |
                                            CAPS_MM_TRANSFER        |
                                            CAPS_MM_32BIT_TRANSFER  |
                                            CAPS_MM_IO              |
                                            CAPS_MM_GLYPH_EXPAND    |
                                            CAPS_16_ENTRY_FIFO      |
                                            CAPS_NEWER_BANK_CONTROL);

        VideoDebugPrint((2, "S3: Vision868 Chip Set\n"));

        pwszChip = L"S3 Vision868";
        cbChip = sizeof(L"S3 Vision868");

        *PointerCapability = (POINTER_BUILT_IN |
                             POINTER_NEEDS_SCALING);    // Note scaling

        hwDeviceExtension->Capabilities |= (CAPS_NEW_MMIO           |
                                            CAPS_POLYGON            |
                                            CAPS_24BPP              |
                                            CAPS_BAD_24BPP          |
                                            CAPS_PACKED_EXPANDS     |
                                            CAPS_PIXEL_FORMATTER);
        break;

    case SUBTYPE_968:

        hwDeviceExtension->Capabilities = (CAPS_HW_PATTERNS        |
                                            CAPS_MM_TRANSFER        |
                                            CAPS_MM_32BIT_TRANSFER  |
                                            CAPS_MM_IO              |
                                            CAPS_MM_GLYPH_EXPAND    |
                                            CAPS_16_ENTRY_FIFO      |
                                            CAPS_NEWER_BANK_CONTROL);

        VideoDebugPrint((2, "S3: Vision968 Chip Set\n"));

        pwszChip = L"S3 Vision968";
        cbChip = sizeof(L"S3 Vision968");

        hwDeviceExtension->Capabilities |= (CAPS_NEW_MMIO           |
                                            CAPS_POLYGON            |
                                            CAPS_24BPP              |
                                            CAPS_BAD_24BPP          |
                                            CAPS_PACKED_EXPANDS     |
                                            CAPS_PIXEL_FORMATTER);
        break;

    default:

        ASSERT(FALSE);

        VideoDebugPrint((1, "What type of S3 is this???\n"));
        pwszChip = L"S3 Unknown Chip Set";
        cbChip = sizeof(L"S3 Unknown Chip Set");

        break;
    }

    VideoPortWritePortUchar(CRT_ADDRESS_REG, 0x36);
    jBus = VideoPortReadPortUchar(CRT_DATA_REG) & 0x3;

    VideoPortWritePortUchar(CRT_ADDRESS_REG, 0x30);
    jChipID = VideoPortReadPortUchar(CRT_DATA_REG);


    if (jBus == 0x3) {

        //
        // Using the buffer expansion method of drawing text is always
        // faster on ISA buses than the glyph expansion method.
        //

        hwDeviceExtension->Capabilities &= ~CAPS_MM_GLYPH_EXPAND;

        //
        // We have to disable memory-mapped I/O in some situations
        // on ISA buses.
        //
        // We can't do any memory-mapped I/O on ISA systems with
        // rev A through D 928's, or rev A or B 801/805's.
        //

        if (((hwDeviceExtension->ChipID == S3_928) && (jChipID < 0x94)) ||
            ((hwDeviceExtension->ChipID == S3_801) && (jChipID < 0xA2))) {

            hwDeviceExtension->Capabilities &= ~(CAPS_MM_TRANSFER | CAPS_MM_IO);
        }

    }

    //
    // We have some weird initialization bug on newer Diamond Stealth
    // 805 and 928 local bus cards where if we enable memory-mapped I/O,
    // even if we don't use it, we'll get all kinds of weird access
    // violations in the system.  The card is sending garbage over the
    // bus?  As a work-around I am simply disabling memory-mappped I/O
    // on newer Diamond 928/928PCI and 805 cards.  It is not a problem
    // with their 964 or newer cards.
    //

    if (hwDeviceExtension->BoardID == S3_DIAMOND) {

        if ((((jChipID & 0xF0) == 0x90) && (jChipID >= 0x94)) ||
            (((jChipID & 0xF0) == 0xB0) && (jChipID >= 0xB0)) ||
            (((jChipID & 0xF0) == 0xA0) && (jChipID >= 0xA2))) {

            hwDeviceExtension->Capabilities
                &= ~(CAPS_MM_TRANSFER | CAPS_MM_IO | CAPS_MM_GLYPH_EXPAND);
            VideoDebugPrint((1, "S3: Disabling Diamond memory-mapped I/O\n"));
        }
    }

    if (hwDeviceExtension->Capabilities & CAPS_NEW_MMIO) {

        //
        // Are we actually using new MMIO? If the length
        // of the range for linear frame buffer entry
        // in the accessRanges array is zero, then we aren't
        // really using NEW_MMIO
        //

        if (accessRange[LINEAR_FRAME_BUF].RangeLength == 0)
        {
            hwDeviceExtension->Capabilities &= ~CAPS_NEW_MMIO;
        }

    }

    VideoPortSetRegistryParameters(hwDeviceExtension,
                                   L"HardwareInformation.ChipType",
                                   pwszChip,
                                   cbChip);
}

VOID
S3DetermineFrequencyTable(
    PVOID HwDeviceExtension,
    VIDEO_ACCESS_RANGE accessRange[],
    INTERFACE_TYPE AdapterInterfaceType
    )

/*++

Routine Description:

    Try to determine which frequency table to use based on the
    vendor string in the bios.

Arguments:

    HwDeviceExtension - Pointer to the miniport's device extension.

Return Value:

    The accessRange array may have been modified.

--*/

{
    PHW_DEVICE_EXTENSION hwDeviceExtension = HwDeviceExtension;
    PVOID romAddress;
    PWSTR pwszAdapterString = L"S3 Compatible";
    ULONG cbAdapterString = sizeof(L"S3 Compatible");

    //
    // We will try to recognize the boards for which we have special
    // frequency/modeset support.
    //

    //
    // Set the defaults for the board type.
    //

    hwDeviceExtension->BoardID = S3_GENERIC;
    hwDeviceExtension->FixedFrequencyTable = GenericFixedFrequencyTable;

    if (hwDeviceExtension->ChipID <= S3_928) {

        hwDeviceExtension->Int10FrequencyTable = GenericFrequencyTable;

    } else {

        hwDeviceExtension->Int10FrequencyTable = Generic64NewFrequencyTable;
    }

    romAddress = hwDeviceExtension->MappedAddress[0];

    //
    // Look for brand name signatures in the ROM.
    //

    if (VideoPortScanRom(hwDeviceExtension,
                         romAddress,
                         MAX_ROM_SCAN,
                         "Number Nine ")) {

        hwDeviceExtension->BoardID = S3_NUMBER_NINE;

        pwszAdapterString = L"Number Nine";
        cbAdapterString = sizeof(L"Number Nine");

        //
        // We can set the refresh on 864/964 Number Nine boards.
        //

        if (hwDeviceExtension->ChipID >= S3_864) {

            hwDeviceExtension->Int10FrequencyTable = NumberNine64FrequencyTable;

        //
        // We also have frequency tables for 928-based GXE boards.
        //

        } else if (hwDeviceExtension->ChipID == S3_928) {

            UCHAR *pjRefString;
            UCHAR *pjBiosVersion;
            UCHAR offset;
            LONG  iCmpRet;

            hwDeviceExtension->Int10FrequencyTable = NumberNine928OldFrequencyTable;
            hwDeviceExtension->FixedFrequencyTable = NumberNine928NewFixedFrequencyTable;

            //
            // We know (at least we think) this is Number Nine board.
            // There was a bios change at #9 to change the refresh rate
            // mapping.  This change was made at Microsofts request.  The
            // problem is that the change has not make into production at
            // the time this driver was written.  For this reason, we must
            // check the bios version number, before we special case the
            // card as the number nine card.
            //
            // There is a byte in the bios at offset 0x190, that is the
            // offset from the beginning of the bios for the bios version
            // number.  The bios version number is a string.  All the
            // bios versions before 1.10.04 need this special translation.
            // all the other bios's use a translation closer to the s3
            // standard.
            //

            offset = VideoPortReadRegisterUchar(
                            ((PUCHAR) romAddress) + 0x190);

            pjBiosVersion = (PUCHAR) romAddress + offset;

            pjRefString = "1.10.04";
            iCmpRet = CompareRom(pjBiosVersion,
                                 pjRefString);

            if (iCmpRet >= 0) {

                hwDeviceExtension->Int10FrequencyTable = NumberNine928NewFrequencyTable;

            }
        }

    } else if (VideoPortScanRom(hwDeviceExtension,
                                romAddress,
                                MAX_ROM_SCAN,
                                "Orchid Technology Fahrenheit 1280")) {

        hwDeviceExtension->BoardID = S3_ORCHID;

        pwszAdapterString = L"Orchid Technology Fahrenheit 1280";
        cbAdapterString = sizeof(L"Orchid Technology Fahrenheit 1280");

        //
        // Only the 911 Orchid board needs specific init parameters.
        // Otherwise, fall through the generic function.
        //

        if (hwDeviceExtension->ChipID == S3_911) {

            hwDeviceExtension->FixedFrequencyTable = OrchidFixedFrequencyTable;

        }

    } else if (VideoPortScanRom(hwDeviceExtension,
                                romAddress,
                                MAX_ROM_SCAN,
                                "Diamond")) {

        hwDeviceExtension->BoardID = S3_DIAMOND;

        pwszAdapterString = L"Diamond Stealth";
        cbAdapterString = sizeof(L"Diamond Stealth");

        //
        // We can set the frequency on 864 and 964 Diamonds.
        //

        if (hwDeviceExtension->ChipID >= S3_864) {

            hwDeviceExtension->Int10FrequencyTable = Diamond64FrequencyTable;

            //
            // Not only did Diamond decide to have a different
            // frequency convention from S3's standard, they also
            // chose to use a different register than S3 did with
            // the 764:
            //

            if (hwDeviceExtension->FrequencySecondaryIndex == 0x41) {

                hwDeviceExtension->FrequencySecondaryIndex = 0x6B;
            }
        }

    } else if (VideoPortScanRom(hwDeviceExtension,
                                romAddress,
                                MAX_ROM_SCAN,
                                "HP Ultra")) {

        hwDeviceExtension->BoardID = S3_HP;

        pwszAdapterString = L"HP Ultra";
        cbAdapterString = sizeof(L"HP Ultra");

    } else if (VideoPortScanRom(hwDeviceExtension,
                                romAddress,
                                MAX_ROM_SCAN,
                                "DELL")) {

        hwDeviceExtension->BoardID = S3_DELL;

        pwszAdapterString = L"DELL";
        cbAdapterString = sizeof(L"DELL");

        //
        // We only have frequency tables for 805 based DELLs.
        //
        // DELLs with onboard 765s can use the Hercules Frequency Table.
        //

        if (hwDeviceExtension->ChipID == S3_801) {

            hwDeviceExtension->Int10FrequencyTable = Dell805FrequencyTable;

        } else if ((hwDeviceExtension->ChipID >= S3_864) &&
                   (hwDeviceExtension->SubTypeID == SUBTYPE_765)) {

            hwDeviceExtension->Int10FrequencyTable = HerculesFrequencyTable;

        }

    } else if (VideoPortScanRom(hwDeviceExtension,
                                romAddress,
                                MAX_ROM_SCAN,
                                "Metheus")) {

        pwszAdapterString = L"Metheus";
        cbAdapterString = sizeof(L"Metheus");

        hwDeviceExtension->BoardID = S3_METHEUS;

        if (hwDeviceExtension->ChipID == S3_928) {

            hwDeviceExtension->Int10FrequencyTable = Metheus928FrequencyTable;
        }

    } else if (VideoPortScanRom(hwDeviceExtension,
                                romAddress,
                                MAX_ROM_SCAN,
                                "Hercules")) {

        if ((hwDeviceExtension->SubTypeID == SUBTYPE_732) ||
            (hwDeviceExtension->SubTypeID == SUBTYPE_764) ||
            (hwDeviceExtension->SubTypeID == SUBTYPE_765)) {

            hwDeviceExtension->Int10FrequencyTable = HerculesFrequencyTable;

        } else if ((hwDeviceExtension->SubTypeID == SUBTYPE_964) ||
                   (hwDeviceExtension->SubTypeID == SUBTYPE_864)) {

            hwDeviceExtension->Int10FrequencyTable = Hercules64FrequencyTable;

        } else if ((hwDeviceExtension->SubTypeID == SUBTYPE_968) ||
                   (hwDeviceExtension->SubTypeID == SUBTYPE_868)) {

            hwDeviceExtension->Int10FrequencyTable = Hercules68FrequencyTable;

        }

    } else if (VideoPortScanRom(hwDeviceExtension,
                                romAddress,
                                MAX_ROM_SCAN,
                                "Phoenix S3")) {

        pwszAdapterString = L"Phoenix";
        cbAdapterString = sizeof(L"Phoenix");

        if (hwDeviceExtension->ChipID >= S3_864) {

            //
            // The Phoenix 864/964 BIOS is based on S3's sample BIOS.
            // Most of the 1.00 versions subscribe to the old 864/964
            // refresh convention; most newer versions subscribe
            // to the newer refresh convention.  Unfortunately, there
            // are exceptions: the ValuePoint machines have '1.00'
            // versions, but subscribe to the new convention.
            //
            // There are probably other exceptions we don't know about,
            // so we leave 'Use Hardware Default' as a refresh option
            // for the user.
            //

            if (VideoPortScanRom(hwDeviceExtension,
                                  romAddress,
                                  MAX_ROM_SCAN,
                                  "Phoenix S3 Vision") &&
                VideoPortScanRom(hwDeviceExtension,
                                  romAddress,
                                  MAX_ROM_SCAN,
                                  "VGA BIOS. Version 1.00") &&
                !VideoPortScanRom(hwDeviceExtension,
                                 romAddress,
                                 MAX_ROM_SCAN,
                                 "COPYRIGHT IBM")) {

                hwDeviceExtension->Int10FrequencyTable = Generic64OldFrequencyTable;

            } else {

                hwDeviceExtension->Int10FrequencyTable = Generic64NewFrequencyTable;

            }
        }
    }


#if defined(_X86_)

    if ((hwDeviceExtension->BiosPresent == FALSE) &&
        (AdapterInterfaceType == MicroChannel))
    {
        VP_STATUS status;

        //
        // This must be an IBM PS/2 with onboard S3 (no bios)
        //
        // We should release our claim on the video bios.
        //

        accessRange[0].RangeStart.LowPart = 0;
        accessRange[0].RangeStart.HighPart = 0;
        accessRange[0].RangeLength = 0;

        pwszAdapterString = L"IBM MicroChannel";
        cbAdapterString = sizeof(L"IBM MicroChannel");

        hwDeviceExtension->BoardID = S3_IBM_PS2;

        //
        // We have to re-reserve every port.
        //

        status = VideoPortVerifyAccessRanges(hwDeviceExtension,
                                             NUM_S3_ACCESS_RANGES,
                                             accessRange);

        if (status != NO_ERROR) {

            VideoDebugPrint((1, "S3: Access Range conflict after ROM change\n"));
            ASSERT(FALSE);

        }

        //
        // If the machine does not have an S3 BIOS, then we need to
        // restore bits 4, 5, and 6 of CRTC reg 0x5C when returning
        // to a VGA mode.
        //
        // Here we'll store bits 4-6 of CRTC reg 0x5c, and set bit
        // 7.  When restoring the mode we'll reset the high order
        // nibble of 0x5c to this value.
        //

        VideoPortWritePortUchar(CRT_ADDRESS_REG, 0x5c);
        hwDeviceExtension->CR5C = (VideoPortReadPortUchar(CRT_DATA_REG)
                                    & 0x70) | 0x80;

    }

#endif

    VideoPortSetRegistryParameters(hwDeviceExtension,
                                   L"HardwareInformation.AdapterString",
                                   pwszAdapterString,
                                   cbAdapterString);

    //
    // Is this a multi-card?
    //

    if (VideoPortScanRom(hwDeviceExtension,
                         (PVOID)((PUCHAR)romAddress + 0x7ff0),
                         8,
                         "612167")) {

        VideoDebugPrint((1, "Found a MEGA Lightning, dual S3 968\n"));

        hwDeviceExtension->ChildCount = 1;

    } else if (VideoPortScanRom(hwDeviceExtension,
                         (PVOID)((PUCHAR)romAddress + 0x7ff0),
                         8,
                         "612168")) {

        VideoDebugPrint((1, "Found a Pro Lightning+, dual S3 Trio64V+\n"));

        hwDeviceExtension->ChildCount = 1;

    } else if (VideoPortScanRom(hwDeviceExtension,
                         (PVOID)((PUCHAR)romAddress + 0x7ff0),
                         8,
                         "612167")) {

        VideoDebugPrint((1, "Found Quad Pro Lightning V+, quad S3 Trio64V+\n"));

        hwDeviceExtension->ChildCount = 3;

    }
}

VOID
S3DetermineDACType(
    PVOID pvHwDeviceExtension,
    POINTER_CAPABILITY *PointerCapability
    )

/*++

Routine Description:

    Determine the DAC type for HwPointer Capabilities.

Arguments:

    pHwDeviceExtension - Pointer to the miniport's device extension.

Return Value:

    None.

--*/

{
    PHW_DEVICE_EXTENSION HwDeviceExtension = pvHwDeviceExtension;

    UCHAR jBt485Status;
    UCHAR jExtendedVideoDacControl;
    UCHAR jTiIndex;
    UCHAR jGeneralOutput;
    UCHAR jTiDacId;

    PWSTR pwszDAC, pwszAdapterString = L"S3 Compatible";
    ULONG cbDAC, cbAdapterString = sizeof(L"S3 Compatible");

    HwDeviceExtension->DacID = UNKNOWN_DAC;
    pwszDAC = L"Unknown";
    cbDAC = sizeof(L"Unknown");


    //
    // We'll use a software pointer in all modes if the user sets
    // the correct entry in the registry (because I predict that
    // people will have hardware pointer problems on some boards,
    // or won't like our jumpy S3 pointer).
    //

    if (NO_ERROR == VideoPortGetRegistryParameters(HwDeviceExtension,
                                                   L"UseSoftwareCursor",
                                                   FALSE,
                                                   S3RegistryCallback,
                                                   NULL)) {

        HwDeviceExtension->Capabilities |= CAPS_SW_POINTER;
    } else if (!(*PointerCapability & POINTER_BUILT_IN) ||
               (HwDeviceExtension->ChipID == S3_928)) {

        //
        // Check for a TI TVP3020 or 3025 DAC.
        //
        // The TI3025 is sort of Brooktree 485 compatible.  Unfortunately,
        // there is a hardware bug between the TI and the 964 that
        // causes the screen to occasionally jump when the pointer shape
        // is changed.  Consequently, we have to specifically use the
        // TI pointer on the TI DAC.
        //
        // We also encountered some flakey Level 14 Number Nine boards
        // that would show garbage on the screen when we used the S3
        // internal pointer; consequently, we use the TI pointer instead.
        //

        VideoPortWritePortUchar(CRT_ADDRESS_REG, 0x5C);

        jGeneralOutput = VideoPortReadPortUchar(CRT_DATA_REG);

        VideoPortWritePortUchar(CRT_DATA_REG, (UCHAR) (jGeneralOutput & ~0x20));
                                        // Select TI mode in the DAC

        VideoPortWritePortUchar(CRT_ADDRESS_REG, 0x55);
                                        // Set CRTC index to EX_DAC_CT

        jExtendedVideoDacControl = VideoPortReadPortUchar(CRT_DATA_REG);

        VideoPortWritePortUchar(CRT_DATA_REG, (UCHAR) ((jExtendedVideoDacControl & 0xfc) | 0x01));

        jTiIndex = VideoPortReadPortUchar(TI025_INDEX_REG);

        VideoPortWritePortUchar(TI025_INDEX_REG, 0x3f);
                                        // Select ID register

        if (VideoPortReadPortUchar(TI025_INDEX_REG) == 0x3f) {

            jTiDacId = VideoPortReadPortUchar(TI025_DATA_REG);

            if ((jTiDacId == 0x25) || (jTiDacId == 0x20)) {

                HwDeviceExtension->Capabilities |= CAPS_TI025_POINTER;
                HwDeviceExtension->DacID = TI_3020; // 3020 compatible

                pwszDAC = L"TI TVP3020/3025";
                cbDAC = sizeof(L"TI TVP3020/3025");
            }
        }

        //
        // Restore all the registers.
        //

        VideoPortWritePortUchar(TI025_INDEX_REG, jTiIndex);

        VideoPortWritePortUchar(CRT_ADDRESS_REG, 0x55);

        VideoPortWritePortUchar(CRT_DATA_REG, jExtendedVideoDacControl);

        VideoPortWritePortUchar(CRT_ADDRESS_REG, 0x5C);

        VideoPortWritePortUchar(CRT_DATA_REG, jGeneralOutput);

        if (!(HwDeviceExtension->Capabilities & CAPS_DAC_POINTER)) {

            //
            // Check for a TI TVP3026 DAC.
            //
            // The procedure here is courtesy of Diamond Multimedia.
            //

            VideoPortWritePortUchar(CRT_ADDRESS_REG, 0x55);
                                            // Set CRTC index to EX_DAC_CT

            jExtendedVideoDacControl = VideoPortReadPortUchar(CRT_DATA_REG);

            VideoPortWritePortUchar(CRT_DATA_REG,
                    (UCHAR) (jExtendedVideoDacControl & 0xfc));

            VideoPortWritePortUchar(DAC_ADDRESS_WRITE_PORT, 0x3f);

            VideoPortWritePortUchar(CRT_DATA_REG,
                    (UCHAR) ((jExtendedVideoDacControl & 0xfc) | 0x2));

            VideoPortWritePortUchar(CRT_ADDRESS_REG, 0x37);

            jTiDacId = VideoPortReadPortUchar(CRT_DATA_REG);

            if (VideoPortReadPortUchar(DAC_PIXEL_MASK_REG) == 0x26) {

                //
                // The 3026 is Brooktree 485 compatible, except for a
                // hardware bug that causes the hardware pointer to
                // 'sparkle' when setting the palette colours, unless we
                // wait for vertical retrace first:
                //

                HwDeviceExtension->Capabilities
                    |= (CAPS_BT485_POINTER | CAPS_WAIT_ON_PALETTE);

                HwDeviceExtension->DacID = BT_485; // 485 compatible

                pwszDAC = L"TI TVP3026";
                cbDAC = sizeof(L"TI TVP3026");
            }

            //
            // Restore all the registers.
            //

            VideoPortWritePortUchar(CRT_ADDRESS_REG, 0x55);

            VideoPortWritePortUchar(CRT_DATA_REG, jExtendedVideoDacControl);
        }

        if (!(HwDeviceExtension->Capabilities & CAPS_DAC_POINTER)) {

            //
            // Check for a BrookTree 485 DAC.
            //

            VideoPortWritePortUchar(BT485_ADDR_CMD_REG0, 0xff);
                                            // Output 0xff to BT485 command register 0

            VideoPortWritePortUchar(CRT_ADDRESS_REG, 0x55);
                                            // Set CRTC index to EX_DAC_CT

            jExtendedVideoDacControl = VideoPortReadPortUchar(CRT_DATA_REG);

            VideoPortWritePortUchar(CRT_DATA_REG, (UCHAR) ((jExtendedVideoDacControl & 0xfc) | 0x02));

            jBt485Status = VideoPortReadPortUchar(BT485_ADDR_CMD_REG0);
                                            // Read Bt485 status register 0

            VideoPortWritePortUchar(CRT_ADDRESS_REG, 0x55);
                                            // Set CRTC index to 0x55

            jExtendedVideoDacControl = VideoPortReadPortUchar(CRT_DATA_REG);

            VideoPortWritePortUchar(CRT_DATA_REG, (UCHAR) (jExtendedVideoDacControl & 0xfc));

            if (jBt485Status != 0xff) {

                HwDeviceExtension->Capabilities |= CAPS_BT485_POINTER;

                pwszDAC = L"Brooktree Bt485";
                cbDAC = sizeof(L"Brooktree Bt485");
                HwDeviceExtension->DacID = BT_485;
            }
        }
    }

    //
    // This section looks for an S3 SDAC if another was not detected,
    // for the PPC.
    //

    if (HwDeviceExtension->DacID == UNKNOWN_DAC) {

        //
        // Only try this on an 864 or newer, because Orchid Farhenheit
        // 1280 911 boards would get black screens when in VGA mode and
        // this code was run (such as during initial Setup):
        //

        if ((HwDeviceExtension->ChipID >= S3_864) &&
            FindSDAC(HwDeviceExtension)) {

            //
            // SDAC does not provide a cursor, but we can use the cursor
            // built into the S3 (if there is one).
            //

            pwszDAC = L"S3 SDAC";
            cbDAC = sizeof(L"S3 SDAC");
            HwDeviceExtension->DacID = S3_SDAC;
        }
    }

    VideoPortSetRegistryParameters(HwDeviceExtension,
                                   L"HardwareInformation.DacType",
                                   pwszDAC,
                                   cbDAC);


}

VOID
S3DetermineMemorySize(
    PVOID HwDeviceExtension
    )
{
    PHW_DEVICE_EXTENSION hwDeviceExtension = HwDeviceExtension;
    UCHAR s3MemSizeCode;

    //
    // Get the size of the video memory.
    //

    VideoPortWritePortUchar(CRT_ADDRESS_REG, 0x36);
    s3MemSizeCode = (VideoPortReadPortUchar(CRT_DATA_REG) >> 5) & 0x7;

    if (hwDeviceExtension->ChipID == S3_911) {

        if (s3MemSizeCode & 1) {

            hwDeviceExtension->AdapterMemorySize = 0x00080000;

        } else {

            hwDeviceExtension->AdapterMemorySize = 0x00100000;

        }

    } else {

        hwDeviceExtension->AdapterMemorySize = gacjMemorySize[s3MemSizeCode];

    }

    VideoPortSetRegistryParameters(hwDeviceExtension,
                                   L"HardwareInformation.MemorySize",
                                   &hwDeviceExtension->AdapterMemorySize,
                                   sizeof(ULONG));

}

VOID
S3ValidateModes(
    PVOID HwDeviceExtension,
    POINTER_CAPABILITY *PointerCapability
    )

/*++

Routine Description:

    For fill in the capabilities bits for the s3 card, and return an
    wide character string representing the chip.

Arguments:

    HwDeviceExtension - Pointer to the miniport's device extension.

Return Value:

    None.

--*/

{
    PHW_DEVICE_EXTENSION hwDeviceExtension = HwDeviceExtension;

    PS3_VIDEO_FREQUENCIES FrequencyEntry;
    PS3_VIDEO_MODES ModeEntry;
    PS3_VIDEO_FREQUENCIES FrequencyTable;

    ULONG i;

    ULONG ModeIndex;

    UCHAR reg67;
    UCHAR jChipID, jRevision;

    VideoPortWritePortUchar(CRT_ADDRESS_REG, 0x30);
    jChipID = VideoPortReadPortUchar(CRT_DATA_REG);

    /////////////////////////////////////////////////////////////////////////
    // Here we prune valid modes, based on rules according to the chip
    // capabilities and memory requirements.  It would be better if we
    // could make the VESA call to determine the modes that the BIOS
    // supports; however, that requires a buffer and I don't have the
    // time to get it working with our Int 10 support.
    //
    // We prune modes so that we will not annoy the user by presenting
    // modes in the 'Video Applet' which we know the user can't use.
    //

    hwDeviceExtension->NumAvailableModes = 0;
    hwDeviceExtension->NumTotalModes = 0;

    //
    // Since there are a number of frequencies possible for each
    // distinct resolution/colour depth, we cycle through the
    // frequency table and find the appropriate mode entry for that
    // frequency entry.
    //

    if (hwDeviceExtension->BiosPresent) {

        FrequencyTable = hwDeviceExtension->Int10FrequencyTable;

    } else {

        //
        // If there is no BIOS, construct the mode list from whatever
        // fixed frequency tables we have for this chip.
        //

        FrequencyTable = hwDeviceExtension->FixedFrequencyTable;
    }

    ModeIndex = 0;

    for (FrequencyEntry = FrequencyTable;
         FrequencyEntry->BitsPerPel != 0;
         FrequencyEntry++, ModeIndex++) {

        //
        // Find the mode for this entry.  First, assume we won't find one.
        //

        FrequencyEntry->ModeValid = FALSE;
        FrequencyEntry->ModeIndex = ModeIndex;

        for (ModeEntry = S3Modes, i = 0; i < NumS3VideoModes; ModeEntry++, i++) {

            if ((FrequencyEntry->BitsPerPel ==
                    ModeEntry->ModeInformation.BitsPerPlane) &&
                (FrequencyEntry->ScreenWidth ==
                    ModeEntry->ModeInformation.VisScreenWidth)) {

                //
                // We've found a mode table entry that matches this frequency
                // table entry.  Now we'll figure out if we can actually do
                // this mode/frequency combination.  For now, assume we'll
                // succeed.
                //

                FrequencyEntry->ModeEntry = ModeEntry;
                FrequencyEntry->ModeValid = TRUE;

                //
                // Flags for private communication with the S3 display driver.
                //

                ModeEntry->ModeInformation.DriverSpecificAttributeFlags =
                    hwDeviceExtension->Capabilities;

                if (*PointerCapability & POINTER_WORKS_ONLY_AT_8BPP) {

                    //
                    // Rule: On 911, 80x, and 928 chips we always use the
                    //       built-in S3 pointer whenever we can; modes of
                    //       colour depths greater than 8bpp, or resolutions
                    //       of width more than 1024, require a DAC pointer.
                    //

                    if ((ModeEntry->ModeInformation.BitsPerPlane == 8) &&
                        (ModeEntry->ModeInformation.VisScreenWidth <= 1024)) {

                        //
                        // Always use the S3 pointer in lieu of the Brooktree
                        // or TI pointer whenever we can.
                        //

                        ModeEntry->ModeInformation.DriverSpecificAttributeFlags
                            &= ~CAPS_DAC_POINTER;

                        if ((hwDeviceExtension->DacID == TI_3020) &&
                            (hwDeviceExtension->ChipID == S3_928)) {

                            //
                            // There are goofy 4-MB Level 14 #9 boards where
                            // stuff is shown on the screen if we try to use
                            // the built-in S3 pointer, and the hot-spot
                            // is wrong if we try to use the TI pointer.
                            // There are other 928 boards with TI 3020 DACs
                            // where the internal S3 pointer doesn't work.  So
                            // punt to a software pointer for these modes:
                            //

                            ModeEntry->ModeInformation.DriverSpecificAttributeFlags
                                |= CAPS_SW_POINTER;
                        }

                    } else {

                        //
                        // We can't use the built-in S3 pointer; if we don't
                        // have a DAC pointer, use a software pointer.
                        //

                        if (!(ModeEntry->ModeInformation.DriverSpecificAttributeFlags
                            & CAPS_DAC_POINTER)) {

                            ModeEntry->ModeInformation.DriverSpecificAttributeFlags
                                |= CAPS_SW_POINTER;
                        }
                    }

                } else {

                    //
                    // On 864/964 or newer chips, the built-in S3 pointer
                    // either handles all colour depths or none.
                    //

                    if (*PointerCapability & POINTER_BUILT_IN) {

                        if (*PointerCapability & POINTER_NEEDS_SCALING) {

                            //
                            // Check out the type of DAC:
                            //
                            // Note: This I/O should likely be moved out of the
                            //       prune loop.
                            //

                            VideoPortWritePortUchar(CRT_ADDRESS_REG, 0x67);
                            reg67 = (UCHAR) VideoPortReadPortUchar(CRT_DATA_REG);

                            //
                            // Newer 864 BIOSes revert to 8-bit DAC mode when
                            // running at 640x480x16bpp even if the DAC is
                            // 16-bits, due to a conflict with the Reel Magic
                            // MPEG board at that resolution.  Unfortunately,
                            // there's not a consistent BIOS version number
                            // that we can look for; we could check the
                            // DAC type after doing the int 10, but
                            // unfortunately, we need this information now
                            // to decide whether we should scale the x-
                            // coordinate or not.
                            //
                            // So simply always use a software pointer when
                            // running at 640x480x16bpp, and there is no
                            // DAC pointer:
                            //

                            if (!(ModeEntry->ModeInformation.DriverSpecificAttributeFlags
                                  & CAPS_DAC_POINTER) &&
                                (ModeEntry->ModeInformation.BitsPerPlane == 16) &&
                                (ModeEntry->ModeInformation.VisScreenWidth == 640)) {

                                ModeEntry->ModeInformation.DriverSpecificAttributeFlags
                                    |= CAPS_SW_POINTER;

                            } else if (reg67 == 8) {

                                //
                                // It's an 8bit DAC.  At 16bpp, we have to
                                // scale the x-coordinate by 2.  At 32bpp,
                                // we have to use a software pointer.
                                //

                                if (ModeEntry->ModeInformation.BitsPerPlane == 16) {

                                    ModeEntry->ModeInformation.DriverSpecificAttributeFlags
                                        |= CAPS_SCALE_POINTER;

                                } else {

                                    ModeEntry->ModeInformation.DriverSpecificAttributeFlags
                                        |= CAPS_SW_POINTER;
                                }

                            } else {

                                //
                                // It's a 16bit DAC.  For 32bpp modes, we have
                                // to scale the pointer position by 2:
                                //

                                if (ModeEntry->ModeInformation.BitsPerPlane == 32) {

                                    ModeEntry->ModeInformation.DriverSpecificAttributeFlags
                                        |= CAPS_SCALE_POINTER;
                                }
                            }
                        }
                    } else {

                        //
                        // There's no built-in S3 pointer.  If we haven't
                        // detected a DAC pointer, we have to use a software
                        // pointer.
                        //

                        if (!(ModeEntry->ModeInformation.DriverSpecificAttributeFlags
                            & CAPS_DAC_POINTER)) {

                            ModeEntry->ModeInformation.DriverSpecificAttributeFlags
                                |= CAPS_SW_POINTER;
                        }
                    }
                }

                //
                // Rule: We allow refresh rates higher than 76 Hz only for
                //       cards that don't have a built-in S3 pointer.  We
                //       do this because we assume that such cards are VRAM
                //       based and have a good external DAC that can properly
                //       handle rates higher than 76 Hz -- because we have
                //       found many Diamond DRAM cards that produce improper
                //       displays at the higher rates, especially on non-x86
                //       machines.
                //

                if ((FrequencyEntry->ScreenFrequency > 76) &&
                    (*PointerCapability & POINTER_BUILT_IN)) {

                    FrequencyEntry->ModeValid = FALSE;

                }

                //
                // Rule: We handle only 8bpp on 911/924 cards.  These chips can also
                //       support only non-contiguous modes.
                //

                if (hwDeviceExtension->ChipID == S3_911) {

                    if (ModeEntry->ModeInformation.BitsPerPlane != 8) {

                        FrequencyEntry->ModeValid = FALSE;

                    } else {

                        ModeEntry->Int10ModeNumberContiguous =
                            ModeEntry->Int10ModeNumberNoncontiguous;

                        ModeEntry->ScreenStrideContiguous =
                            ModeEntry->ModeInformation.ScreenStride;
                    }
                }

                //
                // Rule: The 868/968 cannot do 'new packed 32-bit transfers'
                //       at 8bpp because of a chip bug.
                //

                if ((ModeEntry->ModeInformation.BitsPerPlane == 8) &&
                    ((hwDeviceExtension->SubTypeID == SUBTYPE_868) ||
                     (hwDeviceExtension->SubTypeID == SUBTYPE_968))) {

                    ModeEntry->ModeInformation.DriverSpecificAttributeFlags
                        &= ~CAPS_PACKED_EXPANDS;
                }

                //
                // Rule: The 801/805 cannot do any accelerated modes above
                //       16bpp.
                //

                if ((hwDeviceExtension->ChipID == S3_801) &&
                    (ModeEntry->ModeInformation.BitsPerPlane > 16)) {

                    FrequencyEntry->ModeValid = FALSE;
                }

                //
                // Rule: We use the 2xx non-contiguous modes whenever we can
                //       on 80x/928 boards because some BIOSes have bugs for
                //       the contiguous 8bpp modes.
                //
                //       We don't use the non-contiguous modes on 864 cards
                //       because most 864 BIOSes have a bug where they don't
                //       set the M and N parameters correctly on 1 MB cards,
                //       causing screen noise.
                //

                if ((ModeEntry->ModeInformation.BitsPerPlane == 8) &&
                    (hwDeviceExtension->ChipID <= S3_928)) {

                    //
                    // If we have only 512k, we can't use a non-contiguous
                    // 800x600x256 mode.
                    //

                    if ((ModeEntry->ModeInformation.VisScreenWidth == 640) ||
                        ((ModeEntry->ModeInformation.VisScreenWidth == 800) &&
                         (hwDeviceExtension->AdapterMemorySize > 0x080000))) {

                        ModeEntry->Int10ModeNumberContiguous =
                            ModeEntry->Int10ModeNumberNoncontiguous;

                        ModeEntry->ScreenStrideContiguous =
                            ModeEntry->ModeInformation.ScreenStride;
                    }
                }

                //
                // Rule: Only 964 or 968 or newer boards can handle resolutions
                //       larger than 1280x1024:
                //

                if (ModeEntry->ModeInformation.VisScreenWidth > 1280) {

                    if ((hwDeviceExtension->SubTypeID != SUBTYPE_964) &&
                        (hwDeviceExtension->SubTypeID < SUBTYPE_968)) {

                        FrequencyEntry->ModeValid = FALSE;
                    }
                }

                //
                // Rule: 911s and early revs of 805s and 928s cannot do
                //       1152x864:
                //

                if (ModeEntry->ModeInformation.VisScreenWidth == 1152) {

                    if ((hwDeviceExtension->ChipID == S3_911) ||
                        (jChipID == 0xA0)                     ||
                        (jChipID == 0x90)) {

                        FrequencyEntry->ModeValid = FALSE;
                    }

                    //
                    // Number 9 has different int 10 numbers from
                    // Diamond for 1152x864x16bpp and 1152x864x32bpp.
                    // Later perhaps we should incorporate mode numbers
                    // along with the frequency tables.
                    //

                    if (hwDeviceExtension->BoardID == S3_NUMBER_NINE) {

                        if (ModeEntry->ModeInformation.BitsPerPlane == 16) {

                            ModeEntry->Int10ModeNumberContiguous =
                                ModeEntry->Int10ModeNumberNoncontiguous =
                                    0x126;

                        } else if (ModeEntry->ModeInformation.BitsPerPlane == 32) {

                            ModeEntry->Int10ModeNumberContiguous =
                                ModeEntry->Int10ModeNumberNoncontiguous =
                                    0x127;
                        }

                    }
                }

                //
                // 24bpp support. Need s3 968 and linear space for banks.
                //
                if (ModeEntry->ModeInformation.BitsPerPlane == 24) {

                    //
                    // 24bpp on diamond s3 968 seems to have problems doing ULONG reads.
                    //

                    if (hwDeviceExtension->BoardID == S3_DIAMOND)
                        ModeEntry->ModeInformation.DriverSpecificAttributeFlags |=
                            CAPS_BAD_DWORD_READS;

                    //
                    // Set FALSE for other than 968 and clear CAPS_BAD_DWORD_READS.
                    //

                    if ((hwDeviceExtension->SubTypeID != SUBTYPE_968) ||
                        ((hwDeviceExtension->BoardID != S3_DIAMOND) &&
                         (hwDeviceExtension->BoardID != S3_NUMBER_NINE)) ||           //#9 968 24bpp
                        (!(hwDeviceExtension->Capabilities & CAPS_NEW_MMIO))) {

                        FrequencyEntry->ModeValid = FALSE;

                        ModeEntry->ModeInformation.DriverSpecificAttributeFlags &=
                            ~CAPS_BAD_DWORD_READS;
                    }
                }

                if ((ModeEntry->ModeInformation.VisScreenWidth == 800) &&
                    (ModeEntry->ModeInformation.BitsPerPlane == 32)) {

                    //
                    // Rule: 928 revs A through D can only do 800x600x32 in
                    //       a non-contiguous mode.
                    //

                    if (jChipID == 0x90) {

                        ModeEntry->ScreenStrideContiguous =
                            ModeEntry->ModeInformation.ScreenStride;
                    }
                }

                if (hwDeviceExtension->SubTypeID == SUBTYPE_732) {

                    //
                    // Rule: The 732 Trio32 chip simply can't do 800x600x32bpp.
                    //

                    if ((ModeEntry->ModeInformation.VisScreenWidth == 800) &&
                        (ModeEntry->ModeInformation.BitsPerPlane == 32)) {

                        FrequencyEntry->ModeValid = FALSE;

                    //
                    // Rule: The 732 Trio32 chip simply can't do 1152x864x16bpp.
                    //

                    } else if ((ModeEntry->ModeInformation.VisScreenWidth == 1152) &&
                               (ModeEntry->ModeInformation.BitsPerPlane == 16)) {

                        FrequencyEntry->ModeValid = FALSE;
                    //
                    // Rule: The 732 Trio32 chip simply can't do 1280x1024 modes
                    //

                    } else if ((ModeEntry->ModeInformation.VisScreenWidth) == 1280) {
                        FrequencyEntry->ModeValid = FALSE;
                    }
                }

                //
                // Rule: We have to have enough memory to handle the mode.
                //
                //       Note that we use the contiguous width for this
                //       computation; unfortunately, we don't know at this time
                //       whether we can handle a contiguous mode or not, so we
                //       may err on the side of listing too many possible modes.
                //
                //       We may also list too many possible modes if the card
                //       combines VRAM with a DRAM cache, because it will report
                //       the VRAM + DRAM amount of memory, but only the VRAM can
                //       be used as screen memory.
                //

                if (ModeEntry->ModeInformation.VisScreenHeight *
                    ModeEntry->ScreenStrideContiguous >
                    hwDeviceExtension->AdapterMemorySize) {

                    FrequencyEntry->ModeValid = FALSE;
                }

                //
                // Rule: If we can't use Int 10, restrict 1280x1024 to Number9
                //       cards, because I haven't been able to fix the mode
                //       tables for other cards yet.
                //

                if (FrequencyTable == hwDeviceExtension->FixedFrequencyTable) {

                    if ((ModeEntry->ModeInformation.VisScreenHeight == 1280) &&
                        (hwDeviceExtension->BoardID != S3_NUMBER_NINE)) {

                        FrequencyEntry->ModeValid = FALSE;
                    }

                    //
                    // Rule: If there isn't a table entry for programming the CRTC,
                    //       we can't do this frequency at this mode.
                    //

                    if (FrequencyEntry->Fixed.CRTCTable[hwDeviceExtension->ChipID]
                        == NULL) {

                        FrequencyEntry->ModeValid = FALSE;
                        break;
                    }
                }

                //
                // Don't forget to count it if it's still a valid mode after
                // applying all those rules.
                //

                if (FrequencyEntry->ModeValid) {

                    hwDeviceExtension->NumAvailableModes++;
                }

                //
                // We've found a mode for this frequency entry, so we
                // can break out of the mode loop:
                //

                break;

            }
        }
    }

    hwDeviceExtension->NumTotalModes = ModeIndex;

    VideoDebugPrint((2, "S3: Number of modes = %d\n", ModeIndex));
}

VP_STATUS
S3RegistryCallback(
    PVOID HwDeviceExtension,
    PVOID Context,
    PWSTR ValueName,
    PVOID ValueData,
    ULONG ValueLength
    )

/*++

Routine Description:

    This routine determines if the alternate register set was requested via
    the registry.

Arguments:

    HwDeviceExtension - Supplies a pointer to the miniport's device extension.

    Context - Context value passed to the get registry paramters routine.

    ValueName - Name of the value requested.

    ValueData - Pointer to the requested data.

    ValueLength - Length of the requested data.

Return Value:

    returns NO_ERROR if the paramter was TRUE.
    returns ERROR_INVALID_PARAMETER otherwise.

--*/

{

    if (ValueLength && *((PULONG)ValueData)) {

        return NO_ERROR;

    } else {

        return ERROR_INVALID_PARAMETER;

    }

} // end S3RegistryCallback()


BOOLEAN
S3Initialize(
    PVOID HwDeviceExtension
    )

/*++

Routine Description:

    This routine does one time initialization of the device.

Arguments:

    HwDeviceExtension - Supplies a pointer to the miniport's device extension.

Return Value:


    Always returns TRUE since this routine can never fail.

--*/

{
    UNREFERENCED_PARAMETER(HwDeviceExtension);

    return TRUE;

} // end S3Initialize()

BOOLEAN
S3ResetHw(
    PVOID HwDeviceExtension,
    ULONG Columns,
    ULONG Rows
    )

/*++

Routine Description:

    This routine preps the S3 card for return to a VGA mode.

    This routine is called during system shutdown.  By returning
    a FALSE we inform the HAL to do an int 10 to go into text
    mode before shutting down.  Shutdown would fail with some S3
    cards without this.

    We do some clean up before returning so that the int 10
    will work.

Arguments:

    HwDeviceExtension - Supplies a pointer to the miniport's device extension.

Return Value:

    The return value of FALSE informs the hal to go into text mode.

--*/

{
    PHW_DEVICE_EXTENSION hwDeviceExtension = HwDeviceExtension;

    UNREFERENCED_PARAMETER(Columns);
    UNREFERENCED_PARAMETER(Rows);

    //
    // We don't want to execute this reset code if we are not
    // currently in an S3 mode!
    //

    if (!hwDeviceExtension->bNeedReset)
    {
        return FALSE;
    }

    hwDeviceExtension->bNeedReset = FALSE;

    //
    // Wait for the GP to become idle.
    //

    while (VideoPortReadPortUshort(GP_STAT) & 0x0200);

    //
    // Zero the DAC and the Screen buffer memory.
    //

    ZeroMemAndDac(HwDeviceExtension);

    //
    // Reset the board to a default mode
    //
    // After NT 3.51 ships use the same modetable for all
    // architectures, but just to be sure we don't break
    // something we'll use two for now.  The 'no_bios'
    // version of the modetable is for the IBM PS/2 model
    // 76i.
    //

    if (hwDeviceExtension->BiosPresent == FALSE)
    {
        SetHWMode(HwDeviceExtension, s3_set_vga_mode_no_bios);
    }
    else
    {
        SetHWMode(HwDeviceExtension, s3_set_vga_mode);
    }

    return FALSE;
}


BOOLEAN
S3StartIO(
    PVOID pvHwDeviceExtension,
    PVIDEO_REQUEST_PACKET RequestPacket
    )

/*++

Routine Description:

    This routine is the main execution routine for the miniport driver. It
    acceptss a Video Request Packet, performs the request, and then returns
    with the appropriate status.

Arguments:

    HwDeviceExtension - Supplies a pointer to the miniport's device extension.

    RequestPacket - Pointer to the video request packet. This structure
        contains all the parameters passed to the VideoIoControl function.

Return Value:


--*/

{
    PHW_DEVICE_EXTENSION hwDeviceExtension = pvHwDeviceExtension;
    PHW_DEVICE_EXTENSION HwDeviceExtension = pvHwDeviceExtension;
    VP_STATUS status;
    PVIDEO_MODE_INFORMATION modeInformation;
    PVIDEO_CLUT clutBuffer;
    UCHAR byte;

    ULONG modeNumber;
    PS3_VIDEO_MODES ModeEntry;
    PS3_VIDEO_FREQUENCIES FrequencyEntry;
    PS3_VIDEO_FREQUENCIES FrequencyTable;

    UCHAR ModeControlByte;
    VIDEO_X86_BIOS_ARGUMENTS biosArguments;

    PVIDEO_SHARE_MEMORY pShareMemory;
    PVIDEO_SHARE_MEMORY_INFORMATION pShareMemoryInformation;
    PHYSICAL_ADDRESS shareAddress;
    PVOID virtualAddress;
    ULONG sharedViewSize;
    ULONG inIoSpace;

    UCHAR OriginalRegPrimary;
    UCHAR OriginalRegSecondary;

    //
    // Switch on the IoContolCode in the RequestPacket. It indicates which
    // function must be performed by the driver.
    //

    switch (RequestPacket->IoControlCode) {


    case IOCTL_VIDEO_MAP_VIDEO_MEMORY:

        VideoDebugPrint((2, "S3tartIO - MapVideoMemory\n"));

        {
            PVIDEO_MEMORY_INFORMATION memoryInformation;
            ULONG physicalFrameLength;

            if ( (RequestPacket->OutputBufferLength <
                  (RequestPacket->StatusBlock->Information =
                                         sizeof(VIDEO_MEMORY_INFORMATION))) ||
                 (RequestPacket->InputBufferLength < sizeof(VIDEO_MEMORY)) ) {

                status = ERROR_INSUFFICIENT_BUFFER;
                break;
            }

            memoryInformation = RequestPacket->OutputBuffer;

            memoryInformation->VideoRamBase = ((PVIDEO_MEMORY)
                    (RequestPacket->InputBuffer))->RequestedVirtualAddress;

            physicalFrameLength = hwDeviceExtension->FrameLength;

            inIoSpace = hwDeviceExtension->PhysicalFrameIoSpace;

            //
            // IMPORTANT - As a rule we only map the actual amount of memory
            // on the board, not the whole physical address space reported
            // by PCI.  The reason for this is that mapping the memory takes
            // up a lot of resources in the machine, which as quite scarce by
            // default.  Mapping 64MEG of address space would actually always
            // fail in machines that have 32MEG or even 64MEG of RAM.
            //

            //
            // Performance:
            //
            // Enable USWC on the P6 processor.
            // We only do it for the frame buffer - memory mapped registers can
            // not be mapped USWC because write combining the registers would
            // cause very bad things to happen !
            //

            inIoSpace |= VIDEO_MEMORY_SPACE_P6CACHE;

            //
            // P6 workaround:
            //
            // Because of a current limitation in many P6 machines, USWC only
            // works on sections of 4MEG of memory.  So lets round up the size
            // of memory on the cards that have less than 4MEG up to 4MEG so
            // they can also benefit from this feature.
            //
            // We will only do this for NEW_MMIO cards, which have a large
            // block of address space that is reserved via PCI.  This way
            // we are sure we will not conflict with another device that might
            // have addresses right after us.
            //
            // We do this only for mapping purposes.  We still want to return
            // the real size of memory since the driver can not use memory that
            // is not actually there !
            //

            if ((hwDeviceExtension->Capabilities & CAPS_NEW_MMIO) &&
                (physicalFrameLength < 0x00400000)) {

                physicalFrameLength = 0x00400000;
            }

            status = VideoPortMapMemory(hwDeviceExtension,
                                        hwDeviceExtension->PhysicalFrameAddress,
                                        &physicalFrameLength,
                                        &inIoSpace,
                                        &(memoryInformation->VideoRamBase));

            //
            // The frame buffer and virtual memory are equivalent in this
            // case.
            //

            memoryInformation->FrameBufferBase =
                memoryInformation->VideoRamBase;

            memoryInformation->FrameBufferLength =
                hwDeviceExtension->FrameLength;

            memoryInformation->VideoRamLength =
                hwDeviceExtension->FrameLength;
        }

        break;


    case IOCTL_VIDEO_UNMAP_VIDEO_MEMORY:

        VideoDebugPrint((2, "S3StartIO - UnMapVideoMemory\n"));

        if (RequestPacket->InputBufferLength < sizeof(VIDEO_MEMORY)) {

            status = ERROR_INSUFFICIENT_BUFFER;
            break;
        }

        status = VideoPortUnmapMemory(hwDeviceExtension,
                                      ((PVIDEO_MEMORY)
                                       (RequestPacket->InputBuffer))->
                                           RequestedVirtualAddress,
                                      0);

        break;


    case IOCTL_VIDEO_QUERY_PUBLIC_ACCESS_RANGES:

        VideoDebugPrint((2, "S3StartIO - QueryPublicAccessRanges\n"));

        {

           PVIDEO_PUBLIC_ACCESS_RANGES portAccess;
           ULONG physicalPortLength;

           if ( RequestPacket->OutputBufferLength <
                 (RequestPacket->StatusBlock->Information =
                                        2 * sizeof(VIDEO_PUBLIC_ACCESS_RANGES)) ) {

               status = ERROR_INSUFFICIENT_BUFFER;
               break;
           }

           portAccess = RequestPacket->OutputBuffer;

           portAccess->VirtualAddress  = (PVOID) NULL;    // Requested VA
           portAccess->InIoSpace       = hwDeviceExtension->RegisterSpace;
           portAccess->MappedInIoSpace = portAccess->InIoSpace;

           physicalPortLength = hwDeviceExtension->RegisterLength;

           status = VideoPortMapMemory(hwDeviceExtension,
                                       hwDeviceExtension->PhysicalRegisterAddress,
                                       &physicalPortLength,
                                       &(portAccess->MappedInIoSpace),
                                       &(portAccess->VirtualAddress));

           if (status == NO_ERROR) {

               portAccess++;

               portAccess->VirtualAddress  = (PVOID) NULL;    // Requested VA
               portAccess->InIoSpace       = hwDeviceExtension->MmIoSpace;
               portAccess->MappedInIoSpace = portAccess->InIoSpace;

               physicalPortLength = hwDeviceExtension->MmIoLength;

               status = VideoPortMapMemory(hwDeviceExtension,
                                           hwDeviceExtension->PhysicalMmIoAddress,
                                           &physicalPortLength,
                                           &(portAccess->MappedInIoSpace),
                                           &(portAccess->VirtualAddress));
            }
        }

        break;


    case IOCTL_VIDEO_FREE_PUBLIC_ACCESS_RANGES:

        VideoDebugPrint((2, "S3StartIO - FreePublicAccessRanges\n"));

        {
            PVIDEO_MEMORY mappedMemory;

            if (RequestPacket->InputBufferLength < 2 * sizeof(VIDEO_MEMORY)) {

                status = ERROR_INSUFFICIENT_BUFFER;
                break;
            }

            status = NO_ERROR;

            mappedMemory = RequestPacket->InputBuffer;

            if (mappedMemory->RequestedVirtualAddress != NULL) {

                status = VideoPortUnmapMemory(hwDeviceExtension,
                                              mappedMemory->
                                                   RequestedVirtualAddress,
                                              0);
            }

            if (status == NO_ERROR) {

                mappedMemory++;

                status = VideoPortUnmapMemory(hwDeviceExtension,
                                              mappedMemory->
                                                   RequestedVirtualAddress,
                                              0);
            }
        }

        break;


    case IOCTL_VIDEO_QUERY_AVAIL_MODES:

        VideoDebugPrint((2, "S3StartIO - QueryAvailableModes\n"));

        if (RequestPacket->OutputBufferLength <
            (RequestPacket->StatusBlock->Information =
                 hwDeviceExtension->NumAvailableModes
                 * sizeof(VIDEO_MODE_INFORMATION)) ) {

            VideoDebugPrint((1, "\n*** NOT ENOUGH MEMORY FOR OUTPUT ***\n\n"));

            status = ERROR_INSUFFICIENT_BUFFER;

        } else {

            modeInformation = RequestPacket->OutputBuffer;

            if (hwDeviceExtension->BiosPresent) {

                FrequencyTable = hwDeviceExtension->Int10FrequencyTable;

            } else {

                FrequencyTable = hwDeviceExtension->FixedFrequencyTable;
            }

            for (FrequencyEntry = FrequencyTable;
                 FrequencyEntry->BitsPerPel != 0;
                 FrequencyEntry++) {

                if (FrequencyEntry->ModeValid) {

                    *modeInformation =
                        FrequencyEntry->ModeEntry->ModeInformation;

                    modeInformation->Frequency =
                        FrequencyEntry->ScreenFrequency;

                    modeInformation->ModeIndex =
                        FrequencyEntry->ModeIndex;

                    modeInformation++;
                }
            }

            status = NO_ERROR;
        }

        break;


    case IOCTL_VIDEO_QUERY_CURRENT_MODE:

        VideoDebugPrint((2, "S3StartIO - QueryCurrentModes\n"));

        if (RequestPacket->OutputBufferLength <
            (RequestPacket->StatusBlock->Information =
            sizeof(VIDEO_MODE_INFORMATION)) ) {

            status = ERROR_INSUFFICIENT_BUFFER;

        } else {

            *((PVIDEO_MODE_INFORMATION)RequestPacket->OutputBuffer) =
                hwDeviceExtension->ActiveModeEntry->ModeInformation;

            ((PVIDEO_MODE_INFORMATION)RequestPacket->OutputBuffer)->Frequency =
                hwDeviceExtension->ActiveFrequencyEntry->ScreenFrequency;

            status = NO_ERROR;

        }

        break;


    case IOCTL_VIDEO_QUERY_NUM_AVAIL_MODES:

        VideoDebugPrint((2, "S3StartIO - QueryNumAvailableModes\n"));

        //
        // Find out the size of the data to be put in the the buffer and
        // return that in the status information (whether or not the
        // information is there). If the buffer passed in is not large
        // enough return an appropriate error code.
        //

        if (RequestPacket->OutputBufferLength <
                (RequestPacket->StatusBlock->Information =
                                                sizeof(VIDEO_NUM_MODES)) ) {

            status = ERROR_INSUFFICIENT_BUFFER;

        } else {

            ((PVIDEO_NUM_MODES)RequestPacket->OutputBuffer)->NumModes =
                hwDeviceExtension->NumAvailableModes;

            ((PVIDEO_NUM_MODES)RequestPacket->OutputBuffer)->ModeInformationLength =
                sizeof(VIDEO_MODE_INFORMATION);

            status = NO_ERROR;
        }

        break;


    case IOCTL_VIDEO_SET_CURRENT_MODE:

        VideoDebugPrint((2, "S3StartIO - SetCurrentMode\n"));

        //
        // Check if the size of the data in the input buffer is large enough.
        //

        if (RequestPacket->InputBufferLength < sizeof(VIDEO_MODE)) {

            status = ERROR_INSUFFICIENT_BUFFER;
            break;

        }

        //
        // Assume failure for now.
        //

        status = ERROR_INVALID_PARAMETER;

        //
        // Find the correct entries in the S3_VIDEO_MODES and S3_VIDEO_FREQUENCIES
        // tables that correspond to this mode number.  (Remember that each
        // mode in the S3_VIDEO_MODES table can have a number of possible
        // frequencies associated with it.)
        //

        modeNumber = ((PVIDEO_MODE) RequestPacket->InputBuffer)->RequestedMode;

        if (modeNumber >= hwDeviceExtension->NumTotalModes) {

            break;

        }

        if (hwDeviceExtension->BiosPresent) {

            FrequencyEntry = &hwDeviceExtension->Int10FrequencyTable[modeNumber];

            if (!(FrequencyEntry->ModeValid)) {

                break;

            }

            ModeEntry = FrequencyEntry->ModeEntry;

            //
            // At this point, 'ModeEntry' and 'FrequencyEntry' point to the
            // necessary table entries required for setting the requested mode.
            //

            VideoPortZeroMemory(&biosArguments, sizeof(VIDEO_X86_BIOS_ARGUMENTS));

            //
            // Unlock the S3 registers.
            //

            VideoPortWritePortUshort(CRT_ADDRESS_REG, 0x4838);
            VideoPortWritePortUshort(CRT_ADDRESS_REG, 0xA039);

            //
            // Use register 52 before every Int 10 modeset to set the refresh
            // rate.  If the card doesn't support it, or we don't know what
            // values to use, the requested frequency will be '1', which means
            // 'use the hardware default refresh.'
            //

            if (FrequencyEntry->ScreenFrequency != 1) {

                VideoPortWritePortUchar(CRT_ADDRESS_REG, 0x52);

                OriginalRegPrimary =  VideoPortReadPortUchar(CRT_DATA_REG);
                ModeControlByte    =  OriginalRegPrimary;
                ModeControlByte   &= ~FrequencyEntry->Int10.FrequencyPrimaryMask;
                ModeControlByte   |=  FrequencyEntry->Int10.FrequencyPrimarySet;

                VideoPortWritePortUchar(CRT_DATA_REG, ModeControlByte);

                if (FrequencyEntry->Int10.FrequencySecondaryMask != 0) {
                    VideoPortWritePortUchar(CRT_ADDRESS_REG,
                                            hwDeviceExtension->FrequencySecondaryIndex);

                    OriginalRegSecondary =  VideoPortReadPortUchar(CRT_DATA_REG);
                    ModeControlByte      =  OriginalRegSecondary;
                    ModeControlByte     &= ~FrequencyEntry->Int10.FrequencySecondaryMask;
                    ModeControlByte     |=  FrequencyEntry->Int10.FrequencySecondarySet;

                    VideoPortWritePortUchar(CRT_DATA_REG, ModeControlByte);
                }

            }

            //
            // To do 24bpp on the #9 968 set bit 7 in register 41 before every
            // Int 10 modeset. If not doing 24bpp, clear that bit.
            //

            if ((hwDeviceExtension->BoardID == S3_NUMBER_NINE) &&
                (hwDeviceExtension->SubTypeID == SUBTYPE_968)) {

                VideoPortWritePortUchar(CRT_ADDRESS_REG, 0x41);

                OriginalRegPrimary =  VideoPortReadPortUchar(CRT_DATA_REG);
                ModeControlByte    =  OriginalRegPrimary;

                if (ModeEntry->ModeInformation.BitsPerPlane == 24) {
                    ModeControlByte   |=  0x80;
                } else {
                    ModeControlByte   &=  ~0x80;
                }

                VideoPortWritePortUchar(CRT_DATA_REG, ModeControlByte);

            }

            //
            // Turn off the screen to work around a bug in some
            // s3 bios's.  (The symptom of the bug is we loop
            // forever in the bios after trying to set a mode.)
            //

            VideoPortWritePortUchar(SEQ_ADDRESS_REG, 0x1);
            VideoPortWritePortUchar(SEQ_DATA_REG,
                (UCHAR)(VideoPortReadPortUchar(SEQ_DATA_REG) | 0x20));

            //
            // First try the modeset with the 'Contiguous' mode:
            //

            biosArguments.Ebx = ModeEntry->Int10ModeNumberContiguous;
            biosArguments.Eax = 0x4f02;

            status = VideoPortInt10(HwDeviceExtension, &biosArguments);

            if (status != NO_ERROR) {
                VideoDebugPrint((1, "S3: first int10 call FAILED\n"));
            }

            if ((status == NO_ERROR) && (biosArguments.Eax & 0xff00) == 0) {

                //
                // The contiguous mode set succeeded.
                //

                ModeEntry->ModeInformation.ScreenStride =
                    ModeEntry->ScreenStrideContiguous;

            } else {

                //
                // Try again with the 'Noncontiguous' mode:
                //

                biosArguments.Ebx = ModeEntry->Int10ModeNumberNoncontiguous;
                biosArguments.Eax = 0x4f02;

                status = VideoPortInt10(HwDeviceExtension, &biosArguments);

                if (status != NO_ERROR)
                {
                    VideoDebugPrint((1, "S3: second int10 call FAILED\n"));
                }

                //
                // If the video port called succeeded, check the register return
                // code.  Some HP BIOSes always return failure even when the
                // int 10 works fine, so we ignore its return code.
                //

                if ((status == NO_ERROR) &&
                    ((hwDeviceExtension->BoardID != S3_HP) &&
                       ((biosArguments.Eax & 0xff00) != 0))) {

                    status = ERROR_INVALID_PARAMETER;
                }
            }

            if (FrequencyEntry->ScreenFrequency != 1) {

                //
                // Unlock the S3 registers.
                //

                VideoPortWritePortUshort(CRT_ADDRESS_REG, 0x4838);
                VideoPortWritePortUshort(CRT_ADDRESS_REG, 0xA039);

                //
                // If the user has been running the Display Applet and we're
                // reverting back to 'hardware default setting,' we have to
                // restore the refresh registers to their original settings.
                //

                VideoPortWritePortUchar(CRT_ADDRESS_REG, 0x52);
                VideoPortWritePortUchar(CRT_DATA_REG, OriginalRegPrimary);

                VideoPortWritePortUchar(CRT_ADDRESS_REG,
                    hwDeviceExtension->FrequencySecondaryIndex);
                VideoPortWritePortUchar(CRT_DATA_REG, OriginalRegSecondary);
            }
        }

        if (status != NO_ERROR) {

            VideoDebugPrint((1, "S3: Trying fixed mode-set\n"));

            //
            // A problem occured during the int10.  Let's see if we can recover.
            //

#ifndef S3_USE_FIXED_TABLES

            //
            // If we are only supposed to use int10, then this is total
            // failure.  Just leave.
            //

            break;

#endif

            //
            // Let see if we are using a fixed mode table number
            //

            if (!hwDeviceExtension->BiosPresent) {

                FrequencyEntry = &hwDeviceExtension->FixedFrequencyTable[modeNumber];

            } else {

                PS3_VIDEO_FREQUENCIES oldFrequencyEntry = FrequencyEntry;
                PS3_VIDEO_FREQUENCIES newFrequencyEntry;
                PS3_VIDEO_FREQUENCIES bestFrequencyEntry;

                //
                // Okay, we constructed our original mode list assuming
                // we could use Int 10, but we have just discovered the
                // Int 10 didn't work -- probably because there was a
                // problem with the BIOS emulator.  To recover, we will now
                // try to find the best mode in the Fixed Frequency table to
                // match the requested mode.
                //

                FrequencyEntry = NULL;
                bestFrequencyEntry = NULL;

                for (newFrequencyEntry = &hwDeviceExtension->FixedFrequencyTable[0];
                     newFrequencyEntry->BitsPerPel != 0;
                     newFrequencyEntry++) {

                    //
                    // Check for a matching mode.
                    //

                    if ( (newFrequencyEntry->BitsPerPel ==
                            oldFrequencyEntry->BitsPerPel) &&
                         (newFrequencyEntry->ScreenWidth ==
                            oldFrequencyEntry->ScreenWidth) ) {

                        if (FrequencyEntry == NULL) {

                            //
                            // Remember the first mode that matched, ignoring
                            // the frequency.
                            //

                            FrequencyEntry = newFrequencyEntry;
                        }

                        if (newFrequencyEntry->ScreenFrequency <=
                              oldFrequencyEntry->ScreenFrequency) {

                            //
                            // Ideally, we would like to choose the frequency
                            // that is closest to, but less than or equal to,
                            // the requested frequency.
                            //

                            if ( (bestFrequencyEntry == NULL) ||
                                 (bestFrequencyEntry->ScreenFrequency <
                                     newFrequencyEntry->ScreenFrequency) ) {

                                bestFrequencyEntry = newFrequencyEntry;
                            }
                        }
                    }
                }

                //
                // Use the preferred frequency setting, if there is one.
                //

                if (bestFrequencyEntry != NULL) {

                    FrequencyEntry = bestFrequencyEntry;

                }

                //
                // If we have no valid mode, we must return failure
                //

                if (FrequencyEntry == NULL) {

                    VideoDebugPrint((1, "S3: no valid Fixed Frequency mode\n"));
                    status = ERROR_INVALID_PARAMETER;
                    break;

                }

                //
                // Our new ModeEntry is the same as the old.
                //

                FrequencyEntry->ModeEntry = oldFrequencyEntry->ModeEntry;
                FrequencyEntry->ModeValid = TRUE;

                VideoDebugPrint((1, "S3: Selected Fixed Frequency mode from int 10:\n"));
                VideoDebugPrint((1, "    Bits Per Pel: %d\n", FrequencyEntry->BitsPerPel));
                VideoDebugPrint((1, "    Screen Width: %d\n", FrequencyEntry->ScreenWidth));
                VideoDebugPrint((1, "    Frequency: %d\n", FrequencyEntry->ScreenFrequency));

            }

            ModeEntry = FrequencyEntry->ModeEntry;

            //
            // NOTE:
            // We have to set the ActiveFrequencyEntry since the SetHWMode
            // function depends on this variable to set the CRTC registers.
            // So lets set it here, and it will get reset to the same
            // value after we set the mode.
            //

            hwDeviceExtension->ActiveFrequencyEntry = FrequencyEntry;

            //
            // If it failed, we may not be able to perform int10 due
            // to BIOS emulation problems.
            //
            // Then just do a table mode-set.  First we need to find the
            // right mode table in the fixed Frequency tables.
            //

            //
            // Select the Enhanced mode init depending upon the type of
            // chip found.

            if ( (hwDeviceExtension->BoardID == S3_NUMBER_NINE) &&
                 (ModeEntry->ModeInformation.VisScreenWidth == 1280) ) {

                  SetHWMode(hwDeviceExtension, S3_928_1280_Enhanced_Mode);

            } else {

                //
                // Use defaults for all other boards
                //

                switch(hwDeviceExtension->ChipID) {

                case S3_911:

                    SetHWMode(hwDeviceExtension, S3_911_Enhanced_Mode);
                    break;

                case S3_801:

                    SetHWMode(hwDeviceExtension, S3_801_Enhanced_Mode);
                    break;

                case S3_928:

                    SetHWMode(hwDeviceExtension, S3_928_Enhanced_Mode);

                    break;

                case S3_864:

                    SetHWMode(hwDeviceExtension, S3_864_Enhanced_Mode);
                    Set864MemoryTiming(hwDeviceExtension);
                    break;

                default:

                    VideoDebugPrint((1, "S3: Bad chip type for these boards"));
                    break;
                }

            }
        }

        //
        // Call Int 10, function 0x4f06 to obtain the correct screen pitch
        // of all S3's except the 911/924.
        //

        if ((hwDeviceExtension->ChipID != S3_911) &&
            (hwDeviceExtension->BiosPresent)) {

            VideoPortZeroMemory(&biosArguments,sizeof(VIDEO_X86_BIOS_ARGUMENTS));

            biosArguments.Ebx = 0x0001;
            biosArguments.Eax = 0x4f06;

            status = VideoPortInt10(HwDeviceExtension, &biosArguments);

            //
            // Check to see if the Bios supported this function, and if so
            // update the screen stride for this mode.
            //

            if ((status == NO_ERROR) && (biosArguments.Eax & 0xffff) == 0x004f) {

                ModeEntry->ModeInformation.ScreenStride =
                    biosArguments.Ebx;

            } else {

                //
                // We will use the default value in the mode table.
                //
            }
        }

        //
        // Save the mode since we know the rest will work.
        //

        hwDeviceExtension->ActiveModeEntry = ModeEntry;
        hwDeviceExtension->ActiveFrequencyEntry = FrequencyEntry;

        //
        // Record the fact that we are in an S3 mode, and
        // that we need to be reset.
        //

        hwDeviceExtension->bNeedReset = TRUE;

        //////////////////////////////////////////////////////////////////
        // Update VIDEO_MODE_INFORMATION fields
        //
        // Now that we've set the mode, we now know the screen stride, and
        // so can update some fields in the VIDEO_MODE_INFORMATION
        // structure for this mode.  The S3 display driver is expected to
        // call IOCTL_VIDEO_QUERY_CURRENT_MODE to query these corrected
        // values.
        //

        //
        // Calculate the bitmap width.
        // We currently assume the bitmap width is equivalent to the stride.
        //

        {
            LONG x;

            x = ModeEntry->ModeInformation.BitsPerPlane;

            //
            // you waste 16 bps even when you only use 15 for info.
            //

            if( x == 15 )
            {
                x = 16;
            }

            ModeEntry->ModeInformation.VideoMemoryBitmapWidth =
                (ModeEntry->ModeInformation.ScreenStride * 8) / x;
        }

        //
        // If we're in a mode that the BIOS doesn't really support, it may
        // have reported back a bogus screen width.
        //

        if (ModeEntry->ModeInformation.VideoMemoryBitmapWidth <
            ModeEntry->ModeInformation.VisScreenWidth) {

            VideoDebugPrint((1, "S3: BIOS returned invalid screen width\n"));
            status = ERROR_INVALID_PARAMETER;
            break;
        }

        //
        // Calculate the bitmap height.
        //

        ModeEntry->ModeInformation.VideoMemoryBitmapHeight =
            hwDeviceExtension->AdapterMemorySize /
            ModeEntry->ModeInformation.ScreenStride;

        //
        // The current position registers in the current S3 chips are
        // limited to 12 bits of precision, with the range [0, 4095].
        // Consequently, we must clamp the bitmap height so that we don't
        // attempt to do any drawing beyond that range.
        //

        ModeEntry->ModeInformation.VideoMemoryBitmapHeight =
            MIN(4096, ModeEntry->ModeInformation.VideoMemoryBitmapHeight);

        //////////////////////////////////////////////////////////////////
        // Unlock the S3 registers,  we need to unlock the registers a second
        // time since the interperter has them locked when it returns to us.
        //

        VideoPortWritePortUshort(CRT_ADDRESS_REG, 0x4838);
        VideoPortWritePortUshort(CRT_ADDRESS_REG, 0xA039);

        //////////////////////////////////////////////////////////////////
        // Warm up the hardware for the new mode, and work around any
        // BIOS bugs.
        //

        if ((hwDeviceExtension->ChipID == S3_801) &&
            (hwDeviceExtension->AdapterMemorySize == 0x080000)) {

            //
            // On 801/805 chipsets with 512k of memory we must AND
            // register 0x54 with 0x7.
            //

            VideoPortWritePortUchar(CRT_ADDRESS_REG, 0x54);
            byte = VideoPortReadPortUchar(CRT_DATA_REG);
            byte &= 0x07;
            VideoPortWritePortUchar(CRT_DATA_REG, byte);
        }

        if (ModeEntry->ModeInformation.BitsPerPlane > 8) {

            //
            // Make sure 16-bit memory reads/writes are enabled.
            //

            VideoPortWritePortUchar(CRT_ADDRESS_REG, 0x31);
            byte = VideoPortReadPortUchar(CRT_DATA_REG);
            byte |= 0x04;
            VideoPortWritePortUchar(CRT_DATA_REG, byte);
        }

        //
        // Set the colours for the built-in S3 pointer.
        //

        VideoPortWritePortUshort(CRT_ADDRESS_REG, 0xff0e);
        VideoPortWritePortUshort(CRT_ADDRESS_REG, 0x000f);

        if (hwDeviceExtension->ChipID >= S3_864) {

            VideoPortWritePortUchar(CRT_ADDRESS_REG, 0x45);
            VideoPortReadPortUchar(CRT_DATA_REG);
            VideoPortWritePortUchar(CRT_ADDRESS_REG, 0x4A);
            VideoPortWritePortUchar(CRT_DATA_REG, 0xFF);
            VideoPortWritePortUchar(CRT_DATA_REG, 0xFF);
            VideoPortWritePortUchar(CRT_DATA_REG, 0xFF);
            VideoPortWritePortUchar(CRT_DATA_REG, 0xFF);

            VideoPortWritePortUchar(CRT_ADDRESS_REG, 0x45);
            VideoPortReadPortUchar(CRT_DATA_REG);
            VideoPortWritePortUchar(CRT_ADDRESS_REG, 0x4B);
            VideoPortWritePortUchar(CRT_DATA_REG, 0x00);
            VideoPortWritePortUchar(CRT_DATA_REG, 0x00);
            VideoPortWritePortUchar(CRT_DATA_REG, 0x00);
            VideoPortWritePortUchar(CRT_DATA_REG, 0x00);
        }

        if (hwDeviceExtension->ChipID > S3_911) {

            //
            // Set the address for the frame buffer window and set the window
            // size.
            //

            VideoPortWritePortUchar(CRT_ADDRESS_REG, 0x59);
            VideoPortWritePortUchar(CRT_DATA_REG,
                (UCHAR) (hwDeviceExtension->PhysicalFrameAddress.LowPart >> 24));

            VideoPortWritePortUchar(CRT_ADDRESS_REG, 0x5A);
            VideoPortWritePortUchar(CRT_DATA_REG,
                (UCHAR) (hwDeviceExtension->PhysicalFrameAddress.LowPart >> 16));

            VideoPortWritePortUchar(CRT_ADDRESS_REG, 0x58);
            byte = VideoPortReadPortUchar(CRT_DATA_REG) & ~0x3;

            switch (hwDeviceExtension->FrameLength)
            {
            case 0x400000:
            case 0x800000:
                byte |= 0x3;
                break;
            case 0x200000:
                byte |= 0x2;
                break;
            case 0x100000:
                byte |= 0x1;
                break;
            case 0x010000:
                break;
            default:
                byte |= 0x3;
                break;
            }

            VideoPortWritePortUchar(CRT_DATA_REG, byte);
        }

        if (hwDeviceExtension->Capabilities & CAPS_NEW_MMIO) {

            //
            // Enable 'new memory-mapped I/O':
            //

            VideoPortWritePortUchar(CRT_ADDRESS_REG, 0x53);
            byte = VideoPortReadPortUchar(CRT_DATA_REG);
            byte |= 0x18;
            VideoPortWritePortUchar(CRT_DATA_REG, byte);
        }

        if ((ModeEntry->ModeInformation.DriverSpecificAttributeFlags &
                CAPS_BT485_POINTER) &&
            (hwDeviceExtension->ChipID == S3_928)) {

            //
            // Some of the Number Nine boards do not set the chip up correctly
            // for an external cursor. We must OR in the bits, because if we
            // don't the Metheus board will not initialize.
            //

            VideoPortWritePortUchar(CRT_ADDRESS_REG, 0x45);
            byte = VideoPortReadPortUchar(CRT_DATA_REG);
            byte |= 0x20;
            VideoPortWritePortUchar(CRT_DATA_REG, byte);

            VideoPortWritePortUchar(CRT_ADDRESS_REG, 0x55);
            byte = VideoPortReadPortUchar(CRT_DATA_REG);
            byte |= 0x20;
            VideoPortWritePortUchar(CRT_DATA_REG, byte);
        }

        //
        // Some BIOSes don't disable linear addressing by default, so
        // make sure we do it here.
        //

        VideoPortWritePortUchar(CRT_ADDRESS_REG, 0x58);
        byte = VideoPortReadPortUchar(CRT_DATA_REG);
        byte &= ~0x10;
        VideoPortWritePortUchar(CRT_DATA_REG, byte);

        //
        // Enable the Graphics engine.
        //

        VideoPortWritePortUchar(CRT_ADDRESS_REG, 0x40);
        byte = VideoPortReadPortUchar(CRT_DATA_REG);
        byte |= 0x01;
        VideoPortWritePortUchar(CRT_DATA_REG, byte);

        status = NO_ERROR;

        break;

    case IOCTL_VIDEO_SET_COLOR_REGISTERS:

        VideoDebugPrint((2, "S3StartIO - SetColorRegs\n"));

        clutBuffer = RequestPacket->InputBuffer;

        status = S3SetColorLookup(HwDeviceExtension,
                                   (PVIDEO_CLUT) RequestPacket->InputBuffer,
                                   RequestPacket->InputBufferLength);

        break;


    case IOCTL_VIDEO_RESET_DEVICE:

        VideoDebugPrint((2, "S3StartIO - RESET_DEVICE\n"));

        //
        // Prep the S3 card to return to a VGA mode
        //

        S3ResetHw(HwDeviceExtension, 0, 0);

        VideoDebugPrint((2, "S3 RESET_DEVICE - About to do int10\n"));

        //
        // Do an Int10 to mode 3 will put the board to a known state.
        //

        VideoPortZeroMemory(&biosArguments, sizeof(VIDEO_X86_BIOS_ARGUMENTS));

        biosArguments.Eax = 0x0003;

        VideoPortInt10(HwDeviceExtension,
                       &biosArguments);

        VideoDebugPrint((2, "S3 RESET_DEVICE - Did int10\n"));

        status = NO_ERROR;
        break;

    case IOCTL_VIDEO_SHARE_VIDEO_MEMORY:

        VideoDebugPrint((2, "S3StartIO - ShareVideoMemory\n"));

        if ( (RequestPacket->OutputBufferLength < sizeof(VIDEO_SHARE_MEMORY_INFORMATION)) ||
             (RequestPacket->InputBufferLength < sizeof(VIDEO_MEMORY)) ) {

            VideoDebugPrint((1, "IOCTL_VIDEO_SHARE_VIDEO_MEMORY - ERROR_INSUFFICIENT_BUFFER\n"));
            status = ERROR_INSUFFICIENT_BUFFER;
            break;
        }

        pShareMemory = RequestPacket->InputBuffer;

        if ( (pShareMemory->ViewOffset > hwDeviceExtension->AdapterMemorySize) ||
             ((pShareMemory->ViewOffset + pShareMemory->ViewSize) >
                  hwDeviceExtension->AdapterMemorySize) ) {

            VideoDebugPrint((1, "IOCTL_VIDEO_SHARE_VIDEO_MEMORY - ERROR_INVALID_PARAMETER\n"));
            status = ERROR_INVALID_PARAMETER;
            break;
        }

        RequestPacket->StatusBlock->Information =
                                    sizeof(VIDEO_SHARE_MEMORY_INFORMATION);

        //
        // Beware: the input buffer and the output buffer are the same
        // buffer, and therefore data should not be copied from one to the
        // other
        //

        virtualAddress = pShareMemory->ProcessHandle;
        sharedViewSize = pShareMemory->ViewSize;

        inIoSpace = hwDeviceExtension->PhysicalFrameIoSpace;

        //
        // NOTE: we are ignoring ViewOffset
        //

        shareAddress.QuadPart =
            hwDeviceExtension->PhysicalFrameAddress.QuadPart;

        if (hwDeviceExtension->Capabilities & CAPS_NEW_MMIO) {

            //
            // With 'new memory-mapped I/O', the frame buffer is always
            // mapped in linearly.
            //

            //
            // Performance:
            //
            // Enable USWC on the P6 processor.
            // We only do it for the frame buffer - memory mapped registers can
            // not be mapped USWC because write combining the registers would
            // cause very bad things to happen !
            //

            inIoSpace |= VIDEO_MEMORY_SPACE_P6CACHE;

            //
            // Unlike the MAP_MEMORY IOCTL, in this case we can not map extra
            // address space since the application could actually use the
            // pointer we return to it to touch locations in the address space
            // that do not have actual video memory in them.
            //
            // An app doing this would cause the machine to crash.
            //
            // However, because the caching policy for USWC in the P6 is on
            // *physical* addresses, this memory mapping will "piggy back" on
            // the normal frame buffer mapping, and therefore also benefit
            // from USWC ! Cool side-effect !!!
            //

            status = VideoPortMapMemory(hwDeviceExtension,
                                        shareAddress,
                                        &sharedViewSize,
                                        &inIoSpace,
                                        &virtualAddress);

            pShareMemoryInformation = RequestPacket->OutputBuffer;

            pShareMemoryInformation->SharedViewOffset = pShareMemory->ViewOffset;
            pShareMemoryInformation->VirtualAddress = virtualAddress;
            pShareMemoryInformation->SharedViewSize = sharedViewSize;

        } else {

            status = ERROR_INVALID_PARAMETER;
        }

        break;


    case IOCTL_VIDEO_UNSHARE_VIDEO_MEMORY:

        VideoDebugPrint((2, "S3StartIO - UnshareVideoMemory\n"));

        if (RequestPacket->InputBufferLength < sizeof(VIDEO_SHARE_MEMORY)) {

            status = ERROR_INSUFFICIENT_BUFFER;
            break;

        }

        pShareMemory = RequestPacket->InputBuffer;

        status = VideoPortUnmapMemory(hwDeviceExtension,
                                      pShareMemory->RequestedVirtualAddress,
                                      pShareMemory->ProcessHandle);

        break;

    case IOCTL_VIDEO_S3_QUERY_STREAMS_PARAMETERS:

        VideoDebugPrint((2, "S3StartIO - QueryStreamsParameters\n"));

        //
        // This is a private, non-standard IOCTL so that the display driver
        // can query the appropriate minimum stretch ratio and FIFO value
        // for using the streams overlay processor in a particular mode.
        //

        if ((RequestPacket->InputBufferLength < sizeof(VIDEO_QUERY_STREAMS_MODE)) ||
            (RequestPacket->OutputBufferLength < sizeof(VIDEO_QUERY_STREAMS_PARAMETERS))) {

            status = ERROR_INSUFFICIENT_BUFFER;
            break;
        }

        status = QueryStreamsParameters(hwDeviceExtension,
                                        RequestPacket->InputBuffer,
                                        RequestPacket->OutputBuffer);

        if (status == NO_ERROR) {

            RequestPacket->StatusBlock->Information =
                sizeof(VIDEO_QUERY_STREAMS_PARAMETERS);
        }

        break;

    case IOCTL_PRIVATE_GET_FUNCTIONAL_UNIT:

        VideoDebugPrint((2, "S3StartIO - GetFunctionalUnit\n"));

        if (RequestPacket->OutputBufferLength <
                (RequestPacket->StatusBlock->Information =
                                                sizeof(FUNCTIONAL_UNIT_INFO)) ) {

            status = ERROR_INSUFFICIENT_BUFFER;

        } else {

            ((PFUNCTIONAL_UNIT_INFO)RequestPacket->OutputBuffer)->FunctionalUnitID =
                hwDeviceExtension->FunctionalUnitID;

            ((PFUNCTIONAL_UNIT_INFO)RequestPacket->OutputBuffer)->Reserved = 0;

            status = NO_ERROR;
        }

        break;

    //
    // if we get here, an invalid IoControlCode was specified.
    //

    default:

        VideoDebugPrint((1, "Fell through S3 startIO routine - invalid command\n"));

        status = ERROR_INVALID_FUNCTION;

        break;

    }

    VideoDebugPrint((2, "Leaving S3 startIO routine\n"));

    RequestPacket->StatusBlock->Status = status;

    return TRUE;

} // end S3StartIO()


VP_STATUS
S3SetColorLookup(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_CLUT ClutBuffer,
    ULONG ClutBufferSize
    )

/*++

Routine Description:

    This routine sets a specified portion of the color lookup table settings.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

    ClutBufferSize - Length of the input buffer supplied by the user.

    ClutBuffer - Pointer to the structure containing the color lookup table.

Return Value:

    None.

--*/

{
    USHORT i;

    //
    // Check if the size of the data in the input buffer is large enough.
    //

    if ( (ClutBufferSize < sizeof(VIDEO_CLUT) - sizeof(ULONG)) ||
         (ClutBufferSize < sizeof(VIDEO_CLUT) +
                     (sizeof(ULONG) * (ClutBuffer->NumEntries - 1)) ) ) {

        return ERROR_INSUFFICIENT_BUFFER;

    }

    //
    // Check to see if the parameters are valid.
    //

    if ( (ClutBuffer->NumEntries == 0) ||
         (ClutBuffer->FirstEntry > VIDEO_MAX_COLOR_REGISTER) ||
         (ClutBuffer->FirstEntry + ClutBuffer->NumEntries >
                                     VIDEO_MAX_COLOR_REGISTER + 1) ) {

        return ERROR_INVALID_PARAMETER;

    }

    if (HwDeviceExtension->Capabilities & CAPS_WAIT_ON_PALETTE) {

        //
        // On some DACs, the hardware pointer 'sparkles' unless we first
        // wait for vertical retrace.
        //

        while (VideoPortReadPortUchar(SYSTEM_CONTROL_REG) & 0x08)
            ;
        while (!(VideoPortReadPortUchar(SYSTEM_CONTROL_REG) & 0x08))
            ;

        //
        // Then pause a little more.  0x400 is the lowest value that made
        // any remaining sparkle disappear on my PCI P90.
        //
        // Unfortunately, I have discovered that this is not a complete
        // solution -- there is still sparkle if the mouse is positioned
        // near the top of the screen.  A more complete solution would
        // probably be to turn the mouse off entirely if it's in that
        // range.
        //

        for (i = 0x400; i != 0; i--) {
            VideoPortReadPortUchar(SYSTEM_CONTROL_REG);
        }
    }

    //
    //  Set CLUT registers directly on the hardware
    //

    for (i = 0; i < ClutBuffer->NumEntries; i++) {

        VideoPortWritePortUchar(DAC_ADDRESS_WRITE_PORT, (UCHAR) (ClutBuffer->FirstEntry + i));
        VideoPortWritePortUchar(DAC_DATA_REG_PORT, (UCHAR) (ClutBuffer->LookupTable[i].RgbArray.Red));
        VideoPortWritePortUchar(DAC_DATA_REG_PORT, (UCHAR) (ClutBuffer->LookupTable[i].RgbArray.Green));
        VideoPortWritePortUchar(DAC_DATA_REG_PORT, (UCHAR) (ClutBuffer->LookupTable[i].RgbArray.Blue));

    }

    return NO_ERROR;

} // end S3SetColorLookup()


VOID
SetHWMode(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PUSHORT pusCmdStream
    )

/*++

Routine Description:

    Interprets the appropriate command array to set up VGA registers for the
    requested mode. Typically used to set the VGA into a particular mode by
    programming all of the registers

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

    pusCmdStream - pointer to a command stream to execute.

Return Value:

    The status of the operation (can only fail on a bad command); TRUE for
    success, FALSE for failure.

--*/

{
    ULONG ulCmd;
    ULONG ulPort;
    UCHAR jValue;
    USHORT usValue;
    ULONG culCount;
    ULONG ulIndex,
          Microseconds;
    ULONG mappedAddressIndex = 2; // fool Prefix
    ULONG mappedAddressOffset = 0x3c0; // fool Prefix

    //
    // If there is no command string, just return
    //

    if (!pusCmdStream) {

        return;

    }

    while ((ulCmd = *pusCmdStream++) != EOD) {

        //
        // Determine major command type
        //

        switch (ulCmd & 0xF0) {

        case RESET_CR5C:

            if (HwDeviceExtension->BiosPresent == FALSE)
            {
                UCHAR value, oldvalue;

                //
                // Reset the upper four bits of the General Out Port Reg
                // with the value it had after the POST.
                //

                VideoPortWritePortUchar(CRT_ADDRESS_REG, 0x5c);
                value = VideoPortReadPortUchar(CRT_DATA_REG);
                oldvalue = value;

                value &= 0x0f;
                value |= HwDeviceExtension->CR5C;

                VideoPortWritePortUchar(CRT_DATA_REG, value);

                VideoDebugPrint((2, "S3: CRC5 was 0x%x and we "
                                    "have set it to 0x%x\n",
                                    oldvalue, value));
            }
            break;

        case SELECTACCESSRANGE:

            //
            // Determine which address range to use for commands that follow
            //

            switch (ulCmd & 0x0F) {

            case VARIOUSVGA:

                //
                // Used for registers in the range 0x3c0 - 0x3cf
                //

                mappedAddressIndex  = 2;
                mappedAddressOffset = 0x3c0;

                break;

            case SYSTEMCONTROL:

                //
                // Used for registers in the range 0x3d4 - 0x3df
                //

                mappedAddressIndex  = 3;
                mappedAddressOffset = 0x3d4;

                break;

            case ADVANCEDFUNCTIONCONTROL:

                //
                // Used for registers in the range 0x4ae8-0x4ae9
                //

                mappedAddressIndex  = 5;
                mappedAddressOffset = 0x4ae8;

                break;

            }

            break;


        case OWM:

            ulPort   = *pusCmdStream++;
            culCount = *pusCmdStream++;

            while (culCount--) {
                usValue = *pusCmdStream++;
                VideoPortWritePortUshort((PUSHORT)((PUCHAR)HwDeviceExtension->MappedAddress[mappedAddressIndex] - mappedAddressOffset + ulPort),
                                         usValue);
            }

            break;


        // Basic input/output command

        case INOUT:

            // Determine type of inout instruction
            if (!(ulCmd & IO)) {

                // Out instruction
                // Single or multiple outs?
                if (!(ulCmd & MULTI)) {

                    // Single out
                    // Byte or word out?
                    if (!(ulCmd & BW)) {

                        // Single byte out
                        ulPort = *pusCmdStream++;
                        jValue = (UCHAR) *pusCmdStream++;
                        VideoPortWritePortUchar((PUCHAR)HwDeviceExtension->MappedAddress[mappedAddressIndex] - mappedAddressOffset + ulPort,
                                                jValue);

                    } else {

                        // Single word out
                        ulPort = *pusCmdStream++;
                        usValue = *pusCmdStream++;
                        VideoPortWritePortUshort((PUSHORT)((PUCHAR)HwDeviceExtension->MappedAddress[mappedAddressIndex] - mappedAddressOffset + ulPort),
                                                usValue);

                    }

                } else {

                    // Output a string of values
                    // Byte or word outs?
                    if (!(ulCmd & BW)) {

                        // String byte outs. Do in a loop; can't use
                        // VideoPortWritePortBufferUchar because the data
                        // is in USHORT form
                        ulPort = *pusCmdStream++;
                        culCount = *pusCmdStream++;
                        while (culCount--) {
                            jValue = (UCHAR) *pusCmdStream++;
                            VideoPortWritePortUchar((PUCHAR)HwDeviceExtension->MappedAddress[mappedAddressIndex] - mappedAddressOffset + ulPort,
                                                    jValue);

                        }

                    } else {

                        // String word outs
                        ulPort = *pusCmdStream++;
                        culCount = *pusCmdStream++;
                        VideoPortWritePortBufferUshort((PUSHORT)((PUCHAR)HwDeviceExtension->MappedAddress[mappedAddressIndex] - mappedAddressOffset + ulPort),
                                                       pusCmdStream,
                                                       culCount);
                        pusCmdStream += culCount;

                    }
                }

            } else {

                // In instruction

                // Currently, string in instructions aren't supported; all
                // in instructions are handled as single-byte ins

                // Byte or word in?
                if (!(ulCmd & BW)) {

                    // Single byte in
                    ulPort = *pusCmdStream++;

                    jValue = VideoPortReadPortUchar((PUCHAR)HwDeviceExtension->MappedAddress[mappedAddressIndex] - mappedAddressOffset + ulPort);


                } else {

                    // Single word in
                    ulPort = *pusCmdStream++;
                    usValue = VideoPortReadPortUshort((PUSHORT)((PUCHAR)HwDeviceExtension->MappedAddress[mappedAddressIndex] - mappedAddressOffset + ulPort));

                }

            }

            break;


        // Higher-level input/output commands

        case METAOUT:

            // Determine type of metaout command, based on minor command field
            switch (ulCmd & 0x0F) {

                // Indexed outs
                case INDXOUT:

                    ulPort = *pusCmdStream++;
                    culCount = *pusCmdStream++;
                    ulIndex = *pusCmdStream++;

                    while (culCount--) {

                        usValue = (USHORT) (ulIndex +
                                  (((ULONG)(*pusCmdStream++)) << 8));
                        VideoPortWritePortUshort((PUSHORT)((PUCHAR)HwDeviceExtension->MappedAddress[mappedAddressIndex] - mappedAddressOffset + ulPort),
                                             usValue);

                        ulIndex++;

                    }

                    break;


                // Masked out (read, AND, XOR, write)
                case MASKOUT:

                    ulPort = *pusCmdStream++;
                    jValue = VideoPortReadPortUchar((PUCHAR)HwDeviceExtension->MappedAddress[mappedAddressIndex] - mappedAddressOffset + ulPort);
                    jValue &= *pusCmdStream++;
                    jValue ^= *pusCmdStream++;
                    VideoPortWritePortUchar((PUCHAR)HwDeviceExtension->MappedAddress[mappedAddressIndex] - mappedAddressOffset + ulPort,
                                            jValue);
                    break;


                // Attribute Controller out
                case ATCOUT:

                    ulPort = *pusCmdStream++;
                    culCount = *pusCmdStream++;
                    ulIndex = *pusCmdStream++;

                    while (culCount--) {

                        // Write Attribute Controller index
                        VideoPortWritePortUchar((PUCHAR)HwDeviceExtension->MappedAddress[mappedAddressIndex] - mappedAddressOffset + ulPort,
                                                (UCHAR)ulIndex);

                        // Write Attribute Controller data
                        jValue = (UCHAR) *pusCmdStream++;
                        VideoPortWritePortUchar((PUCHAR)HwDeviceExtension->MappedAddress[mappedAddressIndex] - mappedAddressOffset + ulPort,
                                                jValue);

                        ulIndex++;

                    }

                    break;

                case DELAY:

                    Microseconds = (ULONG) *pusCmdStream++;
                    VideoPortStallExecution(Microseconds);

                    break;

                case VBLANK:

                    Wait_VSync(HwDeviceExtension);

                    break;

                //
                // This function in setmode is pageable !!!
                // it is only used to set high res modes.
                //

                case SETCLK:

                    Set_Oem_Clock(HwDeviceExtension);

                    break;

                case SETCRTC:

                    //
                    // NOTE:
                    // beware: recursive call ...
                    //

                    SetHWMode(HwDeviceExtension,
                              HwDeviceExtension->ActiveFrequencyEntry->
                                  Fixed.CRTCTable[HwDeviceExtension->ChipID]);


                    break;


                // None of the above; error
                default:

                    return;

            }

            break;


        // NOP

        case NCMD:

            break;


        // Unknown command; error

        default:

            return;

        }

    }

    return;

} // end SetHWMode()


LONG
CompareRom(
    PUCHAR Rom,
    PUCHAR String
    )

/*++

Routine Description:

    Compares a string to that in the ROM.  Returns -1 if Rom < String, 0
    if Rom == String, 1 if Rom > String.

Arguments:

    Rom - Rom pointer.

    String - String pointer.

Return Value:

    None

--*/

{
    UCHAR jString;
    UCHAR jRom;

    while (*String) {

        jString = *String;
        jRom = VideoPortReadRegisterUchar(Rom);

        if (jRom != jString) {

            return(jRom < jString ? -1 : 1);

        }

        String++;
        Rom++;
    }

    return(0);
}


VOID
ZeroMemAndDac(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    )

/*++

Routine Description:

    Initialize the DAC to 0 (black).

Arguments:

    HwDeviceExtension - Supplies a pointer to the miniport's device extension.

Return Value:

    None

--*/

{
    ULONG i;

    //
    // Turn off the screen at the DAC.
    //

    VideoPortWritePortUchar(DAC_PIXEL_MASK_REG, 0x0);

    for (i = 0; i < 256; i++) {

        VideoPortWritePortUchar(DAC_ADDRESS_WRITE_PORT, (UCHAR)i);
        VideoPortWritePortUchar(DAC_DATA_REG_PORT, 0x0);
        VideoPortWritePortUchar(DAC_DATA_REG_PORT, 0x0);
        VideoPortWritePortUchar(DAC_DATA_REG_PORT, 0x0);

    }

    //
    // Zero the memory.
    //

    //
    // The zeroing of video memory should be implemented at a later time to
    // ensure that no information remains in video memory at shutdown, or
    // while swtiching to fullscren mode (for security reasons).
    //

    //
    // Turn on the screen at the DAC
    //

    VideoPortWritePortUchar(DAC_PIXEL_MASK_REG, 0x0ff);

    return;

}

VP_STATUS
Set_Oem_Clock(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    )

/*++

Routine Description:

    Set the clock chip on each of the supported cards.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

Return Value:

    Always TRUE

--*/

{
    ULONG ul;
    ULONG screen_width;
    UCHAR cr5C;
    ULONG clock_numbers;

    switch(HwDeviceExtension->BoardID) {

    case S3_NUMBER_NINE:

        VideoPortStallExecution(1000);

        // Jerry said to make the M clock not multiple of the P clock
        // on the 3 meg (level 12) board.  This solves the shimmy
        // problem.

        if (HwDeviceExtension->AdapterMemorySize == 0x00300000) {

            ul = 49000000;
            clock_numbers = calc_clock(ul, 3);
            set_clock(HwDeviceExtension, clock_numbers);
            VideoPortStallExecution(3000);

        }

        ul = HwDeviceExtension->ActiveFrequencyEntry->Fixed.Clock;
        clock_numbers = calc_clock(ul, 2);
        set_clock(HwDeviceExtension, clock_numbers);

        VideoPortStallExecution(3000);

        break;


    case S3_IBM_PS2:

        // Read the current screen frequency and width
        ul = HwDeviceExtension->ActiveFrequencyEntry->ScreenFrequency;
        screen_width = HwDeviceExtension->ActiveFrequencyEntry->ScreenWidth;

        VideoPortWritePortUchar(CRT_ADDRESS_REG, 0x5C);
        cr5C = VideoPortReadPortUchar( CRT_DATA_REG );
        cr5C &= 0xCF;

        switch (screen_width) {
           case 640:

              if (ul == 60) {
                cr5C |= 0x00;
                VideoPortWritePortUchar(CRT_ADDRESS_REG, 0x5C);
                VideoPortWritePortUchar(CRT_DATA_REG, cr5C);
              } else { // 72Hz
                cr5C |= 0x20;
                VideoPortWritePortUchar(CRT_ADDRESS_REG, 0x5C);
                VideoPortWritePortUchar(CRT_DATA_REG, cr5C);
              } /* endif */
              VideoPortWritePortUchar(CRT_ADDRESS_REG, 0x42);
              VideoPortWritePortUchar(CRT_DATA_REG, (UCHAR)0x00);
              VideoPortWritePortUchar(MISC_OUTPUT_REG_WRITE, (UCHAR)0xEF);

              break;

           case 800:

              if (ul == 60) {
                cr5C |= 0x00;
                VideoPortWritePortUchar(CRT_ADDRESS_REG, 0x5C);
                VideoPortWritePortUchar(CRT_DATA_REG, cr5C);
                VideoPortWritePortUchar(CRT_ADDRESS_REG, 0x42);
                VideoPortWritePortUchar(CRT_DATA_REG, (UCHAR)0x05);
              } else { // 72Hz
                cr5C |= 0x10;
                VideoPortWritePortUchar(CRT_ADDRESS_REG, 0x5C);
                VideoPortWritePortUchar(CRT_DATA_REG, cr5C);
                VideoPortWritePortUchar(CRT_ADDRESS_REG, 0x42);
                VideoPortWritePortUchar(CRT_DATA_REG, (UCHAR)0x02);
              } /* endif */
              VideoPortWritePortUchar(MISC_OUTPUT_REG_WRITE, (UCHAR)0x2F);

              break;

           case 1024:

              if (ul == 60) {
                cr5C |= 0x00;
                VideoPortWritePortUchar(CRT_ADDRESS_REG, 0x5C);
                VideoPortWritePortUchar(CRT_DATA_REG, cr5C);
                VideoPortWritePortUchar(CRT_ADDRESS_REG, 0x42);
                VideoPortWritePortUchar(CRT_DATA_REG, (UCHAR)0x05);
                VideoPortWritePortUchar(MISC_OUTPUT_REG_WRITE, (UCHAR)0xEF);
              } else { // 72Hz
                cr5C |= 0x20;
                VideoPortWritePortUchar(CRT_ADDRESS_REG, 0x5C);
                VideoPortWritePortUchar(CRT_DATA_REG, cr5C);
                VideoPortWritePortUchar(CRT_ADDRESS_REG, 0x42);
                VideoPortWritePortUchar(CRT_DATA_REG, (UCHAR)0x05);
                VideoPortWritePortUchar(MISC_OUTPUT_REG_WRITE, (UCHAR)0x2F);
              } /* endif */

              break;

           default:
             break;
        } /* endswitch */

        break;

        //
        // Generic S3 board.
        //

    case S3_GENERIC:
    default:

        //
        // If the board has an SDAC then assume it also has an 864 (for now)
        // this could be made better later by checking ChipID too, it appears
        // that the display driver will need to be made 864 specific to get
        // the best possible performance and this one may need to be specific
        // before this is all done so I am not making it bulletproof yet
        //

        if( HwDeviceExtension->DacID == S3_SDAC ) {
            InitializeSDAC( HwDeviceExtension );
        } else {
            ul = HwDeviceExtension->ActiveFrequencyEntry->Fixed.Clock;
            VideoPortWritePortUchar(CRT_ADDRESS_REG, 0x42);
            VideoPortWritePortUchar(CRT_DATA_REG, (UCHAR) ul);
        }

        break;

    }

    return TRUE;
}


VP_STATUS
Wait_VSync(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    )

/*++

Routine Description:

    Wait for the vertical blanking interval on the chip

Arguments:

    HwDeviceExtension - Supplies a pointer to the miniport's device extension.

Return Value:

    Always TRUE

--*/

{
    ULONG i;
    UCHAR byte;

    // It's real possible that this routine will get called
    // when the 911 is in a zombie state, meaning there is no
    // vertical sync being generated.  This is why we have some long
    // time out loops here.

    // First wait for getting into vertical blanking.

    for (i = 0; i < 0x100000; i++) {

        byte = VideoPortReadPortUchar(SYSTEM_CONTROL_REG);
        if (byte & 0x08)
            break;

    }

    //
    // We are either in a vertical blaning interval or we have timmed out.
    // Wait for the Vertical display interval.
    // This is done to make sure we exit this routine at the beginning
    // of a vertical blanking interval, and not in the middle or near
    // the end of one.
    //

    for (i = 0; i < 0x100000; i++) {

        byte = VideoPortReadPortUchar(SYSTEM_CONTROL_REG);
        if (!(byte & 0x08))
            break;

    }

    //
    // Now wait to get into the vertical blank interval again.
    //

    for (i = 0; i < 0x100000; i++) {

        byte = VideoPortReadPortUchar(SYSTEM_CONTROL_REG);
        if (byte & 0x08)
            break;

    }

    return (TRUE);

}


BOOLEAN
Set864MemoryTiming(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    )

/*++

Routine Description:

    Sets L, M and N timing parameters, also sets and enables the
    Start Display FIFO register

Arguments:

    HwDeviceExtension - Supplies a pointer to the miniport's device extension.

Return Value:

    TRUE if success, FALSE if failure

--*/

{

    ULONG  MIndex, ColorDepth, ScreenWidth, failure = 0;
    USHORT data16;
    UCHAR  data8, old38, old39;

    //
    // unlock registers
    //

    VideoPortWritePortUchar(CRT_ADDRESS_REG, 0x38);
    old38 = VideoPortReadPortUchar( CRT_DATA_REG);
    VideoPortWritePortUchar(CRT_ADDRESS_REG, 0x39);
    old39 = VideoPortReadPortUchar( CRT_DATA_REG);
    VideoPortWritePortUshort(CRT_ADDRESS_REG, 0x4838);
    VideoPortWritePortUshort(CRT_ADDRESS_REG, 0xA039);

    //
    // make sure this is an 864
    //

    VideoPortWritePortUchar(CRT_ADDRESS_REG, 0x30);
    data8 = VideoPortReadPortUchar(CRT_DATA_REG);

    if ((data8 & 0xf0) != 0xc0)
        failure = 1;

    //
    // make sure there is an entry in the M parameter table for this mode
    //

    MIndex = (HwDeviceExtension->AdapterMemorySize < 0x200000) ? 0 : 12;

    switch (HwDeviceExtension->ActiveFrequencyEntry->ScreenWidth) {

    case 640:
        MIndex += 0;
        break;

    case 800:
        MIndex += 4;
        break;

    case 1024:
        MIndex += 8;
        break;

    default:
        failure = 1;
        break;
    }

    switch (HwDeviceExtension->ActiveFrequencyEntry->BitsPerPel) {

    case 8:
        MIndex += 0;
        break;

    case 16:
        MIndex += 2;
        break;

    default:
        failure = 1;
        break;
    }

    switch (HwDeviceExtension->ActiveFrequencyEntry->ScreenFrequency) {

    case 60:
        MIndex += 0;
        break;

    case 72:
        MIndex += 1;
        break;

    default:
        failure = 1;
        break;
    }

    if (failure) {
        // reset lock registers to previous state
        VideoPortWritePortUchar(CRT_ADDRESS_REG, 0x38);
        VideoPortWritePortUchar(CRT_DATA_REG, old38);
        VideoPortWritePortUchar(CRT_ADDRESS_REG, 0x39);
        VideoPortWritePortUchar(CRT_DATA_REG, old39);

        return (FALSE);
    }

    //
    // set and enable L parameter, 1 Mb frame buffer configurations are
    // restricted to a 32 bit data path and therefore make twice as many
    // transfers
    //

    ScreenWidth = HwDeviceExtension->ActiveFrequencyEntry->ScreenWidth;
    ColorDepth  = HwDeviceExtension->ActiveFrequencyEntry->BitsPerPel;

    if (HwDeviceExtension->AdapterMemorySize < 0x200000)
        data16 = (USHORT) ((ScreenWidth * (ColorDepth / 8)) / 4);
    else
        data16 = (USHORT) ((ScreenWidth * (ColorDepth / 8)) / 8);

    VideoPortWritePortUchar(CRT_ADDRESS_REG, 0x62);
    VideoPortWritePortUchar(CRT_DATA_REG, (UCHAR) (data16 & 0xff));
    data16 = (data16 >> 8) & 0x07;
    VideoPortWritePortUchar(CRT_ADDRESS_REG, 0x61);
    VideoPortWritePortUchar(CRT_DATA_REG, (UCHAR) ((data16 & 0x07) | 0x80));

    //
    // set Start Display FIFO register
    //

    VideoPortWritePortUchar(CRT_ADDRESS_REG, 0x5d);
    data8 = VideoPortReadPortUchar(CRT_DATA_REG);
    data16 = data8 & 0x01;
    data16 <<= 8;
    VideoPortWritePortUchar(CRT_ADDRESS_REG, 0x00);
    data8 = VideoPortReadPortUchar(CRT_DATA_REG);
    data16 |= data8;
    data16 -= 5;        // typical CR3B is CR0 - 5 (with extension bits)

    VideoPortWritePortUchar(CRT_ADDRESS_REG, 0x3b);
    VideoPortWritePortUchar(CRT_DATA_REG, (UCHAR) (data16 & 0xff));
    VideoPortWritePortUchar(CRT_ADDRESS_REG, 0x5d);
    data8 = VideoPortReadPortUchar(CRT_DATA_REG);
    data8 &= 0xbf;
    data8 = data8 | (UCHAR) ((data16 & 0x100) >> 2);
    VideoPortWritePortUchar(CRT_DATA_REG, data8);

    //
    // enable Start Display FIFO register
    //

    VideoPortWritePortUchar(CRT_ADDRESS_REG, 0x34);
    data8 = VideoPortReadPortUchar(CRT_DATA_REG);
    data8 |= 0x10;
    VideoPortWritePortUchar(CRT_DATA_REG, data8);

    //
    // set M parameter
    //

    VideoPortWritePortUchar(CRT_ADDRESS_REG, 0x54);
    VideoPortWritePortUchar(CRT_DATA_REG, (UCHAR) MParameterTable[MIndex]);

    //
    // set N parameter
    //

    VideoPortWritePortUchar(CRT_ADDRESS_REG, 0x60);
    VideoPortWritePortUchar(CRT_DATA_REG, (UCHAR) 0xff);

    //
    // restore lock registers to previous state
    //

    VideoPortWritePortUchar(CRT_ADDRESS_REG, 0x38);
    VideoPortWritePortUchar(CRT_DATA_REG, old38);
    VideoPortWritePortUchar(CRT_ADDRESS_REG, 0x39);
    VideoPortWritePortUchar(CRT_DATA_REG, old39);

    return (TRUE);

}


VP_STATUS
QueryStreamsParameters(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    VIDEO_QUERY_STREAMS_MODE *pStreamsMode,
    VIDEO_QUERY_STREAMS_PARAMETERS *pStreamsParameters
    )

/*++

Routine Description:

    Queries various attributes of the card for later determine streams
    parameters for minimum horizontal stretch and FIFO control

Arguments:

    HwDeviceExtension - Supplies a pointer to the miniport's device extension.

    RefreshRate - Supplies the exact refresh rate (a default rate of '1' will
                  not do).

    pWidthRatio - Returns the corresponding minimum horizontal stretch factor,
                  expressed as a multiple of 1000.

    pFifoValue - Returns the corresponding FIFO setting.

Return Value:

    TRUE if success, FALSE if failure

--*/

{
    ULONG BitsPerPel;
    ULONG ScreenWidth;
    ULONG RefreshRate;
    UCHAR MemoryFlags;
    ULONG n;
    ULONG m;
    ULONG r;
    ULONG mclock;
    ULONG MemorySpeed;
    K2TABLE* pEntry;
    ULONG MatchRefreshRate;
    ULONG MatchMemorySpeed;

    //
    // Copy the input parameters and round 15 up to 16.
    //

    BitsPerPel = (pStreamsMode->BitsPerPel + 1) & ~7;
    ScreenWidth = pStreamsMode->ScreenWidth;
    RefreshRate = pStreamsMode->RefreshRate;

    //
    // Determine the memory type and memory size.
    //

    VideoPortWritePortUchar(CRT_ADDRESS_REG, 0x36);
    MemoryFlags = (VideoPortReadPortUchar(CRT_DATA_REG) & 0x0c) >> 2;

    if (HwDeviceExtension->AdapterMemorySize != 0x100000) {

        MemoryFlags |= MEM_2MB;
    }

    //
    // Unlock sequencer registers.
    //

    VideoPortWritePortUshort(SEQ_ADDRESS_REG, 0x0608);

    //
    // Get memory speed, using some inexplicable code from S3.
    //

    VideoPortWritePortUchar(SEQ_ADDRESS_REG, 0x10);
    n = VideoPortReadPortUchar(SEQ_DATA_REG);
    VideoPortWritePortUchar(SEQ_ADDRESS_REG, 0x11);
    m = VideoPortReadPortUchar(SEQ_DATA_REG) & 0x7f;

    MemorySpeed = n | (m << 8);

    switch (MemorySpeed) {

    case 0x1A40:    // Known power-on default value
    case 0x2841:    // 50MHz
        MemorySpeed = 50;
        break;

    case 0x4142:    // 60MHz
        MemorySpeed = 60;
        break;

    case 0x3643:    // 40MHz
        MemorySpeed = 40;
        break;

    default:        // All others:
        r = (n >> 5) & 0x03;
        if (r == 0)
            r = 1;
        else
            r = 2 << (r-1);

        n = n & 0x1f;
        mclock = ((m + 2) * 14318L) / (((n + 2) * r) * 100L);
        MemorySpeed = mclock / 10;
        if ((mclock % 10) >= 5)
            MemorySpeed++;

        if (MemorySpeed < 40)
            MemorySpeed = 40;
        break;
    }

    pEntry = &K2WidthRatio[0];
    MatchRefreshRate = 0;
    MatchMemorySpeed = 0;

    while (pEntry->ScreenWidth != 0) {

        //
        // First find an exact match based on resolution, bits-per-pel,
        // memory type and size.
        //

        if ((pEntry->ScreenWidth == ScreenWidth) &&
            (pEntry->BitsPerPel == BitsPerPel) &&
            (pEntry->MemoryFlags == MemoryFlags)) {

            //
            // Now find the entry with the refresh rate and memory speed the
            // closest to, but not more than, our refresh rate and memory
            // speed.
            //

            if ((pEntry->RefreshRate <= RefreshRate) &&
                (pEntry->RefreshRate >= MatchRefreshRate) &&
                (pEntry->MemorySpeed <= MemorySpeed) &&
                (pEntry->MemorySpeed >= MatchMemorySpeed)) {

                MatchRefreshRate = pEntry->RefreshRate;
                MatchMemorySpeed = pEntry->MemorySpeed;
                pStreamsParameters->MinOverlayStretch = pEntry->Value;
            }
        }

        pEntry++;
    }

    if (MatchRefreshRate == 0) {

        return ERROR_INVALID_PARAMETER;
    }

    pEntry = &K2FifoValue[0];
    MatchRefreshRate = 0;
    MatchMemorySpeed = 0;

    while (pEntry->ScreenWidth != 0) {

        //
        // First find an exact match based on resolution, bits-per-pel,
        // memory type and size.
        //

        if ((pEntry->ScreenWidth == ScreenWidth) &&
            (pEntry->BitsPerPel == BitsPerPel) &&
            (pEntry->MemoryFlags == MemoryFlags)) {

            //
            // Now find the entry with the refresh rate and memory speed the
            // closest to, but not more than, our refresh rate and memory
            // speed.
            //

            if ((pEntry->RefreshRate <= RefreshRate) &&
                (pEntry->RefreshRate >= MatchRefreshRate) &&
                (pEntry->MemorySpeed <= MemorySpeed) &&
                (pEntry->MemorySpeed >= MatchMemorySpeed)) {

                MatchRefreshRate = pEntry->RefreshRate;
                MatchMemorySpeed = pEntry->MemorySpeed;
                pStreamsParameters->FifoValue = pEntry->Value;
            }
        }

        pEntry++;
    }

    if (MatchRefreshRate == 0) {

        return ERROR_INVALID_PARAMETER;
    }

    return NO_ERROR;
}

/*****************************************************************************
 *
 *  FUNCTION NAME:  isMach()
 *
 *  DESCRIPTIVE NAME:
 *
 *  FUNCTION:       Determine if system is an IBM Mach
 *
 *
 *  NOTES:          Query the Vital Product Data (VPD) area
 *                  F000:FFA0 in ROM.
 *                  MACH Systems have "N", "P", "R", or "T" at location D
 *                  i.e. at F000:FFAD location
 *
 *  EXIT:           return code FALSE if not an IBM MACH System
 *                  return code TRUE  if a IBM MACH System
 *
 *  INTERNAL REFERENCES:
 *    ROUTINES:
 *
 *  EXTERNAL REFERENCES:
 *    ROUTINES:
 *
 ****************************************************************************/
BOOLEAN isMach(PHW_DEVICE_EXTENSION HwDeviceExtension)
{
    BOOLEAN ret = FALSE;
    PVOID   MappedVPDAddr = NULL;
    PHYSICAL_ADDRESS VPDPhysAddr;
    VPDPhysAddr.LowPart = 0x000fffad ;
    VPDPhysAddr.HighPart = 0x00000000 ;

    // Get the mapped address of the physical address F000:FFA0
    MappedVPDAddr = VideoPortGetDeviceBase(HwDeviceExtension,
                       VPDPhysAddr,
                       0x20,
                       0);

    if (MappedVPDAddr != NULL)
    {
        if ((VideoPortScanRom(HwDeviceExtension,
                                MappedVPDAddr,
                                1,
                                "N"))||
            (VideoPortScanRom(HwDeviceExtension,
                                MappedVPDAddr,
                                1,
                                "P"))||
            (VideoPortScanRom(HwDeviceExtension,
                                MappedVPDAddr,
                                1,
                                "R"))||
            (VideoPortScanRom(HwDeviceExtension,
                                MappedVPDAddr,
                                1,
                                "T")))
        {
            VideoPortFreeDeviceBase(HwDeviceExtension,
                                    MappedVPDAddr);
            ret = TRUE;
        }
    }

    return(ret);

}

VOID
WorkAroundForMach(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    )

/*++

Routine Description:

    This routine will attempt to determine if we are running on an
    IBM Mach system.  If so, and and 868 card was detected, we
    will treat the card as an 864.

Arguments:

    HwDeviceExtension - pointer to the miniports device extension.

Return:

    none.

--*/

{
    if ((HwDeviceExtension->SubTypeID == SUBTYPE_868) &&
        isMach(HwDeviceExtension))
    {
        VideoDebugPrint((1, "S3 868 detected on IBM Mach.  Treat as 864.\n"));

        HwDeviceExtension->ChipID = S3_864;
        HwDeviceExtension->SubTypeID = SUBTYPE_864;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\test\moninf\comalias.cpp ===
#include "stdafx.h"
#include "mon.h"

CCommonAlias gCommonAlias;

int compareCommonAlias(LPCOMMON_ALIAS p1, LPCOMMON_ALIAS p2)
{
   return (stricmp(p1->lpAlias, p2->lpAlias));
}

CCommonAlias::CCommonAlias()
{
	m_Alias.RemoveAll();
}

CCommonAlias::~CCommonAlias()
{
	ClearAll();
}
VOID CCommonAlias::ClearAll(VOID)
{
	for (int i = 0; i < m_Alias.GetSize(); i++)
		free (m_Alias[i]);
	m_Alias.RemoveAll();
}

LPCOMMON_ALIAS CCommonAlias::AddOneAlias(LPSTR lpAlias, LPSTR lpContents)
{
	LPCOMMON_ALIAS pNewAlias = (PCOMMON_ALIAS)malloc(sizeof(COMMON_ALIAS)
                                                     + lstrlen(lpAlias)
                                                     + lstrlen(lpContents) + 2);
	if (pNewAlias == NULL)
    {
        ASSERT(FALSE);
        return NULL;
    }

	pNewAlias->lpAlias = (LPSTR)(pNewAlias + 1);
    pNewAlias->lpContents = pNewAlias->lpAlias + lstrlen(lpAlias)+1;
    strcpy(pNewAlias->lpAlias, lpAlias);
	strcpy(pNewAlias->lpContents, lpContents);

	int comp = 1;
	for (int i = 0; i < m_Alias.GetSize(); i++)
	{
		LPCOMMON_ALIAS pAlias = (LPCOMMON_ALIAS)m_Alias[i];
		comp = compareCommonAlias(pNewAlias, pAlias);

		if (comp > 0)
			continue;
		else if (comp < 0)
            break;

        if (strcmp(pNewAlias->lpContents, pAlias->lpContents))
        {
            sprintf(gszMsg, "Alias %%%s%% has conflicting contents:\n\n%s\n%s", 
                    lpAlias, pNewAlias->lpContents, pAlias->lpContents);
            MessageBox(NULL, gszMsg, gszInputFileName, MB_OK);

            ASSERT(FALSE);
        }

        break;
	}
	if (comp == 0)
	{
		free(pNewAlias);
	}
	else
	{
		m_Alias.InsertAt(i, (LPVOID)pNewAlias);
	}

	return (LPCOMMON_ALIAS)m_Alias[i];
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\s3\mini\sdac.c ===
/*++

Copyright (c) 1994-1995  International Buisness Machines Corporation
Copyright (c) 1994-1995  Microsoft Corporation

Module Name:

    sdac.c

Abstract:

    This module contains the code that initializes the S3 SDAC.

Environment:

    Kernel mode

Revision History:

--*/

#include    "s3.h"

#if defined(ALLOC_PRAGMA)
#pragma alloc_text(PAGE,InitializeSDAC)
#pragma alloc_text(PAGE,FindSDAC)
#endif


BOOLEAN
InitializeSDAC( PHW_DEVICE_EXTENSION HwDeviceExtension )

/*++

Routine Description:

    Initializes the SDAC.

Arguments:

    HwDeviceExtension - Supplies a pointer to the miniport's device extension.

Return Value:

    Always TRUE

--*/

{

    SDAC_PLL_PARMS
        *SdacClk0;

    ULONG
        tablebase;

    UCHAR
        i,
        clk,
        dval,
        old55;


    tablebase = HwDeviceExtension->ActiveFrequencyEntry->Fixed.Clock;
    clk = (UCHAR) tablebase;

    tablebase = (tablebase < 8) ? 0 : ((tablebase - 2) / 6) * 6;
    SdacClk0 = &SdacTable[tablebase];

    clk -= (UCHAR) tablebase;
    clk |= 0x20;

    // set RS[2] with CR55[0];
    VideoPortWritePortUchar(CRT_ADDRESS_REG, 0x55);
    dval  = VideoPortReadPortUchar(CRT_DATA_REG);
    old55 = dval;
    dval &= 0xfc;
    dval |= 0x01;
    VideoPortWritePortUchar(CRT_DATA_REG, dval);
    VideoPortReadPortUchar(CRT_DATA_REG);

    // Enhanced Command Register
    if( HwDeviceExtension->ActiveFrequencyEntry->BitsPerPel == 16 )
        VideoPortWritePortUchar(DAC_PIXEL_MASK_REG, 0x50);
    else
        VideoPortWritePortUchar(DAC_PIXEL_MASK_REG, 0x00);

    // Program CLK0 registers
    for( i = 2; i < 8; ++i )    // write registers f2 - f7 only
        {
        // make sure we don't run off the end of the table
        if( (ULONG_PTR) &SdacClk0[i] >= (ULONG_PTR) &SdacTable[SDAC_TABLE_SIZE] )
            break;

        if( SdacClk0[i].m || SdacClk0[i].n )
            {
            VideoPortWritePortUchar(DAC_ADDRESS_WRITE_PORT, i);
            VideoPortWritePortUchar(DAC_DATA_REG_PORT, SdacClk0[i].m);
            VideoPortWritePortUchar(DAC_DATA_REG_PORT, SdacClk0[i].n);
            }
        }

    // Program CLK1
    VideoPortWritePortUchar(DAC_ADDRESS_WRITE_PORT, 0x0a);
    VideoPortWritePortUchar(DAC_DATA_REG_PORT, 0x41);
    VideoPortWritePortUchar(DAC_DATA_REG_PORT, 0x26);

    // select CLK0 with the PLL control register
    VideoPortWritePortUchar(DAC_ADDRESS_WRITE_PORT, 0x0e);
    VideoPortWritePortUchar(DAC_DATA_REG_PORT, clk);

    // restore CR55
    VideoPortWritePortUchar(CRT_ADDRESS_REG, 0x55);
    VideoPortWritePortUchar(CRT_DATA_REG, old55);

    return( TRUE );

}



BOOLEAN
FindSDAC( PHW_DEVICE_EXTENSION HwDeviceExtension )

/*++

Routine Description:

    Detects and S3 SDAC.

Arguments:

    HwDeviceExtension - Supplies a pointer to the miniport's device extension.

Return Value:

    TRUE if SDAC detected; FALSE if not.

--*/

{

    UCHAR
            regval,
            old55;


    // 4 consecutive reads of the SDAC's Pixel Mask Register cause
    // the next access to that register to be redirected to the
    // SDAC's Enhanced Command Register, additionally the 4th read
    // returns 0x70 to identify the SDAC

    // set CR55[0] to access the Pixel Mask Register
    VideoPortWritePortUchar( CRT_ADDRESS_REG, 0x55 );
    old55 = VideoPortReadPortUchar( CRT_DATA_REG );
    VideoPortWritePortUchar( CRT_DATA_REG, (UCHAR) (old55 & 0xfc) );

    // look for the SDAC's ID
    VideoPortWritePortUchar( DAC_PIXEL_MASK_REG, 0 );
    VideoPortWritePortUchar( DAC_PIXEL_MASK_REG, 0xff );
    VideoPortReadPortUchar(  DAC_PIXEL_MASK_REG );
    VideoPortReadPortUchar(  DAC_PIXEL_MASK_REG );
    VideoPortReadPortUchar(  DAC_PIXEL_MASK_REG );

    regval = VideoPortReadPortUchar( DAC_PIXEL_MASK_REG );

    if( (regval & 0xf0) == 0x70 )
        {
        // clear the redirection
        VideoPortReadPortUchar( DAC_PIXEL_MASK_REG );
        return( TRUE );
        }

    // restore the contents of register 55
    VideoPortWritePortUchar( CRT_ADDRESS_REG, 0x55 );
    VideoPortWritePortUchar( CRT_DATA_REG, old55 );

    return( FALSE );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\test\moninf\comsect.cpp ===
#include "stdafx.h"
#include "mon.h"

CCommonSection gCommonSections;

int compareCommonSection(LPCOMMON_SECTION p1, LPCOMMON_SECTION p2)
{
   return (stricmp(p1->sectName, p2->sectName));
}

CCommonSection::CCommonSection()
{
	m_sections.RemoveAll();
}

CCommonSection::~CCommonSection()
{
	ClearAll();
}
VOID CCommonSection::ClearAll(VOID)
{
	for (int i = 0; i < m_sections.GetSize(); i++)
		delete((LPCOMMON_SECTION)m_sections[i]);
	m_sections.RemoveAll();
}

LPCOMMON_SECTION CCommonSection::AddOneSection(LPSTR sectName, LPSTR contents)
{
	LPCOMMON_SECTION pNewSection = new(COMMON_SECTION);
	if (pNewSection == NULL)
    {
        ASSERT(FALSE);
        return NULL;
    }

	strcpy(pNewSection->sectName, sectName);
	strcpy(pNewSection->contents, contents);
	LPSTR pEndSectName = pNewSection->sectName + lstrlen(pNewSection->sectName);
	int   dupSectCount = 1;

	int comp = 1;
	for (int i = 0; i < m_sections.GetSize(); i++)
	{
		LPCOMMON_SECTION pSection = (LPCOMMON_SECTION)m_sections[i];
		comp = compareCommonSection(pNewSection, pSection);

		if (comp > 0)
			continue;
		else if (comp < 0)
            break;

		if (stricmp(pNewSection->contents, pSection->contents) == 0)
			break;
		///////////////////////////////////////////////////////////////
		// Come here, we found a section with same section name but
		// different contents.  Need rename the section Name to make
		// it distinct
		sprintf(pEndSectName, "%c", 'A'+dupSectCount);
		dupSectCount++;
	}
	if (comp == 0)
	{
		delete pNewSection;
	}
	else
	{
		m_sections.InsertAt(i, (LPVOID)pNewSection);
	}

	return (LPCOMMON_SECTION)m_sections[i];
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\test\moninf\mon.h ===
#include "stdafx.h"

#define MAX_INFFILE_SIZE	0x60000
#define MAX_LINE_NUMBER     5000
#define MAX_SECTION_NUMBER  1000

const char REPORT_FILE_NAME[] = "d:\\outinf\\report.txt";
const char SRC_INF_PATH[] = "d:\\temp";
const char DEST_INF_PATH[] = "d:\\outinf";
const int  FILE_BREAK_SIZE = 0xFFFFFFFF;   // 0xFFFFFFFF means dump to only one inf

typedef struct tagCommonAlias
{
    DWORD refCount;
    LPSTR lpAlias;
    LPSTR lpContents;
} COMMON_ALIAS, *PCOMMON_ALIAS, *LPCOMMON_ALIAS;

class CCommonAlias
{
public:
    CCommonAlias();
    ~CCommonAlias();
    VOID ClearAll(VOID);
    int  GetSize() const  { return m_Alias.GetSize(); }
    LPCOMMON_ALIAS GetAt(int i) { return (LPCOMMON_ALIAS)m_Alias[i]; }
    LPCOMMON_ALIAS AddOneAlias(LPSTR, LPSTR);

private:
    CPtrArray   m_Alias;
};

typedef struct tagCommonSection
{
    DWORD refCount;
    TCHAR sectName[32];
    TCHAR contents[128];
} COMMON_SECTION, *PCOMMON_SECTION, *LPCOMMON_SECTION;

class CCommonSection
{
public:
    CCommonSection();
    ~CCommonSection();
    VOID ClearAll(VOID);
    int  GetSize() const  { return m_sections.GetSize(); }
    LPCOMMON_SECTION GetAt(int i) const   { return (LPCOMMON_SECTION)m_sections[i]; }
    LPCOMMON_SECTION AddOneSection(LPSTR, LPSTR);

private:
    CPtrArray   m_sections;   
};

typedef struct _SECTION
{
    TCHAR   name[256];
    UINT    startLine, endLine;
} SECTION, *PSECTION, *LPSECTION;

class CMonitor
{
public:
    CMonitor()  { bDupInstSection = FALSE; 
                  pAlias = NULL;
                  AddRegSectionBuf = NULL;
                  numCommonSects = 0; }
    ~CMonitor() { if (AddRegSectionBuf) free(AddRegSectionBuf); }

public:
    BOOL    bDupInstSection;
    TCHAR   AliasName[48];
    LPCOMMON_ALIAS pAlias;
    TCHAR   InstallSectionName[64];
    TCHAR   AddRegSectionName[64];
    TCHAR   ID[16];

    int     numCommonSects;
    LPCOMMON_SECTION CommonSects[8];

    LPSTR   AddRegSectionBuf;
};

class CManufacturer
{
public:
    CManufacturer() { pAlias = NULL; }
    ~CManufacturer();

public:
    TCHAR   name[64];
    TCHAR   AliasName[64];
    LPCOMMON_ALIAS pAlias;

    CPtrArray MonitorArray;
    CPtrArray m_MonitorIDArray;
};

class CMonitorInf
{
public:
    CMonitorInf() { pReadFileBuf = NULL; } 

public:
    LPSTR   pReadFileBuf;
    UINT    numLines;
    LPSTR   lines[MAX_LINE_NUMBER];
    UINT    numSections;
    SECTION sections[MAX_SECTION_NUMBER];

    CPtrArray ManufacturerArray;

private:
    CHAR  m_lineBuf[256];
    LPSTR m_tokens[10];

public:
    ~CMonitorInf();
    
    LPSECTION SeekSection(LPCSTR);
    BOOL      ParseInf(VOID);

private:
    BOOL      ParseOneManufacturer(CManufacturer *);
    BOOL      ParseOneMonitor(CMonitor *);
    VOID      Pack(VOID);
    BOOL      FillupAlias(VOID);
    LPCOMMON_ALIAS LookupCommonAlias(LPCSTR, LPCOMMON_ALIAS, UINT);
};

class CSumInf
{
public:
    CSumInf();
    ~CSumInf();
    VOID Initialize(LPCSTR);
    VOID AddOneManufacturer(CManufacturer*);
    VOID CheckDupSections(VOID);
    VOID CheckDupMonIDs(VOID);
    VOID CheckDupAlias(VOID);
    VOID DumpMonitorInf(LPCSTR, int);

private:
    VOID MergeOneManufacturer(CManufacturer *, CManufacturer *);

    int  DumpManufacturers(LPCSTR, int, int, int);
    VOID DumpManufactureSection(FILE *, CManufacturer *);
    VOID DumpInstallSection(FILE *, CManufacturer *);
    VOID DumpCommonAddRegSection(FILE *, int, int);
    VOID DumpAddRegSection(FILE *, CManufacturer *);
    VOID DumpCommonStringSection(FILE *, int, int);
    VOID DumpCommonHeader(FILE *, int);

private:
    CPtrArray m_ManufacturerArray;
    CPtrArray m_SectionNameArray;
public:
    FILE    *m_fpReport;
};

///////////////////////////////////////////////////////////
// Global variables
extern CCommonSection gCommonSections;
extern CCommonAlias   gCommonAlias;
extern CSumInf        gSumInf;
extern TCHAR          gszMsg[];
extern TCHAR          gszInputFileName[];

///////////////////////////////////////////////////////////
// Global Functions
extern VOID TokenizeInf(LPSTR, CMonitorInf *);
extern UINT TokenOneLine(LPSTR, CHAR, LPSTR);

extern VOID ReadOneMonitorInf(LPCSTR, CMonitorInf *);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\test\moninf\moninf.cpp ===
// moninf.cpp : Defines the class behaviors for the application.
//

#include "stdafx.h"
#include "moninf.h"
#include "moninfDlg.h"
#include "mon.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CMoninfApp

BEGIN_MESSAGE_MAP(CMoninfApp, CWinApp)
	//{{AFX_MSG_MAP(CMoninfApp)
		// NOTE - the ClassWizard will add and remove mapping macros here.
		//    DO NOT EDIT what you see in these blocks of generated code!
	//}}AFX_MSG
	ON_COMMAND(ID_HELP, CWinApp::OnHelp)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CMoninfApp construction

CMoninfApp::CMoninfApp()
{
	// TODO: add construction code here,
	// Place all significant initialization in InitInstance
}

/////////////////////////////////////////////////////////////////////////////
// The one and only CMoninfApp object

CMoninfApp theApp;

/////////////////////////////////////////////////////////////////////////////
// Private Functions

void ReadMonitorInfs(LPCSTR);

/////////////////////////////////////////////////////////////////////////////
// CMoninfApp initialization

BOOL CMoninfApp::InitInstance()
{
    gSumInf.Initialize(REPORT_FILE_NAME);
    
    ReadMonitorInfs(SRC_INF_PATH);

    gSumInf.CheckDupSections();
    gSumInf.CheckDupMonIDs();
    gSumInf.CheckDupAlias();
    gSumInf.DumpMonitorInf(DEST_INF_PATH, FILE_BREAK_SIZE);

    return FALSE;
}

void ReadMonitorInfs(LPCSTR srcDir)
{
    CString     fileName;
    
    fileName = CString(srcDir) + "\\*.*";

    CFileFind finder;

    if (finder.FindFile(fileName))
    {
        BOOL bWorking = TRUE;
        while (bWorking)
        {
            bWorking = finder.FindNextFile();

            if (finder.IsDots())
                continue;

            if (finder.IsDirectory())
            {
                ReadMonitorInfs((LPCSTR)finder.GetFilePath());
                continue;
            }

            //////////////////////////////////////////////
            // Check if it's INF file
            CString fName = finder.GetFileName();
            if (stricmp(fName.Right(4), ".inf") != 0)
                continue;
            
            CMonitorInf *pMonitorInf = new(CMonitorInf);
            if (pMonitorInf == NULL)
                continue;

            //////////////////////////////////////////////
            // Check if it's INF file
            ReadOneMonitorInf(finder.GetFilePath(), pMonitorInf);

            for (int i = 0; i < pMonitorInf->ManufacturerArray.GetSize(); i++)
                gSumInf.AddOneManufacturer((CManufacturer*)pMonitorInf->ManufacturerArray[i]);

            pMonitorInf->ManufacturerArray.RemoveAll();

            delete pMonitorInf;
        }
    }
}

VOID ReadOneMonitorInf(LPCSTR fileName, CMonitorInf *pMonitorInf)
{
    lstrcpy(gszInputFileName, fileName);
    fprintf(gSumInf.m_fpReport, "Handling %s\n", gszInputFileName);

    CFile InfFile(fileName, CFile::modeRead);

    DWORD len = InfFile.GetLength();
    if (len > MAX_INFFILE_SIZE || len <= 20)
        return;
    pMonitorInf->pReadFileBuf = (LPSTR)malloc(len+1024);
    if (pMonitorInf->pReadFileBuf == NULL)
        return;
    
    if (InfFile.Read(pMonitorInf->pReadFileBuf, len) < len)
    {
        free(pMonitorInf->pReadFileBuf);
        return;
    }

    TokenizeInf((LPSTR)pMonitorInf->pReadFileBuf, pMonitorInf);
    
    pMonitorInf->ParseInf();

    free(pMonitorInf->pReadFileBuf);
    pMonitorInf->pReadFileBuf = NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\test\moninf\dumpinf.cpp ===
#include "stdafx.h"
#include "mon.h"

const TCHAR GenericMannufacturerSection[] =
"[Generic]\n\
%Unknown.DeviceDesc%=Unknown.Install,Monitor\\Default_Monitor	; for auto-install\n\
%Unknown.DeviceDesc%=Unknown.Install	; for pick list\n\
%*PNP09FF.DeviceDesc%=VESADDC.Install,*PNP09FF\n\
\n\
%Laptop640.DeviceDesc%=Laptop640.Install,Monitor\\MS_0001\n\
%Laptop800.DeviceDesc%=Laptop800.Install,Monitor\\MS_0002\n\
%Laptop1024.DeviceDesc%=Laptop1024.Install,Monitor\\MS_0003\n\
%Laptop1152.DeviceDesc%=Laptop1152.Install,Monitor\\MS_0004\n\
%Laptop1280.DeviceDesc%=Laptop1280.Install,Monitor\\MS_0005\n\
%Laptop1600.DeviceDesc%=Laptop1600.Install,Monitor\\MS_0006\n\
\n\
%TVGen.DeviceDesc%=640.Install,Monitor\\PNP09FE\n\
%TVGen.DeviceDesc%=640.Install,Monitor\\*PNP09FE\n\
\n\
%640.DeviceDesc%=640.Install,Monitor\\MS_0640\n\
%800.DeviceDesc%=800.Install,Monitor\\MS_0800\n\
%1024.DeviceDesc%=1024.Install,Monitor\\MS_1024\n\
%1280.DeviceDesc%=1280.Install,Monitor\\MS_1280\n\
%1600.DeviceDesc%=1600.Install,Monitor\\MS_1600\n\n";

const TCHAR GenericInstallSection[] =
"; -------------- Generic types\n\
[Unknown.Install]\n\
DelReg=DCR\n\
AddReg=Unknown.AddReg\n\
\n\
[VESADDC.Install]\n\
DelReg=DCR\n\
AddReg=VESADDC.AddReg, 1600, DPMS\n\
\n\
[Laptop640.Install]\n\
DelReg=DCR\n\
AddReg=640VESA60, DPMS\n\
\n\
[Laptop800.Install]\n\
DelReg=DCR\n\
AddReg=800VESA60, DPMS\n\
\n\
[Laptop1024.Install]\n\
DelReg=DCR\n\
AddReg=1024VESA60, DPMS\n\
\n\
[Laptop1152.Install]\n\
DelReg=DCR\n\
AddReg=1152VESA60, DPMS\n\
\n\
[Laptop1280.Install]\n\
DelReg=DCR\n\
AddReg=1280VESA60, DPMS\n\
\n\
[Laptop1600.Install]\n\
DelReg=DCR\n\
AddReg=1600VESA60, DPMS\n\
\n\
[640.Install]\n\
DelReg=DCR\n\
AddReg=640\n\
\n\
[800.Install]\n\
DelReg=DCR\n\
AddReg=800\n\
\n\
[1024.Install]\n\
DelReg=DCR\n\
AddReg=1024\n\
\n\
[1280.Install]\n\
DelReg=DCR\n\
AddReg=1280\n\
\n\
[1600.Install]\n\
DelReg=DCR\n\
AddReg=1600\n\n";

const TCHAR GenericAddRegSection[] =
"; -------------- Generic types\n\
[Unknown.AddReg]\n\
HKR,\"MODES\\640,480\"\n\
\n\
[VESADDC.AddReg]\n\
HKR,\"MODES\\1600,1200\"\n\
\n\
[VGA.AddReg]\n\
HKR,\"MODES\\640,480\",Mode1,,\"31.5,50.0-70.0,-,-\"\n\
\n\
[640VESA60]\n\
HKR,\"MODES\\640,480\",Mode1,,\"60.0,50.0,-,-\"\n\
HKR,,PreferredMode,,\"640,480,60\"\n\
\n\
[800VESA60]\n\
HKR,\"MODES\\640,480\",Mode1,,\"60.0,50.0,-,-\"\n\
HKR,\"MODES\\800,600\",Mode1,,\"60.0,60.0,+,+\"\n\
HKR,,PreferredMode,,\"800,600,60\"\n\
\n\
[1024VESA60]\n\
HKR,\"MODES\\640,480\",Mode1,,\"60.0,50.0,-,-\"\n\
HKR,\"MODES\\1024,768\",Mode1,,\"60.0,60.0,+,+\"\n\
HKR,,PreferredMode,,\"1024,768,60\"\n\
\n\
[1152VESA60]\n\
HKR,\"MODES\\640,480\",Mode1,,\"60.0,50.0,-,-\"\n\
HKR,\"MODES\\1152,864\",Mode1,,\"60.0,60.0,+,+\"\n\
HKR,,PreferredMode,,\"1152,864,60\"\n\
\n\
[1280VESA60]\n\
HKR,\"MODES\\640,480\",Mode1,,\"60.0,50.0,-,-\"\n\
HKR,\"MODES\\1280,1024\",Mode1,,\"48.0,65.0,+,+\"\n\
HKR,,PreferredMode,,\"1280,1024,60\"\n\
\n\
[1600VESA60]\n\
HKR,\"MODES\\640,480\",Mode1,,\"60.0,60.0,-,-\"\n\
HKR,\"MODES\\1600,1200\",Mode1,,\"48.0,75.0,+,+\"\n\
HKR,,PreferredMode,,\"1600,1200,60\"\n\n";

const TCHAR GenericStrings[] =
"MonitorClassName=\"Monitors\"\n\
MS=\"Microsoft\"\n\
\n\
Generic=\"(Standard monitor types)\"\n\
Unknown.DeviceDesc=\"Default Monitor\"\n\
\n\
*PNP09FF.DeviceDesc = \"Plug and Play Monitor\"\n\
\n\
Laptop640.DeviceDesc = \"Digital Flat Panel (640x480)\"\n\
Laptop800.DeviceDesc = \"Digital Flat Panel (800x600)\"\n\
Laptop1024.DeviceDesc =\"Digital Flat Panel (1024x768)\"\n\
Laptop1152.DeviceDesc =\"Digital Flat Panel (1152x864)\"\n\
Laptop1280.DeviceDesc =\"Digital Flat Panel (1280x1024)\"\n\
Laptop1600.DeviceDesc =\"Digital Flat Panel (1600x1200)\"\n\
\n\
TVGen.DeviceDesc =\"Generic Television\"\n\
\n\
640.DeviceDesc  = \"Standard VGA 640x480\"\n\
800.DeviceDesc  = \"Super VGA 800x600\"\n\
1024.DeviceDesc = \"Super VGA 1024x768\"\n\
1280.DeviceDesc = \"Super VGA 1280x1024\"\n\
1600.DeviceDesc = \"Super VGA 1600x1200\"\n\n";


VOID CSumInf::DumpMonitorInf(LPCSTR DumpFilePath, int sizeLimit)
{
	TCHAR DumpFileName[256];
    sprintf(DumpFileName, "%s\\tmp.txt", DumpFilePath);

    ASSERT(m_ManufacturerArray.GetSize());
    
    if (sizeLimit == 0xFFFFFFFF)
    {
        sprintf(DumpFileName, "%s\\MONITOR.INF", DumpFilePath);
        DumpManufacturers(DumpFileName, 0, m_ManufacturerArray.GetSize(), 1);
        return;
    }

    int fileBreaks[64], numFileBreaks = 0, fileSize = 0;
    int start = 0, end = 0;

    // 0
    // 0 1 2
    // 0 1 2 | 3 4 | 5
    //         e     e e=6
    while (1)
    {
        end++;
        if (end >= m_ManufacturerArray.GetSize())
        {
            fileBreaks[numFileBreaks++] = end;
            break;
        }
        fileSize = DumpManufacturers(DumpFileName, start, end-start, (start == 0) ? 6 : 0);
        if (fileSize >= sizeLimit)
        {
            fileBreaks[numFileBreaks++] = end;
            start = end;
            fileSize = 0;
        }
    }

    sprintf(DumpFileName, "%s\\MONITOR.INF", DumpFilePath);
    DumpManufacturers(DumpFileName, 0, fileBreaks[0], numFileBreaks);
    for (int i = 0; i < (numFileBreaks-1); i++)
    {
        sprintf(DumpFileName, "%s\\MONITOR%d.INF", DumpFilePath, i+2);
        DumpManufacturers(DumpFileName, fileBreaks[i], fileBreaks[i+1]-fileBreaks[i], 0);
    }
}

int CSumInf::DumpManufacturers(LPCSTR DumpFileName, int start, int num, int numInfs)
{
    FILE *fpOut = fopen(DumpFileName, "w");

    LPCSTR lpFileName = strrchr(DumpFileName, '\\');
    ASSERT(lpFileName != NULL);
    lpFileName++;

	if (fpOut == NULL)
		return 0;

    fprintf(fpOut, "; %s\n;\n", lpFileName);

    DumpCommonHeader(fpOut, numInfs);
    
    int end = min(start+num, m_ManufacturerArray.GetSize());
    for (int i = start; i < end; i++)
    {
        CManufacturer *pManufacturer = (CManufacturer*)m_ManufacturerArray[i];
        fprintf(fpOut, "%s=%s\n", pManufacturer->AliasName, pManufacturer->name);
    }

    fprintf(fpOut, "\n\n;-------------------------------------------------\n");
    fprintf(fpOut, "; Manufacturer Sections\n\n");

    if (numInfs)
    {
        fprintf(fpOut, "%s", GenericMannufacturerSection);
    }
    
    for (i = start; i < end; i++)
    {
        CManufacturer *pManufacturer = (CManufacturer*)m_ManufacturerArray[i];
        DumpManufactureSection(fpOut, pManufacturer);
    }

    fprintf(fpOut, "\n;-------------------------------------------------\n");
    fprintf(fpOut, "; Install sections\n\n");

    if (numInfs)
    {
        fprintf(fpOut, "%s", GenericInstallSection);
    }
    
    for (i = start; i < end; i++)
    {
        CManufacturer *pManufacturer = (CManufacturer*)m_ManufacturerArray[i];
        DumpInstallSection(fpOut, pManufacturer);
    }
    
    fprintf(fpOut, "\n;-------------------------------------------------\n");
    fprintf(fpOut, "; Common AddReg sections\n");

    DumpCommonAddRegSection(fpOut, start, end);

    fprintf(fpOut, "\n;-------------------------------------------------\n");
    fprintf(fpOut, "; Model AddReg sections\n\n");

    if (numInfs)
    {
        fprintf(fpOut, "%s", GenericAddRegSection);
    }
    
    for (i = start; i < end; i++)
    {
        CManufacturer *pManufacturer = (CManufacturer*)m_ManufacturerArray[i];
        DumpAddRegSection(fpOut, pManufacturer);
    }

    fprintf(fpOut, "\n;-------------------------------------------------\n");
    fprintf(fpOut, "; User visible strings\n\n");
    fprintf(fpOut, "[Strings]\n");

    if (numInfs)
    {
        fprintf(fpOut, "%s", GenericStrings);
    }
    else
        fprintf(fpOut, "MS=\"Microsoft\"\n\n");

    DumpCommonStringSection(fpOut, start, end);

    fpos_t fileSize = 0;
    ASSERT( fgetpos(fpOut, &fileSize) == 0 );

    fclose(fpOut);

    return (int)fileSize;
}

VOID CSumInf::DumpManufactureSection(FILE *fp, CManufacturer *pManufacturer)
{
    fprintf(fp, "[%s]\n", pManufacturer->name);
    for (int i = 0; i < pManufacturer->MonitorArray.GetSize(); i++)
    {
        CMonitor *pMonitor = (CMonitor*)pManufacturer->MonitorArray[i];
        fprintf(fp, "%s=%s, %s\n",
                pMonitor->AliasName,
                pMonitor->InstallSectionName,
                pMonitor->ID);
    }
    fprintf(fp, "\n");
}

VOID CSumInf::DumpInstallSection(FILE *fp, CManufacturer *pManufacturer)
{
    fprintf(fp, "; -------------- %s\n", pManufacturer->name);
    for (int i = 0; i < pManufacturer->MonitorArray.GetSize(); i++)
    {
        CMonitor *pMonitor = (CMonitor*)pManufacturer->MonitorArray[i];
        /////////////////////////////////////////////////////////////
        // If this Monitor has duplicated section, ignore it
        if (pMonitor->bDupInstSection)
        {
            continue;
        }
        fprintf(fp, "[%s]\n", pMonitor->InstallSectionName);
        fprintf(fp, "DelReg=DCR\n");
        fprintf(fp, "AddReg=%s", pMonitor->AddRegSectionName);
        for (int j = 0; j < pMonitor->numCommonSects; j++)
            fprintf(fp, ", %s", pMonitor->CommonSects[j]->sectName);
        fprintf(fp, "\n\n");
    }
}

VOID CSumInf::DumpCommonAddRegSection(FILE *fp, int start, int end)
{
    fprintf(fp, "\n[DCR]\n");
    fprintf(fp, "HKR,MODES\n");
    fprintf(fp, "HKR,,MaxResolution\n");
    fprintf(fp, "HKR,,DPMS\n");
    fprintf(fp, "HKR,,ICMProfile\n\n");

    for (int i = 0; i < gCommonSections.GetSize(); i++)
    {
        LPCOMMON_SECTION pSection = gCommonSections.GetAt(i);
        pSection->refCount = 0;
    }
    
    for (i = start; i < end; i++)
    {
        CManufacturer *pManufacturer = (CManufacturer*)m_ManufacturerArray[i];
        for (int j = 0; j < pManufacturer->MonitorArray.GetSize(); j++)
        {
            CMonitor *pMonitor = (CMonitor*)pManufacturer->MonitorArray[j];
            for (int k = 0; k < pMonitor->numCommonSects; k++)
                pMonitor->CommonSects[k]->refCount++;
        }
    }

    ////////////////////////////////////////////////////////
    // For generic common sections
    if (start == 0)
    {
        for (int i = 0; i < gCommonSections.GetSize(); i++)
        {
            LPCOMMON_SECTION pSection = gCommonSections.GetAt(i);
            if (stricmp(pSection->sectName, "DPMS") == 0 ||
                stricmp(pSection->sectName, "1600") == 0 ||
                stricmp(pSection->sectName, "640") == 0  ||
                stricmp(pSection->sectName, "800") == 0  ||
                stricmp(pSection->sectName, "1024") == 0 ||
                stricmp(pSection->sectName, "1280") == 0)
                pSection->refCount++;
        }
    }
    
    for (i = 0; i < gCommonSections.GetSize(); i++)
    {
        LPCOMMON_SECTION pSection = gCommonSections.GetAt(i);
        if (pSection->refCount == 0)
            continue;
        fprintf(fp, "[%s]\n", pSection->sectName);
        fprintf(fp, "%s\n\n", pSection->contents);
    }
}

VOID CSumInf::DumpAddRegSection(FILE *fp, CManufacturer *pManufacturer)
{
    fprintf(fp, "; -------------- %s\n", pManufacturer->name);
    for (int i = 0; i < pManufacturer->MonitorArray.GetSize(); i++)
    {
        CMonitor *pMonitor = (CMonitor*)pManufacturer->MonitorArray[i];

        /////////////////////////////////////////////////////////////
        // If this Monitor has duplicated section, ignore it
        if (pMonitor->bDupInstSection)
        {
            continue;
        }

        ASSERT(lstrlen(pMonitor->AddRegSectionBuf) != 0);
        fprintf(fp, "[%s]\n", pMonitor->AddRegSectionName);
        fprintf(fp, "%s\n", pMonitor->AddRegSectionBuf);
    }
}

VOID CSumInf::DumpCommonStringSection(FILE *fp, int start, int end)
{
    LPCOMMON_ALIAS pAlias;
    
    for (int i = 0; i < gCommonAlias.GetSize(); i++)
    {
        pAlias = gCommonAlias.GetAt(i);
        pAlias->refCount = 0;
    }
    
    ///////////////////////////////////////////
    // Calculate RefCount
    for (i = start; i < end; i++)
    {
        CManufacturer *pManufacturer = (CManufacturer*)m_ManufacturerArray[i];
        pAlias = pManufacturer->pAlias;
        ASSERT(pAlias != NULL);
        pAlias->refCount++;
        for (int j = 0; j < pManufacturer->MonitorArray.GetSize(); j++)
        {
            CMonitor *pMonitor = (CMonitor*)pManufacturer->MonitorArray[j];
            pAlias = pMonitor->pAlias;
            ASSERT(pAlias != NULL);
            pAlias->refCount++;
        }
    }

    ///////////////////////////////////////////
    // Actual dump
    for (i = start; i < end; i++)
    {
        CManufacturer *pManufacturer = (CManufacturer*)m_ManufacturerArray[i];
        pAlias = pManufacturer->pAlias;
        ASSERT(pAlias != NULL);
        if (pAlias->refCount == 1)
        {
            fprintf(fp, "%s=%s\n", pAlias->lpAlias, pAlias->lpContents);
        }
        else
        {
            pAlias->refCount--;
        }
    }
    fprintf(fp, "\n");

    for (i = start; i < end; i++)
    {
        CManufacturer *pManufacturer = (CManufacturer*)m_ManufacturerArray[i];
        for (int j = 0; j < pManufacturer->MonitorArray.GetSize(); j++)
        {
            CMonitor *pMonitor = (CMonitor*)pManufacturer->MonitorArray[j];
            pAlias = pMonitor->pAlias;
            ASSERT(pAlias != NULL);
            if (pAlias->refCount == 1)
            {
                fprintf(fp, "%s=%s\n", pAlias->lpAlias, pAlias->lpContents);
            }
            else
            {
                pAlias->refCount--;
            }
        }
        fprintf(fp, "\n");
    }
}

VOID CSumInf::DumpCommonHeader(FILE *fp, int numInfs)
{
    if (numInfs == 0)
    {
        fprintf(fp, "; This is a Setup information file for monitors\n");
        fprintf(fp, "; supported in the Windows 2000 product.\n;\n");
        fprintf(fp, "; Copyright (c) 2000-2001, Microsoft Corporation\n\n");

        fprintf(fp, "[VERSION]\n");
        fprintf(fp, "Signature=\"$CHICAGO$\"\n");
        fprintf(fp, "Class=Monitor\n");
        fprintf(fp, "ClassGUID={4d36e96e-e325-11ce-bfc1-08002be10318}\n");
        fprintf(fp, "Provider=%%MS%%\n");
        fprintf(fp, "DriverVer=11/01/2000\n\n\n");

        fprintf(fp, ";-------------------------------------------------\n");
        fprintf(fp, "; Manufacturers\n\n");
        fprintf(fp, "[Manufacturer]\n");
    }
    else
    {
        fprintf(fp, "; This is Setup information file for monitors \n");
        fprintf(fp, ";\n");
        fprintf(fp, "; Copyright (c) 2000-2001, Microsoft Corporation\n\n");

        fprintf(fp, "[version]\n");
        fprintf(fp, "LayoutFile=layout.inf, layout1.inf\n");
        fprintf(fp, "signature=\"$CHICAGO$\"\n");
        fprintf(fp, "Class=Monitor\n");
        fprintf(fp, "ClassGUID={4d36e96e-e325-11ce-bfc1-08002be10318}\n");
        fprintf(fp, "Provider=%%MS%%\n");
        fprintf(fp, "SetupClass=BASE\n");
        fprintf(fp, "DriverVer=11/01/2000\n\n");

        fprintf(fp, "[DestinationDirs]\n");
        fprintf(fp, "DefaultDestDir    = 11          ; LDID_SYS\n");
        fprintf(fp, "monitor.infs.copy = 17          ; LDID_INF\n\n\n");

        fprintf(fp, "; Base Install Sections\n");
        fprintf(fp, ";-------------------------------------------------\n");
        fprintf(fp, "[BaseWinOptions]\n");
        fprintf(fp, "MonitorBase\n\n");

        fprintf(fp, "[MonitorBase]\n");
        fprintf(fp, "CopyFiles=monitor.infs.copy\n");

        fprintf(fp, "[monitor.infs.copy]\n");
        fprintf(fp, "monitor.inf\n");
        for (int i = 1; i < numInfs; i++)
        {
            fprintf(fp, "monitor%d.inf\n", i+1);
        }

        fprintf(fp, "\n[SysCfgClasses]\n");
        fprintf(fp, "Monitor, %%Unknown.DeviceDesc%%,MONITOR,4,%%MonitorClassName%%   ; Default to \"Unknown Monitor\"\n\n\n");

        fprintf(fp, "; Install class \"Monitor\"\n");
        fprintf(fp, ";-------------------------------------------------\n");
        fprintf(fp, "[ClassInstall]\n");
        fprintf(fp, "AddReg=ClassAddReg\n");

        fprintf(fp, "[ClassAddReg]\n");
        fprintf(fp, "HKR,,,,%%MonitorClassName%%\n");
        fprintf(fp, "HKR,,Installer,,\"SetupX.Dll, Monitor_ClassInstaller\"\n");
        fprintf(fp, "HKR,,Icon,,\"-1\"\n\n");

        fprintf(fp, "[ClassDelReg]\n\n\n");

        fprintf(fp, "[ClassInstall32.NT]\n");
        fprintf(fp, "AddReg=monitor_class_addreg\n");

        fprintf(fp, "[monitor_class_addreg]\n");
        fprintf(fp, "HKR,,,,%%MonitorClassName%%\n");
        fprintf(fp, "HKR,,Installer32,,\"Desk.Cpl,MonitorClassInstaller\"\n");
        fprintf(fp, "HKR,,Icon,,\"-1\"\n");
        fprintf(fp, "HKR,,NoInstallClass,,\"1\"\n");
        fprintf(fp, "HKR,,TroubleShooter-0,,\"hcp://help/tshoot/tsdisp.htm\"\n");
        fprintf(fp, "HKR,,SilentInstall,,1\n\n");

        fprintf(fp, "; Monitors to hide from pick list\n");
        fprintf(fp, ";-------------------------------------------------\n");
        fprintf(fp, "[ControlFlags]\n");
        fprintf(fp, "ExcludeFromSelect=Monitor\\Default_Monitor\n\n");

        fprintf(fp, ";-------------------------------------------------\n");
        fprintf(fp, "; Manufacturers\n\n");
        fprintf(fp, "[Manufacturer]\n");
        fprintf(fp, "%%Generic%%=Generic\n");
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\test\moninf\moninf.h ===
// moninf.h : main header file for the MONINF application
//

#if !defined(AFX_MONINF_H__E201B3A5_9C4D_438D_8248_BAB399E78763__INCLUDED_)
#define AFX_MONINF_H__E201B3A5_9C4D_438D_8248_BAB399E78763__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifndef __AFXWIN_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "resource.h"		// main symbols

/////////////////////////////////////////////////////////////////////////////
// CMoninfApp:
// See moninf.cpp for the implementation of this class
//

class CMoninfApp : public CWinApp
{
public:
	CMoninfApp();

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CMoninfApp)
	public:
	virtual BOOL InitInstance();
	//}}AFX_VIRTUAL

// Implementation

	//{{AFX_MSG(CMoninfApp)
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};


/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_MONINF_H__E201B3A5_9C4D_438D_8248_BAB399E78763__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\test\moninf\moninfdlg.h ===
// moninfDlg.h : header file
//

#if !defined(AFX_MONINFDLG_H__AFA00218_49B2_4ECE_B50B_2B4346F8568F__INCLUDED_)
#define AFX_MONINFDLG_H__AFA00218_49B2_4ECE_B50B_2B4346F8568F__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

/////////////////////////////////////////////////////////////////////////////
// CMoninfDlg dialog

class CMoninfDlg : public CDialog
{
// Construction
public:
	CMoninfDlg(CWnd* pParent = NULL);	// standard constructor

// Dialog Data
	//{{AFX_DATA(CMoninfDlg)
	enum { IDD = IDD_MONINF_DIALOG };
		// NOTE: the ClassWizard will add data members here
	//}}AFX_DATA

	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CMoninfDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);	// DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	HICON m_hIcon;

	// Generated message map functions
	//{{AFX_MSG(CMoninfDlg)
	virtual BOOL OnInitDialog();
	afx_msg void OnPaint();
	afx_msg HCURSOR OnQueryDragIcon();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_MONINFDLG_H__AFA00218_49B2_4ECE_B50B_2B4346F8568F__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\test\moninf\parseinf.cpp ===
#include "stdafx.h"
#include "mon.h"

TCHAR gszMsg[256];
TCHAR gszInputFileName[512];
    
int compareMonitors(CMonitor *p1, CMonitor *p2)
{
   return (stricmp(&p1->ID[8], &p2->ID[8]));
}

int compareManufacturers(CManufacturer *p1, CManufacturer *p2)
{
   return (stricmp(p1->name, p2->name));
}

////////////////////////////////////////////////////////////////////
// Strip off blank lines and comments
VOID TokenizeInf(LPSTR orgBuf, CMonitorInf *pMonitorInf)
{
    LPSTR linePtr = orgBuf, startPtr, endPtr, outPtr = orgBuf;

    strcat(orgBuf, "\n");
    
    pMonitorInf->numLines = 0;
    
    while (1)
    {
        startPtr = linePtr;
        endPtr  = strchr(linePtr, '\n');
        if (endPtr == NULL)
            break;
        else
            linePtr = endPtr+1;
        *endPtr = '\0';

        // Remove leading space
        while (*startPtr <= ' ' && *startPtr != '\0')
            startPtr++;

        if (strchr(startPtr, ';'))
            endPtr = strchr(startPtr, ';');
        
        //remove trailing space
        while (startPtr != endPtr)
        {
            if (*(endPtr-1) > ' ')
                break; 
            endPtr--;
        }
        *endPtr = '\0';

        // If not blank line, put it back to buf
        if (*startPtr != '\0')
        {
            pMonitorInf->lines[pMonitorInf->numLines] = outPtr;
            pMonitorInf->numLines++;
            ASSERT(pMonitorInf->numLines < MAX_LINE_NUMBER);

            while (*startPtr != '\0')
            {
                *outPtr = *startPtr;
                startPtr++;   outPtr++;
            }
            *outPtr = '\0';
            outPtr++;
        }
    }
    *outPtr = '\0';

    LPSECTION pSection = &pMonitorInf->sections[0];
    pMonitorInf->numSections = 0;
    for (UINT line = 0;
         line < pMonitorInf->numLines;
         line++)
    {
        LPSTR ptr = pMonitorInf->lines[line];
        if (*ptr == '[')
        {
            pSection = &pMonitorInf->sections[pMonitorInf->numSections];
            pSection->startLine = pSection->endLine = line;
            pMonitorInf->numSections++;

            ASSERT(strlen(ptr) <= 250);
            ASSERT(pMonitorInf->numSections < MAX_SECTION_NUMBER);

            strcpy(pSection->name, ptr+1);
            ptr = strchr(pSection->name, ']');
            ASSERT(ptr != NULL);
            *ptr = '\0';
            CString sectionName(pSection->name);
            sectionName.MakeUpper();
            strcpy(pSection->name, sectionName);
        }
        else
            pSection->endLine = line;
    }
}

UINT TokenOneLine(LPSTR line, CHAR token, LPSTR *tokens)
{
    UINT numToken = 0;
    LPSTR ptr;;

    while (ptr = strchr(line, token))
    {
        tokens[numToken] = line;
        *ptr = '\0';
        line = ptr + 1;
        numToken++;
    }
    tokens[numToken] = line;
    numToken++;

    /////////////////////////////////////////////
    // Remove leading and trailing spaces
    for (UINT i = 0; i < numToken; i++)
    {
        ptr = tokens[i];
        while (*ptr <= ' ' && *ptr != '\0')
            ptr++;
        tokens[i] = ptr;

        ptr = ptr+strlen(ptr);
        while (ptr != tokens[i])
        {
            if (*(ptr-1) > ' ')
                break; 
            ptr--;
        }
        *ptr = '\0';
    }

    return numToken;
}

CManufacturer::~CManufacturer()
{
    for (int i = 0; i < MonitorArray.GetSize(); i++)
        delete ((CMonitor *)MonitorArray[i]);
    MonitorArray.RemoveAll();
    m_MonitorIDArray.RemoveAll();
}

CMonitorInf::~CMonitorInf()
{
    for (int i = 0; i < ManufacturerArray.GetSize(); i++)
        delete ((CManufacturer *)ManufacturerArray[i]);
    ManufacturerArray.RemoveAll();

    if (pReadFileBuf)
        free(pReadFileBuf);
}

BOOL CMonitorInf::ParseInf(VOID)
{
    LPSECTION pSection = SeekSection("version");
    if (pSection == NULL)
        return FALSE;

    /////////////////////////////////////////////////////
    // Confirm it's Monitor Class
    for (UINT i = pSection->startLine + 1;
         i <= pSection->endLine;
         i++)
    {
        strcpy(m_lineBuf, lines[i]);
        if (TokenOneLine(m_lineBuf, '=', m_tokens) != 2)
            return FALSE;
        if (stricmp(m_tokens[0], "Class") == 0 &&
            stricmp(m_tokens[1], "Monitor") == 0)
            break;
    }
    if (i > pSection->endLine)
        return FALSE;

    /////////////////////////////////////////////////////
    // Look for Manufacturers 
    //
    // [Manufacturer]
    // %MagCompu%=MagCompu

    pSection = SeekSection("Manufacturer");
    if (pSection == NULL)
        return FALSE;

    for (i = pSection->startLine + 1;
         i <= pSection->endLine;
         i++)
    {
        strcpy(m_lineBuf, lines[i]);
        if (TokenOneLine(m_lineBuf, '=', m_tokens) != 2)
        {
            ASSERT(FALSE);
            return FALSE;
        }

        ////////////////////////////////////////////////////////////
        // Microsoft Generic is special.  Need to be added manually
        if (stricmp(m_tokens[1], "Generic") == 0)
            continue;

        CManufacturer *pManufacturer = new(CManufacturer);
        if (pManufacturer == NULL)
        {
            ASSERT(FALSE);
            return FALSE;
        }
        strcpy(pManufacturer->name, m_tokens[1]);
        strcpy(pManufacturer->AliasName, m_tokens[0]);

        if (!ParseOneManufacturer(pManufacturer))
        {
            sprintf(gszMsg, "Manufacturer %s contains empty contents.", 
                    &pManufacturer->name);
            MessageBox(NULL, gszMsg, gszInputFileName, MB_OK);
            ASSERT(FALSE);
            return FALSE;
        }

    	/////////////////////////////////////////////////
        // Insert the manufacturer into the array.
        // It's sorted by name
    	int comp = 1;
        for (int k = 0; k < ManufacturerArray.GetSize(); k++)
    	{
	    	CManufacturer *pMan = (CManufacturer *)ManufacturerArray[k];
    		comp = compareManufacturers(pManufacturer, pMan);

    		if (comp > 0)
	    		continue;
		    else if (comp < 0)
                break;

    		////////////////////////////////////////////
            // Duplicated Manufacturer in one inf ?
            ASSERT(FALSE);

            break;
    	}
    	if (comp == 0)
	    {
		    delete pManufacturer;
    	}
    	else
    	{
		    ManufacturerArray.InsertAt(k, (LPVOID)pManufacturer);
	    }
    }

    ///////////////////////////////////////////////////////
    // Remove Manufacturers with empty monitors
    Pack();

    ASSERT(FillupAlias());

    return TRUE;
}


BOOL CMonitorInf::ParseOneManufacturer(CManufacturer *pManufacturer)
{
    ///////////////////////////////////////////////////////////
    // [NEC]
    // %NEC-XE15%=NEC-XE15, Monitor\NEC3C00
    LPSECTION pSection = SeekSection(pManufacturer->name);
    if (pSection == NULL)
        return FALSE;

    for (UINT i = pSection->startLine + 1; i <= pSection->endLine; i++)
    {
        strcpy(m_lineBuf, lines[i]);
        if (TokenOneLine(m_lineBuf, '=', m_tokens) != 2)
        {
            ASSERT(FALSE);
            return FALSE;
        }
        UINT k = TokenOneLine(m_tokens[1], ',', &m_tokens[2]);
        if (k == 1)
            continue;
        else if (k != 2)
        {
            sprintf(gszMsg, "Manufacturer %s has a bad monitor line %s", 
                    &pManufacturer->name, lines[i]);
            MessageBox(NULL, gszMsg, gszInputFileName, MB_OK);
            ASSERT(FALSE);
            return FALSE;
        }

        ///////////////////////////////////////////////////////////
        // Ignore non-pnp monitors
        if (strnicmp(m_tokens[3], "Monitor\\", strlen("Monitor\\")))
            continue;
        if (strlen(m_tokens[3]) != strlen("Monitor\\NEC3C00"))
        {
            sprintf(gszMsg, "Manufacturer %s has a bad monitor line %s", 
                    &pManufacturer->name, lines[i]);
            MessageBox(NULL, gszMsg, gszInputFileName, MB_OK);
            ASSERT(FALSE);
            continue;
        }

        CMonitor *pMonitor = new(CMonitor);
        if (pMonitor == NULL)
        {
            ASSERT(FALSE);
            return FALSE;
        }
        strcpy(pMonitor->AliasName, m_tokens[0]);
        strcpy(pMonitor->InstallSectionName, m_tokens[2]);
        strcpy(pMonitor->ID, m_tokens[3]);

        for (k = 8; k < (UINT)lstrlen(pMonitor->ID); k++)
            pMonitor->ID[k] = toupper(pMonitor->ID[k]);

        if (!ParseOneMonitor(pMonitor))
        {
            ASSERT(FALSE);
            return FALSE;
        }

    	/////////////////////////////////////////////////
        // Insert the monitor into the array.
        // It's sorted by ID
    	int comp = 1;
        for (k = 0; k < (UINT)pManufacturer->MonitorArray.GetSize(); k++)
    	{
	    	CMonitor *pMon = (CMonitor *)pManufacturer->MonitorArray[k];
    		comp = compareMonitors(pMonitor, pMon);

    		if (comp > 0)
	    		continue;
		    else if (comp < 0)
                break;

    		////////////////////////////////////////////
            // Duplicated Monitor ?
            sprintf(gszMsg, "Manufacturer %s has duplicated monitor line %s", 
                    &pManufacturer->name, &pMonitor->ID[8]);
            MessageBox(NULL, gszMsg, gszInputFileName, MB_OK);
            ASSERT(FALSE);

            break;
    	}
    	if (comp == 0)
	    {
		    delete pMonitor;
    	}
    	else
    	{
		    pManufacturer->MonitorArray.InsertAt(k, (LPVOID)pMonitor);
	    }
    }
    return TRUE;
}

BOOL CMonitorInf::ParseOneMonitor(CMonitor *pMonitor)
{
    ///////////////////////////////////////////////////////////
    // [NEC-XE15]
    // DelReg=DCR
    // AddReg=NEC-XE15.Add, 1280, DPMS, ICM12
    //
    // [NEC-XE15.Add]
    // HKR,"MODES\1024,768",Mode1,,"31.0-65.0,55.0-120.0,+,+"
    LPSECTION pSection = SeekSection(pMonitor->InstallSectionName);
    if (pSection == NULL)
    {
        sprintf(gszMsg, "Monitor %s/%s misses InstallSection\n", 
                &pMonitor->ID[8], pMonitor->InstallSectionName);
        MessageBox(NULL, gszMsg, gszInputFileName, MB_OK);
        ASSERT(FALSE);
        return FALSE;
    }

    for (UINT i = pSection->startLine + 1; i <= pSection->endLine; i++)
    {
        TCHAR buf[256];
        strcpy(buf, lines[i]);
        if (TokenOneLine(buf, '=', m_tokens) != 2)
        {
            ASSERT(FALSE);
            return FALSE;
        }

        if (stricmp(m_tokens[0], "DelReg") == 0)
        {
            ASSERT(TokenOneLine(m_tokens[1], ',', &m_tokens[2]) == 1);
        }
        else if (stricmp(m_tokens[0], "AddReg") == 0)
        {
            int numAddReg = TokenOneLine(m_tokens[1], ',', &m_tokens[2]);
            strcpy(pMonitor->AddRegSectionName, m_tokens[2]);
            for (int j = 1; j < numAddReg; j++)
            {
                //////////////////////////////////////////////////////
                // Ignore ICM sectione
                if (strnicmp(m_tokens[j+2], "ICM", lstrlen("ICM")) == 0)
                    continue;
                LPSECTION pSection1 = SeekSection(m_tokens[j+2]);
                if (pSection1 == NULL)
                {
                    sprintf(gszMsg, "Monitor %s/%s misses common InstallSection %s\n", 
                            &pMonitor->ID[8], pMonitor->InstallSectionName, m_tokens[j+2]);
                    MessageBox(NULL, gszMsg, gszInputFileName, MB_OK);
                    ASSERT(FALSE);
                    return FALSE;
                }
                ASSERT(pSection1->endLine == (pSection1->startLine+1));
                pMonitor->CommonSects[pMonitor->numCommonSects] = 
                    gCommonSections.AddOneSection(m_tokens[j+2], lines[pSection1->endLine]);
                pMonitor->numCommonSects++;
            }
        }
    }

    pSection = SeekSection(pMonitor->AddRegSectionName);
    if (pSection == NULL)
    {
        sprintf(gszMsg, "Monitor %s/%s misses AddRegSection %s\n", 
                &pMonitor->ID[8], pMonitor->InstallSectionName, pMonitor->AddRegSectionName);
        MessageBox(NULL, gszMsg, gszInputFileName, MB_OK);
        ASSERT(FALSE);
        return FALSE;
    }

    int lenBuf = 0;
    for (i = pSection->startLine + 1; i <= pSection->endLine; i++)
    {
        lenBuf += strlen(lines[i])+3;
    }
    if (lenBuf == 0)
    {
        sprintf(gszMsg, "Monitor %s/%s has empty AddRegSection\n", 
                &pMonitor->ID[8], pMonitor->InstallSectionName);
        MessageBox(NULL, gszMsg, gszInputFileName, MB_OK);
        ASSERT(FALSE);
    }
    pMonitor->AddRegSectionBuf = (LPSTR)malloc(sizeof(TCHAR)*lenBuf);
    if (pMonitor->AddRegSectionBuf == NULL)
    {
        ASSERT(FALSE);
        return FALSE;
    }

    pMonitor->AddRegSectionBuf[0] = '\0';
    for (i = pSection->startLine + 1; i <= pSection->endLine; i++)
    {
        if ((strnicmp(lines[i], "HKR,\"MODES\\", lstrlen("HKR,\"MODES\\")) == 0) ||
            (stricmp(lines[i], "HKR,,DPMS,,0") == 0))
        {
            sprintf(pMonitor->AddRegSectionBuf + strlen(pMonitor->AddRegSectionBuf),
                    "%s\n", lines[i]);
        }
        else if (strnicmp(lines[i], "HKR,,ICMProfile,0,", lstrlen("HKR,,ICMProfile,1,")) == 0)
        {
        }
        //////////////////////////////////////////////////////////////
        // Anything other than modes, put them into common section
        else if (strnicmp(lines[i], "HKR,,ICMProfile,1,", lstrlen("HKR,,ICMProfile,1,")) == 0)
        {
            // Ignore ICMs
            /*
            TCHAR buf[16];
            LPSTR ptr = lines[i] + lstrlen("HKR,,ICMProfile,1,"), stopPtr;
            ASSERT(lstrlen(ptr) == 1 || lstrlen(ptr) == 2);
            *ptr = tolower(*ptr);
            long icmNum = strtoul(ptr, &stopPtr, 16);
            sprintf(buf, "ICM%d", icmNum);
            pMonitor->CommonSects[pMonitor->numCommonSects] = 
                gCommonSections.AddOneSection(buf, lines[i]);
            pMonitor->numCommonSects++;
            */
        }
        else if (stricmp(lines[i], "HKR,,DPMS,,1") == 0)
        {
            pMonitor->CommonSects[pMonitor->numCommonSects] = 
                gCommonSections.AddOneSection("DPMS", lines[i]);
            pMonitor->numCommonSects++;
        }
        else if (strnicmp(lines[i], "HKR,,MaxResolution,,\"", lstrlen("HKR,,MaxResolution,,\"")) == 0)
        {
            TCHAR buf[64];
            LPSTR ptr;
            strcpy(buf, lines[i] + lstrlen("HKR,,MaxResolution,,\""));
            ptr = strchr(buf, ',');
            ASSERT(ptr != NULL);
            *ptr = '\0';
            pMonitor->CommonSects[pMonitor->numCommonSects] = 
                gCommonSections.AddOneSection(buf, lines[i]);
            pMonitor->numCommonSects++;
        }
        /////////////////////////////////////////////////////////////////////////
        // Something common in specific Manufacturers
        else if ((strnicmp(lines[i], "HKR,,LF,0,1", lstrlen("HKR,,LF,0,1")) == 0) ||
                 (strnicmp(lines[i], "HKR,,VE,0,1", lstrlen("HKR,,LF,0,1")) == 0))
        {
        }
        else
        {
            sprintf(gszMsg, "Monitor %s/%s has unexpected AddReg Section %s", 
                    &pMonitor->ID[8], pMonitor->InstallSectionName, lines[i]);
            MessageBox(NULL, gszMsg, gszInputFileName, MB_OK);
            ASSERT(FALSE);
        }
    }

    return TRUE;
}

LPSECTION CMonitorInf::SeekSection(LPCSTR sectionName)
{
    for (UINT i = 0; i < numSections; i++)
    {
        if (stricmp(sections[i].name, sectionName) == 0)
            return &sections[i];
    }
    return NULL;
}

VOID CMonitorInf::Pack(VOID)
{
    for (int i = 0; i < ManufacturerArray.GetSize(); i++)
    {
        CManufacturer *pManufacturer = (CManufacturer*)ManufacturerArray[i];
        if (pManufacturer->MonitorArray.GetSize() == 0)
        {
            delete pManufacturer;
            ManufacturerArray.RemoveAt(i);
            i--;
        }
    }
}

LPCOMMON_ALIAS CMonitorInf::LookupCommonAlias(LPCSTR lpAliasName, LPCOMMON_ALIAS AliasHead, UINT numAlias)
{
    TCHAR name[64];
    lstrcpy(name, lpAliasName+1);

    ASSERT(lpAliasName[0] == '%');
    ASSERT(lpAliasName[lstrlen(name)] == '%');

    name[lstrlen(name)-1] = '\0';
    for (UINT i = 0; i < numAlias; i++)
    {
        if (stricmp(name, AliasHead[i].lpAlias) == 0)
            return &AliasHead[i];
    }
    return NULL;
}

BOOL CMonitorInf::FillupAlias(VOID)
{
    /////////////////////////////////////////////////////////////////////
    // First read in all strings
    LPSECTION pSection = SeekSection("Strings");
    if (pSection == NULL)
    {
        ASSERT(FALSE);
        return FALSE;
    }

    int numAlias = pSection->endLine - pSection->startLine;
    ASSERT(numAlias > 0);
    LPCOMMON_ALIAS pInfAlias = (LPCOMMON_ALIAS)malloc(numAlias * sizeof(COMMON_ALIAS));
    if (pInfAlias == NULL)
    {
        ASSERT(FALSE);
        return FALSE;
    }

    LPCOMMON_ALIAS pAlias = pInfAlias;
    for (UINT i = pSection->startLine + 1; i <= pSection->endLine; i++, pAlias++)
    {
        if (TokenOneLine(lines[i], '=', m_tokens) != 2)
        {
            sprintf(gszMsg, "A wrong string line %s.", lines[i]);
            MessageBox(NULL, gszMsg, gszInputFileName, MB_OK);
            ASSERT(FALSE);
            free(pInfAlias);
            return FALSE;
        }
        pAlias->lpAlias    = m_tokens[0];
        pAlias->lpContents = m_tokens[1];
        ASSERT(pAlias->lpContents[0] == '\"');
    }

    //////////////////////////////////////////////////////////
    // Go through Manufacturers and Monitors to fill up alias
    for (i = 0; i < (UINT)ManufacturerArray.GetSize(); i++)
    {
        CManufacturer *pManufacturer = (CManufacturer*)ManufacturerArray[i];
        pAlias = LookupCommonAlias(pManufacturer->AliasName, pInfAlias, numAlias);
        if (pAlias == NULL)
        {
            ASSERT(FALSE);
            free(pInfAlias);
            return FALSE;
        }
        pAlias = gCommonAlias.AddOneAlias(pAlias->lpAlias, pAlias->lpContents);
        if (pAlias == NULL)
        {
            ASSERT(FALSE);
            free(pInfAlias);
            return FALSE;
        }
        pManufacturer->pAlias = pAlias;

        for (int j = 0; j < pManufacturer->MonitorArray.GetSize(); j++)
        {
            CMonitor *pMonitor = (CMonitor*)pManufacturer->MonitorArray[j];
            pAlias = LookupCommonAlias(pMonitor->AliasName, pInfAlias, numAlias);
            if (pAlias == NULL)
            {
                ASSERT(FALSE);
                free(pInfAlias);
                return FALSE;
            }
            pAlias = gCommonAlias.AddOneAlias(pAlias->lpAlias, pAlias->lpContents);
            if (pAlias == NULL)
            {
                ASSERT(FALSE);
                free(pInfAlias);
                return FALSE;
            }
            pMonitor->pAlias = pAlias;
        }
    }

    free(pInfAlias);
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\test\moninf\moninfdlg.cpp ===
// moninfDlg.cpp : implementation file
//

#include "stdafx.h"
#include "moninf.h"
#include "moninfDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CMoninfDlg dialog

CMoninfDlg::CMoninfDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CMoninfDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CMoninfDlg)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
	// Note that LoadIcon does not require a subsequent DestroyIcon in Win32
	m_hIcon = AfxGetApp()->LoadIcon(IDR_MAINFRAME);
}

void CMoninfDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CMoninfDlg)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CMoninfDlg, CDialog)
	//{{AFX_MSG_MAP(CMoninfDlg)
	ON_WM_PAINT()
	ON_WM_QUERYDRAGICON()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CMoninfDlg message handlers

BOOL CMoninfDlg::OnInitDialog()
{
	CDialog::OnInitDialog();

	// Set the icon for this dialog.  The framework does this automatically
	//  when the application's main window is not a dialog
	SetIcon(m_hIcon, TRUE);			// Set big icon
	SetIcon(m_hIcon, FALSE);		// Set small icon
	
	// TODO: Add extra initialization here
	
	return TRUE;  // return TRUE  unless you set the focus to a control
}

// If you add a minimize button to your dialog, you will need the code below
//  to draw the icon.  For MFC applications using the document/view model,
//  this is automatically done for you by the framework.

void CMoninfDlg::OnPaint() 
{
	if (IsIconic())
	{
		CPaintDC dc(this); // device context for painting

		SendMessage(WM_ICONERASEBKGND, (WPARAM) dc.GetSafeHdc(), 0);

		// Center icon in client rectangle
		int cxIcon = GetSystemMetrics(SM_CXICON);
		int cyIcon = GetSystemMetrics(SM_CYICON);
		CRect rect;
		GetClientRect(&rect);
		int x = (rect.Width() - cxIcon + 1) / 2;
		int y = (rect.Height() - cyIcon + 1) / 2;

		// Draw the icon
		dc.DrawIcon(x, y, m_hIcon);
	}
	else
	{
		CDialog::OnPaint();
	}
}

// The system calls this to obtain the cursor to display while the user drags
//  the minimized window.
HCURSOR CMoninfDlg::OnQueryDragIcon()
{
	return (HCURSOR) m_hIcon;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\test\moninf\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	moninf.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\test\moninf\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__7B6427A5_8935_44EF_B39F_82AFC0FF0B3E__INCLUDED_)
#define AFX_STDAFX_H__7B6427A5_8935_44EF_B39F_82AFC0FF0B3E__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions
#include <afxdtctl.h>		// MFC support for Internet Explorer 4 Common Controls
#ifndef _AFX_NO_AFXCMN_SUPPORT
#include <afxcmn.h>			// MFC support for Windows Common Controls
#endif // _AFX_NO_AFXCMN_SUPPORT


//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__7B6427A5_8935_44EF_B39F_82AFC0FF0B3E__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\test\moninf\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by MONINF.RC
//
#define IDR_MAINFRAME					128
#define IDD_MONINF_DIALOG				102

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS

#define _APS_NEXT_RESOURCE_VALUE	129
#define _APS_NEXT_CONTROL_VALUE		1000
#define _APS_NEXT_SYMED_VALUE		101
#define _APS_NEXT_COMMAND_VALUE		32771
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\test\moninf\suminf.cpp ===
#include "stdafx.h"
#include "mon.h"

extern int compareManufacturers(CManufacturer *, CManufacturer *);
extern int compareMonitors(CMonitor *, CMonitor *);

CSumInf gSumInf;

CSumInf::CSumInf()
{
    m_fpReport = NULL;
}
CSumInf::~CSumInf()
{
    if (m_fpReport)
        fclose(m_fpReport);

    for (int i = 0; i < m_ManufacturerArray.GetSize(); i++)
    {
		delete((CManufacturer *)m_ManufacturerArray[i]);
    }
    
    m_ManufacturerArray.RemoveAll();
    m_SectionNameArray.RemoveAll();
}

VOID CSumInf::Initialize(LPCSTR reportFileName)
{
	m_fpReport = fopen(reportFileName, "w");
	if (m_fpReport == NULL)
	{
		ASSERT(FALSE);
	}
    m_ManufacturerArray.RemoveAll();
    m_SectionNameArray.RemoveAll();
}

VOID CSumInf::AddOneManufacturer(CManufacturer *pManufacturer)
{
    /////////////////////////////////////////////////
    // Insert the manufacturer into the array.
    // It's sorted by name
    int comp = 1;
    for (int i = 0; i < m_ManufacturerArray.GetSize(); i++)
    {
    	comp = compareManufacturers(pManufacturer, (CManufacturer *)m_ManufacturerArray[i]);

    	if (comp <= 0)
            break;
    }
    if (comp == 0)
	{
		MergeOneManufacturer((CManufacturer *)m_ManufacturerArray[i], pManufacturer);
        delete pManufacturer;
    }
    else
    {
		m_ManufacturerArray.InsertAt(i, (LPVOID)pManufacturer);
	}
}

VOID CSumInf::MergeOneManufacturer(CManufacturer *pDestManufacturer,
                                   CManufacturer *pSrcManufacturer)
{
    CPtrArray &SrcMonitorArray = pSrcManufacturer->MonitorArray,
              &DestMonitorArray = pDestManufacturer->MonitorArray;

    for (int i = 0; i < SrcMonitorArray.GetSize(); i++)
    {
        CMonitor *pMonitor = (CMonitor *)SrcMonitorArray[i];
        
        /////////////////////////////////////////////////
        // Insert the monitor into the array.
        // It's sorted by ID
    	int comp = 1;
        for (int k = 0; k < DestMonitorArray.GetSize(); k++)
    	{
    		comp = compareMonitors(pMonitor, (CMonitor *)DestMonitorArray[k]);

    		if (comp <= 0)
                break;
    	}
    	if (comp == 0)
	    {
            fprintf(m_fpReport, "Warning: %s is duplicated.  Please Check.\n", pMonitor->ID);
            delete pMonitor;
    	}
    	else
    	{
		    DestMonitorArray.InsertAt(k, (LPVOID)pMonitor);
	    }
    }
    SrcMonitorArray.RemoveAll();
}

VOID CSumInf::CheckDupSections(VOID)
{
    fprintf(m_fpReport, "\n");

    CPtrArray sectionNameArray;
    
    int comp = 1;
    for (int i = 0; i < m_ManufacturerArray.GetSize(); i++)
    {
	    CManufacturer *pMan = (CManufacturer *)m_ManufacturerArray[i];

        sectionNameArray.Add(pMan->name);

        /////////////////////////////////////////////////////////////
        // Search for duplicated Install section inside one manufacturer
        // Only this duplication is allowed.
        for (int j = 0; j < pMan->MonitorArray.GetSize(); j++)
        {
            CMonitor *pMon = (CMonitor*)pMan->MonitorArray[j];

            if (pMon->bDupInstSection)
                continue;
            
            for (int k = j+1; k < pMan->MonitorArray.GetSize(); k++)
            {
                CMonitor *pMon1 = (CMonitor*)pMan->MonitorArray[k];
                if (stricmp(pMon->InstallSectionName, pMon1->InstallSectionName) == 0)
                {
                    pMon1->bDupInstSection = TRUE;
                    fprintf(m_fpReport, "Information: \"%s\" AND \"%s\" have same install section [%s].  Please check.\n",
                            &pMon->ID[8], &pMon1->ID[8], pMon->InstallSectionName);
                }
            }

            sectionNameArray.Add(pMon->InstallSectionName);
            sectionNameArray.Add(pMon->AddRegSectionName);
        }
    }

    fprintf(m_fpReport, "\n");

    for (i = 0; i < sectionNameArray.GetSize(); i++)
    {
        LPCSTR pName = (LPCSTR)sectionNameArray[i]; 
        /////////////////////////////////////////////////
        // Insert the sectionName into m_SectionNameArray.
        // It's sorted by name
        int comp = 1;
        for (int j = 0; j < m_SectionNameArray.GetSize(); j++)
        {
    	    comp = stricmp(pName, (LPCSTR)m_SectionNameArray[j]);

            if (comp <= 0)
                break;
        }
        if (comp == 0)
        {
            fprintf(m_fpReport, "Error: Found duplicated section %s\n", pName);
        }
        else
        {
            m_SectionNameArray.InsertAt(j, (LPVOID)pName);
        }
    }
    fprintf(m_fpReport, "\n");
}

////////////////////////////////////////////////////////////////////
// Check if different manufacturers may contain same IDs
// So these manufacturers can be potentialy merged
VOID CSumInf::CheckDupMonIDs(VOID)
{
    for (int i = 0; i < m_ManufacturerArray.GetSize(); i++)
    {
	    CManufacturer *pMan = (CManufacturer *)m_ManufacturerArray[i];
        pMan->m_MonitorIDArray.RemoveAll();

        ASSERT(pMan->MonitorArray.GetSize() > 0);
        
        LPCTSTR pID = ((CMonitor*)pMan->MonitorArray[0])->ID;
        pMan->m_MonitorIDArray.Add((LPVOID)pID);
        
        for (int j = 1; j < pMan->MonitorArray.GetSize(); j++)
        {
            CMonitor *pMon = (CMonitor*)pMan->MonitorArray[j];

            if (strnicmp(pID, pMon->ID, lstrlen("Monitor\\NEC")) != 0)
            {
                pID = pMon->ID;
                pMan->m_MonitorIDArray.Add((LPVOID)pID);
            }
        }
    }

    for (i = 0; i < m_ManufacturerArray.GetSize(); i++)
    {
	    CManufacturer *pMan = (CManufacturer *)m_ManufacturerArray[i];

        for (int j = 0; j < pMan->m_MonitorIDArray.GetSize(); j++)
        {
            LPCTSTR pID = (LPCTSTR)pMan->m_MonitorIDArray[j];

            for (int i1 = i+1; i1 < m_ManufacturerArray.GetSize(); i1++)
            {
        	    CManufacturer *pMan1 = (CManufacturer *)m_ManufacturerArray[i1];
                for (int j1 = 0; j1 < pMan1->m_MonitorIDArray.GetSize(); j1++)
                {
                    LPCTSTR pID1 = (LPCTSTR)pMan1->m_MonitorIDArray[j1];
                    if (strnicmp(pID, pID1, lstrlen("Monitor\\NEC")) == 0)
                    {
                        fprintf(m_fpReport, "Warning: \"%s\" AND \"%s\" have same monitor ID %c%c%c.  Consider merging.\n",
                                pMan->name, pMan1->name, pID[8], pID[9], pID[10]);
                    }
                }
            }
        }
    }

    fprintf(m_fpReport, "\n");
}


VOID CSumInf::CheckDupAlias(VOID)
{
    LPCOMMON_ALIAS pAlias;
    
    for (int i = 0; i < gCommonAlias.GetSize(); i++)
    {
        pAlias = gCommonAlias.GetAt(i);
        pAlias->refCount = 0;
    }
    
    ///////////////////////////////////////////
    // Calculate RefCount
    for (i = 0; i < m_ManufacturerArray.GetSize(); i++)
    {
        CManufacturer *pManufacturer = (CManufacturer*)m_ManufacturerArray[i];
        pAlias = pManufacturer->pAlias;
        ASSERT(pAlias != NULL);
        pAlias->refCount++;
        for (int j = 0; j < pManufacturer->MonitorArray.GetSize(); j++)
        {
            CMonitor *pMonitor = (CMonitor*)pManufacturer->MonitorArray[j];
            pAlias = pMonitor->pAlias;
            ASSERT(pAlias != NULL);
            pAlias->refCount++;
        }
    }

    for (i = 0; i < gCommonAlias.GetSize(); i++)
    {
        pAlias = gCommonAlias.GetAt(i);

        if (pAlias->refCount != 1)
        {
            fprintf(m_fpReport, "Information: String %%%s%% has RefCount %d\n",
                    pAlias->lpAlias, pAlias->refCount);
        }
    }
    fprintf(m_fpReport, "\n");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\test\vchk\allowed.cpp ===
#include "stdafx.h"
#pragma hdrstop

#include "allowed.h"

using namespace std;

ModulesAndImports::~ModulesAndImports ()
{
}

BOOL
ModulesAndImports::IsModule (LPCSTR name)
{
    CString str;
    m_curr_module = name;
    return m_imports.Lookup (name, str);

}

BOOL
ModulesAndImports::Lookup (LPCSTR name, CString& msg)
{
    msg = "";
    return m_imports.Lookup (m_curr_module+CString("!")+CString(name), msg);
}

int __cdecl CompareCString(const void* a, const void* b) 
{
    CString* A = *(CString**)a;
    CString* B = *(CString**)b;
    return strcmp((LPCSTR)*A, (LPCSTR)*B);
}

void
ModulesAndImports::Dump(std::ostream& out)
{
    size_t imp_num = m_imports.GetCount();
    if (imp_num) {
        size_t i = 0;
        CString** Index = new CString*[imp_num];
        POSITION pos = m_imports.GetStartPosition(); 
        while ((pos != NULL) && (i < imp_num)) {
            CString Imp, Msg;
            m_imports.GetNextAssoc(pos, Imp, Msg);
            if (Msg.GetLength()) {
                Imp += " - ";
                Imp += Msg;
            }
            Index[i++] = new CString(Imp);
        }
        imp_num = i;
        qsort(Index, imp_num, sizeof(*Index), CompareCString);
        for (i = 0; i < imp_num; ++i) {
            cout << (LPCSTR)*Index[i] << endl;
            delete Index[i];
        }
        delete[] Index;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\test\vchk\ilimpchk.h ===
#ifndef __ILLEGAL_IMPORTS_CHECK_H__
#define __ILLEGAL_IMPORTS_CHECK_H__

#ifdef __cplusplus
extern "C" {
#endif

typedef struct {
    LPSTR   Ptr;
    int     Num;
} Names;

BOOL    InitIllegalImportsSearch (LPCSTR FileName, LPCSTR SectionNames /*, LPCSTR AllowedImportDLLs*/);
Names   CheckSectionsForImports (void);
Names   GetImportsList (LPCSTR ModuleName);
void    FinalizeIllegalImportsSearch (void);
LPSTR   GetNextName(LPSTR NamePtr);

#ifdef __cplusplus
}
#endif

#endif  // __ILLEGAL_IMPORTS_CHECK_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\test\vchk\allowed.h ===
#pragma once

class ModulesAndImports {
public:
    ModulesAndImports();
    virtual ~ModulesAndImports();
    void SetModule (LPCSTR name);
    void AddImport (LPCSTR name, LPCSTR msg = "");
    BOOL IsModule (LPCSTR name);
    BOOL Lookup (LPCSTR name, CString& msg);
    BOOL Lookup (LPCSTR name);
    void Dump(std::ostream& out);
private:
    CString        m_curr_module;
    CMapStringToString  m_imports;
};

inline
ModulesAndImports::ModulesAndImports () :
    m_curr_module ("")
{
}

inline
void
ModulesAndImports::SetModule (LPCSTR name)
{
    m_curr_module = name;
    m_imports.SetAt (m_curr_module, "");
}

inline
void
ModulesAndImports::AddImport (LPCSTR name, LPCSTR msg)
{
    m_imports.SetAt (m_curr_module+CString("!")+CString(name), msg);
}

inline
BOOL
ModulesAndImports::Lookup (LPCSTR name)
{
    CString msg;
    return Lookup (name, msg);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\test\vchk\ilimpchk.cpp ===
#include "stdafx.h"
#pragma hdrstop

#include <io.h>
#include "vchk.h"
#include "ilimpchk.h"
#include "pefile.h"

#define NAMES_LIST_BUFSIZE  (1024)
#define TMP_BUFFERS (1024)

char    ImportSectionNames [NAMES_LIST_BUFSIZE];

Names Modules = { NULL, 0 };

LPSTR  FoundSectionName = NULL;

LPVOID FileData = NULL;

BOOL
InitIllegalImportsSearch (LPCSTR FileName, LPCSTR SectionNames)
{
    int ofs = 0;
    int fno = 0;
    size_t flen = 0;
    FILE* fp = fopen (FileName,"rb");
    if (!fp)
        return FALSE;
    fno = _fileno( fp );
    flen = (size_t)_filelength (fno);
    if (flen<=0)
        return FALSE;
    if (FileData)
        free (FileData);
    FileData = malloc (flen);
    if (!FileData)
        return FALSE;
    if (fread (FileData, 1, flen, fp) != flen)
        return FALSE;
    fclose (fp);
    
    ofs = 0;
    if (SectionNames) {
        LPCSTR SecName;
        for (SecName = SectionNames; *SecName; SecName++, ofs++) {
            strcpy (ImportSectionNames+ofs, SecName);
            ofs += strlen (SecName);
            SecName += strlen (SecName);
        }
        *(ImportSectionNames+ofs) = 0;
    }
    else {
        ImportSectionNames[0] = 0;
        ImportSectionNames[1] = 0;
    }

    ofs=0;

    Modules.Ptr = NULL;
    Modules.Num = 0;
    return TRUE;
}

LPSTR GetNextName(LPSTR NamePtr)
{
    if (!NamePtr || !*NamePtr)
        return NULL;
    NamePtr += (strlen (NamePtr) + 1);
    if (*NamePtr)
        return NamePtr;
    return NULL;
}

void
FreeName (Names name)
{
    HeapFree (GetProcessHeap(), 0, name.Ptr);
}

Names
CheckSectionsForImports (void)
/*
    Returns buffer with the names of import sections.
    This memory is been freed during FinalizeIllegalImportsSearch,
    one need not free it manually.
*/
{
    char* SectionName;

    Modules.Num = GetImportModuleNames (FileData, ".idata", &Modules.Ptr);
    if (Modules.Num <= 0) {
        for (SectionName = ImportSectionNames; *SectionName; SectionName++) {

            Modules.Num = GetImportModuleNames (FileData, SectionName, &Modules.Ptr);

            if (Modules.Num > 0) {
                FoundSectionName = SectionName;
                break;
            }
            SectionName += strlen (SectionName);
        }
    }
    return Modules;
}

Names GetImportsList (LPCSTR ModuleName)
/*
    Returns buffer with the names of import functions for ModuleName.
    This memory is been freed during FinalizeIllegalImportsSearch,
    one need not free it manually.
*/
{
    Names Imports = {NULL, 0};
    Imports.Num = GetImportFunctionNamesByModule (FileData,
                                                  FoundSectionName,
                                                  (char*)ModuleName,
                                                  &Imports.Ptr);
    return Imports;
}

void
FinalizeIllegalImportsSearch (void)
/*
    Frees temporarily allocated memory.
*/
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\test\vchk\cmpkey.cpp ===
#include <nt.h>
#include <windef.h>
#include <malloc.h>

PKEY_NAME_INFORMATION GetRegKeyInfo(HKEY hKey)
{
    ULONG nRequiredSize = sizeof(KEY_NAME_INFORMATION) + MAX_PATH;
    
    PKEY_NAME_INFORMATION pKeyInfo = 
        (PKEY_NAME_INFORMATION)malloc(nRequiredSize);
        
    if (!pKeyInfo) return NULL;
    
    NTSTATUS Status = NtQueryKey(hKey, 
                                 KeyNameInformation, 
                                 pKeyInfo, 
                                 nRequiredSize, 
                                 &nRequiredSize);
    
    if (Status == STATUS_BUFFER_OVERFLOW) {
    
        PKEY_NAME_INFORMATION pNewKeyInfo = 
            (PKEY_NAME_INFORMATION)realloc(pKeyInfo, nRequiredSize);
        
        if (pNewKeyInfo) {
            pKeyInfo = pNewKeyInfo;
            Status = NtQueryKey(hKey, 
                                KeyNameInformation, 
                                pKeyInfo, 
                                nRequiredSize, 
                                &nRequiredSize);
        }
    }
    
    if (!NT_SUCCESS(Status)) {
        free(pKeyInfo);
        pKeyInfo = NULL;
    }
    
    return pKeyInfo;
}

bool IsTheSameRegKey(HKEY hKey1, HKEY hKey2) 
{
    PKEY_NAME_INFORMATION pKeyInfo1 = GetRegKeyInfo(hKey1);
    PKEY_NAME_INFORMATION pKeyInfo2 = GetRegKeyInfo(hKey2);
    
    bool bTheSame = pKeyInfo1 && pKeyInfo2 &&
                    (pKeyInfo1->NameLength == pKeyInfo2->NameLength) &&
                    !_wcsnicmp(pKeyInfo1->Name, 
                               pKeyInfo2->Name, 
                               pKeyInfo1->NameLength);
    free(pKeyInfo1);
    free(pKeyInfo2);
    
    return bTheSame;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\test\vchk\pefile.h ===
#include <windows.h>

#define IDS_ERRBADFILENAME  1000
#define IDR_CURSOR      1
#define IDR_BITMAP      2
#define IDR_ICON        3
#define IDR_MENU        4
#define IDR_DIALOG      5
#define IDR_STRING      6
#define IDR_FONTDIR     7
#define IDR_FONT        8
#define IDR_ACCELERATOR     9
#define IDR_RCDATA      10
#define IDR_MESSAGETABLE    11

#define SIZE_OF_NT_SIGNATURE    sizeof (DWORD)
#define MAXRESOURCENAME     13

/* global macros to define header offsets into file */
/* offset to PE file signature                     */
#define NTSIGNATURE(a) ((LPVOID)((BYTE *)a           +  \
            ((PIMAGE_DOS_HEADER)a)->e_lfanew))

/* DOS header identifies the NT PEFile signature dword
   the PEFILE header exists just after that dword          */
#define PEFHDROFFSET(a) ((LPVOID)((BYTE *)a          +  \
             ((PIMAGE_DOS_HEADER)a)->e_lfanew    +  \
             SIZE_OF_NT_SIGNATURE))

/* PE optional header is immediately after PEFile header       */
#define OPTHDROFFSET(a) ((LPVOID)((BYTE *)a          +  \
             ((PIMAGE_DOS_HEADER)a)->e_lfanew    +  \
             SIZE_OF_NT_SIGNATURE            +  \
             sizeof (IMAGE_FILE_HEADER)))

/* section headers are immediately after PE optional header    */
#define SECHDROFFSET(a) ((LPVOID)((BYTE *)a          +  \
             ((PIMAGE_DOS_HEADER)a)->e_lfanew    +  \
             SIZE_OF_NT_SIGNATURE            +  \
             sizeof (IMAGE_FILE_HEADER)      +  \
             sizeof (IMAGE_OPTIONAL_HEADER)))

#ifdef __cplusplus

extern "C" {

#endif


typedef struct tagImportDirectory
    {
    DWORD    dwRVAFunctionNameList;
    DWORD    dwUseless1;
    DWORD    dwUseless2;
    DWORD    dwRVAModuleName;
    DWORD    dwRVAFunctionAddressList;
    }IMAGE_IMPORT_MODULE_DIRECTORY, * PIMAGE_IMPORT_MODULE_DIRECTORY;


/* global prototypes for functions in pefile.c */
/* PE file header info */
BOOL    WINAPI GetDosHeader (LPVOID, PIMAGE_DOS_HEADER);
DWORD   WINAPI ImageFileType (LPVOID);
BOOL    WINAPI GetPEFileHeader (LPVOID, PIMAGE_FILE_HEADER);

/* PE optional header info */
BOOL    WINAPI GetPEOptionalHeader (LPVOID, PIMAGE_OPTIONAL_HEADER);
LONG_PTR    WINAPI GetModuleEntryPoint (LPVOID);
int WINAPI NumOfSections (LPVOID);
LPVOID  WINAPI GetImageBase (LPVOID);
LPVOID  WINAPI ImageDirectoryOffset (LPVOID, DWORD);

/* PE section header info */
int WINAPI GetSectionNames (LPVOID, HANDLE, char **);
BOOL    WINAPI GetSectionHdrByName (LPVOID, PIMAGE_SECTION_HEADER, char *);

/* import section info */
int WINAPI GetImportModuleNames (LPVOID, char*, char  **);
int WINAPI GetImportFunctionNamesByModule (LPVOID, char*, char *, char  **);

/* export section info */
int WINAPI GetExportFunctionNames (LPVOID, HANDLE, char **);
int WINAPI GetNumberOfExportedFunctions (LPVOID);
LPVOID  WINAPI GetExportFunctionEntryPoints (LPVOID);
LPVOID  WINAPI GetExportFunctionOrdinals (LPVOID);

/* resource section info */
int WINAPI GetNumberOfResources (LPVOID);
int WINAPI GetListOfResourceTypes (LPVOID, HANDLE, char **);

/* debug section info */
BOOL    WINAPI IsDebugInfoStripped (LPVOID);
int WINAPI RetrieveModuleName (LPVOID, HANDLE, char **);
BOOL    WINAPI IsDebugFile (LPVOID);
BOOL    WINAPI GetSeparateDebugHeader (LPVOID, PIMAGE_SEPARATE_DEBUG_HEADER);

#ifdef __cplusplus

}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\test\vchk\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__8F396420_7660_4704_9B99_07785DF4F2B4__INCLUDED_)
#define AFX_STDAFX_H__8F396420_7660_4704_9B99_07785DF4F2B4__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define VC_EXTRALEAN        // Exclude rarely-used stuff from Windows headers

#include <afx.h>
#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions
#include <afxdtctl.h>       // MFC support for Internet Explorer 4 Common Controls
#ifndef _AFX_NO_AFXCMN_SUPPORT
#include <afxcmn.h>         // MFC support for Windows Common Controls
#endif // _AFX_NO_AFXCMN_SUPPORT

#include <iostream>

// TODO: reference additional headers your program requires here

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__8F396420_7660_4704_9B99_07785DF4F2B4__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\test\vchk\pefile.c ===
#include "pefile.h"

// #include <stdio.h>

HANDLE    hDll;

/*
BOOL  WINAPI DLLEntry (
    HANDLE    hModule,
    DWORD     dwFunction,
    LPVOID    lpNot)
{
    hDll = hModule;

    return TRUE;
}
*/



/* copy dos header information to structure */
BOOL  WINAPI GetDosHeader (
    LPVOID       lpFile,
    PIMAGE_DOS_HEADER    pHeader)
{
    /* dos header rpresents first structure of bytes in file */
    if (*(USHORT *)lpFile == IMAGE_DOS_SIGNATURE)
    CopyMemory ((LPVOID)pHeader, lpFile, sizeof (IMAGE_DOS_HEADER));
    else
    return FALSE;

    return TRUE;
}




/* return file signature */
DWORD  WINAPI ImageFileType (
    LPVOID    lpFile)
{
    /* dos file signature comes first */
    if (*(USHORT *)lpFile == IMAGE_DOS_SIGNATURE)
    {
    /* determine location of PE File header from dos header */
    if (LOWORD (*(DWORD *)NTSIGNATURE (lpFile)) == IMAGE_OS2_SIGNATURE ||
        LOWORD (*(DWORD *)NTSIGNATURE (lpFile)) == IMAGE_OS2_SIGNATURE_LE)
        return (DWORD)LOWORD(*(DWORD *)NTSIGNATURE (lpFile));

    else if (*(DWORD *)NTSIGNATURE (lpFile) == IMAGE_NT_SIGNATURE)
        return IMAGE_NT_SIGNATURE;

    else
        return IMAGE_DOS_SIGNATURE;
    }

    else
    /* unknown file type */
    return 0;
}




/* copy file header information to structure */
BOOL  WINAPI GetPEFileHeader (
    LPVOID        lpFile,
    PIMAGE_FILE_HEADER    pHeader)
{
    /* file header follows dos header */
    if (ImageFileType (lpFile) == IMAGE_NT_SIGNATURE)
    CopyMemory ((LPVOID)pHeader, PEFHDROFFSET (lpFile), sizeof (IMAGE_FILE_HEADER));

    else
    return FALSE;

    return TRUE;
}





/* copy optional header info to structure */
BOOL WINAPI GetPEOptionalHeader (
    LPVOID            lpFile,
    PIMAGE_OPTIONAL_HEADER    pHeader)
{
    /* optional header follows file header and dos header */
    if (ImageFileType (lpFile) == IMAGE_NT_SIGNATURE)
    CopyMemory ((LPVOID)pHeader, OPTHDROFFSET (lpFile), sizeof (IMAGE_OPTIONAL_HEADER));

    else
    return FALSE;

    return TRUE;
}




/* function returns the entry point for an exe module lpFile must
   be a memory mapped file pointer to the beginning of the image file */
LONG_PTR    WINAPI GetModuleEntryPoint (
    LPVOID    lpFile)
{
    PIMAGE_OPTIONAL_HEADER   poh = (PIMAGE_OPTIONAL_HEADER)OPTHDROFFSET (lpFile);

    if (poh != NULL)
    return (LONG_PTR)(poh->AddressOfEntryPoint);
    else
    return 0L;
}




/* return the total number of sections in the module */
int   WINAPI NumOfSections (
    LPVOID    lpFile)
{
    /* number os sections is indicated in file header */
    return ((int)((PIMAGE_FILE_HEADER)PEFHDROFFSET (lpFile))->NumberOfSections);
}




/* retrieve entry point */
LPVOID  WINAPI GetImageBase (
    LPVOID    lpFile)
{
    PIMAGE_OPTIONAL_HEADER   poh = (PIMAGE_OPTIONAL_HEADER)OPTHDROFFSET (lpFile);

    if (poh != NULL)
    return (LPVOID)(poh->ImageBase);
    else
    return NULL;
}




/* return offset to specified IMAGE_DIRECTORY entry */
LPVOID  WINAPI ImageDirectoryOffset (
    LPVOID    lpFile,
    DWORD     dwIMAGE_DIRECTORY)
{
    PIMAGE_OPTIONAL_HEADER   poh = (PIMAGE_OPTIONAL_HEADER)OPTHDROFFSET (lpFile);
    PIMAGE_SECTION_HEADER    psh = (PIMAGE_SECTION_HEADER)SECHDROFFSET (lpFile);
    int              nSections = NumOfSections (lpFile);
    int              i = 0;
    LONG_PTR         VAImageDir;

    /* must be 0 thru (NumberOfRvaAndSizes-1) */
    if (dwIMAGE_DIRECTORY >= poh->NumberOfRvaAndSizes)
    return NULL;

    /* locate specific image directory's relative virtual address */
    VAImageDir = (LONG_PTR)poh->DataDirectory[dwIMAGE_DIRECTORY].VirtualAddress;

    /* locate section containing image directory */
    while (i++<nSections)
    {
    if (psh->VirtualAddress <= (DWORD)VAImageDir &&
        psh->VirtualAddress + psh->SizeOfRawData > (DWORD)VAImageDir)
        break;
    psh++;
    }

    if (i > nSections)
    return NULL;

    /* return image import directory offset */
    return (LPVOID)(((LONG_PTR)lpFile + (LONG_PTR)VAImageDir - psh->VirtualAddress) +
                   (LONG_PTR)psh->PointerToRawData);
}




/* function retrieve names of all the sections in the file */
int WINAPI GetSectionNames (
    LPVOID    lpFile,
    HANDLE    hHeap,
    char      **pszSections)
{
    int              nSections = NumOfSections (lpFile);
    int              i, nCnt = 0;
    PIMAGE_SECTION_HEADER    psh;
    char             *ps;


    if (ImageFileType (lpFile) != IMAGE_NT_SIGNATURE ||
    (psh = (PIMAGE_SECTION_HEADER)SECHDROFFSET (lpFile)) == NULL)
    return 0;

    /* count the number of chars used in the section names */
    for (i=0; i<nSections; i++)
    nCnt += strlen (psh[i].Name) + 1;

    /* allocate space for all section names from heap */
    ps = *pszSections = (char *)HeapAlloc (hHeap, HEAP_ZERO_MEMORY, nCnt);


    for (i=0; i<nSections; i++)
    {
    strcpy (ps, psh[i].Name);
    ps += strlen (psh[i].Name) + 1;
    }

    return nCnt;
}




/* function gets the function header for a section identified by name */
BOOL    WINAPI GetSectionHdrByName (
    LPVOID           lpFile,
    IMAGE_SECTION_HEADER     *sh,
    char             *szSection)
{
    PIMAGE_SECTION_HEADER    psh;
    int              nSections = NumOfSections (lpFile);
    int              i;


    if ((psh = (PIMAGE_SECTION_HEADER)SECHDROFFSET (lpFile)) != NULL)
    {
    /* find the section by name */
    for (i=0; i<nSections; i++)
        {
        if (!strcmp (psh->Name, szSection))
        {
        /* copy data to header */
        CopyMemory ((LPVOID)sh, (LPVOID)psh, sizeof (IMAGE_SECTION_HEADER));
        return TRUE;
        }
        else
        psh++;
        }
    }

    return FALSE;
}




/* get import modules names separated by null terminators, return module count */
int  WINAPI GetImportModuleNames (
    LPVOID    lpFile,
    // HANDLE    hHeap,
    char*     SectionName,
    char      **pszModules)
{
    PIMAGE_IMPORT_MODULE_DIRECTORY  pid = (PIMAGE_IMPORT_MODULE_DIRECTORY)
    ImageDirectoryOffset (lpFile, IMAGE_DIRECTORY_ENTRY_IMPORT);
    IMAGE_SECTION_HEADER     idsh;
    BYTE             *pData = (BYTE *)pid;
    int              nCnt = 0, nSize = 0, i;
    char             *pModule[1024];  /* hardcoded maximum number of modules?? */
    char             *psz;

    /* locate section header for ".idata" section */
    if (!GetSectionHdrByName (lpFile, &idsh, SectionName /*".idata" "INIT"*/))
    return 0;

    /* extract all import modules */
    while (pid->dwRVAModuleName)
    {
    /* allocate temporary buffer for absolute string offsets */
    pModule[nCnt] = (char *)(pData + (pid->dwRVAModuleName-idsh.VirtualAddress));
    nSize += strlen (pModule[nCnt]) + 1;

    /* increment to the next import directory entry */
    pid++;
    nCnt++;
    }

    /* copy all strings to one chunk of heap memory */
    *pszModules = HeapAlloc (GetProcessHeap(), HEAP_ZERO_MEMORY, nSize);
    psz = *pszModules;
    for (i=0; i<nCnt; i++)
    {
    strcpy (psz, pModule[i]);
    psz += strlen (psz) + 1;
    }

    return nCnt;
}




/* get import module function names separated by null terminators, return function count */
int  WINAPI GetImportFunctionNamesByModule (
    LPVOID    lpFile,
    // HANDLE    hHeap,
    char*     SectionName,
    char      *pszModule,
    char      **pszFunctions)
{
    PIMAGE_IMPORT_MODULE_DIRECTORY  pid = (PIMAGE_IMPORT_MODULE_DIRECTORY)
    ImageDirectoryOffset (lpFile, IMAGE_DIRECTORY_ENTRY_IMPORT);

    IMAGE_SECTION_HEADER     idsh;
    LONG_PTR         dwBase;
    int              nCnt = 0, nSize = 0;
    DWORD            dwFunction;
    char             *psz;

    /* locate section header for ".idata" section */
    if (!GetSectionHdrByName (lpFile, &idsh, SectionName/*".idata" "INIT"*/))
    return 0;

    dwBase = ((LONG_PTR)pid - idsh.VirtualAddress);

    /* find module's pid */
    while (pid->dwRVAModuleName &&
       strcmp (pszModule, (char *)(pid->dwRVAModuleName+dwBase)))
    pid++;

    /* exit if the module is not found */
    if (!pid->dwRVAModuleName)
    return 0;

    /* count number of function names and length of strings */
    dwFunction = pid->dwRVAFunctionNameList;
    while (dwFunction              &&
       *(DWORD *)(dwFunction + dwBase) &&
       (!IsBadReadPtr ( (char *)((*(DWORD *)(dwFunction + dwBase)) + dwBase+2), 1 ) ) &&
       *(char *)((*(DWORD *)(dwFunction + dwBase)) + dwBase+2))
    /*
    while (dwFunction              &&
       *(DWORD *)(dwFunction + dwBase) &&
       *(char *)((*(DWORD *)(dwFunction + dwBase)) + dwBase+2))
    */
    {
    nSize += strlen ((char *)((*(DWORD *)(dwFunction + dwBase)) + dwBase+2)) + 1;
    dwFunction += 4;
    nCnt++;
    }

    /* allocate memory off heap for function names */
    *pszFunctions = HeapAlloc (GetProcessHeap(), HEAP_ZERO_MEMORY, nSize);
    psz = *pszFunctions;

    /* copy function names to mempry pointer */
    dwFunction = pid->dwRVAFunctionNameList;
    while (dwFunction              &&
       *(DWORD *)(dwFunction + dwBase) &&
       (!IsBadReadPtr ( (char *)((*(DWORD *)(dwFunction + dwBase)) + dwBase+2), 1 ) ) &&
       *(char *)((*(DWORD *)(dwFunction + dwBase)) + dwBase+2))
    /*
    while (dwFunction              &&
       *(DWORD *)(dwFunction + dwBase) &&
       *((char *)((*(DWORD *)(dwFunction + dwBase)) + dwBase+2)))
    */
    {
    strcpy (psz, (char *)((*(DWORD *)(dwFunction + dwBase)) + dwBase+2));
    psz += strlen ((char *)((*(DWORD *)(dwFunction + dwBase)) + dwBase+2)) + 1;
    dwFunction += 4;
    }

    // fprintf (stderr, "nCnt = %d\n", nCnt);
    return nCnt;
}




/* get exported function names separated by null terminators, return count of functions */
int  WINAPI GetExportFunctionNames (
    LPVOID    lpFile,
    HANDLE    hHeap,
    char      **pszFunctions)
{
    IMAGE_SECTION_HEADER       sh;
    PIMAGE_EXPORT_DIRECTORY    ped;
    char               *pNames, *pCnt;
    int                i, nCnt;

    /* get section header and pointer to data directory for .edata section */
    if ((ped = (PIMAGE_EXPORT_DIRECTORY)ImageDirectoryOffset
            (lpFile, IMAGE_DIRECTORY_ENTRY_EXPORT)) == NULL)
    return 0;
    GetSectionHdrByName (lpFile, &sh, ".edata");

    /* determine the offset of the export function names */
    pNames = (char *)(*(int *)((int)ped->AddressOfNames -
                   (int)sh.VirtualAddress   +
                   (int)sh.PointerToRawData +
                   (LONG_PTR)lpFile)    -
              (int)sh.VirtualAddress   +
              (int)sh.PointerToRawData +
              (LONG_PTR)lpFile);

    /* figure out how much memory to allocate for all strings */
    pCnt = pNames;
    for (i=0; i<(int)ped->NumberOfNames; i++)
    while (*pCnt++);
    nCnt = (int)(pCnt - pNames);

    /* allocate memory off heap for function names */
    *pszFunctions = HeapAlloc (hHeap, HEAP_ZERO_MEMORY, nCnt);

    /* copy all string to buffer */
    CopyMemory ((LPVOID)*pszFunctions, (LPVOID)pNames, nCnt);

    return nCnt;
}




/* return the number of exported functions in the module */
int WINAPI GetNumberOfExportedFunctions (
    LPVOID    lpFile)
{
    PIMAGE_EXPORT_DIRECTORY    ped;

    /* get section header and pointer to data directory for .edata section */
    if ((ped = (PIMAGE_EXPORT_DIRECTORY)ImageDirectoryOffset
            (lpFile, IMAGE_DIRECTORY_ENTRY_EXPORT)) == NULL)
    return 0;
    else
    return (int)ped->NumberOfNames;
}




/* return a pointer to the list of function entry points */
LPVOID   WINAPI GetExportFunctionEntryPoints (
    LPVOID    lpFile)
{
    IMAGE_SECTION_HEADER       sh;
    PIMAGE_EXPORT_DIRECTORY    ped;

    /* get section header and pointer to data directory for .edata section */
    if ((ped = (PIMAGE_EXPORT_DIRECTORY)ImageDirectoryOffset
            (lpFile, IMAGE_DIRECTORY_ENTRY_EXPORT)) == NULL)
    return NULL;
    GetSectionHdrByName (lpFile, &sh, ".edata");

    /* determine the offset of the export function entry points */
    return (LPVOID) ((int)ped->AddressOfFunctions -
             (int)sh.VirtualAddress   +
             (int)sh.PointerToRawData +
             (LONG_PTR)lpFile);
}




/* return a pointer to the list of function ordinals */
LPVOID   WINAPI GetExportFunctionOrdinals (
    LPVOID    lpFile)
{
    IMAGE_SECTION_HEADER       sh;
    PIMAGE_EXPORT_DIRECTORY    ped;

    /* get section header and pointer to data directory for .edata section */
    if ((ped = (PIMAGE_EXPORT_DIRECTORY)ImageDirectoryOffset
            (lpFile, IMAGE_DIRECTORY_ENTRY_EXPORT)) == NULL)
    return NULL;
    GetSectionHdrByName (lpFile, &sh, ".edata");

    /* determine the offset of the export function entry points */
    return (LPVOID) ((int)ped->AddressOfNameOrdinals -
             (int)sh.VirtualAddress   +
             (int)sh.PointerToRawData +
             (LONG_PTR)lpFile);
}




/* determine the total number of resources in the section */
int WINAPI GetNumberOfResources (
    LPVOID    lpFile)
{
    PIMAGE_RESOURCE_DIRECTORY          prdRoot, prdType;
    PIMAGE_RESOURCE_DIRECTORY_ENTRY    prde;
    int                    nCnt=0, i;


    /* get root directory of resource tree */
    if ((prdRoot = (PIMAGE_RESOURCE_DIRECTORY)ImageDirectoryOffset
            (lpFile, IMAGE_DIRECTORY_ENTRY_RESOURCE)) == NULL)
    return 0;

    /* set pointer to first resource type entry */
    prde = (PIMAGE_RESOURCE_DIRECTORY_ENTRY)((LONG_PTR)prdRoot + sizeof (IMAGE_RESOURCE_DIRECTORY));

    /* loop through all resource directory entry types */
    for (i=0; i<prdRoot->NumberOfIdEntries; i++)
    {
    /* locate directory or each resource type */
    prdType = (PIMAGE_RESOURCE_DIRECTORY)((LONG_PTR)prdRoot + (LONG_PTR)prde->OffsetToData);

    /* mask off most significant bit of the data offset */
    prdType = (PIMAGE_RESOURCE_DIRECTORY)((LONG_PTR)prdType ^ 0x80000000);

    /* increment count of name'd and ID'd resources in directory */
    nCnt += prdType->NumberOfNamedEntries + prdType->NumberOfIdEntries;

    /* increment to next entry */
    prde++;
    }

    return nCnt;
}




/* name each type of resource in the section */
int WINAPI GetListOfResourceTypes (
    LPVOID    lpFile,
    HANDLE    hHeap,
    char      **pszResTypes)
{
    PIMAGE_RESOURCE_DIRECTORY          prdRoot;
    PIMAGE_RESOURCE_DIRECTORY_ENTRY    prde;
    char                   *pMem;
    int                    nCnt, i;


    /* get root directory of resource tree */
    if ((prdRoot = (PIMAGE_RESOURCE_DIRECTORY)ImageDirectoryOffset
            (lpFile, IMAGE_DIRECTORY_ENTRY_RESOURCE)) == NULL)
    return 0;

    /* allocate enuff space from heap to cover all types */
    nCnt = prdRoot->NumberOfIdEntries * (MAXRESOURCENAME + 1);
    *pszResTypes = (char *)HeapAlloc (hHeap,
                      HEAP_ZERO_MEMORY,
                      nCnt);
    if ((pMem = *pszResTypes) == NULL)
    return 0;

    /* set pointer to first resource type entry */
    prde = (PIMAGE_RESOURCE_DIRECTORY_ENTRY)((LONG_PTR)prdRoot + sizeof (IMAGE_RESOURCE_DIRECTORY));

    /* loop through all resource directory entry types */
    for (i=0; i<prdRoot->NumberOfIdEntries; i++)
    {
    if (LoadString (hDll, prde->Name, pMem, MAXRESOURCENAME))
        pMem += strlen (pMem) + 1;

    prde++;
    }

    return nCnt;
}




/* function indicates whether debug  info has been stripped from file */
BOOL    WINAPI IsDebugInfoStripped (
    LPVOID    lpFile)
{
    PIMAGE_FILE_HEADER    pfh;

    pfh = (PIMAGE_FILE_HEADER)PEFHDROFFSET (lpFile);

    return (pfh->Characteristics & IMAGE_FILE_DEBUG_STRIPPED);
}




/* retrieve the module name from the debug misc. structure */
int    WINAPI RetrieveModuleName (
    LPVOID    lpFile,
    HANDLE    hHeap,
    char      **pszModule)
{

    PIMAGE_DEBUG_DIRECTORY    pdd;
    PIMAGE_DEBUG_MISC         pdm = NULL;
    int               nCnt;

    if (!(pdd = (PIMAGE_DEBUG_DIRECTORY)ImageDirectoryOffset (lpFile, IMAGE_DIRECTORY_ENTRY_DEBUG)))
    return 0;

    while (pdd->SizeOfData)
    {
    if (pdd->Type == IMAGE_DEBUG_TYPE_MISC)
        {
        pdm = (PIMAGE_DEBUG_MISC)((DWORD)pdd->PointerToRawData + (LONG_PTR)lpFile);

        *pszModule = (char *)HeapAlloc (hHeap,
                        HEAP_ZERO_MEMORY,
                        (nCnt = (lstrlen (pdm->Data)*(pdm->Unicode?2:1)))+1);
        CopyMemory (*pszModule, pdm->Data, nCnt);

        break;
        }

    pdd ++;
    }

    if (pdm != NULL)
    return nCnt;
    else
    return 0;
}





/* determine if this is a valid debug file */
BOOL    WINAPI IsDebugFile (
    LPVOID    lpFile)
{
    PIMAGE_SEPARATE_DEBUG_HEADER    psdh;

    psdh = (PIMAGE_SEPARATE_DEBUG_HEADER)lpFile;

    return (psdh->Signature == IMAGE_SEPARATE_DEBUG_SIGNATURE);
}




/* copy separate debug header structure from debug file */
BOOL    WINAPI GetSeparateDebugHeader (
    LPVOID              lpFile,
    PIMAGE_SEPARATE_DEBUG_HEADER    psdh)
{
    PIMAGE_SEPARATE_DEBUG_HEADER    pdh;

    pdh = (PIMAGE_SEPARATE_DEBUG_HEADER)lpFile;

    if (pdh->Signature == IMAGE_SEPARATE_DEBUG_SIGNATURE)
    {
    CopyMemory ((LPVOID)psdh, (LPVOID)pdh, sizeof (IMAGE_SEPARATE_DEBUG_HEADER));
    return TRUE;
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\test\vidacc\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__8F396420_7660_4704_9B99_07785DF4F2B4__INCLUDED_)
#define AFX_STDAFX_H__8F396420_7660_4704_9B99_07785DF4F2B4__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers

#include <afx.h>
#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions
#include <afxdtctl.h>		// MFC support for Internet Explorer 4 Common Controls
#ifndef _AFX_NO_AFXCMN_SUPPORT
#include <afxcmn.h>			// MFC support for Windows Common Controls
#endif // _AFX_NO_AFXCMN_SUPPORT

#include <iostream>

// TODO: reference additional headers your program requires here

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__8F396420_7660_4704_9B99_07785DF4F2B4__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\test\vchk\vchk.h ===
#if !defined(AFX_VCHK_H__759990C4_C5B1_44C5_8CAE_C55BAE0E2D81__INCLUDED_)
#define AFX_VCHK_H__759990C4_C5B1_44C5_8CAE_C55BAE0E2D81__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

// #include "driverlist.h"

class CommandLine : public CCommandLineInfo {
public:
    typedef enum {parseOK, parseError, parseHelp, parseHelpImports} ParseResult;
    
    CommandLine() :
      m_last_flag (""),
      m_log_fname (""),
      m_drv_fname (""),
      m_parse_error (parseOK),
      m_error_msg (""),
      m_allowed(m_allowed_buf),
      m_append (TRUE),
      m_first_param(FALSE),
      CCommandLineInfo(),
      m_monitor(-1)
      {
          m_allowed[0] = 0;
          m_allowed[1] = 0;
      }

    virtual void ParseParam( LPCTSTR lpszParam, BOOL bFlag, BOOL bLast );

    BOOL        m_append;

    char        m_allowed_buf[2048];

    ParseResult m_parse_error;
    CString     m_error_msg;
    CString     m_log_fname;
    CString     m_list_fname;   //  list of drivers failed, passed and those produced warnings
    CString     m_drv_fname;
    int         m_monitor;

private:
    char*       m_allowed;
    CString     m_last_flag;
    BOOL        m_first_param;
};

/////////////////////////////////////////////////////////////////////////////
// CDrvchkApp:
// See drvchk.cpp for the implementation of this class
//

class CDrvchkApp : public CWinApp
{
public:
    CDrvchkApp();

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CDrvchkApp)
    public:
    virtual BOOL InitInstance();
    //}}AFX_VIRTUAL

protected:
    void ChkDriver (CString drv_name);
    BOOL CheckDriverAndPrintResults (void);
    void PrintOut (LPCSTR str);
    void PrintOut (unsigned num);
    void ListOut (LPCSTR str);
    void ListOut (unsigned num);

private:
    FILE*       m_logf;
    FILE*       m_listf;
    CommandLine m_cmd_line;
    OSVERSIONINFO m_os_ver_info;
    CString     m_drv_name;
    // CDriverList m_drv_list;
};

/////////////////////////////////////////////////////////////////////////////

#endif // !defined(AFX_VCHK_H__759990C4_C5B1_44C5_8CAE_C55BAE0E2D81__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\test\vidacc\vidacc.h ===
#if !defined(AFX_VCHK_H__759990C4_C5B1_44C5_8CAE_C55BAE0E2D81__INCLUDED_)
#define AFX_VCHK_H__759990C4_C5B1_44C5_8CAE_C55BAE0E2D81__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

// #include "driverlist.h"

#define ACC_DISABLED (5)

class CommandLine : public CCommandLineInfo {
public:
    CommandLine() :
      m_last_flag (""),
      m_parse_error (FALSE),
      m_error_msg (""),
	  m_help(FALSE),
      m_acc_level(ACC_DISABLED),
      m_first_param(FALSE),
      CCommandLineInfo(),
      m_monitor(0)
      {
      }

    virtual void ParseParam( LPCTSTR lpszParam, BOOL bFlag, BOOL bLast );

    BOOL        m_parse_error;
    BOOL        m_help;
    CString     m_error_msg;
    CString     m_log_fname;
    int         m_monitor;
    DWORD       m_acc_level;

private:
    CString     m_last_flag;
    BOOL        m_first_param;
};

/////////////////////////////////////////////////////////////////////////////
// CDrvchkApp:
// See drvchk.cpp for the implementation of this class
//

class CDrvchkApp : public CWinApp
{
public:
	CDrvchkApp();

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CDrvchkApp)
	public:
	virtual BOOL InitInstance();
	//}}AFX_VIRTUAL

protected:
    void PrintOut (LPCSTR str);
    void PrintOut (unsigned num);

private:
    FILE*       m_logf;
    CommandLine m_cmd_line;
    OSVERSIONINFO m_os_ver_info;
	CString     m_drv_name;
    // CDriverList m_drv_list;
};

/////////////////////////////////////////////////////////////////////////////

#endif // !defined(AFX_VCHK_H__759990C4_C5B1_44C5_8CAE_C55BAE0E2D81__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\test\vchk\vchk.cpp ===
// vchk.cpp : Defines the entry point for the console application.
//

#include "stdafx.h"
#pragma hdrstop

#include "vchk.h"
#include "allowed.h"
#include "ilimpchk.h"

//#include <devguid.h>
#include <setupapi.h>
//#include <regstr.h>
#include <cfgmgr32.h>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

using namespace std;

//////////////////////////////////////////////////////////////////////////////
//#define VCHK_TRACE_ON 1

#ifdef VCHK_TRACE_ON
const char* VchkTraceGetName(const char* szName)
{
    const char* szLastSeg = szName;
    const char* szSlash = strchr(szName, '\\');
    while (szSlash) {
        ++szSlash;
        szLastSeg = szSlash;
        szSlash = strchr(szSlash, '\\');        
    } 
    return szLastSeg;
}
#define VCHK_TRACE(x) {cerr << " [" << VchkTraceGetName(__FILE__) << ":" << __LINE__ << "] " << x;}
#else
#define VCHK_TRACE(x)
#endif

/////////////////////////////////////////////////////////////////////////////
// Enumerates display devices

typedef class CDisplayDeviceEnum {
public:

    static bool IsDigitsOnly(const char* sz);

    CDisplayDeviceEnum();
    ~CDisplayDeviceEnum() {free(Buffer);}
    
    bool IsValid() const {return bValid;}
    bool Next();
    
    CString GetMiniportPath();
    
    DWORD GetDeviceId() {return iEnum;}
    
    DWORD GetLastError() {return dwLastError;}
    const char* GetLastErrorStr() {return szLastError;}
    
    void MarkDevice(DISPLAY_DEVICE& r_DisplayDevice);
    void UnmarkDevice();
    bool IsMarkedDevice();
    
private:
    static const GUID const displayClassGUID;

    BYTE* Buffer;
    size_t BufferSize;
    bool bValid;
    
    DWORD iEnum;
    HDEVINFO hDevInfo;
    SP_DEVINFO_DATA DeviceInfoData;
    HKEY hMarkedKey;

    DWORD dwLastError;
    const char* szLastError;
    
    bool ReallocBuffer(size_t NewSize)
    {
        if (NewSize > BufferSize) {
            void* p = realloc(Buffer, NewSize);
            if (!p) return false;
            
            Buffer = (PBYTE)p;
            BufferSize = NewSize;
        }
        return true;
    }
    
    void MarkKey(HKEY hKey);
    void UnmarkKey();
    bool IsMarkedDEVINST(DEVINST DevInst);
    
} typedef_CDisplayDeviceEnum;

/////////////////////////////////////////////////////////////////////////////
// CDisplayDeviceEnum implementation

/////////////////////////////////////////////////////////////////////////////
// CDisplayDeviceEnum::IsDigitsOnly

bool CDisplayDeviceEnum::IsDigitsOnly(const char* sz)
{
    if (!sz || !*sz) return false;
    while (('0' <= *sz) && (*sz <= '9')) ++sz;
    return !*sz;
}

/////////////////////////////////////////////////////////////////////////////
// CDisplayDeviceEnum constants

const GUID const CDisplayDeviceEnum::displayClassGUID = 
    {0x4d36e968L, 0xe325, 0x11ce, {0xbf, 0xc1, 0x08, 0x00, 0x2b, 0xe1, 0x03, 0x18}};
    
/////////////////////////////////////////////////////////////////////////////
// CDisplayDeviceEnum constructor

CDisplayDeviceEnum::CDisplayDeviceEnum() : 

    bValid(true),
    Buffer(NULL),
    BufferSize(0),
    iEnum(0),
    hDevInfo(INVALID_HANDLE_VALUE),
    hMarkedKey(NULL),
    dwLastError(0),
    szLastError(NULL)

{
    ZeroMemory(&DeviceInfoData, sizeof(DeviceInfoData)); 
    DeviceInfoData.cbSize = sizeof(DeviceInfoData);
    
    ReallocBuffer(MAX_PATH + 1);
    
    // Get Device Info Set for display class GUID
    hDevInfo = SetupDiGetClassDevs(&displayClassGUID, // class guid
                                   NULL,              // Enumerator
                                   NULL,              // top level window
                                   DIGCF_PRESENT);
    if (hDevInfo != INVALID_HANDLE_VALUE) {
        Next();
    } else {
        dwLastError = GetLastError();
        szLastError = "SetupDiGetClassDevs failure";
        bValid = false;
    }
}

/////////////////////////////////////////////////////////////////////////////
// CDisplayDeviceEnum::Next() - gets next device into scope

bool CDisplayDeviceEnum::Next() 
{
    if (!bValid) return false;
    
    // get device info for the device in the Device Info Set at index iEnum
    if (SetupDiEnumDeviceInfo(hDevInfo,          // device info set
                              iEnum,             // member index
                              &DeviceInfoData))  // Device Info data
    {
        ++iEnum;
    } else {
        dwLastError = GetLastError();
        szLastError = "SetupDiEnumDeviceInfo failure";
        bValid = false;
    }   
    
    return bValid;
}
       
/////////////////////////////////////////////////////////////////////////////
// CDisplayDeviceEnum::GetMiniportPath() - gets miniport of current device

CString CDisplayDeviceEnum::GetMiniportPath()
{
    DWORD BufferSizeNeeded = BufferSize;
    DWORD DataT;
    
    // Get Registry Information for the Device
    // First time through is to find out how much memory we need to allocate.
    // Second time actually gives us the information we want.
    while (!SetupDiGetDeviceRegistryProperty(hDevInfo,          // device info set
                                             &DeviceInfoData,   // info for the device we want to retrieve
                                             SPDRP_SERVICE,     // Specify that we want the service name
                                             &DataT,
                                             Buffer,     // this should return the service name
                                             BufferSizeNeeded,
                                             &BufferSizeNeeded))
    {
        DWORD dwError = GetLastError();
        if (dwError == ERROR_INSUFFICIENT_BUFFER) {
            if (ReallocBuffer(BufferSizeNeeded)) continue;
            szLastError = "Not enough memory";
        } else {            
            szLastError = "SetupDiGetDeviceRegistryProperty failure";
        }
        dwLastError = dwError;
        bValid = false;
        
        return CString();
    }

    // get miniport path
    CString sRegPath("System\\CurrentControlSet\\Services\\");
    sRegPath += (LPCSTR)Buffer;
    
    // open the services key, find the service, and get the image path
    HKEY hkService;
    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                     (LPCSTR)sRegPath,
                     0,
                     KEY_READ,
                     &hkService) != ERROR_SUCCESS) 
    {
        dwLastError = GetLastError();
        szLastError = "RegOpenKeyEx failure";
        bValid = false;
        return CString();
    }
    
    if (!ReallocBuffer(MAX_PATH)) {
        dwLastError = -1;
        szLastError = "Not enough memory";
        bValid = false;
        return CString();
   }

    DWORD cb = BufferSize;
    ZeroMemory(Buffer, cb);
            
    if (RegQueryValueEx(hkService,
                        "ImagePath",
                        NULL,
                        NULL,
                        (LPBYTE)Buffer,
                        &cb) != ERROR_SUCCESS) 
    {
        dwLastError = GetLastError();
        szLastError = "RegQueryValueEx failure";
        bValid = false;
        return CString();
    }
    
    return CString((const char*)Buffer);
}

/////////////////////////////////////////////////////////////////////////////
// CDisplayDeviceEnum::MarkDevice(DISPLAY_DEVICE&)
//
// XXX olegk (it is really XXX level of hack)
// we will mark the child monitor subkey and than will be searching for 
// children with marked keys later in IsMarkedDevice()
//

void CDisplayDeviceEnum::MarkDevice(DISPLAY_DEVICE& r_DisplayDevice)
{
    if (hMarkedKey) UnmarkDevice();
    
    VCHK_TRACE("-------- Marking Device ----------\n");
    VCHK_TRACE("ID        : " << r_DisplayDevice.DeviceID << endl);
    VCHK_TRACE("Key       : " << r_DisplayDevice.DeviceKey << endl);
    VCHK_TRACE("Name      : " << r_DisplayDevice.DeviceName << endl);
    VCHK_TRACE("String    : " << r_DisplayDevice.DeviceString << endl);

    DISPLAY_DEVICE MonitorInfo;
    MonitorInfo.cb = sizeof(MonitorInfo);
    if (!EnumDisplayDevices(r_DisplayDevice.DeviceName, 0, &MonitorInfo, 0)) {
        VCHK_TRACE("Can't get monitor info for " << 
                   r_DisplayDevice.DeviceString << ' ' << 
                   r_DisplayDevice.DeviceName << endl);
        return;
    }
    
    CString sKey;
    
    // XXX olegk - Assume that all device keys are under HKEY_LOCAL_MACHINE
    {
        const CHAR szMachineRegPath[] = "\\REGISTRY\\Machine\\";
        
        if (_strnicmp(szMachineRegPath, 
                     MonitorInfo.DeviceKey, 
                     sizeof(szMachineRegPath) - 1)) 
        {
            dwLastError = DWORD(-1);
            szLastError = "Invalid registry path (must be under HKEY_LOCAL_MACHINE)";
        
            VCHK_TRACE("Invalid registry path " << MonitorInfo.DeviceKey << endl);
            return; 
        }
        sKey = (LPCSTR)(MonitorInfo.DeviceKey) + sizeof(szMachineRegPath) - 1;
    }
    
    HKEY hKey;
    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, 
                     (LPCSTR)sKey, 
                     0, 
                     KEY_READ, 
                     &hKey) != ERROR_SUCCESS)
    {
        // Do nothing - no service will be found
        DWORD dwError = GetLastError();
        VCHK_TRACE("RegOpenKeyEx failure " << dwError << " : " << r_DisplayDevice.DeviceKey << endl);
        return;
    }

    VCHK_TRACE("Marked Key: " << (LPCSTR)sKey << endl);
    MarkKey(hKey);
}

/////////////////////////////////////////////////////////////////////////////
// CDisplayDeviceEnum::UnmarkDevice(DISPLAY_DEVICE&)

void CDisplayDeviceEnum::UnmarkDevice()
{
    UnmarkKey();
}

/////////////////////////////////////////////////////////////////////////////
// CDisplayDeviceEnum::IsMarkedDevice()

bool CDisplayDeviceEnum::IsMarkedDevice()
{
    const size_t nMaxLevel = 10; // XXX olegk - I can't imagine more than 3 but...
    DEVINST DevInstStack[nMaxLevel];
    size_t nLevel = 0;
    
    if (CM_Get_Child(&DevInstStack[nLevel], DeviceInfoData.DevInst, 0) != CR_SUCCESS) return false;
    
    while (!IsMarkedDEVINST(DevInstStack[nLevel])) {
        if ((nLevel < nMaxLevel) &&
            (CM_Get_Child(&DevInstStack[nLevel + 1], 
                          DevInstStack[nLevel], 
                          0) == CR_SUCCESS))
        {
            ++nLevel; 
            continue;
        }
        while (CM_Get_Sibling(&DevInstStack[nLevel], DevInstStack[nLevel], 0) != CR_SUCCESS) {            
            if (!nLevel) return false; // End of search (no marker have been found)
            --nLevel;
        }
    }
    
    return true;
}

/////////////////////////////////////////////////////////////////////////////
// CDisplayDeviceEnum::MarkKey(...)
    
void CDisplayDeviceEnum::MarkKey(HKEY hKey)
{
    UnmarkKey();
    hMarkedKey = hKey;
}

/////////////////////////////////////////////////////////////////////////////
// CDisplayDeviceEnum::UnmarkKey(...)

void CDisplayDeviceEnum::UnmarkKey()
{
    if (!hMarkedKey) return;
    RegCloseKey(hMarkedKey);
    hMarkedKey = NULL;
}

/////////////////////////////////////////////////////////////////////////////
// CDisplayDeviceEnum::IsMarkedDEVINST(...)

bool CDisplayDeviceEnum::IsMarkedDEVINST(DEVINST DevInst)
{
    bool bIsMarked = false;
    
    HKEY hKey;
    if (CM_Open_DevNode_Key(DevInst, 
                            KEY_READ,          // IN  REGSAM         samDesired,
                            0,                 // IN  ULONG          ulHardwareProfile,
                            RegDisposition_OpenExisting,
                            &hKey,              //OUT PHKEY          phkDevice,
                            CM_REGISTRY_SOFTWARE) == CR_SUCCESS)
    {
        extern bool IsTheSameRegKey(HKEY, HKEY);
        bIsMarked = IsTheSameRegKey(hMarkedKey, hKey);
        RegCloseKey(hKey);                         
    }
    return bIsMarked;    
}

/////////////////////////////////////////////////////////////////////////////
// The one and only application object

void
CDrvchkApp::PrintOut (LPCSTR str)
{
    if (m_logf)
        fprintf (m_logf, "%s", str);
    else
        cerr << str;
}

void
CDrvchkApp::PrintOut (unsigned num)
{
    if (m_logf)
        fprintf (m_logf, "%u", num);
    else
        cerr << num;
}

inline
void
CDrvchkApp::ListOut (LPCSTR str)
{
    if (m_listf)
        fprintf (m_listf, "%s", str);
}

void
CDrvchkApp::ListOut (unsigned num)
{
    if (m_listf)
        fprintf (m_listf, "%u", num);
}

ModulesAndImports allowed_modules;
ModulesAndImports allowed_imports;
ModulesAndImports known_illegal;
ModulesAndImports illegal_msgs;

void SetCurrentModule(const char* szModule)
{
    allowed_imports.SetModule(szModule);
    illegal_msgs.SetModule(szModule);
    known_illegal.SetModule(szModule);
}

#define VCHK_WARN  known_illegal.AddImport
#define VCHK_FAIL  illegal_msgs.AddImport
#define VCHK_ALLOW allowed_imports.AddImport

void BuildInAllowedAndIllegal (void)
{
    SetCurrentModule("HAL.DLL");
 
    VCHK_FAIL  ("HalAllocateCommonBuffer", "use VideoPortAllocateCommonBuffer");
    VCHK_FAIL  ("HalFreeCommonBuffer", "use VideoPortFreeCommonBuffer");
    VCHK_WARN  ("HalGetAdapter", "obsolete; see DDK manual");
    VCHK_WARN  ("HalGetBusData", "obsolete; see DDK manual");
    VCHK_WARN  ("HalGetBusDataByOffset");
    VCHK_WARN  ("HalSetBusData", "obsolete; see DDK manual");
    VCHK_WARN  ("HalSetBusDataByOffset");
    VCHK_WARN  ("HalTranslateBusAddress");
    VCHK_FAIL  ("KeGetCurrentIrql", "use VideoPortGetCurrentIrql");
    VCHK_FAIL  ("KeQueryPerformanceCounter", "use VideoPortQueryPerformanceCounter");
    VCHK_FAIL  ("KfAcquireSpinLock", "use VideoPortAcquireSpinLock");
    VCHK_FAIL  ("KfReleaseSpinLock", "use VideoPortReleaseSpinLock");
    VCHK_FAIL  ("READ_PORT_ULONG", "use VideoPortReadPortUlong");
    VCHK_FAIL  ("WRITE_PORT_ULONG", "use VideoPortWritePortUlong");

    SetCurrentModule ("NTOSKRNL.EXE");
    
    VCHK_ALLOW ("_except_handler3");
    VCHK_FAIL  ("ExAllocatePool", "use VideoPortAllocatePool");
    VCHK_FAIL  ("ExAllocatePoolWithTag", "use VideoPortAllocatePool");
    VCHK_FAIL  ("ExFreePool", "use VideoPortFreePool");
    VCHK_FAIL  ("ExFreePoolWithTag", "use VideoPortFreePool");
    VCHK_WARN  ("ExIsProcessorFeaturePresent");
    VCHK_WARN  ("ExQueueWorkItem");
    VCHK_WARN  ("IoAllocateMdl");
    VCHK_WARN  ("IoCreateNotificationEvent");
    VCHK_WARN  ("IoCreateSynchronizationEvent");
    VCHK_WARN  ("IoFreeMdl");
    VCHK_WARN  ("IoGetCurrentProcess");
    VCHK_FAIL  ("IoReportDetectedDevice");
    VCHK_FAIL  ("IoReportResourceForDetection");
    VCHK_WARN  ("KeCancelTimer");
    VCHK_FAIL  ("KeClearEvent", "use VideoPortClearEvent");
    VCHK_FAIL  ("KeDelayExecutionThread", "use VideoPortStallExecution");
    VCHK_FAIL  ("KeInitializeDpc", "use VideoPortQueueDpc");
    VCHK_FAIL  ("KeInitializeSpinLock", "use VideoPortXxxSpinLockXxx");
    VCHK_WARN  ("KeInitializeTimer");
    VCHK_WARN  ("KeInitializeTimerEx");
    VCHK_FAIL  ("KeInsertQueueDpc", "use VideoPortQueueDpc");
    VCHK_WARN  ("KeQuerySystemTime");
    VCHK_WARN  ("KeRestoreFloatingPointState");
    VCHK_WARN  ("KeSaveFloatingPointState");
    VCHK_FAIL  ("KeSetEvent", "use VideoPortSetEvent");
    VCHK_WARN  ("KeSetTimer");
    VCHK_WARN  ("KeSetTimerEx");
    VCHK_FAIL  ("MmAllocateContiguousMemory", "use VideoPortAllocateContiguousMemory");
    VCHK_WARN  ("MmAllocateNonCachedMemory");
    VCHK_WARN  ("MmBuildMdlForNonPagedPool");
    VCHK_WARN  ("MmFreeContiguousMemory");
    VCHK_WARN  ("MmFreeNonCachedMemory");
    VCHK_WARN  ("MmGetPhysicalAddress");
    VCHK_WARN  ("MmIsAddressValid");
    VCHK_WARN  ("MmMapIoSpace");
    VCHK_WARN  ("MmMapLockedPages");
    VCHK_WARN  ("MmMapLockedPagesSpecifyCache");
    VCHK_WARN  ("MmProbeAndLockPages");
    VCHK_WARN  ("MmQuerySystemSize");
    VCHK_WARN  ("MmUnlockPages");
    VCHK_WARN  ("MmUnmapIoSpace");
    VCHK_WARN  ("MmUnmapLockedPages");
    VCHK_WARN  ("ObReferenceObjectByHandle");
    VCHK_WARN  ("PsGetCurrentProcessId");
    VCHK_WARN  ("PsGetVersion");
    VCHK_FAIL  ("READ_REGISTER_UCHAR", "use VideoPortReadRegisterUchar");
    VCHK_WARN  ("RtlAnsiStringToUnicodeString");
    VCHK_WARN  ("RtlAppendUnicodeStringToString");
    VCHK_WARN  ("RtlCheckRegistryKey");
    VCHK_WARN  ("RtlCompareMemory");
    VCHK_WARN  ("RtlCopyUnicodeString");
    VCHK_WARN  ("RtlCreateRegistryKey");
    VCHK_WARN  ("RtlFreeAnsiString");
    VCHK_WARN  ("RtlFreeUnicodeString");
    VCHK_WARN  ("RtlInitAnsiString");
    VCHK_WARN  ("RtlInitUnicodeString");
    VCHK_WARN  ("RtlIntegerToUnicodeString");
    VCHK_WARN  ("RtlQueryRegistryValues");
    VCHK_WARN  ("RtlTimeToTimeFields");
    VCHK_WARN  ("RtlUnicodeStringToAnsiString");
    VCHK_WARN  ("RtlUnicodeToMultiByteN");
    VCHK_WARN  ("RtlUnwind");
    VCHK_WARN  ("RtlWriteRegistryValue");
    VCHK_FAIL  ("wcslen", "link to libcntpr.lib instead");
    VCHK_FAIL  ("WRITE_REGISTER_UCHAR", "use VideoPortWriteRegisterUchar");
    VCHK_FAIL  ("WRITE_REGISTER_USHORT", "use VideoPortWriteRegisterUshort");
    VCHK_WARN  ("ZwClose");
    VCHK_WARN  ("ZwCreateFile");
    VCHK_WARN  ("ZwEnumerateValueKey");
    VCHK_WARN  ("ZwMapViewOfSection");
    VCHK_WARN  ("ZwOpenKey");
    VCHK_WARN  ("ZwOpenSection");
    VCHK_WARN  ("ZwQueryValueKey");
    VCHK_WARN  ("ZwSetSystemInformation");
    VCHK_WARN  ("ZwUnmapViewOfSection");
    VCHK_WARN  ("ZwWriteFile");
}

/////////////////////////////////////////////////////////////////////////////
// main

int __cdecl _tmain(int argc, TCHAR* argv[], TCHAR* envp[])
{
    int nRetCode = 0;

    // initialize MFC and print and error on failure
    if (AfxWinInit(::GetModuleHandle(NULL), NULL, ::GetCommandLine(), 0))
    {
        CDrvchkApp theApp;
        theApp.InitInstance ();
    }

    return nRetCode;
}

/////////////////////////////////////////////////////////////////////////////
// CDrvchkApp construction

CDrvchkApp::CDrvchkApp() :
    m_logf(NULL),
    m_listf(NULL),
    m_drv_name ("")
{
    // TODO: add construction code here,
    // Place all significant initialization in InitInstance
}

/////////////////////////////////////////////////////////////////////////////
// The one and only CDrvchkApp object

void
CommandLine::ParseParam( LPCTSTR lpszParam, BOOL bFlag, BOOL bLast )
{

    if (m_parse_error != parseOK)
        return;

    CString param (lpszParam);

    if (bFlag) {

        param.MakeUpper();
        
        if ((param==CString("?")) || (param == CString("HELP")) || (param == CString("H"))) {
        
            m_parse_error = parseHelp;
            
        } else if ((param==CString("?IMP")) || (param==CString("IMP?"))) {
        
            m_parse_error = parseHelpImports;
            
        } else if (m_last_flag.GetLength() && m_first_param) {
        
            m_parse_error = parseError;
            m_error_msg = CString("Flag ") + m_last_flag + CString(" requires a parameter.");
            
        } else if ((param==CString("LOG")) || (param==CString("DRV")) || (param==CString("MON")) ||
                   (param==CString("LIST")) || (param==CString("LST")) || (param==CString("LS")) ||
                   (param==CString("LIS")) || (param==CString("ALLOW"))) {
                   
            if (bLast) {
                m_parse_error = parseError;
                m_error_msg = CString("Flag ") + param + CString(" requires a parameter.");
            } else {
                m_last_flag = param;
                m_first_param = TRUE;
            }

        } else {
        
            m_last_flag = CString();
            m_parse_error = parseError;
            m_error_msg = CString("Invalid flag: ") + param;           
        }

    } else {

        if (m_last_flag==CString("ALLOW")) {
            m_first_param = FALSE;
            int nSplit = param.Find('!');
            if (nSplit != -1) {
                CString module = param.Left(nSplit);
                CString import = param.Mid(nSplit + 1);
                
                if (module.GetLength() && import.GetLength()) {
                    allowed_imports.SetModule(module);
                    allowed_imports.AddImport(import, "allowed by command line");
                } else {
                    m_parse_error = parseError;
                    m_error_msg = CString("Bad parameter format for flag: ") + m_last_flag;
                }
            } else {
                allowed_modules.SetModule(param);
            }
        } else if (m_last_flag==CString("DRV")) {
            if (m_monitor >= 1) {
                m_error_msg = "bad command line: Conflicting flags MON and DRV";
                m_parse_error = parseError;
            }
            m_drv_fname = param;
            m_last_flag="";
        } else if (m_last_flag==CString("LOG")) {
            m_log_fname = param;
            m_last_flag="";
        } else if (m_last_flag==CString("LIST") ||
                   m_last_flag==CString("LST") ||
                   m_last_flag==CString("LIS") ||
                   m_last_flag==CString("LS")) {
            m_list_fname = param;
            m_last_flag="";
        } else if (m_last_flag==CString("MON")) {
            if ((param.GetLength()==1) && 
                (((LPCSTR)param)[0] >= '1') && 
                (((LPCSTR)param)[0] <= '9')) 
            {
                if (m_drv_fname.GetLength()) {
                    m_error_msg = "bad command line: Conflicting flags MON and DRV";
                    m_parse_error = parseError;
                }
                char c = ((LPCSTR)param)[0];
                m_monitor = c - '0';
            } else {
                m_error_msg = "bad command line: MON flag has invalid parameter";
                m_parse_error = parseError;
            }
            m_last_flag="";
        } else {
            m_parse_error = parseError;
            m_error_msg = CString("Wrong parameter: ") + param;
            m_last_flag="";
        }
    }

    if (bLast) {
        if (m_last_flag==CString("LOG") || m_last_flag==CString("DRV")) {
            m_parse_error = parseError;
            m_error_msg = CString("Flag ") + m_last_flag + CString(" requires a parameter.");
        }
    }
}


/////////////////////////////////////////////////////////////////////////////
// CDrvchkApp initialization

const char* szHelp =
    "Copyright (C) Microsoft Corporation. All rights reserved.\n"
    "\n"
    "usage: vchk [-?] [-LOG logfile] [-DRV drvname | -MON id] [-LIST listname]\n"
    "            [-ALLOW module[!import] [module[!import]] ...]\n"
    "\n"
    "where: -?     displays this help\n"
    "       -IMP?  dumps imports tables that check performed against\n"
    "       -LOG   specifies output file name (if file already exists then new data\n"
    "              will be appended to it)\n"
    "       -DRV   specifies the full name of the driver's binary to check\n"
    "       -MON   specifies 1-based numeric id of the display adapter to check\n"
    "       -LIST  specifies the file for summary (if file already exists then new\n"
    "              data will be appended to it)\n"
    "       -ALLOW specifies allowed imports\n"
    "              module: name of allowed module (if no import specified then all\n"
    "                      imports from the module will be allowed)\n"
    "              import: specific import name\n"
    "\n"
    "       if neither -MON nor -DRV switches used then all currently active video\n"
    "       drivers will be checked\n"
    "\n"
    "Example:\n"
    "    vchk -log c:\\log.out -list con -allow HAL.DLL!HalGetBusData VIDEOPORT.SYS\n";

BOOL CDrvchkApp::InitInstance()
{
    // Standard initialization
    // If you are not using these features and wish to reduce the size

    m_os_ver_info.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    GetVersionEx (&m_os_ver_info);
    if (m_os_ver_info.dwPlatformId != VER_PLATFORM_WIN32_NT) {  //  doesn't work on Win9x
        PrintOut ("warning: unsupported OS (Win9x), nothing done.\n");
        return FALSE;
    }
    
    //if (m_os_ver_info.dwMajorVersion != 5) {                       //  doesn't work on NT version prior to Win2K
    if (m_os_ver_info.dwMajorVersion < 5) {   // XXX olegk - will it work in the future????
        PrintOut ("warning: unsupported OS (");
        PrintOut (m_os_ver_info.dwMajorVersion);
        PrintOut (".");
        PrintOut (m_os_ver_info.dwMinorVersion);
        PrintOut ("): nothing done.\n");
        return FALSE;
    }

    ParseCommandLine (m_cmd_line);
    BuildInAllowedAndIllegal();

    if (m_cmd_line.m_log_fname.GetLength()) {
        m_logf = fopen (m_cmd_line.m_log_fname, "a+");
        if (!m_logf) m_logf = fopen (m_cmd_line.m_log_fname, "a");
    }

    if (m_cmd_line.m_list_fname.GetLength()) {
        m_listf = fopen (m_cmd_line.m_list_fname, "a+");
        if (!m_listf) m_listf = fopen (m_cmd_line.m_list_fname, "a");
    }

    switch (m_cmd_line.m_parse_error) {
    case CommandLine::parseOK: {
        int device_num = m_cmd_line.m_monitor;

        if (m_cmd_line.m_drv_fname.GetLength()) {

            ChkDriver (m_cmd_line.m_drv_fname);

        } else {
            DWORD               cbData = 0;
            DEVMODE             dmCurrent;
            TCHAR               szDeviceDescription[10000];
            TCHAR               szImagePath[MAX_PATH + 1]; 
            TCHAR               szVarImagePath[MAX_PATH + 1]; 
            TCHAR               szExpImagePath[MAX_PATH + 1]; 
            DISPLAY_DEVICE      DisplayDevice, *pDisplayDevice = NULL;

            CString dev_desc_CtrlSet;

            
            int nNonMirroringDevice = 0; 
    
            //
            // Find non mirroring display device #device_num if needed
            //
            if (device_num >= 1) {
                ZeroMemory(&DisplayDevice, sizeof(DisplayDevice));
                DisplayDevice.cb = sizeof(DisplayDevice);
                DWORD i, nNonMirrorDev;
            
                for (i = 0, nNonMirrorDev = 0; EnumDisplayDevices(NULL, i, &DisplayDevice, 0); ++i) {
                    if (DisplayDevice.StateFlags & DISPLAY_DEVICE_MIRRORING_DRIVER) continue; // skip mirroring drivers
                    if (device_num == ++nNonMirroringDevice) {
                        pDisplayDevice = &DisplayDevice;
                        break;
                    }
                }
                if (!pDisplayDevice) {
                    PrintOut ("error: cannot find video service\n");
                    break;
                }
            }
            
            //
            // Let's find all the video drivers that are installed in the system
            //
            CDisplayDeviceEnum DevEnum;
            bool bDevFound = false;
            
            if (pDisplayDevice) DevEnum.MarkDevice(*pDisplayDevice);

            while (DevEnum.IsValid()) {
                if (!pDisplayDevice || DevEnum.IsMarkedDevice()) {
                
                    bDevFound = true;
                    
                    CString sMiniportPath = DevEnum.GetMiniportPath();
                    if (!sMiniportPath.GetLength()) {
                        sprintf (szDeviceDescription, "error: cannot find video service #%d\n", DevEnum.GetDeviceId());
                        PrintOut (szDeviceDescription);
                        VCHK_TRACE("error: " << szDeviceDescription << 
                                   "\n       " << DevEnum.GetLastError() << " " << DevEnum.GetLastErrorStr() << endl)
                                       
                        break;
                    }
                
                    sprintf (szVarImagePath, "%%WINDIR%%\\%s", (LPCSTR)sMiniportPath);
                    ExpandEnvironmentStrings (szVarImagePath, szExpImagePath, MAX_PATH);
                    VCHK_TRACE("Checking miniport " << szExpImagePath << endl)
                    ChkDriver (szExpImagePath); 
                }
                
                DevEnum.Next();
            } 
            
            if (!bDevFound) PrintOut ("error: cannot find video service\n");
        } // look for system drivers
    } // parseOK
    break;
    
    case CommandLine::parseHelp: {
        CString Filename, Version, Description, Copyright;
        {
            CHAR szModuleName[MAX_PATH + 1]; 
            ZeroMemory(szModuleName, sizeof(szModuleName));

            if (GetModuleFileName(m_hInstance, szModuleName, MAX_PATH)) {
                DWORD dw = 0;
                DWORD dwVerLen = GetFileVersionInfoSize(szModuleName, &dw);

                if (dwVerLen) {
                    PBYTE Buffer = (PBYTE)malloc(dwVerLen + 1);
                    PVOID pValue;
                    if (Buffer &&
                        GetFileVersionInfo(szModuleName, dw, dwVerLen, Buffer))
                    {
                        UINT ValLen;
                        if (VerQueryValue(Buffer, "\\StringFileInfo\\000004B0\\OriginalFilename", &pValue, &ValLen)); {
                            Filename = CString((LPCSTR)pValue, ValLen);
                        }
                        if (VerQueryValue(Buffer, "\\StringFileInfo\\000004b0\\ProductVersion", &pValue, &ValLen));
                            Version = CString((LPCSTR)pValue, ValLen);
                        if (VerQueryValue(Buffer, "\\StringFileInfo\\000004b0\\FileDescription", &pValue, &ValLen));
                            Description = CString((LPCSTR)pValue, ValLen);
                    }
    
                    free(Buffer);
               }
            }
        }
        
        cout << endl << (Filename.GetLength() ? (LPCSTR)Filename : "VCHK.EXE!");
        if (Version.GetLength()) cout << " " << (LPCSTR)Version;
        if (Description.GetLength()) cout << ": " << (LPCSTR)Description;
        cout << endl;
        cout << szHelp;
    } // parseHelp
    break;
    
    case CommandLine::parseHelpImports: {
    
        BuildInAllowedAndIllegal();
        
        cout << "\n--- Illegal imports (errors) --------------\n\n";
        illegal_msgs.Dump(cout);
        
        cout << "\n--- Known illegal imports (warnings) ------\n\n";
        known_illegal.Dump(cout);
        
        cout << "\n--- Allowed imports -----------------------\n\n";
        allowed_imports.Dump(cout);
        
        cout << "\n--- Allowed modules -----------------------\n\n";
        allowed_modules.Dump(cout);
        
    } // parseHelpImports
    break;
        
    default:
        PrintOut ("error: ");
        PrintOut (m_cmd_line.m_error_msg.GetLength() ? (LPCSTR)m_cmd_line.m_error_msg : "unknown failure");
        PrintOut ("\nUse vchk -? for help.\n");
    } // switch

    if (m_logf)
        fclose (m_logf);
    m_logf = NULL;

    if (m_listf)
        fclose (m_listf);
    m_listf = NULL;

    return TRUE;
}

void CDrvchkApp::ChkDriver (CString drv_name)
{
    m_drv_name = drv_name;
    cerr << (LPCSTR)m_drv_name << endl;
    if (!InitIllegalImportsSearch (m_drv_name, "INIT")) {
        PrintOut ("error: can't perform check in ");
        PrintOut (m_drv_name);
        PrintOut (", check the name and path please\n");
    } else if (CheckDriverAndPrintResults ()) {
        PrintOut ("success: no illegal imports in ");
        PrintOut (m_drv_name);
        PrintOut ("\n");
    }
}

BOOL CDrvchkApp::CheckDriverAndPrintResults ()
{

    Names Modules = CheckSectionsForImports ();

    if (!Modules.Ptr) {
        PrintOut ("error: cannot retrieve import information from ");
        PrintOut (m_drv_name);
        PrintOut ("\n");
        return FALSE;
    }

    int errors_found = 0;
    int warnings_found = 0;
    bool bad_data = false;

    for (int i=0;
         i<Modules.Num;
         Modules.Ptr = GetNextName(Modules.Ptr), i++) {

        Names Imports = GetImportsList (Modules.Ptr);
        if (!Imports.Num) {
            bad_data = true;
            break;
        }

        VCHK_TRACE("Checking " << (LPCSTR)Modules.Ptr << endl)

        CString module_name (Modules.Ptr);
        module_name.MakeUpper();

        if (allowed_modules.IsModule(module_name)) {
            //
            // The whole module is allowed, no errors on any import
            // from this module.
            //
            VCHK_TRACE("Allowed module " << (LPCSTR)module_name << endl)
            continue;
        }

        BOOL KnownIllegals = known_illegal.IsModule(module_name);
        if (KnownIllegals) {
            VCHK_TRACE("Known Illegals from " << (LPCSTR)module_name << endl)
        }
        
        BOOL IllegalMsgs = illegal_msgs.IsModule(module_name);
        if (IllegalMsgs) {
            VCHK_TRACE("Illegal Imports from " << (LPCSTR)module_name << endl)
        }

        BOOL AllowedImports = allowed_imports.IsModule(module_name);
        if (AllowedImports) {
            VCHK_TRACE("Allowed Imports from " << (LPCSTR)module_name << endl)
        }
        
        LPSTR ImportsPtr = Imports.Ptr;

        for (int j=0;
             j<Imports.Num;
             Imports.Ptr = GetNextName (Imports.Ptr), j++) {
             
                if (allowed_imports.Lookup(Imports.Ptr)) continue;

                CString msg = "";

                CString ImportFnName =  module_name +
                                        CString("!") +
                                        CString(Imports.Ptr);

                if (KnownIllegals && known_illegal.Lookup(Imports.Ptr, msg)) {
                    PrintOut ("warning: ");
                    ++warnings_found;
                } else if (AllowedImports && allowed_imports.Lookup(Imports.Ptr)) {
                    continue; // Ignore allowed import
                } else if (IllegalMsgs && illegal_msgs.Lookup(Imports.Ptr, msg)) {
                    PrintOut ("error: ");
                    ++errors_found;
                } else {
                    PrintOut ("warning: "); // Default case; now we make it warning too, but keep it 
                    ++warnings_found;      // a separate case for very probable future changes.
                }

                PrintOut (m_drv_name);
                PrintOut (": ");
                PrintOut (ImportFnName);
                if (msg.GetLength()) {
                    PrintOut (" -- ");
                    PrintOut (msg);
                }
                PrintOut ("\n");
        }
        
        
        if (ImportsPtr) HeapFree (GetProcessHeap(), 0, ImportsPtr);
    }

    CString drv_bin_name;
    for (int i=m_drv_name.GetLength()-1; i>=0; i--) {
        if (m_drv_name.GetAt(i)=='\\') {
            drv_bin_name = ((LPCSTR)m_drv_name) + i + 1;
            break;
        }
    }

    BOOL skip_it = FALSE;
    if (m_drv_name.Find("\\wdm\\") != -1) {
        skip_it = TRUE;
    }

    char buf[256];
    if (skip_it) {
        sprintf (buf, "SKIP WDM:");
    } else if (bad_data) {
        sprintf (buf, "WRONG_BINARY:");
    } else if (errors_found!=0) {
        sprintf (buf, "ERRORS: ");
    } else if (warnings_found!=0) {
        sprintf (buf, "WARNINGS:");
    } else {
        sprintf (buf, "SUCCESS:");
    }

    ListOut (buf);
    sprintf (buf, "\t%3d errors\t%3d warnings\t%s\n", errors_found, warnings_found, (LPCSTR)drv_bin_name);
    ListOut (buf);

    return (errors_found==0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\test\vidacc\vidacc.cpp ===
// vidacc.cpp : Video acceleration manipulation tool.
//

#include "stdafx.h"
#include "windows.h"
#include "vidacc.h"
#include <devguid.h>
#include <setupapi.h>
#include <regstr.h>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

using namespace std;

/////////////////////////////////////////////////////////////////////////////
// The one and only application object

inline
void
CDrvchkApp::PrintOut (LPCSTR str)
{
    if (m_logf)
        fprintf (m_logf, "%s", str);
    else
        cerr << str;
}

inline
void
CDrvchkApp::PrintOut (unsigned num)
{
    if (m_logf)
        fprintf (m_logf, "%d", num);
    else
        cerr << num;
}

int __cdecl _tmain(int argc, TCHAR* argv[], TCHAR* envp[])
{
	int nRetCode = 0;

    // cerr << ::GetCommandLine() << endl;

	// initialize MFC and print and error on failure
	if (AfxWinInit(::GetModuleHandle(NULL), NULL, ::GetCommandLine(), 0))
	{
        CDrvchkApp theApp;
        theApp.InitInstance ();
	}

	return nRetCode;
}

/////////////////////////////////////////////////////////////////////////////
// CDrvchkApp construction

CDrvchkApp::CDrvchkApp() :
    m_logf(NULL),
	m_drv_name ("")
{
	// TODO: add construction code here,
	// Place all significant initialization in InitInstance
}

/////////////////////////////////////////////////////////////////////////////
// The one and only CDrvchkApp object

/*------------------------------------------------------------------------

  vchk /drv driver.dll /log logname.log /allow videoptr.sys

  /allowed_modules module1.sys FnName1 FnName2 FnName3 /allowed_modules module2.dll FnName4

  ------------------------------------------------------------------------*/

void
CommandLine::ParseParam( LPCTSTR lpszParam, BOOL bFlag, BOOL bLast )
{

    if (m_parse_error)
        return;

    CString param (lpszParam);

    if (bFlag) {

        param.MakeUpper();

        if (m_last_flag.GetLength()) {
            m_parse_error = TRUE;
            m_error_msg = CString("Flag ") + m_last_flag + CString(" requires a parameter.");
        } else if ((param==CString("ACC")) || (param==CString("LOG")) || (param==CString("MON"))) {
            m_last_flag = param;
            m_first_param = TRUE;
        } else if (param==CString("?")) {
            m_help = TRUE;
            m_last_flag="";
        } else {
            m_last_flag = "";
            m_parse_error = TRUE;
            m_error_msg = CString("Unrecognized flag: ") + param;
        }

    } else {
        if ((m_last_flag==CString("ACC"))) {
            DWORD acc_lvl = atoi(param);
			if ((acc_lvl==0) && !(param==CString("0"))) {
                m_error_msg = "bad command line: /ACC flag has wrong parameter";
                m_parse_error = TRUE;
			}
			else if (acc_lvl>ACC_DISABLED)
				m_acc_level=ACC_DISABLED;
			else
				m_acc_level=acc_lvl;
			m_last_flag = "";
        } else if (m_last_flag==CString("MON")) {
            if (param.GetLength()==1) {
                char c = ((LPCSTR)param)[0];
                m_monitor = c - '1';
            } else {
                m_monitor = -1;
                m_error_msg = "bad command line: /MON flag has wrong parameter";
                m_parse_error = TRUE;
            }
            m_last_flag="";
        } else if (m_last_flag==CString("LOG")) {
            m_log_fname = param;
            m_last_flag="";
        } else {
            m_parse_error = TRUE;
            m_error_msg = CString("Wrong parameter: ") + param;
            m_last_flag="";
        }
    }

    if (bLast) {
        if (m_last_flag==CString("ACC")) {
            m_parse_error = TRUE;
            m_error_msg = CString("Flag ") + m_last_flag + CString(" requires a parameter.");
        }
    }
}


/////////////////////////////////////////////////////////////////////////////
// CDrvchkApp initialization

BOOL CDrvchkApp::InitInstance()
{
	// Standard initialization
	// If you are not using these features and wish to reduce the size

    ParseCommandLine (m_cmd_line);

	if (m_cmd_line.m_help) {
        PrintOut ("\nVIDACC [/ACC level] [/MON monitor] [/LOG logfile] [/?]\n\n");
        PrintOut ("  /ACC       explicitely defines acceleration level\n\n");
        PrintOut ("  level      a digit from 0 to 5, 0 means full acceleration,\n"
			      "             and 5 (default) disables acceleration at all.\n\n");
        PrintOut ("  monitor    monitor number (if running on multimon)\n\n");
        PrintOut ("  logfile    a file to dump the output messages\n\n");
		return TRUE;
    }
    
	m_os_ver_info.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    GetVersionEx (&m_os_ver_info);
    if (m_os_ver_info.dwPlatformId != VER_PLATFORM_WIN32_NT) {  //  doesn't work on Win9x
        PrintOut ("warning: unsupported OS (Win9x), nothing done.\n");
        return FALSE;
    }
    if (m_os_ver_info.dwMajorVersion<5) {                       //  doesn't work on NT version prior to Win2K
        PrintOut ("warning: unsupported OS (");
        PrintOut (m_os_ver_info.dwMajorVersion);
        PrintOut (".");
        PrintOut (m_os_ver_info.dwMinorVersion);
        PrintOut ("): nothing done.\n");
        return FALSE;
    }

    if (m_cmd_line.m_log_fname.GetLength()) {
        m_logf = fopen (m_cmd_line.m_log_fname, "a+");
    }

    if (m_cmd_line.m_parse_error) {

        PrintOut ("error: ");
        PrintOut ((LPCSTR)m_cmd_line.m_error_msg);
        PrintOut ("\n");

    } else {

        //
        // Let's find all the video drivers that are installed in the system
        //
        DISPLAY_DEVICE DisplayDevice;
        DisplayDevice.cb = sizeof (DisplayDevice);

        // cerr << "looking for device #" << m_cmd_line.m_monitor << endl;

        for (DWORD d=0, index=0; EnumDisplayDevices(NULL, index, &DisplayDevice, 0); index++) {

            // cerr << "device #" << d << endl;

            if (DisplayDevice.StateFlags & DISPLAY_DEVICE_MIRRORING_DRIVER) {
                // cerr << "DisplayDevice.StateFlags & DISPLAY_DEVICE_MIRRORING_DRIVER\n";
                continue;
            }

            if (m_cmd_line.m_monitor!=d++) {
                // cerr << "m_cmd_line.m_monitor!=d\n";
                continue;
            }

			HKEY hKey = NULL;

			TCHAR device_key[256];     // Name of service (drivers)

			// cerr << DisplayDevice.DeviceKey << endl;
			_tcscpy (device_key, DisplayDevice.DeviceKey+18);  // chop "\Registry\Machine\" off
			// cerr << device_key << endl;

			if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,device_key,(DWORD)0,KEY_ALL_ACCESS,&hKey)==ERROR_SUCCESS) {

					RegSetValueEx(hKey,
								  _TEXT("Acceleration.Level"),
								  0,
								  REG_DWORD,
								  (CONST BYTE *)&m_cmd_line.m_acc_level,
								  sizeof(DWORD));
			}

			ChangeDisplaySettings(NULL, 0);

			switch (m_cmd_line.m_acc_level) {
			case 0:
				PrintOut ("Level 0: Full acceleration enabled\n");
				break;
			case 1:
				PrintOut ("Level 1: Only cursor and birmap acceleration disabled\n");
				break;
			case 2:
				PrintOut ("Level 2: Cursor and advanced drawing acceleration disabled\n");
				break;
			case 3:
				PrintOut ("Level 3: DirectX, cursor and advanced drawing acceleration disabled\n");
				break;
			case 4:
				PrintOut ("Level 4: All but basic accelerations disabled\n");
				break;
			case 5:
				PrintOut ("Level 5: All accelerations disabled\n");
				break;
			}

			if (hKey)
				RegCloseKey(hKey);

        } // for each device

    }   // if no cmd line error

    if (m_logf)
        fclose (m_logf);
    m_logf = NULL;

	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\test\vtsimea\engexts.cpp ===
//----------------------------------------------------------------------------
//
// Debugger engine extension helper library.
//
// Copyright (C) Microsoft Corporation, 1999-2000.
//
//----------------------------------------------------------------------------

#define DEBUG_NO_IMPLEMENTATION
#include <engexts.h>

PDEBUG_ADVANCED       g_ExtAdvanced;
PDEBUG_CLIENT         g_ExtClient;
PDEBUG_CONTROL        g_ExtControl;
PDEBUG_DATA_SPACES    g_ExtData;
PDEBUG_DATA_SPACES2   g_ExtData2;
PDEBUG_DATA_SPACES3   g_ExtData3;
PDEBUG_REGISTERS      g_ExtRegisters;
PDEBUG_SYMBOLS        g_ExtSymbols;
PDEBUG_SYSTEM_OBJECTS g_ExtSystem;

// Queries for all debugger interfaces.
HRESULT
ExtQuery(PDEBUG_CLIENT Client)
{
    HRESULT Status;

    //
    // Required interfaces.
    //
    
    if ((Status = Client->QueryInterface(__uuidof(IDebugAdvanced),
                                         (void **)&g_ExtAdvanced)) != S_OK)
    {
        goto Fail;
    }
    if ((Status = Client->QueryInterface(__uuidof(IDebugControl),
                                         (void **)&g_ExtControl)) != S_OK)
    {
        goto Fail;
    }
    if ((Status = Client->QueryInterface(__uuidof(IDebugDataSpaces),
                                         (void **)&g_ExtData)) != S_OK)
    {
        goto Fail;
    }
    if ((Status = Client->QueryInterface(__uuidof(IDebugRegisters),
                                         (void **)&g_ExtRegisters)) != S_OK)
    {
        goto Fail;
    }
    if ((Status = Client->QueryInterface(__uuidof(IDebugSymbols),
                                         (void **)&g_ExtSymbols)) != S_OK)
    {
        goto Fail;
    }
    if ((Status = Client->QueryInterface(__uuidof(IDebugSystemObjects),
                                         (void **)&g_ExtSystem)) != S_OK)
    {
        goto Fail;
    }

    //
    // Optional interfaces.
    //
    
    if ((Status = Client->QueryInterface(__uuidof(IDebugDataSpaces2),
                                         (void **)&g_ExtData2)) != S_OK)
    {
        g_ExtData2 = NULL;
    }
    
    if ((Status = Client->QueryInterface(__uuidof(IDebugDataSpaces3),
                                         (void **)&g_ExtData3)) != S_OK)
    {
        g_ExtData3 = NULL;
    }
    
    g_ExtClient = Client;
    
    return S_OK;

 Fail:
    ExtRelease();
    return Status;
}

// Cleans up all debugger interfaces.
void
ExtRelease(void)
{
    g_ExtClient = NULL;
    EXT_RELEASE(g_ExtAdvanced);
    EXT_RELEASE(g_ExtControl);
    EXT_RELEASE(g_ExtData);
    EXT_RELEASE(g_ExtData2);
    EXT_RELEASE(g_ExtData3);
    EXT_RELEASE(g_ExtRegisters);
    EXT_RELEASE(g_ExtSymbols);
    EXT_RELEASE(g_ExtSystem);
}

// Normal output.
void __cdecl
ExtOut(PCSTR Format, ...)
{
    va_list Args;
    
    va_start(Args, Format);
    g_ExtControl->OutputVaList(DEBUG_OUTPUT_NORMAL, Format, Args);
    va_end(Args);
}

// Error output.
void __cdecl
ExtErr(PCSTR Format, ...)
{
    va_list Args;
    
    va_start(Args, Format);
    g_ExtControl->OutputVaList(DEBUG_OUTPUT_ERROR, Format, Args);
    va_end(Args);
}

// Warning output.
void __cdecl
ExtWarn(PCSTR Format, ...)
{
    va_list Args;
    
    va_start(Args, Format);
    g_ExtControl->OutputVaList(DEBUG_OUTPUT_WARNING, Format, Args);
    va_end(Args);
}

// Verbose output.
void __cdecl
ExtVerb(PCSTR Format, ...)
{
    va_list Args;
    
    va_start(Args, Format);
    g_ExtControl->OutputVaList(DEBUG_OUTPUT_VERBOSE, Format, Args);
    va_end(Args);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\test\vtsimea\engexts.h ===
//----------------------------------------------------------------------------
//
// Debugger engine extension helper library.
//
// Copyright (C) Microsoft Corporation, 1999-2000.
//
//----------------------------------------------------------------------------

#ifndef __ENGEXTS_H__
#define __ENGEXTS_H__

#include <stdlib.h>
#include <stdio.h>

#include <windows.h>

#include <dbgeng.h>

#ifdef __cplusplus
extern "C" {
#endif

// Safe release and NULL.
#define EXT_RELEASE(Unk) \
    ((Unk) != NULL ? ((Unk)->Release(), (Unk) = NULL) : NULL)

// Global variables initialized by query.
extern PDEBUG_ADVANCED       g_ExtAdvanced;
extern PDEBUG_CLIENT         g_ExtClient;
extern PDEBUG_CONTROL        g_ExtControl;
extern PDEBUG_DATA_SPACES    g_ExtData;
extern PDEBUG_DATA_SPACES2   g_ExtData2;
extern PDEBUG_DATA_SPACES3   g_ExtData3;
extern PDEBUG_REGISTERS      g_ExtRegisters;
extern PDEBUG_SYMBOLS        g_ExtSymbols;
extern PDEBUG_SYSTEM_OBJECTS g_ExtSystem;

// Prototype just to force the extern "C".
// The implementation of these functions are not provided.
HRESULT CALLBACK DebugExtensionInitialize(PULONG Version, PULONG Flags);
void CALLBACK DebugExtensionUninitialize(void);

// Queries for all debugger interfaces.
HRESULT ExtQuery(PDEBUG_CLIENT Client);

// Cleans up all debugger interfaces.
void ExtRelease(void);

// Normal output.
void __cdecl ExtOut(PCSTR Format, ...);
// Error output.
void __cdecl ExtErr(PCSTR Format, ...);
// Warning output.
void __cdecl ExtWarn(PCSTR Format, ...);
// Verbose output.
void __cdecl ExtVerb(PCSTR Format, ...);

#ifdef __cplusplus
}
#endif

#endif // #ifndef __ENGEXTS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\test\vtsimea\vtsimea.cpp ===
#include <engexts.h>

//----------------------------------------------------------------------------
//
// StaticEventCallbacks.
//
//----------------------------------------------------------------------------

class StaticEventCallbacks : public DebugBaseEventCallbacks
{
public:
    // IUnknown.
    STDMETHOD_(ULONG, AddRef)(THIS);
    STDMETHOD_(ULONG, Release)(THIS);
};

STDMETHODIMP_(ULONG)
StaticEventCallbacks::AddRef(THIS)
{
    // This class is designed to be static so
    // there's no true refcount.
    return 1;
}

STDMETHODIMP_(ULONG)
StaticEventCallbacks::Release(THIS)
{
    // This class is designed to be static so
    // there's no true refcount.
    return 0;
}

//----------------------------------------------------------------------------
//
// ExcepCallbacks.
//
//----------------------------------------------------------------------------

class ExcepCallbacks : public StaticEventCallbacks
{
public:
    ExcepCallbacks(void)
    {
        m_Client = NULL;
        m_Control = NULL;
    }
    
    // IDebugEventCallbacks.
    STDMETHOD(GetInterestMask)(THIS_ 
                               OUT PULONG Mask);
    
    STDMETHOD(Exception)(THIS_
                         IN PEXCEPTION_RECORD64 Exception,
                         IN ULONG FirstChance);

    HRESULT Initialize(PDEBUG_CLIENT Client)
    {
        HRESULT Status;
        
        m_Client = Client;
        m_Client->AddRef();
        
        if ((Status = m_Client->QueryInterface(__uuidof(IDebugControl),
                                               (void**)&m_Control)) == S_OK)
        {
#if 0            
            // Turn off default breakin on breakpoint exceptions.
            Status = m_Control->Execute(DEBUG_OUTCTL_ALL_CLIENTS,
                                        "sxd bpe", DEBUG_EXECUTE_DEFAULT);
#endif 
        }

        return Status;
    }
    
    void Uninitialize(void)
    {
        EXT_RELEASE(m_Control);
        EXT_RELEASE(m_Client);
    }
    
private:
    PDEBUG_CLIENT m_Client;
    PDEBUG_CONTROL m_Control;
};

STDMETHODIMP
ExcepCallbacks::GetInterestMask(
    THIS_
    OUT PULONG Mask
    )
{
    *Mask = DEBUG_EVENT_EXCEPTION;
    return S_OK;
}
    
STDMETHODIMP
ExcepCallbacks::Exception(
    THIS_
    IN PEXCEPTION_RECORD64 Exception,
    IN ULONG FirstChance
    )
{
    m_Control->Output(DEBUG_OUTPUT_NORMAL, "Exception %X at %p, chance %d\n",
                      Exception->ExceptionCode, Exception->ExceptionAddress,
                      FirstChance ? 1 : 2);
    return DEBUG_STATUS_GO_HANDLED;
}

ExcepCallbacks g_ExcepCallbacks;

//----------------------------------------------------------------------------
//
// FnProfCallbacks.
//
//----------------------------------------------------------------------------

class FnProfCallbacks : public StaticEventCallbacks
{
public:
    FnProfCallbacks(void)
    {
        m_Client = NULL;
        m_Control = NULL;
    }
    
    // IDebugEventCallbacks.
    STDMETHOD(GetInterestMask)(THIS_
                               OUT PULONG Mask);
    
    STDMETHOD(Breakpoint)(THIS_
                          IN PDEBUG_BREAKPOINT Bp);

    HRESULT Initialize(PDEBUG_CLIENT Client, 
                       PDEBUG_CONTROL Control)
    {
        m_Hits = 0;
        
        m_Client = Client;
        m_Client->AddRef();
        m_Control = Control;
        m_Control->AddRef();
        
        return S_OK;
    }
    
    void Uninitialize(void)
    {
        EXT_RELEASE(m_Control);
        EXT_RELEASE(m_Client);
    }

    ULONG GetHits(void)
    {
        return m_Hits;
    }
    
    PDEBUG_CONTROL GetControl(void)
    {
        return m_Control;
    }
    
private:
PDEBUG_CLIENT m_Client;
    PDEBUG_CONTROL m_Control;
    ULONG m_Hits;
};

STDMETHODIMP
FnProfCallbacks::GetInterestMask(THIS_
                                 OUT PULONG Mask)
{
    *Mask = DEBUG_EVENT_BREAKPOINT;
    return S_OK;
}
    
STDMETHODIMP
FnProfCallbacks::Breakpoint(THIS_
                            IN PDEBUG_BREAKPOINT Bp)
{
    PDEBUG_CLIENT Client;
    HRESULT Status = DEBUG_STATUS_NO_CHANGE;
    
    // If this is one of our profiling breakpoints
    // record the function hit and continue on.
    if (Bp->GetAdder(&Client) == S_OK) {
        if (Client == m_Client) {
            m_Hits++;
            Status = DEBUG_STATUS_GO;
        }
        
        Client->Release();
    }

    Bp->Release();
    return Status;
}

FnProfCallbacks g_FnProfCallbacks;

//----------------------------------------------------------------------------
//
// Extension entry points.
//
//----------------------------------------------------------------------------

extern "C" HRESULT CALLBACK
DebugExtensionInitialize(PULONG Version, PULONG Flags)
{
    *Version = DEBUG_EXTENSION_VERSION(1, 0);
    *Flags = 0;
    return S_OK;
}

extern "C" void CALLBACK
DebugExtensionUninitialize(void)
{
    g_ExcepCallbacks.Uninitialize();
    g_FnProfCallbacks.Uninitialize();
}

const char* szHelp =
    "  usage: !vtsimea [-? | function | address]\n"
    "\n"
    "  where: -?          displays this help\n"
    "         function    name of the function to simulate EA at\n"
    "         address     address to simulate EA at\n"
    "\n"
    "  Example:\n"
    "      !vtsimea nv4_disp!DrvBitBlt\n";
    
const char* szErrorPrefix =
    "  Error: ";

const char* szErrorSuffix =
    "  Use -? for help\n";
    
const char* szSuccess = "Success.\n";
    
HRESULT EncodeInfiniteLoopX86(ULONG64 Address)
{
    // jmp -2
    unsigned char JmpOnSelf[2] = {0xEB, 0xFE}; 
    
    return g_ExtData->WriteVirtual(Address, 
                                   &JmpOnSelf, 
                                   sizeof(JmpOnSelf), 
                                   NULL);
}

HRESULT EncodeInfiniteLoopIA64(ULONG64 Address)
{
    // nop.m 0
    // nop.m 0
    // br.cond.sptk.many +0;;
    unsigned char JmpOnSelf[16] = {0x19, 0x00, 0x00, 0x00, 
                                   0x01, 0x00, 0x00, 0x00, 
                                   0x00, 0x02, 0x00, 0x00, 
                                   0x08, 0x00, 0x00, 0x40};
                                   
    return g_ExtData->WriteVirtual(Address, 
                                   &JmpOnSelf, 
                                   sizeof(JmpOnSelf), 
                                   NULL);
}

HRESULT SimulateEA(ULONG64 Address[2])
{
    HRESULT Status;
    HRESULT BpAdded[2] = {-1, -1};
    
    PDEBUG_BREAKPOINT Bp[2];
    ULONG BpId[2];
    ULONG BpSize;  
    unsigned uBpHit = 0xFF;
    unsigned i, count;
    
    ExtOut("Get CPU type ... ");
    
    ULONG CpuType;
    Status = g_ExtControl->GetEffectiveProcessorType(&CpuType);
    if (Status != S_OK) {
        ExtErr("Failure! Can't get CPU type\n");
        goto CleanExit;
    }
    
    switch (CpuType) {
    case IMAGE_FILE_MACHINE_I386: BpSize = 1; break;
    case IMAGE_FILE_MACHINE_IA64: BpSize = 16; break;
    default: 
        ExtErr("Failure! Invalid CPU type %d\n", CpuType);
        goto CleanExit;
    }
    
    ExtOut(szSuccess);    
    
    count = 0;
    for (i = 0; Address[i] && (i < 2); ++i) {
        ExtOut("Set HW breakpoint at %I64lx ... ", Address[i]);
    
        Status = BpAdded[i] = g_ExtControl->AddBreakpoint(DEBUG_BREAKPOINT_DATA, 
                                                          DEBUG_ANY_ID, 
                                                          &Bp[i]);
    
        if ((Status != S_OK) ||
            ((Status = Bp[i]->SetDataParameters(BpSize, DEBUG_BREAK_EXECUTE)) != S_OK) ||
            ((Status = Bp[i]->SetOffset(Address[i])) != S_OK) ||
            ((Status = Bp[i]->GetId(&BpId[i])) != S_OK) ||
            ((Status = Bp[i]->AddFlags(DEBUG_BREAKPOINT_ENABLED)) != S_OK))
        {
            ExtOut("Failure!\n");
        }
        else {
            ++count;
        }
        ExtOut(szSuccess);    
    } // for
    
    if (!count) {
        ExtErr("Failure! Unable to set HW breakpoints\n");
        goto CleanExit;
    }
    
    ExtOut("Continuing execution (until BP hit) ... ");    
    
    Status = g_ExtControl->SetExecutionStatus(DEBUG_STATUS_GO);
    if (Status != S_OK) {
        ExtOut("Failure\n");
        goto CleanExit;
    }

    Status = g_ExtControl->WaitForEvent(DEBUG_WAIT_DEFAULT, INFINITE);
    if (Status != S_OK) {
        ExtErr("Failure! Call to WaitForEvent failed\n");
        goto CleanExit;
    }

    ULONG EvType, ProcessId, ThreadId;
    DEBUG_LAST_EVENT_INFO_BREAKPOINT BpInfo;
    Status = g_ExtControl->GetLastEventInformation(&EvType,
                                                   &ProcessId,
                                                   &ThreadId,
                                                   &BpInfo, 
                                                   sizeof(BpInfo), 
                                                   0,0,0,0);
    if ((Status != S_OK) || 
        (EvType != DEBUG_EVENT_BREAKPOINT))
    {
        ExtErr("Failure! Unknown event during EA simulation\n");
        goto CleanExit;
    }
    
    for (i = 0; Address[i] && (i < 2); ++i) {
        if (BpInfo.Id == BpId[i]) {
            uBpHit = i; 
            break;
        }
    }
    
    if (uBpHit > 1) {
        ExtErr("Failure! Unknown breakpoint hit during EA simulation\n");
        goto CleanExit;
    }
    
    ExtOut("\n");        
    
    for (i = 0; Address[i] && (i < 2); ++i) {    
        ExtOut("Disable HW breakpoint %d ... ", BpId[i]);
    
        Status = Bp[i]->RemoveFlags(DEBUG_BREAKPOINT_ENABLED);
        if (Status != S_OK) {
            ExtOut("Failure\n");
            goto CleanExit;
        }
        
        ExtOut(szSuccess);
    }
    
    ExtOut("Encoding infinite loop at %I64lx ... ", Address[uBpHit]);    
    
    switch (CpuType) {
    case IMAGE_FILE_MACHINE_I386: 
        Status = EncodeInfiniteLoopX86(Address[uBpHit]); 
        break;
    case IMAGE_FILE_MACHINE_IA64: 
        Status = EncodeInfiniteLoopIA64(Address[uBpHit]); 
        break;
    }
    
    if (Status != S_OK) {
        ExtOut("Failure\n");
        goto CleanExit;    
    }
    
    ExtOut(szSuccess);
    
    ExtOut("Continue execution until EA fault ...\n");
    
    Status = g_ExtControl->SetExecutionStatus(DEBUG_STATUS_GO);
    if (Status != S_OK) {
        ExtOut("Failure\n");
        goto CleanExit;
    }

CleanExit:
    for (i = 0; Address[i] && (i < 2); ++i) {    
        if (BpAdded[i] == S_OK) g_ExtControl->RemoveBreakpoint(Bp[i]);
    }
    return Status;
}

HRESULT GetAddressPair(PCSTR Args, 
                       ULONG64 Address[2], 
                       size_t* pCount)
{
    HRESULT Status;
    ULONG64 h;
    
    Address[0] = Address[1] = 0;
    *pCount = 0;
    
    //
    // Symbol can't start from number so we can optimize 
    // our resolution process
    //
    if ((Args[0] < '0') || (Args[0] > '9')) { // Guess it is just symbol
    
        //
        // search at least 2 to cover ia64 p-label 
        //
        Status = g_ExtSymbols->StartSymbolMatch(Args, &h);
        if (Status != S_OK) return Status;
        
        char szName[1024];
        ULONG64 Offset;
        for(;;) {
            Status = g_ExtSymbols->GetNextSymbolMatch(h, 
                                                      szName, 
                                                      sizeof(szName), 
                                                      NULL, 
                                                      &Offset);
            if (Status != S_OK) break;
            if (*pCount < 2) Address[*pCount] = Offset;
            ++*pCount;
        }
        
        g_ExtSymbols->EndSymbolMatch(h);
    } // if
    
    if (!*pCount) { // It is not simple symbol - guess it is expression
        DEBUG_VALUE AddrVal;
        Status = g_ExtControl->Evaluate(Args, DEBUG_VALUE_INT64, &AddrVal, NULL);
        if (Status == S_OK) {
            Address[0] = AddrVal.I64;
            *pCount = 1;
        }
    } // if
    
    if (!*pCount) return Status;
    return Address[0] ? S_OK : -1;
}

extern "C" HRESULT CALLBACK
vtsimea(PDEBUG_CLIENT pClient, PCSTR Args)
{
    HRESULT Status;
    
    Status = ExtQuery(pClient);
    if (Status != S_OK) {
        ExtErr("Failure! Client unavailable\n");
        return Status;
    }
    
    if (!g_ExtControl ||
        !g_ExtData || 
        !g_ExtSymbols) 
    {
        ExtErr(szErrorPrefix);
        ExtErr("Failure! Required interfaces are unavailable\n");    
        ExtRelease();
        return -1;
    }
    
    size_t ArgsLen = Args ? strlen(Args) : 0;
    
    if (!ArgsLen) {
        ExtErr(szErrorSuffix);
    }
    if (ArgsLen >= 64) {
        ExtErr(szErrorPrefix);
        ExtErr("Parameters size too big\n");
        ExtErr(szErrorSuffix);
    }
    else if (!strcmp(Args, "-?")) {
        ExtOut(szHelp);
    }
    else if (strchr(Args, '*') || 
             strchr(Args, '?') || 
             strchr(Args, ' ')) 
    {
        ExtErr(szErrorPrefix);
        ExtErr("Invalid parameter or wrong parameters number\n");
        ExtErr(szErrorSuffix);
    }
    else {
        size_t Count;
        ULONG64 Address[2];
        Status = GetAddressPair(Args, Address, &Count);
        
        if (Status != S_OK) {
            ExtErr(szErrorPrefix);
            ExtErr("Can't resolve %s\n", Args);
            ExtErr(szErrorSuffix);
        }
        else if (Count > 2) {
            ExtErr(szErrorPrefix);
            ExtErr("Too many resolutions for %s\n", Args);
            ExtErr(szErrorSuffix);
        }
        else {
            ExtOut("Simulating fault EA at %s (%I64lx)\n", Args, Address[0]);
            Status = SimulateEA(Address);
        }
    }
    
    ExtRelease();
    return Status;
}

extern "C" HRESULT CALLBACK
simea(PDEBUG_CLIENT pClient, PCSTR Args)
{
    return vtsimea(pClient, Args);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\vga\disp\16bpp\bitblt.c ===
/******************************Module*Header*******************************\
* Module Name: bitblt.c
*
* Banked Frame Buffer bitblit
*
* Copyright (c) 1992 Microsoft Corporation
*
\**************************************************************************/

#include "driver.h"

/************************************************************************\
* bIntersectRect
*
* Calculates the intersection between *prcSrc1 and *prcSrc2,
* returning the resulting rect in *prcDst.  Returns TRUE if
* *prcSrc1 intersects *prcSrc2, FALSE otherwise.  If there is no
* intersection, an empty rect is returned in *prcDst.
\************************************************************************/

static const RECTL rclEmpty = { 0, 0, 0, 0 };

BOOL bIntersectRect(
    PRECTL prcDst,
    PRECTL prcSrc1,
    PRECTL prcSrc2)

{
    prcDst->left  = max(prcSrc1->left, prcSrc2->left);
    prcDst->right = min(prcSrc1->right, prcSrc2->right);

    // check for empty rect

    if (prcDst->left < prcDst->right)
    {
        prcDst->top    = max(prcSrc1->top, prcSrc2->top);
        prcDst->bottom = min(prcSrc1->bottom, prcSrc2->bottom);

        // check for empty rect

        if (prcDst->top < prcDst->bottom)
            return(TRUE);        // not empty
    }

    // empty rect

    *prcDst = rclEmpty;

    return(FALSE);
}

/******************************Public*Routine******************************\
* BOOL bPuntScreenToScreenCopyBits(ppdev, pco, pxlo, prclDest, pptlSrc)
*
* Performs a screen-to-screen CopyBits entirely using an intermediate
* temporary buffer and GDI.
*
* We found that on most machines it was faster to have the engine copy
* the source to a buffer, then blit the buffer to the destination, than
* to have optimized ASM code that copies a word at a time.  The reason?
* The engine does d-word moves, which are faster than word moves even
* going over the bus to a 16 bit display device.
*
* We could also write optimized ASM code that does d-word moves, but the
* win will be marginal, we're time constrained, we also need a routine
* like this to handle complex clip objects and palette translates, and
* most of the other times we can use planar copies for important things
* like scrolls, anyways.
*
\**************************************************************************/

BOOL bPuntScreenToScreenCopyBits(
PPDEV     ppdev,
CLIPOBJ*  pco,
XLATEOBJ* pxlo,
RECTL*    prclDest,
POINTL*   pptlSrc)
{
    RECTL    rclDest;
    POINTL   ptlSrc;
    BOOL     b = TRUE;

    SURFOBJ* pso    = ppdev->pSurfObj;
    SURFOBJ* psoTmp = ppdev->psoTmp;

    if (prclDest->top < pptlSrc->y)
    {
        ////////////////////////////////////////////////////////////////
        // Do a top-to-bottom copy:
        ////////////////////////////////////////////////////////////////

        LONG ySrcBottom;
        LONG yDestBottom;

        LONG yDestTop = prclDest->top;
        LONG ySrcTop  = pptlSrc->y;
        LONG ySrcLast = ySrcTop + (prclDest->bottom - prclDest->top);

        if (ySrcTop <  ppdev->rcl1WindowClip.top ||
            ySrcTop >= ppdev->rcl1WindowClip.bottom)
        {
            ppdev->pfnBankControl(ppdev, ySrcTop, JustifyTop);
        }

        pso->pvScan0 = ppdev->pvBitmapStart;

        while (TRUE)
        {
            // Copy an entire source bank into the temporary buffer:

            ySrcBottom     = min(ySrcLast, ppdev->rcl1WindowClip.bottom);

            ptlSrc.x       = pptlSrc->x;
            ptlSrc.y       = ySrcTop;

            rclDest.left   = prclDest->left;
            rclDest.top    = 0;
            rclDest.right  = prclDest->right;
            rclDest.bottom = ySrcBottom - ySrcTop;

            b &= EngCopyBits(psoTmp, pso, NULL, NULL, &rclDest, &ptlSrc);

            yDestBottom = yDestTop + rclDest.bottom;

            if (ppdev->rcl1WindowClip.top >= yDestBottom)
            {
                ppdev->pfnBankControl(ppdev, yDestBottom - 1, JustifyBottom);
                pso->pvScan0 = ppdev->pvBitmapStart;
            }

            while (TRUE)
            {
                // Copy the temporary buffer into one or more destination
                // banks:

                LONG yThisTop;
                LONG yThisBottom;
                LONG yOffset;

                yThisBottom    = min(yDestBottom, ppdev->rcl1WindowClip.bottom);
                yThisTop       = max(yDestTop, ppdev->rcl1WindowClip.top);
                yOffset        = yThisTop - yDestTop;

                ptlSrc.x       = prclDest->left;
                ptlSrc.y       = yOffset;

                rclDest.left   = prclDest->left;
                rclDest.top    = yThisTop;
                rclDest.right  = prclDest->right;
                rclDest.bottom = yThisBottom;

                b &= EngCopyBits(pso, psoTmp, pco, pxlo, &rclDest, &ptlSrc);

                if (yOffset == 0)
                    break;

                ppdev->pfnBankControl(ppdev, yThisTop - 1, JustifyBottom);
                pso->pvScan0 = ppdev->pvBitmapStart;
            }

            if (ySrcBottom >= ySrcLast)
                break;

            yDestTop = yDestBottom;
            ySrcTop  = ySrcBottom;

            ppdev->pfnBankControl(ppdev, ySrcTop, JustifyTop);
            pso->pvScan0 = ppdev->pvBitmapStart;
        }
    }
    else
    {
        ////////////////////////////////////////////////////////////////
        // Do a bottom-to-top copy:
        ////////////////////////////////////////////////////////////////

        LONG ySrcTop;
        LONG yDestTop;

        LONG yDestBottom = prclDest->bottom;
        LONG ySrcFirst   = pptlSrc->y;
        LONG ySrcBottom  = ySrcFirst + (prclDest->bottom - prclDest->top);

        if (ySrcBottom <= ppdev->rcl1WindowClip.top ||
            ySrcBottom > ppdev->rcl1WindowClip.bottom)
        {
            ppdev->pfnBankControl(ppdev, ySrcBottom - 1, JustifyBottom);
        }

        pso->pvScan0 = ppdev->pvBitmapStart;

        while (TRUE)
        {
            // Copy an entire source bank into the temporary buffer:

            ySrcTop        = max(ySrcFirst, ppdev->rcl1WindowClip.top);

            ptlSrc.x       = pptlSrc->x;
            ptlSrc.y       = ySrcTop;

            rclDest.left   = prclDest->left;
            rclDest.top    = 0;
            rclDest.right  = prclDest->right;
            rclDest.bottom = ySrcBottom - ySrcTop;

            b &= EngCopyBits(psoTmp, pso, NULL, NULL, &rclDest, &ptlSrc);

            yDestTop = yDestBottom - rclDest.bottom;

            if (ppdev->rcl1WindowClip.bottom <= yDestTop)
            {
                ppdev->pfnBankControl(ppdev, yDestTop, JustifyTop);
                pso->pvScan0 = ppdev->pvBitmapStart;
            }

            while (TRUE)
            {
                // Copy the temporary buffer into one or more destination
                // banks:

                LONG yThisTop;
                LONG yThisBottom;
                LONG yOffset;

                yThisTop       = max(yDestTop, ppdev->rcl1WindowClip.top);
                yThisBottom    = min(yDestBottom, ppdev->rcl1WindowClip.bottom);
                yOffset        = yThisTop - yDestTop;

                ptlSrc.x       = prclDest->left;
                ptlSrc.y       = yOffset;

                rclDest.left   = prclDest->left;
                rclDest.top    = yThisTop;
                rclDest.right  = prclDest->right;
                rclDest.bottom = yThisBottom;

                b &= EngCopyBits(pso, psoTmp, pco, pxlo, &rclDest, &ptlSrc);

                if (yThisBottom == yDestBottom)
                    break;

                ppdev->pfnBankControl(ppdev, yThisBottom, JustifyTop);
                pso->pvScan0 = ppdev->pvBitmapStart;
            }

            if (ySrcTop <= ySrcFirst)
                break;

            yDestBottom = yDestTop;
            ySrcBottom  = ySrcTop;

            ppdev->pfnBankControl(ppdev, ySrcBottom - 1, JustifyBottom);
            pso->pvScan0 = ppdev->pvBitmapStart;
        }
    }

    return(b);
}

/******************************Public*Routine******************************\
* BOOL bPuntScreenToScreenBitBlt(...)
*
* Performs a screen-to-screen BitBlt entirely using an intermediate temporary
* buffer and GDI.
*
* This function is basically a clone of bPuntScreenToScreenCopyBits,
* except that it can handle funky ROPs and stuff.
\**************************************************************************/

BOOL bPuntScreenToScreenBitBlt(
PPDEV     ppdev,
SURFOBJ*  psoMask,
CLIPOBJ*  pco,
XLATEOBJ* pxlo,
RECTL*    prclDest,
POINTL*   pptlSrc,
POINTL*   pptlMask,
BRUSHOBJ* pbo,
POINTL*   pptlBrush,
ROP4      rop4)
{
    RECTL    rclDest;           // Temporary destination rectangle
    POINTL   ptlSrc;            // Temporary source point
    POINTL   ptlMask;           // Temporary mask offset
    POINTL   ptlMaskAdjust;     // Adjustment for mask offset
    BOOL     b = TRUE;

    SURFOBJ* pso    = ppdev->pSurfObj;
    SURFOBJ* psoTmp = ppdev->psoTmp;

    if (psoMask != NULL)
    {
        ptlMaskAdjust.x = prclDest->left - pptlMask->x;
        ptlMaskAdjust.y = prclDest->top  - pptlMask->y;
    }

    if (prclDest->top < pptlSrc->y)
    {
        ////////////////////////////////////////////////////////////////
        // Do a top-to-bottom copy:
        ////////////////////////////////////////////////////////////////

        LONG ySrcBottom;
        LONG yDestBottom;

        LONG yDestTop = prclDest->top;
        LONG ySrcTop  = pptlSrc->y;
        LONG ySrcLast = ySrcTop + (prclDest->bottom - prclDest->top);

        if (ySrcTop <  ppdev->rcl1WindowClip.top ||
            ySrcTop >= ppdev->rcl1WindowClip.bottom)
        {
            ppdev->pfnBankControl(ppdev, ySrcTop, JustifyTop);
        }

        pso->pvScan0 = ppdev->pvBitmapStart;

        while (TRUE)
        {
            // Copy an entire source bank into the temporary buffer:

            ySrcBottom     = min(ySrcLast, ppdev->rcl1WindowClip.bottom);

            ptlSrc.x       = pptlSrc->x;
            ptlSrc.y       = ySrcTop;

            rclDest.left   = prclDest->left;
            rclDest.top    = 0;
            rclDest.right  = prclDest->right;
            rclDest.bottom = ySrcBottom - ySrcTop;

            b &= EngCopyBits(psoTmp, pso, NULL, NULL, &rclDest, &ptlSrc);

            yDestBottom = yDestTop + rclDest.bottom;

            if (ppdev->rcl1WindowClip.top >= yDestBottom)
            {
                ppdev->pfnBankControl(ppdev, yDestBottom - 1, JustifyBottom);
                pso->pvScan0 = ppdev->pvBitmapStart;
            }

            while (TRUE)
            {
                // Copy the temporary buffer into one or more destination
                // banks:

                LONG yThisTop;
                LONG yThisBottom;
                LONG yOffset;

                yThisBottom    = min(yDestBottom, ppdev->rcl1WindowClip.bottom);
                yThisTop       = max(yDestTop, ppdev->rcl1WindowClip.top);
                yOffset        = yThisTop - yDestTop;

                ptlSrc.x       = prclDest->left;
                ptlSrc.y       = yOffset;

                rclDest.left   = prclDest->left;
                rclDest.top    = yThisTop;
                rclDest.right  = prclDest->right;
                rclDest.bottom = yThisBottom;

                ptlMask.x = rclDest.left - ptlMaskAdjust.x;
                ptlMask.y = rclDest.top  - ptlMaskAdjust.y;

                b &= EngBitBlt(pso, psoTmp, psoMask, pco, pxlo, &rclDest,
                               &ptlSrc, &ptlMask, pbo, pptlBrush, rop4);

                if (yOffset == 0)
                    break;

                ppdev->pfnBankControl(ppdev, yThisTop - 1, JustifyBottom);
                pso->pvScan0 = ppdev->pvBitmapStart;
            }

            if (ySrcBottom >= ySrcLast)
                break;

            yDestTop = yDestBottom;
            ySrcTop  = ySrcBottom;

            ppdev->pfnBankControl(ppdev, ySrcTop, JustifyTop);
            pso->pvScan0 = ppdev->pvBitmapStart;
        }
    }
    else
    {
        ////////////////////////////////////////////////////////////////
        // Do a bottom-to-top copy:
        ////////////////////////////////////////////////////////////////

        LONG ySrcTop;
        LONG yDestTop;

        LONG yDestBottom = prclDest->bottom;
        LONG ySrcFirst   = pptlSrc->y;
        LONG ySrcBottom  = ySrcFirst + (prclDest->bottom - prclDest->top);

        if (ySrcBottom <= ppdev->rcl1WindowClip.top ||
            ySrcBottom > ppdev->rcl1WindowClip.bottom)
        {
            ppdev->pfnBankControl(ppdev, ySrcBottom - 1, JustifyBottom);
        }

        pso->pvScan0 = ppdev->pvBitmapStart;

        while (TRUE)
        {
            // Copy an entire source bank into the temporary buffer:

            ySrcTop        = max(ySrcFirst, ppdev->rcl1WindowClip.top);

            ptlSrc.x       = pptlSrc->x;
            ptlSrc.y       = ySrcTop;

            rclDest.left   = prclDest->left;
            rclDest.top    = 0;
            rclDest.right  = prclDest->right;
            rclDest.bottom = ySrcBottom - ySrcTop;

            b &= EngCopyBits(psoTmp, pso, NULL, NULL, &rclDest, &ptlSrc);

            yDestTop = yDestBottom - rclDest.bottom;

            if (ppdev->rcl1WindowClip.bottom <= yDestTop)
            {
                ppdev->pfnBankControl(ppdev, yDestTop, JustifyTop);
                pso->pvScan0 = ppdev->pvBitmapStart;
            }

            while (TRUE)
            {
                // Copy the temporary buffer into one or more destination
                // banks:

                LONG yThisTop;
                LONG yThisBottom;
                LONG yOffset;

                yThisTop       = max(yDestTop, ppdev->rcl1WindowClip.top);
                yThisBottom    = min(yDestBottom, ppdev->rcl1WindowClip.bottom);
                yOffset        = yThisTop - yDestTop;

                ptlSrc.x       = prclDest->left;
                ptlSrc.y       = yOffset;

                rclDest.left   = prclDest->left;
                rclDest.top    = yThisTop;
                rclDest.right  = prclDest->right;
                rclDest.bottom = yThisBottom;

                ptlMask.x = rclDest.left - ptlMaskAdjust.x;
                ptlMask.y = rclDest.top  - ptlMaskAdjust.y;

                b &= EngBitBlt(pso, psoTmp, psoMask, pco, pxlo, &rclDest,
                               &ptlSrc, &ptlMask, pbo, pptlBrush, rop4);

                if (yThisBottom == yDestBottom)
                    break;

                ppdev->pfnBankControl(ppdev, yThisBottom, JustifyTop);
                pso->pvScan0 = ppdev->pvBitmapStart;
            }

            if (ySrcTop <= ySrcFirst)
                break;

            yDestBottom = yDestTop;
            ySrcBottom  = ySrcTop;

            ppdev->pfnBankControl(ppdev, ySrcBottom - 1, JustifyBottom);
            pso->pvScan0 = ppdev->pvBitmapStart;
        }
    }

    return(b);
}

/******************************Public*Data*********************************\
* ROP to mix translation table
*
* Table to translate ternary raster ops to mixes (binary raster ops). Ternary
* raster ops that can't be translated to mixes are translated to 0 (0 is not
* a valid mix).
*
\**************************************************************************/

UCHAR jRop3ToMix[256] = {
    R2_BLACK, 0, 0, 0, 0, R2_NOTMERGEPEN, 0, 0,
    0, 0, R2_MASKNOTPEN, 0, 0, 0, 0, R2_NOTCOPYPEN,
    0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0,
    R2_MASKPENNOT, 0, 0, 0, 0, R2_NOT, 0, 0,
    0, 0, R2_XORPEN, 0, 0, 0, 0, R2_NOTMASKPEN,
    0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0,
    R2_MASKPEN, 0, 0, 0, 0, R2_NOTXORPEN, 0, 0,
    0, 0, R2_NOP, 0, 0, 0, 0, R2_MERGENOTPEN,
    0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0,
    R2_COPYPEN, 0, 0, 0, 0, R2_MERGEPENNOT, 0, 0,
    0, 0, R2_MERGEPEN, 0, 0, 0, 0, R2_WHITE
};

/******************************Public*Routine******************************\
* BOOL DrvBitBlt(psoDest, psoSrc, psoMask, pco, pxlo, prclDest, pptlSrc,
*                pptlMask, pbo, pptlBrush, rop4)
*
* This routine will handle any blit.  Perhaps glacially, but it will be
* handled.
\**************************************************************************/

BOOL DrvBitBlt(
SURFOBJ*  psoDest,
SURFOBJ*  psoSrc,
SURFOBJ*  psoMask,
CLIPOBJ*  pco,
XLATEOBJ* pxlo,
RECTL*    prclDest,
POINTL*   pptlSrc,
POINTL*   pptlMask,
BRUSHOBJ* pbo,
POINTL*   pptlBrush,
ROP4      rop4)
{
    BOOL     b;
    POINTL   ptlSrc;
    RECTL    rclDest;
    PPDEV    ppdev;
    SURFOBJ* pso;
    BYTE     jClipping;
    RECTL    rclTmp;
    POINTL   ptlTmp;
    BBENUM   bben;          // Clip enumerator
    BOOL     bMore;         // Clip continuation flag
    POINTL   ptlMask;       // Temporary mask for engine call-backs
    POINTL   ptlMaskAdjust; // Adjustment for mask
    INT      iCopyDir;

    // Set up the clipping type
    if (pco == (CLIPOBJ *) NULL) {
        // No CLIPOBJ provided, so we don't have to worry about clipping
        jClipping = DC_TRIVIAL;
    } else {
        // Use the CLIPOBJ-provided clipping
        jClipping = pco->iDComplexity;
    }

    // Get the correct surface object for the target and the source

    if (psoDest->iType == STYPE_DEVICE) {

        if ((psoSrc != NULL) && (psoSrc->iType == STYPE_DEVICE)) {

            ////////////////////////////////////////////////////////////////
            // BitBlt screen-to-screen:
            ////////////////////////////////////////////////////////////////

            ppdev = (PPDEV) psoDest->dhsurf;

            // See if we can do a simple CopyBits:

            if (rop4 == 0x0000CCCC)
            {
                ppdev = (PPDEV) psoDest->dhsurf;

                // We can handle quadpixel-aligned screen-to-screen blts with
                // no translation:

                if ((((pptlSrc->x ^ prclDest->left) & 1) == 0) &&
                    (ppdev->fl & DRIVER_PLANAR_CAPABLE) &&
                    ((pxlo == NULL) || (pxlo->flXlate & XO_TRIVIAL)))
                {
                    switch(jClipping)
                    {
                    case DC_TRIVIAL:
                        vPlanarCopyBits(ppdev, prclDest, pptlSrc);
                        return(TRUE);

                    case DC_RECT:

                        // Clip the target rectangle to the clip rectangle:

                        if (!bIntersectRect(&rclTmp, prclDest, &pco->rclBounds))
                        {
                            DISPDBG((0, "DrvBitBlt: Nothing to draw."));
                            return(TRUE);
                        }

                        ptlTmp.x = pptlSrc->x + rclTmp.left - prclDest->left;
                        ptlTmp.y = pptlSrc->y + rclTmp.top  - prclDest->top;

                        vPlanarCopyBits(ppdev, &rclTmp, &ptlTmp);
                        return(TRUE);

                    case DC_COMPLEX:
                        if (pptlSrc->y >= prclDest->top)
                        {
                            if (pptlSrc->x >= prclDest->left)
                                iCopyDir = CD_RIGHTDOWN;
                            else
                                iCopyDir = CD_LEFTDOWN;
                        }
                        else
                        {
                            if (pptlSrc->x >= prclDest->left)
                                iCopyDir = CD_RIGHTUP;
                            else
                                iCopyDir = CD_LEFTUP;
                        }

                        CLIPOBJ_cEnumStart(pco, FALSE, CT_RECTANGLES, iCopyDir, 0);

                        do {
                            RECTL* prcl;
                            RECTL* prclEnd;

                            bMore = CLIPOBJ_bEnum(pco, (ULONG) sizeof(bben),
                                                  (PVOID) &bben);

                            prclEnd = &bben.arcl[bben.c];
                            for (prcl = bben.arcl; prcl < prclEnd; prcl++)
                            {
                                if (bIntersectRect(prcl, prclDest, prcl))
                                {
                                    ptlTmp.x = pptlSrc->x + prcl->left - prclDest->left;
                                    ptlTmp.y = pptlSrc->y + prcl->top  - prclDest->top;

                                    vPlanarCopyBits(ppdev, prcl, &ptlTmp);
                                }
                            }
                        } while (bMore);

                        return(TRUE);
                    }
                }

                // Can't handle in hardware, so punt:

                return(bPuntScreenToScreenCopyBits(ppdev,
                                                   pco,
                                                   pxlo,
                                                   prclDest,
                                                   pptlSrc));
            }

            // It's more complicated than a CopyBits, so punt it:

            return(bPuntScreenToScreenBitBlt(ppdev,
                                             psoMask,
                                             pco,
                                             pxlo,
                                             prclDest,
                                             pptlSrc,
                                             pptlMask,
                                             pbo,
                                             pptlBrush,
                                             rop4));
        }

        ////////////////////////////////////////////////////////////////
        // BitBlt to screen:
        ////////////////////////////////////////////////////////////////

        ppdev = (PPDEV) psoDest->dhsurf;

        // Punt the memory-to-screen call back to the engine:

        if (psoMask != NULL)
        {
            ptlMaskAdjust.x = prclDest->left - pptlMask->x;
            ptlMaskAdjust.y = prclDest->top  - pptlMask->y;
        }

        pso = ppdev->pSurfObj;

        vBankStartBltDest(ppdev, pso, pptlSrc, prclDest, &ptlSrc, &rclDest);

        do {
            ptlMask.x = rclDest.left - ptlMaskAdjust.x;
            ptlMask.y = rclDest.top  - ptlMaskAdjust.y;

            b = EngBitBlt(pso,
                          psoSrc,
                          psoMask,
                          pco,
                          pxlo,
                          &rclDest,
                          &ptlSrc,
                          &ptlMask,
                          pbo,
                          pptlBrush,
                          rop4);

        } while (b && bBankEnumBltDest(ppdev, pso, pptlSrc, prclDest,
                                       &ptlSrc, &rclDest));

        return(b);
    }
    else if ((psoSrc != NULL) && (psoSrc->iType == STYPE_DEVICE))
    {
        ////////////////////////////////////////////////////////////////
        // BitBlt from screen:
        ////////////////////////////////////////////////////////////////

        if (psoMask != NULL)
        {
            ptlMaskAdjust.x = prclDest->left - pptlMask->x;
            ptlMaskAdjust.y = prclDest->top  - pptlMask->y;
        }

        ppdev = (PPDEV) psoSrc->dhsurf;
        pso   = ppdev->pSurfObj;

        vBankStartBltSrc(ppdev, pso, pptlSrc, prclDest, &ptlSrc, &rclDest);

        do {
            ptlMask.x = rclDest.left - ptlMaskAdjust.x;
            ptlMask.y = rclDest.top  - ptlMaskAdjust.y;

            b = EngBitBlt(psoDest,
                          pso,
                          psoMask,
                          pco,
                          pxlo,
                          &rclDest,
                          &ptlSrc,
                          &ptlMask,
                          pbo,
                          pptlBrush,
                          rop4);

        } while (b && bBankEnumBltSrc(ppdev, pso, pptlSrc, prclDest,
                                      &ptlSrc, &rclDest));

        return(b);
    }

    RIP("Got a funky format?");
    return(FALSE);
}

/***************************************************************************\
* DrvCopyBits
\***************************************************************************/

BOOL DrvCopyBits(
SURFOBJ*  psoDest,
SURFOBJ*  psoSrc,
CLIPOBJ*  pco,
XLATEOBJ* pxlo,
RECTL*    prclDest,
POINTL*   pptlSrc)
{
    BOOL     b;
    POINTL   ptlSrc;
    RECTL    rclDest;
    PPDEV    ppdev;
    SURFOBJ* pso;
    BBENUM   bben;
    BOOL     bMore;
    BYTE     jClipping;
    POINTL   ptlTmp;
    RECTL    rclTmp;
    INT      iCopyDir;

    // Get the correct surface object for the target and the source

    if (psoDest->iType == STYPE_DEVICE)
    {
        // We have to special case screen-to-screen operations:

        if ((psoSrc != NULL) && (psoSrc->iType == STYPE_DEVICE))
        {

            ////////////////////////////////////////////////////////////////
            // CopyBits screen-to-screen:
            ////////////////////////////////////////////////////////////////

            ppdev = (PPDEV) psoDest->dhsurf;

            // We check to see if we can do a planar copy, because usually
            // it will be faster.  But the hardware has to be capable of
            // doing it, and the source and destination must be 4-pel
            // aligned.

            if ((((pptlSrc->x ^ prclDest->left) & 1) == 0) &&
                (ppdev->fl & DRIVER_PLANAR_CAPABLE) &&
                ((pxlo == NULL) || (pxlo->flXlate & XO_TRIVIAL)))
            {
                jClipping = (pco != NULL) ? pco->iDComplexity : DC_TRIVIAL;

                switch(jClipping)
                {
                case DC_TRIVIAL:
                    vPlanarCopyBits(ppdev, prclDest, pptlSrc);
                    return(TRUE);

                case DC_RECT:
                    // Clip the target rectangle to the clip rectangle:

                    if (!bIntersectRect(&rclTmp, prclDest, &pco->rclBounds))
                    {
                        DISPDBG((0, "DrvCopyBits: Nothing to draw."));
                        return(TRUE);
                    }

                    ptlTmp.x = pptlSrc->x + rclTmp.left - prclDest->left;
                    ptlTmp.y = pptlSrc->y + rclTmp.top  - prclDest->top;

                    vPlanarCopyBits(ppdev, &rclTmp, &ptlTmp);
                    return(TRUE);

                case DC_COMPLEX:
                    if (pptlSrc->y >= prclDest->top)
                    {
                        if (pptlSrc->x >= prclDest->left)
                            iCopyDir = CD_RIGHTDOWN;
                        else
                            iCopyDir = CD_LEFTDOWN;
                    }
                    else
                    {
                        if (pptlSrc->x >= prclDest->left)
                            iCopyDir = CD_RIGHTUP;
                        else
                            iCopyDir = CD_LEFTUP;
                    }

                    CLIPOBJ_cEnumStart(pco, FALSE, CT_RECTANGLES, iCopyDir, 0);

                    do {
                        RECTL* prcl;
                        RECTL* prclEnd;

                        bMore = CLIPOBJ_bEnum(pco, (ULONG) sizeof(bben),
                                              (PVOID) &bben);

                        prclEnd = &bben.arcl[bben.c];
                        for (prcl = bben.arcl; prcl < prclEnd; prcl++)
                        {
                            if (bIntersectRect(prcl, prclDest, prcl))
                            {
                                ptlTmp.x = pptlSrc->x + prcl->left - prclDest->left;
                                ptlTmp.y = pptlSrc->y + prcl->top  - prclDest->top;

                                vPlanarCopyBits(ppdev, prcl, &ptlTmp);
                            }
                        }
                    } while (bMore);

                    return(TRUE);
                }
            }

            return(bPuntScreenToScreenCopyBits(ppdev,
                                               pco,
                                               pxlo,
                                               prclDest,
                                               pptlSrc));
        }

        ppdev = (PPDEV) psoDest->dhsurf;

        // Fall back to the engine:

        pso = ppdev->pSurfObj;
        vBankStartBltDest(ppdev, pso, pptlSrc, prclDest, &ptlSrc, &rclDest);

        do {
            b = EngCopyBits(pso,
                            psoSrc,
                            pco,
                            pxlo,
                            &rclDest,
                            &ptlSrc);

        } while (b && bBankEnumBltDest(ppdev, pso, pptlSrc, prclDest,
                                       &ptlSrc, &rclDest));

        return(b);
    }
    else if ((psoSrc != NULL) && (psoSrc->iType == STYPE_DEVICE))
    {
        ////////////////////////////////////////////////////////////////
        // CopyBits from screen:
        ////////////////////////////////////////////////////////////////

        ppdev = (PPDEV) psoSrc->dhsurf;
        pso   = ppdev->pSurfObj;

        vBankStartBltSrc(ppdev, pso, pptlSrc, prclDest, &ptlSrc, &rclDest);

        do {
            b = EngCopyBits(psoDest,
                            pso,
                            pco,
                            pxlo,
                            &rclDest,
                            &ptlSrc);

        } while (b && bBankEnumBltSrc(ppdev, pso, pptlSrc, prclDest,
                                      &ptlSrc, &rclDest));

        return(b);
    }

    /* we should never be here */
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\vga\disp\16bpp\debug.h ===
/***************************************************************************\
* Module Name: debug.h
*
* Commonly used debugging macros.
*
* Copyright (c) 1992-1995 Microsoft Corporation
\***************************************************************************/


#if DBG

VOID
DebugPrint(
    ULONG DebugPrintLevel,
    PCHAR DebugMessage,
    ...
    );

#define DISPDBG(arg) DebugPrint arg
#define RIP(x) { DebugPrint(0, x); EngDebugBreak();}
#define ASSERTVGA(x, y) if (!(x)) RIP (y)

#else

#define DISPDBG(arg)
#define RIP(x)
#define ASSERTVGA(x, y)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\vga\disp\16bpp\color.c ===
/******************************Module*Header*******************************\
* Module Name: color.c
*
* This algorithm for color dithering is patent pending and its use is
* restricted to Microsoft products and drivers for Microsoft products.
* Use in non-Microsoft products or in drivers for non-Microsoft product is
* prohibited without written permission from Microsoft.
*
* The patent application is the primary reference for the operation of the
* color dithering code.
*
* Note that in the comments and variable names, "vertex" means "vertex of
* either the inner (half intensity) or outer (full intensity) color cube."
* Vertices map to colors 0-6 and 248-255 of the Windows standard (required)
* 256-color palette, where vertices 0-6 and 248 are the vertices of the inner
* color cube, and 0 plus 249-255 are the vertices of the full color cube.
* Vertex 7 is 75% gray; this could be used in the dither, but that would break
* apps that depend on the exact Windows 3.1 dithering. This code is Window 3.1
* compatible.
*
* Copyright (c) 1992 Microsoft Corporation
\**************************************************************************/

#include "driver.h"

/**************************************************************************\
* This function takes a value from 0 - 255 and uses it to create an
* 8x8 pile of bits in the form of a 1BPP bitmap.  It can also take an
* RGB value and make an 8x8 bitmap.  These can then be used as brushes
* to simulate color unavaible on the device.
*
* For monochrome the basic algorithm is equivalent to turning on bits
* in the 8x8 array according to the following order:
*
*  00 32 08 40 02 34 10 42
*  48 16 56 24 50 18 58 26
*  12 44 04 36 14 46 06 38
*  60 28 52 20 62 30 54 22
*  03 35 11 43 01 33 09 41
*  51 19 59 27 49 17 57 25
*  15 47 07 39 13 45 05 37
*  63 31 55 23 61 29 53 21
*
* Reference: A Survey of Techniques for the Display of Continous
*            Tone Pictures on Bilevel Displays,;
*            Jarvis, Judice, & Ninke;
*            COMPUTER GRAPHICS AND IMAGE PROCESSING 5, pp 13-40, (1976)
\**************************************************************************/

#define SWAP_RB 0x00000004
#define SWAP_GB 0x00000002
#define SWAP_RG 0x00000001

#define SWAPTHEM(a,b) (ulTemp = a, a = b, b = ulTemp)

// PATTERNSIZE is the number of pixels in a dither pattern.
#define PATTERNSIZE 64

typedef union _PAL_ULONG {
    PALETTEENTRY pal;
    ULONG ul;
} PAL_ULONG;

typedef struct _VERTEX_DATA {
    ULONG ulCount;  // # of pixels in this vertex
    ULONG ulVertex; // vertex #
} VERTEX_DATA;

// Tells which row to turn a pel on in when dithering for monochrome bitmaps.
static BYTE ajByte[] = {
    0, 4, 0, 4, 2, 6, 2, 6,
    0, 4, 0, 4, 2, 6, 2, 6,
    1, 5, 1, 5, 3, 7, 3, 7,
    1, 5, 1, 5, 3, 7, 3, 7,
    0, 4, 0, 4, 2, 6, 2, 6,
    0, 4, 0, 4, 2, 6, 2, 6,
    1, 5, 1, 5, 3, 7, 3, 7,
    1, 5, 1, 5, 3, 7, 3, 7
};

// The array of monochrome bits used for monc
static BYTE ajBits[] = {
    0x80, 0x08, 0x08, 0x80, 0x20, 0x02, 0x02, 0x20,
    0x20, 0x02, 0x02, 0x20, 0x80, 0x08, 0x08, 0x80,
    0x40, 0x04, 0x04, 0x40, 0x10, 0x01, 0x01, 0x10,
    0x10, 0x01, 0x01, 0x10, 0x40, 0x04, 0x04, 0x40,
    0x40, 0x04, 0x04, 0x40, 0x10, 0x01, 0x01, 0x10,
    0x10, 0x01, 0x01, 0x10, 0x40, 0x04, 0x04, 0x40,
    0x80, 0x08, 0x08, 0x80, 0x20, 0x02, 0x02, 0x20,
    0x20, 0x02, 0x02, 0x20, 0x80, 0x08, 0x08, 0x80
};

// Translates vertices back to the original subspace. Each row is a subspace,
// as encoded in ulSymmetry, and each column is a vertex between 0 and 15.
BYTE jSwapSubSpace[8*16] = {
    0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
    0, 2, 1, 3, 4, 6, 5, 7, 8, 10, 9, 11, 12, 14, 13, 15,
    0, 1, 4, 5, 2, 3, 6, 7, 8, 9, 12, 13, 10, 11, 14, 15,
    0, 4, 1, 5, 2, 6, 3, 7, 8, 12, 9, 13, 10, 14, 11, 15,
    0, 4, 2, 6, 1, 5, 3, 7, 8, 12, 10, 14, 9, 13, 11, 15,
    0, 2, 4, 6, 1, 3, 5, 7, 8, 10, 12, 14, 9, 11, 13, 15,
    0, 4, 1, 5, 2, 6, 3, 7, 8, 12, 9, 13, 10, 14, 11, 15,
    0, 1, 4, 5, 2, 3, 6, 7, 8, 9, 12, 13, 10, 11, 14, 15,
};

// Converts a nibble value in the range 0-15 to a dword value containing the
// nibble value packed 8 times.
ULONG ulNibbleToDwordWithConvert[16] = {
    0x00000000,
    0x01010101,
    0x02020202,
    0x03030303,
    0x04040404,
    0x05050505,
    0x06060606,
    0xF8F8F8F8,
    0x07070707,
    0xF9F9F9F9,
    0xFAFAFAFA,
    0xFBFBFBFB,
    0xFCFCFCFC,
    0xFDFDFDFD,
    0xFEFEFEFE,
    0xFFFFFFFF
};

// Specifies where in the dither pattern colors should be placed in order
// of increasing intensity.
ULONG aulDitherOrder[] = {
  0, 36,  4, 32, 18, 54, 22, 50,
  2, 38,  6, 34, 16, 52, 20, 48,
  9, 45, 13, 41, 27, 63, 31, 59,
 11, 47, 15, 43, 25, 61, 29, 57,
  1, 37,  5, 33, 19, 55, 23, 51,
  3, 39,  7, 35, 17, 53, 21, 49,
  8, 44, 12, 40, 26, 62, 30, 58,
 10, 46, 14, 42, 24, 60, 28, 56,
};

// Array to convert to 256 color from 16 color. Maps from index that represents
// a 16-color vertex (color) to value that specifies the color index in the
// 256-color palette.

BYTE ajConvert[] =
{
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    248,
    7,
    249,
    250,
    251,
    252,
    253,
    254,
    255
};

/******************************Public*Routine******************************\
* DrvDitherColor
*
* Dithers an RGB color to an 8X8 approximation using the reserved VGA colors
*
\**************************************************************************/

ULONG DrvDitherColor(
IN  DHPDEV dhpdev,
IN  ULONG  iMode,
IN  ULONG  rgb,
OUT ULONG *pul)
{
    ULONG   ulGrey, ulRed, ulGre, ulBlu, ulSymmetry;
    ULONG   ulRedTemp, ulGreenTemp, ulBlueTemp, ulTemp;
    VERTEX_DATA vVertexData[4];
    VERTEX_DATA *pvVertexData;
    VERTEX_DATA *pvVertexDataEnd;
    ULONG  *pulDitherOrder;
    ULONG   ulNumPixels;
    BYTE    jColor;
    ULONG   ulColor;
    VERTEX_DATA *pvMaxVertex;
    ULONG   ulVertex0Temp, ulVertex1Temp, ulVertex2Temp, ulVertex3Temp;
    BYTE   *pjDither = (BYTE *)pul;

    // Figure out if we need a full color dither or only a monochrome dither
    if (iMode != DM_MONOCHROME) {

        // Full color dither

        // Split the color into red, green, and blue components
        ulRedTemp   = ((PAL_ULONG *)&rgb)->pal.peRed;
        ulGreenTemp   = ((PAL_ULONG *)&rgb)->pal.peGreen;
        ulBlueTemp   = ((PAL_ULONG *)&rgb)->pal.peBlue;

        // Sort the RGB so that the point is transformed into subspace 0, and
        // keep track of the swaps in ulSymmetry so we can unravel it again
        // later.  We want r >= g >= b (subspace 0).
        ulSymmetry = 0;
        if (ulBlueTemp > ulRedTemp) {
            SWAPTHEM(ulBlueTemp,ulRedTemp);
            ulSymmetry = SWAP_RB;
        }

        if (ulBlueTemp > ulGreenTemp) {
            SWAPTHEM(ulBlueTemp,ulGreenTemp);
            ulSymmetry |= SWAP_GB;
        }

        if (ulGreenTemp > ulRedTemp) {
            SWAPTHEM(ulGreenTemp,ulRedTemp);
            ulSymmetry |= SWAP_RG;
        }

        ulSymmetry <<= 4;   // for lookup purposes

        // Scale the values from 0-255 to 0-64. Note that the scaling is not
        // symmetric at the ends; this is done to match Windows 3.1 dithering
        ulRed = (ulRedTemp + 1) >> 2;
        ulGre = (ulGreenTemp + 1) >> 2;
        ulBlu = (ulBlueTemp + 1) >> 2;

        // Compute the subsubspace within subspace 0 in which the point lies,
        // then calculate the # of pixels to dither in the colors that are the
        // four vertexes of the tetrahedron bounding the color we're emulating.
        // Only vertices with more than zero pixels are stored, and the
        // vertices are stored in order of increasing intensity, saving us the
        // need to sort them later
        if ((ulRedTemp + ulGreenTemp) > 256) {
            // Subsubspace 2 or 3
            if ((ulRedTemp + ulBlueTemp) > 256) {
                // Subsubspace 3
                // Calculate the number of pixels per vertex, still in
                // subsubspace 3, then convert to original subspace. The pixel
                // counts and vertex numbers are matching pairs, stored in
                // ascending intensity order, skipping vertices with zero
                // pixels. The vertex intensity order for subsubspace 3 is:
                // 7, 9, 0x0B, 0x0F
                pvVertexData = vVertexData;
                if ((ulVertex0Temp = (64 - ulRed) << 1) != 0) {
                    pvVertexData->ulCount = ulVertex0Temp;
                    pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x07];
                }
                ulVertex2Temp = ulGre - ulBlu;
                ulVertex3Temp = (ulRed - 64) + ulBlu;
                if ((ulVertex1Temp = ((PATTERNSIZE - ulVertex0Temp) -
                        ulVertex2Temp) - ulVertex3Temp) != 0) {
                    pvVertexData->ulCount = ulVertex1Temp;
                    pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x09];
                }
                if (ulVertex2Temp != 0) {
                    pvVertexData->ulCount = ulVertex2Temp;
                    pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x0B];
                }
                if (ulVertex3Temp != 0) {
                    pvVertexData->ulCount = ulVertex3Temp;
                    pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x0F];
                }
            } else {
                // Subsubspace 2
                // Calculate the number of pixels per vertex, still in
                // subsubspace 2, then convert to original subspace. The pixel
                // counts and vertex numbers are matching pairs, stored in
                // ascending intensity order, skipping vertices with zero
                // pixels. The vertex intensity order for subsubspace 2 is:
                // 3, 7, 9, 0x0B
                pvVertexData = vVertexData;
                ulVertex1Temp = ulBlu << 1;
                ulVertex2Temp = ulRed - ulGre;
                ulVertex3Temp = (ulRed - 32) + (ulGre - 32);
                if ((ulVertex0Temp = ((PATTERNSIZE - ulVertex1Temp) -
                            ulVertex2Temp) - ulVertex3Temp) != 0) {
                    pvVertexData->ulCount = ulVertex0Temp;
                    pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x03];
                }
                if (ulVertex1Temp != 0) {
                    pvVertexData->ulCount = ulVertex1Temp;
                    pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x07];
                }
                if (ulVertex2Temp != 0) {
                    pvVertexData->ulCount = ulVertex2Temp;
                    pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x09];
                }
                if (ulVertex3Temp != 0) {
                    pvVertexData->ulCount = ulVertex3Temp;
                    pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x0B];
                }
            }
        } else {
            // Subsubspace 0 or 1
            if (ulRedTemp > 128) {
                // Subsubspace 1
                // Calculate the number of pixels per vertex, still in
                // subsubspace 1, then convert to original subspace. The pixel
                // counts and vertex numbers are matching pairs, stored in
                // ascending intensity order, skipping vertices with zero
                // pixels. The vertex intensity order for subsubspace 1 is:
                // 1, 3, 7, 9
                pvVertexData = vVertexData;
                if ((ulVertex0Temp = ((32 - ulGre) + (32 - ulRed)) << 1) != 0) {
                    pvVertexData->ulCount = ulVertex0Temp;
                    pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x01];
                }
                ulVertex2Temp = ulBlu << 1;
                ulVertex3Temp = (ulRed - 32) << 1;
                if ((ulVertex1Temp = ((PATTERNSIZE - ulVertex0Temp) -
                        ulVertex2Temp) - ulVertex3Temp) != 0) {
                    pvVertexData->ulCount = ulVertex1Temp;
                    pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x03];
                }
                if (ulVertex2Temp != 0) {
                    pvVertexData->ulCount = ulVertex2Temp;
                    pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x07];
                }
                if (ulVertex3Temp != 0) {
                    pvVertexData->ulCount = ulVertex3Temp;
                    pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x09];
                }
            } else {
                // Subsubspace 0
                // Calculate the number of pixels per vertex, still in
                // subsubspace 0, then convert to original subspace. The pixel
                // counts and vertex numbers are matching pairs, stored in
                // ascending intensity order, skipping vertices with zero
                // pixels. The vertex intensity order for subsubspace 0 is:
                // 0, 1, 3, 7
                pvVertexData = vVertexData;
                if ((ulVertex0Temp = (32 - ulRed) << 1) != 0) {
                    pvVertexData->ulCount = ulVertex0Temp;
                    pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x00];
                }
                if ((ulVertex1Temp = (ulRed - ulGre) << 1) != 0) {
                    pvVertexData->ulCount = ulVertex1Temp;
                    pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x01];
                }
                ulVertex3Temp = ulBlu << 1;
                if ((ulVertex2Temp = ((PATTERNSIZE - ulVertex0Temp) -
                        ulVertex1Temp) - ulVertex3Temp) != 0) {
                    pvVertexData->ulCount = ulVertex2Temp;
                    pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x03];
                }
                if (ulVertex3Temp != 0) {
                    pvVertexData->ulCount = ulVertex3Temp;
                    pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x07];
                }
            }
        }

        // Now that we have found the bounding vertices and the number of
        // pixels to dither for each vertex, we can create the dither pattern

        // Handle 1, 2, and 3 & 4 vertices per dither separately
        ulTemp = pvVertexData - vVertexData;    // # of vertices with more than
                                                // zero pixels
        if (ulTemp > 2) {

            // There are 3 or 4 vertices in this dither

            if (ulTemp == 3) {

                // There are 3 vertices in this dither

                // Find the vertex with the most pixels, and fill the whole
                // destination bitmap with that vertex's color, which is faster
                // than dithering it
                if (vVertexData[1].ulCount >= vVertexData[2].ulCount) {
                    pvMaxVertex = &vVertexData[1];
                    ulTemp = vVertexData[1].ulCount;
                } else {
                    pvMaxVertex = &vVertexData[2];
                    ulTemp = vVertexData[2].ulCount;
                }

            } else {

                // There are 4 vertices in this dither

                // Find the vertex with the most pixels, and fill the whole
                // destination bitmap with that vertex's color, which is faster
                // than dithering it
                if (vVertexData[2].ulCount >= vVertexData[3].ulCount) {
                    pvMaxVertex = &vVertexData[2];
                    ulTemp = vVertexData[2].ulCount;
                } else {
                    pvMaxVertex = &vVertexData[3];
                    ulTemp = vVertexData[3].ulCount;
                }
            }

            if (vVertexData[1].ulCount > ulTemp) {
                pvMaxVertex = &vVertexData[1];
                ulTemp = vVertexData[1].ulCount;
            }
            if (vVertexData[0].ulCount > ulTemp) {
                pvMaxVertex = &vVertexData[0];
            }

            pvVertexDataEnd = pvVertexData;

            // Prepare a dword version of the most common vertex number (color)
            ulColor = ulNibbleToDwordWithConvert[pvMaxVertex->ulVertex];

            // Mark that the vertex we're about to do doesn't need to be done
            // later
            pvMaxVertex->ulVertex = 0xFF;

            // Block fill the dither pattern with the more common vertex
            *pul = ulColor;
            *(pul+1) = ulColor;
            *(pul+2) = ulColor;
            *(pul+3) = ulColor;
            *(pul+4) = ulColor;
            *(pul+5) = ulColor;
            *(pul+6) = ulColor;
            *(pul+7) = ulColor;
            *(pul+8) = ulColor;
            *(pul+9) = ulColor;
            *(pul+10) = ulColor;
            *(pul+11) = ulColor;
            *(pul+12) = ulColor;
            *(pul+13) = ulColor;
            *(pul+14) = ulColor;
            *(pul+15) = ulColor;

            // Now dither all the remaining vertices in order 0->2 or 0->3
            // (in order of increasing intensity)
            pulDitherOrder = aulDitherOrder;
            pvVertexData = vVertexData;
            do {
                if (pvVertexData->ulVertex == 0xFF) {
                    // This is the max vertex, which we already did, but we
                    // have to account for it in the dither order
                    pulDitherOrder += pvVertexData->ulCount;
                } else {
                    jColor = ajConvert[pvVertexData->ulVertex];
                    ulNumPixels = pvVertexData->ulCount;
                    switch (ulNumPixels & 3) {
                        case 3:
                            pjDither[*(pulDitherOrder+2)] = jColor;
                        case 2:
                            pjDither[*(pulDitherOrder+1)] = jColor;
                        case 1:
                            pjDither[*(pulDitherOrder+0)] = jColor;
                            pulDitherOrder += ulNumPixels & 3;
                        case 0:
                            break;
                    }
                    if ((ulNumPixels >>= 2) != 0) {
                        do {
                            pjDither[*pulDitherOrder] = jColor;
                            pjDither[*(pulDitherOrder+1)] = jColor;
                            pjDither[*(pulDitherOrder+2)] = jColor;
                            pjDither[*(pulDitherOrder+3)] = jColor;
                            pulDitherOrder += 4;
                        } while (--ulNumPixels);
                    }
                }
            } while (++pvVertexData < pvVertexDataEnd);

        } else if (ulTemp == 2) {

            // There are exactly two vertices with more than zero pixels; fill
            // in the dither array as follows: block fill with vertex with more
            // points first, then dither in the other vertex
            if (vVertexData[0].ulCount >= vVertexData[1].ulCount) {
                // There are no more vertex 1 than vertex 0 pixels, so do
                // the block fill with vertex 0
                ulColor = ulNibbleToDwordWithConvert[vVertexData[0].ulVertex];
                // Do the dither with vertex 1
                jColor = ajConvert[vVertexData[1].ulVertex];
                ulNumPixels = vVertexData[1].ulCount;
                // Set where to start dithering with vertex 1 (vertex 0 is
                // lower intensity, so its pixels come first in the dither
                // order)
                pulDitherOrder = aulDitherOrder + vVertexData[0].ulCount;
            } else {
                // There are more vertex 1 pixels, so do the block fill
                // with vertex 1
                ulColor = ulNibbleToDwordWithConvert[vVertexData[1].ulVertex];
                // Do the dither with vertex 0
                jColor = ajConvert[vVertexData[0].ulVertex];
                ulNumPixels = vVertexData[0].ulCount;
                // Set where to start dithering with vertex 0 (vertex 0 is
                // lower intensity, so its pixels come first in the dither
                // order)
                pulDitherOrder = aulDitherOrder;
            }

            // Block fill the dither pattern with the more common vertex
            *pul = ulColor;
            *(pul+1) = ulColor;
            *(pul+2) = ulColor;
            *(pul+3) = ulColor;
            *(pul+4) = ulColor;
            *(pul+5) = ulColor;
            *(pul+6) = ulColor;
            *(pul+7) = ulColor;
            *(pul+8) = ulColor;
            *(pul+9) = ulColor;
            *(pul+10) = ulColor;
            *(pul+11) = ulColor;
            *(pul+12) = ulColor;
            *(pul+13) = ulColor;
            *(pul+14) = ulColor;
            *(pul+15) = ulColor;

            // Dither in the less common vertex
            switch (ulNumPixels & 3) {
                case 3:
                    pjDither[*(pulDitherOrder+2)] = jColor;
                case 2:
                    pjDither[*(pulDitherOrder+1)] = jColor;
                case 1:
                    pjDither[*(pulDitherOrder+0)] = jColor;
                    pulDitherOrder += ulNumPixels & 3;
                case 0:
                    break;
            }
            if ((ulNumPixels >>= 2) != 0) {
                do {
                    pjDither[*pulDitherOrder] = jColor;
                    pjDither[*(pulDitherOrder+1)] = jColor;
                    pjDither[*(pulDitherOrder+2)] = jColor;
                    pjDither[*(pulDitherOrder+3)] = jColor;
                    pulDitherOrder += 4;
                } while (--ulNumPixels);
            }

        } else {

            // There is only one vertex in this dither

            // No sorting or dithering is needed for just one color; we can
            // just generate the final DIB directly
            ulColor = ulNibbleToDwordWithConvert[vVertexData[0].ulVertex];
            *pul = ulColor;
            *(pul+1) = ulColor;
            *(pul+2) = ulColor;
            *(pul+3) = ulColor;
            *(pul+4) = ulColor;
            *(pul+5) = ulColor;
            *(pul+6) = ulColor;
            *(pul+7) = ulColor;
            *(pul+8) = ulColor;
            *(pul+9) = ulColor;
            *(pul+10) = ulColor;
            *(pul+11) = ulColor;
            *(pul+12) = ulColor;
            *(pul+13) = ulColor;
            *(pul+14) = ulColor;
            *(pul+15) = ulColor;
        }

    } else {

        // For monochrome we will only use the Intensity (grey level)
        RtlFillMemory((PVOID) pul, PATTERNSIZE/2, 0);  // zero the dither bits

        ulRed   = (ULONG) ((PALETTEENTRY *) &rgb)->peRed;
        ulGre = (ULONG) ((PALETTEENTRY *) &rgb)->peGreen;
        ulBlu  = (ULONG) ((PALETTEENTRY *) &rgb)->peBlue;

        // I = .30R + .59G + .11B
        // For convience the following ratios are used:
        //
        //  77/256 = 30.08%
        // 151/256 = 58.98%
        //  28/256 = 10.94%

        ulGrey  = (((ulRed * 77) + (ulGre * 151) + (ulBlu * 28)) >> 8) & 255;

        // Convert the RGBI from 0-255 to 0-64 notation.

        ulGrey = (ulGrey + 1) >> 2;

        while(ulGrey) {
            ulGrey--;
            pul[ajByte[ulGrey]] |= ((ULONG) ajBits[ulGrey]);
        }
    }

    return(DCR_DRIVER);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\vga\disp\16bpp\debug.c ===
/******************************Module*Header*******************************\
* Module Name: debug.c
*
* debug helpers routine
*
* Copyright (c) 1992-1995 Microsoft Corporation
*
\**************************************************************************/

#include "driver.h"

#if DBG

ULONG DebugLevel = 0;

/*****************************************************************************
 *
 *   Routine Description:
 *
 *      This function is variable-argument, level-sensitive debug print
 *      routine.
 *      If the specified debug level for the print statement is lower or equal
 *      to the current debug level, the message will be printed.
 *
 *   Arguments:
 *
 *      DebugPrintLevel - Specifies at which debugging level the string should
 *          be printed
 *
 *      DebugMessage - Variable argument ascii c string
 *
 *   Return Value:
 *
 *      None.
 *
 ***************************************************************************/

VOID
DebugPrint(
    ULONG DebugPrintLevel,
    PCHAR DebugMessage,
    ...
    )

{

    va_list ap;

    va_start(ap, DebugMessage);

    if (DebugPrintLevel <= DebugLevel)
    {
        EngDebugPrint(STANDARD_DEBUG_PREFIX, DebugMessage, ap);
    }

    va_end(ap);

}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\vga\disp\16bpp\bankmgr.c ===
/*****************************************************************************\
* Smart 64k Color Bank Manager
*
* Copyright (c) 1992 Microsoft Corporation
\*****************************************************************************/

#include "driver.h"

/*****************************************************************************\
* pcoBankStart - Start the bank enumeration using the clip object.
*
* Used when the destination is the screen and we can't do the clipping
* ourselves (as we can for blt's).
\*****************************************************************************/

CLIPOBJ* pcoBankStart(
    PPDEV       ppdev,
    RECTL*      prclScans,
    SURFOBJ*    pso,
    CLIPOBJ*    pco)
{
    LONG iTopScan;

    // Remember what the last scan is that we're going to, and
    // make sure we only try to go as far as we need to.  It could
    // happen that when get a prclScans bigger than the screen:

    ppdev->iLastScan = min(prclScans->bottom, (LONG) ppdev->cyScreen);

    // Adjust for those weird cases where we're asked to start enumerating
    // above or below the bottom of the screen:

    iTopScan = max(0, prclScans->top);
    iTopScan = min(iTopScan, (LONG) ppdev->cyScreen - 1);

    if (pco->iDComplexity != DC_TRIVIAL)
    {
        iTopScan         = max(pco->rclBounds.top,    iTopScan);
        ppdev->iLastScan = min(pco->rclBounds.bottom, ppdev->iLastScan);
    }

    // Map in the top bank:

    if (iTopScan <  ppdev->rcl1WindowClip.top ||
        iTopScan >= ppdev->rcl1WindowClip.bottom)
    {
        ppdev->pfnBankControl(ppdev, iTopScan, JustifyTop);
    }

    pso->pvScan0 = ppdev->pvBitmapStart;

    if ((pco == NULL) || (pco->iDComplexity == DC_TRIVIAL))
    {
        // The call may have come down to us as having no clipping, but
        // we have to clip to the banks, so use our own clip object:

        pco            = ppdev->pcoNull;
        pco->rclBounds = ppdev->rcl1WindowClip;

        ASSERTVGA(pco->fjOptions & OC_BANK_CLIP, "Default BANK_CLIP not set");
        ASSERTVGA(pco->iDComplexity == DC_RECT, "Default clip not DC_RECT");
    }
    else
    {
        // Save the engine's clip object data that we'll be tromping on:

        ppdev->rclSaveBounds    = pco->rclBounds;
        ppdev->iSaveDComplexity = pco->iDComplexity;
        ppdev->fjSaveOptions    = pco->fjOptions;

        // Let engine know it has to pay attention to the rclBounds of the
        // clip object:

        pco->fjOptions |= OC_BANK_CLIP;

        // Use the bank bounds if they are tighter than the existing
        // bounds.

        if (pco->rclBounds.top <= ppdev->rcl1WindowClip.top)
            pco->rclBounds.top = ppdev->rcl1WindowClip.top;

        if (pco->rclBounds.bottom >= ppdev->rcl1WindowClip.bottom)
            pco->rclBounds.bottom = ppdev->rcl1WindowClip.bottom;

        if ((pco->rclBounds.top  >= pco->rclBounds.bottom) ||
            (pco->rclBounds.left >= pco->rclBounds.right))
        {
            // It's conceivable that we could get a situation where our
            // draw rectangle is completely disjoint from the specified
            // rectangle's rclBounds.  Make sure we don't puke on our
            // shoes:

            pco->rclBounds.left   = 0;
            pco->rclBounds.top    = 0;
            pco->rclBounds.right  = 0;
            pco->rclBounds.bottom = 0;
            ppdev->iLastScan      = 0;
        }
    }

    return(pco);
}

/*****************************************************************************\
* bBankEnum - Continue the bank enumeration.
\*****************************************************************************/

BOOL bBankEnum(PPDEV ppdev, SURFOBJ* pso, CLIPOBJ* pco)
{
    LONG yNewTop = ppdev->rcl1WindowClip.bottom;

    if (yNewTop >= ppdev->iLastScan)
    {
        // Okay, that was the last bank, so restore our structures:

        if (pco != ppdev->pcoNull)
        {
            pco->rclBounds    = ppdev->rclSaveBounds;
            pco->iDComplexity = ppdev->iSaveDComplexity;
            pco->fjOptions    = ppdev->fjSaveOptions;
        }

        return(FALSE);
    }

    ppdev->pfnBankControl(ppdev, yNewTop, JustifyTop);

    ASSERTVGA(yNewTop >= ppdev->rcl1WindowClip.top &&
              yNewTop <  ppdev->rcl1WindowClip.bottom, "Out of bounds");

    // Adjust the pvScan0 because we've moved the window to view
    // a different area:

    pso->pvScan0 = ppdev->pvBitmapStart;

    // Set the bounds to the new bank:

    pco->rclBounds.top    = yNewTop;
    pco->rclBounds.left   = ppdev->rcl1WindowClip.left;
    pco->rclBounds.bottom = ppdev->rcl1WindowClip.bottom;
    pco->rclBounds.right  = ppdev->rcl1WindowClip.right;

    if (pco != ppdev->pcoNull)
    {
        // If we were originally given a non-trivial clip object, we have
        // to clip to the original bounds:

        if (pco->rclBounds.left <= ppdev->rclSaveBounds.left)
            pco->rclBounds.left  = ppdev->rclSaveBounds.left;

        if (pco->rclBounds.right >= ppdev->rclSaveBounds.right)
            pco->rclBounds.right  = ppdev->rclSaveBounds.right;

        if (pco->rclBounds.bottom >= ppdev->rclSaveBounds.bottom)
            pco->rclBounds.bottom  = ppdev->rclSaveBounds.bottom;
    }

    return(TRUE);
}

/***************************************************************************\
* vBankStartBltSrc - Start the bank enumeration for when the screen is
*                   the source.
\***************************************************************************/

VOID vBankStartBltSrc(
    PPDEV       ppdev,
    SURFOBJ*    pso,
    POINTL*     pptlSrc,
    RECTL*      prclDest,
    POINTL*     pptlNewSrc,
    RECTL*      prclNewDest)
{
    LONG xRightSrc;
    LONG yBottomSrc;
    LONG iTopScan = max(0, pptlSrc->y);

    if (iTopScan >= (LONG) ppdev->cyScreen)
    {
    // In some instances we may be asked to start on a scan below the screen.
    // Since we obviously won't be drawing anything, don't bother mapping in
    // a bank:

        return;
    }

    // Map in the bank:

    if (iTopScan <  ppdev->rcl1WindowClip.top ||
        iTopScan >= ppdev->rcl1WindowClip.bottom)
    {
        ppdev->pfnBankControl(ppdev, iTopScan, JustifyTop);
    }

    if (ppdev->rcl1WindowClip.right <= pptlSrc->x)
    {
    // We have to watch out for those rare cases where we're starting
    // on a broken raster and we won't be drawing on the first part:

        ASSERTVGA(ppdev->flBank & BANK_BROKEN_RASTER1, "Weird start bounds");

        ppdev->pfnBankNext(ppdev);
    }

    pso->pvScan0 = ppdev->pvBitmapStart;

    // Adjust the source:

    pptlNewSrc->x = pptlSrc->x;
    pptlNewSrc->y = pptlSrc->y;

    // Adjust the destination:

    prclNewDest->left = prclDest->left;
    prclNewDest->top  = prclDest->top;

    yBottomSrc = pptlSrc->y + prclDest->bottom - prclDest->top;
    prclNewDest->bottom = min(ppdev->rcl1WindowClip.bottom, yBottomSrc);
    prclNewDest->bottom += prclDest->top - pptlSrc->y;

    xRightSrc = pptlSrc->x + prclDest->right - prclDest->left;
    prclNewDest->right = min(ppdev->rcl1WindowClip.right, xRightSrc);
    prclNewDest->right += prclDest->left - pptlSrc->x;
}

/***************************************************************************\
* bBankEnumBltSrc - Continue the bank enumeration for when the screen is
*                   the source.
\***************************************************************************/

BOOL bBankEnumBltSrc(
    PPDEV       ppdev,
    SURFOBJ*    pso,
    POINTL*     pptlSrc,
    RECTL*      prclDest,
    POINTL*     pptlNewSrc,
    RECTL*      prclNewDest)
{
    LONG xLeftSrc;
    LONG xRightSrc;
    LONG yBottomSrc;

    LONG cx = prclDest->right  - prclDest->left;
    LONG cy = prclDest->bottom - prclDest->top;

    LONG dx;
    LONG dy;

    LONG yBottom = min(pptlSrc->y + cy, (LONG) ppdev->cyScreen);
    LONG yNewTop = ppdev->rcl1WindowClip.bottom;

    if (ppdev->flBank & BANK_BROKEN_RASTER1)
    {
        ppdev->pfnBankNext(ppdev);
        if (ppdev->rcl1WindowClip.left >= pptlSrc->x + cx)
        {
            if (ppdev->rcl1WindowClip.bottom < yBottom)
                ppdev->pfnBankNext(ppdev);
            else
            {
                // We're done:

                return(FALSE);
            }
        }
    }
    else if (yNewTop < yBottom)
    {
        ppdev->pfnBankControl(ppdev, yNewTop, JustifyTop);
        if (ppdev->rcl1WindowClip.right <= pptlSrc->x)
        {
            ASSERTVGA(ppdev->flBank & BANK_BROKEN_RASTER1, "Weird bounds");
            ppdev->pfnBankNext(ppdev);
        }
    }
    else
    {
        // We're done:

        return(FALSE);
    }

    // Adjust the source:

    pso->pvScan0 = ppdev->pvBitmapStart;

    pptlNewSrc->x = max(ppdev->rcl1WindowClip.left, pptlSrc->x);
    pptlNewSrc->y = yNewTop;

    // Adjust the destination:

    dy = prclDest->top - pptlSrc->y;        // y delta from source to dest

    prclNewDest->top = yNewTop + dy;

    yBottomSrc = pptlSrc->y + cy;
    prclNewDest->bottom = min(ppdev->rcl1WindowClip.bottom, yBottomSrc) + dy;

    dx = prclDest->left - pptlSrc->x;       // x delta from source to dest

    xLeftSrc = pptlSrc->x;
    prclNewDest->left = pptlNewSrc->x + dx;

    xRightSrc = pptlSrc->x + cx;
    prclNewDest->right = min(ppdev->rcl1WindowClip.right, xRightSrc) + dx;

    return(TRUE);
}

/***************************************************************************\
* vBankStartBltDest - Start the bank enumeration for when the screen is
*                     the destination.
\***************************************************************************/

VOID vBankStartBltDest(
    PPDEV       ppdev,
    SURFOBJ*    pso,
    POINTL*     pptlSrc,
    RECTL*      prclDest,
    POINTL*     pptlNewSrc,
    RECTL*      prclNewDest)
{
    LONG iTopScan = max(0, prclDest->top);

    if (iTopScan >= (LONG) ppdev->cyScreen)
    {
    // In some instances we may be asked to start on a scan below the screen.
    // Since we obviously won't be drawing anything, don't bother mapping in
    // a bank:

        return;
    }

    // Map in the bank:

    if (iTopScan <  ppdev->rcl1WindowClip.top ||
        iTopScan >= ppdev->rcl1WindowClip.bottom)
    {
        ppdev->pfnBankControl(ppdev, iTopScan, JustifyTop);
    }

    if (ppdev->rcl1WindowClip.right <= prclDest->left)
    {
    // We have to watch out for those rare cases where we're starting
    // on a broken raster and we won't be drawing on the first part:

        ASSERTVGA(ppdev->flBank & BANK_BROKEN_RASTER1, "Weird start bounds");
        ppdev->pfnBankNext(ppdev);
    }

    pso->pvScan0 = ppdev->pvBitmapStart;

    // Adjust the destination:

    prclNewDest->left   = prclDest->left;
    prclNewDest->top    = prclDest->top;
    prclNewDest->bottom = min(ppdev->rcl1WindowClip.bottom, prclDest->bottom);
    prclNewDest->right  = min(ppdev->rcl1WindowClip.right,  prclDest->right);

    // Adjust the source if there is one:

    if (pptlSrc != NULL)
        *pptlNewSrc = *pptlSrc;
}

/***************************************************************************\
* bBankEnumBltDest - Continue the bank enumeration for when the screen is
*                   the destination.
\***************************************************************************/

BOOL bBankEnumBltDest(
    PPDEV       ppdev,
    SURFOBJ*    pso,
    POINTL*     pptlSrc,
    RECTL*      prclDest,
    POINTL*     pptlNewSrc,
    RECTL*      prclNewDest)
{
    LONG yBottom = min(prclDest->bottom, (LONG) ppdev->cyScreen);
    LONG yNewTop = ppdev->rcl1WindowClip.bottom;

    if (ppdev->flBank & BANK_BROKEN_RASTER1)
    {
        ppdev->pfnBankNext(ppdev);
        if (ppdev->rcl1WindowClip.left >= prclDest->right)
        {
            if (ppdev->rcl1WindowClip.bottom < yBottom)
                ppdev->pfnBankNext(ppdev);
            else
            {
                // We're done:

                return(FALSE);
            }
        }
    }
    else if (yNewTop < yBottom)
    {
        ppdev->pfnBankControl(ppdev, yNewTop, JustifyTop);
        if (ppdev->rcl1WindowClip.right <= prclDest->left)
        {
            ASSERTVGA(ppdev->flBank & BANK_BROKEN_RASTER1, "Weird bounds");
            ppdev->pfnBankNext(ppdev);
        }
    }
    else
    {
        // We're done:

        return(FALSE);
    }

    pso->pvScan0 = ppdev->pvBitmapStart;

    // Adjust the destination:

    prclNewDest->top    = yNewTop;
    prclNewDest->left   = max(ppdev->rcl1WindowClip.left,   prclDest->left);
    prclNewDest->bottom = min(ppdev->rcl1WindowClip.bottom, prclDest->bottom);
    prclNewDest->right  = min(ppdev->rcl1WindowClip.right,  prclDest->right);

    // Adjust the source if there is one:

    if (pptlSrc != NULL)
    {
        pptlNewSrc->x = pptlSrc->x + (prclNewDest->left - prclDest->left);
        pptlNewSrc->y = pptlSrc->y + (prclNewDest->top  - prclDest->top);
    }

    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\vga\disp\16bpp\driver.h ===
/******************************Module*Header*******************************\
* Module Name: driver.h
*
* Contains prototypes for the 64k color VGA driver.
*
* NOTE: Must mirror driver.inc!
*
* Copyright (c) 1992 Microsoft Corporation
\**************************************************************************/

#ifndef _DRIVER_
#define _DRIVER_

#include "stdlib.h"
#include "stddef.h"
#include "windows.h"
#include "winddi.h"
#include "devioctl.h"
#include "ntddvdeo.h"

#include "debug.h"

typedef struct _PDEV PDEV, *PPDEV;

//
// A mode requires broken rasters if the stride is a power of 2 and the video ram
// accessed is greater than 64K.
//

#define POW2(stride) (!((stride) & ((stride)-1)))   // TRUE if stride is power of 2
#define BROKEN_RASTERS(stride,cy) ((!(POW2(stride))) && ((stride*cy) > 0x10000))

//
// Sizes assumed for 1-window and 2 RW-window banks.
//

#define BANK_SIZE_1_WINDOW      0x10000L
#define BANK_SIZE_2RW_WINDOW    0x08000L

//
// Temporary buffer must be at least as large as a bank.
// Must also be a multiple of 4.
//

#define TMP_BUFFER_SIZE         (BANK_SIZE_1_WINDOW)

/**************************************************************************\
*
* Specifies desired justification for requested scan line within bank window
*
\**************************************************************************/

typedef enum {
    JustifyTop = 0,
    JustifyBottom,
} BANK_JUST;

/**************************************************************************\
*
* Specifies which window is to be mapped by two-window bank handler.
*
\**************************************************************************/

typedef enum {
    MapSourceBank = 0,
    MapDestBank,
} BANK_JUST;

/**************************************************************************\
*
* Bank clipping info
*
\**************************************************************************/

typedef struct {
    RECTL rclBankBounds;    // describes pixels addressable in this bank
    ULONG ulBankOffset;     // offset of bank start from bitmap start, if
                            // the bitmap were linearly addressable
} BANK_INFO, *PBANK_INFO;

/**************************************************************************\
*
* Bank control function vector
*
\**************************************************************************/

typedef VOID (*PFN_PlanarEnable)();
typedef VOID (*PFN_PlanarDisable)();
typedef VOID (*PFN_PlanarControl)(PPDEV, ULONG, BANK_JUST);
typedef VOID (*PFN_PlanarControl2)(PPDEV, ULONG, BANK_JUST, ULONG);
typedef VOID (*PFN_PlanarNext)(PPDEV);
typedef VOID (*PFN_PlanarNext2)(PPDEV, ULONG);
typedef VOID (*PFN_BankControl)(PPDEV, ULONG, BANK_JUST);
typedef VOID (*PFN_BankControl2)(PPDEV, ULONG, BANK_JUST, ULONG);
typedef VOID (*PFN_BankNext)(PPDEV);
typedef VOID (*PFN_BankNext2)(PPDEV, ULONG);

/**************************************************************************\
*
* Miscellaneous driver flags
*
\**************************************************************************/

#define DRIVER_PLANAR_CAPABLE   0x01L
#define DRIVER_USE_OFFSCREEN    0x02L  // if not set, don't use offscreen memory
                                       //   for long operations (because the
                                       //   memory won't be refreshed)
#define DRIVER_HAS_OFFSCREEN    0x04L  // if not set, can't use any offscreen
                                       //   memory

/**************************************************************************\
*
* Bank status flags
*
\**************************************************************************/

#define BANK_BROKEN_RASTER1     0x01L // If bank1 or read bank has broken raster
#define BANK_BROKEN_RASTER2     0x02L // If bank2 or write bank has broken raster
#define BANK_BROKEN_RASTERS    (BANK_BROKEN_RASTER1 | BANK_BROKEN_RASTER2)
#define BANK_PLANAR             0x04L // If in planar mode

/**************************************************************************\
*
* Physical device data structure
*
\**************************************************************************/

// ***********************************************************
// *** MUST match the assembler version in i386\driver.inc ***
// ***********************************************************

typedef struct _PDEV
{
    FLONG       fl;                     // Driver flags (DRIVER_xxx)
    HANDLE      hDriver;                // Handle to \Device\Screen
    HDEV        hdevEng;                // Engine's handle to PDEV
    HSURF       hsurfEng;               // Engine's handle to surface
    HANDLE      hsurfBm;                // Handle to the "punt" surface
    SURFOBJ*    pSurfObj;               // pointer to the locked "punt" surface

    HPALETTE    hpalDefault;            // Handle to the default palette for device.

    PBYTE       pjScreen;               // This is pointer to base screen address
    ULONG       cxScreen;               // Visible screen width
    ULONG       cyScreen;               // Visible screen height
    ULONG       ulMode;                 // Mode the mini-port driver is in.
    LONG        lDeltaScreen;           // Distance from one scan to the next.

    FLONG       flRed;                  // For bitfields device, Red Mask
    FLONG       flGreen;                // For bitfields device, Green Mask
    FLONG       flBlue;                 // For bitfields device, Blue Mask
    ULONG       ulBitCount;             // # of bits per pel -- can be only 16

    GDIINFO*    pGdiInfo;               // Pointer to temporary buffer for GDIINFO struct
    DEVINFO*    pDevInfo;               // Pointer to temporary buffer for DEVINFO struct

    ULONG       ulrm0_wmX;              // Four values (one per byte) to set
                                        //  GC5 to to select read mode 0
                                        //  together with write modes 0-3
// Off screen save stuff:

    HBITMAP     hbmTmp;                 // Handle to temporary buffer
    SURFOBJ*    psoTmp;                 // Temporary surface
    PVOID       pvTmp;                  // Pointer to temporary buffer
    ULONG       cyTmp;                  // # of scans in temporary surface

// DCI stuff:

    BOOL        bSupportDCI;            // True if miniport supports DCI

// Bank manager stuff common between planar and non-planar modes:

    LONG        cTotalScans;            // Number of usable on and off-screen
                                        //  scans
    PVIDEO_BANK_SELECT pBankInfo;       // Bank info for current mode returned
                                        //  by miniport

    FLONG       flBank;                 // Flags for current bank state

    ULONG       ulBitmapSize;           // Length of bitmap if there were no
                                        //  banking, in CPU addressable bytes
    ULONG       ulWindowBank[2];        // Current banks mapped into windows
                                        //  0 & 1
    PVOID       pvBitmapStart;          // Single-window bitmap start pointer
                                        //  (adjusted as necessary to make
                                        //  window map in at proper offset)
    PVOID       pvBitmapStart2Window[2];// Double-window window 0 and 1 bitmap
                                        // start

// Non-planar mode specific bank management control stuff:

    VIDEO_BANK_TYPE  vbtBankingType;        // Type of banking
    PFN              pfnBankSwitchCode;     // Pointer to bank switch code

    LONG             lNextScan;             // Offset to next bank in bytes
    BYTE*            pjJustifyTopBank;      // Pointer to lookup table for
                                            //  converting scans to banks
    BANK_INFO*       pbiBankInfo;           // Array of bank clip info
    ULONG            ulJustifyBottomOffset; // # of scans from top to bottom
                                            //  of bank, for bottom justifying
    ULONG            iLastBank;             // Index of last valid bank in
                                            //  pbiBankInfo table
    ULONG            ulBank2RWSkip;         // Offset from one bank index to next
                                            //  to make two 32K banks appear to be
                                            //  one seamless 64K bank

    PFN_BankControl  pfnBankControl;        // Pointer to bank control function
    PFN_BankControl2 pfnBankControl2Window; // Pointer to double-window bank
                                            //  control function
    PFN_BankNext     pfnBankNext;           // Pointer to next bank function
    PFN_BankNext2    pfnBankNext2Window;    // Pointer to double-window next
                                            //  bank function

    RECTL            rcl1WindowClip;        // Single-window banking clip rect
    RECTL            rcl2WindowClip[2];     // Double-window banking clip rects for
                                            //  windows 0 & 1

// Planar mode specific bank management control stuff:

    VIDEO_BANK_TYPE    vbtPlanarType;       // Type of planar banking

    PFN                pfnPlanarSwitchCode; // Pointer to planar bank switch
                                            //  code

    LONG               lPlanarNextScan;     // Offset to next planar bank in
                                            //  bytes
    BYTE*              pjJustifyTopPlanar;  // Pointer to lookup table for
                                            //  converting scans to banks
    BANK_INFO*         pbiPlanarInfo;       // Array of bank clip info
    ULONG              ulPlanarBottomOffset;// # of scans from top to bottom
                                            //  of bank, for bottom justifying
    ULONG              iLastPlanar;         // Index of last valid bank in
                                            //  pbiPlanarInfo table
    ULONG              ulPlanar2RWSkip;     // Offset from one bank index to next
                                            //  to make two 32K banks appear to be
                                            //  one seamless 64K bank

    PFN_PlanarControl  pfnPlanarControl;    // Planar one window bank control
    PFN_PlanarControl2 pfnPlanarControl2;   // Planar two window bank control

    PFN_PlanarNext     pfnPlanarNext;       // Planar one window next bank
    PFN_PlanarNext2    pfnPlanarNext2;      // Planar two window next bank

    RECTL              rcl1PlanarClip;      // Single-window banking clip rect
    RECTL              rcl2PlanarClip[2];   // Double-window banking clip rects for
                                            //  windows 0 & 1

    PFN_PlanarEnable   pfnPlanarEnable;     // Function to enable planar mode
    PFN_PlanarDisable  pfnPlanarDisable;    // Function to disable planar mode

// Smart bank manager stuff:

    LONG        iLastScan;              // Last scan we want to enumerate
    PVOID       pvSaveScan0;            // Surface's original pvScan0
    RECTL       rclSaveBounds;          // Clip Object's original bounds
    CLIPOBJ*    pcoNull;                // Points to an empty clip object
                                        //  we can use when we're given a
                                        //  NULL CLIPOBJ pointer
    BYTE        iSaveDComplexity;       // Clip Object's original complexity
    BYTE        fjSaveOptions;          // Clip Object's original flags
    BYTE        ajFiller[2];            // Pack dword alignment

    BOOLEAN     BankIoctlSupported;     // does the miniport support ioctl
                                        // based banking?
};                                  /* pdev */

// Size of the driver extra information in the DEVMODe structure passed
// to and from the display driver

#define DRIVER_EXTRA_SIZE 0

#define DLL_NAME                L"vga64k"       // Name of the DLL in UNICODE
#define STANDARD_DEBUG_PREFIX   "VGA64K: "      // All debug output is prefixed
#define ALLOC_TAG               '6gvD'          // 4 byte TAG for memory allocations

// When calling vEnumStart, make sure you set bAll to FALSE.  This will tell
// the Engine to only enumerate rectangles in rclBounds.

// Hooks and Driver function table.

#define HOOKS_BMF16BPP  (HOOK_BITBLT     | HOOK_TEXTOUT    | HOOK_COPYBITS | \
                         HOOK_STROKEPATH | HOOK_PAINT)

#define BB_RECT_LIMIT   50

typedef struct _BBENUM
{
    ULONG   c;
    RECTL   arcl[BB_RECT_LIMIT];
} BBENUM;

// Initialization stuff:

BOOL bEnableBanking(PPDEV);
VOID vDisableBanking(PPDEV);
BOOL bInitPDEV(PPDEV,PDEVMODEW);
BOOL bInitSURF(PPDEV,BOOL);
VOID vDisableSURF(PPDEV);
VOID vInitRegs(PPDEV);
DWORD getAvailableModes(HANDLE, PVIDEO_MODE_INFORMATION *, DWORD *);

// Smart bank manager stuff:

CLIPOBJ* pcoBankStart(PPDEV, RECTL*, SURFOBJ*, CLIPOBJ*);
BOOL     bBankEnum(PPDEV, SURFOBJ*, CLIPOBJ*);
VOID     vBankStartBltSrc(PPDEV, SURFOBJ*, POINTL*, RECTL*, POINTL*, RECTL*);
BOOL     bBankEnumBltSrc(PPDEV, SURFOBJ*, POINTL*, RECTL*, POINTL*, RECTL*);
VOID     vBankStartBltDest(PPDEV, SURFOBJ*, POINTL*, RECTL*, POINTL*, RECTL*);
BOOL     bBankEnumBltDest(PPDEV, SURFOBJ*, POINTL*, RECTL*, POINTL*, RECTL*);

// Other prototypes:

VOID vPlanarCopyBits(PPDEV, RECTL*, POINTL*);
BOOL bIntersectRect(RECTL*, RECTL*, RECTL*);
VOID vSetWriteModes(ULONG *);

#endif // _DRIVER_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\vga\disp\16bpp\bank.c ===
/******************************Module*Header*******************************\
* Module Name: bank.c
*
* Functions to control 64k color VGA banking.
*
* Currently doesn't handle or even detect broken rasters; assumes broken
* rasters, if present, are off the right side of the visible bitmap.
*
* Copyright (c) 1992 Microsoft Corporation
\**************************************************************************/

#include "driver.h"
#include "limits.h"

VOID vBankErrorTrap(PPDEV, ULONG, BANK_JUST);
VOID vBank2Window(PPDEV, ULONG, BANK_JUST, ULONG);
VOID vBank2Window2RW(PPDEV, ULONG, BANK_JUST, ULONG);
VOID vBank2Window1RW(PPDEV, ULONG, BANK_JUST, ULONG);
VOID vBank1Window2RW(PPDEV, ULONG, BANK_JUST);
VOID vBank1Window(PPDEV, ULONG, BANK_JUST);
VOID vPlanar2Window(PPDEV, ULONG, BANK_JUST, ULONG);
VOID vPlanar2Window2RW(PPDEV, ULONG, BANK_JUST, ULONG);
VOID vPlanar2Window1RW(PPDEV, ULONG, BANK_JUST, ULONG);
VOID vPlanar1Window2RW(PPDEV, ULONG, BANK_JUST);
VOID vPlanar1Window(PPDEV, ULONG, BANK_JUST);

/******************************Public*Routine******************************\
* bInitializeNonPlanar(ppdev, pBankInfo)
*
* Initialize for non-planar mode banking.
*
* NOTE: Allocates ppdev->pbiBankInfo and ppdev->pjJustifyTopBank buffers!
\**************************************************************************/

BOOL bInitializeNonPlanar(PPDEV ppdev, VIDEO_BANK_SELECT* pBankInfo)
{
    LONG  lTotalScans;
    LONG  lTotalBanks;
    ULONG cjBankSize;

    ULONG cjGranularity = pBankInfo->Granularity;
    LONG  lDelta        = pBankInfo->BitmapWidthInBytes;
    ULONG cjBitmapSize  = pBankInfo->BitmapSize;

    ASSERTVGA(cjBitmapSize >= ppdev->cyScreen * lDelta, "Not enough vram");

    // Set up for non-planar banking:

    ppdev->lNextScan         = lDelta;
    ppdev->vbtBankingType    = pBankInfo->BankingType;

    ppdev->pfnBankSwitchCode =
                (PFN) (((BYTE*)pBankInfo) + pBankInfo->CodeOffset);

    // Set all clip rects to invalid; they'll be updated when the first
    // bank is mapped in

    ppdev->rcl1WindowClip.bottom    = -1;
    ppdev->rcl2WindowClip[0].bottom = -1;
    ppdev->rcl2WindowClip[1].bottom = -1;

    // Set up to call the appropriate banking control routines

    switch(pBankInfo->BankingType)
    {
    case VideoBanked1RW:
        ppdev->pfnBankControl        = vBank1Window;
        ppdev->pfnBankControl2Window = vBank2Window1RW;
        break;

    case VideoBanked1R1W:
        ppdev->pfnBankControl        = vBank1Window;
        ppdev->pfnBankControl2Window = vBank2Window;
        break;

    case VideoBanked2RW:
        ppdev->pfnBankControl        = vBank1Window2RW;
        ppdev->pfnBankControl2Window = vBank2Window2RW;

        // Offset from one bank index to next to make two 32k banks
        // appear to be one seamless 64k bank:

        ppdev->ulBank2RWSkip = BANK_SIZE_2RW_WINDOW / cjGranularity;
        break;

    default:
        RIP("Bad BankingType");
        return(FALSE);
    }

    // Set up the bank control tables with clip rects for banks
    // Note: lTotalBanks is generally an overestimate when granularity
    // is less than window size, because we ignore any banks after the
    // first one that includes the last scan line of the bitmap. A bit
    // of memory could be saved by sizing lTotalBanks exactly. Note too,
    // though, that the 2 RW window case may require more entries then,
    // because its windows are shorter, so you'd have to make sure there
    // were enough entries for the 2 RW window case, or recalculate
    // lTotalBanks for the 2 RW case

    lTotalBanks = (cjBitmapSize + cjGranularity - 1) / cjGranularity;
    lTotalScans = cjBitmapSize / lDelta;

    ppdev->cTotalScans = lTotalScans;
    ppdev->pbiBankInfo = (PBANK_INFO) EngAllocMem(FL_ZERO_MEMORY,
                          lTotalBanks * sizeof(BANK_INFO), ALLOC_TAG);
    if (ppdev->pbiBankInfo == NULL)
    {
        DISPDBG((0, "VGA64K: Couldn't get memory for bank info"));
        return(FALSE);
    }

    ppdev->pjJustifyTopBank = (BYTE*) EngAllocMem(0, lTotalScans, ALLOC_TAG);
    if (ppdev->pjJustifyTopBank == NULL)
    {
        DISPDBG((0, "VGA64K: Couldn't get memory for JustifyTopBank table"));
        return(FALSE);
    }

    // For 2 RW windows, windows are assumed to be 32k in size, otherwise
    // assumed to be 64k:

    if (pBankInfo->BankingType == VideoBanked2RW)
        cjBankSize = BANK_SIZE_2RW_WINDOW;
    else
        cjBankSize = BANK_SIZE_1_WINDOW;

//    if ((cjGranularity + lDelta) >= cjBankSize &&
//        (cjGranularity % lDelta) != 0)
//    {
//        // Oh no, we've got broken rasters (where a scan line crosses
//        // a bank boundary):
//
//        RIP("Oops, broken rasters not yet handled");
//        return(FALSE);
//    }
//    else
    {
        // We now fill in the scan-to-bank look-up and bank tables:

        LONG        iScan         = 0;
        ULONG       iBank         = 0;
        ULONG       cjScan        = 0;
        ULONG       cjNextBank    = cjGranularity;
        ULONG       cjEndOfBank   = cjBankSize;
        PBANK_INFO  pbiWorking    = ppdev->pbiBankInfo;

        while (TRUE)
        {
            pbiWorking->ulBankOffset         = cjNextBank - cjGranularity;

            // There are no broken rasters (or if they are, they're off the
            // right edge of the visible bitmap), so don't worry about left and
            // right edges:

            pbiWorking->rclBankBounds.left   = LONG_MIN + 1; // +1 to avoid
                                                             // compiler warn
            pbiWorking->rclBankBounds.right  = LONG_MAX;
            pbiWorking->rclBankBounds.top    = iScan;
            pbiWorking->rclBankBounds.bottom =
                    (cjEndOfBank + lDelta - 1) / lDelta;
                    // this rounds up to handle broken rasters that are off the
                    // right side of the visible bitmap

            // We don't need any more banks if we can see to the end
            // of the bitmap with the current bank:

            if (cjScan + cjBankSize >= cjBitmapSize)
                break;

            while (cjScan < cjNextBank)
            {
                ppdev->pjJustifyTopBank[iScan++] = (BYTE) iBank;
                cjScan += lDelta;
            }

            // Get ready for next bank:

            cjNextBank  += cjGranularity;
            cjEndOfBank += cjGranularity;
            pbiWorking++;
            iBank++;
        }

        // Clean up the last scans:

        ppdev->iLastBank = iBank;
        pbiWorking->rclBankBounds.bottom = lTotalScans;
        while (iScan < lTotalScans)
        {
            ppdev->pjJustifyTopBank[iScan++] = (BYTE) iBank;
        }

        // We've just computed the precise table for JustifyTop; we now
        // compute the scan offset for determining JustifyBottom:

        ASSERTVGA(cjBankSize >= cjGranularity,
               "Device says granularity more than bank size?");

        ppdev->ulJustifyBottomOffset = (cjBankSize - cjGranularity) / lDelta;

        // ulJustifyBottomOffset must be less than the number of scans
        // that fit entirely in any bank less the granularity size; if
        // our width doesn't divide evenly into the granularity, we'll
        // have to adjust the value to account for the first scan not
        // starting at offset 0 in any bank:

        if ((cjGranularity % lDelta) != 0 && ppdev->ulJustifyBottomOffset > 0)
            ppdev->ulJustifyBottomOffset--;
    }

    return(TRUE);
}

/******************************Public*Routine******************************\
* bInitializePlanar(ppdev, pBankInfo)
*
* Initialize for non-planar mode banking.
*
* NOTE: Allocates ppdev->pbiPlanarInfo and ppdev->pjJustifyTopPlanar buffers!
\**************************************************************************/

BOOL bInitializePlanar(PPDEV ppdev, VIDEO_BANK_SELECT* pBankInfo)
{
    LONG  lTotalScans;
    LONG  lTotalBanks;
    ULONG cjBankSize;
    ULONG cjGranularity = pBankInfo->PlanarHCGranularity;

    // Since we're in planar mode, every byte we see actually represents
    // four bytes of video memory:

    LONG  lDelta        = pBankInfo->BitmapWidthInBytes / 4;
    ULONG cjBitmapSize  = pBankInfo->BitmapSize / 4;

    ppdev->fl |= DRIVER_PLANAR_CAPABLE;

    // Set all clip rects to invalid; they'll be updated when the first
    // bank is mapped in

    ppdev->rcl1PlanarClip.bottom    = -1;
    ppdev->rcl2PlanarClip[0].bottom = -1;
    ppdev->rcl2PlanarClip[1].bottom = -1;

    // Set up for planar banking:

    ppdev->pfnPlanarSwitchCode =
                (PFN) (((BYTE*)pBankInfo) + pBankInfo->PlanarHCBankCodeOffset);
    ppdev->pfnPlanarEnable     =
                (PFN) (((BYTE*)pBankInfo) + pBankInfo->PlanarHCEnableCodeOffset);
    ppdev->pfnPlanarDisable     =
                (PFN) (((BYTE*)pBankInfo) + pBankInfo->PlanarHCDisableCodeOffset);

    ppdev->lPlanarNextScan = lDelta;
    ppdev->vbtPlanarType   = pBankInfo->PlanarHCBankingType;

    // Set up to call the appropriate banking control routines

    switch(ppdev->vbtPlanarType)
    {
    case VideoBanked1RW:
        ppdev->pfnPlanarControl  = vPlanar1Window;
        ppdev->pfnPlanarControl2 = vPlanar2Window1RW;
        break;

    case VideoBanked1R1W:
        ppdev->pfnPlanarControl  = vPlanar1Window;
        ppdev->pfnPlanarControl2 = vPlanar2Window;
        break;

    case VideoBanked2RW:
        ppdev->pfnPlanarControl  = vPlanar1Window2RW;
        ppdev->pfnPlanarControl2 = vPlanar2Window2RW;

        // Offset from one bank index to next to make two 32k banks
        // appear to be one seamless 64k bank:

        ppdev->ulPlanar2RWSkip = BANK_SIZE_2RW_WINDOW / cjGranularity;
        break;

    default:
        RIP("Bad BankingType");
        return(FALSE);
    }

    lTotalBanks = (cjBitmapSize + cjGranularity - 1) / cjGranularity;
    lTotalScans = cjBitmapSize / lDelta;

    ppdev->pbiPlanarInfo = (PBANK_INFO) EngAllocMem(FL_ZERO_MEMORY,
                          lTotalBanks * sizeof(BANK_INFO), ALLOC_TAG);
    if (ppdev->pbiPlanarInfo == NULL)
    {
        DISPDBG((0, "VGA64K: Couldn't get memory for bank info"));
        return(FALSE);
    }

    ppdev->pjJustifyTopPlanar = (BYTE*) EngAllocMem(0, lTotalScans, ALLOC_TAG);
    if (ppdev->pjJustifyTopPlanar == NULL)
    {
        DISPDBG((0, "VGA64K: Couldn't get memory for JustifyTopBank table"));
        return(FALSE);
    }

    // For 2 RW windows, windows are assumed to be 32k in size, otherwise
    // assumed to be 64k:

    if (pBankInfo->BankingType == VideoBanked2RW)
        cjBankSize = BANK_SIZE_2RW_WINDOW;
    else
        cjBankSize = BANK_SIZE_1_WINDOW;

//    if ((cjGranularity + lDelta) >= cjBankSize &&
//        (cjGranularity % lDelta) != 0)
//    {
//        // Oh no, we've got broken rasters (where a scan line crosses
//        // a bank boundary):
//
//        DISPDBG((0, "Can't handle broken planar rasters"));
//
//        ppdev->fl &= ~DRIVER_PLANAR_CAPABLE;// !!! Temporary, until we handle
//        return(TRUE);                       // broken rasters in planar copy
//    }
//    else
    {
        // We now fill in the scan-to-bank look-up and bank tables:

        LONG        iScan         = 0;
        ULONG       iBank         = 0;
        ULONG       cjScan        = 0;
        ULONG       cjNextBank    = cjGranularity;
        ULONG       cjEndOfBank   = cjBankSize;
        PBANK_INFO  pbiWorking    = ppdev->pbiPlanarInfo;

        while (TRUE)
        {
            pbiWorking->ulBankOffset         = cjNextBank - cjGranularity;

        // There are no broken rasters, so don't worry about left and right
        // edges:

            pbiWorking->rclBankBounds.left   = LONG_MIN + 1; // +1 to avoid
                                                             // compiler warn
            pbiWorking->rclBankBounds.right  = LONG_MAX;
            pbiWorking->rclBankBounds.top    = iScan;
            pbiWorking->rclBankBounds.bottom = iScan +
                (cjEndOfBank - cjScan + lDelta - 1) / lDelta;
                    // this rounds up to handle broken rasters that are off the
                    // right side of the visible bitmap

            // We don't need any more banks if we can see to the end
            // of the bitmap with the current bank:

            if (cjScan + cjBankSize >= cjBitmapSize)
                break;

            while (cjScan < cjNextBank)
            {
                ppdev->pjJustifyTopPlanar[iScan++] = (BYTE) iBank;
                cjScan += lDelta;
            }

            // Get ready for next bank:

            cjNextBank  += cjGranularity;
            cjEndOfBank += cjGranularity;
            pbiWorking++;
            iBank++;
        }

        // Clean up the last scans:

        ppdev->iLastPlanar = iBank;
        pbiWorking->rclBankBounds.bottom = lTotalScans;
        while (iScan < lTotalScans)
        {
            ppdev->pjJustifyTopPlanar[iScan++] = (BYTE) iBank;
        }

        // We've just computed the precise table for JustifyTop; we now
        // compute the scan offset for determining JustifyBottom:

        ASSERTVGA(cjBankSize >= cjGranularity,
               "Device says granularity more than bank size?");

        ppdev->ulPlanarBottomOffset = (cjBankSize - cjGranularity) / lDelta;

        // ulPlanarBottomOffset must be less than the number of scans
        // that fit entirely in any bank less the granularity size; if
        // our width doesn't divide evenly into the granularity, we'll
        // have to adjust the value to account for the first scan not
        // starting at offset 0 in any bank:

        if ((cjGranularity % lDelta) != 0 && ppdev->ulPlanarBottomOffset > 0)
            ppdev->ulPlanarBottomOffset--;
    }

    return(TRUE);
}

/******************************Public*Routine******************************\
* bEnableBanking(ppdev)
*
* Set up banking for the current mode
* pdsurf and ppdev are the pointers to the current surface and device
* Relevant fields in the surface are set up for banking
\**************************************************************************/

BOOL bEnableBanking(PPDEV ppdev)
{
    PVIDEO_BANK_SELECT  pBankInfo;
    UINT                ReturnedDataLength;
    VIDEO_BANK_SELECT   TempBankInfo;
    DWORD               status;

    // Make sure we've set to NULL any pointers to buffers that we allocate,
    // so that we can free them in our error path:

    ppdev->pBankInfo          = NULL;
    ppdev->pjJustifyTopBank   = NULL;
    ppdev->pbiBankInfo        = NULL;
    ppdev->pjJustifyTopPlanar = NULL;
    ppdev->pbiPlanarInfo      = NULL;

    // Query the miniport for banking info for this mode.
    //
    // First, figure out how big a buffer we need for the banking info
    // (returned in TempBankInfo->Size).

    if (status = EngDeviceIoControl(ppdev->hDriver,
                         IOCTL_VIDEO_GET_BANK_SELECT_CODE,
                         NULL,                      // input buffer
                         0,
                         (LPVOID) &TempBankInfo,    // output buffer
                         sizeof(VIDEO_BANK_SELECT),
                         &ReturnedDataLength))
    {
        // We expect this call to fail, because we didn't allow any room
        // for the code; we just want to get the required output buffer
        // size. Make sure we got the expected error, ERROR_MORE_DATA.
    }

    // Now, allocate a buffer of the required size and get the banking info.

    pBankInfo = (PVIDEO_BANK_SELECT) EngAllocMem(FL_ZERO_MEMORY,
                    TempBankInfo.Size, ALLOC_TAG);
    if (pBankInfo == NULL)
    {
        DISPDBG((0, "VGA64K: Initialization error-couldn't get memory for bank info"));
        goto error;
    }

    // Remember it so we can free it later:

    ppdev->pBankInfo    = pBankInfo;

    if (EngDeviceIoControl(ppdev->hDriver,
                         IOCTL_VIDEO_GET_BANK_SELECT_CODE,
                         NULL,
                         0,
                         (LPVOID) pBankInfo,
                         TempBankInfo.Size,
                         &ReturnedDataLength))
    {
        RIP("Initialization error-GetBankSelectCode, second call");
        goto error;
    }

    // Set up for banking:

    ppdev->ulBitmapSize = pBankInfo->BitmapSize;

    if (!bInitializeNonPlanar(ppdev, pBankInfo))
        goto error;

    if (pBankInfo->BankingFlags & PLANAR_HC)
    {
        ppdev->fl |= DRIVER_PLANAR_CAPABLE;
        if (!bInitializePlanar(ppdev, pBankInfo))
            goto error;
    }

    // Map in scan line 0 for read & write, to put things in a known state:

    ppdev->pfnBankControl(ppdev, 0, JustifyTop);

    return(TRUE);

// Error path:

error:
    vDisableBanking(ppdev);

    return(FALSE);
}

/******************************Public*Routine******************************\
* vDisableBanking(ppdev)
*
* Disable banking for the current mode
\**************************************************************************/

VOID vDisableBanking(PPDEV ppdev)
{
    EngFreeMem((LPVOID) ppdev->pBankInfo);
    EngFreeMem((LPVOID) ppdev->pjJustifyTopBank);
    EngFreeMem((LPVOID) ppdev->pbiBankInfo);
    EngFreeMem((LPVOID) ppdev->pjJustifyTopPlanar);
    EngFreeMem((LPVOID) ppdev->pbiPlanarInfo);
}

/******************************Private*Routine******************************\
* vBankErrorTrap
*
* Traps calls to bank control functions in non-banked modes
*
\**************************************************************************/

VOID vBankErrorTrap(PPDEV ppdev, ULONG lScan, BANK_JUST ulJustification)
{
    DISPDBG((0,"Call to bank manager in unbanked mode"));
}

/******************************Private*Routine******************************\
* vBank1Window
*
* Maps in a single R/W window that allows access to lScan. Applies to both
* 1 RW window and 1R1W window banking schemes.
*
\**************************************************************************/

VOID vBank1Window(PPDEV ppdev, ULONG lScan, BANK_JUST ulJustification)
{
             ULONG      ulBank;
             PBANK_INFO pbiWorking;
    volatile ULONG      ulBank0;
    volatile PFN        pBankFn;
             BANK_POSITION BankPosition;
             ULONG      ulReturn;

    // ASM routines that call this may have STD in effect, but the C compiler
    // assumes CLD

    _asm    pushfd
    _asm    cld

    // Set the clip rect for this bank; if it's set to -1, that indicates that
    // a double-window set-up is currently active, so invalidate double-window
    // clip rects and display memory pointers (when double-window is active,
    // single-window is inactive, and vice-versa; a full bank set-up has to be
    // performed to switch between the two)

    if (ppdev->rcl1WindowClip.bottom == -1)
    {
        if (ppdev->flBank & BANK_PLANAR)
        {
            ppdev->flBank &= ~BANK_PLANAR;
            ppdev->pfnPlanarDisable();
        }

        ppdev->rcl2WindowClip[0].bottom = -1;
        ppdev->rcl2WindowClip[1].bottom = -1;
        ppdev->rcl1PlanarClip.bottom    = -1;
        ppdev->rcl2PlanarClip[0].bottom = -1;
        ppdev->rcl2PlanarClip[1].bottom = -1;
    }

    ASSERTVGA(!(ppdev->flBank & BANK_PLANAR), "Shouldn't be in planar mode");

    // Find the bank containing the scan line with the desired justification:

    {
        register LONG lSearchScan = lScan;
        if (ulJustification == JustifyBottom)
        {
            lSearchScan -= ppdev->ulJustifyBottomOffset;
            if (lSearchScan <= 0)
                lSearchScan = 0;
        }

        ulBank     = (ULONG) ppdev->pjJustifyTopBank[lSearchScan];
        pbiWorking = &ppdev->pbiBankInfo[ulBank];
    }

    ASSERTVGA(pbiWorking->rclBankBounds.top <= (LONG)lScan &&
           pbiWorking->rclBankBounds.bottom > (LONG)lScan,
           "Oops, scan not in bank");

    ppdev->rcl1WindowClip = pbiWorking->rclBankBounds;

    // Shift the bitmap start address so that the desired bank aligns with
    // the banking window. The source and destination are set only so 1 R/W
    // aligned blits will work without having to be specifically aware of
    // the adapter type (some of the same code works with 1R/1W adapters too).

    ppdev->pvBitmapStart = (PVOID) (ppdev->pjScreen - pbiWorking->ulBankOffset);
    ppdev->pvBitmapStart2Window[0] = ppdev->pvBitmapStart;
    ppdev->pvBitmapStart2Window[1] = ppdev->pvBitmapStart;

    ppdev->flBank &= ~BANK_BROKEN_RASTERS;              // No broken rasters

    // Map in the desired bank for both read and write
    // This is so convoluted to avoid problems with wiping out registers C
    // thinks it's still using; the values are tranferred to volatiles, and
    // then to registers

    ulBank0 = ulBank;

    if (ppdev->BankIoctlSupported) {

        static ULONG ulBankOld = -1;

        if (ulBankOld != ulBank0) {

            BankPosition.ReadBankPosition = ulBank0;
            BankPosition.WriteBankPosition = ulBank0;

            ulBankOld = ulBank0;

            EngDeviceIoControl(ppdev->hDriver,
                             IOCTL_VIDEO_SET_BANK_POSITION,
                             &BankPosition,
                             sizeof(BANK_POSITION),
                             NULL,
                             0,
                             &ulReturn);
        }

    } else {

        pBankFn = ppdev->pfnBankSwitchCode;

        _asm mov eax,ulBank0;
        _asm mov edx,eax;
        _asm call pBankFn;    // actually switch the banks
    }

    _asm popfd
}

/******************************Private*Routine******************************\
* vBank1Window2RW
*
* Maps in two 32K RW windows so that they form a single 64K R/W window that
* allows access to lScan. Applies only to 2 RW window schemes.
*
\**************************************************************************/

VOID vBank1Window2RW(PPDEV ppdev, ULONG lScan, BANK_JUST ulJustification)
{
             ULONG      ulBank0;
             ULONG      ulBank1;
    volatile PFN        pBankFn;

    // ASM routines that call this may have STD in effect, but the C compiler
    // assumes CLD

    _asm    pushfd
    _asm    cld

    // Set the clip rect for this bank; if it's set to -1, that indicates that
    // a double-window set-up is currently active, so invalidate double-window
    // clip rects and display memory pointers (when double-window is active,
    // single-window is inactive, and vice-versa; a full bank set-up has to be
    // performed to switch between the two)

    if (ppdev->rcl1WindowClip.bottom == -1)
    {
        if (ppdev->flBank & BANK_PLANAR)
        {
            ppdev->flBank &= ~BANK_PLANAR;
            ppdev->pfnPlanarDisable();
        }

        ppdev->rcl2WindowClip[0].bottom = -1;
        ppdev->rcl2WindowClip[1].bottom = -1;
        ppdev->rcl1PlanarClip.bottom    = -1;
        ppdev->rcl2PlanarClip[0].bottom = -1;
        ppdev->rcl2PlanarClip[1].bottom = -1;
    }

    ASSERTVGA(!(ppdev->flBank & BANK_PLANAR), "Shouldn't be in planar mode");

    // Find the bank containing the scan line with the desired justification:

    if (ulJustification == JustifyTop)
    {
        ulBank0 = ppdev->pjJustifyTopBank[lScan];
        ulBank1 = ulBank0 + ppdev->ulBank2RWSkip;
        if (ulBank1 >= ppdev->iLastBank)
        {
            ulBank1 = ppdev->iLastBank;
            ulBank0 = ulBank1 - ppdev->ulBank2RWSkip;
        }
    }
    else
    {
        lScan -= ppdev->ulJustifyBottomOffset;
        if ((LONG)lScan <= 0)
            lScan = 0;

        ulBank1 = ppdev->pjJustifyTopBank[lScan];
        ulBank0 = ulBank1 - ppdev->ulBank2RWSkip;
        if ((LONG) ulBank0 < 0)
        {
            ulBank0 = 0;
            ulBank1 = ppdev->ulBank2RWSkip;
        }
    }

    ppdev->rcl1WindowClip.left   = ppdev->pbiBankInfo[ulBank0].rclBankBounds.left;
    ppdev->rcl1WindowClip.top    = ppdev->pbiBankInfo[ulBank0].rclBankBounds.top;
    ppdev->rcl1WindowClip.bottom = ppdev->pbiBankInfo[ulBank1].rclBankBounds.bottom;
    ppdev->rcl1WindowClip.right  = ppdev->pbiBankInfo[ulBank1].rclBankBounds.right;

    // Shift the bitmap start address so that the desired bank aligns with
    // the banking window. The source and destination are set only so 1 R/W
    // aligned blits will work without having to be specifically aware of
    // the adapter type (some of the same code works with 1R/1W adapters too).

    ppdev->pvBitmapStart = (PVOID) ((BYTE*)ppdev->pjScreen
                         - ppdev->pbiBankInfo[ulBank0].ulBankOffset);

    ppdev->pvBitmapStart2Window[0] = ppdev->pvBitmapStart;
    ppdev->pvBitmapStart2Window[1] = ppdev->pvBitmapStart;

    ppdev->flBank &= ~BANK_BROKEN_RASTERS;              // No broken rasters

    // Map in the desired bank for both read and write; this is accomplished
    // by mapping in the desired 32K bank, followed by the next 32K bank.
    // This is so convoluted to avoid problems with wiping out registers C
    // thinks it's still using; the values are tranferred to volatiles, and
    // then to registers

    pBankFn = ppdev->pfnBankSwitchCode;

    _asm mov eax,ulBank0;
    _asm mov edx,ulBank1;
    _asm call pBankFn;    // actually switch the banks

    _asm popfd;
}

/******************************Private*Routine******************************\
* vBank2Window
*
* Maps in one of two windows, either the source window (window 0) or the dest
* window (window 1), to allows access to lScan. Applies to 1R1W window
* banking scheme; should never be called for 1 RW window schemes, because
* there's only one window in that case.
*
\**************************************************************************/

VOID vBank2Window(
    PPDEV       ppdev,
    ULONG       lScan,
    BANK_JUST   ulJustification,
    ULONG       ulWindowToMap)
{
             ULONG       ulBank;
             PBANK_INFO  pbiWorking;
    volatile ULONG       ulBank0;
    volatile ULONG       ulBank1;
    volatile PFN         pBankFn;

    // ASM routines that call this may have STD in effect, but the C compiler
    // assumes CLD

    _asm    pushfd
    _asm    cld

    // Find the bank containing the scan line with the desired justification:

    if (ulJustification == JustifyBottom)
    {
        lScan -= ppdev->ulJustifyBottomOffset;
        if ((LONG)lScan <= 0)
            lScan = 0;
    }

    ulBank     = (ULONG) ppdev->pjJustifyTopBank[lScan];
    pbiWorking = &ppdev->pbiBankInfo[ulBank];

    // Set the clip rect for this bank; if it's set to -1, that indicates that
    // a single-window set-up is currently active, so invalidate single-window
    // clip rects and display memory pointers (when double-window is active,
    // single-window is inactive, and vice-versa; a full bank set-up has to be
    // performed to switch between the two)

    if (ppdev->rcl2WindowClip[ulWindowToMap].bottom == -1)
    {
        ULONG ulOtherWindow = ulWindowToMap ^ 1;

        if (ppdev->flBank & BANK_PLANAR)
        {
            ppdev->flBank &= ~BANK_PLANAR;
            ppdev->pfnPlanarDisable();
        }

        ppdev->rcl1WindowClip.bottom    = -1;
        ppdev->rcl1PlanarClip.bottom    = -1;
        ppdev->rcl2PlanarClip[0].bottom = -1;
        ppdev->rcl2PlanarClip[1].bottom = -1;

        // Neither of the 2 window windows was active, so we have to set up the
        // variables for the other bank (the one other than the one we were
        // called to set) as well, to make it valid. The other bank is set to
        // the same state as the bank we were called to set

        ppdev->rcl2WindowClip[ulOtherWindow]       = pbiWorking->rclBankBounds;
        ppdev->ulWindowBank[ulOtherWindow]         = ulBank;
        ppdev->pvBitmapStart2Window[ulOtherWindow] =
                (PVOID) ((BYTE*)ppdev->pjScreen - pbiWorking->ulBankOffset);
    }

    ASSERTVGA(!(ppdev->flBank & BANK_PLANAR), "Shouldn't be in planar mode");

    ppdev->rcl2WindowClip[ulWindowToMap] = pbiWorking->rclBankBounds;

    // Shift the bitmap start address so that the desired bank aligns with the
    // banking window

    ppdev->pvBitmapStart2Window[ulWindowToMap] =
            (PVOID) ((UCHAR *)ppdev->pjScreen - pbiWorking->ulBankOffset);

    // Map in the desired bank; also map in the other bank to whatever its
    // current state is

    ppdev->ulWindowBank[ulWindowToMap] = ulBank;

    ppdev->flBank &= ~BANK_BROKEN_RASTERS;              // No broken rasters

    // Set both banks at once, because we may have just initialized the other
    // bank, and because this way the bank switch code doesn't have to do a
    // read before write to obtain the state of the other bank.
    // This is so convoluted to avoid problems with wiping out registers C
    // thinks it's still using; the values are tranferred to volatiles, and
    // then to registers


    ulBank0 = ppdev->ulWindowBank[0];
    ulBank1 = ppdev->ulWindowBank[1];
    pBankFn = ppdev->pfnBankSwitchCode;

    _asm mov eax,ulBank0;
    _asm mov edx,ulBank1;
    _asm call pBankFn;    // actually switch the banks

    _asm popfd;
}

/******************************Private*Routine******************************\
* vBank2Window1RW
*
* Maps in the one window in 1R/W case.  Does exactly the same thing as the
* one window case, because there's only one window, but has to be a separate
* entry point because of the extra parameter (because we're using STDCALL).
\**************************************************************************/

VOID vBank2Window1RW(PPDEV ppdev, ULONG lScan,
    BANK_JUST ulJustification, ULONG ulWindowToMap)
{
    vBank1Window(ppdev, lScan, ulJustification);
}

/******************************Private*Routine******************************\
* vBank2Window2RW
*
* Maps in one of two windows, either the source window (window 0) or the dest
* window (window 1), to allows access to lScan. Applies to 2RW window
* banking scheme; should never be called for 1 RW window schemes, because
* there's only one window in that case.
\**************************************************************************/

VOID vBank2Window2RW(
    PPDEV       ppdev,
    ULONG       lScan,
    BANK_JUST   ulJustification,
    ULONG       ulWindowToMap)
{
             ULONG      ulBank;
             PBANK_INFO pbiWorking;
    volatile ULONG      ulBank0;
    volatile ULONG      ulBank1;
    volatile PFN        pBankFn;

    // ASM routines that call this may have STD in effect, but the C compiler
    // assumes CLD

    _asm    pushfd
    _asm    cld

    // Find the bank containing the scan line with the desired justification:

    if (ulJustification == JustifyBottom)
    {
        lScan -= ppdev->ulJustifyBottomOffset;
        if ((LONG)lScan <= 0)
            lScan = 0;
    }

    ulBank     = (ULONG) ppdev->pjJustifyTopBank[lScan];
    pbiWorking = &ppdev->pbiBankInfo[ulBank];

    // Set the clip rect for this bank; if it's set to -1, that indicates that
    // a single-window set-up is currently active, so invalidate single-window
    // clip rects and display memory pointers (when double-window is active,
    // single-window is inactive, and vice-versa; a full bank set-up has to be
    // performed to switch between the two)

    if (ppdev->rcl2WindowClip[ulWindowToMap].bottom == -1)
    {
        if (ppdev->flBank & BANK_PLANAR)
        {
            ppdev->flBank &= ~BANK_PLANAR;
            ppdev->pfnPlanarDisable();
        }

        ppdev->rcl1WindowClip.bottom    = -1;
        ppdev->rcl1PlanarClip.bottom    = -1;
        ppdev->rcl2PlanarClip[0].bottom = -1;
        ppdev->rcl2PlanarClip[1].bottom = -1;

        // Neither of the 2 window windows was active, so we have to set up the
        // variables for the other bank (the one other than the one we were
        // called to set) as well, to make it valid. The other bank is set to
        // the same state as the bank we were called to set

        ppdev->rcl2WindowClip[ulWindowToMap^1] = pbiWorking->rclBankBounds;
        if (ulWindowToMap == 1)
        {
            ppdev->pvBitmapStart2Window[0] =
                (PVOID) ((BYTE*)ppdev->pjScreen - pbiWorking->ulBankOffset);
        }
        else
        {
            ppdev->pvBitmapStart2Window[1] =
                (PVOID) ((UCHAR *)ppdev->pjScreen - pbiWorking->ulBankOffset +
                BANK_SIZE_2RW_WINDOW);
        }
        ppdev->ulWindowBank[ulWindowToMap^1] = ulBank;
    }

    ASSERTVGA(!(ppdev->flBank & BANK_PLANAR), "Shouldn't be in planar mode");

    ppdev->rcl2WindowClip[ulWindowToMap] = pbiWorking->rclBankBounds;

    // Shift the bitmap start address so that the desired bank aligns with the
    // banking window

    if (ulWindowToMap == 0)
    {
        ppdev->pvBitmapStart2Window[0] =
            (PVOID) ((UCHAR *)ppdev->pjScreen - pbiWorking->ulBankOffset);
    }
    else
    {
        ppdev->pvBitmapStart2Window[1] =
            (PVOID) ((UCHAR *)ppdev->pjScreen - pbiWorking->ulBankOffset +
            BANK_SIZE_2RW_WINDOW);
    }

    ppdev->flBank &= ~BANK_BROKEN_RASTERS;              // No broken rasters

    // Map in the desired bank; also map in the other bank to whatever its
    // current state is

    ppdev->ulWindowBank[ulWindowToMap] = ulBank;

    // Set both banks at once, because we may have just initialized the other
    // bank, and because this way the bank switch code doesn't have to do a
    // read before write to obtain the state of the other bank.
    // This is so convoluted to avoid problems with wiping out registers C
    // thinks it's still using; the values are tranferred to volatiles, and
    // then to registers

    ulBank0 = ppdev->ulWindowBank[0];
    ulBank1 = ppdev->ulWindowBank[1];
    pBankFn = ppdev->pfnBankSwitchCode;
    _asm mov eax,ulBank0;
    _asm mov edx,ulBank1;
    _asm call pBankFn;    // actually switch the banks

    _asm popfd;
}

/******************************Private*Routine******************************\
* vPlanar1Window
*
* Maps in a single R/W window that allows access to lScan. Applies to both
* 1 RW window and 1R1W window banking schemes.
\**************************************************************************/

VOID vPlanar1Window(PPDEV ppdev, ULONG lScan, BANK_JUST ulJustification)
{
             ULONG      ulBank;
             PBANK_INFO pbiWorking;
    volatile ULONG      ulBank0;
    volatile PFN        pBankFn;

    // ASM routines that call this may have STD in effect, but the C compiler
    // assumes CLD

    _asm    pushfd
    _asm    cld

    // Set the clip rect for this bank; if it's set to -1, that indicates that
    // a double-window set-up is currently active, so invalidate double-window
    // clip rects and display memory pointers (when double-window is active,
    // single-window is inactive, and vice-versa; a full bank set-up has to be
    // performed to switch between the two)

    if (ppdev->rcl1PlanarClip.bottom == -1)
    {
        if (!(ppdev->flBank & BANK_PLANAR))
        {
            ppdev->flBank |= BANK_PLANAR;
            ppdev->pfnPlanarEnable();
        }

        ppdev->rcl1WindowClip.bottom    = -1;
        ppdev->rcl2WindowClip[0].bottom = -1;
        ppdev->rcl2WindowClip[1].bottom = -1;
        ppdev->rcl2PlanarClip[0].bottom = -1;
        ppdev->rcl2PlanarClip[1].bottom = -1;
    }

    ASSERTVGA(ppdev->flBank & BANK_PLANAR, "Should be in planar mode");

    // Find the bank containing the scan line with the desired justification:

    if (ulJustification == JustifyBottom)
    {
        lScan -= ppdev->ulPlanarBottomOffset;
        if ((LONG)lScan <= 0)
            lScan = 0;
    }

    ulBank     = (ULONG) ppdev->pjJustifyTopPlanar[lScan];
    pbiWorking = &ppdev->pbiPlanarInfo[ulBank];

    ppdev->rcl1PlanarClip = pbiWorking->rclBankBounds;

    // Shift the bitmap start address so that the desired bank aligns with
    // the banking window. The source and destination are set only so 1 R/W
    // aligned blits will work without having to be specifically aware of
    // the adapter type (some of the same code works with 1R/1W adapters too).

    ppdev->pvBitmapStart = (PVOID) (ppdev->pjScreen - pbiWorking->ulBankOffset);
    ppdev->pvBitmapStart2Window[0] = ppdev->pvBitmapStart;
    ppdev->pvBitmapStart2Window[1] = ppdev->pvBitmapStart;

    ppdev->flBank &= ~BANK_BROKEN_RASTERS;              // No broken rasters

    // Map in the desired bank for both read and write
    // This is so convoluted to avoid problems with wiping out registers C
    // thinks it's still using; the values are tranferred to volatiles, and
    // then to registers

    ulBank0 = ulBank;
    pBankFn = ppdev->pfnPlanarSwitchCode;

    _asm mov eax,ulBank0;
    _asm mov edx,eax;
    _asm call pBankFn;    // actually switch the banks

    _asm popfd
}

/******************************Private*Routine******************************\
* vPlanar1Window2RW
*
* Maps in two 32K RW windows so that they form a single 64K R/W window that
* allows access to lScan. Applies only to 2 RW window schemes.
*
\**************************************************************************/

VOID vPlanar1Window2RW(PPDEV ppdev, ULONG lScan, BANK_JUST ulJustification)
{
             ULONG      ulBank0;
             ULONG      ulBank1;
    volatile PFN        pBankFn;

    // ASM routines that call this may have STD in effect, but the C compiler
    // assumes CLD

    _asm    pushfd
    _asm    cld

    // Set the clip rect for this bank; if it's set to -1, that indicates that
    // a double-window set-up is currently active, so invalidate double-window
    // clip rects and display memory pointers (when double-window is active,
    // single-window is inactive, and vice-versa; a full bank set-up has to be
    // performed to switch between the two)


    if (ppdev->rcl1PlanarClip.bottom == -1)
    {
        if (!(ppdev->flBank & BANK_PLANAR))
        {
            ppdev->flBank |= BANK_PLANAR;
            ppdev->pfnPlanarEnable();
        }

        ppdev->rcl1WindowClip.bottom    = -1;
        ppdev->rcl2WindowClip[0].bottom = -1;
        ppdev->rcl2WindowClip[1].bottom = -1;
        ppdev->rcl2PlanarClip[0].bottom = -1;
        ppdev->rcl2PlanarClip[1].bottom = -1;
    }

    ASSERTVGA(ppdev->flBank & BANK_PLANAR, "Should be in planar mode");

    // Find the bank containing the scan line with the desired justification:

    if (ulJustification == JustifyTop)
    {
        ulBank0 = ppdev->pjJustifyTopPlanar[lScan];
        ulBank1 = ulBank0 + ppdev->ulPlanar2RWSkip;
        if (ulBank1 >= ppdev->iLastPlanar)
            ulBank1 = ppdev->iLastPlanar;
    }
    else
    {
        lScan -= ppdev->ulPlanarBottomOffset;
        if ((LONG)lScan <= 0)
            lScan = 0;

        ulBank1 = ppdev->pjJustifyTopPlanar[lScan];
        ulBank0 = ulBank1 - ppdev->ulPlanar2RWSkip;
        if ((LONG) ulBank0 < 0)
            ulBank0 = 0;
    }

    ppdev->rcl1PlanarClip.left   = ppdev->pbiPlanarInfo[ulBank0].rclBankBounds.left;
    ppdev->rcl1PlanarClip.top    = ppdev->pbiPlanarInfo[ulBank0].rclBankBounds.top;
    ppdev->rcl1PlanarClip.bottom = ppdev->pbiPlanarInfo[ulBank1].rclBankBounds.bottom;
    ppdev->rcl1PlanarClip.right  = ppdev->pbiPlanarInfo[ulBank1].rclBankBounds.right;

    // Shift the bitmap start address so that the desired bank aligns with
    // the banking window. The source and destination are set only so 1 R/W
    // aligned blits will work without having to be specifically aware of
    // the adapter type (some of the same code works with 1R/1W adapters too).

    ppdev->pvBitmapStart = (PVOID) ((BYTE*)ppdev->pjScreen
                         - ppdev->pbiPlanarInfo[ulBank0].ulBankOffset);

    ppdev->pvBitmapStart2Window[0] = ppdev->pvBitmapStart;
    ppdev->pvBitmapStart2Window[1] = ppdev->pvBitmapStart;

    ppdev->flBank &= ~BANK_BROKEN_RASTERS;              // No broken rasters

    // Map in the desired bank for both read and write; this is accomplished
    // by mapping in the desired 32K bank, followed by the next 32K bank.
    // This is so convoluted to avoid problems with wiping out registers C
    // thinks it's still using; the values are tranferred to volatiles, and
    // then to registers

    pBankFn = ppdev->pfnPlanarSwitchCode;

    _asm mov eax,ulBank0;
    _asm mov edx,ulBank1;
    _asm call pBankFn;    // actually switch the banks

    _asm popfd;
}

/******************************Private*Routine******************************\
* vPlanar2Window
*
* Maps in one of two windows, either the source window (window 0) or the dest
* window (window 1), to allows access to lScan. Applies to 1R1W window
* banking scheme; should never be called for 1 RW window schemes, because
* there's only one window in that case.
*
\**************************************************************************/

VOID vPlanar2Window(
    PPDEV       ppdev,
    ULONG       lScan,
    BANK_JUST   ulJustification,
    ULONG       ulWindowToMap)
{
             ULONG       ulBank;
             PBANK_INFO  pbiWorking;
    volatile ULONG       ulBank0;
    volatile ULONG       ulBank1;
    volatile PFN         pBankFn;

    // ASM routines that call this may have STD in effect, but the C compiler
    // assumes CLD

    _asm    pushfd
    _asm    cld

    // Find the bank containing the scan line with the desired justification:

    if (ulJustification == JustifyBottom)
    {
        lScan -= ppdev->ulPlanarBottomOffset;
        if ((LONG)lScan <= 0)
            lScan = 0;
    }

    ulBank     = (ULONG) ppdev->pjJustifyTopPlanar[lScan];
    pbiWorking = &ppdev->pbiPlanarInfo[ulBank];

    // Set the clip rect for this bank; if it's set to -1, that indicates that
    // a single-window set-up is currently active, so invalidate single-window
    // clip rects and display memory pointers (when double-window is active,
    // single-window is inactive, and vice-versa; a full bank set-up has to be
    // performed to switch between the two)

    if (ppdev->rcl2PlanarClip[ulWindowToMap].bottom == -1)
    {
        ULONG ulOtherWindow = ulWindowToMap ^ 1;

        if (!(ppdev->flBank & BANK_PLANAR))
        {
            ppdev->flBank |= BANK_PLANAR;
            ppdev->pfnPlanarEnable();
        }

        ppdev->rcl1WindowClip.bottom    = -1;
        ppdev->rcl2WindowClip[0].bottom = -1;
        ppdev->rcl2WindowClip[1].bottom = -1;
        ppdev->rcl1PlanarClip.bottom    = -1;

        // Neither of the 2 window windows was active, so we have to set up the
        // variables for the other bank (the one other than the one we were
        // called to set) as well, to make it valid. The other bank is set to
        // the same state as the bank we were called to set

        ppdev->rcl2PlanarClip[ulOtherWindow]       = pbiWorking->rclBankBounds;
        ppdev->ulWindowBank[ulOtherWindow]         = ulBank;
        ppdev->pvBitmapStart2Window[ulOtherWindow] =
                (PVOID) ((BYTE*)ppdev->pjScreen - pbiWorking->ulBankOffset);
    }

    ASSERTVGA(ppdev->flBank & BANK_PLANAR, "Should be in planar mode");

    ppdev->rcl2PlanarClip[ulWindowToMap] = pbiWorking->rclBankBounds;

    // Shift the bitmap start address so that the desired bank aligns with the
    // banking window

    ppdev->pvBitmapStart2Window[ulWindowToMap] =
            (PVOID) ((UCHAR *)ppdev->pjScreen - pbiWorking->ulBankOffset);

    // Map in the desired bank; also map in the other bank to whatever its
    // current state is

    ppdev->ulWindowBank[ulWindowToMap] = ulBank;

    ppdev->flBank &= ~BANK_BROKEN_RASTERS;              // No broken rasters

    // Set both banks at once, because we may have just initialized the other
    // bank, and because this way the bank switch code doesn't have to do a
    // read before write to obtain the state of the other bank.
    // This is so convoluted to avoid problems with wiping out registers C
    // thinks it's still using; the values are tranferred to volatiles, and
    // then to registers


    ulBank0 = ppdev->ulWindowBank[0];
    ulBank1 = ppdev->ulWindowBank[1];
    pBankFn = ppdev->pfnPlanarSwitchCode;

    _asm mov eax,ulBank0;
    _asm mov edx,ulBank1;
    _asm call pBankFn;    // actually switch the banks

    _asm popfd;
}

/******************************Private*Routine******************************\
* vPlanar2Window1RW
*
* Maps in the one window in 1R/W case.  Does exactly the same thing as the
* one window case, because there's only one window, but has to be a separate
* entry point because of the extra parameter (because we're using STDCALL).
\**************************************************************************/

VOID vPlanar2Window1RW(PPDEV ppdev, ULONG lScan,
    BANK_JUST ulJustification, ULONG ulWindowToMap)
{
    vPlanar1Window(ppdev, lScan, ulJustification);
}

/******************************Private*Routine******************************\
* vPlanar2Window2RW
*
* Maps in one of two windows, either the source window (window 0) or the dest
* window (window 1), to allows access to lScan. Applies to 2RW window
* banking scheme; should never be called for 1 RW window schemes, because
* there's only one window in that case.
\**************************************************************************/

VOID vPlanar2Window2RW(
    PPDEV       ppdev,
    ULONG       lScan,
    BANK_JUST   ulJustification,
    ULONG       ulWindowToMap)
{
             ULONG      ulBank;
             PBANK_INFO pbiWorking;
    volatile ULONG      ulBank0;
    volatile ULONG      ulBank1;
    volatile PFN        pBankFn;

    // ASM routines that call this may have STD in effect, but the C compiler
    // assumes CLD

    _asm    pushfd
    _asm    cld

    // Find the bank containing the scan line with the desired justification:

    if (ulJustification == JustifyBottom)
    {
        lScan -= ppdev->ulPlanarBottomOffset;
        if ((LONG)lScan <= 0)
            lScan = 0;
    }

    ulBank     = (ULONG) ppdev->pjJustifyTopPlanar[lScan];
    pbiWorking = &ppdev->pbiPlanarInfo[ulBank];

    // Set the clip rect for this bank; if it's set to -1, that indicates that
    // a single-window set-up is currently active, so invalidate single-window
    // clip rects and display memory pointers (when double-window is active,
    // single-window is inactive, and vice-versa; a full bank set-up has to be
    // performed to switch between the two)

    if (ppdev->rcl2PlanarClip[ulWindowToMap].bottom == -1)
    {
        if (!(ppdev->flBank & BANK_PLANAR))
        {
            ppdev->flBank |= BANK_PLANAR;
            ppdev->pfnPlanarEnable();
        }

        ppdev->rcl1WindowClip.bottom    = -1;
        ppdev->rcl2WindowClip[0].bottom = -1;
        ppdev->rcl2WindowClip[1].bottom = -1;
        ppdev->rcl1PlanarClip.bottom    = -1;

        // Neither of the 2 window windows was active, so we have to set up the
        // variables for the other bank (the one other than the one we were
        // called to set) as well, to make it valid. The other bank is set to
        // the same state as the bank we were called to set

        ppdev->rcl2PlanarClip[ulWindowToMap^1] = pbiWorking->rclBankBounds;
        if (ulWindowToMap == 1)
        {
            ppdev->pvBitmapStart2Window[0] =
                (PVOID) ((BYTE*)ppdev->pjScreen - pbiWorking->ulBankOffset);
        }
        else
        {
            ppdev->pvBitmapStart2Window[1] =
                (PVOID) ((UCHAR *)ppdev->pjScreen - pbiWorking->ulBankOffset +
                BANK_SIZE_2RW_WINDOW);
        }
        ppdev->ulWindowBank[ulWindowToMap^1] = ulBank;
    }

    ASSERTVGA(ppdev->flBank & BANK_PLANAR, "Should be in planar mode");

    ppdev->rcl2PlanarClip[ulWindowToMap] = pbiWorking->rclBankBounds;

    // Shift the bitmap start address so that the desired bank aligns with the
    // banking window

    if (ulWindowToMap == 0)
    {
        ppdev->pvBitmapStart2Window[0] =
            (PVOID) ((UCHAR *)ppdev->pjScreen - pbiWorking->ulBankOffset);
    }
    else
    {
        ppdev->pvBitmapStart2Window[1] =
            (PVOID) ((UCHAR *)ppdev->pjScreen - pbiWorking->ulBankOffset +
            BANK_SIZE_2RW_WINDOW);
    }

    ppdev->flBank &= ~BANK_BROKEN_RASTERS;              // No broken rasters

    // Map in the desired bank; also map in the other bank to whatever its
    // current state is

    ppdev->ulWindowBank[ulWindowToMap] = ulBank;

    // Set both banks at once, because we may have just initialized the other
    // bank, and because this way the bank switch code doesn't have to do a
    // read before write to obtain the state of the other bank.
    // This is so convoluted to avoid problems with wiping out registers C
    // thinks it's still using; the values are tranferred to volatiles, and
    // then to registers

    ulBank0 = ppdev->ulWindowBank[0];
    ulBank1 = ppdev->ulWindowBank[1];
    pBankFn = ppdev->pfnPlanarSwitchCode;
    _asm mov eax,ulBank0;
    _asm mov edx,ulBank1;
    _asm call pBankFn;    // actually switch the banks

    _asm popfd;
}


/******************************Private*Routine******************************\
* vPlanarDouble
*
* Maps in two windows simultaneously, both the source window (window 0)
* and the dest window (window 1), to allows access to the scans.
* Applies to 1R1W and 2R/w window banking schemes; should never be called
* for 1 RW window schemes, because there's only one window in that case.
*
\**************************************************************************/

VOID vPlanarDouble(
    PPDEV       ppdev,
    LONG        lScan0,          // Source bank
    BANK_JUST   ulJustification0,// Source justification
    LONG        lScan1,          // Destination bank
    BANK_JUST   ulJustification1)// Destination justification
{
             PBANK_INFO  pbi0;
             PBANK_INFO  pbi1;
             ULONG       ulBank0;
             ULONG       ulBank1;
    volatile ULONG       ulBank0_vol;
    volatile ULONG       ulBank1_vol;
    volatile PFN         pBankFn;

    // ASM routines that call this may have STD in effect, but the C compiler
    // assumes CLD

    _asm    pushfd
    _asm    cld

    // Find the banks containing the scan lines with the desired justification:

    if (ulJustification0 == JustifyBottom)
    {
        lScan0 -= ppdev->ulPlanarBottomOffset;
        if (lScan0 <= 0)
            lScan0 = 0;
    }
    if (ulJustification1 == JustifyBottom)
    {
        lScan1 -= ppdev->ulPlanarBottomOffset;
        if (lScan1 <= 0)
            lScan1 = 0;
    }

    ulBank0    = (ULONG) ppdev->pjJustifyTopPlanar[lScan0];
    ulBank1    = (ULONG) ppdev->pjJustifyTopPlanar[lScan1];
    pbi0       = &ppdev->pbiPlanarInfo[ulBank0];
    pbi1       = &ppdev->pbiPlanarInfo[ulBank1];

    // Set the clip rect for this bank; if it's set to -1, that indicates that
    // a single-window set-up is currently active, so invalidate single-window
    // clip rects and display memory pointers (when double-window is active,
    // single-window is inactive, and vice-versa; a full bank set-up has to be
    // performed to switch between the two)

    if (ppdev->rcl2PlanarClip[0].bottom == -1)
    {
        if (!(ppdev->flBank & BANK_PLANAR))
        {
            ppdev->flBank |= BANK_PLANAR;
            ppdev->pfnPlanarEnable();
        }

        ppdev->rcl1WindowClip.bottom    = -1;
        ppdev->rcl2WindowClip[0].bottom = -1;
        ppdev->rcl2WindowClip[1].bottom = -1;
        ppdev->rcl1PlanarClip.bottom    = -1;
    }

    ASSERTVGA(ppdev->flBank & BANK_PLANAR, "Should be in planar mode");

    ppdev->rcl2PlanarClip[0] = pbi0->rclBankBounds;
    ppdev->rcl2PlanarClip[1] = pbi1->rclBankBounds;

    // Shift the bitmap start address so that the desired bank aligns with the
    // banking window

    ppdev->pvBitmapStart2Window[0] =
            (PVOID) ((UCHAR *)ppdev->pjScreen - pbi0->ulBankOffset);
    ppdev->pvBitmapStart2Window[1] =
            (PVOID) ((UCHAR *)ppdev->pjScreen - pbi1->ulBankOffset);

    if (ppdev->vbtPlanarType == VideoBanked2RW)
    {
        ppdev->pvBitmapStart2Window[1] = (PVOID) ((BYTE*)
            ppdev->pvBitmapStart2Window[1] + BANK_SIZE_2RW_WINDOW);
    }

    // Map in the desired banks.

    ppdev->ulWindowBank[0] = ulBank0;
    ppdev->ulWindowBank[1] = ulBank1;

    ppdev->flBank &= ~BANK_BROKEN_RASTERS;              // No broken rasters

    // Set both banks at once.
    // This is so convoluted to avoid problems with wiping out registers C
    // thinks it's still using; the values are tranferred to volatiles, and
    // then to registers

    ulBank0_vol = ulBank0;
    ulBank1_vol = ulBank1;
    pBankFn = ppdev->pfnPlanarSwitchCode;

    _asm mov eax,ulBank0_vol;
    _asm mov edx,ulBank1_vol;
    _asm call pBankFn;    // actually switch the banks

    _asm popfd;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\vga\disp\16bpp\enable.c ===
/******************************Module*Header*******************************\
* Module Name: enable.c
*
* This module contains the functions that enable and disable the
* driver, the pdev, and the surface.
*
* Copyright (c) 1992 Microsoft Corporation
\**************************************************************************/

#include "driver.h"

//
// Build the driver function table gadrvfn with function index/address pairs
//

DRVFN gadrvfn[] = {
    {   INDEX_DrvEnablePDEV,            (PFN) DrvEnablePDEV         },
    {   INDEX_DrvCompletePDEV,          (PFN) DrvCompletePDEV       },
    {   INDEX_DrvDisablePDEV,           (PFN) DrvDisablePDEV        },
    {   INDEX_DrvEnableSurface,         (PFN) DrvEnableSurface      },
    {   INDEX_DrvDisableSurface,        (PFN) DrvDisableSurface     },
    {   INDEX_DrvAssertMode,            (PFN) DrvAssertMode         },
    {   INDEX_DrvDitherColor,           (PFN) DrvDitherColor        },
    {   INDEX_DrvGetModes,              (PFN) DrvGetModes           },
    {   INDEX_DrvCopyBits,              (PFN) DrvCopyBits           },
    {   INDEX_DrvBitBlt,                (PFN) DrvBitBlt             },
    {   INDEX_DrvTextOut,               (PFN) DrvTextOut            },
    {   INDEX_DrvStrokePath,            (PFN) DrvStrokePath         },
    {   INDEX_DrvPaint,                 (PFN) DrvPaint              },
    {   INDEX_DrvDisableDriver,         (PFN) DrvDisableDriver      }
};

BOOL bInitDefaultPalette(PPDEV ppdev, DEVINFO *pDevInfo);

/******************************Public*Routine******************************\
* DrvEnableDriver
*
* Enables the driver by retrieving the drivers function table and version.
*
\**************************************************************************/

BOOL DrvEnableDriver(
    ULONG iEngineVersion,
    ULONG cj,
    PDRVENABLEDATA pded)
{
    UNREFERENCED_PARAMETER(iEngineVersion);

// Engine Version is passed down so future drivers can support previous
// engine versions.  A next generation driver can support both the old
// and new engine conventions if told what version of engine it is
// working with.  For the first version the driver does nothing with it.

// Fill in as much as we can.

    if (cj >= sizeof(DRVENABLEDATA))
        pded->pdrvfn = gadrvfn;

    if (cj >= (sizeof(ULONG) * 2))
        pded->c = sizeof(gadrvfn) / sizeof(DRVFN);

// DDI version this driver was targeted for is passed back to engine.
// Future graphic's engine may break calls down to old driver format.

    if (cj >= sizeof(ULONG))
        pded->iDriverVersion = DDI_DRIVER_VERSION_NT4;

    return(TRUE);
}

/******************************Public*Routine******************************\
* DrvDisableDriver
*
* Tells the driver it is being disabled. Release any resources allocated in
* DrvEnableDriver.
*
\**************************************************************************/

VOID DrvDisableDriver(VOID)
{
    return;
}

/******************************Public*Routine******************************\
* DrvEnablePDEV
*
* DDI function, Enables the Physical Device.
*
* Return Value: device handle to pdev.
*
\**************************************************************************/

DHPDEV DrvEnablePDEV(
    DEVMODEW   *pDevmode,       // Pointer to DEVMODE
    PWSTR       pwszLogAddress, // Logical address
    ULONG       cPatterns,      // number of patterns
    HSURF      *ahsurfPatterns, // return standard patterns
    ULONG       cjGdiInfo,      // Length of memory pointed to by pGdiInfo
    ULONG      *pGdiInfo,       // Pointer to GdiInfo structure
    ULONG       cjDevInfo,      // Length of following PDEVINFO structure
    DEVINFO    *pDevInfo,       // physical device information structure
    HDEV        hdev,           // HDEV, used for callbacks
    PWSTR       pwszDeviceName, // DeviceName - not used
    HANDLE      hDriver)        // Handle to base driver
{
    GDIINFO GdiInfo;
    DEVINFO DevInfo;
    PPDEV   ppdev;

    UNREFERENCED_PARAMETER(pwszLogAddress);
    UNREFERENCED_PARAMETER(pwszDeviceName);

    // Allocate a physical device structure.

    ppdev = (PPDEV) EngAllocMem(FL_ZERO_MEMORY, sizeof(PDEV), ALLOC_TAG);

    if (ppdev == (PPDEV) NULL)
    {
        DISPDBG((0, "VGA64K: Couldn't allocate PDEV buffer"));
        goto error0;
    }

    // Set up pointers in PDEV to temporary structures we build up to return.

    ppdev->pGdiInfo = &GdiInfo;
    ppdev->pDevInfo = &DevInfo;

    // Save the screen handle in the PDEV.

    ppdev->hDriver = hDriver;

    // Get the current screen mode information.  Set up device caps and devinfo.

    if (!bInitPDEV(ppdev,pDevmode))
    {
        DISPDBG((0,"vga64k Couldn't initialize PDEV"));
        goto error1;
    }

    // Initialize palette information.

    if (!bInitDefaultPalette(ppdev, &DevInfo))
    {
        DISPDBG((0, "VGA64K: DrvEnablePDEV failed bInitPalette"));
        goto error1a;
    }

    // Copy the devinfo into the engine buffer.

    memcpy(pDevInfo, ppdev->pDevInfo, min(sizeof(DEVINFO), cjDevInfo));

    // Set the pdevCaps with GdiInfo we have prepared to the list of caps for this
    // pdev.

    memcpy(pGdiInfo, ppdev->pGdiInfo, min(cjGdiInfo, sizeof(GDIINFO)));

    // Set NULL into pointers for stack allocated memory.

    ppdev->pGdiInfo = (GDIINFO *) NULL;
    ppdev->pDevInfo = (DEVINFO *) NULL;

    // Create a clip object we can use when we're given a NULL clip object:

    ppdev->pcoNull = EngCreateClip();
    if (ppdev->pcoNull == NULL)
    {
        RIP("Couldn't create clip");
        goto error2;
    }

    ppdev->pcoNull->iDComplexity     = DC_RECT;
    ppdev->pcoNull->rclBounds.left   = 0;
    ppdev->pcoNull->rclBounds.top    = 0;
    ppdev->pcoNull->rclBounds.right  = ppdev->cxScreen;
    ppdev->pcoNull->rclBounds.bottom = ppdev->cyScreen;
    ppdev->pcoNull->fjOptions        = OC_BANK_CLIP;

    // pvSaveScan0 is non-NULL only when enumerating banks:

    ppdev->pvSaveScan0 = NULL;

    // We're all done:

    return((DHPDEV) ppdev);

error2:  //@@@
error1a: //@@@
error1:
    EngFreeMem(ppdev);

error0:
    return((DHPDEV) 0);
}

/******************************Public*Routine******************************\
* DrvCompletePDEV
*
* Store the HPDEV, the engines handle for this PDEV, in the DHPDEV.
*
\**************************************************************************/

VOID DrvCompletePDEV(
DHPDEV dhpdev,
HDEV  hdev)
{
    ((PPDEV) dhpdev)->hdevEng = hdev;
}

/******************************Public*Routine******************************\
* DrvDisablePDEV
*
* Release the resources allocated in DrvEnablePDEV.  If a surface has been
* enabled DrvDisableSurface will have already been called.
*
\**************************************************************************/

VOID DrvDisablePDEV(
    DHPDEV dhpdev)
{
    PPDEV ppdev = (PPDEV) dhpdev;

    EngDeleteClip(ppdev->pcoNull);
    EngFreeMem(dhpdev);
}

/******************************Public*Routine******************************\
* DrvEnableSurface
*
* Enable the surface for the device.  Hook the calls this driver supports.
*
* Return: Handle to the surface if successful, 0 for failure.
*
\**************************************************************************/

HSURF DrvEnableSurface(
    DHPDEV dhpdev)
{
    PPDEV ppdev;
    HSURF hsurf;
    HSURF hsurfBm;
    SIZEL sizl;
    ULONG ulBitmapType;
    FLONG flHooks;

    // Create engine bitmap around frame buffer.

    ppdev = (PPDEV) dhpdev;

    if (!bInitSURF(ppdev, TRUE))
        goto error0;

    sizl.cx = ppdev->cxScreen;
    sizl.cy = ppdev->cyScreen;

    ulBitmapType = BMF_16BPP;
    flHooks      = HOOKS_BMF16BPP;

    ASSERTVGA(ppdev->ulBitCount == 16, "Can only handle 16bpp VGAs");

    hsurfBm = (HSURF) EngCreateBitmap(sizl,
                                      ppdev->lDeltaScreen,
                                      (ULONG) (ulBitmapType),
                                      (FLONG) (((ppdev->lDeltaScreen > 0)
                                          ? BMF_TOPDOWN
                                          : 0)),
                                      (PVOID) (ppdev->pjScreen));
    if (hsurfBm == 0)
    {
        RIP("Couldn't create surface");
        goto error0;
    }

    if (!EngAssociateSurface(hsurfBm, ppdev->hdevEng, 0))
    {
        RIP("Couldn't create or associate surface");
        goto error1;
    }

    ppdev->hsurfBm = hsurfBm;

    ppdev->pSurfObj = EngLockSurface(hsurfBm);
    if (ppdev->pSurfObj == NULL)
    {
        RIP("Couldn't lock surface");
        goto error1;
    }

    hsurf = EngCreateDeviceSurface((DHSURF) ppdev, sizl, BMF_16BPP);
    if (hsurf == 0)
    {
        RIP("Couldn't create surface");
        goto error2;
    }

    if (!EngAssociateSurface(hsurf, ppdev->hdevEng, flHooks))
    {
        RIP("Couldn't associate surface");
        goto error3;
    }

    ppdev->hsurfEng = hsurf;

    // Disable all the clipping.

    if (!bEnableBanking(ppdev))
    {
        RIP("Couldn't initialize banking");
        goto error3;
    }

    ppdev->pvTmp = (PVOID) EngAllocMem(0, TMP_BUFFER_SIZE, ALLOC_TAG);
    if (ppdev->pvTmp == NULL)
    {
        DISPDBG((0, "VGA64K: Couldn't allocate temporary buffer"));
        goto error4;
    }

    ASSERTVGA(ppdev->lNextScan != 0, "lNextScan shouldn't be zero");

    sizl.cx = ppdev->cxScreen;
    sizl.cy = TMP_BUFFER_SIZE / (sizl.cx * 2);

    ppdev->hbmTmp = EngCreateBitmap(sizl, sizl.cx*2, BMF_16BPP, 0,
                                    ppdev->pvTmp);
    if (ppdev->hbmTmp == (HBITMAP) 0)
    {
        RIP("Couldn't create temporary bitmap");
        goto error5;
    }

    ppdev->psoTmp = EngLockSurface((HSURF) ppdev->hbmTmp);
    if (ppdev->psoTmp == (SURFOBJ*) NULL)
    {
        RIP("Couldn't lock temporary surface");
        goto error6;
    }

    return(hsurf);

error6:
    EngDeleteSurface((HSURF) ppdev->hbmTmp);

error5:
    EngFreeMem(ppdev->pvTmp);

error4:
    vDisableBanking(ppdev);

error3:
    EngDeleteSurface(hsurf);

error2:
    EngUnlockSurface(ppdev->pSurfObj);

error1:
    EngDeleteSurface(hsurfBm);

error0:

//@@@
    DISPDBG((0,"Exiting DrvEnableSurface... \n"));
//@@@

    return((HSURF) 0);
}

/******************************Public*Routine******************************\
* DrvDisableSurface
*
* Free resources allocated by DrvEnableSurface.  Release the surface.
*
\**************************************************************************/

VOID DrvDisableSurface(
    DHPDEV dhpdev)
{
    PPDEV ppdev = (PPDEV) dhpdev;

    EngUnlockSurface(ppdev->psoTmp);
    EngDeleteSurface((HSURF) ppdev->hbmTmp);
    EngFreeMem(ppdev->pvTmp);
    EngDeleteSurface(ppdev->hsurfEng);
    vDisableSURF(ppdev);
    ppdev->hsurfEng = (HSURF) 0;
    vDisableBanking(ppdev);
}

/******************************Public*Routine******************************\
* DrvAssertMode
*
* This asks the device to reset itself to the mode of the pdev passed in.
*
\**************************************************************************/

BOOL
DrvAssertMode(
    DHPDEV dhpdev,
    BOOL bEnable)
{
    PPDEV   ppdev = (PPDEV) dhpdev;
    ULONG   ulReturn;

    if (bEnable)
    {
        // The screen must be reenabled, reinitialize the device to
        // a clean state.

        return(bInitSURF(ppdev, FALSE));
    }
    else
    {
        // Call the kernel driver to reset the device to a known state.

        if (EngDeviceIoControl(ppdev->hDriver,
                             IOCTL_VIDEO_RESET_DEVICE,
                             NULL,
                             0,
                             NULL,
                             0,
                             &ulReturn))
        {
            RIP("VIDEO_RESET_DEVICE failed");
            return(FALSE);
        }
        else
        {
            return(TRUE);
        }
    }
}

/******************************Public*Routine******************************\
* DrvGetModes
*
* Returns the list of available modes for the device.
*
\**************************************************************************/

ULONG DrvGetModes(
HANDLE hDriver,
ULONG cjSize,
DEVMODEW *pdm)

{

    DWORD cModes;
    DWORD cbOutputSize;
    PVIDEO_MODE_INFORMATION pVideoModeInformation, pVideoTemp;
    DWORD cOutputModes = cjSize / (sizeof(DEVMODEW) + DRIVER_EXTRA_SIZE);
    DWORD cbModeSize;

    DISPDBG((2, "Vga64k.dll: DrvGetModes\n"));

    cModes = getAvailableModes(hDriver,
                               (PVIDEO_MODE_INFORMATION *) &pVideoModeInformation,
                               &cbModeSize);

    if (cModes == 0)
    {
        DISPDBG((0, "VGA64k DISP DrvGetModes failed to get mode information"));
        return 0;
    }

    if (pdm == NULL)
    {
        cbOutputSize = cModes * (sizeof(DEVMODEW) + DRIVER_EXTRA_SIZE);
    }
    else
    {
        //
        // Now copy the information for the supported modes back into the output
        // buffer
        //

        cbOutputSize = 0;

        pVideoTemp = pVideoModeInformation;

        do
        {
            if (pVideoTemp->Length != 0)
            {
                if (cOutputModes == 0)
                {
                    break;
                }

                //
                // Zero the entire structure to start off with.
                //

                memset(pdm, 0, sizeof(DEVMODEW));

                //
                // Set the name of the device to the name of the DLL.
                //

                memcpy(pdm->dmDeviceName, DLL_NAME, sizeof(DLL_NAME));

                pdm->dmSpecVersion      = DM_SPECVERSION;
                pdm->dmDriverVersion    = DM_SPECVERSION;
                pdm->dmSize             = sizeof(DEVMODEW);
                pdm->dmDriverExtra      = DRIVER_EXTRA_SIZE;

                pdm->dmBitsPerPel       = pVideoTemp->NumberOfPlanes *
                                          pVideoTemp->BitsPerPlane;
                pdm->dmPelsWidth        = pVideoTemp->VisScreenWidth;
                pdm->dmPelsHeight       = pVideoTemp->VisScreenHeight;
                pdm->dmDisplayFrequency = pVideoTemp->Frequency;
                pdm->dmDisplayFlags     = 0;

                pdm->dmFields           = DM_BITSPERPEL       |
                                          DM_PELSWIDTH        |
                                          DM_PELSHEIGHT       |
                                          DM_DISPLAYFREQUENCY |
                                          DM_DISPLAYFLAGS     ;

                //
                // Go to the next DEVMODE entry in the buffer.
                //

                cOutputModes--;

                pdm = (LPDEVMODEW) ( ((ULONG)pdm) + sizeof(DEVMODEW) +
                                                   DRIVER_EXTRA_SIZE);

                cbOutputSize += (sizeof(DEVMODEW) + DRIVER_EXTRA_SIZE);

            }

            pVideoTemp = (PVIDEO_MODE_INFORMATION)
                (((PUCHAR)pVideoTemp) + cbModeSize);

        } while (--cModes);
    }

    EngFreeMem(pVideoModeInformation);

    return cbOutputSize;

}


/******************************Public*Routine******************************\
* bInitDefaultPalette
*
* Initializes default palette for PDEV.
*
\**************************************************************************/

BOOL bInitDefaultPalette(PPDEV ppdev, DEVINFO *pDevInfo)
{
    ppdev->hpalDefault =
    pDevInfo->hpalDefault = EngCreatePalette(PAL_BITFIELDS,
                                               0,(PULONG) NULL,
                                               ppdev->flRed,
                                               ppdev->flGreen,
                                               ppdev->flBlue);

    if (ppdev->hpalDefault == (HPALETTE) 0)
    {
        RIP("DISP bInitDefaultPalette failed EngCreatePalette\n");
        return(FALSE);
    }

    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\vga\disp\16bpp\textout.c ===
/******************************Module*Header*******************************\
* Module Name: TextOut.c
*
* Text
*
* Copyright (c) 1992 Microsoft Corporation
*
\**************************************************************************/

#include "driver.h"

/****************************************************************************
 * DrvTextOut
 ***************************************************************************/

BOOL DrvTextOut(
    SURFOBJ*  pso,
    STROBJ*   pstro,
    FONTOBJ*  pfo,
    CLIPOBJ*  pco,
    RECTL*    prclExtra,
    RECTL*    prclOpaque,
    BRUSHOBJ* pboFore,
    BRUSHOBJ* pboOpaque,
    POINTL*   pptlOrg,
    MIX       mix)
{
    BOOL   b;
    PPDEV  ppdev;

    ppdev = (PPDEV) pso->dhpdev;
    pso = ppdev->pSurfObj;

    // It may be that the opaquing rectangle is larger than the text rectangle,
    // so we'll want to use that to tell the bank manager which banks to
    // enumerate:

    pco = pcoBankStart(ppdev,
                       (prclOpaque != NULL) ? prclOpaque : &pstro->rclBkGround,
                       pso,
                       pco);

    do {
        b = EngTextOut(pso,
                       pstro,
                       pfo,
                       pco,
                       prclExtra,
                       prclOpaque,
                       pboFore,
                       pboOpaque,
                       pptlOrg,
                       mix);

    } while (b && bBankEnum(ppdev, pso, pco));

    return(b);
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\vga\disp\16bpp\paint.c ===
/******************************Module*Header*******************************\
* Module Name: paint.c
*
* Copyright (c) 1992 Microsoft Corporation
\**************************************************************************/

#include "driver.h"

/******************************Public*Data*********************************\
* MIX translation table
*
* Translates a mix 1-16, into an old style Rop 0-255.
*
\**************************************************************************/

BYTE gaMix[] =
{
    0xFF,  // R2_WHITE        - Allow rop = gaMix[mix & 0x0F]
    0x00,  // R2_BLACK
    0x05,  // R2_NOTMERGEPEN
    0x0A,  // R2_MASKNOTPEN
    0x0F,  // R2_NOTCOPYPEN
    0x50,  // R2_MASKPENNOT
    0x55,  // R2_NOT
    0x5A,  // R2_XORPEN
    0x5F,  // R2_NOTMASKPEN
    0xA0,  // R2_MASKPEN
    0xA5,  // R2_NOTXORPEN
    0xAA,  // R2_NOP
    0xAF,  // R2_MERGENOTPEN
    0xF0,  // R2_COPYPEN
    0xF5,  // R2_MERGEPENNOT
    0xFA,  // R2_MERGEPEN
    0xFF   // R2_WHITE
};


/**************************************************************************\
* DrvPaint
*
* Paint the clipping region with the specified brush
*
\**************************************************************************/

BOOL DrvPaint
(
    SURFOBJ  *pso,
    CLIPOBJ  *pco,
    BRUSHOBJ *pbo,
    POINTL   *pptlBrush,
    MIX       mix
)
{
    ROP4         rop4;

    rop4  = (gaMix[(mix >> 8) & 0x0F]) << 8;
    rop4 |= ((ULONG) gaMix[mix & 0x0F]);

    return(DrvBitBlt(
        pso,
        (SURFOBJ *) NULL,
        (SURFOBJ *) NULL,
        pco,
        (XLATEOBJ *) NULL,
        &pco->rclBounds,
        (POINTL *)  NULL,
        (POINTL *)  NULL,
        pbo,
        pptlBrush,
        rop4));
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\vga\disp\16bpp\i386\egavga.inc ===
page    ,132
;-----------------------------Module-Header-----------------------------;
; Module Name:	EGAVGA.INC
;
; This file contains the external definitions of the EGA/VGA specific
; locations which driver output routines need to reference.
;
; Copyright (c) 1992 Microsoft Corporation
;-----------------------------------------------------------------------;
; Restrictions:
;
;	The following rules apply to the use of the EGA/VGA registers
;	for the drivers (excluding pointer code and state detection
;	code):
;
;
;	1)  Routines are allowed to alter the following registers:
;
;	    Sequencer:
;
;		SEQ_DATA		SEQ_MAP_MASK
;
;	    Graphics Controller:
;
;		GRAF_ADDR
;		GRAF_DATA		GRAF_DATA_ROT
;		GRAF_SET_RESET		GRAF_READ_MAP
;		GRAF_ENAB_SR		GRAF_MODE
;		GRAF_COL_COMP		GRAF_BIT_MASK
;
;
;	2)  The following registers will always contain the indicated
;	    value.  Routines are not allowed to alter them:
;
;	    Sequencer:
;
;		SEQ_ADDR	set to point SEQ_MAP_MASK
;
;	    Graphics Controller:
;
;		GRAF_CDC	set appropriately for color model
;
;
;	3)  Rotation counts for GRAF_DATA_ROT are not allowed.
;
;
;	4)  The following EGA/VGA registers will contain the indicated
;	    value upon entry to a routine.  Any routine which alters
;	    them must restore them to the indicated state.
;
;		Map Mask	    all planes enabled
;		Enable Set/Reset    all planes disabled
;		Data Rotate	    Set, no rotation
;		Mode		    Processor write, data read
;		Bit Mask	    all bits enabled
;
;
;	5)  The Mode Register is always shadowed in EGA/VGA memory for
;	    the state detection code.  At interrupt time, the mode
;	    will be restored from the structure "shadowed_graf_mode".
;	    Any routine altering the Mode Register must keep this location
;	    current.  This is the only EGA/VGA register which requires
;	    shadowing.
;
;
;	6)  Pointer drawing will save and restore the contents of
;	    the processor latches.
;
;
;	7)  Pointer drawing will leave GRAF_ADDR set to GRAF_BIT_MASK.
;
;-----------------------------------------------------------------------;

;	Miscellaneous Registers used only at EGA/VGA initialization time

MISC_OUTPUT	EQU	0C2h		;Miscellaneous Output Register
CRTC_ADDR	EQU	0D4h		;CRTC Address Register for color mode
CRTC_DATA	EQU	0D5h		;CRTC Data    Register for color mode
GRAF_1_POS	EQU	0CCh		;Graphics 1 Address Register
GRAF_2_POS	EQU	0CAh		;Graphics 2 Address Register
ATTR_READ	EQU	0DAh		;Attribute Controler Read  Address
ATTR_WRITE	EQU	0C0h		;Attribute Controler Write Address
IN_STAT_0	EQU	0C2h		;Input Status Register 0
IN_STAT_1	EQU	0DAh		;Input Status Register 1



;	EGA/VGA Register Definitions.
;
;	The following definitions are the EGA/VGA registers and values
;	used by this driver.  All other registers are set up at
;	when the EGA/VGA is placed into graphics mode and never altered
;	afterwards.
;
;	All unspecified bits in the following registers must be 0.


EGA_BASE	EQU	300h		;Base address of the EGA (3xx)
VGA_BASE	EQU	300h		;Base address of the VGA (3xx)



;	EGA/VGA Register Definitions.

EGA_BASE	EQU	300h		;Base address of the EGA (3xx)
VGA_BASE	EQU	300h		;Base address of the VGA (3xx)

;	SEQUencer Registers Used

SEQ_ADDR	EQU	0C4h		;SEQUencer Address Register
SEQ_DATA	EQU	0C5h		;SEQUencer Data    Register

SEQ_MAP_MASK	EQU	02h		;Write Plane Enable Mask
MM_C0		EQU	00000001b	;  C0 plane enable
MM_C1		EQU	00000010b	;  C1 plane enable
MM_C2		EQU	00000100b	;  C2 plane enable
MM_C3		EQU	00001000b	;  C3 plane enable
MM_ALL		EQU	00001111b	;  All planes

SEQ_MODE	EQU	04h		;Memory Mode
SM_ALPHA	EQU	00000001b	;  Char map select enable
SM_EXTENDED	EQU	00000010b	;  Extended memory present
SM_ODD_PLANE	EQU	00000100b	;  Odd/even bytes to same plane


;	Graphics Controller Registers Used

GRAF_ADDR	EQU	0CEh		;Graphics Controller Address Register
GRAF_DATA	EQU	0CFh		;Graphics Controller Data    Register

GRAF_SET_RESET	EQU	00h		;  Set/Reset Plane Color
GRAF_ENAB_SR	EQU	01h		;  Set/Reset Enable
GRAF_COL_COMP	EQU	02h		;  Color Compare Register

GRAF_DATA_ROT	EQU	03h		;  Data Rotate Register
DR_ROT_CNT	EQU	00000111b	;    Data Rotate Count
DR_SET		EQU	00000000b	;    Data Unmodified
DR_AND		EQU	00001000b	;    Data ANDed with latches
DR_OR		EQU	00010000b	;    Data ORed	with latches
DR_XOR		EQU	00011000b	;    Data XORed with latches

GRAF_READ_MAP	EQU	04h		;  Read Map Select Register
RM_C0		EQU	00000000b	;    Read C0 plane
RM_C1		EQU	00000001b	;    Read C1 plane
RM_C2		EQU	00000010b	;    Read C2 plane
RM_C3		EQU	00000011b	;    Read C3 plane

GRAF_MODE	EQU	05h		;  Mode Register
M_PROC_WRITE	EQU	00000000b	;    Write processor data rotated
M_LATCH_WRITE	EQU	00000001b	;    Write latched data
M_COLOR_WRITE	EQU	00000010b	;    Write processor data as color
M_AND_WRITE	EQU	00000011b	;    Write (procdata AND bitmask)
M_DATA_READ	EQU	00000000b	;    Read selected plane
M_COLOR_READ	EQU	00001000b	;    Read color compare

GRAF_MISC	EQU	06h		;  Miscellaneous Register
MS_NON_ALPHA	EQU	00000001b	;    Char generator disabled
MS_ODD_EVEN	EQU	00000010b	;    Map odd addresses to even
MS_A0000_128K	EQU	00000000b	;    Memory present at A0000, 128kb
MS_A0000_64K	EQU	00000100b	;    Memory present at A0000, 64kb
MS_B0000_32K	EQU	00001000b	;    Memory present at B0000, 32kb
MS_B8000_32K	EQU	00001100b	;    Memory present at B8000, 32kb
MS_ADDR_MASK	EQU	00001100b

GRAF_CDC	EQU	07h		;  Color Don't Care Register
GRAF_BIT_MASK	EQU	08h		;  Bit Mask Register


;       Various sizes for EGA/VGA data structures

;-----------------------------------------------------------------------;
; On the EGA/VGA, the number of bits/pel is 4
; The number of bytes per scan is 80
;-----------------------------------------------------------------------;

BITS_PEL        EQU     4

;-----------------------------------------------------------------------;
; Helper flags for the xyCreateMasks call
;-----------------------------------------------------------------------;

PTRI_INVERT     EQU     1   ; !!! In WINGDIP.H when H2INC works
PTRI_ANIMATE    EQU     2   ; !!! In WINGDIP.H when H2INC works

;-----------------------------------------------------------------------;
; The pointer parameters are the size of the pointer as received from
; DeviceSetCursor.
;-----------------------------------------------------------------------;

PTR_HEIGHT	EQU	32
PTR_WIDTH	EQU	4			;Width in bytes of pointer
PTR_WIDTH_BITS	EQU	PTR_WIDTH*8		;Width in bits of pointer

;-----------------------------------------------------------------------;
; The work width/height is the size of a pointer as manipulated by
; the pointer drawing code.
;-----------------------------------------------------------------------;

WORK_WIDTH	EQU	PTR_WIDTH+1		;Width of mask, work area
WORK_HEIGHT	EQU	PTR_HEIGHT+0		;Height of mask, work area
MASK_LENGTH	EQU	WORK_WIDTH*WORK_HEIGHT	;#bytes in mask, work area
CLR_MASK_LENGTH	EQU	WORK_WIDTH*WORK_HEIGHT*BITS_PEL	;#bytes in color mask
	.errnz	BITS_PEL-4

;-----------------------------------------------------------------------;
; The save area parameters control the size of the buffer used for
; saveing the bits underneath the pointer image.  It should be a
; power of two to allow for easy wrap calculations.
;-----------------------------------------------------------------------;

SAVE_BUFFER_WIDTH  EQU	  8			  ;Width  of the save area
SAVE_BUFFER_HEIGHT EQU	  32			  ;Height of the save area
		   .errnz  PTR_WIDTH  GT SAVE_BUFFER_WIDTH
		   .errnz  PTR_HEIGHT GT SAVE_BUFFER_HEIGHT



=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\vga\disp\16bpp\screen.c ===
/******************************Module*Header*******************************\
* Module Name: screen.c
*
* Initializes the GDIINFO and DEVINFO structures for DrvEnablePDEV.
*
* Copyright (c) 1992 Microsoft Corporation
\**************************************************************************/

#include "driver.h"

#define SYSTM_LOGFONT {16,7,0,0,700,0,0,0,ANSI_CHARSET,OUT_DEFAULT_PRECIS,  \
                       CLIP_DEFAULT_PRECIS,DEFAULT_QUALITY,VARIABLE_PITCH | \
                       FF_DONTCARE,L"System"}
#define HELVE_LOGFONT {12,9,0,0,400,0,0,0,ANSI_CHARSET,OUT_DEFAULT_PRECIS,  \
                       CLIP_STROKE_PRECIS,PROOF_QUALITY,VARIABLE_PITCH | \
                       FF_DONTCARE,L"MS Sans Serif"}
#define COURI_LOGFONT {12,9,0,0,400,0,0,0,ANSI_CHARSET,OUT_DEFAULT_PRECIS,  \
                       CLIP_STROKE_PRECIS,PROOF_QUALITY,FIXED_PITCH |    \
                       FF_DONTCARE, L"Courier"}

// This is the basic devinfo for a default driver.  This is used as a base and customized based
// on information passed back from the miniport driver.

const DEVINFO gDevInfoFrameBuffer = {
    (GCAPS_OPAQUERECT | GCAPS_MONO_DITHER), /* Graphics capabilities         */

     // Should also implement GCAPS_HORIZSTRIKE so that the underlines
     // aren't drawn using DrvBitBlt

    SYSTM_LOGFONT,      // Default font description
    HELVE_LOGFONT,      // ANSI variable font description
    COURI_LOGFONT,      // ANSI fixed font description
    0,                  // Count of device fonts
    BMF_16BPP,          // Preferred DIB format
    8,                  // Width of dither
    8,                  // Height of dither
    0                   // Default palette to use for this device
};

/******************************Public*Routine******************************\
* bInitSURF
*
* Enables the surface.  Maps the frame buffer into memory.
*
\**************************************************************************/

BOOL bInitSURF(PPDEV ppdev, BOOL bFirst)
{
    VIDEO_MEMORY             VideoMemory;
    VIDEO_MEMORY_INFORMATION VideoMemoryInfo;
    DWORD                    ReturnedDataLength;

    // Set the mode.

    if (EngDeviceIoControl(ppdev->hDriver,
                         IOCTL_VIDEO_SET_CURRENT_MODE,
                         (LPVOID) &ppdev->ulMode,  // input buffer
                         sizeof(DWORD),
                         NULL,
                         0,
                         &ReturnedDataLength))
    {
        DISPDBG((0, "vga64k.dll: Failed SET_CURRENT_MODE\n"));
        return(FALSE);
    }

    if (bFirst)
    {
        // Get the linear memory address range.

        VideoMemory.RequestedVirtualAddress = NULL;

        if (EngDeviceIoControl(ppdev->hDriver,
                             IOCTL_VIDEO_MAP_VIDEO_MEMORY,
                             (PVOID) &VideoMemory, // input buffer
                             sizeof (VIDEO_MEMORY),
                             (PVOID) &VideoMemoryInfo, // output buffer
                             sizeof (VideoMemoryInfo),
                             &ReturnedDataLength))
        {
            DISPDBG((0, "vga64k.dll: Failed MAP_VIDEO_MEMORY\n"));
            return(FALSE);
        }
    }

    // Record the Frame Buffer Linear Address.

    if (bFirst)
    {
        ppdev->pjScreen =  (PBYTE) VideoMemoryInfo.FrameBufferBase;
    }

    // Set the various write mode values, so we don't have to read before write
    // later on

    vSetWriteModes(&ppdev->ulrm0_wmX);

    // Initialize the VGA registers to their default states, so that we
    // can be sure of drawing properly even when the miniport didn't
    // happen to set them the way we like them:

    vInitRegs(ppdev);

    // Since we just did a mode-set, we'll be in non-planar mode.  And make
    // sure we reset the bank manager (otherwise, after a switch from full-
    // screen, we may think we've got one bank mapped in, when in fact there's
    // a different one mapped in, and bad things would happen...).

    ppdev->flBank &= ~BANK_PLANAR;

    ppdev->rcl1WindowClip.bottom    = -1;
    ppdev->rcl2WindowClip[0].bottom = -1;
    ppdev->rcl2WindowClip[1].bottom = -1;

    ppdev->rcl1PlanarClip.bottom    = -1;
    ppdev->rcl2PlanarClip[0].bottom = -1;
    ppdev->rcl2PlanarClip[1].bottom = -1;

    return(TRUE);
}

/******************************Public*Routine******************************\
* vDisableSURF
*
* Disable the surface. Un-Maps the frame in memory.
*
\**************************************************************************/

VOID vDisableSURF(PPDEV ppdev)
{
    DWORD returnedDataLength;
    VIDEO_MEMORY videoMemory;

    videoMemory.RequestedVirtualAddress = (PVOID) ppdev->pjScreen;

    if (EngDeviceIoControl(ppdev->hDriver,
                        IOCTL_VIDEO_UNMAP_VIDEO_MEMORY,
                        (LPVOID) &videoMemory,
                        sizeof(VIDEO_MEMORY),
                        NULL,
                        0,
                        &returnedDataLength))
    {
        RIP("Failed UNMAP_VIDEO_MEMORY");
    }
}

/******************************Public*Routine******************************\
* bInitPDEV
*
* Determine the mode we should be in based on the DEVMODE passed in.
* Query mini-port to get information needed to fill in the DevInfo and the
* GdiInfo .
*
\**************************************************************************/

BOOL bInitPDEV(
PPDEV ppdev,
DEVMODEW *pDevMode)
{
    GDIINFO *pGdiInfo;
    ULONG cModes;
    PVIDEO_MODE_INFORMATION pVideoBuffer, pVideoModeSelected, pVideoTemp;
    VIDEO_COLOR_CAPABILITIES colorCapabilities;
    ULONG ulTemp;
    BOOL bSelectDefault;
    ULONG cbModeSize;
    BANK_POSITION BankPosition;
    ULONG ulReturn;

    pGdiInfo = ppdev->pGdiInfo;

    //
    // calls the miniport to get mode information.
    //

    cModes = getAvailableModes(ppdev->hDriver, &pVideoBuffer, &cbModeSize);

    if (cModes == 0)
    {
        DISPDBG((0, "vga64k.dll: no available modes\n"));
        return(FALSE);
    }

    //
    // Determine if we are looking for a default mode.
    //

    if ( ((pDevMode->dmPelsWidth) ||
          (pDevMode->dmPelsHeight) ||
          (pDevMode->dmBitsPerPel) ||
          (pDevMode->dmDisplayFlags) ||
          (pDevMode->dmDisplayFrequency)) == 0)
    {
        bSelectDefault = TRUE;
    }
    else
    {
        bSelectDefault = FALSE;
    }

    //
    // Now see if the requested mode has a match in that table.
    //

    pVideoModeSelected = NULL;
    pVideoTemp = pVideoBuffer;

    while (cModes--)
    {
        if (pVideoTemp->Length != 0)
        {
            if (bSelectDefault ||
                ((pVideoTemp->VisScreenWidth  == pDevMode->dmPelsWidth) &&
                 (pVideoTemp->VisScreenHeight == pDevMode->dmPelsHeight) &&
                 (pVideoTemp->BitsPerPlane *
                    pVideoTemp->NumberOfPlanes  == pDevMode->dmBitsPerPel) &&
                 (pVideoTemp->Frequency  == pDevMode->dmDisplayFrequency)))
            {
                pVideoModeSelected = pVideoTemp;
                DISPDBG((2, "vga64k: Found a match\n")) ;
                break;
            }
        }

        pVideoTemp = (PVIDEO_MODE_INFORMATION)
            (((PUCHAR)pVideoTemp) + cbModeSize);
    }

    //
    // If no mode has been found, return an error
    //

    if (pVideoModeSelected == NULL)
    {
        DISPDBG((0, "vga64k.dll: no valid modes\n"));
        EngFreeMem(pVideoBuffer);
        return(FALSE);
    }

    //
    // Fill in the GDIINFO data structure with the information returned from
    // the kernel driver.
    //

    ppdev->ulMode = pVideoModeSelected->ModeIndex;
    ppdev->cxScreen = pVideoModeSelected->VisScreenWidth;
    ppdev->cyScreen = pVideoModeSelected->VisScreenHeight;
    ppdev->ulBitCount = pVideoModeSelected->BitsPerPlane *
                        pVideoModeSelected->NumberOfPlanes;
    ppdev->lDeltaScreen = pVideoModeSelected->ScreenStride;

    ppdev->flRed = pVideoModeSelected->RedMask;
    ppdev->flGreen = pVideoModeSelected->GreenMask;
    ppdev->flBlue = pVideoModeSelected->BlueMask;

    if (!(pVideoModeSelected->AttributeFlags & VIDEO_MODE_NO_OFF_SCREEN))
    {
        ppdev->fl |= DRIVER_USE_OFFSCREEN;
    }

    pGdiInfo->ulVersion    = GDI_DRIVER_VERSION;
    pGdiInfo->ulTechnology = DT_RASDISPLAY;
    pGdiInfo->ulHorzSize   = pVideoModeSelected->XMillimeter;
    pGdiInfo->ulVertSize   = pVideoModeSelected->YMillimeter;

    pGdiInfo->ulHorzRes        = ppdev->cxScreen;
    pGdiInfo->ulVertRes        = ppdev->cyScreen;
    pGdiInfo->ulPanningHorzRes = ppdev->cxScreen;
    pGdiInfo->ulPanningVertRes = ppdev->cyScreen;
    pGdiInfo->cBitsPixel       = pVideoModeSelected->BitsPerPlane;
    pGdiInfo->cPlanes          = pVideoModeSelected->NumberOfPlanes;
    pGdiInfo->ulVRefresh       = pVideoModeSelected->Frequency;
    pGdiInfo->ulBltAlignment   = 1;     // We're not accelerated, and we don't
                                        //   care about window alignment

    pGdiInfo->ulLogPixelsX = pDevMode->dmLogPixels;
    pGdiInfo->ulLogPixelsY = pDevMode->dmLogPixels;

    pGdiInfo->flTextCaps   = TC_RA_ABLE | TC_SCROLLBLT;
    pGdiInfo->flRaster     = 0;         // DDI reservers flRaster

    pGdiInfo->ulDACRed     = pVideoModeSelected->NumberRedBits;
    pGdiInfo->ulDACGreen   = pVideoModeSelected->NumberGreenBits;
    pGdiInfo->ulDACBlue    = pVideoModeSelected->NumberBlueBits;

    pGdiInfo->ulAspectX    = 0x24;      // One-to-one aspect ratio
    pGdiInfo->ulAspectY    = 0x24;
    pGdiInfo->ulAspectXY   = 0x33;

    pGdiInfo->xStyleStep   = 1;         // A style unit is 3 pels
    pGdiInfo->yStyleStep   = 1;
    pGdiInfo->denStyleStep = 3;

    pGdiInfo->ptlPhysOffset.x = 0;
    pGdiInfo->ptlPhysOffset.y = 0;
    pGdiInfo->szlPhysSize.cx  = 0;
    pGdiInfo->szlPhysSize.cy  = 0;

    // RGB and CMY color info.

    // try to get it from the miniport.
    // if the miniport doesn ot support this feature, use defaults.

    if (EngDeviceIoControl(ppdev->hDriver,
                         IOCTL_VIDEO_QUERY_COLOR_CAPABILITIES,
                         NULL,
                         0,
                         &colorCapabilities,
                         sizeof(VIDEO_COLOR_CAPABILITIES),
                         &ulTemp))
    {
        DISPDBG((1, "vga64k DISP getcolorCapabilities failed \n"));

        pGdiInfo->ciDevice.Red.x = 6700;
        pGdiInfo->ciDevice.Red.y = 3300;
        pGdiInfo->ciDevice.Red.Y = 0;
        pGdiInfo->ciDevice.Green.x = 2100;
        pGdiInfo->ciDevice.Green.y = 7100;
        pGdiInfo->ciDevice.Green.Y = 0;
        pGdiInfo->ciDevice.Blue.x = 1400;
        pGdiInfo->ciDevice.Blue.y = 800;
        pGdiInfo->ciDevice.Blue.Y = 0;
        pGdiInfo->ciDevice.AlignmentWhite.x = 3127;
        pGdiInfo->ciDevice.AlignmentWhite.y = 3290;
        pGdiInfo->ciDevice.AlignmentWhite.Y = 0;

        pGdiInfo->ciDevice.RedGamma = 20000;
        pGdiInfo->ciDevice.GreenGamma = 20000;
        pGdiInfo->ciDevice.BlueGamma = 20000;

    }
    else
    {

        pGdiInfo->ciDevice.Red.x = colorCapabilities.RedChromaticity_x;
        pGdiInfo->ciDevice.Red.y = colorCapabilities.RedChromaticity_y;
        pGdiInfo->ciDevice.Red.Y = 0;
        pGdiInfo->ciDevice.Green.x = colorCapabilities.GreenChromaticity_x;
        pGdiInfo->ciDevice.Green.y = colorCapabilities.GreenChromaticity_y;
        pGdiInfo->ciDevice.Green.Y = 0;
        pGdiInfo->ciDevice.Blue.x = colorCapabilities.BlueChromaticity_x;
        pGdiInfo->ciDevice.Blue.y = colorCapabilities.BlueChromaticity_y;
        pGdiInfo->ciDevice.Blue.Y = 0;
        pGdiInfo->ciDevice.AlignmentWhite.x = colorCapabilities.WhiteChromaticity_x;
        pGdiInfo->ciDevice.AlignmentWhite.y = colorCapabilities.WhiteChromaticity_y;
        pGdiInfo->ciDevice.AlignmentWhite.Y = colorCapabilities.WhiteChromaticity_Y;

        // if we have a color device store the three color gamma values,
        // otherwise store the unique gamma value in all three.

        if (colorCapabilities.AttributeFlags & VIDEO_DEVICE_COLOR)
        {
            pGdiInfo->ciDevice.RedGamma = colorCapabilities.RedGamma;
            pGdiInfo->ciDevice.GreenGamma = colorCapabilities.GreenGamma;
            pGdiInfo->ciDevice.BlueGamma = colorCapabilities.BlueGamma;
        }
        else
        {
            pGdiInfo->ciDevice.RedGamma = colorCapabilities.WhiteGamma;
            pGdiInfo->ciDevice.GreenGamma = colorCapabilities.WhiteGamma;
            pGdiInfo->ciDevice.BlueGamma = colorCapabilities.WhiteGamma;
        }

    };

    pGdiInfo->ciDevice.Cyan.x = 0;
    pGdiInfo->ciDevice.Cyan.y = 0;
    pGdiInfo->ciDevice.Cyan.Y = 0;
    pGdiInfo->ciDevice.Magenta.x = 0;
    pGdiInfo->ciDevice.Magenta.y = 0;
    pGdiInfo->ciDevice.Magenta.Y = 0;
    pGdiInfo->ciDevice.Yellow.x = 0;
    pGdiInfo->ciDevice.Yellow.y = 0;
    pGdiInfo->ciDevice.Yellow.Y = 0;

    // No dye correction for raster displays.

    pGdiInfo->ciDevice.MagentaInCyanDye = 0;
    pGdiInfo->ciDevice.YellowInCyanDye = 0;
    pGdiInfo->ciDevice.CyanInMagentaDye = 0;
    pGdiInfo->ciDevice.YellowInMagentaDye = 0;
    pGdiInfo->ciDevice.CyanInYellowDye = 0;
    pGdiInfo->ciDevice.MagentaInYellowDye = 0;

    // Fill in the rest of the devinfo and GdiInfo structures.

    pGdiInfo->ulNumColors = (ULONG)-1;
    pGdiInfo->ulNumPalReg = 0;

    pGdiInfo->ulDevicePelsDPI  = 0;   // For printers only
    pGdiInfo->ulPrimaryOrder   = PRIMARY_ORDER_CBA;
    pGdiInfo->ulHTPatternSize  = HT_PATSIZE_4x4_M;
    pGdiInfo->ulHTOutputFormat = HT_FORMAT_16BPP;
    pGdiInfo->flHTFlags        = HT_FLAG_ADDITIVE_PRIMS;

    // Fill in the basic devinfo structure

    *(ppdev->pDevInfo) = gDevInfoFrameBuffer;

    EngFreeMem(pVideoBuffer);

    //
    // Check to see if the miniport supports
    // IOCTL_VIDEO_SET_BANK_POSITION.
    //

    BankPosition.ReadBankPosition = 0;
    BankPosition.WriteBankPosition = 0;

    if (EngDeviceIoControl(ppdev->hDriver,
                         IOCTL_VIDEO_SET_BANK_POSITION,
                         &BankPosition,
                         sizeof(BANK_POSITION),
                         NULL,
                         0,
                         &ulReturn) == NO_ERROR)
    {
        ppdev->BankIoctlSupported = TRUE;

    } else {

        ppdev->BankIoctlSupported = FALSE;
    }


    return(TRUE);
}

/******************************Public*Routine******************************\
* getAvailableModes
*
* Calls the miniport to get the list of modes supported by the kernel driver,
* and returns the list of modes supported by the diplay driver among those
*
* returns the number of entries in the videomode buffer.
* 0 means no modes are supported by the miniport or that an error occured.
*
* NOTE: the buffer must be freed up by the caller.
*
\**************************************************************************/

DWORD getAvailableModes(
HANDLE hDriver,
PVIDEO_MODE_INFORMATION *modeInformation,
DWORD *cbModeSize)
{
    ULONG ulTemp;
    VIDEO_NUM_MODES modes;
    PVIDEO_MODE_INFORMATION pVideoTemp;

    //
    // Get the number of modes supported by the mini-port
    //

    if (EngDeviceIoControl(hDriver,
            IOCTL_VIDEO_QUERY_NUM_AVAIL_MODES,
            NULL,
            0,
            &modes,
            sizeof(VIDEO_NUM_MODES),
            &ulTemp))
    {
        DISPDBG((0, "vga64k getAvailableModes failed VIDEO_QUERY_NUM_AVAIL_MODES\n"));
        return(0);
    }

    *cbModeSize = modes.ModeInformationLength;

    //
    // Allocate the buffer for the mini-port to write the modes in.
    //

    *modeInformation = (PVIDEO_MODE_INFORMATION)
                        EngAllocMem(FL_ZERO_MEMORY,
                                   modes.NumModes *
                                   modes.ModeInformationLength, ALLOC_TAG);

    if (*modeInformation == (PVIDEO_MODE_INFORMATION) NULL)
    {
        DISPDBG((0, "vga64k getAvailableModes failed EngAllocMem\n"));

        return 0;
    }

    //
    // Ask the mini-port to fill in the available modes.
    //

    if (EngDeviceIoControl(hDriver,
            IOCTL_VIDEO_QUERY_AVAIL_MODES,
            NULL,
            0,
            *modeInformation,
            modes.NumModes * modes.ModeInformationLength,
            &ulTemp))
    {

        DISPDBG((0, "vga64k getAvailableModes failed VIDEO_QUERY_AVAIL_MODES\n"));

        EngFreeMem(*modeInformation);
        *modeInformation = (PVIDEO_MODE_INFORMATION) NULL;

        return(0);
    }

    //
    // Now see which of these modes are supported by the display driver.
    // As an internal mechanism, set the length to 0 for the modes we
    // DO NOT support.
    //

    ulTemp = modes.NumModes;
    pVideoTemp = *modeInformation;

    //
    // Mode is rejected if it is not one plane, or not graphics, or is not
    // one of 16 bits per pel (that is all the vga64k currently supports)
    //

    while (ulTemp--)
    {
        if ((pVideoTemp->NumberOfPlanes != 1 ) ||
            !(pVideoTemp->AttributeFlags & VIDEO_MODE_GRAPHICS) ||
             (pVideoTemp->AttributeFlags & VIDEO_MODE_LINEAR) ||
            (pVideoTemp->BitsPerPlane != 16) ||

             //
             // This next condition says that either the mode doesn't
             // require broken rasters, or else the ScreenStride has
             // already been set to some funky value.  Some miniports
             // choose strides that have broken rasters, but they're
             // limited to unused areas of video memory.  I only know of
             // 1928, so we'll special case that.
             //

            (BROKEN_RASTERS(pVideoTemp->ScreenStride,
                            pVideoTemp->VisScreenHeight) &&
             (pVideoTemp->ScreenStride != 1928)))

        {
            pVideoTemp->Length = 0;
        }

        pVideoTemp = (PVIDEO_MODE_INFORMATION)
            (((PUCHAR)pVideoTemp) + modes.ModeInformationLength);
    }

    return modes.NumModes;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\vga\disp\16bpp\i386\driver.inc ===
;---------------------------Module-Header------------------------------;
; Module Name: driver.inc
;
; Contains prototypes for the 256 colour VGA driver.
;
; NOTE: Must mirror driver.h!
;
; Copyright (c) 1992 Microsoft Corporation
;-----------------------------------------------------------------------;

; Sizes assumed for 1-window and 2 RW-window banks.

BANK_SIZE_1_WINDOW      equ 10000h
BANK_SIZE_2RW_WINDOW    equ 8000h

; Specifies desired justification for requestion scan line within bank window

JustifyTop              equ 0
JustifyBottom           equ 1

; Specifies which window is to be mapped by two-window bank handler.

MapSourceBank           equ 0
MapDestBank             equ 1

;------------------------------------------------------------------------;

; Miscellaneous driver flags

DRIVER_PLANAR_CAPABLE   equ 1

; Bank status flags

BANK_BROKEN_RASTER1     equ 1       ; If bank1 or read bank has broken raster
BANK_BROKEN_RASTER2     equ 2       ; If bank2 or write bank has broken raster
BANK_BROKEN_RASTERS     equ (BANK_BROKEN_RASTER1 + BANK_BROKEN_RASTER2)

;------------------------------------------------------------------------;
; The Physical Device data structure.

PDEV struc
pdev_fl                     dd  ?   ; Driver flags
pdev_hDriver                dd  ?   ; Handle to \Device\Screen
pdev_hdevEng                dd  ?   ; Engine's handle to PDEV
pdev_hsurfEng               dd  ?   ; Engine's handle to surface
pdev_hsurfBm                dd  ?   ; Handle to the "punt" surface
pdev_pSurfObj               dd  ?   ; Pointer to the locked "punt" surface

pdev_hpalDefault            dd  ?   ; Handle to the default palette for device.

pdev_pjScreen               dd  ?   ; This is pointer to base screen address
pdev_cxScreen               dd  ?   ; Visible screen width
pdev_cyScreen               dd  ?   ; Visible screen height
pdev_ulMode                 dd  ?   ; Mode in which the mini-port driver is
pdev_lDeltaScreen           dd  ?   ; Distance from one scan to the next

pdev_flRed                  dd  ?   ; For bitfields device, Red Mask
pdev_flGreen                dd  ?   ; For bitfields device, Green Mask
pdev_flBlue                 dd  ?   ; For bitfields device, Blue Mask
pdev_ulBitCount             dd  ?   ; # of bits per pel 16 is only supported

pdev_pGdiInfo               dd  ?   ; Pointer to temporary buffer for GDIINFO struct
pdev_pDevInfo               dd  ?   ; Pointer to temporary buffer for DEVINFO struct

pdev_ulrm0_wmX              dd  ?   ; Values to set GC5 to to select read mode
                                    ;  0 together with write modes 0-3

; Off Screen Save Stuff:

pdev_hbmTmp                 dd  ?   ; Handle to temporary buffer
pdev_psoTmp                 dd  ?   ; Temporary surface
pdev_pvTmp                  dd  ?   ; Pointer to temporary buffer
pdev_cyTmp                  dd  ?   ; # of scans in temporary surface

; DCI Stuff:

pdev_bSupportDCI            dd  ?   ; Does miniport support DCI?

; Bank manager stuff common between planar and non-planar modes:

pdev_cTotalScans            dd  ?   ; Number of usable on & off screen scans
pdev_pBankInfo              dd  ?   ; Bank info for current mode
pdev_flBank                 dd  ?   ; Flags for current bank state
pdev_ulBitmapSize           dd  ?   ; Length of bitmap if there were no
                                    ;  banking, in CPU addressable bytes

pdev_ulWindowBank           dd  ?,? ; Current banks mapped into windows
                                    ;  0 & 1 (used in 2 window mode only)

pdev_pvBitmapStart          dd  ?   ; Single-window bitmap start pointer
                                    ;  (adjusted as necessary to make
                                    ;  window map in at proper offset)
pdev_pvBitmapStart2Window   dd  ?,? ; Double-window window 0 and 1 bitmap
                                    ; start

; Non-planar mode specific bank management control stuff:

pdev_vbtBankingType         dd  ?   ; Type of banking
pdev_pfnBankSwitchCode      dd  ?   ; Pointer to bank switch code
pdev_lNextScan              dd  ?   ; Offset to next bank in bytes
pdev_pjJustifyTopBank       dd  ?   ; Pointer to lookup table for
                                    ;  converting scans to banks
pdev_pbiBankInfo            dd  ?   ; Pointer to array of bank clip info
pdev_ulJustifyBottomOffset  dd  ?   ; Number of scans from top to bottom
                                    ;  of bank, for bottom justifying
pdev_iLastBank              dd  ?   ; Index of last valid bank in
pdev_ulBank2RWSkip          dd  ?   ; Offset from one bank index to next
                                    ;  to make two 32K banks appear to be
                                    ;  one seamless 64K bank

pdev_pfnBankControl         dd  ?   ; Pointer to bank control function
pdev_pfnBankControl2Window  dd  ?   ; Pointer to double-window bank
                                    ;  control function

pdev_pfnBankNext            dd  ?   ; Pointer to next bank function
pdev_pfnBankNext2Window     dd  ?   ; Pointer to double-window next bank
                                    ;  function
pdev_rcl1WindowClip         db  (size RECTL) dup (?)
                                    ; Single-window banking clip rect
pdev_rcl2WindowClip         db  (2*(size RECTL)) dup (?)
                                    ; Double-window banking clip rects for
                                    ;  windows 0 & 1

; Planar mode specific bank management control stuff:

pdev_vbtPlanarType          dd  ?   ; Type of planar banking
pdev_pfnPlanarSwitchCode    dd  ?   ; Pointer to planar bank switch code
pdev_lPlanarNextScan        dd  ?   ; Offset to next planar bank in bytes
pdev_pjJustifyTopPlanar     dd  ?   ; Pointer to lookup table for
                                    ;  converting scans to planar banks
pdev_pbiPlanarInfo          dd  ?   ; Pointer to array of bank clip info
pdev_ulPlanarBottomOffset   dd  ?   ; Number of scans from top to bottom
                                    ;  of bank, for bottom justifying
pdev_iLastPlanar            dd  ?   ; Index of last valid bank in
pdev_ulPlanar2RWSkip        dd  ?   ; Offset from one bank index to next
                                    ;  to make two 32K banks appear to be
                                    ;  one seamless 64K bank

pdev_pfnPlanarControl       dd  ?   ; Pointer to bank control function
pdev_pfnPlanarControl2      dd  ?   ; Pointer to double-window bank
                                    ;  control function

pdev_pfnPlanarNext          dd  ?   ; Pointer to next bank function
pdev_pfnPlanarNext2         dd  ?   ; Pointer to double-window next bank
                                    ;  function
pdev_rcl1PlanarClip         db  (size RECTL) dup (?)
                                    ; Single-window banking clip rect
pdev_rcl2PlanarClip         db  (2*(size RECTL)) dup (?)
                                    ; Double-window banking clip rects for

pdev_pfnPlanarEnable        dd  ?   ; Function to enable planar mode
pdev_pfnPlanarDisable       dd  ?   ; Function to disable planar mode

; Smart bank management stuff:

pdev_iLastScan              dd  ?   ; Last scan we want to enumerate
pdev_pvScanScan0            dd  ?   ; Surface's original pvScan0
pdev_rclSaveBounds          db  (size RECTL) dup (?)
                                    ; Clip object's original bounds
pdev_pcoNull                dd  ?   ; Pointer to empty clip object
pdev_iSaveDComplexity       db  ?   ; Clip object's original complexity
pdev_fjSaveOptions          db  ?   ; Clip object's original flags
pdev_ajFiller               db  ?,? ; Pack to dword alignment
PDEV ends

pdev_rcl2WindowClipS        equ     (pdev_rcl2WindowClip)
pdev_rcl2WindowClipD        equ     (pdev_rcl2WindowClip + (size RECTL))

pdev_rcl2PlanarClipS        equ     (pdev_rcl2PlanarClip)
pdev_rcl2PlanarClipD        equ     (pdev_rcl2PlanarClip + (size RECTL))

pdev_pvBitmapStart2WindowS  equ     (pdev_pvBitmapStart2Window)
pdev_pvBitmapStart2WindowD  equ     (pdev_pvBitmapStart2Window + dword)

;------------------------------------------------------------------------;

; Macro to do a simple RET, with no stack stuff, in a proc.

PLAIN_RET macro
        db      0c3h
        endm

; Macro to replace a CALL followed immediately by a JMP:

CALL_AND_JUMP macro CALL_ADDR,JUMP_ADDR
        push    offset JUMP_ADDR
        jmp     CALL_ADDR
        endm
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\vga\disp\16bpp\lines.c ===
/******************************Module*Header*******************************\
* Module Name: lines.c
*
* Banked Frame Buffer Line support
*
* Copyright (c) 1993 Microsoft Corporation
*
\**************************************************************************/

#include "driver.h"

/******************************************************************************
 * DrvStrokePath
 *****************************************************************************/
BOOL DrvStrokePath(
SURFOBJ   *pso,
PATHOBJ   *ppo,
CLIPOBJ   *pco,
XFORMOBJ  *pxo,
BRUSHOBJ  *pbo,
POINTL    *pptlBrushOrg,
LINEATTRS *plineattrs,
MIX       mix)
{
    BOOL    b;
    PPDEV   ppdev;
    RECTL   rclScans;
    RECTFX  rcfx;
    FLOAT_LONG  elSavedStyleState = plineattrs->elStyleState;

    PATHOBJ_vGetBounds(ppo, &rcfx);

    // We add 15 to yBottom before dividing by 16 to get its ceiling,
    // plus add 16 to make the rectangle lower exclusive:

    rclScans.bottom = (rcfx.yBottom + 31) >> 4;
    rclScans.top    = (rcfx.yTop) >> 4;

    ppdev = (PPDEV) pso->dhpdev;
    pso = ppdev->pSurfObj;

    pco = pcoBankStart(ppdev, &rclScans, pso, pco);

    do
    {
        // we pass the entire line through each time, so we
        // must reset the style state to the beginning of
        // the line (because the engine updates it).

        plineattrs->elStyleState = elSavedStyleState;

        b = EngStrokePath(pso,
                          ppo,
                          pco,
                          pxo,
                          pbo,
                          pptlBrushOrg,
                          plineattrs,
                          mix);

    } while (b && bBankEnum(ppdev, pso, pco));

    return(b);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\vga\disp\16bpp\i386\ropdefs.inc ===
;----------------------------Module-Header------------------------------;
; Module Name: ROPDEFS.BLT
;
; Constants relating to raster operation definitions.
;
; Copyright (c) 1988 - 1992  Microsoft Corporation
;
; These constants are used mainly in the file ROPTABLE.BLT, in which
; the raster operation code templates are defined.
;
; This file is part of a set that makes up the Windows BitBLT function
; at driver-level.
;-----------------------------------------------------------------------;

        subttl  Raster Operation Definitions
        page


if 0                                    ; Not passed to us anymore !!!

;       Raster Op Definitions
;
;
;       The include file COMMENT.BLT contains a good description
;       of the encoding of the raster operations.  It should be
;       read before examining the definitions that follow.
;
;       The sixteen-bit number indicating which raster Op is to be
;       performed is encoded in the following manner:


EPS_OFF =       0000000000000011b       ;Offset within parse string
EPS_INDEX =     0000000000011100b       ;Parse string index
LogPar  =       0000000000100000b       ;(1 indicates implied NOT as Logop6)
LogOp1  =       0000000011000000b       ;Logical Operation #1
LogOp2  =       0000001100000000b       ;Logical Operation #2
LogOp3  =       0000110000000000b       ;Logical Operation #3
LogOp4  =       0011000000000000b       ;Logical Operation #4
LogOp5  =       1100000000000000b       ;Logical Operation #5


;       The parity bit is used to encode an optional sixth logical operation
;       which will always be a "NOT".  In most cases this is used to get an
;       even number of "NOT"s so that reduction can take place (two sequential
;       trailing "NOT"s cancel each other out and thus are eliminated).



;       Each LogOp (Logical Operation) is encoded as follows:

LogNOT  =       00b                     ;NOT result
LogXOR  =       01b                     ;XOR result with next operand
LogOR   =       10b                     ;OR  result with next operand
LogAND  =       11b                     ;AND result with next operand



;       The parse string is a string which contains the operands for
;       the logical operation sequences (source, destination, pattern).
;       The logic opcodes are applied to the current result and the next
;       element of the given string (unless the LogOp is a NOT which only
;       affects the result).
;
;       The string is encoded as eight two-bit numbers indicating which
;       operand is to be used

opDefs          struc
  OpSpec        db      ?                 ;Special Operand as noted below
  OpSrc         db      ?                 ;Operand is source field
  OpDest        db      ?                 ;Operand is destination field
  OpPat         db      ?                 ;Operand is pattern field
opDefs          ends



;       The special operand is used for a few rops that would not fit into
;       an RPN format.  On the first occurance of an OpSpec, the current result
;       is "PUSHED", and the next operand is loaded.  On the second occurance
;       of the OpSpec, the given logic operation is performed between the
;       current result and the "PUSHED" value.
;
;       **NOTE**  Since there can be no guarantee that the client will call
;       the BLT routine with one of the 256 published raster ops, it is
;       possible that a value might be "PUSHED" and then never "POPPED".
;       If these "PUSHES" are made to the stack, then care must be made to
;       remove the "PUSHED" value.
;
;       In any case, since the raster op was not one of the published
;       "magic numbers", the BLT can be aborted or the result can be
;       computed to the extent possible.  The only restriction is that it
;       must not crash the system (i.e. don't leave extra stuff on the stack).
;
;               Simply: Compute garbage, but don't crash!




;       Define the parse strings to be allocated later.
;
;       An example parse string for the pattern "SDPSDPSD" would be
;       "0110110110110110b"


parseStr0       =       07AAAh          ;src,pat,dest,dest,dest,dest,dest,dest
parseStr1       =       079E7h          ;src,pat,dest,src,pat,dest,src,pat
parseStr2       =       06DB6h          ;src,dest,pat,src,dest,pat,src,dest
parseStr3       =       0AAAAh          ;dest,dest,dest,dest,dest,dest,dest,dest
parseStr4       =       0AAAAh          ;dest,dest,dest,dest,dest,dest,dest,dest
parseStr5       =       04725h          ;src,spec,src,pat,spec,dest,src,src
parseStr6       =       04739h          ;src,spec,src,pat,spec,pat,dest,src
parseStr7       =       04639h          ;src,spec,src,dest,spec,pat,dest,src



;       The following equates are for certain special functions that are
;       derived from the very first string (index of SpecParseStrIndex).
;
;       These strings will have their innerloops special cased for
;       speed enhancements (i.e MOVSx and STOSx for pattern copys and
;       white/black fill, and MOVSx for source copy if possible)

PAT_COPY        equ     0021h           ;P    - dest = Pattern
NOTPAT_COPY     equ     0001h           ;Pn   - dest = NOT Pattern
FILL_BLACK      equ     0042h           ;DDx  - dest = 0 (black)
FILL_WHITE      equ     0062h           ;DDxn - dest = 1
SOURCE_COPY     equ     0020h           ;S    - dest = source


        errnz   LogXOR-01b              ;These must hold true for above equates
        errnz   LogOp1-0000000011000000b
        errnz   LogPar-0000000000100000b
        errnz   parseStr0-7AAAh         ;  plus the string must be SPDD


SPEC_PARSE_STR_INDEX equ        0       ;Special cased strings index

endif

;       The raster operation table consists of a word for each of
;       the first 128 raster operations (00 through 7F).  The second
;       half of the raster operations (FF through 80) are the inverse
;       of the first half.
;
;       The table is encoded as follows:
;
;           N S P LLL OOOOOOOOOO
;           | | |  |      |
;           | | |  |      |_____  Offset of code from roptable.
;           | | |  |
;           | | |  |____________  Length index
;           | | |
;           | | |_______________  Pattern is present
;           | |
;           | |_________________  Source is present
;           |
;           |___________________  Generate trailing NOT
;
;
;       To map the ROPS 80h through FFh to 00h through 7Fh, take the
;       1's complement of the ROP, and invert 'N' above.
;
;
;       Notes:
;
;           1)  An offset of 0 is reserved for source copy.  This
;               was done to reduce the number of LLLs to 8, so that
;               the above encoding could fit into a 16-bit integer.
;
;
;           2)  LLL only allows a maximum of 8 different template sizes!
;               Actual length is at roptable+256+LLL.
;
;
;
;
;       ROP is the macro that generates the equates which will be
;       stored into the roptable as specified above.
;
;       Usage:
;
;           ROPDEF      Pattern,Number
;
;       Where
;
;           Pattern     Is the RPN definition of the raster operation.
;                       It is used as the label of the first byte of
;                       the template.  It also is used to determine
;                       is there is a (S)ource, (P)attern, and if the
;                       final result is to be (n)egated.
;
;           Number      is the boolean result of the raster operation
;                       based on a P=F0, S=CC, and D=AA.  These labels
;                       and indexes can be found in the file COMMENT.BLT
;
;                       Since there are many equivelent boolean expresions,
;                       some of the rops will not match the label given.
;                       The label is for reference only.  The final result
;                       is what counts.



ROPOffset       equ     0000001111111111b
ROPLength       equ     0001110000000000b
SOURCE_PRESENT  equ     0010000000000000b
PATTERN_PRESENT equ     0100000000000000b
NEGATE_NEEDED   equ     1000000000000000b


;       Define the eight template length indices.

ROPLen0         equ     0
ROPLen2         equ     1
ROPLen4         equ     2
ROPLen6         equ     3
ROPLen8         equ     4
ROPLen10        equ     5
ROPLen12        equ     6
ROPLen14        equ     7

; Binary raster ops
R2_BLACK            equ 1
R2_NOTMERGEPEN      equ 2
R2_MASKNOTPEN       equ 3
R2_NOTCOPYPEN       equ 4
R2_MASKPENNOT       equ 5
R2_NOT              equ 6
R2_XORPEN           equ 7
R2_NOTMASKPEN       equ 8
R2_MASKPEN          equ 9
R2_NOTXORPEN        equ 10
R2_NOP              equ 11
R2_MERGENOTPEN      equ 12
R2_COPYPEN          equ 13
R2_MERGEPENNOT      equ 14
R2_MERGEPEN         equ 15
R2_WHITE            equ 16
R2_LAST             equ 16



=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\vga\disp\16bpp\i386\unroll.inc ===
;---------------------------Module-Header------------------------------;
; Module Name: unroll.inc
;
; Equates and macros for loop unrolling.
;
; Copyright (c) 1992 Microsoft Corporation
;-----------------------------------------------------------------------;

; Module including this must define LOOP_UNROLL_SHIFT. the log2 of the number
; of times you want loops in this module unrolled. For example,
; LOOP_UNROLL_SHIFT of 3 yields 2**3 = 8 times unrolling. This is the only
; thing you need to change to control unrolling.

; # of times to unroll the loop, calculated as 2**n, where n is the
; user-specified log2 of # of times to unroll the loop.

LOOP_UNROLL_COUNT equ   (1 shl LOOP_UNROLL_SHIFT)

;-----------------------------------------------------------------------;
; Macro to generate an unrolled loop of UNROLL_COUNT instances of BASE_MACRO,
; passing the base macro the info needed to construct a label of the form
; BASE_LABELxxx, where xxx is UNROLL_COUNT the first time, and counts down by
; one each time thereafter.

UNROLL_LOOP macro BASE_MACRO,BASE_LABEL,UNROLL_COUNT

INDEX=UNROLL_COUNT
        rept UNROLL_COUNT ;-------------------------;
        &BASE_MACRO &BASE_LABEL,%INDEX
INDEX=INDEX-1
        endm    ;-----------------------------------;

        endm    ;-----------------------------------;

;-----------------------------------------------------------------------;
; Macro to generate a dword memory variable that points to the label
; specified by concatenating the label and the index.

DEFINE_DD macro BASE_LABEL,INDEX ;------------------;
        dd      &BASE_LABEL&INDEX
        endm    ;-----------------------------------;
        
;-----------------------------------------------------------------------;
; Macro to generate a table of vectors into an unrolled loop, for entering
; to handle all possible fractional loops.

UNROLL_LOOP_ENTRY_TABLE macro TABLE,BASE_LABEL,UNROLL_COUNT
        align   4
TABLE label  dword
        DEFINE_DD       BASE_LABEL,%&UNROLL_COUNT

INDEX=1
        rept    UNROLL_COUNT-1
        DEFINE_DD       BASE_LABEL,%INDEX
INDEX=INDEX+1
        endm    ;-----------------------------------;

        endm    ;-----------------------------------;

;-----------------------------------------------------------------------;
; Given a loop count, a vector table, and unrolling parameters, this generates
; COUNT_DEST = # of times to execute unrolled loop, VEC_DEST = entry point into
; unrolled loop to perform whatever fractional loop is needed. Assumes dests
; are registers.
        
SET_UP_UNROLL_VARS macro COUNT_DEST,VEC_DEST,COUNT_SOURCE,VEC_TABLE,UNROLL_SHIFT
        mov     &VEC_DEST&,&COUNT_SOURCE&       ;copy count to vector dest to
                                                ; work with it
        ifdifi  <&COUNT_SOURCE&>,<&COUNT_DEST&>
        mov     &COUNT_DEST&,&COUNT_SOURCE&     ;copy to count dest too, if not
        endif                                   ; same as count source
        add     &COUNT_DEST&,(1 shl LOOP_UNROLL_SHIFT)-1 ;round count up
        and     &VEC_DEST&,(1 shl LOOP_UNROLL_SHIFT)-1
                                            ;fractional part of unrolled loop
        shr     &COUNT_DEST&,UNROLL_SHIFT    ;# of repetitions of unrolled loop
        mov     &VEC_DEST&,&VEC_TABLE&[&VEC_DEST&*4]
                                            ;place to jump into the unrolled
                                            ; loop so as to handle the
                                            ; fractional part first
        endm    ;-----------------------------------;

;-----------------------------------------------------------------------;
; Given a loop count, a vector table, and unrolling parameters, this generates
; COUNT_DEST = # of times to execute unrolled loop, VEC_DEST = entry point into
; unrolled loop to perform whatever fractional loop is needed. Assumes dests
; are registers.
        
SET_UP_UNROLL_AND_BRANCH macro COUNT_REG,VEC_REG,VEC_TABLE,UNROLL_SHIFT
        mov     &VEC_REG&,&COUNT_REG&       ;copy count to vector dest to
                                            ; work with it
        add     &COUNT_reg&,(1 shl LOOP_UNROLL_SHIFT)-1 ;round count up
        and     &VEC_REG&,(1 shl LOOP_UNROLL_SHIFT)-1
                                            ;fractional part of unrolled loop
        shr     &COUNT_REG&,UNROLL_SHIFT    ;# of repetitions of unrolled loop
        jmp     dword ptr &VEC_TABLE&[&VEC_REG&*4]
                                            ;jump into the unrolled loop so as
					    ; to handle the fractional part
					    ; first
        endm    ;-----------------------------------;

;-----------------------------------------------------------------------;


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\vga\disp\16bpp\i386\scroll.asm ===
;---------------------------Module-Header------------------------------;
; Module Name: scroll.asm
;
; Copyright (c) 1992-1993 Microsoft Corporation
;-----------------------------------------------------------------------;

;-----------------------------------------------------------------------;
; VOID vPlanarCopyBits(ppdev, prclDest, pptlSrc);
;
; Input:
;
;  ppdev    - surface on which to copy
;  prcldest - pointer to destination rectangle
;  pptlsrc  - pointer to source upper left corner
;
; Performs accelerated SRCCOPY screen-to-screen blts.
;
;-----------------------------------------------------------------------;
;
; NOTE: This handles only quad-pixel aligned blits!
;
; NOTE: Assumes all rectangles have positive heights and widths. Will
; not work properly if this is not the case.
;
;-----------------------------------------------------------------------;


;-----------------------------------------------------------------------;
; Set LOOP_UNROLL_SHIFT to the log2 of the number of times you want loops in
; this module unrolled. For example, LOOP_UNROLL_SHIFT of 3 yields 2**3 = 8
; times unrolling. This is the only thing you need to change to control
; unrolling.

LOOP_UNROLL_SHIFT equ 1

;-----------------------------------------------------------------------;

        .386

        .model  small,c

        assume cs:FLAT,ds:FLAT,es:FLAT,ss:FLAT
        assume fs:nothing,gs:nothing

        .xlist
        include stdcall.inc             ;calling convention cmacros
        include i386\strucs.inc
        include i386\driver.inc
        include i386\unroll.inc
        include i386\egavga.inc

        .list

;-----------------------------------------------------------------------;

        .code

        EXTRNP          bPuntScreenToScreenCopyBits,20

        .data

; Bits for block copier tables:

BLOCK_RIGHT_TO_LEFT     equ 4
BLOCK_LEFT_EDGE         equ 2
BLOCK_RIGHT_EDGE        equ 1

;-----------------------------------------------------------------------;
; Table of block copiers for various horizontal directions, with the
; look-up index a 3-bit field as follows:
;
; Bit 2 (BLOCK_RIGHT_TO_LEFT) = 1 if right-to-left copy
; Bit 1 (BLOCK_LEFT_EDGE)     = 1 if left edge must be copied
; Bit 0 (BLOCK_RIGHT_EDGE)    = 1 if right edge must be copied

        align   4
MasterBlockTable label dword

        dd      copy_just_middle_block
        dd      Block_WR
        dd      Block_LW
        dd      Block_LWR

        dd      copy_just_middle_block
        dd      Block_RW
        dd      Block_WL
        dd      Block_RWL

        align   4
TopToBottomLoopTable label dword
        dd      0                               ;Not used - unbanked case
        dd      top_to_bottom_1RW
        dd      top_to_bottom_2RW
        dd      top_to_bottom_2RW

        align   4
BottomToTopLoopTable label dword
        dd      0                               ;Not used - unbanked case
        dd      bottom_to_top_1RW
        dd      bottom_to_top_2RW
        dd      bottom_to_top_2RW

        align   4
SetUpForCopyDirection label dword
        dd      left_to_right_top_to_bottom     ;CD_RIGHTDOWN
        dd      right_to_left_top_to_bottom     ;CD_LEFTDOWN
        dd      left_to_right_bottom_to_top     ;CD_RIGHTUP
        dd      right_to_left_bottom_to_top     ;CD_LEFTUP

LeftMaskTable label dword
        dd      01111b
        dd      01100b

RightMaskTable label dword
        dd      00000b
        dd      00011b

;-----------------------------------------------------------------------;

        .code

Block_WR:
        push    offset copy_right_block
        jmp     copy_middle_block

Block_LW:
        push    offset copy_middle_block
        jmp     copy_left_block

Block_LWR:
        push    offset copy_right_block
        push    offset copy_middle_block
        jmp     copy_left_block

Block_RW:
        push    offset copy_middle_block
        jmp     copy_right_block

Block_WL:
        push    offset copy_left_block
        jmp     copy_middle_block

Block_RWL:
        push    offset copy_left_block
        push    offset copy_middle_block
        jmp     copy_right_block

;-----------------------------------------------------------------------;

cProc   vPlanarCopyBits,12,<    \
        uses esi edi ebx,       \
        ppdev:    ptr PDEV,     \
        prclDest: ptr RECTL,    \
        pptlSrc:  ptr POINTL    >

; Variables used in block copiers:

        local pfnCopyBlocks:       ptr   ;pointer to block copy routines

        local ulMiddleSrc:         dword ;bitmap offset to 1st source
        local ulMiddleDest:        dword ;bitmap offset to 1st dest
        local lMiddleDelta:        dword ;delta from end of middle scan to next
        local ulBlockHeight:       dword ;number of scans to be copied in block
        local cjMiddle:            dword ;number of bytes to be copied on scan

        local ulLeftSrc:           dword ;bitmap offset to left source byte edge
        local ulLeftDest:          dword ;bitmap offset to left dest byte edge
        local ulRightSrc:          dword ;bitmap offset to right source byte edge
        local ulRightDest:         dword ;bitmap offset to right dest byte edge
        local lDelta:              dword ;delta between scans

        local ulLeftMask:          dword ;byte mask for left-edge copies
        local ulRightMask:         dword ;byte mask for right-edge copies

        local rclDest[size RECTL]: byte  ;left and right values always valid
        local ptlSrc[size POINTL]: byte  ;x value always valid

        local ulCurrentSrcScan:    dword ;real current source scan
        local ulCurrentDestScan:   dword ;real current destination scan
        local ulLastDestScan:      dword ;last destination scan

; Set the bit mask to disable all bits, so we can copy through the latches:

        mov     edx,VGA_BASE + GRAF_ADDR
        mov     eax,(0 shl 8) + GRAF_BIT_MASK
        out     dx,ax

; Figure out which direction to do the copies:

        mov     esi,pptlSrc
        mov     edi,prclDest
        mov     eax,[esi].ptl_y
        cmp     eax,[edi].yTop
        jl      planar_bottom_to_top

        mov     eax,[esi].ptl_x
        cmp     eax,[edi].xLeft
        jge     short left_to_right_top_to_bottom       ; CD_RIGHTDOWN
        jmp     right_to_left_top_to_bottom             ; CD_LEFTDOWN

planar_bottom_to_top:
        mov     eax,[esi].ptl_x
        cmp     eax,[edi].xLeft
        jge     left_to_right_bottom_to_top             ; CD_RIGHTUP
        jmp     right_to_left_bottom_to_top             ; CD_LEFTUP

all_done:

; Enable bit mask for all bits:

        mov     edx,VGA_BASE + GRAF_ADDR
        mov     eax,(0ffh shl 8) + GRAF_BIT_MASK
        out     dx,ax

; Enable writes to all planes and reset direction flag:

        mov     edx,VGA_BASE + SEQ_DATA
        mov     al,MM_ALL
        out     dx,al

        cld

        cRet    vPlanarCopyBits

;=======================================================================;
;==================== Direction Dependent Setup ========================;
;=======================================================================;

;-----------------------------------------------------------------------;
; Set-up code for left-to-right, top-to-bottom copies.
;
; Input:
;       esi - pptlSrc
;       edi - prclDest
;-----------------------------------------------------------------------;

        public left_to_right_top_to_bottom
left_to_right_top_to_bottom::

; Need to set-up: ulMiddleSrc, ulMiddleDest, lMiddleDelta, cjMiddle
;                 ulLeftSrc, ulLeftDest, ulLeftMask
;                 lDelta
;                 ulRightSrc, ulRightDest, ulRightMask
;                 ulCurrentDestScan, ulLastDestScan
;                 pfnCopyBlocks
;                 ptlSrc.x, rclDest.left, rclDest.right

; lDelta = ppdev->lPlanarScan
; ulCurrentSrcScan  = pptl->y
; ulLeftSrc         = pptl->y       * lDelta + (pptl->x >> 1)
; ulCurrentDestScan = prclDest->top
; ulLeftDest        = prclDest->top * lDelta + (prclDest->left >> 1)
;
; ulMiddleSrc  = ulLeftSrc
; ulMiddleDest = ulLeftDest
;
; cjMiddle = (prclDest->right >> 1) - (prclDest->left >> 1)
; if (prclDest->left & 3)
;     ulLeftMask = LeftMaskTable[prclDest->left & 1]
;     fl |= BLOCK_LEFT_EDGE
;     ulMiddleSrc++
;     ulMiddleDest++
;     cjMiddle--
;
; lMiddleDelta = lDelta - cjMiddle
;
; if (prclDest->right & 1)
;     ulRightMask = RightMaskTable[prclDest->right & 1]
;     fl |= BLOCK_RIGHT_EDGE
;     ulRightSrc  = ulMiddleSrc  + cjMiddle
;     ulRightDest = ulMiddleDest + cjMiddle

        mov     edx,ppdev
        mov     eax,[edi].yBottom
        mov     edx,[edx].pdev_lPlanarNextScan ;edx = lDelta
        mov     ulLastDestScan,eax      ;ulLastDestScan = prclDest->bottom

        mov     ecx,[esi].ptl_y
        mov     eax,edx
        mov     ulCurrentSrcScan,ecx    ;ulCurrentSrcScan = pptlSrc->y
        imul    eax,ecx
        mov     ecx,[esi].ptl_x
        mov     ptlSrc.ptl_x,ecx        ;ptlSrc.x = pptlSrc->x
        shr     ecx,1
        add     eax,ecx                 ;eax = ulLeftSrc = pptlSrc->y *
                                        ;  lDelta + (pptlSrc->x >> 1)

        xor     esi,esi                 ;initialize flags

        mov     ecx,[edi].yTop
        mov     ebx,edx
        mov     ulCurrentDestScan,ecx   ;ulCurrentDestScan = prclDest->top
        imul    ebx,ecx
        mov     ecx,[edi].xLeft
        mov     rclDest.xLeft,ecx       ;rclDest.left = prclDest->left
        shr     ecx,1
        add     ebx,ecx                 ;ebx = ulLeftDest = prclDest->top *
                                        ;  lDelta + (prclDest->left >> 1)

        mov     edi,[edi].xRight
        mov     rclDest.xRight,edi
        shr     edi,1
        sub     edi,ecx                 ;cjMiddle = (prclDest->right >> 1) -
                                        ;  (prclDest->left >> 1)

        mov     ecx,rclDest.xLeft
        and     ecx,1
        jz      short l_t_done_left_edge ;skip if we don't need a left edge

        or      esi,BLOCK_LEFT_EDGE
        mov     ecx,LeftMaskTable[ecx*4]
        mov     ulLeftMask,ecx          ;ulLeftMask =
                                        ;  LeftMaskTable[prclDest->left & 1]

        mov     ulLeftSrc,eax           ;ulLeftSrc
        mov     ulLeftDest,ebx          ;ulLeftDest
        inc     eax
        inc     ebx
        dec     edi

l_t_done_left_edge:
        mov     ulMiddleSrc,eax         ;ulMiddleSrc
        mov     ulMiddleDest,ebx        ;ulMiddleDest

        mov     ecx,rclDest.xRight
        and     ecx,1
        jz      short l_t_done_right_edge ;skip if we don't need a right edge

        or      esi,BLOCK_RIGHT_EDGE
        mov     ecx,RightMaskTable[ecx*4]
        mov     ulRightMask,ecx         ;ulRightMask =
                                        ;  RightMaskTable[prclDest->right & 1]

        add     eax,edi
        add     ebx,edi
        mov     ulRightSrc,eax          ;ulRightSrc = ulMiddleSrc + cjMiddle
        mov     ulRightDest,ebx         ;ulRightDest = ulMiddleDest + cjMiddle

; We special case here blits that are less than 2 pels wide and begin and end
; in the same 4-pel quadruple:

        cmp     edi,0
        jge     l_t_done_right_edge

; We make sure the 'middle' count of bytes is zero (we'll just let the code
; fall through the 'middle' copy code), turn off the right-edge flag, and
; give ulLeftMask the composite mask:

        inc     edi
        xor     esi,BLOCK_RIGHT_EDGE
        and     ecx,ulLeftMask
        mov     ulLeftMask,ecx

l_t_done_right_edge:
        mov     cjMiddle,edi            ;cjMiddle

        mov     lDelta,edx              ;lDelta = ppdev->lPlanarNextScan
        sub     edx,edi
        mov     lMiddleDelta,edx        ;lMiddleDelta = lDelta - cjMiddle

        mov     ebx,ppdev
        mov     eax,MasterBlockTable[esi*4]
        mov     pfnCopyBlocks,eax       ;copy blocks between video memory

; Branch to the appropriate top-to-bottom bank enumeration loop:

        mov     eax,[ebx].pdev_vbtPlanarType
        jmp     TopToBottomLoopTable[eax*4]

;-----------------------------------------------------------------------;
; Set-up code for right-to-left, top-to-bottom copies.
;
; Input:
;       esi - pptlSrc
;       edi - prclDest
;-----------------------------------------------------------------------;

        public right_to_left_top_to_bottom
right_to_left_top_to_bottom::

        std                             ;copy middle blocks right-to-left

        mov     edx,ppdev
        mov     eax,[edi].yBottom
        mov     edx,[edx].pdev_lPlanarNextScan ;edx = lDelta
        mov     ulLastDestScan,eax      ;ulLastDestScan = prclDest->bottom

        mov     ecx,[esi].ptl_y
        mov     eax,edx
        mov     ulCurrentSrcScan,ecx    ;ulCurrentSrcScan = pptlSrc->y
        imul    eax,ecx
        mov     ecx,[esi].ptl_x
        mov     ptlSrc.ptl_x,ecx        ;ptlSrc.x = pptlSrc->x
        add     ecx,[edi].xRight
        sub     ecx,[edi].xLeft
        shr     ecx,1
        add     eax,ecx                 ;eax = ulRightSrc = pptlSrc->y *
                                        ; lDelta + (pptlSrc->x +
                                        ; prclDest->right - prclDest->left) / 2

        mov     esi,BLOCK_RIGHT_TO_LEFT ;initialize flags

        mov     ecx,[edi].yTop
        mov     ebx,edx
        mov     ulCurrentDestScan,ecx   ;ulCurrentDestScan = prclDest->top
        imul    ebx,ecx
        mov     ecx,[edi].xRight
        mov     rclDest.xRight,ecx      ;rclDest.right = prclDest->right
        shr     ecx,1
        add     ebx,ecx                 ;ebx = ulRightDest = prclDest->top *
                                        ; lDelta + prclDest->right / 2

        mov     edi,[edi].xLeft
        mov     rclDest.xLeft,edi
        shr     edi,1
        neg     edi
        add     edi,ecx                 ;cjMiddle = prclDest->right / 2 -
                                        ;  prclDest->left / 2

        mov     ecx,rclDest.xRight
        and     ecx,1
        jz      short r_t_done_right_edge ;skip if we don't need a right edge

        or      esi,BLOCK_RIGHT_EDGE
        mov     ecx,RightMaskTable[ecx*4]
        mov     ulRightMask,ecx         ;ulRightMask =
                                        ;  RightMaskTable[prclDest->right & 1]

        mov     ulRightSrc,eax          ;ulRightSrc
        mov     ulRightDest,ebx         ;ulRightDest

r_t_done_right_edge:
        dec     eax
        dec     ebx
        mov     ulMiddleSrc,eax         ;ulMiddleSrc
        mov     ulMiddleDest,ebx        ;ulMiddleDest

        mov     ecx,rclDest.xLeft
        and     ecx,1
        jz      short r_t_done_left_edge ;skip if we don't need a right edge
        or      esi,BLOCK_LEFT_EDGE
        mov     ecx,LeftMaskTable[ecx*4]
        mov     ulLeftMask,ecx          ;ulLeftMask =
                                        ;  LeftMaskTable[prclDest->left & 1]

        dec     edi                     ;adjust middle block length because
                                        ;  we're effectively doing one less
                                        ;  middle byte

        sub     eax,edi
        sub     ebx,edi
        mov     ulLeftSrc,eax           ;ulLeftSrc = ulMiddleSrc - cjMiddle
        mov     ulLeftDest,ebx          ;ulLeftDest = ulMiddleDest - cjMiddle

; We special case here blits that are less than 2 pels wide and begin and end
; in the same 4-pel quadruple:

        cmp     edi,0
        jge     r_t_done_left_edge

; We make sure the 'middle' count of bytes is zero (we'll just let the code
; fall through the 'middle' copy code), turn off the right-edge flag, and
; give ulRightMask the composite mask:

        inc     edi
        xor     esi,BLOCK_LEFT_EDGE
        and     ecx,ulRightMask
        mov     ulRightMask,ecx

r_t_done_left_edge:
        mov     cjMiddle,edi            ;cjMiddle

        mov     lDelta,edx              ;lDelta = ppdev->lPlanarNextScan
        add     edx,edi
        mov     lMiddleDelta,edx        ;lMiddleDelta = lDelta + cjMiddle

        mov     ebx,ppdev
        mov     eax,MasterBlockTable[esi*4]
        mov     pfnCopyBlocks,eax       ;copy blocks between video memory

; Branch to the appropriate top-to-bottom bank enumeration loop:

        mov     eax,[ebx].pdev_vbtPlanarType
        jmp     TopToBottomLoopTable[eax*4]

;-----------------------------------------------------------------------;
; Set-up code for left-to-right, bottom-to-top copies.
;
; Input:
;       esi - pptlSrc
;       edi - prclDest
;-----------------------------------------------------------------------;

        public left_to_right_bottom_to_top
left_to_right_bottom_to_top::

        mov     edx,ppdev
        mov     eax,[edi].yTop
        mov     edx,[edx].pdev_lPlanarNextScan ;edx = lDelta
        mov     ulLastDestScan,eax      ;ulLastDestScan = prclDest->top

        mov     ecx,[esi].ptl_y
        add     ecx,[edi].yBottom
        sub     ecx,[edi].yTop
        mov     eax,edx
        mov     ulCurrentSrcScan,ecx    ;ulCurrentSrcScan = pptlSrc->y +
                                        ;  (prclDest->bottom - prclDest->top)
        dec     ecx
        imul    eax,ecx
        mov     ecx,[esi].ptl_x
        mov     ptlSrc.ptl_x,ecx        ;ptlSrc.x = pptlSrc->x
        shr     ecx,1
        add     eax,ecx                 ;eax = ulLeftSrc = (ulCurrentSrcScan - 1)
                                        ;  * lDelta + (pptlSrc->x >> 1)

        xor     esi,esi                 ;initialize flags

        mov     ecx,[edi].yBottom
        mov     ebx,edx
        mov     ulCurrentDestScan,ecx   ;ulCurrentDestScan = prclDest->bottom
        dec     ecx
        imul    ebx,ecx
        mov     ecx,[edi].xLeft
        mov     rclDest.xLeft,ecx       ;rclDest.left = prclDest->left
        shr     ecx,1
        add     ebx,ecx                 ;ebx = ulLeftDest = (prclDest->bottom - 1)
                                        ;  * lDelta + (prclDest->left >> 1)

        mov     edi,[edi].xRight
        mov     rclDest.xRight,edi
        shr     edi,1
        sub     edi,ecx                 ;cjMiddle = (prclDest->right >> 1) -
                                        ;  (prclDest->left >> 1)

        mov     ecx,rclDest.xLeft
        and     ecx,1
        jz      short l_b_done_left_edge ;skip if we don't need a left edge

        or      esi,BLOCK_LEFT_EDGE
        mov     ecx,LeftMaskTable[ecx*4]
        mov     ulLeftMask,ecx          ;ulLeftMask =
                                        ;  LeftMaskTable[prclDest->left & 3]

        mov     ulLeftSrc,eax           ;ulLeftSrc
        mov     ulLeftDest,ebx          ;ulLeftDest
        inc     eax
        inc     ebx
        dec     edi

l_b_done_left_edge:
        mov     ulMiddleSrc,eax         ;ulMiddleSrc
        mov     ulMiddleDest,ebx        ;ulMiddleDest

        mov     ecx,rclDest.xRight
        and     ecx,1
        jz      short l_b_done_right_edge ;skip if we don't need a right edge

        or      esi,BLOCK_RIGHT_EDGE
        mov     ecx,RightMaskTable[ecx*4]
        mov     ulRightMask,ecx         ;ulRightMask =
                                        ;  RightMaskTable[prclDest->right & 1]

        add     eax,edi
        add     ebx,edi
        mov     ulRightSrc,eax          ;ulRightSrc = ulMiddleSrc + cjMiddle
        mov     ulRightDest,ebx         ;ulRightDest = ulMiddleDest + cjMiddle

; We special case here blits that are less than 2 pels wide and begin and end
; in the same 4-pel quadruple:

        cmp     edi,0
        jge     l_b_done_right_edge

; We make sure the 'middle' count of bytes is zero (we'll just let the code
; fall through the 'middle' copy code), turn off the right-edge flag, and
; give ulLeftMask the composite mask:

        inc     edi
        xor     esi,BLOCK_RIGHT_EDGE
        and     ecx,ulLeftMask
        mov     ulLeftMask,ecx

l_b_done_right_edge:
        mov     cjMiddle,edi            ;cjMiddle

        neg     edx
        mov     lDelta,edx              ;lDelta = -ppdev->lPlanarNextScan
        sub     edx,edi
        mov     lMiddleDelta,edx        ;lMiddleDelta = lDelta - cjMiddle

        mov     ebx,ppdev
        mov     eax,MasterBlockTable[esi*4]
        mov     pfnCopyBlocks,eax       ;copy blocks between video memory

; Branch to the appropriate top-to-bottom bank enumeration loop:

        mov     eax,[ebx].pdev_vbtPlanarType
        jmp     BottomToTopLoopTable[eax*4]

;-----------------------------------------------------------------------;
; Set-up code for right-to-left, bottom-to-top copies.
;
; Input:
;       esi - pptlSrc
;       edi - prclDest
;-----------------------------------------------------------------------;

        public right_to_left_bottom_to_top
right_to_left_bottom_to_top::

        std                             ;copy middle blocks right-to-left

        mov     edx,ppdev
        mov     eax,[edi].yTop
        mov     edx,[edx].pdev_lPlanarNextScan ;edx = lDelta
        mov     ulLastDestScan,eax      ;ulLastDestScan = prclDest->top

        mov     ecx,[esi].ptl_y
        add     ecx,[edi].yBottom
        sub     ecx,[edi].yTop
        mov     eax,edx
        mov     ulCurrentSrcScan,ecx    ;ulCurrentSrcScan = pptlSrc->y +
                                        ;  (prclDest->bottom - prclDest->top)
        dec     ecx
        imul    eax,ecx
        mov     ecx,[esi].ptl_x
        mov     ptlSrc.ptl_x,ecx        ;ptlSrc.x = pptlSrc->x
        add     ecx,[edi].xRight
        sub     ecx,[edi].xLeft
        shr     ecx,1
        add     eax,ecx                 ;eax = ulRightSrc = (ulCurrentSrcScan
                                        ; - 1) * lDelta + (pptlSrc->x +
                                        ; prclDest->right - prclDest->left) / 2

        mov     esi,BLOCK_RIGHT_TO_LEFT ;initialize flags

        mov     ecx,[edi].yBottom
        mov     ebx,edx
        mov     ulCurrentDestScan,ecx   ;ulCurrentDestScan = prclDest->bottom
        dec     ecx
        imul    ebx,ecx
        mov     ecx,[edi].xRight
        mov     rclDest.xRight,ecx      ;rclDest.right = prclDest->right
        shr     ecx,1
        add     ebx,ecx                 ;ebx = ulRightDest = (ulCurrentDestScan
                                        ; - 1) * lDelta + prclDest->right / 2

        mov     edi,[edi].xLeft
        mov     rclDest.xLeft,edi
        shr     edi,1
        neg     edi
        add     edi,ecx                 ;cjMiddle = prclDest->right / 2 -
                                        ;  prclDest->left / 2

        mov     ecx,rclDest.xRight
        and     ecx,1
        jz      short r_b_done_right_edge ;skip if we don't need a right edge

        or      esi,BLOCK_RIGHT_EDGE
        mov     ecx,RightMaskTable[ecx*4]
        mov     ulRightMask,ecx         ;ulRightMask =
                                        ;  RightMaskTable[prclDest->right & 1]

        mov     ulRightSrc,eax          ;ulRightSrc
        mov     ulRightDest,ebx         ;ulRightDest

r_b_done_right_edge:
        dec     eax
        dec     ebx
        mov     ulMiddleSrc,eax         ;ulMiddleSrc
        mov     ulMiddleDest,ebx        ;ulMiddleDest

        mov     ecx,rclDest.xLeft
        and     ecx,1
        jz      short r_b_done_left_edge ;skip if we don't need a right edge

        or      esi,BLOCK_LEFT_EDGE
        mov     ecx,LeftMaskTable[ecx*4]
        mov     ulLeftMask,ecx          ;ulLeftMask =
                                        ;  LeftMaskTable[prclDest->left & 1]

        dec     edi                     ;adjust middle block length because
                                        ;  we're effectively doing one less
                                        ;  middle byte

        sub     eax,edi
        sub     ebx,edi
        mov     ulLeftSrc,eax           ;ulLeftSrc = ulMiddleSrc - cjMiddle
        mov     ulLeftDest,ebx          ;ulLeftDest = ulMiddleDest - cjMiddle

; We special case here blits that are less than 2 pels wide and begin and end
; in the same 4-pel quadruple:

        cmp     edi,0
        jge     r_b_done_left_edge

; We make sure the 'middle' count of bytes is zero (we'll just let the code
; fall through the 'middle' copy code), turn off the right-edge flag, and
; give ulRightMask the composite mask:

        inc     edi
        xor     esi,BLOCK_LEFT_EDGE
        and     ecx,ulRightMask
        mov     ulRightMask,ecx

r_b_done_left_edge:
        mov     cjMiddle,edi            ;cjMiddle

        neg     edx
        mov     lDelta,edx              ;lDelta = -ppdev->lPlanarNextScan
        add     edx,edi
        mov     lMiddleDelta,edx        ;lMiddleDelta = lDelta + cjMiddle

        mov     ebx,ppdev
        mov     eax,MasterBlockTable[esi*4]
        mov     pfnCopyBlocks,eax       ;copy blocks between video memory

; Branch to the appropriate top-to-bottom bank enumeration loop:

        mov     eax,[ebx].pdev_vbtPlanarType
        jmp     BottomToTopLoopTable[eax*4]

;=======================================================================;
;============================= Banking =================================;
;=======================================================================;

;-----------------------------------------------------------------------;
; Banking for 1 R/W adapters, top to bottom.
;
; Input:
;       ulCurrentSrcScan
;       ulCurrentDestScan
;       ulLastDestScan
;       Plus some other stuff for split rasters and block copiers
;-----------------------------------------------------------------------;
        public  top_to_bottom_1RW
top_to_bottom_1RW::

; LATER: Should check to see if there's any chance that the source and
;     destination overlap in the same window, so that we can use planar
;     copies -- otherwise, it's faster to directly call of to
;     bPuntScreenToScreenCopyBits

; We're going top to bottom. Map in the source and dest, top-justified.

        mov     ebx,ppdev
        mov     edi,ulCurrentDestScan

        cmp     edi,[ebx].pdev_rcl1PlanarClip.yTop
        jl      short top_1RW_map_init_bank

        cmp     edi,[ebx].pdev_rcl1PlanarClip.yBottom
        jl      short top_1RW_init_bank_mapped

top_1RW_map_init_bank:

; Map bank containing the top destination scan line into window.
; Note: EBX, ESI, and EDI preserved, according to C calling conventions.

        ptrCall <dword ptr [ebx].pdev_pfnPlanarControl>, \
                <ebx,edi,JustifyTop>

top_1RW_init_bank_mapped:

        mov     eax,ulCurrentSrcScan
        cmp     eax,[ebx].pdev_rcl1PlanarClip.yBottom

        jl      short top_1RW_do_planar_copy

; ulCurrentSrcScan >= ppdev->rcl1PlanarClip.bottom, which means that
; the window can't overlap the source and destination at all.  We'll
; have to use an intermediate temporary buffer:

; ebx = ppdev
; eax = ulCurrentSrcScan
; edi = ulCurrentDestScan

        mov     ptlSrc.ptl_y,eax        ;ptlSrc.y = ulCurrentSrcScan
        mov     rclDest.yTop,edi        ;rclDest.top = ulCurrentDestScan

        mov     esi,[ebx].pdev_rcl1PlanarClip.yBottom
        mov     eax,ulLastDestScan
        sub     eax,esi
        sbb     ecx,ecx
        and     ecx,eax
        add     esi,ecx
        mov     rclDest.yBottom,esi     ;rclDest.bottom = min(ulLastDestScan,
                                        ;  ppdev->pdev_rcl1PlanarClip.bottom)

; Enable bit mask for all bits:

        mov     edx,VGA_BASE + GRAF_ADDR
        mov     eax,(0ffh shl 8) + GRAF_BIT_MASK
        out     dx,ax

; Enable writes to all planes and reset direction flag:

        mov     edx,VGA_BASE + SEQ_DATA
        mov     al,MM_ALL
        out     dx,al

        pushfd
        cld

; Call our routine that copies bits the slow way, preserving EBX, ESI and EDI
; according to C calling conventions:

        lea     ecx,rclDest
        lea     edx,ptlSrc

        cCall   bPuntScreenToScreenCopyBits,<ebx,0,0,ecx,edx>

        popfd

; Set the bit mask to disable all bits, so we can copy through latches again:

        mov     edx,VGA_BASE + GRAF_ADDR
        mov     eax,(000h shl 8) + GRAF_BIT_MASK
        out     dx,ax

; Update our position variables:

        mov     ulCurrentDestScan,esi   ;ulCurrentDestScan = rclDest.bottom

        sub     esi,edi                 ;ulBlockHeight = rclDest.bottom -
                                        ;  rclDest.top

        add     ulCurrentSrcScan,esi    ;ulCurrentSrcScan += ulBlockHeight

; We have to adjust the offsets for all our block copiers, according to the
; number of scans we copied:

        mov     edx,lDelta
        imul    edx,esi                 ;edx = lDelta * ulBlockHeight
        add     ulLeftSrc,edx
        add     ulLeftDest,edx
        add     ulMiddleSrc,edx
        add     ulMiddleDest,edx
        add     ulRightSrc,edx
        add     ulRightDest,edx

        jmp     short top_1RW_see_if_done

top_1RW_do_planar_copy:

; ebx = ppdev
; eax = ulCurrentSrcScan
; edi = ulCurrentDestScan

        mov     ebx,[ebx].pdev_rcl1PlanarClip.yBottom
        sub     ebx,eax                 ;ebx = ppdev->rcl1PlanarClip.bottom -
                                        ;  ulCurrentSrcScan
                                        ;ebx is the available number of scans
                                        ;  we have in the source

        mov     edx,ulLastDestScan
        sub     edx,edi                 ;edx = ulLastDestScan - ulCurrentDestScan
                                        ;edx is the available number of scans
                                        ;  in the destination

; (Because the source starts lower in the window than the destination,
; the bottom of the bank always limits the source number of scans before
; it does the destination.)

        sub     ebx,edx
        sbb     ecx,ecx
        and     ecx,ebx
        add     edx,ecx                 ;edx = min(source available,
                                        ;  destination available)
        mov     ulBlockHeight,edx

        add     eax,edx                 ;We have to adjust our current scans
        add     edi,edx
        mov     ulCurrentSrcScan,eax
        mov     ulCurrentDestScan,edi

; Now copy the puppy:

        call    pfnCopyBlocks

; See if we're done:

top_1RW_see_if_done:
        mov     edi,ulCurrentDestScan
        cmp     edi,ulLastDestScan
        jge     all_done

        mov     ebx,ppdev

; Map bank containing the top destination scan line into window.
; Note: EBX, ESI, and EDI preserved, according to C calling conventions.

        ptrCall <dword ptr [ebx].pdev_pfnPlanarControl>, \
                <ebx,edi,JustifyTop>

        jmp     top_1RW_init_bank_mapped

;-----------------------------------------------------------------------;
; Banking for 1 R/W adapters, bottom to top.
;
; Input:
;       ulCurrentSrcScan  - Actually, 1 more current source scan
;       ulCurrentDestScan - Actually, 1 more current destination scan
;       ulLastDestScan
;       Plus some other stuff for split rasters and block copiers
;-----------------------------------------------------------------------;
        public  bottom_to_top_1RW
bottom_to_top_1RW::

; We're going top to bottom. Map in the source and dest, top-justified.

        mov     ebx,ppdev
        mov     edi,ulCurrentDestScan

        cmp     edi,[ebx].pdev_rcl1PlanarClip.yTop
        jle     short bot_1RW_map_init_bank

        cmp     edi,[ebx].pdev_rcl1PlanarClip.yBottom
        jle     short bot_1RW_init_bank_mapped

bot_1RW_map_init_bank:

; Map bank containing the top destination scan line into window.
; Note: EBX, ESI, and EDI preserved, according to C calling conventions.

        dec     edi
        ptrCall <dword ptr [ebx].pdev_pfnPlanarControl>, \
                <ebx,edi,JustifyTop>
        inc     edi

bot_1RW_init_bank_mapped:

        mov     eax,ulCurrentSrcScan
        cmp     eax,[ebx].pdev_rcl1PlanarClip.yTop

        jg      short bot_1RW_do_planar_copy

; ulCurrentSrcScan <= ppdev->rcl1PlanarClip.top, which means that
; the window can't overlap the source and destination at all.  We'll
; have to use an intermediate temporary buffer:

; ebx = ppdev
; eax = ulCurrentSrcScan
; edi = ulCurrentDestScan

        mov     esi,[ebx].pdev_rcl1PlanarClip.yTop
        mov     edx,ulLastDestScan
        cmp     esi,edx
        jg      @F
        mov     esi,edx
@@:
        mov     rclDest.yTop,esi        ;rclDest.top = max(ulLastDestScan,
                                        ;  ppdev->rcl1PlanarClip.top)

        mov     rclDest.yBottom,edi     ;rclDest.bottom = ulCurrentDestScan
        add     eax,esi
        sub     eax,edi
        mov     ptlSrc.ptl_y,eax        ;ptlSrc.y = ulCurrentSrcScan -
                                        ;  (rclDest.bottom - rclDest.top)

; Enable bit mask for all bits:

        mov     edx,VGA_BASE + GRAF_ADDR
        mov     eax,(0ffh shl 8) + GRAF_BIT_MASK
        out     dx,ax

; Enable writes to all planes and reset direction flag:

        mov     edx,VGA_BASE + SEQ_DATA
        mov     al,MM_ALL
        out     dx,al

        pushfd
        cld

; Call our routine that copies bits the slow way, preserving EBX, ESI and EDI
; according to C calling conventions:

        lea     ecx,rclDest
        lea     edx,ptlSrc

        cCall   bPuntScreenToScreenCopyBits,<ebx,0,0,ecx,edx>

        popfd

; Set the bit mask to disable all bits, so we can copy through latches again:

        mov     edx,VGA_BASE + GRAF_ADDR
        mov     eax,(000h shl 8) + GRAF_BIT_MASK
        out     dx,ax

; Update our position variables:

        mov     ulCurrentDestScan,esi   ;ulCurrentDestScan = rclDest.top

        sub     edi,esi                 ;ulBlockHeight = rclDest.bottom -
                                        ;  rclDest.top

        sub     ulCurrentSrcScan,edi    ;ulCurrentSrcScan -= ulBlockHeight

; We have to adjust the offsets for all our block copiers, according to the
; number of scans we copied:

        mov     edx,lDelta
        imul    edx,edi                 ;edx = lDelta * ulBlockHeight
        add     ulLeftSrc,edx
        add     ulLeftDest,edx
        add     ulMiddleSrc,edx
        add     ulMiddleDest,edx
        add     ulRightSrc,edx
        add     ulRightDest,edx

        jmp     short bot_1RW_see_if_done

bot_1RW_do_planar_copy:

; ebx = ppdev
; eax = ulCurrentSrcScan
; edi = ulCurrentDestScan

        sub     eax,[ebx].pdev_rcl1PlanarClip.yTop
                                        ;eax = ulCurrentSrcScan -
                                        ;  ppdev->rcl1PlanarClip.top

        sub     edi,ulLastDestScan      ;edi = ulCurrentDestScan - ulLastDestScan
                                        ;edi is the available number of scans
                                        ;  in the destination


; (Because the source starts higher in the window than the destination,
; the bottom of the bank always limits the source number of scans before
; it does the destination.)

        sub     eax,edi
        sbb     ecx,ecx
        and     ecx,eax
        add     edi,ecx                 ;edi = min(source available,
                                        ;  destination available)

        mov     ulBlockHeight,edi

        sub     ulCurrentSrcScan,edi    ;We have to adjust our current scans
        sub     ulCurrentDestScan,edi

; Now copy the puppy:

        call    pfnCopyBlocks

; See if we're done:

bot_1RW_see_if_done:
        mov     edi,ulCurrentDestScan
        cmp     edi,ulLastDestScan
        jle     all_done

        mov     ebx,ppdev

; Map bank containing the top destination scan line into window.
; Note: EBX, ESI, and EDI preserved, according to C calling conventions.

        dec     edi
        ptrCall <dword ptr [ebx].pdev_pfnPlanarControl>, \
                <ebx,edi,JustifyTop>
        inc     edi

        jmp     bot_1RW_init_bank_mapped

;-----------------------------------------------------------------------;
; Banking for 1R/1W or 2R/W adapters, top to bottom.
;
; Input:
;       ulCurrentSrcScan
;       ulCurrentDestScan
;       ulLastDestScan
;       Plus some other stuff for split rasters and block copiers
;-----------------------------------------------------------------------;
        public  top_to_bottom_2RW
top_to_bottom_2RW::

; We're going top to bottom. Map in the destination, top-justified.

        mov     ebx,ppdev
        mov     edi,ulCurrentDestScan
        mov     esi,ulCurrentSrcScan

        cmp     edi,[ebx].pdev_rcl2PlanarClipD.yTop
        jl      short top_2RW_map_init_dest_bank

        cmp     edi,[ebx].pdev_rcl2PlanarClipD.yBottom
        jl      short top_2RW_init_dest_bank_mapped

top_2RW_map_init_dest_bank:

; Map bank containing the top destination scan line into window.
; Note: EBX, ESI, and EDI preserved, according to C calling conventions.

        ptrCall <dword ptr [ebx].pdev_pfnPlanarControl2>, \
                <ebx,edi,JustifyTop,MapDestBank>

top_2RW_init_dest_bank_mapped:

        cmp     esi,[ebx].pdev_rcl2PlanarClipS.yTop
        jl      short top_2RW_map_init_src_bank

        cmp     esi,[ebx].pdev_rcl2PlanarClipS.yBottom
        jl      short top_2RW_main_loop

top_2RW_map_init_src_bank:

; Map bank containing the top source scan line into window.
; Note: EBX, ESI, and EDI preserved, according to C calling conventions.

        ptrCall <dword ptr [ebx].pdev_pfnPlanarControl2>, \
                <ebx,esi,JustifyTop,MapSourceBank>

top_2RW_main_loop:
        mov     ecx,[ebx].pdev_rcl2PlanarClipD.yBottom
        mov     edx,ulLastDestScan

        sub     ecx,edx
        sbb     eax,eax
        and     eax,ecx
        add     edx,eax                 ;edx = min(ulLastDestScan,
                                        ;  ppdev->rcl2PlanarClipD.bottom)

        mov     ecx,[ebx].pdev_rcl2PlanarClipS.yBottom

        sub     edx,edi                 ;edx = available scans in destination
                                        ;  bank
        sub     ecx,esi                 ;ecx = available scans in source bank

        sub     ecx,edx
        sbb     eax,eax
        and     eax,ecx
        add     edx,eax

        mov     ulBlockHeight,edx       ;ulBlockHeight = min(source available,
                                        ;  dest available)

        add     esi,edx                 ;adjust our currents scans accordingly
        add     edi,edx
        mov     ulCurrentSrcScan,esi
        mov     ulCurrentDestScan,edi

; Do the actual copy:

        call    pfnCopyBlocks

        mov     edi,ulCurrentDestScan   ;check if done
        cmp     edi,ulLastDestScan
        jge     all_done

        mov     ebx,ppdev

; We'll have to map a new source bank, destination bank, or both:

        mov     esi,ulCurrentSrcScan
        cmp     edi,[ebx].pdev_rcl2PlanarClipD.yBottom
        jl      short top_2RW_map_next_src_bank

; Map bank containing the top destination scan line into window.
; Note: EBX, ESI, and EDI preserved, according to C calling conventions.

        ptrCall <dword ptr [ebx].pdev_pfnPlanarControl2>, \
                <ebx,edi,JustifyTop,MapDestBank>

        cmp     esi,[ebx].pdev_rcl2PlanarClipS.yBottom
        jl      short top_2RW_main_loop

top_2RW_map_next_src_bank:

; Map bank containing the top source scan line into window.
; Note: EBX, ESI, and EDI preserved, according to C calling conventions.

        ptrCall <dword ptr [ebx].pdev_pfnPlanarControl2>, \
                <ebx,esi,JustifyTop,MapSourceBank>

        jmp     short top_2RW_main_loop

;-----------------------------------------------------------------------;
; Banking for 1R/1W or 2R/W adapters, bottom to top.
;
; Input:
;       ulCurrentSrcScan
;       ulCurrentDestScan
;       ulLastDestScan
;       Plus some other stuff for split rasters and block copiers
;-----------------------------------------------------------------------;
        public  bottom_to_top_2RW
bottom_to_top_2RW::

; We're going bottom to top. Map in the destination, bottom-justified.

        mov     ebx,ppdev
        mov     edi,ulCurrentDestScan   ; 1 more than actual destination scan
        mov     esi,ulCurrentSrcScan    ; 1 more than actual source scan

        cmp     edi,[ebx].pdev_rcl2PlanarClipD.yTop
        jle     short bot_2RW_map_init_dest_bank

        cmp     edi,[ebx].pdev_rcl2PlanarClipD.yBottom
        jle     short bot_2RW_init_dest_bank_mapped

bot_2RW_map_init_dest_bank:

; Map bank containing the top destination scan line into window.
; Note: EBX, ESI, and EDI preserved, according to C calling conventions.

        dec     edi
        ptrCall <dword ptr [ebx].pdev_pfnPlanarControl2>, \
                <ebx,edi,JustifyBottom,MapDestBank>
        inc     edi

bot_2RW_init_dest_bank_mapped:

        cmp     esi,[ebx].pdev_rcl2PlanarClipS.yTop
        jle     short bot_2RW_map_init_src_bank

        cmp     esi,[ebx].pdev_rcl2PlanarClipS.yBottom
        jle     short bot_2RW_main_loop

bot_2RW_map_init_src_bank:

; Map bank containing the top source scan line into window.
; Note: EBX, ESI, and EDI preserved, according to C calling conventions.

        dec     esi
        ptrCall <dword ptr [ebx].pdev_pfnPlanarControl2>, \
                <ebx,esi,JustifyBottom,MapSourceBank>
        inc     esi

bot_2RW_main_loop:
        mov     ecx,[ebx].pdev_rcl2PlanarClipD.yTop
        mov     edx,ulLastDestScan

        cmp     edx,ecx
        jg      @F
        mov     edx,ecx                 ;edx = max(ulLastDestScan,
@@:                                     ;  ppdev->rcl2PlanarClipD.top)

        sub     edi,edx                 ;edi = available scans in destination
                                        ;  bank
        sub     esi,[ebx].pdev_rcl2PlanarClipS.yTop
                                        ;esi = available scans in source bank

        sub     esi,edi
        sbb     eax,eax
        and     eax,esi
        add     edi,eax

        mov     ulBlockHeight,edi       ;ulBlockHeight = min(source available,
                                        ;  dest available)

        sub     ulCurrentSrcScan,edi    ;adjust our current scans
        sub     ulCurrentDestScan,edi

; Do the actual copy:

        call    pfnCopyBlocks

        mov     edi,ulCurrentDestScan   ;check if done
        cmp     edi,ulLastDestScan
        jle     all_done

        mov     ebx,ppdev

; We'll have to map a new source bank, destination bank, or both:

        mov     esi,ulCurrentSrcScan
        cmp     edi,[ebx].pdev_rcl2PlanarClipD.yTop
        jg      short bot_2RW_map_next_src_bank

; Map bank containing the top destination scan line into window.
; Note: EBX, ESI, and EDI preserved, according to C calling conventions.

        dec     edi
        ptrCall <dword ptr [ebx].pdev_pfnPlanarControl2>, \
                <ebx,edi,JustifyBottom,MapDestBank>
        inc     edi

        cmp     esi,[ebx].pdev_rcl2PlanarClipS.yTop
        jg      short bot_2RW_main_loop

bot_2RW_map_next_src_bank:

; Map bank containing the top source scan line into window.
; Note: EBX, ESI, and EDI preserved, according to C calling conventions.

        dec     esi
        ptrCall <dword ptr [ebx].pdev_pfnPlanarControl2>, \
                <ebx,esi,JustifyBottom,MapSourceBank>
        inc     esi

        jmp     short bot_2RW_main_loop

;=======================================================================;
;=========================== Block Copiers =============================;
;=======================================================================;

;-----------------------------------------------------------------------;
; Input:
;       Direction flag  - set to the appropriate direction
;       ulMiddleSrc     - offset in bitmap to source
;       ulMiddleDest    - offset in bitmap to destination
;       lMiddleDelta    - distance from end of current scan to start of next
;       ulBlockHeight   - # of scans to copy
;       cjMiddle        - # of planar bytes to copy on every scan
;
; Output:
;       Advances ulMiddleSrc and ulMiddleDest to next strip
;-----------------------------------------------------------------------;

        public  copy_middle_block
copy_middle_block::

; We only have to reset which planes are enabled if we do edges too:

        mov     edx,VGA_BASE + SEQ_DATA
        mov     al,MM_ALL
        out     dx,al

copy_just_middle_block::

; Calculate full start addresses:

        mov     edi,ppdev
        mov     eax,cjMiddle
        mov     ebx,ulBlockHeight
        mov     edx,lMiddleDelta
        mov     esi,[edi].pdev_pvBitmapStart2WindowS
        mov     edi,[edi].pdev_pvBitmapStart2WindowD
        add     esi,ulMiddleSrc
        add     edi,ulMiddleDest

        SET_UP_UNROLL_VARS ebx,ecx,ebx,pfnCopyMiddleEntry, \
                                LOOP_UNROLL_SHIFT

        jmp     ecx

        UNROLL_LOOP_ENTRY_TABLE pfnCopyMiddleEntry,MIDDLE, \
                                LOOP_UNROLL_COUNT

COPY_MIDDLE macro ENTRY_LABEL,ENTRY_INDEX
&ENTRY_LABEL&ENTRY_INDEX&:
        mov     ecx,eax
        rep     movsb
        add     esi,edx
        add     edi,edx
        endm    ;-----------------------------------;

;  EAX = # of bytes to copy
;  EBX = count of unrolled loop iterations
;  EDX = offset from end of one scan's fill to start of next
;  ESI = source address from which to copy
;  EDI = target address to which to copy

middle_loop:
        UNROLL_LOOP     COPY_MIDDLE,MIDDLE,LOOP_UNROLL_COUNT
        dec     ebx
        jnz     middle_loop

; get ready for next time:

        mov     ecx,ppdev
        sub     esi,[ecx].pdev_pvBitmapStart2WindowS
        sub     edi,[ecx].pdev_pvBitmapStart2WindowD
        mov     ulMiddleSrc,esi
        mov     ulMiddleDest,edi

        PLAIN_RET

;-----------------------------------------------------------------------;
; Input:
;       ulLeftSrc     - offset in bitmap to source
;       ulLeftDest    - offset in bitmap to destination
;       lDelta        - distance from between planar scans
;       ulBlockHeight - # of scans to copy
;
; Output:
;       Advances ulLeftSrc and ulLeftDest to next strip
;-----------------------------------------------------------------------;

        public  copy_left_block
copy_left_block::

; Set left mask by disabling some planes:

        mov     edx,VGA_BASE + SEQ_DATA
        mov     eax,ulLeftMask
        out     dx,al

; Calculate full start addresses:

        mov     ecx,ppdev
        mov     ebx,ulBlockHeight
        mov     edx,lDelta
        mov     esi,[ecx].pdev_pvBitmapStart2WindowS
        mov     edi,[ecx].pdev_pvBitmapStart2WindowD
        add     esi,ulLeftSrc
        add     edi,ulLeftDest

        SET_UP_UNROLL_VARS ebx,eax,ebx,pfnCopyLeftEntry, \
                                LOOP_UNROLL_SHIFT

        jmp     eax

        UNROLL_LOOP_ENTRY_TABLE pfnCopyLeftEntry,LEFT, \
                                LOOP_UNROLL_COUNT

COPY_LEFT macro ENTRY_LABEL,ENTRY_INDEX
&ENTRY_LABEL&ENTRY_INDEX&:
        mov     al,[esi]
        mov     [edi],al
        add     esi,edx
        add     edi,edx
        endm    ;-----------------------------------;

;  EBX = count of unrolled loop iterations
;  EDX = offset from one scan to next
;  ESI = source address from which to copy
;  EDI = target address to which to copy

left_loop:
        UNROLL_LOOP     COPY_LEFT,LEFT,LOOP_UNROLL_COUNT
        dec     ebx
        jnz     left_loop

; get ready for next time:

        sub     esi,[ecx].pdev_pvBitmapStart2WindowS
        sub     edi,[ecx].pdev_pvBitmapStart2WindowD
        mov     ulLeftSrc,esi
        mov     ulLeftDest,edi

        PLAIN_RET

;-----------------------------------------------------------------------;
; Input:
;       ulRightSrc    - offset in bitmap to source
;       ulRightDest   - offset in bitmap to destination
;       lDelta        - distance from between planar scans
;       ulBlockHeight - # of scans to copy
;
; Output:
;       Advances ulRightSrc and ulRightDest to next strip
;-----------------------------------------------------------------------;

        public  copy_right_block
copy_right_block::

; Set right mask by disabling some planes:

        mov     edx,VGA_BASE + SEQ_DATA
        mov     eax,ulRightMask
        out     dx,al

; Calculate full start addresses:

        mov     ecx,ppdev
        mov     ebx,ulBlockHeight
        mov     edx,lDelta
        mov     esi,[ecx].pdev_pvBitmapStart2WindowS
        mov     edi,[ecx].pdev_pvBitmapStart2WindowD
        add     esi,ulRightSrc
        add     edi,ulRightDest

        SET_UP_UNROLL_VARS ebx,eax,ebx,pfnCopyRightEntry, \
                                LOOP_UNROLL_SHIFT

        jmp     eax

        UNROLL_LOOP_ENTRY_TABLE pfnCopyRightEntry,RIGHT, \
                                LOOP_UNROLL_COUNT

COPY_RIGHT macro ENTRY_LABEL,ENTRY_INDEX
&ENTRY_LABEL&ENTRY_INDEX&:
        mov     al,[esi]
        mov     [edi],al
        add     esi,edx
        add     edi,edx
        endm    ;-----------------------------------;

;  EBX = count of unrolled loop iterations
;  EDX = offset from one scan to next
;  ESI = source address from which to copy
;  EDI = target address to which to copy

right_loop:
        UNROLL_LOOP     COPY_RIGHT,RIGHT,LOOP_UNROLL_COUNT
        dec     ebx
        jnz     right_loop

; get ready for next time:

        sub     esi,[ecx].pdev_pvBitmapStart2WindowS
        sub     edi,[ecx].pdev_pvBitmapStart2WindowD
        mov     ulRightSrc,esi
        mov     ulRightDest,edi

        PLAIN_RET

;-----------------------------------------------------------------------;

endProc vPlanarCopyBits

        end


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\vga\disp\16bpp\i386\vgaregs.asm ===
;---------------------------Module-Header------------------------------;
; Module Name: vgaregs.asm
;
; Copyright (c) 1992 Microsoft Corporation
;-----------------------------------------------------------------------;
;-----------------------------------------------------------------------;
; VOID vInitRegs(void)
;
; Sets the VGA's data control registers to their default states.
;
;-----------------------------------------------------------------------;

        .386

        .model  small,c

        assume cs:FLAT,ds:FLAT,es:FLAT,ss:FLAT
        assume fs:nothing,gs:nothing

        .xlist
        include stdcall.inc             ;calling convention cmacros
        include i386\strucs.inc
        include i386\driver.inc
        include i386\egavga.inc

        .list

        .code

cProc vInitRegs,4,<             \
        uses esi edi ebx,       \
        ppdev: ptr PDEV         >

        mov     esi,ppdev

;       Initialize sequencer to its defaults (all planes enabled, index
;       pointing to Map Mask).

        mov     dx,VGA_BASE + SEQ_ADDR
        mov     ax,(MM_ALL shl 8) + SEQ_MAP_MASK
        out     dx,ax

;       Initialize graphics controller to its defaults (set/reset disabled for
;       all planes, no rotation & ALU function == replace, write mode 0 & read
;       mode 0, color compare ignoring all planes (read mode 1 reads always
;       return 0ffh, handy for ANDing), and the bit mask == 0ffh, gating all
;       bytes from the CPU.

        mov     dl,GRAF_ADDR
        mov     ax,(0 shl 8) + GRAF_ENAB_SR
        out     dx,ax

        mov     ax,(DR_SET shl 8) + GRAF_DATA_ROT
        out     dx,ax

;       Default to read mode 0, write mode 0:

        mov     edx,VGA_BASE + GRAF_ADDR
        mov     ah,byte ptr [esi].pdev_ulrm0_wmX[0]
        mov     al,GRAF_MODE
        out     dx,ax                   ;write mode 0, read mode 0

        mov     ax,(0 shl 8) + GRAF_CDC
        out     dx,ax

        mov     ax,(0FFh shl 8) + GRAF_BIT_MASK
        out     dx,ax

        cRet    vInitRegs


endProc vInitRegs

;-----------------------------------------------------------------------;
; VOID vSetWriteModes(ULONG * pulWriteModes);
;
; Sets the four bytes at *pulWriteModes to the values to be written to
; the Graphics Mode register to select read mode 0 and:
;  write mode 0, write mode 1, write mode 2, and write mode 3,
; respectively.
;
; Must already be in graphics mode when this is called.
;-----------------------------------------------------------------------;

cProc vSetWriteModes,4,<   \
        pulWriteModes:ptr  >

        mov     edx,VGA_BASE + GRAF_ADDR
        mov     al,GRAF_MODE
        out     dx,al           ;point the GC Index to the Graphics Mode reg
        inc     edx             ;point to the GC Data reg
        in      al,dx           ;get the current setting of the Graphics Mode
        and     eax,0fch        ;mask off the write mode fields
        mov     ah,al
        mov     edx,eax
        shl     edx,16
        or      eax,edx         ;put the Graphics Mode setting in all 4 bytes
        mov     edx,pulWriteModes ;the mode values go here
        or      eax,03020100h   ;insert the write mode fields
        mov     [edx],eax       ;store the Graphics Mode settings

        cRet    vSetWriteModes

endProc vSetWriteModes

        end


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\vga\disp\16bpp\i386\strucs.inc ===
;---------------------------Module-Header------------------------------;
; Module Name: stucts.inc
;
; Defines common structures.
;
; Copyright (c) 1992 Microsoft Corporation
;-----------------------------------------------------------------------;
;-----------------------------------------------------------------------;
; POINTB is used for points with a range of -128..+127.
;-----------------------------------------------------------------------;

POINTB          STRUC
ptb_x           DB      0
ptb_y           DB      0
POINTB          ENDS

;-----------------------------------------------------------------------;
; POINTL is used for points with a range of +/- 2G.
;-----------------------------------------------------------------------;

POINTL          STRUC
ptl_x           DD      0
ptl_y           DD      0
POINTL          ENDS


;-----------------------------------------------------------------------;
; SIZEB is used for extents with a range of -128..+127.
;-----------------------------------------------------------------------;

SIZEB           STRUC
sizb_cx         DB      0
sizb_cy         DB      0
SIZEB           ENDS


;-----------------------------------------------------------------------;
; SIZEL is used for extents with a range of +/- 2G
;-----------------------------------------------------------------------;

SIZEL           STRUC
sizl_cx         DD      0
sizl_cy         DD      0
SIZEL           ENDS

;-----------------------------------------------------------------------;
; Definition of a rectangle
;-----------------------------------------------------------------------;


RECTL               struc           ; /* rcl */
xLeft               dd      ?
yTop                dd      ?
xRight              dd      ?
yBottom             dd      ?
RECTL               ends


;-----------------------------------------------------------------------;
; Definitions for dsurf_iFormat
;-----------------------------------------------------------------------;

BMF_DEVICE          equ     0
BMF_1BPP            equ     1
BMF_4BPP            equ     2
BMF_8BPP            equ     3
BMF_16BPP           equ     4
BMF_24BPP           equ     5
BMF_32BPP           equ     6
BMF_4RLE            equ     8
BMF_8RLE            equ     9
BMF_PHYSDEVICE      equ     0FFh


;-----------------------------------------------------------------------;
; Definitions for text output
;-----------------------------------------------------------------------;


GLYPHPOS    struc           ; /* gp */
gp_hg       dd      ?       ; hglyph (unused by vga)
gp_pgdf     dd      ?       ; glyphdef
gp_x        dd      ?       ; glyph x position
gp_y        dd      ?       ; glyph y position
GLYPHPOS    ends


GLYPHDEF struc              ; /* gdf */
gdf_pgb     dd      ?       ; points to GLYPHBITS
GLYPHDEF ends


GLYPHBITS struc             ; /* gb */
gb_x        dd      ?       ; glyph x offset
gb_y        dd      ?       ; glyph y offset
gb_cx       dd      ?       ; glyph width in pels
gb_cy       dd      ?       ; glyph height in pels
gb_aj       db      ?       ; glyph bit mask
GLYPHBITS ends

;-----------------------------------------------------------------------;
; Information block for RLE blts
;-----------------------------------------------------------------------;

RLEINFO struc
RLE_pjTrg        dd  ?
RLE_pjSrcBits    dd  ?
RLE_pjSrcBitsMax dd  ?
RLE_prctlClip    dd  ?
RLE_pulTranslate dd  ?
RLE_xBegin       dd  ?
RLE_lNextScan    dd  ?
RLE_lNextPlane   dd  ?
RLE_prctlTrg     dd  ?
RLE_dwFormat     dd  ?
Rle_pdsurfTrg    dd  ?
RLEINFO ends
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\vga\disp\8bpp\debug.c ===
/******************************Module*Header*******************************\
* Module Name: debug.c
*
* debug helpers routine
*
* Copyright (c) 1992-1995 Microsoft Corporation
*
\**************************************************************************/

#include "driver.h"

#if DBG

ULONG DebugLevel = 0;

/*****************************************************************************
 *
 *   Routine Description:
 *
 *      This function is variable-argument, level-sensitive debug print
 *      routine.
 *      If the specified debug level for the print statement is lower or equal
 *      to the current debug level, the message will be printed.
 *
 *   Arguments:
 *
 *      DebugPrintLevel - Specifies at which debugging level the string should
 *          be printed
 *
 *      DebugMessage - Variable argument ascii c string
 *
 *   Return Value:
 *
 *      None.
 *
 ***************************************************************************/

VOID
DebugPrint(
    ULONG DebugPrintLevel,
    PCHAR DebugMessage,
    ...
    )

{

    va_list ap;

    va_start(ap, DebugMessage);

    if (DebugPrintLevel <= DebugLevel)
    {
        EngDebugPrint(STANDARD_DEBUG_PREFIX, DebugMessage, ap);
    }

    va_end(ap);

}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\vga\disp\8bpp\bitblt.c ===
/******************************Module*Header*******************************\
* Module Name: bitblt.c
*
* Banked Frame Buffer bitblit
*
* Copyright (c) 1992 Microsoft Corporation
*
\**************************************************************************/

#include "driver.h"

/************************************************************************\
* bIntersectRect
*
* Calculates the intersection between *prcSrc1 and *prcSrc2,
* returning the resulting rect in *prcDst.  Returns TRUE if
* *prcSrc1 intersects *prcSrc2, FALSE otherwise.  If there is no
* intersection, an empty rect is returned in *prcDst.
\************************************************************************/

static const RECTL rclEmpty = { 0, 0, 0, 0 };

BOOL bIntersectRect(
    PRECTL prcDst,
    PRECTL prcSrc1,
    PRECTL prcSrc2)

{
    prcDst->left  = max(prcSrc1->left, prcSrc2->left);
    prcDst->right = min(prcSrc1->right, prcSrc2->right);

    // check for empty rect

    if (prcDst->left < prcDst->right)
    {
        prcDst->top    = max(prcSrc1->top, prcSrc2->top);
        prcDst->bottom = min(prcSrc1->bottom, prcSrc2->bottom);

        // check for empty rect

        if (prcDst->top < prcDst->bottom)
            return(TRUE);        // not empty
    }

    // empty rect

    *prcDst = rclEmpty;

    return(FALSE);
}

/******************************Public*Routine******************************\
* BOOL bPuntScreenToScreenCopyBits(ppdev, pco, pxlo, prclDest, pptlSrc)
*
* Performs a screen-to-screen CopyBits entirely using an intermediate
* temporary buffer and GDI.
*
* We found that on most machines it was faster to have the engine copy
* the source to a buffer, then blit the buffer to the destination, than
* to have optimized ASM code that copies a word at a time.  The reason?
* The engine does d-word moves, which are faster than word moves even
* going over the bus to a 16 bit display device.
*
* We could also write optimized ASM code that does d-word moves, but the
* win will be marginal, we're time constrained, we also need a routine
* like this to handle complex clip objects and palette translates, and
* most of the other times we can use planar copies for important things
* like scrolls, anyways.
*
\**************************************************************************/

BOOL bPuntScreenToScreenCopyBits(
PPDEV     ppdev,
CLIPOBJ*  pco,
XLATEOBJ* pxlo,
RECTL*    prclDest,
POINTL*   pptlSrc)
{
    RECTL    rclDest;
    POINTL   ptlSrc;
    BOOL     b = TRUE;
    ULONG    ulWidth;
    LONG     ulBurstSize;
    LONG     xLeft;
    LONG     xRight;

    SURFOBJ* pso    = ppdev->pSurfObj;
    SURFOBJ* psoTmp = ppdev->psoTmp;
    ULONG    ulAlign;

    PVOID   savedpvScan0 = psoTmp->pvScan0;
    LONG    savedlDelta = psoTmp->lDelta;
    USHORT  savedfjBitmap = psoTmp->fjBitmap;

    xLeft = prclDest->left;
    xRight = prclDest->right;

    if (pco && (pco->iDComplexity != DC_TRIVIAL))
    {
        xLeft  = max(xLeft,pco->rclBounds.left);
        xRight = min(xRight,pco->rclBounds.right);
    }

    ulAlign = xLeft & 3;
    ulWidth = (((xRight + 3) & ~3) - (xLeft & ~3));
    ulBurstSize = min((GLOBAL_BUFFER_SIZE/ulWidth),(ULONG)(prclDest->bottom-prclDest->top));

    ASSERTVGA (ulBurstSize > 0, "VGA256:  bPuntScreenToScreenBitBlt ulBurstSize <= 0\n");

    // set up pso to use stack memory

    psoTmp->pvScan0 = ppdev->pvTmpBuf;
    psoTmp->lDelta  = ulWidth;
    psoTmp->fjBitmap |= BMF_TOPDOWN;

    if (prclDest->top < pptlSrc->y)
    {
        ////////////////////////////////////////////////////////////////
        // Do a top-to-bottom copy:
        ////////////////////////////////////////////////////////////////

        LONG ySrcBottom;
        LONG yDestBottom;

        LONG yDestTop = prclDest->top;
        LONG ySrcTop  = pptlSrc->y;
        LONG ySrcLast = ySrcTop + (prclDest->bottom - prclDest->top);

        if (ySrcTop <  ppdev->rcl1WindowClip.top ||
            ySrcTop >= ppdev->rcl1WindowClip.bottom)
        {
            ppdev->pfnBankControl(ppdev, ySrcTop, JustifyTop);
        }

        pso->pvScan0 = ppdev->pvBitmapStart;

        while (TRUE)
        {
            // Copy some scans into the temporary buffer:

            ySrcBottom     = min(ySrcLast, ppdev->rcl1WindowClip.bottom);
            ySrcBottom     = min(ySrcBottom,ySrcTop+ulBurstSize);

            ptlSrc.x       = pptlSrc->x;
            ptlSrc.y       = ySrcTop;

            rclDest.left   = ulAlign;   // make sure buffer is aligned to dst
            rclDest.top    = 0;
            rclDest.right  = xRight - xLeft + ulAlign;
            rclDest.bottom = ySrcBottom - ySrcTop;

            b &= EngCopyBits(psoTmp, pso, NULL, NULL, &rclDest, &ptlSrc);

            yDestBottom = yDestTop + rclDest.bottom;

            if (ppdev->rcl1WindowClip.top >= yDestBottom)
            {
                ppdev->pfnBankControl(ppdev, yDestBottom - 1, JustifyBottom);
                pso->pvScan0 = ppdev->pvBitmapStart;
            }

            while (TRUE)
            {
                // Copy the temporary buffer into one or more destination
                // banks:

                LONG yThisTop;
                LONG yThisBottom;
                LONG yOffset;

                yThisBottom    = min(yDestBottom, ppdev->rcl1WindowClip.bottom);
                yThisTop       = max(yDestTop, ppdev->rcl1WindowClip.top);
                yOffset        = yThisTop - yDestTop;

                ptlSrc.x       = ulAlign;
                ptlSrc.y       = yOffset;

                rclDest.left   = xLeft;
                rclDest.top    = yThisTop;
                rclDest.right  = xRight;
                rclDest.bottom = yThisBottom;

                b &= EngCopyBits(pso, psoTmp, pco, pxlo, &rclDest, &ptlSrc);

                if (yOffset == 0)
                    break;

                if (ppdev->rcl1WindowClip.top >= yThisTop)
                {
                    ppdev->pfnBankControl(ppdev, yThisTop - 1, JustifyBottom);
                    pso->pvScan0 = ppdev->pvBitmapStart;
                }
            }

            if (ySrcBottom >= ySrcLast)
                break;

            yDestTop = yDestBottom;
            ySrcTop  = ySrcBottom;

            if (ySrcTop >= ppdev->rcl1WindowClip.bottom)
            {
                ppdev->pfnBankControl(ppdev, ySrcTop, JustifyTop);
                pso->pvScan0 = ppdev->pvBitmapStart;
            }
        }
    }
    else
    {
        ////////////////////////////////////////////////////////////////
        // Do a bottom-to-top copy:
        ////////////////////////////////////////////////////////////////

        LONG ySrcTop;
        LONG yDestTop;

        LONG yDestBottom = prclDest->bottom;
        LONG ySrcFirst   = pptlSrc->y;
        LONG ySrcBottom  = ySrcFirst + (prclDest->bottom - prclDest->top);

        if (ySrcBottom <= ppdev->rcl1WindowClip.top ||
            ySrcBottom > ppdev->rcl1WindowClip.bottom)
        {
            ppdev->pfnBankControl(ppdev, ySrcBottom - 1, JustifyBottom);
        }

        pso->pvScan0 = ppdev->pvBitmapStart;

        while (TRUE)
        {
            // Copy some scans into the temporary buffer:

            ySrcTop        = max(ySrcFirst, ppdev->rcl1WindowClip.top);
            ySrcTop        = max(ySrcTop,ySrcBottom-ulBurstSize);

            ptlSrc.x       = pptlSrc->x;
            ptlSrc.y       = ySrcTop;

            rclDest.left   = ulAlign;
            rclDest.top    = 0;
            rclDest.right  = xRight - xLeft + ulAlign;
            rclDest.bottom = ySrcBottom - ySrcTop;

            b &= EngCopyBits(psoTmp, pso, NULL, NULL, &rclDest, &ptlSrc);

            yDestTop = yDestBottom - rclDest.bottom;

            if (ppdev->rcl1WindowClip.bottom <= yDestTop)
            {
                ppdev->pfnBankControl(ppdev, yDestTop, JustifyTop);
                pso->pvScan0 = ppdev->pvBitmapStart;
            }

            while (TRUE)
            {
                // Copy the temporary buffer into one or more destination
                // banks:

                LONG yThisTop;
                LONG yThisBottom;
                LONG yOffset;

                yThisTop       = max(yDestTop, ppdev->rcl1WindowClip.top);
                yThisBottom    = min(yDestBottom, ppdev->rcl1WindowClip.bottom);
                yOffset        = yThisTop - yDestTop;

                ptlSrc.x       = ulAlign;
                ptlSrc.y       = yOffset;

                rclDest.left   = xLeft;
                rclDest.top    = yThisTop;
                rclDest.right  = xRight;
                rclDest.bottom = yThisBottom;

                b &= EngCopyBits(pso, psoTmp, pco, pxlo, &rclDest, &ptlSrc);

                if (yThisBottom == yDestBottom)
                    break;

                if (ppdev->rcl1WindowClip.bottom <= yThisBottom)
                {
                    ppdev->pfnBankControl(ppdev, yThisBottom, JustifyTop);
                    pso->pvScan0 = ppdev->pvBitmapStart;
                }
            }

            if (ySrcTop <= ySrcFirst)
                break;

            yDestBottom = yDestTop;
            ySrcBottom  = ySrcTop;

            if (ppdev->rcl1WindowClip.top >= ySrcBottom)
            {
                ppdev->pfnBankControl(ppdev, ySrcBottom - 1, JustifyBottom);
                pso->pvScan0 = ppdev->pvBitmapStart;
            }
        }
    }

    // restore initial values to pso

    ppdev->psoTmp->pvScan0          = savedpvScan0;
    ppdev->psoTmp->lDelta           = savedlDelta;
    ppdev->psoTmp->fjBitmap         = savedfjBitmap;

    return(b);
}

/******************************Public*Routine******************************\
* BOOL bPuntScreenToScreenBitBlt(...)
*
* Performs a screen-to-screen BitBlt entirely using an intermediate temporary
* buffer and GDI.
*
* This function is basically a clone of bPuntScreenToScreenCopyBits,
* except that it can handle funky ROPs and stuff.
\**************************************************************************/

BOOL bPuntScreenToScreenBitBlt(
PPDEV     ppdev,
SURFOBJ*  psoMask,
CLIPOBJ*  pco,
XLATEOBJ* pxlo,
RECTL*    prclDest,
POINTL*   pptlSrc,
POINTL*   pptlMask,
BRUSHOBJ* pbo,
POINTL*   pptlBrush,
ROP4      rop4)
{
    RECTL    rclDest;           // Temporary destination rectangle
    POINTL   ptlSrc;            // Temporary source point
    POINTL   ptlMask;           // Temporary mask offset
    POINTL   ptlMaskAdjust;     // Adjustment for mask offset
    BOOL     b = TRUE;
    ULONG    ulWidth;
    LONG     ulBurstSize;
    LONG     xLeft;
    LONG     xRight;

    SURFOBJ* pso    = ppdev->pSurfObj;
    SURFOBJ* psoTmp = ppdev->psoTmp;
    ULONG    ulAlign;

    PVOID   savedpvScan0        = psoTmp->pvScan0;
    LONG    savedlDelta         = psoTmp->lDelta;
    USHORT  savedfjBitmap       = psoTmp->fjBitmap;


    xLeft = prclDest->left;
    xRight = prclDest->right;

    if (pco && (pco->iDComplexity != DC_TRIVIAL))
    {
        xLeft  = max(xLeft,pco->rclBounds.left);
        xRight = min(xRight,pco->rclBounds.right);
    }

    if (psoMask != NULL)
    {
        ptlMaskAdjust.x = xLeft - pptlMask->x;
        ptlMaskAdjust.y = prclDest->top  - pptlMask->y;
    }

    ulAlign = xLeft & 3;
    ulWidth = (((xRight + 3) & ~3) - (xLeft & ~3));
    ulBurstSize = min((GLOBAL_BUFFER_SIZE/ulWidth),(ULONG)(prclDest->bottom-prclDest->top));

    ASSERTVGA (ulBurstSize > 0, "bPuntScreenToScreenBitBlt ulBurstSize <= 0\n");

    // set up pso to use stack memory

    psoTmp->pvScan0 = ppdev->pvTmpBuf;
    psoTmp->lDelta  = ulWidth;
    psoTmp->fjBitmap |= BMF_TOPDOWN;

    if (prclDest->top < pptlSrc->y)
    {
        ////////////////////////////////////////////////////////////////
        // Do a top-to-bottom copy:
        ////////////////////////////////////////////////////////////////

        LONG ySrcBottom;
        LONG yDestBottom;

        LONG yDestTop = prclDest->top;
        LONG ySrcTop  = pptlSrc->y;
        LONG ySrcLast = ySrcTop + (prclDest->bottom - prclDest->top);

        if (ySrcTop <  ppdev->rcl1WindowClip.top ||
            ySrcTop >= ppdev->rcl1WindowClip.bottom)
        {
            ppdev->pfnBankControl(ppdev, ySrcTop, JustifyTop);
        }

        pso->pvScan0 = ppdev->pvBitmapStart;

        while (TRUE)
        {
            // Copy some scans into the temporary buffer:

            ySrcBottom     = min(ySrcLast, ppdev->rcl1WindowClip.bottom);
            ySrcBottom     = min(ySrcBottom,ySrcTop+ulBurstSize);

            ptlSrc.x       = pptlSrc->x;
            ptlSrc.y       = ySrcTop;

            rclDest.left   = ulAlign;
            rclDest.top    = 0;
            rclDest.right  = xRight - xLeft + ulAlign;
            rclDest.bottom = ySrcBottom - ySrcTop;

            b &= EngCopyBits(psoTmp, pso, NULL, NULL, &rclDest, &ptlSrc);

            yDestBottom = yDestTop + rclDest.bottom;

            if (ppdev->rcl1WindowClip.top >= yDestBottom)
            {
                ppdev->pfnBankControl(ppdev, yDestBottom - 1, JustifyBottom);
                pso->pvScan0 = ppdev->pvBitmapStart;
            }

            while (TRUE)
            {
                // Copy the temporary buffer into one or more destination
                // banks:

                LONG yThisTop;
                LONG yThisBottom;
                LONG yOffset;

                yThisBottom    = min(yDestBottom, ppdev->rcl1WindowClip.bottom);
                yThisTop       = max(yDestTop, ppdev->rcl1WindowClip.top);
                yOffset        = yThisTop - yDestTop;

                ptlSrc.x       = ulAlign;
                ptlSrc.y       = yOffset;

                rclDest.left   = xLeft;
                rclDest.top    = yThisTop;
                rclDest.right  = xRight;
                rclDest.bottom = yThisBottom;

                ptlMask.x = rclDest.left - ptlMaskAdjust.x;
                ptlMask.y = rclDest.top  - ptlMaskAdjust.y;

                b &= EngBitBlt(pso, psoTmp, psoMask, pco, pxlo, &rclDest,
                               &ptlSrc, &ptlMask, pbo, pptlBrush, rop4);

                if (yOffset == 0)
                    break;

                if (ppdev->rcl1WindowClip.top >= yThisTop)
                {
                    ppdev->pfnBankControl(ppdev, yThisTop - 1, JustifyBottom);
                    pso->pvScan0 = ppdev->pvBitmapStart;
                }
            }

            if (ySrcBottom >= ySrcLast)
                break;

            yDestTop = yDestBottom;
            ySrcTop  = ySrcBottom;

            if (ySrcTop >= ppdev->rcl1WindowClip.bottom)
            {
                ppdev->pfnBankControl(ppdev, ySrcTop, JustifyTop);
                pso->pvScan0 = ppdev->pvBitmapStart;
            }
        }
    }
    else
    {
        ////////////////////////////////////////////////////////////////
        // Do a bottom-to-top copy:
        ////////////////////////////////////////////////////////////////

        LONG ySrcTop;
        LONG yDestTop;

        LONG yDestBottom = prclDest->bottom;
        LONG ySrcFirst   = pptlSrc->y;
        LONG ySrcBottom  = ySrcFirst + (prclDest->bottom - prclDest->top);

        if (ySrcBottom <= ppdev->rcl1WindowClip.top ||
            ySrcBottom > ppdev->rcl1WindowClip.bottom)
        {
            ppdev->pfnBankControl(ppdev, ySrcBottom - 1, JustifyBottom);
        }

        pso->pvScan0 = ppdev->pvBitmapStart;

        while (TRUE)
        {
            // Copy some scans into the temporary buffer:

            ySrcTop        = max(ySrcFirst, ppdev->rcl1WindowClip.top);
            ySrcTop        = max(ySrcTop,ySrcBottom-ulBurstSize);

            ptlSrc.x       = pptlSrc->x;
            ptlSrc.y       = ySrcTop;

            rclDest.left   = ulAlign;
            rclDest.top    = 0;
            rclDest.right  = xRight - xLeft + ulAlign;
            rclDest.bottom = ySrcBottom - ySrcTop;

            b &= EngCopyBits(psoTmp, pso, NULL, NULL, &rclDest, &ptlSrc);

            yDestTop = yDestBottom - rclDest.bottom;

            if (ppdev->rcl1WindowClip.bottom <= yDestTop)
            {
                ppdev->pfnBankControl(ppdev, yDestTop, JustifyTop);
                pso->pvScan0 = ppdev->pvBitmapStart;
            }

            while (TRUE)
            {
                // Copy the temporary buffer into one or more destination
                // banks:

                LONG yThisTop;
                LONG yThisBottom;
                LONG yOffset;

                yThisTop       = max(yDestTop, ppdev->rcl1WindowClip.top);
                yThisBottom    = min(yDestBottom, ppdev->rcl1WindowClip.bottom);
                yOffset        = yThisTop - yDestTop;

                ptlSrc.x       = ulAlign;
                ptlSrc.y       = yOffset;

                rclDest.left   = xLeft;
                rclDest.top    = yThisTop;
                rclDest.right  = xRight;
                rclDest.bottom = yThisBottom;

                ptlMask.x = rclDest.left - ptlMaskAdjust.x;
                ptlMask.y = rclDest.top  - ptlMaskAdjust.y;

                b &= EngBitBlt(pso, psoTmp, psoMask, pco, pxlo, &rclDest,
                               &ptlSrc, &ptlMask, pbo, pptlBrush, rop4);

                if (yThisBottom == yDestBottom)
                    break;

                if (ppdev->rcl1WindowClip.bottom <= yThisBottom)
                {
                    ppdev->pfnBankControl(ppdev, yThisBottom, JustifyTop);
                    pso->pvScan0 = ppdev->pvBitmapStart;
                }
            }

            if (ySrcTop <= ySrcFirst)
                break;

            yDestBottom = yDestTop;
            ySrcBottom  = ySrcTop;

            if (ppdev->rcl1WindowClip.top >= ySrcBottom)
            {
                ppdev->pfnBankControl(ppdev, ySrcBottom - 1, JustifyBottom);
                pso->pvScan0 = ppdev->pvBitmapStart;
            }
        }
    }

    // restore initial values to pso

    ppdev->psoTmp->pvScan0          = savedpvScan0;
    ppdev->psoTmp->lDelta           = savedlDelta;
    ppdev->psoTmp->fjBitmap         = savedfjBitmap;

    return(b);
}

/******************************Public*Data*********************************\
* ROP to mix translation table
*
* Table to translate ternary raster ops to mixes (binary raster ops). Ternary
* raster ops that can't be translated to mixes are translated to 0 (0 is not
* a valid mix).
*
\**************************************************************************/

UCHAR jRop3ToMix[256] = {
    R2_BLACK, 0, 0, 0, 0, R2_NOTMERGEPEN, 0, 0,
    0, 0, R2_MASKNOTPEN, 0, 0, 0, 0, R2_NOTCOPYPEN,
    0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0,
    R2_MASKPENNOT, 0, 0, 0, 0, R2_NOT, 0, 0,
    0, 0, R2_XORPEN, 0, 0, 0, 0, R2_NOTMASKPEN,
    0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0,
    R2_MASKPEN, 0, 0, 0, 0, R2_NOTXORPEN, 0, 0,
    0, 0, R2_NOP, 0, 0, 0, 0, R2_MERGENOTPEN,
    0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0,
    R2_COPYPEN, 0, 0, 0, 0, R2_MERGEPENNOT, 0, 0,
    0, 0, R2_MERGEPEN, 0, 0, 0, 0, R2_WHITE
};

/******************************Public*Routine******************************\
* BOOL DrvBitBlt(psoDest, psoSrc, psoMask, pco, pxlo, prclDest, pptlSrc,
*                pptlMask, pbo, pptlBrush, rop4)
*
* This routine will handle any blit.  Perhaps glacially, but it will be
* handled.
\**************************************************************************/

BOOL DrvBitBlt(
SURFOBJ*  psoDest,
SURFOBJ*  psoSrc,
SURFOBJ*  psoMask,
CLIPOBJ*  pco,
XLATEOBJ* pxlo,
RECTL*    prclDest,
POINTL*   pptlSrc,
POINTL*   pptlMask,
BRUSHOBJ* pbo,
POINTL*   pptlBrush,
ROP4      rop4)
{
    BOOL     b;
    POINTL   ptlSrc;
    RECTL    rclDest;
    PPDEV    ppdev;
    SURFOBJ* pso;
    MIX      mix;           // Mix, when solid fill performed
    BYTE     jClipping;
    RECTL    rclTmp;
    POINTL   ptlTmp;
    BBENUM   bben;          // Clip enumerator
    BOOL     bMore;         // Clip continuation flag
    POINTL   ptlMask;       // Temporary mask for engine call-backs
    POINTL   ptlMaskAdjust; // Adjustment for mask
    INT      iCopyDir;

    RBRUSH_COLOR rbc;               // Pointer to RBRUSH or iSolidColor value
    PFNFILL      pfnFill = vTrgBlt; // Pointer to appropriate fill routine
                                    //  (solid color by default)

    DISPDBG((3, "DrvBitBlt: Entering."));

    // Set up the clipping type
    if (pco == (CLIPOBJ *) NULL) {
        // No CLIPOBJ provided, so we don't have to worry about clipping
        jClipping = DC_TRIVIAL;
    } else {
        // Use the CLIPOBJ-provided clipping
        jClipping = pco->iDComplexity;
    }

    // Handle solid fills to the VGA surface with special-case code if planar
    // mode is supported.
    // LATER handle non-planar also

    if (psoDest->iType == STYPE_DEVICE) {

        // Destination is the VGA surface

        // Masked cases must be handled differently

        if ((((PPDEV) psoDest->dhsurf)->fl & DRIVER_PLANAR_CAPABLE) &&
            ((rop4 & 0xFF) == ((rop4 >> 8) & 0xFF))) {

            // Special-case static code for no-mask cases

            // Calculate mix from ROP if possible (not possible if it's truly a
            // ternary rop or a real rop4, but we can treat all pure binary
            // rops as mixes rather than rop4s)
            mix = jRop3ToMix[rop4 & 0xFF];

            switch (mix) {
                case R2_MASKNOTPEN:
                case R2_NOTCOPYPEN:
                case R2_XORPEN:
                case R2_MASKPEN:
                case R2_NOTXORPEN:
                case R2_MERGENOTPEN:
                case R2_COPYPEN:
                case R2_MERGEPEN:
                case R2_NOTMERGEPEN:
                case R2_MASKPENNOT:
                case R2_NOTMASKPEN:
                case R2_MERGEPENNOT:

                    // vTrgBlt can only handle solid color fills

                    if (pbo->iSolidColor != 0xffffffff)
                    {
                        rbc.iSolidColor = pbo->iSolidColor;
                    }
                    else
                    {
                        rbc.prb = (RBRUSH*) pbo->pvRbrush;
                        if (rbc.prb == NULL)
                        {
                            rbc.prb = (RBRUSH*) BRUSHOBJ_pvGetRbrush(pbo);
                            if (rbc.prb == NULL)
                            {
                            // If we haven't realized the brush, punt the call
                            // to the engine:

                                break;
                            }
                        }
                        if (!(rbc.prb->fl & RBRUSH_BLACKWHITE) &&
                            (mix != R2_COPYPEN))
                        {
                        // Only black/white brushes can handle ROPs other
                        // than COPYPEN:

                            break;
                        }

                        if (rbc.prb->fl & RBRUSH_NCOLOR)
                            pfnFill = vColorPat;
                        else
                            pfnFill = vMonoPat;
                    }

                // Rops that are implicit solid colors

                case R2_NOT:
                case R2_WHITE:
                case R2_BLACK:
                    // We can do a special-case solid fill

                    switch(jClipping) {
                        case DC_TRIVIAL:

                            // Just fill the rectangle:

                            (*pfnFill)((PPDEV) psoDest->dhsurf, 1,
                                       prclDest, mix, rbc, pptlBrush);

                            break;

                        case DC_RECT:

                            // Clip the solid fill to the clip rectangle
                            if (!bIntersectRect(&rclTmp, prclDest,
                                    &pco->rclBounds))
                                return(TRUE);

                            // Fill the clipped rectangle

                            (*pfnFill)((PPDEV) psoDest->dhsurf, 1,
                                       &rclTmp, mix, rbc, pptlBrush);

                            break;

                        case DC_COMPLEX:

                            ppdev = (PPDEV) psoDest->dhsurf;

                            CLIPOBJ_cEnumStart(pco, FALSE, CT_RECTANGLES,
                                               CD_ANY, BB_RECT_LIMIT);

                            do {
                                bMore = CLIPOBJ_bEnum(pco,(ULONG) sizeof(bben),
                                                      (PVOID) &bben);

                                if (bben.c > 0)
                                {
                                    RECTL* prclEnd = &bben.arcl[bben.c];
                                    RECTL* prcl    = &bben.arcl[0];

                                    do {
                                        bIntersectRect(prcl, prcl, prclDest);
                                        prcl++;

                                    } while (prcl < prclEnd);

                                    (*pfnFill)(ppdev, bben.c, bben.arcl,
                                               mix, rbc, pptlBrush);
                                }

                            } while(bMore);
                    }

                case R2_NOP:
                    return(TRUE);

                default:
                    break;
            }
        }
    }

    // Get the correct surface object for the target and the source

    if (psoDest->iType == STYPE_DEVICE) {

        if ((psoSrc != NULL) && (psoSrc->iType == STYPE_DEVICE)) {

            ////////////////////////////////////////////////////////////////
            // BitBlt screen-to-screen:
            ////////////////////////////////////////////////////////////////

            ppdev = (PPDEV) psoDest->dhsurf;

            // See if we can do a simple CopyBits:

            if (rop4 == 0x0000CCCC)
            {
                ppdev = (PPDEV) psoDest->dhsurf;

                // We can handle quadpixel-aligned screen-to-screen blts with
                // no translation:

                if ((((pptlSrc->x ^ prclDest->left) & 3) == 0) &&
                    (ppdev->fl & DRIVER_PLANAR_CAPABLE) &&
                    ((pxlo == NULL) || (pxlo->flXlate & XO_TRIVIAL)))
                {
                    switch(jClipping)
                    {
                    case DC_TRIVIAL:
                        vPlanarCopyBits(ppdev, prclDest, pptlSrc);
                        return(TRUE);

                    case DC_RECT:

                        // Clip the target rectangle to the clip rectangle:

                        if (!bIntersectRect(&rclTmp, prclDest, &pco->rclBounds))
                        {
                            DISPDBG((0, "DrvBitBlt: Nothing to draw."));
                            return(TRUE);
                        }

                        ptlTmp.x = pptlSrc->x + rclTmp.left - prclDest->left;
                        ptlTmp.y = pptlSrc->y + rclTmp.top  - prclDest->top;

                        vPlanarCopyBits(ppdev, &rclTmp, &ptlTmp);
                        return(TRUE);

                    case DC_COMPLEX:
                        if (pptlSrc->y >= prclDest->top)
                        {
                            if (pptlSrc->x >= prclDest->left)
                                iCopyDir = CD_RIGHTDOWN;
                            else
                                iCopyDir = CD_LEFTDOWN;
                        }
                        else
                        {
                            if (pptlSrc->x >= prclDest->left)
                                iCopyDir = CD_RIGHTUP;
                            else
                                iCopyDir = CD_LEFTUP;
                        }

                        CLIPOBJ_cEnumStart(pco, FALSE, CT_RECTANGLES, iCopyDir, 0);

                        do {
                            RECTL* prcl;
                            RECTL* prclEnd;

                            bMore = CLIPOBJ_bEnum(pco, (ULONG) sizeof(bben),
                                                  (PVOID) &bben);

                            prclEnd = &bben.arcl[bben.c];
                            for (prcl = bben.arcl; prcl < prclEnd; prcl++)
                            {
                                if (bIntersectRect(prcl, prclDest, prcl))
                                {
                                    ptlTmp.x = pptlSrc->x + prcl->left - prclDest->left;
                                    ptlTmp.y = pptlSrc->y + prcl->top  - prclDest->top;

                                    vPlanarCopyBits(ppdev, prcl, &ptlTmp);
                                }
                            }
                        } while (bMore);

                        return(TRUE);
                    }
                }

                // Can't handle in hardware, so punt:

                return(bPuntScreenToScreenCopyBits(ppdev,
                                                   pco,
                                                   pxlo,
                                                   prclDest,
                                                   pptlSrc));
            }

            // It's more complicated than a CopyBits, so punt it:

            return(bPuntScreenToScreenBitBlt(ppdev,
                                             psoMask,
                                             pco,
                                             pxlo,
                                             prclDest,
                                             pptlSrc,
                                             pptlMask,
                                             pbo,
                                             pptlBrush,
                                             rop4));
        }

        ////////////////////////////////////////////////////////////////
        // BitBlt to screen:
        ////////////////////////////////////////////////////////////////

        ppdev = (PPDEV) psoDest->dhsurf;

        if ((rop4 == 0x0000CCCC) &&
            (psoSrc->iBitmapFormat == BMF_8BPP) &&
            ((pxlo == NULL) || (pxlo->flXlate & XO_TRIVIAL)))
        {
        // We have special code for the common 8bpp from memory to screen
        // with no ROPs:

            switch(jClipping)
            {
            case DC_TRIVIAL:
                vSrcCopy8bpp(ppdev, prclDest, pptlSrc,
                             psoSrc->lDelta, psoSrc->pvScan0);
                return(TRUE);

            case DC_RECT:

                // Clip the blt to the clip rectangle

                if(bIntersectRect(&rclTmp, prclDest, &pco->rclBounds)){

                    ptlTmp.x = pptlSrc->x + rclTmp.left - prclDest->left;
                    ptlTmp.y = pptlSrc->y + rclTmp.top  - prclDest->top;

                    vSrcCopy8bpp(ppdev, &rclTmp, &ptlTmp,
                                 psoSrc->lDelta, psoSrc->pvScan0);
                }

                return(TRUE);

            case DC_COMPLEX:

                CLIPOBJ_cEnumStart(pco, FALSE, CT_RECTANGLES,
                                   CD_ANY, BB_RECT_LIMIT);

                do {
                    bMore = CLIPOBJ_bEnum(pco,(ULONG) sizeof(bben),
                                          (PVOID) &bben);

                    if (bben.c > 0)
                    {
                        RECTL* prclEnd = &bben.arcl[bben.c];
                        RECTL* prcl    = &bben.arcl[0];

                        do {
                            if (bIntersectRect(prcl, prcl, prclDest)){

                                ptlTmp.x = pptlSrc->x + prcl->left
                                           - prclDest->left;
                                ptlTmp.y = pptlSrc->y + prcl->top
                                           - prclDest->top;

                                vSrcCopy8bpp(ppdev, prcl, &ptlTmp,
                                             psoSrc->lDelta, psoSrc->pvScan0);
                            }

                            prcl++;

                        } while (prcl < prclEnd);
                    }

                } while(bMore);

                return(TRUE);
            }
        }

        // Punt the memory-to-screen call back to the engine:

        if (psoMask != NULL)
        {
            ptlMaskAdjust.x = prclDest->left - pptlMask->x;
            ptlMaskAdjust.y = prclDest->top  - pptlMask->y;
        }

        pso = ppdev->pSurfObj;

        vBankStartBltDest(ppdev, pso, pptlSrc, prclDest, &ptlSrc, &rclDest);

        do {
            ptlMask.x = rclDest.left - ptlMaskAdjust.x;
            ptlMask.y = rclDest.top  - ptlMaskAdjust.y;

            b = EngBitBlt(pso,
                          psoSrc,
                          psoMask,
                          pco,
                          pxlo,
                          &rclDest,
                          &ptlSrc,
                          &ptlMask,
                          pbo,
                          pptlBrush,
                          rop4);

        } while (b && bBankEnumBltDest(ppdev, pso, pptlSrc, prclDest,
                                       &ptlSrc, &rclDest));

        return(b);
    }
    else if ((psoSrc != NULL) && (psoSrc->iType == STYPE_DEVICE))
    {
        ////////////////////////////////////////////////////////////////
        // BitBlt from screen:
        ////////////////////////////////////////////////////////////////

        if (psoMask != NULL)
        {
            ptlMaskAdjust.x = prclDest->left - pptlMask->x;
            ptlMaskAdjust.y = prclDest->top  - pptlMask->y;
        }

        ppdev = (PPDEV) psoSrc->dhsurf;
        pso   = ppdev->pSurfObj;

        vBankStartBltSrc(ppdev, pso, pptlSrc, prclDest, &ptlSrc, &rclDest);

        do {
            ptlMask.x = rclDest.left - ptlMaskAdjust.x;
            ptlMask.y = rclDest.top  - ptlMaskAdjust.y;

            b = EngBitBlt(psoDest,
                          pso,
                          psoMask,
                          pco,
                          pxlo,
                          &rclDest,
                          &ptlSrc,
                          &ptlMask,
                          pbo,
                          pptlBrush,
                          rop4);

        } while (b && bBankEnumBltSrc(ppdev, pso, pptlSrc, prclDest,
                                      &ptlSrc, &rclDest));

        return(b);
    }

    RIP("Got a funky format?");
    return(FALSE);
}

/***************************************************************************\
* DrvCopyBits
\***************************************************************************/

BOOL DrvCopyBits(
SURFOBJ*  psoDest,
SURFOBJ*  psoSrc,
CLIPOBJ*  pco,
XLATEOBJ* pxlo,
RECTL*    prclDest,
POINTL*   pptlSrc)
{
    BOOL     b;
    POINTL   ptlSrc;
    RECTL    rclDest;
    PPDEV    ppdev;
    SURFOBJ* pso;
    BBENUM   bben;
    BOOL     bMore;
    BYTE     jClipping;
    POINTL   ptlTmp;
    RECTL    rclTmp;
    INT      iCopyDir;

    // Get the correct surface object for the target and the source

    if (psoDest->iType == STYPE_DEVICE)
    {
        // We have to special case screen-to-screen operations:

        if ((psoSrc != NULL) && (psoSrc->iType == STYPE_DEVICE))
        {

            ////////////////////////////////////////////////////////////////
            // CopyBits screen-to-screen:
            ////////////////////////////////////////////////////////////////

            ppdev = (PPDEV) psoDest->dhsurf;

            // We check to see if we can do a planar copy, because usually
            // it will be faster.  But the hardware has to be capable of
            // doing it, and the source and destination must be 4-pel
            // aligned.

            if ((((pptlSrc->x ^ prclDest->left) & 3) == 0) &&
                (ppdev->fl & DRIVER_PLANAR_CAPABLE) &&
                ((pxlo == NULL) || (pxlo->flXlate & XO_TRIVIAL)))
            {
                jClipping = (pco != NULL) ? pco->iDComplexity : DC_TRIVIAL;

                switch(jClipping)
                {
                case DC_TRIVIAL:
                    vPlanarCopyBits(ppdev, prclDest, pptlSrc);
                    return(TRUE);

                case DC_RECT:
                    // Clip the target rectangle to the clip rectangle:

                    if (!bIntersectRect(&rclTmp, prclDest, &pco->rclBounds))
                    {
                        DISPDBG((0, "DrvCopyBits: Nothing to draw."));
                        return(TRUE);
                    }

                    ptlTmp.x = pptlSrc->x + rclTmp.left - prclDest->left;
                    ptlTmp.y = pptlSrc->y + rclTmp.top  - prclDest->top;

                    vPlanarCopyBits(ppdev, &rclTmp, &ptlTmp);
                    return(TRUE);

                case DC_COMPLEX:
                    if (pptlSrc->y >= prclDest->top)
                    {
                        if (pptlSrc->x >= prclDest->left)
                            iCopyDir = CD_RIGHTDOWN;
                        else
                            iCopyDir = CD_LEFTDOWN;
                    }
                    else
                    {
                        if (pptlSrc->x >= prclDest->left)
                            iCopyDir = CD_RIGHTUP;
                        else
                            iCopyDir = CD_LEFTUP;
                    }

                    CLIPOBJ_cEnumStart(pco, FALSE, CT_RECTANGLES, iCopyDir, 0);

                    do {
                        RECTL* prcl;
                        RECTL* prclEnd;

                        bMore = CLIPOBJ_bEnum(pco, (ULONG) sizeof(bben),
                                              (PVOID) &bben);

                        prclEnd = &bben.arcl[bben.c];
                        for (prcl = bben.arcl; prcl < prclEnd; prcl++)
                        {
                            if (bIntersectRect(prcl, prclDest, prcl))
                            {
                                ptlTmp.x = pptlSrc->x + prcl->left - prclDest->left;
                                ptlTmp.y = pptlSrc->y + prcl->top  - prclDest->top;

                                vPlanarCopyBits(ppdev, prcl, &ptlTmp);
                            }
                        }
                    } while (bMore);

                    return(TRUE);
                }
            }

            return(bPuntScreenToScreenCopyBits(ppdev,
                                               pco,
                                               pxlo,
                                               prclDest,
                                               pptlSrc));
        }

        ////////////////////////////////////////////////////////////////
        // CopyBits to screen:
        ////////////////////////////////////////////////////////////////

        ppdev = (PPDEV) psoDest->dhsurf;

        if ((psoSrc->iBitmapFormat == BMF_8BPP) &&
            ((pxlo == NULL) || (pxlo->flXlate & XO_TRIVIAL)))
        {
        // We have special code for the common 8bpp from memory to screen
        // with no ROPs:

            jClipping = (pco != NULL) ? pco->iDComplexity : DC_TRIVIAL;

            switch(jClipping)
            {
            case DC_TRIVIAL:
                vSrcCopy8bpp(ppdev, prclDest, pptlSrc,
                             psoSrc->lDelta, psoSrc->pvScan0);
                return(TRUE);

            case DC_RECT:

                // Clip the blt to the clip rectangle

                if( bIntersectRect(&rclTmp, prclDest, &pco->rclBounds)){

                    ptlTmp.x = pptlSrc->x + rclTmp.left - prclDest->left;
                    ptlTmp.y = pptlSrc->y + rclTmp.top  - prclDest->top;

                    vSrcCopy8bpp(ppdev, &rclTmp, &ptlTmp,
                                 psoSrc->lDelta, psoSrc->pvScan0);
                }

                return(TRUE);

            case DC_COMPLEX:

                CLIPOBJ_cEnumStart(pco, FALSE, CT_RECTANGLES,
                                   CD_ANY, BB_RECT_LIMIT);

                do {
                    bMore = CLIPOBJ_bEnum(pco,(ULONG) sizeof(bben),
                                          (PVOID) &bben);

                    if (bben.c > 0)
                    {
                        RECTL* prclEnd = &bben.arcl[bben.c];
                        RECTL* prcl    = &bben.arcl[0];

                        do {

                            ASSERTVGA((prcl->bottom - prcl->top) > 0,
                                      "DrvCopyBits: enum rect height <= 0\n");

                            ASSERTVGA((prcl->right - prcl->left) > 0,
                                      "DrvCopyBits: enum rect width <= 0\n");

                            if(bIntersectRect(prcl, prcl, prclDest)){

                                ptlTmp.x = pptlSrc->x + prcl->left
                                         - prclDest->left;
                                ptlTmp.y = pptlSrc->y + prcl->top
                                         - prclDest->top;

                                vSrcCopy8bpp(ppdev, prcl, &ptlTmp,
                                             psoSrc->lDelta, psoSrc->pvScan0);
                            }

                            prcl++;

                        } while (prcl < prclEnd);
                    }

                } while(bMore);

                return(TRUE);
            }
        }

        // Fall back to the engine:

        pso = ppdev->pSurfObj;
        vBankStartBltDest(ppdev, pso, pptlSrc, prclDest, &ptlSrc, &rclDest);

        do {
            b = EngCopyBits(pso,
                            psoSrc,
                            pco,
                            pxlo,
                            &rclDest,
                            &ptlSrc);

        } while (b && bBankEnumBltDest(ppdev, pso, pptlSrc, prclDest,
                                       &ptlSrc, &rclDest));

        return(b);
    }
    else if ((psoSrc != NULL) && (psoSrc->iType == STYPE_DEVICE))
    {
        ////////////////////////////////////////////////////////////////
        // CopyBits from screen:
        ////////////////////////////////////////////////////////////////

        ppdev = (PPDEV) psoSrc->dhsurf;
        pso   = ppdev->pSurfObj;

        vBankStartBltSrc(ppdev, pso, pptlSrc, prclDest, &ptlSrc, &rclDest);

        do {
            b = EngCopyBits(psoDest,
                            pso,
                            pco,
                            pxlo,
                            &rclDest,
                            &ptlSrc);

        } while (b && bBankEnumBltSrc(ppdev, pso, pptlSrc, prclDest,
                                      &ptlSrc, &rclDest));

        return(b);
    }

    /* we should never be here */
    return FALSE;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\vga\disp\8bpp\bankmgr.c ===
/*****************************************************************************\
* Smart 256 Colour Bank Manager
*
* Copyright (c) 1992 Microsoft Corporation
\*****************************************************************************/

#include "driver.h"

/*****************************************************************************\
* pcoBankStart - Start the bank enumeration using the clip object.
*
* Used when the destination is the screen and we can't do the clipping
* ourselves (as we can for blt's).
\*****************************************************************************/

CLIPOBJ* pcoBankStart(
    PPDEV       ppdev,
    RECTL*      prclScans,
    SURFOBJ*    pso,
    CLIPOBJ*    pco)
{
    LONG iTopScan = max(0, prclScans->top);

    if (pco)
    {
        iTopScan = max(prclScans->top, pco->rclBounds.top);
    }
    // Adjust for those weird cases where we're asked to start enumerating
    // below the bottom of the screen:

    iTopScan = min(iTopScan, (LONG) ppdev->cyScreen - 1);

    // Map in the bank:

    if (iTopScan <  ppdev->rcl1WindowClip.top ||
        iTopScan >= ppdev->rcl1WindowClip.bottom)
    {
        ppdev->pfnBankControl(ppdev, iTopScan, JustifyTop);
    }

    // Remember what the last scan is that we're going to, and
    // make sure we only try to go as far as we need to.  It could
    // happen that when get a prclScans bigger than the screen:

    ppdev->iLastScan = min(prclScans->bottom, (LONG) ppdev->cyScreen);

    if (pco)
    {
        ppdev->iLastScan = min(ppdev->iLastScan, pco->rclBounds.bottom);
    }

    pso->pvScan0 = ppdev->pvBitmapStart;

    if (pco == NULL)
    {
        // The call may have come down to us as having no clipping, but
        // we have to clip to the banks, so use our own clip object:

        pco            = ppdev->pcoNull;
        pco->rclBounds = ppdev->rcl1WindowClip;
    }
    else
    {
        // Save the engine's clip object data that we'll be tromping on:

        ppdev->rclSaveBounds    = pco->rclBounds;
        ppdev->iSaveDComplexity = pco->iDComplexity;
        ppdev->fjSaveOptions    = pco->fjOptions;

        // Let engine know it has to pay attention to the rclBounds of the
        // clip object:

        pco->fjOptions |= OC_BANK_CLIP;

        if (pco->iDComplexity == DC_TRIVIAL)
            pco->iDComplexity = DC_RECT;

        // Use the bank bounds if they are tighter than the existing
        // bounds.  We don't have to check the left case here because we
        // know that ppdev->rcl1WindowClip.left == 0.

        if (pco->rclBounds.top <= ppdev->rcl1WindowClip.top)
            pco->rclBounds.top = ppdev->rcl1WindowClip.top;

        if (pco->rclBounds.right >= ppdev->rcl1WindowClip.right)
            pco->rclBounds.right = ppdev->rcl1WindowClip.right;

        if (pco->rclBounds.bottom >= ppdev->rcl1WindowClip.bottom)
            pco->rclBounds.bottom = ppdev->rcl1WindowClip.bottom;

        if ((pco->rclBounds.top  >= pco->rclBounds.bottom) ||
            (pco->rclBounds.left >= pco->rclBounds.right))
        {
            // It's conceivable that we could get a situation where our
            // draw rectangle is completely disjoint from the specified
            // rectangle's rclBounds.  Make sure we don't puke on our
            // shoes:

            pco->rclBounds.left   = 0;
            pco->rclBounds.top    = 0;
            pco->rclBounds.right  = 0;
            pco->rclBounds.bottom = 0;
            ppdev->iLastScan      = 0;
        }
    }

    return(pco);
}

/*****************************************************************************\
* bBankEnum - Continue the bank enumeration.
\*****************************************************************************/

BOOL bBankEnum(PPDEV ppdev, SURFOBJ* pso, CLIPOBJ* pco)
{
    // If we're on the first portion of a broken raster, get the next:

    LONG yNewTop = ppdev->rcl1WindowClip.bottom;

    DISPDBG((4, "bBankEnum: Start.\n"));

    if (ppdev->flBank & BANK_BROKEN_RASTER1)
        ppdev->pfnBankNext(ppdev);

    else if (ppdev->rcl1WindowClip.bottom < ppdev->iLastScan)
        ppdev->pfnBankControl(ppdev, yNewTop, JustifyTop);

    else
    {
        // Okay, that was the last bank, so restore our structures:

        if (pco != ppdev->pcoNull)
        {
            pco->rclBounds    = ppdev->rclSaveBounds;
            pco->iDComplexity = ppdev->iSaveDComplexity;
            pco->fjOptions    = ppdev->fjSaveOptions;
        }

        return(FALSE);
    }

    // Adjust the pvScan0 because we've moved the window to view
    // a different area:

    pso->pvScan0 = ppdev->pvBitmapStart;

    if (pco == ppdev->pcoNull)
    {
        // If were given a NULL clip object originally, we don't have
        // to worry about clipping to ppdev->rclSaveBounds:

        pco->rclBounds.top    = yNewTop;
        pco->rclBounds.left   = ppdev->rcl1WindowClip.left;
        pco->rclBounds.bottom = ppdev->rcl1WindowClip.bottom;
        pco->rclBounds.right  = ppdev->rcl1WindowClip.right;
    }
    else
    {
        // Use the bank bounds if they are tighter than the bounds
        // we were originally given:

        pco->rclBounds = ppdev->rclSaveBounds;

        if (pco->rclBounds.top <= yNewTop)
            pco->rclBounds.top = yNewTop;

        if (pco->rclBounds.left <= ppdev->rcl1WindowClip.left)
            pco->rclBounds.left = ppdev->rcl1WindowClip.left;

        if (pco->rclBounds.right >= ppdev->rcl1WindowClip.right)
            pco->rclBounds.right = ppdev->rcl1WindowClip.right;

        if (pco->rclBounds.bottom >= ppdev->rcl1WindowClip.bottom)
            pco->rclBounds.bottom = ppdev->rcl1WindowClip.bottom;
    }

    DISPDBG((4, "bBankEnum: Leaving.\n"));

    return(TRUE);
}

/***************************************************************************\
* vBankStartBltSrc - Start the bank enumeration for when the screen is
*                   the source.
\***************************************************************************/

VOID vBankStartBltSrc(
    PPDEV       ppdev,
    SURFOBJ*    pso,
    POINTL*     pptlSrc,
    RECTL*      prclDest,
    POINTL*     pptlNewSrc,
    RECTL*      prclNewDest)
{
    LONG xRightSrc;
    LONG yBottomSrc;
    LONG iTopScan = max(0, pptlSrc->y);

    DISPDBG((4, "vBankStartBltSrc: Entering.\n"));

    if (iTopScan >= (LONG) ppdev->cyScreen)
    {
    // In some instances we may be asked to start on a scan below the screen.
    // Since we obviously won't be drawing anything, don't bother mapping in
    // a bank:

        return;
    }

    // Map in the bank:

    if (iTopScan <  ppdev->rcl1WindowClip.top ||
        iTopScan >= ppdev->rcl1WindowClip.bottom)
    {
        ppdev->pfnBankControl(ppdev, iTopScan, JustifyTop);
    }

    if (ppdev->rcl1WindowClip.right <= pptlSrc->x)
    {
    // We have to watch out for those rare cases where we're starting
    // on a broken raster and we won't be drawing on the first part:

        ASSERTVGA(ppdev->flBank & BANK_BROKEN_RASTER1, "Weird start bounds");

        ppdev->pfnBankNext(ppdev);
    }

    pso->pvScan0 = ppdev->pvBitmapStart;

    // Adjust the source:

    pptlNewSrc->x = pptlSrc->x;
    pptlNewSrc->y = pptlSrc->y;

    // Adjust the destination:

    prclNewDest->left = prclDest->left;
    prclNewDest->top  = prclDest->top;

    yBottomSrc = pptlSrc->y + prclDest->bottom - prclDest->top;
    prclNewDest->bottom = min(ppdev->rcl1WindowClip.bottom, yBottomSrc);
    prclNewDest->bottom += prclDest->top - pptlSrc->y;

    xRightSrc = pptlSrc->x + prclDest->right - prclDest->left;
    prclNewDest->right = min(ppdev->rcl1WindowClip.right, xRightSrc);
    prclNewDest->right += prclDest->left - pptlSrc->x;

    DISPDBG((4, "vBankStartBltSrc: Leaving.\n"));
}

/***************************************************************************\
* bBankEnumBltSrc - Continue the bank enumeration for when the screen is
*                   the source.
\***************************************************************************/

BOOL bBankEnumBltSrc(
    PPDEV       ppdev,
    SURFOBJ*    pso,
    POINTL*     pptlSrc,
    RECTL*      prclDest,
    POINTL*     pptlNewSrc,
    RECTL*      prclNewDest)
{
    LONG xLeftSrc;
    LONG xRightSrc;
    LONG yBottomSrc;

    LONG cx = prclDest->right  - prclDest->left;
    LONG cy = prclDest->bottom - prclDest->top;

    LONG dx;
    LONG dy;

    LONG yBottom = min(pptlSrc->y + cy, (LONG) ppdev->cyScreen);
    LONG yNewTop = ppdev->rcl1WindowClip.bottom;

    DISPDBG((4, "bBankEnumBltSrc: Entering.\n"));

    if (ppdev->flBank & BANK_BROKEN_RASTER1)
    {
        ppdev->pfnBankNext(ppdev);
        if (ppdev->rcl1WindowClip.left >= pptlSrc->x + cx)
        {
            if (ppdev->rcl1WindowClip.bottom < yBottom)
                ppdev->pfnBankNext(ppdev);
            else
            {
                // We're done:

                return(FALSE);
            }
        }
    }
    else if (yNewTop < yBottom)
    {
        ppdev->pfnBankControl(ppdev, yNewTop, JustifyTop);
        if (ppdev->rcl1WindowClip.right <= pptlSrc->x)
        {
            ASSERTVGA(ppdev->flBank & BANK_BROKEN_RASTER1, "Weird bounds");
            ppdev->pfnBankNext(ppdev);
        }
    }
    else
    {
        // We're done:

        return(FALSE);
    }

    // Adjust the source:

    pso->pvScan0 = ppdev->pvBitmapStart;

    pptlNewSrc->x = max(ppdev->rcl1WindowClip.left, pptlSrc->x);
    pptlNewSrc->y = yNewTop;

    // Adjust the destination:

    dy = prclDest->top - pptlSrc->y;        // y delta from source to dest

    prclNewDest->top = yNewTop + dy;

    yBottomSrc = pptlSrc->y + cy;
    prclNewDest->bottom = min(ppdev->rcl1WindowClip.bottom, yBottomSrc) + dy;

    dx = prclDest->left - pptlSrc->x;       // x delta from source to dest

    xLeftSrc = pptlSrc->x;
    prclNewDest->left = pptlNewSrc->x + dx;

    xRightSrc = pptlSrc->x + cx;
    prclNewDest->right = min(ppdev->rcl1WindowClip.right, xRightSrc) + dx;

    DISPDBG((4, "bBankEnumBltSrc: Leaving.\n"));

    return(TRUE);
}

/***************************************************************************\
* vBankStartBltDest - Start the bank enumeration for when the screen is
*                     the destination.
\***************************************************************************/

VOID vBankStartBltDest(
    PPDEV       ppdev,
    SURFOBJ*    pso,
    POINTL*     pptlSrc,
    RECTL*      prclDest,
    POINTL*     pptlNewSrc,
    RECTL*      prclNewDest)
{
    LONG iTopScan = max(0, prclDest->top);

    DISPDBG((4, "vBankSTartBltDest: Entering.\n"));

    if (iTopScan >= (LONG) ppdev->cyScreen)
    {
    // In some instances we may be asked to start on a scan below the screen.
    // Since we obviously won't be drawing anything, don't bother mapping in
    // a bank:

        return;
    }

    // Map in the bank:

    if (iTopScan <  ppdev->rcl1WindowClip.top ||
        iTopScan >= ppdev->rcl1WindowClip.bottom)
    {
        ppdev->pfnBankControl(ppdev, iTopScan, JustifyTop);
    }

    if (ppdev->rcl1WindowClip.right <= prclDest->left)
    {
    // We have to watch out for those rare cases where we're starting
    // on a broken raster and we won't be drawing on the first part:

        ASSERTVGA(ppdev->flBank & BANK_BROKEN_RASTER1, "Weird start bounds");
        ppdev->pfnBankNext(ppdev);
    }

    pso->pvScan0 = ppdev->pvBitmapStart;

    // Adjust the destination:

    prclNewDest->left   = prclDest->left;
    prclNewDest->top    = prclDest->top;
    prclNewDest->bottom = min(ppdev->rcl1WindowClip.bottom, prclDest->bottom);
    prclNewDest->right  = min(ppdev->rcl1WindowClip.right,  prclDest->right);

    // Adjust the source if there is one:

    if (pptlSrc != NULL)
        *pptlNewSrc = *pptlSrc;

    DISPDBG((4, "vBankStartBltDest: Leaving.\n"));
}

/***************************************************************************\
* bBankEnumBltDest - Continue the bank enumeration for when the screen is
*                   the destination.
\***************************************************************************/

BOOL bBankEnumBltDest(
    PPDEV       ppdev,
    SURFOBJ*    pso,
    POINTL*     pptlSrc,
    RECTL*      prclDest,
    POINTL*     pptlNewSrc,
    RECTL*      prclNewDest)
{
    LONG yBottom = min(prclDest->bottom, (LONG) ppdev->cyScreen);
    LONG yNewTop = ppdev->rcl1WindowClip.bottom;

    DISPDBG((4, "bBankEnumBltDest: Entering.\n"));

    if (ppdev->flBank & BANK_BROKEN_RASTER1)
    {
        ppdev->pfnBankNext(ppdev);
        if (ppdev->rcl1WindowClip.left >= prclDest->right)
        {
            if (ppdev->rcl1WindowClip.bottom < yBottom)
                ppdev->pfnBankNext(ppdev);
            else
            {
                // We're done:

                return(FALSE);
            }
        }
    }
    else if (yNewTop < yBottom)
    {
        ppdev->pfnBankControl(ppdev, yNewTop, JustifyTop);
        if (ppdev->rcl1WindowClip.right <= prclDest->left)
        {
            ASSERTVGA(ppdev->flBank & BANK_BROKEN_RASTER1, "Weird bounds");
            ppdev->pfnBankNext(ppdev);
        }
    }
    else
    {
        // We're done:

        return(FALSE);
    }

    pso->pvScan0 = ppdev->pvBitmapStart;

    // Adjust the destination:

    prclNewDest->top    = yNewTop;
    prclNewDest->left   = max(ppdev->rcl1WindowClip.left,   prclDest->left);
    prclNewDest->bottom = min(ppdev->rcl1WindowClip.bottom, prclDest->bottom);
    prclNewDest->right  = min(ppdev->rcl1WindowClip.right,  prclDest->right);

    // Adjust the source if there is one:

    if (pptlSrc != NULL)
    {
        pptlNewSrc->x = pptlSrc->x + (prclNewDest->left - prclDest->left);
        pptlNewSrc->y = pptlSrc->y + (prclNewDest->top  - prclDest->top);
    }

    DISPDBG((4, "bBankEnumBltDest: Leaving.\n"));

    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\vga\disp\8bpp\debug.h ===
/***************************************************************************\
* Module Name: debug.h
*
* Commonly used debugging macros.
*
* Copyright (c) 1992-1995 Microsoft Corporation
\***************************************************************************/


#if DBG

VOID
DebugPrint(
    ULONG DebugPrintLevel,
    PCHAR DebugMessage,
    ...
    );

#define DISPDBG(arg) DebugPrint arg
#define RIP(x) { DebugPrint(0, x); EngDebugBreak();}
#define ASSERTVGA(x, y) if (!(x)) RIP (y)

#else

#define DISPDBG(arg)
#define RIP(x)
#define ASSERTVGA(x, y)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\vga\disp\8bpp\brush.c ===
/******************************Module*Header*******************************\
* Module Name: Brush.c
*
* Brush support.
*
* Copyright (c) 1992-1993 Microsoft Corporation
*
\**************************************************************************/

#include "driver.h"

/****************************************************************************
 * DrvRealizeBrush
 ***************************************************************************/

BOOL DrvRealizeBrush(
BRUSHOBJ* pbo,
SURFOBJ*  psoTarget,
SURFOBJ*  psoPattern,
SURFOBJ*  psoMask,
XLATEOBJ* pxlo,
ULONG     iHatch)
{
    RBRUSH* prb;        // Pointer to where realization goes
    ULONG*  pulSrc;     // Temporary pointer
    ULONG*  pulDst;     // Temporary pointer
    BYTE*   pjSrc;
    BYTE*   pjDst;
    ULONG*  pulRBits;   // Points to RBRUSH pattern bits
    BYTE    jBkColor;
    BYTE    jFgColor;
    LONG    i;
    LONG    j;

    PPDEV   ppdev = (PPDEV) psoTarget->dhsurf;

    // For now, we only accelerate patterns using the latches, and we
    // sometimes need offscreen memory as a temporary work space to
    // initialize the latches for 2-color patterns:

    if ((ppdev->fl & (DRIVER_PLANAR_CAPABLE | DRIVER_HAS_OFFSCREEN)) !=
        (DRIVER_PLANAR_CAPABLE | DRIVER_HAS_OFFSCREEN) )
    {
        return(FALSE);
    }

    // We only accelerate 8x8 patterns:

    if (psoPattern->sizlBitmap.cx != 8 || psoPattern->sizlBitmap.cy != 8)
        return(FALSE);

    // We only implement n-color patterns on devices that have multiple
    // or separate read/write banks:

    if (ppdev->vbtPlanarType == VideoBanked1RW)
        return(FALSE);

    // We also only handle 1bpp, 4bpp and 8bpp patterns:

    if (psoPattern->iBitmapFormat > BMF_8BPP)
        return(FALSE);

    // At this point, we're definitely going to realize the brush:

    prb = BRUSHOBJ_pvAllocRbrush(pbo, sizeof(RBRUSH));
    if (prb == NULL)
        return(FALSE);

    pulRBits = &prb->aulPattern[0];

    DISPDBG((2, "\n  RBrush: "));

    // If 8bpp or 4bpp, copy the bitmap to our local buffer:

    if (psoPattern->iBitmapFormat == BMF_1BPP)
    {
        ULONG ulFlippedGlyph;

        DISPDBG((2, "1bpp "));

        // First, convert the bits to our desired format:

        pjSrc  = psoPattern->pvScan0;
        pulDst = pulRBits;
        for (i = 8; i > 0; i--)
        {
            // We want to take the byte with bits 76543210 and convert it
            // to the word 4567012301234567.  The pjGlyphFlipTable gives
            // us 45670123 from 76543210.

            ulFlippedGlyph = (ULONG) ppdev->pjGlyphFlipTable[*pjSrc];
            *pulDst = (ulFlippedGlyph << 8) | ((ulFlippedGlyph & 15) << 4) |
                      (ulFlippedGlyph >> 4);

            pulDst++;
            pjSrc += psoPattern->lDelta;
        }

        // Now initialize the rest of the RBrush fields:

        prb->xBrush    = 0;
        prb->ulBkColor = (pxlo->pulXlate[0] & 0xff);
        prb->ulFgColor = (pxlo->pulXlate[1] & 0xff);

        if (prb->ulFgColor == 0xff && prb->ulBkColor == 0x00)
        {
            prb->fl = RBRUSH_BLACKWHITE;
        }
        else if (prb->ulFgColor == 0x00 && prb->ulBkColor == 0xff)
        {
            // We have to invert the brush:

            prb->fl = RBRUSH_BLACKWHITE;
            for (i = 0; i < 8; i++)
            {
                prb->aulPattern[i] = ~prb->aulPattern[i];
            }
        }
        else
        {
            prb->fl = RBRUSH_2COLOR;
        }

        return(TRUE);
    }
    else if (psoPattern->iBitmapFormat == BMF_8BPP)
    {

        if (pxlo == NULL || pxlo->flXlate & XO_TRIVIAL)
        {
            pulSrc = psoPattern->pvScan0;
            pulDst = pulRBits;

            DISPDBG((2, "8bpp noxlate "));

            // 8bpp no translate case:

            for (i = 4; i > 0; i--)
            {
                *(pulDst)     = *(pulSrc);
                *(pulDst + 1) = *(pulSrc + 1);
                pulSrc = (ULONG*) ((BYTE*) pulSrc + psoPattern->lDelta);

                *(pulDst + 2) = *(pulSrc);
                *(pulDst + 3) = *(pulSrc + 1);

                pulSrc = (ULONG*) ((BYTE*) pulSrc + psoPattern->lDelta);
                pulDst += 4;
            }
        }
        else
        {
            pjSrc = (BYTE*) psoPattern->pvScan0;
            pjDst = (BYTE*) pulRBits;

            DISPDBG((2, "8bpp xlate "));

            // 8bpp translate case:

            for (i = 8; i > 0; i--)
            {
                for (j = 8; j > 0; j--)
                {
                    *pjDst++ = (BYTE) pxlo->pulXlate[*pjSrc++];
                }

                pjSrc += psoPattern->lDelta - 8;
            }
        }
    }
    else
    {
        DISPDBG((2, "4bpp xlate "));

        ASSERTVGA(psoPattern->iBitmapFormat == BMF_4BPP, "Extra case added?");

        // 4bpp case:

        pjSrc = (BYTE*) psoPattern->pvScan0;
        pjDst = (BYTE*) pulRBits;

        for (i = 8; i > 0; i--)
        {
            // Inner loop is repeated only 4 times because each loop handles
            // 2 pixels:

            for (j = 4; j > 0; j--)
            {
                *pjDst++ = (BYTE) pxlo->pulXlate[*pjSrc >> 4];
                *pjDst++ = (BYTE) pxlo->pulXlate[*pjSrc & 15];
                pjSrc++;
            }

            pjSrc += psoPattern->lDelta - 4;
        }
    }

    // We want to check if the 4bpp or 8bpp patterns are actually
    // only two colors:

    if (b2ColorBrush(pulRBits, &jFgColor, &jBkColor))
    {
        DISPDBG((2, "2 color "));

        // ??? We could actually also handle this case even if we have only
        // 1 r/w window in planar format:

        prb->xBrush    = 0;
        prb->ulBkColor = (ULONG) jBkColor;
        prb->ulFgColor = (ULONG) jFgColor;
        prb->fl        = RBRUSH_2COLOR;

        if (jFgColor == 0x00 && jBkColor == 0xff)
        {
            // Monochrome brushes always have to have the '0' bits
            // as black and the '1' bits as white, so we'll have to
            // invert the 1bpp pattern:

            prb->fl = RBRUSH_BLACKWHITE;
            for (i = 0; i < 8; i++)
            {
                prb->aulPattern[i] = ~prb->aulPattern[i];
            }
        }

        return(TRUE);
    }

    prb->fl     = RBRUSH_NCOLOR;
    prb->cy     = 8;
    prb->cyLog2 = 3;

    // xBrush is the brush alignment for the cached brush, and this value
    // will get compared to (pptlBrush->x & 7) to see if the cache brush
    // is correctly aligned with the brush requested.  Since it will never
    // match with -1, the brush will be correctly aligned and placed in
    // the cache (which, of course, is what we want to finish our
    // initialization):

    prb->xBrush = -1;

    // Copy those bitmap bits:

    // See if pattern is really only 4 scans long:

    if (pulRBits[0] == pulRBits[8]  && pulRBits[1] == pulRBits[9]  &&
        pulRBits[2] == pulRBits[10] && pulRBits[3] == pulRBits[11] &&
        pulRBits[4] == pulRBits[12] && pulRBits[5] == pulRBits[13] &&
        pulRBits[6] == pulRBits[14] && pulRBits[7] == pulRBits[15])
    {
        prb->cy     = 4;
        prb->cyLog2 = 2;

        // See if pattern is really only 2 scans long:

        if (pulRBits[0] == pulRBits[4] && pulRBits[1] == pulRBits[5] &&
            pulRBits[2] == pulRBits[6] && pulRBits[3] == pulRBits[7])
        {
            DISPDBG((2, "cy = 2 "));

            prb->cy     = 2;
            prb->cyLog2 = 1;
        }
        else
        {
            DISPDBG((2, "cy = 4 "));
        }
    }

    // See if pattern is really only 4 pels wide:

    pulDst = pulRBits;
    for (i = prb->cy / 2; i > 0; i--)
    {
        if (*(pulDst    ) != *(pulDst + 1) ||
            *(pulDst + 2) != *(pulDst + 3))
            goto done_this_realize_brush_stuff;

        pulDst += 4;
    }

    DISPDBG((2, "4pels wide"));

    prb->fl |= RBRUSH_4PELS_WIDE;

done_this_realize_brush_stuff:

    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\vga\disp\8bpp\bank.c ===
/******************************Module*Header*******************************\
* Module Name: bank.c
*
* Functions to control 256 colour VGA banking.
*
* Copyright (c) 1992 Microsoft Corporation
\**************************************************************************/

#include "driver.h"
#include "limits.h"

VOID vBankErrorTrap(PPDEV, ULONG, BANK_JUST);
VOID vBank2Window(PPDEV, ULONG, BANK_JUST, ULONG);
VOID vBank2Window2RW(PPDEV, ULONG, BANK_JUST, ULONG);
VOID vBank2Window1RW(PPDEV, ULONG, BANK_JUST, ULONG);
VOID vBank1Window2RW(PPDEV, ULONG, BANK_JUST);
VOID vBank1Window(PPDEV, ULONG, BANK_JUST);
VOID vPlanar2Window(PPDEV, ULONG, BANK_JUST, ULONG);
VOID vPlanar2Window2RW(PPDEV, ULONG, BANK_JUST, ULONG);
VOID vPlanar2Window1RW(PPDEV, ULONG, BANK_JUST, ULONG);
VOID vPlanar1Window2RW(PPDEV, ULONG, BANK_JUST);
VOID vPlanar1Window(PPDEV, ULONG, BANK_JUST);

/******************************Public*Routine******************************\
* bInitializeNonPlanar(ppdev, pBankInfo)
*
* Initialize for non-planar mode banking.
*
* NOTE: Allocates ppdev->pbiBankInfo and ppdev->pjJustifyTopBank buffers!
\**************************************************************************/

BOOL bInitializeNonPlanar(PPDEV ppdev, VIDEO_BANK_SELECT* pBankInfo)
{
    LONG  lTotalScans;
    LONG  lTotalBanks;
    ULONG cjBankSize;

    ULONG cjGranularity = pBankInfo->Granularity;
    LONG  lDelta        = pBankInfo->BitmapWidthInBytes;
    ULONG cjBitmapSize  = pBankInfo->BitmapSize;

    ASSERTVGA(cjBitmapSize >= ppdev->cyScreen * lDelta, "Not enough vram");

    // Set up for non-planar banking:

    ppdev->lNextScan         = lDelta;
    ppdev->vbtBankingType    = pBankInfo->BankingType;

    ppdev->pfnBankSwitchCode =
                (PFN) (((BYTE*)pBankInfo) + pBankInfo->CodeOffset);

    // Set all clip rects to invalid; they'll be updated when the first
    // bank is mapped in

    ppdev->rcl1WindowClip.bottom    = -1;
    ppdev->rcl2WindowClip[0].bottom = -1;
    ppdev->rcl2WindowClip[1].bottom = -1;

    // Set up to call the appropriate banking control routines

    switch(pBankInfo->BankingType)
    {
    case VideoBanked1RW:
        ppdev->pfnBankControl        = vBank1Window;
        ppdev->pfnBankControl2Window = vBank2Window1RW;
        break;

    case VideoBanked1R1W:
        ppdev->pfnBankControl        = vBank1Window;
        ppdev->pfnBankControl2Window = vBank2Window;
        break;

    case VideoBanked2RW:
        ppdev->pfnBankControl        = vBank1Window2RW;
        ppdev->pfnBankControl2Window = vBank2Window2RW;

        // Offset from one bank index to next to make two 32k banks
        // appear to be one seamless 64k bank:

        ppdev->ulBank2RWSkip = BANK_SIZE_2RW_WINDOW / cjGranularity;
        break;

    default:
        RIP("Bad BankingType");
        return(FALSE);
    }

    // Set up the bank control tables with clip rects for banks
    // Note: lTotalBanks is generally an overestimate when granularity
    // is less than window size, because we ignore any banks after the
    // first one that includes the last scan line of the bitmap. A bit
    // of memory could be saved by sizing lTotalBanks exactly. Note too,
    // though, that the 2 RW window case may require more entries then,
    // because its windows are shorter, so you'd have to make sure there
    // were enough entries for the 2 RW window case, or recalculate
    // lTotalBanks for the 2 RW case

    lTotalBanks = (cjBitmapSize + cjGranularity - 1) / cjGranularity;
    lTotalScans = cjBitmapSize / lDelta;

    ppdev->cTotalScans = lTotalScans;
    ppdev->pbiBankInfo = (PBANK_INFO) EngAllocMem(FL_ZERO_MEMORY,
                          lTotalBanks * sizeof(BANK_INFO), ALLOC_TAG);
    if (ppdev->pbiBankInfo == NULL)
    {
        DISPDBG((0, "VGA256: Couldn't get memory for bank info"));
        return(FALSE);
    }

    ppdev->pjJustifyTopBank = (BYTE*) EngAllocMem(0, lTotalScans, ALLOC_TAG);
    if (ppdev->pjJustifyTopBank == NULL)
    {
        DISPDBG((0, "VGA256: Couldn't get memory for JustifyTopBank table"));
        return(FALSE);
    }

    // For 2 RW windows, windows are assumed to be 32k in size, otherwise
    // assumed to be 64k:

    if (pBankInfo->BankingType == VideoBanked2RW)
        cjBankSize = BANK_SIZE_2RW_WINDOW;
    else
        cjBankSize = BANK_SIZE_1_WINDOW;

    if ((cjGranularity + lDelta) >= cjBankSize &&
        (cjGranularity % lDelta) != 0)
    {
        // Oh no, we've got broken rasters (where a scan line crosses
        // a bank boundary):

        RIP("Oops, broken rasters not yet handled");
        return(FALSE);
    }
    else
    {
        // We now fill in the scan-to-bank look-up and bank tables:

        LONG        iScan         = 0;
        ULONG       iBank         = 0;
        ULONG       cjScan        = 0;
        ULONG       cjNextBank    = cjGranularity;
        ULONG       cjEndOfBank   = cjBankSize;
        PBANK_INFO  pbiWorking    = ppdev->pbiBankInfo;

        while (TRUE)
        {
            pbiWorking->ulBankOffset         = cjNextBank - cjGranularity;

        // There are no broken rasters, so don't worry about left and right
        // edges:

            pbiWorking->rclBankBounds.left   = LONG_MIN + 1; // +1 to avoid
                                                             // compiler warn
            pbiWorking->rclBankBounds.right  = LONG_MAX;
            pbiWorking->rclBankBounds.top    = iScan;
            pbiWorking->rclBankBounds.bottom = iScan +
                (cjEndOfBank - cjScan) / lDelta;

            // We don't need any more banks if we can see to the end
            // of the bitmap with the current bank:

            if (cjScan + cjBankSize >= cjBitmapSize)
                break;

            while (cjScan < cjNextBank)
            {
                ppdev->pjJustifyTopBank[iScan++] = (BYTE) iBank;
                cjScan += lDelta;
            }

            // Get ready for next bank:

            cjNextBank  += cjGranularity;
            cjEndOfBank += cjGranularity;
            pbiWorking++;
            iBank++;
        }

        // Clean up the last scans:

        ppdev->iLastBank = iBank;
        pbiWorking->rclBankBounds.bottom = lTotalScans;
        while (iScan < lTotalScans)
        {
            ppdev->pjJustifyTopBank[iScan++] = (BYTE) iBank;
        }

        // We've just computed the precise table for JustifyTop; we now
        // compute the scan offset for determining JustifyBottom:

        ASSERTVGA(cjBankSize >= cjGranularity,
               "Device says granularity more than bank size?");

        ppdev->ulJustifyBottomOffset = (cjBankSize - cjGranularity) / lDelta;

        // ulJustifyBottomOffset must be less than the number of scans
        // that fit entirely in any bank less the granularity size; if
        // our width doesn't divide evenly into the granularity, we'll
        // have to adjust the value to account for the first scan not
        // starting at offset 0 in any bank:

        if ((cjGranularity % lDelta) != 0 && ppdev->ulJustifyBottomOffset > 0)
            ppdev->ulJustifyBottomOffset--;
    }

    return(TRUE);
}

/******************************Public*Routine******************************\
* bInitializePlanar(ppdev, pBankInfo)
*
* Initialize for non-planar mode banking.
*
* NOTE: Allocates ppdev->pbiPlanarInfo and ppdev->pjJustifyTopPlanar buffers!
\**************************************************************************/

BOOL bInitializePlanar(PPDEV ppdev, VIDEO_BANK_SELECT* pBankInfo)
{
    LONG  lTotalScans;
    LONG  lTotalBanks;
    ULONG cjBankSize;
    ULONG cjGranularity = pBankInfo->PlanarHCGranularity;

    // Since we're in planar mode, every byte we see actually represents
    // four bytes of video memory:

    LONG  lDelta        = pBankInfo->BitmapWidthInBytes / 4;
    ULONG cjBitmapSize  = pBankInfo->BitmapSize / 4;

    ppdev->fl |= DRIVER_PLANAR_CAPABLE;

    // Set all clip rects to invalid; they'll be updated when the first
    // bank is mapped in

    ppdev->rcl1PlanarClip.bottom    = -1;
    ppdev->rcl2PlanarClip[0].bottom = -1;
    ppdev->rcl2PlanarClip[1].bottom = -1;

    // Set up for planar banking:

    ppdev->pfnPlanarSwitchCode =
                (PFN) (((BYTE*)pBankInfo) + pBankInfo->PlanarHCBankCodeOffset);
    ppdev->pfnPlanarEnable     =
                (PFN) (((BYTE*)pBankInfo) + pBankInfo->PlanarHCEnableCodeOffset);
    ppdev->pfnPlanarDisable     =
                (PFN) (((BYTE*)pBankInfo) + pBankInfo->PlanarHCDisableCodeOffset);

    ppdev->lPlanarNextScan = lDelta;
    ppdev->vbtPlanarType   = pBankInfo->PlanarHCBankingType;

    // Set up to call the appropriate banking control routines

    switch(ppdev->vbtPlanarType)
    {
    case VideoBanked1RW:
        ppdev->pfnPlanarControl  = vPlanar1Window;
        ppdev->pfnPlanarControl2 = vPlanar2Window1RW;
        break;

    case VideoBanked1R1W:
        ppdev->pfnPlanarControl  = vPlanar1Window;
        ppdev->pfnPlanarControl2 = vPlanar2Window;
        break;

    case VideoBanked2RW:
        ppdev->pfnPlanarControl  = vPlanar1Window2RW;
        ppdev->pfnPlanarControl2 = vPlanar2Window2RW;

        // Offset from one bank index to next to make two 32k banks
        // appear to be one seamless 64k bank:

        ppdev->ulPlanar2RWSkip = BANK_SIZE_2RW_WINDOW / cjGranularity;
        break;

    default:
        RIP("Bad BankingType");
        return(FALSE);
    }

    lTotalBanks = (cjBitmapSize + cjGranularity - 1) / cjGranularity;
    lTotalScans = cjBitmapSize / lDelta;

    ppdev->pbiPlanarInfo = (PBANK_INFO) EngAllocMem(FL_ZERO_MEMORY,
                          lTotalBanks * sizeof(BANK_INFO), ALLOC_TAG);
    if (ppdev->pbiPlanarInfo == NULL)
    {
        DISPDBG((0, "VGA256: Couldn't get memory for bank info"));
        return(FALSE);
    }

    ppdev->pjJustifyTopPlanar = (BYTE*) EngAllocMem(0, lTotalScans, ALLOC_TAG);
    if (ppdev->pjJustifyTopPlanar == NULL)
    {
        DISPDBG((0, "VGA256: Couldn't get memory for JustifyTopBank table"));
        return(FALSE);
    }

    // For 2 RW windows, windows are assumed to be 32k in size, otherwise
    // assumed to be 64k:

    if (pBankInfo->BankingType == VideoBanked2RW)
        cjBankSize = BANK_SIZE_2RW_WINDOW;
    else
        cjBankSize = BANK_SIZE_1_WINDOW;

    if ((cjGranularity + lDelta) >= cjBankSize &&
        (cjGranularity % lDelta) != 0)
    {
        // Oh no, we've got broken rasters (where a scan line crosses
        // a bank boundary):

        DISPDBG((0, "Can't handle broken planar rasters"));

        ppdev->fl &= ~DRIVER_PLANAR_CAPABLE;// !!! Temporary, until we handle
        return(TRUE);                       // broken rasters in planar copy
    }
    else
    {
        // We now fill in the scan-to-bank look-up and bank tables:

        LONG        iScan         = 0;
        ULONG       iBank         = 0;
        ULONG       cjScan        = 0;
        ULONG       cjNextBank    = cjGranularity;
        ULONG       cjEndOfBank   = cjBankSize;
        PBANK_INFO  pbiWorking    = ppdev->pbiPlanarInfo;

        while (TRUE)
        {
            pbiWorking->ulBankOffset         = cjNextBank - cjGranularity;

        // There are no broken rasters, so don't worry about left and right
        // edges:

            pbiWorking->rclBankBounds.left   = LONG_MIN + 1; // +1 to avoid
                                                             // compiler warn
            pbiWorking->rclBankBounds.right  = LONG_MAX;
            pbiWorking->rclBankBounds.top    = iScan;
            pbiWorking->rclBankBounds.bottom = iScan +
                (cjEndOfBank - cjScan) / lDelta;

            // We don't need any more banks if we can see to the end
            // of the bitmap with the current bank:

            if (cjScan + cjBankSize >= cjBitmapSize)
                break;

            while (cjScan < cjNextBank)
            {
                ppdev->pjJustifyTopPlanar[iScan++] = (BYTE) iBank;
                cjScan += lDelta;
            }

            // Get ready for next bank:

            cjNextBank  += cjGranularity;
            cjEndOfBank += cjGranularity;
            pbiWorking++;
            iBank++;
        }

        // Clean up the last scans:

        ppdev->iLastPlanar = iBank;
        pbiWorking->rclBankBounds.bottom = lTotalScans;
        while (iScan < lTotalScans)
        {
            ppdev->pjJustifyTopPlanar[iScan++] = (BYTE) iBank;
        }

        // We've just computed the precise table for JustifyTop; we now
        // compute the scan offset for determining JustifyBottom:

        ASSERTVGA(cjBankSize >= cjGranularity,
               "Device says granularity more than bank size?");

        ppdev->ulPlanarBottomOffset = (cjBankSize - cjGranularity) / lDelta;

        // ulPlanarBottomOffset must be less than the number of scans
        // that fit entirely in any bank less the granularity size; if
        // our width doesn't divide evenly into the granularity, we'll
        // have to adjust the value to account for the first scan not
        // starting at offset 0 in any bank:

        if ((cjGranularity % lDelta) != 0 && ppdev->ulPlanarBottomOffset > 0)
            ppdev->ulPlanarBottomOffset--;
    }

    return(TRUE);
}

/******************************Public*Routine******************************\
* bEnableBanking(ppdev)
*
* Set up banking for the current mode
* pdsurf and ppdev are the pointers to the current surface and device
* Relevant fields in the surface are set up for banking
\**************************************************************************/

BOOL bEnableBanking(PPDEV ppdev)
{
    PVIDEO_BANK_SELECT  pBankInfo;
    UINT                ReturnedDataLength;
    VIDEO_BANK_SELECT   TempBankInfo;
    DWORD               status;

    // Make sure we've set to NULL any pointers to buffers that we allocate,
    // so that we can free them in our error path:

    ppdev->pBankInfo          = NULL;
    ppdev->pjJustifyTopBank   = NULL;
    ppdev->pbiBankInfo        = NULL;
    ppdev->pjJustifyTopPlanar = NULL;
    ppdev->pbiPlanarInfo      = NULL;

    // Query the miniport for banking info for this mode.
    //
    // First, figure out how big a buffer we need for the banking info
    // (returned in TempBankInfo->Size).

    if (status = EngDeviceIoControl(ppdev->hDriver,
                         IOCTL_VIDEO_GET_BANK_SELECT_CODE,
                         NULL,                      // input buffer
                         0,
                         (LPVOID) &TempBankInfo,    // output buffer
                         sizeof(VIDEO_BANK_SELECT),
                         &ReturnedDataLength))
    {
        // We expect this call to fail, because we didn't allow any room
        // for the code; we just want to get the required output buffer
        // size.
    }

    // Now, allocate a buffer of the required size and get the banking info.

    pBankInfo = (PVIDEO_BANK_SELECT) EngAllocMem(FL_ZERO_MEMORY,
                    TempBankInfo.Size, ALLOC_TAG);
    if (pBankInfo == NULL)
    {
        DISPDBG((0, "VGA256: Initialization error-couldn't get memory for bank info"));
        goto error;
    }

    // Remember it so we can free it later:

    ppdev->pBankInfo    = pBankInfo;

    if (EngDeviceIoControl(ppdev->hDriver,
                         IOCTL_VIDEO_GET_BANK_SELECT_CODE,
                         NULL,
                         0,
                         (LPVOID) pBankInfo,
                         TempBankInfo.Size,
                         &ReturnedDataLength))
    {
        RIP("Initialization error-GetBankSelectCode, second call");
        goto error;
    }

    // Set up for banking:

    ppdev->ulBitmapSize = pBankInfo->BitmapSize;

    if (!bInitializeNonPlanar(ppdev, pBankInfo))
        goto error;

    if (pBankInfo->BankingFlags & PLANAR_HC)
    {
        ppdev->fl |= DRIVER_PLANAR_CAPABLE;
        if (!bInitializePlanar(ppdev, pBankInfo))
            goto error;
    }

    // Map in scan line 0 for read & write, to put things in a known state:

    ppdev->pfnBankControl(ppdev, 0, JustifyTop);

    return(TRUE);

// Error path:

error:
    vDisableBanking(ppdev);

    return(FALSE);
}

/******************************Public*Routine******************************\
* vDisableBanking(ppdev)
*
* Disable banking for the current mode
\**************************************************************************/

VOID vDisableBanking(PPDEV ppdev)
{
    EngFreeMem((LPVOID) ppdev->pBankInfo);
    EngFreeMem((LPVOID) ppdev->pjJustifyTopBank);
    EngFreeMem((LPVOID) ppdev->pbiBankInfo);
    EngFreeMem((LPVOID) ppdev->pjJustifyTopPlanar);
    EngFreeMem((LPVOID) ppdev->pbiPlanarInfo);
}

/******************************Private*Routine******************************\
* vBankErrorTrap
*
* Traps calls to bank control functions in non-banked modes
*
\**************************************************************************/

VOID vBankErrorTrap(PPDEV ppdev, ULONG lScan, BANK_JUST ulJustification)
{
    DISPDBG((0,"Call to bank manager in unbanked mode"));
}

/******************************Private*Routine******************************\
* vBank1Window
*
* Maps in a single R/W window that allows access to lScan. Applies to both
* 1 RW window and 1R1W window banking schemes.
*
\**************************************************************************/

VOID vBank1Window(PPDEV ppdev, ULONG lScan, BANK_JUST ulJustification)
{
             ULONG      ulBank;
             PBANK_INFO pbiWorking;
    volatile ULONG      ulBank0;
    volatile PFN        pBankFn;
             BANK_POSITION BankPosition;
             ULONG      ulReturn;

    // ASM routines that call this may have STD in effect, but the C compiler
    // assumes CLD

    _asm    pushfd
    _asm    cld

    // Set the clip rect for this bank; if it's set to -1, that indicates that
    // a double-window set-up is currently active, so invalidate double-window
    // clip rects and display memory pointers (when double-window is active,
    // single-window is inactive, and vice-versa; a full bank set-up has to be
    // performed to switch between the two)

    if (ppdev->rcl1WindowClip.bottom == -1)
    {
        if (ppdev->flBank & BANK_PLANAR)
        {
            ppdev->flBank &= ~BANK_PLANAR;
            ppdev->pfnPlanarDisable();
        }

        ppdev->rcl2WindowClip[0].bottom = -1;
        ppdev->rcl2WindowClip[1].bottom = -1;
        ppdev->rcl1PlanarClip.bottom    = -1;
        ppdev->rcl2PlanarClip[0].bottom = -1;
        ppdev->rcl2PlanarClip[1].bottom = -1;
    }

    ASSERTVGA(!(ppdev->flBank & BANK_PLANAR), "Shouldn't be in planar mode");

    // Find the bank containing the scan line with the desired justification:

    {
        register LONG lSearchScan = (LONG)lScan;
        if (ulJustification == JustifyBottom)
        {
            lSearchScan -= ppdev->ulJustifyBottomOffset;
            if (lSearchScan <= 0)
                lSearchScan = 0;
        }

        ulBank     = (ULONG) ppdev->pjJustifyTopBank[lSearchScan];
        pbiWorking = &ppdev->pbiBankInfo[ulBank];
    }

    ASSERTVGA(pbiWorking->rclBankBounds.top <= (LONG)lScan &&
           pbiWorking->rclBankBounds.bottom > (LONG)lScan,
           "Oops, scan not in bank");

    ppdev->rcl1WindowClip = pbiWorking->rclBankBounds;

    // Shift the bitmap start address so that the desired bank aligns with
    // the banking window. The source and destination are set only so 1 R/W
    // aligned blits will work without having to be specifically aware of
    // the adapter type (some of the same code works with 1R/1W adapters too).

    ppdev->pvBitmapStart = (PVOID) (ppdev->pjScreen - pbiWorking->ulBankOffset);
    ppdev->pvBitmapStart2Window[0] = ppdev->pvBitmapStart;
    ppdev->pvBitmapStart2Window[1] = ppdev->pvBitmapStart;

    ppdev->flBank &= ~BANK_BROKEN_RASTERS;              // No broken rasters

    // Map in the desired bank for both read and write
    // This is so convoluted to avoid problems with wiping out registers C
    // thinks it's still using; the values are tranferred to volatiles, and
    // then to registers

    ulBank0 = ulBank;

    if (ppdev->BankIoctlSupported) {

        static ulBankOld = -1;

        if (ulBank0 != ulBankOld) {

            ulBankOld = ulBank0;

            BankPosition.ReadBankPosition = ulBank0;
            BankPosition.WriteBankPosition = ulBank0;

            EngDeviceIoControl(ppdev->hDriver,
                               IOCTL_VIDEO_SET_BANK_POSITION,
                               &BankPosition,
                               sizeof(BANK_POSITION),
                               NULL,
                               0,
                               &ulReturn);
        }

    } else {

        pBankFn = ppdev->pfnBankSwitchCode;

        _asm mov eax,ulBank0;
        _asm mov edx,eax;
        _asm call pBankFn;    // actually switch the banks
    }

    _asm popfd
}

/******************************Private*Routine******************************\
* vBank1Window2RW
*
* Maps in two 32K RW windows so that they form a single 64K R/W window that
* allows access to lScan. Applies only to 2 RW window schemes.
*
\**************************************************************************/

VOID vBank1Window2RW(PPDEV ppdev, ULONG lScan, BANK_JUST ulJustification)
{
             ULONG      ulBank0;
             ULONG      ulBank1;
    volatile PFN        pBankFn;

    // ASM routines that call this may have STD in effect, but the C compiler
    // assumes CLD

    _asm    pushfd
    _asm    cld

    // Set the clip rect for this bank; if it's set to -1, that indicates that
    // a double-window set-up is currently active, so invalidate double-window
    // clip rects and display memory pointers (when double-window is active,
    // single-window is inactive, and vice-versa; a full bank set-up has to be
    // performed to switch between the two)

    if (ppdev->rcl1WindowClip.bottom == -1)
    {
        if (ppdev->flBank & BANK_PLANAR)
        {
            ppdev->flBank &= ~BANK_PLANAR;
            ppdev->pfnPlanarDisable();
        }

        ppdev->rcl2WindowClip[0].bottom = -1;
        ppdev->rcl2WindowClip[1].bottom = -1;
        ppdev->rcl1PlanarClip.bottom    = -1;
        ppdev->rcl2PlanarClip[0].bottom = -1;
        ppdev->rcl2PlanarClip[1].bottom = -1;
    }

    ASSERTVGA(!(ppdev->flBank & BANK_PLANAR), "Shouldn't be in planar mode");

    // Find the bank containing the scan line with the desired justification:

    if (ulJustification == JustifyTop)
    {
        ulBank0 = ppdev->pjJustifyTopBank[lScan];
        ulBank1 = ulBank0 + ppdev->ulBank2RWSkip;
        if (ulBank1 >= ppdev->iLastBank)
        {
            ulBank1 = ppdev->iLastBank;
            ulBank0 = ulBank1 - ppdev->ulBank2RWSkip;
        }
    }
    else
    {
        lScan -= ppdev->ulJustifyBottomOffset;
        if ((LONG)lScan <= 0)
            lScan = 0;

        ulBank1 = ppdev->pjJustifyTopBank[lScan];
        ulBank0 = ulBank1 - ppdev->ulBank2RWSkip;
        if ((LONG) ulBank0 < 0)
        {
            ulBank0 = 0;
            ulBank1 = ppdev->ulBank2RWSkip;
        }
    }

    ppdev->rcl1WindowClip.left   = ppdev->pbiBankInfo[ulBank0].rclBankBounds.left;
    ppdev->rcl1WindowClip.top    = ppdev->pbiBankInfo[ulBank0].rclBankBounds.top;
    ppdev->rcl1WindowClip.bottom = ppdev->pbiBankInfo[ulBank1].rclBankBounds.bottom;
    ppdev->rcl1WindowClip.right  = ppdev->pbiBankInfo[ulBank1].rclBankBounds.right;

    // Shift the bitmap start address so that the desired bank aligns with
    // the banking window. The source and destination are set only so 1 R/W
    // aligned blits will work without having to be specifically aware of
    // the adapter type (some of the same code works with 1R/1W adapters too).

    ppdev->pvBitmapStart = (PVOID) ((BYTE*)ppdev->pjScreen
                         - ppdev->pbiBankInfo[ulBank0].ulBankOffset);

    ppdev->pvBitmapStart2Window[0] = ppdev->pvBitmapStart;
    ppdev->pvBitmapStart2Window[1] = ppdev->pvBitmapStart;

    ppdev->flBank &= ~BANK_BROKEN_RASTERS;              // No broken rasters

    // Map in the desired bank for both read and write; this is accomplished
    // by mapping in the desired 32K bank, followed by the next 32K bank.
    // This is so convoluted to avoid problems with wiping out registers C
    // thinks it's still using; the values are tranferred to volatiles, and
    // then to registers

    pBankFn = ppdev->pfnBankSwitchCode;

    _asm mov eax,ulBank0;
    _asm mov edx,ulBank1;
    _asm call pBankFn;    // actually switch the banks

    _asm popfd;
}

/******************************Private*Routine******************************\
* vBank2Window
*
* Maps in one of two windows, either the source window (window 0) or the dest
* window (window 1), to allows access to lScan. Applies to 1R1W window
* banking scheme; should never be called for 1 RW window schemes, because
* there's only one window in that case.
*
\**************************************************************************/

VOID vBank2Window(
    PPDEV       ppdev,
    ULONG       lScan,
    BANK_JUST   ulJustification,
    ULONG       ulWindowToMap)
{
             ULONG       ulBank;
             PBANK_INFO  pbiWorking;
    volatile ULONG       ulBank0;
    volatile ULONG       ulBank1;
    volatile PFN         pBankFn;

    // ASM routines that call this may have STD in effect, but the C compiler
    // assumes CLD

    _asm    pushfd
    _asm    cld

    // Find the bank containing the scan line with the desired justification:

    if (ulJustification == JustifyBottom)
    {
        lScan -= ppdev->ulJustifyBottomOffset;
        if ((LONG)lScan <= 0)
            lScan = 0;
    }

    ulBank     = (ULONG) ppdev->pjJustifyTopBank[lScan];
    pbiWorking = &ppdev->pbiBankInfo[ulBank];

    // Set the clip rect for this bank; if it's set to -1, that indicates that
    // a single-window set-up is currently active, so invalidate single-window
    // clip rects and display memory pointers (when double-window is active,
    // single-window is inactive, and vice-versa; a full bank set-up has to be
    // performed to switch between the two)

    if (ppdev->rcl2WindowClip[ulWindowToMap].bottom == -1)
    {
        ULONG ulOtherWindow = ulWindowToMap ^ 1;

        if (ppdev->flBank & BANK_PLANAR)
        {
            ppdev->flBank &= ~BANK_PLANAR;
            ppdev->pfnPlanarDisable();
        }

        ppdev->rcl1WindowClip.bottom    = -1;
        ppdev->rcl1PlanarClip.bottom    = -1;
        ppdev->rcl2PlanarClip[0].bottom = -1;
        ppdev->rcl2PlanarClip[1].bottom = -1;

        // Neither of the 2 window windows was active, so we have to set up the
        // variables for the other bank (the one other than the one we were
        // called to set) as well, to make it valid. The other bank is set to
        // the same state as the bank we were called to set

        ppdev->rcl2WindowClip[ulOtherWindow]       = pbiWorking->rclBankBounds;
        ppdev->ulWindowBank[ulOtherWindow]         = ulBank;
        ppdev->pvBitmapStart2Window[ulOtherWindow] =
                (PVOID) ((BYTE*)ppdev->pjScreen - pbiWorking->ulBankOffset);
    }

    ASSERTVGA(!(ppdev->flBank & BANK_PLANAR), "Shouldn't be in planar mode");

    ppdev->rcl2WindowClip[ulWindowToMap] = pbiWorking->rclBankBounds;

    // Shift the bitmap start address so that the desired bank aligns with the
    // banking window

    ppdev->pvBitmapStart2Window[ulWindowToMap] =
            (PVOID) ((UCHAR *)ppdev->pjScreen - pbiWorking->ulBankOffset);

    // Map in the desired bank; also map in the other bank to whatever its
    // current state is

    ppdev->ulWindowBank[ulWindowToMap] = ulBank;

    ppdev->flBank &= ~BANK_BROKEN_RASTERS;              // No broken rasters

    // Set both banks at once, because we may have just initialized the other
    // bank, and because this way the bank switch code doesn't have to do a
    // read before write to obtain the state of the other bank.
    // This is so convoluted to avoid problems with wiping out registers C
    // thinks it's still using; the values are tranferred to volatiles, and
    // then to registers


    ulBank0 = ppdev->ulWindowBank[0];
    ulBank1 = ppdev->ulWindowBank[1];
    pBankFn = ppdev->pfnBankSwitchCode;

    _asm mov eax,ulBank0;
    _asm mov edx,ulBank1;
    _asm call pBankFn;    // actually switch the banks

    _asm popfd;
}

/******************************Private*Routine******************************\
* vBank2Window1RW
*
* Maps in the one window in 1R/W case.  Does exactly the same thing as the
* one window case, because there's only one window, but has to be a separate
* entry point because of the extra parameter (because we're using STDCALL).
\**************************************************************************/

VOID vBank2Window1RW(PPDEV ppdev, ULONG lScan,
    BANK_JUST ulJustification, ULONG ulWindowToMap)
{
    vBank1Window(ppdev, lScan, ulJustification);
}

/******************************Private*Routine******************************\
* vBank2Window2RW
*
* Maps in one of two windows, either the source window (window 0) or the dest
* window (window 1), to allows access to lScan. Applies to 2RW window
* banking scheme; should never be called for 1 RW window schemes, because
* there's only one window in that case.
\**************************************************************************/

VOID vBank2Window2RW(
    PPDEV       ppdev,
    ULONG       lScan,
    BANK_JUST   ulJustification,
    ULONG       ulWindowToMap)
{
             ULONG      ulBank;
             PBANK_INFO pbiWorking;
    volatile ULONG      ulBank0;
    volatile ULONG      ulBank1;
    volatile PFN        pBankFn;

    // ASM routines that call this may have STD in effect, but the C compiler
    // assumes CLD

    _asm    pushfd
    _asm    cld

    // Find the bank containing the scan line with the desired justification:

    if (ulJustification == JustifyBottom)
    {
        lScan -= ppdev->ulJustifyBottomOffset;
        if ((LONG)lScan <= 0)
            lScan = 0;
    }

    ulBank     = (ULONG) ppdev->pjJustifyTopBank[lScan];
    pbiWorking = &ppdev->pbiBankInfo[ulBank];

    // Set the clip rect for this bank; if it's set to -1, that indicates that
    // a single-window set-up is currently active, so invalidate single-window
    // clip rects and display memory pointers (when double-window is active,
    // single-window is inactive, and vice-versa; a full bank set-up has to be
    // performed to switch between the two)

    if (ppdev->rcl2WindowClip[ulWindowToMap].bottom == -1)
    {
        if (ppdev->flBank & BANK_PLANAR)
        {
            ppdev->flBank &= ~BANK_PLANAR;
            ppdev->pfnPlanarDisable();
        }

        ppdev->rcl1WindowClip.bottom    = -1;
        ppdev->rcl1PlanarClip.bottom    = -1;
        ppdev->rcl2PlanarClip[0].bottom = -1;
        ppdev->rcl2PlanarClip[1].bottom = -1;

        // Neither of the 2 window windows was active, so we have to set up the
        // variables for the other bank (the one other than the one we were
        // called to set) as well, to make it valid. The other bank is set to
        // the same state as the bank we were called to set

        ppdev->rcl2WindowClip[ulWindowToMap^1] = pbiWorking->rclBankBounds;
        if (ulWindowToMap == 1)
        {
            ppdev->pvBitmapStart2Window[0] =
                (PVOID) ((BYTE*)ppdev->pjScreen - pbiWorking->ulBankOffset);
        }
        else
        {
            ppdev->pvBitmapStart2Window[1] =
                (PVOID) ((UCHAR *)ppdev->pjScreen - pbiWorking->ulBankOffset +
                BANK_SIZE_2RW_WINDOW);
        }
        ppdev->ulWindowBank[ulWindowToMap^1] = ulBank;
    }

    ASSERTVGA(!(ppdev->flBank & BANK_PLANAR), "Shouldn't be in planar mode");

    ppdev->rcl2WindowClip[ulWindowToMap] = pbiWorking->rclBankBounds;

    // Shift the bitmap start address so that the desired bank aligns with the
    // banking window

    if (ulWindowToMap == 0)
    {
        ppdev->pvBitmapStart2Window[0] =
            (PVOID) ((UCHAR *)ppdev->pjScreen - pbiWorking->ulBankOffset);
    }
    else
    {
        ppdev->pvBitmapStart2Window[1] =
            (PVOID) ((UCHAR *)ppdev->pjScreen - pbiWorking->ulBankOffset +
            BANK_SIZE_2RW_WINDOW);
    }

    ppdev->flBank &= ~BANK_BROKEN_RASTERS;              // No broken rasters

    // Map in the desired bank; also map in the other bank to whatever its
    // current state is

    ppdev->ulWindowBank[ulWindowToMap] = ulBank;

    // Set both banks at once, because we may have just initialized the other
    // bank, and because this way the bank switch code doesn't have to do a
    // read before write to obtain the state of the other bank.
    // This is so convoluted to avoid problems with wiping out registers C
    // thinks it's still using; the values are tranferred to volatiles, and
    // then to registers

    ulBank0 = ppdev->ulWindowBank[0];
    ulBank1 = ppdev->ulWindowBank[1];
    pBankFn = ppdev->pfnBankSwitchCode;
    _asm mov eax,ulBank0;
    _asm mov edx,ulBank1;
    _asm call pBankFn;    // actually switch the banks

    _asm popfd;
}

/******************************Private*Routine******************************\
* vPlanar1Window
*
* Maps in a single R/W window that allows access to lScan. Applies to both
* 1 RW window and 1R1W window banking schemes.
\**************************************************************************/

VOID vPlanar1Window(PPDEV ppdev, ULONG lScan, BANK_JUST ulJustification)
{
             ULONG      ulBank;
             PBANK_INFO pbiWorking;
    volatile ULONG      ulBank0;
    volatile PFN        pBankFn;

    // ASM routines that call this may have STD in effect, but the C compiler
    // assumes CLD

    _asm    pushfd
    _asm    cld

    // Set the clip rect for this bank; if it's set to -1, that indicates that
    // a double-window set-up is currently active, so invalidate double-window
    // clip rects and display memory pointers (when double-window is active,
    // single-window is inactive, and vice-versa; a full bank set-up has to be
    // performed to switch between the two)

    if (ppdev->rcl1PlanarClip.bottom == -1)
    {
        if (!(ppdev->flBank & BANK_PLANAR))
        {
            ppdev->flBank |= BANK_PLANAR;
            ppdev->pfnPlanarEnable();
        }

        ppdev->rcl1WindowClip.bottom    = -1;
        ppdev->rcl2WindowClip[0].bottom = -1;
        ppdev->rcl2WindowClip[1].bottom = -1;
        ppdev->rcl2PlanarClip[0].bottom = -1;
        ppdev->rcl2PlanarClip[1].bottom = -1;
    }

    ASSERTVGA(ppdev->flBank & BANK_PLANAR, "Should be in planar mode");

    // Find the bank containing the scan line with the desired justification:

    if (ulJustification == JustifyBottom)
    {
        lScan -= ppdev->ulPlanarBottomOffset;
        if ((LONG)lScan <= 0)
            lScan = 0;
    }

    ulBank     = (ULONG) ppdev->pjJustifyTopPlanar[lScan];
    pbiWorking = &ppdev->pbiPlanarInfo[ulBank];

    ppdev->rcl1PlanarClip = pbiWorking->rclBankBounds;

    // Shift the bitmap start address so that the desired bank aligns with
    // the banking window. The source and destination are set only so 1 R/W
    // aligned blits will work without having to be specifically aware of
    // the adapter type (some of the same code works with 1R/1W adapters too).

    ppdev->pvBitmapStart = (PVOID) (ppdev->pjScreen - pbiWorking->ulBankOffset);
    ppdev->pvBitmapStart2Window[0] = ppdev->pvBitmapStart;
    ppdev->pvBitmapStart2Window[1] = ppdev->pvBitmapStart;

    ppdev->flBank &= ~BANK_BROKEN_RASTERS;              // No broken rasters

    // Map in the desired bank for both read and write
    // This is so convoluted to avoid problems with wiping out registers C
    // thinks it's still using; the values are tranferred to volatiles, and
    // then to registers

    ulBank0 = ulBank;
    pBankFn = ppdev->pfnPlanarSwitchCode;

    _asm mov eax,ulBank0;
    _asm mov edx,eax;

    _asm call pBankFn;    // actually switch the banks

    _asm popfd
}

/******************************Private*Routine******************************\
* vPlanar1Window2RW
*
* Maps in two 32K RW windows so that they form a single 64K R/W window that
* allows access to lScan. Applies only to 2 RW window schemes.
*
\**************************************************************************/

VOID vPlanar1Window2RW(PPDEV ppdev, ULONG lScan, BANK_JUST ulJustification)
{
             ULONG      ulBank0;
             ULONG      ulBank1;
    volatile PFN        pBankFn;

    // ASM routines that call this may have STD in effect, but the C compiler
    // assumes CLD

    _asm    pushfd
    _asm    cld

    // Set the clip rect for this bank; if it's set to -1, that indicates that
    // a double-window set-up is currently active, so invalidate double-window
    // clip rects and display memory pointers (when double-window is active,
    // single-window is inactive, and vice-versa; a full bank set-up has to be
    // performed to switch between the two)


    if (ppdev->rcl1PlanarClip.bottom == -1)
    {
        if (!(ppdev->flBank & BANK_PLANAR))
        {
            ppdev->flBank |= BANK_PLANAR;
            ppdev->pfnPlanarEnable();
        }

        ppdev->rcl1WindowClip.bottom    = -1;
        ppdev->rcl2WindowClip[0].bottom = -1;
        ppdev->rcl2WindowClip[1].bottom = -1;
        ppdev->rcl2PlanarClip[0].bottom = -1;
        ppdev->rcl2PlanarClip[1].bottom = -1;
    }

    ASSERTVGA(ppdev->flBank & BANK_PLANAR, "Should be in planar mode");

    // Find the bank containing the scan line with the desired justification:

    if (ulJustification == JustifyTop)
    {
        ulBank0 = ppdev->pjJustifyTopPlanar[lScan];
        ulBank1 = ulBank0 + ppdev->ulPlanar2RWSkip;
        if (ulBank1 >= ppdev->iLastPlanar)
            ulBank1 = ppdev->iLastPlanar;
    }
    else
    {
        lScan -= ppdev->ulPlanarBottomOffset;
        if ((LONG)lScan <= 0)
            lScan = 0;

        ulBank1 = ppdev->pjJustifyTopPlanar[lScan];
        ulBank0 = ulBank1 - ppdev->ulPlanar2RWSkip;
        if ((LONG) ulBank0 < 0)
            ulBank0 = 0;
    }

    ppdev->rcl1PlanarClip.left   = ppdev->pbiPlanarInfo[ulBank0].rclBankBounds.left;
    ppdev->rcl1PlanarClip.top    = ppdev->pbiPlanarInfo[ulBank0].rclBankBounds.top;
    ppdev->rcl1PlanarClip.bottom = ppdev->pbiPlanarInfo[ulBank1].rclBankBounds.bottom;
    ppdev->rcl1PlanarClip.right  = ppdev->pbiPlanarInfo[ulBank1].rclBankBounds.right;

    // Shift the bitmap start address so that the desired bank aligns with
    // the banking window. The source and destination are set only so 1 R/W
    // aligned blits will work without having to be specifically aware of
    // the adapter type (some of the same code works with 1R/1W adapters too).

    ppdev->pvBitmapStart = (PVOID) ((BYTE*)ppdev->pjScreen
                         - ppdev->pbiPlanarInfo[ulBank0].ulBankOffset);

    ppdev->pvBitmapStart2Window[0] = ppdev->pvBitmapStart;
    ppdev->pvBitmapStart2Window[1] = ppdev->pvBitmapStart;

    ppdev->flBank &= ~BANK_BROKEN_RASTERS;              // No broken rasters

    // Map in the desired bank for both read and write; this is accomplished
    // by mapping in the desired 32K bank, followed by the next 32K bank.
    // This is so convoluted to avoid problems with wiping out registers C
    // thinks it's still using; the values are tranferred to volatiles, and
    // then to registers

    pBankFn = ppdev->pfnPlanarSwitchCode;

    _asm mov eax,ulBank0;
    _asm mov edx,ulBank1;
    _asm call pBankFn;    // actually switch the banks

    _asm popfd;
}

/******************************Private*Routine******************************\
* vPlanar2Window
*
* Maps in one of two windows, either the source window (window 0) or the dest
* window (window 1), to allows access to lScan. Applies to 1R1W window
* banking scheme; should never be called for 1 RW window schemes, because
* there's only one window in that case.
*
\**************************************************************************/

VOID vPlanar2Window(
    PPDEV       ppdev,
    ULONG       lScan,
    BANK_JUST   ulJustification,
    ULONG       ulWindowToMap)
{
             ULONG       ulBank;
             PBANK_INFO  pbiWorking;
    volatile ULONG       ulBank0;
    volatile ULONG       ulBank1;
    volatile PFN         pBankFn;

    // ASM routines that call this may have STD in effect, but the C compiler
    // assumes CLD

    _asm    pushfd
    _asm    cld

    // Find the bank containing the scan line with the desired justification:

    if (ulJustification == JustifyBottom)
    {
        lScan -= ppdev->ulPlanarBottomOffset;
        if ((LONG)lScan <= 0)
            lScan = 0;
    }

    ulBank     = (ULONG) ppdev->pjJustifyTopPlanar[lScan];
    pbiWorking = &ppdev->pbiPlanarInfo[ulBank];

    // Set the clip rect for this bank; if it's set to -1, that indicates that
    // a single-window set-up is currently active, so invalidate single-window
    // clip rects and display memory pointers (when double-window is active,
    // single-window is inactive, and vice-versa; a full bank set-up has to be
    // performed to switch between the two)

    if (ppdev->rcl2PlanarClip[ulWindowToMap].bottom == -1)
    {
        ULONG ulOtherWindow = ulWindowToMap ^ 1;

        if (!(ppdev->flBank & BANK_PLANAR))
        {
            ppdev->flBank |= BANK_PLANAR;
            ppdev->pfnPlanarEnable();
        }

        ppdev->rcl1WindowClip.bottom    = -1;
        ppdev->rcl2WindowClip[0].bottom = -1;
        ppdev->rcl2WindowClip[1].bottom = -1;
        ppdev->rcl1PlanarClip.bottom    = -1;

        // Neither of the 2 window windows was active, so we have to set up the
        // variables for the other bank (the one other than the one we were
        // called to set) as well, to make it valid. The other bank is set to
        // the same state as the bank we were called to set

        ppdev->rcl2PlanarClip[ulOtherWindow]       = pbiWorking->rclBankBounds;
        ppdev->ulWindowBank[ulOtherWindow]         = ulBank;
        ppdev->pvBitmapStart2Window[ulOtherWindow] =
                (PVOID) ((BYTE*)ppdev->pjScreen - pbiWorking->ulBankOffset);
    }

    ASSERTVGA(ppdev->flBank & BANK_PLANAR, "Should be in planar mode");

    ppdev->rcl2PlanarClip[ulWindowToMap] = pbiWorking->rclBankBounds;

    // Shift the bitmap start address so that the desired bank aligns with the
    // banking window

    ppdev->pvBitmapStart2Window[ulWindowToMap] =
            (PVOID) ((UCHAR *)ppdev->pjScreen - pbiWorking->ulBankOffset);

    // Map in the desired bank; also map in the other bank to whatever its
    // current state is

    ppdev->ulWindowBank[ulWindowToMap] = ulBank;

    ppdev->flBank &= ~BANK_BROKEN_RASTERS;              // No broken rasters

    // Set both banks at once, because we may have just initialized the other
    // bank, and because this way the bank switch code doesn't have to do a
    // read before write to obtain the state of the other bank.
    // This is so convoluted to avoid problems with wiping out registers C
    // thinks it's still using; the values are tranferred to volatiles, and
    // then to registers


    ulBank0 = ppdev->ulWindowBank[0];
    ulBank1 = ppdev->ulWindowBank[1];
    pBankFn = ppdev->pfnPlanarSwitchCode;

    _asm mov eax,ulBank0;
    _asm mov edx,ulBank1;
    _asm call pBankFn;    // actually switch the banks

    _asm popfd;
}

/******************************Private*Routine******************************\
* vPlanar2Window1RW
*
* Maps in the one window in 1R/W case.  Does exactly the same thing as the
* one window case, because there's only one window, but has to be a separate
* entry point because of the extra parameter (because we're using STDCALL).
\**************************************************************************/

VOID vPlanar2Window1RW(PPDEV ppdev, ULONG lScan,
    BANK_JUST ulJustification, ULONG ulWindowToMap)
{
    vPlanar1Window(ppdev, lScan, ulJustification);
}

/******************************Private*Routine******************************\
* vPlanar2Window2RW
*
* Maps in one of two windows, either the source window (window 0) or the dest
* window (window 1), to allows access to lScan. Applies to 2RW window
* banking scheme; should never be called for 1 RW window schemes, because
* there's only one window in that case.
\**************************************************************************/

VOID vPlanar2Window2RW(
    PPDEV       ppdev,
    ULONG       lScan,
    BANK_JUST   ulJustification,
    ULONG       ulWindowToMap)
{
             ULONG      ulBank;
             PBANK_INFO pbiWorking;
    volatile ULONG      ulBank0;
    volatile ULONG      ulBank1;
    volatile PFN        pBankFn;

    // ASM routines that call this may have STD in effect, but the C compiler
    // assumes CLD

    _asm    pushfd
    _asm    cld

    // Find the bank containing the scan line with the desired justification:

    if (ulJustification == JustifyBottom)
    {
        lScan -= ppdev->ulPlanarBottomOffset;
        if ((LONG)lScan <= 0)
            lScan = 0;
    }

    ulBank     = (ULONG) ppdev->pjJustifyTopPlanar[lScan];
    pbiWorking = &ppdev->pbiPlanarInfo[ulBank];

    // Set the clip rect for this bank; if it's set to -1, that indicates that
    // a single-window set-up is currently active, so invalidate single-window
    // clip rects and display memory pointers (when double-window is active,
    // single-window is inactive, and vice-versa; a full bank set-up has to be
    // performed to switch between the two)

    if (ppdev->rcl2PlanarClip[ulWindowToMap].bottom == -1)
    {
        if (!(ppdev->flBank & BANK_PLANAR))
        {
            ppdev->flBank |= BANK_PLANAR;
            ppdev->pfnPlanarEnable();
        }

        ppdev->rcl1WindowClip.bottom    = -1;
        ppdev->rcl2WindowClip[0].bottom = -1;
        ppdev->rcl2WindowClip[1].bottom = -1;
        ppdev->rcl1PlanarClip.bottom    = -1;

        // Neither of the 2 window windows was active, so we have to set up the
        // variables for the other bank (the one other than the one we were
        // called to set) as well, to make it valid. The other bank is set to
        // the same state as the bank we were called to set

        ppdev->rcl2PlanarClip[ulWindowToMap^1] = pbiWorking->rclBankBounds;
        if (ulWindowToMap == 1)
        {
            ppdev->pvBitmapStart2Window[0] =
                (PVOID) ((BYTE*)ppdev->pjScreen - pbiWorking->ulBankOffset);
        }
        else
        {
            ppdev->pvBitmapStart2Window[1] =
                (PVOID) ((UCHAR *)ppdev->pjScreen - pbiWorking->ulBankOffset +
                BANK_SIZE_2RW_WINDOW);
        }
        ppdev->ulWindowBank[ulWindowToMap^1] = ulBank;
    }

    ASSERTVGA(ppdev->flBank & BANK_PLANAR, "Should be in planar mode");

    ppdev->rcl2PlanarClip[ulWindowToMap] = pbiWorking->rclBankBounds;

    // Shift the bitmap start address so that the desired bank aligns with the
    // banking window

    if (ulWindowToMap == 0)
    {
        ppdev->pvBitmapStart2Window[0] =
            (PVOID) ((UCHAR *)ppdev->pjScreen - pbiWorking->ulBankOffset);
    }
    else
    {
        ppdev->pvBitmapStart2Window[1] =
            (PVOID) ((UCHAR *)ppdev->pjScreen - pbiWorking->ulBankOffset +
            BANK_SIZE_2RW_WINDOW);
    }

    ppdev->flBank &= ~BANK_BROKEN_RASTERS;              // No broken rasters

    // Map in the desired bank; also map in the other bank to whatever its
    // current state is

    ppdev->ulWindowBank[ulWindowToMap] = ulBank;

    // Set both banks at once, because we may have just initialized the other
    // bank, and because this way the bank switch code doesn't have to do a
    // read before write to obtain the state of the other bank.
    // This is so convoluted to avoid problems with wiping out registers C
    // thinks it's still using; the values are tranferred to volatiles, and
    // then to registers

    ulBank0 = ppdev->ulWindowBank[0];
    ulBank1 = ppdev->ulWindowBank[1];
    pBankFn = ppdev->pfnPlanarSwitchCode;
    _asm mov eax,ulBank0;
    _asm mov edx,ulBank1;
    _asm call pBankFn;    // actually switch the banks

    _asm popfd;
}


/******************************Private*Routine******************************\
* vPlanarDouble
*
* Maps in two windows simultaneously, both the source window (window 0)
* and the dest window (window 1), to allows access to the scans.
* Applies to 1R1W and 2R/w window banking schemes; should never be called
* for 1 RW window schemes, because there's only one window in that case.
*
\**************************************************************************/

VOID vPlanarDouble(
    PPDEV       ppdev,
    LONG        lScan0,          // Source bank
    BANK_JUST   ulJustification0,// Source justification
    LONG        lScan1,          // Destination bank
    BANK_JUST   ulJustification1)// Destination justification
{
             PBANK_INFO  pbi0;
             PBANK_INFO  pbi1;
             ULONG       ulBank0;
             ULONG       ulBank1;
    volatile ULONG       ulBank0_vol;
    volatile ULONG       ulBank1_vol;
    volatile PFN         pBankFn;

    // ASM routines that call this may have STD in effect, but the C compiler
    // assumes CLD

    _asm    pushfd
    _asm    cld

    // Find the banks containing the scan lines with the desired justification:

    if (ulJustification0 == JustifyBottom)
    {
        lScan0 -= ppdev->ulPlanarBottomOffset;
        if (lScan0 <= 0)
            lScan0 = 0;
    }
    if (ulJustification1 == JustifyBottom)
    {
        lScan1 -= ppdev->ulPlanarBottomOffset;
        if (lScan1 <= 0)
            lScan1 = 0;
    }

    ulBank0    = (ULONG) ppdev->pjJustifyTopPlanar[lScan0];
    ulBank1    = (ULONG) ppdev->pjJustifyTopPlanar[lScan1];
    pbi0       = &ppdev->pbiPlanarInfo[ulBank0];
    pbi1       = &ppdev->pbiPlanarInfo[ulBank1];

    // Set the clip rect for this bank; if it's set to -1, that indicates that
    // a single-window set-up is currently active, so invalidate single-window
    // clip rects and display memory pointers (when double-window is active,
    // single-window is inactive, and vice-versa; a full bank set-up has to be
    // performed to switch between the two)

    if (ppdev->rcl2PlanarClip[0].bottom == -1)
    {
        if (!(ppdev->flBank & BANK_PLANAR))
        {
            ppdev->flBank |= BANK_PLANAR;
            ppdev->pfnPlanarEnable();
        }

        ppdev->rcl1WindowClip.bottom    = -1;
        ppdev->rcl2WindowClip[0].bottom = -1;
        ppdev->rcl2WindowClip[1].bottom = -1;
        ppdev->rcl1PlanarClip.bottom    = -1;
    }

    ASSERTVGA(ppdev->flBank & BANK_PLANAR, "Should be in planar mode");

    ppdev->rcl2PlanarClip[0] = pbi0->rclBankBounds;
    ppdev->rcl2PlanarClip[1] = pbi1->rclBankBounds;

    // Shift the bitmap start address so that the desired bank aligns with the
    // banking window

    ppdev->pvBitmapStart2Window[0] =
            (PVOID) ((UCHAR *)ppdev->pjScreen - pbi0->ulBankOffset);
    ppdev->pvBitmapStart2Window[1] =
            (PVOID) ((UCHAR *)ppdev->pjScreen - pbi1->ulBankOffset);

    if (ppdev->vbtPlanarType == VideoBanked2RW)
    {
        ppdev->pvBitmapStart2Window[1] = (PVOID) ((BYTE*)
            ppdev->pvBitmapStart2Window[1] + BANK_SIZE_2RW_WINDOW);
    }

    // Map in the desired banks.

    ppdev->ulWindowBank[0] = ulBank0;
    ppdev->ulWindowBank[1] = ulBank1;

    ppdev->flBank &= ~BANK_BROKEN_RASTERS;              // No broken rasters

    // Set both banks at once.
    // This is so convoluted to avoid problems with wiping out registers C
    // thinks it's still using; the values are tranferred to volatiles, and
    // then to registers

    ulBank0_vol = ulBank0;
    ulBank1_vol = ulBank1;
    pBankFn = ppdev->pfnPlanarSwitchCode;

    _asm mov eax,ulBank0_vol;
    _asm mov edx,ulBank1_vol;
    _asm call pBankFn;    // actually switch the banks

    _asm popfd;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\vga\disp\8bpp\fillpath.c ===
/******************************Module*Header*******************************\
* Module Name: fillpath.c
*
* DrvFillPath
*
* Copyright (c) 1992-1993 Microsoft Corporation
\**************************************************************************/

// LATER identify convex polygons and special-case?
// LATER identify vertical edges and special-case?
// LATER move pointed-to variables into automatics in search loops
// LATER punt to the engine with segmented framebuffer callbacks
// LATER handle complex clipping
// LATER coalesce rectangles

#include "driver.h"
#include "limits.h"


#define     TAKING_ALLOC_STATS      0


#if TAKING_ALLOC_STATS
    ULONG BufferHitInFillpath = 0;
    ULONG BufferMissInFillpath = 0;
#endif

// Describe a single non-horizontal edge of a path to fill.
typedef struct _EDGE {
    PVOID pNext;
    INT iScansLeft;
    INT X;
    INT Y;
    INT iErrorTerm;
    INT iErrorAdjustUp;
    INT iErrorAdjustDown;
    INT iXWhole;
    INT iXDirection;
    INT iWindingDirection;
} EDGE, *PEDGE;

// Maximum number of rects we'll fill per call to
// the fill code
#define MAX_PATH_RECTS  50
#define RECT_BYTES      (MAX_PATH_RECTS * sizeof(RECT))
#define EDGE_BYTES      (GLOBAL_BUFFER_SIZE - RECT_BYTES)
#define MAX_EDGES       (EDGE_BYTES/sizeof(EDGE))

//MIX translation table. Translates a mix 1-16, into an old style Rop 0-255.
extern BYTE gaMix[];

VOID AdvanceAETEdges(EDGE *pAETHead);
VOID XSortAETEdges(EDGE *pAETHead);
VOID MoveNewEdges(EDGE *pGETHead, EDGE *pAETHead, INT iCurrentY);
EDGE * AddEdgeToGET(EDGE *pGETHead, EDGE *pFreeEdge, POINTFIX *ppfxEdgeStart,
        POINTFIX *ppfxEdgeEnd, RECTL *pClipRect);
BOOL ConstructGET(EDGE *pGETHead, EDGE *pFreeEdges, PATHOBJ *ppo,
        PATHDATA *pd, BOOL bMore, RECTL *pClipRect);
void AdjustErrorTerm(INT *pErrorTerm, INT iErrorAdjustUp, INT iErrorAdjustDown,
        INT yJump, INT *pXStart, INT iXDirection);

/******************************Public*Routine******************************\
* DrvFillPath
*
* Fill the specified path with the specified brush and ROP.
*
\**************************************************************************/

BOOL DrvFillPath
(
    SURFOBJ  *pso,
    PATHOBJ  *ppo,
    CLIPOBJ  *pco,
    BRUSHOBJ *pbo,
    POINTL   *pptlBrush,
    MIX       mix,
    FLONG    flOptions
)
{
    PPDEV ppdev;
    BYTE jClipping;     // clipping type
    EDGE *pCurrentEdge;
    EDGE AETHead;       // dummy head/tail node & sentinel for Active Edge Table
    EDGE *pAETHead;     // pointer to AETHead
    EDGE GETHead;       // dummy head/tail node & sentinel for Global Edge Table
    EDGE *pGETHead;     // pointer to GETHead
    EDGE *pFreeEdges;   // pointer to memory free for use to store edges
    ULONG ulNumRects;   // # of rectangles to draw currently in rectangle list
    RECTL *prclRects;   // pointer to start of rectangle draw list
    INT iCurrentY;      // scan line for which we're currently scanning out the
                        //  fill

    RBRUSH_COLOR rbc;    // Realized brush or solid color
    PFNFILL      pfnFill;// Points to appropriate fill routine

    BOOL     bMore;
    PATHDATA pd;
    RECTL    ClipRect;
    RECTL   *pRectBuf;
    EDGE    *pEdgeBuf;

    BOOL    bRetVal=FALSE;      //FALSE until proven TRUE
    BOOL    bMemAlloced=FALSE;  //FALSE until proven TRUE

    // The drawing surface
    ppdev = (PPDEV) pso->dhsurf;

    pRectBuf = (RECTL*) ((BYTE *)ppdev->pvTmpBuf);
    pEdgeBuf = (EDGE*) ((BYTE *)ppdev->pvTmpBuf + RECT_BYTES);

    // Our rectangle fill routines work only in planar mode:
    if (!(ppdev->fl & DRIVER_PLANAR_CAPABLE))
        goto ReturnFalse;

    // Set up the clipping
    if (pco == (CLIPOBJ *) NULL) {
        // No CLIPOBJ provided, so we don't have to worry about clipping
        jClipping = DC_TRIVIAL;
    } else {
        // Use the CLIPOBJ-provided clipping
        jClipping = pco->iDComplexity;
    }

    if (jClipping != DC_TRIVIAL) {
        if (jClipping != DC_RECT) {
            goto ReturnFalse;  // there is complex clipping; let GDI fill the path
        }
        // Clip to the clip rectangle
        ClipRect = pco->rclBounds;
    } else {
        // So the y-clipping code doesn't do any clipping
        // /16 so we don't blow the values out when we scale up to GIQ
        ClipRect.top = (LONG_MIN + 1) / 16; // +1 to avoid compiler problem
        ClipRect.bottom = LONG_MAX / 16;
    }

    // There's nothing to do if there are only one or two points
    if (ppo->cCurves <= 2) {
        goto ReturnTrue;
    }

    // See if we can handle this pattern and ROP

    // We don't handle ROP4s
    if ((mix & 0xFF) != ((mix >> 8) & 0xFF)) {
        goto ReturnFalse;  // it's a ROP4; let GDI fill the path
    }


    // See if we can use the solid brush accelerators, or have to draw a
    // pattern
    switch (mix &= 0xFF)
    {
        case R2_MASKNOTPEN:
        case R2_NOTCOPYPEN:
        case R2_XORPEN:
        case R2_MASKPEN:
        case R2_NOTXORPEN:
        case R2_MERGENOTPEN:
        case R2_COPYPEN:
        case R2_MERGEPEN:
        case R2_NOTMERGEPEN:
        case R2_MASKPENNOT:
        case R2_NOTMASKPEN:
        case R2_MERGEPENNOT:

            // vTrgBlt can only handle solid color fills

            if (pbo->iSolidColor != 0xffffffff)
            {
                rbc.iSolidColor = pbo->iSolidColor;
                pfnFill = vTrgBlt;
            }
            else
            {
                rbc.prb = (RBRUSH*) pbo->pvRbrush;
                if (rbc.prb == NULL)
                {
                    rbc.prb = (RBRUSH*) BRUSHOBJ_pvGetRbrush(pbo);
                    if (rbc.prb == NULL)
                    {
                    // If we haven't realized the brush, punt the call:

                        goto ReturnFalse;
                    }
                }
                if (!(rbc.prb->fl & RBRUSH_BLACKWHITE) &&
                    ((mix & 0xff) != R2_COPYPEN))
                {
                // Only black/white brushes can handle ROPs other
                // than COPYPEN:

                    goto ReturnFalse;
                }

                if (rbc.prb->fl & RBRUSH_NCOLOR)
                    pfnFill = vColorPat;
                else
                    pfnFill = vMonoPat;
            }

            break;

        // Rops that are implicit solid colors

        case R2_NOT:
        case R2_WHITE:
        case R2_BLACK:

            // Brush color parameter doesn't matter for these rops

            pfnFill = vTrgBlt;
            break;

        case R2_NOP:
            goto ReturnTrue;

        default:
            RIP("DrvFillPath: bad mix == 0");
    }

    // Set up working storage in the temporary buffer

    prclRects = pRectBuf;       // storage for list of rectangles to draw

    // Enumerate path here first time to check for special
    // cases (rectangles and monotone polygons)

    // It is too difficult to determine interaction between
    // multiple paths, if there is more than one, skip this

    if (!(bMore = PATHOBJ_bEnum(ppo, &pd))) {

        RECTL *rectangle;
        INT cPoints = pd.count;

        // The count can't be less than three, because we got all the edges
        // in this subpath, and above we checked that there were at least
        // three edges

        // If the count is four, check to see if the polygon is really a
        // rectangle since we can really speed that up. We'll also check for
        // five with the first and last points the same, because under Win 3.1,
        // it was required to close polygons

        if ((cPoints == 4) ||
           ((cPoints == 5) &&
            (pd.pptfx[0].x == pd.pptfx[4].x) &&
            (pd.pptfx[0].y == pd.pptfx[4].y))) {

            rectangle = prclRects;

      /* we have to start somewhere so assume that most
         applications specify the top left point  first

         we want to check that the first two points are
         either vertically or horizontally aligned.  if
         they are then we check that the last point [3]
         is either horizontally or  vertically  aligned,
         and finally that the 3rd point [2] is  aligned
         with both the first point and the  last  point */

#define FIX_SHIFT 4L
#define FIX_MASK (- (1 << FIX_SHIFT))

         rectangle->top   = pd.pptfx[0].y - 1 & FIX_MASK;
         rectangle->left  = pd.pptfx[0].x - 1 & FIX_MASK;
         rectangle->right = pd.pptfx[1].x - 1 & FIX_MASK;

         if (rectangle->left ^ rectangle->right) {
            if (rectangle->top  ^ (pd.pptfx[1].y - 1 & FIX_MASK))
               goto not_rectangle;

            if (rectangle->left ^ (pd.pptfx[3].x - 1 & FIX_MASK))
               goto not_rectangle;

            if (rectangle->right ^ (pd.pptfx[2].x - 1 & FIX_MASK))
               goto not_rectangle;

            rectangle->bottom = pd.pptfx[2].y - 1 & FIX_MASK;
            if (rectangle->bottom ^ (pd.pptfx[3].y - 1 & FIX_MASK))
               goto not_rectangle;
         }
         else {
            if (rectangle->top ^ (pd.pptfx[3].y - 1 & FIX_MASK))
               goto not_rectangle;

            rectangle->bottom = pd.pptfx[1].y - 1 & FIX_MASK;
            if (rectangle->bottom ^ (pd.pptfx[2].y - 1 & FIX_MASK))
               goto not_rectangle;

            rectangle->right = pd.pptfx[2].x - 1 & FIX_MASK;
            if (rectangle->right ^ (pd.pptfx[3].x - 1 & FIX_MASK))
                goto not_rectangle;
         }

      /* if the left is greater than the right then
         swap them so the blt code doesn't wig  out */

         if (rectangle->left > rectangle->right) {
            FIX temp;

            temp = rectangle->left;
            rectangle->left = rectangle->right;
            rectangle->right = temp;
         }
         else {

         /* if left == right there's nothing to draw */

            if (rectangle->left == rectangle->right) {
               goto ReturnTrue;
            }
         }

      /* shift the values to get pixel coordinates */

         rectangle->left  = (rectangle->left  >> FIX_SHIFT) + 1;
         rectangle->right = (rectangle->right >> FIX_SHIFT) + 1;

         if (rectangle->top > rectangle->bottom) {
            FIX temp;

            temp = rectangle->top;
            rectangle->top = rectangle->bottom;
            rectangle->bottom = temp;
         }
         else {
            if (rectangle->top == rectangle->bottom) {
               goto ReturnTrue;
            }
         }

      /* shift the values to get pixel coordinates */

         rectangle->top    = (rectangle->top    >> FIX_SHIFT) + 1;
         rectangle->bottom = (rectangle->bottom >> FIX_SHIFT) + 1;

         // Finally, check for clipping
         if (jClipping == DC_RECT) {
            // Clip to the clip rectangle
            if (!bIntersectRect(rectangle, &ClipRect, rectangle)) {
                // Totally clipped, nothing to do
                goto ReturnTrue;
            }
         }

      /* if we get here then the polygon is a rectangle,
         set count to 1 and  goto  bottom  to  draw  it */

         ulNumRects = 1;
         goto draw_remaining_rectangles;
      }

not_rectangle:

        ;

    }

    // Do we have enough memory for all the edges?
    // LATER does cCurves include closure?
    if (ppo->cCurves > MAX_EDGES) {
#if TAKING_ALLOC_STATS
            BufferMissInFillpath++;
#endif
        //
        // try to allocate enough memory
        //
        pFreeEdges = (EDGE *) EngAllocMem(0, (ppo->cCurves * sizeof(EDGE)), ALLOC_TAG);

        if (pFreeEdges == NULL)
        {
            goto ReturnFalse;  // too many edges; let GDI fill the path
        }
        else
        {
            bMemAlloced = TRUE;
        }
    }
    else {
#if TAKING_ALLOC_STATS
            BufferHitInFillpath++;
#endif
        pFreeEdges = pEdgeBuf; // use buffer on stack (it's big enough)
    }

    // Initialize an empty list of rectangles to fill
    ulNumRects = 0;

    // Enumerate the path edges and build a Global Edge Table (GET) from them
    // in YX-sorted order.
    pGETHead = &GETHead;
    if (!ConstructGET(pGETHead, pFreeEdges, ppo, &pd, bMore, &ClipRect)) {
        goto ReturnFalse;  // outside GDI's 2**27 range
    }

    // Create an empty AET with the head node also a tail sentinel
    pAETHead = &AETHead;
    AETHead.pNext = pAETHead;  // mark that the AET is empty
    AETHead.X = 0x7FFFFFFF;    // this is greater than any valid X value, so
                               //  searches will always terminate

    // Top scan of polygon is the top of the first edge we come to
    iCurrentY = ((EDGE *)GETHead.pNext)->Y;

    // Loop through all the scans in the polygon, adding edges from the GET to
    // the Active Edge Table (AET) as we come to their starts, and scanning out
    // the AET at each scan into a rectangle list. Each time it fills up, the
    // rectangle list is passed to the filling routine, and then once again at
    // the end if any rectangles remain undrawn. We continue so long as there
    // are edges to be scanned out
    while (1) {

        // Advance the edges in the AET one scan, discarding any that have
        // reached the end (if there are any edges in the AET)
        if (AETHead.pNext != pAETHead) {
            AdvanceAETEdges(pAETHead);
        }

        // If the AET is empty, done if the GET is empty, else jump ahead to
        // the next edge in the GET; if the AET isn't empty, re-sort the AET
        if (AETHead.pNext == pAETHead) {
            if (GETHead.pNext == pGETHead) {
                // Done if there are no edges in either the AET or the GET
                break;
            }
            // There are no edges in the AET, so jump ahead to the next edge in
            // the GET
            iCurrentY = ((EDGE *)GETHead.pNext)->Y;
        } else {
            // Re-sort the edges in the AET by X coordinate, if there are at
            // least two edges in the AET (there could be one edge if the
            // balancing edge hasn't yet been added from the GET)
            if (((EDGE *)AETHead.pNext)->pNext != pAETHead) {
                XSortAETEdges(pAETHead);
            }
        }

        // Move any new edges that start on this scan from the GET to the AET;
        // bother calling only if there's at least one edge to add
        if (((EDGE *)GETHead.pNext)->Y == iCurrentY) {
            MoveNewEdges(pGETHead, pAETHead, iCurrentY);
        }

        // Scan the AET into rectangles to fill (there's always at least one
        // edge pair in the AET)
        pCurrentEdge = AETHead.pNext;   // point to the first edge
        do {

            INT iLeftEdge;

            // The left edge of any given edge pair is easy to find; it's just
            // wherever we happen to be currently
            iLeftEdge = pCurrentEdge->X;

            // Find the matching right edge according to the current fill rule
            if ((flOptions & FP_WINDINGMODE) != 0) {

                INT iWindingCount;

                // Do winding fill; scan across until we've found equal numbers
                // of up and down edges
                iWindingCount = pCurrentEdge->iWindingDirection;
                do {
                    pCurrentEdge = pCurrentEdge->pNext;
                    iWindingCount += pCurrentEdge->iWindingDirection;
                } while (iWindingCount != 0);
            } else {
                // Odd-even fill; the next edge is the matching right edge
                pCurrentEdge = pCurrentEdge->pNext;
            }

            // See if the resulting span encompasses at least one pixel, and
            // add it to the list of rectangles to draw if so
            if (iLeftEdge < pCurrentEdge->X) {

                // We've got an edge pair to add to the list to be filled; see
                // if there's room for one more rectangle
                if (ulNumRects >= MAX_PATH_RECTS) {
                    // No more room; draw the rectangles in the list and reset
                    // it to empty

                    (*pfnFill)(ppdev, ulNumRects, prclRects, mix, rbc,
                               pptlBrush);

                    // Reset the list to empty
                    ulNumRects = 0;
                }

                // Add the rectangle representing the current edge pair
                if (jClipping == DC_RECT) {
                    // Clipped
                    // Clip to left
                    prclRects[ulNumRects].left = max(iLeftEdge, ClipRect.left);
                    // Clip to right
                    prclRects[ulNumRects].right =
                            min(pCurrentEdge->X, ClipRect.right);
                    // Draw only if not fully clipped
                    if (prclRects[ulNumRects].left <
                            prclRects[ulNumRects].right) {
                        prclRects[ulNumRects].top = iCurrentY;
                        prclRects[ulNumRects].bottom = iCurrentY+1;
                        ulNumRects++;
                    }
                }
                else
                {
                    // Unclipped
                    prclRects[ulNumRects].top = iCurrentY;
                    prclRects[ulNumRects].bottom = iCurrentY+1;
                    prclRects[ulNumRects].left = iLeftEdge;
                    prclRects[ulNumRects].right = pCurrentEdge->X;
                    ulNumRects++;
                }
            }
        } while ((pCurrentEdge = pCurrentEdge->pNext) != pAETHead);

        iCurrentY++;    // next scan
    }

/* draw the remaining rectangles,  if there are any */

draw_remaining_rectangles:

    if (ulNumRects > 0) {
        (*pfnFill)(ppdev, ulNumRects, prclRects, mix, rbc, pptlBrush);
    }

ReturnTrue:
    bRetVal = TRUE; // done successfully

ReturnFalse:

    // bRetVal is originally false.  If you jumped to ReturnFalse from somewhere,
    // then it will remain false, and be returned.

    if (bMemAlloced)
    {
        //
        // we did allocate memory, so release it
        //
        EngFreeMem (pFreeEdges);
    }

    return(bRetVal);
}

// Advance the edges in the AET to the next scan, dropping any for which we've
// done all scans. Assumes there is at least one edge in the AET.
VOID AdvanceAETEdges(EDGE *pAETHead)
{
    EDGE *pLastEdge, *pCurrentEdge;

    pLastEdge = pAETHead;
    pCurrentEdge = pLastEdge->pNext;
    do {

        // Count down this edge's remaining scans
        if (--pCurrentEdge->iScansLeft == 0) {
            // We've done all scans for this edge; drop this edge from the AET
            pLastEdge->pNext = pCurrentEdge->pNext;
        } else {
            // Advance the edge's X coordinate for a 1-scan Y advance
            // Advance by the minimum amount
            pCurrentEdge->X += pCurrentEdge->iXWhole;
            // Advance the error term and see if we got one extra pixel this
            // time
            pCurrentEdge->iErrorTerm += pCurrentEdge->iErrorAdjustUp;
            if (pCurrentEdge->iErrorTerm >= 0) {
                // The error term turned over, so adjust the error term and
                // advance the extra pixel
                pCurrentEdge->iErrorTerm -= pCurrentEdge->iErrorAdjustDown;
                pCurrentEdge->X += pCurrentEdge->iXDirection;
            }

            pLastEdge = pCurrentEdge;
        }
    } while ((pCurrentEdge = pLastEdge->pNext) != pAETHead);
}

// X-sort the AET, because the edges may have moved around relative to
// one another when we advanced them. We'll use a multipass bubble
// sort, which is actually okay for this application because edges
// rarely move relative to one another, so we usually do just one pass.
// Also, this makes it easy to keep just a singly-linked list. Assumes there
// are at least two edges in the AET.
VOID XSortAETEdges(EDGE *pAETHead)
{
    BOOL bEdgesSwapped;
    EDGE *pLastEdge, *pCurrentEdge, *pNextEdge;

    do {

        bEdgesSwapped = FALSE;
        pLastEdge = pAETHead;
        pCurrentEdge = pLastEdge->pNext;
        pNextEdge = pCurrentEdge->pNext;

        do {
            if (pNextEdge->X < pCurrentEdge->X) {

                // Next edge is to the left of the current edge; swap them
                pLastEdge->pNext = pNextEdge;
                pCurrentEdge->pNext = pNextEdge->pNext;
                pNextEdge->pNext = pCurrentEdge;
                bEdgesSwapped = TRUE;
                pCurrentEdge = pNextEdge;   // continue sorting before the edge
                                            //  we just swapped; it might move
                                            //  farther yet
            }
            pLastEdge = pCurrentEdge;
            pCurrentEdge = pLastEdge->pNext;
        } while ((pNextEdge = pCurrentEdge->pNext) != pAETHead);
    } while (bEdgesSwapped);
}

// Moves all edges that start on the current scan from the GET to the AET in
// X-sorted order. Parameters are pointer to head of GET and pointer to dummy
// edge at head of AET, plus current scan line. Assumes there's at least one
// edge to be moved.
VOID MoveNewEdges(EDGE *pGETHead, EDGE *pAETHead, INT iCurrentY)
{
    EDGE *pCurrentEdge = pAETHead;
    EDGE *pGETNext = pGETHead->pNext;

    do {

        // Scan through the AET until the X-sorted insertion point for this
        // edge is found. We can continue from where the last search left
        // off because the edges in the GET are in X sorted order, as is
        // the AET. The search always terminates because the AET sentinel
        // is greater than any valid X
        while (pGETNext->X > ((EDGE *)pCurrentEdge->pNext)->X) {
            pCurrentEdge = pCurrentEdge->pNext;
        }

        // We've found the insertion point; add the GET edge to the AET, and
        // remove it from the GET
        pGETHead->pNext = pGETNext->pNext;
        pGETNext->pNext = pCurrentEdge->pNext;
        pCurrentEdge->pNext = pGETNext;
        pCurrentEdge = pGETNext;    // continue insertion search for the next
                                    //  GET edge after the edge we just added
        pGETNext = pGETHead->pNext;

    } while (pGETNext->Y == iCurrentY);
}





// Build the Global Edge Table from the path. There must be enough memory in
// the free edge area to hold all edges. The GET is constructed in Y-X order,
// and has a head/tail/sentinel node at pGETHead.

BOOL ConstructGET(
   EDGE     *pGETHead,
   EDGE     *pFreeEdges,
   PATHOBJ  *ppo,
   PATHDATA *pd,
   BOOL      bMore,
   RECTL    *pClipRect)
{
   POINTFIX pfxPathStart;    // point that started the current subpath
   POINTFIX pfxPathPrevious; // point before the current point in a subpath;
                              //  starts the current edge

/* Create an empty GET with the head node also a tail sentinel */

   pGETHead->pNext = pGETHead; // mark that the GET is empty
   pGETHead->Y = 0x7FFFFFFF;   // this is greater than any valid Y value, so
                                //  searches will always terminate

/* PATHOBJ_vEnumStart is implicitly  performed  by  engine
   already and first path  is  enumerated  by  the  caller */

next_subpath:

/* Make sure the PATHDATA is not empty (is this necessary) */

   if (pd->count != 0) {

   /* If first point starts a subpath, remember it as such
      and go on to the next point,   so we can get an edge */

      if (pd->flags & PD_BEGINSUBPATH) {

      /* the first point starts the subpath;   remember it */


         pfxPathStart    = *pd->pptfx; /* the subpath starts here          */
         pfxPathPrevious = *pd->pptfx; /* this points starts the next edge */
         pd->pptfx++;                  /* advance to the next point        */
         pd->count--;                  /* count off this point             */
      }


   /* add edges in PATHDATA to GET,  in Y-X  sorted  order */

      while (pd->count--) {
        if ((pFreeEdges =
            AddEdgeToGET(pGETHead, pFreeEdges, &pfxPathPrevious, pd->pptfx,
                         pClipRect)) == NULL) {
            goto ReturnFalse;
        }
        pfxPathPrevious = *pd->pptfx; /* current point becomes previous   */
        pd->pptfx++;                  /* advance to the next point        */
      }


   /* If last point ends the subpath, insert the edge that
      connects to first point  (is this built in already?) */

      if (pd->flags & PD_ENDSUBPATH) {
         if ((pFreeEdges = AddEdgeToGET(pGETHead, pFreeEdges, &pfxPathPrevious,
                                   &pfxPathStart, pClipRect)) == NULL) {
            goto ReturnFalse;
        }
      }
   }

/* the initial loop conditions preclude a do, while or for */

   if (bMore) {
       bMore = PATHOBJ_bEnum(ppo, pd);
       goto next_subpath;
   }

    return(TRUE);   // done successfully

ReturnFalse:
    return(FALSE);  // failed
}

// Adds the edge described by the two passed-in points to the Global Edge
// Table, if the edge spans at least one pixel vertically.
EDGE * AddEdgeToGET(EDGE *pGETHead, EDGE *pFreeEdge,
        POINTFIX *ppfxEdgeStart, POINTFIX *ppfxEdgeEnd, RECTL *pClipRect)
{
    INT iYStart, iYEnd, iXStart, iXEnd, iYHeight, iXWidth;
    INT yJump, yTop;

    // Set the winding-rule direction of the edge, and put the endpoints in
    // top-to-bottom order
    iYHeight = ppfxEdgeEnd->y - ppfxEdgeStart->y;
    if (iYHeight == 0) {
        return(pFreeEdge);  // zero height; ignore this edge
    } else if (iYHeight >= 0) {
        iXStart = ppfxEdgeStart->x;
        iYStart = ppfxEdgeStart->y;
        iXEnd = ppfxEdgeEnd->x;
        iYEnd = ppfxEdgeEnd->y;
        pFreeEdge->iWindingDirection = 1;
    } else {
        iYHeight = -iYHeight;
        iXEnd = ppfxEdgeStart->x;
        iYEnd = ppfxEdgeStart->y;
        iXStart = ppfxEdgeEnd->x;
        iYStart = ppfxEdgeEnd->y;
        pFreeEdge->iWindingDirection = -1;
    }

    if (iYHeight & 0x80000000) {
        return(NULL);       // too large; outside 2**27 GDI range
    }

    // Set the error term and adjustment factors, all in GIQ coordinates for
    // now
    iXWidth = iXEnd - iXStart;
    if (iXWidth >= 0) {
        // Left to right, so we change X as soon as we move at all
        pFreeEdge->iXDirection = 1;
        pFreeEdge->iErrorTerm = -1;
    } else {
        // Right to left, so we don't change X until we've moved a full GIQ
        // coordinate
        iXWidth = -iXWidth;
        pFreeEdge->iXDirection = -1;
        pFreeEdge->iErrorTerm = -iYHeight;
    }

    if (iXWidth & 0x80000000) {
        return(NULL);       // too large; outside 2**27 GDI range
    }

    if (iXWidth >= iYHeight) {
        // Calculate base run length (minimum distance advanced in X for a 1-
        // scan advance in Y)
        pFreeEdge->iXWhole = iXWidth / iYHeight;
        // Add sign back into base run length if going right to left
        if (pFreeEdge->iXDirection == -1) {
            pFreeEdge->iXWhole = -pFreeEdge->iXWhole;
        }
        pFreeEdge->iErrorAdjustUp = iXWidth % iYHeight;
    } else {
        // Base run length is 0, because line is closer to vertical than
        // horizontal
        pFreeEdge->iXWhole = 0;
        pFreeEdge->iErrorAdjustUp = iXWidth;
    }
    pFreeEdge->iErrorAdjustDown = iYHeight;

    // Calculate the number of pixels spanned by this edge, accounting for
    // clipping

    // Top true pixel scan in GIQ coordinates
    // Shifting to divide and multiply by 16 is okay because the clip rect
    // always contains positive numbers
    yTop = max(pClipRect->top << 4, (iYStart + 15) & ~0x0F);
    pFreeEdge->Y = yTop >> 4;    // initial scan line on which to fill edge

    // Calculate # of scans to actually fill, accounting for clipping
    if ((pFreeEdge->iScansLeft = min(pClipRect->bottom, ((iYEnd + 15) >> 4))
            - pFreeEdge->Y) <= 0) {

        return(pFreeEdge);  // no pixels at all are spanned, so we can
                            // ignore this edge
    }

    // If the edge doesn't start on a pixel scan (that is, it starts at a
    // fractional GIQ coordinate), advance it to the first pixel scan it
    // intersects. Ditto if there's top clipping. Also clip to the bottom if
    // needed

    if (iYStart != yTop) {
        // Jump ahead by the Y distance in GIQ coordinates to the first pixel
        // to draw
        yJump = yTop - iYStart;

        // Advance x the minimum amount for the number of scans traversed
        iXStart += pFreeEdge->iXWhole * yJump;

        AdjustErrorTerm(&pFreeEdge->iErrorTerm, pFreeEdge->iErrorAdjustUp,
                        pFreeEdge->iErrorAdjustDown, yJump, &iXStart,
                        pFreeEdge->iXDirection);
    }
    // Turn the calculations into pixel rather than GIQ calculations

    // Move the X coordinate to the nearest pixel, and adjust the error term
    // accordingly
    // Dividing by 16 with a shift is okay because X is always positive
    pFreeEdge->X = (iXStart + 15) >> 4; // convert from GIQ to pixel coordinates

    // LATER adjust only if needed (if prestepped above)?
    if (pFreeEdge->iXDirection == 1) {
        // Left to right
        pFreeEdge->iErrorTerm -= pFreeEdge->iErrorAdjustDown *
                (((iXStart + 15) & ~0x0F) - iXStart);
    } else {
        // Right to left
        pFreeEdge->iErrorTerm -= pFreeEdge->iErrorAdjustDown *
                ((iXStart - 1) & 0x0F);
    }

    // Scale the error term down 16 times to switch from GIQ to pixels.
    // Shifts work to do the multiplying because these values are always
    // non-negative
    pFreeEdge->iErrorTerm >>= 4;

    // Insert the edge into the GET in YX-sorted order. The search always ends
    // because the GET has a sentinel with a greater-than-possible Y value
    while ((pFreeEdge->Y > ((EDGE *)pGETHead->pNext)->Y) ||
            ((pFreeEdge->Y == ((EDGE *)pGETHead->pNext)->Y) &&
            (pFreeEdge->X > ((EDGE *)pGETHead->pNext)->X))) {
        pGETHead = pGETHead->pNext;
    }

    pFreeEdge->pNext = pGETHead->pNext; // link the edge into the GET
    pGETHead->pNext = pFreeEdge;

    return(++pFreeEdge);    // point to the next edge storage location for next
                            //  time
}

// Adjust the error term for a skip ahead in y. This is in ASM because there's
// a multiply/divide that may involve a larger than 32-bit value.

void AdjustErrorTerm(INT *pErrorTerm, INT iErrorAdjustUp, INT iErrorAdjustDown,
        INT yJump, INT *pXStart, INT iXDirection)
{
#if defined(_X86_) || defined(i386)
    // Adjust the error term up by the number of y coordinates we'll skip
    //*pErrorTerm += iErrorAdjustUp * yJump;
    _asm    mov ebx,pErrorTerm
    _asm    mov eax,iErrorAdjustUp
    _asm    mul yJump
    _asm    add eax,[ebx]
    _asm    adc edx,-1      // the error term starts out negative

    // See if the error term turned over even once while skipping
    //if (*pErrorTerm >= 0) {
    _asm    js  short NoErrorTurnover

        // # of times we'll turn over the error term and step an extra x
        // coordinate while skipping
        // NumAdjustDowns = (*pErrorTerm / iErrorAdjustDown) + 1;
        _asm    div iErrorAdjustDown
        _asm    inc eax
        // Note that EDX is the remainder; (EDX - iErrorAdjustDown) is where
        // the error term ends up ultimately

        // Advance x appropriately for the # of times the error term
        // turned over
        // if (iXDirection == 1) {
        //     *pXStart += NumAdjustDowns;
        // } else {
        //     *pXStart -= NumAdjustDowns;
        // }
        _asm    mov ecx,pXStart
        _asm    cmp iXDirection,1
        _asm    jz  short GoingRight
        _asm    neg eax
GoingRight:
        _asm    add [ecx],eax

        // Adjust the error term down to its proper post-skip value
        // *pErrorTerm -= iErrorAdjustDown * NumAdjustDowns;
        _asm    sub edx,iErrorAdjustDown
        _asm    mov eax,edx     // put into EAX for storing to pErrorTerm next
        // }
NoErrorTurnover:
        _asm    mov [ebx],eax
#else
    INT NumAdjustDowns;

    // Adjust the error term up by the number of y coordinates we'll skip
    *pErrorTerm += iErrorAdjustUp * yJump;

    // See if the error term turned over even once while skipping
    if (*pErrorTerm >= 0) {
        // # of times we'll turn over the error term and step an extra x
        // coordinate while skipping
        NumAdjustDowns = (*pErrorTerm / iErrorAdjustDown) + 1;

        // Advance x appropriately for the # of times the error term
        // turned over
        if (iXDirection == 1) {
            *pXStart += NumAdjustDowns;
        } else {
            *pXStart -= NumAdjustDowns;
        }

        // Adjust the error term down to its proper post-skip value
        *pErrorTerm -= iErrorAdjustDown * NumAdjustDowns;
    }
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\vga\disp\8bpp\driver.h ===
/******************************Module*Header*******************************\
* Module Name: driver.h
*
* Contains prototypes for the 256 colour VGA driver.
*
* NOTE: Must mirror driver.inc!
*
* Copyright (c) 1992-1995 Microsoft Corporation
\**************************************************************************/

#ifndef _DRIVER_
#define _DRIVER_

#include "stdlib.h"
#include "stddef.h"
#include "windows.h"
#include "winddi.h"
#include "devioctl.h"
#include "ntddvdeo.h"

#include "debug.h"

typedef struct _PDEV PDEV, *PPDEV;

//
// A mode requires broken rasters if the stride is a power of 2 and the video ram
// accessed is greater than 64K.
//

#define POW2(stride) (!((stride) & ((stride)-1)))   // TRUE if stride is power of 2
#define BROKEN_RASTERS(stride,cy) ((!(POW2(stride))) && ((stride*cy) > 0x10000))

//
// Sizes assumed for 1-window and 2 RW-window banks.
//

#define BANK_SIZE_1_WINDOW      0x10000L
#define BANK_SIZE_2RW_WINDOW    0x08000L

//
// This will be used by everyone who needs a temporary working buffer
//

#define     PAGE_SIZE           4096
#define     NUM_GLOBAL_PAGES    2
#define     GLOBAL_BUFFER_SIZE  (PAGE_SIZE * NUM_GLOBAL_PAGES)

#define     PELS_PER_DWORD      4


/**************************************************************************\
*
* Specifies desired justification for requestion scan line within bank window
*
\**************************************************************************/

typedef enum {
    JustifyTop = 0,
    JustifyBottom,
} BANK_JUST;

/**************************************************************************\
*
* Specifies which window is to be mapped by two-window bank handler.
*
\**************************************************************************/

typedef enum {
    MapSourceBank = 0,
    MapDestBank,
} BANK_JUST;

/**************************************************************************\
*
* Bank clipping info
*
\**************************************************************************/

typedef struct {
    RECTL rclBankBounds;    // describes pixels addressable in this bank
    ULONG ulBankOffset;     // offset of bank start from bitmap start, if
                            // the bitmap were linearly addressable
} BANK_INFO, *PBANK_INFO;

/**************************************************************************\
*
* Bank control function vector
*
\**************************************************************************/

typedef VOID (*PFN_PlanarEnable)();
typedef VOID (*PFN_PlanarDisable)();
typedef VOID (*PFN_PlanarControl)(PPDEV, ULONG, BANK_JUST);
typedef VOID (*PFN_PlanarControl2)(PPDEV, ULONG, BANK_JUST, ULONG);
typedef VOID (*PFN_PlanarNext)(PPDEV);
typedef VOID (*PFN_PlanarNext2)(PPDEV, ULONG);
typedef VOID (*PFN_BankControl)(PPDEV, ULONG, BANK_JUST);
typedef VOID (*PFN_BankControl2)(PPDEV, ULONG, BANK_JUST, ULONG);
typedef VOID (*PFN_BankNext)(PPDEV);
typedef VOID (*PFN_BankNext2)(PPDEV, ULONG);

/**************************************************************************\
*
* Miscellaneous driver flags
*
\**************************************************************************/

#define DRIVER_PLANAR_CAPABLE       0x01L
#define DRIVER_OFFSCREEN_REFRESHED  0x02L // if not set, don't use offscreen
                                          //   memory for long operations
                                          //   (because the memory won't be
                                          //   refreshed)
#define DRIVER_HAS_OFFSCREEN        0x04L // if not set, can't use any offscreen
                                          //   memory

/**************************************************************************\
*
* Bank status flags
*
\**************************************************************************/

#define BANK_BROKEN_RASTER1     0x01L // If bank1 or read bank has broken raster
#define BANK_BROKEN_RASTER2     0x02L // If bank2 or write bank has broken raster
#define BANK_BROKEN_RASTERS    (BANK_BROKEN_RASTER1 | BANK_BROKEN_RASTER2)
#define BANK_PLANAR             0x04L // If in planar mode

/**************************************************************************\
*
* Structure for maintaining a realized brush:
*
\**************************************************************************/

extern const ULONG gaaulPlanarPat[][8]; // Hatch brushes in preferred format

#define RBRUSH_BLACKWHITE       0x001L  // Black and white brush
#define RBRUSH_2COLOR           0x002L  // 2 color brush
#define RBRUSH_NCOLOR           0x004L  // n color brush
#define RBRUSH_4PELS_WIDE       0x008L  // Brush is 4xN

#define BRUSH_SIZE              64      // An 8x8 8bpp brush needs 64 bytes
#define BRUSH_MAX_CACHE_SCANS   2       // Maximum # of scans used by brush cache

typedef struct _RBRUSH
{
    FLONG       fl;                     // Flags
    LONG        xBrush;                 // Realized brush's x brush origin

    // Info for 2 color brushes:

    ULONG       ulFgColor;              // Foreground color
    ULONG       ulBkColor;              // Background color

    // Info for n color brushes:

    LONG        cy;                     // Height of pattern
    LONG        cyLog2;                 // log2 of the height
    LONG        iCache;                 // Cache entry index.  Zero is not
                                        //  a valid index.

    // Pattern in preferred format:

    ULONG       aulPattern[BRUSH_SIZE / sizeof(ULONG)];

} RBRUSH;                           /* rb */

typedef struct _BRUSHCACHEENTRY
{
    RBRUSH*     prbVerifyRealization;   // We never dereference this pointer
                                        //  to find a brush realization;
                                        //  it is only ever used in a compare
                                        //  to verify that for a realized brush,
                                        //  its off-screen cache entry is still
                                        //  valid.
    LONG        yCache;                 // Scan where entry's bits live
    LONG        ulCache;                // Offset to cache entry from screen
                                        //  start (assuming planar format --
                                        //  if you want the non-planar offset,
                                        //  multiply by 4)

} BRUSHCACHEENTRY;                  /* bce */

/**************************************************************************\
*
* Physical device data structure
*
\**************************************************************************/

// ***********************************************************
// *** MUST match the assembler version in i386\driver.inc ***
// ***********************************************************

typedef struct _PDEV
{
    FLONG       fl;                     // Driver flags (DRIVER_xxx)
    HANDLE      hDriver;                // Handle to \Device\Screen
    HDEV        hdevEng;                // Engine's handle to PDEV
    HSURF       hsurfEng;               // Engine's handle to surface
    HANDLE      hsurfBm;                // Handle to the "punt" surface
    SURFOBJ*    pSurfObj;               // pointer to the locked "punt" surface

    HPALETTE    hpalDefault;            // Handle to the default palette for device.

    PBYTE       pjScreen;               // This is pointer to base screen address
    ULONG       cxScreen;               // Visible screen width
    ULONG       cyScreen;               // Visible screen height
    ULONG       ulMode;                 // Mode the mini-port driver is in.
    LONG        lDeltaScreen;           // Distance from one scan to the next.

    FLONG       flRed;                  // For bitfields device, Red Mask
    FLONG       flGreen;                // For bitfields device, Green Mask
    FLONG       flBlue;                 // For bitfields device, Blue Mask
    ULONG       cPaletteShift;          // number of bits the 8-8-8 palette must
                                        // be shifted by to fit in the hardware
                                        // palette.
    ULONG       ulBitCount;             // # of bits per pel -- can be only 8

    ULONG       ulrm0_wmX;              // Four values (one per byte) to set
                                        //  GC5 to to select read mode 0
                                        //  together with write modes 0-3

    BYTE*       pjGlyphFlipTableBase;   // Base allocated address for flip
                                        //  table; the pointer we use is this
                                        //  pointer rounded up to the nearest
                                        //  256-byte boundary
    BYTE*       pjGlyphFlipTable;       // Pointer to table used to flip glyph
                                        //  bits 0-3 and 4-7
    PALETTEENTRY* pPal;                 // If this is pal managed, this is the pal

    HBITMAP     hbmTmp;                 // Handle to temporary buffer
    SURFOBJ*    psoTmp;                 // Temporary surface

//-----------------------------------------------------------------------------

// DCI stuff:

    BOOL        bSupportDCI;            // True if miniport supports DCI

//-----------------------------------------------------------------------------

// Off screen stuff:

// Brush cache:

    LONG                iCache;         // Index for next brush to be allocated
    LONG                iCacheLast;     // Last valid cache index (so the
                                        //  number of entries in cache is
                                        //  iCacheLast + 1)
    BRUSHCACHEENTRY*    pbceCache;      // Pointer to allocated cache

// Saved screen bits stuff

    RECTL       rclSavedBitsRight;      // right rect of vga memory that's
                                        //  not visible
    RECTL       rclSavedBitsBottom;     // bottom rect of vga memory that's
                                        //  not visible
    BOOL        bBitsSaved;             // TRUE if bits are currently saved

//-----------------------------------------------------------------------------

// Bank manager stuff common between planar and non-planar modes:

    LONG        cTotalScans;            // Number of usable on and off-screen
                                        //  scans
    PVIDEO_BANK_SELECT pBankInfo;       // Bank info for current mode returned
                                        //  by miniport

    FLONG       flBank;                 // Flags for current bank state

    ULONG       ulBitmapSize;           // Length of bitmap if there were no
                                        //  banking, in CPU addressable bytes
    ULONG       ulWindowBank[2];        // Current banks mapped into windows
                                        //  0 & 1
    PVOID       pvBitmapStart;          // Single-window bitmap start pointer
                                        //  (adjusted as necessary to make
                                        //  window map in at proper offset)
    PVOID       pvBitmapStart2Window[2];// Double-window window 0 and 1 bitmap
                                        // start

// Non-planar mode specific bank management control stuff:

    VIDEO_BANK_TYPE  vbtBankingType;        // Type of banking
    PFN              pfnBankSwitchCode;     // Pointer to bank switch code

    LONG             lNextScan;             // Offset to next bank in bytes
    BYTE*            pjJustifyTopBank;      // Pointer to lookup table for
                                            //  converting scans to banks
    BANK_INFO*       pbiBankInfo;           // Array of bank clip info
    ULONG            ulJustifyBottomOffset; // # of scans from top to bottom
                                            //  of bank, for bottom justifying
    ULONG            iLastBank;             // Index of last valid bank in
                                            //  pbiBankInfo table
    ULONG            ulBank2RWSkip;         // Offset from one bank index to next
                                            //  to make two 32K banks appear to be
                                            //  one seamless 64K bank

    PFN_BankControl  pfnBankControl;        // Pointer to bank control function
    PFN_BankControl2 pfnBankControl2Window; // Pointer to double-window bank
                                            //  control function
    PFN_BankNext     pfnBankNext;           // Pointer to next bank function
    PFN_BankNext2    pfnBankNext2Window;    // Pointer to double-window next
                                            //  bank function

    RECTL            rcl1WindowClip;        // Single-window banking clip rect
    RECTL            rcl2WindowClip[2];     // Double-window banking clip rects for
                                            //  windows 0 & 1

// Planar mode specific bank management control stuff:

    VIDEO_BANK_TYPE    vbtPlanarType;       // Type of planar banking

    PFN                pfnPlanarSwitchCode; // Pointer to planar bank switch
                                            //  code

    LONG               lPlanarNextScan;     // Offset to next planar bank in
                                            //  bytes
    BYTE*              pjJustifyTopPlanar;  // Pointer to lookup table for
                                            //  converting scans to banks
    BANK_INFO*         pbiPlanarInfo;       // Array of bank clip info
    ULONG              ulPlanarBottomOffset;// # of scans from top to bottom
                                            //  of bank, for bottom justifying
    ULONG              iLastPlanar;         // Index of last valid bank in
                                            //  pbiPlanarInfo table
    ULONG              ulPlanar2RWSkip;     // Offset from one bank index to next
                                            //  to make two 32K banks appear to be
                                            //  one seamless 64K bank

    PFN_PlanarControl  pfnPlanarControl;    // Planar one window bank control
    PFN_PlanarControl2 pfnPlanarControl2;   // Planar two window bank control

    PFN_PlanarNext     pfnPlanarNext;       // Planar one window next bank
    PFN_PlanarNext2    pfnPlanarNext2;      // Planar two window next bank

    RECTL              rcl1PlanarClip;      // Single-window banking clip rect
    RECTL              rcl2PlanarClip[2];   // Double-window banking clip rects for
                                            //  windows 0 & 1

    PFN_PlanarEnable   pfnPlanarEnable;     // Function to enable planar mode
    PFN_PlanarDisable  pfnPlanarDisable;    // Function to disable planar mode

// Smart bank manager stuff:

    LONG        iLastScan;              // Last scan we want to enumerate
    PVOID       pvSaveScan0;            // Surface's original pvScan0
    RECTL       rclSaveBounds;          // Clip Object's original bounds
    CLIPOBJ*    pcoNull;                // Points to an empty clip object
                                        //  we can use when we're given a
                                        //  NULL CLIPOBJ pointer
    BYTE        iSaveDComplexity;       // Clip Object's original complexity
    BYTE        fjSaveOptions;          // Clip Object's original flags
    BYTE        ajFiller[2];            // Pack dword alignment

    PVOID       pvTmpBuf;               // Ptr to buffer attached to pdev

    BOOLEAN     BankIoctlSupported;     // Does the miniport support ioclt
                                        // based banking?
};                                  /* pdev */

// Palette stuff:

#define MAX_CLUT_SIZE (sizeof(VIDEO_CLUT) + (sizeof(ULONG) * 256))

// Size of the driver extra information in the DEVMODe structure passed
// to and from the display driver

#define DRIVER_EXTRA_SIZE 0

#define DLL_NAME                L"VGA256"       // Name of the DLL in UNICODE
#define STANDARD_DEBUG_PREFIX   "VGA256: "      // All debug output is prefixed
#define ALLOC_TAG               '2gvD'          // 4 byte TAG for memory allocations

// When calling vEnumStart, make sure you set bAll to FALSE.  This will tell
// the Engine to only enumerate rectangles in rclBounds.

// Hooks and Driver function table.

#define HOOKS_BMF8BPP   (HOOK_BITBLT   | HOOK_TEXTOUT    | HOOK_FILLPATH | \
                         HOOK_COPYBITS | HOOK_STROKEPATH | HOOK_PAINT | \
                         HOOK_STRETCHBLT)

#define BB_RECT_LIMIT   50

typedef struct _BBENUM
{
    ULONG   c;
    RECTL   arcl[BB_RECT_LIMIT];
} BBENUM;

#define TO_RECT_LIMIT   20

typedef struct _TEXTENUM
{
    ULONG       c;
    RECTL       arcl[TO_RECT_LIMIT];
} TEXTENUM;

// Initialization stuff:

BOOL bEnableBanking(PPDEV);
VOID vDisableBanking(PPDEV);
BOOL bInitPDEV(PPDEV,PDEVMODEW,GDIINFO *, DEVINFO *);
BOOL bInitSURF(PPDEV,BOOL);
BOOL bInitPaletteInfo(PPDEV, DEVINFO *);
BOOL bInit256ColorPalette(PPDEV);
BOOL bInitPatterns(PPDEV, INT);
VOID vInitBrushCache(PPDEV);
VOID vInitSavedBits(PPDEV);
VOID vDisablePalette(PPDEV);
VOID vDisablePatterns(PPDEV);
VOID vDisableSURF(PPDEV);
VOID vDisableBrushCache(PPDEV);
VOID vResetBrushCache(PPDEV);
VOID vInitRegs(PPDEV);
DWORD getAvailableModes(HANDLE, PVIDEO_MODE_INFORMATION *, DWORD *);

// Smart bank manager stuff:

CLIPOBJ* pcoBankStart(PPDEV, RECTL*, SURFOBJ*, CLIPOBJ*);
BOOL     bBankEnum(PPDEV, SURFOBJ*, CLIPOBJ*);
VOID     vBankStartBltSrc(PPDEV, SURFOBJ*, POINTL*, RECTL*, POINTL*, RECTL*);
BOOL     bBankEnumBltSrc(PPDEV, SURFOBJ*, POINTL*, RECTL*, POINTL*, RECTL*);
VOID     vBankStartBltDest(PPDEV, SURFOBJ*, POINTL*, RECTL*, POINTL*, RECTL*);
BOOL     bBankEnumBltDest(PPDEV, SURFOBJ*, POINTL*, RECTL*, POINTL*, RECTL*);

// Fill routines:

typedef union _RBRUSH_COLOR {
    RBRUSH* prb;
    ULONG   iSolidColor;
} RBRUSH_COLOR;          /* rbc */

typedef VOID (*PFNFILL)(PPDEV, ULONG, PRECTL, MIX, RBRUSH_COLOR, POINTL*);

VOID vTrgBlt(PPDEV, ULONG, PRECTL, MIX, RBRUSH_COLOR, POINTL*);
VOID vMonoPat(PPDEV, ULONG, PRECTL, MIX, RBRUSH_COLOR, POINTL*);
VOID vColorPat(PPDEV, ULONG, PRECTL, MIX, RBRUSH_COLOR, POINTL*);

// Other prototypes:

BOOL b2ColorBrush(ULONG* pvBits, BYTE* pjFgColor, BYTE* pjBkColor);
VOID vPlanarCopyBits(PPDEV, RECTL*, POINTL*);
BOOL bIntersectRect(RECTL*, RECTL*, RECTL*);
VOID vSetWriteModes(ULONG *);
VOID vClearMemDword(PULONG * pulBuffer, ULONG ulDwordCount);
VOID vSrcCopy8bpp(PPDEV, RECTL*, POINTL*, LONG, VOID*);
VOID vFastLine(PPDEV, PATHOBJ*, LONG, ULONG);

#endif // _DRIVER_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\vga\disp\8bpp\paint.c ===
/******************************Module*Header*******************************\
* Module Name: paint.c
*
* Copyright (c) 1992 Microsoft Corporation
\**************************************************************************/

#include "driver.h"

/******************************Public*Data*********************************\
* MIX translation table
*
* Translates a mix 1-16, into an old style Rop 0-255.
*
\**************************************************************************/

BYTE gaMix[] =
{
    0xFF,  // R2_WHITE        - Allow rop = gaMix[mix & 0x0F]
    0x00,  // R2_BLACK
    0x05,  // R2_NOTMERGEPEN
    0x0A,  // R2_MASKNOTPEN
    0x0F,  // R2_NOTCOPYPEN
    0x50,  // R2_MASKPENNOT
    0x55,  // R2_NOT
    0x5A,  // R2_XORPEN
    0x5F,  // R2_NOTMASKPEN
    0xA0,  // R2_MASKPEN
    0xA5,  // R2_NOTXORPEN
    0xAA,  // R2_NOP
    0xAF,  // R2_MERGENOTPEN
    0xF0,  // R2_COPYPEN
    0xF5,  // R2_MERGEPENNOT
    0xFA,  // R2_MERGEPEN
    0xFF   // R2_WHITE
};

/******************************Public*Routine******************************\
* bPaintRgn
*
* Paint the clipping region with the specified color and mode
*
\**************************************************************************/

BOOL bPaintRgn
(
    SURFOBJ      *pso,
    CLIPOBJ      *pco,
    MIX          mix,
    RBRUSH_COLOR rbc,
    POINTL       *pptlBrush,
    PFNFILL      pfnFill
)
{
    BBENUM      bben;
    PPDEV       ppdev;
    ULONG       iRT;
    BOOL        bMore;

// Get the target surface information.

    ppdev = (PPDEV) pso->dhsurf;

    switch(pco->iMode) {

        case TC_RECTANGLES:

            // Rectangular clipping can be handled without enumeration.
            // Note that trivial clipping is not possible, since the clipping
            // region defines the area to fill

            if (pco->iDComplexity == DC_RECT)
            {
                (*pfnFill)(ppdev, 1, &pco->rclBounds, mix, rbc, pptlBrush);

            } else {

                // Enumerate all the rectangles and draw them

                CLIPOBJ_cEnumStart(pco,FALSE,CT_RECTANGLES,CD_ANY,BB_RECT_LIMIT);

                do {
                    bMore = CLIPOBJ_bEnum(pco, sizeof(bben), (PVOID) &bben);

                    (*pfnFill)(ppdev, bben.c, &bben.arcl[0], mix, rbc, pptlBrush);

                } while (bMore);
            }

            return(TRUE);

        default:
            RIP("bPaintRgn: unhandled TC_xxx\n");
            return(FALSE);
    }
}


/**************************************************************************\
* DrvPaint
*
* Paint the clipping region with the specified brush
*
\**************************************************************************/

BOOL DrvPaint
(
    SURFOBJ  *pso,
    CLIPOBJ  *pco,
    BRUSHOBJ *pbo,
    POINTL   *pptlBrush,
    MIX       mix
)
{
    ROP4         rop4;
    RBRUSH_COLOR rbc;
    PFNFILL      pfnFill;

    // If this adapter supports planar mode and the foreground and background
    // mixes are the same,
    // LATER or if there's no brush mask
    // then see if we can use the brush accelerators
    // LATER handle non-planar also

    if ((((PPDEV) pso->dhsurf)->fl & DRIVER_PLANAR_CAPABLE) &&
        ((mix & 0xFF) == ((mix >> 8) & 0xFF))) {

        switch (mix & 0xFF) {
            case 0:
                break;

            // vTrgBlt can only handle solid color fills where if the
            // destination is inverted, no other action is also required

            case R2_MASKNOTPEN:
            case R2_NOTCOPYPEN:
            case R2_XORPEN:
            case R2_MASKPEN:
            case R2_NOTXORPEN:
            case R2_MERGENOTPEN:
            case R2_COPYPEN:
            case R2_MERGEPEN:
            case R2_NOTMERGEPEN:
            case R2_MASKPENNOT:
            case R2_NOTMASKPEN:
            case R2_MERGEPENNOT:

                // vTrgBlt can only handle solid color fills

                if (pbo->iSolidColor != 0xffffffff)
                {
                    rbc.iSolidColor = pbo->iSolidColor;
                    pfnFill = vTrgBlt;
                }
                else
                {
                    rbc.prb = (RBRUSH*) pbo->pvRbrush;
                    if (rbc.prb == NULL)
                    {
                        rbc.prb = (RBRUSH*) BRUSHOBJ_pvGetRbrush(pbo);
                        if (rbc.prb == NULL)
                        {
                        // If we haven't realized the brush, punt the call:

                            break;
                        }
                    }
                    if (!(rbc.prb->fl & RBRUSH_BLACKWHITE) &&
                        ((mix & 0xff) != R2_COPYPEN))
                    {
                    // Only black/white brushes can handle ROPs other
                    // than COPYPEN:

                        break;
                    }

                    if (rbc.prb->fl & RBRUSH_NCOLOR)
                        pfnFill = vColorPat;
                    else
                        pfnFill = vMonoPat;
                }

                return(bPaintRgn(pso, pco, mix, rbc, pptlBrush, pfnFill));

            // Rops that are implicit solid colors

            case R2_NOT:
            case R2_WHITE:
            case R2_BLACK:

                // Brush color parameter doesn't matter for these rops

                // compiler error local variable 'rbc' used without having been initialized
                rbc.prb = NULL;
                rbc.iSolidColor = 0;

                return(bPaintRgn(pso, pco, mix, rbc, NULL, vTrgBlt));

            case R2_NOP:
                return(TRUE);

            default:
                break;
        }
    }

    rop4  = (gaMix[(mix >> 8) & 0x0F]) << 8;
    rop4 |= ((ULONG) gaMix[mix & 0x0F]);

    return(DrvBitBlt(
        pso,
        (SURFOBJ *) NULL,
        (SURFOBJ *) NULL,
        pco,
        (XLATEOBJ *) NULL,
        &pco->rclBounds,
        (POINTL *)  NULL,
        (POINTL *)  NULL,
        pbo,
        pptlBrush,
        rop4));
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\vga\disp\8bpp\palette.c ===
/******************************Module*Header*******************************\
* Module Name: palette.c
*
* Palette support.
*
* Copyright (c) 1992 Microsoft Corporation
\**************************************************************************/

#include "driver.h"

// Global Table defining the 20 Window Default Colors.  For 256 color
// palettes the first 10 must be put at the beginning of the palette
// and the last 10 at the end of the palette.

const PALETTEENTRY BASEPALETTE[20] =
{
    { 0,   0,   0,   0 },       // 0
    { 0x80,0,   0,   0 },       // 1
    { 0,   0x80,0,   0 },       // 2
    { 0x80,0x80,0,   0 },       // 3
    { 0,   0,   0x80,0 },       // 4
    { 0x80,0,   0x80,0 },       // 5
    { 0,   0x80,0x80,0 },       // 6
    { 0xC0,0xC0,0xC0,0 },       // 7
    { 192, 220, 192, 0 },       // 8
    { 166, 202, 240, 0 },       // 9
    { 255, 251, 240, 0 },       // 10
    { 160, 160, 164, 0 },       // 11
    { 0x80,0x80,0x80,0 },       // 12
    { 0xFF,0,   0   ,0 },       // 13
    { 0,   0xFF,0   ,0 },       // 14
    { 0xFF,0xFF,0   ,0 },       // 15
    { 0   ,0,   0xFF,0 },       // 16
    { 0xFF,0,   0xFF,0 },       // 17
    { 0,   0xFF,0xFF,0 },       // 18
    { 0xFF,0xFF,0xFF,0 },       // 19
};

BOOL bInitDefaultPalette(PPDEV ppdev, DEVINFO *pDevInfo);

/******************************Public*Routine******************************\
* bInitPaletteInfo
*
* Initializes the palette information for this PDEV.
*
* Called by DrvEnablePDEV.
*
\**************************************************************************/

BOOL bInitPaletteInfo(PPDEV ppdev, DEVINFO *pDevInfo)
{
    if (!bInitDefaultPalette(ppdev, pDevInfo))
        return(FALSE);

    return(TRUE);
}

/******************************Public*Routine******************************\
* vDisablePalette
*
* Frees resources allocated by bInitPaletteInfo.
*
\**************************************************************************/

VOID vDisablePalette(PPDEV ppdev)
{
// Delete the default palette if we created one.

    if (ppdev->hpalDefault)
    {
        EngDeletePalette(ppdev->hpalDefault);
        ppdev->hpalDefault = (HPALETTE) 0;
    }

    if (ppdev->pPal != (PPALETTEENTRY)NULL)
        EngFreeMem((PVOID)ppdev->pPal);
}

/******************************Public*Routine******************************\
* bInitDefaultPalette
*
* Initializes default palette for PDEV.
*
\**************************************************************************/

BOOL bInitDefaultPalette(PPDEV ppdev, DEVINFO *pDevInfo)
{
    ULONG ulLoop;
    BYTE  jRed;
    BYTE  jGre;
    BYTE  jBlu;

    // Allocate our palette

    ppdev->pPal = (PPALETTEENTRY)EngAllocMem(FL_ZERO_MEMORY,
            (sizeof(PALETTEENTRY) * 256), ALLOC_TAG);

    if ((ppdev->pPal) == NULL)
    {
        RIP("Couldn't allocate default palette");
        return(FALSE);
    }

    // Generate 256 (8*4*4) RGB combinations to fill the palette

    jRed = jGre = jBlu = 0;

    for (ulLoop = 0; ulLoop < 256; ulLoop++)
    {
        ppdev->pPal[ulLoop].peRed   = jRed;
        ppdev->pPal[ulLoop].peGreen = jGre;
        ppdev->pPal[ulLoop].peBlue  = jBlu;
        ppdev->pPal[ulLoop].peFlags = (BYTE)0;

        if (!((jRed += 8) & 0x3F))
            if (!((jGre += 8) & 0x3F))
                jBlu += 16;
    }

// Fill in Windows Reserved Colors from the WIN 3.0 DDK
// The Window Manager reserved the first and last 10 colors for
// painting windows borders and for non-palette managed applications.

    for (ulLoop = 0; ulLoop < 10; ulLoop++)
    {
    // First 10

        ppdev->pPal[ulLoop].peRed   = BASEPALETTE[ulLoop].peRed   ;
        ppdev->pPal[ulLoop].peGreen = BASEPALETTE[ulLoop].peGreen ;
        ppdev->pPal[ulLoop].peBlue  = BASEPALETTE[ulLoop].peBlue  ;
        ppdev->pPal[ulLoop].peFlags = BASEPALETTE[ulLoop].peFlags;

    // Last 10

        ppdev->pPal[246+ulLoop].peRed   = BASEPALETTE[ulLoop+10].peRed   ;
        ppdev->pPal[246+ulLoop].peGreen = BASEPALETTE[ulLoop+10].peGreen ;
        ppdev->pPal[246+ulLoop].peBlue  = BASEPALETTE[ulLoop+10].peBlue  ;
        ppdev->pPal[246+ulLoop].peFlags = BASEPALETTE[ulLoop+10].peFlags;
    }

// Create handle for palette.

    ppdev->hpalDefault = EngCreatePalette(PAL_INDEXED,
                                               256,
                                               (PULONG) ppdev->pPal,
                                               0,0,0);
    pDevInfo->hpalDefault = ppdev->hpalDefault;

    if (ppdev->hpalDefault == (HPALETTE) 0)
    {
        RIP("Couldn't create default palette");
        EngFreeMem(ppdev->pPal);
        return(FALSE);
    }

// Initialize the hardware with the initial palette.

    return(TRUE);
}

/******************************Public*Routine******************************\
* bInit256ColorPalette
*
* Initialize the hardware's palette registers.
*
\**************************************************************************/

BOOL bInit256ColorPalette(PPDEV ppdev)
{
    BYTE        ajClutSpace[MAX_CLUT_SIZE];
    PVIDEO_CLUT pScreenClut;
    ULONG       ulReturnedDataLength;
    ULONG       cColors;
    PVIDEO_CLUTDATA pScreenClutData;

    if (ppdev->ulBitCount == 8)
    {
        // Fill in pScreenClut header info:

        pScreenClut             = (PVIDEO_CLUT) ajClutSpace;
        pScreenClut->NumEntries = 256;
        pScreenClut->FirstEntry = 0;

        // Copy colours in:

        cColors = 256;
        pScreenClutData = (PVIDEO_CLUTDATA) (&(pScreenClut->LookupTable[0]));

        while(cColors--)
        {
            pScreenClutData[cColors].Red =    ppdev->pPal[cColors].peRed >>
                                              ppdev->cPaletteShift;
            pScreenClutData[cColors].Green =  ppdev->pPal[cColors].peGreen >>
                                              ppdev->cPaletteShift;
            pScreenClutData[cColors].Blue =   ppdev->pPal[cColors].peBlue >>
                                              ppdev->cPaletteShift;
            pScreenClutData[cColors].Unused = 0;
        }

        // Set palette registers:

        if (EngDeviceIoControl(ppdev->hDriver,
                             IOCTL_VIDEO_SET_COLOR_REGISTERS,
                             pScreenClut,
                             MAX_CLUT_SIZE,
                             NULL,
                             0,
                             &ulReturnedDataLength))
        {
            DISPDBG((0, "Failed bEnablePalette"));
            return(FALSE);
        }
    }

    DISPDBG((5, "Passed bEnablePalette"));

    return(TRUE);
}

/******************************Public*Routine******************************\
* DrvSetPalette
*
* DDI entry point for manipulating the palette.
*
\**************************************************************************/

BOOL DrvSetPalette(
DHPDEV  dhpdev,
PALOBJ* ppalo,
FLONG   fl,
ULONG   iStart,
ULONG   cColors)
{
    BYTE            ajClutSpace[MAX_CLUT_SIZE];
    PVIDEO_CLUT     pScreenClut;
    PVIDEO_CLUTDATA pScreenClutData;
    PDEV*           ppdev;

    UNREFERENCED_PARAMETER(fl);

    ppdev = (PDEV*) dhpdev;

    // Fill in pScreenClut header info:

    pScreenClut             = (PVIDEO_CLUT) ajClutSpace;
    pScreenClut->NumEntries = (USHORT) cColors;
    pScreenClut->FirstEntry = (USHORT) iStart;

    pScreenClutData = (PVIDEO_CLUTDATA) (&(pScreenClut->LookupTable[0]));

    if (cColors != PALOBJ_cGetColors(ppalo, iStart, cColors,
                                     (ULONG*) pScreenClutData))
    {
        DISPDBG((0, "DrvSetPalette failed PALOBJ_cGetColors\n"));
        return (FALSE);
    }

    // Set the high reserved byte in each palette entry to 0.
    // Do the appropriate palette shifting to fit in the DAC.

    if (ppdev->cPaletteShift)
    {
        while(cColors--)
        {
            pScreenClutData[cColors].Red >>= ppdev->cPaletteShift;
            pScreenClutData[cColors].Green >>= ppdev->cPaletteShift;
            pScreenClutData[cColors].Blue >>= ppdev->cPaletteShift;
            pScreenClutData[cColors].Unused = 0;
        }
    }
    else
    {
        while(cColors--)
        {
            pScreenClutData[cColors].Unused = 0;
        }
    }

    // Set palette registers

    if (EngDeviceIoControl(ppdev->hDriver,
                         IOCTL_VIDEO_SET_COLOR_REGISTERS,
                         pScreenClut,
                         MAX_CLUT_SIZE,
                         NULL,
                         0,
                         &cColors))
    {
        DISPDBG((0, "DrvSetPalette failed EngDeviceIoControl\n"));
        return (FALSE);
    }

    return(TRUE);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\vga\disp\8bpp\color.c ===
/******************************Module*Header*******************************\
* Module Name: color.c
*
* This algorithm for color dithering is patent pending and its use is
* restricted to Microsoft products and drivers for Microsoft products.
* Use in non-Microsoft products or in drivers for non-Microsoft product is
* prohibited without written permission from Microsoft.
*
* The patent application is the primary reference for the operation of the
* color dithering code.
*
* Note that in the comments and variable names, "vertex" means "vertex of
* either the inner (half intensity) or outer (full intensity) color cube."
* Vertices map to colors 0-6 and 248-255 of the Windows standard (required)
* 256-color palette, where vertices 0-6 and 248 are the vertices of the inner
* color cube, and 0 plus 249-255 are the vertices of the full color cube.
* Vertex 7 is 75% gray; this could be used in the dither, but that would break
* apps that depend on the exact Windows 3.1 dithering. This code is Window 3.1
* compatible.
*
* Copyright (c) 1992 Microsoft Corporation
\**************************************************************************/

#include "driver.h"

/**************************************************************************\
* This function takes a value from 0 - 255 and uses it to create an
* 8x8 pile of bits in the form of a 1BPP bitmap.  It can also take an
* RGB value and make an 8x8 bitmap.  These can then be used as brushes
* to simulate color unavaible on the device.
*
* For monochrome the basic algorithm is equivalent to turning on bits
* in the 8x8 array according to the following order:
*
*  00 32 08 40 02 34 10 42
*  48 16 56 24 50 18 58 26
*  12 44 04 36 14 46 06 38
*  60 28 52 20 62 30 54 22
*  03 35 11 43 01 33 09 41
*  51 19 59 27 49 17 57 25
*  15 47 07 39 13 45 05 37
*  63 31 55 23 61 29 53 21
*
* Reference: A Survey of Techniques for the Display of Continous
*            Tone Pictures on Bilevel Displays,;
*            Jarvis, Judice, & Ninke;
*            COMPUTER GRAPHICS AND IMAGE PROCESSING 5, pp 13-40, (1976)
\**************************************************************************/

#define SWAP_RB 0x00000004
#define SWAP_GB 0x00000002
#define SWAP_RG 0x00000001

#define SWAPTHEM(a,b) (ulTemp = a, a = b, b = ulTemp)

// PATTERNSIZE is the number of pixels in a dither pattern.
#define PATTERNSIZE 64

typedef union _PAL_ULONG {
    PALETTEENTRY pal;
    ULONG ul;
} PAL_ULONG;

typedef struct _VERTEX_DATA {
    ULONG ulCount;  // # of pixels in this vertex
    ULONG ulVertex; // vertex #
} VERTEX_DATA;

// Tells which row to turn a pel on in when dithering for monochrome bitmaps.
static BYTE ajByte[] = {
    0, 4, 0, 4, 2, 6, 2, 6,
    0, 4, 0, 4, 2, 6, 2, 6,
    1, 5, 1, 5, 3, 7, 3, 7,
    1, 5, 1, 5, 3, 7, 3, 7,
    0, 4, 0, 4, 2, 6, 2, 6,
    0, 4, 0, 4, 2, 6, 2, 6,
    1, 5, 1, 5, 3, 7, 3, 7,
    1, 5, 1, 5, 3, 7, 3, 7
};

// The array of monochrome bits used for monc
static BYTE ajBits[] = {
    0x80, 0x08, 0x08, 0x80, 0x20, 0x02, 0x02, 0x20,
    0x20, 0x02, 0x02, 0x20, 0x80, 0x08, 0x08, 0x80,
    0x40, 0x04, 0x04, 0x40, 0x10, 0x01, 0x01, 0x10,
    0x10, 0x01, 0x01, 0x10, 0x40, 0x04, 0x04, 0x40,
    0x40, 0x04, 0x04, 0x40, 0x10, 0x01, 0x01, 0x10,
    0x10, 0x01, 0x01, 0x10, 0x40, 0x04, 0x04, 0x40,
    0x80, 0x08, 0x08, 0x80, 0x20, 0x02, 0x02, 0x20,
    0x20, 0x02, 0x02, 0x20, 0x80, 0x08, 0x08, 0x80
};

// Translates vertices back to the original subspace. Each row is a subspace,
// as encoded in ulSymmetry, and each column is a vertex between 0 and 15.
BYTE jSwapSubSpace[8*16] = {
    0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
    0, 2, 1, 3, 4, 6, 5, 7, 8, 10, 9, 11, 12, 14, 13, 15,
    0, 1, 4, 5, 2, 3, 6, 7, 8, 9, 12, 13, 10, 11, 14, 15,
    0, 4, 1, 5, 2, 6, 3, 7, 8, 12, 9, 13, 10, 14, 11, 15,
    0, 4, 2, 6, 1, 5, 3, 7, 8, 12, 10, 14, 9, 13, 11, 15,
    0, 2, 4, 6, 1, 3, 5, 7, 8, 10, 12, 14, 9, 11, 13, 15,
    0, 4, 1, 5, 2, 6, 3, 7, 8, 12, 9, 13, 10, 14, 11, 15,
    0, 1, 4, 5, 2, 3, 6, 7, 8, 9, 12, 13, 10, 11, 14, 15,
};

// Converts a nibble value in the range 0-15 to a dword value containing the
// nibble value packed 8 times.
ULONG ulNibbleToDwordWithConvert[16] = {
    0x00000000,
    0x01010101,
    0x02020202,
    0x03030303,
    0x04040404,
    0x05050505,
    0x06060606,
    0xF8F8F8F8,
    0x07070707,
    0xF9F9F9F9,
    0xFAFAFAFA,
    0xFBFBFBFB,
    0xFCFCFCFC,
    0xFDFDFDFD,
    0xFEFEFEFE,
    0xFFFFFFFF
};

// Specifies where in the dither pattern colors should be placed in order
// of increasing intensity.
ULONG aulDitherOrder[] = {
  0, 36,  4, 32, 18, 54, 22, 50,
  2, 38,  6, 34, 16, 52, 20, 48,
  9, 45, 13, 41, 27, 63, 31, 59,
 11, 47, 15, 43, 25, 61, 29, 57,
  1, 37,  5, 33, 19, 55, 23, 51,
  3, 39,  7, 35, 17, 53, 21, 49,
  8, 44, 12, 40, 26, 62, 30, 58,
 10, 46, 14, 42, 24, 60, 28, 56,
};

// Array to convert to 256 color from 16 color. Maps from index that represents
// a 16-color vertex (color) to value that specifies the color index in the
// 256-color palette.

BYTE ajConvert[] =
{
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    248,
    7,
    249,
    250,
    251,
    252,
    253,
    254,
    255
};

/******************************Public*Routine******************************\
* DrvDitherColor
*
* Dithers an RGB color to an 8X8 approximation using the reserved VGA colors
*
\**************************************************************************/

ULONG DrvDitherColor(
IN  DHPDEV dhpdev,
IN  ULONG  iMode,
IN  ULONG  rgb,
OUT ULONG *pul)
{
    ULONG   ulGrey, ulRed, ulGre, ulBlu, ulSymmetry;
    ULONG   ulRedTemp, ulGreenTemp, ulBlueTemp, ulTemp;
    VERTEX_DATA vVertexData[4];
    VERTEX_DATA *pvVertexData;
    VERTEX_DATA *pvVertexDataEnd;
    ULONG  *pulDitherOrder;
    ULONG   ulNumPixels;
    BYTE    jColor;
    ULONG   ulColor;
    VERTEX_DATA *pvMaxVertex;
    ULONG   ulVertex0Temp, ulVertex1Temp, ulVertex2Temp, ulVertex3Temp;
    BYTE   *pjDither = (BYTE *)pul;

    // Figure out if we need a full color dither or only a monochrome dither
    if (iMode != DM_MONOCHROME) {

        // Full color dither

        // Split the color into red, green, and blue components
        ulRedTemp   = ((PAL_ULONG *)&rgb)->pal.peRed;
        ulGreenTemp   = ((PAL_ULONG *)&rgb)->pal.peGreen;
        ulBlueTemp   = ((PAL_ULONG *)&rgb)->pal.peBlue;

        // Sort the RGB so that the point is transformed into subspace 0, and
        // keep track of the swaps in ulSymmetry so we can unravel it again
        // later.  We want r >= g >= b (subspace 0).
        ulSymmetry = 0;
        if (ulBlueTemp > ulRedTemp) {
            SWAPTHEM(ulBlueTemp,ulRedTemp);
            ulSymmetry = SWAP_RB;
        }

        if (ulBlueTemp > ulGreenTemp) {
            SWAPTHEM(ulBlueTemp,ulGreenTemp);
            ulSymmetry |= SWAP_GB;
        }

        if (ulGreenTemp > ulRedTemp) {
            SWAPTHEM(ulGreenTemp,ulRedTemp);
            ulSymmetry |= SWAP_RG;
        }

        ulSymmetry <<= 4;   // for lookup purposes

        // Scale the values from 0-255 to 0-64. Note that the scaling is not
        // symmetric at the ends; this is done to match Windows 3.1 dithering
        ulRed = (ulRedTemp + 1) >> 2;
        ulGre = (ulGreenTemp + 1) >> 2;
        ulBlu = (ulBlueTemp + 1) >> 2;

        // Compute the subsubspace within subspace 0 in which the point lies,
        // then calculate the # of pixels to dither in the colors that are the
        // four vertexes of the tetrahedron bounding the color we're emulating.
        // Only vertices with more than zero pixels are stored, and the
        // vertices are stored in order of increasing intensity, saving us the
        // need to sort them later
        if ((ulRedTemp + ulGreenTemp) > 256) {
            // Subsubspace 2 or 3
            if ((ulRedTemp + ulBlueTemp) > 256) {
                // Subsubspace 3
                // Calculate the number of pixels per vertex, still in
                // subsubspace 3, then convert to original subspace. The pixel
                // counts and vertex numbers are matching pairs, stored in
                // ascending intensity order, skipping vertices with zero
                // pixels. The vertex intensity order for subsubspace 3 is:
                // 7, 9, 0x0B, 0x0F
                pvVertexData = vVertexData;
                if ((ulVertex0Temp = (64 - ulRed) << 1) != 0) {
                    pvVertexData->ulCount = ulVertex0Temp;
                    pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x07];
                }
                ulVertex2Temp = ulGre - ulBlu;
                ulVertex3Temp = (ulRed - 64) + ulBlu;
                if ((ulVertex1Temp = ((PATTERNSIZE - ulVertex0Temp) -
                        ulVertex2Temp) - ulVertex3Temp) != 0) {
                    pvVertexData->ulCount = ulVertex1Temp;
                    pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x09];
                }
                if (ulVertex2Temp != 0) {
                    pvVertexData->ulCount = ulVertex2Temp;
                    pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x0B];
                }
                if (ulVertex3Temp != 0) {
                    pvVertexData->ulCount = ulVertex3Temp;
                    pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x0F];
                }
            } else {
                // Subsubspace 2
                // Calculate the number of pixels per vertex, still in
                // subsubspace 2, then convert to original subspace. The pixel
                // counts and vertex numbers are matching pairs, stored in
                // ascending intensity order, skipping vertices with zero
                // pixels. The vertex intensity order for subsubspace 2 is:
                // 3, 7, 9, 0x0B
                pvVertexData = vVertexData;
                ulVertex1Temp = ulBlu << 1;
                ulVertex2Temp = ulRed - ulGre;
                ulVertex3Temp = (ulRed - 32) + (ulGre - 32);
                if ((ulVertex0Temp = ((PATTERNSIZE - ulVertex1Temp) -
                            ulVertex2Temp) - ulVertex3Temp) != 0) {
                    pvVertexData->ulCount = ulVertex0Temp;
                    pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x03];
                }
                if (ulVertex1Temp != 0) {
                    pvVertexData->ulCount = ulVertex1Temp;
                    pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x07];
                }
                if (ulVertex2Temp != 0) {
                    pvVertexData->ulCount = ulVertex2Temp;
                    pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x09];
                }
                if (ulVertex3Temp != 0) {
                    pvVertexData->ulCount = ulVertex3Temp;
                    pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x0B];
                }
            }
        } else {
            // Subsubspace 0 or 1
            if (ulRedTemp > 128) {
                // Subsubspace 1
                // Calculate the number of pixels per vertex, still in
                // subsubspace 1, then convert to original subspace. The pixel
                // counts and vertex numbers are matching pairs, stored in
                // ascending intensity order, skipping vertices with zero
                // pixels. The vertex intensity order for subsubspace 1 is:
                // 1, 3, 7, 9
                pvVertexData = vVertexData;
                if ((ulVertex0Temp = ((32 - ulGre) + (32 - ulRed)) << 1) != 0) {
                    pvVertexData->ulCount = ulVertex0Temp;
                    pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x01];
                }
                ulVertex2Temp = ulBlu << 1;
                ulVertex3Temp = (ulRed - 32) << 1;
                if ((ulVertex1Temp = ((PATTERNSIZE - ulVertex0Temp) -
                        ulVertex2Temp) - ulVertex3Temp) != 0) {
                    pvVertexData->ulCount = ulVertex1Temp;
                    pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x03];
                }
                if (ulVertex2Temp != 0) {
                    pvVertexData->ulCount = ulVertex2Temp;
                    pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x07];
                }
                if (ulVertex3Temp != 0) {
                    pvVertexData->ulCount = ulVertex3Temp;
                    pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x09];
                }
            } else {
                // Subsubspace 0
                // Calculate the number of pixels per vertex, still in
                // subsubspace 0, then convert to original subspace. The pixel
                // counts and vertex numbers are matching pairs, stored in
                // ascending intensity order, skipping vertices with zero
                // pixels. The vertex intensity order for subsubspace 0 is:
                // 0, 1, 3, 7
                pvVertexData = vVertexData;
                if ((ulVertex0Temp = (32 - ulRed) << 1) != 0) {
                    pvVertexData->ulCount = ulVertex0Temp;
                    pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x00];
                }
                if ((ulVertex1Temp = (ulRed - ulGre) << 1) != 0) {
                    pvVertexData->ulCount = ulVertex1Temp;
                    pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x01];
                }
                ulVertex3Temp = ulBlu << 1;
                if ((ulVertex2Temp = ((PATTERNSIZE - ulVertex0Temp) -
                        ulVertex1Temp) - ulVertex3Temp) != 0) {
                    pvVertexData->ulCount = ulVertex2Temp;
                    pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x03];
                }
                if (ulVertex3Temp != 0) {
                    pvVertexData->ulCount = ulVertex3Temp;
                    pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x07];
                }
            }
        }

        // Now that we have found the bounding vertices and the number of
        // pixels to dither for each vertex, we can create the dither pattern

        // Handle 1, 2, and 3 & 4 vertices per dither separately
        ulTemp = pvVertexData - vVertexData;    // # of vertices with more than
                                                // zero pixels
        if (ulTemp > 2) {

            // There are 3 or 4 vertices in this dither

            if (ulTemp == 3) {

                // There are 3 vertices in this dither

                // Find the vertex with the most pixels, and fill the whole
                // destination bitmap with that vertex's color, which is faster
                // than dithering it
                if (vVertexData[1].ulCount >= vVertexData[2].ulCount) {
                    pvMaxVertex = &vVertexData[1];
                    ulTemp = vVertexData[1].ulCount;
                } else {
                    pvMaxVertex = &vVertexData[2];
                    ulTemp = vVertexData[2].ulCount;
                }

            } else {

                // There are 4 vertices in this dither

                // Find the vertex with the most pixels, and fill the whole
                // destination bitmap with that vertex's color, which is faster
                // than dithering it
                if (vVertexData[2].ulCount >= vVertexData[3].ulCount) {
                    pvMaxVertex = &vVertexData[2];
                    ulTemp = vVertexData[2].ulCount;
                } else {
                    pvMaxVertex = &vVertexData[3];
                    ulTemp = vVertexData[3].ulCount;
                }
            }

            if (vVertexData[1].ulCount > ulTemp) {
                pvMaxVertex = &vVertexData[1];
                ulTemp = vVertexData[1].ulCount;
            }
            if (vVertexData[0].ulCount > ulTemp) {
                pvMaxVertex = &vVertexData[0];
            }

            pvVertexDataEnd = pvVertexData;

            // Prepare a dword version of the most common vertex number (color)
            ulColor = ulNibbleToDwordWithConvert[pvMaxVertex->ulVertex];

            // Mark that the vertex we're about to do doesn't need to be done
            // later
            pvMaxVertex->ulVertex = 0xFF;

            // Block fill the dither pattern with the more common vertex
            *pul = ulColor;
            *(pul+1) = ulColor;
            *(pul+2) = ulColor;
            *(pul+3) = ulColor;
            *(pul+4) = ulColor;
            *(pul+5) = ulColor;
            *(pul+6) = ulColor;
            *(pul+7) = ulColor;
            *(pul+8) = ulColor;
            *(pul+9) = ulColor;
            *(pul+10) = ulColor;
            *(pul+11) = ulColor;
            *(pul+12) = ulColor;
            *(pul+13) = ulColor;
            *(pul+14) = ulColor;
            *(pul+15) = ulColor;

            // Now dither all the remaining vertices in order 0->2 or 0->3
            // (in order of increasing intensity)
            pulDitherOrder = aulDitherOrder;
            pvVertexData = vVertexData;
            do {
                if (pvVertexData->ulVertex == 0xFF) {
                    // This is the max vertex, which we already did, but we
                    // have to account for it in the dither order
                    pulDitherOrder += pvVertexData->ulCount;
                } else {
                    jColor = ajConvert[pvVertexData->ulVertex];
                    ulNumPixels = pvVertexData->ulCount;
                    switch (ulNumPixels & 3) {
                        case 3:
                            pjDither[*(pulDitherOrder+2)] = jColor;
                        case 2:
                            pjDither[*(pulDitherOrder+1)] = jColor;
                        case 1:
                            pjDither[*(pulDitherOrder+0)] = jColor;
                            pulDitherOrder += ulNumPixels & 3;
                        case 0:
                            break;
                    }
                    if ((ulNumPixels >>= 2) != 0) {
                        do {
                            pjDither[*pulDitherOrder] = jColor;
                            pjDither[*(pulDitherOrder+1)] = jColor;
                            pjDither[*(pulDitherOrder+2)] = jColor;
                            pjDither[*(pulDitherOrder+3)] = jColor;
                            pulDitherOrder += 4;
                        } while (--ulNumPixels);
                    }
                }
            } while (++pvVertexData < pvVertexDataEnd);

        } else if (ulTemp == 2) {

            // There are exactly two vertices with more than zero pixels; fill
            // in the dither array as follows: block fill with vertex with more
            // points first, then dither in the other vertex
            if (vVertexData[0].ulCount >= vVertexData[1].ulCount) {
                // There are no more vertex 1 than vertex 0 pixels, so do
                // the block fill with vertex 0
                ulColor = ulNibbleToDwordWithConvert[vVertexData[0].ulVertex];
                // Do the dither with vertex 1
                jColor = ajConvert[vVertexData[1].ulVertex];
                ulNumPixels = vVertexData[1].ulCount;
                // Set where to start dithering with vertex 1 (vertex 0 is
                // lower intensity, so its pixels come first in the dither
                // order)
                pulDitherOrder = aulDitherOrder + vVertexData[0].ulCount;
            } else {
                // There are more vertex 1 pixels, so do the block fill
                // with vertex 1
                ulColor = ulNibbleToDwordWithConvert[vVertexData[1].ulVertex];
                // Do the dither with vertex 0
                jColor = ajConvert[vVertexData[0].ulVertex];
                ulNumPixels = vVertexData[0].ulCount;
                // Set where to start dithering with vertex 0 (vertex 0 is
                // lower intensity, so its pixels come first in the dither
                // order)
                pulDitherOrder = aulDitherOrder;
            }

            // Block fill the dither pattern with the more common vertex
            *pul = ulColor;
            *(pul+1) = ulColor;
            *(pul+2) = ulColor;
            *(pul+3) = ulColor;
            *(pul+4) = ulColor;
            *(pul+5) = ulColor;
            *(pul+6) = ulColor;
            *(pul+7) = ulColor;
            *(pul+8) = ulColor;
            *(pul+9) = ulColor;
            *(pul+10) = ulColor;
            *(pul+11) = ulColor;
            *(pul+12) = ulColor;
            *(pul+13) = ulColor;
            *(pul+14) = ulColor;
            *(pul+15) = ulColor;

            // Dither in the less common vertex
            switch (ulNumPixels & 3) {
                case 3:
                    pjDither[*(pulDitherOrder+2)] = jColor;
                case 2:
                    pjDither[*(pulDitherOrder+1)] = jColor;
                case 1:
                    pjDither[*(pulDitherOrder+0)] = jColor;
                    pulDitherOrder += ulNumPixels & 3;
                case 0:
                    break;
            }
            if ((ulNumPixels >>= 2) != 0) {
                do {
                    pjDither[*pulDitherOrder] = jColor;
                    pjDither[*(pulDitherOrder+1)] = jColor;
                    pjDither[*(pulDitherOrder+2)] = jColor;
                    pjDither[*(pulDitherOrder+3)] = jColor;
                    pulDitherOrder += 4;
                } while (--ulNumPixels);
            }

        } else {

            // There is only one vertex in this dither

            // No sorting or dithering is needed for just one color; we can
            // just generate the final DIB directly
            ulColor = ulNibbleToDwordWithConvert[vVertexData[0].ulVertex];
            *pul = ulColor;
            *(pul+1) = ulColor;
            *(pul+2) = ulColor;
            *(pul+3) = ulColor;
            *(pul+4) = ulColor;
            *(pul+5) = ulColor;
            *(pul+6) = ulColor;
            *(pul+7) = ulColor;
            *(pul+8) = ulColor;
            *(pul+9) = ulColor;
            *(pul+10) = ulColor;
            *(pul+11) = ulColor;
            *(pul+12) = ulColor;
            *(pul+13) = ulColor;
            *(pul+14) = ulColor;
            *(pul+15) = ulColor;
        }

    } else {

        // For monochrome we will only use the Intensity (grey level)
        RtlFillMemory((PVOID) pul, PATTERNSIZE/2, 0);  // zero the dither bits

        ulRed   = (ULONG) ((PALETTEENTRY *) &rgb)->peRed;
        ulGre = (ULONG) ((PALETTEENTRY *) &rgb)->peGreen;
        ulBlu  = (ULONG) ((PALETTEENTRY *) &rgb)->peBlue;

        // I = .30R + .59G + .11B
        // For convience the following ratios are used:
        //
        //  77/256 = 30.08%
        // 151/256 = 58.98%
        //  28/256 = 10.94%

        ulGrey  = (((ulRed * 77) + (ulGre * 151) + (ulBlu * 28)) >> 8) & 255;

        // Convert the RGBI from 0-255 to 0-64 notation.

        ulGrey = (ulGrey + 1) >> 2;

        while(ulGrey) {
            ulGrey--;
            pul[ajByte[ulGrey]] |= ((ULONG) ajBits[ulGrey]);
        }
    }

    return(DCR_DRIVER);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\vga\disp\8bpp\enable.c ===
/******************************Module*Header*******************************\
* Module Name: enable.c
*
* This module contains the functions that enable and disable the
* driver, the pdev, and the surface.
*
* Copyright (c) 1992 Microsoft Corporation
\**************************************************************************/

#include "driver.h"

//
// Build the driver function table gadrvfn with function index/address pairs
//

DRVFN gadrvfn[] = {
    {   INDEX_DrvEnablePDEV,            (PFN) DrvEnablePDEV         },
    {   INDEX_DrvCompletePDEV,          (PFN) DrvCompletePDEV       },
    {   INDEX_DrvDisablePDEV,           (PFN) DrvDisablePDEV        },
    {   INDEX_DrvEnableSurface,         (PFN) DrvEnableSurface      },
    {   INDEX_DrvDisableSurface,        (PFN) DrvDisableSurface     },
    {   INDEX_DrvAssertMode,            (PFN) DrvAssertMode         },
    {   INDEX_DrvGetModes,              (PFN) DrvGetModes           },
    {   INDEX_DrvDitherColor,           (PFN) DrvDitherColor        },
    {   INDEX_DrvSetPalette,            (PFN) DrvSetPalette         },
    {   INDEX_DrvCopyBits,              (PFN) DrvCopyBits           },
    {   INDEX_DrvBitBlt,                (PFN) DrvBitBlt             },
    {   INDEX_DrvTextOut,               (PFN) DrvTextOut            },
    {   INDEX_DrvStrokePath,            (PFN) DrvStrokePath         },
    {   INDEX_DrvFillPath,              (PFN) DrvFillPath           },
    {   INDEX_DrvRealizeBrush,          (PFN) DrvRealizeBrush       },
    {   INDEX_DrvStretchBlt,            (PFN) DrvStretchBlt         },
    {   INDEX_DrvSaveScreenBits,        (PFN) DrvSaveScreenBits     },
    {   INDEX_DrvPaint,                 (PFN) DrvPaint              },
    {   INDEX_DrvDisableDriver,         (PFN) DrvDisableDriver      }
};



/********************************* COMMENT ********************************\

    This routine allocates a 4K global buffer for temporary working storage
    which is used by several routines.  We wanted to get the most space for
    the least paging impact, so a page aligned 4K buffer was chosen.  Any
    access to this buffer will cause at most one page fault.  Because it is
    aligned, we can access the entire 4K without causing another page fault.

    Any buffer requirement over 4K must be allocated.  If we find that we
    are still having a low hit rate on the buffer (using lot's of allocs)
    then the buffer size should be increased to 8K.

    The ONLY reason that it is OK to have this global buffer is that this
    driver does not support DFBs, and accesses to the screen are synhronized
    by the engine.  In other words, it is currently never possible to have
    two threads executing code in the driver at the same time.

\**************************************************************************/



/******************************Public*Routine******************************\
* DrvEnableDriver
*
* Enables the driver by retrieving the drivers function table and version.
*
\**************************************************************************/

BOOL DrvEnableDriver(
    ULONG iEngineVersion,
    ULONG cj,
    PDRVENABLEDATA pded)
{
    UNREFERENCED_PARAMETER(iEngineVersion);

// Engine Version is passed down so future drivers can support previous
// engine versions.  A next generation driver can support both the old
// and new engine conventions if told what version of engine it is
// working with.  For the first version the driver does nothing with it.

// Fill in as much as we can.

    if (cj >= sizeof(DRVENABLEDATA))
        pded->pdrvfn = gadrvfn;

    if (cj >= (sizeof(ULONG) * 2))
        pded->c = sizeof(gadrvfn) / sizeof(DRVFN);

// DDI version this driver was targeted for is passed back to engine.
// Future graphic's engine may break calls down to old driver format.

    if (cj >= sizeof(ULONG))
        pded->iDriverVersion = DDI_DRIVER_VERSION_NT4;

    return(TRUE);
}

/******************************Public*Routine******************************\
* DrvDisableDriver
*
* Tells the driver it is being disabled. Release any resources allocated in
* DrvEnableDriver.
*
\**************************************************************************/

VOID DrvDisableDriver(VOID)
{
    return;
}

/******************************Public*Routine******************************\
* DrvEnablePDEV
*
* DDI function, Enables the Physical Device.
*
* Return Value: device handle to pdev.
*
\**************************************************************************/

DHPDEV DrvEnablePDEV(
    DEVMODEW   *pDevmode,       // Pointer to DEVMODE
    PWSTR       pwszLogAddress, // Logical address
    ULONG       cPatterns,      // number of patterns
    HSURF      *ahsurfPatterns, // return standard patterns
    ULONG       cjGdiInfo,      // Length of memory pointed to by pGdiInfo
    ULONG      *pGdiInfo,       // Pointer to GdiInfo structure
    ULONG       cjDevInfo,      // Length of following PDEVINFO structure
    DEVINFO    *pDevInfo,       // physical device information structure
    HDEV        hdev,           // HDEV, used for callbacks
    PWSTR       pwszDeviceName, // DeviceName - not used
    HANDLE      hDriver)        // Handle to base driver
{
    GDIINFO GdiInfo;
    DEVINFO DevInfo;
    PPDEV   ppdev;
    BYTE   *pjTemp;
    INT     i;

    UNREFERENCED_PARAMETER(pwszLogAddress);
    UNREFERENCED_PARAMETER(pwszDeviceName);

    // Allocate a physical device structure.

    ppdev = (PPDEV) EngAllocMem(FL_ZERO_MEMORY, sizeof(PDEV), ALLOC_TAG);

    if (ppdev == (PPDEV) NULL)
    {
        DISPDBG((0, "VGA256: Couldn't allocate PDEV buffer"));
        goto error0;
    }

    // Create the table used for flipping bits 0-3 and 4-7 when drawing text.
    // This table must be aligned to a 256-byte boundary.
    ppdev->pjGlyphFlipTableBase =
            (BYTE *) EngAllocMem((FL_ZERO_MEMORY),
            ((256+256)*sizeof(UCHAR)), ALLOC_TAG);
    if (ppdev->pjGlyphFlipTableBase == NULL) {
        DISPDBG((0, "VGA256: Couldn't allocate pjGlyphFlipTableBase"));
        goto error01;
    }

    // Round the table start up to the nearest 256 byte boundary, because the
    // table must start on 256-byte boundaries for look-up reasons

    ppdev->pjGlyphFlipTable =
            (BYTE *) ((ULONG) (ppdev->pjGlyphFlipTableBase + 0xFF) & ~0xFF);

    // Set the table to convert bits 76543210 to 45670123, which we need for
    // drawing text in planar mode (because plane 0 is the leftmost, not
    // rightmost, pixel)

    pjTemp = ppdev->pjGlyphFlipTable;
    for (i=0; i<256; i++) {
        *pjTemp++ = ((i & 0x80) >> 3) |
                    ((i & 0x40) >> 1) |
                    ((i & 0x20) << 1) |
                    ((i & 0x10) << 3) |
                    ((i & 0x08) >> 3) |
                    ((i & 0x04) >> 1) |
                    ((i & 0x02) << 1) |
                    ((i & 0x01) << 3);
    }

    // Save the screen handle in the PDEV.

    ppdev->hDriver = hDriver;

    // Get the current screen mode information.  Set up device caps and devinfo.

    if (!bInitPDEV(ppdev,pDevmode, &GdiInfo, &DevInfo))
    {
        DISPDBG((0,"VGA256: Couldn't initialize PDEV"));
        goto error1;
    }

    // Initialize palette information.

    if (!bInitPaletteInfo(ppdev, &DevInfo))
    {
        DISPDBG((0, "VGA256: Couldn't initialize palette"));
        goto error1;
    }

    // Copy the devinfo into the engine buffer.

    memcpy(pDevInfo, &DevInfo, min(sizeof(DEVINFO), cjDevInfo));

    // Set the pdevCaps with GdiInfo we have prepared to the list of caps for this
    // pdev.

    memcpy(pGdiInfo, &GdiInfo, min(cjGdiInfo, sizeof(GDIINFO)));

    // Create a clip object we can use when we're given a NULL clip object:

    ppdev->pcoNull = EngCreateClip();
    if (ppdev->pcoNull == NULL)
    {
        DISPDBG((0, "VGA256: Couldn't create clip"));
        goto error2;
    }

    ppdev->pcoNull->iDComplexity     = DC_RECT;
    ppdev->pcoNull->rclBounds.left   = 0;
    ppdev->pcoNull->rclBounds.top    = 0;
    ppdev->pcoNull->rclBounds.right  = ppdev->cxScreen;
    ppdev->pcoNull->rclBounds.bottom = ppdev->cyScreen;
    ppdev->pcoNull->fjOptions        = OC_BANK_CLIP;

    // pvSaveScan0 is non-NULL only when enumerating banks:

    ppdev->pvSaveScan0 = NULL;

    // We're all done:

    return((DHPDEV) ppdev);

error2:
    vDisablePalette(ppdev);

error1:
    EngFreeMem(ppdev->pjGlyphFlipTableBase);

error01:
    EngFreeMem(ppdev);

error0:
    return((DHPDEV) 0);
}

/******************************Public*Routine******************************\
* DrvCompletePDEV
*
* Store the HPDEV, the engines handle for this PDEV, in the DHPDEV.
*
\**************************************************************************/

VOID DrvCompletePDEV(
DHPDEV dhpdev,
HDEV  hdev)
{
    ((PPDEV) dhpdev)->hdevEng = hdev;
}

/******************************Public*Routine******************************\
* DrvDisablePDEV
*
* Release the resources allocated in DrvEnablePDEV.  If a surface has been
* enabled DrvDisableSurface will have already been called.
*
\**************************************************************************/

VOID DrvDisablePDEV(
    DHPDEV dhpdev)
{
    PPDEV ppdev = (PPDEV) dhpdev;

    EngDeleteClip(ppdev->pcoNull);
    vDisablePalette(ppdev);
    EngFreeMem(ppdev->pjGlyphFlipTableBase);
    EngFreeMem(dhpdev);
}

/******************************Public*Routine******************************\
* DrvEnableSurface
*
* Enable the surface for the device.  Hook the calls this driver supports.
*
* Return: Handle to the surface if successful, 0 for failure.
*
\**************************************************************************/

HSURF DrvEnableSurface(
    DHPDEV dhpdev)
{
    PPDEV ppdev;
    HSURF hsurf;
    HSURF hsurfBm;
    SIZEL sizl;
    ULONG ulBitmapType;
    FLONG flHooks;

    // Create engine bitmap around frame buffer.

    ppdev = (PPDEV) dhpdev;

    if (!bInitSURF(ppdev, TRUE))
        goto error0;

    if (!bInit256ColorPalette(ppdev))
        goto error0;

    sizl.cx = ppdev->cxScreen;
    sizl.cy = ppdev->cyScreen;

    ulBitmapType = BMF_8BPP;
    flHooks      = HOOKS_BMF8BPP;

    ASSERTVGA(ppdev->ulBitCount == 8, "Can only handle 8bpp VGAs");

    hsurfBm = (HSURF) EngCreateBitmap(sizl,
                                      ppdev->lDeltaScreen,
                                      (ULONG) (ulBitmapType),
                                      (FLONG) (((ppdev->lDeltaScreen > 0)
                                          ? BMF_TOPDOWN
                                          : 0)),
                                      (PVOID) (ppdev->pjScreen));
    if (hsurfBm == 0)
    {
        RIP("Couldn't create surface");
        goto error0;
    }

    if (!EngAssociateSurface(hsurfBm, ppdev->hdevEng, 0))
    {
        RIP("Couldn't create or associate surface");
        goto error1;
    }

    ppdev->hsurfBm = hsurfBm;

    ppdev->pSurfObj = EngLockSurface(hsurfBm);
    if (ppdev->pSurfObj == NULL)
    {
        RIP("Couldn't lock surface");
        goto error1;
    }

    hsurf = EngCreateDeviceSurface((DHSURF) ppdev, sizl, BMF_8BPP);
    if (hsurf == 0)
    {
        RIP("Couldn't create surface");
        goto error2;
    }

    if (!EngAssociateSurface(hsurf, ppdev->hdevEng, flHooks))
    {
        RIP("Couldn't associate surface");
        goto error3;
    }

    ppdev->hsurfEng = hsurf;

    // Disable all the clipping.

    if (!bEnableBanking(ppdev))
    {
        RIP("Couldn't initialize banking");
        goto error3;
    }

    ppdev->pvTmpBuf = EngAllocMem(FL_ZERO_MEMORY,
                                  GLOBAL_BUFFER_SIZE,
                                  ALLOC_TAG);

    if (ppdev->pvTmpBuf == NULL)
    {
        DISPDBG((0, "VGA256: Couldn't allocate global buffer"));
        goto error4;
    }

    ASSERTVGA(ppdev->lNextScan != 0, "lNextScan shouldn't be zero");

    sizl.cx = ppdev->lNextScan;
    sizl.cy = GLOBAL_BUFFER_SIZE / abs(ppdev->lNextScan);

    ppdev->hbmTmp = EngCreateBitmap(sizl, sizl.cx, BMF_8BPP, 0, ppdev->pvTmpBuf);
    if (ppdev->hbmTmp == (HBITMAP) 0)
    {
        RIP("Couldn't create temporary bitmap");
        goto error5;
    }

    ppdev->psoTmp = EngLockSurface((HSURF) ppdev->hbmTmp);
    if (ppdev->psoTmp == (SURFOBJ*) NULL)
    {
        RIP("Couldn't lock temporary surface");
        goto error6;
    }

    // Attempt to initialize the brush cache; if this fails, it sets a flag in
    // the PDEV instructing us to punt brush fills to the engine
    vInitBrushCache(ppdev);
    vInitSavedBits(ppdev);

    return(hsurf);

error6:
    EngDeleteSurface((HSURF) ppdev->hbmTmp);

error5:
    EngFreeMem(ppdev->pvTmpBuf);

error4:
    vDisableBanking(ppdev);

error3:
    EngDeleteSurface(hsurf);

error2:
    EngUnlockSurface(ppdev->pSurfObj);

error1:
    EngDeleteSurface(hsurfBm);

error0:
    return((HSURF) 0);
}

/******************************Public*Routine******************************\
* DrvDisableSurface
*
* Free resources allocated by DrvEnableSurface.  Release the surface.
*
\**************************************************************************/

VOID DrvDisableSurface(
    DHPDEV dhpdev)
{
    PPDEV ppdev = (PPDEV) dhpdev;

    EngUnlockSurface(ppdev->psoTmp);
    EngDeleteSurface((HSURF) ppdev->hbmTmp);
    EngFreeMem(ppdev->pvTmpBuf);
    EngDeleteSurface(ppdev->hsurfEng);
    vDisableSURF(ppdev);
    vDisableBrushCache(ppdev);
    ppdev->hsurfEng = (HSURF) 0;
    vDisableBanking(ppdev);
}

/******************************Public*Routine******************************\
* DrvAssertMode
*
* This asks the device to reset itself to the mode of the pdev passed in.
*
\**************************************************************************/

BOOL
DrvAssertMode(
    DHPDEV dhpdev,
    BOOL bEnable)
{
    BOOL    bRet = TRUE;
    PPDEV   ppdev = (PPDEV) dhpdev;
    ULONG   ulReturn;

    if (bEnable)
    {
        // The screen must be reenabled, reinitialize the device to
        // a clean state.

        bRet = bInitSURF(ppdev, FALSE);

        // Restore the off screen data.  This protects the Desktop
        // from a DOS application that might trash the off screen
        // memory.

        ppdev->bBitsSaved = FALSE;  // clear the DrvSaveScreenBits info flag
                                    // ie. blow away cached screen region

        // Blow away our brush cache because a full-screen app may have
        // overwritten the video memory where we cache our brushes:

        vResetBrushCache(ppdev);
    }
    else
    {
        // Call the kernel driver to reset the device to a known state.

        if (EngDeviceIoControl(ppdev->hDriver,
                             IOCTL_VIDEO_RESET_DEVICE,
                             NULL,
                             0,
                             NULL,
                             0,
                             &ulReturn))
        {
            RIP("VIDEO_RESET_DEVICE failed");
            bRet = FALSE;
        }
    }

    return bRet;
}

/******************************Public*Routine******************************\
* DrvGetModes
*
* Returns the list of available modes for the device.
*
\**************************************************************************/

ULONG DrvGetModes(
HANDLE hDriver,
ULONG cjSize,
DEVMODEW *pdm)

{

    DWORD cModes;
    DWORD cbOutputSize;
    PVIDEO_MODE_INFORMATION pVideoModeInformation, pVideoTemp;
    DWORD cOutputModes = cjSize / (sizeof(DEVMODEW) + DRIVER_EXTRA_SIZE);
    DWORD cbModeSize;

    DISPDBG((2, "Vga256.dll: DrvGetModes\n"));

    cModes = getAvailableModes(hDriver,
                               (PVIDEO_MODE_INFORMATION *) &pVideoModeInformation,
                               &cbModeSize);

    if (cModes == 0)
    {
        DISPDBG((0, "VGA256 DISP DrvGetModes failed to get mode information"));
        return 0;
    }

    if (pdm == NULL)
    {
        cbOutputSize = cModes * (sizeof(DEVMODEW) + DRIVER_EXTRA_SIZE);
    }
    else
    {
        //
        // Now copy the information for the supported modes back into the output
        // buffer
        //

        cbOutputSize = 0;

        pVideoTemp = pVideoModeInformation;

        do
        {
            if (pVideoTemp->Length != 0)
            {
                if (cOutputModes == 0)
                {
                    break;
                }

                //
                // Zero the entire structure to start off with.
                //

                memset(pdm, 0, sizeof(DEVMODEW));

                //
                // Set the name of the device to the name of the DLL.
                //

                memcpy(pdm->dmDeviceName, DLL_NAME, sizeof(DLL_NAME));

                pdm->dmSpecVersion      = DM_SPECVERSION;
                pdm->dmDriverVersion    = DM_SPECVERSION;
                pdm->dmSize             = sizeof(DEVMODEW);
                pdm->dmDriverExtra      = DRIVER_EXTRA_SIZE;

                pdm->dmBitsPerPel       = pVideoTemp->NumberOfPlanes *
                                          pVideoTemp->BitsPerPlane;
                pdm->dmPelsWidth        = pVideoTemp->VisScreenWidth;
                pdm->dmPelsHeight       = pVideoTemp->VisScreenHeight;
                pdm->dmDisplayFrequency = pVideoTemp->Frequency;
                pdm->dmDisplayFlags     = 0;

                pdm->dmFields           = DM_BITSPERPEL       |
                                          DM_PELSWIDTH        |
                                          DM_PELSHEIGHT       |
                                          DM_DISPLAYFREQUENCY |
                                          DM_DISPLAYFLAGS     ;

                //
                // Go to the next DEVMODE entry in the buffer.
                //

                cOutputModes--;

                pdm = (LPDEVMODEW) ( ((ULONG)pdm) + sizeof(DEVMODEW) +
                                                   DRIVER_EXTRA_SIZE);

                cbOutputSize += (sizeof(DEVMODEW) + DRIVER_EXTRA_SIZE);

            }

            pVideoTemp = (PVIDEO_MODE_INFORMATION)
                (((PUCHAR)pVideoTemp) + cbModeSize);

        } while (--cModes);
    }

    EngFreeMem(pVideoModeInformation);

    return cbOutputSize;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\vga\disp\8bpp\lines.h ===
/******************************Module*Header*******************************\
* Module Name: lines.h
*
* Line drawing constants and structures.
*
* NOTE: This file mirrors LINES.INC.  Changes here must be reflected in
* the .inc file!
*
* Created: 30-Mar-1992
* Author: Andrew Milton [w-andym]
*
* Copyright (c) 1992 Microsoft Corporation
\**************************************************************************/

typedef LONG STYLEPOS;

#define STYLE_MAX_COUNT     16          // Maximum number of style array entries
#define STYLE_MAX_VALUE     0x3fffL     // Maximum for of a style array element
#define RUN_MAX             20          // Size of our complex clip runs buffer
#define STRIP_MAX           100         // Size of our strip buffer
#define STYLE_DENSITY       3           // Each style unit is 3 pixels long

// For the ROP table:

#define MIX_XOR_OFFSET      8

#define AND_ZERO            0L
#define AND_PEN             1L
#define AND_NOTPEN          2L
#define AND_ONE             3L

#define XOR_ZERO            (AND_ZERO   << MIX_XOR_OFFSET)
#define XOR_PEN             (AND_PEN    << MIX_XOR_OFFSET)
#define XOR_NOTPEN          (AND_NOTPEN << MIX_XOR_OFFSET)
#define XOR_ONE             (AND_ONE    << MIX_XOR_OFFSET)

// Flip and round flags (see lines.inc for a description):

#define FL_H_ROUND_DOWN         0x00000080L     // .... .... 1... ....
#define FL_V_ROUND_DOWN         0x00008000L     // 1... .... .... ....

#define FL_FLIP_D               0x00000005L     // .... .... .... .1.1
#define FL_FLIP_V               0x00000008L     // .... .... .... 1...
#define FL_FLIP_SLOPE_ONE       0x00000010L     // .... .... ...1 ....
#define FL_FLIP_HALF            0x00000002L     // .... .... .... ..1.
#define FL_FLIP_H               0x00000200L     // .... ..1. .... ....

#define FL_ROUND_MASK           0x0000001CL     // .... .... ...1 11..
#define FL_ROUND_SHIFT          2

#define FL_RECTLCLIP_MASK       0x0000000CL     // .... .... .... 11..
#define FL_RECTLCLIP_SHIFT      2

#define FL_STRIP_MASK           0x00000003L     // .... .... .... ..11
#define FL_STRIP_SHIFT          0

#define FL_SIMPLE_CLIP          0x00000020      // .... .... ..1. ....
#define FL_COMPLEX_CLIP         0x00000040      // .... .... .1.. ....
#define FL_CLIP                (FL_SIMPLE_CLIP | FL_COMPLEX_CLIP)

#define FL_ARBITRARYSTYLED      0x00000400L     // .... .1.. .... ....
#define FL_SET                  0x00000800L     // .... 1... .... ....
#define FL_STYLED              (FL_ARBITRARYSTYLED)

#define FL_STRIP_ARRAY_MASK     0x00000C00L
#define FL_STRIP_ARRAY_SHIFT    10

// Simpler flag bits in high byte:

#define FL_DONT_DO_HALF_FLIP    0x00002000L     // ..1. .... .... ....
#define FL_PHYSICAL_DEVICE      0x00004000L     // .1.. .... .... ....

// Miscellaneous DDA defines:

#define LROUND(x, flRoundDown) (((x) + F/2 - ((flRoundDown) > 0)) >> 4)
#define F                     16
#define FLOG2                 4
#define LFLOOR(x)             ((x) >> 4)
#define FXFRAC(x)             ((x) & (F - 1))

struct _STRIP;
struct _LINESTATE;

typedef VOID (*PFNSTRIP)(struct _STRIP*, struct _LINESTATE*, LONG*);

typedef struct _STRIP {

// Updated by strip drawers:

    BYTE*           pjScreen;       // Points to the first pixel of the line
    BYTE            bIsGap;         // Are we working on a gap in the style?
    BYTE            jFiller2[3];    //   bIsGap sometimes treated as a ULONG

    STYLEPOS*       psp;            // Pointer to current style entry
    STYLEPOS        spRemaining;    // To go in current style

// Not modified by strip drawers:

    LONG            lNextScan;      // Signed increment to next scan
    LONG*           plStripEnd;     // Points one element past last strip
    LONG            flFlips;        // Indicates if line goes up or down
    STYLEPOS*       pspStart;       // Pointer to start of style array
    STYLEPOS*       pspEnd;         // Pointer to end of style array
    ULONG           xyDensity;      // Density of style
    ULONG           chAndXor;       // Lines colors (need 2 for doing ROPs)

// We leave room for a couple of extra dwords at the end of the strips
// array that can be used by the strip drawers:

    LONG            alStrips[STRIP_MAX + 2]; // Array of strips
} STRIP;

typedef struct _LINESTATE {

    ULONG           chAndXor;       // Line colors (need 2 for doing ROPs)
    STYLEPOS        spTotal;        // Sum of style array
    STYLEPOS        spTotal2;       // Twice sum of style array
    STYLEPOS        spNext;         // Style state at start of next line
    STYLEPOS        spComplex;      // Style state at start of complex clip line

    STYLEPOS*       aspRtoL;        // Style array in right-to-left order
    STYLEPOS*       aspLtoR;        // Style array in left-to-right order

    ULONG           xyDensity;      // Density of style
    ULONG           cStyle;         // Size of style array

    ULONG           ulStyleMaskLtoR;// Original style mask, left-to-right order
    ULONG           ulStyleMaskRtoL;// Original style mask, right-to-left order

    BOOL            bStartIsGap;    // Determines if first element in style
                                    // array is for a gap or a dash

} LINESTATE;	                /* ls */

BOOL bLinesSimple(PPDEV, POINTFIX*, POINTFIX*, RUN*, ULONG, LINESTATE*,
                  RECTL*, PFNSTRIP*, FLONG);

BOOL bLines(PPDEV, POINTFIX*, POINTFIX*, RUN*, ULONG,
            LINESTATE*, RECTL*, PFNSTRIP*, FLONG);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\vga\disp\8bpp\savescr.c ===
/******************************Module*Header*******************************\
* Module Name: savescr.c                                                   *
*                                                                          *
* DrvSaveScreenBits                                                        *
*                                                                          *
* Copyright (c) 1994 Microsoft Corporation                                 *
\**************************************************************************/


#include <driver.h>

// This is just a unique ID that the driver will recongize.  Hopefully,
// nothing will ever call with this ID by pure chance.

#define     SAVED_OFFSCREEN_ID      0x7813

ULONG       ulSaveOrRestoreBits(SURFOBJ *,PPDEV,RECTL *,BOOL);

/******************************Public*Routine******************************\
* DrvSaveScreenBits(pso,iMode,iIdent,prcl)                                 *
*                                                                          *
* Saves and restores the specified area of the screen                      *
*                                                                          *
\**************************************************************************/

ULONG DrvSaveScreenBits(SURFOBJ *pso, ULONG iMode, ULONG iIdent, RECTL *prcl)
{
    PPDEV ppdev;
    ULONG ulRet;

    ppdev = (PPDEV) pso->dhpdev;    // find the PDEV that goes with this surface

    if (!((ppdev->fl & DRIVER_OFFSCREEN_REFRESHED) &&
          (ppdev->fl & DRIVER_HAS_OFFSCREEN)))
    {
        return(0);
    }

    switch(iMode)
    {
        case SS_SAVE:

            //
            // Save a block of screen bits.
            //

            if (ppdev->bBitsSaved)
            {
                DISPDBG((1, "DrvSaveScreenBits: off screen area is already in use\n"));
                return(FALSE);      // there are already valid bits saved
            }

            ulRet = ulSaveOrRestoreBits(pso, ppdev, prcl, TRUE);
            if (ulRet)
            {
                ppdev->bBitsSaved = TRUE;
            }
            else
            {
                DISPDBG((1, "DrvSaveScreenBits (save): save couldn't fit\n"));
            }

            return(ulRet);

        case SS_RESTORE:

            //
            // Restore a saved screen bits block to the screen, then free it.
            //

            ASSERTVGA(iIdent == SAVED_OFFSCREEN_ID,
                      "DrvSaveScreenBits (restore): invalid iIdent\n");
            ASSERTVGA(ppdev->bBitsSaved == TRUE,
                      "DrvSaveScreenBits (restore): there are no saved bits\n");

            ppdev->bBitsSaved = FALSE;  // successful or not, destroy the bits

            if (!ulSaveOrRestoreBits(pso, ppdev, prcl, FALSE))
            {
                RIP("DrvSaveScreenBits (restore): restore failed\n");
            }

            return(TRUE);

        case SS_FREE:

            //
            // Free up the saved screen bits
            //

            ppdev->bBitsSaved = FALSE;
            return(TRUE);

        default:

            //
            // An unknown mode was passed in.
            //

            RIP("DrvSaveScreenBits: invalid iMode");
    }

    //
    // error if you get to here
    //

    return(FALSE);
}


/******************************Public*Routine******************************\
* vCopyRects(pso,ppdev,prclSrc,prclTrg,cxPad,bIsSave)                      *
*                                                                          *
* Breaks prclSrc up and copies the parts into prclTrg                      *
*                                                                          *
\**************************************************************************/

VOID vCopyRects(SURFOBJ *pso, PPDEV ppdev, RECTL * prclSrc, RECTL * prclTrg,
                LONG cxPad,  BOOL bIsSave)
{
    RECTL rclOnScreen;
    RECTL rclOffScreen;
    POINTL * pptlSrcTmp;
    RECTL * prclTrgTmp;
    ULONG cx, cy;
    ULONG cAlign;

    // We are assuming here that either the Trg is wider than the Src, or
    // the Trg is taller than the src.

    // We are assuming that if there is a nonzero cxPad, we are copying to
    // a rectangle such that the src is taller than the dst.
    // In other words, the prclTrg is a rectangle in the bottom offscreen
    // memory region, and the prclSrc needs to be broken up.

    ASSERTVGA(cxPad == 0 ||
              (prclSrc->bottom - prclSrc->top > prclTrg->bottom - prclTrg->top),
              "DrvSaveScreenBits: vCopyRects - cxPad is invalid\n");

    // Make sure that the src and trg are dword aligned.

    cAlign = (((prclSrc->left) - (prclTrg->left)) & (PELS_PER_DWORD - 1));

    if ((prclSrc->right - prclSrc->left) > prclTrg->right - prclTrg->left)
    {
        if ((prclSrc->bottom - prclSrc->top) >= prclTrg->bottom - prclTrg->top)
        {
            RIP("DrvSaveScreenBits: vCopyRects src is bigger than trg\n");
        }

        //
        // we need to break it up into vertical strips
        //

        cx = prclTrg->right - prclTrg->left;
        cy = prclSrc->bottom - prclSrc->top;

        ASSERTVGA(cx != 0, "DrvSaveScreenBits: vCopyRects (v save width == 0)\n");
        ASSERTVGA(cy != 0, "DrvSaveScreenBits: vCopyRects (v save height == 0)\n");

        rclOnScreen.right  = prclSrc->left;
        rclOnScreen.top    = prclSrc->top;
        rclOnScreen.bottom = prclSrc->top + cy;

        rclOffScreen.left  = prclTrg->left;
        rclOffScreen.bottom = prclTrg->top;

        // align offscreen rect to src

        rclOffScreen.left += cAlign;

        /* local variable used without having been initialized */
        // rclOffScreen.right += cAlign;

        while (rclOnScreen.right < prclSrc->right)
        {
            cx = min(cx,(ULONG)(prclSrc->right - rclOnScreen.right));
            ASSERTVGA(cx != 0, "DrvSaveScreenBits: vCopyRects (cx == 0)\n");
            rclOnScreen.left = rclOnScreen.right;
            rclOnScreen.right += cx;
            rclOffScreen.right = rclOffScreen.left + cx; // in case cx is thinner on last
            rclOffScreen.top = rclOffScreen.bottom;
            rclOffScreen.bottom += cy;

            if (rclOffScreen.bottom > prclTrg->bottom)
            {
                RIP("DrvSaveScreenBits: vCopyRects can't fit src into trg (vertical)\n");
            }

            if (bIsSave)
            {
                // save
                pptlSrcTmp = (POINTL *) &rclOnScreen;
                prclTrgTmp = &rclOffScreen;

                DISPDBG((1,"DrvSaveScreenBits (v save):    "));
            }
            else
            {
                // restore
                pptlSrcTmp = (POINTL *) &rclOffScreen;
                prclTrgTmp = &rclOnScreen;

                DISPDBG((1,"DrvSaveScreenBits (v restore): "));
            }

            DISPDBG((1,"%08x,%08x,%08x,%08x    %lux%lu\n",
                    rclOffScreen.left,
                    rclOffScreen.top,
                    rclOffScreen.right,
                    rclOffScreen.bottom,
                    rclOffScreen.right - rclOffScreen.left,
                    rclOffScreen.bottom - rclOffScreen.top
                    ));

            ASSERTVGA (((prclTrgTmp->left ^ pptlSrcTmp->x) &
                        (PELS_PER_DWORD - 1)) == 0,
                       "DrvSaveScreenBits (v): Src and Target are not aligned\n");

            DrvCopyBits(pso,                // psoDst   (screen)
                        pso,                // psoSrc   (screen)
                        NULL,               // pco      (none)
                        NULL,               // pxlo     (none)
                        prclTrgTmp,         // prclDst
                        pptlSrcTmp);        // pptlSrc
        }
    }
    else if ((prclSrc->bottom - prclSrc->top) > prclTrg->bottom - prclTrg->top)
    {
        //
        // we need to break it up into horizontal strips
        //

        cx = prclSrc->right - prclSrc->left;
        cy = prclTrg->bottom - prclTrg->top;

        ASSERTVGA(cx != 0, "DrvSaveScreenBits: vCopyRects (h save width == 0)\n");
        ASSERTVGA(cy != 0, "DrvSaveScreenBits: vCopyRects (h save height == 0)\n");

        rclOnScreen.bottom = prclSrc->top;
        rclOnScreen.left   = prclSrc->left;
        rclOnScreen.right  = prclSrc->left + cx;

        rclOffScreen.top  = prclTrg->top;
        rclOffScreen.right = prclTrg->left - cxPad;

        // align offscreen rect to src

        rclOffScreen.right += cAlign;

        while (rclOnScreen.bottom < prclSrc->bottom)
        {
            cy = min(cy,(ULONG)(prclSrc->bottom - rclOnScreen.bottom));
            ASSERTVGA(cy != 0, "DrvSaveScreenBits: vCopyRects (cy == 0)\n");
            rclOnScreen.top = rclOnScreen.bottom;
            rclOnScreen.bottom += cy;
            rclOffScreen.bottom = rclOffScreen.top + cy; // in case cy is shorter on last
            rclOffScreen.left = rclOffScreen.right + cxPad;
            rclOffScreen.right = rclOffScreen.left + cx;

            if (rclOffScreen.right > (prclTrg->right + (LONG)cAlign))
            {
                RIP("DrvSaveScreenBits: vCopyRects can't fit src into trg (horizontal)\n");
            }

            if (bIsSave)
            {
                // save
                pptlSrcTmp = (POINTL *) &rclOnScreen;
                prclTrgTmp = &rclOffScreen;

                DISPDBG((1,"DrvSaveScreenBits (h save):    "));
            }
            else
            {
                // restore
                pptlSrcTmp = (POINTL *) &rclOffScreen;
                prclTrgTmp = &rclOnScreen;

                DISPDBG((1,"DrvSaveScreenBits (h restore): "));
            }

            DISPDBG((1,"%08x,%08x,%08x,%08x    %lux%lu\n",
                    rclOffScreen.left,
                    rclOffScreen.top,
                    rclOffScreen.right,
                    rclOffScreen.bottom,
                    rclOffScreen.right - rclOffScreen.left,
                    rclOffScreen.bottom - rclOffScreen.top
                    ));

            ASSERTVGA (((prclTrgTmp->left ^ pptlSrcTmp->x) &
                        (PELS_PER_DWORD - 1)) == 0,
                       "DrvSaveScreenBits (h): Src and Target are not aligned\n");

            DrvCopyBits(pso,                // psoDst   (screen)
                        pso,                // psoSrc   (screen)
                        NULL,               // pco      (none)
                        NULL,               // pxlo     (none)
                        prclTrgTmp,         // prclDst
                        pptlSrcTmp);        // pptlSrc
        }
    }
    else
    {
        // we don't need to break it up at all

        cx = prclSrc->right - prclSrc->left;
        cy = prclSrc->bottom - prclSrc->top;

        ASSERTVGA(cx != 0, "DrvSaveScreenBits: vCopyRects (save width == 0)\n");
        ASSERTVGA(cy != 0, "DrvSaveScreenBits: vCopyRects (save height == 0)\n");

        rclOffScreen.left   = prclTrg->left;
        rclOffScreen.right  = prclTrg->left + cx;
        rclOffScreen.top    = prclTrg->top;
        rclOffScreen.bottom = prclTrg->top + cy;

        // align offscreen rect to src

        rclOffScreen.left += cAlign;
        rclOffScreen.right += cAlign;

        if (bIsSave)
        {
            // save
            pptlSrcTmp = (POINTL *) prclSrc;
            prclTrgTmp = &rclOffScreen;

            DISPDBG((1,"DrvSaveScreenBits (save):    "));
        }
        else
        {
            // restore
            pptlSrcTmp = (POINTL *) &rclOffScreen;
            prclTrgTmp = prclSrc;

            DISPDBG((1,"DrvSaveScreenBits (restore): "));
        }

        DISPDBG((1,"%08x,%08x,%08x,%08x    %lux%lu\n",
                rclOffScreen.left,
                rclOffScreen.top,
                rclOffScreen.right,
                rclOffScreen.bottom,
                rclOffScreen.right - rclOffScreen.left,
                rclOffScreen.bottom - rclOffScreen.top
                ));

        ASSERTVGA (((prclTrgTmp->left ^ pptlSrcTmp->x) &
                    (PELS_PER_DWORD - 1)) == 0,
                   "DrvSaveScreenBits: Src and Target are not aligned\n");

        DrvCopyBits(pso,                // psoDst   (screen)
                    pso,                // psoSrc   (screen)
                    NULL,               // pco      (none)
                    NULL,               // pxlo     (none)
                    prclTrgTmp,         // prclDst
                    pptlSrcTmp);        // pptlSrc
    }

    return;
}


/******************************Public*Routine******************************\
* ulSaveOrRestoreBits(pso, ppdev,prcl,bIsSave)                             *
*                                                                          *
* Saves or restores the specified area of the screen                       *
*                                                                          *
\**************************************************************************/

ULONG ulSaveOrRestoreBits(SURFOBJ *pso, PPDEV ppdev, RECTL * prcl, BOOL bIsSave)
{
    ULONG dxDstBottom, dyDstBottom; // width, height of bottom edge off screen area
    ULONG dxDstRight, dyDstRight;   // width, height of right edge off screen area
    ULONG dxSrc,  dySrc;            // width, height of screen area to copy
    RECTL rclSrcRight;              // portion of *prcl to go into right edge area
    RECTL rclSrcBottom;             // portion of *prcl to go into bottom edge area
    ULONG dxPadBottom;              // width of spacer required to keep all copies
                                    //   after the first aligned in the bottom
                                    //   rectangle
    //
    // Saves bits from visible VGA memory in unused VGA memory
    //

    dxDstBottom = ppdev->rclSavedBitsBottom.right - ppdev->rclSavedBitsBottom.left;
    dyDstBottom = ppdev->rclSavedBitsBottom.bottom - ppdev->rclSavedBitsBottom.top;
    dxDstRight  = ppdev->rclSavedBitsRight.right - ppdev->rclSavedBitsRight.left;
    dyDstRight  = ppdev->rclSavedBitsRight.bottom - ppdev->rclSavedBitsRight.top;
    dxSrc       = prcl->right - prcl->left;
    dySrc       = prcl->bottom - prcl->top;

    // see if rect fits in lower rect, unbroken
    // this is the most common case!

    if (dySrc <= dyDstBottom  && dxSrc <= dxDstBottom)
    {
        // YES!

        DISPDBG((1,"DrvSaveScreenBits: bits all fit into bottom rect\n"));
        vCopyRects(pso,
                   ppdev,
                   prcl,
                   &ppdev->rclSavedBitsBottom,
                   0,
                   bIsSave);
        return(SAVED_OFFSCREEN_ID);
    }

    // see if rect fits in right rect, unbroken

    if (dySrc <= dyDstRight && dxSrc <= dxDstRight)
    {
        // YES!

        DISPDBG((1,"DrvSaveScreenBits: bits all fit into right rect\n"));
        vCopyRects(pso,
                   ppdev,
                   prcl,
                   &ppdev->rclSavedBitsRight,
                   0,
                   bIsSave);
        return(SAVED_OFFSCREEN_ID);
    }

    //
    // before we bother to break it up, see if it could even POSSIBLY fit
    //

    if ((dxSrc * dySrc) > ((dxDstRight * dyDstRight) + (dxDstBottom * dyDstBottom)))
    {
        // Forget it bud.  There are more bytes to save than we have total.
        // Don't bother checking for best fit.

        return(0);
    }

    // ARGGGHHHH!

    //
    // split source rectangle into two rectangles and see if they fit
    //

    rclSrcRight = rclSrcBottom = *prcl;

    //
    // see how many strips of height dySrc we can get into the rclDstRight
    // (of height dyDstRight) and then divide the rclSrc rectangles so
    // that rclSrcRight has that many strips and rclSrcBottom has what's left
    //
    rclSrcBottom.left = rclSrcRight.right =
        min(rclSrcBottom.right,
            rclSrcRight.left + (LONG)(dxDstRight * (dyDstRight/dySrc)));

    //
    // FYI: rclSrcRight WILL fit into ppdev->rclSavedBitsBottom because that's
    //      how its size was determined
    //

    // dxPadBottom = (-x) & (PELS_PER_DWORD - 1) where x is the width of
    // the rectangle that we want to break up and put into the bottom offscreen
    // area.  Therefore, ((rclSrcBottom.right-rclSrcBottom.left)+dxPadBottom)
    // will be a number of pels that is a DWORD multiple.

    dxPadBottom = (rclSrcBottom.left-rclSrcBottom.right) & (PELS_PER_DWORD - 1);

    if (((rclSrcBottom.right-rclSrcBottom.left) == 0) ||
        ((dySrc/dyDstBottom) <
         (dxDstBottom/((rclSrcBottom.right-rclSrcBottom.left)+dxPadBottom))))
    {
        //
        // rclSrcBottom fits into ppdev->rclSavedBitsBottom
        //

        if ((rclSrcRight.right - rclSrcRight.left) > 0)
        {
            //
            // there is data that should go into the right edge area
            //

            vCopyRects(pso,
                       ppdev,
                       &rclSrcRight,
                       &ppdev->rclSavedBitsRight,
                       0,
                       bIsSave);
        }

        if (((rclSrcBottom.right - rclSrcBottom.left) > 0) &&
            ((rclSrcBottom.bottom - rclSrcBottom.top) > 0))
        {
            //
            // there is data that should go into the bottom area
            //

            vCopyRects(pso,
                       ppdev,
                       &rclSrcBottom,
                       &ppdev->rclSavedBitsBottom,
                       dxPadBottom,
                       bIsSave);
        }

        return(SAVED_OFFSCREEN_ID);

    }

    // All that @#!&ing work, and we just barely missed fitting in.

    return(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\vga\disp\8bpp\i386\egavga.inc ===
page    ,132
;-----------------------------Module-Header-----------------------------;
; Module Name:	EGAVGA.INC
;
; This file contains the external definitions of the EGA/VGA specific
; locations which driver output routines need to reference.
;
; Copyright (c) 1992 Microsoft Corporation
;-----------------------------------------------------------------------;
; Restrictions:
;
;	The following rules apply to the use of the EGA/VGA registers
;	for the drivers (excluding pointer code and state detection
;	code):
;
;
;	1)  Routines are allowed to alter the following registers:
;
;	    Sequencer:
;
;		SEQ_DATA		SEQ_MAP_MASK
;
;	    Graphics Controller:
;
;		GRAF_ADDR
;		GRAF_DATA		GRAF_DATA_ROT
;		GRAF_SET_RESET		GRAF_READ_MAP
;		GRAF_ENAB_SR		GRAF_MODE
;		GRAF_COL_COMP		GRAF_BIT_MASK
;
;
;	2)  The following registers will always contain the indicated
;	    value.  Routines are not allowed to alter them:
;
;	    Sequencer:
;
;		SEQ_ADDR	set to point SEQ_MAP_MASK
;
;	    Graphics Controller:
;
;		GRAF_CDC	set appropriately for color model
;
;
;	3)  Rotation counts for GRAF_DATA_ROT are not allowed.
;
;
;	4)  The following EGA/VGA registers will contain the indicated
;	    value upon entry to a routine.  Any routine which alters
;	    them must restore them to the indicated state.
;
;		Map Mask	    all planes enabled
;		Enable Set/Reset    all planes disabled
;		Data Rotate	    Set, no rotation
;		Mode		    Processor write, data read
;		Bit Mask	    all bits enabled
;
;
;	5)  The Mode Register is always shadowed in EGA/VGA memory for
;	    the state detection code.  At interrupt time, the mode
;	    will be restored from the structure "shadowed_graf_mode".
;	    Any routine altering the Mode Register must keep this location
;	    current.  This is the only EGA/VGA register which requires
;	    shadowing.
;
;
;	6)  Pointer drawing will save and restore the contents of
;	    the processor latches.
;
;
;	7)  Pointer drawing will leave GRAF_ADDR set to GRAF_BIT_MASK.
;
;-----------------------------------------------------------------------;

;	Miscellaneous Registers used only at EGA/VGA initialization time

MISC_OUTPUT	EQU	0C2h		;Miscellaneous Output Register
CRTC_ADDR	EQU	0D4h		;CRTC Address Register for color mode
CRTC_DATA	EQU	0D5h		;CRTC Data    Register for color mode
GRAF_1_POS	EQU	0CCh		;Graphics 1 Address Register
GRAF_2_POS	EQU	0CAh		;Graphics 2 Address Register
ATTR_READ	EQU	0DAh		;Attribute Controler Read  Address
ATTR_WRITE	EQU	0C0h		;Attribute Controler Write Address
IN_STAT_0	EQU	0C2h		;Input Status Register 0
IN_STAT_1	EQU	0DAh		;Input Status Register 1



;	EGA/VGA Register Definitions.
;
;	The following definitions are the EGA/VGA registers and values
;	used by this driver.  All other registers are set up at
;	when the EGA/VGA is placed into graphics mode and never altered
;	afterwards.
;
;	All unspecified bits in the following registers must be 0.


EGA_BASE	EQU	300h		;Base address of the EGA (3xx)
VGA_BASE	EQU	300h		;Base address of the VGA (3xx)



;	EGA/VGA Register Definitions.

EGA_BASE	EQU	300h		;Base address of the EGA (3xx)
VGA_BASE	EQU	300h		;Base address of the VGA (3xx)

;	SEQUencer Registers Used

SEQ_ADDR	EQU	0C4h		;SEQUencer Address Register
SEQ_DATA	EQU	0C5h		;SEQUencer Data    Register

SEQ_MAP_MASK	EQU	02h		;Write Plane Enable Mask
MM_C0		EQU	00000001b	;  C0 plane enable
MM_C1		EQU	00000010b	;  C1 plane enable
MM_C2		EQU	00000100b	;  C2 plane enable
MM_C3		EQU	00001000b	;  C3 plane enable
MM_ALL		EQU	00001111b	;  All planes

SEQ_MODE	EQU	04h		;Memory Mode
SM_ALPHA	EQU	00000001b	;  Char map select enable
SM_EXTENDED	EQU	00000010b	;  Extended memory present
SM_ODD_PLANE	EQU	00000100b	;  Odd/even bytes to same plane


;	Graphics Controller Registers Used

GRAF_ADDR	EQU	0CEh		;Graphics Controller Address Register
GRAF_DATA	EQU	0CFh		;Graphics Controller Data    Register

GRAF_SET_RESET	EQU	00h		;  Set/Reset Plane Color
GRAF_ENAB_SR	EQU	01h		;  Set/Reset Enable
GRAF_COL_COMP	EQU	02h		;  Color Compare Register

GRAF_DATA_ROT	EQU	03h		;  Data Rotate Register
DR_ROT_CNT	EQU	00000111b	;    Data Rotate Count
DR_SET		EQU	00000000b	;    Data Unmodified
DR_AND		EQU	00001000b	;    Data ANDed with latches
DR_OR		EQU	00010000b	;    Data ORed	with latches
DR_XOR		EQU	00011000b	;    Data XORed with latches

GRAF_READ_MAP	EQU	04h		;  Read Map Select Register
RM_C0		EQU	00000000b	;    Read C0 plane
RM_C1		EQU	00000001b	;    Read C1 plane
RM_C2		EQU	00000010b	;    Read C2 plane
RM_C3		EQU	00000011b	;    Read C3 plane

GRAF_MODE	EQU	05h		;  Mode Register
M_PROC_WRITE	EQU	00000000b	;    Write processor data rotated
M_LATCH_WRITE	EQU	00000001b	;    Write latched data
M_COLOR_WRITE	EQU	00000010b	;    Write processor data as color
M_AND_WRITE	EQU	00000011b	;    Write (procdata AND bitmask)
M_DATA_READ	EQU	00000000b	;    Read selected plane
M_COLOR_READ	EQU	00001000b	;    Read color compare

GRAF_MISC	EQU	06h		;  Miscellaneous Register
MS_NON_ALPHA	EQU	00000001b	;    Char generator disabled
MS_ODD_EVEN	EQU	00000010b	;    Map odd addresses to even
MS_A0000_128K	EQU	00000000b	;    Memory present at A0000, 128kb
MS_A0000_64K	EQU	00000100b	;    Memory present at A0000, 64kb
MS_B0000_32K	EQU	00001000b	;    Memory present at B0000, 32kb
MS_B8000_32K	EQU	00001100b	;    Memory present at B8000, 32kb
MS_ADDR_MASK	EQU	00001100b

GRAF_CDC	EQU	07h		;  Color Don't Care Register
GRAF_BIT_MASK	EQU	08h		;  Bit Mask Register


;       Various sizes for EGA/VGA data structures

;-----------------------------------------------------------------------;
; On the EGA/VGA, the number of bits/pel is 4
; The number of bytes per scan is 80
;-----------------------------------------------------------------------;

BITS_PEL        EQU     4

;-----------------------------------------------------------------------;
; Helper flags for the xyCreateMasks call
;-----------------------------------------------------------------------;

PTRI_INVERT     EQU     1   ; !!! In WINGDIP.H when H2INC works
PTRI_ANIMATE    EQU     2   ; !!! In WINGDIP.H when H2INC works

;-----------------------------------------------------------------------;
; The pointer parameters are the size of the pointer as received from
; DeviceSetCursor.
;-----------------------------------------------------------------------;

PTR_HEIGHT	EQU	32
PTR_WIDTH	EQU	4			;Width in bytes of pointer
PTR_WIDTH_BITS	EQU	PTR_WIDTH*8		;Width in bits of pointer

;-----------------------------------------------------------------------;
; The work width/height is the size of a pointer as manipulated by
; the pointer drawing code.
;-----------------------------------------------------------------------;

WORK_WIDTH	EQU	PTR_WIDTH+1		;Width of mask, work area
WORK_HEIGHT	EQU	PTR_HEIGHT+0		;Height of mask, work area
MASK_LENGTH	EQU	WORK_WIDTH*WORK_HEIGHT	;#bytes in mask, work area
CLR_MASK_LENGTH	EQU	WORK_WIDTH*WORK_HEIGHT*BITS_PEL	;#bytes in color mask
	.errnz	BITS_PEL-4

;-----------------------------------------------------------------------;
; The save area parameters control the size of the buffer used for
; saveing the bits underneath the pointer image.  It should be a
; power of two to allow for easy wrap calculations.
;-----------------------------------------------------------------------;

SAVE_BUFFER_WIDTH  EQU	  8			  ;Width  of the save area
SAVE_BUFFER_HEIGHT EQU	  32			  ;Height of the save area
		   .errnz  PTR_WIDTH  GT SAVE_BUFFER_WIDTH
		   .errnz  PTR_HEIGHT GT SAVE_BUFFER_HEIGHT



=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\vga\disp\8bpp\stretch.c ===
/******************************Module*Header*******************************\
* Module Name: stretch.c
*
* DrvStretchBlt
*
* Copyright (c) 1993 Microsoft Corporation
\**************************************************************************/

#include "driver.h"

//@@@ This should become a VOID when all cases are handled in the stretching
//@@@ code, and should go in driver.h
INT vStretchBlt8bpp(PPDEV ppdev, PBYTE pSrc, LONG lSrcNext,
                    PRECTL prclSrc, PRECTL prclDest, PRECTL prclDestClip,
                    PULONG pulXlatVector);

BOOL DrvStretchBlt(
SURFOBJ         *psoDest,
SURFOBJ         *psoSrc,
SURFOBJ         *psoMask,
CLIPOBJ         *pco,
XLATEOBJ        *pxlo,
COLORADJUSTMENT *pca,
POINTL          *pptlBrushOrg,
RECTL           *prclDest,
RECTL           *prclSrc,
POINTL          *pptlMask,
ULONG            iMode)
{
    PPDEV  ppdev = (PPDEV) psoDest->dhpdev;
    PULONG pulXlatVector;
    INT    iClipping;

    // Handle only cases where the source is a DIB and the destination is
    // the VGA surface (which is always the case here if the source is a
    // DIB). Also, halftoning and masking aren't handled by the special-case
    // code. We only handle the case where a single source pixel is mapped onto
    // each destination pixel
    if ((iMode == COLORONCOLOR) &&
        (psoSrc->iType == STYPE_BITMAP) &&
        (psoMask == NULL)) {

        // We don't special case X or Y inversion for now
        if ((prclDest->left < prclDest->right) &&
            (prclDest->top < prclDest->bottom)) {

            // We don't special-case cases where the source has to be clipped
            // to the source bitmap extent
            if ((prclSrc->left >= 0) &&
                (prclSrc->top >= 0)  &&
                (prclSrc->right <= psoSrc->sizlBitmap.cx) &&
                (prclSrc->bottom <= psoSrc->sizlBitmap.cy)) {

                // Set up the clipping type
                if (pco == (CLIPOBJ *) NULL) {
                    // No CLIPOBJ provided, so we don't have to worry about
                    // clipping
                    iClipping = DC_TRIVIAL;
                } else {
                    // Use the CLIPOBJ-provided clipping
                    iClipping = pco->iDComplexity;
                }

                // We don't special-case clipping for now
                if (iClipping != DC_COMPLEX) {

                    switch(psoSrc->iBitmapFormat) {
                        case BMF_1BPP:
                            break;

                        case BMF_4BPP:
                            break;

                        case BMF_8BPP:

                            // Set up the color translation, if any
                            if ((pxlo == NULL) ||
                                    (pxlo->flXlate & XO_TRIVIAL)) {
                                pulXlatVector = NULL;
                            } else {
                                if (pxlo->pulXlate != NULL) {
                                    pulXlatVector = pxlo->pulXlate;
                                } else {
                                    if ((pulXlatVector =
                                            XLATEOBJ_piVector(pxlo)) == NULL) {
                                        return FALSE;
                                    }
                                }
                            }

                            //if the Dest is wider than 1024, it won't fit
                            //into our 4K global buffer.  For each pixel across,
                            //we store a 4 byte DDA step in the buffer.

                            if ((prclDest->right - prclDest->left) <=
                                (GLOBAL_BUFFER_SIZE/sizeof(DWORD)))
                            {
                                //@@@ won't need to test return code once both
                                //@@@ expand cases are also handled in the
                                //@@@ stretching code

                                if (vStretchBlt8bpp(ppdev,
                                                    psoSrc->pvScan0,
                                                    psoSrc->lDelta,
                                                    prclSrc,
                                                    prclDest,
                                                    (iClipping == DC_TRIVIAL) ?
                                                     NULL :
                                                     &pco->rclBounds,
                                                    pulXlatVector))
                                {
                                    return(TRUE);
                                }
                            }
                            break;

                        case BMF_16BPP:
                            break;

                        case BMF_24BPP:
                            break;

                        case BMF_32BPP:
                            break;

                        default:
                            break;
                    }
                }
            }
        }
    }

    return(EngStretchBlt(psoDest,
                         psoSrc,
                         psoMask,
                         pco,
                         pxlo,
                         pca,
                         pptlBrushOrg,
                         prclDest,
                         prclSrc,
                         pptlMask,
                         iMode));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\vga\disp\8bpp\textout.c ===
/******************************Module*Header*******************************\
* Module Name: TextOut.c
*
* Text
*
* Copyright (c) 1992 Microsoft Corporation
*
\**************************************************************************/

#include "driver.h"

BOOL vFastText(PDEV *, GLYPHPOS *, ULONG, PBYTE, ULONG, ULONG, RECTL *,
    RECTL *, INT, INT, ULONG);
VOID lclFillRect(CLIPOBJ *, ULONG, PRECTL, PPDEV, INT);


#define     FIFTEEN_BITS        ((1 << 15)-1)

#define     TAKING_ALLOC_STATS      0

#if TAKING_ALLOC_STATS
    ULONG BufferHitInText = 0;
    ULONG BufferMissInText = 0;
#endif

/****************************************************************************
 * DrvTextOut
 ***************************************************************************/

BOOL DrvTextOut(
    SURFOBJ*  pso,
    STROBJ*   pstro,
    FONTOBJ*  pfo,
    CLIPOBJ*  pco,
    RECTL*    prclExtra,
    RECTL*    prclOpaque,
    BRUSHOBJ* pboFore,
    BRUSHOBJ* pboOpaque,
    POINTL*   pptlOrg,
    MIX       mix)
{
    BOOL    b;
    PPDEV   ppdev;
    INT     iClip;              // clip object's complexity
    ULONG   iSolidForeColor;    // Solid foreground color
    ULONG   iSolidBkColor;      // Solid background color
    RECTL   arclTmp[4];         // Temp storage for portions of opaquing rect
    ULONG   culRcl;             // Temp rectangle count
    PVOID   pvBuf;              // pointer to buffer we'll use

    ULONG   ulBufferWidthInBytes;
    ULONG   ulBufferHeight;
    ULONG   ulBufferBytes;
    BOOL    bTextPerfectFit;
    ULONG   fDrawFlags;


    ppdev = (PPDEV) pso->dhpdev;


    //---------------------------------------------------------------------
    // Get information about clip object.
    //---------------------------------------------------------------------

    iClip = DC_TRIVIAL;

    if (pco != NULL) {
        iClip = pco->iDComplexity;
    }

    //---------------------------------------------------------------------
    // Get text color.
    //---------------------------------------------------------------------

    iSolidForeColor = pboFore->iSolidColor;

    //---------------------------------------------------------------------
    // See if this is text we can handle faster with special-case code.
    //---------------------------------------------------------------------

    if (((ppdev->fl & DRIVER_PLANAR_CAPABLE) ||
        (prclOpaque == (PRECTL) NULL)) &&   // opaque only if planar for now
                                            // LATER implement fast non-planar
                                            // opaque
        (iClip == DC_TRIVIAL) &&            // no clipping for now
            ((pstro->rclBkGround.right & ~0x03) >
             ((pstro->rclBkGround.left + 3) & ~0x03)) &&
                                            // not if no full nibbles spanned
                                            //  for now @@@
            (pstro->pgp != NULL) &&         // no glyph enumeration for now
            (prclExtra == NULL) &&          // no extra rects for now
            ((pstro->flAccel & (SO_HORIZONTAL | SO_VERTICAL | SO_REVERSED)) ==
             SO_HORIZONTAL)) {              // only left-to-right text for now

        // It's the type of text we can special-case; see if the temp buffer is
        // big enough for the text.

        ulBufferWidthInBytes = ((((pstro->rclBkGround.right + 7) & ~0x07) -
                (pstro->rclBkGround.left & ~0x07)) >> 3);

        ulBufferHeight = pstro->rclBkGround.bottom - pstro->rclBkGround.top;

        ulBufferBytes = ulBufferWidthInBytes * ulBufferHeight;

        if ((ulBufferWidthInBytes > FIFTEEN_BITS) ||
            (ulBufferHeight > FIFTEEN_BITS))
        {
            // the math will have overflowed
            return(FALSE);
        }

        if (ulBufferBytes <= GLOBAL_BUFFER_SIZE)
        {
#if TAKING_ALLOC_STATS
            BufferHitInText++;
#endif
            pvBuf = ppdev->pvTmpBuf;
        }
        else
        {
#if TAKING_ALLOC_STATS
            BufferMissInText++;
#endif
            pvBuf = EngAllocUserMem(ulBufferBytes, ALLOC_TAG);
            if (!pvBuf)
            {
                goto no_special_case;
            }
        }

        // It's big enough; set up for the accelerator

        // Set fixed pitch, overlap, and top & bottom Y alignment flags
        fDrawFlags = ((pstro->ulCharInc != 0) ? 0x01 : 0) |
                     (((pstro->flAccel & (SO_ZERO_BEARINGS |
                      SO_FLAG_DEFAULT_PLACEMENT)) !=
                      (SO_ZERO_BEARINGS | SO_FLAG_DEFAULT_PLACEMENT))
                      ? 0x02 : 0) |
                     (((pstro->flAccel & (SO_ZERO_BEARINGS |
                      SO_FLAG_DEFAULT_PLACEMENT |
                      SO_MAXEXT_EQUAL_BM_SIDE)) ==
                      (SO_ZERO_BEARINGS | SO_FLAG_DEFAULT_PLACEMENT |
                      SO_MAXEXT_EQUAL_BM_SIDE)) ? 0x04 : 0);

        // If there's an opaque rectangle, we'll do as much opaquing as
        // possible as we do the text. If the opaque rectangle is larger
        // than the text rectangle, then we'll do the fringe areas right
        // now, and the text and associated background areas together,
        // later.
        if (prclOpaque != (PRECTL) NULL) {

            // This driver only handles solid brushes
            iSolidBkColor = pboOpaque->iSolidColor;

            // See if we have fringe areas to do. If so, build a list of
            // rectangles to fill, in rightdown order

            culRcl = 0;

            // Top fragment
            if (pstro->rclBkGround.top > prclOpaque->top) {
                arclTmp[culRcl].top = prclOpaque->top;
                arclTmp[culRcl].left = prclOpaque->left;
                arclTmp[culRcl].right = prclOpaque->right;
                arclTmp[culRcl++].bottom = pstro->rclBkGround.top;
            }

            // Left fragment
            if (pstro->rclBkGround.left > prclOpaque->left) {
                arclTmp[culRcl].top = pstro->rclBkGround.top;
                arclTmp[culRcl].left = prclOpaque->left;
                arclTmp[culRcl].right = pstro->rclBkGround.left;
                arclTmp[culRcl++].bottom = pstro->rclBkGround.bottom;
            }

            // Right fragment
            if (pstro->rclBkGround.right < prclOpaque->right) {
                arclTmp[culRcl].top = pstro->rclBkGround.top;
                arclTmp[culRcl].right = prclOpaque->right;
                arclTmp[culRcl].left = pstro->rclBkGround.right;
                arclTmp[culRcl++].bottom = pstro->rclBkGround.bottom;
            }

            // Bottom fragment
            if (pstro->rclBkGround.bottom < prclOpaque->bottom) {
                arclTmp[culRcl].bottom = prclOpaque->bottom;
                arclTmp[culRcl].left = prclOpaque->left;
                arclTmp[culRcl].right = prclOpaque->right;
                arclTmp[culRcl++].top = pstro->rclBkGround.bottom;
            }

            if (culRcl != 0) {
                if (iClip == DC_TRIVIAL) {
                    vTrgBlt(ppdev, culRcl, arclTmp, R2_COPYPEN,
                            *((RBRUSH_COLOR*) &iSolidBkColor), NULL);
                } else {
                    lclFillRect(pco, culRcl, arclTmp, ppdev,
                                iSolidBkColor);
                }
            }
        }

        // We're done with separate opaquing; any further opaquing will
        // happen as part of the text drawing

        // Clear the buffer if the text isn't going to set every bit
        bTextPerfectFit = (pstro->flAccel & (SO_ZERO_BEARINGS |
                SO_FLAG_DEFAULT_PLACEMENT | SO_MAXEXT_EQUAL_BM_SIDE |
                SO_CHAR_INC_EQUAL_BM_BASE)) ==
                (SO_ZERO_BEARINGS | SO_FLAG_DEFAULT_PLACEMENT |
                SO_MAXEXT_EQUAL_BM_SIDE | SO_CHAR_INC_EQUAL_BM_BASE);

        if (!bTextPerfectFit) {
            vClearMemDword(pvBuf, (ulBufferBytes + 3) >> 2);
        }

        // Draw the text into the temp buffer, and thence to the screen
        vFastText(ppdev,
                  pstro->pgp,
                  pstro->cGlyphs,
                  pvBuf,
                  ulBufferWidthInBytes,
                  pstro->ulCharInc,
                  &pstro->rclBkGround,
                  prclOpaque,
                  iSolidForeColor,
                  iSolidBkColor,
                  fDrawFlags);

        // free any memory that was allocated
        if (ulBufferBytes > GLOBAL_BUFFER_SIZE)
        {
            // we had to have allocated memory
            EngFreeUserMem (pvBuf);
        }

        return(TRUE);
    }
no_special_case:

    // Can't special-case; let the engine draw the text

    pso = ppdev->pSurfObj;

    // It may be that the opaquing rectangle is larger than the text rectangle,
    // so we'll want to use that to tell the bank manager which banks to
    // enumerate:

    pco = pcoBankStart(ppdev,
                       (prclOpaque != NULL) ? prclOpaque : &pstro->rclBkGround,
                       pso,
                       pco);

    do {
        b = EngTextOut(pso,
                       pstro,
                       pfo,
                       pco,
                       prclExtra,
                       prclOpaque,
                       pboFore,
                       pboOpaque,
                       pptlOrg,
                       mix);

    } while (b && bBankEnum(ppdev, pso, pco));

    return(b);
}

//--------------------------------------------------------------------------
// Fills the specified rectangles on the specified surface with the
// specified color, honoring the requested clipping. No more than four
// rectangles should be passed in. Intended for drawing the areas of the
// opaquing rectangle that extended beyond the text box. The rectangles must
// be in left to right, top to bottom order. Assumes there is at least one
// rectangle in the list.
//--------------------------------------------------------------------------

VOID lclFillRect(
 CLIPOBJ *pco,
 ULONG culRcl,
 PRECTL prcl,
 PPDEV ppdev,
 INT iColor)
{
    BOOL  bMore;                  // Flag for clip enumeration
    TEXTENUM txen;                // Clip enumeration object
    ULONG i, j;
    RECTL arclTmp[4];
    ULONG culRclTmp;
    RECTL *prclTmp, *prclClipTmp;
    INT   iLastBottom;
    RECTL *pClipRcl;
    INT iClip;

    iClip = DC_TRIVIAL;

    if (pco != NULL) {
        iClip = pco->iDComplexity;
    }

    switch ( iClip ) {

        case DC_TRIVIAL:

            vTrgBlt(ppdev, culRcl, prcl, R2_COPYPEN,
                    *((RBRUSH_COLOR*) &iColor), NULL);

            break;

        case DC_RECT:

            prclTmp = &pco->rclBounds;

            // Generate a list of clipped rects
            for (culRclTmp=0, i=0; i<culRcl; i++, prcl++) {

                // Intersect fill and clip rectangles
                if (bIntersectRect(&arclTmp[culRclTmp], prcl, prclTmp)) {

                    // Add to list if anything's left to draw
                    culRclTmp++;
                }
            }

            // Draw the clipped rects
            if (culRclTmp != 0) {
                vTrgBlt(ppdev, culRclTmp, arclTmp, R2_COPYPEN,
                        *((RBRUSH_COLOR*) &iColor), NULL);
            }

            break;

        case DC_COMPLEX:

            // Bottom of last rectangle to fill
            iLastBottom = prcl[culRcl-1].bottom;

            // Initialize the clip rectangle enumeration to rightdown so we can
            // take advantage of the rectangle list being rightdown
            CLIPOBJ_cEnumStart(pco, FALSE, CT_RECTANGLES, CD_RIGHTDOWN,
                    TO_RECT_LIMIT);

            // Scan through all the clip rectangles, looking for intersects
            // of fill areas with region rectangles
            do {

                // Get a batch of region rectangles
                bMore = CLIPOBJ_bEnum(pco, (ULONG)sizeof(txen), (PVOID)&txen);

                // Clip the rect list to each region rect
                for (j = txen.c, pClipRcl = txen.arcl; j-- > 0; pClipRcl++) {

                    // Since the rectangles and the region enumeration are both
                    // rightdown, we can zip through the region until we reach
                    // the first fill rect, and are done when we've passed the
                    // last fill rect.

                    if (pClipRcl->top >= iLastBottom) {
                        // Past last fill rectangle; nothing left to do
                        return;
                    }

                    // Do intersection tests only if we've reached the top of
                    // the first rectangle to fill
                    if (pClipRcl->bottom > prcl->top) {

                        // We've reached the top Y scan of the first rect, so
                        // it's worth bothering checking for intersection

                        // Generate a list of the rects clipped to this region
                        // rect
                        prclTmp = prcl;
                        prclClipTmp = arclTmp;
                        for (i = culRcl, culRclTmp=0; i-- > 0; prclTmp++) {

                            // Intersect fill and clip rectangles
                            if (bIntersectRect(prclClipTmp, prclTmp,
                                    pClipRcl)) {

                                // Add to list if anything's left to draw
                                culRclTmp++;
                                prclClipTmp++;
                            }
                        }

                        // Draw the clipped rects
                        if (culRclTmp != 0) {
                            vTrgBlt(ppdev, culRclTmp, arclTmp, R2_COPYPEN,
                                    *((RBRUSH_COLOR*) &iColor), NULL);
                        }
                    }
                }
            } while (bMore);

            break;
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\vga\disp\8bpp\screen.c ===
/******************************Module*Header*******************************\
* Module Name: screen.c
*
* Initializes the GDIINFO and DEVINFO structures for DrvEnablePDEV.
*
* Copyright (c) 1992 Microsoft Corporation
\**************************************************************************/

#include "driver.h"


#define SYSTM_LOGFONT {16,7,0,0,700,0,0,0,ANSI_CHARSET,OUT_DEFAULT_PRECIS,  \
                       CLIP_DEFAULT_PRECIS,DEFAULT_QUALITY,VARIABLE_PITCH | \
                       FF_DONTCARE,L"System"}
#define HELVE_LOGFONT {12,9,0,0,400,0,0,0,ANSI_CHARSET,OUT_DEFAULT_PRECIS,  \
                       CLIP_STROKE_PRECIS,PROOF_QUALITY,VARIABLE_PITCH | \
                       FF_DONTCARE,L"MS Sans Serif"}
#define COURI_LOGFONT {12,9,0,0,400,0,0,0,ANSI_CHARSET,OUT_DEFAULT_PRECIS,  \
                       CLIP_STROKE_PRECIS,PROOF_QUALITY,FIXED_PITCH |    \
                       FF_DONTCARE, L"Courier"}

// This is the basic devinfo for a default driver.  This is used as a base and customized based
// on information passed back from the miniport driver.

const DEVINFO gDevInfoFrameBuffer = {
    (GCAPS_OPAQUERECT    | // Graphics capabilities
     GCAPS_PALMANAGED    |
     GCAPS_ALTERNATEFILL |
     GCAPS_WINDINGFILL   |
     GCAPS_MONO_DITHER   |
     GCAPS_COLOR_DITHER  ),

     // Should also implement GCAPS_HORIZSTRIKE so that the underlines
     // aren't drawn using DrvBitBlt

    SYSTM_LOGFONT,      // Default font description
    HELVE_LOGFONT,      // ANSI variable font description
    COURI_LOGFONT,      // ANSI fixed font description
    0,                  // Count of device fonts
    BMF_8BPP,           // Preferred DIB format
    8,                  // Width of color dither
    8,                  // Height of color dither
    0                   // Default palette to use for this device
};

/******************************Public*Routine******************************\
* bInitSURF
*
* Enables the surface.  Maps the frame buffer into memory.
*
\**************************************************************************/

BOOL bInitSURF(PPDEV ppdev, BOOL bFirst)
{
    VIDEO_MEMORY             VideoMemory;
    VIDEO_MEMORY_INFORMATION VideoMemoryInfo;
    DWORD                    ReturnedDataLength;

    // Set the mode.

    if (EngDeviceIoControl(ppdev->hDriver,
                         IOCTL_VIDEO_SET_CURRENT_MODE,
                         (LPVOID) &ppdev->ulMode,  // input buffer
                         sizeof(DWORD),
                         NULL,
                         0,
                         &ReturnedDataLength))
    {
        DISPDBG((0, "Failed SET_CURRENT_MODE\n"));
        return(FALSE);
    }

    if (bFirst)
    {
        // Get the linear memory address range.

        VideoMemory.RequestedVirtualAddress = NULL;

        if (EngDeviceIoControl(ppdev->hDriver,
                             IOCTL_VIDEO_MAP_VIDEO_MEMORY,
                             (PVOID) &VideoMemory, // input buffer
                             sizeof (VIDEO_MEMORY),
                             (PVOID) &VideoMemoryInfo, // output buffer
                             sizeof (VideoMemoryInfo),
                             &ReturnedDataLength))
        {
            DISPDBG((0, "Failed MAP_VIDEO_MEMORY\n"));
            return(FALSE);
        }
    }

    // Record the Frame Buffer Linear Address.

    if (bFirst)
    {
        ppdev->pjScreen =  (PBYTE) VideoMemoryInfo.FrameBufferBase;
    }

    // Set the various write mode values, so we don't have to read before write
    // later on

    vSetWriteModes(&ppdev->ulrm0_wmX);

    // Initialize the VGA registers to their default states, so that we
    // can be sure of drawing properly even when the miniport didn't
    // happen to set them the way we like them:

    vInitRegs(ppdev);

    // Since we just did a mode-set, we'll be in non-planar mode.  And make
    // sure we reset the bank manager (otherwise, after a switch from full-
    // screen, we may think we've got one bank mapped in, when in fact there's
    // a different one mapped in, and bad things would happen...).

    ppdev->flBank &= ~BANK_PLANAR;

    ppdev->rcl1WindowClip.bottom    = -1;
    ppdev->rcl2WindowClip[0].bottom = -1;
    ppdev->rcl2WindowClip[1].bottom = -1;

    ppdev->rcl1PlanarClip.bottom    = -1;
    ppdev->rcl2PlanarClip[0].bottom = -1;
    ppdev->rcl2PlanarClip[1].bottom = -1;

    return(TRUE);
}

/******************************Public*Routine******************************\
* vDisableSURF
*
* Disable the surface. Un-Maps the frame in memory.
*
\**************************************************************************/

VOID vDisableSURF(PPDEV ppdev)
{
    DWORD returnedDataLength;
    VIDEO_MEMORY videoMemory;

    videoMemory.RequestedVirtualAddress = (PVOID) ppdev->pjScreen;

    if (EngDeviceIoControl(ppdev->hDriver,
                        IOCTL_VIDEO_UNMAP_VIDEO_MEMORY,
                        (LPVOID) &videoMemory,
                        sizeof(VIDEO_MEMORY),
                        NULL,
                        0,
                        &returnedDataLength))
    {
        RIP("Failed UNMAP_VIDEO_MEMORY");
    }
}

/******************************Public*Routine******************************\
* bInitPDEV
*
* Determine the mode we should be in based on the DEVMODE passed in.
* Query mini-port to get information needed to fill in the DevInfo and the
* GdiInfo .
*
\**************************************************************************/

BOOL bInitPDEV(
PPDEV ppdev,
DEVMODEW *pDevMode,
GDIINFO *pGdiInfo,
DEVINFO *pDevInfo)
{
    ULONG cModes;
    PVIDEO_MODE_INFORMATION pVideoBuffer, pVideoModeSelected, pVideoTemp;
    VIDEO_COLOR_CAPABILITIES colorCapabilities;
    ULONG ulTemp;
    BOOL bSelectDefault;
    ULONG cbModeSize;
    BANK_POSITION BankPosition;
    ULONG ulReturn;

    //
    // calls the miniport to get mode information.
    //

    cModes = getAvailableModes(ppdev->hDriver, &pVideoBuffer, &cbModeSize);

    if (cModes == 0)
    {
        DISPDBG((0, "vga256.dll: no available modes\n"));
        return(FALSE);
    }

    //
    // Determine if we are looking for a default mode.
    //

    if ( ((pDevMode->dmPelsWidth) ||
          (pDevMode->dmPelsHeight) ||
          (pDevMode->dmBitsPerPel) ||
          (pDevMode->dmDisplayFlags) ||
          (pDevMode->dmDisplayFrequency)) == 0)
    {
        bSelectDefault = TRUE;
    }
    else
    {
        bSelectDefault = FALSE;
    }

    //
    // Now see if the requested mode has a match in that table.
    //

    pVideoModeSelected = NULL;
    pVideoTemp = pVideoBuffer;

    while (cModes--)
    {
        if (pVideoTemp->Length != 0)
        {
            if (bSelectDefault ||
                ((pVideoTemp->VisScreenWidth  == pDevMode->dmPelsWidth) &&
                 (pVideoTemp->VisScreenHeight == pDevMode->dmPelsHeight) &&
                 (pVideoTemp->BitsPerPlane *
                    pVideoTemp->NumberOfPlanes  == pDevMode->dmBitsPerPel) &&
                 (pVideoTemp->Frequency  == pDevMode->dmDisplayFrequency)))
            {
                pVideoModeSelected = pVideoTemp;
                DISPDBG((2, "vga256: Found a match\n")) ;
                break;
            }
        }

        pVideoTemp = (PVIDEO_MODE_INFORMATION)
            (((PUCHAR)pVideoTemp) + cbModeSize);
    }

    //
    // If no mode has been found, return an error
    //

    if (pVideoModeSelected == NULL)
    {
        DISPDBG((0, "vga256.dll: no valid modes\n"));
        EngFreeMem(pVideoBuffer);
        return(FALSE);
    }

    //
    // Fill in the GDIINFO data structure with the information returned from
    // the kernel driver.
    //

    ppdev->ulMode = pVideoModeSelected->ModeIndex;
    ppdev->cxScreen = pVideoModeSelected->VisScreenWidth;
    ppdev->cyScreen = pVideoModeSelected->VisScreenHeight;
    ppdev->ulBitCount = pVideoModeSelected->BitsPerPlane *
                        pVideoModeSelected->NumberOfPlanes;
    ppdev->lDeltaScreen = pVideoModeSelected->ScreenStride;

    ppdev->flRed = pVideoModeSelected->RedMask;
    ppdev->flGreen = pVideoModeSelected->GreenMask;
    ppdev->flBlue = pVideoModeSelected->BlueMask;

    if (!(pVideoModeSelected->AttributeFlags & VIDEO_MODE_NO_OFF_SCREEN))
    {
        ppdev->fl |= DRIVER_OFFSCREEN_REFRESHED;
    }

    pGdiInfo->ulVersion    = GDI_DRIVER_VERSION;
    pGdiInfo->ulTechnology = DT_RASDISPLAY;
    pGdiInfo->ulHorzSize   = pVideoModeSelected->XMillimeter;
    pGdiInfo->ulVertSize   = pVideoModeSelected->YMillimeter;

    pGdiInfo->ulHorzRes        = ppdev->cxScreen;
    pGdiInfo->ulVertRes        = ppdev->cyScreen;
    pGdiInfo->ulPanningHorzRes = ppdev->cxScreen;
    pGdiInfo->ulPanningVertRes = ppdev->cyScreen;
    pGdiInfo->cBitsPixel       = pVideoModeSelected->BitsPerPlane;
    pGdiInfo->cPlanes          = pVideoModeSelected->NumberOfPlanes;
    pGdiInfo->ulVRefresh       = pVideoModeSelected->Frequency;
    pGdiInfo->ulBltAlignment   = 8;     // Prefer 8-pel alignment of windows
                                        //   for fast text routines

    pGdiInfo->ulLogPixelsX = pDevMode->dmLogPixels;
    pGdiInfo->ulLogPixelsY = pDevMode->dmLogPixels;

    pGdiInfo->flTextCaps   = TC_RA_ABLE | TC_SCROLLBLT;
    pGdiInfo->flRaster     = 0;         // DDI reservers flRaster

    pGdiInfo->ulDACRed     = pVideoModeSelected->NumberRedBits;
    pGdiInfo->ulDACGreen   = pVideoModeSelected->NumberGreenBits;
    pGdiInfo->ulDACBlue    = pVideoModeSelected->NumberBlueBits;

    // Assuming palette is orthogonal - all colors are same size.

    ppdev->cPaletteShift   = 8 - pGdiInfo->ulDACRed;

    pGdiInfo->ulAspectX    = 0x24;      // One-to-one aspect ratio
    pGdiInfo->ulAspectY    = 0x24;
    pGdiInfo->ulAspectXY   = 0x33;

    pGdiInfo->xStyleStep   = 1;         // A style unit is 3 pels
    pGdiInfo->yStyleStep   = 1;
    pGdiInfo->denStyleStep = 3;

    pGdiInfo->ptlPhysOffset.x = 0;
    pGdiInfo->ptlPhysOffset.y = 0;
    pGdiInfo->szlPhysSize.cx  = 0;
    pGdiInfo->szlPhysSize.cy  = 0;

    // RGB and CMY color info.

    // try to get it from the miniport.
    // if the miniport doesn ot support this feature, use defaults.

    if (EngDeviceIoControl(ppdev->hDriver,
                         IOCTL_VIDEO_QUERY_COLOR_CAPABILITIES,
                         NULL,
                         0,
                         &colorCapabilities,
                         sizeof(VIDEO_COLOR_CAPABILITIES),
                         &ulTemp))
    {
        DISPDBG((1, "vga256 DISP getcolorCapabilities failed \n"));

        pGdiInfo->ciDevice.Red.x = 6700;
        pGdiInfo->ciDevice.Red.y = 3300;
        pGdiInfo->ciDevice.Red.Y = 0;
        pGdiInfo->ciDevice.Green.x = 2100;
        pGdiInfo->ciDevice.Green.y = 7100;
        pGdiInfo->ciDevice.Green.Y = 0;
        pGdiInfo->ciDevice.Blue.x = 1400;
        pGdiInfo->ciDevice.Blue.y = 800;
        pGdiInfo->ciDevice.Blue.Y = 0;
        pGdiInfo->ciDevice.AlignmentWhite.x = 3127;
        pGdiInfo->ciDevice.AlignmentWhite.y = 3290;
        pGdiInfo->ciDevice.AlignmentWhite.Y = 0;

        pGdiInfo->ciDevice.RedGamma = 20000;
        pGdiInfo->ciDevice.GreenGamma = 20000;
        pGdiInfo->ciDevice.BlueGamma = 20000;

    }
    else
    {

        pGdiInfo->ciDevice.Red.x = colorCapabilities.RedChromaticity_x;
        pGdiInfo->ciDevice.Red.y = colorCapabilities.RedChromaticity_y;
        pGdiInfo->ciDevice.Red.Y = 0;
        pGdiInfo->ciDevice.Green.x = colorCapabilities.GreenChromaticity_x;
        pGdiInfo->ciDevice.Green.y = colorCapabilities.GreenChromaticity_y;
        pGdiInfo->ciDevice.Green.Y = 0;
        pGdiInfo->ciDevice.Blue.x = colorCapabilities.BlueChromaticity_x;
        pGdiInfo->ciDevice.Blue.y = colorCapabilities.BlueChromaticity_y;
        pGdiInfo->ciDevice.Blue.Y = 0;
        pGdiInfo->ciDevice.AlignmentWhite.x = colorCapabilities.WhiteChromaticity_x;
        pGdiInfo->ciDevice.AlignmentWhite.y = colorCapabilities.WhiteChromaticity_y;
        pGdiInfo->ciDevice.AlignmentWhite.Y = colorCapabilities.WhiteChromaticity_Y;

        // if we have a color device store the three color gamma values,
        // otherwise store the unique gamma value in all three.

        if (colorCapabilities.AttributeFlags & VIDEO_DEVICE_COLOR)
        {
            pGdiInfo->ciDevice.RedGamma = colorCapabilities.RedGamma;
            pGdiInfo->ciDevice.GreenGamma = colorCapabilities.GreenGamma;
            pGdiInfo->ciDevice.BlueGamma = colorCapabilities.BlueGamma;
        }
        else
        {
            pGdiInfo->ciDevice.RedGamma = colorCapabilities.WhiteGamma;
            pGdiInfo->ciDevice.GreenGamma = colorCapabilities.WhiteGamma;
            pGdiInfo->ciDevice.BlueGamma = colorCapabilities.WhiteGamma;
        }

    };

    pGdiInfo->ciDevice.Cyan.x = 0;
    pGdiInfo->ciDevice.Cyan.y = 0;
    pGdiInfo->ciDevice.Cyan.Y = 0;
    pGdiInfo->ciDevice.Magenta.x = 0;
    pGdiInfo->ciDevice.Magenta.y = 0;
    pGdiInfo->ciDevice.Magenta.Y = 0;
    pGdiInfo->ciDevice.Yellow.x = 0;
    pGdiInfo->ciDevice.Yellow.y = 0;
    pGdiInfo->ciDevice.Yellow.Y = 0;

    // No dye correction for raster displays.

    pGdiInfo->ciDevice.MagentaInCyanDye = 0;
    pGdiInfo->ciDevice.YellowInCyanDye = 0;
    pGdiInfo->ciDevice.CyanInMagentaDye = 0;
    pGdiInfo->ciDevice.YellowInMagentaDye = 0;
    pGdiInfo->ciDevice.CyanInYellowDye = 0;
    pGdiInfo->ciDevice.MagentaInYellowDye = 0;

    // Fill in the rest of the devinfo and GdiInfo structures.

    pGdiInfo->ulNumColors = 20;
    pGdiInfo->ulNumPalReg = 1 << ppdev->ulBitCount;

    pGdiInfo->ulDevicePelsDPI  = 0;   // For printers only
    pGdiInfo->ulPrimaryOrder   = PRIMARY_ORDER_CBA;
    pGdiInfo->ulHTPatternSize  = HT_PATSIZE_4x4_M;
    pGdiInfo->ulHTOutputFormat = HT_FORMAT_8BPP;
    pGdiInfo->flHTFlags        = HT_FLAG_ADDITIVE_PRIMS;

    // Fill in the basic devinfo structure

    *pDevInfo = gDevInfoFrameBuffer;

    EngFreeMem(pVideoBuffer);

    //
    // Try to determine if the miniport supports
    // IOCTL_VIDEO_SET_BANK_POSITION.
    //

    BankPosition.ReadBankPosition = 0;
    BankPosition.WriteBankPosition = 0;

    if (EngDeviceIoControl(ppdev->hDriver,
                         IOCTL_VIDEO_SET_BANK_POSITION,
                         &BankPosition,
                         sizeof(BANK_POSITION),
                         NULL,
                         0,
                         &ulReturn) == NO_ERROR)
    {
        ppdev->BankIoctlSupported = TRUE;

    } else {

        ppdev->BankIoctlSupported = FALSE;
    }

    return(TRUE);
}

/******************************Public*Routine******************************\
* VOID vInitSavedBits(ppdev)
*
* Initializes saved bits structures.  Must be done after bank
* initialization and vInitBrushCache.
*
\**************************************************************************/

VOID vInitSavedBits(PPDEV ppdev)
{
    if (!((ppdev->fl & DRIVER_OFFSCREEN_REFRESHED) &&
          (ppdev->fl & DRIVER_HAS_OFFSCREEN)))
    {
        return;
    }

    //
    // set up rect to right of visible screen
    //
    ppdev->rclSavedBitsRight.left   = ppdev->cxScreen;
    ppdev->rclSavedBitsRight.top    = 0;
    ppdev->rclSavedBitsRight.right  = max((ppdev->lNextScan-PELS_PER_DWORD),
                                          ppdev->rclSavedBitsRight.left);
    ppdev->rclSavedBitsRight.bottom = ppdev->cyScreen;

    //
    // set up rect below visible screen
    //
    ppdev->rclSavedBitsBottom.left   = 0;
    ppdev->rclSavedBitsBottom.top    = ppdev->cyScreen;
    ppdev->rclSavedBitsBottom.right  = ppdev->rclSavedBitsRight.right;
    ppdev->rclSavedBitsBottom.bottom = ppdev->cTotalScans - BRUSH_MAX_CACHE_SCANS;

    //
    // NOTE: we have subtracted one DWORD from the right edge.  This is because
    //       later it is assumed that we can align by right shifting by up to
    //       one DWORD (unless of course, the width of the buffer is 0).
    //

    ppdev->bBitsSaved = FALSE;

    DISPDBG((1,"ppdev->rclSavedBitsRight = (%04x,%04x,%04x,%04x)    %lux%lu\n",
            ppdev->rclSavedBitsRight.left,
            ppdev->rclSavedBitsRight.top,
            ppdev->rclSavedBitsRight.right,
            ppdev->rclSavedBitsRight.bottom,
            ppdev->rclSavedBitsRight.right - ppdev->rclSavedBitsRight.left,
            ppdev->rclSavedBitsRight.bottom - ppdev->rclSavedBitsRight.top
            ));

    DISPDBG((1,"ppdev->rclSavedBitsBottom = (%04x,%04x,%04x,%04x)    %lux%lu\n",
            ppdev->rclSavedBitsBottom.left,
            ppdev->rclSavedBitsBottom.top,
            ppdev->rclSavedBitsBottom.right,
            ppdev->rclSavedBitsBottom.bottom,
            ppdev->rclSavedBitsBottom.right - ppdev->rclSavedBitsBottom.left,
            ppdev->rclSavedBitsBottom.bottom - ppdev->rclSavedBitsBottom.top
            ));

    return;
}

/******************************Public*Routine******************************\
* VOID vInitBrushCache(ppdev)
*
* Initializes various brush cache structures.  Must be done after bank
* initialization.
*
\**************************************************************************/

VOID vInitBrushCache(PPDEV ppdev)
{
    LONG cCacheBrushesPerScan = ppdev->lNextScan / BRUSH_SIZE;
    LONG cCacheScans;
    LONG cCacheEntries;
    LONG i;
    LONG j;
    BRUSHCACHEENTRY* pbce;

    if (ppdev->cyScreen + BRUSH_MAX_CACHE_SCANS > (ULONG) ppdev->cTotalScans)
    {
        goto InitFailed;
    }

    cCacheScans = BRUSH_MAX_CACHE_SCANS;
    cCacheEntries = cCacheScans * cCacheBrushesPerScan;

    ppdev->pbceCache = (BRUSHCACHEENTRY*) EngAllocMem(FL_ZERO_MEMORY,
                       cCacheEntries * sizeof(BRUSHCACHEENTRY), ALLOC_TAG);

    if (ppdev->pbceCache == NULL)
    {
        goto InitFailed;
    }

    // We successfully managed to allocate all our data structures for looking
    // after off-screen memory, so set the flag saying that we can use it
    // (note that if ppdev->fl's DRIVER_OFFSCREEN_REFRESHED hasn't been set, the
    // memory cannot be used for long-term storage):

    ppdev->fl |= DRIVER_HAS_OFFSCREEN;

    ppdev->iCache     = 0;          // 0 is a reserved index
    ppdev->iCacheLast = cCacheEntries - 1;

    // Initialize our cache entry array:

    pbce    = &ppdev->pbceCache[0];

    for (i = (ppdev->cTotalScans-BRUSH_MAX_CACHE_SCANS); i < ppdev->cTotalScans; i++)
    {
        for (j = 0; j < cCacheBrushesPerScan; j++)
        {
            // Bitmap offset is in planar format, where every byte is one
            // quadpixel:

            pbce->yCache  = i;
            pbce->ulCache = (i * ppdev->lNextScan + j * BRUSH_SIZE) / 4;

            // This verification pointer doesn't actually have to be
            // initialized, but we do so for debugging purposes:

            pbce->prbVerifyRealization = NULL;

            pbce++;
        }
    }

    return;

InitFailed:
    ppdev->fl &= ~(DRIVER_OFFSCREEN_REFRESHED | DRIVER_HAS_OFFSCREEN);
    return;
}

/******************************Public*Routine******************************\
* VOID vResetBrushCache(ppdev)
*
* Blows away the brush cache entries -- this is useful when switching
* out of full-screen mode, where anyone could have written over the video
* memory where we cache our brushes.
*
\**************************************************************************/

VOID vResetBrushCache(PPDEV ppdev)
{
    BRUSHCACHEENTRY* pbce;
    LONG             i;

    // Make sure we actually have a brush cache before we try to reset it:

    if (ppdev->fl & DRIVER_HAS_OFFSCREEN)
    {
        pbce = &ppdev->pbceCache[0];
        for (i = ppdev->iCacheLast; i >= 0; i--)
        {
            pbce->prbVerifyRealization = NULL;
            pbce++;
        }
    }
}

/******************************Public*Routine******************************\
* VOID vDisableBrushCache(ppdev)
*
* Frees various brush cache structures.
*
\**************************************************************************/

VOID vDisableBrushCache(PPDEV ppdev)
{
    if (ppdev->pbceCache != NULL)
    {
        EngFreeMem(ppdev->pbceCache);
    }
}

/******************************Public*Routine******************************\
* getAvailableModes
*
* Calls the miniport to get the list of modes supported by the kernel driver,
* and returns the list of modes supported by the diplay driver among those
*
* returns the number of entries in the videomode buffer.
* 0 means no modes are supported by the miniport or that an error occured.
*
* NOTE: the buffer must be freed up by the caller.
*
\**************************************************************************/

DWORD getAvailableModes(
HANDLE hDriver,
PVIDEO_MODE_INFORMATION *modeInformation,
DWORD *cbModeSize)
{
    ULONG ulTemp;
    VIDEO_NUM_MODES modes;
    PVIDEO_MODE_INFORMATION pVideoTemp;

    //
    // Get the number of modes supported by the mini-port
    //

    if (EngDeviceIoControl(hDriver,
            IOCTL_VIDEO_QUERY_NUM_AVAIL_MODES,
            NULL,
            0,
            &modes,
            sizeof(VIDEO_NUM_MODES),
            &ulTemp))
    {
        DISPDBG((0, "vga256 getAvailableModes failed VIDEO_QUERY_NUM_AVAIL_MODES\n"));
        return(0);
    }

    *cbModeSize = modes.ModeInformationLength;

    //
    // Allocate the buffer for the mini-port to write the modes in.
    //

    *modeInformation = (PVIDEO_MODE_INFORMATION)
                        EngAllocMem(FL_ZERO_MEMORY,
                                   modes.NumModes *
                                   modes.ModeInformationLength, ALLOC_TAG);

    if (*modeInformation == (PVIDEO_MODE_INFORMATION) NULL)
    {
        DISPDBG((0, "vga256 getAvailableModes failed EngAllocMem\n"));

        return 0;
    }

    //
    // Ask the mini-port to fill in the available modes.
    //

    if (EngDeviceIoControl(hDriver,
            IOCTL_VIDEO_QUERY_AVAIL_MODES,
            NULL,
            0,
            *modeInformation,
            modes.NumModes * modes.ModeInformationLength,
            &ulTemp))
    {

        DISPDBG((0, "vga256 getAvailableModes failed VIDEO_QUERY_AVAIL_MODES\n"));

        EngFreeMem(*modeInformation);
        *modeInformation = (PVIDEO_MODE_INFORMATION) NULL;

        return(0);
    }

    //
    // Now see which of these modes are supported by the display driver.
    // As an internal mechanism, set the length to 0 for the modes we
    // DO NOT support.
    //

    ulTemp = modes.NumModes;
    pVideoTemp = *modeInformation;

    //
    // Mode is rejected if it is not one plane, or not graphics, or is not
    // one of 8 bits per pel (that is all the vga 256 currently supports)
    //

    while (ulTemp--)
    {
        if ((pVideoTemp->NumberOfPlanes != 1 ) ||
            !(pVideoTemp->AttributeFlags & VIDEO_MODE_GRAPHICS) ||
             (pVideoTemp->AttributeFlags & VIDEO_MODE_LINEAR) ||
            (pVideoTemp->BitsPerPlane != 8) ||
            (BROKEN_RASTERS(pVideoTemp->ScreenStride,
                           pVideoTemp->VisScreenHeight)))
        {
            pVideoTemp->Length = 0;
        }

        pVideoTemp = (PVIDEO_MODE_INFORMATION)
            (((PUCHAR)pVideoTemp) + modes.ModeInformationLength);
    }

    return modes.NumModes;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\vga\disp\8bpp\i386\colorpat.asm ===
;---------------------------Module-Header------------------------------;
; Module Name: colorpat.asm
;
; Copyright (c) 1992-1993 Microsoft Corporation.  All rights reserved.
;-----------------------------------------------------------------------;

;-----------------------------------------------------------------------;
; BOOL vColorPat(ppdev, culRcl, prcl, ulMix, prb, pptlBrush)
;
; Input:
;
;  ppdev     - surface on which to draw
;  culRcl    - number of rectangles
;  prcl      - pointer to rectangles
;  ulMix     - mix mode
;  prb       - pointer to realized brush
;  pptlBrush - brush alignment
;
; Draws n-color 8x8 patterns using the latches -- we load the latches
; with one part of the pattern, and write the result whereever that
; part of the pattern is repeated; then, we load the latches for the next
; part of the pattern, and repeat the process.
;
; We special case brushes that are really 4 pels wide (i.e., the left and
; right halves of the 8x8 brush are the same), because we can light 8
; pixels on every word write to the VGA memory.  We still have to 'venetian
; blind' vertically -- i.e., load the latches with one row of the pattern,
; and write on every 8th scan line of the screen, then load the latches
; with the second row of the pattern, and repeat the process one scan lower.
;
; For brushes that are actually 8 pels wide, we also horizontally-venetian
; blind.
;
; We also handle patterns that are really only 4 or 2 pels high, because
; then we don't have to laod the latches as often, and the venetian
; blinding isn't as visually obvious.
;
; We only do all this with 1R/1W or 2R/W adapters.  We make an off-screen
; cache of brushes, and always keep one bank pointing to the brush, while
; the other bank points to the pattern destination; this way, it's easy
; to load the latches with the appropriate part of the pattern.
;
;-----------------------------------------------------------------------;
;
; NOTE: Assumes all rectangles have positive heights and widths.  Will
; not work properly if this is not the case.
;
;-----------------------------------------------------------------------;

;-----------------------------------------------------------------------;

        .386

        .model  small,c

        assume cs:FLAT,ds:FLAT,es:FLAT,ss:FLAT
        assume fs:nothing,gs:nothing

        .xlist
        include stdcall.inc             ;calling convention cmacros
        include i386\strucs.inc
        include i386\driver.inc
        include i386\egavga.inc
        include i386\ropdefs.inc

        .list

        .data

; Function to map in two windows at the same time:

;-----------------------------------------------------------------------;
; Bits for drawing routine 8xN look-ups.

BLOCK_8xN_LEFT_EDGE               equ 000100b
BLOCK_8xN_RIGHT_EDGE              equ 000010b
BLOCK_8xN_NO_MIDDLE               equ 000001b

;-----------------------------------------------------------------------;
; Bits for drawing routine 4xN look-ups.

BLOCK_4xN_LEFT_EDGE               equ 010000b
BLOCK_4xN_RIGHT_EDGE              equ 001000b
BLOCK_4xN_MIDDLE_STARTS_UNALIGNED equ 000100b
BLOCK_4xN_NO_MIDDLE               equ 000010b
BLOCK_4xN_MIDDLE_ENDS_UNALIGNED   equ 000001b

;-----------------------------------------------------------------------;
; Table of drawing routines, with the look-up index a 3 bit field as
; follows:
;
; Bit 2 = 1 if a left edge must be drawn
; Bit 1 = 1 if a right edge must be drawn
; Bit 0 = 1 if no middle block

        align   4
gapfn8xN label dword
        dd      middle_8xN              ;000
        dd      0                       ;001
        dd      Block_MR_8xN            ;010
        dd      right_8xN               ;011
        dd      Block_LM_8xN            ;100
        dd      left_8xN                ;101
        dd      Block_LMR_8xN           ;110
        dd      Block_LR_8xN            ;111

        align   4
gapfn4xN label dword
        dd      middle_00_4xN           ;00000
        dd      middle_01_4xN           ;00001
        dd      0                       ;00010
        dd      0                       ;00011
        dd      middle_11_4xN           ;00100
        dd      middle_10_4xN           ;00101
        dd      0                       ;00110
        dd      0                       ;00111
        dd      Block_01000_4xN         ;01000
        dd      Block_01001_4xN         ;01001
        dd      right_8xN               ;01010
        dd      right_8xN               ;01011
        dd      Block_01100_4xN         ;01100
        dd      Block_01101_4xN         ;01101
        dd      right_8xN               ;01110
        dd      right_8xN               ;01111
        dd      Block_10000_4xN         ;10000
        dd      Block_10001_4xN         ;10001
        dd      left_8xN                ;10010
        dd      left_8xN                ;10011
        dd      Block_10100_4xN         ;10100
        dd      Block_10101_4xN         ;10101
        dd      left_8xN                ;10110
        dd      left_8xN                ;10111
        dd      Block_11000_4xN         ;11000
        dd      Block_11001_4xN         ;11001
        dd      Block_11010_4xN         ;11010
        dd      0                       ;11011 - can never happen
        dd      Block_11100_4xN         ;11100
        dd      Block_11101_4xN         ;11101
        dd      Block_11110_4xN         ;11110
        dd      0                       ;11111 - can never happen

        .code

        EXTRNP  vPlanarDouble,20

;-----------------------------------------------------------------------;

Block_MR_8xN:
        push    offset right_8xN
        jmp     middle_8xN

Block_LM_8xN:
        push    offset left_8xN
        jmp     middle_8xN

Block_LMR_8xN:
        push    offset right_8xN
        push    offset left_8xN
        jmp     middle_8xN

Block_LR_8xN:
        push    offset right_8xN
        jmp     left_8xN

;-----------------------------------------------------------------------;

Block_01000_4xN:
        push    offset right_8xN
        jmp     middle_00_4xN

Block_01001_4xN:
        push    offset right_8xN
        jmp     middle_01_4xN

Block_01100_4xN:
        push    offset right_8xN
        jmp     middle_11_4xN

Block_01101_4xN:
        push    offset right_8xN
        jmp     middle_10_4xN

Block_11000_4xN:
        push    offset right_8xN
Block_10000_4xN:
        push    offset left_8xN
        jmp     middle_00_4xN

Block_11001_4xN:
        push    offset right_8xN
Block_10001_4xN:
        push    offset left_8xN
        jmp     middle_01_4xN

Block_11100_4xN:
        push    offset right_8xN
Block_10100_4xN:
        push    offset left_8xN
        jmp     middle_11_4xN

Block_11101_4xN:
        push    offset right_8xN
Block_10101_4xN:
        push    offset left_8xN
        jmp     middle_10_4xN

Block_11010_4xN:
        push    offset right_8xN
        jmp     left_8xN

Block_11110_4xN:
        push    offset right_8xN
        jmp     left_8xN

;-----------------------------------------------------------------------;

cProc   vColorPat,24,<        \
        uses esi edi ebx,     \
        ppdev:     ptr PDEV,  \
        culRcl:    dword,     \
        prcl:      ptr RECTL, \
        ulMix:     dword,     \
        prb:       ptr RBRUSH,\
        pptlBrush: ptr POINTL >

        local pfnDraw:             ptr   ;pointer to draw routines

        local yBrushTimesTwo:      dword ;current y brush alignment
        local yBrushSave:          dword ;temp for saving y brush alignment
        local yBrushOrg:           dword ;original y brush alignment
        local ulMiddleDest:        dword ;bitmap offset to middle
        local ulBlockHeight:       dword ;# of scans to be drawn in block
        local ulBlockWidth:        dword ;# of quadpixels to be drawn

        local ulLeftDest:          dword ;bitmap offset to left edge
        local ulLeftMask:          dword ;plane mask for left-edge drawing
        local ulRightDest:         dword ;bitmap offset to right edge
        local ulRightMask:         dword ;plane mask for right-edge drawing
        local lPlanarNextScan:     dword ;delta between scans in planar mode

        local ulCurrentDestScan:   dword ;current destination scan
        local ulLastDestScan:      dword ;last destination scan

        local pjPattern:           ptr   ;points to off-screen cached brush

        local cyPat:               dword ;pattern height
        local cyPatLog2:           dword ;log2 of pattern height
        local cyPatMinusOne:       dword ;cyPat - 1
        local ulPatIndexMask:      dword ;cyPattern*2 - 1
        local lVenetianNextScan:   dword ;ppdev->lPlanarNextScan * cyPat
        local pbce:                ptr   ;pointer to brush's cache entry

        local ulMiddleIndexAdjust: dword ;1 if to start drawing with right half
        local ulLeftIndexAdjust:   dword ; half of pattern, 0 if with left
        local ulRightIndexAdjust:  dword

        ; For 8xN patterns:

        local cyPattern1:          dword
        local cyPattern2:          dword
        local cyPatternTop1:       dword
        local cyPatternTop2:       dword
        local pvSaveScreen:        ptr
        local cyVenetianTop1:      dword
        local cyVenetianTop2:      dword

        ; For 4xN patterns:

        local cLoops:              dword
        local cwMiddle:            dword

        mov     esi,prb                 ;esi = prb
        mov     edx,pptlBrush           ;edx = pptlBrush
        mov     edi,ppdev               ;edi = pddev

; Initialize some stack variables that we'll use later:

        mov     ecx,[esi].rb_cyLog2
        mov     cyPatLog2,ecx           ;cyPatLog2 = prb->cyLog2

        mov     eax,[edi].pdev_lPlanarNextScan
        shl     eax,cl
        mov     lVenetianNextScan,eax   ;lVenetianNextScan =
                                        ;    ppdev->lPlanarNextScan * prb->cy

        mov     eax,[esi].rb_cy
        mov     cyPat,eax               ;cyPat = prb->cy
        dec     eax
        mov     cyPatMinusOne,eax       ;cyPatMinusOne = cyPat - 1
        lea     eax,[2*eax + 1]
        mov     ulPatIndexMask,eax      ;ulPatIndexMask = cyPat * 2 - 1

; See if we'll have to refresh our brush cache:

        mov     eax,[edx].ptl_y
        mov     ecx,[edx].ptl_x
        mov     yBrushOrg,eax           ;yBrushOrg = pptlBrush->y
        and     ecx,7                   ;ecx = (pptlBrush->x & 7)

        cmp     ecx,[esi].rb_xBrush
        jne     ncol_put_brush_in_cache ;if cached brush doesn't have proper
                                        ; alignment, we have to realign

        .errnz  (size BRUSHCACHEENTRY - 12)

        mov     ebx,[edi].pdev_pbceCache
        mov     eax,[esi].rb_iCache
        lea     eax,[eax+eax*2]
        lea     ebx,[ebx+eax*4]         ;ebx = pbce (pointer to brush's cache
                                        ; entry)

        cmp     esi,[ebx].bce_prbVerifyRealization
        jne     ncol_put_brush_in_cache ;if the cache entry was commandeered
                                        ; by some other brush, we'll have to
                                        ; put the brush in the cache again

ncol_done_brush_in_cache:
        mov     pbce,ebx

; edi = ppdev
; ebx = pbce

; Set the bit mask to disable all bits, so we can copy through the latches:

        mov     edx,VGA_BASE + GRAF_ADDR
        mov     eax,(0 shl 8) + GRAF_BIT_MASK
        out     dx,ax

        mov     edx,[edi].pdev_lPlanarNextScan
        mov     esi,prb
        mov     lPlanarNextScan,edx     ;lPlanarNextScan = ppdev->lPlanarNextScan
        test    [esi].rb_fl,RBRUSH_4PELS_WIDE
        jnz     col4xN_draw_rectangles

;-----------------------------------------------------------------------;
; Start here for every 8xN rectangle.
;-----------------------------------------------------------------------;

        public  col8xN_draw_rectangles
col8xN_draw_rectangles::

        mov     edi,prcl                ;edi = prcl
        mov     ecx,lPlanarNextScan     ;ecx = lPlanarNextScan
        mov     eax,[edi].yBottom
        mov     ebx,[edi].yTop
        mov     ulLastDestScan,eax      ;ulLastDestScan = prcl->bottom
        mov     ulCurrentDestScan,ebx   ;ulCurrentDestScan = prcl->top

        imul    ecx,ebx

        sub     ebx,yBrushOrg
        add     ebx,ebx
        mov     yBrushTimesTwo,ebx      ;yBrushTimesTwo = 8 * (prcl->top -
                                        ; pptlBrush->y) (our current index into
                                        ; the pattern array)

        mov     ebx,[edi].xLeft
        shr     ebx,2
        add     ebx,ecx                 ;ebx = prcl->top * lPlanarNextScan +
                                        ; (prcl->left >> 2)
                                        ; (offset into bitmap of left side)

        mov     eax,[edi].xRight
        shr     eax,2
        add     eax,ecx
        mov     ulRightDest,eax         ;ulRightDest = prcl->top * lPlanarNextScan
                                        ; + (prcl->right >> 2)
                                        ; (offset into bitmap of right side)

        xor     esi,esi                 ;zero our flags

        mov     ecx,[edi].xLeft
        and     ecx,3
        jz      short col8xN_done_left    ;skip if we don't need a left edge

        mov     esi,0fh                 ;compute the plane mask for the left
        shl     esi,cl                  ; edge.  we don't use a look-up table
        mov     ulLeftMask,esi          ; 'cause it won't be in the cache.

        mov     esi,(BLOCK_8xN_LEFT_EDGE shr 1)
                                        ;set our flag (we soon shift left by 2)

        mov     ulLeftDest,ebx          ;ulLeftDest = prcl->top * lPlanarNextScan +
                                        ; (prcl->left >> 2)

        mov     ecx,ebx
        and     ecx,1
        mov     ulLeftIndexAdjust,ecx   ;this value is used when doing the left
                                        ; edge to know whether to use all the
                                        ; half of the pattern or the right side
                                        ; (i.e., 0 or 1)

        inc     ebx                     ;ebx = ulMiddleDest = ulLeftDest + 1
                                        ; (we have to adjust our offset to
                                        ; the first whole byte)

        public  col8xN_done_left
col8xN_done_left::
        sub     eax,ebx                 ;eax = cjMiddle =
                                        ; ulRightDest - ulMiddleDest
        mov     ulMiddleDest,ebx        ;ulMiddleDest

        and     ebx,1
        mov     ulMiddleIndexAdjust,ebx ;start with left or right pattern half

        mov     ecx,[edi].xRight
        and     ecx,3
        jz      short col8xN_done_right ;skip if we don't need a right edge

        mov     ebx,ulRightDest
        and     ebx,1
        mov     ulRightIndexAdjust,ebx  ;edge uses left or right pattern half

        mov     ebx,0f0h                ;compute the plane mask for the right
        rol     bl,cl                   ; edge.  we don't use a look-up table
        mov     ulRightMask,ebx         ; 'cause it won't be in the cache.

        or      esi,(BLOCK_8xN_RIGHT_EDGE shr 1)
                                        ;set our flag (we soon shift left by 2)

; If the count of whole bytes is negative, that means that the pattern
; starts and ends in the same quadpixel, so we do some more work:

        cmp     eax,0
        jge     short col8xN_done_right

; It starts and ends in the same quadpixel:

        and     esi,not (BLOCK_8xN_RIGHT_EDGE shr 1)
                                        ;turn off right edge
        and     ebx,ulLeftMask
        mov     ulLeftMask,ebx
        xor     eax,eax                 ;we do zero middle bytes

        public  col8xN_done_right
col8xN_done_right::

; We're going to do an 'adc esi,esi' instructions here, effectively
; shifting our flags left by 1, and setting the low bit:

        .errnz  (BLOCK_8xN_NO_MIDDLE - 1)
        cmp     eax,1                   ;shift flags left one, and set low
        adc     esi,esi                 ; bit if we don't need to do a middle

        mov     ulBlockWidth,eax

        mov     eax,gapfn8xN[esi*4]
        mov     pfnDraw,eax             ;pointer to function that draws
                                        ; everything in the bank

; If we were just doing a n-color patblt in the same area as this call,
; there's a good chance that we're still in planar mode, and that the source
; window points to the brush cache and the destination window points to the
; patblt destination.  So go through the bother of checking:

        mov     esi,pbce
        mov     ebx,ppdev
        mov     eax,[esi].bce_yCache
        mov     edi,[edi].yTop

        cmp     eax,[ebx].pdev_rcl2PlanarClipS.yTop
        jl      short col8xN_map_init_bank

        cmp     eax,[ebx].pdev_rcl2PlanarClipS.yBottom
        jge     short col8xN_map_init_bank

        cmp     edi,[ebx].pdev_rcl2PlanarClipD.yTop
        jl      short col8xN_map_init_bank

        cmp     edi,[ebx].pdev_rcl2PlanarClipD.yBottom
        jl      short col8xN_init_bank_mapped

col8xN_map_init_bank:

; Map both windows in a single call.
; Preserves EBX, ESI and EDI, according to C calling conventions:

        cCall   vPlanarDouble, \
                <ebx,eax,JustifyBottom,edi,JustifyTop>

        public  col8xN_init_bank_mapped
col8xN_init_bank_mapped::

; esi = pbce
; ebx = ppdev
; edi = current scan

        mov     eax,[esi].bce_ulCache
        add     eax,[ebx].pdev_pvBitmapStart2WindowS
        mov     pjPattern,eax           ;points to directly to cached off-
                                        ; screen brush bits

        mov     eax,ulLastDestScan
        mov     ebx,[ebx].pdev_rcl2PlanarClipD.yBottom

        sub     eax,ebx
        sbb     ecx,ecx
        and     ecx,eax
        add     ebx,ecx                 ;ebx = min(ulLastDestScan,
                                        ;      ppdev->rcl2PlanarClipD.yBottom)
        mov     ulCurrentDestScan,ebx

        sub     ebx,edi
        mov     ulBlockHeight,ebx       ;ulBlockHeight = ebx - ulCurrentDestScan

; Draw everything in this bank:

        call    pfnDraw

        mov     edi,ulCurrentDestScan
        cmp     edi,ulLastDestScan
        jge     short col8xN_next_rectangle

; It's hard for the block copiers to advance their bitmap offsets to the
; next bank, so we do them all here:

        mov     eax,lPlanarNextScan
        imul    eax,ulBlockHeight
        add     ulLeftDest,eax
        add     ulMiddleDest,eax
        add     ulRightDest,eax

; Get the next bank:

        mov     ebx,ppdev

; Map the next bank into window.
; Note: EBX, ESI, and EDI are preserved, according to C calling conventions.

        ptrCall <dword ptr [ebx].pdev_pfnPlanarControl2>, \
                <ebx,edi,JustifyTop,MapDestBank>

        mov     eax,edi
        sub     eax,yBrushOrg
        add     eax,eax
        mov     yBrushTimesTwo,eax      ;alignment for new bank

        mov     esi,pbce
        jmp     short col8xN_init_bank_mapped

;-----------------------------------------------------------------------;
; Done rectangle.
;-----------------------------------------------------------------------;

        public  col8xN_next_rectangle
col8xN_next_rectangle::
        add     prcl, size RECTL
        dec     culRcl
        jg      col8xN_draw_rectangles  ;do more rectangles

; Enable bit mask for all bits:

        mov     edx,VGA_BASE + GRAF_ADDR
        mov     eax,(0ffh shl 8) + GRAF_BIT_MASK
        out     dx,ax

; Enable writes to all planes:

        mov     edx,VGA_BASE + SEQ_DATA
        mov     al,MM_ALL
        out     dx,al

        cRet    vColorPat

;-----------------------------------------------------------------------;
; Start here for every 4xN rectangle.
;-----------------------------------------------------------------------;

        public  col4xN_draw_rectangles
col4xN_draw_rectangles::

        mov     edi,prcl                ;edi = prcl
        mov     ecx,lPlanarNextScan     ;ecx = lPlanarNextScan
        mov     eax,[edi].yBottom
        mov     ebx,[edi].yTop
        mov     ulLastDestScan,eax      ;ulLastDestScan = prcl->bottom
        mov     ulCurrentDestScan,ebx   ;ulCurrentDestScan = prcl->top

        imul    ecx,ebx

        sub     ebx,yBrushOrg
        add     ebx,ebx
        mov     yBrushTimesTwo,ebx      ;yBrushTimesTwo = 8 * (prcl->top -
                                        ; pptlBrush->y) (our current index into
                                        ; the pattern array)

        mov     ebx,[edi].xLeft
        shr     ebx,2
        add     ebx,ecx                 ;ebx = prcl->top * lPlanarNextScan +
                                        ; (prcl->left >> 2)
                                        ; (offset into bitmap of left side)

        mov     eax,[edi].xRight
        shr     eax,2
        add     eax,ecx
        mov     ulRightDest,eax         ;ulRightDest = prcl->top * lPlanarNextScan
                                        ; + (prcl->right >> 2)
                                        ; (offset into bitmap of right side)

        xor     esi,esi                 ;zero our flags

        mov     ecx,[edi].xLeft
        and     ecx,3
        jz      short col4xN_done_left  ;skip if we don't need a left edge

        mov     esi,0fh                 ;compute the plane mask for the left
        shl     esi,cl                  ; edge.  we don't use a look-up table
        mov     ulLeftMask,esi          ; 'cause it won't be in the cache.

        mov     esi,(BLOCK_4xN_LEFT_EDGE shr 2)
                                        ;set our flag (we soon shift left by 2)

        mov     ulLeftDest,ebx          ;ulLeftDest = prcl->top * lPlanarNextScan +
                                        ; (prcl->left >> 2)

        mov     ulLeftIndexAdjust,0     ;always want to use left side of pattern

        inc     ebx                     ;ebx = ulMiddleDest = ulLeftDest + 1
                                        ; (we have to adjust our offset to
                                        ; the first whole byte)

        public  col4xN_done_left
col4xN_done_left::
        sub     eax,ebx                 ;eax = cjMiddle =
                                        ; ulRightDest - ulMiddleDest
        mov     ulMiddleDest,ebx        ;ulMiddleDest

        .errnz  (BLOCK_4xN_MIDDLE_STARTS_UNALIGNED shr 2) - 1
        and     ebx,1                   ;set bit if middle doesn't start
        or      esi,ebx                 ; word aligned (remembering we'll
                                        ; soon shift flags left by 2)

        mov     ecx,[edi].xRight
        and     ecx,3
        jz      short col4xN_done_right ;skip if we don't need a right edge

        mov     ulRightIndexAdjust,0    ;always use left side of pattern

        mov     ebx,0f0h                ;compute the plane mask for the right
        rol     bl,cl                   ; edge.  we don't use a look-up table
        mov     ulRightMask,ebx         ; 'cause it won't be in the cache.

        or      esi,(BLOCK_4xN_RIGHT_EDGE shr 2)
                                        ;set our flag (we soon shift left by 2)

; If the count of whole bytes is negative, that means that the pattern
; starts and ends in the same quadpixel, so we do some more work:

        cmp     eax,0
        jge     short col4xN_done_right

; It starts and ends in the same quadpixel:

        and     esi,not (BLOCK_4xN_RIGHT_EDGE shr 2)
                                        ;turn off right edge
        and     ebx,ulLeftMask
        mov     ulLeftMask,ebx
        xor     eax,eax                 ;we do zero middle bytes

        public  col4xN_done_right
col4xN_done_right::

; We're going to do two 'adc esi,esi' instructions here, effectively
; shifting our flags left by 2, and setting the low bits:

        .errnz  (BLOCK_4xN_NO_MIDDLE shr 1) - 1
        cmp     eax,1                   ;shift flags left one, and set low
        adc     esi,esi                 ; bit if we don't need to do a middle

        .errnz  (BLOCK_4xN_MIDDLE_ENDS_UNALIGNED) - 1
        shr     eax,1
        adc     esi,esi                 ;shift flags left one, and set low
                                        ; bit if the middle isn't an even
                                        ; number of bytes in length
        mov     cwMiddle,eax            ;cwMiddle = cjMiddle / 2
        add     eax,eax
        mov     ulBlockWidth,eax        ;ulBlockWidth = cwMiddle * 2

        mov     eax,gapfn4xN[esi*4]
        mov     pfnDraw,eax             ;pointer to function that draws
                                        ; everything in the bank

; If we were just doing a n-color patblt in the same area as this call,
; there's a good chance that we're still in planar mode, and that the source
; window points to the brush cache and the destination window points to the
; patblt destination.  So go through the bother of checking:

        mov     esi,pbce
        mov     ebx,ppdev
        mov     eax,[esi].bce_yCache
        mov     edi,[edi].yTop

        cmp     eax,[ebx].pdev_rcl2PlanarClipS.yTop
        jl      short col4xN_map_init_bank

        cmp     eax,[ebx].pdev_rcl2PlanarClipS.yBottom
        jge     short col4xN_map_init_bank

        cmp     edi,[ebx].pdev_rcl2PlanarClipD.yTop
        jl      short col4xN_map_init_bank

        cmp     edi,[ebx].pdev_rcl2PlanarClipD.yBottom
        jl      short col4xN_init_bank_mapped

col4xN_map_init_bank:

; Map both windows in a single call.
; Preserves EBX, ESI and EDI, according to C calling conventions:

        cCall   vPlanarDouble, \
                <ebx,eax,JustifyBottom,edi,JustifyTop>

        public  col4xN_init_bank_mapped
col4xN_init_bank_mapped::

; esi = pbce
; ebx = ppdev
; edi = current scan

        mov     eax,[esi].bce_ulCache
        add     eax,[ebx].pdev_pvBitmapStart2WindowS
        mov     pjPattern,eax           ;points to directly to cached off-
                                        ; screen brush bits

        mov     eax,ulLastDestScan
        mov     ebx,[ebx].pdev_rcl2PlanarClipD.yBottom

        sub     eax,ebx
        sbb     ecx,ecx
        and     ecx,eax
        add     ebx,ecx                 ;ebx = min(ulLastDestScan,
                                        ;      ppdev->rcl2PlanarClipD.yBottom)
        mov     ulCurrentDestScan,ebx

        sub     ebx,edi
        mov     ulBlockHeight,ebx       ;ulBlockHeight = ebx - ulCurrentDestScan

; Draw everything in this bank:

        call    pfnDraw

        mov     edi,ulCurrentDestScan
        cmp     edi,ulLastDestScan
        jge     short col4xN_next_rectangle

; It's hard for the block copiers to advance their bitmap offsets to the
; next bank, so we do them all here:

        mov     eax,lPlanarNextScan
        imul    eax,ulBlockHeight
        add     ulLeftDest,eax
        add     ulMiddleDest,eax
        add     ulRightDest,eax

; Get the next bank:

        mov     ebx,ppdev

; Map the next bank into window.
; Note: EBX, ESI, and EDI are preserved, according to C calling conventions.

        ptrCall <dword ptr [ebx].pdev_pfnPlanarControl2>, \
                <ebx,edi,JustifyTop,MapDestBank>

        mov     eax,edi
        sub     eax,yBrushOrg
        add     eax,eax
        mov     yBrushTimesTwo,eax      ;alignment for new bank

        mov     esi,pbce
        jmp     short col4xN_init_bank_mapped

;-----------------------------------------------------------------------;
; Done rectangle.
;-----------------------------------------------------------------------;

        public  col4xN_next_rectangle
col4xN_next_rectangle::
        add     prcl, size RECTL
        dec     culRcl
        jg      col4xN_draw_rectangles  ;do more rectangles

; Enable bit mask for all bits:

        mov     edx,VGA_BASE + GRAF_ADDR
        mov     eax,(0ffh shl 8) + GRAF_BIT_MASK
        out     dx,ax

; Enable writes to all planes:

        mov     edx,VGA_BASE + SEQ_DATA
        mov     al,MM_ALL
        out     dx,al

        cRet    vColorPat

;=======================================================================;
;=========================== Brush Caching =============================;
;=======================================================================;

;-----------------------------------------------------------------------;
; ncol_put_brush_in_cache
;
; Allocates a brush cache entry, and copies the bits from the realized
; brush to the off-screen cache.
;
; Input:
;       edi = ppdev
;       ecx = (pptlBrush->x & 7)
;       esi = prb
;
; Output:
;       edi = ppdev
;       ebx = pbce (pointer to new brush cache entry)
;-----------------------------------------------------------------------;

        align   4
gapfnCopyBrush4xN     label   dword
        dd      0
        dd      ncol_4x2
        dd      ncol_4x4
        dd      ncol_4x8

        public  ncol_put_brush_in_cache
ncol_put_brush_in_cache::

; We employ a simple FIFO circular buffer caching scheme.

        mov     eax,[edi].pdev_iCache
        cmp     eax,[edi].pdev_iCacheLast
        sbb     edx,edx
        and     edx,eax
        inc     edx                     ;edx = new brush index =
                                        ;      (ppdev->iCache + 1)
                                        ; (if the new index is greater than
                                        ; ppdev->iCacheLast, its value becomes
                                        ; one -- index zero is reserved)

        mov     [edi].pdev_iCache,edx   ;remember this cache index for nex
                                        ; time we need a new one

        mov     [esi].rb_iCache,edx     ;point the realized brush to our cache
                                        ; entry

; If offscreen memory isn't refreshed, the brush cache can't be
; guaranteed to be valid between calls.  But it should be safe to
; initialize and use it in the same call.  By never changing 'xBrush',
; we effectively never mark the cached entry as valid (and so the
; cache entry will get updated on every call), but we can still use
; our fast Asm fill code:

        test    [edi].pdev_fl,DRIVER_OFFSCREEN_REFRESHED
        jz      short ncol_find_brush_entry

        mov     [esi].rb_xBrush,ecx     ;remember the brush's x alignment

ncol_find_brush_entry::
        .errnz  (size BRUSHCACHEENTRY - 12)

        mov     ebx,[edi].pdev_pbceCache
        lea     edx,[edx+edx*2]
        lea     ebx,[ebx+edx*4]         ;ebx = new BRUSHCACHEENTRY for brush

; Because of the DDI design, we are not notified by the engine when it
; kills a brush realization, so we have no way of freeing legitimately
; free cache entries.  So whenever we cache a new brush, we pretty much
; just randomly pick a new off-screen location to write the brush bits too;
; if it was holding the brush bits for another brush that still might be
; used, we have to have some way of telling that old brush realization that
; its cache entry is no longer valid.
;
; We do this by means of the prbVerifyRealization field in the cache entry --
; it points to the brush realization that owns the brush bits.  (Remember
; that the realization may be deleted by the engine at any time, so it might
; be pointing to freed memory.  But that's okay since we only ever use it
; when given a realized brush, to see if its off-screen cache entry is still
; valid.)

        mov     [ebx].bce_prbVerifyRealization,esi
                                        ;mark that this realized brush has a
                                        ; valid cache entry

        mov     eax,[ebx].bce_yCache

        cmp     eax,[edi].pdev_rcl1WindowClip.yTop
        jl      short ncol_map_brush_bank

        cmp     eax,[edi].pdev_rcl1WindowClip.yBottom
        jl      short ncol_brush_bank_mapped

ncol_map_brush_bank:
        push    ecx
        ptrCall <dword ptr [edi].pdev_pfnBankControl>, \
                <edi,eax,JustifyBottom>
        pop     ecx

ncol_brush_bank_mapped:
        test    [esi].rb_fl,RBRUSH_4PELS_WIDE
        jz      ncol_8_wide

        mov     eax,[edi].pdev_pvBitmapStart
        mov     edi,[ebx].bce_ulCache   ;ulCache will have to be multiplied by
                                        ; 4 because we want the non-planar
                                        ; offset, not the planar offset
        lea     edi,[eax+edi*4]         ;edi = off-screen destination

        shl     ecx,3                   ;each pixel is 8 bits long

        mov     eax,[esi].rb_cyLog2
        lea     esi,[esi].rb_aulPattern ;esi = realized brush source
        jmp     gapfnCopyBrush4xN[eax*4]

; ebx = pbce
; ecx = (pptlBrush->x & 7) * 8
; esi = pointer to source realized brush bits
; edi = pointer to destination off-screen brush bits

ncol_4x8:
        mov     eax,[esi+56]
        mov     edx,[esi+60]
        shld    eax,edx,cl
        mov     [edi+56],eax            ;8th quadpixel

        mov     eax,[esi+48]
        mov     edx,[esi+52]
        shld    eax,edx,cl
        mov     [edi+48],eax            ;7th quadpixel

        mov     eax,[esi+40]
        mov     edx,[esi+44]
        shld    eax,edx,cl
        mov     [edi+40],eax            ;6th quadpixel

        mov     eax,[esi+32]
        mov     edx,[esi+36]
        shld    eax,edx,cl
        mov     [edi+32],eax            ;5th quadpixel

ncol_4x4:
        mov     eax,[esi+24]
        mov     edx,[esi+28]
        shld    eax,edx,cl
        mov     [edi+24],eax            ;4th quadpixel

        mov     eax,[esi+16]
        mov     edx,[esi+20]
        shld    eax,edx,cl
        mov     [edi+16],eax            ;3rd quadpixel

ncol_4x2:
        mov     eax,[esi+8]
        mov     edx,[esi+12]
        shld    eax,edx,cl
        mov     [edi+8],eax             ;2nd quadpixel

        mov     eax,[esi]
        mov     edx,[esi+4]
        shld    eax,edx,cl
        mov     [edi],eax               ;1st quadpixel

        mov     edi,ppdev
        jmp     ncol_done_brush_in_cache

;-----------------------------------------------------------------------;

        align   4
gapfnCopyBrush8xN     label   dword
        dd      0
        dd      ncol_8x2
        dd      ncol_8x4
        dd      ncol_8x8

        public  ncol_8_wide
ncol_8_wide::
        push    ebx                     ;we'll need 'pbce' later

        mov     eax,[edi].pdev_pvBitmapStart
        mov     edi,[ebx].bce_ulCache   ;ulCache will have to be multiplied by
                                        ; 4 because we want the non-planar
                                        ; offset, not the planar offset

; We're lacking a 64 bit roll instruction.  And we have the problem that
; we might have to roll the pattern by (for example) 7 pixels (i.e., 56
; bits), but shld can only do up to a 32 bit shift.  In those cases, the
; right quadpixel has to be moved with a shift to the left quadpixel (and
; vice versa) -- so we detect those cases and switch the destination
; pointer between left and right:

        cmp     ecx,4
        sbb     edi,-1

        lea     edi,[eax+edi*4]         ;edi = off-screen destination

        mov     ebx,edi
        xor     ebx,4                   ;put the pattern's right pixel
                                        ; adjacent to the left pixel

        shl     ecx,3                   ;each pixel is 8 bits long

        mov     eax,[esi].rb_cyLog2
        lea     esi,[esi].rb_aulPattern ;esi = realized brush source

        jmp     gapfnCopyBrush8xN[eax*4]

; ebx = destination for the source pattern's right pixels
; ecx = (pptlBrush->x & 7) * 8
; esi = pointer to source realized brush bits
; edi = destination for the source pattern's left pixels

ncol_8x8:
        mov     eax,[esi+56]
        mov     edx,[esi+60]
        shld    eax,edx,cl
        mov     [edi+56],eax            ;left side of pattern's 8th scan
        mov     eax,[esi+56]
        shld    edx,eax,cl
        mov     [ebx+56],edx            ;right side of pattern' 8th scan

        mov     eax,[esi+48]
        mov     edx,[esi+52]
        shld    eax,edx,cl
        mov     [edi+48],eax            ;left side of pattern's 7th scan
        mov     eax,[esi+48]
        shld    edx,eax,cl
        mov     [ebx+48],edx            ;right side of pattern' 7th scan

        mov     eax,[esi+40]
        mov     edx,[esi+44]
        shld    eax,edx,cl
        mov     [edi+40],eax            ;left side of pattern's 6th scan
        mov     eax,[esi+40]
        shld    edx,eax,cl
        mov     [ebx+40],edx            ;right side of pattern' 6th scan

        mov     eax,[esi+32]
        mov     edx,[esi+36]
        shld    eax,edx,cl
        mov     [edi+32],eax            ;left side of pattern's 5th scan
        mov     eax,[esi+32]
        shld    edx,eax,cl
        mov     [ebx+32],edx            ;right side of pattern' 5th scan

ncol_8x4:
        mov     eax,[esi+24]
        mov     edx,[esi+28]
        shld    eax,edx,cl
        mov     [edi+24],eax            ;left side of pattern's 4th scan
        mov     eax,[esi+24]
        shld    edx,eax,cl
        mov     [ebx+24],edx            ;right side of pattern' 4th scan

        mov     eax,[esi+16]
        mov     edx,[esi+20]
        shld    eax,edx,cl
        mov     [edi+16],eax            ;left side of pattern's 3rd scan
        mov     eax,[esi+16]
        shld    edx,eax,cl
        mov     [ebx+16],edx            ;right side of pattern' 3rd scan

ncol_8x2:
        mov     eax,[esi+8]
        mov     edx,[esi+12]
        shld    eax,edx,cl
        mov     [edi+8],eax             ;left side of pattern's 2nd scan
        mov     eax,[esi+8]
        shld    edx,eax,cl
        mov     [ebx+8],edx             ;right side of pattern's 2nd scan

        mov     eax,[esi]
        mov     edx,[esi+4]
        shld    eax,edx,cl
        mov     [edi],eax               ;left side of pattern's 1st scan
        mov     eax,[esi]
        shld    edx,eax,cl
        mov     [ebx],edx               ;right side of pattern's 1st scan

        pop     ebx
        mov     edi,ppdev
        jmp     ncol_done_brush_in_cache

;=======================================================================;
;=========================== Block Drawers =============================;
;=======================================================================;

;-----------------------------------------------------------------------;
; left_8xN
;
; Draws left edge of 8xN patterns.
;
; Input:
;       ulLeftMask
;       ulLeftDest
;       ulBlockHeight
;       pjPattern         = start of pattern
;       lPlanarNextScan
;       yBrushTimesTwo    = not kept normalized
;       ulLeftIndexAdjust
;
; Output:
;-----------------------------------------------------------------------;

        public  left_8xN
left_8xN::
        mov     edx,VGA_BASE + SEQ_DATA
        mov     eax,ulLeftMask
        out     dx,al                   ;set left mask by disabling some planes

        mov     ecx,ppdev
        mov     edi,ulLeftDest
        add     edi,[ecx].pdev_pvBitmapStart2WindowD
                                        ;adjust edi to point into the
                                        ; screen destination bank

        mov     eax,ulLeftIndexAdjust
        add     eax,yBrushTimesTwo      ;we adjust eax to point to either the
                                        ; left or right quadpixels of the
                                        ; first 8 pixels in the pattern,
                                        ; depending on how the edge is located

        mov     edx,lVenetianNextScan   ;screen delta between rows that have
                                        ; the same pattern

        mov     esi,ulBlockHeight
        mov     ebx,esi
        and     ebx,cyPatMinusOne         ;ebx = number of rows of pattern that
        jz      short left_8xN_do_lower ; are in the upper part of the venetian

        mov     ecx,cyPatLog2
        shr     esi,cl
        inc     esi                     ;(ulBlockHeight >> cyPatLog2) + 1
                                        ; scans are drawn with each of the top
                                        ; (ulBlockHeight & cyPatternMinus1)
                                        ; rows of the pattern
left_8xN_upper_loop:
        push    edi                     ;save screen pointer for next scan

        mov     ecx,pjPattern
        and     eax,ulPatIndexMask
        mov     cl,[ecx+eax]            ;load latches with current quadpixel
        add     eax,2                   ;advance to next quadpixel in pattern
                                        ; that is in the same row

        mov     ecx,esi

; eax = current index into brush
; ebx = # of scans in upper part of venetian blind
; ecx = scan count
; edx = venetian delta
; edi = screen

@@:
        mov     [edi],al                ;write the quadpixel
        add     edi,edx                 ;skip a quadpixel

        dec     ecx
        jnz     @B                      ;repeat this quadpixel of the pattern
                                        ; on all the scans we can
        pop     edi
        add     edi,lPlanarNextScan     ;we're now 1 scan lower in the venetian

        dec     ebx
        jnz     short left_8xN_upper_loop

        mov     esi,ulBlockHeight
        cmp     esi,cyPat
        jl      short left_8xN_done     ;have to watch for rectangles that are
                                        ; shorter than the pattern

        mov     ebx,esi
        and     ebx,cyPatMinusOne

left_8xN_do_lower:
        neg     ebx
        add     ebx,cyPat               ;ebx = number of rows in pattern that
                                        ; are in the lower part of the venetian
                                        ; (namely, cyPat - # in upper)

        mov     ecx,cyPatLog2
        shr     esi,cl                  ;(ulBlockHeight >> cyPatLog2) scans
                                        ; are drawn with each of the bottom
                                        ; cyPattern - (ulBlockHeight &
                                        ; cyPatternMinus1) rows of the pattern
left_8xN_lower_loop:
        push    edi                     ;save screen pointer for next scan

        mov     ecx,pjPattern
        and     eax,ulPatIndexMask
        mov     cl,[ecx+eax]            ;load latches with current quadpixel
        add     eax,2                   ;advance to next quadpixel in pattern
                                        ; that is in the same row

        mov     ecx,esi

@@:
        mov     [edi],al                ;write the quadpixel
        add     edi,edx                 ;skip a quadpixel

        dec     ecx
        jnz     @B                      ;repeat this quadpixel of the pattern
                                        ; on all the scans we can
        pop     edi
        add     edi,lPlanarNextScan     ;we're one scan lower in the venetian

        dec     ebx
        jnz     short left_8xN_lower_loop

left_8xN_done:
        PLAIN_RET

;-----------------------------------------------------------------------;
; right_8xN
;
; Draws right edge of 8xN patterns.
;
; Input:
;       ulRightMask
;       ulRightDest
;       ulBlockHeight
;       pjPattern         = start of pattern
;       lPlanarNextScan
;       yBrushTimesTwo    = not kept normalized
;       ulRightIndexAdjust
;
; Output:
;-----------------------------------------------------------------------;

        public  right_8xN
right_8xN::
        mov     edx,VGA_BASE + SEQ_DATA
        mov     eax,ulRightMask
        out     dx,al                   ;set right mask by disabling some planes

        mov     ecx,ppdev
        mov     edi,ulRightDest
        add     edi,[ecx].pdev_pvBitmapStart2WindowD
                                        ;adjust edi to point into the
                                        ; screen destination bank

        mov     eax,ulRightIndexAdjust
        add     eax,yBrushTimesTwo      ;we adjust eax to point to either the
                                        ; right or right quadpixels of the
                                        ; first 8 pixels in the pattern,
                                        ; depending on how the edge is located

        mov     edx,lVenetianNextScan   ;screen delta between rows that have
                                        ; the same pattern

        mov     esi,ulBlockHeight
        mov     ebx,esi
        and     ebx,cyPatMinusOne         ;ebx = number of rows of pattern that
        jz      short right_8xN_do_lower ; are in the upper part of the venetian

        mov     ecx,cyPatLog2
        shr     esi,cl
        inc     esi                     ;(ulBlockHeight >> cyPatLog2) + 1
                                        ; scans are drawn with each of the top
                                        ; (ulBlockHeight & cyPatternMinus1)
                                        ; rows of the pattern
right_8xN_upper_loop:
        push    edi                     ;save screen pointer for next scan

        mov     ecx,pjPattern
        and     eax,ulPatIndexMask
        mov     cl,[ecx+eax]            ;load latches with current quadpixel
        add     eax,2                   ;advance to next quadpixel in pattern
                                        ; that is in the same row

        mov     ecx,esi

; eax = current index into brush
; ebx = # of scans in upper part of venetian blind
; ecx = scan count
; edx = venetian delta
; edi = screen

@@:
        mov     [edi],al                ;write the quadpixel
        add     edi,edx                 ;skip a quadpixel

        dec     ecx
        jnz     @B                      ;repeat this quadpixel of the pattern
                                        ; on all the scans we can
        pop     edi
        add     edi,lPlanarNextScan     ;we're now 1 scan lower in the venetian

        dec     ebx
        jnz     short right_8xN_upper_loop

        mov     esi,ulBlockHeight
        cmp     esi,cyPat
        jl      short right_8xN_done     ;have to watch for rectangles that are
                                        ; shorter than the pattern

        mov     ebx,esi
        and     ebx,cyPatMinusOne

right_8xN_do_lower:
        neg     ebx
        add     ebx,cyPat               ;ebx = number of rows in pattern that
                                        ; are in the lower part of the venetian
                                        ; (namely, cyPat - # in upper)

        mov     ecx,cyPatLog2
        shr     esi,cl                  ;(ulBlockHeight >> cyPatLog2) scans
                                        ; are drawn with each of the bottom
                                        ; cyPattern - (ulBlockHeight &
                                        ; cyPatternMinus1) rows of the pattern
right_8xN_lower_loop:
        push    edi                     ;save screen pointer for next scan

        mov     ecx,pjPattern
        and     eax,ulPatIndexMask
        mov     cl,[ecx+eax]            ;load latches with current quadpixel
        add     eax,2                   ;advance to next quadpixel in pattern
                                        ; that is in the same row

        mov     ecx,esi

@@:
        mov     [edi],al                ;write the quadpixel
        add     edi,edx                 ;skip a quadpixel

        dec     ecx
        jnz     @B                      ;repeat this quadpixel of the pattern
                                        ; on all the scans we can
        pop     edi
        add     edi,lPlanarNextScan     ;we're one scan lower in the venetian

        dec     ebx
        jnz     short right_8xN_lower_loop

right_8xN_done:
        PLAIN_RET

;-----------------------------------------------------------------------;
; middle_8xN
;
; Draws middle of 8xN patterns.
;
; Input:
;
;-----------------------------------------------------------------------;

        public  middle_8xN
middle_8xN::
        mov     edx,VGA_BASE + SEQ_DATA
        mov     eax,MM_ALL
        out     dx,al                   ;we'll be writing to all planes

        mov     ecx,ppdev
        mov     edi,ulMiddleDest
        add     edi,[ecx].pdev_pvBitmapStart2WindowD
                                        ;adjust edi to point into the screen
                                        ; destination bank

        mov     pvSaveScreen,edi        ;save for later

        mov     esi,ulBlockHeight
        mov     ebx,esi
        mov     eax,cyPat
        sub     ebx,eax                 ;ebx = ulBlockHeight - cyPat
        sbb     ecx,ecx
        and     ecx,ebx
        add     eax,ecx
        mov     cyPattern1,eax
        mov     cyPattern2,eax          ;cyPatternX = min(ulBlockHeight, cyPat)

        and     ebx,cyPatMinusOne
        mov     cyPatternTop1,ebx
        mov     cyPatternTop2,ebx       ;cyPatternTopX = number of rows of
                                        ; pattern that are in the upper rows
                                        ; of the venetian

        mov     eax,ulMiddleIndexAdjust
        add     eax,yBrushTimesTwo
        mov     yBrushSave,eax          ;tells us where in the pattern to start

        mov     ecx,cyPatLog2
        shr     esi,cl
        inc     esi
        mov     cyVenetianTop1,esi
        mov     cyVenetianTop2,esi      ;cyVenetianTop = # scans that are
                                        ; drawn with each of the top
                                        ; cyPatternTopX rows of the pattern

        mov     esi,ulBlockWidth
        inc     esi
        shr     esi,1                   ;esi = number of columns to lay down
                                        ; with 'left' side of pattern

        mov     edx,lVenetianNextScan
        sub     edx,esi
        sub     edx,esi                 ;edx = delta in bytes to go from
                                        ; end of current screen scan to
                                        ; start of next that has same pattern
                                        ; quadpixel

mid_8xN_first_loop:
        push    edi                     ;save screen pointer for next scan

        mov     ebx,cyVenetianTop1
        sub     cyPatternTop1,1         ;set carry if zero or less
        sbb     ebx,0                   ;the number of scans drawn for the
                                        ; top part of the pattern is 1 more
                                        ; than that drawn for the bottom
        mov     cyVenetianTop1,ebx

        mov     ecx,pjPattern
        and     eax,ulPatIndexMask
        mov     cl,[ecx+eax]            ;load latches with current quadpixel
        add     eax,2                   ;advance to next quadpixel in pattern
                                        ; that is in the same row

; eax = current brush index
; ebx = # of scans to draw
; edx = venetian delta
; ecx = scan count
; edi = destination address

        call    draw_horizontal_8xN_middle_loop
        pop     edi
        add     edi,lPlanarNextScan     ;we're one scan lower in the venetian

        dec     cyPattern1
        jnz     short mid_8xN_first_loop

        mov     esi,ulBlockWidth
        shr     esi,1
        jz      short mid_8xN_done      ;if middle was only one quadpixel wide,
                                        ; there is no second half to do

        mov     edx,lVenetianNextScan
        sub     edx,esi
        sub     edx,esi                 ;edx = delta in bytes to go from
                                        ; end of current screen scan to
                                        ; start of next that has same pattern
                                        ; quadpixel

; Now handle second half of pattern:

        mov     edi,pvSaveScreen
        inc     edi
        mov     eax,yBrushSave
        xor     eax,1                   ;now handle 'second' half of pattern

mid_8xN_second_loop:
        push    edi                     ;save screen pointer for next scan

        mov     ebx,cyVenetianTop2
        sub     cyPatternTop2,1         ;set carry if zero or less
        sbb     ebx,0                   ;the number of scans drawn for the
                                        ; top part of the pattern is 1 more
                                        ; than that drawn for the bottom
        mov     cyVenetianTop2,ebx

        mov     ecx,pjPattern
        and     eax,ulPatIndexMask
        mov     cl,[ecx+eax]            ;load latches with current quadpixel
        add     eax,2                   ;advance to next quadpixel in pattern
                                        ; that is in the same row
        call    draw_horizontal_8xN_middle_loop
        pop     edi
        add     edi,lPlanarNextScan     ;we're one scan lower in the venetian

        dec     cyPattern2
        jnz     short mid_8xN_second_loop

mid_8xN_done:
        retn

;-----------------------------------------------------------------------;
; Routine to write the middle of an n-color 8xN pattern.
;
; Input:
;
;    ebx = number of scans to draw
;    edx = venetian delta
;    esi = loop count (same as ecx)
;    edi = destination address
;
; Output:
;
;    ebx = 0
;    edi = end address
;
;-----------------------------------------------------------------------;

        public  draw_horizontal_8xN_middle_loop
draw_horizontal_8xN_middle_loop::
        mov     ecx,esi                 ;reload our cross-scan count
@@:
        mov     [edi],al                ;write the quadpixel
        add     edi,2                   ;skip a quadpixel

        dec     ecx
        jnz     @B

        add     edi,edx                 ;move to next scan

        dec     ebx                     ;that's one more scan done
        jnz     draw_horizontal_8xN_middle_loop ;do the next scan, if any

        retn

;-----------------------------------------------------------------------;
; middle_00_4xN
;
; Draws middle of 4xN patterns.
;
; Input:
;       ulLeftMask
;       ulMiddleDest
;       ulBlockHeight
;       pjPattern     = start of pattern
;       lPlanarNextScan
;       yBrushTimesTwo        = not kept normalized
;
; Output:
;-----------------------------------------------------------------------;

        public  middle_00_4xN
middle_00_4xN::
        mov     edx,VGA_BASE + SEQ_DATA
        mov     eax,MM_ALL
        out     dx,al                   ;write to all planes

        mov     ecx,ppdev
        mov     edi,ulMiddleDest
        add     edi,[ecx].pdev_pvBitmapStart2WindowD
                                        ;adjust edi to point into the
                                        ; screen destination bank

        mov     eax,yBrushTimesTwo

        mov     edx,lVenetianNextScan
        sub     edx,ulBlockWidth        ;screen delta between rows that have

        mov     esi,ulBlockHeight
        mov     ebx,esi
        and     ebx,cyPatMinusOne       ;ebx = number of rows of pattern that
        jz      short mid00_do_lower    ; are in the upper part of the venetian

        mov     ecx,cyPatLog2
        shr     esi,cl
        inc     esi                     ;(ulBlockHeight >> cyPatLog2) + 1
                                        ; scans are drawn with each of the top
                                        ; (ulBlockHeight & cyPatternMinus1)
                                        ; rows of the pattern
        mov     cLoops,esi

mid00_upper_loop:
        push    edi                     ;save screen pointer for next scan

        mov     ecx,pjPattern
        and     eax,ulPatIndexMask
        mov     cl,[ecx+eax]            ;load latches with current quadpixel
        add     eax,2                   ;advance to next quadpixel in pattern
                                        ; that is in the same row

        mov     esi,cLoops

; eax = current index into brush
; ebx = # of scans in upper part of venetian blind
; ecx =
; edx = venetian delta
; esi = loop count
; edi = screen

@@:
        mov     ecx,cwMiddle
        rep     stosw
        add     edi,edx

        dec     esi
        jnz     @B                      ;repeat this quadpixel of the pattern
                                        ; on all the scans we can
        pop     edi
        add     edi,lPlanarNextScan     ;we're now 1 scan lower in the venetian

        dec     ebx
        jnz     short mid00_upper_loop

        mov     esi,ulBlockHeight
        cmp     esi,cyPat
        jl      short mid00_done        ;have to watch for rectangles that are
                                        ; shorter than the pattern

        mov     ebx,esi
        and     ebx,cyPatMinusOne

mid00_do_lower:
        neg     ebx
        add     ebx,cyPat               ;ebx = number of rows in pattern that
                                        ; are in the lower part of the venetian
                                        ; (namely, cyPat - # in upper)

        mov     ecx,cyPatLog2
        shr     esi,cl                  ;(ulBlockHeight >> cyPatLog2) scans
                                        ; are drawn with each of the bottom
                                        ; cyPattern - (ulBlockHeight &
                                        ; cyPatternMinus1) rows of the pattern
        mov     cLoops,esi

mid00_lower_loop:
        push    edi                     ;save screen pointer for next scan

        mov     ecx,pjPattern
        and     eax,ulPatIndexMask
        mov     cl,[ecx+eax]            ;load latches with current quadpixel
        add     eax,2                   ;advance to next quadpixel in pattern
                                        ; that is in the same row

        mov     esi,cLoops

@@:
        mov     ecx,cwMiddle
        rep     stosw
        add     edi,edx

        dec     esi
        jnz     @B                      ;repeat this quadpixel of the pattern
                                        ; on all the scans we can
        pop     edi
        add     edi,lPlanarNextScan     ;we're one scan lower in the venetian

        dec     ebx
        jnz     short mid00_lower_loop

mid00_done:
        PLAIN_RET


;-----------------------------------------------------------------------;
; middle_01_4xN
;
; Draws middle of 4xN patterns.
;
; Input:
;       ulLeftMask
;       ulMiddleDest
;       ulBlockHeight
;       pjPattern     = start of pattern
;       lPlanarNextScan
;       yBrushTimesTwo        = not kept normalized
;
; Output:
;-----------------------------------------------------------------------;

        public  middle_01_4xN
middle_01_4xN::
        mov     edx,VGA_BASE + SEQ_DATA
        mov     eax,MM_ALL
        out     dx,al                   ;write to all planes

        mov     ecx,ppdev
        mov     edi,ulMiddleDest
        add     edi,[ecx].pdev_pvBitmapStart2WindowD
                                        ;adjust edi to point into the
                                        ; screen destination bank

        mov     eax,yBrushTimesTwo

        mov     edx,lVenetianNextScan
        sub     edx,ulBlockWidth        ;screen delta between rows that have

        mov     esi,ulBlockHeight
        mov     ebx,esi
        and     ebx,cyPatMinusOne       ;ebx = number of rows of pattern that
        jz      short mid01_do_lower    ; are in the upper part of the venetian

        mov     ecx,cyPatLog2
        shr     esi,cl
        inc     esi                     ;(ulBlockHeight >> cyPatLog2) + 1
                                        ; scans are drawn with each of the top
                                        ; (ulBlockHeight & cyPatternMinus1)
                                        ; rows of the pattern
        mov     cLoops,esi
mid01_upper_loop:
        push    edi                     ;save screen pointer for next scan

        mov     ecx,pjPattern
        and     eax,ulPatIndexMask
        mov     cl,[ecx+eax]            ;load latches with current quadpixel
        add     eax,2                   ;advance to next quadpixel in pattern
                                        ; that is in the same row

        mov     esi,cLoops

; eax = current index into brush
; ebx = # of scans in upper part of venetian blind
; ecx =
; edx = venetian delta
; esi = loop count
; edi = screen

@@:
        mov     ecx,cwMiddle
        rep     stosw
        mov     [edi],al
        add     edi,edx

        dec     esi
        jnz     @B                      ;repeat this quadpixel of the pattern
                                        ; on all the scans we can
        pop     edi
        add     edi,lPlanarNextScan     ;we're now 1 scan lower in the venetian

        dec     ebx
        jnz     short mid01_upper_loop

        mov     esi,ulBlockHeight
        cmp     esi,cyPat
        jl      short mid01_done        ;have to watch for rectangles that are
                                        ; shorter than the pattern

        mov     ebx,esi
        and     ebx,cyPatMinusOne

mid01_do_lower:
        neg     ebx
        add     ebx,cyPat               ;ebx = number of rows in pattern that
                                        ; are in the lower part of the venetian
                                        ; (namely, cyPat - # in upper)

        mov     ecx,cyPatLog2
        shr     esi,cl                  ;(ulBlockHeight >> cyPatLog2) scans
                                        ; are drawn with each of the bottom
                                        ; cyPattern - (ulBlockHeight &
                                        ; cyPatternMinus1) rows of the pattern
        mov     cLoops,esi

mid01_lower_loop:
        push    edi                     ;save screen pointer for next scan

        mov     ecx,pjPattern
        and     eax,ulPatIndexMask
        mov     cl,[ecx+eax]            ;load latches with current quadpixel
        add     eax,2                   ;advance to next quadpixel in pattern
                                        ; that is in the same row

        mov     esi,cLoops

@@:
        mov     ecx,cwMiddle
        rep     stosw
        mov     [edi],al
        add     edi,edx

        dec     esi
        jnz     @B                      ;repeat this quadpixel of the pattern
                                        ; on all the scans we can
        pop     edi
        add     edi,lPlanarNextScan     ;we're one scan lower in the venetian

        dec     ebx
        jnz     short mid01_lower_loop

mid01_done:
        PLAIN_RET

;-----------------------------------------------------------------------;
; middle_10_4xN
;
; Draws middle of 4xN patterns.
;
; Input:
;       ulLeftMask
;       ulMiddleDest
;       ulBlockHeight
;       pjPattern     = start of pattern
;       lPlanarNextScan
;       yBrushTimesTwo        = not kept normalized
;
; Output:
;-----------------------------------------------------------------------;

        public  middle_10_4xN
middle_10_4xN::
        mov     edx,VGA_BASE + SEQ_DATA
        mov     eax,MM_ALL
        out     dx,al                   ;write to all planes

        mov     ecx,ppdev
        mov     edi,ulMiddleDest
        add     edi,[ecx].pdev_pvBitmapStart2WindowD
                                        ;adjust edi to point into the
                                        ; screen destination bank

        inc     edi                     ;word align destination

        mov     eax,yBrushTimesTwo

        mov     edx,lVenetianNextScan
        sub     edx,ulBlockWidth        ;screen delta between rows that have

        mov     esi,ulBlockHeight
        mov     ebx,esi
        and     ebx,cyPatMinusOne       ;ebx = number of rows of pattern that
        jz      short mid10_do_lower    ; are in the upper part of the venetian

        mov     ecx,cyPatLog2
        shr     esi,cl
        inc     esi                     ;(ulBlockHeight >> cyPatLog2) + 1
                                        ; scans are drawn with each of the top
                                        ; (ulBlockHeight & cyPatternMinus1)
                                        ; rows of the pattern
        mov     cLoops,esi

mid10_upper_loop:
        push    edi                     ;save screen pointer for next scan

        mov     ecx,pjPattern
        and     eax,ulPatIndexMask
        mov     cl,[ecx+eax]            ;load latches with current quadpixel
        add     eax,2                   ;advance to next quadpixel in pattern
                                        ; that is in the same row
        mov     esi,cLoops

; eax = current index into brush
; ebx = # of scans in upper part of venetian blind
; ecx =
; edx = venetian delta
; esi = loop count
; edi = screen

@@:
        mov     [edi-1],al
        mov     ecx,cwMiddle
        rep     stosw
        add     edi,edx

        dec     esi
        jnz     @B                      ;repeat this quadpixel of the pattern
                                        ; on all the scans we can
        pop     edi
        add     edi,lPlanarNextScan     ;we're now 1 scan lower in the venetian

        dec     ebx
        jnz     short mid10_upper_loop

        mov     esi,ulBlockHeight
        cmp     esi,cyPat
        jl      short mid10_done        ;have to watch for rectangles that are
                                        ; shorter than the pattern

        mov     ebx,esi
        and     ebx,cyPatMinusOne

mid10_do_lower:
        neg     ebx
        add     ebx,cyPat               ;ebx = number of rows in pattern that
                                        ; are in the lower part of the venetian
                                        ; (namely, cyPat - # in upper)

        mov     ecx,cyPatLog2
        shr     esi,cl                  ;(ulBlockHeight >> cyPatLog2) scans
                                        ; are drawn with each of the bottom
                                        ; cyPattern - (ulBlockHeight &
                                        ; cyPatternMinus1) rows of the pattern
        mov     cLoops,esi

mid10_lower_loop:
        push    edi                     ;save screen pointer for next scan

        mov     ecx,pjPattern
        and     eax,ulPatIndexMask
        mov     cl,[ecx+eax]            ;load latches with current quadpixel
        add     eax,2                   ;advance to next quadpixel in pattern
                                        ; that is in the same row

        mov     esi,cLoops

@@:
        mov     [edi-1],al
        mov     ecx,cwMiddle
        rep     stosw
        add     edi,edx

        dec     esi
        jnz     @B                      ;repeat this quadpixel of the pattern
                                        ; on all the scans we can
        pop     edi
        add     edi,lPlanarNextScan     ;we're one scan lower in the venetian

        dec     ebx
        jnz     short mid10_lower_loop

mid10_done:
        PLAIN_RET

;-----------------------------------------------------------------------;
; middle_11_4xN
;
; Draws middle of 4xN patterns.
;
; Input:
;       ulLeftMask
;       ulMiddleDest
;       ulBlockHeight
;       pjPattern     = start of pattern
;       lPlanarNextScan
;       yBrushTimesTwo        = not kept normalized
;
; Output:
;-----------------------------------------------------------------------;

        public  middle_11_4xN
middle_11_4xN::
        mov     edx,VGA_BASE + SEQ_DATA
        mov     eax,MM_ALL
        out     dx,al                   ;write to all planes

        mov     ecx,ppdev
        mov     edi,ulMiddleDest
        add     edi,[ecx].pdev_pvBitmapStart2WindowD
                                        ;adjust edi to point into the
                                        ; screen destination bank

        inc     edi                     ;word align destination
        dec     cwMiddle                ;first and last bytes count as 1 word

        mov     eax,yBrushTimesTwo

        mov     edx,lVenetianNextScan
        sub     edx,ulBlockWidth        ;screen delta between rows that have
        add     edx,2                   ;plus extra word for 1st and last byte

        mov     esi,ulBlockHeight
        mov     ebx,esi
        and     ebx,cyPatMinusOne       ;ebx = number of rows of pattern that
        jz      short mid11_do_lower    ; are in the upper part of the venetian

        mov     ecx,cyPatLog2
        shr     esi,cl
        inc     esi                     ;(ulBlockHeight >> cyPatLog2) + 1
                                        ; scans are drawn with each of the top
                                        ; (ulBlockHeight & cyPatternMinus1)
                                        ; rows of the pattern

        mov     cLoops,esi

mid11_upper_loop:
        push    edi                     ;save screen pointer for next scan

        mov     ecx,pjPattern
        and     eax,ulPatIndexMask
        mov     cl,[ecx+eax]            ;load latches with current quadpixel
        add     eax,2                   ;advance to next quadpixel in pattern
                                        ; that is in the same row

        mov     esi,cLoops

; eax = current index into brush
; ebx = # of scans in upper part of venetian blind
; ecx =
; edx = venetian delta
; esi = loop count
; edi = screen

@@:
        mov     [edi-1],al
        mov     ecx,cwMiddle
        rep     stosw
        mov     [edi],al
        add     edi,edx

        dec     esi
        jnz     @B                      ;repeat this quadpixel of the pattern
                                        ; on all the scans we can
        pop     edi
        add     edi,lPlanarNextScan     ;we're now 1 scan lower in the venetian

        dec     ebx
        jnz     short mid11_upper_loop

        mov     esi,ulBlockHeight
        cmp     esi,cyPat
        jl      short mid11_done        ;have to watch for rectangles that are
                                        ; shorter than the pattern

        mov     ebx,esi
        and     ebx,cyPatMinusOne

mid11_do_lower:
        neg     ebx
        add     ebx,cyPat               ;ebx = number of rows in pattern that
                                        ; are in the lower part of the venetian
                                        ; (namely, cyPat - # in upper)

        mov     ecx,cyPatLog2
        shr     esi,cl                  ;(ulBlockHeight >> cyPatLog2) scans
                                        ; are drawn with each of the bottom
                                        ; cyPattern - (ulBlockHeight &
                                        ; cyPatternMinus1) rows of the pattern

        mov     cLoops,esi

mid11_lower_loop:
        push    edi                     ;save screen pointer for next scan

        mov     ecx,pjPattern
        and     eax,ulPatIndexMask
        mov     cl,[ecx+eax]            ;load latches with current quadpixel
        add     eax,2                   ;advance to next quadpixel in pattern
                                        ; that is in the same row

        mov     esi,cLoops

@@:
        mov     [edi-1],al
        mov     ecx,cwMiddle
        rep     stosw
        mov     [edi],al
        add     edi,edx

        dec     esi
        jnz     @B                      ;repeat this quadpixel of the pattern
                                        ; on all the scans we can
        pop     edi
        add     edi,lPlanarNextScan     ;we're one scan lower in the venetian

        dec     ebx
        jnz     short mid11_lower_loop

mid11_done:
        inc     cwMiddle                ;restore cwMiddle
        PLAIN_RET

;-----------------------------------------------------------------------;

endProc vColorPat

        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\vga\disp\8bpp\stroke.c ===
/******************************Module*Header*******************************\
* Module Name: Stroke.c
*
* DrvStrokePath for VGA driver
*
* Copyright (c) 1992 Microsoft Corporation
\**************************************************************************/

#include "driver.h"
#include "lines.h"

// Style array for alternate style (alternates one pixel on, one pixel off):

STYLEPOS gaspAlternateStyle[] = { 1 };

// Array to compute ROP masks:

LONG gaiLineMix[] = {
    AND_ZERO   | XOR_ONE,
    AND_ZERO   | XOR_ZERO,
    AND_NOTPEN | XOR_NOTPEN,
    AND_NOTPEN | XOR_ZERO,
    AND_ZERO   | XOR_NOTPEN,
    AND_PEN    | XOR_PEN,
    AND_ONE    | XOR_ONE,
    AND_ONE    | XOR_PEN,
    AND_PEN    | XOR_ONE,
    AND_PEN    | XOR_ZERO,
    AND_ONE    | XOR_NOTPEN,
    AND_ONE    | XOR_ZERO,
    AND_PEN    | XOR_NOTPEN,
    AND_ZERO   | XOR_PEN,
    AND_NOTPEN | XOR_ONE,
    AND_NOTPEN | XOR_PEN
};

// We have 4 basic strip drawers, one for every semi-octant.  The near-
// horizontal semi-octant is number 0, and the rest are numbered
// consecutively.

// Prototypes to go to the screen and handle any ROPs:

VOID vStripSolid0(STRIP*, LINESTATE*, LONG*);
VOID vStripSolid1(STRIP*, LINESTATE*, LONG*);
VOID vStripSolid2(STRIP*, LINESTATE*, LONG*);
VOID vStripSolid3(STRIP*, LINESTATE*, LONG*);

VOID vStripStyled0(STRIP*, LINESTATE*, LONG*);
VOID vStripStyled123(STRIP*, LINESTATE*, LONG*);

// Prototypes to go to the screen and handle only set-style ROPs:

VOID vStripSolidSet0(STRIP*, LINESTATE*, LONG*);
VOID vStripSolidSet1(STRIP*, LINESTATE*, LONG*);
VOID vStripSolidSet2(STRIP*, LINESTATE*, LONG*);
VOID vStripSolidSet3(STRIP*, LINESTATE*, LONG*);

VOID vStripStyledSet0(STRIP*, LINESTATE*, LONG*);
VOID vStripStyledSet123(STRIP*, LINESTATE*, LONG*);

PFNSTRIP gapfnStrip[] = {
    vStripSolid0,
    vStripSolid3,
    vStripSolid1,
    vStripSolid2,

    vStripStyled0,
    vStripStyled123,
    vStripStyled123,
    vStripStyled123,

    vStripSolidSet0,
    vStripSolidSet3,
    vStripSolidSet1,
    vStripSolidSet2,

    vStripStyledSet0,
    vStripStyledSet123,
    vStripStyledSet123,
    vStripStyledSet123,
};

/******************************Public*Routine******************************\
* BOOL DrvStrokePath(pso, ppo, pco, pxo, pbo, pptlBrushOrg, pla, mix)
*
* Strokes the path.
\**************************************************************************/

BOOL DrvStrokePath(
SURFOBJ*   pso,
PATHOBJ*   ppo,
CLIPOBJ*   pco,
XFORMOBJ*  pxo,
BRUSHOBJ*  pbo,
POINTL*    pptlBrushOrg,
LINEATTRS* pla,
MIX        mix)
{
    STYLEPOS  aspLtoR[STYLE_MAX_COUNT];
    STYLEPOS  aspRtoL[STYLE_MAX_COUNT];
    LINESTATE ls;
    PFNSTRIP* apfn;
    FLONG     fl;
    PPDEV     ppdev = (PPDEV) pso->dhsurf;

    UNREFERENCED_PARAMETER(pxo);
    UNREFERENCED_PARAMETER(pptlBrushOrg);

// Fast lines can't handle trivial clipping, ROPs other than R2_COPYPEN, or
// styles:

    mix &= 0xf;
    if ((mix == 0x0d) &&
        (pco->iDComplexity == DC_TRIVIAL) &&
        (pla->pstyle == NULL) && !(pla->fl & LA_ALTERNATE))
    {
        vFastLine(ppdev, ppo, ppdev->lNextScan,
                  (pbo->iSolidColor << 8) | (pbo->iSolidColor & 0xff));
        return(TRUE);
    }

    fl = 0;

// Look after styling initialization:

    if (pla->fl & LA_ALTERNATE)
    {
        ASSERTVGA(pla->pstyle == (FLOAT_LONG*) NULL && pla->cstyle == 0,
               "Non-empty style array for PS_ALTERNATE");

        ls.bStartIsGap  = 0;                        // First pel is a dash
        ls.cStyle       = 1;                        // Size of style array
        ls.spTotal      = 1;                        // Sum of style array
        ls.spTotal2     = 2;                        // Twice the sum
        ls.aspRtoL      = &gaspAlternateStyle[0];   // Right-to-left array
        ls.aspLtoR      = &gaspAlternateStyle[0];   // Left-to-right array
        ls.spNext       = HIWORD(pla->elStyleState.l) & 1;
                                                    // Light first pixel if
                                                    //   a multiple of 2
        ls.xyDensity    = 1;                        // Each 'dot' is one
                                                    //   pixel long
        fl             |= FL_ARBITRARYSTYLED;
    }
    else if (pla->pstyle != (FLOAT_LONG*) NULL)
    {
        FLOAT_LONG* pstyle;
        STYLEPOS*   pspDown;
        STYLEPOS*   pspUp;

        ASSERTVGA(pla->cstyle <= STYLE_MAX_COUNT, "Style array too large");

    // Compute length of style array:

        pstyle = &pla->pstyle[pla->cstyle];

        ls.xyDensity = STYLE_DENSITY;
        ls.spTotal   = 0;
        while (pstyle-- > pla->pstyle)
        {
            ls.spTotal += pstyle->l;
        }

    // The style array is given in 'style' units.  Since we're going to
    // assign each unit to be STYLE_DENSITY (3) pixels long, multiply:

        ls.spTotal *= STYLE_DENSITY;
        ls.spTotal2 = 2 * ls.spTotal;

    // Compute starting style position (this is guaranteed not to overflow).
    // Note that since the array repeats infinitely, this number might
    // actually be more than ls.spTotal2, but we take care of that later
    // in our code:

        ls.spNext = HIWORD(pla->elStyleState.l) * STYLE_DENSITY +
                    LOWORD(pla->elStyleState.l);

        fl            |= FL_ARBITRARYSTYLED;
        ls.cStyle      = pla->cstyle;
        ls.aspRtoL     = aspRtoL;   // Style array in right-to-left order
        ls.aspLtoR     = aspLtoR;   // Style array in left-to-right order

    // ulStartMask determines if the first entry in the style array is for
    // a dash or a gap:

        ls.bStartIsGap = (pla->fl & LA_STARTGAP) ? -1L : 0L;

        pstyle  = pla->pstyle;
        pspDown = &ls.aspRtoL[ls.cStyle - 1];
        pspUp   = &ls.aspLtoR[0];

    // We always draw strips left-to-right, but styles have to be laid
    // down in the direction of the original line.  This means that in
    // the strip code we have to traverse the style array in the
    // opposite direction;

        while (pspDown >= &ls.aspRtoL[0])
        {
            ASSERTVGA(pstyle->l > 0 && pstyle->l <= STYLE_MAX_VALUE,
                   "Illegal style array value");

            *pspDown = pstyle->l * STYLE_DENSITY;
            *pspUp   = *pspDown;

            pspUp++;
            pspDown--;
            pstyle++;
        }
    }

    {
    // All ROPs are handled in a single pass:

        ULONG achColor[4];
        LONG  iIndex;
        ULONG iColor = (pbo->iSolidColor & 0xff);

        achColor[AND_ZERO]   =  0;
        achColor[AND_PEN]    =  pbo->iSolidColor;
        achColor[AND_NOTPEN] = ~pbo->iSolidColor;
        achColor[AND_ONE]    =  (ULONG) -1L;

        iIndex = gaiLineMix[mix];

    // We have special strip drawers for set-style ROPs (where we don't
    // have to read video memory):

        if ((iIndex & 0xff) == AND_ZERO)
            fl |= FL_SET;

    // Put the AND index in the low byte, and the XOR index in the next:

        *((BYTE*) &ls.chAndXor)     = (BYTE) achColor[iIndex & 0xff];
        *((BYTE*) &ls.chAndXor + 1) = (BYTE) achColor[iIndex >> MIX_XOR_OFFSET];
    }

    apfn = &gapfnStrip[4 * ((fl & FL_STRIP_ARRAY_MASK) >> FL_STRIP_ARRAY_SHIFT)];

// Set up to enumerate the path:

    if (pco->iDComplexity != DC_COMPLEX)
    {
        RECTL     arclClip[4];                   // For rectangular clipping
        PATHDATA  pd;
        RECTL*    prclClip = (RECTL*) NULL;
        BOOL      bMore;
        ULONG     cptfx;
        POINTFIX  ptfxStartFigure;
        POINTFIX  ptfxLast;
        POINTFIX* pptfxFirst;
        POINTFIX* pptfxBuf;

        if (pco->iDComplexity == DC_RECT)
        {
            fl |= FL_SIMPLE_CLIP;

            arclClip[0]        =  pco->rclBounds;

        // FL_FLIP_D:

            arclClip[1].top    =  pco->rclBounds.left;
            arclClip[1].left   =  pco->rclBounds.top;
            arclClip[1].bottom =  pco->rclBounds.right;
            arclClip[1].right  =  pco->rclBounds.bottom;

        // FL_FLIP_V:

            arclClip[2].top    = -pco->rclBounds.bottom + 1;
            arclClip[2].left   =  pco->rclBounds.left;
            arclClip[2].bottom = -pco->rclBounds.top + 1;
            arclClip[2].right  =  pco->rclBounds.right;

        // FL_FLIP_V | FL_FLIP_D:

            arclClip[3].top    =  pco->rclBounds.left;
            arclClip[3].left   = -pco->rclBounds.bottom + 1;
            arclClip[3].bottom =  pco->rclBounds.right;
            arclClip[3].right  = -pco->rclBounds.top + 1;

            prclClip = arclClip;
        }

        do {
            bMore = PATHOBJ_bEnum(ppo, &pd);

            cptfx = pd.count;
            if (cptfx == 0)
            {
                ASSERTVGA(!bMore, "Empty path record in non-empty path");
                break;
            }

            if (pd.flags & PD_BEGINSUBPATH)
            {
                ptfxStartFigure  = *pd.pptfx;
                pptfxFirst       = pd.pptfx;
                pptfxBuf         = pd.pptfx + 1;
                cptfx--;
            }
            else
            {
                pptfxFirst       = &ptfxLast;
                pptfxBuf         = pd.pptfx;
            }

            if (pd.flags & PD_RESETSTYLE)
                ls.spNext = 0;

        // We have to check for cptfx == 0 because the only point in the
        // subpath may have been the StartFigure point:

            if (cptfx > 0)
            {
                if (!bLines(ppdev,
                            pptfxFirst,
                            pptfxBuf,
                            (RUN*) NULL,
                            cptfx,
                            &ls,
                            prclClip,
                            apfn,
                            fl))
                    return(FALSE);
            }

            ptfxLast = pd.pptfx[pd.count - 1];

            if (pd.flags & PD_CLOSEFIGURE)
            {
                if (!bLines(ppdev,
                            &ptfxLast,
                            &ptfxStartFigure,
                            (RUN*) NULL,
                            1,
                            &ls,
                            prclClip,
                            apfn,
                            fl))
                    return(FALSE);
            }
        } while (bMore);

        if (fl & FL_STYLED)
        {
        // Save the style state:

            ULONG ulHigh;
            ULONG ulLow;

            ulHigh = ls.spNext / ls.xyDensity;
            ulLow  = ls.spNext % ls.xyDensity;

            pla->elStyleState.l = MAKELONG(ulLow, ulHigh);
        }
    }
    else
    {
    // Local state for path enumeration:

        BOOL bMore;
        union {
            BYTE     aj[offsetof(CLIPLINE, arun) + RUN_MAX * sizeof(RUN)];
            CLIPLINE cl;
        } cl;

        fl |= FL_COMPLEX_CLIP;

    // We use the clip object when non-simple clipping is involved:

        PATHOBJ_vEnumStartClipLines(ppo, pco, pso, pla);

        do {
            bMore = PATHOBJ_bEnumClipLines(ppo, sizeof(cl), &cl.cl);
            if (cl.cl.c != 0)
            {
                if (fl & FL_STYLED)
                {
                    ls.spComplex = HIWORD(cl.cl.lStyleState) * ls.xyDensity
                                 + LOWORD(cl.cl.lStyleState);
                }
                if (!bLines(ppdev,
                            &cl.cl.ptfxA,
                            &cl.cl.ptfxB,
                            &cl.cl.arun[0],
                            cl.cl.c,
                            &ls,
                            (RECTL*) NULL,
                            apfn,
                            fl))
                    return(FALSE);
            }
        } while (bMore);
    }

    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\vga\disp\8bpp\i386\fastline.asm ===
;---------------------------Module-Header------------------------------;
; Module Name: fastline.asm
;
; This module goes completely overboard in trying to do fast lines.
; It handles only solid R2_COPYPEN unclipped lines.
;
; Unfortunately, I know of only 4 performance tricks:
;
;    1) Most VGAs can co-process the last write to video memory,
;       so we employ a traditional Bresenham-style algorithm (as
;       opposed to a run-length version) as this minimizes our
;       set-up time, and we can do some work between video writes
;       without any throughput penalty.
;
;    2) Most VGAs can do one aligned word write faster than two
;       byte writes; consequently we derive a double-stepping DDA
;       that does aligned word writes whenever possible (note that
;       this only makes sense on x-major lines).
;
;    3) Planar mode can be used to speed up long horizontal lines,
;       where the cost to switch from linear to planar mode is offset
;       by the ability to light 8 pixels on every word write instead
;       of 2.
;
;    4) Most lines have integer end-points, so we accelerate those.
;
; If you're not familiar with GIQ lines, this is not the code to start
; with.
;
; Copyright (c) 1992-1993 Microsoft Corporation
;-----------------------------------------------------------------------;

        .386

        .model  small,c

        assume cs:FLAT,ds:FLAT,es:FLAT,ss:FLAT
        assume fs:nothing,gs:nothing

        .xlist
        include stdcall.inc             ;calling convention cmacros
        include i386\egavga.inc
        include i386\strucs.inc
        include i386\driver.inc
        include i386\lines.inc
        .list

; Length of horizontal line needed before we'll do it in planar mode:

        NUM_PELS_NEEDED_FOR_PLANAR_HORIZONTAL   equ 64

; Line coordinates are given in 28.4 fixed point format:

        F               equ 16
        FLOG2           equ 4

; The following values must match those in winddi.h!

        PD_BEGINSUBPATH equ 00000001h
        PD_ENDSUBPATH   equ 00000002h
        PD_RESETSTYLE   equ 00000004h
        PD_CLOSEFIGURE  equ 00000008h
        PD_BEZIERS      equ 00000010h

        PATHDATA struc

        pd_flags        dd  ?
        pd_count        dd  ?
        pd_pptfx        dd  ?

        PATHDATA ends

;-------------------------------------------------------------------------;
; I felt a compelling need to use 'ebp' as a 7th general register, and we
; have no nifty macros for dereferencing frame variables off 'esp'.  So
; with this structure I am rolling my own stack frame:

STATE_MEM_SIZE          equ 4           ;4 dwords
PROC_MEM_SIZE           equ 6           ;6 dwords

STACK_FRAME struc

; State variables (don't add/delete fields without modifying STATE_MEM_SIZE!)

sf_ulOurEbp             dd ?            ;useful for debugging
sf_ulOriginalEbx        dd ?
sf_ulOriginalEdi        dd ?
sf_ulOriginalEsi        dd ?

; Frame variables (feel free to add/delete fields):

sf_lDelta               dd ?            ;sign depends on going up or down
sf_pfnReturn            dd ?            ;where to jump after getting next bank
sf_pfnNextBank          dd ?            ;routine for getting the next bank
sf_y0                   dd ?            ;GIQ variables
sf_y1                   dd ?
sf_x1                   dd ?
sf_pjStart              dd ?            ;for remembering edi
sf_cAfterThisBank       dd ?            ;# of pixels to light after this bank
sf_ptlOrg               db (size POINTL) dup (?)
                                        ;our  origin for normalizing the line
sf_ptfxLast             db (size POINTL) dup (?)
                                        ;the most recent point
sf_ptfxStartFigure      db (size POINTL) dup (?)
                                        ;the figure's 1st point
sf_bMore                dd ?            ;more path records to get?
sf_pptfxEnd             dd ?            ;points to last point in record
sf_pptfx                dd ?            ;points to current point
sf_pd                   db (size PATHDATA) dup (?)
                                        ;pathdata structure

; Procedure variables (don't add/delete fields without modifying
; PROC_MEM_SIZE!)

sf_ulOriginalEbp        dd ?
sf_ulOriginalReturn     dd ?
sf_ppdev                dd ?
sf_ppo                  dd ?
sf_lNextScan            dd ?
sf_iColor               dd ?

STACK_FRAME ends

        .code

        EXTRNP  PATHOBJ_bEnum,8

        ROUND_X_DOWN            equ     01h
        ROUND_Y_DOWN            equ     02h
        ROUND_SLOPE_ONE         equ     04h
        ROUND_X_AND_Y_DOWN      equ     (ROUND_X_DOWN + ROUND_Y_DOWN)
        ROUND_X_DOWN_SLOPE_ONE  equ     (ROUND_X_DOWN + ROUND_SLOPE_ONE)
        ROUND_Y_DOWN_SLOPE_ONE  equ     (ROUND_Y_DOWN + ROUND_SLOPE_ONE)

;--------------------------------Macro----------------------------------;
; GIQ flags
;
; This macros computes the start pixel, the number of pixels to
; be lit, and the initial error term given a GIQ line.  The line must
; have already been normalized such that dM >= dN, dN >= 0.
;
; Input:   eax - M0
;          ebx - N0
;          ecx - dM
;          edx - dN
; Trashes:
;          esi, ebp
;          [esp].sf_ptlOrg.ptl_x, [esp].sf_ptlOrg.ptl_y
; Output:
;          [esp].sf_x1  - x-coordinate of last pixel (exclusive)
;          eax - x-coordinate of first pixel
;          ebx - error term
;          ecx - dM
;          edx - dN
;          edi - y-coordinate of first pixel
;-----------------------------------------------------------------------;

GIQ     macro   flags
        local   compute_x1, compute_error_term

; We normalize our coordinate system so that if the start point is
; (M0/F, N0/F), the origin is at (floor(M0/F), (N0/F)):

        mov     esi,eax
        mov     edi,ebx
        sar     esi,FLOG2
        sar     edi,FLOG2
        mov     [esp].sf_ptlOrg.ptl_x,esi
                                        ;ptlOrg.x = floor(M0 / F)
        mov     [esp].sf_ptlOrg.ptl_y,edi
                                        ;ptlOrg.y = floor(N0 / F)

; Calculate the correct [esp].sf_x1:

        lea     edi,[ebx + edx]         ;edi = N1
        and     edi,F - 1

    if (flags AND ROUND_X_DOWN)

    if (flags AND ROUND_SLOPE_ONE)
        cmp     edi,8
        sbb     edi,-1
    endif

        cmp     edi,1
        sbb     edi,8                   ;N1 -= 8
    else
        sub     edi,8                   ;N1 -= 8
    endif
        sbb     esi,esi
        xor     edi,esi
        sub     edi,esi                 ;N1 = ABS(N1)

        lea     ebp,[eax + ecx]
        mov     esi,ebp
        sar     ebp,FLOG2
        and     esi,F - 1
        jz      short @f                ;special case for M1 == 0
        cmp     esi,edi                 ;cmp M1, N1
        sbb     ebp,-1                  ;ebp is now one pixel past the actual
@@:                                     ; end coordinate (note that it hasn't
                                        ; been affected by the origin shift)

compute_error_term:

; eax = M0
; ebx = N0
; ebp = x1
; ecx = dM
; edx = dN

        and     ebx,F - 1
        mov     [esp].sf_x1,ebp         ;save x1

; Calculate our error term for x = 0.
;
; NOTE: Since this routine is used only for lines that are unclipped, we
;       are guaranteed by our screen size that the values will be far less
;       than 32 bits in significance, and so we don't worry about overflow.
;       If this is used for clipped lines, these multiplies will have to
;       be converted to give 64 bit results, because we can have 36 bits of
;       significance!


        lea     edi,[ebx + 8]           ;edi = N0 + 8
        mov     esi,ecx
        imul    esi,edi                 ;esi = dM * (N0 + 8)
        mov     edi,edx

; We have to special case when M0 is 0 -- we know x0 will be zero.
; So we jump ahead a bit to a place where 'eax' is assumed to contain
; x0 -- and it just so happens 'eax' is zero in this case:

        and     eax,F - 1
        jz      short @f
        imul    edi,eax                 ;edi = dN * M0
        sub     esi,edi

; Calculate the x-coordinate of the first pixel:

    if (flags AND ROUND_X_DOWN)

    if (flags AND ROUND_SLOPE_ONE)
        cmp     ebx,8
        sbb     ebx,-1
    endif

        cmp     ebx,1
        sbb     ebx,8                   ;N0 -= 8
    else
        sub     ebx,8                   ;N0 -= 8
    endif
        sbb     edi,edi
        xor     ebx,edi
        sub     ebx,edi                 ;N0 = ABS(N0)
        cmp     eax,ebx
        sbb     eax,eax
        not     eax                     ;eax = -x0

; Now adjust the error term accordingly:

@@:
    if (flags AND ROUND_Y_DOWN)
        dec     esi
    endif
        sar     esi,FLOG2               ;esi = floor((N0 + 8) dM - M0 dN] / 16)

        mov     ebx,[esp].sf_ptlOrg.ptl_x
        mov     edi,[esp].sf_ptlOrg.ptl_y

        sub     ebx,eax                 ;ebx = ptlOrg.ptl_x + x0

        and     eax,edx
        add     eax,esi
        sub     eax,ecx                 ;eax = dN * x0 + initial error - dM
        jl      short @f                ;if the error term >= 0, we have to
        sub     eax,ecx                 ; add 1 to the y position and subtract
        inc     edi                     ; dM off again
@@:
        xchg    eax,ebx

endm

;--------------------------------Macro----------------------------------;
; GIQR flags
;
; Same as above, except it handles flips about the line x = y.
;
; Input:   eax - M0
;          ebx - N0
;          ecx - dM
;          edx - dN
; Trashes:
;          esi, ebp
;          [esp].sf_ptlOrg.ptl_x, [esp].sf_ptlOrg.ptl_y
; Output:
;          [esp].sf_y1  - y-coordinate of last pixel (exclusive)
;          eax - x-coordinate of first pixel
;          ebx - error term
;          ecx - dM
;          edx - dN
;          edi - y-coordinate of first pixel
;-----------------------------------------------------------------------;

GIQR    macro   flags

; We normalize our coordinate system so that if the start point is
; (M0/F, N0/F), the origin is at (floor(M0/F), (N0/F)):

        mov     esi,eax
        mov     edi,ebx
        sar     esi,FLOG2
        sar     edi,FLOG2
        mov     [esp].sf_ptlOrg.ptl_x,esi
                                        ;ptlOrg.x = floor(M0 / F)
        mov     [esp].sf_ptlOrg.ptl_y,edi
                                        ;ptlOrg.y = floor(N0 / F)

; Calculate the correct [esp].sf_y1:

        lea     edi,[eax + ecx]         ;edi = M1
        and     edi,F - 1

    if (flags AND ROUND_Y_DOWN)
        cmp     edi,1
        sbb     edi,8                   ;M1 -= 8
    else
        sub     edi,8                   ;M1 -= 8
    endif
        sbb     esi,esi
        xor     edi,esi
        sub     edi,esi                 ;M1 = ABS(M1)

        lea     ebp,[ebx + edx]
        mov     esi,ebp
        sar     ebp,FLOG2
        and     esi,F - 1
        jz      short @f                ;special case for N1 == 0
        cmp     esi,edi                 ;cmp N1, M1
        sbb     ebp,-1                  ;ebp is now one pixel past the actual
@@:                                     ; end coordinate (note that it hasn't
                                        ; been affected by the origin shift)
        and     eax,F - 1
        mov     [esp].sf_y1,ebp

; Calculate our error term for y = 0.
;
; NOTE: Since this routine is used only for lines that are unclipped, we
;       are guaranteed by our screen size that the values will be far less
;       than 32 bits in significance, and so we don't worry about overflow.
;       If this is used for clipped lines, these multiplies will have to
;       be converted to give 64 bit results, because we can have 36 bits of
;       significance!

        lea     edi,[eax + 8]           ;edi = M0 + 8
        mov     esi,edx
        imul    esi,edi                 ;esi = dN * (M0 + 8)
        mov     edi,ecx

; We have to special case when N0 is 0 -- we know y0 will be zero.
; So we jump ahead a bit to a place where 'ebx' is assumed to contain
; y0 -- and it just so happens 'ebx' is zero in this case:

        and     ebx,F - 1
        jz      short @f
        imul    edi,ebx                 ;edi = dM * N0
        sub     esi,edi

; Calculate the x-coordinate of the first pixel:

    if (flags AND ROUND_Y_DOWN)
        cmp     eax,1
        sbb     eax,8                   ;M0 -= 8
    else
        sub     eax,8                   ;M0 -= 8
    endif
        sbb     edi,edi
        xor     eax,edi
        sub     eax,edi                 ;M0 = ABS(M0)
        cmp     ebx,eax
        sbb     ebx,ebx
        not     ebx                     ;ebx = -y0

; Now adjust the error term accordingly:

@@:
    if (flags AND ROUND_X_DOWN)
        dec     esi
    endif
        sar     esi,FLOG2               ;esi = floor((M0 + 8) dN - N0 dM] / 16)

        mov     eax,[esp].sf_ptlOrg.ptl_x
        mov     edi,[esp].sf_ptlOrg.ptl_y

        sub     edi,ebx                 ;edi = ptlOrg.ptl_y + y0

        and     ebx,ecx
        add     ebx,esi
        sub     ebx,edx                 ;ebx = dM * x0 + initial error - dN
        jl      short @f                ;if the error term >= 0, we have to
        sub     ebx,edx                 ; add 1 to the x position and subtract
        inc     eax                     ; dN off again
@@:

endm

;---------------------------Public-Routine------------------------------;
; vFastLine(ppdev, ppo, lNextScan, iColor)
;
; Draws fast lines.  Or at least attempts to.
;
; Input:
;
;    ppdev     - PDEV pointer
;    ppo       - path
;    lNextScan - delta to start of next scan (same as ppdev->lNextScan)
;    iColor    - color (least significant byte must be the same as the next
;                least signficant byte, so that we can do words writes)
;
;-----------------------------------------------------------------------;

; NOTE: Don't go changing parameters without also changing STACK_FRAME!

cProc vFastLine,16,<     \
    uses esi edi ebx,    \
    ebp_ppdev:     ptr,  \
    ebp_ppo:       ptr,  \
    ebp_lNextScan: ptr,  \
    ebp_iColor:    dword >

; Leave room for our stack frame.
;
; NOTE: Don't add local variables here -- you can't reference them with
;       ebp anyway!  Add them to the STACK_FRAME structure.

    local aj[(size STACK_FRAME) - 4 * (STATE_MEM_SIZE + PROC_MEM_SIZE)]: byte

; We save 'ebp' on the stack (note that STACK_FRAME accounts for this push):

        push    ebp

; Now get some path stuff:

next_record:

        mov     esi,[esp].sf_ppo
        lea     eax,[esp].sf_pd
        cCall   PATHOBJ_bEnum,<esi,eax>
        mov     [esp].sf_bMore,eax      ;save away return code for later

        mov     eax,[esp].sf_pd.pd_count;if 0 points in record, get outta here
        or      eax,eax
        jz      check_for_closefigure

        lea     edi,[8 * eax - 8]
        add     edi,[esp].sf_pd.pd_pptfx
        mov     [esp].sf_pptfxEnd,edi   ;points to last point in record

        mov     ebx,[esp].sf_pd.pd_flags
        test    ebx,PD_BEGINSUBPATH
        jz      short continue_subpath

; Handle a new sub-path:

        mov     esi,[esp].sf_pd.pd_pptfx
        add     esi,8
        mov     [esp].sf_pptfx,esi

        mov     ecx,[edi].ptl_x         ;remember last point in case we have
        mov     edx,[edi].ptl_y         ; to continue to another record
        mov     [esp].sf_ptfxLast.ptl_x,ecx
        mov     [esp].sf_ptfxLast.ptl_y,edx

        mov     eax,[esi - 8].ptl_x     ;load up current start and end point
        mov     ebx,[esi - 8].ptl_y
        mov     ecx,[esi].ptl_x
        mov     edx,[esi].ptl_y
        mov     [esp].sf_ptfxStartFigure.ptl_x,eax
        mov     [esp].sf_ptfxStartFigure.ptl_y,ebx

        cmp     esi,[esp].sf_pptfxEnd   ;we have to be careful when the only
                                        ; point in the record is the start-
                                        ; figure point (pretty rare)
        jbe     new_line
        jmp     short next_record

continue_subpath:

; This record continues the path:

        mov     esi,[esp].sf_pd.pd_pptfx
        mov     eax,[esp].sf_ptfxLast.ptl_x ;load up current start point
        mov     ebx,[esp].sf_ptfxLast.ptl_y

        mov     ecx,[edi].ptl_x         ;remember last point in case we have
        mov     edx,[edi].ptl_y         ; to continue to another record
        mov     [esp].sf_ptfxLast.ptl_x,ecx
        mov     [esp].sf_ptfxLast.ptl_y,edx

        mov     ecx,[esi].ptl_x         ;load up current end point
        mov     edx,[esi].ptl_y
        mov     [esp].sf_pptfx,esi
        jmp     short new_line

;/////////////////////////////////////////////////////////////////////
;// Next Line Stuff
;/////////////////////////////////////////////////////////////////////

handle_closefigure:
        mov     [esp].sf_pd.pd_flags,0
        mov     eax,[esp].sf_ptfxLast.ptl_x
        mov     ebx,[esp].sf_ptfxLast.ptl_y
        mov     ecx,[esp].sf_ptfxStartFigure.ptl_x
        mov     edx,[esp].sf_ptfxStartFigure.ptl_y
        jmp     new_line

; Before getting the next path record, see if we have to do a closefigure:

check_for_closefigure:
        test    [esp].sf_pd.pd_flags,PD_CLOSEFIGURE
        jnz     handle_closefigure
        mov     ecx,[esp].sf_bMore
        or      ecx,ecx
        jnz     next_record

all_done:

        pop     ebp
        cRet    vFastLine

        public  next_line
next_line::
        mov     esi,[esp].sf_pptfx
        cmp     esi,[esp].sf_pptfxEnd
        jae     short check_for_closefigure

        mov     eax,[esi].ptl_x
        mov     ebx,[esi].ptl_y
        mov     ecx,[esi+8].ptl_x
        mov     edx,[esi+8].ptl_y
        add     esi,8
        mov     [esp].sf_pptfx,esi

;/////////////////////////////////////////////////////////////////////
;// Main Loop
;/////////////////////////////////////////////////////////////////////

        public  new_line
new_line::

; Octants are numbered as follows:
;
;        \ 5 | 6 /
;         \  |  /
;        4 \ | / 7
;           \ /
;       -----+-----
;           /|\
;        3 / | \ 0
;         /  |  \
;        / 2 | 1 \
;

; eax = M0
; ebx = N0
; ecx = M1 (dM)
; edx = N1 (dN)

        sub     ecx,eax
        jl      octants_2_3_4_5
        sub     edx,ebx
        jl      octants_6_7
        cmp     ecx,edx
        jl      octant_1

;/////////////////////////////////////////////////////////////////////
;// Octant 0
;/////////////////////////////////////////////////////////////////////

        public  octant_0
octant_0::
        mov     esi,[esp].sf_lNextScan
        mov     [esp].sf_lDelta,esi     ;we're going down
        mov     [esp].sf_pfnNextBank,offset bank_x_major_next_lower

        mov     esi,ecx
        or      esi,edx
        jz      next_line               ;we do an early check here for
                                        ; lines that start and end on the
                                        ; same GIQ point, because those
                                        ; occur surprisingly often.
        or      esi,eax
        or      esi,ebx
        and     esi,F - 1
        jnz     oct_0_non_integer

        or      edx,edx
        jz      do_horizontal_line

        mov     esi,[esp].sf_ppdev
        sar     eax,FLOG2               ;x0
        sar     ebx,FLOG2               ;y0

        cmp     ebx,[esi].pdev_rcl1WindowClip.yTop
        jl      short oct_0_map_in_bank

        cmp     ebx,[esi].pdev_rcl1WindowClip.yBottom
        jl      short oct_0_done_bank_map

oct_0_map_in_bank:
        push    eax
        push    ecx
        push    edx

; ebx, esi, edi and ebp are preserved according to C calling conventions:

        ptrCall <dword ptr [esi].pdev_pfnBankControl>, \
                <esi, ebx, JustifyTop>  ;###

        pop     edx
        pop     ecx
        pop     eax

        public  oct_0_done_bank_map
oct_0_done_bank_map::
        mov     edi,[esp].sf_lNextScan
        imul    edi,ebx
        add     edi,[esi].pdev_pvBitmapStart
        add     edi,eax                 ;edi now points to start byte

        mov     ebp,[esi].pdev_rcl1WindowClip.yBottom
        sub     ebp,ebx                 ;### ebp = # of scans before end of bank

        mov     esi,ecx
        sar     esi,FLOG2               ;esi = # of pixels to lay down

        mov     ebx,-1                  ;### round y = 1/2 *DOWN* in value
        sub     ebx,ecx
        sar     ebx,1                   ;now have error term

        mov     eax,[esp].sf_iColor
        sub     ecx,edx                 ;ecx = dM - dN
        cmp     edx,ecx
        jg      oct_07b

;-------------------------------------------------------------------------;
; Left-to-right Lines With ABS(Slope) <= 1/2
; ------------------------------------------
;
; Since the line's slope is less than 1/2, we have only 3 possibilities
; at each pair of pixels:
;
;    Case 1:  o            Case 2:  o o            Case 3:  o o o
;               o o                     o
;
; Case:    err + dN >= 0         err + 2dN >= 0          err + 2dN < 0
; New:     err += 2dN - dM       err += 2dN - dM         err += 2dN
;
; eax = color
; ebx = error term
; ecx = dM - dN
; edx = dN
; esi = # of pixels to lay down
; edi = memory pointer
; ebp = # of scans before end of bank
;-------------------------------------------------------------------------;

        public  oct_07a
oct_07a::
        test    edi,1
        jz      short oct_07a_main      ;start is word aligned

; Handle unaligned start:

        dec     esi
        jl      next_line

        mov     [edi],al
        inc     edi
        add     ebx,edx                 ;err += dN
        jl      short oct_07a_main

        add     edi,[esp].sf_lDelta
        dec     ebp                     ;hit a new bank?
        jz      short oct_07a_next_bank_3
oct_07a_done_bank_3:
        sub     ebx,ecx                 ;err += dN - dM
        jl      short oct_07a_continue

;;; Case 1:

        public  oct_07a_case_1
oct_07a_case_1::
        sub     esi,2
        jl      short oct_07a_done
        mov     [edi],al
        add     edi,[esp].sf_lDelta
        add     edi,2
        dec     ebp
        jz      short oct_07a_next_bank_1
oct_07a_done_bank_1:
        mov     [edi-1],al
        sub     ebx,ecx                 ;err += dN - dM
                                        ;;;case 1 is done
;;; Main loop:

oct_07a_main:
        add     ebx,edx                 ;err += dN
        jge     short oct_07a_case_1
oct_07a_continue:
        sub     esi,2
        jl      short oct_07a_done
        mov     [edi],ax
        add     edi,2
        add     ebx,edx                 ;err += dN
        jl      short oct_07a_main      ;;;case 3 is done

;;; Handle end of case 2:

        add     edi,[esp].sf_lDelta
        dec     ebp
        jz      short oct_07a_next_bank_2
oct_07a_done_bank_2:
        sub     ebx,ecx                 ;err += dN - dM
        jge     short oct_07a_case_1
        jmp     short oct_07a_continue  ;;;case 2 is done

oct_07a_done:
        inc     esi                     ;esi = -1 means do another pixel
        jnz     next_line
        mov     [edi],al
        jmp     next_line

oct_07a_next_bank_1:
        mov     [esp].sf_pfnReturn,offset oct_07a_done_bank_1
        jmp     [esp].sf_pfnNextBank
oct_07a_next_bank_2:
        mov     [esp].sf_pfnReturn,offset oct_07a_done_bank_2
        jmp     [esp].sf_pfnNextBank
oct_07a_next_bank_3:
        mov     [esp].sf_pfnReturn,offset oct_07a_done_bank_3
        jmp     [esp].sf_pfnNextBank

;-------------------------------------------------------------------------;
; Left-to-right Lines With 1/2 < ABS(Slope) <= 1
; ----------------------------------------------
;
; Since the line's slope is between 1/2 and 1, we have only 3 possibilities
; at each pair of pixels:
;
;   Case 1:  o o          Case 2:  o              Case 3:  o
;                o                   o o                     o
;                                                              o
;
; Case:   err + dN < 0          err + 2dN - dM < 0      err + 2dN - dM >= 0
; New:    err += 2dN - dM       err += 2dN - dM         err += 2dN - 2dM
;
; eax = color
; ebx = error term
; ecx = dM - dN
; edx = dN
; esi = # of pixels to lay down
; edi = memory pointer
; ebp = # of scans before end of bank
;-------------------------------------------------------------------------;

        public  oct_07b
oct_07b::
        test    edi,1
        jz      short oct_07b_main

        dec     esi
        jl      next_line

        mov     [edi],al
        inc     edi
        add     ebx,edx                 ;err += dN
        jl      short oct_07b_main

        add     edi,[esp].sf_lDelta
        dec     ebp
        jz      short oct_07b_next_bank_4
oct_07b_done_bank_4:
        sub     ebx,ecx                 ;err += dN - dM
        jge     short oct_07b_continue

        public  oct_07b_case_1
oct_07b_case_1::
        sub     esi,2
        jl      short oct_07b_done
        mov     [edi],ax
        add     edi,[esp].sf_lDelta
        add     edi,2
        dec     ebp
        jz      short oct_07b_next_bank_1
oct_07b_done_bank_1:
        sub     ebx,ecx                 ;err += dN - dM
                                        ;;;case 1 is done
;;; Main loop:

oct_07b_main:
        add     ebx,edx                 ;err += dN
        jl      short oct_07b_case_1
oct_07b_continue:
        sub     esi,2
        jl      short oct_07b_done
        mov     [edi],al
        add     edi,[esp].sf_lDelta
        add     edi,2
        dec     ebp
        jz      short oct_07b_next_bank_2
oct_07b_done_bank_2:
        mov     [edi-1],al
        sub     ebx,ecx                 ;err += dN - dM
        jl      short oct_07b_main      ;;;case 2 is done

        add     edi,[esp].sf_lDelta
        dec     ebp
        jz      oct_07b_next_bank_3
oct_07b_done_bank_3:
        sub     ebx,ecx                 ;err += dN - dM
        jl      short oct_07b_case_1    ;;;case 3 is done
        jmp     short oct_07b_continue

oct_07b_next_bank_4:
        mov     [esp].sf_pfnReturn,offset oct_07b_done_bank_4
        jmp     [esp].sf_pfnNextBank
oct_07b_next_bank_3:
        mov     [esp].sf_pfnReturn,offset oct_07b_done_bank_3
        jmp     [esp].sf_pfnNextBank
oct_07b_next_bank_2:
        mov     [esp].sf_pfnReturn,offset oct_07b_done_bank_2
        jmp     [esp].sf_pfnNextBank
oct_07b_next_bank_1:
        mov     [esp].sf_pfnReturn,offset oct_07b_done_bank_1
        jmp     [esp].sf_pfnNextBank

oct_07b_done:
        inc     esi
        jnz     next_line               ;esi = -1 means do another pixel
        mov     [edi],al
        jmp     next_line

;-------------------------------------------------------------------------;

        public  oct_0_non_integer
oct_0_non_integer::
        cmp     ecx,edx
        je      oct_0_slope_one         ;have a special case rounding rule for
                                        ; 45 degree lines (which only affects
                                        ; non-integer lines)

        GIQ     ROUND_X_AND_Y_DOWN      ;### round x=1/2, y=1/2 down in value

        or      edx,edx
        jz      do_non_integer_horizontal_line

oct_0_common:
        mov     esi,[esp].sf_ppdev
        cmp     edi,[esi].pdev_rcl1WindowClip.yTop
        jl      short oct_0_nonint_map_in_bank

        cmp     edi,[esi].pdev_rcl1WindowClip.yBottom
        jl      short oct_0_nonint_done_bank_map

oct_0_nonint_map_in_bank:
        push    eax
        push    ecx
        push    edx

        ptrCall <dword ptr [esi].pdev_pfnBankControl>, \
                <esi, edi, JustifyTop>  ;###

        pop     edx
        pop     ecx
        pop     eax

oct_0_nonint_done_bank_map:
        mov     ebp,[esi].pdev_rcl1WindowClip.yBottom
        sub     ebp,edi                 ;### ebp = # scans before end of bank

        imul    edi,[esp].sf_lNextScan  ;
        add     edi,[esi].pdev_pvBitmapStart
        add     edi,eax                 ;edi now points to start byte

        mov     esi,[esp].sf_x1
        sub     esi,eax                 ;esi = # pixels to lay down

        mov     eax,[esp].sf_iColor

        sub     ecx,edx                 ;ecx = dM - dN
        cmp     edx,ecx
        jg      oct_07b
        jmp     oct_07a

;-------------------------------------------------------------------;
; 45 degree lines have a special rounding rule: when the line
; runs exactly half way between to pixels, the upper or right pel
; is illuminated.  This translates into x=1/2 rounding up, and
; y=1/2 rounding down in value:

        public  oct_0_slope_one
oct_0_slope_one::
        GIQ     ROUND_Y_DOWN_SLOPE_ONE  ;round y=1/2 down in value
        jmp     oct_0_common

;/////////////////////////////////////////////////////////////////////
;// Octant 1
;/////////////////////////////////////////////////////////////////////

        public  octant_1
octant_1::
        mov     [esp].sf_pfnNextBank,offset bank_y_major_next_lower

        mov     esi,eax
        or      esi,ebx
        or      esi,ecx
        or      esi,edx
        and     esi,F - 1
        jnz     oct_1_non_integer

        mov     esi,[esp].sf_ppdev
        sar     eax,FLOG2               ;x0
        sar     ebx,FLOG2               ;y0

        cmp     ebx,[esi].pdev_rcl1WindowClip.yTop
        jl      short oct_1_map_in_bank

        cmp     ebx,[esi].pdev_rcl1WindowClip.yBottom
        jl      short oct_1_done_bank_map

oct_1_map_in_bank:
        push    eax
        push    ecx
        push    edx

; ebx, esi, edi and ebp are preserved according to C calling conventions:

        ptrCall <dword ptr [esi].pdev_pfnBankControl>, \
                <esi, ebx, JustifyTop>  ;###

        pop     edx
        pop     ecx
        pop     eax

        public  oct_1_done_bank_map
oct_1_done_bank_map::
        mov     edi,[esp].sf_lNextScan
        imul    edi,ebx
        add     edi,[esi].pdev_pvBitmapStart
        add     edi,eax                 ;edi now points to start byte

        mov     ebp,[esi].pdev_rcl1WindowClip.yBottom
        sub     ebp,ebx                 ;### ebp = # of scans before end of bank

        mov     esi,edx
        sar     esi,FLOG2               ;esi = # of pixels to lay down

        sub     esi,ebp
        sbb     ebx,ebx
        and     ebx,esi
        add     ebp,ebx                 ;ebp = # of pels in this bank

        mov     [esp].sf_cAfterThisBank,esi
        mov     esi,[esp].sf_lNextScan

        mov     ebx,-1                  ;### round x = 1/2 *DOWN* in value
        sub     ebx,edx
        sar     ebx,1                   ;now have error term

        mov     eax,[esp].sf_iColor

;-------------------------------------------------------------------------;
; Left-to-right Lines With Abs(Slope) > 1/2
; -----------------------------------------
;
; eax = color
; ebx = error term
; ecx = dM
; edx = dN
; esi = delta
; edi = memory pointer
; ebp = # of scans before end of bank
;-------------------------------------------------------------------------;

oct_1_main_loop:
        dec     ebp
        jl      short oct_1_see_if_more
        mov     [edi],al
        add     edi,esi
        add     ebx,ecx                 ;err += dM
        jl      short oct_1_main_loop

        inc     edi                     ;one to right
        sub     ebx,edx                 ;err -= dN

; Unroll a bit:

        dec     ebp
        jl      short oct_1_see_if_more
        mov     [edi],al
        add     edi,esi
        add     ebx,ecx                 ;err += dM
        jl      short oct_1_main_loop

        inc     edi                     ;one to right
        sub     ebx,edx                 ;err -= dN
        jmp     short oct_1_main_loop

        public  oct_1_see_if_more
oct_1_see_if_more::
        mov     eax,[esp].sf_cAfterThisBank
        cmp     eax,0
        jle     next_line

        mov     [esp].sf_pfnReturn,offset oct_1_main_loop
        jmp     [esp].sf_pfnNextBank

        public  oct_1_non_integer
oct_1_non_integer::
        GIQR    ROUND_X_AND_Y_DOWN      ;### round x=1/2, y=1/2 down in value

        mov     esi,[esp].sf_ppdev
        cmp     edi,[esi].pdev_rcl1WindowClip.yTop
        jl      short oct_1_nonint_map_in_bank

        cmp     edi,[esi].pdev_rcl1WindowClip.yBottom
        jl      short oct_1_nonint_done_bank_map

oct_1_nonint_map_in_bank:
        push    eax
        push    ecx
        push    edx

        ptrCall <dword ptr [esi].pdev_pfnBankControl>, \
                <esi, edi, JustifyTop>  ;###

        pop     edx
        pop     ecx
        pop     eax

oct_1_nonint_done_bank_map:
        mov     [esp].sf_y0,edi
        imul    edi,[esp].sf_lNextScan
        add     edi,[esi].pdev_pvBitmapStart
        add     edi,eax                 ;edi points to start byte

        mov     ebp,[esi].pdev_rcl1WindowClip.yBottom
        mov     esi,[esp].sf_y1
        sub     esi,ebp

        sbb     eax,eax
        and     eax,esi
        add     ebp,eax
        sub     ebp,[esp].sf_y0         ;ebp = min(y1,
                                        ; ppdev->rcl1WindowClip.yBottom) - y0
                                        ; (# of pixels to lay down)

        mov     [esp].sf_cAfterThisBank,esi

        mov     esi,[esp].sf_lNextScan
        mov     eax,[esp].sf_iColor

        jmp     oct_1_main_loop

;/////////////////////////////////////////////////////////////////////
;// Octant 3
;/////////////////////////////////////////////////////////////////////

octants_2_3_4_5:
        neg     ecx                     ;dM = -dM (now positive)
        neg     eax                     ;M0 = -M0
        sub     edx,ebx
        jl      octants_4_5
        cmp     ecx,edx
        jl      octant_2

        public  octant_3
octant_3::
        mov     esi,[esp].sf_lNextScan
        mov     [esp].sf_lDelta,esi     ;we're going down
        mov     [esp].sf_pfnNextBank,offset bank_x_major_next_lower

        mov     esi,eax
        or      esi,ebx
        or      esi,ecx
        or      esi,edx
        and     esi,F - 1
        jnz     oct_3_non_integer

        or      edx,edx
        jz      flip_and_do_horizontal_line

        mov     esi,[esp].sf_ppdev

        neg     eax                     ;### untransform M0

        sar     eax,FLOG2               ;x0
        sar     ebx,FLOG2               ;y0

        cmp     ebx,[esi].pdev_rcl1WindowClip.yTop
        jl      short oct_3_map_in_bank

        cmp     ebx,[esi].pdev_rcl1WindowClip.yBottom
        jl      short oct_3_done_bank_map

oct_3_map_in_bank:
        push    eax
        push    ecx
        push    edx

; ebx, esi, edi and esi are preserved according to C calling conventions:

        ptrCall <dword ptr [esi].pdev_pfnBankControl>, \
                <esi, ebx, JustifyTop>  ;###

        pop     edx
        pop     ecx
        pop     eax

        public  oct_3_done_bank_map
oct_3_done_bank_map::
        mov     edi,[esp].sf_lNextScan
        imul    edi,ebx
        add     edi,[esi].pdev_pvBitmapStart
        add     edi,eax                 ;edi now points to start byte

        mov     ebp,[esi].pdev_rcl1WindowClip.yBottom
        sub     ebp,ebx                 ;### ebp = # of scans before end of bank

        mov     esi,ecx
        sar     esi,FLOG2               ;esi = # of pixels to lay down

        mov     ebx,-1                  ;### round y = 1/2 *DOWN* in value
        sub     ebx,ecx
        sar     ebx,1                   ;now have error term

        mov     eax,[esp].sf_iColor
        sub     ecx,edx                 ;ecx = dM - dN
        cmp     edx,ecx
        jg      oct_34b

;-------------------------------------------------------------------------;
; Right-to-left Lines With ABS(Slope) <= 1/2
; ------------------------------------------
;
; Since the line's slope is less than 1/2, we have only 3 possibilities
; at each pair of pixels:
;
;    Case 1:  o            Case 2:  o o            Case 3:  o o o
;               o o                     o
;
; Case:    err + dN >= 0         err + 2dN >= 0          err + 2dN < 0
; New:     err += 2dN - dM       err += 2dN - dM         err += 2dN
;
; eax = color
; ebx = error term
; ecx = dM - dN
; edx = dN
; esi = # of pixels to lay down
; edi = memory pointer
; ebp = # of scans before end of bank
;-------------------------------------------------------------------------;

oct_34a:
        test    edi,1
        jnz     short oct_34a_main      ;### start is word aligned

; Handle unaligned start:

        dec     esi
        jl      next_line

        mov     [edi],al
        dec     edi                     ;###
        add     ebx,edx                 ;err += dN
        jl      short oct_34a_main

        add     edi,[esp].sf_lDelta
        dec     ebp                     ;hit a new bank?
        jz      short oct_34a_next_bank_3
oct_34a_done_bank_3:
        sub     ebx,ecx                 ;err += dN - dM
        jl      short oct_34a_continue

;;; Case 1:

        public  oct_34a_case_1
oct_34a_case_1::
        sub     esi,2
        jl      short oct_34a_done
        mov     [edi],al
        add     edi,[esp].sf_lDelta
        sub     edi,2                   ;###
        dec     ebp
        jz      short oct_34a_next_bank_1
oct_34a_done_bank_1:
        mov     [edi+1],al
        sub     ebx,ecx                 ;err += dN - dM
                                        ;;;case 1 is done
;;; Main loop:

oct_34a_main:
        add     ebx,edx                 ;err += dN
        jge     short oct_34a_case_1
oct_34a_continue:
        sub     esi,2
        jl      short oct_34a_done
        mov     [edi-1],ax              ;###
        sub     edi,2                   ;###
        add     ebx,edx                 ;err += dN
        jl      short oct_34a_main      ;;;case 3 is done

;;; Handle end of case 2:

        add     edi,[esp].sf_lDelta
        dec     ebp
        jz      short oct_34a_next_bank_2
oct_34a_done_bank_2:
        sub     ebx,ecx                 ;err += dN - dM
        jge     short oct_34a_case_1
        jmp     short oct_34a_continue  ;;;case 2 is done

oct_34a_done:
        inc     esi                     ;esi = -1 means do another pixel
        jnz     next_line
        mov     [edi],al
        jmp     next_line

oct_34a_next_bank_1:
        mov     [esp].sf_pfnReturn,offset oct_34a_done_bank_1
        jmp     [esp].sf_pfnNextBank
oct_34a_next_bank_2:
        mov     [esp].sf_pfnReturn,offset oct_34a_done_bank_2
        jmp     [esp].sf_pfnNextBank
oct_34a_next_bank_3:
        mov     [esp].sf_pfnReturn,offset oct_34a_done_bank_3
        jmp     [esp].sf_pfnNextBank

;-------------------------------------------------------------------------;
; Right-to-left Lines With 1/2 < ABS(Slope) <= 1
; ----------------------------------------------
;
; Since the line's slope is between 1/2 and 1, we have only 3 possibilities
; at each pair of pixels:
;
;   Case 1:  o o          Case 2:  o              Case 3:  o
;                o                   o o                     o
;                                                              o
;
; Case:   err + dN < 0          err + 2dN - dM < 0      err + 2dN - dM >= 0
; New:    err += 2dN - dM       err += 2dN - dM         err += 2dN - 2dM
;
; eax = color
; ebx = error term
; ecx = dM - dN
; edx = dN
; esi = # of pixels to lay down
; edi = memory pointer
; ebp = # of scans before end of bank
;-------------------------------------------------------------------------;

        public  oct_34b
oct_34b::
        test    edi,1
        jnz     short oct_34b_main      ;###

        dec     esi
        jl      next_line

        mov     [edi],al
        dec     edi                     ;###
        add     ebx,edx                 ;err += dN
        jl      short oct_34b_main

        add     edi,[esp].sf_lDelta
        dec     ebp
        jz      short oct_34b_next_bank_4
oct_34b_done_bank_4:
        sub     ebx,ecx                 ;err += dN - dM
        jge     short oct_34b_continue

        public  oct_34b_case_1
oct_34b_case_1::
        sub     esi,2
        jl      short oct_34b_done
        mov     [edi-1],ax              ;###
        add     edi,[esp].sf_lDelta
        sub     edi,2                   ;###
        dec     ebp
        jz      short oct_34b_next_bank_1
oct_34b_done_bank_1:
        sub     ebx,ecx                 ;err += dN - dM
                                        ;;;case 1 is done
;;; Main loop:

oct_34b_main:
        add     ebx,edx                 ;err += dN
        jl      short oct_34b_case_1
oct_34b_continue:
        sub     esi,2
        jl      short oct_34b_done
        mov     [edi],al
        add     edi,[esp].sf_lDelta
        sub     edi,2                   ;###
        dec     ebp
        jz      short oct_34b_next_bank_2
oct_34b_done_bank_2:
        mov     [edi+1],al
        sub     ebx,ecx                 ;err += dN - dM
        jl      short oct_34b_main      ;;;case 2 is done

        add     edi,[esp].sf_lDelta
        dec     ebp
        jz      oct_34b_next_bank_3
oct_34b_done_bank_3:
        sub     ebx,ecx                 ;err += dN - dM
        jl      short oct_34b_case_1    ;;;case 3 is done
        jmp     short oct_34b_continue

oct_34b_next_bank_4:
        mov     [esp].sf_pfnReturn,offset oct_34b_done_bank_4
        jmp     [esp].sf_pfnNextBank
oct_34b_next_bank_3:
        mov     [esp].sf_pfnReturn,offset oct_34b_done_bank_3
        jmp     [esp].sf_pfnNextBank
oct_34b_next_bank_2:
        mov     [esp].sf_pfnReturn,offset oct_34b_done_bank_2
        jmp     [esp].sf_pfnNextBank
oct_34b_next_bank_1:
        mov     [esp].sf_pfnReturn,offset oct_34b_done_bank_1
        jmp     [esp].sf_pfnNextBank

oct_34b_done:
        inc     esi
        jnz     next_line               ;esi = -1 means do another pixel
        mov     [edi],al
        jmp     next_line

;-------------------------------------------------------------------------;

        public  oct_3_non_integer
oct_3_non_integer::
        GIQ     ROUND_Y_DOWN            ;### round y=1/2 down in value
                                        ;###  (remember that we're flipped
                                        ;###  in 'x')

        or      edx,edx
        jz      flip_and_do_non_integer_horizontal_line

        mov     esi,[esp].sf_ppdev
        neg     eax                     ;### Untransform x0
        cmp     edi,[esi].pdev_rcl1WindowClip.yTop
        jl      short oct_3_nonint_map_in_bank

        cmp     edi,[esi].pdev_rcl1WindowClip.yBottom
        jl      short oct_3_nonint_done_bank_map

oct_3_nonint_map_in_bank:
        push    eax
        push    ecx
        push    edx

        ptrCall <dword ptr [esi].pdev_pfnBankControl>, \
                <esi, edi, JustifyTop>  ;###

        pop     edx
        pop     ecx
        pop     eax

oct_3_nonint_done_bank_map:
        mov     ebp,[esi].pdev_rcl1WindowClip.yBottom
        sub     ebp,edi                 ;### ebp = # scans before end of bank

        imul    edi,[esp].sf_lNextScan  ;
        add     edi,[esi].pdev_pvBitmapStart
        add     edi,eax                 ;edi now points to start byte

        mov     esi,[esp].sf_x1
        add     esi,eax                 ;### esi = # pixels to lay down

        mov     eax,[esp].sf_iColor

        sub     ecx,edx                 ;ecx = dM - dN
        cmp     edx,ecx
        jg      oct_34b
        jmp     oct_34a

;/////////////////////////////////////////////////////////////////////
;// Octant 2
;/////////////////////////////////////////////////////////////////////

        public  octant_2
octant_2::
        mov     [esp].sf_pfnNextBank,offset bank_y_major_next_lower

        mov     esi,eax
        or      esi,ebx
        or      esi,ecx
        or      esi,edx
        and     esi,F - 1
        jnz     oct_2_non_integer

        neg     eax                     ;### untransform M0

        mov     esi,[esp].sf_ppdev
        sar     eax,FLOG2               ;x0
        sar     ebx,FLOG2               ;y0

        cmp     ebx,[esi].pdev_rcl1WindowClip.yTop
        jl      short oct_2_map_in_bank

        cmp     ebx,[esi].pdev_rcl1WindowClip.yBottom
        jl      short oct_2_done_bank_map

oct_2_map_in_bank:
        push    eax
        push    ecx
        push    edx

; ebx, esi, edi and ebp are preserved according to C calling conventions:

        ptrCall <dword ptr [esi].pdev_pfnBankControl>, \
                <esi, ebx, JustifyTop>  ;###

        pop     edx
        pop     ecx
        pop     eax

        public  oct_2_done_bank_map
oct_2_done_bank_map::
        mov     edi,[esp].sf_lNextScan
        imul    edi,ebx
        add     edi,[esi].pdev_pvBitmapStart
        add     edi,eax                 ;edi now points to start byte

        mov     ebp,[esi].pdev_rcl1WindowClip.yBottom
        sub     ebp,ebx                 ;### ebp = # of scans before end of bank

        mov     esi,edx
        sar     esi,FLOG2               ;esi = # of pixels to lay down

        sub     esi,ebp
        sbb     ebx,ebx
        and     ebx,esi
        add     ebp,ebx                 ;ebp = # of pels in this bank

        mov     [esp].sf_cAfterThisBank,esi
        mov     esi,[esp].sf_lNextScan

        xor     ebx,ebx                 ;### round x = 1/2 *UP* in value
        sub     ebx,edx
        sar     ebx,1                   ;now have error term

        mov     eax,[esp].sf_iColor

;-------------------------------------------------------------------------;
; Right-to-left Lines With Abs(Slope) > 1/2
; -----------------------------------------
;
; eax = color
; ebx = error term
; ecx = dM
; edx = dN
; esi = delta
; edi = memory pointer
; ebp = # of scans before end of bank
;-------------------------------------------------------------------------;

oct_2_main_loop:
        dec     ebp
        jl      short oct_2_see_if_more
        mov     [edi],al
        add     edi,esi
        add     ebx,ecx                 ;err += dM
        jl      short oct_2_main_loop

        dec     edi                     ;one to left
        sub     ebx,edx                 ;err -= dN

; Unroll a bit:

        dec     ebp
        jl      short oct_2_see_if_more
        mov     [edi],al
        add     edi,esi
        add     ebx,ecx                 ;err += dM
        jl      short oct_2_main_loop

        dec     edi                     ;one to left
        sub     ebx,edx                 ;err -= dN
        jmp     short oct_2_main_loop

        public  oct_2_see_if_more
oct_2_see_if_more::
        mov     eax,[esp].sf_cAfterThisBank
        cmp     eax,0
        jle     next_line

        mov     [esp].sf_pfnReturn,offset oct_2_main_loop
        jmp     [esp].sf_pfnNextBank

        public  oct_2_non_integer
oct_2_non_integer::
        GIQR    ROUND_Y_DOWN            ;### round y=1/2 down in value
                                        ;###  (remember that we're flipped
                                        ;###  in 'x')

        mov     esi,[esp].sf_ppdev

        neg     eax                     ;### untransform x0

        cmp     edi,[esi].pdev_rcl1WindowClip.yTop
        jl      short oct_2_nonint_map_in_bank

        cmp     edi,[esi].pdev_rcl1WindowClip.yBottom
        jl      short oct_2_nonint_done_bank_map

oct_2_nonint_map_in_bank:
        push    eax
        push    ecx
        push    edx

        ptrCall <dword ptr [esi].pdev_pfnBankControl>, \
                <esi, edi, JustifyTop>  ;###

        pop     edx
        pop     ecx
        pop     eax

oct_2_nonint_done_bank_map:
        mov     [esp].sf_y0,edi
        imul    edi,[esp].sf_lNextScan
        add     edi,[esi].pdev_pvBitmapStart
        add     edi,eax                 ;edi points to start byte

        mov     ebp,[esi].pdev_rcl1WindowClip.yBottom
        mov     esi,[esp].sf_y1
        sub     esi,ebp

        sbb     eax,eax
        and     eax,esi
        add     ebp,eax
        sub     ebp,[esp].sf_y0         ;ebp = min(y1,
                                        ; ppdev->rcl1WindowClip.yBottom) - y0
                                        ; (# of pixels to lay down)

        mov     [esp].sf_cAfterThisBank,esi

        mov     esi,[esp].sf_lNextScan
        mov     eax,[esp].sf_iColor

        jmp     oct_2_main_loop

;/////////////////////////////////////////////////////////////////////
;// Octant 4
;/////////////////////////////////////////////////////////////////////

octants_4_5:
        neg     edx
        neg     ebx
        cmp     ecx,edx
        jl      octant_5

        public  octant_4
octant_4::
        mov     esi,[esp].sf_lNextScan
        neg     esi
        mov     [esp].sf_lDelta,esi     ;we're going up
        mov     [esp].sf_pfnNextBank,offset bank_x_major_next_upper

        mov     esi,eax
        or      esi,ebx
        or      esi,ecx
        or      esi,edx
        and     esi,F - 1
        jnz     oct_4_non_integer

        neg     eax                     ;### untransform x
        neg     ebx                     ;### untransform y

        mov     esi,[esp].sf_ppdev
        sar     eax,FLOG2               ;x0
        sar     ebx,FLOG2               ;y0

        cmp     ebx,[esi].pdev_rcl1WindowClip.yTop
        jl      short oct_4_map_in_bank

        cmp     ebx,[esi].pdev_rcl1WindowClip.yBottom
        jl      short oct_4_done_bank_map

oct_4_map_in_bank:
        push    eax
        push    ecx
        push    edx

; ebx, esi, edi and esi are preserved according to C calling conventions:

        ptrCall <dword ptr [esi].pdev_pfnBankControl>, \
                <esi, ebx, JustifyBottom> ;###

        pop     edx
        pop     ecx
        pop     eax

        public  oct_4_done_bank_map
oct_4_done_bank_map::
        mov     edi,[esp].sf_lNextScan
        imul    edi,ebx
        add     edi,[esi].pdev_pvBitmapStart
        add     edi,eax                 ;edi now points to start byte

        mov     ebp,ebx                 ;###
        sub     ebp,[esi].pdev_rcl1WindowClip.yTop
        inc     ebp                     ;### ebp = # scans before end of bank

        mov     esi,ecx
        sar     esi,FLOG2               ;esi = # of pixels to lay down

        xor     ebx,ebx                 ;### round y = 1/2 *UP* in value
        sub     ebx,ecx
        sar     ebx,1                   ;now have error term

        mov     eax,[esp].sf_iColor
        sub     ecx,edx                 ;ecx = dM - dN
        cmp     edx,ecx
        jg      oct_34b
        jmp     oct_34a

        public  oct_4_non_integer
oct_4_non_integer::
        cmp     ecx,edx
        je      oct_4_slope_one
        GIQ     0                       ;###
                                        ;###  (remember that we're flipped
                                        ;###  in 'x' and 'y')

oct_4_common:
        mov     esi,[esp].sf_ppdev
        neg     edi                     ;### untransform y
        neg     eax                     ;### untransform x

        cmp     edi,[esi].pdev_rcl1WindowClip.yTop
        jl      short oct_4_nonint_map_in_bank

        cmp     edi,[esi].pdev_rcl1WindowClip.yBottom
        jl      short oct_4_nonint_done_bank_map

oct_4_nonint_map_in_bank:
        push    eax
        push    ecx
        push    edx

        ptrCall <dword ptr [esi].pdev_pfnBankControl>, \
                <esi, edi, JustifyBottom>;###

        pop     edx
        pop     ecx
        pop     eax

oct_4_nonint_done_bank_map:
        mov     ebp,edi                 ;###
        sub     ebp,[esi].pdev_rcl1WindowClip.yTop
        inc     ebp                     ;### esp = # scans before end of bank

        imul    edi,[esp].sf_lNextScan
        add     edi,[esi].pdev_pvBitmapStart
        add     edi,eax                 ;edi now points to start byte

        mov     esi,[esp].sf_x1
        add     esi,eax                 ;### esi = # pixels to lay down

        mov     eax,[esp].sf_iColor

        sub     ecx,edx                 ;ecx = dM - dN
        cmp     edx,ecx
        jg      oct_34b
        jmp     oct_34a

;-------------------------------------------------------------------;
; 45 degree lines have a special rounding rule: when the line
; runs exactly half way between to pixels, the upper or right pel
; is illuminated.  This translates into x=1/2 rounding up, and
; y=1/2 rounding down in value:

        public  oct_4_slope_one
oct_4_slope_one::
        GIQ     ROUND_X_DOWN_SLOPE_ONE  ;round x=1/2 down in value
        jmp     oct_4_common

;/////////////////////////////////////////////////////////////////////
;// Octant 5
;/////////////////////////////////////////////////////////////////////

        public  octant_5
octant_5::
        mov     [esp].sf_pfnNextBank,offset bank_y_major_next_upper

        mov     esi,eax
        or      esi,ebx
        or      esi,ecx
        or      esi,edx
        and     esi,F - 1
        jnz     oct_5_non_integer

        mov     esi,[esp].sf_ppdev
        neg     eax                     ;### untransform
        neg     ebx                     ;### untransform
        sar     eax,FLOG2               ;x0
        sar     ebx,FLOG2               ;y0

        cmp     ebx,[esi].pdev_rcl1WindowClip.yTop
        jl      short oct_5_map_in_bank

        cmp     ebx,[esi].pdev_rcl1WindowClip.yBottom
        jl      short oct_5_done_bank_map

oct_5_map_in_bank:
        push    eax
        push    ecx
        push    edx

; ebx, esi, edi and ebp are preserved according to C calling conventions:

        ptrCall <dword ptr [esi].pdev_pfnBankControl>, \
                <esi,ebx,JustifyBottom> ;###

        pop     edx
        pop     ecx
        pop     eax

        public  oct_5_done_bank_map
oct_5_done_bank_map::
        mov     edi,[esp].sf_lNextScan
        imul    edi,ebx
        add     edi,[esi].pdev_pvBitmapStart
        add     edi,eax                 ;edi now points to start byte

        mov     ebp,ebx                 ;###
        sub     ebp,[esi].pdev_rcl1WindowClip.yTop
        inc     ebp                     ;### ebp = # scans before end of bank

        mov     esi,edx
        sar     esi,FLOG2               ;esi = # of pixels to lay down

        sub     esi,ebp
        sbb     ebx,ebx
        and     ebx,esi
        add     ebp,ebx                 ;ebp = # of pels in this bank

        mov     [esp].sf_cAfterThisBank,esi
        mov     esi,[esp].sf_lNextScan
        neg     esi                     ;### going down!

        xor     ebx,ebx                 ;### round x = 1/2 *UP* in value
        sub     ebx,edx
        sar     ebx,1                   ;now have error term

        mov     eax,[esp].sf_iColor
        jmp     oct_2_main_loop

        public  oct_5_non_integer
oct_5_non_integer::
        GIQR    0                       ;###
                                        ;###  (remember that we're flipped
                                        ;###  in 'x' and 'y')

        mov     esi,[esp].sf_ppdev

        neg     edi                     ;### untransform y0
        neg     eax                     ;### untransform x0

        cmp     edi,[esi].pdev_rcl1WindowClip.yTop
        jl      short oct_5_nonint_map_in_bank

        cmp     edi,[esi].pdev_rcl1WindowClip.yBottom
        jl      short oct_5_nonint_done_bank_map

oct_5_nonint_map_in_bank:
        push    eax
        push    ecx
        push    edx

        ptrCall <dword ptr [esi].pdev_pfnBankControl>, \
                <esi,edi,JustifyBottom> ;###

        pop     edx
        pop     ecx
        pop     eax

oct_5_nonint_done_bank_map:
        mov     [esp].sf_y0,edi
        imul    edi,[esp].sf_lNextScan
        add     edi,[esi].pdev_pvBitmapStart
        add     edi,eax                 ;edi points to start byte

        mov     ebp,[esp].sf_y0         ;###
        mov     esi,[esi].pdev_rcl1WindowClip.yTop
        dec     esi                     ;### make top exclusive
        sub     ebp,esi                 ;###
        add     esi,[esp].sf_y1         ;### don't forget that y1 wasn't un-
                                        ;###  transformed (so this is an 'add')

        jg      short @F                ;###
        add     ebp,esi                 ;###
@@:
        mov     [esp].sf_cAfterThisBank,esi

        mov     esi,[esp].sf_lNextScan
        neg     esi                     ;### going down!
        mov     eax,[esp].sf_iColor

        jmp     oct_2_main_loop

;/////////////////////////////////////////////////////////////////////
;// Octant 6
;/////////////////////////////////////////////////////////////////////

        public  octants_6_7
octants_6_7::
        neg     edx                     ;dN = -dN (now positive)
        neg     ebx                     ;M1 = -M1
        cmp     ecx,edx
        jge     octant_7

        public  octant_6
octant_6::
        mov     [esp].sf_pfnNextBank,offset bank_y_major_next_upper

        mov     esi,eax
        or      esi,ebx
        or      esi,ecx
        or      esi,edx
        and     esi,F - 1
        jnz     oct_6_non_integer

        mov     esi,[esp].sf_ppdev
        neg     ebx                     ;### untransform
        sar     eax,FLOG2               ;x0
        sar     ebx,FLOG2               ;y0

        cmp     ebx,[esi].pdev_rcl1WindowClip.yTop
        jl      short oct_6_map_in_bank

        cmp     ebx,[esi].pdev_rcl1WindowClip.yBottom
        jl      short oct_6_done_bank_map

oct_6_map_in_bank:
        push    eax
        push    ecx
        push    edx

; ebx, esi, edi and ebp are preserved according to C calling conventions:

        ptrCall <dword ptr [esi].pdev_pfnBankControl>, \
                <esi,ebx,JustifyBottom> ;###

        pop     edx
        pop     ecx
        pop     eax

        public  oct_6_done_bank_map
oct_6_done_bank_map::
        mov     edi,[esp].sf_lNextScan
        imul    edi,ebx
        add     edi,[esi].pdev_pvBitmapStart
        add     edi,eax                 ;edi now points to start byte

        mov     ebp,ebx                 ;###
        sub     ebp,[esi].pdev_rcl1WindowClip.yTop
        inc     ebp                     ;### ebp = # scans before end of bank

        mov     esi,edx
        sar     esi,FLOG2               ;esi = # of pixels to lay down

        sub     esi,ebp
        sbb     ebx,ebx
        and     ebx,esi
        add     ebp,ebx                 ;ebp = # of pels in this bank

        mov     [esp].sf_cAfterThisBank,esi
        mov     esi,[esp].sf_lNextScan
        neg     esi                     ;### going down!

        mov     ebx,-1                  ;### round x = 1/2 *DOWN* in value
        sub     ebx,edx
        sar     ebx,1                   ;now have error term

        mov     eax,[esp].sf_iColor
        jmp     oct_1_main_loop

        public  oct_6_non_integer
oct_6_non_integer::
        GIQR    ROUND_X_DOWN            ;### round x=1/2 down in value
                                        ;###  (remember that we're flipped
                                        ;###  in 'y')

        mov     esi,[esp].sf_ppdev

        neg     edi                     ;### untransform y0

        cmp     edi,[esi].pdev_rcl1WindowClip.yTop
        jl      short oct_6_nonint_map_in_bank

        cmp     edi,[esi].pdev_rcl1WindowClip.yBottom
        jl      short oct_6_nonint_done_bank_map

oct_6_nonint_map_in_bank:
        push    eax
        push    ecx
        push    edx

        ptrCall <dword ptr [esi].pdev_pfnBankControl>, \
                <esi,edi,JustifyBottom> ;###

        pop     edx
        pop     ecx
        pop     eax

oct_6_nonint_done_bank_map:
        mov     [esp].sf_y0,edi
        imul    edi,[esp].sf_lNextScan
        add     edi,[esi].pdev_pvBitmapStart
        add     edi,eax                 ;edi points to start byte

        mov     ebp,[esp].sf_y0         ;###
        mov     esi,[esi].pdev_rcl1WindowClip.yTop
        dec     esi                     ;### make top exclusive
        sub     ebp,esi                 ;###
        add     esi,[esp].sf_y1         ;### don't forget that y1 wasn't un-
                                        ;###  transformed (so this is an 'add')

        jg      short @F                ;###
        add     ebp,esi                 ;###
@@:
        mov     [esp].sf_cAfterThisBank,esi

        mov     esi,[esp].sf_lNextScan
        neg     esi                     ;### going down!
        mov     eax,[esp].sf_iColor

        jmp     oct_1_main_loop

;/////////////////////////////////////////////////////////////////////
;// Octant 7
;/////////////////////////////////////////////////////////////////////

        public  octant_7
octant_7::
        mov     esi,[esp].sf_lNextScan
        neg     esi
        mov     [esp].sf_lDelta,esi     ;we're going up
        mov     [esp].sf_pfnNextBank,offset bank_x_major_next_upper

        mov     esi,eax
        or      esi,ebx
        or      esi,ecx
        or      esi,edx
        and     esi,F - 1
        jnz     oct_7_non_integer

        neg     ebx                     ;### untransform y

        mov     esi,[esp].sf_ppdev
        sar     eax,FLOG2               ;x0
        sar     ebx,FLOG2               ;y0

        cmp     ebx,[esi].pdev_rcl1WindowClip.yTop
        jl      short oct_7_map_in_bank

        cmp     ebx,[esi].pdev_rcl1WindowClip.yBottom
        jl      short oct_7_done_bank_map

oct_7_map_in_bank:
        push    eax
        push    ecx
        push    edx

; ebx, esi, edi and esi are preserved according to C calling conventions:

        ptrCall <dword ptr [esi].pdev_pfnBankControl>, \
                <esi, ebx, JustifyBottom> ;###

        pop     edx
        pop     ecx
        pop     eax

        public  oct_7_done_bank_map
oct_7_done_bank_map::
        mov     edi,[esp].sf_lNextScan
        imul    edi,ebx
        add     edi,[esi].pdev_pvBitmapStart
        add     edi,eax                 ;edi now points to start byte

        mov     ebp,ebx                 ;###
        sub     ebp,[esi].pdev_rcl1WindowClip.yTop
        inc     ebp                     ;### ebp = # scans before end of bank

        mov     esi,ecx
        sar     esi,FLOG2               ;esi = # of pixels to lay down

        xor     ebx,ebx                 ;### round y = 1/2 *UP* in value
        sub     ebx,ecx
        sar     ebx,1                   ;now have error term

        mov     eax,[esp].sf_iColor
        sub     ecx,edx                 ;ecx = dM - dN
        cmp     edx,ecx
        jg      oct_07b
        jmp     oct_07a

        public  oct_7_non_integer
oct_7_non_integer::
        cmp     ecx,edx
        je      oct_7_slope_one
        GIQ     ROUND_X_DOWN            ;### round x=1/2 down in value
                                        ;###  (remember that we're flipped
                                        ;###  in 'y')

oct_7_common:
        mov     esi,[esp].sf_ppdev
        neg     edi                     ;### untransform y

        cmp     edi,[esi].pdev_rcl1WindowClip.yTop
        jl      short oct_7_nonint_map_in_bank

        cmp     edi,[esi].pdev_rcl1WindowClip.yBottom
        jl      short oct_7_nonint_done_bank_map

oct_7_nonint_map_in_bank:
        push    eax
        push    ecx
        push    edx

        ptrCall <dword ptr [esi].pdev_pfnBankControl>, \
                <esi, edi, JustifyBottom>;###

        pop     edx
        pop     ecx
        pop     eax

oct_7_nonint_done_bank_map:
        mov     ebp,edi                 ;###
        sub     ebp,[esi].pdev_rcl1WindowClip.yTop
        inc     ebp                     ;### esp = # scans before end of bank

        imul    edi,[esp].sf_lNextScan
        add     edi,[esi].pdev_pvBitmapStart
        add     edi,eax                 ;edi now points to start byte

        mov     esi,[esp].sf_x1
        sub     esi,eax                 ;esi = # pixels to lay down

        mov     eax,[esp].sf_iColor

        sub     ecx,edx                 ;ecx = dM - dN
        cmp     edx,ecx
        jg      oct_07b
        jmp     oct_07a

;-------------------------------------------------------------------;
; We have to special case those lines with a slope of exactly -1 when
; 'x' rounds down in value after normalizing:

        public  oct_7_slope_one
oct_7_slope_one::
        GIQ     ROUND_X_DOWN_SLOPE_ONE
        jmp     oct_7_common

;-------------------------------------------------------------------------;
; Function to get next lower bank for x-major lines.
;-------------------------------------------------------------------------;

        public  bank_x_major_next_lower
bank_x_major_next_lower::
        push    ebx
        mov     ebx,[esp+4].sf_ppdev    ;NOTE: Add 4 because of above push!
        push    ecx
        push    edx
        push    esi

        mov     esi,[ebx].pdev_rcl1WindowClip.yBottom
        sub     edi,[ebx].pdev_pvBitmapStart

        ptrCall <dword ptr [ebx].pdev_pfnBankControl>, \
                <ebx,esi,JustifyTop>

        add     edi,[ebx].pdev_pvBitmapStart
        mov     ebp,[ebx].pdev_rcl1WindowClip.yBottom
        sub     ebp,esi

        pop     esi
        pop     edx
        pop     ecx
        pop     ebx
        mov     eax,[esp].sf_iColor

        jmp     [esp].sf_pfnReturn

;-------------------------------------------------------------------------;
; Function to get next upper bank for x-major lines.
;-------------------------------------------------------------------------;

        public  bank_x_major_next_upper
bank_x_major_next_upper::
        push    ebx
        mov     ebx,[esp+4].sf_ppdev    ;NOTE: Add 4 because of above push!
        push    ecx
        push    edx
        push    esi

        mov     esi,[ebx].pdev_rcl1WindowClip.yTop
        dec     esi
        sub     edi,[ebx].pdev_pvBitmapStart

        ptrCall <dword ptr [ebx].pdev_pfnBankControl>, \
                <ebx,esi,JustifyBottom>

        add     edi,[ebx].pdev_pvBitmapStart
        lea     ebp,[esi+1]
        sub     ebp,[ebx].pdev_rcl1WindowClip.yTop

        pop     esi
        pop     edx
        pop     ecx
        pop     ebx
        mov     eax,[esp].sf_iColor

        jmp     [esp].sf_pfnReturn

;-------------------------------------------------------------------------;
; Function to get next lower bank for y-major lines.
;-------------------------------------------------------------------------;

        public  bank_y_major_next_lower
bank_y_major_next_lower::

; eax = # pels after this bank

        push    ebx
        mov     ebx,[esp+4].sf_ppdev    ;NOTE: Plus 4 because of above push!
        push    ecx
        push    edx
        push    esi

        mov     esi,[ebx].pdev_rcl1WindowClip.yBottom
        sub     edi,[ebx].pdev_pvBitmapStart

        push    eax
        ptrCall <dword ptr [ebx].pdev_pfnBankControl>, \
                <ebx,esi,JustifyTop>
        pop     eax

        add     edi,[ebx].pdev_pvBitmapStart
        mov     ebp,[ebx].pdev_rcl1WindowClip.yBottom
        sub     ebp,esi                 ;ebp = # of pels can do in this bank
        sub     eax,ebp                 ;esi = # of pels after this bank
        sbb     ebx,ebx
        and     ebx,eax
        add     ebp,ebx                 ;ebp = # of pels in this bank

        pop     esi
        pop     edx
        pop     ecx
        pop     ebx

        mov     [esp].sf_cAfterThisBank,eax
                                        ;this has to be done after 'esp' is
                                        ; restored!

        mov     eax,[esp].sf_iColor

        jmp     [esp].sf_pfnReturn

;-------------------------------------------------------------------------;
; Function to get next upper bank for y-major lines.
;-------------------------------------------------------------------------;

        public  bank_y_major_next_upper
bank_y_major_next_upper::

; eax = # pels after this bank

        push    ebx
        mov     ebx,[esp+4].sf_ppdev    ;NOTE: Plus 4 because of above push!
        push    ecx
        push    edx
        push    esi

        mov     ebp,[ebx].pdev_rcl1WindowClip.yTop
        dec     ebp

        sub     edi,[ebx].pdev_pvBitmapStart

        push    eax
        ptrCall <dword ptr [ebx].pdev_pfnBankControl>, \
                <ebx,ebp,JustifyBottom>
        pop     eax

        add     edi,[ebx].pdev_pvBitmapStart

        inc     ebp                     ;restore exclusiveness
        sub     ebp,[ebx].pdev_rcl1WindowClip.yTop
                                        ;ebp = # of pels can do in this bank
        sub     eax,ebp                 ;esi = # of pels after this bank
        sbb     ebx,ebx
        and     ebx,eax
        add     ebp,ebx                 ;ebp = # of pels in this bank

        pop     esi
        pop     edx
        pop     ecx
        pop     ebx

        mov     [esp].sf_cAfterThisBank,eax
                                        ;this has to be done after 'esp' is
                                        ; restored!

        mov     eax,[esp].sf_iColor

        jmp     [esp].sf_pfnReturn

;/////////////////////////////////////////////////////////////////////
;// Horizontal Line
;/////////////////////////////////////////////////////////////////////

        public  flip_and_do_non_integer_horizontal_line
flip_and_do_non_integer_horizontal_line::
        mov     ebx,edi
        mov     ecx,[esp].sf_x1
        sub     ecx,eax
        jle     next_line
        add     eax,ecx
        neg     eax
        inc     eax                     ;x0' = -(-original x0 - dx) + 1
        jmp     short horizontal_common

        public  do_non_integer_horizontal_line
do_non_integer_horizontal_line::
        mov     ebx,edi
        mov     ecx,[esp].sf_x1
        sub     ecx,eax
        jg      short horizontal_common
        jmp     next_line

        public  flip_and_do_horizontal_line
flip_and_do_horizontal_line::

; This 'flip' entry point is for lines that were originally right-to-left:

        add     eax,ecx
        neg     eax
        add     eax,F                   ;M0' = -(-original M0 - original dM) + 1

        public  do_horizontal_line
do_horizontal_line::
        sar     eax,FLOG2               ;x0 (we're now in pixel coordinates)
        sar     ebx,FLOG2               ;y0
        sar     ecx,FLOG2               ;dx
        jz      next_line

; NOTE: Have to have some pixels to light at this point
;
; eax = x0 (in pixel coordinates)
; ebx = y0
; ecx = dx (# pixels to light)

horizontal_common:
        mov     esi,[esp].sf_ppdev

        cmp     ecx,NUM_PELS_NEEDED_FOR_PLANAR_HORIZONTAL
        jl      do_short_horizontal_line

        test    [esi].pdev_fl,DRIVER_PLANAR_CAPABLE
        jz      do_short_horizontal_line

;---------------------------------------------------------------------;
; Draw horizontal lines using planar mode.
;
; NOTE: This code assumes that the length is at least 8 pels long!

        public  horizontal_planar
horizontal_planar::
        mov     edi,[esi].pdev_lPlanarNextScan
        imul    edi,ebx

        cmp     ebx,[esi].pdev_rcl1PlanarClip.yTop
        jl      short hor_planar_map_bank

        cmp     ebx,[esi].pdev_rcl1PlanarClip.yBottom
        jl      short hor_planar_done_bank

hor_planar_map_bank:
        push    eax
        push    ecx

; ebx, esi, edi and ebp are preserved according to C calling conventions:

        ptrCall <dword ptr [esi].pdev_pfnPlanarControl>, \
                <esi,ebx,JustifyTop>

        pop     ecx
        pop     eax

hor_planar_done_bank:
        add     edi,[esi].pdev_pvBitmapStart

        mov     ebp,eax                 ;save x0
        sar     eax,2
        add     edi,eax                 ;edi now points to start byte

        and     ebp,3
        jz      short hor_planar_start_middle

; When the left end doesn't start on a quadpixel boundary, we have to
; adjust the start address and do some other stuff:

        mov     [esp].sf_pjStart,edi
        inc     edi
        sub     ebp,4
        add     ecx,ebp                 ;adjust byte count to account for
                                        ; fractional start

hor_planar_start_middle:
        mov     eax,[esp].sf_iColor     ;load the color
        mov     esi,ecx                 ;save length

        test    edi,1
        jz      short hor_planar_middle_aligned
        mov     [edi],al                ;handle unaligned whole start byte
        inc     edi
        sub     ecx,4
hor_planar_middle_aligned:
        shr     ecx,3                   ;NOTE: we look at the carry later!
        rep     stosw                   ;write middle as words
        jnc     short hor_planar_handle_ends
                                        ;NOTE: here we look at the carry!
        mov     [edi],al                ;handle whole end byte
        inc     edi

hor_planar_handle_ends:
        mov     edx,VGA_BASE + SEQ_DATA
        and     esi,3
        jz      short hor_planar_left
hor_planar_right:
        mov     ecx,esi
        mov     eax,0f0h
        rol     al,cl                   ;we compute the mask instead of
                                        ; using a look-up table, because the
                                        ; table probably wouldn't be in the
                                        ; cache

; Set right mask by disabling some planes:

        out     dx,al

        push    eax                     ;we add a delay here because some
        pop     eax                     ; cards can't handle a write too soon
                                        ; after an out.  Hopefully this will
                                        ; help.

        mov     eax,[esp].sf_iColor
        mov     [edi],al

hor_planar_left:
        and     ebp,3
        jz      short hor_planar_done

        mov     ecx,ebp
        mov     eax,0fh
        shl     eax,cl

; Set left mask by disabling some planes:

        out     dx,al

        push    eax                     ;we add a delay here because some
        pop     eax                     ; cards can't handle a write too soon
                                        ; after an out.  Hopefully this will
                                        ; help.

        mov     edi,[esp].sf_pjStart
        mov     eax,[esp].sf_iColor
        mov     [edi],al

hor_planar_done:
        mov     al,MM_ALL
        out     dx,al

        jmp     next_line

;---------------------------------------------------------------------;
; Draw horizontal lines using linear mode.

        public  do_short_horizontal_line
do_short_horizontal_line::
        mov     edi,[esp].sf_lNextScan
        imul    edi,ebx
        add     edi,eax

        cmp     ebx,[esi].pdev_rcl1WindowClip.yTop
        jl      short hor_map_in_bank

        cmp     ebx,[esi].pdev_rcl1WindowClip.yBottom
        jl      short hor_done_bank_map

hor_map_in_bank:
        push    ecx

; ebx, esi, edi and ebp are preserved according to C calling conventions:

        ptrCall <dword ptr [esi].pdev_pfnBankControl>, \
                <esi,ebx,JustifyTop>

        pop     ecx

hor_done_bank_map:
        add     edi,[esi].pdev_pvBitmapStart
                                        ;edi now points to start byte
        mov     eax,[esp].sf_iColor

        test    edi,1
        jz      short hor_aligned
        mov     [edi],al                ;write initial unaligned byte
        inc     edi
        dec     ecx
        jz      next_line

hor_aligned:
        shr     ecx,1                   ;NOTE: we look at the carry later!
        rep     stosw                   ;write middle words
        jnc     next_line               ;NOTE: here we look at the carry!
        mov     [edi],al                ;write last byte
        jmp     next_line


endProc vFastLine

        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\vga\disp\8bpp\i386\fasttext.asm ===
;---------------------------Module-Header------------------------------;
; Module Name: fasttext.asm
;
; Copyright (c) 1992 Microsoft Corporation
;-----------------------------------------------------------------------;
;-----------------------------------------------------------------------;
; BOOL vFastText(PDEV * ppdev, GLYPHPOS * pGlyphPos, ULONG ulGlyphCount,
;                PBYTE pTempBuffer, ULONG ulBufDelta, ULONG ulCharInc,
;                RECTL * prclText, RECTL * prclOpaque, INT iFgColor,
;                INT iBgColor, ULONG fDrawFlags);
; ppdev -
; pGlyphPos -
; ulGlyphCount - # of glyphs to draw. Must never be 0.
; pTempBuffer -
; ulBufDelta - logical width of temp buffer in bytes. This value *must* be the
;               same number of bytes spanned by prclText; it is assumed that
;               scans in the temp buffer are contiguous
; ulCharInc -
; prclText -
; prclOpaque -
; iFgColor -
; iBgColor -
; fDrawFlags -
;
; Performs accelerated proportional text drawing.
;
;-----------------------------------------------------------------------;
;
; Note: The general opaque text back-end currently assumes that it will
; never receive a text string with a bounding box that does not span at
; least one quadpixel (the four pixels at a VGA screen address).
;
;-----------------------------------------------------------------------;
;
; Note: The term "quadpixel" means a four-pixel set stored across all
; four planes of VGA memory in planar high-color mode. Quadpixels map to
; nibbles in the temp buffer in which text is assembled, where nibbles
; are always bits 4-7 or 0-3.
;
;-----------------------------------------------------------------------;
;
; Note: The direction flag is *not* explicitly set or cleared.
;
;-----------------------------------------------------------------------;
;
; Note: Assumes the text rectangle has a positive height and width. Will
; not work properly if this is not the case.
;
;-----------------------------------------------------------------------;

        comment $

The overall approach of this module is to draw the text into a system
memory buffer, then copy the buffer to the screen a word at a time
using write mode 2 and clever use of the VGA hardware so that no OUTs
and a minimum of display memory reads are required. The clever use is
setting the ALUs to XOR, the latches to the background color, and the
write mode to 2, so each nibble in bits 0-3 written by the CPU turns
into 0 or 0ffh for that plane. Then the Bit Mask is set to fg ^ bg,
so that common bits between the fg and bg are preserved, while non-
common bits are either preserved (=bg color) by a 0->000h bit for
that plane, or flipped (=fg color) by a 1->0ffh bit for that plane. The
Map Mask is used to clip edges; no read before write is required. Note
that bits 0-3 must be reversed to match the order of pixels in planes
0-3. Note also that we write a whole word, containing two nibbles in
bits 0-3 of each byte, at once, to draw 8 pixels per write.

        commend $

        .386

ifndef  DOS_PLATFORM
        .model  small,c
else
ifdef   STD_CALL
        .model  small,c
else
        .model  small,pascal
endif;  STD_CALL
endif;  DOS_PLATFORM

        assume cs:FLAT,ds:FLAT,es:FLAT,ss:FLAT
        assume fs:nothing,gs:nothing

        .xlist
        include stdcall.inc             ;calling convention cmacros
        include i386\strucs.inc
        include i386\driver.inc
        include i386\egavga.inc

        .list

;-----------------------------------------------------------------------;

        .data

;-----------------------------------------------------------------------;
; Tables used to branch into glyph-drawing optimizations.
;
; Handles narrow (1-4 bytes wide) glyph drawing, for case where initial byte
; should be MOVed even if it's not aligned (intended for use in drawing the
; first glyph in a string). Table format is:
;  Bits 3-2: dest width
;  Bit   1 : 1 if don't need last source byte, 0 if do need last source byte
;  Bit   0 : 1 if no rotation (aligned), 0 if rotation (non-aligned)
        align   4
MovInitialTableNarrow   label   dword
        dd      draw_prop_done                     ;0 wide
        dd      draw_prop_done                     ;0 wide
        dd      draw_prop_done                     ;0 wide
        dd      draw_prop_done                     ;0 wide
        dd      mov_first_1_wide_rotated_need_last ;nonalign, 1 wide, need last
        dd      mov_first_1_wide_unrotated         ;aligned, 1 wide
        dd      mov_first_1_wide_rotated_no_last   ;nonalign, 1 wide, no last
        dd      mov_first_1_wide_unrotated         ;aligned, 1 wide
        dd      mov_first_2_wide_rotated_need_last ;nonalign, 2 wide, need last
        dd      mov_first_2_wide_unrotated         ;aligned, 2 wide
        dd      mov_first_2_wide_rotated_no_last   ;nonalign, 2 wide, no last
        dd      mov_first_2_wide_unrotated         ;aligned, 2 wide
        dd      mov_first_3_wide_rotated_need_last ;nonalign, 3 wide, need last
        dd      mov_first_3_wide_unrotated         ;aligned, 3 wide
        dd      mov_first_3_wide_rotated_no_last   ;nonalign, 3 wide, no last
        dd      mov_first_3_wide_unrotated         ;aligned, 3 wide
        dd      mov_first_4_wide_rotated_need_last ;nonalign, 4 wide, need last
        dd      mov_first_4_wide_unrotated         ;aligned, 4 wide
        dd      mov_first_4_wide_rotated_no_last   ;nonalign, 4 wide, no last
        dd      mov_first_4_wide_unrotated         ;aligned, 4 wide

; Handles narrow (1-4 bytes wide) glyph drawing, for case where initial byte
; ORed if it's not aligned (intended for use in drawing all but the first glyph
; in a string). Table format is:
;  Bits 3-2: dest width
;  Bit   1 : 1 if don't need last source byte, 0 if do need last source byte
;  Bit   0 : 1 if no rotation (aligned), 0 if rotation (non-aligned)
        align   4
OrInitialTableNarrow    label   dword
        dd      draw_prop_done                     ;0 wide
        dd      draw_prop_done                     ;0 wide
        dd      draw_prop_done                     ;0 wide
        dd      draw_prop_done                     ;0 wide
        dd      or_first_1_wide_rotated_need_last  ;nonalign, 1 wide, need last
        dd      mov_first_1_wide_unrotated         ;aligned, 1 wide
        dd      or_first_1_wide_rotated_no_last    ;nonalign, 1 wide, no last
        dd      mov_first_1_wide_unrotated         ;aligned, 1 wide
        dd      or_first_2_wide_rotated_need_last  ;nonalign, 2 wide, need last
        dd      mov_first_2_wide_unrotated         ;aligned, 2 wide
        dd      or_first_2_wide_rotated_no_last    ;nonalign, 2 wide, no last
        dd      mov_first_2_wide_unrotated         ;aligned, 2 wide
        dd      or_first_3_wide_rotated_need_last  ;nonalign, 3 wide, need last
        dd      mov_first_3_wide_unrotated         ;aligned, 3 wide
        dd      or_first_3_wide_rotated_no_last    ;nonalign, 3 wide, no last
        dd      mov_first_3_wide_unrotated         ;aligned, 3 wide
        dd      or_first_4_wide_rotated_need_last  ;nonalign, 4 wide, need last
        dd      mov_first_4_wide_unrotated         ;aligned, 4 wide
        dd      or_first_4_wide_rotated_no_last    ;nonalign, 4 wide, no last
        dd      mov_first_4_wide_unrotated         ;aligned, 4 wide

; Handles narrow (1-4 bytes wide) glyph drawing, for case where all bytes
; should be ORed (intended for use in drawing potentially overlapping glyphs).
; Table format is:
;  Bits 3-2: dest width
;  Bit   1 : 1 if don't need last source byte, 0 if do need last source byte
;  Bit   0 : 1 if no rotation (aligned), 0 if rotation (non-aligned)
        align   4
OrAllTableNarrow        label   dword
        dd      draw_prop_done                     ;0 wide
        dd      draw_prop_done                     ;0 wide
        dd      draw_prop_done                     ;0 wide
        dd      draw_prop_done                     ;0 wide
        dd      or_all_1_wide_rotated_need_last    ;nonalign, 1 wide, need last
        dd      or_all_1_wide_unrotated            ;aligned, 1 wide
        dd      or_all_1_wide_rotated_no_last      ;nonalign, 1 wide, no last
        dd      or_all_1_wide_unrotated            ;aligned, 1 wide
        dd      or_all_2_wide_rotated_need_last    ;nonalign, 2 wide, need last
        dd      or_all_2_wide_unrotated            ;aligned, 2 wide
        dd      or_all_2_wide_rotated_no_last      ;nonalign, 2 wide, no last
        dd      or_all_2_wide_unrotated            ;aligned, 2 wide
        dd      or_all_3_wide_rotated_need_last    ;nonalign, 3 wide, need last
        dd      or_all_3_wide_unrotated            ;aligned, 3 wide
        dd      or_all_3_wide_rotated_no_last      ;nonalign, 3 wide, no last
        dd      or_all_3_wide_unrotated            ;aligned, 3 wide
        dd      or_all_4_wide_rotated_need_last    ;nonalign, 4 wide, need last
        dd      or_all_4_wide_unrotated            ;aligned, 4 wide
        dd      or_all_4_wide_rotated_no_last      ;nonalign, 4 wide, no last
        dd      or_all_4_wide_unrotated            ;aligned, 4 wide

; Handles arbitrarily wide glyph drawing, for case where initial byte should be
; MOVed even if it's not aligned (intended for use in drawing the first glyph
; in a string). Table format is:
;  Bit   1 : 1 if don't need last source byte, 0 if do need last source byte
;  Bit   0 : 1 if no rotation (aligned), 0 if rotation (non-aligned)
        align   4
MovInitialTableWide     label   dword
        dd      mov_first_N_wide_rotated_need_last      ;nonalign, need last
        dd      mov_first_N_wide_unrotated              ;aligned
        dd      mov_first_N_wide_rotated_no_last        ;nonalign, no last
        dd      mov_first_N_wide_unrotated              ;aligned

; Handles arbitrarily wide glyph drawing, for case where initial byte should be
; ORed if it's not aligned (intended for use in drawing all but the first glyph
; in a string). Table format is:
;  Bit   1 : 1 if don't need last source byte, 0 if do need last source byte
;  Bit   0 : 1 if no rotation (aligned), 0 if rotation (non-aligned)
        align   4
OrInitialTableWide      label   dword
        dd      or_first_N_wide_rotated_need_last       ;nonalign, need last
        dd      mov_first_N_wide_unrotated              ;aligned
        dd      or_first_N_wide_rotated_no_last         ;nonalign, no last
        dd      mov_first_N_wide_unrotated              ;aligned

; Handles arbitrarily wide glyph drawing, for case where all bytes should
; be ORed (intended for use in drawing potentially overlapping glyphs).
; Table format is:
;  Bit   1 : 1 if don't need last source byte, 0 if do need last source byte
;  Bit   0 : 1 if no rotation (aligned), 0 if rotation (non-aligned)
        align   4
OrAllTableWide  label   dword
        dd      or_all_N_wide_rotated_need_last ;nonalign, need last
        dd      or_all_N_wide_unrotated         ;aligned
        dd      or_all_N_wide_rotated_no_last   ;nonalign, no last
        dd      or_all_N_wide_unrotated         ;aligned

; Vectors to entry points for drawing various types of text. '*' means works as
; is but could be acclerated with a custom scanning loop.
        align   4
MasterTextTypeTable     label   dword       ;tops aligned  overlap  fixed pitch
        dd      draw_nf_ntb_o_to_temp_start ;      N          N          N *
        dd      draw_f_ntb_o_to_temp_start  ;      N          N          Y *
        dd      draw_nf_ntb_o_to_temp_start ;      N          Y          N
        dd      draw_f_ntb_o_to_temp_start  ;      N          Y          Y
        dd      draw_nf_tb_no_to_temp_start ;      Y          N          N
        dd      draw_f_tb_no_to_temp_start  ;      Y          N          Y
        dd      draw_nf_ntb_o_to_temp_start ;      Y          Y          N *
        dd      draw_f_ntb_o_to_temp_start  ;      Y          Y          Y *

;-----------------------------------------------------------------------
; Tables of pointers to optimizations for drawing up to four pixels
; of transparent text based on the upper or lower nibble of a byte.
        align   4
xpar_high_nibble_table  label   dword
        dd      xpar_high_nibble_0
        dd      xpar_high_nibble_1
        dd      xpar_high_nibble_2
        dd      xpar_high_nibble_3
        dd      xpar_high_nibble_4
        dd      xpar_high_nibble_5
        dd      xpar_high_nibble_6
        dd      xpar_high_nibble_7
        dd      xpar_high_nibble_8
        dd      xpar_high_nibble_9
        dd      xpar_high_nibble_A
        dd      xpar_high_nibble_B
        dd      xpar_high_nibble_C
        dd      xpar_high_nibble_D
        dd      xpar_high_nibble_E
        dd      xpar_high_nibble_F

        align   4
xpar_low_nibble_table   label   dword
        dd      xpar_low_nibble_0
        dd      xpar_low_nibble_1
        dd      xpar_low_nibble_2
        dd      xpar_low_nibble_3
        dd      xpar_low_nibble_4
        dd      xpar_low_nibble_5
        dd      xpar_low_nibble_6
        dd      xpar_low_nibble_7
        dd      xpar_low_nibble_8
        dd      xpar_low_nibble_9
        dd      xpar_low_nibble_A
        dd      xpar_low_nibble_B
        dd      xpar_low_nibble_C
        dd      xpar_low_nibble_D
        dd      xpar_low_nibble_E
        dd      xpar_low_nibble_F

; Masks for clipping for the four possible left and right edge alignments
jOpaqueLeftMasks        label   byte
        db      0ffh,00eh,00ch,008h

jOpaqueRightMasks       label   byte
        db      0ffh,001h,003h,007h

;-----------------------------------------------------------------------;

        .code

;-----------------------------------------------------------------------;

cProc vFastText,44,<\
 uses esi edi ebx,\
 ppdev:ptr,\
 pGlyphPos:ptr,\
 ulGlyphCount:dword,\
 pTempBuffer:ptr,\
 ulBufDelta:dword,\
 ulCharInc:dword,\
 prclText:ptr,\
 prclOpaque:ptr,\
 iFgColor:dword,\
 iBgColor:dword,\
 fDrawFlags:dword>

        local ulGlyDelta:dword  ;width per scan of source glyph, in bytes
        local ulWidthInBytes:dword ;width of glyph, in bytes
        local ulTmpWidthInBytes:dword ;working byte-width count
        local ulGlyphX:dword    ;for fixed-pitch text, maintains the current
                                ; glyph's left-edge X coordinate
        local pGlyphLoop:dword  ;pointer to glyph-processing loop
        local ulTempLeft:dword  ;X coordinate on screen of left edge of temp
                                ; buffer
        local ulXparBytes:dword ;general loop count storage
        local ulTmpSrcDelta:dword ;distance from end of one buffer text scan to
                                  ; start of next
        local ulTmpDstDelta:dword ;distance from end of one screen text scan to
                                  ; start of next
        local ulTopScan:dword     ;top scan of dest text rect in current bank
        local ulBottomScan:dword  ;bottom scan of dest text rect
        local ulNumScans:dword    ;# of scans to draw
        local ulScreenDelta:dword ;scan-to-scan offset in screen
        local ulScreenDeltaLinear:dword ;scan-to-scan offset in screen when in
                                        ; nice, neat linear packed-pixel mode
        local ulTextWidthInBytesMinus1:dword ;# of bytes across spanned by
                                             ; text, minus 1
        local pScreen:dword     ;pointer to first screen byte to which to draw
        local pfnEdgeVector:dword ;pointer to routine to draw any needed edges
        local pfnFirstOpaqVector:dword ;pointer to initial drawing routine
                                       ; called for opaque (either whole
                                       ; bytes, or edge(s) if no whole bytes)
        local ulWholeWidthInQuadpixelPairs:dword ;# of quadpixel pairs to copy
        local ulWholeWidthInQuadpixelPairsMinus1:dword ;# of whole bytes to
                                                       ; copy - 1
        local ulOddQuadpixel:dword      ;1 if odd quadpixel in quadpixel-pair
                                        ; copy
        local ulTextLeft:dword  ;left edge of leftmost glyph
        local ulLeftMask:dword  ;for opaque text, left edge mask for string
        local ulRightMask:dword ;for opaque text, right edge mask for string
        local ulScans:dword     ;# of scans in glyph
        local ulYOrigin:dword   ;Y origin of text in string (all glyphs are at
                                ; the same Y origin)
        local pGlyphFlipTable:dword ;pointer to look-up table used to reverse
                                    ; the order of bits 0-3 and 4-7
        local ulLeftEdgeShift:dword ;amount by which to right-shift left-edge
                                    ; nibbles during opaque expansion to
                                    ; right-justify them (0 or 4)
        local ulRightEdgeShift:dword ;amount by which to right-shift right-edge
                                     ; nibbles during opaque expansion to
                                     ; right-justify them (0 or 4)
        local ulVGAWidthInBytesMinus1:dword ;# of VGA addresses from left edge
                                            ; to right edge of destination

;-----------------------------------------------------------------------;
; Set the pointer to the table used to flip glyph bits 0-3 and 4-7. This
; table is guaranteed to be on a 256-byte boundary, so look-up can be
; performed simply by loading the low byte of a pointer register.
;-----------------------------------------------------------------------;

        mov     esi,ppdev
        mov     ebx,prclText    ;point to bounding text rect during 486
                                ; interlock slot
        mov     eax,[esi].pdev_pjGlyphFlipTable
        mov     pGlyphFlipTable,eax

;-----------------------------------------------------------------------;
; If 8 wide, byte aligned, and opaque, handle with very fast special-case
; code.
;-----------------------------------------------------------------------;

        cmp     ulCharInc,8                     ;8 wide?
        jnz     short @F                        ;no
        cmp     fDrawFlags,5                    ;fixed pitch?
        jnz     short @F                        ;no
        cmp     prclOpaque,0                    ;opaque?
        jz      short @F                        ;no
        test    [ebx].xLeft,111b                ;byte aligned?
        jz      special_8_wide_aligned_opaque   ;yes, special-case
@@:

general_handler::

        mov     esi,ppdev
        mov     eax,[ebx].yTop
        mov     ulTopScan,eax   ;Y screen coordinate of top edge of temp buf
        mov     eax,[ebx].xLeft
        and     eax,not 7
        mov     ulTempLeft,eax  ;X screen coordinate of left edge of temp buf

        mov     eax,fDrawFlags

        mov     edx,[ebx].yBottom
        mov     ulBottomScan,edx ;bottom scan of text area

        jmp     MasterTextTypeTable[eax*4]

;-----------------------------------------------------------------------;
; Entry point for fixed-pitch | tops and bottoms aligned | no overlap.
; Sets up to draw first glyph.
;-----------------------------------------------------------------------;
draw_f_tb_no_to_temp_start::
        mov     ebx,pGlyphPos           ;point to the first glyph to draw
        mov     esi,[ebx].gp_pgdf       ;point to glyph def

        mov     edi,[ebx].gp_x          ;dest X coordinate
        sub     edi,ulTempLeft          ;adjust relative to the left of the
                                        ; temp buffer (we assume the text is
                                        ; right at the top of the text rect
                                        ; and hence the buffer)
        mov     ulGlyphX,edi            ;remember where this glyph started
        mov     esi,[esi].gdf_pgb       ;point to glyph bits
        mov     pGlyphLoop,offset draw_f_tb_no_to_temp_loop
                                        ;draw additional characters with this
                                        ; loop
        jmp     short draw_to_temp_start_entry

;-----------------------------------------------------------------------;
; Entry point for non-fixed-pitch | tops and bottoms aligned | no overlap.
; Sets up to draw first glyph.
;-----------------------------------------------------------------------;
draw_nf_tb_no_to_temp_start::
        mov     ebx,pGlyphPos           ;point to the first glyph to draw
        mov     esi,[ebx].gp_pgdf       ;point to glyph def

        mov     edi,[ebx].gp_x          ;dest X coordinate
        sub     edi,ulTempLeft          ;adjust relative to the left of the
                                        ; temp buffer
        mov     esi,[esi].gdf_pgb       ;point to glyph bits
        mov     pGlyphLoop,offset draw_nf_tb_no_to_temp_loop
                                        ;draw additional characters with this
                                        ; loop
draw_to_temp_start_entry::
        add     edi,[esi].gb_x          ;adjust to position of upper left glyph
                                        ; corner in dest
        mov     ecx,edi
        shr     edi,3                   ;byte offset of first column of glyph
                                        ; offset of upper left of glyph in temp
                                        ; buffer
        add     edi,pTempBuffer         ;initial dest byte in temp buffer

        and     ecx,111b                ;bit alignment of upper left in temp

                                        ;calculate scan-to-scan glyph width
        mov     ebx,[esi].gb_cx         ;glyph width in pixels

        lea     eax,[ebx+ecx+7]
        shr     eax,3                   ;# of dest bytes per scan

        add     ebx,7
        shr     ebx,3                   ;# of source bytes per scan

        mov     edx,ulBufDelta          ;width of destination buffer in bytes

        cmp     eax,4                   ;do we have special case code for this
                                        ; dest width?
        ja      short @F                ;no, handle as general case
                                        ;yes, handle as special case
        cmp     ebx,eax                 ;carry if more dest than source bytes
                                        ; (last source byte not needed)
        rcl     eax,1                   ;factor last source byte status in
        cmp     cl,1                    ;carry if aligned
        rcl     eax,1                   ;factor in alignment (aligned or not)
        mov     ebx,[esi].gb_cy         ;# of scans in glyph
        add     esi,gb_aj               ;point to the first glyph byte

        jmp     MovInitialTableNarrow[eax*4]
                                        ;branch to draw the first glyph; never
                                        ; need to OR first glyph, because
                                        ; there's nothing there yet

@@:                                     ;too wide to special case
        mov     ulWidthInBytes,eax      ;# of bytes across dest
        cmp     ebx,eax                 ;carry if more dest than source bytes
                                        ; (last source byte not needed)
        mov     eax,0
        rcl     eax,1                   ;factor last source byte status in
        cmp     cl,1                    ;carry if aligned
        rcl     eax,1                   ;factor in alignment (aligned or not)

        mov     ebx,[esi].gb_cx         ;glyph width in pixels
        add     ebx,7
        shr     ebx,3                   ;glyph width in bytes
        mov     ulGlyDelta,ebx

        mov     ebx,[esi].gb_cy         ;# of scans in glyph
        add     esi,gb_aj               ;point to the first glyph byte

        jmp     MovInitialTableWide[eax*4]
                                        ;branch to draw the first glyph; never
                                        ; need to OR first glyph, because
                                        ; there's nothing there yet

;-----------------------------------------------------------------------;
; Entry point for fixed-pitch | tops and bottoms not aligned | overlap.
; Sets up to draw first glyph.
;-----------------------------------------------------------------------;
draw_f_ntb_o_to_temp_start::
        mov     ebx,pGlyphPos           ;point to the first glyph to draw
        mov     pGlyphLoop,offset draw_f_ntb_o_to_temp_loop
                                        ;draw additional characters with this
                                        ; loop
        mov     edi,[ebx].gp_x          ;dest X coordinate
        mov     esi,[ebx].gp_pgdf       ;point to glyph def
        sub     edi,ulTempLeft          ;adjust relative to the left of the
                                        ; temp buffer
        mov     ulGlyphX,edi            ;remember where this glyph started
        mov     esi,[esi].gdf_pgb       ;point to glyph bits
        add     edi,[esi].gb_x          ;adjust to position of upper left glyph
                                        ; corner in dest
        mov     ecx,edi
        shr     edi,3                   ;byte offset of first column of glyph
                                        ; offset of upper left of glyph in temp
                                        ; buffer
        jmp     short draw_to_temp_start_entry2

;-----------------------------------------------------------------------;
; Entry point for non-fixed-pitch | tops and bottoms not aligned | overlap.
; Sets up to draw first glyph.
;-----------------------------------------------------------------------;
draw_nf_ntb_o_to_temp_start::
        mov     ebx,pGlyphPos           ;point to the first glyph to draw
        mov     pGlyphLoop,offset draw_nf_ntb_o_to_temp_loop
                                        ;draw additional characters with this
                                        ; loop
        mov     edi,[ebx].gp_x          ;dest X coordinate
        mov     esi,[ebx].gp_pgdf       ;point to glyph def
        sub     edi,ulTempLeft          ;adjust relative to the left of the
                                        ; temp buffer
        mov     esi,[esi].gdf_pgb       ;point to glyph bits
        add     edi,[esi].gb_x          ;adjust to position of upper left glyph
                                        ; corner in dest
        mov     ecx,edi
        shr     edi,3                   ;byte offset of first column of glyph
                                        ; offset of upper left of glyph in temp
                                        ; buffer
draw_to_temp_start_entry2::
        mov     eax,[ebx].gp_y          ;dest origin Y coordinate
        sub     eax,ulTopScan           ;coord of glyph origin in temp buffer
        mov     ulYOrigin,eax           ;remember the Y origin of all glyphs
                                        ; (necessary because glyph positions
                                        ; after first aren't set for fixed-
                                        ; pitch strings)
        add     eax,[esi].gb_y          ;adjust to position of upper left glyph
                                        ; corner in dest
        mul     ulBufDelta              ;offset in buffer of top glyph scan
        add     eax,pTempBuffer         ;initial dest byte
        add     edi,eax

        and     ecx,111b                ;bit alignment of upper left in temp

                                        ;calculate scan-to-scan glyph width
        mov     ebx,[esi].gb_cx         ;glyph width in pixels

        lea     eax,[ebx+ecx+7]
        shr     eax,3                   ;# of dest bytes per scan

        add     ebx,7
        shr     ebx,3                   ;# of source bytes per scan

        mov     edx,ulBufDelta          ;width of destination buffer in bytes

        cmp     eax,4                   ;do we have special case code for this
                                        ; dest width?
        ja      short @F                ;no, handle as general case
                                        ;yes, handle as special case
        cmp     ebx,eax                 ;carry if more dest than source bytes
                                        ; (last source byte not needed)
        rcl     eax,1                   ;factor last source byte status in
        cmp     cl,1                    ;carry if aligned
        rcl     eax,1                   ;factor in alignment (aligned or not)
        mov     ebx,[esi].gb_cy         ;# of scans in glyph
        add     esi,gb_aj               ;point to the first glyph byte

        jmp     OrAllTableNarrow[eax*4] ;branch to draw the first glyph; OR all
                                        ; glyphs, because text may overlap

@@:                                     ;too wide to special case
        mov     ulWidthInBytes,eax      ;# of bytes across dest
        cmp     ebx,eax                 ;carry if more dest than source bytes
                                        ; (last source byte not needed)
        mov     eax,0
        rcl     eax,1                   ;factor last source byte status in
        cmp     cl,1                    ;carry if aligned
        rcl     eax,1                   ;factor in alignment (aligned or not)

        mov     ebx,[esi].gb_cx         ;glyph width in pixels
        add     ebx,7
        shr     ebx,3                   ;glyph width in bytes
        mov     ulGlyDelta,ebx

        mov     ebx,[esi].gb_cy         ;# of scans in glyph
        add     esi,gb_aj               ;point to the first glyph byte

        jmp     OrAllTableWide[eax*4]   ;branch to draw the first glyph; OR all                                 ; glyphs, because text may overlap never
                                        ; glyphs, because text may overlap

;-----------------------------------------------------------------------;
; Loop to draw all fixed-pitch | tops and bottoms aligned | no overlap
; glyphs after first.
;-----------------------------------------------------------------------;
draw_f_tb_no_to_temp_loop::
        dec     ulGlyphCount            ;any more glyphs to draw?
        jz      draw_to_screen          ;no, done
        mov     ebx,pGlyphPos
        add     ebx,size GLYPHPOS       ;point to the next glyph (the one
        mov     pGlyphPos,ebx           ; we're going to draw this time)
        mov     esi,[ebx].gp_pgdf       ;point to glyph def

        mov     edi,ulGlyphX            ;last glyph's dest X start in temp buf
        add     edi,ulCharInc           ;this glyph's dest X start in temp buf
        mov     ulGlyphX,edi            ;remember for next glyph
        mov     esi,[esi].gdf_pgb       ;point to glyph bits
        jmp     short draw_to_temp_loop_entry

;-----------------------------------------------------------------------;
; Loop to draw all non-fixed-pitch | tops and bottoms aligned | no overlap
; glyphs after first.
;-----------------------------------------------------------------------;
draw_nf_tb_no_to_temp_loop::
        dec     ulGlyphCount            ;any more glyphs to draw?
        jz      draw_to_screen          ;no, done
        mov     ebx,pGlyphPos
        add     ebx,size GLYPHPOS       ;point to the next glyph (the one we're
        mov     pGlyphPos,ebx           ; going to draw this time)
        mov     esi,[ebx].gp_pgdf       ;point to glyph def
        mov     edi,[ebx].gp_x          ;dest X coordinate
        mov     esi,[esi].gdf_pgb       ;point to glyph bits
        sub     edi,ulTempLeft          ;adjust relative to the left edge of
                                        ; the temp buffer

draw_to_temp_loop_entry::
        add     edi,[esi].gb_x          ;adjust to position of upper left glyph
                                        ; corner in dest
        mov     ecx,edi                 ;pixel X coordinate in temp buffer
        shr     edi,3                   ;byte offset of first column = dest
                                        ; offset of upper left of glyph in temp
                                        ; buffer
        add     edi,pTempBuffer         ;initial dest byte

        and     ecx,111b                ;bit alignment of upper left in temp

                                        ;calculate scan-to-scan glyph width
        mov     ebx,[esi].gb_cx         ;glyph width in pixels

        lea     eax,[ebx+ecx+7]
        shr     eax,3                   ;# of dest bytes to copy to per scan

        add     ebx,7
        shr     ebx,3                   ;# of source bytes to copy from per
                                        ; scan
        mov     edx,ulBufDelta          ;width of destination buffer in bytes

        cmp     eax,4                   ;do we have special case code for this
                                        ; dest width?
        ja      short @F                ;no, handle as general case
                                        ;yes, handle as special case
        cmp     ebx,eax                 ;carry if more dest than source bytes
                                        ; (last source byte not needed)
        rcl     eax,1                   ;factor last source byte status in
        cmp     cl,1                    ;carry if aligned
        rcl     eax,1                   ;factor in alignment (aligned or not)
        mov     ebx,[esi].gb_cy         ;# of scans in glyph
        add     esi,gb_aj               ;point to the first glyph byte

        jmp     OrInitialTableNarrow[eax*4] ;branch to draw the first glyph;
                                            ; need to OR the 1st byte if
                                            ; non-aligned to avoid overwriting
                                            ; what's already there
@@:                                     ;too wide to special case
        mov     ulWidthInBytes,eax      ;# of bytes across dest
        cmp     ebx,eax                 ;carry if more dest than source bytes
                                        ; (last source byte not needed)
        mov     eax,0
        rcl     eax,1                   ;factor last source byte status in
        cmp     cl,1                    ;carry if aligned
        rcl     eax,1                   ;factor in alignment (aligned or not)

        mov     ebx,[esi].gb_cx         ;glyph width in pixels
        add     ebx,7
        shr     ebx,3                   ;glyph width in bytes
        mov     ulGlyDelta,ebx

        mov     ebx,[esi].gb_cy         ;# of scans in glyph
        add     esi,gb_aj               ;point to the first glyph byte

        jmp     OrInitialTableWide[eax*4] ;branch to draw the next glyph;
                                          ; need to OR the 1st byte if
                                          ; non-aligned to avoid overwriting
                                          ; what's already there

;-----------------------------------------------------------------------;
; Loop to draw all fixed-pitch | tops and bottoms not aligned | overlap
; glyphs after first.
;-----------------------------------------------------------------------;
draw_f_ntb_o_to_temp_loop::
        dec     ulGlyphCount            ;any more glyphs to draw?
        jz      draw_to_screen          ;no, done
        mov     ebx,pGlyphPos
        add     ebx,size GLYPHPOS       ;point to the next glyph (the one we're
        mov     pGlyphPos,ebx           ; going to draw this time)

        mov     esi,[ebx].gp_pgdf       ;point to glyph def
        mov     edi,ulGlyphX            ;last glyph's dest X start in temp buf
        add     edi,ulCharInc           ;this glyph's dest X start in temp buf
        mov     ulGlyphX,edi            ;remember for next glyph
        mov     esi,[esi].gdf_pgb       ;point to glyph bits

        jmp     short draw_to_temp_loop_entry2

;-----------------------------------------------------------------------;
; Loop to draw all non-fixed-pitch | tops and bottoms not aligned | overlap
; glyphs after first.
;-----------------------------------------------------------------------;
draw_nf_ntb_o_to_temp_loop::
        dec     ulGlyphCount            ;any more glyphs to draw?
        jz      draw_to_screen          ;no, done
        mov     ebx,pGlyphPos
        add     ebx,size GLYPHPOS       ;point to the next glyph (the one we're
        mov     pGlyphPos,ebx           ; going to draw this time)

        mov     esi,[ebx].gp_pgdf       ;point to glyph def
        mov     edi,[ebx].gp_x          ;dest X coordinate
        mov     esi,[esi].gdf_pgb       ;point to glyph bits
        sub     edi,ulTempLeft          ;adjust relative to the left edge of
                                        ; the temp buffer
draw_to_temp_loop_entry2::
        add     edi,[esi].gb_x          ;adjust to position of upper left glyph
                                        ; corner in dest
        mov     ecx,edi                 ;pixel X coordinate in temp buffer
        shr     edi,3                   ;byte offset of first column = dest
                                        ; offset of upper left of glyph in temp
                                        ; buffer
        mov     eax,ulYOrigin           ;dest Y coordinate

        add     eax,[esi].gb_y          ;adjust to position of upper left glyph
                                        ; corner in dest
        mul     ulBufDelta              ;offset in buffer of top glyph scan
        add     eax,pTempBuffer         ;initial dest byte
        add     edi,eax

        and     ecx,111b                ;bit alignment of upper left in temp

                                        ;calculate scan-to-scan glyph width
        mov     ebx,[esi].gb_cx         ;glyph width in pixels

        lea     eax,[ebx+ecx+7]
        shr     eax,3                   ;# of dest bytes to copy to per scan

        add     ebx,7
        shr     ebx,3                   ;# of source bytes to copy from per
                                        ; scan
        mov     edx,ulBufDelta          ;width of destination buffer in bytes

        cmp     eax,4                   ;do we have special case code for this
                                        ; dest width?
        ja      short @F                ;no, handle as general case
                                        ;yes, handle as special case
        cmp     ebx,eax                 ;carry if more dest than source bytes
                                        ; (last source byte not needed)
        rcl     eax,1                   ;factor last source byte status in
        cmp     cl,1                    ;carry if aligned
        rcl     eax,1                   ;factor in alignment (aligned or not)
        mov     ebx,[esi].gb_cy         ;# of scans in glyph
        add     esi,gb_aj               ;point to the first glyph byte

        jmp     OrAllTableNarrow[eax*4] ;branch to draw the next glyph

@@:                                     ;too wide to special case
        mov     ulWidthInBytes,eax      ;# of bytes across dest
        cmp     ebx,eax                 ;carry if more dest than source bytes
                                        ; (last source byte not needed)
        mov     eax,0
        rcl     eax,1                   ;factor last source byte status in
        cmp     cl,1                    ;carry if aligned
        rcl     eax,1                   ;factor in alignment (aligned or not)

        mov     ebx,[esi].gb_cx         ;glyph width in pixels
        add     ebx,7
        shr     ebx,3                   ;glyph width in bytes
        mov     ulGlyDelta,ebx

        mov     ebx,[esi].gb_cy         ;# of scans in glyph
        add     esi,gb_aj               ;point to the first glyph byte

        jmp     OrAllTableWide[eax*4]   ;branch to draw the next glyph

;-----------------------------------------------------------------------;
; Routines to draw all scans of a single glyph into the temp buffer,
; optimized for the following cases:
;
;       1 to 4 byte-wide destination rectangles for each of:
;               No rotation needed
;               Rotation needed, same # of source as dest bytes needed
;               Rotation needed, one less source than dest bytes needed
;
; Additionally, the three cases are handled for 5 and wider cases by a
; general routine for each case.
;
; If rotation is needed, there are three sorts of routines:
;
; 1) The leftmost byte is MOVed, to initialize the byte. Succeeding bytes are
;    MOVed. This is generally used for the leftmost glyph of a string.
; 2) The leftmost byte is ORed into the existing byte. Succeeding bytes are
;    MOVed. This is generally used after the leftmost glyph, because this may
;    not be the first data written to that byte.
; 3) All bytes are ORed. This is for drawing when characters might overlap.
;
; If rotation is not needed, there are two sorts of routines:
;
; 1) The leftmost byte is MOVed, to initialize the byte. Succeeding bytes are
;    MOVed. This is generally used for the leftmost glyph of a string.
; 2) All bytes are ORed. This is for drawing when characters might overlap.
;
; On entry:
;       EBX = # of scans to copy
;       CL  = right rotation
;       EDX = ulBufDelta = width per scan of destination buffer, in bytes
;       ESI = pointer to first glyph byte
;       EDI = pointer to first dest buffer byte
;       DF  = cleared
;       ulGlyDelta = width per scan of source glyph, in bytes (wide case only)
;       ulWidthInBytes = width of glyph, in bytes (required only for 5 and
;               wider cases)
;
; On exit:
;       Any or all of EAX, EBX, ECX, EDX, ESI, and EDI may be trashed.

;-----------------------------------------------------------------------;
; OR first byte, 1 byte wide dest, rotated.
;-----------------------------------------------------------------------;
or_all_1_wide_rotated_need_last::
or_all_1_wide_rotated_no_last::
or_first_1_wide_rotated_need_last::
or_first_1_wide_rotated_no_last::
or_first_1_wide_rotated_loop::
        mov     ch,[esi]
        inc     esi
        shr     ch,cl
        or      [edi],ch
        add     edi,edx
        dec     ebx
        jnz     or_first_1_wide_rotated_loop
        jmp     pGlyphLoop

;-----------------------------------------------------------------------;
; MOV first byte, 1 byte wide dest, rotated.
;-----------------------------------------------------------------------;
mov_first_1_wide_rotated_need_last::
mov_first_1_wide_rotated_no_last::
mov_first_1_wide_rotated_loop::
        mov     ch,[esi]
        inc     esi
        shr     ch,cl
        mov     [edi],ch
        add     edi,edx
        dec     ebx
        jnz     mov_first_1_wide_rotated_loop
        jmp     pGlyphLoop

;-----------------------------------------------------------------------;
; MOV first byte, 1 byte wide dest, unrotated.
;-----------------------------------------------------------------------;
mov_first_1_wide_unrotated::
mov_first_1_wide_unrotated_loop::
        mov     al,[esi]
        inc     esi
        mov     [edi],al
        add     edi,edx
        dec     ebx
        jnz     mov_first_1_wide_unrotated_loop
        jmp     pGlyphLoop

;-----------------------------------------------------------------------;
; OR all bytes, 1 byte wide dest, unrotated.
;-----------------------------------------------------------------------;
or_all_1_wide_unrotated::
or_all_1_wide_unrotated_loop::
        mov     al,[esi]
        inc     esi
        or      [edi],al
        add     edi,edx
        dec     ebx
        jnz     or_all_1_wide_unrotated_loop
        jmp     pGlyphLoop

;-----------------------------------------------------------------------;
; OR first byte, 2 bytes wide dest, rotated, need final source byte.
;-----------------------------------------------------------------------;
or_first_2_wide_rotated_need_last::
or_first_2_wide_rotated_need_loop::
        mov     ax,[esi]
        add     esi,2
        ror     ax,cl
        or      [edi],al
        mov     [edi+1],ah
        add     edi,edx
        dec     ebx
        jnz     or_first_2_wide_rotated_need_loop
        jmp     pGlyphLoop

;-----------------------------------------------------------------------;
; OR all bytes, 2 bytes wide dest, rotated, need final source byte.
;-----------------------------------------------------------------------;
or_all_2_wide_rotated_need_last::
or_all_2_wide_rotated_need_loop::
        mov     ax,[esi]
        add     esi,2
        ror     ax,cl
        or      [edi],ax
        add     edi,edx
        dec     ebx
        jnz     or_all_2_wide_rotated_need_loop
        jmp     pGlyphLoop

;-----------------------------------------------------------------------;
; MOV first byte, 2 bytes wide dest, rotated, need final source byte.
;-----------------------------------------------------------------------;
mov_first_2_wide_rotated_need_last::
mov_first_2_wide_rotated_need_loop::
        mov     ax,[esi]
        add     esi,2
        ror     ax,cl
        mov     [edi],ax
        add     edi,edx
        dec     ebx
        jnz     mov_first_2_wide_rotated_need_loop
        jmp     pGlyphLoop

;-----------------------------------------------------------------------;
; OR first byte, 2 bytes wide dest, rotated, don't need final source byte.
;-----------------------------------------------------------------------;
or_first_2_wide_rotated_no_last::
or_first_2_wide_rotated_loop::
        sub     eax,eax
        mov     ah,[esi]
        inc     esi
        shr     eax,cl
        or      [edi],ah
        mov     [edi+1],al
        add     edi,edx
        dec     ebx
        jnz     or_first_2_wide_rotated_loop
        jmp     pGlyphLoop

;-----------------------------------------------------------------------;
; OR all bytes, 2 bytes wide dest, rotated, don't need final source byte.
;-----------------------------------------------------------------------;
or_all_2_wide_rotated_no_last::
or_all_2_wide_rotated_loop::
        sub     eax,eax
        mov     al,[esi]
        inc     esi
        ror     ax,cl
        or      [edi],ax
        add     edi,edx
        dec     ebx
        jnz     or_all_2_wide_rotated_loop
        jmp     pGlyphLoop

;-----------------------------------------------------------------------;
; MOV first byte, 2 bytes wide dest, rotated, don't need final source byte.
;-----------------------------------------------------------------------;
mov_first_2_wide_rotated_no_last::
mov_first_2_wide_rotated_loop::
        sub     eax,eax
        mov     al,[esi]
        inc     esi
        ror     ax,cl
        mov     [edi],ax
        add     edi,edx
        dec     ebx
        jnz     mov_first_2_wide_rotated_loop
        jmp     pGlyphLoop

;-----------------------------------------------------------------------;
; MOV first byte, 2 bytes wide dest, unrotated.
;-----------------------------------------------------------------------;
mov_first_2_wide_unrotated::
mov_first_2_wide_unrotated_loop::
        mov     ax,[esi]
        add     esi,2
        mov     [edi],ax
        add     edi,edx
        dec     ebx
        jnz     mov_first_2_wide_unrotated_loop
        jmp     pGlyphLoop

;-----------------------------------------------------------------------;
; OR all bytes, 2 bytes wide dest, unrotated.
;-----------------------------------------------------------------------;
or_all_2_wide_unrotated::
or_all_2_wide_unrotated_loop::
        mov     ax,[esi]
        add     esi,2
        or      [edi],ax
        add     edi,edx
        dec     ebx
        jnz     or_all_2_wide_unrotated_loop
        jmp     pGlyphLoop

;-----------------------------------------------------------------------;
; OR first byte, 3 bytes wide dest, rotated, need final source byte.
;-----------------------------------------------------------------------;
or_first_3_wide_rotated_need_last::
@@:
        mov     al,[esi]
        shr     al,cl
        or      [edi],al
        mov     ax,[esi]
        ror     ax,cl
        mov     [edi+1],ah
        mov     ax,[esi+1]
        add     esi,3
        ror     ax,cl
        mov     [edi+2],ah
        add     edi,edx
        dec     ebx
        jnz     @B
        jmp     pGlyphLoop

;-----------------------------------------------------------------------;
; OR first byte, 3 bytes wide dest, rotated, need final source byte.
;-----------------------------------------------------------------------;
or_all_3_wide_rotated_need_last::
@@:
        mov     al,[esi]
        shr     al,cl
        or      [edi],al
        mov     ax,[esi]
        ror     ax,cl
        or      [edi+1],ah
        mov     ax,[esi+1]
        add     esi,3
        ror     ax,cl
        or      [edi+2],ah
        add     edi,edx
        dec     ebx
        jnz     @B
        jmp     pGlyphLoop

;-----------------------------------------------------------------------;
; MOV first byte, 3 bytes wide dest, rotated, need final source byte.
;-----------------------------------------------------------------------;
mov_first_3_wide_rotated_need_last::
@@:
        mov     al,[esi]
        shr     al,cl
        mov     [edi],al
        mov     ax,[esi]
        ror     ax,cl
        mov     [edi+1],ah
        mov     ax,[esi+1]
        add     esi,3
        ror     ax,cl
        mov     [edi+2],ah
        add     edi,edx
        dec     ebx
        jnz     @B
        jmp     pGlyphLoop

;-----------------------------------------------------------------------;
; OR first byte, 3 bytes wide dest, rotated, don't need final source byte.
;-----------------------------------------------------------------------;
or_first_3_wide_rotated_no_last::
        neg     cl
        and     cl,111b         ;convert from right shift to left shift
@@:
        sub     eax,eax
        mov     ax,[esi]
        add     esi,2
        xchg    ah,al
        shl     eax,cl
        mov     [edi+1],ah
        mov     [edi+2],al
        shr     eax,16
        or      [edi],al
        add     edi,edx
        dec     ebx
        jnz     @B
        jmp     pGlyphLoop

;-----------------------------------------------------------------------;
; OR all bytes, 3 bytes wide dest, rotated, don't need final source byte.
;-----------------------------------------------------------------------;
or_all_3_wide_rotated_no_last::
        neg     cl
        and     cl,111b         ;convert from right shift to left shift
@@:
        sub     eax,eax
        mov     ax,[esi]
        add     esi,2
        xchg    ah,al
        shl     eax,cl
        xchg    ah,al
        or      [edi+1],ax
        shr     eax,16
        or      [edi],al
        add     edi,edx
        dec     ebx
        jnz     @B
        jmp     pGlyphLoop

;-----------------------------------------------------------------------;
; MOV first byte, 3 bytes wide dest, rotated, don't need final source byte.
;-----------------------------------------------------------------------;
mov_first_3_wide_rotated_no_last::
        neg     cl
        and     cl,111b         ;convert from right shift to left shift
@@:
        sub     eax,eax
        mov     ax,[esi]
        add     esi,2
        xchg    ah,al
        shl     eax,cl
        mov     [edi+1],ah
        mov     [edi+2],al
        shr     eax,16
        mov     [edi],al
        add     edi,edx
        dec     ebx
        jnz     @B
        jmp     pGlyphLoop

;-----------------------------------------------------------------------;
; MOV first byte, 3 bytes wide dest, unrotated.
;-----------------------------------------------------------------------;
mov_first_3_wide_unrotated::
@@:
        mov     ax,[esi]
        mov     [edi],ax
        mov     al,[esi+2]
        add     esi,3
        mov     [edi+2],al
        add     edi,edx
        dec     ebx
        jnz     @B
        jmp     pGlyphLoop

;-----------------------------------------------------------------------;
; OR all bytes, 3 bytes wide dest, unrotated.
;-----------------------------------------------------------------------;
or_all_3_wide_unrotated::
@@:
        mov     ax,[esi]
        or      [edi],ax
        mov     al,[esi+2]
        add     esi,3
        or      [edi+2],al
        add     edi,edx
        dec     ebx
        jnz     @B
        jmp     pGlyphLoop

;-----------------------------------------------------------------------;
; OR first byte, 4 bytes wide dest, rotated, need final source byte.
;-----------------------------------------------------------------------;
or_first_4_wide_rotated_need_last::
@@:
        mov     eax,[esi]
        add     esi,4
        xchg    ah,al
        ror     eax,16
        xchg    ah,al
        shr     eax,cl
        xchg    ah,al
        mov     [edi+2],ax
        shr     eax,16
        mov     [edi+1],al
        or      [edi],ah
        add     edi,edx
        dec     ebx
        jnz     @B
        jmp     pGlyphLoop

;-----------------------------------------------------------------------;
; OR all bytes, 4 bytes wide dest, rotated, need final source byte.
;-----------------------------------------------------------------------;
or_all_4_wide_rotated_need_last::
@@:
        mov     eax,[esi]
        add     esi,4
        xchg    ah,al
        ror     eax,16
        xchg    ah,al
        shr     eax,cl
        xchg    ah,al
        ror     eax,16
        xchg    al,ah
        or      [edi],eax
        add     edi,edx
        dec     ebx
        jnz     @B
        jmp     pGlyphLoop

;-----------------------------------------------------------------------;
; MOV first byte, 4 bytes wide dest, rotated, need final source byte.
;-----------------------------------------------------------------------;
mov_first_4_wide_rotated_need_last::
@@:
        mov     eax,[esi]
        add     esi,4
        xchg    ah,al
        ror     eax,16
        xchg    ah,al
        shr     eax,cl
        xchg    ah,al
        ror     eax,16
        xchg    ah,al
        mov     [edi],eax
        add     edi,edx
        dec     ebx
        jnz     @B
        jmp     pGlyphLoop

;-----------------------------------------------------------------------;
; OR first byte, 4 bytes wide dest, rotated, don't need final source byte.
;-----------------------------------------------------------------------;
or_first_4_wide_rotated_no_last::
@@:
        mov     ax,[esi]
        xchg    ah,al
        shl     eax,16
        mov     ah,[esi+2]
        add     esi,3
        shr     eax,cl
        xchg    ah,al
        mov     [edi+2],ax
        shr     eax,16
        mov     [edi+1],al
        or      [edi],ah
        add     edi,edx
        dec     ebx
        jnz     @B
        jmp     pGlyphLoop

;-----------------------------------------------------------------------;
; OR all bytes, 4 bytes wide dest, rotated, don't need final source byte.
;-----------------------------------------------------------------------;
or_all_4_wide_rotated_no_last::
@@:
        mov     ax,[esi]
        xchg    ah,al
        shl     eax,16
        mov     ah,[esi+2]
        add     esi,3
        shr     eax,cl
        xchg    ah,al
        ror     eax,16
        xchg    ah,al
        or      [edi],eax
        add     edi,edx
        dec     ebx
        jnz     @B
        jmp     pGlyphLoop

;-----------------------------------------------------------------------;
; MOV first byte, 4 bytes wide dest, rotated, don't need final source byte.
;-----------------------------------------------------------------------;
mov_first_4_wide_rotated_no_last::
@@:
        mov     ax,[esi]
        xchg    ah,al
        shl     eax,16
        mov     ah,[esi+2]
        add     esi,3
        shr     eax,cl
        xchg    ah,al
        ror     eax,16
        xchg    ah,al
        mov     [edi],eax
        add     edi,edx
        dec     ebx
        jnz     @B
        jmp     pGlyphLoop

;-----------------------------------------------------------------------;
; MOV first byte, 4 bytes wide dest, unrotated.
;-----------------------------------------------------------------------;
mov_first_4_wide_unrotated::
@@:
        mov     eax,[esi]
        add     esi,4
        mov     [edi],eax
        add     edi,edx
        dec     ebx
        jnz     @B
        jmp     pGlyphLoop

;-----------------------------------------------------------------------;
; OR all bytes, 4 bytes wide dest, unrotated.
;-----------------------------------------------------------------------;
or_all_4_wide_unrotated::
@@:
        mov     eax,[esi]
        add     esi,4
        or      [edi],eax
        add     edi,edx
        dec     ebx
        jnz     @B
        jmp     pGlyphLoop

;-----------------------------------------------------------------------;
; OR first byte, n bytes wide dest, rotated, need final source byte.
;-----------------------------------------------------------------------;
or_first_N_wide_rotated_need_last::
        mov     eax,ulWidthInBytes
        mov     edx,ulBufDelta
        sub     edx,eax
        mov     ulTmpDstDelta,edx
        dec     eax             ;source doesn't advance after first byte, and
                                ; we do the first byte outside the loop
        mov     edx,ulGlyDelta
        sub     edx,eax
        mov     ulTmpSrcDelta,edx
        mov     ulTmpWidthInBytes,eax
ofNwrnl_scan_loop:
        mov     al,[esi]        ;do the initial, ORed byte separately
        shr     al,cl
        or      [edi],al
        inc     edi
        mov     edx,ulTmpWidthInBytes
@@:
        mov     ax,[esi]
        inc     esi
        ror     ax,cl
        mov     [edi],ah
        inc     edi
        dec     edx
        jnz     @B
        add     esi,ulTmpSrcDelta
        add     edi,ulTmpDstDelta
        dec     ebx
        jnz     ofNwrnl_scan_loop
        jmp     pGlyphLoop

;-----------------------------------------------------------------------;
; OR all bytes, n bytes wide dest, rotated, need final source byte.
;-----------------------------------------------------------------------;
or_all_N_wide_rotated_need_last::
        mov     eax,ulWidthInBytes
        mov     edx,ulBufDelta
        sub     edx,eax
        mov     ulTmpDstDelta,edx
        dec     eax             ;source doesn't advance after first byte, and
                                ; we do the first byte outside the loop
        mov     edx,ulGlyDelta
        sub     edx,eax
        mov     ulTmpSrcDelta,edx
        mov     ulTmpWidthInBytes,eax
oaNwrnl_scan_loop:
        mov     al,[esi]        ;do the initial, ORed byte separately
        shr     al,cl
        or      [edi],al
        inc     edi
        mov     edx,ulTmpWidthInBytes
@@:
        mov     ax,[esi]
        inc     esi
        ror     ax,cl
        or      [edi],ah
        inc     edi
        dec     edx
        jnz     @B
        add     esi,ulTmpSrcDelta
        add     edi,ulTmpDstDelta
        dec     ebx
        jnz     oaNwrnl_scan_loop
        jmp     pGlyphLoop

;-----------------------------------------------------------------------;
; MOV first byte, n bytes wide dest, rotated, need final source byte.
;-----------------------------------------------------------------------;
mov_first_N_wide_rotated_need_last::
        mov     eax,ulWidthInBytes
        mov     edx,ulBufDelta
        sub     edx,eax
        mov     ulTmpDstDelta,edx
        mov     eax,ulWidthInBytes
        dec     eax             ;source doesn't advance after first byte, and
                                ; we do the first byte outside the loop
        mov     edx,ulGlyDelta
        sub     edx,eax
        mov     ulTmpSrcDelta,edx
        mov     ulTmpWidthInBytes,eax
mfNwrnl_scan_loop:
        mov     al,[esi]        ;do the initial byte separately
        shr     al,cl
        mov     [edi],al
        inc     edi
        mov     edx,ulTmpWidthInBytes
@@:
        mov     ax,[esi]
        inc     esi
        ror     ax,cl
        mov     [edi],ah
        inc     edi
        dec     edx
        jnz     @B
        add     esi,ulTmpSrcDelta
        add     edi,ulTmpDstDelta
        dec     ebx
        jnz     mfNwrnl_scan_loop
        jmp     pGlyphLoop

;-----------------------------------------------------------------------;
; OR first byte, N bytes wide dest, rotated, don't need final source byte.
;-----------------------------------------------------------------------;
or_first_N_wide_rotated_no_last::
        mov     eax,ulWidthInBytes
        dec     eax             ;one less because we don't advance after the
                                ; last byte
        mov     edx,ulBufDelta
        sub     edx,eax
        mov     ulTmpDstDelta,edx
        dec     eax             ;source doesn't advance after first byte, and
                                ; we do the first & last bytes outside the
                                ; loop; already subtracted 1 above
        mov     edx,ulGlyDelta
        sub     edx,eax
        mov     ulTmpSrcDelta,edx
        mov     ulTmpWidthInBytes,eax
ofNwr_scan_loop:
        mov     al,[esi]        ;do the initial, ORed byte separately
        shr     al,cl
        or      [edi],al
        inc     edi
        mov     edx,ulTmpWidthInBytes
@@:
        mov     ax,[esi]
        inc     esi
        ror     ax,cl
        mov     [edi],ah
        inc     edi
        dec     edx
        jnz     @B

        mov     ah,[esi]        ;do the final byte separately
        sub     al,al
        shr     eax,cl
        mov     [edi],al

        add     esi,ulTmpSrcDelta
        add     edi,ulTmpDstDelta
        dec     ebx
        jnz     ofNwr_scan_loop
        jmp     pGlyphLoop

;-----------------------------------------------------------------------;
; OR all bytes, N bytes wide dest, rotated, don't need final source byte.
;-----------------------------------------------------------------------;
or_all_N_wide_rotated_no_last::
        mov     eax,ulWidthInBytes
        dec     eax             ;one less because we don't advance after the
                                ; last byte
        mov     edx,ulBufDelta
        sub     edx,eax
        mov     ulTmpDstDelta,edx
        dec     eax             ;source doesn't advance after first byte, and
                                ; we do the first & last bytes outside the
                                ; loop; already subtracted 1 above
        mov     edx,ulGlyDelta
        sub     edx,eax
        mov     ulTmpSrcDelta,edx
        mov     ulTmpWidthInBytes,eax
oaNwr_scan_loop:
        mov     al,[esi]        ;do the initial, ORed byte separately
        shr     al,cl
        or      [edi],al
        inc     edi
        mov     edx,ulTmpWidthInBytes
@@:
        mov     ax,[esi]
        inc     esi
        ror     ax,cl
        or      [edi],ah
        inc     edi
        dec     edx
        jnz     @B

        mov     ah,[esi]        ;do the final byte separately
        sub     al,al
        shr     eax,cl
        or      [edi],al

        add     esi,ulTmpSrcDelta
        add     edi,ulTmpDstDelta
        dec     ebx
        jnz     oaNwr_scan_loop
        jmp     pGlyphLoop

;-----------------------------------------------------------------------;
; MOV first byte, N bytes wide dest, rotated, don't need final source byte.
;-----------------------------------------------------------------------;
mov_first_N_wide_rotated_no_last::
        mov     eax,ulWidthInBytes
        dec     eax             ;one less because we don't advance after the
                                ; last byte
        mov     edx,ulBufDelta
        sub     edx,eax
        mov     ulTmpDstDelta,edx
        dec     eax             ;source doesn't advance after first byte, and
                                ; we do the first & last bytes outside the
                                ; loop; already subtracted 1 above
        mov     edx,ulGlyDelta
        sub     edx,eax
        mov     ulTmpSrcDelta,edx
        mov     ulTmpWidthInBytes,eax
mfNwr_scan_loop:
        mov     al,[esi]        ;do the initial byte separately
        shr     al,cl
        mov     [edi],al
        inc     edi
        mov     edx,ulTmpWidthInBytes
@@:
        mov     ax,[esi]
        inc     esi
        ror     ax,cl
        mov     [edi],ah
        inc     edi
        dec     edx
        jnz     @B

        mov     ah,[esi]        ;do the final byte separately
        sub     al,al
        shr     eax,cl
        mov     [edi],al

        add     esi,ulTmpSrcDelta
        add     edi,ulTmpDstDelta
        dec     ebx
        jnz     mfNwr_scan_loop
        jmp     pGlyphLoop

;-----------------------------------------------------------------------;
; MOV first byte, N bytes wide dest, unrotated.
;-----------------------------------------------------------------------;
mov_first_N_wide_unrotated::
        mov     edx,ulBufDelta
        mov     eax,ulWidthInBytes
        sub     edx,eax
        shr     eax,1           ;width in words
        jc      short odd_width ;there's at least one odd byte
        shr     eax,1           ;width in dwords
        jc      short two_odd_bytes ;there's an odd word
                                ;copy width is a dword multiple
@@:
        mov     ecx,eax
        rep     movsd           ;copy as many dwords as possible
        add     edi,edx
        dec     ebx
        jnz     @B
        jmp     pGlyphLoop

odd_width::
        shr     eax,1           ;width in dwords
        jc      short three_odd_bytes ;there's an odd word and an odd byte
                                ;there's just an odd byte
        inc     edx             ;because we won't advance after last byte
@@:
        mov     ecx,eax
        rep     movsd           ;copy as many dwords as possible
        mov     cl,[esi]
        inc     esi
        mov     [edi],cl
        add     edi,edx
        dec     ebx
        jnz     @B
        jmp     pGlyphLoop

two_odd_bytes::
        add     edx,2           ;because we won't advance after last word
@@:
        mov     ecx,eax
        rep     movsd           ;copy as many dwords as possible
        mov     cx,[esi]
        add     esi,2
        mov     [edi],cx
        add     edi,edx
        dec     ebx
        jnz     @B
        jmp     pGlyphLoop

three_odd_bytes::
        add     edx,3           ;because we won't advance after last word/byte
@@:
        mov     ecx,eax
        rep     movsd           ;copy as many dwords as possible
        mov     cx,[esi]
        mov     [edi],cx
        mov     cl,[esi+2]
        add     esi,3
        mov     [edi+2],cl
        add     edi,edx
        dec     ebx
        jnz     @B
        jmp     pGlyphLoop

;-----------------------------------------------------------------------;
; OR all bytes, N bytes wide dest, unrotated.
;-----------------------------------------------------------------------;
or_all_N_wide_unrotated::
        mov     edx,ulBufDelta
        mov     eax,ulWidthInBytes
        sub     edx,eax
        shr     eax,1           ;width in words
        jc      short or_odd_width ;there's at least one odd byte
        shr     eax,1           ;width in dwords
        jc      short or_two_odd_bytes ;there's an odd word
                                ;copy width is a dword multiple
or_no_odd_bytes_loop::
        push    ebx             ;preserve scan count
        mov     ebx,eax
@@:
        mov     ecx,[esi]
        add     esi,4
        or      [edi],ecx
        add     edi,4           ;copy as many dwords as possible
        dec     ebx
        jnz     @B
        add     edi,edx
        pop     ebx             ;restore scan count
        dec     ebx
        jnz     or_no_odd_bytes_loop
        jmp     pGlyphLoop

or_odd_width::
        shr     eax,1           ;width in dwords
        jc      short or_three_odd_bytes ;there's an odd word and an odd byte
                                ;there's just an odd byte
        inc     edx             ;skip over last byte too
or_one_odd_bytes_loop::
        push    ebx             ;preserve scan count
        mov     ebx,eax
@@:
        mov     ecx,[esi]
        add     esi,4
        or      [edi],ecx
        add     edi,4           ;copy as many dwords as possible
        dec     ebx
        jnz     @B
        mov     cl,[esi]
        or      [edi],cl
        inc     esi
        add     edi,edx
        pop     ebx             ;restore scan count
        dec     ebx
        jnz     or_one_odd_bytes_loop
        jmp     pGlyphLoop

or_two_odd_bytes::
        add     edx,2           ;skip over last 2 bytes too
or_two_odd_bytes_loop::
        push    ebx             ;preserve scan count
        mov     ebx,eax
@@:
        mov     ecx,[esi]
        add     esi,4
        or      [edi],ecx
        add     edi,4           ;copy as many dwords as possible
        dec     ebx
        jnz     @B
        mov     cx,[esi]
        or      [edi],cx
        add     esi,2
        add     edi,edx
        pop     ebx             ;restore scan count
        dec     ebx
        jnz     or_two_odd_bytes_loop
        jmp     pGlyphLoop

or_three_odd_bytes::
        add     edx,3           ;skip over last 3 bytes too
or_three_odd_bytes_loop::
        push    ebx             ;preserve scan count
        mov     ebx,eax
@@:
        mov     ecx,[esi]
        add     esi,4
        or      [edi],ecx
        add     edi,4           ;copy as many dwords as possible
        dec     ebx
        jnz     @B
        mov     cx,[esi]
        or      [edi],cx
        mov     cl,[esi+2]
        or      [edi+2],cl
        add     esi,3
        add     edi,edx
        pop     ebx             ;restore scan count
        dec     ebx
        jnz     or_three_odd_bytes_loop
        jmp     pGlyphLoop

;-----------------------------------------------------------------------;
; At this point, the text is drawn to the temp buffer.
; Now, color-expand the temp buffer to the screen.
;
; Input:
;       ppdev = pointer to target surface's PDEV (screen)
;       prclText = pointer to text bounding rectangle
;       prclOpaque = pointer to opaquing rectangle, if there is one
;       iFgColor = text color
;       iBgColor = opaquing rectangle color, if there is one
;       ulTempLeft = X coordinate on dest of left edge of temp buffer pointed
;               to by pTempBuffer
;       pTempBuffer = pointer to first byte (upper left corner) of
;               temp buffer into which we're drawing. This should be
;               word-aligned with the destination
;       ulBufDelta = destination scan-to-scan offset
;       Text drawn to temp buffer
;
;-----------------------------------------------------------------------;
draw_to_screen::

;-----------------------------------------------------------------------;
; Is this transparent or opaque text?
;-----------------------------------------------------------------------;

        cmp     prclOpaque,0
        jnz     opaque_text

;-----------------------------------------------------------------------;
; Transparent text.
;-----------------------------------------------------------------------;

;-----------------------------------------------------------------------;
; Calculate drawing parameters.
;-----------------------------------------------------------------------;

        mov     esi,prclText
        mov     ebx,ppdev
        mov     eax,[esi].xRight
        mov     edx,[esi].xLeft
        and     edx,not 7
        add     eax,7
        sub     eax,edx
        shr     eax,3           ;width of text in temp buffer in bytes, rounded
        mov     ulXparBytes,eax ; up. Also number of quadpixels to draw

        mov     ecx,[ebx].pdev_lNextScan
        mov     ulScreenDelta,ecx
        shl     eax,3           ;each temp buffer byte maps to eight VGA
                                ; addresses (two quadpixels in linear mode)
        sub     ecx,eax         ;offset to next scan in screen
        mov     ulTmpDstDelta,ecx

;-----------------------------------------------------------------------;
; Calculate the offset of the initial destination quadpixel.
;-----------------------------------------------------------------------;

        mov     eax,[esi].yTop
        mul     ulScreenDelta
        mov     edi,ulTempLeft
        add     edi,eax         ;offset in bitmap of first quadpixel's byte
                                ; (remember, this is linear mode)
;-----------------------------------------------------------------------;
; Map in the bank containing the top scan of the text, if it's not
; mapped in already.
;-----------------------------------------------------------------------;

        mov     eax,[esi].yTop  ;top scan line of text
        mov     ulTopScan,eax
        mov     esi,pTempBuffer ;initial source address
        cmp     eax,[ebx].pdev_rcl1WindowClip.yTop ;is text top less than
                                                   ; current bank?
        jl      short xpar_map_init_bank           ;yes, map in proper bank
        cmp     eax,[ebx].pdev_rcl1WindowClip.yBottom ;text top greater than
                                                      ; current bank?
        jl      short xpar_init_bank_mapped     ;no, proper bank already mapped
xpar_map_init_bank::

; Map in the bank containing the top scan line of the fill.
; Preserves EBX, ESI, and EDI.

        ptrCall <dword ptr [ebx].pdev_pfnBankControl>,<ebx,eax,JustifyTop>

xpar_init_bank_mapped::

        add     edi,[ebx].pdev_pvBitmapStart    ;initial destination address

;-----------------------------------------------------------------------;
; Main loop for processing fill in each bank.
;
; At start of loop, EBX->pdsurf
;-----------------------------------------------------------------------;

xpar_bank_loop::
        mov     edx,ulBottomScan        ;bottom of destination rectangle
        cmp     edx,[ebx].pdev_rcl1WindowClip.yBottom
                                        ;which comes first, the bottom of the
                                        ; text rect or the bottom of the
                                        ; current bank?
        jl      short @F                ;text bottom comes first, so draw to
                                        ; that; this is the last bank in text
        mov     edx,[ebx].pdev_rcl1WindowClip.yBottom
                                        ;bank bottom comes first; draw to
                                        ; bottom of bank
@@:
        sub     edx,ulTopScan           ;# of scans to draw in bank

        mov     al,byte ptr iFgColor
        mov     ah,al
        mov     ebx,eax
        shl     eax,16
        mov     ax,bx                   ;put drawing color in all bytes of EAX

        sub     ebx,ebx                 ;prepare for look-up in loop
xpar_scan_loop::

        mov     ecx,ulXparBytes         ;number of quadpixel pairs to draw

        mov     bl,[esi]                ;get next glyph byte
        and     bl,bl                   ;are all 8 pixels transparent?
        jz      xpar_low_nibble_0       ;yes, just skip everything in this byte
        shr     bl,4                    ;shift the high nibble into the low
                                        ; nibble
        jmp     xpar_high_nibble_table[ebx*4] ;branch to draw up to four
                                              ; pixels, followed by a branch to
                                              ; draw the the other nibble (up
                                              ; to four more pixels)
xpar_scan_done::

        add     edi,ulTmpDstDelta       ;point to next screen scan

        dec     edx                     ;count down scans
        jnz     xpar_scan_loop

;-----------------------------------------------------------------------;
; See if there are more banks to draw.
;-----------------------------------------------------------------------;

        mov     ebx,ppdev
        mov     eax,[ebx].pdev_rcl1WindowClip.yBottom ;is the text bottom in
        cmp     ulBottomScan,eax                       ; the current bank?
        jnle    short do_next_xpar_bank ;no, map in the next bank and draw

        cRet    vFastText               ;yes, so we're done

do_next_xpar_bank::
        mov     ulTopScan,eax
        sub     edi,[ebx].pdev_pvBitmapStart ;convert from address to offset
                                             ; within bitmap
        ptrCall <dword ptr [ebx].pdev_pfnBankControl>,<ebx,eax,JustifyTop>
                                             ;map in the bank (call preserves
                                             ; EBX, ESI, and EDI)
        add     edi,[ebx].pdev_pvBitmapStart ;convert from offset within bitmap
                                             ; to address (bitmap start just
                                             ; moved)
        jmp     xpar_bank_loop               ;we're ready to draw to the new
                                             ; bank

;-----------------------------------------------------------------------
; Routines to draw 0-4 pixels with the color in each byte of EAX, depending
; on the value of the nibble describing the four pixels to draw. "high_nibble"
; routines draw based on the upper nibble of the byte pointed to by ESI;
; "low_nibble" routines draw based on the lower nibble of that byte.
;
;  EAX = color with which to draw, repeated four times
;  EBX = zero (0)
;  ECX = the number of nibble pairs (source bytes = pixels*8) to draw
;  EDX = not used (preserved)
;  ESI = pointer to first nibble pair to draw
;  EDI = pointer to first destination byte to which to draw
;
; Must always be entered on the high nibble and extended for an even number of
;  nibbles.

;-----------------------------------------------------------------------
; Macro to draw the four pixels represented by the high nibble of the byte at
; [ESI].

DO_HIGH_NIBBLE macro
        inc     esi             ;point to the next glyph byte
        add     edi,8           ;point to the next destination 8-pixel set
        dec     ecx             ;count down nibble pairs (8-pixel sets)
        jz      xpar_scan_done  ;done with this scan
        mov     bl,[esi]        ;not done; get next glyph byte
        and     bl,bl           ;are all 8 pixels transparent?
        jz      xpar_low_nibble_0 ;yes, just skip everything in this byte
        shr     bl,4            ;shift the high nibble into the low nibble
        jmp     xpar_high_nibble_table[ebx*4] ;branch to draw up to four pixels
        endm

;-----------------------------------------------------------------------
; Macro to draw the four pixels represented by the low nibble of the byte at
; [ESI].

DO_LOW_NIBBLE macro
        mov     bl,[esi]        ;get glyph byte again, for the low nibble this
                                ; time
        and     ebx,0fh         ;isolate the low nibble
        jmp     xpar_low_nibble_table[ebx*4] ;branch to draw up to four pixels
        endm

;-----------------------------------------------------------------------

xpar_high_nibble_F::
        mov     [edi],eax
xpar_high_nibble_0::
        DO_LOW_NIBBLE

xpar_high_nibble_E::
        mov     [edi],ax
        mov     [edi+2],al
        DO_LOW_NIBBLE

xpar_high_nibble_D::
        mov     [edi],ax
        mov     [edi+3],al
        DO_LOW_NIBBLE

xpar_high_nibble_C::
        mov     [edi],ax
        DO_LOW_NIBBLE

xpar_high_nibble_B::
        mov     [edi],al
        mov     [edi+2],ax
        DO_LOW_NIBBLE

xpar_high_nibble_8::
        mov     [edi],al
        DO_LOW_NIBBLE

xpar_high_nibble_6::
        mov     [edi+1],ax
        DO_LOW_NIBBLE

xpar_high_nibble_5::
        mov     [edi+1],al
        mov     [edi+3],al
        DO_LOW_NIBBLE

xpar_high_nibble_4::
        mov     [edi+1],al
        DO_LOW_NIBBLE

xpar_high_nibble_7::
        mov     [edi+1],al
xpar_high_nibble_3::
        mov     [edi+2],ax
        DO_LOW_NIBBLE

xpar_high_nibble_A::
        mov     [edi],al
xpar_high_nibble_2::
        mov     [edi+2],al
        DO_LOW_NIBBLE

xpar_high_nibble_9::
        mov     [edi],al
xpar_high_nibble_1::
        mov     [edi+3],al
        DO_LOW_NIBBLE


xpar_low_nibble_0::
        DO_HIGH_NIBBLE

xpar_low_nibble_F::
        mov     [edi+4],eax
        DO_HIGH_NIBBLE

xpar_low_nibble_E::
        mov     [edi+4],ax
        mov     [edi+6],al
        DO_HIGH_NIBBLE

xpar_low_nibble_D::
        mov     [edi+4],ax
        mov     [edi+7],al
        DO_HIGH_NIBBLE

xpar_low_nibble_C::
        mov     [edi+4],ax
        DO_HIGH_NIBBLE

xpar_low_nibble_B::
        mov     [edi+4],al
        mov     [edi+6],ax
        DO_HIGH_NIBBLE

xpar_low_nibble_8::
        mov     [edi+4],al
        DO_HIGH_NIBBLE

xpar_low_nibble_6::
        mov     [edi+5],ax
        DO_HIGH_NIBBLE

xpar_low_nibble_5::
        mov     [edi+5],al
        mov     [edi+7],al
        DO_HIGH_NIBBLE

xpar_low_nibble_4::
        mov     [edi+5],al
        DO_HIGH_NIBBLE

xpar_low_nibble_7::
        mov     [edi+5],al
xpar_low_nibble_3::
        mov     [edi+6],ax
        DO_HIGH_NIBBLE

xpar_low_nibble_A::
        mov     [edi+4],al
xpar_low_nibble_2::
        mov     [edi+6],al
        DO_HIGH_NIBBLE

xpar_low_nibble_9::
        mov     [edi+4],al
xpar_low_nibble_1::
        mov     [edi+7],al
        DO_HIGH_NIBBLE


;-----------------------------------------------------------------------;
; Opaque text.
;-----------------------------------------------------------------------;

opaque_text::

;-----------------------------------------------------------------------;
; Calculate drawing parameters.
;-----------------------------------------------------------------------;

        mov     ebx,ppdev
        mov     esi,prclText            ;point to bounding rectangle for text

        mov     eax,[ebx].pdev_lPlanarNextScan  ;set the screen width in
        mov     ulScreenDelta,eax               ; quadpixels

        sub     eax,eax                 ;assume clipped edge bytes won't need
        mov     ulLeftEdgeShift,eax     ; to be shifted into position
        mov     ulRightEdgeShift,eax

        mov     eax,[esi].xRight
        mov     ebx,eax
        and     ebx,11b                         ;dest right edge % 4
        mov     edx,[esi].xLeft
        mov     ulTextLeft,edx                  ;remember dest left edge
        mov     cl,jOpaqueRightMasks[ebx]       ;set right edge clip mask
        mov     ebx,edx
        and     ebx,11b                         ;dest left edge % 4
        mov     ulRightMask,ecx
        mov     cl,jOpaqueLeftMasks[ebx]        ;set left edge clip mask
        mov     ulLeftMask,ecx

        and     edx,not 7       ;left edge, rounded down to nearest byte
        dec     eax             ;right edge - 1
        sub     eax,edx
        shr     eax,3           ;width of the text in the temp buffer in bytes,
                                ; rounded up, minus 1. This is used to point to
                                ; the partial right edge, if there is one
        mov     ulTextWidthInBytesMinus1,eax

;-----------------------------------------------------------------------;
; Figure out what edges we need to handle, and calculate some info for
; doing whole bytes.
;-----------------------------------------------------------------------;

        mov     edx,[esi].xLeft
        mov     eax,[esi].xRight
        and     edx,not 3
        add     eax,3
        sub     eax,edx
        shr     eax,2           ;width of the text in the temp buffer in
                                ; quadpixels, rounded up (counting all whole
                                ; and partial quadpixels)
        cmp     eax,1           ;only one quadpixels total?
        jnz     short @F        ;no
                                ;yes, special case a single quadpixel
        mov     ecx,offset opaq_check_more_banks  ;assume it's a solid
                                                  ; quadpixel
        mov     ebx,ulLeftMask
        and     ebx,ulRightMask
        cmp     bl,0ffh                 ;solid quadpixel?
        jz      short opaq_set_deltas_and_edge_vector ;yes, all set
        mov     ulLeftMask,ebx          ;no, draw as a left edge
        dec     eax                     ;there are no whole quadpixels
        mov     ecx,offset opaq_draw_left_edge_only
        test    [esi].xLeft,100b        ;is partial quadpixel in bits 0-3?
        jnz     opaq_set_edge_vector    ;yes, no shift required, already set
        mov     ulLeftEdgeShift,4       ;no, must shift right 4 to get into
                                        ; bits 0-3
        jmp     short opaq_set_edge_vector ;yes, all set

@@:
        lea     edx,[eax-1]
        mov     ulVGAWidthInBytesMinus1,edx ;offset from leftmost VGA dest byte
                                            ; to rightmost

        test    [esi].xLeft,11b            ;is left edge a solid quadpixel?
        jz      short opaq_left_edge_solid ;yes
        dec     eax                        ;one less whole quadpixel
        mov     ecx,offset opaq_draw_left_edge_only ;assume right edge is solid
        test    [esi].xLeft,100b           ;is partial quadpixel in bits 0-3?
        jnz     short @F                   ;yes, no shift required, already set
        mov     ulLeftEdgeShift,4          ;no, must shift right 4 to get into
                                           ; bits 0-3
@@:
        test    [esi].xRight,11b           ;is right edge a solid quadpixel?
        jz      short opaq_set_deltas_and_edge_vector ;yes, all set
        dec     eax                        ;one less whole quadpixel
        mov     ecx,offset opaq_draw_both_edges ;both edges are non-solid
        jmp     short opaq_set_right_edge_shift

opaq_left_edge_solid::
        mov     ecx,offset opaq_check_more_banks  ;assume right edge is solid
        test    [esi].xRight,11b           ;is right edge a solid quadpixel?
        jz      short opaq_set_deltas_and_edge_vector ;yes, all set
        dec     eax                        ;one less whole quadpixel
        mov     ecx,offset opaq_draw_right_edge_only ;no, do non-solid right
                                                     ; edge
opaq_set_right_edge_shift:
        test    [esi].xRight,100b       ;is partial quadpixel in bits 0-3?
        jnz     short opaq_set_deltas_and_edge_vector
                                        ;yes, no shift required, already set
        mov     ulRightEdgeShift,4      ;no, must shift right 4 to get into
                                        ; bits 0-3

; At this point, EAX = # of whole quadpixels across source = # of whole bytes
; (addresses) across destination

opaq_set_deltas_and_edge_vector:
        mov     edi,ulScreenDelta
        sub     edi,eax         ;whole bytes offset to next scan in screen
                                ; (there are four pixels--one quadpixel--
                                ; at each VGA address)
        mov     ulTmpDstDelta,edi

        mov     edx,[esi].xLeft
        mov     edi,[esi].xRight
        add     edx,3
        and     edx,not 7
        add     edi,4
        sub     edi,edx
        shr     edi,3           ;width of the text in the temp buffer in bytes,
                                ; counting bytes containing whole quadpixels
                                ; but not bytes containing only partial
                                ; quadpixels. (Remember, text bytes map to
                                ; quadpixel pairs; text nibbles map to
                                ; quadpixels)
        sub     edi,ulBufDelta
        neg     edi
        mov     ulTmpSrcDelta,edi ;offset to next scan in source buffer when
                                  ; doing whole quadpixels
opaq_set_edge_vector::
        mov     pfnEdgeVector,ecx       ;save address of partial-quadpixel-
                                        ; drawing code, or end of loop if no
                                        ; partial edge
        mov     edx,eax                 ;# of whole quadpixels
        mov     pfnFirstOpaqVector,offset opaq_whole_quadpixels
                                        ;assume there are whole quadpixels
                                        ; to copy, in which case we'll draw
                                        ; them first, then the partial edge
                                        ; quadpixels
        sub     edi,edi
        shr     edx,1                   ;# of quadpixels / 2
        mov     ulWholeWidthInQuadpixelPairs,edx ;# of quadpixel pairs to copy
        adc     edi,edi                 ;odd quadpixel status
        mov     ulOddQuadpixel,edi      ;1 if there is an odd quadpixel, 0 else
        dec     edx
        mov     ulWholeWidthInQuadpixelPairsMinus1,edx
                                        ;# of whole quadpixel pairs to copy,
                                        ; minus 1 (for case with both leading
                                        ; and trailing quadpixels)
        cmp     eax,0                   ;are there any whole quadpixels at all?
        jg      short @F                ;yes, we're all set
                                        ;no, set up for edge(s) only
        mov     pfnFirstOpaqVector,ecx  ;the edges are first and only, because
                                        ; there are no whole quadpixels
@@:

;-----------------------------------------------------------------------;
; Determine the screen offset of the first destination byte.
;-----------------------------------------------------------------------;

        mov     ebx,ppdev
        mov     eax,ulTopScan
        mov     ecx,eax
        mul     ulScreenDelta
        mov     edi,[esi].xLeft
        shr     edi,2           ;left edge screen offset in quadpixels
        add     edi,eax

;-----------------------------------------------------------------------;
; Map in the bank containing the top scan of the text, if it's not
; mapped in already.
;-----------------------------------------------------------------------;

        cmp     ecx,[ebx].pdev_rcl1PlanarClip.yTop ;is text top less than
                                                   ; current bank?
        jl      short opaq_map_init_bank           ;yes, map in proper bank
        cmp     ecx,[ebx].pdev_rcl1PlanarClip.yBottom ;text top greater than
                                                      ; current bank?
        jl      short opaq_init_bank_mapped     ;no, proper bank already mapped
opaq_map_init_bank::

; Map in the bank containing the top scan line of the fill.
; Preserves EBX, ESI, and EDI.

        ptrCall <dword ptr [ebx].pdev_pfnPlanarControl>,<ebx,ecx,JustifyTop>

opaq_init_bank_mapped::

        add     edi,[ebx].pdev_pvBitmapStart    ;initial destination address

;-----------------------------------------------------------------------;
; Load the latches with the background color.
;-----------------------------------------------------------------------;

        sub     eax,eax
        mov     edx,[esi].xLeft
        and     edx,011b
        cmp     eax,edx                 ;is the first quadpixel a full
                                        ; quadpixel?
        adc     eax,eax                 ;if so, EAX = 1, else EAX = 0
        mov     edx,iBgColor
        mov     [edi+eax],dl            ;write the bg color to the first full
                                        ; quadpixel, in each of the four planes
        mov     dl,[edi+eax]            ;read back the quadpixel to load the
                                        ; latches with the bg color

;-----------------------------------------------------------------------;
; Set up the VGA's hardware for read mode 0 and write mode 2, the ALUs
; for XOR, and the Bit Mask to 1 for bits that differ between the fg and
; bg, 0 for bits that are the same.
;-----------------------------------------------------------------------;

        mov     edx,VGA_BASE + GRAF_ADDR
        mov     ah,byte ptr [ebx].pdev_ulrm0_wmX[2]
                                        ;write mode 2 setting for Graphics Mode
        mov     al,GRAF_MODE
        out     dx,ax                   ;write mode 2 to expand glyph bits to
                                        ; 0 or 0ffh per plane
        mov     eax,GRAF_DATA_ROT + (DR_XOR SHL 8)
        out     dx,ax                   ;XOR to flip latched data to make ~bg

        mov     ah,byte ptr iBgColor
        xor     ah,byte ptr iFgColor
        mov     al,GRAF_BIT_MASK
        out     dx,ax                   ;pass through common fg & bg bits
                                        ; unchanged from bg color in latches;
                                        ; non-common bits come from XOR in the
                                        ; ALUs, flipped from the bg to the fg
                                        ; state if the glyph bit for the pixel
                                        ; in that plane is 1, still in bg state
                                        ; if the glyph bit for that plane is 0

;-----------------------------------------------------------------------;
; Main loop for processing fill in each bank.
;
; At start of loop and on each loop, EBX->ppdev and EDI->first destination
; byte.
;-----------------------------------------------------------------------;

opaq_bank_loop::
        mov     pScreen,edi             ;remember initial copy destination

        mov     edx,ulBottomScan        ;bottom of destination rectangle
        cmp     edx,[ebx].pdev_rcl1PlanarClip.yBottom
                                        ;which comes first, the bottom of the
                                        ; text rect or the bottom of the
                                        ; current bank?
        jl      short @F                ;text bottom comes first, so draw to
                                        ; that; this is the last bank in text
        mov     edx,[ebx].pdev_rcl1PlanarClip.yBottom
                                        ;bank bottom comes first; draw to
                                        ; bottom of bank
@@:
        sub     edx,ulTopScan           ;# of scans to draw in bank
        mov     ulNumScans,edx
        jmp     pfnFirstOpaqVector      ;do first sort of drawing (whole
                                        ; bytes, or edge(s) if no whole
                                        ; bytes)

;-----------------------------------------------------------------------;
; Draw the whole quadpixels, handling as many as possible paired into
; bytes so we can draw 8 pixels at a time.
;
; On entry:
;       EDI = first destination byte
;-----------------------------------------------------------------------;
opaq_whole_quadpixels::
        mov     esi,pTempBuffer         ;point to first source byte
        mov     eax,ulTextLeft          ;left edge
        test    eax,011b                ;is there a partial (masked) edge?
        jz      short @f                ;no, start addresses are correct
        inc     edi                     ;yes, skip over one dest byte for the
                                        ; four pixels in the partial edge
        test    eax,100b                ;do we have a partial left edge in the
                                        ; second quadpixel?
        jz      short @f                ;no, source start address is correct
        inc     esi                     ;yes, skip over a source byte because
                                        ; the partial edge is all that's in
                                        ; this byte
@@:
        mov     ebx,pGlyphFlipTable     ;point to the look-up table we'll use
                                        ; to flip the glyph bits into the form
                                        ; required by planar mode
        mov     edx,ulNumScans          ;# of scans to draw

                                        ;decide which copy loop to use, based
                                        ; on the word-alignment of the dest
                                        ; rectangle with the screen
                                        ;the following tests rely on VGA even
                                        ; addresses being aligned to the start
                                        ; of corresponding source buffer bytes
                                        ; (4-pixel sets at even VGA addresses
                                        ; match up to the upper quadpixels of
                                        ; source buffer bytes)
        test    edi,1                   ;is dest word-aligned?
        jnz     short opaq_need_leading ;no, need leading quadpixel
                                        ;yes, no leading quadpixel
        cmp     ulOddQuadpixel,1        ;odd width in quadpixels?
        jnz     short opaq_scan_loop    ;no, no trailing quadpixel
        jmp     opaq_scan_loop_t        ;yes, trailing quadpixel

opaq_need_leading:                      ;there's a leading quadpixel
        cmp     ulOddQuadpixel,1        ;odd width in quadpixels?
        jnz     opaq_scan_loop_lt       ;no, trailing quadpixel
        jmp     opaq_scan_loop_l        ;yes, no trailing quadpixel


;-----------------------------------------------------------------------;
; Loops for copying whole quadpixels to the screen, as much as possible a
; quadpixel pair at a time.
; On entry:
;       EBX = pointer to flip table
;       EDX = # of scans to draw
;       ESI = pointer to first buffer byte from which to copy
;       EDI = pointer to first screen byte to which to copy
;       ulTmpSrcDelta = offset to next buffer scan
;       ulTmpDstDelta = offset to next destination (VGA) scan
;       ulWholeWidthInQuadpixelPairs = # of whole bytes to copy
;       ulWholeWidthInQuadpixelPairsMinus1 = # of whole bytes to copy, minus 1
; LATER could break out and optimize short runs, such as 1, 2, 3, 4 wide.
;-----------------------------------------------------------------------;

;-----------------------------------------------------------------------;
; Loop for doing whole opaque words: no leading quadpixel, no trailing
; quadpixel.
;-----------------------------------------------------------------------;
opaq_scan_loop::
opaq_sl_row_loop:
        mov     ecx,ulWholeWidthInQuadpixelPairs
opaq_sl_byte_loop:
        mov     bl,[esi]        ;get the next temp buffer byte
        mov     al,[ebx]        ;reverse the order of bits 0-3 and 4-7
        inc     esi             ;point to the next temp buffer byte
        mov     ah,al
        shr     al,4            ;first quadpixel to draw in AL, next in AH
        mov     [edi],ax        ;draw the glyph
        add     edi,2           ;point to the next destination address

        dec     ecx
        jnz     opaq_sl_byte_loop
opaq_sl_whole_done:
        add     esi,ulTmpSrcDelta ;point to next buffer scan
        add     edi,ulTmpDstDelta ;point to next screen scan
        dec     edx               ;count down scans
        jnz     opaq_sl_row_loop
        jmp     pfnEdgeVector     ;do the edge(s)


;-----------------------------------------------------------------------;
; Loop for doing whole opaque words: leading quadpixel, no trailing
; quadpixel.
;-----------------------------------------------------------------------;
opaq_scan_loop_l::
opaq_sll_row_loop:
        mov     bl,[esi]        ;get the first temp buffer byte
        inc     esi             ;point to the next temp buffer byte
        mov     al,[ebx]        ;reverse the order of bits 0-3
        mov     [edi],al        ;draw the first 4 pixels (the leading quadpixel)
        inc     edi             ;point to the next destination address

        mov     ecx,ulWholeWidthInQuadpixelPairs
        test    ecx,ecx         ;see if there's anything else to draw
        jz      short opaq_sll_whole_done
opaq_sll_byte_loop:
        mov     bl,[esi]        ;get the next temp buffer byte
        mov     al,[ebx]        ;reverse the order of bits 0-3 and 4-7
        inc     esi             ;point to the next temp buffer byte
        mov     ah,al
        shr     al,4            ;first quadpixel to draw in AL, next in AH
        mov     [edi],ax        ;draw the glyph
        add     edi,2           ;point to the next destination address

        dec     ecx
        jnz     opaq_sll_byte_loop
opaq_sll_whole_done:
        add     esi,ulTmpSrcDelta ;point to next buffer scan
        add     edi,ulTmpDstDelta ;point to next screen scan
        dec     edx             ;count down scans
        jnz     opaq_sll_row_loop
        jmp     pfnEdgeVector   ;do the edge(s)


;-----------------------------------------------------------------------;
; Loop for doing whole opaque words: leading byte, trailing byte.
;-----------------------------------------------------------------------;
opaq_scan_loop_lt::
opaq_sllt_row_loop:
        mov     bl,[esi]        ;get the first temp buffer byte
        inc     esi             ;point to the next temp buffer byte
        mov     al,[ebx]        ;reverse the order of bits 0-3
        mov     [edi],al        ;draw the first 4 pixels (the leading quadpixel)
        inc     edi             ;point to the next destination address

        mov     ecx,ulWholeWidthInQuadpixelPairsMinus1
        test    ecx,ecx         ;see if there's anything else to draw
        jz      short opaq_sllt_whole_done
opaq_sllt_byte_loop:
        mov     bl,[esi]        ;get the next temp buffer byte
        mov     al,[ebx]        ;reverse the order of bits 0-3 and 4-7
        inc     esi             ;point to the next temp buffer byte
        mov     ah,al
        shr     al,4            ;first quadpixel to draw in AL, next in AH
        mov     [edi],ax        ;draw the glyph
        add     edi,2           ;point to the next destination address

        dec     ecx
        jnz     opaq_sllt_byte_loop
opaq_sllt_whole_done:
        mov     bl,[esi]        ;get the last temp buffer byte
        inc     esi             ;point to the next temp buffer byte
        mov     al,[ebx]        ;reverse the order of bits 4-7
        shr     eax,4           ;put the quadpixel in bits 0-3
        mov     [edi],al        ;draw the last 4 pixels (the trailing quadpixel)
        inc     edi             ;point to the next destination address

        add     esi,ulTmpSrcDelta ;point to next buffer scan
        add     edi,ulTmpDstDelta ;point to next screen scan
        dec     edx             ;count down scans
        jnz     opaq_sllt_row_loop
        jmp     pfnEdgeVector   ;do the edge(s)

;-----------------------------------------------------------------------;
; Loop for doing whole opaque words: no leading byte, trailing byte.
;-----------------------------------------------------------------------;
opaq_scan_loop_t::
opaq_slt_row_loop:
        mov     ecx,ulWholeWidthInQuadpixelPairs
        test    ecx,ecx         ;see if there's anything else to draw
        jz      short opaq_slt_whole_done
opaq_slt_byte_loop:
        mov     bl,[esi]        ;get the next temp buffer byte
        mov     al,[ebx]        ;reverse the order of bits 0-3 and 4-7
        inc     esi             ;point to the next temp buffer byte
        mov     ah,al
        shr     al,4            ;first quadpixel to draw in AL, next in AH
        mov     [edi],ax        ;draw the glyph
        add     edi,2           ;point to the next destination address

        dec     ecx
        jnz     opaq_slt_byte_loop
opaq_slt_whole_done:
        mov     bl,[esi]        ;get the last temp buffer byte
        inc     esi             ;point to the next temp buffer byte
        mov     al,[ebx]        ;reverse the order of bits 4-7
        shr     eax,4           ;put the quadpixel in bits 0-3
        mov     [edi],al        ;draw the last 4 pixels (the trailing quadpixel)
        inc     edi             ;point to the next destination address

        add     esi,ulTmpSrcDelta ;point to next buffer scan
        add     edi,ulTmpDstDelta ;point to next screen scan
        dec     edx             ;count down scans
        jnz     opaq_slt_row_loop
        jmp     pfnEdgeVector   ;do the edge(s)

;-----------------------------------------------------------------------;
; Draw a partial left edge.
;-----------------------------------------------------------------------;
opaq_draw_left_edge_only::

        push    offset opaq_edges_done  ;return here when done with edge

opaq_draw_left_edge_only_entry::
        mov     esi,pTempBuffer         ;source start
        mov     edi,pScreen             ;destination (VGA) start
        mov     ecx,ulLeftEdgeShift     ;CL=amount by which to shift byte to
                                        ; right-justify desired quadpixel (0 or
                                        ; 4)
        mov     eax,ulLeftMask          ;clip mask for edge

; Enter here to copy a partial edge, with the Map Mask set to clip, ESI
; pointing to the first source byte to copy, EDI pointing to the first dest
; byte to copy to, CL the amount by which to right-shift to get the quadpixel
; of interest into bits 0-3, and AL the Map Mask setting to clip the edge

opaq_draw_edge_entry:
        push    ebp                     ;preserve stack frame pointer

        mov     edx,VGA_BASE + SEQ_DATA ;SEQ_INDEX already points to Map Mask
        out     dx,al                   ;set Map Mask for left edge

        mov     edx,ulScreenDelta       ;width of a screen scan in addresses
        mov     eax,ulNumScans          ;height of text
        mov     ebx,pGlyphFlipTable     ;point to the look-up table we'll use
                                        ; to flip the glyph bits into the form
                                        ; required by planar mode
        mov     ebp,ulBufDelta          ;width of a source scan in bytes
                                        ;***stack frame unavailable***
opaq_edge_loop::
        mov     bl,[esi]        ;get the next text buffer byte
        shr     bl,cl           ;move the desired quadpixel into bits 0-3
        add     esi,ebp         ;point to the next destination byte
        mov     bl,[ebx]        ;reverse the order of bits 0-3
        mov     [edi],bl        ;draw up to four pixels, with the Map Mask
                                ; clipping, if necessary
        add     edi,edx         ;point to the next destination byte

        dec     eax
        jnz     opaq_edge_loop

        pop     ebp             ;restore stack frame pointer
                                ;***stack frame available***
        retn

;-----------------------------------------------------------------------;
; Draw a partial right edge only. Once we've set up the pointers, this
; is done with exactly the same code as the left edge.
;-----------------------------------------------------------------------;
opaq_draw_right_edge_only::
        push    offset opaq_edges_done  ;return here when done with edge

opaq_draw_right_edge_only_entry::
        mov     esi,ulTextWidthInBytesMinus1
        add     esi,pTempBuffer         ;point to right edge start in buffer
        mov     edi,ulVGAWidthInBytesMinus1
        add     edi,pScreen             ;point to right edge start in screen
        mov     ecx,ulRightEdgeShift    ;CL=amount by which to shift byte to
                                        ; right-justify desired quadpixel (0 or
                                        ; 4)
        mov     eax,ulRightMask         ;clip mask for edge

        jmp     opaq_draw_edge_entry

;-----------------------------------------------------------------------;
; Draw both left and right partial  edges. We do this by calling first
; the left and then the right edge drawing code.
;-----------------------------------------------------------------------;
opaq_draw_both_edges::
        call    opaq_draw_left_edge_only_entry
        call    opaq_draw_right_edge_only_entry

;-----------------------------------------------------------------------;
; Restore Map Mask to enable all planes, now that we're done drawing
; partial edges.
;-----------------------------------------------------------------------;

opaq_edges_done:
        mov     al,MM_ALL
        mov     edx,VGA_BASE + SEQ_DATA ;SEQ_INDEX already points to Map Mask
        out     dx,al                   ;set Map Mask for left edge

;-----------------------------------------------------------------------;
; See if there are more banks to draw.
;-----------------------------------------------------------------------;

opaq_check_more_banks::
        mov     ebx,ppdev
        mov     eax,[ebx].pdev_rcl1PlanarClip.yBottom ;is the text bottom in
        cmp     ulBottomScan,eax                       ; the current bank?
        jnle    short opaq_do_next_bank ;no, do the next bank
                                        ;yes, so we're done

;-----------------------------------------------------------------------;
; Restore the VGA's hardware to the default state.
; The Graphics Controller Index still points to the Bit Mask at this
; point.
;-----------------------------------------------------------------------;

        mov     edx,VGA_BASE + GRAF_DATA
        mov     al,0ffh
        out     dx,al                   ;enable all bits through the Bit Mask

        mov     esi,ppdev
        dec     edx                     ;point back to the Graphics Index reg
        mov     ah,byte ptr [esi].pdev_ulrm0_wmX[0]
                                        ;write mode 0 setting for Graphics Mode
        mov     al,GRAF_MODE
        out     dx,ax                   ;write mode 0, read mode 0

        mov     eax,GRAF_DATA_ROT + (DR_SET SHL 8)
        out     dx,ax                   ;replace mode, no rotate

        cRet    vFastText


opaq_do_next_bank::
        mov     esi,prclText
        mov     ulTopScan,eax           ;this will be the top of the next bank
        mov     ecx,eax
        mul     ulScreenDelta
        mov     edi,[esi].xLeft
        shr     edi,2                   ;convert from pixels to quadpixels
        add     edi,eax                 ;next screen byte to which to copy

        ptrCall <dword ptr [ebx].pdev_pfnPlanarControl>,<ebx,ecx,JustifyTop>
                                        ;map in the bank (call preserves EBX,
                                        ; ESI, and EDI)

        add     edi,[ebx].pdev_pvBitmapStart    ;initial destination address

        mov     eax,ulBufDelta
        mul     ulNumScans
        add     pTempBuffer,eax         ;advance to next temp buffer scan to
                                        ; copy

        jmp     opaq_bank_loop          ;we're ready to draw in the new bank

;-----------------------------------------------------------------------;
; Special 8-wide aligned opaque drawing code. Loads the latches with the
; background color, sets the Bit Mask to 1 for bits that differ between
; the foreground and background, sets the ALUs to XOR, then uses write
; mode 3 to draw the glyphs. Joyously, there are no partial bytes to
; worry about, so we can really crank up the code.
;
; On entry:
;       EBX = prclText
;-----------------------------------------------------------------------;
special_8_wide_aligned_opaque::

        mov     esi,ppdev
        mov     edi,[ebx].yBottom
        mov     eax,[ebx].yTop
        sub     edi,eax                 ;height of glyphs

;-----------------------------------------------------------------------;
; Map in the bank containing the top scan of the text, if it's not
; mapped in already.
;-----------------------------------------------------------------------;

        cmp     eax,[esi].pdev_rcl1PlanarClip.yTop ;is text top less than
                                                    ; current bank?
        jl      short s8wao_map_init_bank           ;yes, map in proper bank
        cmp     eax,[esi].pdev_rcl1PlanarClip.yBottom ;text top greater than
                                                       ; current bank?
        jl      short s8wa0_init_bank_mapped   ;no, proper bank already mapped
s8wao_map_init_bank::

; Map in the bank containing the top scan line of the text, making sure we're
; in planar mode at the same time.
; Preserves EBX, ESI, and EDI.

        ptrCall <dword ptr [esi].pdev_pfnPlanarControl>,<esi,eax,JustifyTop>

s8wa0_init_bank_mapped::

;-----------------------------------------------------------------------;
; We handle only cases where the text lies entirely in one bank.
; LATER handle broken rasters and/or bank-spanning cases?
;-----------------------------------------------------------------------;

        mov     eax,[esi].pdev_rcl1PlanarClip.yBottom
        sub     eax,[ebx].yTop          ;maximum run in bank
        cmp     edi,eax                 ;does all the text fit in the bank?
        jg      general_handler         ;no, let general code handle it

;-----------------------------------------------------------------------;
; Set up variables.
;-----------------------------------------------------------------------;

        mov     ulScans,edi             ;# of scans

;-----------------------------------------------------------------------;
; Point to the first screen byte at which to draw.
;-----------------------------------------------------------------------;

        mov     eax,[ebx].yTop
        mul     [esi].pdev_lPlanarNextScan
        mov     edi,[ebx].xLeft
        shr     edi,2
        add     edi,eax                 ;next screen byte to which to copy
        add     edi,[esi].pdev_pvBitmapStart   ;initial destination address
        mov     pScreen,edi

;-----------------------------------------------------------------------;
; Load the latches with the background color.
;-----------------------------------------------------------------------;

        mov     eax,iBgColor
        mov     byte ptr [edi],al       ;write the bg color to the first byte
        mov     al,[edi]                ;read back the byte to load the
                                        ; latches with the bg color

;-----------------------------------------------------------------------;
; Set up the VGA's hardware for read mode 0 and write mode 2, the ALUs
; for XOR, and the Bit Mask to 1 for bits that differ between the fg and
; bg, 0 for bits that are the same.
;-----------------------------------------------------------------------;

        mov     edx,VGA_BASE + GRAF_ADDR
        mov     ah,byte ptr [esi].pdev_ulrm0_wmX[2]
                                        ;write mode 2 setting for Graphics Mode
        mov     al,GRAF_MODE
        out     dx,ax                   ;write mode 2 to expand glyph bits to
                                        ; 0 or 0ffh per plane
        mov     eax,GRAF_DATA_ROT + (DR_XOR SHL 8)
        out     dx,ax                   ;XOR to flip latched data to make ~bg

        mov     ah,byte ptr iBgColor
        xor     ah,byte ptr iFgColor
        mov     al,GRAF_BIT_MASK
        out     dx,ax                   ;pass through common fg & bg bits
                                        ; unchanged from bg color in latches;
                                        ; non-common bits come from XOR in the
                                        ; ALUs, flipped from the bg to the fg
                                        ; state if the glyph bit for the pixel
                                        ; in that plane is 1, still in bg state
                                        ; if the glyph bit for that plane is 0

;-----------------------------------------------------------------------;
; Set up the screen scan offset in EDX.
;-----------------------------------------------------------------------;

        mov     edx,[esi].pdev_lPlanarNextScan ;offset from one scan to next

        mov     ecx,ulGlyphCount

s8wao_glyph_loop:
        mov     ebx,pGlyphPos           ;point to the current glyph to draw
        add     pGlyphPos,(size GLYPHPOS) ;point to the next glyph
        mov     edi,pScreen             ;point to current glyph's screen
                                        ; location
        mov     esi,[ebx].gp_pgdf       ;point to current glyph def
        add     pScreen,2               ;point to the next glyph's screen
                                        ; location
        mov     ecx,ulScans             ;# of scans
        mov     esi,[esi].gdf_pgb       ;point to current glyph
        mov     ebx,pGlyphFlipTable     ;point to the look-up table we'll use
                                        ; to flip the glyph bits into the form
                                        ; required by planar mode
        add     esi,gb_aj               ;point to the current glyph's bits

s8wao_byte_loop::
        mov     bl,[esi]        ;get the next glyph byte
        inc     esi             ;point to the next glyph byte
        mov     al,[ebx]        ;reverse the order of bits 0-3 and 4-7
        mov     ah,al
        shr     al,4            ;first quadpixel to draw in AL, next in AH
        mov     [edi],ax        ;draw the glyph
        add     edi,edx         ;point to the next destination byte

        dec     ecx             ;count down glyph scans
        jnz     s8wao_byte_loop

        dec     ulGlyphCount    ;count down glyphs
        jnz     s8wao_glyph_loop

;-----------------------------------------------------------------------;
; Restore the VGA's hardware to the default state.
; The Graphics Controller Index still points to the Bit Mask at this
; point.
;-----------------------------------------------------------------------;

        mov     edx,VGA_BASE + GRAF_DATA
        mov     al,0ffh
        out     dx,al                   ;enable all bits through the Bit Mask

        mov     esi,ppdev
        dec     edx                     ;point back to the Graphics Index reg
        mov     ah,byte ptr [esi].pdev_ulrm0_wmX[0]
                                        ;write mode 0 setting for Graphics Mode
        mov     al,GRAF_MODE
        out     dx,ax                   ;write mode 0, read mode 0

        mov     eax,GRAF_DATA_ROT + (DR_SET SHL 8)
        out     dx,ax                   ;replace mode, no rotate

draw_prop_done::
        cRet    vFastText

endProc vFastText

;-----------------------------------------------------------------------;
; VOID vSetWriteModes(ULONG * pulWriteModes);
;
; Sets the four bytes at *pulWriteModes to the values to be written to
; the Graphics Mode register to select read mode 0 and:
;  write mode 0, write mode 1, write mode 2, and write mode 3,
; respectively.
;
; Must already be in graphics mode when this is called.
;-----------------------------------------------------------------------;

cProc vSetWriteModes,4,<   \
        pulWriteModes:ptr  >

        mov     edx,VGA_BASE + GRAF_ADDR
        mov     al,GRAF_MODE
        out     dx,al           ;point the GC Index to the Graphics Mode reg
        inc     edx             ;point to the GC Data reg
        in      al,dx           ;get the current setting of the Graphics Mode
        and     eax,0fch        ;mask off the write mode fields
        mov     ah,al
        mov     edx,eax
        shl     edx,16
        or      eax,edx         ;put the Graphics Mode setting in all 4 bytes
        mov     edx,pulWriteModes ;the mode values go here
        or      eax,03020100h   ;insert the write mode fields
        mov     [edx],eax       ;store the Graphics Mode settings

        cRet    vSetWriteModes

endProc vSetWriteModes

;-----------------------------------------------------------------------;
; VOID vClearMemDword(PULONG * pulBuffer, ULONG ulDwordCount);
;
; Clears ulCount dwords starting at pjBuffer.
;-----------------------------------------------------------------------;

pulBuffer    equ [esp+8]
ulDwordCount equ [esp+12]

cProc vClearMemDword,8,<>

        push    edi
        mov     edi,pulBuffer
        mov     ecx,ulDwordCount
        sub     eax,eax
        rep     stosd
        pop     edi

        cRet  vClearMemDword

endProc vClearMemDword

public general_handler
public draw_f_tb_no_to_temp_start
public draw_nf_tb_no_to_temp_start
public draw_to_temp_start_entry
public draw_f_ntb_o_to_temp_start
public draw_nf_ntb_o_to_temp_start
public draw_to_temp_start_entry2
public draw_f_tb_no_to_temp_loop
public draw_nf_tb_no_to_temp_loop
public draw_to_temp_loop_entry
public draw_f_ntb_o_to_temp_loop
public draw_nf_ntb_o_to_temp_loop
public draw_to_temp_loop_entry2
public or_all_1_wide_rotated_need_last
public or_all_1_wide_rotated_no_last
public or_first_1_wide_rotated_need_last
public or_first_1_wide_rotated_no_last
public or_first_1_wide_rotated_loop
public mov_first_1_wide_rotated_need_last
public mov_first_1_wide_rotated_no_last
public mov_first_1_wide_rotated_loop
public mov_first_1_wide_unrotated
public mov_first_1_wide_unrotated_loop
public or_all_1_wide_unrotated
public or_all_1_wide_unrotated_loop
public or_first_2_wide_rotated_need_last
public or_first_2_wide_rotated_need_loop
public or_all_2_wide_rotated_need_last
public or_all_2_wide_rotated_need_loop
public mov_first_2_wide_rotated_need_last
public mov_first_2_wide_rotated_need_loop
public or_first_2_wide_rotated_no_last
public or_first_2_wide_rotated_loop
public or_all_2_wide_rotated_no_last
public or_all_2_wide_rotated_loop
public mov_first_2_wide_rotated_no_last
public mov_first_2_wide_rotated_loop
public mov_first_2_wide_unrotated
public mov_first_2_wide_unrotated_loop
public or_all_2_wide_unrotated
public or_all_2_wide_unrotated_loop
public or_first_3_wide_rotated_need_last
public or_all_3_wide_rotated_need_last
public mov_first_3_wide_rotated_need_last
public or_first_3_wide_rotated_no_last
public or_all_3_wide_rotated_no_last
public mov_first_3_wide_rotated_no_last
public mov_first_3_wide_unrotated
public or_all_3_wide_unrotated
public or_first_4_wide_rotated_need_last
public or_all_4_wide_rotated_need_last
public mov_first_4_wide_rotated_need_last
public or_first_4_wide_rotated_no_last
public or_all_4_wide_rotated_no_last
public mov_first_4_wide_rotated_no_last
public mov_first_4_wide_unrotated
public or_all_4_wide_unrotated
public or_first_N_wide_rotated_need_last
public or_all_N_wide_rotated_need_last
public mov_first_N_wide_rotated_need_last
public or_first_N_wide_rotated_no_last
public or_all_N_wide_rotated_no_last
public mov_first_N_wide_rotated_no_last
public mov_first_N_wide_unrotated
public odd_width
public two_odd_bytes
public three_odd_bytes
public or_all_N_wide_unrotated
public or_no_odd_bytes_loop
public or_odd_width
public or_one_odd_bytes_loop
public or_two_odd_bytes
public or_two_odd_bytes_loop
public or_three_odd_bytes
public or_three_odd_bytes_loop
public draw_to_screen
public opaque_text
public opaq_left_edge_solid
public opaq_set_edge_vector
public opaq_map_init_bank
public opaq_init_bank_mapped
public opaq_bank_loop
public opaq_whole_quadpixels
public opaq_scan_loop
public opaq_scan_loop_l
public opaq_scan_loop_lt
public opaq_scan_loop_t
public opaq_draw_left_edge_only
public opaq_draw_left_edge_only_entry
public opaq_edge_loop
public opaq_draw_right_edge_only
public opaq_draw_right_edge_only_entry
public opaq_draw_both_edges
public opaq_check_more_banks
public opaq_do_next_bank
public special_8_wide_aligned_opaque
public s8wa0_init_bank_mapped
public s8wao_byte_loop
public s8wao_map_init_bank
public xpar_map_init_bank
public xpar_init_bank_mapped
public xpar_bank_loop
public xpar_scan_loop
public xpar_scan_done
public do_next_xpar_bank
public xpar_high_nibble_F
public xpar_high_nibble_E
public xpar_high_nibble_D
public xpar_high_nibble_C
public xpar_high_nibble_B
public xpar_high_nibble_8
public xpar_high_nibble_6
public xpar_high_nibble_5
public xpar_high_nibble_4
public xpar_high_nibble_7
public xpar_high_nibble_3
public xpar_high_nibble_A
public xpar_high_nibble_2
public xpar_high_nibble_9
public xpar_high_nibble_1
public xpar_high_nibble_0
public xpar_low_nibble_F
public xpar_low_nibble_E
public xpar_low_nibble_D
public xpar_low_nibble_C
public xpar_low_nibble_B
public xpar_low_nibble_8
public xpar_low_nibble_6
public xpar_low_nibble_5
public xpar_low_nibble_4
public xpar_low_nibble_7
public xpar_low_nibble_3
public xpar_low_nibble_A
public xpar_low_nibble_2
public xpar_low_nibble_9
public xpar_low_nibble_1
public xpar_low_nibble_0


        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\vga\disp\8bpp\i386\driver.inc ===
;---------------------------Module-Header------------------------------;
; Module Name: driver.inc
;
; Contains prototypes for the 256 colour VGA driver.
;
; NOTE: Must mirror driver.h!
;
; Copyright (c) 1992 Microsoft Corporation
;-----------------------------------------------------------------------;

; Sizes assumed for 1-window and 2 RW-window banks.

BANK_SIZE_1_WINDOW      equ 10000h
BANK_SIZE_2RW_WINDOW    equ 8000h

; Specifies desired justification for requestion scan line within bank window

JustifyTop              equ 0
JustifyBottom           equ 1

; Specifies which window is to be mapped by two-window bank handler.

MapSourceBank           equ 0
MapDestBank             equ 1

;------------------------------------------------------------------------;

; Miscellaneous driver flags

DRIVER_PLANAR_CAPABLE       equ 1
DRIVER_OFFSCREEN_REFRESHED  equ 2
DRIVER_HAS_OFFSCREEN        equ 4

; Bank status flags

BANK_BROKEN_RASTER1     equ 1       ; If bank1 or read bank has broken raster
BANK_BROKEN_RASTER2     equ 2       ; If bank2 or write bank has broken raster
BANK_BROKEN_RASTERS     equ (BANK_BROKEN_RASTER1 + BANK_BROKEN_RASTER2)

;------------------------------------------------------------------------;
; Structures for maintaining a realized brush:

RBRUSH_BLACKWHITE       equ 001h    ; Black and white brush
RBRUSH_2COLOR           equ 002h    ; 2 color brush
RBRUSH_NCOLOR           equ 004h    ; n color brush
RBRUSH_4PELS_WIDE       equ 008h    ; Brush is 4xN

BRUSH_SIZE              equ 64      ; An 8x8 8bpp brush needs 64 bytes

RBRUSH struc
rb_fl                       dd  ?           ; Flags
rb_xBrush                   dd  ?           ; Realized brush's x brush origin
                                            ; Pattern in planar format
rb_ulFgColor                dd  ?           ; Foreground color for 2-color
rb_ulBkColor                dd  ?           ; Background color for 2-color
rb_cy                       dd  ?           ; Height of pattern
rb_cyLog2                   dd  ?           ; log2 of height
rb_iCache                   dd  ?           ; Cache entry index; 0 not valid
rb_aulPattern               dd  (BRUSH_SIZE / 4) dup (?)
RBRUSH ends

BRUSHCACHEENTRY struc
bce_prbVerifyRealization    dd  ?           ; For verifying cache entry valid
bce_yCache                  dd  ?           ; Scan where entry's bits live
bce_ulCache                 dd  ?           ; Planar (!) offset to cache entry
BRUSHCACHEENTRY ends

;------------------------------------------------------------------------;
; The Physical Device data structure.

PDEV struc
pdev_fl                     dd  ?   ; Driver flags
pdev_hDriver                dd  ?   ; Handle to \Device\Screen
pdev_hdevEng                dd  ?   ; Engine's handle to PDEV
pdev_hsurfEng               dd  ?   ; Engine's handle to surface
pdev_hsurfBm                dd  ?   ; Handle to the "punt" surface
pdev_pSurfObj               dd  ?   ; Pointer to the locked "punt" surface

pdev_hpalDefault            dd  ?   ; Handle to the default palette for device.

pdev_pjScreen               dd  ?   ; This is pointer to base screen address
pdev_cxScreen               dd  ?   ; Visible screen width
pdev_cyScreen               dd  ?   ; Visible screen height
pdev_ulMode                 dd  ?   ; Mode in which the mini-port driver is
pdev_lDeltaScreen           dd  ?   ; Distance from one scan to the next

pdev_flRed                  dd  ?   ; For bitfields device, Red Mask
pdev_flGreen                dd  ?   ; For bitfields device, Green Mask
pdev_flBlue                 dd  ?   ; For bitfields device, Blue Mask
pdev_cPaletteShift          dd  ?   ; Number of bits the palette must be shifted by
pdev_ulBitCount             dd  ?   ; # of bits per pel 8,16 are only supported

pdev_ulrm0_wmX              dd  ?   ; Values to set GC5 to to select read mode
                                    ;  0 together with write modes 0-3

pdev_pjGlyphFlipTableBase   dd  ?   ; Base allocated address for flip table;
                                    ;  the pointer we use is this pointer
                                    ;  rounded up to the nearest 256-byte
                                    ;  boundary
pdev_pjGlyphFlipTable       dd  ?   ; Pointer to table used to flip glyph bits
                                    ;  0-3 and 4-7

pdev_pPal                   dd  ?   ; If this is pal managed, this is the pal

; Off Screen Save Stuff:

pdev_hbmTmp                 dd  ?   ; Handle to temporary buffer
pdev_psoTmp                 dd  ?   ; Temporary surface

; DCI:

pdev_bSupportDCI            dd  ?   ; Does miniport support DCI?

; Brush cache:

pdev_iCache                 dd  ?   ; Index for last brush to be allocated
pdev_iCacheLast             dd  ?   ; Last valid cache index
pdev_pbceCache              dd  ?   ; Pointer to allocated cache

; Saved screen bits stuff
pdev_rclSavedBitsRight      dd  ?,?,?,? ; right rect of vga memory that's unused
pdev_rclSavedBitsBottom     dd  ?,?,?,? ; bottom rect of vga memory that's unused
pdev_bBitsSaved             dd  ?   ; TRUE if bits are currently saved

; Bank manager stuff common between planar and non-planar modes:

pdev_cTotalScans            dd  ?   ; Number of usable on & off screen scans
pdev_pBankInfo              dd  ?   ; Bank info for current mode
pdev_flBank                 dd  ?   ; Flags for current bank state
pdev_ulBitmapSize           dd  ?   ; Length of bitmap if there were no
                                    ;  banking, in CPU addressable bytes

pdev_ulWindowBank           dd  ?,? ; Current banks mapped into windows
                                    ;  0 & 1 (used in 2 window mode only)

pdev_pvBitmapStart          dd  ?   ; Single-window bitmap start pointer
                                    ;  (adjusted as necessary to make
                                    ;  window map in at proper offset)
pdev_pvBitmapStart2Window   dd  ?,? ; Double-window window 0 and 1 bitmap
                                    ; start

; Non-planar mode specific bank management control stuff:

pdev_vbtBankingType         dd  ?   ; Type of banking
pdev_pfnBankSwitchCode      dd  ?   ; Pointer to bank switch code
pdev_lNextScan              dd  ?   ; Offset to next bank in bytes
pdev_pjJustifyTopBank       dd  ?   ; Pointer to lookup table for
                                    ;  converting scans to banks
pdev_pbiBankInfo            dd  ?   ; Pointer to array of bank clip info
pdev_ulJustifyBottomOffset  dd  ?   ; Number of scans from top to bottom
                                    ;  of bank, for bottom justifying
pdev_iLastBank              dd  ?   ; Index of last valid bank in
pdev_ulBank2RWSkip          dd  ?   ; Offset from one bank index to next
                                    ;  to make two 32K banks appear to be
                                    ;  one seamless 64K bank

pdev_pfnBankControl         dd  ?   ; Pointer to bank control function
pdev_pfnBankControl2Window  dd  ?   ; Pointer to double-window bank
                                    ;  control function

pdev_pfnBankNext            dd  ?   ; Pointer to next bank function
pdev_pfnBankNext2Window     dd  ?   ; Pointer to double-window next bank
                                    ;  function
pdev_rcl1WindowClip         db  (size RECTL) dup (?)
                                    ; Single-window banking clip rect
pdev_rcl2WindowClip         db  (2*(size RECTL)) dup (?)
                                    ; Double-window banking clip rects for
                                    ;  windows 0 & 1

; Planar mode specific bank management control stuff:

pdev_vbtPlanarType          dd  ?   ; Type of planar banking
pdev_pfnPlanarSwitchCode    dd  ?   ; Pointer to planar bank switch code
pdev_lPlanarNextScan        dd  ?   ; Offset to next planar bank in bytes
pdev_pjJustifyTopPlanar     dd  ?   ; Pointer to lookup table for
                                    ;  converting scans to planar banks
pdev_pbiPlanarInfo          dd  ?   ; Pointer to array of bank clip info
pdev_ulPlanarBottomOffset   dd  ?   ; Number of scans from top to bottom
                                    ;  of bank, for bottom justifying
pdev_iLastPlanar            dd  ?   ; Index of last valid bank in
pdev_ulPlanar2RWSkip        dd  ?   ; Offset from one bank index to next
                                    ;  to make two 32K banks appear to be
                                    ;  one seamless 64K bank

pdev_pfnPlanarControl       dd  ?   ; Pointer to bank control function
pdev_pfnPlanarControl2      dd  ?   ; Pointer to double-window bank
                                    ;  control function

pdev_pfnPlanarNext          dd  ?   ; Pointer to next bank function
pdev_pfnPlanarNext2         dd  ?   ; Pointer to double-window next bank
                                    ;  function
pdev_rcl1PlanarClip         db  (size RECTL) dup (?)
                                    ; Single-window banking clip rect
pdev_rcl2PlanarClip         db  (2*(size RECTL)) dup (?)
                                    ; Double-window banking clip rects for

pdev_pfnPlanarEnable        dd  ?   ; Function to enable planar mode
pdev_pfnPlanarDisable       dd  ?   ; Function to disable planar mode

; Smart bank management stuff:

pdev_iLastScan              dd  ?   ; Last scan we want to enumerate
pdev_pvScanScan0            dd  ?   ; Surface's original pvScan0
pdev_rclSaveBounds          db  (size RECTL) dup (?)
                                    ; Clip object's original bounds
pdev_pcoNull                dd  ?   ; Pointer to empty clip object
pdev_iSaveDComplexity       db  ?   ; Clip object's original complexity
pdev_fjSaveOptions          db  ?   ; Clip object's original flags
pdev_ajFiller               db  ?,? ; Pack to dword alignment

pdev_pvTmpBuf               dd  ?   ; Ptr to buffer attached to pdev
PDEV ends

pdev_rcl2WindowClipS        equ     (pdev_rcl2WindowClip)
pdev_rcl2WindowClipD        equ     (pdev_rcl2WindowClip + (size RECTL))

pdev_rcl2PlanarClipS        equ     (pdev_rcl2PlanarClip)
pdev_rcl2PlanarClipD        equ     (pdev_rcl2PlanarClip + (size RECTL))

pdev_pvBitmapStart2WindowS  equ     (pdev_pvBitmapStart2Window)
pdev_pvBitmapStart2WindowD  equ     (pdev_pvBitmapStart2Window + dword)

;------------------------------------------------------------------------;

; Macro to do a simple RET, with no stack stuff, in a proc.

PLAIN_RET macro
        db      0c3h
        endm

; Macro to replace a CALL followed immediately by a JMP:

CALL_AND_JUMP macro CALL_ADDR,JUMP_ADDR
        push    offset JUMP_ADDR
        jmp     CALL_ADDR
        endm
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\vga\disp\8bpp\i386\lines.inc ===
;---------------------------- Include File Header ---------------------------;
; lines.inc
;
; Line drawing constants and structures.
;
; NOTE: This file mirrors LINES.H.  Changes here must be reflected in
; the .h file!
;
; See lines.h for a description of most defines.
;
;----------------------------------------------------------------------------;

STYLE_MAX_COUNT         equ 16
STYLE_MAX_VALUE         equ 3fffh
RUN_MAX                 equ 20
STRIP_MAX               equ 100
STYLE_DENSITY           equ 3

; For the ROP table:

MIX_XOR_OFFSET          equ 8

AND_ZERO                equ 0
AND_PEN                 equ 1
AND_NOTPEN              equ 2
AND_ONE                 equ 3

XOR_ZERO                equ (AND_ZERO   shl MIX_XOR_OFFSET)
XOR_PEN                 equ (AND_PEN    shl MIX_XOR_OFFSET)
XOR_NOTPEN              equ (AND_NOTPEN shl MIX_XOR_OFFSET)
XOR_ONE                 equ (AND_ONE    shl MIX_XOR_OFFSET)

;
; Flip and round flags:
;

FL_H_ROUND_DOWN         equ 00000080h   ; Set if x = 1/2 rounds to x = 1
FL_V_ROUND_DOWN         equ 00008000h   ; Set if y = 1/2 rounds to y = 1

FL_FLIP_D               equ 00000005h   ; Diagonal flip
FL_FLIP_V               equ 00000008h   ; Vertical flip
FL_FLIP_SLOPE_ONE       equ 00000010h   ; If slope is exactly one
FL_FLIP_HALF            equ 00000002h   ; Half flip
FL_FLIP_H               equ 00000200h   ; Horizontal (right-to-left) exchange

FL_ROUND_MASK           equ 0000001ch   ; Rounding is dependent on diagonal,
FL_ROUND_SHIFT          equ 2           ;  vertical flips and if slope is one

FL_RECTLCLIP_MASK       equ 0000000ch   ; When we unflip to do clipping, we
FL_RECTLCLIP_SHIFT      equ 2           ;  only have to look at diagonal and
                                        ;  vertical flips

FL_STRIP_MASK           equ 00000003h   ; Which strip drawer we call is based
FL_STRIP_SHIFT          equ 0           ;  on if we did diagonal and/or half
                                        ;  flips

FL_SIMPLE_CLIP          equ 00000020h   ; Denotes our clipping complexity
FL_COMPLEX_CLIP         equ 00000040h
FL_CLIP                 equ (FL_SIMPLE_CLIP + FL_COMPLEX_CLIP)

FL_SET                  equ 00000800h   ; If ROP is such that we don't have to
                                        ;  read video memory
FL_ARBITRARYSTYLED      equ 00000400h   ; If the line is styled
FL_STYLED               equ (FL_ARBITRARYSTYLED)

FL_STRIP_ARRAY_MASK     equ 00000C00h   ; Which strip arrays we look up depends
FL_STRIP_ARRAY_SHIFT    equ 10          ;  on if we're doing style and/or have
                                        ;  a 'set' style ROP

; Simple flag bits in high byte:

FL_DONT_DO_HALF_FLIP    equ 00002000h

; Miscellaneous DDA defines:

F                       equ 16
FLOG2                   equ 4

STRIPS struc

; Updated by strip drawers:

    ST_pjScreen         dd  ?
    ST_bIsGap           dd  ?

    ST_psp              dd  ?
    ST_spRemaining      dd  ?

; Not modified by strip drawers:

    ST_lNextScan        dd  ?
    ST_plStripEnd       dd  ?       ; usually won't be valid
    ST_flFlips          dd  ?
    ST_pspStart         dd  ?
    ST_pspEnd           dd  ?
    ST_xyDensity        dd  ?
    ST_chAndXor         dd  ?

; We leave room for a couple of extra dwords at the end of the strips
; array that can be used by the strip drawers:

    ST_alStrips	        dd  (STRIP_MAX + 2) dup (?)
STRIPS ends

LINESTATE struc
    LS_chAndXor         dd  ?
    LS_spTotal          dd  ?
    LS_spTotal2         dd  ?
    LS_spNext           dd  ?
    LS_spComplex        dd  ?

    LS_aspRtoL          dd  ?
    LS_aspLtoR          dd  ?

    LS_xyDensity        dd  ?
    LS_cStyle           dd  ?

    LS_ulStyleMaskLtoR  dd  ?
    LS_ulStyleMaskRtoL  dd  ?

    LS_bStartIsGap      db  ?
    LS_filler3          db  3 dup (?)
LINESTATE ends

;
; This RUN structure must match that in winddi.h!
;

RUN struc
    RUN_iStart          dd  ?
    RUN_iStop           dd  ?
RUN ends
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\vga\disp\8bpp\i386\monopat.asm ===
;---------------------------Module-Header------------------------------;
; Module Name: monopat.asm
;
; Copyright (c) 1992-1993 Microsoft Corporation.  All rights reserved.
;-----------------------------------------------------------------------;

;-----------------------------------------------------------------------;
; VOID vMonoPat(ppdev, culRcl, prcl, ulMix, prb, pptlBrush)
;
; Input:
;
;  ppdev     - surface on which to draw
;  culRcl    - number of rectangles
;  prcl      - pointer to rectangles
;  ulMix     - mix mode (i.e., ROP)
;  prb       - pointer to realized brush
;  pptlBrush - brush alignment
;
; Draws two color patterns using the VGA hardware.  If the ROP is a
; PATCOPY ROP, we can light 8 pixels on every word write to VGA memory.
;
; We special case black & white patterns because we can do slightly less
; initialization, and we can handle arbitrary ROPs (although if the ROP
; has to read video memory, we can only do 4 pixels on every read/write
; operation).
;
;-----------------------------------------------------------------------;
;
; NOTE: Assumes all rectangles have positive heights and widths.  Will
; not work properly if this is not the case.
;
;-----------------------------------------------------------------------;

;-----------------------------------------------------------------------;

        .386

        .model  small,c

        assume cs:FLAT,ds:FLAT,es:FLAT,ss:FLAT
        assume fs:nothing,gs:nothing

        .xlist
        include stdcall.inc             ;calling convention cmacros
        include i386\strucs.inc
        include i386\driver.inc
        include i386\egavga.inc
        include i386\ropdefs.inc

        .list

;-----------------------------------------------------------------------;

        .code

; vTrgBlt is used for 2-pass ROPs:

        EXTRNP          vTrgBlt,24

        .data

; Tables shared with vgablts.asm:

extrn   jALUFuncTable:  byte
extrn   jInvertDest:    byte

;-----------------------------------------------------------------------;
; Bits for drawing routine look-ups.

BLOCK_LEFT_EDGE                 equ 010000b
BLOCK_RIGHT_EDGE                equ 001000b
BLOCK_MIDDLE_STARTS_UNALIGNED   equ 000100b
BLOCK_NO_MIDDLE                 equ 000010b
BLOCK_MIDDLE_ENDS_UNALIGNED     equ 000001b

;-----------------------------------------------------------------------;
; Table of drawing routines, with the look-up index a 5 bit field as
; follows:
;
; Bit 4 = 1 if a left edge must be drawn
; Bit 3 = 1 if a right edge must be drawn
; Bit 2 = 1 if middle block starts unaligned word-wise
; Bit 1 = 1 if no middle block
; Bit 0 = 1 if middle block is an odd number of bytes in length

        align   4
gapfnSetTable label dword
        dd      dual_wide_00_w          ;00000
        dd      dual_wide_01_w          ;00001
        dd      0                       ;00010
        dd      0                       ;00011
        dd      dual_wide_11_w          ;00100
        dd      dual_wide_10_w          ;00101
        dd      0                       ;00110
        dd      0                       ;00111
        dd      Block_01000_w           ;01000
        dd      Block_01001_w           ;01001
        dd      dual_right_0_w          ;01010
        dd      dual_right_1_w          ;01011
        dd      Block_01100_w           ;01100
        dd      Block_01101_w           ;01101
        dd      dual_right_1_w          ;01110
        dd      dual_right_0_w          ;01111
        dd      Block_10000_w           ;10000
        dd      Block_10001_w           ;10001
        dd      dual_left_0_w           ;10010
        dd      dual_left_0_w           ;10011
        dd      Block_10100_w           ;10100
        dd      Block_10101_w           ;10101
        dd      dual_left_1_w           ;10110
        dd      dual_left_1_w           ;10111
        dd      Block_11000_w           ;11000
        dd      Block_11001_w           ;11001
        dd      Block_11010_w           ;11010
        dd      0                       ;11011 - can never happen
        dd      Block_11100_w           ;11100
        dd      Block_11101_w           ;11101
        dd      Block_11110_w           ;11110
        dd      0                       ;11111 - can never happen

gapfnROPTable label dword
        dd      dual_wide_00_rw         ;00000
        dd      dual_wide_01_rw         ;00001
        dd      0                       ;00010
        dd      0                       ;00011
        dd      dual_wide_11_rw         ;00100
        dd      dual_wide_10_rw         ;00101
        dd      0                       ;00110
        dd      0                       ;00111
        dd      Block_01000_rw          ;01000
        dd      Block_01001_rw          ;01001
        dd      dual_right_0_rw         ;01010
        dd      dual_right_1_rw         ;01011
        dd      Block_01100_rw          ;01100
        dd      Block_01101_rw          ;01101
        dd      dual_right_1_rw         ;01110
        dd      dual_right_0_rw         ;01111
        dd      Block_10000_rw          ;10000
        dd      Block_10001_rw          ;10001
        dd      dual_left_0_rw          ;10010
        dd      dual_left_0_rw          ;10011
        dd      Block_10100_rw          ;10100
        dd      Block_10101_rw          ;10101
        dd      dual_left_1_rw          ;10110
        dd      dual_left_1_rw          ;10111
        dd      Block_11000_rw          ;11000
        dd      Block_11001_rw          ;11001
        dd      Block_11010_rw          ;11010
        dd      0                       ;11011 - can never happen
        dd      Block_11100_rw          ;11100
        dd      Block_11101_rw          ;11101
        dd      Block_11110_rw          ;11110
        dd      0                       ;11111 - can never happen

gaulForceOffTable label dword
        dd      0                       ;ignored - there is no mix 0
        dd      0
        dd      0ffffffffh
        dd      0ffffffffh
        dd      0ffffffffh
        dd      0ffffffffh
        dd      0ffffffffh
        dd      0ffffffffh
        dd      0ffffffffh
        dd      0ffffffffh
        dd      0ffffffffh
        dd      0
        dd      0ffffffffh
        dd      0ffffffffh
        dd      0ffffffffh
        dd      0ffffffffh
        dd      0ffffffffh

gaulForceOnTable label dword
        dd      0                       ;ignored - there is no mix 0
        dd      0
        dd      0
        dd      0
        dd      0
        dd      0
        dd      0ffffffffh
        dd      0
        dd      0
        dd      0
        dd      0
        dd      0
        dd      0
        dd      0
        dd      0
        dd      0
        dd      0ffffffffh

gaulForceNotTable label dword
        dd      0                       ;ignored - there is no mix 0
        dd      0
        dd      0ffffffffh
        dd      0ffffffffh
        dd      0ffffffffh
        dd      0
        dd      0
        dd      0
        dd      0ffffffffh
        dd      0
        dd      0ffffffffh
        dd      0
        dd      0ffffffffh
        dd      0
        dd      0
        dd      0
        dd      0

;-----------------------------------------------------------------------;

        .code
;-----------------------------------------------------------------------;
; Write thunks (for set ROPs)
;-----------------------------------------------------------------------;

Block_01000_w:
        push    offset dual_right_0_w
        jmp     dual_wide_00_w

Block_01001_w:
        push    offset dual_right_1_w
        jmp     dual_wide_01_w

Block_01100_w:
        push    offset dual_right_1_w
        jmp     dual_wide_11_w

Block_01101_w:
        push    offset dual_right_0_w
        jmp     dual_wide_10_w

Block_11000_w:
        push    offset dual_right_0_w
Block_10000_w:
        push    offset dual_left_0_w
        jmp     dual_wide_00_w

Block_11001_w:
        push    offset dual_right_1_w
Block_10001_w:
        push    offset dual_left_0_w
        jmp     dual_wide_01_w

Block_11100_w:
        push    offset dual_right_1_w
Block_10100_w:
        push    offset dual_left_1_w
        jmp     dual_wide_11_w

Block_11101_w:
        push    offset dual_right_0_w
Block_10101_w:
        push    offset dual_left_1_w
        jmp     dual_wide_10_w

Block_11010_w:
        push    offset dual_right_0_w
        jmp     dual_left_0_w

Block_11110_w:
        push    offset dual_right_1_w
        jmp     dual_left_1_w

;-----------------------------------------------------------------------;
; Read/write thunks (for arbitrary ROPs)
;-----------------------------------------------------------------------;

Block_01000_rw:
        push    offset dual_right_0_rw
        jmp     dual_wide_00_rw

Block_01001_rw:
        push    offset dual_right_1_rw
        jmp     dual_wide_01_rw

Block_01100_rw:
        push    offset dual_right_1_rw
        jmp     dual_wide_11_rw

Block_01101_rw:
        push    offset dual_right_0_rw
        jmp     dual_wide_10_rw

Block_11000_rw:
        push    offset dual_right_0_rw
Block_10000_rw:
        push    offset dual_left_0_rw
        jmp     dual_wide_00_rw

Block_11001_rw:
        push    offset dual_right_1_rw
Block_10001_rw:
        push    offset dual_left_0_rw
        jmp     dual_wide_01_rw

Block_11100_rw:
        push    offset dual_right_1_rw
Block_10100_rw:
        push    offset dual_left_1_rw
        jmp     dual_wide_11_rw

Block_11101_rw:
        push    offset dual_right_0_rw
Block_10101_rw:
        push    offset dual_left_1_rw
        jmp     dual_wide_10_rw

Block_11010_rw:
        push    offset dual_right_0_rw
        jmp     dual_left_0_rw

Block_11110_rw:
        push    offset dual_right_1_rw
        jmp     dual_left_1_rw

;-----------------------------------------------------------------------;

cProc   vMonoPat,24,<         \
        uses esi edi ebx,     \
        ppdev:     ptr PDEV,  \
        culRcl:    dword,     \
        prcl:      ptr RECTL, \
        ulMix:     dword,     \
        prb:       ptr RBRUSH,\
        pptlBrush: ptr POINTL >

; Variables used in block drawers:

        local ppfnDraw:            ptr   ;pointer to array of draw routines
        local pfnDraw:             ptr   ;pointer to draw routines

        local yBrush:              dword ;current y brush alignment
        local yBrushOrg:           dword ;original y brush alignment
        local ulMiddleDest:        dword ;bitmap offset to middle
        local lMiddleDelta:        dword ;delta from end of middle scan to next
        local ulBlockHeight:       dword ;# of scans to be drawn in block
        local ulBlockHeightTmp:    dword ;scratch copy of ulBlockHeight
        local cwMiddle:            dword ;# of words to be written in middle

        local ulLeftDest:          dword ;bitmap offset to left edge
        local ulLeftMask:          dword ;plane mask for left-edge drawing
        local ulRightDest:         dword ;bitmap offset to right edge
        local ulRightMask:         dword ;plane mask for right-edge drawing
        local lDelta:              dword ;delta between scans

        local ulCurrentDestScan:   dword ;current destination scan
        local ulLastDestScan:      dword ;last destination scan

        local pulPattern:          ptr   ;pointer to working pattern buffer
                                         ; (to account for brush inversions)
        local aulPatternBuffer[8]: dword ;pattern buffer

        local pfnLoopTop:           ptr   ;points to desired loop top

        mov     esi,pptlBrush
        mov     edi,prb
        mov     ecx,[esi].ptl_y
        mov     yBrushOrg,ecx           ;yBrushOrg = pptlBrush->y
        mov     ecx,[esi].ptl_x
        mov     eax,[edi].rb_xBrush
        and     ecx,7
        cmp     eax,ecx
        jne     dual_align_brush        ;only align if we really have to

dual_done_align_brush:
        test    [edi].rb_fl,RBRUSH_2COLOR
        jnz     col2_colors

; Set VGA to read mode 1 and write mode 2:

        mov     esi,ppdev
        mov     edx,VGA_BASE + GRAF_ADDR
        mov     ah,byte ptr [esi].pdev_ulrm0_wmX[2]
        or      ah,M_COLOR_READ
        mov     al,GRAF_MODE
        out     dx,ax                   ;write mode 2 to expand pattern bits to
                                        ; 0 or 0ffh per plane, read mode 1 so
                                        ; we can read 0xFF from memory always,
                                        ; for ANDing (because Color Don't Care
                                        ; is all zeros)

;-----------------------------------------------------------------------;
; Handle only black/white patterns.
;-----------------------------------------------------------------------;

        lea     eax,[edi].rb_aulPattern
        mov     pulPattern,eax          ;pulPattern = &pbr.rb_aulPattern[0]
        lea     eax,gapfnSetTable
        mov     ppfnDraw,eax            ;ppfnDraw = gapfnSetTable

        mov     ecx,ulMix
        and     ecx,0fh
        cmp     ecx,R2_COPYPEN
        jne     bw_init_rop             ;do some more work if not copy ROP

bw_done_init_rop:

        call    dual_draw_rectangles    ;draw those puppies

; All done!  Restore read mode 0, write mode 0:

        mov     esi,ppdev
        mov     edx,VGA_BASE + GRAF_ADDR
        mov     ah,byte ptr [esi].pdev_ulrm0_wmX[0]
        mov     al,GRAF_MODE
        out     dx,ax

; Enable all planes:

        mov     edx,VGA_BASE + SEQ_DATA
        mov     al,MM_ALL
        out     dx,al

        cmp     ulMix,R2_COPYPEN
        jne     short bw_enable_set_mode
        cRet    vMonoPat

; Set ALU function to Set mode (we don't have to bother if we had a
; COPYPEN ROP):

bw_enable_set_mode:
        mov     eax,GRAF_DATA_ROT + (DR_SET shl 8)
        mov     edx,VGA_BASE + GRAF_ADDR
        out     dx,ax
        cRet    vMonoPat

;-----------------------------------------------------------------------;
; Draw both black and white and 2 color rectangles.
;-----------------------------------------------------------------------;

        public  dual_draw_rectangles
dual_draw_rectangles::

        mov     edi,prcl                ;edi = prcl
        mov     edx,ppdev
        mov     eax,[edi].yBottom
        mov     ebx,[edi].yTop
        mov     edx,[edx].pdev_lPlanarNextScan

        mov     lDelta,edx              ;lDelta = ppdev->lPlanarNextScan
        mov     ulLastDestScan,eax      ;ulLastDestScan = prcl->bottom
        mov     ulCurrentDestScan,ebx   ;ulCurrentDestScan = prcl->top

        mov     ecx,edx
        imul    ecx,ebx

        sub     ebx,yBrushOrg
        and     ebx,7
        mov     yBrush,ebx              ;yBrush = (prcl->top - pptlBrush->y) & 7
                                        ; (our current index into the pattern
                                        ; array)

        mov     ebx,[edi].xLeft
        shr     ebx,2
        add     ebx,ecx                 ;ebx = prcl->top * lDelta +
                                        ; (prcl->left >> 2)
                                        ; (offset into bitmap of left side)

        mov     eax,[edi].xRight
        shr     eax,2
        add     eax,ecx
        mov     ulRightDest,eax         ;ulRightDest = prcl->top * lDelta +
                                        ; (prcl->right >> 2)
                                        ; (offset into bitmap of right side)

        xor     esi,esi                 ;zero our flags

        mov     ecx,[edi].xLeft
        and     ecx,3
        jz      short dual_done_left    ;skip if we don't need a left edge

        mov     esi,0fh                 ;compute the plane mask for the left
        shl     esi,cl                  ; edge.  we don't use a look-up table
        mov     ulLeftMask,esi          ; 'cause it won't be in the cache.

        mov     esi,(BLOCK_LEFT_EDGE shr 2)
                                        ;set our flag (we soon shift left by 2)

        mov     ulLeftDest,ebx          ;ulLeftDest = prcl->top * lDelta +
                                        ; (prcl->left >> 2)
        inc     ebx                     ;ebx = ulMiddleDest = ulLeftDest + 1
                                        ; (we have to adjust our offset to
                                        ; the first whole byte)

dual_done_left:
        sub     eax,ebx                 ;eax = cjMiddle =
                                        ; ulRightDest - ulMiddleDest
        mov     ulMiddleDest,ebx        ;ulMiddleDest

        .errnz  (BLOCK_MIDDLE_STARTS_UNALIGNED shr 2) - 1
        and     ebx,1                   ;set bit if middle doesn't start
        or      esi,ebx                 ; word aligned (remembering we'll
                                        ; soon shift flags left by 2)

        mov     ecx,[edi].xRight
        and     ecx,3
        jz      short dual_done_right   ;skip if we don't need a right edge

        mov     ebx,0f0h                ;compute the plane mask for the right
        rol     bl,cl                   ; edge.  we don't use a look-up table
        mov     ulRightMask,ebx         ; 'cause it won't be in the cache.

        or      esi,(BLOCK_RIGHT_EDGE shr 2)
                                        ;set our flag (we soon shift left by 2)

; If the count of whole bytes is negative, that means that the pattern
; starts and ends in the same quadpixel, so we do some more work:

        cmp     eax,0
        jge     short dual_done_right

; It starts and ends in the same quadpixel:

        and     esi,not (BLOCK_RIGHT_EDGE shr 2)
                                        ;turn off right edge
        and     ebx,ulLeftMask
        mov     ulLeftMask,ebx
        xor     eax,eax                 ;we do zero middle bytes

        public  dual_done_right
dual_done_right::
        mov     ebx,ppfnDraw

; We're going to do two 'adc esi,esi' instructions here, effectively
; shifting our flags left by 2, and setting the low bits:

        .errnz  (BLOCK_NO_MIDDLE shr 1) - 1
        cmp     eax,1                   ;shift flags left one, and set low
        adc     esi,esi                 ; bit if we don't need to do a middle

        .errnz  (BLOCK_MIDDLE_ENDS_UNALIGNED) - 1
        shr     eax,1
        adc     esi,esi                 ;shift flags left one, and set low
                                        ; bit if the middle isn't an even
                                        ; number of bytes in length
        mov     cwMiddle,eax            ;cwMiddle = cjMiddle / 2

        sub     edx,eax
        sub     edx,eax
        mov     lMiddleDelta,edx        ;lMiddleDelta = lDelta - 2 * cwMiddle

        mov     eax,[ebx+esi*4]
        mov     pfnDraw,eax             ;pointer to function that draws
                                        ; everything in the bank

        mov     ebx,ppdev
        mov     edi,[edi].yTop

        cmp     edi,[ebx].pdev_rcl1PlanarClip.yTop
        jl      short dual_map_init_bank

        cmp     edi,[ebx].pdev_rcl1PlanarClip.yBottom
        jl      short dual_init_bank_mapped

dual_map_init_bank:
        ptrCall <dword ptr [ebx].pdev_pfnPlanarControl>, \
                <ebx,edi,JustifyTop>

dual_init_bank_mapped:
        mov     eax,ulLastDestScan
        mov     ebx,[ebx].pdev_rcl1PlanarClip.yBottom

        sub     eax,ebx
        sbb     ecx,ecx
        and     ecx,eax
        add     ebx,ecx                 ;ebx = min(ulLastDestScan,
                                        ;      ppdev->rcl1PlanarClip.yBottom)
        mov     ulCurrentDestScan,ebx

        sub     ebx,edi
        mov     ulBlockHeight,ebx       ;ulBlockHeight = ebx - ulCurrentDestScan

; Draw everything in this bank:

        call    pfnDraw

dual_done_pfnDraw:
        mov     edi,ulCurrentDestScan
        cmp     edi,ulLastDestScan
        jge     short dual_next_rectangle

; Get the next bank:

        mov     ebx,ppdev
        mov     yBrush,esi              ;make sure we record the new brush
                                        ; alignment

; Map the next bank into window.
; Note: EBX, ESI, and EDI are preserved, according to C calling conventions.

        ptrCall <dword ptr [ebx].pdev_pfnPlanarControl>, \
                <ebx,edi,JustifyTop>

        jmp     short dual_init_bank_mapped

;-----------------------------------------------------------------------;
; Done rectangle.
;-----------------------------------------------------------------------;

        public  dual_next_rectangle
dual_next_rectangle::
        add     prcl, size RECTL
        dec     culRcl
        jg      dual_draw_rectangles    ;do more rectangles

        PLAIN_RET                       ;return

;-----------------------------------------------------------------------;
; Handle x-brush alignment.
;-----------------------------------------------------------------------;

        public  dual_align_brush
dual_align_brush::

; Align the pattern on x.  Remember it in the realized brush, because if
; the brush is used again, it's likely to have the same alignment...

        mov     [edi].rb_xBrush,ecx     ;remember our new alignment
        sub     ecx,eax                 ;rotate pattern left by
                                        ; pptlBrush->x - prb->xBrush

; We keep each row of the pattern in the low word of each dword.  If the
; bits are to appear on the screen as 01234567, the word of our pattern
; has the bits 32107654|76543210 -- we're in write mode 3, and when
; written as a word, this results in 3210 being written in the first
; byte, and 7654 in the second byte.
;
; For our funky plaanr format, we just rotate each byte of the word left by
; 'cl' to get the desired result.

        rol     byte ptr [edi][0].rb_aulPattern,cl        ;0
        rol     byte ptr [edi][1].rb_aulPattern,cl
        rol     byte ptr [edi][4].rb_aulPattern,cl        ;1
        rol     byte ptr [edi][5].rb_aulPattern,cl
        rol     byte ptr [edi][8].rb_aulPattern,cl        ;2
        rol     byte ptr [edi][9].rb_aulPattern,cl
        rol     byte ptr [edi][12].rb_aulPattern,cl       ;3
        rol     byte ptr [edi][13].rb_aulPattern,cl
        rol     byte ptr [edi][16].rb_aulPattern,cl       ;4
        rol     byte ptr [edi][17].rb_aulPattern,cl
        rol     byte ptr [edi][20].rb_aulPattern,cl       ;5
        rol     byte ptr [edi][21].rb_aulPattern,cl
        rol     byte ptr [edi][24].rb_aulPattern,cl       ;6
        rol     byte ptr [edi][25].rb_aulPattern,cl
        rol     byte ptr [edi][28].rb_aulPattern,cl       ;7
        rol     byte ptr [edi][29].rb_aulPattern,cl

        jmp     dual_done_align_brush

;-----------------------------------------------------------------------;
; Handle arbitrary ROPs for black/white patterns.
;-----------------------------------------------------------------------;

; Expect:
;
; ecx = ulMix

        public  bw_init_rop
bw_init_rop::
        cmp     jInvertDest[ecx],0
        je      short bw_set_that_ALU   ;skip if don't need 2 passes

; For some ROPs, we have to invert the destination first, then do another
; operation (that is, it's a 2-pass ROP).  We handle the inversion here:

        cCall   vTrgBlt,<ppdev, culRcl, prcl, R2_NOT, 0, 0>
        mov     ecx,ulMix
        and     ecx,0fh

bw_set_that_ALU:
        mov     ah,jALUFuncTable[ecx]
        cmp     ah,DR_SET
        je      short bw_that_ALU_is_set
                                        ;we're already in Set mode

        mov     edx,VGA_BASE + GRAF_ADDR
        mov     al,GRAF_DATA_ROT
        out     dx,ax                   ;set the ALU logical function
        lea     ebx,gapfnROPTable
        mov     ppfnDraw,ebx

bw_that_ALU_is_set:
        lea     esi,aulPatternBuffer
        mov     pulPattern,esi          ;we're using the temporary buffer

        mov     ebx,gaulForceOffTable[ecx*4]
        mov     edx,gaulForceOnTable[ecx*4]
        mov     esi,gaulForceNotTable[ecx*4]

        mov     eax,[edi][0].rb_aulPattern      ;0
        and     eax,ebx
        or      eax,edx
        xor     eax,esi
        mov     [aulPatternBuffer][0],eax
        mov     eax,[edi][4].rb_aulPattern      ;1
        and     eax,ebx
        or      eax,edx
        xor     eax,esi
        mov     [aulPatternBuffer][4],eax
        mov     eax,[edi][8].rb_aulPattern      ;2
        and     eax,ebx
        or      eax,edx
        xor     eax,esi
        mov     [aulPatternBuffer][8],eax
        mov     eax,[edi][12].rb_aulPattern     ;3
        and     eax,ebx
        or      eax,edx
        xor     eax,esi
        mov     [aulPatternBuffer][12],eax
        mov     eax,[edi][16].rb_aulPattern     ;4
        and     eax,ebx
        or      eax,edx
        xor     eax,esi
        mov     [aulPatternBuffer][16],eax
        mov     eax,[edi][20].rb_aulPattern     ;5
        and     eax,ebx
        or      eax,edx
        xor     eax,esi
        mov     [aulPatternBuffer][20],eax
        mov     eax,[edi][24].rb_aulPattern     ;6
        and     eax,ebx
        or      eax,edx
        xor     eax,esi
        mov     [aulPatternBuffer][24],eax
        mov     eax,[edi][28].rb_aulPattern     ;7
        and     eax,ebx
        or      eax,edx
        xor     eax,esi
        mov     [aulPatternBuffer][28],eax

        jmp     bw_done_init_rop

;-----------------------------------------------------------------------;
; Handle 2-color patterns.
;-----------------------------------------------------------------------;

        public  col2_colors
col2_colors::
        lea     eax,[edi].rb_aulPattern
        mov     pulPattern,eax          ;pulPattern = &pbr.rb_aulPattern[0]
        lea     eax,gapfnSetTable
        mov     ppfnDraw,eax            ;ppfnDraw = gapfnSetTable

        call    col2_first_rectangle

; Restore VGA hardware to its default state:

        mov     edx,VGA_BASE + GRAF_DATA
        mov     al,0ffh
        out     dx,al                   ;enable all bits through the Bit Mask

        mov     esi,ppdev
        dec     edx                     ;point back to the Graphics Index reg
        mov     ah,byte ptr [esi].pdev_ulrm0_wmX[0]
                                        ;write mode 0 setting for Graphics Mode
        mov     al,GRAF_MODE
        out     dx,ax                   ;write mode 0, read mode 0

        mov     eax,GRAF_DATA_ROT + (DR_SET SHL 8)
        out     dx,ax                   ;replace mode, no rotate

        mov     edx,VGA_BASE + SEQ_DATA
        mov     al,MM_ALL
        out     dx,al                   ;enable all planes

        cRet    vMonoPat

;-----------------------------------------------------------------------;
; Handle first rectangle for 2-color patterns.
;-----------------------------------------------------------------------;

; We have to special case the first rectangle because we have to load
; the latches with the background color after mapping the bank but before
; doing any drawing.

        public  col2_first_rectangle
col2_first_rectangle::
        mov     edi,prcl                ;edi = prcl
        mov     edx,ppdev
        mov     eax,[edi].yBottom
        mov     ebx,[edi].yTop
        mov     edx,[edx].pdev_lPlanarNextScan

        mov     lDelta,edx              ;lDelta = ppdev->lPlanarNextScan
        mov     ulLastDestScan,eax      ;ulLastDestScan = prcl->bottom
        mov     ulCurrentDestScan,ebx   ;ulCurrentDestScan = prcl->top

        mov     ecx,edx
        imul    ecx,ebx

        sub     ebx,yBrushOrg
        and     ebx,7
        mov     yBrush,ebx              ;yBrush = (prcl->top - pptlBrush->y) & 7
                                        ; (our current index into the pattern
                                        ; array)

        mov     ebx,[edi].xLeft
        shr     ebx,2
        add     ebx,ecx                 ;ebx = prcl->top * lDelta +
                                        ; (prcl->left >> 2)
                                        ; (offset into bitmap of left side)

        mov     eax,[edi].xRight
        shr     eax,2
        add     eax,ecx
        mov     ulRightDest,eax         ;ulRightDest = prcl->top * lDelta +
                                        ; (prcl->right >> 2)
                                        ; (offset into bitmap of right side)

        xor     esi,esi                 ;zero our flags

        mov     ecx,[edi].xLeft
        and     ecx,3
        jz      short col2_done_left    ;skip if we don't need a left edge

        mov     esi,0fh                 ;compute the plane mask for the left
        shl     esi,cl                  ; edge.  we don't use a look-up table
        mov     ulLeftMask,esi          ; 'cause it won't be in the cache.

        mov     esi,(BLOCK_LEFT_EDGE shr 2)
                                        ;set our flag (we soon shift left by 2)

        mov     ulLeftDest,ebx          ;ulLeftDest = prcl->top * lDelta +
                                        ; (prcl->left >> 2)
        inc     ebx                     ;ebx = ulMiddleDest = ulLeftDest + 1
                                        ; (we have to adjust our offset to
                                        ; the first whole byte)

col2_done_left:
        sub     eax,ebx                 ;eax = cjMiddle =
                                        ; ulRightDest - ulMiddleDest
        mov     ulMiddleDest,ebx        ;ulMiddleDest

        .errnz  (BLOCK_MIDDLE_STARTS_UNALIGNED shr 2) - 1
        and     ebx,1                   ;set bit if middle doesn't start
        or      esi,ebx                 ; word aligned (remembering we'll
                                        ; soon shift flags left by 2)

        mov     ecx,[edi].xRight
        and     ecx,3
        jz      short col2_done_right   ;skip if we don't need a right edge

        mov     ebx,0f0h                ;compute the plane mask for the right
        rol     bl,cl                   ; edge.  we don't use a look-up table
        mov     ulRightMask,ebx         ; 'cause it won't be in the cache.

        or      esi,(BLOCK_RIGHT_EDGE shr 2)
                                        ;set our flag (we soon shift left by 2)

; If the count of whole bytes is negative, that means that the pattern
; starts and ends in the same quadpixel, so we do some more work:

        cmp     eax,0
        jge     short col2_done_right

; It starts and ends in the same quadpixel:

        and     esi,not (BLOCK_RIGHT_EDGE shr 2)
                                        ;turn off right edge
        and     ebx,ulLeftMask
        mov     ulLeftMask,ebx
        xor     eax,eax                 ;we do zero middle bytes

        public  col2_done_right
col2_done_right::
        mov     ebx,ppfnDraw

; We're going to do two 'adc esi,esi' instructions here, effectively
; shifting our flags left by 2, and setting the low bits:

        .errnz  (BLOCK_NO_MIDDLE shr 1) - 1
        cmp     eax,1                   ;shift flags left one, and set low
        adc     esi,esi                 ; bit if we don't need to do a middle

        .errnz  (BLOCK_MIDDLE_ENDS_UNALIGNED) - 1
        shr     eax,1
        mov     cwMiddle,eax            ;cwMiddle = cjMiddle / 2
        adc     esi,esi                 ;shift flags left one, and set low
                                        ; bit if the middle isn't an even
                                        ; number of bytes in length

        sub     edx,eax
        sub     edx,eax
        mov     lMiddleDelta,edx        ;lMiddleDelta = lDelta - 2 * cwMiddle

        mov     eax,[ebx+esi*4]
        mov     pfnDraw,eax             ;pointer to function that draws
                                        ; everything in the bank

        mov     ebx,ppdev
        test    esi,BLOCK_NO_MIDDLE
        jz      short col2_have_a_middle

;-----------------------------------------;

; Handle case where there isn't a whole quadpixel that will be overwritten
; by the pattern, and so we don't have a convenient place for loading the
; latches.  For this case, we'll use off-screen memory.

        mov     esi,[ebx].pdev_pbceCache
        mov     eax,[esi].bce_yCache

        cmp     eax,[ebx].pdev_rcl1PlanarClip.yTop
        jl      short col2_no_middle_map_brush_bank

        cmp     eax,[ebx].pdev_rcl1PlanarClip.yBottom
        jl      short col2_no_middle_brush_bank_mapped

col2_no_middle_map_brush_bank:
        ptrCall <dword ptr [ebx].pdev_pfnPlanarControl>, \
                <ebx,eax,JustifyBottom>

col2_no_middle_brush_bank_mapped:
        mov     ecx,prb                 ;ecx = prb
        mov     esi,[esi].bce_ulCache
        add     esi,[ebx].pdev_pvBitmapStart

        mov     eax,[ecx].rb_ulBkColor
        mov     [esi],al
        mov     al,[esi]                ;latches now laoded with bk color

        mov     edi,[edi].yTop

        cmp     edi,[ebx].pdev_rcl1PlanarClip.yTop
        jl      short col2_no_middle_map_init_bank

        cmp     edi,[ebx].pdev_rcl1PlanarClip.yBottom
        jl      col2_latches_loaded

col2_no_middle_map_init_bank:
        ptrCall <dword ptr [ebx].pdev_pfnPlanarControl>, \
                <ebx,edi,JustifyTop>

        mov     ecx,prb                 ;reload ecx = prb
        jmp     col2_latches_loaded

;-----------------------------------------;

col2_have_a_middle:
        mov     edi,[edi].yTop

        cmp     edi,[ebx].pdev_rcl1PlanarClip.yTop
        jl      short col2_map_init_bank

        cmp     edi,[ebx].pdev_rcl1PlanarClip.yBottom
        jl      short col2_init_bank_mapped

col2_map_init_bank:
        ptrCall <dword ptr [ebx].pdev_pfnPlanarControl>, \
                <ebx,edi,JustifyTop>

col2_init_bank_mapped:
        mov     ecx,prb                 ;ecx = prb
        mov     esi,ulMiddleDest
        add     esi,[ebx].pdev_pvBitmapStart
                                        ;pointer to the first whole quadpixel
                                        ; that will be overwritten by the
                                        ; pattern, and so which is a great
                                        ; place to use to load the latches

        mov     eax,[ecx].rb_ulBkColor
        mov     [esi],al
        mov     al,[esi]                ;latches now loaded with bk color

; Set VGA to read mode 0 and write mode 2:

col2_latches_loaded:

; ebx = ppdev
; ecx = prb
; edi = top line of rectangle

        mov     esi,ppdev
        mov     edx,VGA_BASE + GRAF_ADDR
        mov     ah,byte ptr [esi].pdev_ulrm0_wmX[2]
        mov     al,GRAF_MODE
        out     dx,ax

        mov     eax,GRAF_DATA_ROT + (DR_XOR SHL 8)
        out     dx,ax                   ;XOR to flip latched data to make ~bk

        mov     ah,byte ptr [ecx].rb_ulBkColor
        xor     ah,byte ptr [ecx].rb_ulFgColor
        mov     al,GRAF_BIT_MASK
        out     dx,ax                   ;pass through common fg & bk bits
                                        ; unchanged from bk color in latches;
                                        ; non-common bits come from XOR in the
                                        ; ALUs, flipped from the bk to the fg
                                        ; state if the glyph bit for the pixel
                                        ; in that plane is 1, still in bk state
                                        ; if the glyph bit for that plane is 0

; All done hardware initialization.  Do rest of this boring stuff:

        mov     eax,ulLastDestScan
        mov     ebx,[ebx].pdev_rcl1PlanarClip.yBottom

        sub     eax,ebx
        sbb     ecx,ecx
        and     ecx,eax
        add     ebx,ecx                 ;ebx = min(ulLastDestScan,
                                        ;      ppdev->rcl1PlanarClip.yBottom)
        mov     ulCurrentDestScan,ebx

        sub     ebx,edi
        mov     ulBlockHeight,ebx       ;ulBlockHeight = ebx - ulCurrentDestScan

; Draw everything in this bank:

        CALL_AND_JUMP   pfnDraw,dual_done_pfnDraw

;=======================================================================;
;========================= Set Block Drawers ===========================;
;=======================================================================;

;-----------------------------------------------------------------------;
; dual_wide_11_w
;
; Draws middle words with 1 leading byte and 1 trailing byte.
;
; Input:
;     ppdev         - pointer to physical device structure
;     ulBlockHeight - # of scans to draw
;     lMiddleDelta  - distance from end of current scan to start of next
;     ulMiddleDest  - offset in bitmap at which to start drawing
;     yBrush        - current y brush alignment
;     cwMiddle      - # of words to draw on each scan
;
; Output:
;     esi           - new y brush alignment
;     ulMiddleDest  - new bitmap offset
;-----------------------------------------------------------------------;

        public  dual_wide_11_w
dual_wide_11_w::

; We only have to reset which planes are enabled if we do edges too:

        mov     edx,VGA_BASE + SEQ_DATA
        mov     al,MM_ALL
        out     dx,al

; Calculate full start addresses:

        mov     edi,ppdev
        mov     ebx,ulBlockHeight
        mov     ulBlockHeightTmp,ebx
        mov     ebx,pulPattern
        mov     edx,lMiddleDelta
        add     edx,2                   ;account for first and last
                                        ; bytes
        mov     esi,yBrush
        mov     edi,[edi].pdev_pvBitmapStart
        add     edi,ulMiddleDest
        inc     edi                     ;align to word

;  EBX = pointer to start of pattern
;  EDX = offset from end of scan to start of next
;  ESI = current offset into pattern
;  EDI = target address to which to write

dual_wide_11_w_loop:

; We aim to overdrive.

        mov     eax,[ebx+esi * 4]       ;load pattern for this scan
        mov     [edi-1],ah              ;write the first byte

        mov     ecx,cwMiddle
        dec     ecx                     ;account for first and last
                                        ; bytes
        rep     stosw                   ;light 8 pels on every write

        inc     esi                     ;advance to next scan of pattern
        and     esi,7
        mov     [edi],al                ;write that last byte

        add     edi,edx                 ;advance to next scan

        dec     ulBlockHeightTmp
        jnz     short dual_wide_11_w_loop

; get ready for next time:

        mov     ecx,ppdev
        sub     edi,[ecx].pdev_pvBitmapStart
        dec     edi                     ;undo our word alignment
        mov     ulMiddleDest,edi

        PLAIN_RET

;-----------------------------------------------------------------------;
; dual_wide_10_w
;
; Draws middle words with 1 leading byte and 0 trailing bytes.
;
; Input:
;     ppdev         - pointer to physical device structure
;     ulBlockHeight - # of scans to draw
;     lMiddleDelta  - distance from end of current scan to start of next
;     ulMiddleDest  - offset in bitmap at which to start drawing
;     yBrush        - current y brush alignment
;     cwMiddle      - # of words to draw on each scan
;
; Output:
;     esi           - new y brush alignment
;     ulMiddleDest  - new bitmap offset
;-----------------------------------------------------------------------;

        public  dual_wide_10_w
dual_wide_10_w::

; We only have to reset which planes are enabled if we do edges too:

        mov     edx,VGA_BASE + SEQ_DATA
        mov     al,MM_ALL
        out     dx,al

; Calculate full start addresses:

        mov     edi,ppdev
        mov     ebx,ulBlockHeight
        mov     ulBlockHeightTmp,ebx
        mov     ebx,pulPattern
        mov     edx,lMiddleDelta
        mov     esi,yBrush
        mov     edi,[edi].pdev_pvBitmapStart
        add     edi,ulMiddleDest
        inc     edi                             ;align to word

;  EBX = pointer to start of pattern
;  EDX = offset from end of scan to start of next
;  ESI = current offset into pattern
;  EDI = target address to which to write

dual_wide_10_w_loop:
        mov     eax,[ebx+esi * 4]               ;load pattern for this scan
        mov     [edi-1],ah                      ;write the first byte

        mov     ecx,cwMiddle
        rep     stosw                           ;light 8 pels on every write

        inc     esi                             ;advance to next scan of pattern
        and     esi,7

        add     edi,edx                         ;advance to next scan

        dec     ulBlockHeightTmp
        jnz     short dual_wide_10_w_loop

; get ready for next time:

        mov     ecx,ppdev
        sub     edi,[ecx].pdev_pvBitmapStart
        dec     edi                             ;undo our word alignment
        mov     ulMiddleDest,edi

        PLAIN_RET

;-----------------------------------------------------------------------;
; dual_wide_01_w
;
; Draws middle words with 0 leading bytes and 1 trailing byte.
;
; Input:
;     ppdev         - pointer to physical device structure
;     ulBlockHeight - # of scans to draw
;     lMiddleDelta  - distance from end of current scan to start of next
;     ulMiddleDest  - offset in bitmap at which to start drawing
;     yBrush        - current y brush alignment
;     cwMiddle      - # of words to draw on each scan
;
; Output:
;     esi           - new y brush alignment
;     ulMiddleDest  - new bitmap offset
;-----------------------------------------------------------------------;

        public  dual_wide_01_w
dual_wide_01_w::

; We only have to reset which planes are enabled if we do edges too:

        mov     edx,VGA_BASE + SEQ_DATA
        mov     al,MM_ALL
        out     dx,al

; Calculate full start addresses:

        mov     edi,ppdev
        mov     ebx,ulBlockHeight
        mov     ulBlockHeightTmp,ebx
        mov     ebx,pulPattern
        mov     edx,lMiddleDelta
        mov     esi,yBrush
        mov     edi,[edi].pdev_pvBitmapStart
        add     edi,ulMiddleDest

;  EBX = pointer to start of pattern
;  EDX = offset from end of scan to start of next
;  ESI = current offset into pattern
;  EDI = target address to which to write

dual_wide_01_w_loop:
        mov     eax,[ebx+esi*4]                 ;load pattern for this scan

        mov     ecx,cwMiddle
        rep     stosw                           ;light 8 pels on every write

        inc     esi                             ;advance to next scan of pattern
        and     esi,7
        mov     [edi],al                        ;write that last byte

        add     edi,edx                         ;advance to next scan

        dec     ulBlockHeightTmp
        jnz     short dual_wide_01_w_loop

; get ready for next time:

        mov     ecx,ppdev
        sub     edi,[ecx].pdev_pvBitmapStart
        mov     ulMiddleDest,edi

        PLAIN_RET

;-----------------------------------------------------------------------;
; dual_wide_00_w
;
; Draws middle words with 0 leading bytes and 1 trailing byte.
;
; Input:
;     ppdev         - pointer to physical device structure
;     ulBlockHeight - # of scans to draw
;     lMiddleDelta  - distance from end of current scan to start of next
;     ulMiddleDest  - offset in bitmap at which to start drawing
;     yBrush        - current y brush alignment
;     cwMiddle      - # of words to draw on each scan
;
; Output:
;     esi           - new y brush alignment
;     ulMiddleDest  - new bitmap offset
;-----------------------------------------------------------------------;

        public  dual_wide_00_w
dual_wide_00_w::

; We only have to reset which planes are enabled if we do edges too:

        mov     edx,VGA_BASE + SEQ_DATA
        mov     al,MM_ALL
        out     dx,al

; Calculate full start addresses:

        mov     edi,ppdev
        mov     ebx,ulBlockHeight
        mov     ulBlockHeightTmp,ebx
        mov     ebx,pulPattern
        mov     edx,lMiddleDelta
        mov     esi,yBrush
        mov     edi,[edi].pdev_pvBitmapStart
        add     edi,ulMiddleDest

;  EBX = pointer to start of pattern
;  EDX = offset from end of scan to start of next
;  ESI = current offset into pattern
;  EDI = target address to which to write

dual_wide_00_w_loop:
        mov     eax,[ebx+esi*4]                 ;load pattern for this scan

        mov     ecx,cwMiddle
        rep     stosw                           ;light 8 pels on every write

        inc     esi                             ;advance to next scan of pattern
        and     esi,7

        add     edi,edx                         ;advance to next scan

        dec     ulBlockHeightTmp
        jnz     short dual_wide_00_w_loop

; get ready for next time:

        mov     ecx,ppdev
        sub     edi,[ecx].pdev_pvBitmapStart
        mov     ulMiddleDest,edi

        PLAIN_RET

;-----------------------------------------------------------------------;
; dual_left_1_w
;
; Draws a left edge when the next byte is not word aligned.
;
; Input:
;     ppdev         - pointer to physical device structure
;     ulBlockHeight - # of scans to draw
;     lDelta        - distance from end of current scan to start of next
;     ulLeftDest    - offset in bitmap at which to start drawing
;     yBrush        - current y brush alignment
;
; Output:
;     esi           - new y brush alignment
;     ulLeftDest    - new bitmap offset
;-----------------------------------------------------------------------;

        public  dual_left_1_w
dual_left_1_w::

; Set left mask by disabling some planes:

        mov     edx,VGA_BASE + SEQ_DATA
        mov     eax,ulLeftMask
        out     dx,al

; Calculate full start addresses:

        mov     edi,ppdev
        mov     ebx,ulBlockHeight
        mov     ecx,pulPattern
        mov     edx,lDelta
        mov     esi,yBrush
        mov     edi,[edi].pdev_pvBitmapStart
        add     edi,ulLeftDest

;  EBX = count of loop iterations
;  ECX = pointer to start of pattern
;  EDX = offset to next scan
;  ESI = current offset into pattern
;  EDI = target address to which to write

dual_left_1_w_loop:
        mov     eax,[ecx+esi*4]                 ;load pattern for this scan
        mov     [edi],al                        ;write the low byte
        inc     esi                             ;advance to next scan of pattern
        and     esi,7
        add     edi,edx                         ;advance to next scan

        dec     ebx
        jnz     short dual_left_1_w_loop

; get ready for next time:

        mov     ecx,ppdev
        sub     edi,[ecx].pdev_pvBitmapStart
        mov     ulLeftDest,edi

        PLAIN_RET

;-----------------------------------------------------------------------;
; dual_left_0_w
;
; Draws a left edge when the next byte is word aligned.
;
; Input:
;     ppdev         - pointer to physical device structure
;     ulBlockHeight - # of scans to draw
;     lDelta        - distance from end of current scan to start of next
;     ulLeftDest    - offset in bitmap at which to start drawing
;     yBrush        - current y brush alignment
;
; Output:
;     esi           - new y brush alignment
;     ulLeftDest    - new bitmap offset
;-----------------------------------------------------------------------;

        public  dual_left_0_w
dual_left_0_w::

; Set left mask by disabling some planes:

        mov     edx,VGA_BASE + SEQ_DATA
        mov     eax,ulLeftMask
        out     dx,al

; Calculate full start addresses:

        mov     edi,ppdev
        mov     ebx,ulBlockHeight
        mov     ecx,pulPattern
        mov     edx,lDelta
        mov     esi,yBrush
        mov     edi,[edi].pdev_pvBitmapStart
        add     edi,ulLeftDest

;  EBX = count of loop iterations
;  ECX = pointer to start of pattern
;  EDX = offset to next scan
;  ESI = current offset into pattern
;  EDI = target address to which to write

dual_left_0_w_loop:
        mov     eax,[ecx+esi*4]                 ;load pattern for this scan
        mov     [edi],ah                        ;write the high byte
        inc     esi                             ;advance to next scan of pattern
        and     esi,7
        add     edi,edx                         ;advance to next scan

        dec     ebx
        jnz     short dual_left_0_w_loop

; get ready for next time:

        mov     ecx,ppdev
        sub     edi,[ecx].pdev_pvBitmapStart
        mov     ulLeftDest,edi

        PLAIN_RET

;-----------------------------------------------------------------------;
; dual_right_1_w
;
; Draws a right edge when not word aligned.
;
; Input:
;     ppdev         - pointer to physical device structure
;     ulBlockHeight - # of scans to draw
;     lDelta        - distance from end of current scan to start of next
;     ulRightDest   - offset in bitmap at which to start drawing
;     yBrush        - current y brush alignment
;
; Output:
;     esi           - new y brush alignment
;     ulRightDest   - new bitmap offset
;-----------------------------------------------------------------------;

        public  dual_right_1_w
dual_right_1_w::

; Set right mask by disabling some planes:

        mov     edx,VGA_BASE + SEQ_DATA
        mov     eax,ulRightMask
        out     dx,al

; Calculate full start addresses:

        mov     edi,ppdev
        mov     ebx,ulBlockHeight
        mov     ecx,pulPattern
        mov     edx,lDelta
        mov     esi,yBrush
        mov     edi,[edi].pdev_pvBitmapStart
        add     edi,ulRightDest

;  EBX = count of loop iterations
;  ECX = pointer to start of pattern
;  EDX = offset to next scan
;  ESI = current offset into pattern
;  EDI = target address to which to write

dual_right_1_w_loop:
        mov     eax,[ecx+esi*4]                 ;load pattern for this scan
        mov     [edi],ah                        ;write the high byte
        inc     esi                             ;advance to next scan of pattern
        and     esi,7
        add     edi,edx                         ;advance to next scan

        dec     ebx
        jnz     short dual_right_1_w_loop

; get ready for next time:

        mov     ecx,ppdev
        sub     edi,[ecx].pdev_pvBitmapStart
        mov     ulRightDest,edi

        PLAIN_RET

;-----------------------------------------------------------------------;
; dual_right_0_w
;
; Draws a right edge when word aligned.
;
; Input:
;     ppdev         - pointer to physical device structure
;     ulBlockHeight - # of scans to draw
;     lDelta        - distance from end of current scan to start of next
;     ulRightDest   - offset in bitmap at which to start drawing
;     yBrush        - current y brush alignment
;
; Output:
;     esi           - new y brush alignment
;     ulRightDest   - new bitmap offset
;-----------------------------------------------------------------------;

        public  dual_right_0_w
dual_right_0_w::

; Set right mask by disabling some planes:

        mov     edx,VGA_BASE + SEQ_DATA
        mov     eax,ulRightMask
        out     dx,al

; Calculate full start addresses:

        mov     edi,ppdev
        mov     ebx,ulBlockHeight
        mov     ecx,pulPattern
        mov     edx,lDelta
        mov     esi,yBrush
        mov     edi,[edi].pdev_pvBitmapStart
        add     edi,ulRightDest

;  EBX = count of loop iterations
;  ECX = pointer to start of pattern
;  EDX = offset to next scan
;  ESI = current offset into pattern
;  EDI = target address to which to write

dual_right_0_w_loop:
        mov     eax,[ecx+esi*4]                 ;load pattern for this scan
        mov     [edi],al                        ;write the low byte
        inc     esi                             ;advance to next scan of pattern
        and     esi,7
        add     edi,edx                         ;advance to next scan

        dec     ebx
        jnz     short dual_right_0_w_loop

; get ready for next time:

        mov     ecx,ppdev
        sub     edi,[ecx].pdev_pvBitmapStart
        mov     ulRightDest,edi

        PLAIN_RET

;=======================================================================;
;========================= ROP Block Drawers ===========================;
;=======================================================================;

;-----------------------------------------------------------------------;
; dual_wide_11_rw
;
; Draws middle words with 1 leading byte and 1 trailing byte.
;
; Input:
;     ppdev         - pointer to physical device structure
;     ulBlockHeight - # of scans to draw
;     lMiddleDelta  - distance from end of current scan to start of next
;     ulMiddleDest  - offset in bitmap at which to start drawing
;     yBrush        - current y brush alignment
;     cwMiddle      - # of words to draw on each scan
;
; Output:
;     esi           - new y brush alignment
;     ulMiddleDest  - new bitmap offset
;-----------------------------------------------------------------------;

        public  dual_wide_11_rw
dual_wide_11_rw::

; We only have to reset which planes are enabled if we do edges too:

        mov     edx,VGA_BASE + SEQ_DATA
        mov     al,MM_ALL
        out     dx,al

        mov     edi,ppdev

        mov     edx,ulBlockHeight
        mov     ulBlockHeightTmp,edx
        mov     edx,pulPattern                  ;load those registers

        mov     edi,[edi].pdev_pvBitmapStart
        add     edi,ulMiddleDest
        mov     esi,yBrush
        mov     ebx,cwMiddle

        mov     eax,[edx+esi*4]                 ;load pattern for this scan
        inc     esi
        and     esi,7

;  EAX = pattern for this scan
;  EBX = count of loop iterations
;  EDX = pointer to start of pattern
;  ESI = current offset into pattern
;  EDI = target address to which to write

dual_wide_11_rw_loop:
        and     [edi],ah
        and     [edi+1],al
        add     edi,2                           ;the write will overlap this

        dec     ebx
        jnz     short dual_wide_11_rw_loop

        add     edi,lMiddleDelta
        dec     ulBlockHeightTmp
        jz      short dual_wide_11_rw_done

        mov     eax,[edx+esi*4]                 ;load pattern for this scan
        inc     esi
        and     esi,7

        mov     ebx,cwMiddle
        jmp     dual_wide_11_rw_loop

dual_wide_11_rw_done:
        mov     ecx,ppdev
        sub     edi,[ecx].pdev_pvBitmapStart
        mov     ulMiddleDest,edi

        PLAIN_RET

;-----------------------------------------------------------------------;
; dual_wide_10_rw
;
; Draws middle words with 1 leading byte and 0 trailing bytes.
;
; Input:
;     ppdev         - pointer to physical device structure
;     ulBlockHeight - # of scans to draw
;     lMiddleDelta  - distance from end of current scan to start of next
;     ulMiddleDest  - offset in bitmap at which to start drawing
;     yBrush        - current y brush alignment
;     cwMiddle      - # of words to draw on each scan
;
; Output:
;     esi           - new y brush alignment
;     ulMiddleDest  - new bitmap offset
;-----------------------------------------------------------------------;

        public  dual_wide_10_rw
dual_wide_10_rw::

; We only have to reset which planes are enabled if we do edges too:

        mov     edx,VGA_BASE + SEQ_DATA
        mov     al,MM_ALL
        out     dx,al

        mov     edi,ppdev

        mov     edx,ulBlockHeight
        mov     ulBlockHeightTmp,edx
        mov     edx,pulPattern                  ;load those registers

        mov     edi,[edi].pdev_pvBitmapStart
        add     edi,ulMiddleDest
        mov     esi,yBrush
        mov     ebx,cwMiddle

        mov     eax,[edx+esi*4]                 ;load pattern for this scan
        inc     esi
        and     esi,7

        or      ebx,ebx                         ;have to watch for zero words
        jz      short dual_wide_10_rw_only_one_byte

        mov     pfnLoopTop,offset dual_wide_10_rw_loop

;  EAX = pattern for this scan
;  EBX = count of loop iterations
;  EDX = pointer to start of pattern
;  ESI = current offset into pattern
;  EDI = target address to which to write

dual_wide_10_rw_loop:
        and     [edi],ah
        and     [edi+1],al
        add     edi,2                           ;the write will overlap this

        dec     ebx
        jnz     short dual_wide_10_rw_loop

dual_wide_10_rw_odd_byte:
        and     [edi],ah                        ;write that odd byte

        add     edi,lMiddleDelta
        dec     ulBlockHeightTmp
        jz      short dual_wide_10_rw_done

        mov     eax,[edx+esi*4]                 ;load pattern for this scan
        inc     esi
        and     esi,7

        mov     ebx,cwMiddle
        jmp     pfnLoopTop

dual_wide_10_rw_only_one_byte:
        mov     pfnLoopTop,offset dual_wide_10_rw_odd_byte
        jmp     short dual_wide_10_rw_odd_byte

dual_wide_10_rw_done:
        mov     ecx,ppdev
        sub     edi,[ecx].pdev_pvBitmapStart
        mov     ulMiddleDest,edi

        PLAIN_RET

;-----------------------------------------------------------------------;
; dual_wide_01_rw
;
; Draws middle words with 0 leading bytes and 1 trailing byte.
;
; Input:
;     ppdev         - pointer to physical device structure
;     ulBlockHeight - # of scans to draw
;     lMiddleDelta  - distance from end of current scan to start of next
;     ulMiddleDest  - offset in bitmap at which to start drawing
;     yBrush        - current y brush alignment
;     cwMiddle      - # of words to draw on each scan
;
; Output:
;     esi           - new y brush alignment
;     ulMiddleDest  - new bitmap offset
;-----------------------------------------------------------------------;

        public  dual_wide_01_rw
dual_wide_01_rw::

; We only have to reset which planes are enabled if we do edges too:

        mov     edx,VGA_BASE + SEQ_DATA
        mov     al,MM_ALL
        out     dx,al

        mov     edi,ppdev

        mov     edx,ulBlockHeight
        mov     ulBlockHeightTmp,edx
        mov     edx,pulPattern                  ;load those registers

        mov     edi,[edi].pdev_pvBitmapStart
        add     edi,ulMiddleDest
        mov     esi,yBrush
        mov     ebx,cwMiddle

        mov     eax,[edx+esi*4]                 ;load pattern for this scan
        inc     esi
        and     esi,7

        or      ebx,ebx
        jz      short dual_wide_01_rw_only_one_byte

        mov     pfnLoopTop,offset dual_wide_01_rw_loop

;  EAX = pattern for this scan
;  EBX = count of loop iterations
;  EDX = pointer to start of pattern
;  ESI = current offset into pattern
;  EDI = target address to which to write

dual_wide_01_rw_loop:
        and     [edi],al
        and     [edi+1],ah
        add     edi,2                           ;the write will overlap this

        dec     ebx
        jnz     short dual_wide_01_rw_loop

dual_wide_01_rw_odd_byte:
        and     [edi],al                        ;write that odd byte

        add     edi,lMiddleDelta
        dec     ulBlockHeightTmp
        jz      short dual_wide_01_rw_done

        mov     eax,[edx+esi*4]                 ;load pattern for this scan
        inc     esi
        and     esi,7

        mov     ebx,cwMiddle
        jmp     pfnLoopTop

dual_wide_01_rw_only_one_byte:
        mov     pfnLoopTop,offset dual_wide_01_rw_odd_byte
        jmp     short dual_wide_01_rw_odd_byte

dual_wide_01_rw_done:
        mov     ecx,ppdev
        sub     edi,[ecx].pdev_pvBitmapStart
        mov     ulMiddleDest,edi

        PLAIN_RET

;-----------------------------------------------------------------------;
; dual_wide_00_rw
;
; Draws middle words with 0 leading bytes and 0 trailing bytes.
;
; Input:
;     ppdev         - pointer to physical device structure
;     ulBlockHeight - # of scans to draw
;     lMiddleDelta  - distance from end of current scan to start of next
;     ulMiddleDest  - offset in bitmap at which to start drawing
;     yBrush        - current y brush alignment
;     cwMiddle      - # of words to draw on each scan
;
; Output:
;     esi           - new y brush alignment
;     ulMiddleDest  - new bitmap offset
;-----------------------------------------------------------------------;

        public  dual_wide_00_rw
dual_wide_00_rw::

; We only have to reset which planes are enabled if we do edges too:

        mov     edx,VGA_BASE + SEQ_DATA
        mov     al,MM_ALL
        out     dx,al

        mov     edi,ppdev

        mov     edx,ulBlockHeight
        mov     ulBlockHeightTmp,edx
        mov     edx,pulPattern                  ;load those registers

        mov     edi,[edi].pdev_pvBitmapStart
        add     edi,ulMiddleDest
        mov     esi,yBrush
dual_wide_00_rw_scan_loop:
        mov     ebx,cwMiddle
        mov     eax,[edx+esi*4]                 ;load pattern for this scan
        inc     esi
        and     esi,7

;  EAX = pattern for this scan
;  EBX = count of loop iterations
;  EDX = pointer to start of pattern
;  ESI = current offset into pattern
;  EDI = target address to which to write

dual_wide_00_rw_loop:
        and     [edi],al
        and     [edi+1],ah
        add     edi,2                           ;the write will overlap this

        dec     ebx
        jnz     short dual_wide_00_rw_loop

        add     edi,lMiddleDelta
        dec     ulBlockHeightTmp
        jnz     dual_wide_00_rw_scan_loop

        mov     ecx,ppdev
        sub     edi,[ecx].pdev_pvBitmapStart
        mov     ulMiddleDest,edi

        PLAIN_RET

;-----------------------------------------------------------------------;
; dual_left_1_rw
;
; Draws a left edge when the next byte is not word aligned.
;
; Input:
;     ppdev         - pointer to physical device structure
;     ulBlockHeight - # of scans to draw
;     lDelta        - distance from end of current scan to start of next
;     ulLeftDest    - offset in bitmap at which to start drawing
;     yBrush        - current y brush alignment
;
; Output:
;     esi           - new y brush alignment
;     ulLeftDest    - new bitmap offset
;-----------------------------------------------------------------------;

        public  dual_left_1_rw
dual_left_1_rw::

; Set left mask by disabling some planes:

        mov     edx,VGA_BASE + SEQ_DATA
        mov     eax,ulLeftMask
        out     dx,al

; Calculate full start addresses:

        mov     edi,ppdev
        mov     ebx,ulBlockHeight
        mov     ecx,pulPattern
        mov     edx,lDelta
        mov     esi,yBrush
        mov     edi,[edi].pdev_pvBitmapStart
        add     edi,ulLeftDest

;  EBX = count of loop iterations
;  ECX = pointer to start of pattern
;  EDX = offset to next scan
;  ESI = current offset into pattern
;  EDI = target address to which to write

dual_left_1_rw_loop:
        mov     eax,[ecx+esi*4]                 ;load pattern for this scan
        and     [edi],al                        ;write the low byte
        inc     esi                             ;advance to next scan of pattern
        and     esi,7
        add     edi,edx                         ;advance to next scan

        dec     ebx
        jnz     short dual_left_1_rw_loop

; get ready for next time:

        mov     ecx,ppdev
        sub     edi,[ecx].pdev_pvBitmapStart
        mov     ulLeftDest,edi

        PLAIN_RET

;-----------------------------------------------------------------------;
; dual_left_0_rw
;
; Draws a left edge when the next byte is word aligned.
;
; Input:
;     ppdev         - pointer to physical device structure
;     ulBlockHeight - # of scans to draw
;     lDelta        - distance from end of current scan to start of next
;     ulLeftDest    - offset in bitmap at which to start drawing
;     yBrush        - current y brush alignment
;
; Output:
;     esi           - new y brush alignment
;     ulLeftDest    - new bitmap offset
;-----------------------------------------------------------------------;

        public  dual_left_0_rw
dual_left_0_rw::

; Set left mask by disabling some planes:

        mov     edx,VGA_BASE + SEQ_DATA
        mov     eax,ulLeftMask
        out     dx,al

; Calculate full start addresses:

        mov     edi,ppdev
        mov     ebx,ulBlockHeight
        mov     ecx,pulPattern
        mov     edx,lDelta
        mov     esi,yBrush
        mov     edi,[edi].pdev_pvBitmapStart
        add     edi,ulLeftDest

;  EBX = count of loop iterations
;  ECX = pointer to start of pattern
;  EDX = offset to next scan
;  ESI = current offset into pattern
;  EDI = target address to which to write

dual_left_0_rw_loop:
        mov     eax,[ecx+esi*4]                 ;load pattern for this scan
        and     [edi],ah                        ;write the high byte
        inc     esi                             ;advance to next scan of pattern
        and     esi,7
        add     edi,edx                         ;advance to next scan

        dec     ebx
        jnz     short dual_left_0_rw_loop

; get ready for next time:

        mov     ecx,ppdev
        sub     edi,[ecx].pdev_pvBitmapStart
        mov     ulLeftDest,edi

        PLAIN_RET

;-----------------------------------------------------------------------;
; dual_right_1_rw
;
; Draws a right edge when not word aligned.
;
; Input:
;     ppdev         - pointer to physical device structure
;     ulBlockHeight - # of scans to draw
;     lDelta        - distance from end of current scan to start of next
;     ulRightDest   - offset in bitmap at which to start drawing
;     yBrush        - current y brush alignment
;
; Output:
;     esi           - new y brush alignment
;     ulRightDest   - new bitmap offset
;-----------------------------------------------------------------------;

        public  dual_right_1_rw
dual_right_1_rw::

; Set right mask by disabling some planes:

        mov     edx,VGA_BASE + SEQ_DATA
        mov     eax,ulRightMask
        out     dx,al

; Calculate full start addresses:

        mov     edi,ppdev
        mov     ebx,ulBlockHeight
        mov     ecx,pulPattern
        mov     edx,lDelta
        mov     esi,yBrush
        mov     edi,[edi].pdev_pvBitmapStart
        add     edi,ulRightDest

;  EBX = count of loop iterations
;  ECX = pointer to start of pattern
;  EDX = offset to next scan
;  ESI = current offset into pattern
;  EDI = target address to which to write

dual_right_1_rw_loop:
        mov     eax,[ecx+esi*4]                 ;load pattern for this scan
        and     [edi],ah                        ;write the high byte
        inc     esi                             ;advance to next scan of pattern
        and     esi,7
        add     edi,edx                         ;advance to next scan

        dec     ebx
        jnz     short dual_right_1_rw_loop

; get ready for next time:

        mov     ecx,ppdev
        sub     edi,[ecx].pdev_pvBitmapStart
        mov     ulRightDest,edi

        PLAIN_RET

;-----------------------------------------------------------------------;
; dual_right_0_rw
;
; Draws a right edge when word aligned.
;
; Input:
;     ppdev         - pointer to physical device structure
;     ulBlockHeight - # of scans to draw
;     lDelta        - distance from end of current scan to start of next
;     ulRightDest   - offset in bitmap at which to start drawing
;     yBrush        - current y brush alignment
;
; Output:
;     esi           - new y brush alignment
;     ulRightDest   - new bitmap offset
;-----------------------------------------------------------------------;

        public  dual_right_0_rw
dual_right_0_rw::

; Set right mask by disabling some planes:

        mov     edx,VGA_BASE + SEQ_DATA
        mov     eax,ulRightMask
        out     dx,al

; Calculate full start addresses:

        mov     edi,ppdev
        mov     ebx,ulBlockHeight
        mov     ecx,pulPattern
        mov     edx,lDelta
        mov     esi,yBrush
        mov     edi,[edi].pdev_pvBitmapStart
        add     edi,ulRightDest

;  EBX = count of loop iterations
;  ECX = pointer to start of pattern
;  EDX = offset to next scan
;  ESI = current offset into pattern
;  EDI = target address to which to write

dual_right_0_rw_loop:
        mov     eax,[ecx+esi*4]                 ;load pattern for this scan
        and     [edi],al                        ;write the low byte
        inc     esi                             ;advance to next scan of pattern
        and     esi,7
        add     edi,edx                         ;advance to next scan

        dec     ebx
        jnz     short dual_right_0_rw_loop

; get ready for next time:

        mov     ecx,ppdev
        sub     edi,[ecx].pdev_pvBitmapStart
        mov     ulRightDest,edi

        PLAIN_RET

;-----------------------------------------------------------------------;

endProc vMonoPat

;-----------------------------------------------------------------------;
; BOOL b2ColorBrush(pjBits, pjFgColor, pjBkColor)
;
; Determines if the 8x8x8bpp packed brush pointed to by pjBits has only
; two colors, and if so returns the 1bpp bitmap.
;
; Returns:
;       eax        = 1 if two (or one) color brush, 0 otherwise
;       pjBits     = pointer to packed 1bpp bitmap if a 2-color brush
;       *pjFgColor = foreground color for returned 1bpp bitmap (i.e.,
;                       used to color-expand '1' bits)
;       *pjBkColor = backgroun color for returned 1bpp bitmap (i.e.,
;                       used to color-expand '0' bits)
;-----------------------------------------------------------------------;

cProc   b2ColorBrush,12,<     \
        uses esi edi ebx,     \
        pjBits:    ptr BYTE,  \
        pjFgColor: ptr BYTE,  \
        pjBkColor: ptr BYTE   >

; al = first color
; ah = second color
; ecx = number of unrolled loops

        mov     esi,pjBits
        mov     ecx,(BRUSH_SIZE shr 1)
        mov     al,[esi]

b2col_find_2nd_color_loop:
        mov     ah,[esi+1]
        cmp     ah,al
        jne     short b2col_find_consecutive_2nd_color_loop_part_1

        add     esi,2
        dec     ecx
        jz      short b2col_is_2_colors ;actually, it's only one color

        mov     ah,[esi]
        cmp     ah,al
        jne     short b2col_find_consecutive_2nd_color_loop_part_2
        jmp     short b2col_find_2nd_color_loop

;------------------------------------;

b2col_find_consecutive_1st_color_loop_part_1:
        add     esi,2
        dec     ecx
        jz      short b2col_is_2_colors

        mov     bl,[esi]
        cmp     bl,ah
        je      short b2col_find_consecutive_2nd_color_loop_part_2
        cmp     bl,al
        jne     short b2col_isnt_2_colors

b2col_find_consecutive_1st_color_loop_part_2:
        mov     bl,[esi+1]
        cmp     bl,ah
        je      short b2col_find_consecutive_2nd_color_loop_part_1
        cmp     bl,al
        je      short b2col_find_consecutive_1st_color_loop_part_1

        xor     eax,eax
        cRet    b2ColorBrush            ;return FALSE

;------------------------------------;

b2col_find_consecutive_2nd_color_loop_part_1:
        add     esi,2
        dec     ecx
        jz      short b2col_is_2_colors

        mov     bl,[esi]
        cmp     bl,al
        je      short b2col_find_consecutive_1st_color_loop_part_2
        cmp     bl,ah
        jne     short b2col_isnt_2_colors

b2col_find_consecutive_2nd_color_loop_part_2:
        mov     bl,[esi+1]
        cmp     bl,al
        je      short b2col_find_consecutive_1st_color_loop_part_1
        cmp     bl,ah
        je      short b2col_find_consecutive_2nd_color_loop_part_1

b2col_isnt_2_colors:
        xor     eax,eax
        cRet    b2ColorBrush            ;return FALSE

;------------------------------------;

        public  b2col_is_2_colors
b2col_is_2_colors::

; Here, we want the color with the lesser value to be in 'al', and the
; other to be in 'ah'.

        cmp     al,ah
        jb      short b2col_ordered_colors
        xchg    al,ah

b2col_ordered_colors:
        mov     ecx,(BRUSH_SIZE shr 3)
        mov     esi,pjBits
        mov     edi,esi

; Colors matching 'al' will get mapped to '1' bits, and colors matching
; 'ah' will get mapped to '0' bits:

b2col_monochrome_bitmap_loop:
        cmp     [esi+7],ah
        adc     bl,bl
        cmp     [esi+6],ah
        adc     bl,bl
        cmp     [esi+5],ah
        adc     bl,bl
        cmp     [esi+4],ah
        adc     bl,bl
        cmp     [esi+3],ah
        adc     bl,bl
        cmp     [esi+2],ah
        adc     bl,bl
        cmp     [esi+1],ah
        adc     bl,bl
        cmp     [esi],ah
        adc     bl,bl

; At this point, where the 8 bytes of the bitmap were ordered 0 1 2 3 4 5 6 7,
; we've got the monochrome byte in 'bl' ordered 7 6 5 4 3 2 1 0.  We want
; the word ordered '3 2 1 0 7 6 5 4 | 7 6 5 4 3 2 1 0' where the lower 4 bits
; of every bit are the planes mask, and the upper 4 bits are ordered to
; facilitate easy rotating.
;
; The word is actually written into a dword in the destination buffer.

        mov     bh,bl
        ror     bh,4
        mov     [edi],ebx               ;save this dword of monochrome bitmap
        add     edi,4
        add     esi,8
        dec     ecx
        jnz     b2col_monochrome_bitmap_loop

; Aside: because of the way this is written, if the two colors are black
; and white (i.e., 0x00 and 0xff), the foreground color will be black (0x00),
; and the background will be white (0xff).

        mov     esi,pjFgColor
        mov     edi,pjBkColor
        mov     [esi],al                ;save foreground color
        mov     [edi],ah                ;save background color
        mov     eax,1
        cRet    b2ColorBrush

endProc b2ColorBrush

        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\vga\disp\8bpp\i386\scroll.asm ===
;---------------------------Module-Header------------------------------;
; Module Name: scroll.asm
;
; Copyright (c) 1992-1993 Microsoft Corporation
;-----------------------------------------------------------------------;

;-----------------------------------------------------------------------;
; VOID vPlanarCopyBits(ppdev, prclDest, pptlSrc);
;
; Input:
;
;  ppdev    - surface on which to copy
;  prcldest - pointer to destination rectangle
;  pptlsrc  - pointer to source upper left corner
;
; Performs accelerated SRCCOPY screen-to-screen blts.
;
;-----------------------------------------------------------------------;
;
; NOTE: This handles only quad-pixel aligned blits!
;
; NOTE: Assumes all rectangles have positive heights and widths. Will
; not work properly if this is not the case.
;
;-----------------------------------------------------------------------;

        .386

        .model  small,c

        assume cs:FLAT,ds:FLAT,es:FLAT,ss:FLAT
        assume fs:nothing,gs:nothing

        .xlist
        include stdcall.inc             ;calling convention cmacros
        include i386\strucs.inc
        include i386\driver.inc
        include i386\egavga.inc

        .list

;-----------------------------------------------------------------------;

        .data

; Bits for block copier tables:

BLOCK_RIGHT_TO_LEFT     equ 4
BLOCK_LEFT_EDGE         equ 2
BLOCK_RIGHT_EDGE        equ 1

;-----------------------------------------------------------------------;
; Table of block copiers for various horizontal directions, with the
; look-up index a 3-bit field as follows:
;
; Bit 2 (BLOCK_RIGHT_TO_LEFT) = 1 if right-to-left copy
; Bit 1 (BLOCK_LEFT_EDGE)     = 1 if left edge must be copied
; Bit 0 (BLOCK_RIGHT_EDGE)    = 1 if right edge must be copied

        align   4
MasterBlockTable label dword

        dd      copy_just_middle_block
        dd      Block_WR
        dd      Block_LW
        dd      Block_LWR

        dd      copy_just_middle_block
        dd      Block_RW
        dd      Block_WL
        dd      Block_RWL

        align   4
TopToBottomLoopTable label dword
        dd      0                               ;Not used - unbanked case
        dd      top_to_bottom_1RW
        dd      top_to_bottom_2RW
        dd      top_to_bottom_2RW

        align   4
BottomToTopLoopTable label dword
        dd      0                               ;Not used - unbanked case
        dd      bottom_to_top_1RW
        dd      bottom_to_top_2RW
        dd      bottom_to_top_2RW

        align   4
SetUpForCopyDirection label dword
        dd      left_to_right_top_to_bottom     ;CD_RIGHTDOWN
        dd      right_to_left_top_to_bottom     ;CD_LEFTDOWN
        dd      left_to_right_bottom_to_top     ;CD_RIGHTUP
        dd      right_to_left_bottom_to_top     ;CD_LEFTUP

LeftMaskTable label dword
        dd      01111b
        dd      01110b
        dd      01100b
        dd      01000b

RightMaskTable label dword
        dd      00000b
        dd      00001b
        dd      00011b
        dd      00111b

;-----------------------------------------------------------------------;

        .code

        EXTRNP  bPuntScreenToScreenCopyBits,20

Block_WR:
        push    offset copy_right_block
        jmp     copy_middle_block

Block_LW:
        push    offset copy_middle_block
        jmp     copy_left_block

Block_LWR:
        push    offset copy_right_block
        push    offset copy_middle_block
        jmp     copy_left_block

Block_RW:
        push    offset copy_middle_block
        jmp     copy_right_block

Block_WL:
        push    offset copy_left_block
        jmp     copy_middle_block

Block_RWL:
        push    offset copy_left_block
        push    offset copy_middle_block
        jmp     copy_right_block

;-----------------------------------------------------------------------;

cProc   vPlanarCopyBits,12,<    \
        uses esi edi ebx,       \
        ppdev:    ptr PDEV,     \
        prclDest: ptr RECTL,    \
        pptlSrc:  ptr POINTL    >

; Variables used in block copiers:

        local pfnCopyBlocks:       ptr   ;pointer to block copy routines

        local ulMiddleSrc:         dword ;bitmap offset to 1st source
        local ulMiddleDest:        dword ;bitmap offset to 1st dest
        local lMiddleDelta:        dword ;delta from end of middle scan to next
        local ulBlockHeight:       dword ;number of scans to be copied in block
        local cjMiddle:            dword ;number of bytes to be copied on scan

        local ulLeftSrc:           dword ;bitmap offset to left source byte edge
        local ulLeftDest:          dword ;bitmap offset to left dest byte edge
        local ulRightSrc:          dword ;bitmap offset to right source byte edge
        local ulRightDest:         dword ;bitmap offset to right dest byte edge
        local lDelta:              dword ;delta between scans

        local ulLeftMask:          dword ;byte mask for left-edge copies
        local ulRightMask:         dword ;byte mask for right-edge copies

        local rclDest[size RECTL]: byte  ;left and right values always valid
        local ptlSrc[size POINTL]: byte  ;x value always valid

        local ulCurrentSrcScan:    dword ;real current source scan
        local ulCurrentDestScan:   dword ;real current destination scan
        local ulLastDestScan:      dword ;last destination scan

; Set the bit mask to disable all bits, so we can copy through the latches:

        mov     edx,VGA_BASE + GRAF_ADDR
        mov     eax,(0 shl 8) + GRAF_BIT_MASK
        out     dx,ax

; Figure out which direction to do the copies:

        mov     esi,pptlSrc
        mov     edi,prclDest
        mov     eax,[esi].ptl_y
        cmp     eax,[edi].yTop
        jl      planar_bottom_to_top

        mov     eax,[esi].ptl_x
        cmp     eax,[edi].xLeft
        jge     short left_to_right_top_to_bottom       ; CD_RIGHTDOWN
        jmp     right_to_left_top_to_bottom             ; CD_LEFTDOWN

planar_bottom_to_top:
        mov     eax,[esi].ptl_x
        cmp     eax,[edi].xLeft
        jge     left_to_right_bottom_to_top             ; CD_RIGHTUP
        jmp     right_to_left_bottom_to_top             ; CD_LEFTUP

all_done:

; Enable bit mask for all bits:

        mov     edx,VGA_BASE + GRAF_ADDR
        mov     eax,(0ffh shl 8) + GRAF_BIT_MASK
        out     dx,ax

; Enable writes to all planes and reset direction flag:

        mov     edx,VGA_BASE + SEQ_DATA
        mov     al,MM_ALL
        out     dx,al

        cld

        cRet    vPlanarCopyBits

;=======================================================================;
;==================== Direction Dependent Setup ========================;
;=======================================================================;

;-----------------------------------------------------------------------;
; Set-up code for left-to-right, top-to-bottom copies.
;
; Input:
;       esi - pptlSrc
;       edi - prclDest
;-----------------------------------------------------------------------;

        public left_to_right_top_to_bottom
left_to_right_top_to_bottom::

; Need to set-up: ulMiddleSrc, ulMiddleDest, lMiddleDelta, cjMiddle
;                 ulLeftSrc, ulLeftDest, ulLeftMask
;                 lDelta
;                 ulRightSrc, ulRightDest, ulRightMask
;                 ulCurrentDestScan, ulLastDestScan
;                 pfnCopyBlocks
;                 ptlSrc.x, rclDest.left, rclDest.right

; lDelta = ppdev->lPlanarScan
; ulCurrentSrcScan  = pptl->y
; ulLeftSrc         = pptl->y       * lDelta + (pptl->x >> 2)
; ulCurrentDestScan = prclDest->top
; ulLeftDest        = prclDest->top * lDelta + (prclDest->left >> 2)
;
; ulMiddleSrc  = ulLeftSrc
; ulMiddleDest = ulLeftDest
;
; cjMiddle = (prclDest->right >> 2) - (prclDest->left >> 2)
; if (prclDest->left & 3)
;     ulLeftMask = LeftMaskTable[prclDest->left & 3]
;     fl |= BLOCK_LEFT_EDGE
;     ulMiddleSrc++
;     ulMiddleDest++
;     cjMiddle--
;
; lMiddleDelta = lDelta - cjMiddle
;
; if (prclDest->right & 3)
;     ulRightMask = RightMaskTable[prclDest->right & 3]
;     fl |= BLOCK_RIGHT_EDGE
;     ulRightSrc  = ulMiddleSrc  + cjMiddle
;     ulRightDest = ulMiddleDest + cjMiddle

        mov     edx,ppdev
        mov     eax,[edi].yBottom
        mov     edx,[edx].pdev_lPlanarNextScan ;edx = lDelta
        mov     ulLastDestScan,eax      ;ulLastDestScan = prclDest->bottom

        mov     ecx,[esi].ptl_y
        mov     eax,edx
        mov     ulCurrentSrcScan,ecx    ;ulCurrentSrcScan = pptlSrc->y
        imul    eax,ecx
        mov     ecx,[esi].ptl_x
        mov     ptlSrc.ptl_x,ecx        ;ptlSrc.x = pptlSrc->x
        shr     ecx,2
        add     eax,ecx                 ;eax = ulLeftSrc = pptlSrc->y *
                                        ;  lDelta + (pptlSrc->x >> 2)

        xor     esi,esi                 ;initialize flags

        mov     ecx,[edi].yTop
        mov     ebx,edx
        mov     ulCurrentDestScan,ecx   ;ulCurrentDestScan = prclDest->top
        imul    ebx,ecx
        mov     ecx,[edi].xLeft
        mov     rclDest.xLeft,ecx       ;rclDest.left = prclDest->left
        shr     ecx,2
        add     ebx,ecx                 ;ebx = ulLeftDest = prclDest->top *
                                        ;  lDelta + (prclDest->left >> 2)

        mov     edi,[edi].xRight
        mov     rclDest.xRight,edi
        shr     edi,2
        sub     edi,ecx                 ;cjMiddle = (prclDest->right >> 2) -
                                        ;  (prclDest->left >> 2)

        mov     ecx,rclDest.xLeft
        and     ecx,3
        jz      short l_t_done_left_edge ;skip if we don't need a left edge

        or      esi,BLOCK_LEFT_EDGE
        mov     ecx,LeftMaskTable[ecx*4]
        mov     ulLeftMask,ecx          ;ulLeftMask =
                                        ;  LeftMaskTable[prclDest->left & 3]

        mov     ulLeftSrc,eax           ;ulLeftSrc
        mov     ulLeftDest,ebx          ;ulLeftDest
        inc     eax
        inc     ebx
        dec     edi

l_t_done_left_edge:
        mov     ulMiddleSrc,eax         ;ulMiddleSrc
        mov     ulMiddleDest,ebx        ;ulMiddleDest

        mov     ecx,rclDest.xRight
        and     ecx,3
        jz      short l_t_done_right_edge ;skip if we don't need a right edge

        or      esi,BLOCK_RIGHT_EDGE
        mov     ecx,RightMaskTable[ecx*4]
        mov     ulRightMask,ecx         ;ulRightMask =
                                        ;  RightMaskTable[prclDest->right & 3]

        add     eax,edi
        add     ebx,edi
        mov     ulRightSrc,eax          ;ulRightSrc = ulMiddleSrc + cjMiddle
        mov     ulRightDest,ebx         ;ulRightDest = ulMiddleDest + cjMiddle

; We special case here blits that are less than 4 pels wide and begin and end
; in the same 4-pel quadruple:

        cmp     edi,0
        jge     l_t_done_right_edge

; We make sure the 'middle' count of bytes is zero (we'll just let the code
; fall through the 'middle' copy code), turn off the right-edge flag, and
; give ulLeftMask the composite mask:

        inc     edi
        xor     esi,BLOCK_RIGHT_EDGE
        and     ecx,ulLeftMask
        mov     ulLeftMask,ecx

l_t_done_right_edge:
        mov     cjMiddle,edi            ;cjMiddle

        mov     lDelta,edx              ;lDelta = ppdev->lPlanarNextScan
        sub     edx,edi
        mov     lMiddleDelta,edx        ;lMiddleDelta = lDelta - cjMiddle

        mov     ebx,ppdev
        mov     eax,MasterBlockTable[esi*4]
        mov     pfnCopyBlocks,eax       ;copy blocks between video memory

; Branch to the appropriate top-to-bottom bank enumeration loop:

        mov     eax,[ebx].pdev_vbtPlanarType
        jmp     TopToBottomLoopTable[eax*4]

;-----------------------------------------------------------------------;
; Set-up code for right-to-left, top-to-bottom copies.
;
; Input:
;       esi - pptlSrc
;       edi - prclDest
;-----------------------------------------------------------------------;

        public right_to_left_top_to_bottom
right_to_left_top_to_bottom::

        std                             ;copy middle blocks right-to-left

        mov     edx,ppdev
        mov     eax,[edi].yBottom
        mov     edx,[edx].pdev_lPlanarNextScan ;edx = lDelta
        mov     ulLastDestScan,eax      ;ulLastDestScan = prclDest->bottom

        mov     ecx,[esi].ptl_y
        mov     eax,edx
        mov     ulCurrentSrcScan,ecx    ;ulCurrentSrcScan = pptlSrc->y
        imul    eax,ecx
        mov     ecx,[esi].ptl_x
        mov     ptlSrc.ptl_x,ecx        ;ptlSrc.x = pptlSrc->x
        add     ecx,[edi].xRight
        sub     ecx,[edi].xLeft
        shr     ecx,2
        add     eax,ecx                 ;eax = ulRightSrc = pptlSrc->y *
                                        ; lDelta + (pptlSrc->x +
                                        ; prclDest->right - prclDest->left) / 4

        mov     esi,BLOCK_RIGHT_TO_LEFT ;initialize flags

        mov     ecx,[edi].yTop
        mov     ebx,edx
        mov     ulCurrentDestScan,ecx   ;ulCurrentDestScan = prclDest->top
        imul    ebx,ecx
        mov     ecx,[edi].xRight
        mov     rclDest.xRight,ecx      ;rclDest.right = prclDest->right
        shr     ecx,2
        add     ebx,ecx                 ;ebx = ulRightDest = prclDest->top *
                                        ; lDelta + prclDest->right / 4

        mov     edi,[edi].xLeft
        mov     rclDest.xLeft,edi
        shr     edi,2
        neg     edi
        add     edi,ecx                 ;cjMiddle = prclDest->right / 4 -
                                        ;  prclDest->left / 4

        mov     ecx,rclDest.xRight
        and     ecx,3
        jz      short r_t_done_right_edge ;skip if we don't need a right edge

        or      esi,BLOCK_RIGHT_EDGE
        mov     ecx,RightMaskTable[ecx*4]
        mov     ulRightMask,ecx         ;ulRightMask =
                                        ;  RightMaskTable[prclDest->right & 3]

        mov     ulRightSrc,eax          ;ulRightSrc
        mov     ulRightDest,ebx         ;ulRightDest

r_t_done_right_edge:
        dec     eax
        dec     ebx
        mov     ulMiddleSrc,eax         ;ulMiddleSrc
        mov     ulMiddleDest,ebx        ;ulMiddleDest

        mov     ecx,rclDest.xLeft
        and     ecx,3
        jz      short r_t_done_left_edge ;skip if we don't need a right edge
        or      esi,BLOCK_LEFT_EDGE
        mov     ecx,LeftMaskTable[ecx*4]
        mov     ulLeftMask,ecx          ;ulLeftMask =
                                        ;  LeftMaskTable[prclDest->left & 3]

        dec     edi                     ;adjust middle block length because
                                        ;  we're effectively doing one less
                                        ;  middle byte

        sub     eax,edi
        sub     ebx,edi
        mov     ulLeftSrc,eax           ;ulLeftSrc = ulMiddleSrc - cjMiddle
        mov     ulLeftDest,ebx          ;ulLeftDest = ulMiddleDest - cjMiddle

; We special case here blits that are less than 4 pels wide and begin and end
; in the same 4-pel quadruple:

        cmp     edi,0
        jge     r_t_done_left_edge

; We make sure the 'middle' count of bytes is zero (we'll just let the code
; fall through the 'middle' copy code), turn off the right-edge flag, and
; give ulRightMask the composite mask:

        inc     edi
        xor     esi,BLOCK_LEFT_EDGE
        and     ecx,ulRightMask
        mov     ulRightMask,ecx

r_t_done_left_edge:
        mov     cjMiddle,edi            ;cjMiddle

        mov     lDelta,edx              ;lDelta = ppdev->lPlanarNextScan
        add     edx,edi
        mov     lMiddleDelta,edx        ;lMiddleDelta = lDelta + cjMiddle

        mov     ebx,ppdev
        mov     eax,MasterBlockTable[esi*4]
        mov     pfnCopyBlocks,eax       ;copy blocks between video memory

; Branch to the appropriate top-to-bottom bank enumeration loop:

        mov     eax,[ebx].pdev_vbtPlanarType
        jmp     TopToBottomLoopTable[eax*4]

;-----------------------------------------------------------------------;
; Set-up code for left-to-right, bottom-to-top copies.
;
; Input:
;       esi - pptlSrc
;       edi - prclDest
;-----------------------------------------------------------------------;

        public left_to_right_bottom_to_top
left_to_right_bottom_to_top::

        mov     edx,ppdev
        mov     eax,[edi].yTop
        mov     edx,[edx].pdev_lPlanarNextScan ;edx = lDelta
        mov     ulLastDestScan,eax      ;ulLastDestScan = prclDest->top

        mov     ecx,[esi].ptl_y
        add     ecx,[edi].yBottom
        sub     ecx,[edi].yTop
        mov     eax,edx
        mov     ulCurrentSrcScan,ecx    ;ulCurrentSrcScan = pptlSrc->y +
                                        ;  (prclDest->bottom - prclDest->top)
        dec     ecx
        imul    eax,ecx
        mov     ecx,[esi].ptl_x
        mov     ptlSrc.ptl_x,ecx        ;ptlSrc.x = pptlSrc->x
        shr     ecx,2
        add     eax,ecx                 ;eax = ulLeftSrc = (ulCurrentSrcScan - 1)
                                        ;  * lDelta + (pptlSrc->x >> 2)

        xor     esi,esi                 ;initialize flags

        mov     ecx,[edi].yBottom
        mov     ebx,edx
        mov     ulCurrentDestScan,ecx   ;ulCurrentDestScan = prclDest->bottom
        dec     ecx
        imul    ebx,ecx
        mov     ecx,[edi].xLeft
        mov     rclDest.xLeft,ecx       ;rclDest.left = prclDest->left
        shr     ecx,2
        add     ebx,ecx                 ;ebx = ulLeftDest = (prclDest->bottom - 1)
                                        ;  * lDelta + (prclDest->left >> 2)

        mov     edi,[edi].xRight
        mov     rclDest.xRight,edi
        shr     edi,2
        sub     edi,ecx                 ;cjMiddle = (prclDest->right >> 2) -
                                        ;  (prclDest->left >> 2)

        mov     ecx,rclDest.xLeft
        and     ecx,3
        jz      short l_b_done_left_edge ;skip if we don't need a left edge

        or      esi,BLOCK_LEFT_EDGE
        mov     ecx,LeftMaskTable[ecx*4]
        mov     ulLeftMask,ecx          ;ulLeftMask =
                                        ;  LeftMaskTable[prclDest->left & 3]

        mov     ulLeftSrc,eax           ;ulLeftSrc
        mov     ulLeftDest,ebx          ;ulLeftDest
        inc     eax
        inc     ebx
        dec     edi

l_b_done_left_edge:
        mov     ulMiddleSrc,eax         ;ulMiddleSrc
        mov     ulMiddleDest,ebx        ;ulMiddleDest

        mov     ecx,rclDest.xRight
        and     ecx,3
        jz      short l_b_done_right_edge ;skip if we don't need a right edge

        or      esi,BLOCK_RIGHT_EDGE
        mov     ecx,RightMaskTable[ecx*4]
        mov     ulRightMask,ecx         ;ulRightMask =
                                        ;  RightMaskTable[prclDest->right & 3]

        add     eax,edi
        add     ebx,edi
        mov     ulRightSrc,eax          ;ulRightSrc = ulMiddleSrc + cjMiddle
        mov     ulRightDest,ebx         ;ulRightDest = ulMiddleDest + cjMiddle

; We special case here blits that are less than 4 pels wide and begin and end
; in the same 4-pel quadruple:

        cmp     edi,0
        jge     l_b_done_right_edge

; We make sure the 'middle' count of bytes is zero (we'll just let the code
; fall through the 'middle' copy code), turn off the right-edge flag, and
; give ulLeftMask the composite mask:

        inc     edi
        xor     esi,BLOCK_RIGHT_EDGE
        and     ecx,ulLeftMask
        mov     ulLeftMask,ecx

l_b_done_right_edge:
        mov     cjMiddle,edi            ;cjMiddle

        neg     edx
        mov     lDelta,edx              ;lDelta = -ppdev->lPlanarNextScan
        sub     edx,edi
        mov     lMiddleDelta,edx        ;lMiddleDelta = lDelta - cjMiddle

        mov     ebx,ppdev
        mov     eax,MasterBlockTable[esi*4]
        mov     pfnCopyBlocks,eax       ;copy blocks between video memory

; Branch to the appropriate top-to-bottom bank enumeration loop:

        mov     eax,[ebx].pdev_vbtPlanarType
        jmp     BottomToTopLoopTable[eax*4]

;-----------------------------------------------------------------------;
; Set-up code for right-to-left, bottom-to-top copies.
;
; Input:
;       esi - pptlSrc
;       edi - prclDest
;-----------------------------------------------------------------------;

        public right_to_left_bottom_to_top
right_to_left_bottom_to_top::

        std                             ;copy middle blocks right-to-left

        mov     edx,ppdev
        mov     eax,[edi].yTop
        mov     edx,[edx].pdev_lPlanarNextScan ;edx = lDelta
        mov     ulLastDestScan,eax      ;ulLastDestScan = prclDest->top

        mov     ecx,[esi].ptl_y
        add     ecx,[edi].yBottom
        sub     ecx,[edi].yTop
        mov     eax,edx
        mov     ulCurrentSrcScan,ecx    ;ulCurrentSrcScan = pptlSrc->y +
                                        ;  (prclDest->bottom - prclDest->top)
        dec     ecx
        imul    eax,ecx
        mov     ecx,[esi].ptl_x
        mov     ptlSrc.ptl_x,ecx        ;ptlSrc.x = pptlSrc->x
        add     ecx,[edi].xRight
        sub     ecx,[edi].xLeft
        shr     ecx,2
        add     eax,ecx                 ;eax = ulRightSrc = (ulCurrentSrcScan
                                        ; - 1) * lDelta + (pptlSrc->x +
                                        ; prclDest->right - prclDest->left) / 4

        mov     esi,BLOCK_RIGHT_TO_LEFT ;initialize flags

        mov     ecx,[edi].yBottom
        mov     ebx,edx
        mov     ulCurrentDestScan,ecx   ;ulCurrentDestScan = prclDest->bottom
        dec     ecx
        imul    ebx,ecx
        mov     ecx,[edi].xRight
        mov     rclDest.xRight,ecx      ;rclDest.right = prclDest->right
        shr     ecx,2
        add     ebx,ecx                 ;ebx = ulRightDest = (ulCurrentDestScan
                                        ; - 1) * lDelta + prclDest->right / 4

        mov     edi,[edi].xLeft
        mov     rclDest.xLeft,edi
        shr     edi,2
        neg     edi
        add     edi,ecx                 ;cjMiddle = prclDest->right / 4 -
                                        ;  prclDest->left / 4

        mov     ecx,rclDest.xRight
        and     ecx,3
        jz      short r_b_done_right_edge ;skip if we don't need a right edge

        or      esi,BLOCK_RIGHT_EDGE
        mov     ecx,RightMaskTable[ecx*4]
        mov     ulRightMask,ecx         ;ulRightMask =
                                        ;  RightMaskTable[prclDest->right & 3]

        mov     ulRightSrc,eax          ;ulRightSrc
        mov     ulRightDest,ebx         ;ulRightDest

r_b_done_right_edge:
        dec     eax
        dec     ebx
        mov     ulMiddleSrc,eax         ;ulMiddleSrc
        mov     ulMiddleDest,ebx        ;ulMiddleDest

        mov     ecx,rclDest.xLeft
        and     ecx,3
        jz      short r_b_done_left_edge ;skip if we don't need a right edge

        or      esi,BLOCK_LEFT_EDGE
        mov     ecx,LeftMaskTable[ecx*4]
        mov     ulLeftMask,ecx          ;ulLeftMask =
                                        ;  LeftMaskTable[prclDest->left & 3]

        dec     edi                     ;adjust middle block length because
                                        ;  we're effectively doing one less
                                        ;  middle byte

        sub     eax,edi
        sub     ebx,edi
        mov     ulLeftSrc,eax           ;ulLeftSrc = ulMiddleSrc - cjMiddle
        mov     ulLeftDest,ebx          ;ulLeftDest = ulMiddleDest - cjMiddle

; We special case here blits that are less than 4 pels wide and begin and end
; in the same 4-pel quadruple:

        cmp     edi,0
        jge     r_b_done_left_edge

; We make sure the 'middle' count of bytes is zero (we'll just let the code
; fall through the 'middle' copy code), turn off the right-edge flag, and
; give ulRightMask the composite mask:

        inc     edi
        xor     esi,BLOCK_LEFT_EDGE
        and     ecx,ulRightMask
        mov     ulRightMask,ecx

r_b_done_left_edge:
        mov     cjMiddle,edi            ;cjMiddle

        neg     edx
        mov     lDelta,edx              ;lDelta = -ppdev->lPlanarNextScan
        add     edx,edi
        mov     lMiddleDelta,edx        ;lMiddleDelta = lDelta + cjMiddle

        mov     ebx,ppdev
        mov     eax,MasterBlockTable[esi*4]
        mov     pfnCopyBlocks,eax       ;copy blocks between video memory

; Branch to the appropriate top-to-bottom bank enumeration loop:

        mov     eax,[ebx].pdev_vbtPlanarType
        jmp     BottomToTopLoopTable[eax*4]

;=======================================================================;
;============================= Banking =================================;
;=======================================================================;

;-----------------------------------------------------------------------;
; Banking for 1 R/W adapters, top to bottom.
;
; Input:
;       ulCurrentSrcScan
;       ulCurrentDestScan
;       ulLastDestScan
;       Plus some other stuff for split rasters and block copiers
;-----------------------------------------------------------------------;
        public  top_to_bottom_1RW
top_to_bottom_1RW::

; LATER: Should check to see if there's any chance that the source and
;     destination overlap in the same window, so that we can use planar
;     copies -- otherwise, it's faster to directly call of to
;     bPuntScreenToScreenCopyBits

; We're going top to bottom. Map in the source and dest, top-justified.

        mov     ebx,ppdev
        mov     edi,ulCurrentDestScan

        cmp     edi,[ebx].pdev_rcl1PlanarClip.yTop
        jl      short top_1RW_map_init_bank

        cmp     edi,[ebx].pdev_rcl1PlanarClip.yBottom
        jl      short top_1RW_init_bank_mapped

top_1RW_map_init_bank:

; Map bank containing the top destination scan line into window.
; Note: EBX, ESI, and EDI preserved, according to C calling conventions.

        ptrCall <dword ptr [ebx].pdev_pfnPlanarControl>, \
                <ebx,edi,JustifyTop>

top_1RW_init_bank_mapped:

        mov     eax,ulCurrentSrcScan
        cmp     eax,[ebx].pdev_rcl1PlanarClip.yBottom

        jl      short top_1RW_do_planar_copy

; ulCurrentSrcScan >= ppdev->rcl1PlanarClip.bottom, which means that
; the window can't overlap the source and destination at all.  We'll
; have to use an intermediate temporary buffer:

; ebx = ppdev
; eax = ulCurrentSrcScan
; edi = ulCurrentDestScan

        mov     ptlSrc.ptl_y,eax        ;ptlSrc.y = ulCurrentSrcScan
        mov     rclDest.yTop,edi        ;rclDest.top = ulCurrentDestScan

        mov     esi,[ebx].pdev_rcl1PlanarClip.yBottom
        mov     eax,ulLastDestScan
        sub     eax,esi
        sbb     ecx,ecx
        and     ecx,eax
        add     esi,ecx
        mov     rclDest.yBottom,esi     ;rclDest.bottom = min(ulLastDestScan,
                                        ;  ppdev->pdev_rcl1PlanarClip.bottom)

; Enable bit mask for all bits:

        mov     edx,VGA_BASE + GRAF_ADDR
        mov     eax,(0ffh shl 8) + GRAF_BIT_MASK
        out     dx,ax

; Enable writes to all planes and reset direction flag:

        mov     edx,VGA_BASE + SEQ_DATA
        mov     al,MM_ALL
        out     dx,al

        pushfd
        cld

; Call our routine that copies bits the slow way, preserving EBX, ESI and EDI
; according to C calling conventions:

        lea     ecx,rclDest
        lea     edx,ptlSrc

        cCall   bPuntScreenToScreenCopyBits,<ebx,0,0,ecx,edx>

        popfd

; Set the bit mask to disable all bits, so we can copy through latches again:

        mov     edx,VGA_BASE + GRAF_ADDR
        mov     eax,(000h shl 8) + GRAF_BIT_MASK
        out     dx,ax

; Update our position variables:

        mov     ulCurrentDestScan,esi   ;ulCurrentDestScan = rclDest.bottom

        sub     esi,edi                 ;ulBlockHeight = rclDest.bottom -
                                        ;  rclDest.top

        add     ulCurrentSrcScan,esi    ;ulCurrentSrcScan += ulBlockHeight

; We have to adjust the offsets for all our block copiers, according to the
; number of scans we copied:

        mov     edx,lDelta
        imul    edx,esi                 ;edx = lDelta * ulBlockHeight
        add     ulLeftSrc,edx
        add     ulLeftDest,edx
        add     ulMiddleSrc,edx
        add     ulMiddleDest,edx
        add     ulRightSrc,edx
        add     ulRightDest,edx

        jmp     short top_1RW_see_if_done

top_1RW_do_planar_copy:

; ebx = ppdev
; eax = ulCurrentSrcScan
; edi = ulCurrentDestScan

        mov     ebx,[ebx].pdev_rcl1PlanarClip.yBottom
        sub     ebx,eax                 ;ebx = ppdev->rcl1PlanarClip.bottom -
                                        ;  ulCurrentSrcScan
                                        ;ebx is the available number of scans
                                        ;  we have in the source

        mov     edx,ulLastDestScan
        sub     edx,edi                 ;edx = ulLastDestScan - ulCurrentDestScan
                                        ;edx is the available number of scans
                                        ;  in the destination

; (Because the source starts lower in the window than the destination,
; the bottom of the bank always limits the source number of scans before
; it does the destination.)

        sub     ebx,edx
        sbb     ecx,ecx
        and     ecx,ebx
        add     edx,ecx                 ;edx = min(source available,
                                        ;  destination available)
        mov     ulBlockHeight,edx

        add     eax,edx                 ;We have to adjust our current scans
        add     edi,edx
        mov     ulCurrentSrcScan,eax
        mov     ulCurrentDestScan,edi

; Now copy the puppy:

        call    pfnCopyBlocks

; See if we're done:

top_1RW_see_if_done:
        mov     edi,ulCurrentDestScan
        cmp     edi,ulLastDestScan
        jge     all_done

        mov     ebx,ppdev

; Map bank containing the top destination scan line into window.
; Note: EBX, ESI, and EDI preserved, according to C calling conventions.

        ptrCall <dword ptr [ebx].pdev_pfnPlanarControl>, \
                <ebx,edi,JustifyTop>

        jmp     top_1RW_init_bank_mapped

;-----------------------------------------------------------------------;
; Banking for 1 R/W adapters, bottom to top.
;
; Input:
;       ulCurrentSrcScan  - Actually, 1 more current source scan
;       ulCurrentDestScan - Actually, 1 more current destination scan
;       ulLastDestScan
;       Plus some other stuff for split rasters and block copiers
;-----------------------------------------------------------------------;
        public  bottom_to_top_1RW
bottom_to_top_1RW::

; We're going top to bottom. Map in the source and dest, top-justified.

        mov     ebx,ppdev
        mov     edi,ulCurrentDestScan

        cmp     edi,[ebx].pdev_rcl1PlanarClip.yTop
        jle     short bot_1RW_map_init_bank

        cmp     edi,[ebx].pdev_rcl1PlanarClip.yBottom
        jle     short bot_1RW_init_bank_mapped

bot_1RW_map_init_bank:

; Map bank containing the top destination scan line into window.
; Note: EBX, ESI, and EDI preserved, according to C calling conventions.

        dec     edi
        ptrCall <dword ptr [ebx].pdev_pfnPlanarControl>, \
                <ebx,edi,JustifyTop>
        inc     edi

bot_1RW_init_bank_mapped:

        mov     eax,ulCurrentSrcScan
        cmp     eax,[ebx].pdev_rcl1PlanarClip.yTop

        jg      short bot_1RW_do_planar_copy

; ulCurrentSrcScan <= ppdev->rcl1PlanarClip.top, which means that
; the window can't overlap the source and destination at all.  We'll
; have to use an intermediate temporary buffer:

; ebx = ppdev
; eax = ulCurrentSrcScan
; edi = ulCurrentDestScan

        mov     esi,[ebx].pdev_rcl1PlanarClip.yTop
        mov     edx,ulLastDestScan
        cmp     esi,edx
        jg      @F
        mov     esi,edx
@@:
        mov     rclDest.yTop,esi        ;rclDest.top = max(ulLastDestScan,
                                        ;  ppdev->rcl1PlanarClip.top)

        mov     rclDest.yBottom,edi     ;rclDest.bottom = ulCurrentDestScan
        add     eax,esi
        sub     eax,edi
        mov     ptlSrc.ptl_y,eax        ;ptlSrc.y = ulCurrentSrcScan -
                                        ;  (rclDest.bottom - rclDest.top)

; Enable bit mask for all bits:

        mov     edx,VGA_BASE + GRAF_ADDR
        mov     eax,(0ffh shl 8) + GRAF_BIT_MASK
        out     dx,ax

; Enable writes to all planes and reset direction flag:

        mov     edx,VGA_BASE + SEQ_DATA
        mov     al,MM_ALL
        out     dx,al

        pushfd
        cld

; Call our routine that copies bits the slow way, preserving EBX, ESI and EDI
; according to C calling conventions:

        lea     ecx,rclDest
        lea     edx,ptlSrc

        cCall   bPuntScreenToScreenCopyBits,<ebx,0,0,ecx,edx>

        popfd

; Set the bit mask to disable all bits, so we can copy through latches again:

        mov     edx,VGA_BASE + GRAF_ADDR
        mov     eax,(000h shl 8) + GRAF_BIT_MASK
        out     dx,ax

; Update our position variables:

        mov     ulCurrentDestScan,esi   ;ulCurrentDestScan = rclDest.top

        sub     edi,esi                 ;ulBlockHeight = rclDest.bottom -
                                        ;  rclDest.top

        sub     ulCurrentSrcScan,edi    ;ulCurrentSrcScan -= ulBlockHeight

; We have to adjust the offsets for all our block copiers, according to the
; number of scans we copied:

        mov     edx,lDelta
        imul    edx,edi                 ;edx = lDelta * ulBlockHeight
        add     ulLeftSrc,edx
        add     ulLeftDest,edx
        add     ulMiddleSrc,edx
        add     ulMiddleDest,edx
        add     ulRightSrc,edx
        add     ulRightDest,edx

        jmp     short bot_1RW_see_if_done

bot_1RW_do_planar_copy:

; ebx = ppdev
; eax = ulCurrentSrcScan
; edi = ulCurrentDestScan

        sub     eax,[ebx].pdev_rcl1PlanarClip.yTop
                                        ;eax = ulCurrentSrcScan -
                                        ;  ppdev->rcl1PlanarClip.top

        sub     edi,ulLastDestScan      ;edi = ulCurrentDestScan - ulLastDestScan
                                        ;edi is the available number of scans
                                        ;  in the destination


; (Because the source starts higher in the window than the destination,
; the bottom of the bank always limits the source number of scans before
; it does the destination.)

        sub     eax,edi
        sbb     ecx,ecx
        and     ecx,eax
        add     edi,ecx                 ;edi = min(source available,
                                        ;  destination available)

        mov     ulBlockHeight,edi

        sub     ulCurrentSrcScan,edi    ;We have to adjust our current scans
        sub     ulCurrentDestScan,edi

; Now copy the puppy:

        call    pfnCopyBlocks

; See if we're done:

bot_1RW_see_if_done:
        mov     edi,ulCurrentDestScan
        cmp     edi,ulLastDestScan
        jle     all_done

        mov     ebx,ppdev

; Map bank containing the top destination scan line into window.
; Note: EBX, ESI, and EDI preserved, according to C calling conventions.

        dec     edi
        ptrCall <dword ptr [ebx].pdev_pfnPlanarControl>, \
                <ebx,edi,JustifyTop>
        inc     edi

        jmp     bot_1RW_init_bank_mapped

;-----------------------------------------------------------------------;
; Banking for 1R/1W or 2R/W adapters, top to bottom.
;
; Input:
;       ulCurrentSrcScan
;       ulCurrentDestScan
;       ulLastDestScan
;       Plus some other stuff for split rasters and block copiers
;-----------------------------------------------------------------------;
        public  top_to_bottom_2RW
top_to_bottom_2RW::

; We're going top to bottom. Map in the destination, top-justified.

        mov     ebx,ppdev
        mov     edi,ulCurrentDestScan
        mov     esi,ulCurrentSrcScan

        cmp     edi,[ebx].pdev_rcl2PlanarClipD.yTop
        jl      short top_2RW_map_init_dest_bank

        cmp     edi,[ebx].pdev_rcl2PlanarClipD.yBottom
        jl      short top_2RW_init_dest_bank_mapped

top_2RW_map_init_dest_bank:

; Map bank containing the top destination scan line into window.
; Note: EBX, ESI, and EDI preserved, according to C calling conventions.

        ptrCall <dword ptr [ebx].pdev_pfnPlanarControl2>, \
                <ebx,edi,JustifyTop,MapDestBank>

top_2RW_init_dest_bank_mapped:

        cmp     esi,[ebx].pdev_rcl2PlanarClipS.yTop
        jl      short top_2RW_map_init_src_bank

        cmp     esi,[ebx].pdev_rcl2PlanarClipS.yBottom
        jl      short top_2RW_main_loop

top_2RW_map_init_src_bank:

; Map bank containing the top source scan line into window.
; Note: EBX, ESI, and EDI preserved, according to C calling conventions.

        ptrCall <dword ptr [ebx].pdev_pfnPlanarControl2>, \
                <ebx,esi,JustifyTop,MapSourceBank>

top_2RW_main_loop:
        mov     ecx,[ebx].pdev_rcl2PlanarClipD.yBottom
        mov     edx,ulLastDestScan

        sub     ecx,edx
        sbb     eax,eax
        and     eax,ecx
        add     edx,eax                 ;edx = min(ulLastDestScan,
                                        ;  ppdev->rcl2PlanarClipD.bottom)

        mov     ecx,[ebx].pdev_rcl2PlanarClipS.yBottom

        sub     edx,edi                 ;edx = available scans in destination
                                        ;  bank
        sub     ecx,esi                 ;ecx = available scans in source bank

        sub     ecx,edx
        sbb     eax,eax
        and     eax,ecx
        add     edx,eax

        mov     ulBlockHeight,edx       ;ulBlockHeight = min(source available,
                                        ;  dest available)

        add     esi,edx                 ;adjust our currents scans accordingly
        add     edi,edx
        mov     ulCurrentSrcScan,esi
        mov     ulCurrentDestScan,edi

; Do the actual copy:

        call    pfnCopyBlocks

        mov     edi,ulCurrentDestScan   ;check if done
        cmp     edi,ulLastDestScan
        jge     all_done

        mov     ebx,ppdev

; We'll have to map a new source bank, destination bank, or both:

        mov     esi,ulCurrentSrcScan
        cmp     edi,[ebx].pdev_rcl2PlanarClipD.yBottom
        jl      short top_2RW_map_next_src_bank

; Map bank containing the top destination scan line into window.
; Note: EBX, ESI, and EDI preserved, according to C calling conventions.

        ptrCall <dword ptr [ebx].pdev_pfnPlanarControl2>, \
                <ebx,edi,JustifyTop,MapDestBank>

        cmp     esi,[ebx].pdev_rcl2PlanarClipS.yBottom
        jl      short top_2RW_main_loop

top_2RW_map_next_src_bank:

; Map bank containing the top source scan line into window.
; Note: EBX, ESI, and EDI preserved, according to C calling conventions.

        ptrCall <dword ptr [ebx].pdev_pfnPlanarControl2>, \
                <ebx,esi,JustifyTop,MapSourceBank>

        jmp     short top_2RW_main_loop

;-----------------------------------------------------------------------;
; Banking for 1R/1W or 2R/W adapters, bottom to top.
;
; Input:
;       ulCurrentSrcScan
;       ulCurrentDestScan
;       ulLastDestScan
;       Plus some other stuff for split rasters and block copiers
;-----------------------------------------------------------------------;
        public  bottom_to_top_2RW
bottom_to_top_2RW::

; We're going bottom to top. Map in the destination, bottom-justified.

        mov     ebx,ppdev
        mov     edi,ulCurrentDestScan   ; 1 more than actual destination scan
        mov     esi,ulCurrentSrcScan    ; 1 more than actual source scan

        cmp     edi,[ebx].pdev_rcl2PlanarClipD.yTop
        jle     short bot_2RW_map_init_dest_bank

        cmp     edi,[ebx].pdev_rcl2PlanarClipD.yBottom
        jle     short bot_2RW_init_dest_bank_mapped

bot_2RW_map_init_dest_bank:

; Map bank containing the top destination scan line into window.
; Note: EBX, ESI, and EDI preserved, according to C calling conventions.

        dec     edi
        ptrCall <dword ptr [ebx].pdev_pfnPlanarControl2>, \
                <ebx,edi,JustifyBottom,MapDestBank>
        inc     edi

bot_2RW_init_dest_bank_mapped:

        cmp     esi,[ebx].pdev_rcl2PlanarClipS.yTop
        jle     short bot_2RW_map_init_src_bank

        cmp     esi,[ebx].pdev_rcl2PlanarClipS.yBottom
        jle     short bot_2RW_main_loop

bot_2RW_map_init_src_bank:

; Map bank containing the top source scan line into window.
; Note: EBX, ESI, and EDI preserved, according to C calling conventions.

        dec     esi
        ptrCall <dword ptr [ebx].pdev_pfnPlanarControl2>, \
                <ebx,esi,JustifyBottom,MapSourceBank>
        inc     esi

bot_2RW_main_loop:
        mov     ecx,[ebx].pdev_rcl2PlanarClipD.yTop
        mov     edx,ulLastDestScan

        cmp     edx,ecx
        jg      @F
        mov     edx,ecx                 ;edx = max(ulLastDestScan,
@@:                                     ;  ppdev->rcl2PlanarClipD.top)

        sub     edi,edx                 ;edi = available scans in destination
                                        ;  bank
        sub     esi,[ebx].pdev_rcl2PlanarClipS.yTop
                                        ;esi = available scans in source bank

        sub     esi,edi
        sbb     eax,eax
        and     eax,esi
        add     edi,eax

        mov     ulBlockHeight,edi       ;ulBlockHeight = min(source available,
                                        ;  dest available)

        sub     ulCurrentSrcScan,edi    ;adjust our current scans
        sub     ulCurrentDestScan,edi

; Do the actual copy:

        call    pfnCopyBlocks

        mov     edi,ulCurrentDestScan   ;check if done
        cmp     edi,ulLastDestScan
        jle     all_done

        mov     ebx,ppdev

; We'll have to map a new source bank, destination bank, or both:

        mov     esi,ulCurrentSrcScan
        cmp     edi,[ebx].pdev_rcl2PlanarClipD.yTop
        jg      short bot_2RW_map_next_src_bank

; Map bank containing the top destination scan line into window.
; Note: EBX, ESI, and EDI preserved, according to C calling conventions.

        dec     edi
        ptrCall <dword ptr [ebx].pdev_pfnPlanarControl2>, \
                <ebx,edi,JustifyBottom,MapDestBank>
        inc     edi

        cmp     esi,[ebx].pdev_rcl2PlanarClipS.yTop
        jg      short bot_2RW_main_loop

bot_2RW_map_next_src_bank:

; Map bank containing the top source scan line into window.
; Note: EBX, ESI, and EDI preserved, according to C calling conventions.

        dec     esi
        ptrCall <dword ptr [ebx].pdev_pfnPlanarControl2>, \
                <ebx,esi,JustifyBottom,MapSourceBank>
        inc     esi

        jmp     short bot_2RW_main_loop

;=======================================================================;
;=========================== Block Copiers =============================;
;=======================================================================;

;-----------------------------------------------------------------------;
; Input:
;       Direction flag  - set to the appropriate direction
;       ulMiddleSrc     - offset in bitmap to source
;       ulMiddleDest    - offset in bitmap to destination
;       lMiddleDelta    - distance from end of current scan to start of next
;       ulBlockHeight   - # of scans to copy
;       cjMiddle        - # of planar bytes to copy on every scan
;
; Output:
;       Advances ulMiddleSrc and ulMiddleDest to next strip
;-----------------------------------------------------------------------;

        public  copy_middle_block
copy_middle_block::

; We only have to reset which planes are enabled if we do edges too:

        mov     edx,VGA_BASE + SEQ_DATA
        mov     al,MM_ALL
        out     dx,al

copy_just_middle_block::

; Calculate full start addresses:

        mov     edi,ppdev
        mov     eax,cjMiddle
        mov     ebx,ulBlockHeight
        mov     edx,lMiddleDelta
        mov     esi,[edi].pdev_pvBitmapStart2WindowS
        mov     edi,[edi].pdev_pvBitmapStart2WindowD
        add     esi,ulMiddleSrc
        add     edi,ulMiddleDest

;  EAX = # of bytes to copy
;  EBX = count of unrolled loop iterations
;  EDX = offset from end of one scan's fill to start of next
;  ESI = source address from which to copy
;  EDI = target address to which to copy

middle_loop:
        mov     ecx,eax
        rep     movsb
        add     esi,edx
        add     edi,edx

        dec     ebx
        jnz     middle_loop

; get ready for next time:

        mov     ecx,ppdev
        sub     esi,[ecx].pdev_pvBitmapStart2WindowS
        sub     edi,[ecx].pdev_pvBitmapStart2WindowD
        mov     ulMiddleSrc,esi
        mov     ulMiddleDest,edi

        PLAIN_RET

;-----------------------------------------------------------------------;
; Input:
;       ulLeftSrc     - offset in bitmap to source
;       ulLeftDest    - offset in bitmap to destination
;       lDelta        - distance from between planar scans
;       ulBlockHeight - # of scans to copy
;
; Output:
;       Advances ulLeftSrc and ulLeftDest to next strip
;-----------------------------------------------------------------------;

        public  copy_left_block
copy_left_block::

; Set left mask by disabling some planes:

        mov     edx,VGA_BASE + SEQ_DATA
        mov     eax,ulLeftMask
        out     dx,al

; Calculate full start addresses:

        mov     ecx,ppdev
        mov     ebx,ulBlockHeight
        mov     edx,lDelta
        mov     esi,[ecx].pdev_pvBitmapStart2WindowS
        mov     edi,[ecx].pdev_pvBitmapStart2WindowD
        add     esi,ulLeftSrc
        add     edi,ulLeftDest

;  EBX = count of unrolled loop iterations
;  EDX = offset from one scan to next
;  ESI = source address from which to copy
;  EDI = target address to which to copy

left_loop:
        mov     al,[esi]
        mov     [edi],al
        add     esi,edx
        add     edi,edx

        dec     ebx
        jnz     left_loop

; get ready for next time:

        sub     esi,[ecx].pdev_pvBitmapStart2WindowS
        sub     edi,[ecx].pdev_pvBitmapStart2WindowD
        mov     ulLeftSrc,esi
        mov     ulLeftDest,edi

        PLAIN_RET

;-----------------------------------------------------------------------;
; Input:
;       ulRightSrc    - offset in bitmap to source
;       ulRightDest   - offset in bitmap to destination
;       lDelta        - distance from between planar scans
;       ulBlockHeight - # of scans to copy
;
; Output:
;       Advances ulRightSrc and ulRightDest to next strip
;-----------------------------------------------------------------------;

        public  copy_right_block
copy_right_block::

; Set right mask by disabling some planes:

        mov     edx,VGA_BASE + SEQ_DATA
        mov     eax,ulRightMask
        out     dx,al

; Calculate full start addresses:

        mov     ecx,ppdev
        mov     ebx,ulBlockHeight
        mov     edx,lDelta
        mov     esi,[ecx].pdev_pvBitmapStart2WindowS
        mov     edi,[ecx].pdev_pvBitmapStart2WindowD
        add     esi,ulRightSrc
        add     edi,ulRightDest

;  EBX = count of unrolled loop iterations
;  EDX = offset from one scan to next
;  ESI = source address from which to copy
;  EDI = target address to which to copy

right_loop:
        mov     al,[esi]
        mov     [edi],al
        add     esi,edx
        add     edi,edx

        dec     ebx
        jnz     right_loop

; get ready for next time:

        sub     esi,[ecx].pdev_pvBitmapStart2WindowS
        sub     edi,[ecx].pdev_pvBitmapStart2WindowD
        mov     ulRightSrc,esi
        mov     ulRightDest,edi

        PLAIN_RET

;-----------------------------------------------------------------------;

endProc vPlanarCopyBits

        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\vga\disp\8bpp\i386\strucs.inc ===
;---------------------------Module-Header------------------------------;
; Module Name: stucts.inc
;
; Defines common structures.
;
; Copyright (c) 1992 Microsoft Corporation
;-----------------------------------------------------------------------;
;-----------------------------------------------------------------------;
; POINTB is used for points with a range of -128..+127.
;-----------------------------------------------------------------------;

POINTB          STRUC
ptb_x           DB      0
ptb_y           DB      0
POINTB          ENDS

;-----------------------------------------------------------------------;
; POINTL is used for points with a range of +/- 2G.
;-----------------------------------------------------------------------;

POINTL          STRUC
ptl_x           DD      0
ptl_y           DD      0
POINTL          ENDS


;-----------------------------------------------------------------------;
; SIZEB is used for extents with a range of -128..+127.
;-----------------------------------------------------------------------;

SIZEB           STRUC
sizb_cx         DB      0
sizb_cy         DB      0
SIZEB           ENDS


;-----------------------------------------------------------------------;
; SIZEL is used for extents with a range of +/- 2G
;-----------------------------------------------------------------------;

SIZEL           STRUC
sizl_cx         DD      0
sizl_cy         DD      0
SIZEL           ENDS

;-----------------------------------------------------------------------;
; Definition of a rectangle
;-----------------------------------------------------------------------;


RECTL               struc           ; /* rcl */
xLeft               dd      ?
yTop                dd      ?
xRight              dd      ?
yBottom             dd      ?
RECTL               ends


;-----------------------------------------------------------------------;
; Definitions for dsurf_iFormat
;-----------------------------------------------------------------------;

BMF_DEVICE          equ     0
BMF_1BPP            equ     1
BMF_4BPP            equ     2
BMF_8BPP            equ     3
BMF_16BPP           equ     4
BMF_24BPP           equ     5
BMF_32BPP           equ     6
BMF_4RLE            equ     8
BMF_8RLE            equ     9
BMF_PHYSDEVICE      equ     0FFh


;-----------------------------------------------------------------------;
; Definitions for text output
;-----------------------------------------------------------------------;


GLYPHPOS    struc           ; /* gp */
gp_hg       dd      ?       ; hglyph (unused by vga)
gp_pgdf     dd      ?       ; glyphdef
gp_x        dd      ?       ; glyph x position
gp_y        dd      ?       ; glyph y position
GLYPHPOS    ends


GLYPHDEF struc              ; /* gdf */
gdf_pgb     dd      ?       ; points to GLYPHBITS
GLYPHDEF ends


GLYPHBITS struc             ; /* gb */
gb_x        dd      ?       ; glyph x offset
gb_y        dd      ?       ; glyph y offset
gb_cx       dd      ?       ; glyph width in pels
gb_cy       dd      ?       ; glyph height in pels
gb_aj       db      ?       ; glyph bit mask
GLYPHBITS ends

;-----------------------------------------------------------------------;
; Information block for RLE blts
;-----------------------------------------------------------------------;

RLEINFO struc
RLE_pjTrg        dd  ?
RLE_pjSrcBits    dd  ?
RLE_pjSrcBitsMax dd  ?
RLE_prctlClip    dd  ?
RLE_pulTranslate dd  ?
RLE_xBegin       dd  ?
RLE_lNextScan    dd  ?
RLE_lNextPlane   dd  ?
RLE_prctlTrg     dd  ?
RLE_dwFormat     dd  ?
Rle_pdsurfTrg    dd  ?
RLEINFO ends
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\vga\disp\8bpp\i386\srccopy.asm ===
;---------------------------Module-Header------------------------------;
; Module Name: srccopy.asm
;
; Copyright (c) 1993 Microsoft Corporation
;-----------------------------------------------------------------------;

;-----------------------------------------------------------------------;
; VOID vSrcCopy8bpp(ppdev, psoSrc, prclDst, pptlSrc, lSrcDelta, pvSrcStart);
;
; Input:
;
;  ppdev      - screen pdev
;  psoSrc     - source surface
;  prcldest   - pointer to destination rectangle
;  pptlsrc    - pointer to source upper left corner
;  lSrcDelta  - offset from start of one scan to next in source
;  pvSrcStart - pointer to start of bitmap
;
; Performs 8bpp SRCCOPY memory-to-screen blts.
;
;-----------------------------------------------------------------------;
; NOTE: Assumes all rectangles have positive heights and widths. Will
; not work properly if this is not the case.
;-----------------------------------------------------------------------;

;-----------------------------------------------------------------------;

        .386

        .model  small,c

        assume cs:FLAT,ds:FLAT,es:FLAT,ss:FLAT
        assume fs:nothing,gs:nothing

        .xlist
        include stdcall.inc             ;calling convention cmacros
        include i386\strucs.inc
        include i386\driver.inc
        include i386\egavga.inc

        .list

;-----------------------------------------------------------------------;

        .data

;-----------------------------------------------------------------------;

        .code

;-----------------------------------------------------------------------;

cProc   vSrcCopy8bpp,20,<       \
        uses esi edi ebx,       \
        ppdev:      ptr PDEV,   \
        prclDst:    ptr RECTL,  \
        pptlSrc:    ptr POINTL, \
        lSrcDelta:  dword,      \
        pvSrcStart: ptr         >

        local culMiddle:    dword ;# of dwords in middle
        local cyToGo:       dword ;# of scans to copy after the current bank
        local pfnLoopVector:ptr   ;vector to appropriate copying loop
        local pvSrc:        ptr   ;source pointer

        mov     esi,prclDst             ;esi = prclDest
        mov     ebx,ppdev               ;ebx = ppdev
        mov     edi,[esi].yTop

        cmp     edi,[ebx].pdev_rcl1WindowClip.yTop
        jl      short src8_map_init_bank

        mov     edx,[ebx].pdev_rcl1WindowClip.yBottom
                                        ;edx = ppdev->rcl1WindowClip.bottom
        cmp     edi,edx
        jl      short src8_init_bank_mapped

src8_map_init_bank:
        ptrCall <dword ptr [ebx].pdev_pfnBankControl>, \
                <ebx,edi,JustifyTop>

        mov     edx,[ebx].pdev_rcl1WindowClip.yBottom

src8_init_bank_mapped:
        mov     eax,[esi].yBottom
        sub     eax,edx
        mov     cyToGo,eax              ;eax = # scans to do after this bank
        sbb     ecx,ecx
        and     ecx,eax
        add     edx,ecx                 ;edx = min(prclDst->bottom,
                                        ;          ppdev->rcl1WindowClip.bottom)
        sub     edx,edi                 ;edx = # of scans to do in this bank

; ebx = ppdev
; edx = # of scans to do in this bank
; esi = prclDst

        mov     eax,[esi].xLeft
        add     eax,3
        and     eax,not 3               ;eax = xLeft aligned to next dword

        mov     edi,pptlSrc             ;edi = pptlSrc
        mov     ecx,lSrcDelta
        imul    ecx,[edi].ptl_y
        add     ecx,[edi].ptl_x
        add     ecx,eax
        sub     ecx,[esi].xLeft
        add     ecx,pvSrcStart
        mov     pvSrc,ecx               ;pvSrc = pptlSrc->y * lSrcDelta +
                                        ;        pptlSrc->x + dest alignment +
                                        ;        pvSrcStart

        mov     edi,[ebx].pdev_lNextScan
        imul    edi,[esi].yTop
        add     edi,eax
        add     edi,[ebx].pdev_pvBitmapStart
                                        ;edi = prclDst->top * ppdev->lNextScan +
                                        ; aligned left + ppdev->pvBitmapStart
                                        ; (the aligned destination address)

; eax = prclDst->left aligned to dword
; ebx = ppdev
; edx = # of scans to do in this bank
; esi = prclDst
; edi = destination address

        mov     ecx,[esi].xRight        ;esi = prclDst->right
        sub     ecx,eax                 ;ecx = length in bytes from first full
                                        ;      dword to last byte
        jl      short src8_one_dword    ;special case if the destination
                                        ; starts and ends in the same dword

        mov     eax,ecx
        and     ecx,not 3               ;ecx = length of middle dwords in bytes
        sub     eax,ecx                 ;eax = (right & 3)

        mov     esi,[esi].xLeft
        and     esi,3                   ;esi = (left & 3)
        shl     eax,2
        or      esi,eax                 ;esi = ((right & 3) << 2) | (left & 3)
                                        ; (look-up index for loop vectors)

        mov     ebx,[ebx].pdev_lNextScan
        sub     ebx,ecx                 ;ebx = ppdev->lNextScan
                                        ; - (culMiddle << 2)
                                        ; (destination delta)

        mov     eax,lSrcDelta
        sub     eax,ecx                 ;eax = lSrcDelta - (culMiddle << 2)
                                        ; (source delta)

        shr     ecx,2
        mov     culMiddle,ecx           ;culMiddle = number of middle dwords

; eax = source delta
; ebx = destination delta
; ecx =
; edx = # scans to do
; esi = flags
; edi = destination pointer

; Set up for loop entry

        mov     ecx,gapfnMasterCopyTable[esi*4] ;every loop vector is a dword
        mov     esi,pvSrc
        mov     pfnLoopVector,ecx       ;save loop vector for next bank
        jmp     ecx

;-----------------------------------------------------------------------;
; Here we handle cases where copy starts and ends in same dword:

        public  src8_one_dword
src8_one_dword::
        sub     eax,[esi].xLeft         ;eax = # of bytes from left edge to
                                        ; first dword
        add     ecx,eax                 ;ecx = # of bytes to do

        sub     edi,eax                 ;adjust back to start byte
        sub     pvSrc,eax               ;adjust accordingly

        mov     ebx,[ebx].pdev_lNextScan;ebx = ppdev->lNextScan
                                        ; (destination delta)

        mov     eax,lSrcDelta           ;eax = lSrcDelta
                                        ; (source delta)

; eax = source delta
; ebx = destination delta
; esi =
; edx = # scans to do
; ecx = flags
; edi = destination pointer

; Set up for loop entry

        dec     ecx                     ;adjust for table (no zero entry)
        mov     ecx,gapfnOneDwordCopyTable[ecx*4]
        mov     esi,pvSrc
        mov     pfnLoopVector,ecx       ;save loop vector for next bank
        jmp     ecx

;-----------------------------------------------------------------------;
; We have following variables set before calling loops:
;
;   eax = source delta (from end of dwords to start of dwords on next scan)
;   ebx = destination delta
;   edx = # of scans
;   esi = source pointer
;   edi = destination pointer
;   culMiddle = number of dwords to copy

;-----------------------------------------------------------------------;
; See if done.  If not, get next bank.

        public  src8_done
src8_done::
        cmp     cyToGo,0
        jg      short src8_next_bank
        cRet    vSrcCopy8bpp

src8_next_bank:
        push    esi
        push    ebx                     ;save some registers
        mov     ebx,ppdev
        push    eax

        mov     esi,[ebx].pdev_rcl1WindowClip.yBottom
        sub     edi,[ebx].pdev_pvBitmapStart

        ptrCall <dword ptr [ebx].pdev_pfnBankControl>, \
                <ebx,esi,JustifyTop>

        add     edi,[ebx].pdev_pvBitmapStart
        mov     edx,[ebx].pdev_rcl1WindowClip.yBottom
        sub     edx,esi                 ;edx = # scans can do in this bank

        mov     eax,cyToGo
        sub     eax,edx
        mov     cyToGo,eax              ;eax = # scans to do after this bank
        sbb     ecx,ecx
        and     ecx,eax
        add     edx,ecx                 ;edx = min(# of scans can do in bank,
                                        ;          # of scans to go)
        pop     eax                     ;restore those registers
        pop     ebx
        pop     esi

        jmp     pfnLoopVector

;-----------------------------------------------------------------------;
; We organize the tables as follows so that it's easy to index into them:
;
;   Bits 2 and 3 = # of trailing bytes
;   Bits 0 and 1 = # of leading bytes to skip in first dword

        align   4
gapfnMasterCopyTable label dword
        dd      copy_wide_w_00_loop
        dd      copy_wide_w_30_loop
        dd      copy_wide_w_20_loop
        dd      copy_wide_w_10_loop
        dd      copy_wide_w_01_loop
        dd      copy_wide_w_31_loop
        dd      copy_wide_w_21_loop
        dd      copy_wide_w_11_loop
        dd      copy_wide_w_02_loop
        dd      copy_wide_w_32_loop
        dd      copy_wide_w_22_loop
        dd      copy_wide_w_12_loop
        dd      copy_wide_w_03_loop
        dd      copy_wide_w_33_loop
        dd      copy_wide_w_23_loop
        dd      copy_wide_w_13_loop

        align   4
gapfnOneDwordCopyTable label dword
        dd      copy_thin_t_1_loop
        dd      copy_thin_t_2_loop
        dd      copy_thin_t_3_loop

;-----------------------------------------------------------------------;
; Copy n dwords, 0 leading bytes, 0 trailing bytes, then advance to next
; scan line.

copy_wide_w_00_loop::
        mov     ecx,culMiddle
        rep     movsd
        add     esi,eax
        add     edi,ebx

        dec     edx
        jnz     copy_wide_w_00_loop
        jmp     src8_done

;-----------------------------------------------------------------------;
; Copy n dwords, 0 leading bytes, 1 trailing bytes, then advance to next
; scan line.

copy_wide_w_01_loop::
        mov     ecx,culMiddle
        rep     movsd
        mov     cl,[esi]
        mov     [edi],cl
        add     esi,eax
        add     edi,ebx

        dec     edx
        jnz     copy_wide_w_01_loop
        jmp     src8_done

;-----------------------------------------------------------------------;
; Copy n dwords, 0 leading bytes, 2 trailing bytes, then advance to next
; scan line.

copy_wide_w_02_loop::
        mov     ecx,culMiddle
        rep     movsd
        mov     cx,[esi]
        mov     [edi],cx
        add     esi,eax
        add     edi,ebx

        dec     edx
        jnz     copy_wide_w_02_loop
        jmp     src8_done

;-----------------------------------------------------------------------;
; Copy n dwords, 0 leading bytes, 3 trailing bytes, then advance to next
; scan line.

copy_wide_w_03_loop::
        mov     ecx,culMiddle
        rep     movsd
        mov     cx,[esi]
        mov     [edi],cx
        mov     cl,[esi+2]
        mov     [edi+2],cl
        add     esi,eax
        add     edi,ebx

        dec     edx
        jnz     copy_wide_w_03_loop
        jmp     src8_done

;-----------------------------------------------------------------------;
; Copy n dwords, 1 leading byte, 0 trailing bytes, then advance to next
; scan line.

copy_wide_w_10_loop::
        mov     cl,[esi-1]
        mov     [edi-1],cl
        mov     ecx,culMiddle
        rep     movsd
        add     esi,eax
        add     edi,ebx

        dec     edx
        jnz     copy_wide_w_10_loop
        jmp     src8_done

;-----------------------------------------------------------------------;
; Copy n dwords, 1 leading byte, 1 trailing bytes, then advance to next
; scan line.

copy_wide_w_11_loop::
        mov     cl,[esi-1]
        mov     [edi-1],cl
        mov     ecx,culMiddle
        rep     movsd
        mov     cl,[esi]
        mov     [edi],cl
        add     esi,eax
        add     edi,ebx

        dec     edx
        jnz     copy_wide_w_11_loop
        jmp     src8_done

;-----------------------------------------------------------------------;
; Copy n dwords, 1 leading byte, 2 trailing bytes, then advance to next
; scan line.

copy_wide_w_12_loop::
        mov     cl,[esi-1]
        mov     [edi-1],cl
        mov     ecx,culMiddle
        rep     movsd
        mov     cx,[esi]
        mov     [edi],cx
        add     esi,eax
        add     edi,ebx

        dec     edx
        jnz     copy_wide_w_12_loop
        jmp     src8_done

;-----------------------------------------------------------------------;
; Copy n dwords, 1 leading byte, 3 trailing bytes, then advance to next
; scan line.

copy_wide_w_13_loop::
        mov     cl,[esi-1]
        mov     [edi-1],cl
        mov     ecx,culMiddle
        rep     movsd
        mov     cx,[esi]
        mov     [edi],cx
        mov     cl,[esi+2]
        mov     [edi+2],cl
        add     esi,eax
        add     edi,ebx

        dec     edx
        jnz     copy_wide_w_13_loop
        jmp     src8_done

;-----------------------------------------------------------------------;
; Copy n dwords, 2 leading bytes, 0 trailing bytes, then advance to next
; scan line.

copy_wide_w_20_loop::
        mov     cx,[esi-2]
        mov     [edi-2],cx
        mov     ecx,culMiddle
        rep     movsd
        add     esi,eax
        add     edi,ebx

        dec     edx
        jnz     copy_wide_w_20_loop
        jmp     src8_done

;-----------------------------------------------------------------------;
; Copy n dwords, 2 leading bytes, 1 trailing bytes, then advance to next
; scan line.

copy_wide_w_21_loop::
        mov     cx,[esi-2]
        mov     [edi-2],cx
        mov     ecx,culMiddle
        rep     movsd
        mov     cl,[esi]
        mov     [edi],cl
        add     esi,eax
        add     edi,ebx

        dec     edx
        jnz     copy_wide_w_21_loop
        jmp     src8_done

;-----------------------------------------------------------------------;
; Copy n dwords, 2 leading bytes, 2 trailing bytes, then advance to next
; scan line.

copy_wide_w_22_loop::
        mov     cx,[esi-2]
        mov     [edi-2],cx
        mov     ecx,culMiddle
        rep     movsd
        mov     cx,[esi]
        mov     [edi],cx
        add     esi,eax
        add     edi,ebx

        dec     edx
        jnz     copy_wide_w_22_loop
        jmp     src8_done

;-----------------------------------------------------------------------;
; Copy n dwords, 2 leading bytes, 3 trailing bytes, then advance to next
; scan line.

copy_wide_w_23_loop::
        mov     cx,[esi-2]
        mov     [edi-2],cx
        mov     ecx,culMiddle
        rep     movsd
        mov     cx,[esi]
        mov     [edi],cx
        mov     cl,[esi+2]
        mov     [edi+2],cl
        add     esi,eax
        add     edi,ebx

        dec     edx
        jnz     copy_wide_w_23_loop
        jmp     src8_done

;-----------------------------------------------------------------------;
; Copy n dwords, 3 leading bytes, 0 trailing bytes, then advance to next
; scan line.

copy_wide_w_30_loop::
        mov     cl,[esi-3]
        mov     [edi-3],cl
        mov     cx,[esi-2]
        mov     [edi-2],cx
        mov     ecx,culMiddle
        rep     movsd
        add     esi,eax
        add     edi,ebx

        dec     edx
        jnz     copy_wide_w_30_loop
        jmp     src8_done

;-----------------------------------------------------------------------;
; Copy n dwords, 3 leading bytes, 1 trailing bytes, then advance to next
; scan line.

copy_wide_w_31_loop::
        mov     cl,[esi-3]
        mov     [edi-3],cl
        mov     cx,[esi-2]
        mov     [edi-2],cx
        mov     ecx,culMiddle
        rep     movsd
        mov     cl,[esi]
        mov     [edi],cl
        add     esi,eax
        add     edi,ebx

        dec     edx
        jnz     copy_wide_w_31_loop
        jmp     src8_done

;-----------------------------------------------------------------------;
; Copy n dwords, 3 leading bytes, 2 trailing bytes, then advance to next
; scan line.

copy_wide_w_32_loop::
        mov     cl,[esi-3]
        mov     [edi-3],cl
        mov     cx,[esi-2]
        mov     [edi-2],cx
        mov     ecx,culMiddle
        rep     movsd
        mov     cx,[esi]
        mov     [edi],cx
        add     esi,eax
        add     edi,ebx

        dec     edx
        jnz     copy_wide_w_32_loop
        jmp     src8_done

;-----------------------------------------------------------------------;
; Copy n dwords, 3 leading bytes, 3 trailing bytes, then advance to next
; scan line.

copy_wide_w_33_loop::
        mov     cl,[esi-3]
        mov     [edi-3],cl
        mov     cx,[esi-2]
        mov     [edi-2],cx
        mov     ecx,culMiddle
        rep     movsd
        mov     cx,[esi]
        mov     [edi],cx
        mov     cl,[esi+2]
        mov     [edi+2],cl
        add     esi,eax
        add     edi,ebx

        dec     edx
        jnz     copy_wide_w_33_loop
        jmp     src8_done

;-----------------------------------------------------------------------;
; Copy 1 byte, then advance to next scan line.

copy_thin_t_1_loop::
        mov     cl,[esi]
        mov     [edi],cl
        add     esi,eax
        add     edi,ebx

        dec     edx
        jnz     copy_thin_t_1_loop
        jmp     src8_done

;-----------------------------------------------------------------------;
; Copy 2 bytes, then advance to next scan line.

copy_thin_t_2_loop::
        mov     cx,[esi]
        mov     [edi],cx
        add     esi,eax
        add     edi,ebx

        dec     edx
        jnz     copy_thin_t_2_loop
        jmp     src8_done

;-----------------------------------------------------------------------;
; Copy 3 bytes, then advance to next scan line.

copy_thin_t_3_loop::
        mov     cx,[esi]
        mov     [edi],cx
        mov     cl,[esi+2]
        mov     [edi+2],cl
        add     esi,eax
        add     edi,ebx

        dec     edx
        jnz     copy_thin_t_3_loop
        jmp     src8_done

public copy_wide_w_00_loop
public copy_wide_w_01_loop
public copy_wide_w_02_loop
public copy_wide_w_03_loop
public copy_wide_w_10_loop
public copy_wide_w_11_loop
public copy_wide_w_12_loop
public copy_wide_w_13_loop
public copy_wide_w_20_loop
public copy_wide_w_21_loop
public copy_wide_w_22_loop
public copy_wide_w_23_loop
public copy_wide_w_30_loop
public copy_wide_w_31_loop
public copy_wide_w_32_loop
public copy_wide_w_33_loop
public copy_thin_t_1_loop
public copy_thin_t_2_loop
public copy_thin_t_3_loop

endProc vSrcCopy8bpp

        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\vga\disp\8bpp\i386\unroll.inc ===
;---------------------------Module-Header------------------------------;
; Module Name: unroll.inc
;
; Equates and macros for loop unrolling.
;
; Copyright (c) 1992 Microsoft Corporation
;-----------------------------------------------------------------------;

; Module including this must define LOOP_UNROLL_SHIFT. the log2 of the number
; of times you want loops in this module unrolled. For example,
; LOOP_UNROLL_SHIFT of 3 yields 2**3 = 8 times unrolling. This is the only
; thing you need to change to control unrolling.

; # of times to unroll the loop, calculated as 2**n, where n is the
; user-specified log2 of # of times to unroll the loop.

LOOP_UNROLL_COUNT equ   (1 shl LOOP_UNROLL_SHIFT)

;-----------------------------------------------------------------------;
; Macro to generate an unrolled loop of UNROLL_COUNT instances of BASE_MACRO,
; passing the base macro the info needed to construct a label of the form
; BASE_LABELxxx, where xxx is UNROLL_COUNT the first time, and counts down by
; one each time thereafter.

UNROLL_LOOP macro BASE_MACRO,BASE_LABEL,UNROLL_COUNT

INDEX=UNROLL_COUNT
        rept UNROLL_COUNT ;-------------------------;
        &BASE_MACRO &BASE_LABEL,%INDEX
INDEX=INDEX-1
        endm    ;-----------------------------------;

        endm    ;-----------------------------------;

;-----------------------------------------------------------------------;
; Macro to generate a dword memory variable that points to the label
; specified by concatenating the label and the index.

DEFINE_DD macro BASE_LABEL,INDEX ;------------------;
        dd      &BASE_LABEL&INDEX
        endm    ;-----------------------------------;
        
;-----------------------------------------------------------------------;
; Macro to generate a table of vectors into an unrolled loop, for entering
; to handle all possible fractional loops.

UNROLL_LOOP_ENTRY_TABLE macro TABLE,BASE_LABEL,UNROLL_COUNT
        align   4
TABLE label  dword
        DEFINE_DD       BASE_LABEL,%&UNROLL_COUNT

INDEX=1
        rept    UNROLL_COUNT-1
        DEFINE_DD       BASE_LABEL,%INDEX
INDEX=INDEX+1
        endm    ;-----------------------------------;

        endm    ;-----------------------------------;

;-----------------------------------------------------------------------;
; Given a loop count, a vector table, and unrolling parameters, this generates
; COUNT_DEST = # of times to execute unrolled loop, VEC_DEST = entry point into
; unrolled loop to perform whatever fractional loop is needed. Assumes dests
; are registers.
        
SET_UP_UNROLL_VARS macro COUNT_DEST,VEC_DEST,COUNT_SOURCE,VEC_TABLE,UNROLL_SHIFT
        mov     &VEC_DEST&,&COUNT_SOURCE&       ;copy count to vector dest to
                                                ; work with it
        ifdifi  <&COUNT_SOURCE&>,<&COUNT_DEST&>
        mov     &COUNT_DEST&,&COUNT_SOURCE&     ;copy to count dest too, if not
        endif                                   ; same as count source
        add     &COUNT_DEST&,(1 shl LOOP_UNROLL_SHIFT)-1 ;round count up
        and     &VEC_DEST&,(1 shl LOOP_UNROLL_SHIFT)-1
                                            ;fractional part of unrolled loop
        shr     &COUNT_DEST&,UNROLL_SHIFT    ;# of repetitions of unrolled loop
        mov     &VEC_DEST&,&VEC_TABLE&[&VEC_DEST&*4]
                                            ;place to jump into the unrolled
                                            ; loop so as to handle the
                                            ; fractional part first
        endm    ;-----------------------------------;

;-----------------------------------------------------------------------;
; Given a loop count, a vector table, and unrolling parameters, this generates
; COUNT_DEST = # of times to execute unrolled loop, VEC_DEST = entry point into
; unrolled loop to perform whatever fractional loop is needed. Assumes dests
; are registers.
        
SET_UP_UNROLL_AND_BRANCH macro COUNT_REG,VEC_REG,VEC_TABLE,UNROLL_SHIFT
        mov     &VEC_REG&,&COUNT_REG&       ;copy count to vector dest to
                                            ; work with it
        add     &COUNT_reg&,(1 shl LOOP_UNROLL_SHIFT)-1 ;round count up
        and     &VEC_REG&,(1 shl LOOP_UNROLL_SHIFT)-1
                                            ;fractional part of unrolled loop
        shr     &COUNT_REG&,UNROLL_SHIFT    ;# of repetitions of unrolled loop
        jmp     dword ptr &VEC_TABLE&[&VEC_REG&*4]
                                            ;jump into the unrolled loop so as
					    ; to handle the fractional part
					    ; first
        endm    ;-----------------------------------;

;-----------------------------------------------------------------------;


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\vga\disp\8bpp\i386\stretch8.asm ===
;---------------------------Module-Header------------------------------;
; Module Name: stretch.asm
;
; Copyright (c) 1992 Microsoft Corporation
;-----------------------------------------------------------------------;
;-----------------------------------------------------------------------;
; INT vStretchBlt8bpp(PPDEV ppdev, PBYTE pSrc, LONG lSrcNext,
;                     PRECTL prclSrc, PRECTL prclDest, PRECTL prclDestClip,
;                     PULONG pulXlatVector)
; Input:
;
; Performs accelerated stretch blts from 8-bit DIBs to 256-color VGA
; display memory.
;-----------------------------------------------------------------------;
; Note: Does not handle source clipping.
;
; Note: Does not yet handle expansion, only shrinking.
;-----------------------------------------------------------------------;

        comment $

***

Note: in the noxlat loop, EBX isn't altered, so it could be used for
something else, like the scan line count. This isn't done currently
because the scan-line loop is shared by the xlat and noxlat cases, and
the xlat cases do alter EBX; separate loops would be needed in order
to perform this optimization.

        commend $

;-----------------------------------------------------------------------;

                .386

ifndef  DOS_PLATFORM
        .model  small,c
else
ifdef   STD_CALL
        .model  small,c
else
        .model  small,pascal
endif;  STD_CALL
endif;  DOS_PLATFORM

        assume cs:FLAT,ds:FLAT,es:FLAT,ss:FLAT
        assume fs:nothing,gs:nothing

        .xlist
        include stdcall.inc             ;calling convention cmacros
        include i386\strucs.inc
        include i386\driver.inc

        .list

;-----------------------------------------------------------------------;

        .data

;-----------------------------------------------------------------------;

        .code

;-----------------------------------------------------------------------;

cProc vStretchBlt8bpp,28,< \
 uses esi edi ebx,         \
 ppdev:ptr,                \
 pSrc:ptr,                 \
 lSrcNext:dword,           \
 prclSrc:ptr,              \
 prclDest:ptr,             \
 prclDestClip:ptr,         \
 pulXlatVector:dword       >

        local   pulDDAArray:dword       ;pointer to array of n and n+1
                                        ; values generated by DDA, used to
                                        ; advance across source
        local   ulXStretchCount:dword   ;# of pixels or pixel pair to copy to
                                        ; (pixel pairs except in narrow
                                        ; cases; doesn't include leading or
                                        ; trailing single pixels in pixel
                                        ; pair cases)
        local   ulDestNext:dword         ;offset from last dest pixel on one
                                        ; scan to first on next
        local   ulSrcMinNext:dword      ;offset from start of one source scan
                                        ; to start of next scan that's skipped
                                        ; to by minimum DDA advance (basically,
                                        ; skips over n scans when DDA advances
                                        ; either n or n+1 scans)
        local   lYErrorTerm:dword       ;current error term for the DDA in Y
        local   ulYAdjUp:dword          ;error term adjust up for advancing
                                        ; DDA in Y
        local   ulYAdjDown:dword        ;error term adjust down for advancing
                                        ; DDA in Y
        local   ulDstTopScan:dword         ;top scan of dest text rect in
                                        ; current bank
        local   ulDstBottomScan :dword     ;bottom scan line of dest rectangle
        local   ulScanCount:dword       ;# of scans to stretch in current
                                        ; bank
        local   pfnRowVector:dword      ;pointer to routine to be used to
                                        ; stretch each row
        local   pfnStretchFn:dword      ;pointer to routine to do a bank's
                                        ; worth of stretching
        local   ulSrcTopScan:dword      ;top scan line of source from which
                                        ; to copy (after clipping, if needed)
        local   ulYMinStep:dword        ;minimum # of scans to skip in source
                                        ; when advancing dest one scan
        local   lXDstRight:dword        ;right edge of dest area to which to
                                        ; stretch, accounting for clipping
        local   lXDstLeft:dword         ;left edge of dest area to which to
                                        ; stretch, accounting for clipping
        local   ulXAdjUp:dword          ;X error term adjust up
        local   ulXMinStep:dword        ;X minimum step per dest 1-pixel step
        local   ulXAdjDown:dword        ;X error term adjust down
        local   lXSrcRight:dword        ;right edge of source area from which
                                        ; to stretch, accounting for clipping
        local   lXSrcLeft:dword         ;left edge of source area from which to
                                        ; stretch, accounting for clipping
        local   pvBuf:dword             ;local copy of ppdev->pvTmpBuf ptr

;-----------------------------------------------------------------------;

        mov     esi,ppdev
        mov     edi,[esi].pdev_pvTmpBuf
        mov     pvBuf,edi

        mov     esi,prclSrc
        mov     edi,prclDest

        mov     eax,[esi].xRight
        mov     edx,[esi].xLeft
        mov     lXSrcLeft,edx
        sub     eax,edx         ;EAX = source width
        mov     ecx,[edi].xRight
        mov     lXDstRight,ecx
        mov     edx,[edi].xLeft
        mov     lXDstLeft,edx
        sub     ecx,edx         ;ECX = dest width

        cmp     eax,ecx         ;shrink or stretch in X?
        jge     short x_shrink  ;shrink
                                ;stretch
;@@@
DoneFailed::
        sub     eax,eax         ;@@@shouldn't have to return a value
        jmp     done

;The destination is narrower than the source
x_shrink::
        mov     pfnStretchFn,offset shrink_8bpp_loop

;-----------------------------------------------------------------------;
; Precalculate the DDA steps for X and store them in the temp buffer. We know
; these will fit in the temp buffer, because there are only, say, 2K steps
; max across the screen, and the temp buffer is guaranteed to be more than
; 2K*4 = 8K bytes long.
;
; At this point, EAX = source width, ECX = destination width
;-----------------------------------------------------------------------;

        sub     edx,edx         ;prepare for division
        div     ecx             ;SourceDeltaX / DestDeltaX
        mov     ulXMinStep,eax  ;EAX = minimum step in source for 1 dest step

        mov     esi,edx         ;set aside SourceDeltaX % DestDeltaX
        add     edx,edx         ;scale up ulXAdjUp by 2 so we can handle a
                                ; half-pixel advance
        mov     ulXAdjUp,edx    ;ulXAdjUp = (SourceDeltaX % DestDeltaX)*2

                                ;prestep source X coord and error term by 1/2
                                ; a destination pixel, so we pick the source
                                ; pixel that most closely matches the center
                                ; of each destination pixel

                                ;step by 1/2 the whole source pixel advance
                                ; per destination step
        shr     eax,1           ;minimum step/2
        jnc     short @F        ;odd
                                ;even
        add     esi,ecx         ;advance error term for 1/2 of the source
                                ; pixel we just split (by DestDeltaX)
@@:
        add     lXSrcLeft,eax   ;advance 1/2 minimum step in source
        add     ecx,ecx         ;scale up DestDeltaX by 2 so we can handle a
                                ; half-pixel advance
        mov     ulXAdjDown,ecx  ;ulXAdjDown = DestDeltaX*2

        sub     esi,ecx         ;initial error term = -(DestDeltaX*2) + 1/2
                                ; normal error term step (for 1/2 pixel dest
                                ; advance effect on error term; note that 1/2
                                ; effect on whole source pixels has already
                                ; been accounted for)

;-----------------------------------------------------------------------;
; Clip to the dest in X, if necessary.
;-----------------------------------------------------------------------;

        mov     ebx,prclDestClip
        and     ebx,ebx                 ;any clipping?
        jz      short x_clip_done       ;no, all set
        mov     eax,[ebx].xRight        ;right clip edge
        cmp     eax,lXDstRight          ;is the right edge clipped?
        jge     short check_x_left_clip ;no
                                        ;right edge is clipped
        mov     lXDstRight,eax          ;set the clipped right edge
check_x_left_clip:
        mov     eax,[ebx].xLeft         ;left clip edge
        cmp     eax,lXDstLeft           ;is the left edge clipped?
        jle     short check_x_not_fully_clipped ;no
                                        ;left edge is clipped
        mov     edx,lXDstLeft           ;get the unclipped dest left edge
        mov     lXDstLeft,eax           ;set the clipped dest left edge
                                        ;now figure out how many source pixels
                                        ; were clipped, and advance the error
                                        ; term appropriately
        sub     eax,edx                 ;# of dest pixels clipped
        mov     ecx,eax                 ;set aside # of dest pixels to skip
        mul     ulXAdjUp                ;# of adjust ups in the course of the
                                        ; skipped pixels
        add     esi,eax                 ;EDX:ESI = error term after skipping
        adc     edx,-1                  ;(the initial error term is negative;
                                        ; this stretches it to 64 bits)
        jnc     short check_x_not_fully_clipped ;didn't turn over even once
        mov     eax,esi                 ;EDX:EAX = error term after skipping
        div     ulXAdjDown              ;EAX = # of times to adjust down
                                        ; while skipping pixels, minus 1
        sub     edx,ulXAdjDown          ;do the last adjust down, to cross
                                        ; back into negative territory where
                                        ; the error term belongs
        mov     esi,edx                 ;error term at new, clipped dest left
                                        ; edge
        inc     eax                     ;count the last adjust down (# of times
                                        ; source error turned over while
                                        ; advancing to the clipped left edge)
        imul    ecx,ulXMinStep          ;# of whole pixels skipped in source
                                        ; while advancing to dest clip left
                                        ; edge
        add     eax,ecx                 ;total # of pixels skipped in source
                                        ; while advancing to dest clip left
                                        ; edge
        add     lXSrcLeft,eax           ;advance the source left edge to match
                                        ; advancing the destination left edge
                                        ; to the left edge of the clip
                                        ; rectangle
check_x_not_fully_clipped:
        mov     eax,lXDstLeft
        cmp     lXDstRight,eax          ;is the destination fully x-clipped?
        jle     done                    ;yes, nothing to draw
x_clip_done:

;-----------------------------------------------------------------------;
; Now actually generate the (possibly clipped) X DDA skip array
;
; At this point, ESI = X error term for left edge (accounting for any
; X clipping that has occurred)
;-----------------------------------------------------------------------;

        mov     eax,ulXMinStep
        mov     edi,pvBuf       ;we'll store the DDA steps in the temp
        mov     pulDDAArray,edi ; buffer

        mov     edx,ulXAdjUp
        mov     ebx,ulXAdjDown
        mov     ecx,lXDstRight
        sub     ecx,lXDstLeft   ;ECX = # of pixels per dest scan
        push    ecx             ;remember # of dest pixels across
        push    ebp             ;preserve stack frame pointer
        lea     ebp,[eax+1]     ;maximum step
                                ;***stack frame unavailable***
x_shrink_set_dda_loop::
        add     esi,edx         ;adjust the error term up
        jnc     short x_shrink_set_dda_min ;didn't turn over, so advance
                                           ; minimum step
x_shrink_set_dda_max::
        sub     esi,ebx         ;turned over; adjust error term back down
        mov     [edi],ebp       ;advance by maximum step
        add     edi,4           ;point to next DDA array storage location
        dec     ecx             ;count down steps
        jz      short x_shrink_set_dda_done ;no more steps
        add     esi,edx         ;adjust the error term up
        jc      x_shrink_set_dda_max ;did turn over, so advance maximum step
x_shrink_set_dda_min::
        mov     [edi],eax       ;advance by minimum step
        add     edi,4           ;point to next DDA array storage location
        dec     ecx             ;count down steps
        jnz     x_shrink_set_dda_loop
x_shrink_set_dda_done::
        mov     dword ptr [edi],0 ;mark the end of the DDA
        pop     ebp             ;restore stack frame pointer
                                ;***stack frame available***
        pop     ecx             ;retrieve # of dest pixels across

        mov     edi,prclDest
        cmp     pulXlatVector,0         ;translation?
        jz      short x_shrink_noxlat   ;no
                                        ;yes
        cmp     ecx,3           ;narrow case?
        ja      short @F        ;no
        mov     pfnRowVector,offset shrink_xlat_8bpp_narrow     ;narrow case
        mov     ulXStretchCount,ecx     ;do all dest pixels one at a time
        jmp     check_y_shrink
@@:                             ;not narrow case; figure out which wide case,
                                ; based on the need to perform as many word-
                                ; aligned writes to display memory as possible
        mov     edx,ecx
        test    [edi].xLeft,1   ;starting at an odd destination address?
        jnz     short x_shrink_xlat_leading ;yes, need leading pixel
        mov     pfnRowVector,offset shrink_xlat_8bpp_nl_nt
                                        ;assume no leading or trailing pixels
        shr     edx,1                   ;destination width in pixel pairs
        mov     ulXStretchCount,edx     ;count of pixel pairs to draw
        jnc     short check_y_shrink  ;no leading or trailing pixels
        mov     pfnRowVector,offset shrink_xlat_8bpp_nl_t
                                        ;no leading pixel, is a trailing pixel
        jmp     short check_y_shrink
x_shrink_xlat_leading:                  ;there is a leading pixel
        mov     pfnRowVector,offset shrink_xlat_8bpp_l_nt
                                        ;assume no trailing pixel
        shr     edx,1                   ;destination width in pixel pairs
        mov     ulXStretchCount,edx     ;count of pixel pairs to draw
        jc      short check_y_shrink  ;no trailing pixel
        mov     pfnRowVector,offset shrink_xlat_8bpp_l_t
                                        ;both leading and trailing pixels
        dec     edx                     ;we'll do one pixel pair in the form
                                        ; of the leading/trailing pixel pair
        mov     ulXStretchCount,edx     ;count of pixel pairs to draw
        jmp     short check_y_shrink

x_shrink_noxlat:                        ;no translation
        cmp     ecx,3           ;narrow case?
        ja      short @F        ;no
        mov     pfnRowVector,offset shrink_noxlat_8bpp_narrow   ;narrow case
        mov     ulXStretchCount,ecx     ;do all dest pixels one at a time
        jmp     short check_y_shrink
@@:                             ;not narrow case; figure out which wide case,
                                ; based on the need to perform as many word-
                                ; aligned writes to display memory as possible
        mov     edx,ecx
        test    [edi].xLeft,1   ;starting at an odd destination address?
        jnz     short x_shrink_noxlat_leading ;yes, need leading pixel
        mov     pfnRowVector,offset shrink_noxlat_8bpp_nl_nt
                                        ;assume no leading or trailing pixels
        shr     edx,1                   ;destination width in pixel pairs
        mov     ulXStretchCount,edx     ;count of pixel pairs to draw
        jnc     short check_y_shrink  ;no leading or trailing pixels
        mov     pfnRowVector,offset shrink_noxlat_8bpp_nl_t
                                        ;no leading pixel, is a trailing pixel
        jmp     short check_y_shrink
x_shrink_noxlat_leading:                ;there is a leading pixel
        mov     pfnRowVector,offset shrink_noxlat_8bpp_l_nt
                                        ;assume no trailing pixel
        shr     edx,1                   ;destination width in pixel pairs
        mov     ulXStretchCount,edx     ;count of pixel pairs to draw
        jc      short check_y_shrink  ;no trailing pixel
        mov     pfnRowVector,offset shrink_noxlat_8bpp_l_t
                                        ;both leading and trailing pixels
        dec     edx                     ;we'll do one pixel pair in the form
                                        ; of the leading/trailing pixel pair
        mov     ulXStretchCount,edx     ;count of pixel pairs to draw

check_y_shrink::

        mov     esi,edi                 ;ESI->prclDest
        mov     edi,prclSrc             ;EDI->prclSrc
        mov     eax,[edi].yBottom
        mov     ecx,[edi].yTop
        mov     ulSrcTopScan,ecx
        sub     eax,ecx                 ;EAX = source height
        mov     ecx,[esi].yBottom
        mov     ulDstBottomScan,ecx
        mov     edx,[esi].yTop
        mov     ulDstTopScan,edx
        sub     ecx,edx         ;ECX = dest height

        cmp     eax,ecx         ;shrink or stretch in Y?
        jge     short y_shrink  ;shrink
                                ;stretch
;@@@
        sub     eax,eax         ;@@@shouldn't have to return a value
        jmp     done

;The destination is shorter than the source; calculate the error term values
; for advancing through the source on a per-dest-scan-line basis.
y_shrink::
        sub     edx,edx         ;prepare for division
        div     ecx             ;SourceDeltaY/DestDeltaY
        mov     ulYMinStep,eax  ;EAX = minimum step in source for 1 dest step

        mov     ebx,edx         ;set aside SourceDeltaY % DestDeltaY
        add     edx,edx         ;scale up ulYAdjUp by 2 so we can handle a
                                ; half-pixel advance
        mov     ulYAdjUp,edx    ;ulYAdjUp = (SourceDeltaY % DestDeltaY)*2

        imul    lSrcNext        ;(minimum step * source scan width in bytes)
        mov     ulSrcMinNext,eax ; = minimum offset by which to advance from
                                 ; one scan to the next

                                ;prestep source X coord and error term by 1/2
                                ; a destination pixel, so we pick the source
                                ; pixel that most closely matches the center
                                ; of each destination pixel

                                ;step by 1/2 the whole source pixel advance
                                ; per destination step
        mov     eax,ulYMinStep  ;retrieve minimum step
        shr     eax,1           ;minimum step/2
        jnc     short @F        ;odd
                                ;even
        add     ebx,ecx         ;advance error term for 1/2 of the source
                                ; pixel we just split
@@:
        add     ulSrcTopScan,eax ;advance 1/2 minimum step in source

        add     ecx,ecx         ;scale up DestDeltaY by 2 so we can handle a
                                ; half-pixel advance
        mov     ulYAdjDown,ecx  ;ulYAdjDown = DestDeltaY*2

        sub     ebx,ecx         ;initial error term = -(DestDeltaY*2) + 1/2
                                ; normal error term step (for 1/2 pixel dest
                                ; advance effect on error term; note that 1/2
                                ; effect on whole source pixels has already
                                ; been accounted for)
        mov     lYErrorTerm,ebx

;-----------------------------------------------------------------------;
; Clip in Y, if necessary.
;-----------------------------------------------------------------------;

        mov     ebx,prclDestClip
        and     ebx,ebx                 ;any clipping?
        jz      short y_clip_done       ;no, all set
        mov     eax,[ebx].yBottom       ;yes, clipping
                                        ;see if the dest is clipped off the
                                        ; bottom
        cmp     ulDstBottomScan,eax     ;is the bottom clipped?
        jle     short check_y_top_clip  ;no, check the top
        mov     ulDstBottomScan,eax     ;yes, set the new bottom
check_y_top_clip:
                                        ;see if the dest is clipped off the
                                        ; top
        mov     eax,[ebx].yTop
        cmp     ulDstTopScan,eax        ;is the top clipped?
        jge     short check_y_not_fully_clipped ;no
                                        ;yes, so advance the top scan and the
                                        ; error term accordingly
        mov     ulDstTopScan,eax        ;top of clipped destination rectangle
        sub     eax,[esi].yTop          ;# of destination scans to skip
        mov     ecx,eax                 ;set aside # of dest scans to skip
        mul     ulYAdjUp                ;# of adjust ups in the course of the
                                        ; skipped scans
        add     eax,lYErrorTerm         ;EDX:EAX = error term after skipping
        adc     edx,-1                  ;(the initial error term is negative;
                                        ; this stretches it to 64 bits)
        jnc     short check_y_not_fully_clipped ;didn't turn over even once
        div     ulYAdjDown              ;EAX = # of times to adjust down
                                        ; while skipping scans, minus 1
        sub     edx,ulYAdjDown          ;do the last adjust down, to cross
                                        ; back into negative territory where
                                        ; the error term belongs
        mov     lYErrorTerm,edx         ;error term at new, clipped dest top
        inc     eax                     ;count the last adjust down (# of
                                        ; times source error has turned over)
        imul    ecx,ulYMinStep          ;# of whole steps in source while
                                        ; advancing to dest clip top
        add     eax,ecx                 ;total # of scans skipped in source
                                        ; while advancing to dest clip top
        add     ulSrcTopScan,eax        ;advance the source top edge to match
                                        ; advancing the destination top edge to
                                        ; the top of the clip rectangle
check_y_not_fully_clipped:
        mov     eax,ulDstTopScan
        cmp     ulDstBottomScan,eax        ;is the destination fully y-clipped?
        jle     done                    ;yes, nothing to draw
y_clip_done:

;-----------------------------------------------------------------------;
; Calculate the offset of the initial destination pixel.
;-----------------------------------------------------------------------;

        mov     ebx,ppdev
        mov     eax,ulDstTopScan   ;top scan line of text
        mov     esi,[ebx].pdev_lDeltaScreen
        mul     esi
        mov     edi,lXDstLeft
        mov     ecx,lXDstRight
        sub     ecx,edi         ;dest width
        sub     esi,ecx         ;dest width - width of a dest scan to stretch
        mov     ulDestNext,esi  ;offset from end of one dest stretched
                                ; scan to start of next
        add     edi,eax

;-----------------------------------------------------------------------;
; Map in the bank containing the top scan of the text, if it's not
; mapped in already.
;-----------------------------------------------------------------------;

        mov     eax,ulDstTopScan   ;top scan line of text
        cmp     eax,[ebx].pdev_rcl1WindowClip.yTop ;is text top less than
                                                   ; current bank?
        jl      short map_init_bank                ;yes, map in proper bank
        cmp     eax,[ebx].pdev_rcl1WindowClip.yBottom ;text top greater than
                                                      ; current bank?
        jl      short init_bank_mapped        ;no, proper bank already mapped
map_init_bank::

; Map in the bank containing the top scan line of the destination.
; Preserves EBX, ESI, and EDI.

        ptrCall <dword ptr [ebx].pdev_pfnBankControl>,<ebx,eax,JustifyTop>

init_bank_mapped::

        add     edi,[ebx].pdev_pvBitmapStart    ;initial destination address

;-----------------------------------------------------------------------;
; Calculate the offset of the initial source pixel.
;-----------------------------------------------------------------------;

        mov     esi,prclSrc
        mov     eax,lSrcNext
        imul    ulSrcTopScan
        mov     esi,lXSrcLeft
        add     esi,eax
        add     esi,pSrc

;-----------------------------------------------------------------------;
; Main loop for processing stretch blt in each bank.
;
; At start of loop, EBX->ppdev, ESI->current src, EDI->current dst
;-----------------------------------------------------------------------;

bank_loop::
        mov     edx,ulDstBottomScan        ;bottom of destination rectangle
        cmp     edx,[ebx].pdev_rcl1WindowClip.yBottom
                                        ;which comes first, the bottom of the
                                        ; text rect or the bottom of the
                                        ; current bank?
        jl      short @F                ;text bottom comes first, so draw to
                                        ; that; this is the last bank in text
        mov     edx,[ebx].pdev_rcl1WindowClip.yBottom
                                        ;bank bottom comes first; draw to
                                        ; bottom of bank
@@:
        sub     edx,ulDstTopScan           ;# of scans to draw in bank
        mov     ulScanCount,edx

        call    pfnStretchFn    ;stretch the bitmap block that's in this bank

;-----------------------------------------------------------------------;
; See if there are more banks to draw.
;-----------------------------------------------------------------------;

        mov     ebx,ppdev
        mov     eax,[ebx].pdev_rcl1WindowClip.yBottom ;is the text bottom in
        cmp     ulDstBottomScan,eax                   ; the current bank?
        jnle    short do_next_bank      ;no, map in the next bank and draw
        mov     eax,1                   ;success
                                        ;@@@shouldn't return a value
done::
        cRet    vStretchBlt8bpp         ;yes, so we're done

do_next_bank::
        mov     ulDstTopScan,eax
        sub     edi,[ebx].pdev_pvBitmapStart ;convert from address to offset
                                             ; within bitmap
        ptrCall <dword ptr [ebx].pdev_pfnBankControl>,<ebx,eax,JustifyTop>
                                             ;map in the bank (call preserves
                                             ; EBX, ESI, and EDI)
        add     edi,[ebx].pdev_pvBitmapStart ;convert from offset within bitmap
                                             ; to address (bitmap start just
                                             ; moved)
        jmp     bank_loop                    ;we're ready to draw to the new
                                             ; bank

;-----------------------------------------------------------------------;
; Shrink in X and Y, xlat or noxlat, 8-bpp source, VGA dest
;
; On entry: ESI->first source pixel to copy from
;           EDI->first dest pixel to copy to
;           pulXlatVector = pointer to color translation array (xlat cases
;                           only)
;           ulSrcMinNext = minimum offset from end of current source scan to
;                          start of next source scan to stretch
;           lSrcNext = offset from start of one source scan to start of next
;           ulDestNext = offset from end of current dest scan to start of
;                        next dest scan to stretch to
;           pfnRowVector = pointer to routine to call to stretch one scan
;           ulScanCount = # of scans to stretch
;           lYErrorTerm, ulYAdjUp, ulYAdjDown = Y DDA error term components
;
; On exit:  ESI->next source pixel to copy from
;           EDI->next dest pixel to copy to
;           lYErrorTerm advanced for next scan
;-----------------------------------------------------------------------;

shrink_8bpp_loop::
        sub     ebx,ebx         ;prepare EBX=0 for xlat-case row-drawing
                                ; routines
shrink_block_8bpp_loop::
        mov     edx,pulDDAArray ;point to array of skip values to use to scan
                                ; across the source
        mov     ecx,ulXStretchCount ;# of pixels or pixel pairs to copy to
        push    esi             ;preserve source pointer
        call    pfnRowVector    ;stretch/shrink this row
        pop     esi             ;restore source pointer
        add     esi,ulSrcMinNext ;point to start of next source row, assuming
                                 ; no extra row for error term turnover
        mov     eax,lYErrorTerm
        add     eax,ulYAdjUp    ;advance the error term
        jnc     short @F        ; didn't turn over (minimum step)
        sub     eax,ulYAdjDown  ;turned over, adjust down and...
        add     esi,lSrcNext    ; advance an extra scan (maximum step)
@@:
        mov     lYErrorTerm,eax ;remember the new error term
        add     edi,ulDestNext  ;point to start of next destination row
        dec     ulScanCount     ;count down scans
        jnz     shrink_block_8bpp_loop
        retn

;-----------------------------------------------------------------------;
; Single-row optimizations, called out of main stretch loops.
;-----------------------------------------------------------------------;

;-----------------------------------------------------------------------;
; Shrink in X
; No xlat
; 8-bit source
; Writes a word at a time
;
; Input: ECX = number of pixel pairs to do, not counting leading and trailing
;              single pixels (except in narrow case, where ECX = number of
;              pixels, not pixel pairs)
;        EDX = pointer to pre-computed skip array
;        ESI = pointer to initial source pixel
;        EDI = pointer to initial destination pixel
;
; Output: ESI = pointer after last source pixel processed
;         EDI = pointer after last source pixel processed
;
; EBX and EBP are preserved
; The contents of EAX, ECX, and EDX may be destroyed
;-----------------------------------------------------------------------;

; No leading byte, no trailing byte.

shrink_noxlat_8bpp_nl_nt::
shrink_noxlat_8bpp_nl_nt_pixel_loop::
        mov     al,[esi]        ;get first source pixel
        add     esi,[edx]       ;point to next source pixel
        mov     ah,[esi]        ;get second source pixel
        add     esi,[edx+4]     ;point to next source pixel
        add     edx,8           ;point to next skip entry
        mov     [edi],ax        ;write both pixels to the destination
        add     edi,2           ;point to next destination pixel
        dec     ecx             ;count down pixel pairs
        jnz     shrink_noxlat_8bpp_nl_nt_pixel_loop
        retn

; Leading byte, no trailing byte.

shrink_noxlat_8bpp_l_nt::
                                ;do the leading pixel
        mov     al,[esi]        ;get the current source pixel
        add     esi,[edx]       ;point to next source pixel
        add     edx,4           ;point to next skip entry
        mov     [edi],al        ;write the pixel to the destination
        inc     edi             ;point to next destination pixel
                                ;now do pixel pairs across the middle
shrink_noxlat_8bpp_l_nt_pixel_loop::
        mov     al,[esi]        ;get first source pixel
        add     esi,[edx]       ;point to next source pixel
        mov     ah,[esi]        ;get second source pixel
        add     esi,[edx+4]     ;point to next source pixel
        add     edx,8           ;point to next skip entry
        mov     [edi],ax        ;write both pixels to the destination
        add     edi,2           ;point to next destination pixel
        dec     ecx             ;count down pixel pairs
        jnz     shrink_noxlat_8bpp_l_nt_pixel_loop
        retn

; Leading byte, trailing byte.

shrink_noxlat_8bpp_l_t::
                                ;do the leading pixel
        mov     al,[esi]        ;get current source pixel
        add     esi,[edx]       ;point to next source pixel
        add     edx,4           ;point to next skip entry
        mov     [edi],al        ;write the pixel to the destination
        inc     edi             ;point to next destination pixel
                                ;now do pixel pairs across the middle
shrink_noxlat_8bpp_l_t_pixel_loop::
        mov     al,[esi]        ;get first source pixel
        add     esi,[edx]       ;point to next source pixel
        mov     ah,[esi]        ;get second source pixel
        add     esi,[edx+4]     ;point to next source pixel
        add     edx,8           ;point to next skip entry
        mov     [edi],ax        ;write both pixels to the destination
        add     edi,2           ;point to next destination pixel
        dec     ecx             ;count down pixel pairs
        jnz     shrink_noxlat_8bpp_l_t_pixel_loop
                                ;do the trailing pixel
        mov     al,[esi]        ;get current source pixel
        add     esi,[edx]       ;point to next source pixel
        add     edx,4           ;point to next skip entry
        mov     [edi],al        ;write the pixel to the destination
        inc     edi             ;point to next destination pixel
        retn

; No leading byte, trailing byte.

shrink_noxlat_8bpp_nl_t::
shrink_noxlat_8bpp_nl_t_pixel_loop::
        mov     al,[esi]        ;get first source pixel
        add     esi,[edx]       ;point to next source pixel
        mov     ah,[esi]        ;get second source pixel
        add     esi,[edx+4]     ;point to next source pixel
        add     edx,8           ;point to next skip entry
        mov     [edi],ax        ;write both pixels to the destination
        add     edi,2           ;point to next destination pixel
        dec     ecx             ;count down pixel pairs
        jnz     shrink_noxlat_8bpp_nl_t_pixel_loop
                                ;do the trailing pixel
        mov     al,[esi]        ;get current source pixel
        add     esi,[edx]       ;point to next source pixel
        add     edx,4           ;point to next skip entry
        mov     [edi],al        ;write the pixel to the destination
        inc     edi             ;point to next destination pixel
        retn

; Narrow case, a byte at a time.

shrink_noxlat_8bpp_narrow::
shrink_noxlat_8bpp_narrow_pixel_loop::
        mov     al,[esi]        ;get current source pixel
        add     esi,[edx]       ;point to next source pixel
        add     edx,4           ;point to next skip entry
        mov     [edi],al        ;write the pixel to the destination
        inc     edi             ;point to next destination pixel
        dec     ecx             ;count down pixels
        jnz     shrink_noxlat_8bpp_narrow_pixel_loop
        retn

;-----------------------------------------------------------------------;
; Shrink in X
; Xlat
; 8-bit source
; Writes a word at a time
;
; Input: EBX upper three bytes = zero (0)
;        ECX = number of pixel pairs to do, not counting leading and trailing
;              single pixels (except in narrow case, where ECX = number of
;              pixels, not pixel pairs)
;        EDX = pointer to pre-computed skip array
;        ESI = pointer to initial source pixel
;        EDI = pointer to initial destination pixel
;        pulXlatVector = pointer to color translation array
;
; Output: ESI = pointer after last source pixel processed
;         EDI = pointer after last source pixel processed
;
; EBP is preserved
; The upper three bytes of EBX are preserved
; The contents of EAX, BL, ECX, and EDX may be destroyed
;-----------------------------------------------------------------------;

; No leading byte, no trailing byte.

shrink_xlat_8bpp_nl_nt::
        push    ebp             ;***stack frame not available***
        mov     ebp,pulXlatVector ;point EBP to the translation table
shrink_xlat_8bpp_nl_nt_pixel_loop::
        mov     bl,[esi]        ;get first source pixel
        add     esi,[edx]       ;point to next source pixel
        mov     eax,[ebp+ebx*4] ;translate the pixel color
        mov     bl,[esi]        ;get second source pixel
        add     esi,[edx+4]     ;point to next source pixel
        mov     ah,[ebp+ebx*4]  ;translate the pixel color
        add     edx,8           ;point to next skip entry
        mov     [edi],ax        ;write both pixels to the destination
        add     edi,2           ;point to next destination pixel
        dec     ecx             ;count down pixel pairs
        jnz     shrink_xlat_8bpp_nl_nt_pixel_loop
        pop     ebp             ;***stack frame available***
        retn

; Leading byte, no trailing byte.

shrink_xlat_8bpp_l_nt::
        push    ebp             ;***stack frame not available***
        mov     ebp,pulXlatVector ;point EBP to the translation table
                                ;do the leading pixel
        mov     bl,[esi]        ;get first source pixel
        add     esi,[edx]       ;point to next source pixel
        mov     eax,[ebp+ebx*4] ;translate the pixel color
        add     edx,4           ;point to next skip entry
        mov     [edi],al        ;write the pixel to the destination
        inc     edi             ;point to next destination pixel
                                ;now do pixel pairs across the middle
shrink_xlat_8bpp_l_nt_pixel_loop::
        mov     bl,[esi]        ;get first source pixel
        add     esi,[edx]       ;point to next source pixel
        mov     eax,[ebp+ebx*4] ;translate the pixel color
        mov     bl,[esi]        ;get second source pixel
        add     esi,[edx+4]     ;point to next source pixel
        mov     ah,[ebp+ebx*4]  ;translate the pixel color
        add     edx,8           ;point to next skip entry
        mov     [edi],ax        ;write both pixels to the destination
        add     edi,2           ;point to next destination pixel
        dec     ecx             ;count down pixel pairs
        jnz     shrink_xlat_8bpp_l_nt_pixel_loop
        pop     ebp             ;***stack frame available***
        retn

; Leading byte, trailing byte.

shrink_xlat_8bpp_l_t::
        push    ebp             ;***stack frame not available***
        mov     ebp,pulXlatVector ;point EBP to the translation table
                                ;do the leading pixel
        mov     bl,[esi]        ;get first source pixel
        add     esi,[edx]       ;point to next source pixel
        mov     eax,[ebp+ebx*4] ;translate the pixel color
        add     edx,4           ;point to next skip entry
        mov     [edi],al        ;write the pixel to the destination
        inc     edi             ;point to next destination pixel
                                ;now do pixel pairs across the middle
shrink_xlat_8bpp_l_t_pixel_loop::
        mov     bl,[esi]        ;get first source pixel
        add     esi,[edx]       ;point to next source pixel
        mov     eax,[ebp+ebx*4] ;translate the pixel color
        mov     bl,[esi]        ;get second source pixel
        add     esi,[edx+4]     ;point to next source pixel
        mov     ah,[ebp+ebx*4]  ;translate the pixel color
        add     edx,8           ;point to next skip entry
        mov     [edi],ax        ;write both pixels to the destination
        add     edi,2           ;point to next destination pixel
        dec     ecx             ;count down pixel pairs
        jnz     shrink_xlat_8bpp_l_t_pixel_loop
                                ;do the trailing pixel
        mov     bl,[esi]        ;get first source pixel
        add     esi,[edx]       ;point to next source pixel
        mov     eax,[ebp+ebx*4] ;translate the pixel color
        add     edx,4           ;point to next skip entry
        mov     [edi],al        ;write the pixel to the destination
        inc     edi             ;point to next destination pixel
        pop     ebp             ;***stack frame available***
        retn

; No leading byte, trailing byte.

shrink_xlat_8bpp_nl_t::
        push    ebp             ;***stack frame not available***
        mov     ebp,pulXlatVector ;point EBP to the translation table
shrink_xlat_8bpp_nl_t_pixel_loop::
        mov     bl,[esi]        ;get first source pixel
        add     esi,[edx]       ;point to next source pixel
        mov     eax,[ebp+ebx*4] ;translate the pixel color
        mov     bl,[esi]        ;get second source pixel
        add     esi,[edx+4]     ;point to next source pixel
        mov     ah,[ebp+ebx*4]  ;translate the pixel color
        add     edx,8           ;point to next skip entry
        mov     [edi],ax        ;write both pixels to the destination
        add     edi,2           ;point to next destination pixel
        dec     ecx             ;count down pixel pairs
        jnz     shrink_xlat_8bpp_nl_t_pixel_loop
                                ;do the trailing pixel
        mov     bl,[esi]        ;get first source pixel
        add     esi,[edx]       ;point to next source pixel
        mov     eax,[ebp+ebx*4] ;translate the pixel color
        add     edx,4           ;point to next skip entry
        mov     [edi],al        ;write the pixel to the destination
        inc     edi             ;point to next destination pixel
        pop     ebp             ;***stack frame available***
        retn
; Narrow case, a byte at a time.

shrink_xlat_8bpp_narrow::
        push    ebp             ;***stack frame not available***
        mov     ebp,pulXlatVector ;point EBP to the translation table
shrink_xlat_8bpp_narrow_loop::
        mov     bl,[esi]        ;get first source pixel
        add     esi,[edx]       ;point to next source pixel
        mov     eax,[ebp+ebx*4] ;translate the pixel color
        add     edx,4           ;point to next skip entry
        mov     [edi],al        ;write the pixel to the destination
        inc     edi             ;point to next destination pixel
        dec     ecx             ;count down pixels
        jnz     shrink_xlat_8bpp_narrow_loop
        pop     ebp             ;***stack frame available***
        retn

endProc vStretchBlt8bpp

public DoneFailed
public x_shrink
public check_y_shrink
public x_shrink_set_dda_loop
public x_shrink_set_dda_max
public x_shrink_set_dda_min
public x_shrink_set_dda_done
public y_shrink
public map_init_bank
public init_bank_mapped
public bank_loop
public done
public do_next_bank
public shrink_8bpp_loop
public shrink_block_8bpp_loop
public shrink_noxlat_8bpp_nl_nt
public shrink_noxlat_8bpp_nl_nt_pixel_loop
public shrink_noxlat_8bpp_l_nt
public shrink_noxlat_8bpp_l_nt_pixel_loop
public shrink_noxlat_8bpp_l_t
public shrink_noxlat_8bpp_l_t_pixel_loop
public shrink_noxlat_8bpp_nl_t
public shrink_noxlat_8bpp_nl_t_pixel_loop
public shrink_noxlat_8bpp_narrow
public shrink_noxlat_8bpp_narrow_pixel_loop
public shrink_xlat_8bpp_nl_nt
public shrink_xlat_8bpp_nl_nt_pixel_loop
public shrink_xlat_8bpp_l_nt
public shrink_xlat_8bpp_l_nt_pixel_loop
public shrink_xlat_8bpp_l_t
public shrink_xlat_8bpp_l_t_pixel_loop
public shrink_xlat_8bpp_nl_t
public shrink_xlat_8bpp_nl_t_pixel_loop
public shrink_xlat_8bpp_narrow
public shrink_xlat_8bpp_narrow_loop

        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\vga\disp\8bpp\i386\lines.asm ===
;---------------------------Module-Header------------------------------;
; Module Name: lines.asm
;
; Draws a set of connected polylines.
;
; The actual pixel-lighting code is different depending on if the lines
; are styled/unstyled and we're doing an arbitrary ROP or set-style ROP.
;
; Lines are drawn from left to right.  So if a line moves from right
; to left, the endpoints are swapped and the line is drawn from left to
; right.
;
; See s3\lines.cxx for a portable version (sans simple clipping).
;
; Copyright (c) 1992 Microsoft Corporation
;-----------------------------------------------------------------------;

        .386

        .model  small,c

        assume cs:FLAT,ds:FLAT,es:FLAT,ss:FLAT
        assume fs:nothing,gs:nothing

        .xlist
        include stdcall.inc             ;calling convention cmacros
        include i386\egavga.inc
        include i386\strucs.inc
        include i386\driver.inc
        include i386\lines.inc
        .list

        .data

        public gaflRoundTable
gaflRoundTable       label  dword
        dd      FL_H_ROUND_DOWN + FL_V_ROUND_DOWN       ; no flips
        dd      FL_H_ROUND_DOWN + FL_V_ROUND_DOWN       ; D flip
        dd      FL_H_ROUND_DOWN                         ; V flip
        dd      FL_V_ROUND_DOWN                         ; D & V flip
        dd      FL_V_ROUND_DOWN                         ; slope one
        dd      0baadf00dh
        dd      FL_H_ROUND_DOWN                         ; slope one & V flip
        dd      0baadf00dh

        .code

;--------------------------------Macro----------------------------------;
; testb ebx, <mask>
;
; Substitutes a byte compare if the mask is entirely in the lo-byte or
; hi-byte (thus saving 3 bytes of code space).
;
;-----------------------------------------------------------------------;

TESTB   macro   targ,mask,thirdarg
        local   mask2,delta

ifnb <thirdarg>
        .err    TESTB mask must be enclosed in brackets!
endif

        delta = 0
        mask2 = mask

        if mask2 AND 0ffff0000h
            test targ,mask                      ; If bit set in hi-word,
            exitm                               ; test entire dword
        endif

        if mask2 AND 0ff00h
            if mask2 AND 0ffh                   ; If bit set in lo-byte and
                test targ,mask                  ; hi-byte, test entire dword
                exitm
            endif

            mask2 = mask2 SHR 8
            delta = 1
        endif

ifidni <targ>,<EBX>
        if delta
            test bh,mask2
        else
            test bl,mask2
        endif
        exitm
endif

        .err    Too bad TESTB doesn't support targets other than ebx!
endm

;---------------------------Public-Routine------------------------------;
; BOOL bLines(ppdev, pptfxFirst, pptfxBuf, prun, cptfx, pls,
;        prclClip, apfn[], flStart)
;
; Do all the DDA calculations for lines.
;
; Doing Lines Right
; -----------------
;
; In NT, all lines are given to the device driver in fractional
; coordinates, in a 28.4 fixed point format.  The lower 4 bits are
; fractional for sub-pixel positioning.
;
; Note that you CANNOT! just round the coordinates to integers
; and pass the results to your favorite integer Bresenham routine!!
; (Unless, of course, you have such a high resolution device that
; nobody will notice -- not likely for a display device.)  The
; fractions give a more accurate rendering of the line -- this is
; important for things like our Bezier curves, which would have 'kinks'
; if the points in its polyline approximation were rounded to integers.
;
; Unfortunately, for fractional lines there is more setup work to do
; a DDA than for integer lines.  However, the main loop is exactly
; the same (and can be done entirely with 32 bit math).
;
; If You've Got Hardware That Does Bresenham
; ------------------------------------------
;
; A lot of hardware limits DDA error terms to 'n' bits.  With fractional
; coordinates, 4 bits are given to the fractional part, letting
; you draw in hardware only those lines that lie entirely in a 2^(n-4)
; by 2^(n-4) pixel space.
;
; And you still have to correctly draw those lines with coordinates
; outside that space!  Remember that the screen is only a viewport
; onto a 28.4 by 28.4 space -- if any part of the line is visible
; you MUST render it precisely, regardless of where the end points lie.
; So even if you do it in software, somewhere you'll have to have a
; 32 bit DDA routine.
;
; Our Implementation
; ------------------
;
; We employ a run length slice algorithm: our DDA calculates the
; number of pixels that are in each row (or 'strip') of pixels.
;
; We've separated the running of the DDA and the drawing of pixels:
; we run the DDA for several iterations and store the results in
; a 'strip' buffer (which are the lengths of consecutive pixel rows of
; the line), then we crank up a 'strip drawer' that will draw all the
; strips in the buffer.
;
; We also employ a 'half-flip' to reduce the number of strip
; iterations we need to do in the DDA and strip drawing loops: when a
; (normalized) line's slope is more than 1/2, we do a final flip
; about the line y = (1/2)x.  So now, instead of each strip being
; consecutive horizontal or vertical pixel rows, each strip is composed
; of those pixels aligned in 45 degree rows.  So a line like (0, 0) to
; (128, 128) would generate only one strip.
;
; We also always draw only left-to-right.
;
; Style lines may have arbitrary style patterns.  We specially
; optimize the default patterns (and call them 'masked' styles).
;
; The DDA Derivation
; ------------------
;
; Here is how I like to think of the DDA calculation.
;
; We employ Knuth's "diamond rule": rendering a one-pixel-wide line
; can be thought of as dragging a one-pixel-wide by one-pixel-high
; diamond along the true line.  Pixel centers lie on the integer
; coordinates, and so we light any pixel whose center gets covered
; by the "drag" region (John D. Hobby, Journal of the Association
; for Computing Machinery, Vol. 36, No. 2, April 1989, pp. 209-229).
;
; We must define which pixel gets lit when the true line falls
; exactly half-way between two pixels.  In this case, we follow
; the rule: when two pels are equidistant, the upper or left pel
; is illuminated, unless the slope is exactly one, in which case
; the upper or right pel is illuminated.  (So we make the edges
; of the diamond exclusive, except for the top and left vertices,
; which are inclusive, unless we have slope one.)
;
; This metric decides what pixels should be on any line BEFORE it is
; flipped around for our calculation.  Having a consistent metric
; this way will let our lines blend nicely with our curves.  The
; metric also dictates that we will never have one pixel turned on
; directly above another that's turned on.  We will also never have
; a gap; i.e., there will be exactly one pixel turned on for each
; column between the start and end points.  All that remains to be
; done is to decide how many pixels should be turned on for each row.
;
; So lines we draw will consist of varying numbers of pixels on
; successive rows, for example:
;
;       ******
;             *****
;                  ******
;                        *****
;
; We'll call each set of pixels on a row a "strip".
;
; (Please remember that our coordinate space has the origin as the
; upper left pixel on the screen; postive y is down and positive x
; is right.)
;
; Device coordinates are specified as fixed point 28.4 numbers,
; where the first 28 bits are the integer coordinate, and the last
; 4 bits are the fraction.  So coordinates may be thought of as
; having the form (x, y) = (M/F, N/F) where F is the constant scaling
; factor F = 2^4 = 16, and M and N are 32 bit integers.
;
; Consider the line from (M0/F, N0/F) to (M1/F, N1/F) which runs
; left-to-right and whose slope is in the first octant, and let
; dM = M1 - M0 and dN = N1 - N0.  Then dM >= 0, dN >= 0 and dM >= dN.
;
; Since the slope of the line is less than 1, the edges of the
; drag region are created by the top and bottom vertices of the
; diamond.  At any given pixel row y of the line, we light those
; pixels whose centers are between the left and right edges.
;
; Let mL(n) denote the line representing the left edge of the drag
; region.  On pixel row j, the column of the first pixel to be
; lit is
;
;       iL(j) = ceiling( mL(j * F) / F)
;
; Since the line's slope is less than one:
;
;       iL(j) = ceiling( mL([j + 1/2] F) / F )
;
; Recall the formula for our line:
;
;       n(m) = (dN / dM) (m - M0) + N0
;
;       m(n) = (dM / dN) (n - N0) + M0
;
; Since the line's slope is less than one, the line representing
; the left edge of the drag region is the original line offset
; by 1/2 pixel in the y direction:
;
;       mL(n) = (dM / dN) (n - F/2 - N0) + M0
;
; From this we can figure out the column of the first pixel that
; will be lit on row j, being careful of rounding (if the left
; edge lands exactly on an integer point, the pixel at that
; point is not lit because of our rounding convention):
;
;       iL(j) = floor( mL(j F) / F ) + 1
;
;             = floor( ((dM / dN) (j F - F/2 - N0) + M0) / F ) + 1
;
;             = floor( F dM j - F/2 dM - N0 dM + dN M0) / F dN ) + 1
;
;                      F dM j - [ dM (N0 + F/2) - dN M0 ]
;             = floor( ---------------------------------- ) + 1
;                                   F dN
;
;                      dM j - [ dM (N0 + F/2) - dN M0 ] / F
;             = floor( ------------------------------------ ) + 1       (1)
;                                     dN
;
;             = floor( (dM j + alpha) / dN ) + 1
;
; where
;
;       alpha = - [ dM (N0 + F/2) - dN M0 ] / F
;
; We use equation (1) to calculate the DDA: there are iL(j+1) - iL(j)
; pixels in row j.  Because we are always calculating iL(j) for
; integer quantities of j, we note that the only fractional term
; is constant, and so we can 'throw away' the fractional bits of
; alpha:
;
;       beta = floor( - [ dM (N0 + F/2) - dN M0 ] / F )                 (2)
;
; so
;
;       iL(j) = floor( (dM j + beta) / dN ) + 1                         (3)
;
; for integers j.
;
; Note if iR(j) is the line's rightmost pixel on row j, that
; iR(j) = iL(j + 1) - 1.
;
; Similarly, rewriting equation (1) as a function of column i,
; we can determine, given column i, on which pixel row j is the line
; lit:
;
;                       dN i + [ dM (N0 + F/2) - dN M0 ] / F
;       j(i) = ceiling( ------------------------------------ ) - 1
;                                       dM
;
; Floors are easier to compute, so we can rewrite this:
;
;                     dN i + [ dM (N0 + F/2) - dN M0 ] / F + dM - 1/F
;       j(i) = floor( ----------------------------------------------- ) - 1
;                                       dM
;
;                     dN i + [ dM (N0 + F/2) - dN M0 ] / F + dM - 1/F - dM
;            = floor( ---------------------------------------------------- )
;                                       dM
;
;                     dN i + [ dM (N0 + F/2) - dN M0 - 1 ] / F
;            = floor( ---------------------------------------- )
;                                       dM
;
; We can once again wave our hands and throw away the fractional bits
; of the remainder term:
;
;       j(i) = floor( (dN i + gamma) / dM )                             (4)
;
; where
;
;       gamma = floor( [ dM (N0 + F/2) - dN M0 - 1 ] / F )              (5)
;
; We now note that
;
;       beta = -gamma - 1 = ~gamma                                      (6)
;
; To draw the pixels of the line, we could evaluate (3) on every scan
; line to determine where the strip starts.  Of course, we don't want
; to do that because that would involve a multiply and divide for every
; scan.  So we do everything incrementally.
;
; We would like to easily compute c , the number of pixels on scan j:
;                                  j
;
;    c  = iL(j + 1) - iL(j)
;     j
;
;       = floor((dM (j + 1) + beta) / dN) - floor((dM j + beta) / dN)   (7)
;
; This may be rewritten as
;
;    c  = floor(i    + r    / dN) - floor(i  + r  / dN)                 (8)
;     j          j+1    j+1                j    j
;
; where i , i    are integers and r  < dN, r    < dN.
;        j   j+1                   j        j+1
;
; Rewriting (7) again:
;
;    c  = floor(i  + r  / dN + dM / dN) - floor(i  + r  / dN)
;     j          j    j                          j    j
;
;
;       = floor((r  + dM) / dN) - floor(r  / dN)
;                 j                      j
;
; This may be rewritten as
;
;    c  = dI + floor((r  + dR) / dN) - floor(r  / dN)
;     j                j                      j
;
; where dI + dR / dN = dM / dN, dI is an integer and dR < dN.
;
; r  is the remainder (or "error") term in the DDA loop: r  / dN
;  j                                                      j
; is the exact fraction of a pixel at which the strip ends.  To go
; on to the next scan and compute c    we need to know r   .
;                                  j+1                  j+1
;
; So in the main loop of the DDA:
;
;    c  = dI + floor((r  + dR) / dN) and r    = (r  + dR) % dN
;     j                j                  j+1     j
;
; and we know r  < dN, r    < dN, and dR < dN.
;              j        j+1
;
; We have derived the DDA only for lines in the first octant; to
; handle other octants we do the common trick of flipping the line
; to the first octant by first making the line left-to-right by
; exchanging the end-points, then flipping about the lines y = 0 and
; y = x, as necessary.  We must record the transformation so we can
; undo them later.
;
; We must also be careful of how the flips affect our rounding.  If
; to get the line to the first octant we flipped about x = 0, we now
; have to be careful to round a y value of 1/2 up instead of down as
; we would for a line originally in the first octant (recall that
; "In the case where two pels are equidistant, the upper or left
; pel is illuminated...").
;
; To account for this rounding when running the DDA, we shift the line
; (or not) in the y direction by the smallest amount possible.  That
; takes care of rounding for the DDA, but we still have to be careful
; about the rounding when determining the first and last pixels to be
; lit in the line.
;
; Determining The First And Last Pixels In The Line
; -------------------------------------------------
;
; Fractional coordinates also make it harder to determine which pixels
; will be the first and last ones in the line.  We've already taken
; the fractional coordinates into account in calculating the DDA, but
; the DDA cannot tell us which are the end pixels because it is quite
; happy to calculate pixels on the line from minus infinity to positive
; infinity.
;
; The diamond rule determines the start and end pixels.  (Recall that
; the sides are exclusive except for the left and top vertices.)
; This convention can be thought of in another way: there are diamonds
; around the pixels, and wherever the true line crosses a diamond,
; that pel is illuminated.
;
; Consider a line where we've done the flips to the first octant, and the
; floor of the start coordinates is the origin:
;
;        +-----------------------> +x
;        |
;        | 0                     1
;        |     0123456789abcdef
;        |
;        |   0 00000000?1111111
;        |   1 00000000 1111111
;        |   2 0000000   111111
;        |   3 000000     11111
;        |   4 00000    ** 1111
;        |   5 0000       ****1
;        |   6 000           1***
;        |   7 00             1  ****
;        |   8 ?                     ***
;        |   9 22             3         ****
;        |   a 222           33             ***
;        |   b 2222         333                ****
;        |   c 22222       3333                    **
;        |   d 222222     33333
;        |   e 2222222   333333
;        |   f 22222222 3333333
;        |
;        | 2                     3
;        v
;        +y
;
; If the start of the line lands on the diamond around pixel 0 (shown by
; the '0' region here), pixel 0 is the first pel in the line.  The same
; is true for the other pels.
;
; A little more work has to be done if the line starts in the
; 'nether-land' between the diamonds (as illustrated by the '*' line):
; the first pel lit is the first diamond crossed by the line (pixel 1 in
; our example).  This calculation is determined by the DDA or slope of
; the line.
;
; If the line starts exactly half way between two adjacent pixels
; (denoted here by the '?' spots), the first pixel is determined by our
; round-down convention (and is dependent on the flips done to
; normalize the line).
;
; Last Pel Exclusive
; ------------------
;
; To eliminate repeatedly lit pels between continuous connected lines,
; we employ a last-pel exclusive convention: if the line ends exactly on
; the diamond around a pel, that pel is not lit.  (This eliminates the
; checks we had in the old code to see if we were re-lighting pels.)
;
; The Half Flip
; -------------
;
; To make our run length algorithm more efficient, we employ a "half
; flip".  If after normalizing to the first octant, the slope is more
; than 1/2, we subtract the y coordinate from the x coordinate.  This
; has the effect of reflecting the coordinates through the line of slope
; 1/2.  Note that the diagonal gets mapped into the x-axis after a half
; flip.
;
; How Many Bits Do We Need, Anyway?
; ---------------------------------
;
; Note that if the line is visible on your screen, you must light up
; exactly the correct pixels, no matter where in the 28.4 x 28.4 device
; space the end points of the line lie (meaning you must handle 32 bit
; DDAs, you can certainly have optimized cases for lesser DDAs).
;
; We move the origin to (floor(M0 / F), floor(N0 / F)), so when we
; calculate gamma from (5), we know that 0 <= M0, N0 < F.  And we
; are in the first octant, so dM >= dN.  Then we know that gamma can
; be in the range [(-1/2)dM, (3/2)dM].  The DDI guarantees us that
; valid lines will have dM and dN values at most 31 bits (unsigned)
; of significance.  So gamma requires 33 bits of significance (we store
; this as a 64 bit number for convenience).
;
; When running through the DDA loop, r  + dR can have a value in the
;                                     j
; range 0 <= r  < 2 dN; thus the result must be a 32 bit unsigned value.
;             j
;
; Testing Lines
; -------------
;
; To be NT compliant, a display driver must exactly adhere to GIQ,
; which means that for any given line, the driver must light exactly
; the same pels as does GDI.  This can be tested using the Guiman tool
; provided elsewhere in the DDK, and 'ZTest', which draws random lines
; on the screen and to a bitmap, and compares the results.
;
; If You've Got Line Hardware
; ---------------------------
;
; If your hardware already adheres to GIQ, you're all set.  Otherwise
; you'll want to look at the S3 sample code and read the following:
;
; 1) You'll want to special case integer-only lines, since they require
;    less processing time and are more common (CAD programs will probably
;    only ever give integer lines).  GDI does not provide a flag saying
;    that all lines in a path are integer lines; consequently, you will
;    have to explicitly check every line.
;
; 2) You are required to correctly draw any line in the 28.4 device
;    space that intersects the viewport.  If you have less than 32 bits
;    of significance in the hardware for the Bresenham terms, extremely
;    long lines would overflow the hardware.  For such (rare) cases, you
;    can fall back to strip-drawing code, of which there is a C version in
;    the S3's lines.cxx (or if your display is a frame buffer, fall back
;    to the engine).
;
; 3) If you can explicitly set the Bresenham terms in your hardware, you
;    can draw non-integer lines using the hardware.  If your hardware has
;    'n' bits of precision, you can draw GIQ lines that are up to 2^(n-5)
;    pels long (4 bits are required for the fractional part, and one bit is
;    used as a sign bit).  Note that integer lines don't require the 4
;    fractional bits, so if you special case them as in 1), you can do
;    integer lines that are up to 2^(n - 1) pels long.  See the S3's
;    fastline.asm for an example.
;
;-----------------------------------------------------------------------;

cProc   bLines,36,< \
    uses esi edi ebx,  \
    ppdev:     ptr,   \
    pptfxFirst: ptr,   \
    pptfxBuf:   ptr,   \
    prun:       ptr,   \
    cptfx:      dword, \
    pls:        ptr,   \
    prclClip:   ptr,   \
    apfn:       ptr,   \
    flStart:    dword  >

; ppdev:     Surface data
; pptfxFirst: Start point of first line
; pptfxBuf:   All subsequent points
; prun:       Array of runs if doing complex clipping
; cptfx:      Number of points in pptfxBuf (i.e., # lines)
; pls:        Line state
; prclClip:   Clip rectangle if doing simple clipping
; apfn:       Pointer to table of strip drawers
; flStart:    Flags for all lines

        local cPelsAfterThisBank:    dword ; For bank switching
        local cStripsInNextRun:      dword ; For bank switching
        local pptfxBufEnd:           ptr   ; Last point in pptfxBuf
        local M0:                    dword ; Normalized x0 in device coords
        local dM:                    dword ; Delta-x in device coords
        local N0:                    dword ; Normalized y0 in device coords
        local dN:                    dword ; Delta-y in device coords
        local fl:                    dword ; Flags for current line
        local x:                     dword ; Normalized start pixel x-coord
        local y:                     dword ; Normalized start pixel y-coord
        local eqGamma_lo:            dword ; Upper 32 bits of Gamma
        local eqGamma_hi:            dword ; Lower 32 bits of Gamma
        local x0:                    dword ; Start pixel x-offset
        local y0:                    dword ; Start pixel y-offset
        local ulSlopeOneAdjustment:  dword ; Special offset if line of slope 1
        local cStylePels:            dword ; # of pixels in line (before clip)
        local xStart:                dword ; Start pixel x-offset before clip
        local pfn:                   ptr   ; Pointer to strip drawing function
        local cPels:                 dword ; # pixels to be drawn (after clip)
        local i:                     dword ; # pixels in strip
        local r:                     dword ; Remainder (or "error") term
        local d_I:                   dword ; Delta-I
        local d_R:                   dword ; Delta-R
        local plStripEnd:            ptr   ; Last strip in buffer
        local ptlStart[size POINTL]: byte  ; Unnormalized start coord
        local dN_Original:           dword ; dN before half-flip
        local xClipLeft:             dword ; Left side of clip rectangle
        local xClipRight:            dword ; Right side of clip rectangle
        local strip[size STRIPS]:    byte  ; Our strip buffer

; Do some initializing:

        mov     esi, pls
        mov     ecx, cptfx
        mov     edx, pptfxBuf
        lea     eax, [edx + ecx * (size POINTL) - (size POINTL)]
        mov     pptfxBufEnd, eax        ; pptfxBufEnd is inclusive of end point

        mov     eax, [esi].LS_chAndXor  ; copy chAndXor from LINESTATE to STRIPS
        mov     strip.ST_chAndXor, eax  ;   buffer

        mov     eax, [edx].ptl_x        ; Load up end point (M1, N1)
        mov     edi, [edx].ptl_y

        mov     edx, pptfxFirst         ; Load up start point (M0, N0)
        mov     esi, [edx].ptl_x
        mov     ecx, [edx].ptl_y

        mov     ebx, flStart

;-----------------------------------------------------------------------;
; Flip to the first octant.                                             ;
;-----------------------------------------------------------------------;

; Register state:       esi = M0
;                       ecx = N0
;                       eax = dM (M1)
;                       edi = dN (N1)
;                       ebx = fl

; Make sure we go left to right:

        public  the_main_loop
the_main_loop::
        cmp     esi, eax
        jle     short is_left_to_right  ; skip if M0 <= M1
        xchg    esi, eax                ; swap M0, M1
        xchg    ecx, edi                ; swap N0, N1
        or      ebx, FL_FLIP_H

is_left_to_right:

; Compute the deltas, remembering that the DDI says we should get
; deltas less than 2^31.  If we get more, we ensure we don't crash
; later on by simply skipping the line:

        sub     eax, esi                ; eax = dM
        jo      next_line               ; dM must be less than 2^31
        sub     edi, ecx                ; edi = dN
        jo      next_line               ; dN must be less than 2^31

        jge     short is_top_to_bottom  ; skip if dN >= 0
        neg     ecx                     ; N0 = -N0
        neg     edi                     ; N1 = -N1
        or      ebx, FL_FLIP_V

is_top_to_bottom:
        cmp     edi, eax
        jb      short done_flips        ; skip if dN < dM
        jne     short slope_more_than_one

; We must special case slopes of one (because of our rounding convention):

        or      ebx, FL_FLIP_SLOPE_ONE
        jmp     short done_flips

slope_more_than_one:
        xchg    eax, edi                ; swap dM, dN
        xchg    esi, ecx                ; swap M0, N0
        or      ebx, FL_FLIP_D

done_flips:

        mov     edx, ebx
        and     edx, FL_ROUND_MASK
        .errnz  FL_ROUND_SHIFT - 2
        or      ebx, [gaflRoundTable + edx]  ; get our rounding flags

        mov     dM, eax                 ; save some info
        mov     dN, edi
        mov     fl, ebx

; We're going to shift our origin so that it's at the closest integer
; coordinate to the left/above our fractional start point (it makes
; the math quicker):

        mov     edx, esi                ; x = LFLOOR(M0)
        sar     edx, FLOG2
        mov     x, edx

        mov     edx, ecx                ; y = LFLOOR(N0)
        sar     edx, FLOG2
        mov     y, edx

;-----------------------------------------------------------------------;
; Compute the fractional remainder term                                 ;
;-----------------------------------------------------------------------;

; By shifting the origin we've contrived to eliminate the integer
; portion of our fractional start point, giving us start point
; fractional coordinates in the range [0, F - 1]:

        and     esi, F - 1              ; M0 = FXFRAC(M0)
        and     ecx, F - 1              ; N0 = FXFRAC(N0)

; We now compute Gamma:

        mov     M0, esi                 ; save M0, N0 for later
        mov     N0, ecx

        lea     edx, [ecx + F/2]
        mul     edx                     ; [edx:eax] = dM * (N0 + F/2)
        xchg    eax, edi
        mov     ecx, edx                ; [ecx:edi] = dM * (N0 + F/2)
                                        ; (we just nuked N0)

        mul     esi                     ; [edx:eax] = dN * M0

; Now gamma = dM * (N0 + F/2) - dN * M0 - bRoundDown

        .errnz  FL_V_ROUND_DOWN - 8000h
        ror     bh, 8
        sbb     edi, eax
        sbb     ecx, edx

        shrd    edi, ecx, FLOG2
        sar     ecx, FLOG2              ; gamma = [ecx:edi] >>= 4

        mov     eqGamma_hi, ecx
        mov     eqGamma_lo, edi

        mov     eax, N0

; Register state:
;                       eax = N0
;                       ebx = fl
;                       ecx = eqGamma_hi
;                       edx = garbage
;                       esi = M0
;                       edi = eqGamma_lo

        testb   ebx, FL_FLIP_H
        jnz     line_runs_right_to_left

;-----------------------------------------------------------------------;
; Figure out which pixels are at the ends of a left-to-right line.      ;
;                               -------->                               ;
;-----------------------------------------------------------------------;

        public line_runs_left_to_right
line_runs_left_to_right::
        or      esi, esi
        jz      short LtoR_check_slope_one
                                        ; skip ahead if M0 == 0
                                        ;   (in that case, x0 = 0 which is to be
                                        ;   kept in esi, and is already
                                        ;   conventiently zero)

        or      eax, eax
        jnz     short LtoR_N0_not_zero

        .errnz  FL_H_ROUND_DOWN - 80h
        ror     bl, 8
        sbb     esi, -F/2
        shr     esi, FLOG2
        jmp     short LtoR_check_slope_one
                                        ; esi = x0 = rounded M0

LtoR_N0_not_zero:
        sub     eax, F/2
        sbb     edx, edx
        xor     eax, edx
        sub     eax, edx
        cmp     esi, eax
        sbb     esi, esi
        inc     esi                     ; esi = x0 = (abs(N0 - F/2) <= M0)

        public  LtoR_check_slope_one
LtoR_check_slope_one::
        mov     ulSlopeOneAdjustment, 0
        mov     eax, ebx
        and     eax, FL_FLIP_SLOPE_ONE + FL_H_ROUND_DOWN
        cmp     eax, FL_FLIP_SLOPE_ONE + FL_H_ROUND_DOWN
        jne     short LtoR_compute_y0_from_x0

; We have to special case lines that are exactly of slope 1 or -1:

        ;
        ;       if (M1 > 0) AMD (N1 == M1 + 8)
        ;

        mov     eax, N0
        add     eax, dN
        and     eax, F - 1              ; eax = N1

        mov     edx, M0
        add     edx, dM
        and     edx, F - 1              ; edx = M1

        jz      short LtoR_slope_one_check_start_point

        add     edx, F/2                ; M1 + 8
        cmp     edx, eax                ; cmp N1, M1 + 8
        jne     short LtoR_slope_one_check_start_point
        mov     ulSlopeOneAdjustment, -1

LtoR_slope_one_check_start_point:

        ;
        ;       if (M0 > 0) AMD (N0 == M0 + 8)
        ;

        mov     eax, M0
        or      eax, eax
        jz      short LtoR_compute_y0_from_x0

        add     eax, F/2
        cmp     eax, N0                 ; cmp M0 + 8, N0
        jne     short LtoR_compute_y0_from_x0

        xor     esi, esi                ; x0 = 0

LtoR_compute_y0_from_x0:

; ecx = eqGamma_hi
; esi = x0
; edi = eqGamma_lo

        mov     eax, dN
        mov     edx, dM

        mov     x0, esi
        mov     y0, 0
        cmp     ecx, 0
        jl      short LtoR_compute_x1

        neg     esi
        and     esi, eax
        sub     edx, esi
        cmp     edi, edx
        mov     edx, dM
        jb      short LtoR_compute_x1   ; Bug fix: Must be unsigned!
        mov     y0, 1                   ; y0 = floor((dN * x0 + eqGamma) / dM)

LtoR_compute_x1:

; Register state:
;                       eax = dN
;                       ebx = fl
;                       ecx = garbage
;                       edx = dM
;                       esi = garbage
;                       edi = garbage

        mov     esi, M0
        add     esi, edx
        mov     ecx, esi
        shr     esi, FLOG2
        dec     esi                     ; x1 = ((M0 + dM) >> 4) - 1
        add     esi, ulSlopeOneAdjustment
        and     ecx, F-1                ; M1 = (M0 + dM) & 15
        jz      done_first_pel_last_pel

        add     eax, N0
        and     eax, F-1                ; N1 = (N0 + dN) & 15
        jnz     short LtoR_N1_not_zero

        .errnz  FL_H_ROUND_DOWN - 80h
        ror     bl, 8
        sbb     ecx, -F/2
        shr     ecx, FLOG2              ; ecx = LROUND(M1, fl & FL_ROUND_DOWN)
        add     esi, ecx
        jmp     done_first_pel_last_pel

LtoR_N1_not_zero:
        sub     eax, F/2
        sbb     edx, edx
        xor     eax, edx
        sub     eax, edx
        cmp     eax, ecx
        jg      done_first_pel_last_pel
        inc     esi
        jmp     done_first_pel_last_pel

;-----------------------------------------------------------------------;
; Figure out which pixels are at the ends of a right-to-left line.      ;
;                               <--------                               ;
;-----------------------------------------------------------------------;

; Compute x0:

        public  line_runs_right_to_left
line_runs_right_to_left::
        mov     x0, 1                   ; x0 = 1
        or      eax, eax
        jnz     short RtoL_N0_not_zero

        xor     edx, edx                ; ulDelta = 0
        .errnz  FL_H_ROUND_DOWN - 80h
        ror     bl, 8
        sbb     esi, -F/2
        shr     esi, FLOG2              ; esi = LROUND(M0, fl & FL_H_ROUND_DOWN)
        jz      short RtoL_check_slope_one

        mov     x0, 2
        mov     edx, dN
        jmp     short RtoL_check_slope_one

RtoL_N0_not_zero:
        sub     eax, F/2
        sbb     edx, edx
        xor     eax, edx
        sub     eax, edx
        add     eax, esi                ; eax = ABS(N0 - F/2) + M0
        xor     edx, edx                ; ulDelta = 0
        cmp     eax, F
        jle     short RtoL_check_slope_one

        mov     x0, 2                   ; x0 = 2
        mov     edx, dN                 ; ulDelta = dN

        public  RtoL_check_slope_one
RtoL_check_slope_one::
        mov     ulSlopeOneAdjustment, 0
        mov     eax, ebx
        and     eax, FL_FLIP_SLOPE_ONE + FL_H_ROUND_DOWN
        cmp     eax, FL_FLIP_SLOPE_ONE
        jne     short RtoL_compute_y0_from_x0

; We have to special case lines that are exactly of slope 1 or -1:

        ;
        ;  if ((N1 > 0) && (M1 == N1 + 8))
        ;

        mov     eax, N0
        add     eax, dN
        and     eax, F - 1              ; eax = N1
        jz      short RtoL_slope_one_check_start_point

        mov     esi, M0
        add     esi, dM
        and     esi, F - 1              ; esi = M1

        add     eax, F/2                ; N1 + 8
        cmp     esi, eax                ; cmp M1, N1 + 8
        jne     short RtoL_slope_one_check_start_point
        mov     ulSlopeOneAdjustment, 1

RtoL_slope_one_check_start_point:

        ;
        ;  if ((N0 > 0) && (M0 == N0 + 8))
        ;

        mov     eax,N0                  ; eax = N0
        or      eax,eax                 ; check for N0 == 0
        jz      short RtoL_compute_y0_from_x0

        mov     esi, M0                 ; esi = M0

        add     eax, F/2                ; N0 + 8
        cmp     eax, esi                ; cmp M0 , N0 + 8
        jne     short RtoL_compute_y0_from_x0

        mov     x0, 2                   ; x0 = 2
        mov     edx, dN                 ; ulDelta = dN

RtoL_compute_y0_from_x0:

; eax = garbage
; ebx = fl
; ecx = eqGamma_hi
; edx = ulDelta
; esi = garbage
; edi = eqGamma_lo

        mov     eax, dN                 ; eax = dN
        mov     y0, 0                   ; y0 = 0

        add     edi, edx
        adc     ecx, 0                  ; eqGamma += ulDelta
                                        ; NOTE: Setting flags here!
        mov     edx, dM                 ; edx = dM
        jl      short RtoL_compute_x1   ; NOTE: Looking at the flags here!
        jg      short RtoL_y0_is_2

        lea     ecx, [edx + edx]
        sub     ecx, eax                ; ecx = 2 * dM - dN
        cmp     edi, ecx
        jae     short RtoL_y0_is_2      ; Bug fix: Must be unsigned!

        sub     ecx, edx                ; ecx = dM - dN
        cmp     edi, ecx
        jb      short RtoL_compute_x1   ; Bug fix: Must be unsigned!

        mov     y0, 1
        jmp     short RtoL_compute_x1

RtoL_y0_is_2:
        mov     y0, 2

RtoL_compute_x1:

; Register state:
;                       eax = dN
;                       ebx = fl
;                       ecx = garbage
;                       edx = dM
;                       esi = garbage
;                       edi = garbage

        mov     esi, M0
        add     esi, edx
        mov     ecx, esi
        shr     esi, FLOG2              ; x1 = (M0 + dM) >> 4
        add     esi, ulSlopeOneAdjustment
        and     ecx, F-1                ; M1 = (M0 + dM) & 15

        add     eax, N0
        and     eax, F-1                ; N1 = (N0 + dN) & 15
        jnz     short RtoL_N1_not_zero

        .errnz  FL_H_ROUND_DOWN - 80h
        ror     bl, 8
        sbb     ecx, -F/2
        shr     ecx, FLOG2              ; ecx = LROUND(M1, fl & FL_ROUND_DOWN)
        add     esi, ecx
        jmp     done_first_pel_last_pel

RtoL_N1_not_zero:
        sub     eax, F/2
        sbb     edx, edx
        xor     eax, edx
        sub     eax, edx
        add     eax, ecx                ; eax = ABS(N1 - F/2) + M1
        cmp     eax, F+1
        sbb     esi, -1

done_first_pel_last_pel:

; Register state:
;                       eax = garbage
;                       ebx = fl
;                       ecx = garbage
;                       edx = garbage
;                       esi = x1
;                       edi = garbage

        mov     ecx, x0
        lea     edx, [esi + 1]
        sub     edx, ecx                ; edx = x1 - x0 + 1

        jle     next_line
        mov     cStylePels, edx
        mov     xStart, ecx

;-----------------------------------------------------------------------;
; See if clipping or styling needs to be done.                          ;
;-----------------------------------------------------------------------;

        testb   ebx, FL_CLIP
        jnz     do_some_clipping

; Register state:
;                       eax = garbage
;                       ebx = fl
;                       ecx = x0        (stack variable correct too)
;                       edx = garbage
;                       esi = x1
;                       edi = garbage

done_clipping:
        mov     eax, y0

        sub     esi, ecx
        inc     esi                     ; esi = cPels = x1 - x0 + 1
        mov     cPels, esi

        mov     esi, ppdev
        add     ecx, x                  ; ecx = ptlStart.ptl_x
        add     eax, y                  ; eax = ptlStart.ptl_y

        mov     esi, [esi].pdev_lNextScan ; we'll compute the sign of lNextScan

        testb   ebx, FL_FLIP_D
        jz      short do_v_unflip
        xchg    ecx, eax

do_v_unflip:
        testb   ebx, FL_FLIP_V
        jz      short done_unflips
        neg     eax
        neg     esi

done_unflips:
        mov     strip.ST_lNextScan, esi ; lNextScan now right for y-direction
        testb   ebx, FL_STYLED
        jnz     do_some_styling

done_styling:
        lea     edx, [strip.ST_alStrips + (STRIP_MAX * 4)]
        mov     plStripEnd, edx

        mov     cPelsAfterThisBank, 0
        mov     cStripsInNextRun, 7fffffffh

;-----------------------------------------------------------------------;
; Do banking setup.                                                     ;
;-----------------------------------------------------------------------;

        public  bank_setup
bank_setup::

; Register state:
;                       eax = ptlStart.ptl_y
;                       ebx = fl
;                       ecx = ptlStart.ptl_x
;                       edx = garbage
;                       esi = garbage
;                       edi = garbage

        mov     esi, ppdev
        cmp     eax, [esi].pdev_rcl1WindowClip.yTop
        jl      short bank_get_initial_bank   ; ptlStart.y < rcl1WindowClip.yTop

        cmp     eax, [esi].pdev_rcl1WindowClip.yBottom
        jl      short bank_got_initial_bank   ; ptlStart.y < rcl1WindowClip.yBot

bank_get_initial_bank:
        mov     ptlStart.ptl_y, eax     ; Save ptlStart.ptl_y
        mov     edi, ecx                ; Save ptlStart.ptl_x

        .errnz  JustifyTop
        .errnz  JustifyBottom - 1
        .errnz  FL_FLIP_V - 8

        mov     ecx, ebx                ; JustifyTop if line goes down,
        shr     ecx, 3                  ; JustifyBottom if line goes up
        and     ecx, 1

bank_justified:
        ptrCall <dword ptr [esi].pdev_pfnBankControl>, \
                <esi, eax, ecx>

        mov     eax, ptlStart.ptl_y
        mov     ecx, edi

bank_got_initial_bank:
        testb   ebx, FL_FLIP_D
        jz      short bank_major_x

bank_major_y:
        testb   ebx, FL_FLIP_V
        jz      short bank_major_y_down
bank_major_y_up:
        lea     edi, [eax + 1]
        sub     edi, [esi].pdev_rcl1WindowClip.yTop
        jmp     short bank_done_y_major
bank_major_y_down:
        mov     edi, [esi].pdev_rcl1WindowClip.yBottom
        sub     edi, eax
bank_done_y_major:
        mov     esi, cPels
        sub     esi, edi                ; edi = cPelsInBank
        mov     cPelsAfterThisBank, esi
        jle     short done_bank_setup
        mov     cPels, edi
        jmp     short done_bank_setup

bank_major_x:
        mov     edi, dN
        shr     edi, FLOG2
        add     edi, y

; We're guessing at the y-position of the end pixel (it's too much work
; to compute the actual value) to see if the line spans more than one
; bank.  We have to add at least a slop value of '3' because the actual
; start pixel may be may 2 off from 'y' because of end-pixel exclusiveness,
; and we have to add 1 more because we're taking the floor of (dN / F), to
; account for rounding:

        add     edi, 3                  ; yEnd = edi = y + LFLOOR(dN) + 3
        testb   ebx, FL_FLIP_V
        jz      short bank_major_x_down
bank_major_x_up:
        mov     edx, 1
        sub     edx, [esi].pdev_rcl1WindowClip.yTop    ; edx = -yNextBankStart

        cmp     edi, edx
        lea     edx, [edx + eax]        ; edx = cStripsInNextRun
        jl      short bank_major_x_done

; Line may go over bank boundary, so don't do a half flip:

        or      ebx, FL_DONT_DO_HALF_FLIP
        jmp     short bank_major_x_done

bank_major_x_down:
        mov     esi, [esi].pdev_rcl1WindowClip.yBottom  ; esi = yNextBankStart

        mov     edx, esi
        sub     edx, eax                ; edx = cStripsInNextRun

        cmp     edi, esi
        jl      short bank_major_x_done
        or      ebx, FL_DONT_DO_HALF_FLIP

bank_major_x_done:
        sub     edx, STRIP_MAX
        mov     cStripsInNextRun, edx
        jge     short done_bank_setup

        lea     edx, [strip.ST_alStrips + edx * 4 + (STRIP_MAX * 4)]
        mov     plStripEnd, edx

done_bank_setup:

;-----------------------------------------------------------------------;
; Setup to do DDA.                                                      ;
;-----------------------------------------------------------------------;

; Register state:
;                       eax = ptlStart.ptl_y
;                       ebx = fl
;                       ecx = ptlStart.ptl_x
;                       edx = garbage
;                       esi = garbage
;                       edi = garbage

        mov     esi, ppdev
        mov     edi, eax                ; Now edi = ptlStart.ptl_y
        imul    [esi].pdev_lNextScan
        add     eax, [esi].pdev_pvBitmapStart
        add     eax, ecx
        mov     strip.ST_pjScreen, eax  ; pjScreen = pchBits + ptlStart.y *
                                        ;   cjDelta + ptlStart.x

        mov     eax, dM
        mov     ecx, dN
        mov     esi, eqGamma_lo
        mov     edi, eqGamma_hi

; Register state:
;                       eax = dM
;                       ebx = fl
;                       ecx = dN
;                       edx = garbage
;                       esi = eqGamma_lo
;                       edi = eqGamma_hi

        lea     edx, [ecx + ecx]        ; if (2 * dN > dM)
        cmp     edx, eax
        mov     edx, y0                 ; Load y0 again
        jbe     short after_half_flip

        test    ebx, FL_DONT_DO_HALF_FLIP
        jnz     short after_half_flip

        or      ebx, FL_FLIP_HALF
        mov     fl, ebx

; Do a half flip!

        not     esi
        not     edi
        add     esi, eax
        adc     edi, 0                  ; eqGamma = -eqGamma - 1 + dM

        neg     ecx
        add     ecx, eax                ; dN = dM - dN

        neg     edx
        add     edx, x0                 ; y0 = x0 - y0

after_half_flip:
        mov     strip.ST_flFlips, ebx
        and     ebx, FL_STRIP_MASK

        .errnz  FL_STRIP_SHIFT
        mov     eax, apfn
        lea     eax, [eax + ebx * 4]
        mov     eax, [eax]
        mov     pfn, eax
        mov     eax, dM

; Register state:
;                       eax = dM
;                       ebx = garbage
;                       ecx = dN
;                       edx = y0
;                       esi = eqGamma_lo
;                       edi = eqGamma_hi

        or      ecx, ecx
        jz      short zero_slope

compute_dda_stuff:
        inc     edx
        mul     edx
        stc                             ; set the carry to accomplish -1
        sbb     eax, esi
        sbb     edx, edi                ; (y0 + 1) * dM - eqGamma - 1
        div     ecx

        mov     esi, eax                ; esi = i
        mov     edi, edx                ; edi = r

        xor     edx, edx
        mov     eax, dM
        div     ecx                     ; edx = d_R, eax = d_I
        mov     d_I, eax

        sub     esi, x0
        inc     esi

done_dda_stuff:
        lea     eax, [strip.ST_alStrips]
        mov     ebx, cPels

;-----------------------------------------------------------------------;
; Do our main DDA loop.                                                 ;
;-----------------------------------------------------------------------;

        sub     edi, ecx                ; offset remainder term from [0..dN)
                                        ;   to [-dN..0) so test in inner
                                        ;   loop is quicker

; Register state:
;                       eax = plStrip   ; current pointer into strip array
;                       ebx = cPels     ; total number of pels in line
;                       ecx = dN        ; delta-N = rise in line
;                       edx = d_R       ; d_I + d_R/dN = exact strip length
;                       esi = i         ; length of current strip
;                       edi = r         ; remainder term for current strip
;                                       ;   in range [-dN..0)

        public  dda_loop
dda_loop::
        sub     ebx, esi                ; subtract strip length from line length
        jle     final_strip             ; if negative, done with line

        mov     [eax], esi              ; write strip length to strip array
        add     eax, 4
        cmp     plStripEnd, eax         ; is the strip array buffer full?
        jbe     short output_strips     ; if so, empty it

; The output_strips routine jumps to here when done:

done_output_strips:
        mov     esi, d_I                ; our normal strip length
        add     edi, edx                ; adjust our remainder term
        jl      short dda_loop

        sub     edi, ecx                ; our remainder became 1 or more, so
        inc     esi                     ;   we increment this strip length
                                        ;   and adjust the remainder term

; We've unrolled our loop a bit, so this should look familiar to the above:

        sub     ebx, esi                ; subtract strip length from line length
        jle     final_strip             ; if negative, done with line

        mov     [eax], esi              ; write strip length to strip array
        add     eax, 4                  ; adjust strip pointer

; Note that banking requires us to check if the strip array is full here
; too (and note that if output_strips is called it will return to
; done_output_strips):

        cmp     plStripEnd, eax
        jbe     short output_strips

        mov     esi, d_I                ; our normal strip length
        add     edi, edx                ; adjust our remainder term
        jl      short dda_loop

        sub     edi, ecx                ; our remainder became 1 or more, so
        inc     esi                     ; adjust
        jmp     short dda_loop

zero_slope:
        mov     esi, 7fffffffh
        jmp     short done_dda_stuff

;-----------------------------------------------------------------------;
; Empty strips buffer & possibly do x-major bank switch.                ;
;-----------------------------------------------------------------------;

output_strips:
        mov     d_R, edx
        mov     cPels, ebx
        mov     i, esi
        mov     r, edi
        mov     dN, ecx

        lea     edx, [strip]
        mov     ecx, pls

; Call our strip routine:

        ptrCall <dword ptr pfn>, \
                <edx, ecx, eax>

; It may be that we ran out of run in our strips buffer, and don't
; actually have to switch banks.  See if that's the case:

        mov     eax, cStripsInNextRun
        or      eax, eax
        jg      short done_strip_bank_switch

; We have to switch banks.  See if we're going up or down:

        mov     esi, ppdev
        test    fl, FL_FLIP_V
        jz      short bank_x_down

bank_x_up:
        mov     edi, strip.ST_pjScreen
        sub     edi, [esi].pdev_pvBitmapStart
        mov     ebx, [esi].pdev_rcl1WindowClip.yTop
        dec     ebx                     ; we want yTop - 1 to be mapped in

; Map in the next higher bank:

        ptrCall <dword ptr [esi].pdev_pfnBankControl>, \
                <esi, ebx, JustifyBottom>; ebx, esi and edi are preserved

        lea     eax, [ebx + 1]
        sub     eax, [esi].pdev_rcl1WindowClip.yTop
                                        ; eax = # of scans can do in bank

        add     edi, [esi].pdev_pvBitmapStart
        mov     strip.ST_pjScreen, edi

        jmp     short done_strip_bank_switch

bank_x_down:
        mov     edi, strip.ST_pjScreen
        sub     edi, [esi].pdev_pvBitmapStart
        mov     ebx, [esi].pdev_rcl1WindowClip.yBottom

; Map in the next lower bank:

        ptrCall <dword ptr [esi].pdev_pfnBankControl>, \
                <esi, ebx, JustifyTop>  ; ebx, esi and edi are preserved

        mov     eax, [esi].pdev_rcl1WindowClip.yBottom
        sub     eax, ebx                ; eax = # scans can do in bank

        add     edi, [esi].pdev_pvBitmapStart
        mov     strip.ST_pjScreen,edi

done_strip_bank_switch:

; eax = cStripsInNextRun

        lea     edx, [strip.ST_alStrips + (STRIP_MAX * 4)]
        sub     eax, STRIP_MAX
        mov     cStripsInNextRun, eax
        jge     short get_ready_for_more_strips
        lea     edx, [edx + eax * 4]

get_ready_for_more_strips:
        mov     plStripEnd, edx

        mov     esi, i
        mov     edi, r
        mov     ebx, cPels
        mov     edx, d_R
        mov     ecx, dN
        lea     eax, [strip.ST_alStrips]
        jmp     done_output_strips

;-----------------------------------------------------------------------;
; Empty strips buffer.  Either get new line or do y-major bank switch.  ;
;-----------------------------------------------------------------------;

final_strip:
        add     ebx, esi
        mov     [eax], ebx
        add     eax, 4

        cmp     cPelsAfterThisBank, 0
        jg      short bank_y_major

very_final_strip:
        lea     edx, [strip]
        mov     ecx, pls

        ptrCall <dword ptr pfn>, \
                <edx, ecx, eax>

; NOTE: next_line is jumped to from various places, and it cannot assume
;       any registers are loaded.

next_line:
        mov     ebx, flStart
        testb   ebx, FL_COMPLEX_CLIP
        jnz     short see_if_done_complex_clipping

        mov     edx, pptfxBuf
        cmp     edx, pptfxBufEnd
        je      short all_done

        mov     esi, [edx].ptl_x
        mov     ecx, [edx].ptl_y
        add     edx, size POINTL
        mov     pptfxBuf, edx
        mov     eax, [edx].ptl_x
        mov     edi, [edx].ptl_y
        jmp     the_main_loop

all_done:
        mov     eax, 1

        cRet    bLines

see_if_done_complex_clipping:
        mov     ebx, fl
        dec     cptfx
        jz      short all_done

        and     ebx, NOT FL_FLIP_HALF   ; Make sure the next run doesn't have
        mov     fl, ebx                 ;   to do a half-flip if it doesn't
                                        ;   want to
        jmp     continue_complex_clipping

;-----------------------------------------------------------------------;
; Switch banks for a y-major line.                                      ;
;-----------------------------------------------------------------------;

        public  bank_y_major
bank_y_major::
        mov     d_R, edx
        mov     i, esi
        mov     r, edi
        mov     dN, ecx
        sub     ebx, esi                ; Undo our offset

bank_y_output_strips:
        lea     edx, [strip]
        mov     ecx, pls

        ptrCall <dword ptr pfn>, \
                <edx, ecx, eax>

        mov     esi, ppdev
        test    fl, FL_FLIP_V
        jz      short bank_y_down

bank_y_up:
        mov     edi, strip.ST_pjScreen
        sub     edi, [esi].pdev_pvBitmapStart
        mov     ecx, [esi].pdev_rcl1WindowClip.yTop
        push    ecx
        dec     ecx                     ; we want yTop - 1 to be mapped in

; Map in the next higher bank:

        ptrCall <dword ptr [esi].pdev_pfnBankControl>, \
                <esi, ecx, JustifyBottom>; ebx, esi and edi are preserved

        pop     ecx
        sub     ecx, [esi].pdev_rcl1WindowClip.yTop
                                        ; ecx = # of scans can do in bank

        add     edi, [esi].pdev_pvBitmapStart
        mov     strip.ST_pjScreen, edi

        mov     edx, cPelsAfterThisBank                 ; edx = cPelsAfterBank
        lea     eax, [strip.ST_alStrips]                ; eax = plStrip
        or      ebx, ebx                                ; ebx = cPels
        jge     bank_y_done_partial_strip
        jmp     short bank_y_done_switch

bank_y_down:
        mov     edi, strip.ST_pjScreen
        sub     edi, [esi].pdev_pvBitmapStart
        mov     ecx, [esi].pdev_rcl1WindowClip.yBottom
        push    ecx

; Map in the next lower bank:

        ptrCall <dword ptr [esi].pdev_pfnBankControl>, \
                <esi, ecx, JustifyTop>  ; ebx, esi and edi are preserved

        pop     eax
        mov     ecx, [esi].pdev_rcl1WindowClip.yBottom
        sub     ecx, eax                ; ecx = # scans can do in bank

        add     edi, [esi].pdev_pvBitmapStart
        mov     strip.ST_pjScreen,edi

        mov     edx, cPelsAfterThisBank                 ; edx = cPelsAfterBank
        lea     eax, [strip.ST_alStrips]                ; eax = plStrip
        or      ebx, ebx                                ; ebx = cPels
        jge     short bank_y_done_partial_strip

bank_y_done_switch:

; Handle a single strip stretching over multiple banks:

        test    fl, FL_FLIP_HALF
        jz      short bank_y_no_half_flip

; We now have to adjust for the fact that the strip drawers always leave
; the state ready for the next new strip (e.g., if we're doing vertical
; strips, it advances pjScreen one to the right after drawing each strip).
; But the problem is that since we crossed a bank, we have to continue the
; *old* strip, so we have to undo that advance:

bank_y_half_flip:
        inc     strip.ST_pjScreen
        jmp     short bank_y_done_bit_adjust

bank_y_no_half_flip:
        dec     strip.ST_pjScreen

bank_y_done_bit_adjust:
        mov     esi, ebx
        neg     esi                             ; esi = # pels left in strip

; eax = pointer to first strip entry
; ebx = negative esi
; ecx = # of pels we can put down in this window
; edx = # of pels remaining to do in line
; esi = # of pels left in strip

; We have three special cases to check here:
;
;       1) If the strip spans the entire next window
;       2) This is the last strip in the line
;       3) Neither of the above

        cmp     edx,ecx                         ;if line shorter than bank,
        jle     short bank_y_check_if_last_strip;  know strip doesn't span bank

        cmp     esi,ecx                         ;if line spans bank, don't have
        jl      short bank_y_continue_strip     ;  to check if last strip

; If ((# of pels in line > window size) && (# of pels in strip > window size))
; then the strip spans this bank:

        mov     [eax], ecx
        add     eax, 4
        add     ebx, ecx
        sub     edx, ecx
        mov     cPelsAfterThisBank, edx
        jmp     bank_y_output_strips

bank_y_check_if_last_strip:
        cmp     esi, edx                        ;if strip is shorter than line,
        jl      short bank_y_continue_strip     ;  we know this isn't the last
                                                ;  strip

; Handle case where this is the last strip in the line and it overlaps a bank:

        mov     [eax], edx
        add     eax, 4
        jmp     very_final_strip

bank_y_continue_strip:
        mov     [eax], esi
        add     eax, 4

bank_y_done_partial_strip:
        add     ebx, edx                ; cPels += cPelsAfterThisBank
        sub     edx, ecx                ; cPelsAfterThisBank -= cyWindow

        jle     short bank_y_get_ready
        sub     ebx, edx

bank_y_get_ready:
        mov     cPelsAfterThisBank, edx
        mov     edi, r
        mov     edx, d_R
        mov     ecx, dN
        jmp     done_output_strips

;---------------------------Private-Routine-----------------------------;
; do_some_styling
;
; Inputs:
;       eax = ptlStart.ptl_y
;       ebx = fl
;       ecx = ptlStart.ptl_x
; Preserves:
;       eax, ebx, ecx
; Output:
;       Exits to done_styling.
;
;-----------------------------------------------------------------------;

        public  do_some_styling
do_some_styling::
        mov     esi, pls
        mov     ptlStart.ptl_x, ecx

        mov     edi, [esi].LS_spNext    ; spThis
        mov     edx, edi
        add     edx, cStylePels         ; spNext

do_non_alternate_style:

; For styles, we don't bother to keep the style position normalized.
; (we do ensure that it's positive, though).  If a figure is over 2
; billion pels long, we'll be a pel off in our style state (oops!).

        and     edx, 7fffffffh
        mov     [esi].LS_spNext, edx
        mov     ptlStart.ptl_y, eax

        testb   ebx, FL_FLIP_H
        jz      short arbitrary_left_to_right

        sub     edx, x0
        add     edx, xStart
        mov     eax, edx
        xor     edx, edx
        div     [esi].LS_spTotal

        neg     edx
        jge     short continue_right_to_left
        add     edx, [esi].LS_spTotal
        not     eax

continue_right_to_left:
        mov     edi, dword ptr [esi].LS_bStartIsGap
        not     edi
        mov     ecx, [esi].LS_aspRtoL
        jmp     short compute_arbitrary_stuff

arbitrary_left_to_right:
        add     edi, x0
        sub     edi, xStart
        mov     eax, edi
        xor     edx, edx
        div     [esi].LS_spTotal
        mov     edi, dword ptr [esi].LS_bStartIsGap
        mov     ecx, [esi].LS_aspLtoR

compute_arbitrary_stuff:
;       eax = sp / spTotal
;       ebx = fl
;       ecx = pspStart
;       edx = sp % spTotal
;       esi = pls
;       edi = bIsGap

        and     eax, [esi].LS_cStyle        ; if odd length style and second run
        and     al, 1                       ; through style array, flip the
        jz      short odd_style_array_done  ; meaning of the elements
        not     edi

odd_style_array_done:
        mov     eax, [esi].LS_cStyle
        mov     strip.ST_pspStart, ecx
        lea     eax, [ecx + eax * 4 - 4]
        mov     strip.ST_pspEnd, eax

find_psp:
        sub     edx, [ecx]
        jl      short found_psp
        add     ecx, 4
        jmp     short find_psp

found_psp:
        mov     strip.ST_psp, ecx
        neg     edx
        mov     strip.ST_spRemaining, edx

        sub     ecx, strip.ST_pspStart
        test    ecx, 4                      ; size STYLEPOS
        jz      short done_arbitrary
        not     edi

done_arbitrary:
        mov     dword ptr strip.ST_bIsGap, edi
        mov     eax, ptlStart.ptl_y
        mov     ecx, ptlStart.ptl_x
        jmp     done_styling

;---------------------------Private-Routine-----------------------------;
; do_some_clipping
;
; Inputs:
;       eax = garbage
;       ebx = fl
;       ecx = x0
;       edx = garbage
;       esi = x1
;       edi = garbage
;
; Decides whether to do simple or complex clipping.
;
;-----------------------------------------------------------------------;

        public  do_some_clipping
do_some_clipping::
        testb   ebx, FL_COMPLEX_CLIP
        jnz     initialize_complex_clipping

;-----------------------------------------------------------------------;
; simple_clipping
;
; Inputs:
;       ebx = fl
;       ecx = x0
;       esi = x1
; Output:
;       ebx = fl
;       ecx = new x0 (stack variable updated too)
;       esi = new x1
;       y0 stack variable updated
; Uses:
;       All registers
; Exits:
;       to done_clipping
;
; This routine handles clipping the line to the clip rectangle (it's
; faster to handle this case in the driver than to call the engine to
; clip for us).
;
; Fractional end-point lines complicate our lives a bit when doing
; clipping:
;
; 1) For styling, we must know the unclipped line's length in pels, so
;    that we can correctly update the styling state when the line is
;    clipped.  For this reason, I do clipping after doing the hard work
;    of figuring out which pixels are at the ends of the line (this is
;    wasted work if the line is not styled and is completely clipped,
;    but I think it's simpler this way).  Another reason is that we'll
;    have calculated eqGamma already, which we use for the intercept
;    calculations.
;
;    With the assumption that most lines will not be completely clipped
;    away, this strategy isn't too painful.
;
; 2) x0, y0 are not necessarily zero, where (x0, y0) is the start pel of
;    the line.
;
; 3) We know x0, y0 and x1, but not y1.  We haven't needed to calculate
;    y1 until now.  We'll need the actual value, and not an upper bound
;    like y1 = LFLOOR(dM) + 2 because we have to be careful when
;    calculating x(y) that y0 <= y <= y1, otherwise we can cause an
;    overflow on the divide (which, needless to say, is bad).
;
;-----------------------------------------------------------------------;

        public  simple_clipping
simple_clipping::
        mov     edi, prclClip           ; get pointer to normalized clip rect
        and     ebx, FL_RECTLCLIP_MASK  ;   (it's lower-right exclusive)

        .errnz  (FL_RECTLCLIP_SHIFT - 2); ((ebx AND FL_RECTLCLIP_MASK) shr
        .errnz  (size RECTL) - 16       ;   FL_RECTLCLIP_SHIFT) is our index
        lea     edi, [edi + ebx*4]      ;   into the array of rectangles

        mov     edx, [edi].xRight       ; load the rect coordinates
        mov     eax, [edi].xLeft
        mov     ebx, [edi].yBottom
        mov     edi, [edi].yTop

; Translate to our origin and so some quick completely clipped tests:

        sub     edx, x
        cmp     ecx, edx
        jge     totally_clipped         ; totally clipped if x0 >= xRight

        sub     eax, x
        cmp     esi, eax
        jl      totally_clipped         ; totally clipped if x1 < xLeft

        sub     ebx, y
        cmp     y0, ebx
        jge     totally_clipped         ; totally clipped if y0 >= yBottom

        sub     edi, y

; Save some state:

        mov     xClipRight, edx
        mov     xClipLeft, eax

        cmp     esi, edx                ; if (x1 >= xRight) x1 = xRight - 1
        jl      short calculate_y1
        lea     esi, [edx - 1]

calculate_y1:
        mov     eax, esi                ; y1 = (x1 * dN + eqGamma) / dM
        mul     dN
        add     eax, eqGamma_lo
        adc     edx, eqGamma_hi
        div     dM

        cmp     edi, eax                ; if (yTop > y1) clipped
        jg      short totally_clipped

        cmp     ebx, eax                ; if (yBottom > y1) know x1
        jg      short x1_computed

        mov     eax, ebx                ; x1 = (yBottom * dM + eqBeta) / dN
        mul     dM
        stc
        sbb     eax, eqGamma_lo
        sbb     edx, eqGamma_hi
        div     dN
        mov     esi, eax

; At this point, we've taken care of calculating the intercepts with the
; right and bottom edges.  Now we work on the left and top edges:

x1_computed:
        mov     edx, y0

        mov     eax, xClipLeft          ; don't have to compute y intercept
        cmp     eax, ecx                ;   at left edge if line starts to
        jle     short top_intercept     ;   right of left edge

        mov     ecx, eax                ; x0 = xLeft
        mul     dN                      ; y0 = (xLeft * dN + eqGamma) / dM
        add     eax, eqGamma_lo
        adc     edx, eqGamma_hi
        div     dM

        cmp     ebx, eax                ; if (yBottom <= y0) clipped
        jle     short totally_clipped

        mov     edx, eax
        mov     y0, eax

top_intercept:
        mov     ebx, fl                 ; get ready to leave
        mov     x0, ecx

        cmp     edi, edx                ; if (yTop <= y0) done clipping
        jle     done_clipping

        mov     eax, edi                ; x0 = (yTop * dM + eqBeta) / dN + 1
        mul     dM
        stc
        sbb     eax, eqGamma_lo
        sbb     edx, eqGamma_hi
        div     dN
        lea     ecx, [eax + 1]

        cmp     xClipRight, ecx         ; if (xRight <= x0) clipped
        jle     short totally_clipped

        mov     y0, edi                 ; y0 = yTop
        mov     x0, ecx
        jmp     done_clipping           ; all done!

totally_clipped:

; The line is completely clipped.  See if we have to update our style state:

        mov     ebx, fl
        testb   ebx, FL_STYLED
        jz      next_line

; Adjust our style state:

        mov     esi, pls
        mov     eax, [esi].LS_spNext
        add     eax, cStylePels
        mov     [esi].LS_spNext, eax

        cmp     eax, [esi].LS_spTotal2
        jb      next_line

; Have to normalize first:

        xor     edx, edx
        div     [esi].LS_spTotal2
        mov     [esi].LS_spNext, edx

        jmp     next_line

;-----------------------------------------------------------------------;

initialize_complex_clipping:
        mov     eax, dN                 ; save a copy of original dN
        mov     dN_Original, eax

;---------------------------Private-Routine-----------------------------;
; continue_complex_clipping
;
; Inputs:
;       ebx = fl
; Output:
;       ebx = fl
;       ecx = x0
;       esi = x1
; Uses:
;       All registers.
; Exits:
;       to done_clipping
;
; This routine handles the necessary initialization for the next
; run in the CLIPLINE structure.
;
; NOTE: This routine is jumped to from two places!
;-----------------------------------------------------------------------;

        public  continue_complex_clipping
continue_complex_clipping::
        mov     edi, prun
        mov     ecx, xStart
        testb   ebx, FL_FLIP_H
        jz      short complex_left_to_right

complex_right_to_left:

; Figure out x0 and x1 for right-to-left lines:

        add     ecx, cStylePels
        dec     ecx
        mov     esi, ecx                ; esi = ecx = xStart + cStylePels - 1
        sub     ecx, [edi].RUN_iStop    ; New x0
        sub     esi, [edi].RUN_iStart   ; New x1
        jmp     short complex_reset_variables

complex_left_to_right:

; Figure out x0 and x1 for left-to-right lines:

        mov     esi, ecx                ; esi = ecx = xStart
        add     ecx, [edi].RUN_iStart   ; New x0
        add     esi, [edi].RUN_iStop    ; New x1

complex_reset_variables:
        mov     x0, ecx

; The half flip mucks with some of our variables, and we have to reset
; them every pass.  We would have to reset eqGamma too, but it never
; got saved to memory in its modified form.

        add     edi, size RUN
        mov     prun, edi               ; Increment run pointer for next time

        mov     edi, pls
        mov     eax, [edi].LS_spComplex
        mov     [edi].LS_spNext, eax    ; pls->spNext = pls->spComplex

        mov     eax, dN_Original        ; dN = dN_Original
        mov     dN, eax

        mul     ecx
        add     eax, eqGamma_lo
        adc     edx, eqGamma_hi         ; [edx:eax] = dN*x0 + eqGamma

        div     dM
        mov     y0, eax
        jmp     done_clipping

endProc bLines

        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\vga\mini\cmdcnst.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    cmdcnst.h

Abstract:

    This is the command string interpreter definitions

Environment:

    kernel mode only

Notes:

Revision History:

--*/

//--------------------------------------------------------------------------
//   Definition of the set/clear mode command language.
//
//   Each command is composed of a major portion and a minor portion.
//   The major portion of a command can be found in the most significant
//   nibble of a command byte, while the minor portion is in the least
//   significant portion of a command byte.
//
//   maj  minor      Description
//   ---- -----      --------------------------------------------
//   00              End of data
//
//   10              in and out type commands as described by flags
//        flags:
//
//        xxxx
//        ||||
//        |||+-------- unused
//        ||+--------- 0/1 single/multiple values to output (in's are always 
//        |+---------- 0/1 8/16 bit operation                  single)
//        +----------- 0/1 out/in instruction
//
//       Outs
//       ----------------------------------------------
//       0           reg:W val:B
//       2           reg:W cnt:W val1:B val2:B...valN:B
//       4           reg:W val:W
//       6           reg:W cnt:W val1:W val2:W...valN:W
//
//       Ins
//       ----------------------------------------------
//       8           reg:W
//       a           reg:W cnt:W
//       c           reg:W
//       e           reg:W cnt:W
//
//   20              Special purpose outs
//       00          do indexed outs for seq, crtc, and gdc
//                   indexreg:W cnt:B startindex:B val1:B val2:B...valN:B
//       01          do indexed outs for atc
//                   index-data_reg:W cnt:B startindex:B val1:B val2:B...valN:B
//       02          do masked outs
//                   indexreg:W andmask:B xormask:B
//
//   F0              Nop
//
//---------------------------------------------------------------------------

// some useful equates - major commands

#define EOD     0x000                   // end of data
#define INOUT   0x010                   // do ins or outs
#define METAOUT 0x020                   // do special types of outs
#define NCMD    0x0f0                   // Nop command


// flags for INOUT major command

//#define UNUSED    0x01                    // reserved
#define MULTI   0x02                    // multiple or single outs
#define BW      0x04                    // byte/word size of operation
#define IO      0x08                    // out/in instruction

// minor commands for metout

#define INDXOUT 0x00                    // do indexed outs
#define ATCOUT  0x01                    // do indexed outs for atc
#define MASKOUT 0x02                    // do masked outs using and-xor masks


// composite inout type commands

#define OB      (INOUT)                 // output 8 bit value
#define OBM     (INOUT+MULTI)           // output multiple bytes
#define OW      (INOUT+BW)              // output single word value
#define OWM     (INOUT+BW+MULTI)        // output multiple words

#define IB      (INOUT+IO)              // input byte
#define IBM     (INOUT+IO+MULTI)        // input multiple bytes
#define IW      (INOUT+IO+BW)           // input word
#define IWM     (INOUT+IO+BW+MULTI)     // input multiple words
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\vga\disp\8bpp\i386\ropdefs.inc ===
;----------------------------Module-Header------------------------------;
; Module Name: ROPDEFS.BLT
;
; Constants relating to raster operation definitions.
;
; Copyright (c) 1988 - 1992  Microsoft Corporation
;
; These constants are used mainly in the file ROPTABLE.BLT, in which
; the raster operation code templates are defined.
;
; This file is part of a set that makes up the Windows BitBLT function
; at driver-level.
;-----------------------------------------------------------------------;

        subttl  Raster Operation Definitions
        page


if 0                                    ; Not passed to us anymore !!!

;       Raster Op Definitions
;
;
;       The include file COMMENT.BLT contains a good description
;       of the encoding of the raster operations.  It should be
;       read before examining the definitions that follow.
;
;       The sixteen-bit number indicating which raster Op is to be
;       performed is encoded in the following manner:


EPS_OFF =       0000000000000011b       ;Offset within parse string
EPS_INDEX =     0000000000011100b       ;Parse string index
LogPar  =       0000000000100000b       ;(1 indicates implied NOT as Logop6)
LogOp1  =       0000000011000000b       ;Logical Operation #1
LogOp2  =       0000001100000000b       ;Logical Operation #2
LogOp3  =       0000110000000000b       ;Logical Operation #3
LogOp4  =       0011000000000000b       ;Logical Operation #4
LogOp5  =       1100000000000000b       ;Logical Operation #5


;       The parity bit is used to encode an optional sixth logical operation
;       which will always be a "NOT".  In most cases this is used to get an
;       even number of "NOT"s so that reduction can take place (two sequential
;       trailing "NOT"s cancel each other out and thus are eliminated).



;       Each LogOp (Logical Operation) is encoded as follows:

LogNOT  =       00b                     ;NOT result
LogXOR  =       01b                     ;XOR result with next operand
LogOR   =       10b                     ;OR  result with next operand
LogAND  =       11b                     ;AND result with next operand



;       The parse string is a string which contains the operands for
;       the logical operation sequences (source, destination, pattern).
;       The logic opcodes are applied to the current result and the next
;       element of the given string (unless the LogOp is a NOT which only
;       affects the result).
;
;       The string is encoded as eight two-bit numbers indicating which
;       operand is to be used

opDefs          struc
  OpSpec        db      ?                 ;Special Operand as noted below
  OpSrc         db      ?                 ;Operand is source field
  OpDest        db      ?                 ;Operand is destination field
  OpPat         db      ?                 ;Operand is pattern field
opDefs          ends



;       The special operand is used for a few rops that would not fit into
;       an RPN format.  On the first occurance of an OpSpec, the current result
;       is "PUSHED", and the next operand is loaded.  On the second occurance
;       of the OpSpec, the given logic operation is performed between the
;       current result and the "PUSHED" value.
;
;       **NOTE**  Since there can be no guarantee that the client will call
;       the BLT routine with one of the 256 published raster ops, it is
;       possible that a value might be "PUSHED" and then never "POPPED".
;       If these "PUSHES" are made to the stack, then care must be made to
;       remove the "PUSHED" value.
;
;       In any case, since the raster op was not one of the published
;       "magic numbers", the BLT can be aborted or the result can be
;       computed to the extent possible.  The only restriction is that it
;       must not crash the system (i.e. don't leave extra stuff on the stack).
;
;               Simply: Compute garbage, but don't crash!




;       Define the parse strings to be allocated later.
;
;       An example parse string for the pattern "SDPSDPSD" would be
;       "0110110110110110b"


parseStr0       =       07AAAh          ;src,pat,dest,dest,dest,dest,dest,dest
parseStr1       =       079E7h          ;src,pat,dest,src,pat,dest,src,pat
parseStr2       =       06DB6h          ;src,dest,pat,src,dest,pat,src,dest
parseStr3       =       0AAAAh          ;dest,dest,dest,dest,dest,dest,dest,dest
parseStr4       =       0AAAAh          ;dest,dest,dest,dest,dest,dest,dest,dest
parseStr5       =       04725h          ;src,spec,src,pat,spec,dest,src,src
parseStr6       =       04739h          ;src,spec,src,pat,spec,pat,dest,src
parseStr7       =       04639h          ;src,spec,src,dest,spec,pat,dest,src



;       The following equates are for certain special functions that are
;       derived from the very first string (index of SpecParseStrIndex).
;
;       These strings will have their innerloops special cased for
;       speed enhancements (i.e MOVSx and STOSx for pattern copys and
;       white/black fill, and MOVSx for source copy if possible)

PAT_COPY        equ     0021h           ;P    - dest = Pattern
NOTPAT_COPY     equ     0001h           ;Pn   - dest = NOT Pattern
FILL_BLACK      equ     0042h           ;DDx  - dest = 0 (black)
FILL_WHITE      equ     0062h           ;DDxn - dest = 1
SOURCE_COPY     equ     0020h           ;S    - dest = source


        errnz   LogXOR-01b              ;These must hold true for above equates
        errnz   LogOp1-0000000011000000b
        errnz   LogPar-0000000000100000b
        errnz   parseStr0-7AAAh         ;  plus the string must be SPDD


SPEC_PARSE_STR_INDEX equ        0       ;Special cased strings index

endif

;       The raster operation table consists of a word for each of
;       the first 128 raster operations (00 through 7F).  The second
;       half of the raster operations (FF through 80) are the inverse
;       of the first half.
;
;       The table is encoded as follows:
;
;           N S P LLL OOOOOOOOOO
;           | | |  |      |
;           | | |  |      |_____  Offset of code from roptable.
;           | | |  |
;           | | |  |____________  Length index
;           | | |
;           | | |_______________  Pattern is present
;           | |
;           | |_________________  Source is present
;           |
;           |___________________  Generate trailing NOT
;
;
;       To map the ROPS 80h through FFh to 00h through 7Fh, take the
;       1's complement of the ROP, and invert 'N' above.
;
;
;       Notes:
;
;           1)  An offset of 0 is reserved for source copy.  This
;               was done to reduce the number of LLLs to 8, so that
;               the above encoding could fit into a 16-bit integer.
;
;
;           2)  LLL only allows a maximum of 8 different template sizes!
;               Actual length is at roptable+256+LLL.
;
;
;
;
;       ROP is the macro that generates the equates which will be
;       stored into the roptable as specified above.
;
;       Usage:
;
;           ROPDEF      Pattern,Number
;
;       Where
;
;           Pattern     Is the RPN definition of the raster operation.
;                       It is used as the label of the first byte of
;                       the template.  It also is used to determine
;                       is there is a (S)ource, (P)attern, and if the
;                       final result is to be (n)egated.
;
;           Number      is the boolean result of the raster operation
;                       based on a P=F0, S=CC, and D=AA.  These labels
;                       and indexes can be found in the file COMMENT.BLT
;
;                       Since there are many equivelent boolean expresions,
;                       some of the rops will not match the label given.
;                       The label is for reference only.  The final result
;                       is what counts.



ROPOffset       equ     0000001111111111b
ROPLength       equ     0001110000000000b
SOURCE_PRESENT  equ     0010000000000000b
PATTERN_PRESENT equ     0100000000000000b
NEGATE_NEEDED   equ     1000000000000000b


;       Define the eight template length indices.

ROPLen0         equ     0
ROPLen2         equ     1
ROPLen4         equ     2
ROPLen6         equ     3
ROPLen8         equ     4
ROPLen10        equ     5
ROPLen12        equ     6
ROPLen14        equ     7

; Binary raster ops
R2_BLACK            equ 1
R2_NOTMERGEPEN      equ 2
R2_MASKNOTPEN       equ 3
R2_NOTCOPYPEN       equ 4
R2_MASKPENNOT       equ 5
R2_NOT              equ 6
R2_XORPEN           equ 7
R2_NOTMASKPEN       equ 8
R2_MASKPEN          equ 9
R2_NOTXORPEN        equ 10
R2_NOP              equ 11
R2_MERGENOTPEN      equ 12
R2_COPYPEN          equ 13
R2_MERGEPENNOT      equ 14
R2_MERGEPEN         equ 15
R2_WHITE            equ 16
R2_LAST             equ 16



=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\vga\disp\8bpp\i386\strips.asm ===
;---------------------------Module-Header------------------------------;
; Module Name: strips.asm
;
; Routines used by line code to draw strips of pixels.
;
; Copyright (c) 1992 Microsoft Corporation
;-----------------------------------------------------------------------;

        .386

        .model  small,c

        assume cs:FLAT,ds:FLAT,es:FLAT,ss:FLAT
        assume fs:nothing,gs:nothing

; Set LOOP_UNROLL_SHIFT to the log2 of the number of times you want loops in
; this module unrolled. For example, LOOP_UNROLL_SHIFT of 3 yields 2**3 = 8
; times unrolling. This is the only thing you need to change to control
; unrolling.

LOOP_UNROLL_SHIFT equ 1

        .xlist
        include stdcall.inc             ;calling convention cmacros
        include i386\egavga.inc
        include i386\strucs.inc
        include i386\driver.inc
        include i386\lines.inc
        .list

        .code

;--------------------------Private-Routine------------------------------;
; vStripSolid0
;
;   Draw lines in the 1st half-octant.
;
;-----------------------------------------------------------------------;

cProc   vStripSolid0,12,<          \
        uses        esi edi ebx,   \
        pStrips:    ptr STRIPS,    \
        pls:        ptr LINESTATE, \
        plStripEnd: ptr >

; Do some initializing:

        mov     esi, pStrips
        push    ebp
        mov     ebp, plStripEnd

        mov     eax,[esi].ST_lNextScan
        mov     [ebp],eax                       ;copy delta

        mov     eax,[esi].ST_chAndXor
        mov     bl,ah
        mov     bh,ah
        mov     ah,al

        mov     edi,[esi].ST_pjScreen
        add     esi,offset ST_alStrips

;       ax    = and mask
;       bx    = xor mask
;       ecx   = pixel count
;       dx    = temporary register
;       esi   = strip pointer
;       edi   = display pointer
;       ebp   = ends of strips pointer
;       [ebp] = delta

        mov     ecx,[esi]
        add     esi,4
        test    edi,1
        jnz     short sol0_unaligned_start

sol0_aligned_loop:
        sub     ecx,2
        jl      short sol0_strip_end_unaligned
        je      short sol0_strip_end_aligned
        mov     dx,[edi]
        and     edx,eax
        xor     edx,ebx
        mov     [edi],dx
        add     edi,2
        jmp     short sol0_aligned_loop

sol0_strip_end_aligned:
        mov     dx,[edi]
        and     edx,eax
        xor     edx,ebx
        mov     [edi],dx
        add     edi,2
        add     edi,[ebp]               ;go to next scan

        cmp     esi,ebp
        jae     short sol0_all_done

        mov     ecx,[esi]
        add     esi,4
        jmp     short sol0_aligned_loop

sol0_strip_end_unaligned:
        mov     dl,[edi]                ;do last pixel
        and     dl,al
        xor     dl,bl
        mov     [edi],dl
        inc     edi
        add     edi,[ebp]               ;go to next scan

        cmp     esi,ebp
        jae     short sol0_all_done

        mov     ecx,[esi]               ;do first pixel of next strip
        add     esi,4

sol0_unaligned_start:
        mov     dl,[edi]
        and     dl,al
        xor     dl,bl
        mov     [edi],dl
        inc     edi
        dec     ecx
        jnz     short sol0_aligned_loop

; Have to be careful when there is only one pel in the strip and it starts
; on an unaligned address:

        add     edi,[ebp]
        cmp     esi,ebp
        jae     short sol0_all_done

        mov     ecx,[esi]
        add     esi,4
        jmp     short sol0_aligned_loop

sol0_all_done:
        pop     ebp
        mov     esi, pStrips
        mov     [esi].ST_pjScreen,edi
        cRet    vStripSolid0

endProc vStripSolid0

;--------------------------Private-Routine------------------------------;
; vStripSolid1
;
; Draws lines in the 2nd half-octant.
;
;-----------------------------------------------------------------------;

cProc   vStripSolid1,12,<          \
        uses        esi edi ebx,   \
        pStrips:    ptr STRIPS,    \
        pls:        ptr LINESTATE, \
        plStripEnd: ptr >

        mov     esi,pStrips
        push    ebp
        mov     ebp,plStripEnd
        mov     ecx,[esi].ST_lNextScan
        inc     ecx                            ; Make delta advance 1 to right
        mov     eax,[esi].ST_chAndXor
        mov     edi,[esi].ST_pjScreen
        add     esi,offset ST_alStrips

;                   al  = and mask
;                   ah  = xor mask
;                   ebx = pixel count
;                   ecx = delta
;                   dl  = temporary register
;                   esi = strip pointer
;                   edi = memory pointer
;                   ebp = end of strips pointer

sol1_next_diagonal:
        mov     ebx,[esi]
        add     esi, 4

sol1_diagonal_loop:
        mov     dl,[edi]
        and     dl,al
        xor     dl,ah
        mov     [edi],dl

        add     edi,ecx
        dec     ebx
        jnz     short sol1_diagonal_loop

        sub     edi,ecx
        inc     edi
        cmp     esi,ebp
        jb      short sol1_next_diagonal

        pop     ebp
        mov     esi, pStrips
        mov     [esi].ST_pjScreen,edi
        cRet    vStripSolid1

endProc vStripSolid1

;--------------------------Private-Routine------------------------------;
; vStripSolid2
;
; Draws lines in the 3rd half-octant.
;
;-----------------------------------------------------------------------;

cProc   vStripSolid2,12,<          \
        uses        esi edi ebx,   \
        pStrips:    ptr STRIPS,    \
        pls:        ptr LINESTATE, \
        plStripEnd: ptr >

        mov     esi,pStrips
        push    ebp
        mov     ebp,plStripEnd
        mov     ecx,[esi].ST_lNextScan
        inc     ecx                             ; Make delta advance 1 to right
        mov     eax,[esi].ST_chAndXor
        mov     edi,[esi].ST_pjScreen
        add     esi,offset ST_alStrips

;                   al  = and mask
;                   ah  = xor mask
;                   ebx = pixel count
;                   ecx = delta
;                   dl  = temporary register
;                   esi = strip pointer
;                   edi = memory pointer
;                   ebp = end of strips pointer

sol2_next_diagonal:
        mov     ebx,[esi]
        add     esi,4

sol2_diagonal_loop:
        mov     dl,[edi]
        and     dl,al
        xor     dl,ah
        mov     [edi],dl

        add     edi,ecx
        dec     ebx
        jnz     short sol2_diagonal_loop

        dec     edi
        cmp     esi,ebp
        jb      short sol2_next_diagonal

        pop     ebp
        mov     esi, pStrips
        mov     [esi].ST_pjScreen,edi
        cRet    vStripSolid2

endProc vStripSolid2

;--------------------------Private-Routine------------------------------;
; vStripSolid3
;
; Draws lines in the 4th half-octant.
;
;-----------------------------------------------------------------------;

cProc   vStripSolid3,12,<          \
        uses        esi edi ebx,   \
        pStrips:    ptr STRIPS,    \
        pls:        ptr LINESTATE, \
        plStripEnd: ptr >

        mov     esi,pStrips
        push    ebp
        mov     ebp,plStripEnd
        mov     ecx,[esi].ST_lNextScan
        mov     eax,[esi].ST_chAndXor
        mov     edi,[esi].ST_pjScreen
        add     esi,offset ST_alStrips

;                   al  = and mask
;                   ah  = xor mask
;                   ebx = pixel count
;                   ecx = delta
;                   dl  = temporary register
;                   esi = strip pointer
;                   edi = memory pointer
;                   ebp = end of strips pointer

sol3_next_vertical:
        mov     ebx,[esi]
        add     esi,4

sol3_vertical_loop:
        mov     dl,[edi]
        and     dl,al
        xor     dl,ah
        mov     [edi],dl

        add     edi,ecx
        dec     ebx
        jnz     short sol3_vertical_loop

        inc     edi
        cmp     esi,ebp
        jb      short sol3_next_vertical

        pop     ebp
        mov     esi,pStrips
        mov     [esi].ST_pjScreen,edi
        cRet    vStripSolid3

endProc vStripSolid3

;--------------------------Private-Routine------------------------------;
; vStripStyled0
;
; Draws styled lines in the 1st half-octant.
;
;-----------------------------------------------------------------------;

cProc   vStripStyled0,12,<         \
        uses        esi edi ebx,   \
        pStrips:    ptr STRIPS,    \
        pls:        ptr LINESTATE, \
        plStripEnd: ptr >

        local   ulNumPixels:    dword ;# of pixels in current style
        local   pspEnd:         dword ;pointer to end of style array
        local   cjMajor:        dword ;lNextScan for screen
        local   cjStyleDelta:   dword ;delta from end of style array to start

; al  = and mask
; ah  = xor mask
; ebx = # of pixels in current strip
; ecx = style pointer
; edx = temporary register
; esi = strips pointer
; edi = memory pointer

        mov     esi,pStrips

        mov     eax,[esi].ST_lNextScan
        mov     cjMajor,eax
        mov     eax,[esi].ST_pspEnd
        mov     pspEnd,eax
        mov     ebx,[esi].ST_pspStart
        sub     ebx,eax                 ;compute cjStyleDelta
        sub     ebx,4                   ;make it exclusive
        mov     cjStyleDelta,ebx

        mov     edx,[esi].ST_spRemaining
        mov     ulNumPixels,edx
        mov     eax,[esi].ST_chAndXor
        mov     ecx,[esi].ST_psp
        mov     edx,[esi].ST_bIsGap
        mov     edi,[esi].ST_pjScreen
        add     esi,offset ST_alStrips

        mov     ebx,[esi]
        add     esi,4

        or      edx,edx
        jz      short sty0_output_loop  ;if working on a dash, start there
        jmp     short sty0_skip_loop    ;if working on a gap, start there

sty0_prepare_for_output:
        add     edi,ulNumPixels         ;adjust to do remainder of strip

        add     ecx,4
        cmp     pspEnd,ecx              ;if (ecx == pspEnd + 4)
        sbb     edx,edx                 ;  then ecx = pspStart
        and     edx,cjStyleDelta
        add     ecx,edx

        mov     ebx,ulNumPixels
        push    eax
        mov     eax,[ecx]               ;get next style array element
        mov     ulNumPixels,eax
        pop     eax
        neg     ebx
        jz      short sty0_output_get_new_strip

sty0_output_loop:
        mov     dl,[edi]
        and     dl,al
        xor     dl,ah
        mov     [edi],dl                ;write pixel
        inc     edi                     ;move one pixel to right
        dec     ulNumPixels             ;might have to go to next style element
        jz      short sty0_prepare_for_skip

        dec     ebx
        jnz     short sty0_output_loop

sty0_output_get_new_strip:
        add     edi,cjMajor             ;move up one scan
        cmp     esi,plStripEnd
        jae     short sty0_output_all_done

        mov     ebx,[esi]               ;get next strip
        add     esi,4
        jmp     short sty0_output_loop

sty0_output_all_done:
        mov     esi,pStrips
        mov     [esi].ST_pjScreen,edi
        mov     [esi].ST_bIsGap,0       ;we were working on a dash
        mov     edi,ulNumPixels
        mov     [esi].ST_spRemaining,edi
        mov     [esi].ST_psp,ecx
        cRet    vStripStyled0

sty0_prepare_for_skip:
        add     ecx,4
        cmp     pspEnd,ecx              ;if (ecx == pspEnd + 4)
        sbb     edx,edx                 ;  then ecx = pspStart
        and     edx,cjStyleDelta
        add     ecx,edx

        dec     ebx
        push    eax
        mov     eax,[ecx]               ;get next style array element
        mov     ulNumPixels,eax
        pop     eax
        jz      short sty0_skip_get_new_strip

sty0_skip_loop:
        add     edi,ebx                 ;assume we'll skip entire strip
        sub     ulNumPixels,ebx         ;  (we'll correct it if not)
        jle     short sty0_prepare_for_output

sty0_skip_get_new_strip:
        add     edi,cjMajor             ;move up one scan
        cmp     esi,plStripEnd
        jae     short sty0_skip_all_done

        mov     ebx,[esi]               ;get next strip
        add     esi,4
        jmp     short sty0_skip_loop

sty0_skip_all_done:
        mov     esi,pStrips
        mov     [esi].ST_pjScreen,edi
        mov     [esi].ST_bIsGap,0ffh    ;we were working on a gap
        mov     edi,ulNumPixels
        mov     [esi].ST_spRemaining,edi
        mov     [esi].ST_psp,ecx
        cRet    vStripStyled0

endProc vStripStyled0

;--------------------------Private-Routine------------------------------;
; vStripStyled123
;
; Draws styled lines in the 2nd, 3rd and 4th half-octants.
;
;-----------------------------------------------------------------------;

cProc   vStripStyled123,12,<       \
        uses        esi edi ebx,   \
        pStrips:    ptr STRIPS,    \
        pls:        ptr LINESTATE, \
        plStripEnd: ptr >

        local   ulNumPixels:    dword ;# of pixels in current style
        local   pspEnd:         dword ;pointer to end of style array
        local   cjMajor:        dword ;delta to go in major direction
        local   cjMinor:        dword ;delta to go in minor direction
        local   cjStyleDelta:   dword ;delta from end of style array to start

; al  = and mask
; ah  = xor mask
; ebx = # of pixels in current strip
; ecx = style pointer
; edx = temporary register
; esi = strips pointer
; edi = memory pointer

        mov     esi,pStrips

; If in half-octant 3, cjMajor = cjDelta and cjMinor = 1
; If in half-octant 2, cjMajor = cjDelta + 1 and cjMinor = -1
; If in half-octant 1, cjMajor = cjDelta + 1 and cjMinor = -cjDelta

        mov     eax,[esi].ST_lNextScan
        mov     ebx,[esi].ST_flFlips
        test    ebx,FL_FLIP_HALF
        jz      short sty3_halfoctant_3

        inc     eax
        mov     cjMajor,eax
        mov     cjMinor,-1

        test    ebx,FL_FLIP_D
        jnz     short sty3_done_major_minor_comp

        neg     eax
        inc     eax
        mov     cjMinor,eax
        jmp     short sty3_done_major_minor_comp

sty3_halfoctant_3:
        mov     cjMajor,eax
        mov     cjMinor,1

sty3_done_major_minor_comp:
        mov     eax,[esi].ST_pspEnd
        mov     pspEnd,eax
        mov     ebx,[esi].ST_pspStart
        sub     ebx,eax                 ;compute cjStyleDelta
        sub     ebx,4                   ;make it exclusive
        mov     cjStyleDelta,ebx

        mov     edx,[esi].ST_spRemaining
        mov     ulNumPixels,edx
        mov     eax,[esi].ST_chAndXor
        mov     ecx,[esi].ST_psp
        mov     edx,[esi].ST_bIsGap
        mov     edi,[esi].ST_pjScreen
        add     esi,offset ST_alStrips

        mov     ebx,[esi]
        add     esi,4

        or      edx,edx
        jz      short sty3_output_loop  ;if working on a dash, start there
        jmp     short sty3_skip_loop    ;if working on a gap, start there

sty3_prepare_for_output:
        add     ecx,4
        cmp     pspEnd,ecx              ;if (ecx == pspEnd + 4)
        sbb     edx,edx                 ;  then ecx = pspStart
        and     edx,cjStyleDelta
        add     ecx,edx

        mov     ebx,ulNumPixels
        push    eax
        mov     eax,[ecx]               ;get next style array element
        mov     ulNumPixels,eax
        pop     eax
        neg     ebx                     ;adjust to do remainder of strip

        jz      short sty3_output_get_new_strip

sty3_output_loop:
        mov     dl,[edi]
        and     dl,al
        xor     dl,ah
        mov     [edi],dl                ;write pixel
        add     edi,cjMajor             ;move to next scan
        dec     ulNumPixels             ;might have to go to next style element
        jz      short sty3_prepare_for_skip

        dec     ebx
        jnz     short sty3_output_loop

sty3_output_get_new_strip:
        add     edi,cjMinor             ;move one pixel in minor direction
        cmp     esi,plStripEnd
        jae     short sty3_output_all_done

        mov     ebx,[esi]               ;get next strip
        add     esi,4
        jmp     short sty3_output_loop

sty3_output_all_done:
        mov     esi,pStrips
        mov     [esi].ST_pjScreen,edi
        mov     [esi].ST_bIsGap,0       ;we were working on a dash
        mov     edi,ulNumPixels
        mov     [esi].ST_spRemaining,edi
        mov     [esi].ST_psp,ecx
        cRet    vStripStyled123

sty3_prepare_for_skip:
        add     ecx,4
        cmp     pspEnd,ecx              ;if (ecx == pspEnd + 4)
        sbb     edx,edx                 ;  then ecx = pspStart
        and     edx,cjStyleDelta
        add     ecx,edx

        dec     ebx
        push    eax
        mov     eax,[ecx]               ;get next style array element
        mov     ulNumPixels,eax
        pop     eax
        jz      short sty3_skip_get_new_strip

sty3_skip_loop:

; compute min(left in strip, left in style)

        sub     ulNumPixels,ebx         ;ulNumPixels = # style - # strip
        sbb     edx,edx
        and     edx,ulNumPixels
        add     ebx,edx                 ;ebx = min(pels left in strip,
                                        ;          pels left in style)

        mov     edx,cjMajor
        imul    edx,ebx
        add     edi,edx                 ;adjust our pointer

        cmp     ulNumPixels,0
        jle     sty3_prepare_for_output

sty3_skip_get_new_strip:
        add     edi,cjMinor             ;move one pixel in minor direction
        cmp     esi,plStripEnd
        jae     short sty3_skip_all_done

        mov     ebx,[esi]               ;get next strip
        add     esi,4
        jmp     short sty3_skip_loop

sty3_skip_all_done:
        mov     esi,pStrips
        mov     [esi].ST_pjScreen,edi
        mov     [esi].ST_bIsGap,0ffh    ;we were working on a gap
        mov     edi,ulNumPixels
        mov     [esi].ST_spRemaining,edi
        mov     [esi].ST_psp,ecx
        cRet    vStripStyled123

endProc vStripStyled123

;--------------------------Private-Routine------------------------------;
; vStripSolidSet0
;
;   Draw lines in the 1st half-octant.
;
;-----------------------------------------------------------------------;

cProc   vStripSolidSet0,12,<       \
        uses        esi edi ebx,   \
        pStrips:    ptr STRIPS,    \
        pls:        ptr LINESTATE, \
        plStripEnd: ptr >

; Do some initializing:

        mov     esi, pStrips
        push    ebp
        mov     ebp, plStripEnd

        mov     eax,[esi].ST_lNextScan
        mov     [ebp],eax                       ;copy delta

        mov     eax,[esi].ST_chAndXor
        mov     bl,ah
        mov     bh,ah
        mov     ah,al

        mov     edi,[esi].ST_pjScreen
        add     esi,offset ST_alStrips

;       ax    = and mask
;       bx    = xor mask
;       ecx   = pixel count
;       dx    = temporary register
;       esi   = strip pointer
;       edi   = display pointer
;       ebp   = ends of strips pointer
;       [ebp] = delta

        mov     ecx,[esi]
        add     esi,4
        test    edi,1
        jnz     short sol0s_unaligned_start

sol0s_aligned_loop:
        sub     ecx,2
        jl      short sol0s_strip_end_unaligned
        je      short sol0s_strip_end_aligned
        mov     [edi],bx
        add     edi,2
        jmp     short sol0s_aligned_loop

sol0s_strip_end_aligned:
        mov     [edi],bx
        add     edi,2
        add     edi,[ebp]               ;go to next scan

        cmp     esi,ebp
        jae     short sol0s_all_done

        mov     ecx,[esi]
        add     esi,4
        jmp     short sol0s_aligned_loop

sol0s_strip_end_unaligned:
        mov     [edi],bl                ;do last pixel
        inc     edi
        add     edi,[ebp]               ;go to next scan

        cmp     esi,ebp
        jae     short sol0s_all_done

        mov     ecx,[esi]               ;do first pixel of next strip
        add     esi,4

sol0s_unaligned_start:
        mov     [edi],bl
        inc     edi
        dec     ecx
        jnz     short sol0s_aligned_loop

; Have to be careful when there is only one pel in the strip and it starts
; on an unaligned address:

        add     edi,[ebp]
        cmp     esi,ebp
        jae     short sol0s_all_done

        mov     ecx,[esi]
        add     esi,4
        jmp     short sol0s_aligned_loop

sol0s_all_done:
        pop     ebp
        mov     esi, pStrips
        mov     [esi].ST_pjScreen,edi
        cRet    vStripSolidSet0

endProc vStripSolidSet0

;--------------------------Private-Routine------------------------------;
; vStripSolidSet1
;
; Draws lines in the 2nd half-octant.
;
;-----------------------------------------------------------------------;

cProc   vStripSolidSet1,12,<       \
        uses        esi edi ebx,   \
        pStrips:    ptr STRIPS,    \
        pls:        ptr LINESTATE, \
        plStripEnd: ptr >

        mov     esi,pStrips
        push    ebp
        mov     ebp,plStripEnd
        mov     ecx,[esi].ST_lNextScan
        inc     ecx                            ; Make delta advance 1 to right
        mov     eax,[esi].ST_chAndXor
        mov     edi,[esi].ST_pjScreen
        add     esi,offset ST_alStrips

;                   al  = and mask
;                   ah  = xor mask
;                   ebx = pixel count
;                   ecx = delta
;                   dl  = temporary register
;                   esi = strip pointer
;                   edi = memory pointer
;                   ebp = end of strips pointer

sol1s_next_diagonal:
        mov     ebx,[esi]
        add     esi, 4

sol1s_diagonal_loop:
        mov     [edi],ah

        add     edi,ecx
        dec     ebx
        jnz     short sol1s_diagonal_loop

        sub     edi,ecx
        inc     edi
        cmp     esi,ebp
        jb      short sol1s_next_diagonal

        pop     ebp
        mov     esi, pStrips
        mov     [esi].ST_pjScreen,edi
        cRet    vStripSolidSet1

endProc vStripSolidSet1

;--------------------------Private-Routine------------------------------;
; vStripSolidSet2
;
; Draws lines in the 3rd half-octant.
;
;-----------------------------------------------------------------------;

cProc   vStripSolidSet2,12,<       \
        uses        esi edi ebx,   \
        pStrips:    ptr STRIPS,    \
        pls:        ptr LINESTATE, \
        plStripEnd: ptr >

        mov     esi,pStrips
        push    ebp
        mov     ebp,plStripEnd
        mov     ecx,[esi].ST_lNextScan
        inc     ecx                             ; Make delta advance 1 to right
        mov     eax,[esi].ST_chAndXor
        mov     edi,[esi].ST_pjScreen
        add     esi,offset ST_alStrips

;                   al  = and mask
;                   ah  = xor mask
;                   ebx = pixel count
;                   ecx = delta
;                   dl  = temporary register
;                   esi = strip pointer
;                   edi = memory pointer
;                   ebp = end of strips pointer

sol2s_next_diagonal:
        mov     ebx,[esi]
        add     esi,4

sol2s_diagonal_loop:
        mov     [edi],ah

        add     edi,ecx
        dec     ebx
        jnz     short sol2s_diagonal_loop

        dec     edi
        cmp     esi,ebp
        jb      short sol2s_next_diagonal

        pop     ebp
        mov     esi, pStrips
        mov     [esi].ST_pjScreen,edi
        cRet    vStripSolidSet2

endProc vStripSolidSet2

;--------------------------Private-Routine------------------------------;
; vStripSolidSet3
;
; Draws lines in the 4th half-octant.
;
;-----------------------------------------------------------------------;

cProc   vStripSolidSet3,12,<       \
        uses        esi edi ebx,   \
        pStrips:    ptr STRIPS,    \
        pls:        ptr LINESTATE, \
        plStripEnd: ptr >

        mov     esi,pStrips
        push    ebp
        mov     ebp,plStripEnd
        mov     ecx,[esi].ST_lNextScan
        mov     eax,[esi].ST_chAndXor
        mov     edi,[esi].ST_pjScreen
        add     esi,offset ST_alStrips

;                   al  = and mask
;                   ah  = xor mask
;                   ebx = pixel count
;                   ecx = delta
;                   dl  = temporary register
;                   esi = strip pointer
;                   edi = memory pointer
;                   ebp = end of strips pointer

sol3s_next_vertical:
        mov     ebx,[esi]
        add     esi,4

sol3s_vertical_loop:
        mov     [edi],ah

        add     edi,ecx
        dec     ebx
        jnz     short sol3s_vertical_loop

        inc     edi
        cmp     esi,ebp
        jb      short sol3s_next_vertical

        pop     ebp
        mov     esi,pStrips
        mov     [esi].ST_pjScreen,edi
        cRet    vStripSolidSet3

endProc vStripSolidSet3

;--------------------------Private-Routine------------------------------;
; vStripStyledSet0
;
; Draws styled lines in the 1st half-octant.
;
;-----------------------------------------------------------------------;

cProc   vStripStyledSet0,12,<      \
        uses        esi edi ebx,   \
        pStrips:    ptr STRIPS,    \
        pls:        ptr LINESTATE, \
        plStripEnd: ptr >

        local   ulNumPixels:    dword ;# of pixels in current style
        local   pspEnd:         dword ;pointer to end of style array
        local   cjMajor:        dword ;lNextScan for screen
        local   cjStyleDelta:   dword ;delta from end of style array to start

; al  = and mask
; ah  = xor mask
; ebx = # of pixels in current strip
; ecx = style pointer
; edx = temporary register
; esi = strips pointer
; edi = memory pointer

        mov     esi,pStrips

        mov     eax,[esi].ST_lNextScan
        mov     cjMajor,eax
        mov     eax,[esi].ST_pspEnd
        mov     pspEnd,eax
        mov     ebx,[esi].ST_pspStart
        sub     ebx,eax                 ;compute cjStyleDelta
        sub     ebx,4                   ;make it exclusive
        mov     cjStyleDelta,ebx

        mov     edx,[esi].ST_spRemaining
        mov     ulNumPixels,edx
        mov     eax,[esi].ST_chAndXor
        mov     ecx,[esi].ST_psp
        mov     edx,[esi].ST_bIsGap
        mov     edi,[esi].ST_pjScreen
        add     esi,offset ST_alStrips

        mov     ebx,[esi]
        add     esi,4

        or      edx,edx
        jz      short sty0s_output_loop ;if working on a dash, start there
        jmp     short sty0s_skip_loop   ;if working on a gap, start there

sty0s_prepare_for_output:
        add     edi,ulNumPixels         ;adjust to do remainder of strip

        add     ecx,4
        cmp     pspEnd,ecx              ;if (ecx == pspEnd + 4)
        sbb     edx,edx                 ;  then ecx = pspStart
        and     edx,cjStyleDelta
        add     ecx,edx

        mov     ebx,ulNumPixels
        push    eax
        mov     eax,[ecx]               ;get next style array element
        mov     ulNumPixels,eax
        pop     eax
        neg     ebx                     ;see if we also need a new strip
        jz      short sty0s_output_get_new_strip

sty0s_output_loop:
        mov     [edi],ah                ;write pixel
        inc     edi                     ;move one pixel to right
        dec     ulNumPixels             ;might have to go to next style element
        jz      short sty0s_prepare_for_skip

        dec     ebx
        jnz     short sty0s_output_loop

sty0s_output_get_new_strip:
        add     edi,cjMajor             ;move up one scan
        cmp     esi,plStripEnd
        jae     short sty0s_output_all_done

        mov     ebx,[esi]               ;get next strip
        add     esi,4
        jmp     short sty0s_output_loop

sty0s_output_all_done:
        mov     esi,pStrips
        mov     [esi].ST_pjScreen,edi
        mov     [esi].ST_bIsGap,0       ;we were working on a dash
        mov     edi,ulNumPixels
        mov     [esi].ST_spRemaining,edi
        mov     [esi].ST_psp,ecx
        cRet    vStripStyledSet0

sty0s_prepare_for_skip:
        add     ecx,4
        cmp     pspEnd,ecx              ;if (ecx == pspEnd + 4)
        sbb     edx,edx                 ;  then ecx = pspStart
        and     edx,cjStyleDelta
        add     ecx,edx

        dec     ebx
        push    eax
        mov     eax,[ecx]               ;get next style array element
        mov     ulNumPixels,eax
        pop     eax
        jz      short sty0s_skip_get_new_strip

sty0s_skip_loop:
        add     edi,ebx                 ;assume we'll skip entire strip
        sub     ulNumPixels,ebx         ;  (we'll correct it if not)
        jle     short sty0s_prepare_for_output

sty0s_skip_get_new_strip:
        add     edi,cjMajor             ;move up one scan
        cmp     esi,plStripEnd
        jae     short sty0s_skip_all_done

        mov     ebx,[esi]               ;get next strip
        add     esi,4
        jmp     short sty0s_skip_loop

sty0s_skip_all_done:
        mov     esi,pStrips
        mov     [esi].ST_pjScreen,edi
        mov     [esi].ST_bIsGap,0ffh    ;we were working on a gap
        mov     edi,ulNumPixels
        mov     [esi].ST_spRemaining,edi
        mov     [esi].ST_psp,ecx
        cRet    vStripStyledSet0

endProc vStripStyledSet0

;--------------------------Private-Routine------------------------------;
; vStripStyledSet123
;
; Draws styled lines in the 2nd, 3rd and 4th half-octants.
;
;-----------------------------------------------------------------------;

cProc   vStripStyledSet123,12,<    \
        uses        esi edi ebx,   \
        pStrips:    ptr STRIPS,    \
        pls:        ptr LINESTATE, \
        plStripEnd: ptr >

        local   ulNumPixels:    dword ;# of pixels in current style
        local   pspEnd:         dword ;pointer to end of style array
        local   cjMajor:        dword ;delta to go in major direction
        local   cjMinor:        dword ;delta to go in minor direction
        local   cjStyleDelta:   dword ;delta from end of style array to start

; al  = and mask
; ah  = xor mask
; ebx = # of pixels in current strip
; ecx = style pointer
; edx = temporary register
; esi = strips pointer
; edi = memory pointer

        mov     esi,pStrips

; If in half-octant 3, cjMajor = cjDelta and cjMinor = 1
; If in half-octant 2, cjMajor = cjDelta + 1 and cjMinor = -1
; If in half-octant 1, cjMajor = cjDelta + 1 and cjMinor = -cjDelta

        mov     eax,[esi].ST_lNextScan
        mov     ebx,[esi].ST_flFlips
        test    ebx,FL_FLIP_HALF
        jz      short sty3s_halfoctant_3

        inc     eax
        mov     cjMajor,eax
        mov     cjMinor,-1

        test    ebx,FL_FLIP_D
        jnz     short sty3s_done_major_minor_comp

        neg     eax
        inc     eax
        mov     cjMinor,eax
        jmp     short sty3s_done_major_minor_comp

sty3s_halfoctant_3:
        mov     cjMajor,eax
        mov     cjMinor,1

sty3s_done_major_minor_comp:
        mov     eax,[esi].ST_pspEnd
        mov     pspEnd,eax
        mov     ebx,[esi].ST_pspStart
        sub     ebx,eax                 ;compute cjStyleDelta
        sub     ebx,4                   ;make it exclusive
        mov     cjStyleDelta,ebx

        mov     edx,[esi].ST_spRemaining
        mov     ulNumPixels,edx
        mov     eax,[esi].ST_chAndXor
        mov     ecx,[esi].ST_psp
        mov     edx,[esi].ST_bIsGap
        mov     edi,[esi].ST_pjScreen
        add     esi,offset ST_alStrips

        mov     ebx,[esi]
        add     esi,4

        or      edx,edx
        jz      short sty3s_output_loop ;if working on a dash, start there
        jmp     short sty3s_skip_loop   ;if working on a gap, start there

sty3s_prepare_for_output:
        add     ecx,4
        cmp     pspEnd,ecx              ;if (ecx == pspEnd + 4)
        sbb     edx,edx                 ;  then ecx = pspStart
        and     edx,cjStyleDelta
        add     ecx,edx

        mov     ebx,ulNumPixels
        push    eax
        mov     eax,[ecx]               ;get next style array element
        mov     ulNumPixels,eax
        pop     eax
        neg     ebx                     ;adjust to do remainder of strip
        jz      short sty3s_output_get_new_strip

sty3s_output_loop:
        mov     [edi],ah                ;write pixel
        add     edi,cjMajor             ;move to next scan
        dec     ulNumPixels             ;might have to go to next style element
        jz      short sty3s_prepare_for_skip

        dec     ebx
        jnz     short sty3s_output_loop

sty3s_output_get_new_strip:
        add     edi,cjMinor             ;move in minor direction
        cmp     esi,plStripEnd
        jae     short sty3s_output_all_done

        mov     ebx,[esi]               ;get next strip
        add     esi,4
        jmp     short sty3s_output_loop

sty3s_output_all_done:
        mov     esi,pStrips
        mov     [esi].ST_pjScreen,edi
        mov     [esi].ST_bIsGap,0       ;we were working on a dash
        mov     edi,ulNumPixels
        mov     [esi].ST_spRemaining,edi
        mov     [esi].ST_psp,ecx
        cRet    vStripStyledSet123

sty3s_prepare_for_skip:
        add     ecx,4
        cmp     pspEnd,ecx              ;if (ecx == pspEnd + 4)
        sbb     edx,edx                 ;  then ecx = pspStart
        and     edx,cjStyleDelta
        add     ecx,edx

        dec     ebx
        push    eax
        mov     eax,[ecx]               ;get next style array element
        mov     ulNumPixels,eax
        pop     eax
        jz      short sty3s_skip_get_new_strip

sty3s_skip_loop:

; compute min(left in strip, left in style)

        sub     ulNumPixels,ebx         ;ulNumPixels = # style - # strip
        sbb     edx,edx
        and     edx,ulNumPixels
        add     ebx,edx                 ;ebx = min(pels left in strip,
                                        ;          pels left in style)

        mov     edx,cjMajor
        imul    edx,ebx
        add     edi,edx                 ;adjust our pointer

        cmp     ulNumPixels,0
        jle     sty3s_prepare_for_output

sty3s_skip_get_new_strip:
        add     edi,cjMinor             ;move in minor direction
        cmp     esi,plStripEnd
        jae     short sty3s_skip_all_done

        mov     ebx,[esi]               ;get next strip
        add     esi,4
        jmp     short sty3s_skip_loop

sty3s_skip_all_done:
        mov     esi,pStrips
        mov     [esi].ST_pjScreen,edi
        mov     [esi].ST_bIsGap,0ffh    ;we were working on a gap
        mov     edi,ulNumPixels
        mov     [esi].ST_spRemaining,edi
        mov     [esi].ST_psp,ecx
        cRet    vStripStyledSet123

endProc vStripStyledSet123

        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\vga\disp\8bpp\i386\vgablts.asm ===
;---------------------------Module-Header------------------------------;
; Module Name: vgablts.asm
;
; Copyright (c) 1992-1993 Microsoft Corporation
;-----------------------------------------------------------------------;
;-----------------------------------------------------------------------;
; VOID vTrgBlt(PDEV * ppdev, ULONG culRcl, RECTL * prcl, MIX ulMix,
;              ULONG ulClr, POINTL * pptlBrush)
; Input:
;  ppdev     - pointer to PDEV for surface to which to draw
;  culRcl    - # of rectangles to fill
;  prcl      - pointer to list of rectangles to fill
;  ulMix     - mix rop with which to fill
;  ulClr     - color with which to fill
;  pptlBrush - not used
;
; Performs accelerated solid area fills for all mixes.
;
;-----------------------------------------------------------------------;
;
; Note: Assumes all rectangles have positive heights and widths. Will not
; work properly if this is not the case.
;
;-----------------------------------------------------------------------;
;
; Note: Cases where the width of the whole bytes fill is equal to the
; width of the bitmap could be sped up by using a single REP MOVS or REP
; STOS, but how often does WIN32 do a fill that's the width of the screen?
; Not very.
;
;-----------------------------------------------------------------------;

        comment $

The overall approach of this module is to accept a list of rectangles to
fill, set up the VGA hardware for the desired fill, and then fill the
rectangles one at a time. Each rectangle fill is set up for everything
but vertical parameters, and then decomposed into the sections that
intersect each VGA bank; each section is drawn in turn. Vectors are set
up so that the drawing code appropriate for the desired fill is
essentially threaded together.

        commend $

;-----------------------------------------------------------------------;

                .386

ifndef  DOS_PLATFORM
        .model  small,c
else
ifdef   STD_CALL
        .model  small,c
else
        .model  small,pascal
endif;  STD_CALL
endif;  DOS_PLATFORM

        assume cs:FLAT,ds:FLAT,es:FLAT,ss:FLAT
        assume fs:nothing,gs:nothing

        .xlist
        include stdcall.inc             ;calling convention cmacros
        include i386\strucs.inc
        include i386\driver.inc
        include i386\egavga.inc
        include i386\ropdefs.inc

        .list

;-----------------------------------------------------------------------;

        .data

;-----------------------------------------------------------------------;
; Left edge clip masks for intrabyte start addresses 0 through 3.
; Whole byte cases are flagged as 0ffh.
        public jLeftMask
jLeftMask       label   byte
        db      0ffh,0eh,0ch,08h

;-----------------------------------------------------------------------;
; Right edge clip masks for intrabyte end addresses (non-inclusive)
; 0 through 3. Whole byte cases are flagged as 0ffh.
        public jRightMask
jRightMask      label   byte
        db      0ffh,01h,03h,07h

;-----------------------------------------------------------------------;
; Tables used to set up for the desired raster op. Note that entries for raster
; ops that aren't handled here are generally correct, except that they ignore
; need for inversion of the destination, which those rops require.

; Table used to force off the drawing color for R2_BLACK (0).
; The first entry is ignored; there is no mix 0.
        public jForceOffTable
jForceOffTable  db         0
                db         000h,0ffh,0ffh,0ffh,0ffh,0ffh,0ffh,0ffh
                db         0ffh,0ffh,000h,0ffh,0ffh,0ffh,0ffh,0ffh

;-----------------------------------------------------------------------;
; Table used to force on the drawing color for R2_NOT (Dn) and R2_WHITE (1).
; The first entry is ignored; there is no mix 0.
        public  jForceOnTable
jForceOnTable   db      0, 0,0,0,0,0,0ffh,0,0,0,0,0,0,0,0,0,0ffh

;-----------------------------------------------------------------------;
; Table used to invert the passed-in drawing color for Pn mixes.
; The first entry is ignored; there is no mix 0.
        public  jNotTable
jNotTable       db      0, 0,0ffh,0ffh,0ffh,0,0,0,0ffh,0,0ffh,0,0ffh,0,0,0,0

;-----------------------------------------------------------------------;
; Table of VGA ALU logical functions corresponding to mixes. Note that Dn is
; handled as a separate preceding inversion pass when part of a more complex
; mix.
; The first entry is ignored; there is no mix 0.
        public jALUFuncTable
jALUFuncTable   db      DR_SET
                db      DR_SET,DR_AND,DR_AND,DR_SET
                db      DR_AND,DR_XOR,DR_XOR,DR_OR
                db      DR_AND,DR_XOR,     0,DR_OR
                db      DR_SET,DR_OR ,DR_OR ,DR_SET

;-----------------------------------------------------------------------;
; 1 entries mark rops that require two passes, one to invert the destination
; and then another to finish the rop.
; The first entry is ignored; there is no mix 0.
        public  jInvertDest
jInvertDest     db      0, 0,1,0,0,1,0,0,1,0,0,0,0,0,1,0,0

;-----------------------------------------------------------------------;
; Table of routines to be called to draw edges, according to which edges are
; partial and which edges are whole bytes.
        align   4
pfnEdgeDrawing  label   dword
        dd      do_right_edge_bytes
        dd      do_both_edge_bytes
        dd      check_next_bank
        dd      do_left_edge_bytes

;-----------------------------------------------------------------------;
; Table of pointers to tables used to find appropriate whole byte loops.

        align   4
pfnWideWholeRep label   dword
        dd      draw_wide_w_00_loop
        dd      draw_wide_w_01_loop
        dd      draw_wide_w_02_loop
        dd      draw_wide_w_03_loop
        dd      draw_wide_w_10_loop
        dd      draw_wide_w_11_loop
        dd      draw_wide_w_12_loop
        dd      draw_wide_w_13_loop
        dd      draw_wide_w_20_loop
        dd      draw_wide_w_21_loop
        dd      draw_wide_w_22_loop
        dd      draw_wide_w_23_loop
        dd      draw_wide_w_30_loop
        dd      draw_wide_w_31_loop
        dd      draw_wide_w_32_loop
        dd      draw_wide_w_33_loop

;-----------------------------------------------------------------------;
; Table of pointers to tables used to find narrow, special-cased
; non-replace whole byte loops.

; Note: The breakpoint where one should switch from special-casing to
;  REP MOVSB is purely a guess on my part. 5 seemed reasonable.

        align   4
pfnWholeBytesNonReplaceEntries  label   dword
        dd      0                       ;we never get a 0-wide case
        dd      draw_1_wide_rw_loop
        dd      draw_2_wide_rw_loop
        dd      draw_3_wide_rw_loop
        dd      draw_4_wide_rw_loop
MAX_NON_REPLACE_SPECIAL equ     ($-pfnWholeBytesNonReplaceEntries)/4

;-----------------------------------------------------------------------;
; Table of pointers to tables used to find narrow, special-cased replace
; whole byte loops.

; Note: The breakpoint where one should switch from special-casing to
;  REP STOS is purely a guess on my part. 8 seemed reasonable.

; Start address MOD 3 is 0.
        align   4
pfnWholeBytesMod0ReplaceEntries  label   dword
        dd      0                       ;we never get a 0-wide case
        dd      draw_1_wide_w_loop
        dd      draw_2_wide_w_loop
        dd      draw_3_wide_w_even_loop
        dd      draw_4_wide_w_loop
        dd      draw_5_wide_w_even_loop
        dd      draw_6_wide_w_mod3_0_loop
        dd      draw_7_wide_w_mod3_0_loop
        dd      draw_8_wide_w_mod3_0_loop
MAX_REPLACE_SPECIAL equ     ($-pfnWholeBytesMod0ReplaceEntries)/4

; Start address MOD 3 is 1.
        align   4
pfnWholeBytesMod1ReplaceEntries  label   dword
        dd      0                       ;we never get a 0-wide case
        dd      draw_1_wide_w_loop
        dd      draw_2_wide_w_loop
        dd      draw_3_wide_w_odd_loop
        dd      draw_4_wide_w_loop
        dd      draw_5_wide_w_odd_loop
        dd      draw_6_wide_w_mod3_1_loop
        dd      draw_7_wide_w_mod3_1_loop
        dd      draw_8_wide_w_mod3_1_loop

; Start address MOD 3 is 2.
        align   4
pfnWholeBytesMod2ReplaceEntries  label   dword
        dd      0                       ;we never get a 0-wide case
        dd      draw_1_wide_w_loop
        dd      draw_2_wide_w_loop
        dd      draw_3_wide_w_even_loop
        dd      draw_4_wide_w_loop
        dd      draw_5_wide_w_even_loop
        dd      draw_6_wide_w_mod3_2_loop
        dd      draw_7_wide_w_mod3_2_loop
        dd      draw_8_wide_w_mod3_2_loop

; Start address MOD 3 is 3.
        align   4
pfnWholeBytesMod3ReplaceEntries  label   dword
        dd      0                       ;we never get a 0-wide case
        dd      draw_1_wide_w_loop
        dd      draw_2_wide_w_loop
        dd      draw_3_wide_w_odd_loop
        dd      draw_4_wide_w_loop
        dd      draw_5_wide_w_odd_loop
        dd      draw_6_wide_w_mod3_1_loop
        dd      draw_7_wide_w_mod3_3_loop
        dd      draw_8_wide_w_mod3_3_loop

; Master MOD 3 alignment look-up table for entry tables for four possible
; alignments for narrow, special-cased replace whole byte loops.
        align   4
pfnWholeBytesReplaceMaster      label   dword
        dd      pfnWholeBytesMod0ReplaceEntries
        dd      pfnWholeBytesMod1ReplaceEntries
        dd      pfnWholeBytesMod2ReplaceEntries
        dd      pfnWholeBytesMod3ReplaceEntries

;-----------------------------------------------------------------------;

                .code

;-----------------------------------------------------------------------;

cProc   vTrgBlt,24,<         \
        uses    esi edi ebx, \
        ppdev:    ptr,       \
        culRcl:   dword,     \
        prcl:     ptr RECTL, \
        ulMix:    dword,     \
        ulColor:  dword,     \
        pptlBrsuh:ptr POINTL >

        local   ulRowOffset :dword      ;Offset from start of scan line of
                                        ; first byte to fill
        local   ulWholeBytes :dword     ;# of whole bytes to fill
        local   ulWholeDwords :dword    ;# of whole dwords to fill
        local   pfnWholeFn  :dword      ;pointer to routine used to draw
                                        ; whole bytes
        local   ulScanWidth :dword      ;offset from start of one scan to start
                                        ; of next
        local   ulNextScan  :dword      ;offset from end of one scan line's
                                        ; fill to start of next
        local   ulCurrentTopScan :dword ;top scan line to fill in current bank
        local   ulMasks     :dword      ;low byte = right mask, high byte =
                                        ; left mask
        local   ulBottomScan :dword     ;bottom scan line of fill rectangle
        local   jALUFunc   :dword       ;VGA ALU logical operation (SET, AND,
                                        ; OR, or XOR)
        local   pfnStartDrawing :dword  ;pointer to function to call to start
                                        ; drawing
        local   pfnContinueDrawing :dword ;pointer to function to call to
                                        ; continue drawing after doing whole
                                        ; bytes
        local   ulLeftEdgeAdjust :dword ;used to bump the whole bytes start
                                        ; address past the left edge when the
                                        ; left edge is partial
        local   pfnWholeBytes :dword    ;pointer to loop for whole byte filling
        local   jInvertDestFirst :dword ;1 if the rop requires a pass to invert
                                        ; the destination before the normal
                                        ; pass
        local   ulDrawingColor :dword   ;color byte with which to fill,
                                        ; replicated to a dword
        local   ppfnDrawEdgeTable :dword ;points to loop to be used to draw
                                         ; edge ; bytes (draw_1_wide_rw_loop
                                         ; or draw_1_wide_w_loop)

;-----------------------------------------------------------------------;
; CLD is assumed on entry.
;-----------------------------------------------------------------------;

;-----------------------------------------------------------------------;
; Make sure there's something to draw; clip enumerations can be empty.
;-----------------------------------------------------------------------;

        cmp     culRcl,0                ;any rects to fill?
        jz      vTrgBlts_done           ;no, we're done


;-----------------------------------------------------------------------;
; Set up variables that are constant for the entire time we're in this
; module.
;-----------------------------------------------------------------------;

;-----------------------------------------------------------------------;
; Set up for the desired raster op.
;-----------------------------------------------------------------------;

        sub     ebx,ebx                 ;ignore any background mix; we're only
        mov     bl,byte ptr ulMix       ; concerned with the foreground in this
                                        ; module
        cmp     ebx,R2_NOP              ;is this NOP?
        jz      vTrgBlts_done           ;yes, we're done
        mov     al,jInvertDest[ebx]          ;remember whether we need to
        mov     byte ptr jInvertDestFirst,al ; invert the destination before
                                             ; finishing the rop
        mov     ah,byte ptr ulColor     ;get the drawing color
        and     ah,jForceOffTable[ebx]  ;force color to 0 if necessary
                                        ; (R2_BLACK)
        or      ah,jForceOnTable[ebx]   ;force color to 0ffh if necessary
                                        ; (R2_WHITE, R2_NOT)
        xor     ah,jNotTable[ebx]       ;invert color if necessary (any Pn mix)
                                        ;at this point, CH has the color we
                                        ; want to draw with; set up the VGA
                                        ; hardware to draw with that color
        mov     al,ah                   ;replicate the drawing color to a dword
        mov     edx,eax
        shl     eax,16
        mov     ax,dx
        mov     ulDrawingColor,eax      ;remember drawing color

        mov     ppfnDrawEdgeTable,offset draw_1_wide_w_loop
                                        ;assume replace-type rop, so we can
                                        ; draw edge bytes with the write-
                                        ; without-read code pointed to by this
                                        ; table
        mov     ah,jALUFuncTable[ebx]   ;get the ALU logical function
        and     ah,ah                   ;is the logical function DR_SET?
        .errnz  DR_SET
        jz      short skip_ALU_set      ;yes, don't have to set because that's
                                        ; the VGA's default state
        mov     edx,VGA_BASE + GRAF_ADDR
        mov     al,GRAF_DATA_ROT
        out     dx,ax                   ;set the ALU logical function
        mov     ppfnDrawEdgeTable,offset draw_1_wide_rw_loop
                                        ;draw edge bytes with this loop
                                        ; (read/write)
skip_ALU_set:
        mov     byte ptr jALUFunc,ah    ;remember the ALU logical function

;-----------------------------------------------------------------------;
; Fill the current rectangle with the specified raster op and color.
;-----------------------------------------------------------------------;

fill_rect_loop:

;-----------------------------------------------------------------------;
; Set up variables that are constant from bank to bank during a single
; fill.
;-----------------------------------------------------------------------;

;-----------------------------------------------------------------------;
; Set up masks and widths.
;-----------------------------------------------------------------------;

        mov     edi,prcl                ;point to rectangle to fill
        mov     eax,[edi].yBottom
        mov     ulBottomScan,eax        ;remember the bottom scan line of fill

        mov     ebx,[edi].xRight        ;right edge of fill (non-inclusive)
        mov     ecx,ebx
        and     ecx,011b                ;intrabyte address of right edge
        mov     ah,jRightMask[ecx]      ;right edge mask

        mov     esi,[edi].xLeft         ;left edge of fill (inclusive)
        mov     ecx,esi
        shr     ecx,2                   ;/4 for start offset from left edge
                                        ; of scan line
        mov     ulRowOffset,ecx         ;remember offset from start of scan
                                        ; line
        sub     ebx,esi                 ;width in pixels of fill

        and     esi,011b                ;intrabyte address of left edge
        mov     al,jLeftMask[esi]       ;left edge mask

        dec     ebx                     ;make inclusive on right
        add     ebx,esi                 ;inclusive width, starting counting at
                                        ; the beginning of the left edge byte
        shr     ebx,2                   ;width of fill in bytes touched - 1
        jnz     short more_than_1_byte  ;more than 1 byte is involved

; Only one byte will be affected. Combine first/last masks.

        and     al,ah                   ;we'll use first byte mask only
        xor     ah,ah                   ;want last byte mask to be 0
        inc     ebx                     ;so there's one count to subtract below
                                        ; if this isn't a whole edge byte
more_than_1_byte:

; If all pixels in the left edge are altered, combine the first byte into the
; whole byte count and clear the first byte mask, because we can handle solid
; edge bytes faster as part of the whole bytes. Ditto for the right edge.

        sub     ecx,ecx                 ;edge whole-status accumulator
        cmp     al,-1                   ;is left edge a whole byte or partial?
        adc     ecx,ecx                 ;ECX=1 if left edge partial, 0 if whole
        sub     ebx,ecx                 ;if left edge partial, deduct it from
                                        ; the whole bytes count
        mov     ulLeftEdgeAdjust,ecx    ;for skipping over the left edge if
                                        ; it's partial when pointing to the
                                        ; whole bytes
        and     ah,ah                   ;is right edge mask 0, meaning this
                                        ; fill is only 1 byte wide?
        jz      short save_masks        ;yes, no need to do anything
        cmp     ah,-1                   ;is right edge a whole byte or partial?
        jnz     short save_masks        ;partial
        add     ecx,2                   ;bit 1 of ECX=0 if right edge partial,
                                        ; 1 if whole;
                                        ;bit 1=0 if left edge partial, 1 whole
        inc     ebx                     ;if right edge whole, include it in the
                                        ; whole bytes count
save_masks:
        mov     ulMasks,eax             ;save left and right clip masks
        mov     ulWholeBytes,ebx        ;save # of whole bytes

        mov     ecx,pfnEdgeDrawing[ecx*4] ;set address of routine to draw
        mov     pfnContinueDrawing,ecx    ; all partial (non-whole) edges

        and     ebx,ebx                 ;any whole bytes?
        jz      short start_vec_set     ;no
                                        ;yes, so draw the whole bytes before
                                        ; the edge bytes

; The whole bytes loop depends on the type of operation being done. If the
; operation is one which uses DR_SET, then we can use a STOS-type operation,
; else we have to use a MOVSB-type operation (to load the latches with the
; existing contents of display memory to allow the ALUs to work).

        cmp     byte ptr jALUFunc,DR_SET ;is it a replace-type rop?
        jz      short is_replace_type   ;yes
                                        ;no, set up for non-replace whole bytes
        mov     ecx,offset whole_bytes_non_replace_wide
                                        ;assume too wide to special-case
        cmp     ebx,MAX_NON_REPLACE_SPECIAL ;too wide to special case?
        jnb     short start_vec_set     ;yes
        mov     ecx,pfnWholeBytesNonReplaceEntries[ebx*4] ;no, point to entry
        mov     pfnWholeBytes,ecx       ; table for width
        mov     ecx,offset whole_bytes_special
                                        ;set up to call special routine to fill
                                        ; whole bytes
        jmp     short start_vec_set

is_replace_type:                        ;set up for replace-type rop
        cmp     ebx,MAX_REPLACE_SPECIAL ;too wide to special case?
        jnb     short is_wide_replace   ;yes
                                        ;narrow enough to special case. Look up
                                        ; the entry table for the special case
                                        ; base on the start alignment
        mov     ecx,ulRowOffset
        add     ecx,ulLeftEdgeAdjust    ;left edge whole bytes start offset
        and     ecx,011b                ;left edge whole bytes start alignment
                                        ; MOD 3
        mov     ecx,pfnWholeBytesReplaceMaster[ecx*4] ;look up table of entry
                                                      ; tables for alignment
        mov     ecx,[ecx+ebx*4]         ;look up entry table for width
        mov     pfnWholeBytes,ecx       ; table for width
        mov     ecx,offset whole_bytes_special
                                        ;set up to call special routine to fill
                                        ; whole bytes
        jmp     short start_vec_set

is_wide_replace:                        ;set up for wide replace-type op
                                        ;Note: assumes there is at least one
                                        ; full dword involved!
        mov     ecx,ulRowOffset
        add     ecx,ulLeftEdgeAdjust    ;left edge whole bytes start offset
        neg     ecx
        and     ecx,011b
        mov     edx,ebx
        sub     edx,ecx                 ;ignore odd leading bytes
        mov     eax,edx
        shr     edx,2                   ;# of whole dwords across (not counting
                                        ; odd leading & trailing bytes)
        mov     ulWholeDwords,edx
        and     eax,011b                ;# of odd (fractional) trailing bytes
        shl     ecx,2
        or      ecx,eax                 ;build a look-up index from the number
                                        ; of leading and trailing bytes
        mov     ecx,pfnWideWholeRep[ecx*4] ;proper drawing handler for front/
        mov     pfnWholeBytes,ecx          ; back alignment
        mov     ecx,offset whole_bytes_rep_wide
                                        ;set up to call routine to perform wide
                                        ; whole bytes fill
start_vec_set:
        mov     pfnStartDrawing,ecx     ; all partial (non-whole) edges

        mov     ecx,ppdev
        mov     eax,[ecx].pdev_lPlanarNextScan
        mov     ulScanWidth,eax         ;local copy of scan line width
        sub     eax,ebx                 ;EAX = delta to next scan
        mov     ulNextScan,eax


;-----------------------------------------------------------------------;
; Fill this rectangle.
;-----------------------------------------------------------------------;

        cmp     byte ptr jInvertDestFirst,1
                                        ;is this an invert-dest-plus-something-
                                        ; else rop that requires two passes?
        jz      short do_invert_dest_rop ;yes, special case with two passes

do_single_pass:
        call    draw_banks


;-----------------------------------------------------------------------;
; See if there are any more rectangles to fill.
;-----------------------------------------------------------------------;

        add     prcl,(size RECTL) ;point to the next rectangle, if there is one
        dec     culRcl            ;count down the rectangles to fill
        jnz     fill_rect_loop


;-----------------------------------------------------------------------;
; We have filled all rectangles.  Restore the VGA to its default state.
;-----------------------------------------------------------------------;

        cmp     byte ptr jALUfunc,DR_SET ;is the logical function already SET?
        jnz     short @F                 ;no, need to reset it
        cRet    vTrgBlt                  ;yes, no need to reset it

@@:
        mov     edx,VGA_BASE + GRAF_ADDR
        mov     eax,(DR_SET shl 8) + GRAF_DATA_ROT ;set the logical function to
        out     dx,ax                              ; SET
vTrgBlts_done:
        cRet    vTrgBlt


;-----------------------------------------------------------------------;
; Handles rops that require two passes, the first being a destination
; inversion pass.
;-----------------------------------------------------------------------;

do_invert_dest_rop:

; Set up the VGA's hardware for inversion

        mov     eax,ulDrawingColor      ;remember the normal drawing color
        push    eax
        mov     ulDrawingColor,-1       ;with XOR, this flips all bits

        mov     edx,VGA_BASE + GRAF_ADDR
        mov     eax,(DR_XOR shl 8) + GRAF_DATA_ROT
        out     dx,ax                   ;logical function = XOR to invert

; Invert the destination

        call    draw_banks

; Restore the VGA's hardware to the state required for the second pass.

        mov     edx,VGA_BASE + GRAF_ADDR
        mov     ah,byte ptr jALUFunc
        mov     al,GRAF_DATA_ROT
        out     dx,ax                   ;set the ALU logical function back to
                                        ; proper state for the rest of the rop

        pop     eax
        mov     ulDrawingColor,eax      ;restore the normal drawing color

; Perform the second pass to finish the rop.

        jmp     do_single_pass


;-----------------------------------------------------------------------;
; Fills all banks in the current fill rectangle. Called once per fill
; rectangle, except for destination-inversion-plus-something-else rops.
;-----------------------------------------------------------------------;

draw_banks:

;-----------------------------------------------------------------------;
; Map in the bank containing the top scan to fill, if it's not mapped in
; already.
;-----------------------------------------------------------------------;

        mov     edi,prcl                ;point to rectangle to fill
        mov     ecx,ppdev               ;point to PDEV
        mov     eax,[edi].yTop          ;top scan line of fill
        mov     ulCurrentTopScan,eax    ;this will be the fill top in 1st bank

        cmp     eax,[ecx].pdev_rcl1PlanarClip.yTop ;is fill top less than
                                                   ; current bank?
        jl      short map_init_bank             ;yes, map in proper bank
        cmp     eax,[ecx].pdev_rcl1PlanarClip.yBottom ;fill top greater than
                                                      ; current bank?
        jl      short init_bank_mapped          ;no, proper bank already mapped
map_init_bank:

; Map in the bank containing the top scan line of the fill.

        ptrCall <dword ptr [ecx].pdev_pfnPlanarControl>,<ecx,eax,JustifyTop>

init_bank_mapped:

;-----------------------------------------------------------------------;
; Main loop for processing fill in each bank.
;-----------------------------------------------------------------------;

; Compute the starting address and scan line count for the initial bank.

        mov     eax,ppdev               ;point to PDEV
        mov     ebx,ulBottomScan        ;bottom of destination rectangle
        cmp     ebx,[eax].pdev_rcl1PlanarClip.yBottom
                                        ;which comes first, the bottom of the
                                        ; dest rect or the bottom of the
                                        ; current bank?
        jl      short BottomScanSet     ;fill bottom comes first, so draw to
                                        ; that; this is the last bank in fill
        mov     ebx,[eax].pdev_rcl1PlanarClip.yBottom
                                        ;bank bottom comes first; draw to
                                        ; bottom of bank
BottomScanSet:
        mov     edi,ulCurrentTopScan    ;top scan line to fill in current bank
        sub     ebx,edi                 ;# of scans to fill in bank
        imul    edi,ulScanWidth         ;offset of starting scan line

; Note that the start of the bitmap will change each time through the
; bank loop, because the start of the bitmap is varied to map the
; desired scan line to the banking window.

        add     edi,[eax].pdev_pvBitmapStart ;start of scan in bitmap
        add     edi,ulRowOffset         ;EDI = start offset of fill in bitmap

; We have computed the starting address and scan count. Time to start drawing
; in the initial bank.

        jmp     pfnStartDrawing


;-----------------------------------------------------------------------;
; Whole byte fills.
;-----------------------------------------------------------------------;

;-----------------------------------------------------------------------;
; Handles non-replace whole byte fills wider than the maximum special
; case width.
;
; The destination is not involved, so a STOS (or equivalent) can be used
; (no read needed before write).
;-----------------------------------------------------------------------;

whole_bytes_rep_wide:
        push    ebx                     ;save scan count
        push    edi                     ;save starting address

        add     edi,ulLeftEdgeAdjust    ;point to first whole byte to fill
        mov     esi,ulWholeDwords       ;whole dwords width
        mov     edx,ulNextScan          ;offset from end of one scan line to
                                        ; start of next
        mov     eax,ulDrawingColor      ;each byte is color with which to fill

        call    pfnWholeBytes           ;draw the wide whole bytes

        pop     edi                     ;restore screen pointer
        pop     ebx                     ;restore fill scan count
        jmp     pfnContinueDrawing      ;either keep drawing or we're done


;-----------------------------------------------------------------------;
; Handles both replace and non-replace whole byte fills narrow enough to
; special case.
;-----------------------------------------------------------------------;

whole_bytes_special:
        push    ebx                     ;save scan count
        push    edi                     ;save starting address

        add     edi,ulLeftEdgeAdjust    ;point to first whole byte to fill
        mov     ecx,ulScanWidth         ;offset to next scan line
        mov     eax,ulDrawingColor      ;each byte is color with which to fill

        call    pfnWholeBytes           ;draw the wide whole bytes

        pop     edi                     ;restore screen pointer
        pop     ebx                     ;restore fill scan count
        jmp     pfnContinueDrawing      ;either keep drawing or we're done


;-----------------------------------------------------------------------;
; Handles non-replace whole byte fills wider than the maximum special case
; width.
;
; The destination is involved, so a MOVSB (or equivalent) must be
; performed in order to do a read before write to give the ALUs something
; to work with.
;-----------------------------------------------------------------------;

whole_bytes_non_replace_wide:
        push    ebx                     ;save scan count
        push    edi                     ;save starting address

        add     edi,ulLeftEdgeAdjust    ;point to first whole byte to fill
        mov     esi,ulWholeBytes        ;whole bytes width
        mov     edx,ulNextScan          ;offset from end of one scan line to
                                        ; start of next
        mov     eax,ulDrawingColor      ;each byte is color with which to fill

;-----------------------------------------------------------------------;
; 5-or-wider read before write loop.
;
; Entry:
;       EAX = # of bytes to fill across scan line (needed only by 5-or-wider
;               handler)
;       EBX = loop count
;       EDX = offset from end of one scan line to the start of the next next
;       EDI = start offset
;
; EBX, ECX, ESI, EDI modified. All other registers preserved.

; 5-or-wider read/write.

draw_wide_rw_loop:
        mov     ecx,esi
@@:
        mov     ah,[edi]        ;latch the target address. The data read
                                ; doesn't matter
        mov     [edi],al        ;merge the drawing color with the latched
                                ; target address according to the selected ALU
                                ; function, and write the result to display
                                ; memory
        inc     edi             ;point to the next byte
        dec     ecx
        jnz     @B
        add     edi,edx
        dec     ebx
        jnz     draw_wide_rw_loop

        pop     edi                     ;restore screen pointer
        pop     ebx                     ;restore fill scan count
        jmp     pfnContinueDrawing      ;either keep drawing or we're done


;-----------------------------------------------------------------------;
; Process any left/right columns that that have to be done.
;
;   Currently:
;       EBX =   height to fill, in scans
;       EDI --> first byte of left edge
;-----------------------------------------------------------------------;

;-----------------------------------------------------------------------;
; Handle case where both edges are partial (non-whole) bytes. We don't
; have to read before write because we're using the Map Mask, not the
; Bit Mask.
;-----------------------------------------------------------------------;
        public do_both_edge_bytes
do_both_edge_bytes::

; Set up variables for entering loop.

        mov     al,byte ptr ulMasks     ;this will become the clip mask for the
                                        ; left edge
        mov     edx,VGA_BASE + SEQ_DATA ;SEQ_INDEX already points to Map Mask
        out     dx,al                   ;set Map Mask for left edge

        mov     ecx,ulScanWidth         ;offset from one scan to next

        mov     esi,ulWholeBytes        ;ESI = # of whole bytes
        lea     esi,[esi+edi+1]         ;--> start for right edge
        mov     eax,ulDrawingColor      ;each byte is color with which to fill

        push    ebx                     ;preserve scan line count
        call    ppfnDrawEdgeTable       ;jump into the loop to draw
        pop     ebx                     ;restore scan line count

        mov     edi,esi                 ;point to first right edge byte
        mov     al,byte ptr ulMasks+1   ;this will become the Bit Mask for the
                                        ; right edge
        mov     edx,VGA_BASE + SEQ_DATA ;SEQ_INDEX already points to Map Mask
        out     dx,al                   ;set Map Mask for left edge

        mov     eax,ulDrawingColor      ;each byte is color with which to fill

        push    offset edges_done       ;return here
        jmp     ppfnDrawEdgeTable       ;jump into the loop to draw

;-----------------------------------------------------------------------;
; Handle case where only the left edge is partial (non-whole).
;-----------------------------------------------------------------------;
do_left_edge_bytes::

; Set up variables for entering loop.

        mov     ecx,ulScanWidth         ;offset from one scan to next
        mov     al,byte ptr ulMasks     ;this will become the Bit Mask for the
                                        ; left edge
        mov     edx,VGA_BASE + SEQ_DATA ;SEQ_INDEX already points to Map Mask
        out     dx,al                   ;set Map Mask for left edge

        mov     eax,ulDrawingColor      ;each byte is color with which to fill

        push    offset edges_done       ;return here
        jmp     ppfnDrawEdgeTable       ;jump into the loop to draw

;-----------------------------------------------------------------------;
; Handle case where only the right edge is partial (non-whole).
;-----------------------------------------------------------------------;
do_right_edge_bytes::

; Set up variables for entering loop.

        mov     ecx,ulScanWidth         ;offset from one scan to next
        add     edi,ulWholeBytes        ;--> start for right edge (remember,
                                        ; left edge is whole, so the left edge
                                        ; byte is included in the whole byte
                                        ; count)
        mov     al,byte ptr ulMasks+1   ;this will become the Bit Mask for the
                                        ; right edge
        mov     edx,VGA_BASE + SEQ_DATA ;SEQ_INDEX already points to Map Mask
        out     dx,al                   ;set Map Mask for right edge

        mov     eax,ulDrawingColor      ;each byte is color with which to fill

        call    ppfnDrawEdgeTable       ;jump into the loop to draw

;-----------------------------------------------------------------------;
; We have done all partial edges.
;-----------------------------------------------------------------------;

edges_done:

        mov     edx,VGA_BASE + SEQ_DATA ;SEQ_INDEX already points to Map Mask
        mov     al,MM_ALL               ;restore the default Map Mask of all
        out     dx,al                   ; planes enabled

;-----------------------------------------------------------------------;
; See if there are any more banks to process.
;-----------------------------------------------------------------------;

check_next_bank::

        mov     edi,ppdev
        mov     eax,[edi].pdev_rcl1PlanarClip.yBottom ;is the fill bottom in
        cmp     ulBottomScan,eax                      ; the current bank?
        jle     short banks_done        ;yes, so we're done
                                        ;no, map in the next bank and fill it
        mov     ulCurrentTopScan,eax    ;remember where the top of the bank
                                        ; we're about to map in is (same as
                                        ; bottom of bank we just did)

        ptrCall <dword ptr [edi].pdev_pfnPlanarControl>,<edi,eax,JustifyTop>
                                        ;map in the bank

; Compute the starting address and scan line count in this bank.

        mov     eax,ppdev               ;EAX->target surface
        mov     ebx,ulBottomScan        ;bottom of destination rectangle
        cmp     ebx,[eax].pdev_rcl1PlanarClip.yBottom
                                        ;which comes first, the bottom of the
                                        ; dest rect or the bottom of the
                                        ; current bank?
        jl      short BottomScanSet2    ;fill bottom comes first, so draw to
                                        ; that; this is the last bank in fill
        mov     ebx,[eax].pdev_rcl1PlanarClip.yBottom
                                        ;bank bottom comes first; draw to
                                        ; bottom of bank
BottomScanSet2:
        mov     edi,ulCurrentTopScan    ;top scan line to fill in current bank
        sub     ebx,edi                 ;# of scans to fill in bank
        imul    edi,ulScanWidth         ;offset of starting scan line

; Note that the start of the bitmap will change each time through the
; bank loop, because the start of the bitmap is varied to map the
; desired scan line to the banking window.

        add     edi,[eax].pdev_pvBitmapStart ;start of scan in bitmap
        add     edi,ulRowOffset         ;EDI = start offset of fill in bitmap

; Draw in the new bank.

        jmp     pfnStartDrawing


;-----------------------------------------------------------------------;
; Done with all banks in this fill.

banks_done:
        retn

endProc vTrgBlt


;-----------------------------------------------------------------------;
; Drawing loops.
; There are two kinds of drawing loops: read-before-write (to load the
;  latches), and write-only (for replace-type rops).
;-----------------------------------------------------------------------;


;-----------------------------------------------------------------------;
; Drawing stuff for cases where read before write is required,
; to load the latches.
;-----------------------------------------------------------------------;

;-----------------------------------------------------------------------;
; 1-, 2-, 3-, and 4-wide read before write drawing loops.
;
; Entry:
;       AL  = drawing color
;       EBX = loop count
;       ECX = scan line width in bytes
;       EDI = start offset
;
; EBX, EDI modified. All other registers preserved.

; 1-wide read/write.

draw_1_wide_rw_loop     proc    near
        mov     ah,[edi]        ;latch the target address. The data read
                                ; doesn't matter
        mov     [edi],al        ;merge the drawing color with the latched
                                ; target address according to the selected ALU
                                ; function, and write the result to display
                                ; memory
        add     edi,ecx         ;point to the next scan line

        dec     ebx
        jnz     draw_1_wide_rw_loop

        ret

draw_1_wide_rw_loop     endp

; 2-wide read/write.

draw_2_wide_rw_loop     proc    near
        mov     ah,[edi]                ;see 1-wide RW case for comments
        mov     [edi],al
        mov     ah,[edi+1]
        mov     [edi+1],al
        add     edi,ecx                 ;point to the next scan line

        dec     ebx
        jnz     draw_2_wide_rw_loop

        ret

draw_2_wide_rw_loop     endp

; 3-wide read/write.

draw_3_wide_rw_loop     proc    near
        mov     ah,[edi]                ;see 1-wide RW case for comments
        mov     [edi],al
        mov     ah,[edi+1]
        mov     [edi+1],al
        mov     ah,[edi+2]
        mov     [edi+2],al
        add     edi,ecx                 ;point to the next scan line

        dec     ebx
        jnz     draw_3_wide_rw_loop

        ret

draw_3_wide_rw_loop     endp

; 4-wide read/write.

draw_4_wide_rw_loop     proc    near
        mov     ah,[edi]                ;see 1-wide RW case for comments
        mov     [edi],al
        mov     ah,[edi+1]
        mov     [edi+1],al
        mov     ah,[edi+2]
        mov     [edi+2],al
        mov     ah,[edi+3]
        mov     [edi+3],al
        add     edi,ecx                 ;point to the next scan line

        dec     ebx
        jnz     draw_4_wide_rw_loop

        ret

draw_4_wide_rw_loop     endp

;-----------------------------------------------------------------------;
; Drawing stuff for cases where read before write is NOT required.
;-----------------------------------------------------------------------;

;-----------------------------------------------------------------------;
; 1-, 2-, 3-, and 4-wide write-only edge-drawing loops.
;
; Entry:
;       EAX = fill color, replicated four times
;       EBX = loop count
;       ECX = scan line width in bytes
;       EDI = start offset
;
; EBX, EDI modified. All other registers preserved.

; 1-wide write-only.

draw_1_wide_w_loop     proc    near
        mov     [edi],al                ;draw the pixel
        add     edi,ecx                 ;point to the next scan line

        dec     ebx
        jnz     draw_1_wide_w_loop

        ret

draw_1_wide_w_loop     endp

; 2-wide write-only.

draw_2_wide_w_loop     proc    near
        mov     [edi],ax
        add     edi,ecx                 ;point to the next scan line

        dec     ebx
        jnz     draw_2_wide_w_loop

        ret

draw_2_wide_w_loop     endp

; 3-wide write-only, starting at an even address.

draw_3_wide_w_even_loop     proc    near
        mov     [edi],ax
        mov     [edi+2],al
        add     edi,ecx                 ;point to the next scan line

        dec     ebx
        jnz     draw_3_wide_w_even_loop

        ret

draw_3_wide_w_even_loop     endp

; 3-wide write-only, starting at an odd address.

draw_3_wide_w_odd_loop     proc    near
        mov     [edi],al
        mov     [edi+1],ax
        add     edi,ecx                 ;point to the next scan line

        dec     ebx
        jnz     draw_3_wide_w_odd_loop

        ret

draw_3_wide_w_odd_loop     endp

; 4-wide write-only.

draw_4_wide_w_loop     proc    near
        mov     [edi],eax
        add     edi,ecx                 ;point to the next scan line

        dec     ebx
        jnz     draw_4_wide_w_loop

        ret

draw_4_wide_w_loop     endp

; 5-wide write-only, starting at an even address.

draw_5_wide_w_even_loop     proc    near
        mov     [edi],eax
        mov     [edi+4],al
        add     edi,ecx                 ;point to the next scan line

        dec     ebx
        jnz     draw_5_wide_w_even_loop

        ret

draw_5_wide_w_even_loop     endp

; 5-wide write-only, starting at an odd address.

draw_5_wide_w_odd_loop     proc    near
        mov     [edi],al
        mov     [edi+1],eax
        add     edi,ecx                 ;point to the next scan line

        dec     ebx
        jnz     draw_5_wide_w_odd_loop

        ret

draw_5_wide_w_odd_loop     endp

; 6-wide write-only, starting at MOD 3 == 0.

draw_6_wide_w_mod3_0_loop     proc    near
        mov     [edi],eax
        mov     [edi+4],ax
        add     edi,ecx                 ;point to the next scan line

        dec     ebx
        jnz     draw_6_wide_w_mod3_0_loop

        ret

draw_6_wide_w_mod3_0_loop     endp

; 6-wide write-only, starting at MOD 3 == 1 or 3.

draw_6_wide_w_mod3_1_loop     proc    near
        mov     [edi],al
        mov     [edi+1],eax
        mov     [edi+5],al
        add     edi,ecx                 ;point to the next scan line

        dec     ebx
        jnz     draw_6_wide_w_mod3_1_loop

        ret

draw_6_wide_w_mod3_1_loop     endp

; 6-wide write-only, starting at MOD 3 == 2.

draw_6_wide_w_mod3_2_loop     proc    near
        mov     [edi],ax
        mov     [edi+2],eax
        add     edi,ecx                 ;point to the next scan line

        dec     ebx
        jnz     draw_6_wide_w_mod3_2_loop

        ret

draw_6_wide_w_mod3_2_loop     endp

; 7-wide write-only, starting at MOD 3 == 0.

draw_7_wide_w_mod3_0_loop     proc    near
        mov     [edi],eax
        mov     [edi+4],ax
        mov     [edi+6],al
        add     edi,ecx                 ;point to the next scan line

        dec     ebx
        jnz     draw_7_wide_w_mod3_0_loop

        ret

draw_7_wide_w_mod3_0_loop     endp

; 7-wide write-only, starting at MOD 3 == 0.

draw_7_wide_w_mod3_1_loop     proc    near
        mov     [edi],al
        mov     [edi+1],ax
        mov     [edi+3],eax
        add     edi,ecx                 ;point to the next scan line

        dec     ebx
        jnz     draw_7_wide_w_mod3_1_loop

        ret

draw_7_wide_w_mod3_1_loop     endp

; 7-wide write-only, starting at MOD 3 == 2.

draw_7_wide_w_mod3_2_loop     proc    near
        mov     [edi],ax
        mov     [edi+2],eax
        mov     [edi+6],al
        add     edi,ecx                 ;point to the next scan line

        dec     ebx
        jnz     draw_7_wide_w_mod3_2_loop

        ret

draw_7_wide_w_mod3_2_loop     endp

; 7-wide write-only, starting at MOD 3 == 3.

draw_7_wide_w_mod3_3_loop     proc    near
        mov     [edi],al
        mov     [edi+1],eax
        mov     [edi+5],ax
        add     edi,ecx                 ;point to the next scan line

        dec     ebx
        jnz     draw_7_wide_w_mod3_3_loop

        ret

draw_7_wide_w_mod3_3_loop     endp

; 8-wide write-only, starting at MOD 3 == 0.

draw_8_wide_w_mod3_0_loop     proc    near
        mov     [edi],eax
        mov     [edi+4],eax
        add     edi,ecx                 ;point to the next scan line

        dec     ebx
        jnz     draw_8_wide_w_mod3_0_loop

        ret

draw_8_wide_w_mod3_0_loop     endp

; 8-wide write-only, starting at MOD 3 == 0.

draw_8_wide_w_mod3_1_loop     proc    near
        mov     [edi],al
        mov     [edi+1],ax
        mov     [edi+3],eax
        mov     [edi+7],al
        add     edi,ecx                 ;point to the next scan line

        dec     ebx
        jnz     draw_8_wide_w_mod3_1_loop

        ret

draw_8_wide_w_mod3_1_loop     endp

; 8-wide write-only, starting at MOD 3 == 2.

draw_8_wide_w_mod3_2_loop     proc    near
        mov     [edi],ax
        mov     [edi+2],eax
        mov     [edi+6],ax
        add     edi,ecx                 ;point to the next scan line

        dec     ebx
        jnz     draw_8_wide_w_mod3_2_loop

        ret

draw_8_wide_w_mod3_2_loop     endp

; 8-wide write-only, starting at MOD 3 == 3.

draw_8_wide_w_mod3_3_loop     proc    near
        mov     [edi],al
        mov     [edi+1],eax
        mov     [edi+5],ax
        mov     [edi+7],al
        add     edi,ecx                 ;point to the next scan line

        dec     ebx
        jnz     draw_8_wide_w_mod3_3_loop

        ret

draw_8_wide_w_mod3_3_loop     endp

;-----------------------------------------------------------------------;
; Loop stuff for wide replace-type rops (arbitrary width).
;-----------------------------------------------------------------------;

; N-wide write-only, 0 leading bytes, 0 trailing bytes.
;  EAX = 0ffffh
;  EBX = count of scans to fill
;  EDX = offset from end of one scan's fill to start of next
;  ESI = # of dwords to fill
;  EDI = target address to fill

draw_wide_w_00_loop     proc    near
        mov     ecx,esi         ;# of whole dwords
        rep     stosd           ;fill all whole bytes as dwords
        add     edi,edx         ;point to the next scan line

        dec     ebx
        jnz     draw_wide_w_00_loop

        ret

draw_wide_w_00_loop     endp

; N-wide write-only, 0 leading bytes, 1 trailing byte.
;  EAX = # of dwords to fill
;  EBX = count of scans to fill
;  EDX = offset from end of one scan's fill to start of next
;  ESI = # of dwords to fill
;  EDI = target address to fill

draw_wide_w_01_loop     proc    near
        mov     ecx,esi         ;# of whole dwords
        rep     stosd           ;fill whole bytes as dwords
        mov     [edi],al        ;fill the trailing byte
        inc     edi
        add     edi,edx         ;point to the next scan line

        dec     ebx
        jnz     draw_wide_w_01_loop

        ret

draw_wide_w_01_loop     endp

; N-wide write-only, 0 leading bytes, 2 trailing byte.
;  EAX = # of dwords to fill
;  EBX = count of scans to fill
;  EDX = offset from end of one scan's fill to start of next
;  ESI = # of dwords to fill
;  EDI = target address to fill

draw_wide_w_02_loop     proc    near
        mov     ecx,esi         ;# of whole dwords
        rep     stosd           ;fill whole bytes as dwords
        mov     [edi],ax        ;fill the trailing word
        add     edi,2
        add     edi,edx         ;point to the next scan line

        dec     ebx
        jnz     draw_wide_w_02_loop

        ret

draw_wide_w_02_loop     endp

; N-wide write-only, 0 leading bytes, 3 trailing bytes.
;  EAX = # of dwords to fill
;  EBX = count of scans to fill
;  EDX = offset from end of one scan's fill to start of next
;  ESI = # of dwords to fill
;  EDI = target address to fill

draw_wide_w_03_loop     proc    near
        mov     ecx,esi         ;# of whole dwords
        rep     stosd           ;fill whole bytes as dwords
        mov     [edi],ax        ;fill the leading word
        mov     [edi+2],al      ;fill the trailing byte
        add     edi,3
        add     edi,edx         ;point to the next scan line

        dec     ebx
        jnz     draw_wide_w_03_loop

        ret

draw_wide_w_03_loop     endp

; N-wide write-only, 1 leading byte, 0 trailing bytes.
;  EAX = # of dwords to fill
;  EBX = count of scans to fill
;  EDX = offset from end of one scan's fill to start of next
;  ESI = # of dwords to fill
;  EDI = target address to fill

draw_wide_w_10_loop     proc    near
        mov     [edi],al        ;fill the leading byte
        inc     edi
        mov     ecx,esi         ;# of whole dwords
        rep     stosd           ;fill all whole bytes as dwords
        add     edi,edx         ;point to the next scan line

        dec     ebx
        jnz     draw_wide_w_10_loop

        ret

draw_wide_w_10_loop     endp

; N-wide write-only, 1 leading bytes, 1 trailing byte.
;  EAX = # of dwords to fill
;  EBX = count of scans to fill
;  EDX = offset from end of one scan's fill to start of next
;  ESI = # of dwords to fill
;  EDI = target address to fill

draw_wide_w_11_loop     proc    near
        mov     [edi],al        ;fill the leading byte
        inc     edi
        mov     ecx,esi         ;# of whole dwords
        rep     stosd           ;fill whole bytes as dwords
        mov     [edi],al        ;fill the trailing byte
        inc     edi
        add     edi,edx         ;point to the next scan line

        dec     ebx
        jnz     draw_wide_w_11_loop

        ret

draw_wide_w_11_loop     endp

; N-wide write-only, 1 leading bytes, 2 trailing byte.
;  EAX = # of dwords to fill
;  EBX = count of scans to fill
;  EDX = offset from end of one scan's fill to start of next
;  ESI = # of dwords to fill
;  EDI = target address to fill

draw_wide_w_12_loop     proc    near
        mov     [edi],al        ;fill the leading byte
        inc     edi
        mov     ecx,esi         ;# of whole dwords
        rep     stosd           ;fill whole bytes as dwords
        mov     [edi],ax        ;fill the trailing word
        add     edi,2
        add     edi,edx         ;point to the next scan line

        dec     ebx
        jnz     draw_wide_w_12_loop

        ret

draw_wide_w_12_loop     endp

; N-wide write-only, 0 leading bytes, 3 trailing bytes.
;  EAX = # of dwords to fill
;  EBX = count of scans to fill
;  EDX = offset from end of one scan's fill to start of next
;  ESI = # of dwords to fill
;  EDI = target address to fill

draw_wide_w_13_loop     proc    near
        mov     [edi],al        ;fill the leading byte
        inc     edi
        mov     ecx,esi         ;# of whole dwords
        rep     stosd           ;fill whole bytes as dwords
        mov     [edi],ax        ;fill the trailing word
        mov     [edi+2],al      ;fill the trailing byte
        add     edi,3
        add     edi,edx         ;point to the next scan line

        dec     ebx
        jnz     draw_wide_w_13_loop

        ret

draw_wide_w_13_loop     endp

; N-wide write-only, 2 leading bytes, 0 trailing bytes.
;  EAX = # of dwords to fill
;  EBX = count of scans to fill
;  EDX = offset from end of one scan's fill to start of next
;  ESI = # of dwords to fill
;  EDI = target address to fill

draw_wide_w_20_loop     proc    near
        mov     [edi],ax        ;fill the leading word
        add     edi,2
        mov     ecx,esi         ;# of whole dwords
        rep     stosd           ;fill all whole bytes as dwords
        add     edi,edx         ;point to the next scan line

        dec     ebx
        jnz     draw_wide_w_20_loop

        ret

draw_wide_w_20_loop     endp

; N-wide write-only, 2 leading bytess, 1 trailing byte.
;  EAX = # of dwords to fill
;  EBX = count of scans to fill
;  EDX = offset from end of one scan's fill to start of next
;  ESI = # of dwords to fill
;  EDI = target address to fill

draw_wide_w_21_loop     proc    near
        mov     [edi],ax        ;fill the leading word
        add     edi,2
        mov     ecx,esi         ;# of whole dwords
        rep     stosd           ;fill whole bytes as dwords
        mov     [edi],al        ;fill the trailing byte
        inc     edi
        add     edi,edx         ;point to the next scan line

        dec     ebx
        jnz     draw_wide_w_21_loop

        ret

draw_wide_w_21_loop     endp

; N-wide write-only, 2 leading bytess, 2 trailing byte.
;  EAX = # of dwords to fill
;  EBX = count of scans to fill
;  EDX = offset from end of one scan's fill to start of next
;  ESI = # of dwords to fill
;  EDI = target address to fill

draw_wide_w_22_loop     proc    near
        mov     [edi],ax        ;fill the leading word
        add     edi,2
        mov     ecx,esi         ;# of whole dwords
        rep     stosd           ;fill whole bytes as dwords
        mov     [edi],ax        ;fill the trailing word
        add     edi,2
        add     edi,edx         ;point to the next scan line

        dec     ebx
        jnz     draw_wide_w_22_loop

        ret

draw_wide_w_22_loop     endp

; N-wide write-only, 0 leading bytes, 3 trailing bytes.
;  EAX = # of dwords to fill
;  EBX = count of scans to fill
;  EDX = offset from end of one scan's fill to start of next
;  ESI = # of dwords to fill
;  EDI = target address to fill

draw_wide_w_23_loop     proc    near
        mov     [edi],ax        ;fill the leading word
        add     edi,2
        mov     ecx,esi         ;# of whole dwords
        rep     stosd           ;fill whole bytes as dwords
        mov     [edi],ax        ;fill the trailing word
        mov     [edi+2],al      ;fill the trailing byte
        add     edi,3
        add     edi,edx         ;point to the next scan line

        dec     ebx
        jnz     draw_wide_w_23_loop

        ret

draw_wide_w_23_loop     endp

; N-wide write-only, 3 leading bytes, 0 trailing bytes.
;  EAX = # of dwords to fill
;  EBX = count of scans to fill
;  EDX = offset from end of one scan's fill to start of next
;  ESI = # of dwords to fill
;  EDI = target address to fill

draw_wide_w_30_loop     proc    near
        mov     [edi],al        ;fill the leading byte
        mov     [edi+1],ax      ;fill the leading word
        add     edi,3
        mov     ecx,esi         ;# of whole dwords
        rep     stosd           ;fill all whole bytes as dwords
        add     edi,edx         ;point to the next scan line

        dec     ebx
        jnz     draw_wide_w_30_loop

        ret

draw_wide_w_30_loop     endp

; N-wide write-only, 3 leading bytess, 1 trailing byte.
;  EAX = # of dwords to fill
;  EBX = count of scans to fill
;  EDX = offset from end of one scan's fill to start of next
;  ESI = # of dwords to fill
;  EDI = target address to fill

draw_wide_w_31_loop     proc    near
        mov     [edi],al        ;fill the leading byte
        mov     [edi+1],ax      ;fill the leading word
        add     edi,3
        mov     ecx,esi         ;# of whole dwords
        rep     stosd           ;fill whole bytes as dwords
        mov     [edi],al        ;fill the trailing byte
        inc     edi
        add     edi,edx         ;point to the next scan line

        dec     ebx
        jnz     draw_wide_w_31_loop

        ret

draw_wide_w_31_loop     endp

; N-wide write-only, 3 leading bytess, 2 trailing byte.
;  EAX = # of dwords to fill
;  EBX = count of scans to fill
;  EDX = offset from end of one scan's fill to start of next
;  ESI = # of dwords to fill
;  EDI = target address to fill

draw_wide_w_32_loop     proc    near
        mov     [edi],al        ;fill the leading byte
        mov     [edi+1],ax      ;fill the leading word
        add     edi,3
        mov     ecx,esi         ;# of whole dwords
        rep     stosd           ;fill whole bytes as dwords
        mov     [edi],ax        ;fill the trailing word
        add     edi,2
        add     edi,edx         ;point to the next scan line

        dec     ebx
        jnz     draw_wide_w_32_loop

        ret

draw_wide_w_32_loop     endp

; N-wide write-only, 0 leading bytes, 3 trailing bytes.
;  EAX = # of dwords to fill
;  EBX = count of scans to fill
;  EDX = offset from end of one scan's fill to start of next
;  ESI = # of dwords to fill
;  EDI = target address to fill

draw_wide_w_33_loop     proc    near
        mov     [edi],al        ;fill the leading byte
        mov     [edi+1],ax      ;fill the leading word
        add     edi,3
        mov     ecx,esi         ;# of whole dwords
        rep     stosd           ;fill whole bytes as dwords
        mov     [edi],ax        ;fill the trailing word
        mov     [edi+2],al      ;fill the trailing byte
        add     edi,3
        add     edi,edx         ;point to the next scan line

        dec     ebx
        jnz     draw_wide_w_33_loop

        ret

draw_wide_w_33_loop     endp

        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\vga\disp\8bpp\i386\vgaregs.asm ===
;---------------------------Module-Header------------------------------;
; Module Name: vgaregs.asm
;
; Copyright (c) 1992 Microsoft Corporation
;-----------------------------------------------------------------------;
;-----------------------------------------------------------------------;
; VOID vInitRegs(void)
;
; Sets the VGA's data control registers to their default states.
;
;-----------------------------------------------------------------------;

        .386

        .model  small,c

        assume cs:FLAT,ds:FLAT,es:FLAT,ss:FLAT
        assume fs:nothing,gs:nothing

        .xlist
        include stdcall.inc             ;calling convention cmacros
        include i386\strucs.inc
        include i386\driver.inc
        include i386\egavga.inc

        .list

        .code

cProc vInitRegs,4,<             \
        uses esi edi ebx,       \
        ppdev: ptr PDEV         >

        mov     esi,ppdev

;       Initialize sequencer to its defaults (all planes enabled, index
;       pointing to Map Mask).

        mov     dx,VGA_BASE + SEQ_ADDR
        mov     ax,(MM_ALL shl 8) + SEQ_MAP_MASK
        out     dx,ax

;       Initialize graphics controller to its defaults (set/reset disabled for
;       all planes, no rotation & ALU function == replace, write mode 0 & read
;       mode 0, color compare ignoring all planes (read mode 1 reads always
;       return 0ffh, handy for ANDing), and the bit mask == 0ffh, gating all
;       bytes from the CPU.

        mov     dl,GRAF_ADDR
        mov     ax,(0 shl 8) + GRAF_ENAB_SR
        out     dx,ax

        mov     ax,(DR_SET shl 8) + GRAF_DATA_ROT
        out     dx,ax

;       Default to read mode 0, write mode 0:

        mov     edx,VGA_BASE + GRAF_ADDR
        mov     ah,byte ptr [esi].pdev_ulrm0_wmX[0]
        mov     al,GRAF_MODE
        out     dx,ax                   ;write mode 0, read mode 0

        mov     ax,(0 shl 8) + GRAF_CDC
        out     dx,ax

        mov     ax,(0FFh shl 8) + GRAF_BIT_MASK
        out     dx,ax

        cRet    vInitRegs


endProc vInitRegs

        end

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\vga\mini\vesa.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    vesa.c

Abstract:

    This module implements VESA support.

Author:

    Erick Smith (ericks) Sep. 2000

Environment:

    kernel mode only

Revision History:

--*/

#include "dderror.h"
#include "devioctl.h"
#include "miniport.h"

#include "ntddvdeo.h"
#include "video.h"
#include "vga.h"
#include "vesa.h"

#if defined(ALLOC_PRAGMA)
#pragma alloc_text(PAGE,ValidateVbeInfo)
#pragma alloc_text(PAGE,InitializeModeTable)
#pragma alloc_text(PAGE,UpdateRegistry)
#pragma alloc_text(PAGE,VgaSaveHardwareState)
#pragma alloc_text(PAGE,VesaSaveHardwareState)
#pragma alloc_text(PAGE,GetVideoMemoryBaseAddress)
#pragma alloc_text(PAGE,RaiseToPower2)
#pragma alloc_text(PAGE,RaiseToPower2Ulong)
#pragma alloc_text(PAGE,IsPower2)
#pragma alloc_text(PAGE,VBESetMode)
#pragma alloc_text(PAGE,VBEGetMode)
#pragma alloc_text(PAGE,VBEGetModeInfo)
#pragma alloc_text(PAGE,VBESaveState)
#pragma alloc_text(PAGE,VBERestoreState)
#pragma alloc_text(PAGE,VBESetDisplayWindow)
#pragma alloc_text(PAGE,VBEGetDisplayWindow)
#pragma alloc_text(PAGE,VBEGetScanLineLength)
#pragma alloc_text(PAGE,IsSavedModeVesa)
#pragma alloc_text(PAGE,VesaSaveHardwareState)
#pragma alloc_text(PAGE,VesaRestoreHardwareState)
#pragma alloc_text(PAGE,SaveFrameBuffer)
#pragma alloc_text(PAGE,RestoreFrameBuffer)
#endif

USHORT
RaiseToPower2(
    USHORT x
    )

{
    USHORT Mask = x;

    if (Mask & (Mask - 1)) {

        Mask = 1;

        while (Mask < x && Mask != 0) {
            Mask <<= 1;
        }
    }

    return Mask;
}

ULONG
RaiseToPower2Ulong(
    ULONG x
    )

{
    ULONG Mask = x;

    if (Mask & (Mask - 1)) {

        Mask = 1;

        while (Mask < x && Mask != 0) {
            Mask <<= 1;
        }
    }

    return Mask;
}

BOOLEAN
IsPower2(
    USHORT x
    )

{
    return( !(x & (x- 1)) );
}

VOID
UpdateRegistry(
    PHW_DEVICE_EXTENSION hwDeviceExtension,
    PWSTR ValueName,
    PUCHAR Value
    )

/*++

--*/

{
    ULONG Len = (strlen(Value) + 1) * 2;
    PWSTR WideString;

    WideString = VideoPortAllocatePool(hwDeviceExtension,
                                       VpPagedPool,
                                       Len,
                                       ' agV');

    if (WideString) {

        PWSTR ptr = WideString;

        while(*Value) {
            *ptr++ = (WCHAR) *Value++;
        }
        *ptr = 0;

        VideoPortSetRegistryParameters(hwDeviceExtension,
                                       ValueName,
                                       WideString,
                                       Len);

        VideoPortFreePool(hwDeviceExtension, WideString);
    }
}

BOOLEAN
IsVesaBiosOk(
    PVIDEO_PORT_INT10_INTERFACE pInt10,
    USHORT OemSoftwareRev,
    PUCHAR OemVendorName,
    PUCHAR OemProductName,
    PUCHAR OemProductRev
    )

{

    VideoDebugPrint((1, "OemSoftwareRev = %d\n",   OemSoftwareRev));
    VideoDebugPrint((1, "OemVendorName  = '%s'\n", OemVendorName));
    VideoDebugPrint((1, "OemProductName = '%s'\n", OemProductName));
    VideoDebugPrint((1, "OemProductRev  = '%s'\n", OemProductRev));

    //
    // The ATI ArtX boxes currently have a VESA Bios bug where
    // they indicate they support linear mode access when
    // they don't.  Fail these boards.
    //

    if ((strcmp(OemProductName, "ATI S1-370TL") == 0) ||
        (strcmp(OemProductName, "ArtX I") == 0)) {

        return FALSE;
    }

    //
    // Several 3dfx boards have buggy vesa bioses.  The mode set
    // works, but the display is corrupted.
    //

    if ((strcmp(OemProductName, "Voodoo4 4500 ") == 0) ||
        (strcmp(OemProductName, "Voodoo3 3000 LC ") == 0) ||
        (strcmp(OemProductName, "Voodoo3 2000 LC ") == 0) || 
        (strcmp(OemProductName, "3Dfx Banshee") == 0)) {

        return FALSE;
    }

    //
    // Matrox G100 boards with rev 1.05 bioses can't set vesa modes.
    // We hang in the bios.
    //

    if ((strcmp(OemProductName, "MGA-G100") == 0) &&
        (OemSoftwareRev == 0x105)) {

        //
        // We must also disable 800x600 16 color mode for this
        // device.  This makes the assumption that the mode we
        // are deleting is the last mode in our table.
        //

        NumVideoModes--;
        return FALSE;
    }

    //
    // We have seen at least on SIS 5597 part which returns a bad
    // linear address.  Lets disable these parts.
    //

    if (strcmp(OemProductName, "SiS 5597") == 0) {

        return FALSE;
    }

    //
    // We found a bad nVidia GeForce MX part.  It hangs in the bios
    // on boot.
    //

    if ((strcmp(OemVendorName, "NVidia Corporation") == 0) &&
        (strcmp(OemProductName, "NV11 (GeForce2) Board") == 0) &&
        (strcmp(OemProductRev, "Chip Rev B2") == 0) &&
        (OemSoftwareRev == 0x311)) {

        //
        // This bios "may" be buggy, but in an effort to not kill
        // vesa support on all GeForce MX boards, lets also look at
        // the version string embedded in the bios.
        //
        // We know the bad bios's have the following string at location
        // c000:0159:
        //
        // "Version 3.11.01.24N16"
        //
        // Lets read from this location and try to match on this string
        //
        // NOTE: This call requires that the VDM memory be allocated
        // with Int10AllocateBuffer.  Since our calling function has
        // this allocated, we are ok.
        //

        UCHAR Version[22];
        if(pInt10->Int10ReadMemory(pInt10->Context,
                                   (USHORT)0xC000,
                                   (USHORT)0x0159,
                                   Version,
                                   21) != NO_ERROR) {
             return FALSE;
        }

        Version[21] = 0;

        if (strcmp(Version, "Version 3.11.01.24N16") == 0) {

            return FALSE;
        }
    }

    return TRUE;
}

BOOLEAN
ValidateVbeInfo(
    PHW_DEVICE_EXTENSION hwDeviceExtension,
    PVGA_INFO_BLOCK InfoBlock
    )

/*++

Notes:

    This routine makes the assumption that the InfoBlock is still
    valid in the VDM transfer area.

--*/

{
    PVIDEO_PORT_INT10_INTERFACE pInt10;
    BOOLEAN UseVesa = FALSE;

    pInt10 = &hwDeviceExtension->Int10;

    if (InfoBlock->VesaSignature == 'ASEV') {

        PUCHAR OemString;
        UCHAR OemStringBuffer[80];
        UCHAR OemVendorName[80];
        UCHAR OemProductName[80];
        UCHAR OemProductRev[80];
        ULONG MemorySize;

        //
        // Capture OEM String
        //

        if(pInt10->Int10ReadMemory(pInt10->Context,
                                   (USHORT)SEG(InfoBlock->OemStringPtr),
                                   (USHORT)OFF(InfoBlock->OemStringPtr),
                                    OemStringBuffer,
                                    80) != NO_ERROR) {
            goto FallOut;
        }

        OemStringBuffer[79] = 0;
        OemString = OemStringBuffer;

        VideoDebugPrint((1, "*********************************************\n"));
        VideoDebugPrint((1, "  VBE Signature:      VESA\n"));
        VideoDebugPrint((1, "  VBE Version:        %d.%02d\n",
                            InfoBlock->VbeVersion >> 8,
                            InfoBlock->VbeVersion & 0xff));
        VideoDebugPrint((1, "  OEM String:         %s\n",
                             OemString));

        if (InfoBlock->TotalMemory < 16) {

            //
            // If less than 1 meg, display in KB
            //

            VideoDebugPrint((1, "  Total Memory:       %dKB\n",
                                InfoBlock->TotalMemory * 64));

        } else {

            //
            // Else display in MB
            //

            VideoDebugPrint((1, "  Total Memory:       %dMB\n",
                                InfoBlock->TotalMemory / 16));
        }

        if (InfoBlock->VbeVersion >= 0x102) {

            if(pInt10->Int10ReadMemory(pInt10->Context,
                                    (USHORT)SEG(InfoBlock->OemVendorNamePtr),
                                    (USHORT)OFF(InfoBlock->OemVendorNamePtr),
                                    OemVendorName,
                                    80) != NO_ERROR){
                goto FallOut;
            }
            
            if(pInt10->Int10ReadMemory(pInt10->Context,
                                    (USHORT)SEG(InfoBlock->OemProductNamePtr),
                                    (USHORT)OFF(InfoBlock->OemProductNamePtr),
                                    OemProductName,
                                    80) != NO_ERROR){
                goto FallOut;
            }
            

            if(pInt10->Int10ReadMemory(pInt10->Context,
                                    (USHORT)SEG(InfoBlock->OemProductRevPtr),
                                    (USHORT)OFF(InfoBlock->OemProductRevPtr),
                                    OemProductRev,
                                    80) != NO_ERROR){
                goto FallOut;
            }
            

            OemVendorName[79] = 0;
            OemProductName[79] = 0;
            OemProductRev[79] = 0;

            VideoDebugPrint((1, "  OEM Software Rev:   %d.%02d\n",
                                InfoBlock->OemSoftwareRev >> 8,
                                InfoBlock->OemSoftwareRev & 0xff));
            VideoDebugPrint((1, "  OEM Vendor Name:    %s\n", OemVendorName));
            VideoDebugPrint((1, "  OEM Product Name:   %s\n", OemProductName));
            VideoDebugPrint((1, "  OEM Product Rev:    %s\n", OemProductRev));

            UseVesa = IsVesaBiosOk(pInt10,
                                   InfoBlock->OemSoftwareRev,
                                   OemVendorName,
                                   OemProductName,
                                   OemProductRev);

        }

        VideoDebugPrint((1, "*********************************************\n"));

#if defined(PLUG_AND_PLAY)

        //
        // It would be nice if we could dump the following info into the
        // registry.  But as the GDI code currently stands, if we add
        // ChipType or AdapterString info into the registry, we lose
        // fullscreen support.  This has to do with the way GDI currently
        // determines the fullscreen device.
        //
        // For now, lets just not add this registry info.
        //

        UpdateRegistry(hwDeviceExtension,
                       L"HardwareInformation.ChipType",
                       OemString);

        //
        // Adapter String MUST be VGA.  Without it, the system won't
        // recognize this driver as the VGA driver.
        //

        UpdateRegistry(hwDeviceExtension,
                       L"HardwareInformation.AdapterString",
                       "VGA");

        UpdateRegistry(hwDeviceExtension,
                       L"HardwareInformation.DacType",
                       (InfoBlock->Capabilities & VBE_CAP_DAC_WIDTH_8BPP)
                           ? "8 bit" : "6 bit");

        UpdateRegistry(hwDeviceExtension,
                       L"HardwareInformation.BiosString",
                       OemProductRev);

        //
        // Store memory size in registry
        //

        MemorySize = InfoBlock->TotalMemory << 16;

        VideoPortSetRegistryParameters(hwDeviceExtension,
                                       L"HardwareInformation.MemorySize",
                                       &MemorySize,
                                       sizeof(ULONG));
#endif

    } else {

        VideoDebugPrint((0, "Invalid VBE Info Block.\n"));
    }

FallOut:

    return UseVesa;
}

VOID
InitializeModeTable(
    PVOID HwDeviceExtension
    )

/*++

Routine Description:

    This routine does one time initialization of the device.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's adapter information.

Return Value:

    None.

--*/

{
    PHW_DEVICE_EXTENSION hwDeviceExtension = HwDeviceExtension;
    INT10_BIOS_ARGUMENTS BiosArguments;
    PVGA_INFO_BLOCK InfoBlock;
    PMODE_INFO_BLOCK ModeBlock;
    PUSHORT ModeTable;
    PUSHORT ModePtr;
    ULONG NumVesaModes;
    PVIDEOMODE VideoModePtr;
    LONG TotalMemory;
    ULONG VideoMemoryRequired;
    USHORT VbeVersion;
    PULONG Memory;
    ULONG AdditionalModes = 0;

    USHORT VdmSeg, VdmOff;
    VP_STATUS Status;
    PVIDEO_PORT_INT10_INTERFACE pInt10;
    ULONG Length = 0x1000;

    BOOLEAN LinearModeSupported;
    BOOLEAN ModeValid;

    VgaModeList = ModesVGA;

#if !defined(PLUG_AND_PLAY)

    //
    // To avoid problems on high-end servers with bus-relative resources 
    // being reported by the VESA BIOS that we will not be able to translate 
    // without PnP support, use the specially defined boot flag NOVESA to 
    // disable anything more than legacy VGA.
    // Zero the key int10 fields just as if VESA support was unavailable.
    //
    if(VideoPortIsNoVesa()){

        hwDeviceExtension->Int10.Size = 0;
        hwDeviceExtension->Int10.Version = 0;
        return;
    }
#endif
    
    
    hwDeviceExtension->Int10.Size = sizeof(VIDEO_PORT_INT10_INTERFACE);
    hwDeviceExtension->Int10.Version = 1;

    Status = VideoPortQueryServices(hwDeviceExtension,
                                    VideoPortServicesInt10,
                                    (PINTERFACE)&hwDeviceExtension->Int10);
    if(Status != NO_ERROR){

        // 	
        // Set these fields to zero so that later we know the int10 
        // interface is not available
        //

        hwDeviceExtension->Int10.Size = 0;
        hwDeviceExtension->Int10.Version = 0;
        return;
    }

    pInt10 = &hwDeviceExtension->Int10;

    pInt10->InterfaceReference(pInt10->Context);

    //
    // Get a chunk of memory in VDM area to use for buffers.
    //

    Status = pInt10->Int10AllocateBuffer(pInt10->Context,
                                         &VdmSeg,
                                         &VdmOff,
                                         &Length);

    if (Status != NO_ERROR) {
        return;
    }

    //
    // Allocate Memory
    //

    InfoBlock = VideoPortAllocatePool(hwDeviceExtension,
                                      VpPagedPool,
                                      sizeof(VGA_INFO_BLOCK) +
                                      sizeof(MODE_INFO_BLOCK) +
                                      256 +
                                      2, // space for a 0xffff terminator
                                      ' agV');

    if (InfoBlock) {

        ModeBlock = (PMODE_INFO_BLOCK)((ULONG_PTR)InfoBlock + sizeof(VGA_INFO_BLOCK));
        ModeTable = (PUSHORT)((ULONG_PTR)ModeBlock + sizeof(MODE_INFO_BLOCK));

        ModeTable[128] = 0xffff;  // make sure we have a mode terminator

        //
        // Get VESA mode information
        //

        InfoBlock->VesaSignature = '2EBV';

        if(pInt10->Int10WriteMemory(pInt10->Context,
                                    VdmSeg,
                                    VdmOff,
                                    InfoBlock,
                                    sizeof(VGA_INFO_BLOCK)) != NO_ERROR){
            goto FallOut;
        }

        //
        // Get SuperVGA support info
        //

        BiosArguments.Eax = 0x4f00;
        BiosArguments.Edi = VdmOff;
        BiosArguments.SegEs = VdmSeg;

        if(pInt10->Int10CallBios(pInt10->Context, 
                                 &BiosArguments) != NO_ERROR ||

           !VESA_SUCCESS(BiosArguments.Eax)) {

            goto FallOut;
        }

        if(pInt10->Int10ReadMemory(pInt10->Context,
                                   VdmSeg,
                                   VdmOff,
                                   InfoBlock,
                                   sizeof(VGA_INFO_BLOCK)) != NO_ERROR) {
            goto FallOut;
        }

        TotalMemory = InfoBlock->TotalMemory * 0x10000;
        VbeVersion = InfoBlock->VbeVersion;

        //
        // NOTE: We must call ValidateVbeInfo while the info block
        // is still in the transfer area.
        //

        if (ValidateVbeInfo(hwDeviceExtension, InfoBlock)) {

            //
            // Capture the list of mode numbers
            //

            if(pInt10->Int10ReadMemory(pInt10->Context,
                                    (USHORT)(InfoBlock->VideoModePtr >> 16),
                                    (USHORT)(InfoBlock->VideoModePtr & 0xffff),
                                    ModeTable,
                                    256) != NO_ERROR) {
                goto FallOut;
            }

            {
                BOOLEAN Mode800x600x4Supported = FALSE;

                //
                // Count the number of VESA modes, and allocate memory for the
                // mode list.  The mode list is terminated by a -1.
                //

                ModePtr = ModeTable;
                NumVesaModes = 0;

                while (*ModePtr != 0xffff) {

                    if((*ModePtr & 0x1ff) == 0x102 || 
	               (*ModePtr & 0x1ff) == 0x6a ) {

                        Mode800x600x4Supported = TRUE;
                    }

                    NumVesaModes++;
                    ModePtr++;
                }

                //
                // We disable 800x600 16 color mode unless this mode
                // is in the mode list. This makes the assumption that
                // the 800x600x16 mode is the last mode in our table.
                //

                if(!Mode800x600x4Supported) {
	
                    NumVideoModes--;
                }
            }

            if (NumVesaModes == 128) {

                //
                // Something is wrong.  We hit our hard coded terminator.
                // Don't try to use vesa modes.
                //

                goto FallOut;

            }

            VgaModeList = VideoPortAllocatePool(hwDeviceExtension,
                                                VpPagedPool,
                                                (NumVesaModes + NumVideoModes) *
                                                    sizeof(VIDEOMODE),
                                                ' agV');

            if (VgaModeList == NULL) {

                VideoDebugPrint((0, "failed to allocate %d bytes.\n",
                                 (NumVesaModes + NumVideoModes) * sizeof(VIDEOMODE)));

                VgaModeList = ModesVGA;

                //
                // Perform clean up.
                //

                VideoPortFreePool(hwDeviceExtension, InfoBlock);

                pInt10->Int10FreeBuffer(pInt10->Context,
                                        VdmSeg,
                                        VdmOff);
                return;
            }

            //
            // Copy the existing constant VGA modes into our mode list table.
            //

            memmove(VgaModeList, ModesVGA, sizeof(VIDEOMODE) * NumVideoModes);

            //
            // Now populate the rest of the table based on the VESA mode
            // table.
            //

            VideoModePtr = VgaModeList + NumVideoModes;
            ModePtr = ModeTable;

            while (NumVesaModes--) {

                ModeValid = FALSE;

                //
                // Get info about the VESA mode.
                //

                BiosArguments.Eax = 0x4f01;
                BiosArguments.Ecx = *ModePtr;
                BiosArguments.Edi = VdmOff;
                BiosArguments.SegEs = VdmSeg;

                Status = pInt10->Int10CallBios(pInt10->Context, 
                                               &BiosArguments);
                if(Status == NO_ERROR &&
                   VESA_SUCCESS(BiosArguments.Eax) &&
                   pInt10->Int10ReadMemory(pInt10->Context,
                                           VdmSeg,
                                           VdmOff,
                                           ModeBlock,
                                           sizeof(MODE_INFO_BLOCK)) == NO_ERROR){

                    //
                    // Make sure that this is a graphics mode, and
                    // that it is supported by this hardware.
                    //

                    if ((ModeBlock->ModeAttributes & 0x11) == 0x11) {

                        if ((VbeVersion >= 0x200) &&
                            (ModeBlock->PhysBasePtr) &&
                            (ModeBlock->ModeAttributes & 0x80)) {

                            LinearModeSupported = TRUE;

                        } else {

                            //
                            // Make sure banked modes are supported
                            //

                            ASSERT((ModeBlock->ModeAttributes & 0x40) == 0);
                            LinearModeSupported = FALSE;
                        }

                        //
                        // Only include this mode if the following are true:
                        //
                        //   1. The mode is an 8bpp or higher mode
                        //   2. The resolution is 640x480 or greater
                        //

                        if ((ModeBlock->XResolution >= 640) &&
                            (ModeBlock->YResolution >= 480) &&
                            (ModeBlock->NumberOfPlanes != 0) &&
                            (ModeBlock->BitsPerPixel >= 8)) {

                            //
                            // Fill in the video mode structure.
                            //

                            memset(VideoModePtr, 0, sizeof(VIDEOMODE));

                            if (ModeBlock->ModeAttributes & 0x08) {
                                VideoModePtr->fbType |= VIDEO_MODE_COLOR;
                            }

                            if (ModeBlock->ModeAttributes & 0x10) {
                                VideoModePtr->fbType |= VIDEO_MODE_GRAPHICS;
                            }

                            VideoModePtr->numPlanes = ModeBlock->NumberOfPlanes;
                            VideoModePtr->bitsPerPlane = ModeBlock->BitsPerPixel /
                                                             ModeBlock->NumberOfPlanes;

                            if (VideoModePtr->bitsPerPlane == 16) {

                                //
                                // Check to see if this is really a 15 bpp mode
                                //

                                if (ModeBlock->GreenMaskSize == 5) {
                                    VideoModePtr->bitsPerPlane = 15;
                                }
                            }

                            if (ModeBlock->XCharSize) {
                                VideoModePtr->col = ModeBlock->XResolution / ModeBlock->XCharSize;
                            } else {
                                VideoModePtr->col = 80;
                            }

                            if (ModeBlock->YCharSize) {
                                VideoModePtr->row = ModeBlock->YResolution / ModeBlock->YCharSize;
                            } else {
                                VideoModePtr->row = 25;
                            }

                            VideoModePtr->hres = ModeBlock->XResolution;
                            VideoModePtr->vres = ModeBlock->YResolution;
                            VideoModePtr->frequency = 1;
                            VideoModePtr->Int10ModeNumber = (((ULONG)*ModePtr) << 16) | 0x00004f02;
                            VideoModePtr->Granularity = ModeBlock->WinGranularity << 10;
                            VideoModePtr->NonVgaHardware = (ModeBlock->ModeAttributes & 0x20) ? TRUE : FALSE;


                            if (LinearModeSupported) {

                                if ((VbeVersion >= 0x300) && ModeBlock->LinBytesPerScanLine) {
                                    VideoModePtr->wbytes = ModeBlock->LinBytesPerScanLine;
                                } else {
                                    VideoModePtr->wbytes = ModeBlock->BytesPerScanLine;
                                }

                                //
                                // We first try to round up VideoMemoryRequired
                                // to power of 2 so that we'll have a better 
                                // chance to get it mapped as write combined 
                                // on systems where MTRR is the only mechanism
                                // for such mappings. If the rounded up value
                                // is larger than the size of on-board memory
                                // we'll at least round it up to page boundary
                                //

                                VideoMemoryRequired = RaiseToPower2Ulong(VideoModePtr->wbytes * VideoModePtr->vres);

                                if(VideoMemoryRequired > (ULONG)TotalMemory) {
                                    VideoMemoryRequired = 
                                               (VideoModePtr->wbytes * VideoModePtr->vres + 0x1000 - 1) & ~(0x1000 - 1);
                                }
    
                                VideoModePtr->sbytes = VideoMemoryRequired;
                                VideoModePtr->PixelsPerScan = VideoModePtr->hres;
                                VideoModePtr->banktype = NoBanking;
                                VideoModePtr->Int10ModeNumber |= 0x40000000;
                                VideoModePtr->MemoryBase = ModeBlock->PhysBasePtr;
                                VideoModePtr->MemoryLength = VideoMemoryRequired;
                                VideoModePtr->FrameOffset = 0;
                                VideoModePtr->FrameLength = VideoMemoryRequired;
                                VideoModePtr->fbType |= VIDEO_MODE_LINEAR;

                            } else {

                                VideoModePtr->wbytes = RaiseToPower2(ModeBlock->BytesPerScanLine);

                                //
                                // Round up to bank boundary if possible.
                                //
 
                                VideoMemoryRequired = 
                                     (VideoModePtr->wbytes * VideoModePtr->vres + 0x10000 - 1) & ~(0x10000 - 1);

                                if(VideoMemoryRequired > (ULONG)TotalMemory) {

                                    //
                                    // Round up to page boundary.
                                    //

                                    VideoMemoryRequired = 
                                         (VideoModePtr->wbytes * VideoModePtr->vres + 0x1000 - 1) & ~(0x1000 - 1);
                                }

                                VideoModePtr->sbytes = VideoMemoryRequired;
                                VideoModePtr->PixelsPerScan = RaiseToPower2(VideoModePtr->hres);
                                VideoModePtr->banktype = VideoBanked1RW;
                                VideoModePtr->MemoryBase = 0xa0000;
                                VideoModePtr->MemoryLength = 0x10000;
                                VideoModePtr->FrameOffset = 0;
                                VideoModePtr->FrameLength = 0x10000;
                                VideoModePtr->fbType |= VIDEO_MODE_BANKED;

                            }

                            if (ModeBlock->ModeAttributes & 0x40) {
                                VideoModePtr->banktype = NormalBanking;
                            }

                            //
                            // Make sure there is enough memory for the mode
                            //

                            if ((VideoModePtr->wbytes * VideoModePtr->vres) <= TotalMemory) {
                                ModeValid = TRUE;
                            } 
                        }
                    }
                }

                if (ModeValid) {

                    VideoDebugPrint((1, "Supported: %dx%dx%dbpp\n",
                                        VideoModePtr->hres,
                                        VideoModePtr->vres,
                                        VideoModePtr->bitsPerPlane));

                    VideoModePtr++;
                    AdditionalModes++;

                } else {

                    VideoDebugPrint((1, "Rejecting: %dx%dx%dbpp\n",
                                        ModeBlock->XResolution,
                                        ModeBlock->YResolution,
                                        ModeBlock->BitsPerPixel));
                }

                ModePtr++;
            }

            //
            // Lets check to see if we can map the memory for one of these modes.
            // If not, don't support the extended modes.
            //
            // Note: this is a temporary hack, until I can implent the correct
            // fix.
            //

            VideoModePtr--;

            if (IS_LINEAR_MODE(VideoModePtr)) {

                PHYSICAL_ADDRESS Address;
                UCHAR inIoSpace = 0;

                Address.LowPart = VideoModePtr->MemoryBase;
                Address.HighPart = 0;

#if defined(PLUG_AND_PLAY)
                inIoSpace |= VIDEO_MEMORY_SPACE_P6CACHE;
#endif
                Memory = VideoPortGetDeviceBase(hwDeviceExtension,
                                                Address,
                                                0x1000,
                                                inIoSpace);

                if (Memory) {

                    VideoPortFreeDeviceBase(hwDeviceExtension, Memory);

                } else {

                    //
                    // We can't map the memory, so don't expose the extra modes.
                    //

                    VideoDebugPrint((0, "vga.sys: Mapping 0x%x failed\n", VideoModePtr->MemoryBase));
                    AdditionalModes = 0;
                }
            }
        }

FallOut:

        VideoPortFreePool(hwDeviceExtension, InfoBlock);
    }

    pInt10->Int10FreeBuffer(pInt10->Context,
                            VdmSeg,
                            VdmOff);

    NumVideoModes += AdditionalModes;

} 

ULONG
GetVideoMemoryBaseAddress(
    PHW_DEVICE_EXTENSION hwDeviceExtension,
    PVIDEOMODE pRequestedMode
    )

/*++

Routine Description:

    This routine get the base address of the framebuffer of a given mode

Return Value:

    Base address of framebuffer

--*/

{
    PMODE_INFO_BLOCK ModeBlock;
    ULONG Length = 0x1000;
    INT10_BIOS_ARGUMENTS BiosArguments;
    PVIDEO_PORT_INT10_INTERFACE pInt10;
    ULONG RetValue = 0;
    USHORT VdmSeg;
    USHORT VdmOff;

    //
    // If this is not a vesa mode, just return the saved base address
    //

    if (pRequestedMode->fbType & VIDEO_MODE_BANKED) {

        return 0;
    }

    pInt10 = &hwDeviceExtension->Int10;

    if(!(pInt10->Size)) {
  
        //
        // This structure should be initialized in VgaInitialize
        // If this function get called before VgaInitialize, just return 0;
        //

        return 0;
    }

    ModeBlock = VideoPortAllocatePool(hwDeviceExtension,
                                      VpPagedPool,
                                      sizeof(MODE_INFO_BLOCK),
                                      ' agV');

    if(!ModeBlock) {

        return 0;
    }

    if (pInt10->Int10AllocateBuffer(pInt10->Context,
                                    &VdmSeg,
                                    &VdmOff,
                                    &Length) != NO_ERROR) {

        VideoPortFreePool(hwDeviceExtension, ModeBlock);
        return 0;
    }

    //
    // Get info about the VESA mode.
    //

    BiosArguments.Eax = 0x4f01;
    BiosArguments.Ecx = pRequestedMode->Int10ModeNumber >> 16;
    BiosArguments.Edi = VdmOff;
    BiosArguments.SegEs = VdmSeg;

    if(pInt10->Int10CallBios(pInt10->Context, 
                             &BiosArguments) == NO_ERROR && 

       VESA_SUCCESS(BiosArguments.Eax)) {

        //
        // Copy the mode information out of the csrss process
        //

        if(pInt10->Int10ReadMemory(pInt10->Context,
                                   VdmSeg,
                                   VdmOff,
                                    ModeBlock,
                                    sizeof(MODE_INFO_BLOCK)) == NO_ERROR){

             RetValue = ModeBlock->PhysBasePtr;
        }

    } 

    pInt10->Int10FreeBuffer(pInt10->Context, VdmSeg, VdmOff);
    VideoPortFreePool(hwDeviceExtension, ModeBlock);
    return( RetValue );

}

VP_STATUS
VBEGetModeInfo(
    PHW_DEVICE_EXTENSION hwDeviceExtension,
    USHORT ModeNumber,
    PMODE_INFO_BLOCK ModeInfoBlock
    )
{
    INT10_BIOS_ARGUMENTS Int10BiosArguments;
    PVIDEO_PORT_INT10_INTERFACE pInt10;
    VP_STATUS status = ERROR_INVALID_PARAMETER;
    USHORT VdmSeg;
    USHORT VdmOff;
    ULONG  Length = 0x1000;

    pInt10 = &hwDeviceExtension->Int10;

    if(pInt10->Size &&
       pInt10->Int10AllocateBuffer(pInt10->Context,
                                    &VdmSeg,
                                    &VdmOff,
                                    &Length) == NO_ERROR) {

        Int10BiosArguments.Eax = VBE_GET_MODE_INFO;
        Int10BiosArguments.Ecx = ModeNumber;
        Int10BiosArguments.Edi = VdmOff;
        Int10BiosArguments.SegEs = VdmSeg;

        status = pInt10->Int10CallBios(pInt10->Context, &Int10BiosArguments);

        if (status == NO_ERROR &&
            VESA_SUCCESS(Int10BiosArguments.Eax)) {

            //
            // Copy the mode information out of the csrss process
            //

            status = pInt10->Int10ReadMemory(pInt10->Context,
                                             VdmSeg,
                                             VdmOff,
                                             ModeInfoBlock,
                                             sizeof(MODE_INFO_BLOCK));

        }

        pInt10->Int10FreeBuffer(pInt10->Context, VdmSeg, VdmOff);
    }

    return status;
}

VP_STATUS
VBESetMode(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    USHORT VesaModeNumber
    )
{
    VIDEO_X86_BIOS_ARGUMENTS biosArguments;
    VP_STATUS status;

    biosArguments.Eax = VBE_SET_MODE;
    biosArguments.Ebx = VesaModeNumber;

    status = VideoPortInt10(HwDeviceExtension, &biosArguments);

    if ((status == NO_ERROR) && 
        VESA_SUCCESS(biosArguments.Eax)) {

        return NO_ERROR;
    }

    return ERROR_INVALID_PARAMETER;
}

USHORT
VBEGetMode(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    )
{
    VIDEO_X86_BIOS_ARGUMENTS biosArguments;
    VP_STATUS status;

    biosArguments.Eax = VBE_GET_MODE;

    status = VideoPortInt10(HwDeviceExtension, &biosArguments);

    if ((status == NO_ERROR) && 
        (VESA_SUCCESS(biosArguments.Eax))) {

        return (USHORT)(biosArguments.Ebx & 0x0000FFFF) ;

    } else {

        return 0;
    }
}

ULONG
VBESaveState(
    PHW_DEVICE_EXTENSION hwDeviceExtension,
    PCHAR StateBuffer
    )
{
    INT10_BIOS_ARGUMENTS Int10BiosArguments;
    PVIDEO_PORT_INT10_INTERFACE pInt10;
    VP_STATUS status;
    ULONG Size;
    USHORT VdmSeg;
    USHORT VdmOff;
    ULONG  Length = 0x1000;

    pInt10 = &hwDeviceExtension->Int10;

    if(!(pInt10->Size)) {

        return 0;
    }

    Int10BiosArguments.Eax = VBE_SAVE_RESTORE_STATE;
    Int10BiosArguments.Edx = 0x0;

    //
    // Save all the state
    //

    Int10BiosArguments.Ecx = 0x0F;

    status = pInt10->Int10CallBios(pInt10->Context, &Int10BiosArguments);

    if (status != NO_ERROR ||
        !VESA_SUCCESS(Int10BiosArguments.Eax)) {

        return 0;
    }

    Size = (Int10BiosArguments.Ebx & 0xffff) << 6 ;

    //
    // if StateBuffer is NULL, the caller is only want to know the size
    // of the buffer needed to store the state
    //

    if (StateBuffer == NULL) {
        return Size;
    }

    if (pInt10->Int10AllocateBuffer(pInt10->Context,
                                    &VdmSeg,
                                    &VdmOff,
                                    &Length) == NO_ERROR) {

        Int10BiosArguments.Eax = VBE_SAVE_RESTORE_STATE;
        Int10BiosArguments.Edx = 0x1;
        Int10BiosArguments.Ecx = 0x0F;
        Int10BiosArguments.Ebx = VdmOff;
        Int10BiosArguments.SegEs = VdmSeg;

        status = pInt10->Int10CallBios(pInt10->Context, &Int10BiosArguments);

        if (status == NO_ERROR &&
            VESA_SUCCESS(Int10BiosArguments.Eax)) {

            //
            // Copy the state data of the csrss process
            //

            status = pInt10->Int10ReadMemory(pInt10->Context,
                                             VdmSeg,
                                             VdmOff,
                                             StateBuffer,
                                             Size);
            if (status != NO_ERROR) {

                Size = 0;
            }
        }

        pInt10->Int10FreeBuffer(pInt10->Context, VdmSeg, VdmOff);

    } else {

        Size = 0;
    }

    return Size;
}

VP_STATUS
VBERestoreState(
    PHW_DEVICE_EXTENSION hwDeviceExtension,
    PCHAR StateBuffer,
    ULONG Size
    )
{
    INT10_BIOS_ARGUMENTS Int10BiosArguments;
    PVIDEO_PORT_INT10_INTERFACE pInt10;
    VP_STATUS status = ERROR_INVALID_PARAMETER;
    USHORT VdmSeg;
    USHORT VdmOff;
    ULONG  Length = 0x1000;

    pInt10 = &hwDeviceExtension->Int10;

    if(!(pInt10->Size)) {

        return 0;
    }

    if (pInt10->Int10AllocateBuffer(pInt10->Context,
                                    &VdmSeg,
                                    &VdmOff,
                                    &Length) == NO_ERROR) {

        //
        // Copy the state data to the csrss process
        //

        status = pInt10->Int10WriteMemory(pInt10->Context,
                                          VdmSeg,
                                          VdmOff,
                                          StateBuffer,
                                          Size);

        if (status == NO_ERROR) {

            Int10BiosArguments.Eax = VBE_SAVE_RESTORE_STATE;
            Int10BiosArguments.Edx = 0x2;
            Int10BiosArguments.Ecx = 0x0f;
            Int10BiosArguments.Ebx = VdmOff;
            Int10BiosArguments.SegEs = VdmSeg;

            status = pInt10->Int10CallBios(pInt10->Context, &Int10BiosArguments);

            if (status != NO_ERROR ||
                !VESA_SUCCESS(Int10BiosArguments.Eax)) {

                status = ERROR_INVALID_PARAMETER;
            }
        }

        pInt10->Int10FreeBuffer(pInt10->Context, VdmSeg, VdmOff);
    }

    return status;
}

VP_STATUS
VBESetDisplayWindow(
    PHW_DEVICE_EXTENSION hwDeviceExtension,
    UCHAR WindowSelect,
    USHORT WindowNumber
    )

/*++

Routine Description:

    This routine set the position of the specified window in the
    frame buffer memory

Arguments:

    HwDeviceExtension  
        Pointer to the miniport driver's adapter information.

    WindowSelect
        0 for Window A and 1 for Window B

    WindowNumber
        Window number in video memory in window granularity units

Return Value:

    VP_STATUS

--*/

{
    VIDEO_X86_BIOS_ARGUMENTS biosArguments;
    VP_STATUS status;

    biosArguments.Eax = VBE_WINDOW_CONTROL;
    biosArguments.Ebx = WindowSelect & 0x01;
    biosArguments.Edx = WindowNumber;

    status = VideoPortInt10(hwDeviceExtension, &biosArguments);

    if ((status != NO_ERROR) || 
        (!VESA_SUCCESS(biosArguments.Eax))) {

        return ERROR_INVALID_PARAMETER;
    }

    return NO_ERROR;
}

USHORT
VBEGetDisplayWindow(
    PHW_DEVICE_EXTENSION hwDeviceExtension,
    UCHAR WindowSelect
    )

/*++

Routine Description:

    This routine set the position of the specified window in the
    frame buffer memory

Arguments:

    HwDeviceExtension
        Pointer to the miniport driver's adapter information.

    WindowSelect 
        0 for Window A and 1 for Window B

Return Value:

    Window number in video memory in window granularity units

--*/

{
    VIDEO_X86_BIOS_ARGUMENTS biosArguments;
    VP_STATUS status;

    biosArguments.Eax = VBE_WINDOW_CONTROL;
    biosArguments.Ebx = (WindowSelect & 0x1) | 0x100;

    status = VideoPortInt10(hwDeviceExtension, &biosArguments);

    if ((status != NO_ERROR) || 
        (!VESA_SUCCESS(biosArguments.Eax))) {

        return 0;
    }

    return ((USHORT)(biosArguments.Edx & 0xFFFF));
}

USHORT
VBEGetScanLineLength(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    )
{
    VIDEO_X86_BIOS_ARGUMENTS biosArguments;
    VP_STATUS status;

    biosArguments.Eax = VBE_SCANLINE;
    biosArguments.Ebx = 0x1;

    status = VideoPortInt10(HwDeviceExtension, &biosArguments);

    if ((status == NO_ERROR) && 
        (VESA_SUCCESS(biosArguments.Eax))) {

        return (USHORT)(biosArguments.Ebx & 0x0000FFFF) ;

    } else {

        return 0;
    }
}

VP_STATUS
VesaSaveHardwareState(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_HARDWARE_STATE HardwareState,
    ULONG HardwareStateSize,
    USHORT ModeNumber
    )
{
    PVIDEO_HARDWARE_STATE_HEADER hardwareStateHeader;
    VP_STATUS status;
    ULONG FrameBufferSize;
    PMODE_INFO_BLOCK ModeInfoBlock;
    PVESA_INFO pVesaInfo;

    //
    // See if the buffer is big enough to hold the hardware state structure.
    // (This is only the HardwareState structure itself, not the buffer it
    // points to.)
    //

    if (HardwareStateSize < sizeof(VIDEO_HARDWARE_STATE) ) {

        return ERROR_INSUFFICIENT_BUFFER;

    }


    hardwareStateHeader = 
            (PVIDEO_HARDWARE_STATE_HEADER) HardwareState->StateHeader;

    //
    // Zero out the structure
    //

    VideoPortZeroMemory((PVOID) hardwareStateHeader, 
                         sizeof(VIDEO_HARDWARE_STATE_HEADER));

    //
    // Set the Header field
    //

    hardwareStateHeader->Length = sizeof(VIDEO_HARDWARE_STATE_HEADER);
    hardwareStateHeader->VGAStateFlags |= VIDEO_STATE_UNEMULATED_VGA_STATE;

    hardwareStateHeader->VesaInfoOffset = 
                        (sizeof(VIDEO_HARDWARE_STATE_HEADER) + 7) & ~7;
 
    pVesaInfo = (PVESA_INFO)((PCHAR)hardwareStateHeader + 
                              hardwareStateHeader->VesaInfoOffset);

    //
    // Check the size needed to store hardware state
    //

    if (!(pVesaInfo->HardwareStateSize = 
                     VBESaveState(HwDeviceExtension, NULL))) {

        return ERROR_INVALID_FUNCTION;
    }

    //
    // In the case the size needed is too big just retrun failure
    // This should not happen in reality 
    // 

    if( VGA_TOTAL_STATE_SIZE < hardwareStateHeader->VesaInfoOffset + 
                               sizeof(VESA_INFO) + 
                               pVesaInfo->HardwareStateSize) {

        return ERROR_INVALID_FUNCTION;
    }

    //
    // Save hardware state
    //

    if (pVesaInfo->HardwareStateSize !=  
                   VBESaveState(HwDeviceExtension, pVesaInfo->HardwareState)) {

        return ERROR_INVALID_FUNCTION;
    }

    pVesaInfo->ModeNumber = ModeNumber;

    ModeInfoBlock = &(pVesaInfo->ModeInfoBlock);

    //
    // Retrieve mode info
    //

    if( VBEGetModeInfo(HwDeviceExtension, 
                       ModeNumber, 
                       ModeInfoBlock) != NO_ERROR) {

        return ERROR_INVALID_FUNCTION;
    }

    //
    // Save framebuffer
    //

    hardwareStateHeader->FrameBufferData = 
                         SaveFrameBuffer(HwDeviceExtension, pVesaInfo);

    if(hardwareStateHeader->FrameBufferData) {

        return NO_ERROR;

    } else {

        return ERROR_NOT_ENOUGH_MEMORY;  
    }
}

PCHAR
SaveFrameBuffer(
    PHW_DEVICE_EXTENSION hwDeviceExtension, 
    PVESA_INFO pVesaInfo
    ) 
{
    ULONG FrameBufferSize, BankSize, CopySize, LeftSize, k = 1;
    USHORT i;
    PCHAR FrameBufferData, pFrameBuffer;
    PHYSICAL_ADDRESS FBPhysicalAddress; 
    PMODE_INFO_BLOCK ModeInfoBlock;
    UCHAR inIoSpace = 0;

    ModeInfoBlock = (PMODE_INFO_BLOCK) &(pVesaInfo->ModeInfoBlock);

    //
    // We'll try to get the current value of scanline size just in case a DOS 
    // app changed it. But we stay on the value we have if the vesa function
    // is not supported or failed.
    //

    i = VBEGetScanLineLength(hwDeviceExtension);

    if(i) { 
        
        ModeInfoBlock->BytesPerScanLine = i;
    }

    // 
    // 1) Calculate Framebuffer size
    // 

    //
    // Check if it is graphics or text mode. For text mode we simply
    // assume a size of 32k
    //

    if (ModeInfoBlock->ModeAttributes & 0x10) {

        FrameBufferSize = ModeInfoBlock->BytesPerScanLine * 
                          ModeInfoBlock->YResolution;

    } else {

        FrameBufferSize = 0x8000;
    }

    pVesaInfo->FrameBufferSize = FrameBufferSize;

    // 
    // 2) Determine the location and the size to be mapped and map it
    // 

    if (!(ModeInfoBlock->ModeAttributes & 0x10)) {

        //
        // This is a text mode
        //

        FBPhysicalAddress.HighPart = 0;
        FBPhysicalAddress.LowPart = ModeInfoBlock->WinASegment << 4;

        if( FBPhysicalAddress.LowPart == 0) {

            FBPhysicalAddress.LowPart = 0xB8000;
        }

        BankSize = 0x8000;
        
    } else if (pVesaInfo->ModeNumber & 0x4000) {

        //
        // Linear framebuffer can be viewed as one large bank
        //

        FBPhysicalAddress.LowPart = ModeInfoBlock->PhysBasePtr;
        FBPhysicalAddress.HighPart = 0;
        BankSize = FrameBufferSize;

#if defined(PLUG_AND_PLAY)
        inIoSpace |= VIDEO_MEMORY_SPACE_P6CACHE;
#endif

    } else {

        //
        // This is a banked mode
        //

        FBPhysicalAddress.HighPart = 0;
        FBPhysicalAddress.LowPart = ModeInfoBlock->WinASegment << 4;

        if( FBPhysicalAddress.LowPart == 0) {

            FBPhysicalAddress.LowPart = 0xA0000;
        }

        BankSize = 1024 * ModeInfoBlock->WinSize;

        //
        // The bank size shouldn't exceed 64k. But we'd better guard 
        // the bad BIOS
        //

        if(BankSize > 0x10000 || BankSize == 0) {
            return NULL;
        }

        //
        // k will be used later to translate the window number 
        // in the unit of WinSize to the window number in the 
        // unit of WinGranularity
        //
 
        if (ModeInfoBlock->WinGranularity) {

           k = ModeInfoBlock->WinSize/ModeInfoBlock->WinGranularity;
        }
    }

    if(( pFrameBuffer = VideoPortGetDeviceBase(hwDeviceExtension, 
                                               FBPhysicalAddress,
                                               BankSize,
                                               inIoSpace)) == NULL ) {
        return NULL;
    }

    //
    // 3) Allocate memory for framebuffer data
    //
    
    if((FrameBufferData = VideoPortAllocatePool(hwDeviceExtension,
                                                VpPagedPool,
                                                FrameBufferSize,
                                                ' agV')) == NULL) {

        VideoPortFreeDeviceBase(hwDeviceExtension, pFrameBuffer);
        return NULL;
    }

    //
    // 4) Save famebuffer data
    //
    
    LeftSize = FrameBufferSize;

    for ( i = 0; LeftSize > 0; i++ ) {
    
        if (!(pVesaInfo->ModeNumber & 0x4000)) {

            // 
            // If this is a banked mode, switch to the right bank.
            // We set both Window A and B, as some VBEs have these 
            // set as separately available read and write windows.
            //

            VBESetDisplayWindow(hwDeviceExtension, 0, i * (USHORT)k);
            VBESetDisplayWindow(hwDeviceExtension, 1, i * (USHORT)k);
        }

        CopySize = (LeftSize < BankSize) ? LeftSize : BankSize;

        VideoPortMoveMemory(FrameBufferData + i * BankSize, 
                            pFrameBuffer, 
                            CopySize); 

        LeftSize -= CopySize;
    }

    // 
    // 5) Relese resource
    // 

    VideoPortFreeDeviceBase(hwDeviceExtension, pFrameBuffer);

    return FrameBufferData;
}

BOOLEAN
IsSavedModeVesa(
    PVIDEO_HARDWARE_STATE HardwareState
    )
{
    PVIDEO_HARDWARE_STATE_HEADER hardwareStateHeader;

    hardwareStateHeader = 
                (PVIDEO_HARDWARE_STATE_HEADER) HardwareState->StateHeader;

    if (hardwareStateHeader->Length == sizeof(VIDEO_HARDWARE_STATE_HEADER) &&
        hardwareStateHeader->VesaInfoOffset ) {

        return TRUE;

    } else {

        return FALSE;
    }
}


VP_STATUS
VesaRestoreHardwareState(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_HARDWARE_STATE HardwareState,
    ULONG HardwareStateSize
    )
{

    VIDEO_X86_BIOS_ARGUMENTS biosArguments;
    PVIDEO_HARDWARE_STATE_HEADER hardwareStateHeader;
    PMODE_INFO_BLOCK ModeInfoBlock;
    PVESA_INFO pVesaInfo;
    VP_STATUS status;

    hardwareStateHeader = 
           (PVIDEO_HARDWARE_STATE_HEADER) HardwareState->StateHeader;

    pVesaInfo = (PVESA_INFO)((PCHAR)hardwareStateHeader + 
                                    hardwareStateHeader->VesaInfoOffset);

    // 
    // 
    // 1) set the original mode
    // 2) restore hardware state 
    // 
    // Please note that both steps are necessary
    // 

    // 
    // We always use default CRTC value
    // 

    VBESetMode (HwDeviceExtension, pVesaInfo->ModeNumber & (~0x800));
              
    if ( VBERestoreState(HwDeviceExtension, 
                         pVesaInfo->HardwareState,
                         pVesaInfo->HardwareStateSize) != NO_ERROR ) {

        return ERROR_INVALID_FUNCTION;
    }

    ModeInfoBlock = (PMODE_INFO_BLOCK) &(pVesaInfo->ModeInfoBlock);

    //
    // Restore framebuffer data
    //

    if(RestoreFrameBuffer(HwDeviceExtension, 
                          pVesaInfo,
                          hardwareStateHeader->FrameBufferData)) {

        hardwareStateHeader->FrameBufferData = 0;
        return NO_ERROR;

    } else {

        return ERROR_INVALID_PARAMETER;
    }
}

ULONG
RestoreFrameBuffer(
    PHW_DEVICE_EXTENSION HwDeviceExtension, 
    PVESA_INFO pVesaInfo,
    PCHAR FrameBufferData
    ) 
{
    ULONG FrameBufferSize, BankSize, CopySize, LeftSize, k;
    PHYSICAL_ADDRESS FBPhysicalAddress; 
    USHORT i, WinA, WinB;
    PCHAR pFrameBuffer;
    PMODE_INFO_BLOCK ModeInfoBlock;
    UCHAR inIoSpace = 0;

    if(!FrameBufferData) {

        return 0;
    }

    ModeInfoBlock = (PMODE_INFO_BLOCK) &(pVesaInfo->ModeInfoBlock);

    // 
    // 1) Get Framebuffer size
    // 

    FrameBufferSize = pVesaInfo->FrameBufferSize;

    if (!FrameBufferSize) {

        return 0;
    }

    // 
    // 2) Determine the location and the size to be mapped and map it
    // 

    if (!(ModeInfoBlock->ModeAttributes & 0x10)) {

        //
        // This is a text mode
        //

        FBPhysicalAddress.HighPart = 0;
        FBPhysicalAddress.LowPart = ModeInfoBlock->WinASegment << 4;

        if( FBPhysicalAddress.LowPart == 0) {

            FBPhysicalAddress.LowPart = 0xB8000;
        }

        BankSize = 0x8000;
        
    } else if (pVesaInfo->ModeNumber & 0x4000) {

        //
        // Linear framebuffer can be viewed as one large bank
        //

        FBPhysicalAddress.LowPart = ModeInfoBlock->PhysBasePtr;
        FBPhysicalAddress.HighPart = 0;
        BankSize = FrameBufferSize;

#if defined(PLUG_AND_PLAY)
        inIoSpace |= VIDEO_MEMORY_SPACE_P6CACHE;
#endif

    } else {

        //
        // This is a banked mode
        //

        FBPhysicalAddress.HighPart = 0;
        FBPhysicalAddress.LowPart = ModeInfoBlock->WinASegment << 4;

        if( FBPhysicalAddress.LowPart == 0) {

            FBPhysicalAddress.LowPart = 0xA0000;
        }

        BankSize = 1024 * ModeInfoBlock->WinSize;

        //
        // The bank size shouldn't exceed 64k. But we'd better guard 
        // the bad BIOS
        //

        if(BankSize > 0x10000 || BankSize == 0) {
            return 0;
        }

        //
        // k will be used later to translate the window number 
        // in the unit of WinSize to the window number in the 
        // unit of WinGranularity
        //
 
        if (ModeInfoBlock->WinGranularity) {

            k = ModeInfoBlock->WinSize/ModeInfoBlock->WinGranularity;

        } else {

           k = 1;
        }

    }

    if((pFrameBuffer = VideoPortGetDeviceBase(HwDeviceExtension, 
                                              FBPhysicalAddress,
                                              FrameBufferSize,
                                              inIoSpace)) == NULL) {
        return 0;
    }

    // 
    // 3) Restore framebuffer data
    // 

    // 
    // For banked mode we need to save the current bank number before
    // we change it.
    // 

    if (!(pVesaInfo->ModeNumber & 0x4000)) {

        // 
        // We need to save the curren window number for banked mode
        // 

        WinA = VBEGetDisplayWindow(HwDeviceExtension, 0);
        WinB = VBEGetDisplayWindow(HwDeviceExtension, 1);

    }

    LeftSize = FrameBufferSize;

    for (i = 0; LeftSize > 0; i++) {
    
        if (!(pVesaInfo->ModeNumber & 0x4000)) {

            // 
            // This is a banked mode.
            // 
            // We need set both Window A and B, as some VBEs have these 
            // set as separately available read and write windows.
            //

            VBESetDisplayWindow(HwDeviceExtension, 0, i * (USHORT)k);
            VBESetDisplayWindow(HwDeviceExtension, 1, i * (USHORT)k);
        }

        CopySize = (LeftSize < BankSize) ? LeftSize : BankSize;

        VideoPortMoveMemory(pFrameBuffer, 
                            FrameBufferData + i * BankSize, 
                            CopySize); 

        LeftSize -= CopySize;
    }

    if (!(pVesaInfo->ModeNumber & 0x4000)) {

        // 
        // For banked mode we need to restore the window number after
        // we changed it.
        // 

        VBESetDisplayWindow(HwDeviceExtension, 0, WinA);
        VBESetDisplayWindow(HwDeviceExtension, 1, WinB);
    }


    // 
    // 4) Relese resource
    // 

    VideoPortFreeDeviceBase(HwDeviceExtension, pFrameBuffer);
    VideoPortFreePool(HwDeviceExtension, FrameBufferData);

    return FrameBufferSize;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\vga\mini\modeset.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    modeset.c

Abstract:

    This is the modeset code for the VGA miniport driver.

Environment:

    kernel mode only

Notes:

Revision History:

--*/
#include "dderror.h"
#include "devioctl.h"
#include "miniport.h"

#include "ntddvdeo.h"
#include "video.h"
#include "vga.h"
#include "vesa.h"

#include "cmdcnst.h"

#if defined(ALLOC_PRAGMA)
#pragma alloc_text(PAGE,VgaQueryAvailableModes)
#pragma alloc_text(PAGE,VgaQueryNumberOfAvailableModes)
#pragma alloc_text(PAGE,VgaQueryCurrentMode)
#pragma alloc_text(PAGE,VgaSetMode)
#pragma alloc_text(PAGE,VgaInterpretCmdStream)
#pragma alloc_text(PAGE,VgaZeroVideoMemory)
#endif


VP_STATUS
VgaInterpretCmdStream(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PUSHORT pusCmdStream
    )

/*++

Routine Description:

    Interprets the appropriate command array to set up VGA registers for the
    requested mode. Typically used to set the VGA into a particular mode by
    programming all of the registers

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

    pusCmdStream - array of commands to be interpreted.

Return Value:

    The status of the operation (can only fail on a bad command); TRUE for
    success, FALSE for failure.

--*/

{
    ULONG ulCmd;
    ULONG_PTR ulPort;
    UCHAR jValue;
    USHORT usValue;
    ULONG culCount;
    ULONG ulIndex;
    ULONG_PTR ulBase;

    if (pusCmdStream == NULL) {

        VideoDebugPrint((1, "VgaInterpretCmdStream - Invalid pusCmdStream\n"));
        return TRUE;
    }

    ulBase = (ULONG_PTR)HwDeviceExtension->IOAddress;

    //
    // Now set the adapter to the desired mode.
    //

    while ((ulCmd = *pusCmdStream++) != EOD) {

        //
        // Determine major command type
        //

        switch (ulCmd & 0xF0) {

            //
            // Basic input/output command
            //

            case INOUT:

                //
                // Determine type of inout instruction
                //

                if (!(ulCmd & IO)) {

                    //
                    // Out instruction. Single or multiple outs?
                    //

                    if (!(ulCmd & MULTI)) {

                        //
                        // Single out. Byte or word out?
                        //

                        if (!(ulCmd & BW)) {

                            //
                            // Single byte out
                            //

                            ulPort = *pusCmdStream++;
                            jValue = (UCHAR) *pusCmdStream++;
                            VideoPortWritePortUchar((PUCHAR)(ulBase+ulPort),
                                    jValue);

                        } else {

                            //
                            // Single word out
                            //

                            ulPort = *pusCmdStream++;
                            usValue = *pusCmdStream++;
                            VideoPortWritePortUshort((PUSHORT)(ulBase+ulPort),
                                    usValue);

                        }

                    } else {

                        //
                        // Output a string of values
                        // Byte or word outs?
                        //

                        if (!(ulCmd & BW)) {

                            //
                            // String byte outs. Do in a loop; can't use
                            // VideoPortWritePortBufferUchar because the data
                            // is in USHORT form
                            //

                            ulPort = ulBase + *pusCmdStream++;
                            culCount = *pusCmdStream++;

                            while (culCount--) {
                                jValue = (UCHAR) *pusCmdStream++;
                                VideoPortWritePortUchar((PUCHAR)ulPort,
                                        jValue);

                            }

                        } else {

                            //
                            // String word outs
                            //

                            ulPort = *pusCmdStream++;
                            culCount = *pusCmdStream++;
                            VideoPortWritePortBufferUshort((PUSHORT)
                                    (ulBase + ulPort), pusCmdStream, culCount);
                            pusCmdStream += culCount;

                        }
                    }

                } else {

                    // In instruction
                    //
                    // Currently, string in instructions aren't supported; all
                    // in instructions are handled as single-byte ins
                    //
                    // Byte or word in?
                    //

                    if (!(ulCmd & BW)) {
                        //
                        // Single byte in
                        //

                        ulPort = *pusCmdStream++;
                        jValue = VideoPortReadPortUchar((PUCHAR)ulBase+ulPort);

                    } else {

                        //
                        // Single word in
                        //

                        ulPort = *pusCmdStream++;
                        usValue = VideoPortReadPortUshort((PUSHORT)
                                (ulBase+ulPort));

                    }

                }

                break;

            //
            // Higher-level input/output commands
            //

            case METAOUT:

                //
                // Determine type of metaout command, based on minor
                // command field
                //
                switch (ulCmd & 0x0F) {

                    //
                    // Indexed outs
                    //

                    case INDXOUT:

                        ulPort = ulBase + *pusCmdStream++;
                        culCount = *pusCmdStream++;
                        ulIndex = *pusCmdStream++;

                        while (culCount--) {

                            usValue = (USHORT) (ulIndex +
                                      (((ULONG)(*pusCmdStream++)) << 8));
                            VideoPortWritePortUshort((PUSHORT)ulPort, usValue);

                            ulIndex++;

                        }

                        break;

                    //
                    // Masked out (read, AND, XOR, write)
                    //

                    case MASKOUT:

                        ulPort = *pusCmdStream++;
                        jValue = VideoPortReadPortUchar((PUCHAR)ulBase+ulPort);
                        jValue &= *pusCmdStream++;
                        jValue ^= *pusCmdStream++;
                        VideoPortWritePortUchar((PUCHAR)ulBase + ulPort,
                                jValue);
                        break;

                    //
                    // Attribute Controller out
                    //

                    case ATCOUT:

                        ulPort = ulBase + *pusCmdStream++;
                        culCount = *pusCmdStream++;
                        ulIndex = *pusCmdStream++;

                        while (culCount--) {

                            // Write Attribute Controller index
                            VideoPortWritePortUchar((PUCHAR)ulPort,
                                    (UCHAR)ulIndex);

                            // Write Attribute Controller data
                            jValue = (UCHAR) *pusCmdStream++;
                            VideoPortWritePortUchar((PUCHAR)ulPort, jValue);

                            ulIndex++;

                        }

                        break;

                    //
                    // None of the above; error
                    //
                    default:

                        return FALSE;

                }


                break;

            //
            // NOP
            //

            case NCMD:

                break;

            //
            // Unknown command; error
            //

            default:

                return FALSE;

        }

    }

    return TRUE;

} // end VgaInterpretCmdStream()


VP_STATUS
VgaSetMode(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_MODE Mode,
    ULONG ModeSize,
    PULONG FrameBufferIsMoved
    )

/*++

Routine Description:

    This routine sets the VGA into the requested mode.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

    Mode - Pointer to the structure containing the information about the
        font to be set.

    ModeSize - Length of the input buffer supplied by the user.

Return Value:

    ERROR_INSUFFICIENT_BUFFER if the input buffer was not large enough
        for the input data.

    ERROR_INVALID_PARAMETER if the mode number is invalid.

    NO_ERROR if the operation completed successfully.

--*/

{

    PVIDEOMODE pRequestedMode;

    //
    // Check if the size of the data in the input buffer is large enough.
    //

    if (ModeSize < sizeof(VIDEO_MODE)) {

        return ERROR_INSUFFICIENT_BUFFER;

    }

    *FrameBufferIsMoved = 0;

    //
    // Extract the clear memory bit.
    //

    if (Mode->RequestedMode & VIDEO_MODE_NO_ZERO_MEMORY) {

        Mode->RequestedMode &= ~VIDEO_MODE_NO_ZERO_MEMORY;

    }  else {

        if (IS_LINEAR_MODE(&VgaModeList[Mode->RequestedMode]) == FALSE) {
            VgaZeroVideoMemory(HwDeviceExtension);
        }
    }

    //
    // Check to see if we are requesting a vlid mode
    //

    if (Mode->RequestedMode >= NumVideoModes) {

        ASSERT(FALSE);
        return ERROR_INVALID_PARAMETER;

    }

    pRequestedMode = &VgaModeList[Mode->RequestedMode];

#ifdef INT10_MODE_SET
{

    VIDEO_X86_BIOS_ARGUMENTS biosArguments;
    UCHAR temp;
    UCHAR dummy;
    UCHAR bIsColor;
    ULONG modeNumber;
    VP_STATUS status;

    VideoPortZeroMemory(&biosArguments, sizeof(VIDEO_X86_BIOS_ARGUMENTS));

    modeNumber = pRequestedMode->Int10ModeNumber;

    VideoDebugPrint((1, "Setting Mode: (%d,%d) @ %d bpp\n",
                        pRequestedMode->hres,
                        pRequestedMode->vres,
                        pRequestedMode->bitsPerPlane * pRequestedMode->numPlanes));


    biosArguments.Eax = modeNumber & 0x0000FFFF;
    biosArguments.Ebx = modeNumber >> 16;

    status = VideoPortInt10(HwDeviceExtension, &biosArguments);

    if (status != NO_ERROR) {
        
        // HACK: If the resolution we tried to set was 640x480x4 we probably 
        // have uncompatible basic VGA device like early McKinley so trying 
        // other way
        
        ASSERT(FALSE); 

        if (status == ERROR_INVALID_FUNCTION) { // HAL call failed

            if (!(pRequestedMode->CmdStrings && 
                  VgaInterpretCmdStream(HwDeviceExtension, pRequestedMode->CmdStrings))) {
                return status;
            }
        }
        else {
            return status;
        }
    }
    else {
    
        //
        // If this was the VESA mode modeset, check the return value in eax
        //
    
        if (modeNumber >> 16) {
    
            if (!VESA_SUCCESS(biosArguments.Eax)) {
    
                VideoDebugPrint((0, "Mode set failed!  AX = 0x%x\n", biosArguments.Eax));
    
                return ERROR_INVALID_PARAMETER;
            }
    
            //
            // Double check if the current mode is the mode we just set.
            // This is to workaround the BIOS problem of some cards.
            //
    
            biosArguments.Eax = 0x4F03;
            status = VideoPortInt10(HwDeviceExtension, &biosArguments);
    
            if ( (status == NO_ERROR) && 
                 (VESA_SUCCESS(biosArguments.Eax)) && 
                 ((biosArguments.Ebx & 0x1FF) != ((modeNumber >> 16) & 0x1FF))) {
    
                VideoDebugPrint((0, "VGA: The BIOS of this video card is buggy!\n"));
                return ERROR_INVALID_PARAMETER;
            }
    
            //
            // Set the scan line width if we are stretching scan lines to avoid
            // broken rasters.
            //
    
            if (pRequestedMode->PixelsPerScan != pRequestedMode->hres) {
    
                VideoDebugPrint((1, "Setting scan line length to %d pixels\n",
                                    pRequestedMode->PixelsPerScan));
    
                biosArguments.Eax = 0x4f06;
                biosArguments.Ebx = 0x00;
                biosArguments.Ecx = pRequestedMode->PixelsPerScan;
    
                status = VideoPortInt10(HwDeviceExtension, &biosArguments);
    
                if ((status != NO_ERROR) || 
                    !(VESA_SUCCESS(biosArguments.Eax)) || 
                    ((biosArguments.Ecx & 0xFFFF) != pRequestedMode->PixelsPerScan)) {
    
                    VideoDebugPrint((1, "Scan line status: eax = 0x%x\n", biosArguments.Eax));
                    return ERROR_INVALID_PARAMETER;
                }
    
            }
        }
    
        //
        // If we are trying to go into mode X, then we are now in
        // 320x200 256 color mode.  Now let's finish the modeset
        // into MODE X.
        //
    
        if (pRequestedMode->hres == 320) {
    
            if ((pRequestedMode->vres == 240) || (pRequestedMode->vres == 480)) {
    
                VgaInterpretCmdStream(HwDeviceExtension, ModeX240);
    
            } else if ((pRequestedMode->vres == 200) || (pRequestedMode->vres == 400)) {
    
                VgaInterpretCmdStream(HwDeviceExtension, ModeX200);
    
            }
    
            if ((pRequestedMode->vres == 400) || (pRequestedMode->vres == 480)) {
    
                VgaInterpretCmdStream(HwDeviceExtension, ModeXDoubleScans);
    
            }
        }
    
        //
        // Fix to get 640x350 text mode
        //
    
        if (!(pRequestedMode->fbType & VIDEO_MODE_GRAPHICS)) {
    
            if ((pRequestedMode->hres == 640) &&
                (pRequestedMode->vres == 350)) {
    
                VgaInterpretCmdStream(HwDeviceExtension, VGA_TEXT_1);
    
            } else {
    
                //
                // Fix to make sure we always set the colors in text mode to be
                // intensity, and not flashing
                // For this zero out the Mode Control Regsiter bit 3 (index 0x10
                // of the Attribute controller).
                //
    
                if (VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                        MISC_OUTPUT_REG_READ_PORT) & 0x01) {
    
                    bIsColor = TRUE;
    
                } else {
    
                    bIsColor = FALSE;
    
                }
    
                if (bIsColor) {
    
                    dummy = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                            INPUT_STATUS_1_COLOR);
                } else {
    
                    dummy = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                            INPUT_STATUS_1_MONO);
                }
    
                VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                        ATT_ADDRESS_PORT, (0x10 | VIDEO_ENABLE));
                temp = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                        ATT_DATA_READ_PORT);
    
                temp &= 0xF7;
    
                if (bIsColor) {
    
                    dummy = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                            INPUT_STATUS_1_COLOR);
                } else {
    
                    dummy = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                            INPUT_STATUS_1_MONO);
                }
    
                VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                        ATT_ADDRESS_PORT, (0x10 | VIDEO_ENABLE));
                VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                        ATT_DATA_WRITE_PORT, temp);
            }
        }

#if !defined(PLUG_AND_PLAY)

        {
            //
            // Retrieve the base address again. This is to handle the case 
            // when pci reprograms the bar. This should only happen on the
            // legacy version of vga driver
            //
    
            ULONG MemoryBase;
    
            MemoryBase = GetVideoMemoryBaseAddress(HwDeviceExtension, pRequestedMode);
         
            if (MemoryBase && pRequestedMode->MemoryBase != MemoryBase) {
                *FrameBufferIsMoved = 1;
                pRequestedMode->MemoryBase = MemoryBase;
            }
        }
#endif

    }
}
#else
    VgaInterpretCmdStream(HwDeviceExtension, pRequestedMode->CmdStrings);
#endif

    //
    // Update the location of the physical frame buffer within video memory.
    //

    HwDeviceExtension->PhysicalVideoMemoryBase.LowPart = 
        pRequestedMode->MemoryBase;

    HwDeviceExtension->PhysicalVideoMemoryLength =
        pRequestedMode->MemoryLength;

    HwDeviceExtension->PhysicalFrameBaseOffset.LowPart =
        pRequestedMode->FrameOffset;

    HwDeviceExtension->PhysicalFrameLength =
        pRequestedMode->FrameLength;

    //
    // Store the new mode value.
    //

    HwDeviceExtension->CurrentMode = pRequestedMode;
    HwDeviceExtension->ModeIndex = Mode->RequestedMode;

    return NO_ERROR;

} //end VgaSetMode()


VP_STATUS
VgaQueryAvailableModes(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_MODE_INFORMATION ModeInformation,
    ULONG ModeInformationSize,
    PULONG OutputSize
    )

/*++

Routine Description:

    This routine returns the list of all available available modes on the
    card.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

    ModeInformation - Pointer to the output buffer supplied by the user.
        This is where the list of all valid modes is stored.

    ModeInformationSize - Length of the output buffer supplied by the user.

    OutputSize - Pointer to a buffer in which to return the actual size of
        the data in the buffer. If the buffer was not large enough, this
        contains the minimum required buffer size.

Return Value:

    ERROR_INSUFFICIENT_BUFFER if the output buffer was not large enough
        for the data being returned.

    NO_ERROR if the operation completed successfully.

--*/

{
    PVIDEO_MODE_INFORMATION videoModes = ModeInformation;
    ULONG i;

    UNREFERENCED_PARAMETER(HwDeviceExtension);

    //
    // Find out the size of the data to be put in the buffer and return
    // that in the status information (whether or not the information is
    // there). If the buffer passed in is not large enough return an
    // appropriate error code.
    //

    if (ModeInformationSize < (*OutputSize =
            NumVideoModes * sizeof(VIDEO_MODE_INFORMATION)) ) {

        return ERROR_INSUFFICIENT_BUFFER;

    }

    //
    // For each mode supported by the card, store the mode characteristics
    // in the output buffer.
    //


    for (i = 0; i < NumVideoModes; i++, videoModes++) {

        videoModes->Length = sizeof(VIDEO_MODE_INFORMATION);
        videoModes->ModeIndex  = i;
        videoModes->VisScreenWidth = VgaModeList[i].hres;
        videoModes->ScreenStride = VgaModeList[i].wbytes;
        videoModes->VisScreenHeight = VgaModeList[i].vres;
        videoModes->NumberOfPlanes = VgaModeList[i].numPlanes;
        videoModes->BitsPerPlane = VgaModeList[i].bitsPerPlane;
        videoModes->Frequency = VgaModeList[i].frequency;
        videoModes->XMillimeter = 320;        // temporary hardcoded constant
        videoModes->YMillimeter = 240;        // temporary hardcoded constant

        if (VgaModeList[i].bitsPerPlane < 15) {

            videoModes->NumberRedBits = 6;
            videoModes->NumberGreenBits = 6;
            videoModes->NumberBlueBits = 6;

            videoModes->RedMask = 0;
            videoModes->GreenMask = 0;
            videoModes->BlueMask = 0;

        } else if (VgaModeList[i].bitsPerPlane == 15) {

            videoModes->NumberRedBits = 6;
            videoModes->NumberGreenBits = 6;
            videoModes->NumberBlueBits = 6;

            videoModes->RedMask = 0x1F << 10;
            videoModes->GreenMask = 0x1F << 5;
            videoModes->BlueMask = 0x1F;

        } else if (VgaModeList[i].bitsPerPlane == 16) {

            videoModes->NumberRedBits = 6;
            videoModes->NumberGreenBits = 6;
            videoModes->NumberBlueBits = 6;

            videoModes->RedMask = 0x1F << 11;
            videoModes->GreenMask = 0x3F << 5;
            videoModes->BlueMask = 0x1F;

        } else {

            videoModes->NumberRedBits = 8;
            videoModes->NumberGreenBits = 8;
            videoModes->NumberBlueBits = 8;

            videoModes->RedMask = 0xff0000;
            videoModes->GreenMask = 0x00ff00;
            videoModes->BlueMask = 0x0000ff;
        }

        videoModes->AttributeFlags = VgaModeList[i].fbType |
               VIDEO_MODE_PALETTE_DRIVEN | VIDEO_MODE_MANAGED_PALETTE;

    }

    return NO_ERROR;

} // end VgaGetAvailableModes()

VP_STATUS
VgaQueryNumberOfAvailableModes(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_NUM_MODES NumModes,
    ULONG NumModesSize,
    PULONG OutputSize
    )

/*++

Routine Description:

    This routine returns the number of available modes for this particular
    video card.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

    NumModes - Pointer to the output buffer supplied by the user. This is
        where the number of modes is stored.

    NumModesSize - Length of the output buffer supplied by the user.

    OutputSize - Pointer to a buffer in which to return the actual size of
        the data in the buffer.

Return Value:

    ERROR_INSUFFICIENT_BUFFER if the output buffer was not large enough
        for the data being returned.

    NO_ERROR if the operation completed successfully.

--*/

{
    UNREFERENCED_PARAMETER(HwDeviceExtension);

    //
    // Find out the size of the data to be put in the the buffer and return
    // that in the status information (whether or not the information is
    // there). If the buffer passed in is not large enough return an
    // appropriate error code.
    //

    if (NumModesSize < (*OutputSize = sizeof(VIDEO_NUM_MODES)) ) {

        return ERROR_INSUFFICIENT_BUFFER;

    }

    //
    // Store the number of modes into the buffer.
    //

    NumModes->NumModes = NumVideoModes;
    NumModes->ModeInformationLength = sizeof(VIDEO_MODE_INFORMATION);

    return NO_ERROR;

} // end VgaGetNumberOfAvailableModes()

VP_STATUS
VgaQueryCurrentMode(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_MODE_INFORMATION ModeInformation,
    ULONG ModeInformationSize,
    PULONG OutputSize
    )

/*++

Routine Description:

    This routine returns a description of the current video mode.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

    ModeInformation - Pointer to the output buffer supplied by the user.
        This is where the current mode information is stored.

    ModeInformationSize - Length of the output buffer supplied by the user.

    OutputSize - Pointer to a buffer in which to return the actual size of
        the data in the buffer. If the buffer was not large enough, this
        contains the minimum required buffer size.

Return Value:

    ERROR_INSUFFICIENT_BUFFER if the output buffer was not large enough
        for the data being returned.

    NO_ERROR if the operation completed successfully.

--*/

{
    //
    //
    // check if a mode has been set
    //

    if (HwDeviceExtension->CurrentMode == NULL) {

        return ERROR_INVALID_FUNCTION;

    }

    //
    // Find out the size of the data to be put in the the buffer and return
    // that in the status information (whether or not the information is
    // there). If the buffer passed in is not large enough return an
    // appropriate error code.
    //

    if (ModeInformationSize < (*OutputSize = sizeof(VIDEO_MODE_INFORMATION))) {

        return ERROR_INSUFFICIENT_BUFFER;

    }

    //
    // Store the characteristics of the current mode into the buffer.
    //

    ModeInformation->Length = sizeof(VIDEO_MODE_INFORMATION);
    ModeInformation->ModeIndex = HwDeviceExtension->ModeIndex;
    ModeInformation->VisScreenWidth = HwDeviceExtension->CurrentMode->hres;
    ModeInformation->ScreenStride = HwDeviceExtension->CurrentMode->wbytes;
    ModeInformation->VisScreenHeight = HwDeviceExtension->CurrentMode->vres;
    ModeInformation->NumberOfPlanes = HwDeviceExtension->CurrentMode->numPlanes;
    ModeInformation->BitsPerPlane = HwDeviceExtension->CurrentMode->bitsPerPlane;
    ModeInformation->Frequency = HwDeviceExtension->CurrentMode->frequency;

    ModeInformation->XMillimeter = 320;        // temporary hardcoded constant
    ModeInformation->YMillimeter = 240;        // temporary hardcoded constant

    if (HwDeviceExtension->CurrentMode->bitsPerPlane < 15) {

        ModeInformation->NumberRedBits = 6;
        ModeInformation->NumberGreenBits = 6;
        ModeInformation->NumberBlueBits = 6;

        ModeInformation->RedMask = 0;
        ModeInformation->GreenMask = 0;
        ModeInformation->BlueMask = 0;

    } else if (HwDeviceExtension->CurrentMode->bitsPerPlane == 15) {

        ModeInformation->NumberRedBits = 6;
        ModeInformation->NumberGreenBits = 6;
        ModeInformation->NumberBlueBits = 6;

        ModeInformation->RedMask = 0x1F << 10;
        ModeInformation->GreenMask = 0x1F << 5;
        ModeInformation->BlueMask = 0x1F;

    } else if (HwDeviceExtension->CurrentMode->bitsPerPlane == 16) {

        ModeInformation->NumberRedBits = 6;
        ModeInformation->NumberGreenBits = 6;
        ModeInformation->NumberBlueBits = 6;

        ModeInformation->RedMask = 0x1F << 11;
        ModeInformation->GreenMask = 0x3F << 5;
        ModeInformation->BlueMask = 0x1F;

    } else {

        ModeInformation->NumberRedBits = 8;
        ModeInformation->NumberGreenBits = 8;
        ModeInformation->NumberBlueBits = 8;

        ModeInformation->RedMask = 0xff0000;
        ModeInformation->GreenMask = 0x00ff00;
        ModeInformation->BlueMask = 0x0000ff;
    }

    ModeInformation->AttributeFlags = HwDeviceExtension->CurrentMode->fbType |
             VIDEO_MODE_PALETTE_DRIVEN | VIDEO_MODE_MANAGED_PALETTE;

    return NO_ERROR;

} // end VgaQueryCurrentMode()


VOID
VgaZeroVideoMemory(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    )
/*++

Routine Description:

    This routine zeros the first 256K on the VGA.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.


Return Value:

    None.

--*/
{
    UCHAR temp;

    //
    // Map font buffer at A0000
    //
    // We need the 2 calls below to VideoPortStallExecution because on 
    // some old cards the machine would hard hang without this delay.
    //

    VgaInterpretCmdStream(HwDeviceExtension, EnableA000Data);
    VideoPortStallExecution(25);

    //
    // Enable all planes.
    //
    VideoPortWritePortUchar(HwDeviceExtension->IOAddress + SEQ_ADDRESS_PORT,
            IND_MAP_MASK);

    temp = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
            SEQ_DATA_PORT) | (UCHAR)0x0F;

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress + SEQ_DATA_PORT,
            temp);

    //
    // Zero the memory.
    //

    VideoPortZeroDeviceMemory(HwDeviceExtension->VideoMemoryAddress, 0xFFFF);
    VideoPortStallExecution(25);

    VgaInterpretCmdStream(HwDeviceExtension, DisableA000Color);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\vgarisc\disp\debug.c ===
/******************************Module*Header*******************************\
* Module Name: debug.c
*
* debug helpers routine
*
* Copyright (c) 1992-1995 Microsoft Corporation
*
\**************************************************************************/

#include "precomp.h"

#if DBG

ULONG DebugLevel = 0;

/*****************************************************************************
 *
 *   Routine Description:
 *
 *      This function is variable-argument, level-sensitive debug print
 *      routine.
 *      If the specified debug level for the print statement is lower or equal
 *      to the current debug level, the message will be printed.
 *
 *   Arguments:
 *
 *      DebugPrintLevel - Specifies at which debugging level the string should
 *          be printed
 *
 *      DebugMessage - Variable argument ascii c string
 *
 *   Return Value:
 *
 *      None.
 *
 ***************************************************************************/

VOID
DebugPrint(
    ULONG DebugPrintLevel,
    PCHAR DebugMessage,
    ...
    )

{

    va_list ap;

    va_start(ap, DebugMessage);

    if (DebugPrintLevel <= DebugLevel)
    {
        EngDebugPrint(STANDARD_DEBUG_PREFIX, DebugMessage, ap);
        EngDebugPrint("", "\n", ap);
    }

    va_end(ap);

}

#endif  // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\vgarisc\disp\debug.h ===
/***************************************************************************\
* Module Name: debug.h
*
* Commonly used debugging macros.
*
* Copyright (c) 1992-1995 Microsoft Corporation
\***************************************************************************/

#if DBG

VOID
DebugPrint(
    ULONG DebugPrintLevel,
    PCHAR DebugMessage,
    ...
    );

#define DISPDBG(arg) DebugPrint arg
#define RIP(x) { DebugPrint(0, x); EngDebugBreak();}
#define ASSERTDD(x, y) if (!(x)) RIP (y)
#define STATEDBG(level)
#define LOGDBG(arg)

#else

#define DISPDBG(arg)
#define RIP(x)
#define ASSERTDD(x, y)
#define STATEDBG(level)
#define LOGDBG(arg)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\vga\mini\vga.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    vga.h

Abstract:

    This module contains the definitions for the code that implements the
    VGA device driver.

Author:

Environment:

    Kernel mode

Revision History:


--*/

//
// Base address of VGA memory range.  Also used as base address of VGA
// memory when loading a font, which is done with the VGA mapped at A0000.
//

#define MEM_VGA      0xA0000
#define MEM_VGA_SIZE 0x20000

//
// Index in the access range sturture for video memory
// !!! This must match the VgaAccessRange structure    !!!
// !!! Memory is in the structure, index 2 (3rd entry) !!!

#define VGA_MEMORY  2


//
// VGA port-related definitions.
//
//
// Port definitions for filling the ACCSES_RANGES structure in the miniport
// information, defines the range of I/O ports the VGA spans.
// There is a break in the IO ports - a few ports are used for the parallel
// port. Those cannot be defined in the ACCESS_RANGE, but are still mapped
// so all VGA ports are in one address range.
//

#define VGA_BASE_IO_PORT      0x000003B0
#define VGA_START_BREAK_PORT  0x000003BB
#define VGA_END_BREAK_PORT    0x000003C0
#define VGA_MAX_IO_PORT       0x000003DF

//
// VGA register definitions
//
                                            // ports in monochrome mode
#define CRTC_ADDRESS_PORT_MONO      0x0004  // CRT Controller Address and
#define CRTC_DATA_PORT_MONO         0x0005  // Data registers in mono mode
#define FEAT_CTRL_WRITE_PORT_MONO   0x000A  // Feature Control write port
                                            // in mono mode
#define INPUT_STATUS_1_MONO         0x000A  // Input Status 1 register read
                                            // port in mono mode
#define ATT_INITIALIZE_PORT_MONO    INPUT_STATUS_1_MONO
                                            // Register to read to reset
                                            // Attribute Controller index/data

#define ATT_ADDRESS_PORT            0x0010  // Attribute Controller Address and
#define ATT_DATA_WRITE_PORT         0x0010  // Data registers share one port
                                            // for writes, but only Address is
                                            // readable at 0x3C0
#define ATT_DATA_READ_PORT          0x0011  // Attribute Controller Data reg is
                                            // readable here
#define MISC_OUTPUT_REG_WRITE_PORT  0x0012  // Miscellaneous Output reg write
                                            // port
#define INPUT_STATUS_0_PORT         0x0012  // Input Status 0 register read
                                            // port
#define VIDEO_SUBSYSTEM_ENABLE_PORT 0x0013  // Bit 0 enables/disables the
                                            // entire VGA subsystem
#define SEQ_ADDRESS_PORT            0x0014  // Sequence Controller Address and
#define SEQ_DATA_PORT               0x0015  // Data registers
#define DAC_PIXEL_MASK_PORT         0x0016  // DAC pixel mask reg
#define DAC_ADDRESS_READ_PORT       0x0017  // DAC register read index reg,
                                            // write-only
#define DAC_STATE_PORT              0x0017  // DAC state (read/write),
                                            // read-only
#define DAC_ADDRESS_WRITE_PORT      0x0018  // DAC register write index reg
#define DAC_DATA_REG_PORT           0x0019  // DAC data transfer reg
#define FEAT_CTRL_READ_PORT         0x001A  // Feature Control read port
#define MISC_OUTPUT_REG_READ_PORT   0x001C  // Miscellaneous Output reg read
                                            // port
#define GRAPH_ADDRESS_PORT          0x001E  // Graphics Controller Address
#define GRAPH_DATA_PORT             0x001F  // and Data registers

#define CRTC_ADDRESS_PORT_COLOR     0x0024  // CRT Controller Address and
#define CRTC_DATA_PORT_COLOR        0x0025  // Data registers in color mode
#define FEAT_CTRL_WRITE_PORT_COLOR  0x002A  // Feature Control write port
#define INPUT_STATUS_1_COLOR        0x002A  // Input Status 1 register read
                                            // port in color mode
#define ATT_INITIALIZE_PORT_COLOR   INPUT_STATUS_1_COLOR
                                            // Register to read to reset
                                            // Attribute Controller index/data
                                            // toggle in color mode

//
// Offsets in HardwareStateHeader->PortValue[] of save areas for non-indexed
// VGA registers.
//

#define CRTC_ADDRESS_MONO_OFFSET      0x04
#define FEAT_CTRL_WRITE_MONO_OFFSET   0x0A
#define ATT_ADDRESS_OFFSET            0x10
#define MISC_OUTPUT_REG_WRITE_OFFSET  0x12
#define VIDEO_SUBSYSTEM_ENABLE_OFFSET 0x13
#define SEQ_ADDRESS_OFFSET            0x14
#define DAC_PIXEL_MASK_OFFSET         0x16
#define DAC_STATE_OFFSET              0x17
#define DAC_ADDRESS_WRITE_OFFSET      0x18
#define GRAPH_ADDRESS_OFFSET          0x1E
#define CRTC_ADDRESS_COLOR_OFFSET     0x24
#define FEAT_CTRL_WRITE_COLOR_OFFSET  0x2A

//
// VGA indexed register indexes.
//

#define IND_CURSOR_START        0x0A    // index in CRTC of the Cursor Start
#define IND_CURSOR_END          0x0B    //  and End registers
#define IND_CURSOR_HIGH_LOC     0x0E    // index in CRTC of the Cursor Location
#define IND_CURSOR_LOW_LOC      0x0F    //  High and Low Registers
#define IND_VSYNC_END           0x11    // index in CRTC of the Vertical Sync
                                        //  End register, which has the bit
                                        //  that protects/unprotects CRTC
                                        //  index registers 0-7
#define IND_SET_RESET_ENABLE    0x01    // index of Set/Reset Enable reg in GC
#define IND_DATA_ROTATE         0x03    // index of Data Rotate reg in GC
#define IND_READ_MAP            0x04    // index of Read Map reg in Graph Ctlr
#define IND_GRAPH_MODE          0x05    // index of Mode reg in Graph Ctlr
#define IND_GRAPH_MISC          0x06    // index of Misc reg in Graph Ctlr
#define IND_BIT_MASK            0x08    // index of Bit Mask reg in Graph Ctlr
#define IND_SYNC_RESET          0x00    // index of Sync Reset reg in Seq
#define IND_MAP_MASK            0x02    // index of Map Mask in Sequencer
#define IND_MEMORY_MODE         0x04    // index of Memory Mode reg in Seq
#define IND_CRTC_PROTECT        0x11    // index of reg containing regs 0-7 in
                                        //  CRTC

#define START_SYNC_RESET_VALUE  0x01    // value for Sync Reset reg to start
                                        //  synchronous reset
#define END_SYNC_RESET_VALUE    0x03    // value for Sync Reset reg to end
                                        //  synchronous reset

//
// Values for Attribute Controller Index register to turn video off
// and on, by setting bit 5 to 0 (off) or 1 (on).
//

#define VIDEO_DISABLE 0
#define VIDEO_ENABLE  0x20

//
// Value written to the Read Map register when identifying the existence of
// a VGA in VgaInitialize. This value must be different from the final test
// value written to the Bit Mask in that routine.
//

#define READ_MAP_TEST_SETTING 0x03

//
// Masks to keep only the significant bits of the Graphics Controller and
// Sequencer Address registers. Masking is necessary because some VGAs, such
// as S3-based ones, don't return unused bits set to 0, and some SVGAs use
// these bits if extensions are enabled.
//

#define GRAPH_ADDR_MASK 0x0F
#define SEQ_ADDR_MASK   0x07

//
// Mask used to toggle Chain4 bit in the Sequencer's Memory Mode register.
//

#define CHAIN4_MASK 0x08

//
// Default text mode setting for various registers, used to restore their
// states if VGA detection fails after they've been modified.
//

#define MEMORY_MODE_TEXT_DEFAULT 0x02
#define BIT_MASK_DEFAULT 0xFF
#define READ_MAP_DEFAULT 0x00

//
// Palette-related info.
//

//
// Highest valid DAC color register index.
//

#define VIDEO_MAX_COLOR_REGISTER  0xFF

//
// Highest valid palette register index
//

#define VIDEO_MAX_PALETTE_REGISTER 0x0F

//
// Hardware ID for detected monitor
//

#define VGA_MONITOR_ID 0x12345678

//
// For a mode, the type of banking supported. Controls the information
// returned in VIDEO_BANK_SELECT. PlanarHCBanking includes NormalBanking.
//

typedef enum _BANK_TYPE {
    NoBanking = 0,
    NormalBanking,
    PlanarHCBanking
} BANK_TYPE, *PBANK_TYPE;

//
// Structure used to describe each video mode in ModesVGA[].
//

typedef struct {
    USHORT  fbType; // color or monochrome, text or graphics, via
                    //  VIDEO_MODE_COLOR and VIDEO_MODE_GRAPHICS
    USHORT  numPlanes;    // # of video memory planes
    USHORT  bitsPerPlane; // # of bits of color in each plane
    SHORT   col;    // # of text columns across screen with default font
    SHORT   row;    // # of text rows down screen with default font
    USHORT  hres;   // # of pixels across screen
    USHORT  vres;   // # of scan lines down screen
    USHORT  frequency;    // refresh rate in Hz
    USHORT  wbytes; // # of bytes from start of one scan line to start of next
    ULONG   sbytes; // total size of addressable display memory in bytes
    BANK_TYPE banktype; // NoBanking, NormalBanking, PlanarHCBanking
    ULONG   Int10ModeNumber;
    PUSHORT CmdStrings;     // pointer to array of register-setting commands
    ULONG MemoryBase;       // Base of frame buffer
    ULONG FrameOffset;      // Offset from beginning of frame buffer for this mode
    ULONG FrameLength;      // Size of available frame buffer
    ULONG MemoryLength;     // Total memory
    ULONG PixelsPerScan;    // This is larger than hres if we need to stretch scan
    BOOLEAN NonVgaHardware; // If this mode is compatible with VGA hw register & io ports
    ULONG Granularity;      // The window granularity for banked modes
} VIDEOMODE, *PVIDEOMODE;


//
// Mode into which to put the VGA before starting a VDM, so it's a plain
// vanilla VGA.  (This is the mode's index in ModesVGA[], currently standard
// 80x25 text mode.)
//

#define DEFAULT_MODE 0


//
// Info for the validator functions.
//

//
// Number of each type of indexed register in a standard VGA, used by
// validator and state save/restore functions.
//
// Note: VDMs currently only support basic VGAs only.
//

#define VGA_NUM_SEQUENCER_PORTS     5
#define VGA_NUM_CRTC_PORTS         25
#define VGA_NUM_GRAPH_CONT_PORTS    9
#define VGA_NUM_ATTRIB_CONT_PORTS  21
#define VGA_NUM_DAC_ENTRIES       256

//
// Number of each type of extended indexed register.
//

#define EXT_NUM_SEQUENCER_PORTS     0
#define EXT_NUM_CRTC_PORTS          0
#define EXT_NUM_GRAPH_CONT_PORTS    0
#define EXT_NUM_ATTRIB_CONT_PORTS   0
#define EXT_NUM_DAC_ENTRIES         0

//
// Info used by the Validator functions and save/restore code.
// Structure used to trap register accesses that must be done atomically.
//

#define VGA_MAX_VALIDATOR_DATA             100

#define VGA_VALIDATOR_UCHAR_ACCESS   1
#define VGA_VALIDATOR_USHORT_ACCESS  2
#define VGA_VALIDATOR_ULONG_ACCESS   3

typedef struct _VGA_VALIDATOR_DATA {
   ULONG Port;
   UCHAR AccessType;
   ULONG Data;
} VGA_VALIDATOR_DATA, *PVGA_VALIDATOR_DATA;


//
// Info for the save and restore state functions.
//

//
// Number of bytes to save in each plane.
//

#define VGA_PLANE_SIZE 0x10000

//
// These constants determine the offsets within the
// VIDEO_HARDWARE_STATE_HEADER structure that are used to save and
// restore the VGA's state.
//

#define VGA_HARDWARE_STATE_SIZE sizeof(VIDEO_HARDWARE_STATE_HEADER)

#define VGA_BASIC_SEQUENCER_OFFSET (VGA_HARDWARE_STATE_SIZE + 0)
#define VGA_BASIC_CRTC_OFFSET (VGA_BASIC_SEQUENCER_OFFSET + \
         VGA_NUM_SEQUENCER_PORTS)
#define VGA_BASIC_GRAPH_CONT_OFFSET (VGA_BASIC_CRTC_OFFSET + \
         VGA_NUM_CRTC_PORTS)
#define VGA_BASIC_ATTRIB_CONT_OFFSET (VGA_BASIC_GRAPH_CONT_OFFSET + \
         VGA_NUM_GRAPH_CONT_PORTS)
#define VGA_BASIC_DAC_OFFSET (VGA_BASIC_ATTRIB_CONT_OFFSET + \
         VGA_NUM_ATTRIB_CONT_PORTS)
#define VGA_BASIC_LATCHES_OFFSET (VGA_BASIC_DAC_OFFSET + \
         (3 * VGA_NUM_DAC_ENTRIES))

#define VGA_EXT_SEQUENCER_OFFSET (VGA_BASIC_LATCHES_OFFSET + 4)
#define VGA_EXT_CRTC_OFFSET (VGA_EXT_SEQUENCER_OFFSET + \
         EXT_NUM_SEQUENCER_PORTS)
#define VGA_EXT_GRAPH_CONT_OFFSET (VGA_EXT_CRTC_OFFSET + \
         EXT_NUM_CRTC_PORTS)
#define VGA_EXT_ATTRIB_CONT_OFFSET (VGA_EXT_GRAPH_CONT_OFFSET + \
         EXT_NUM_GRAPH_CONT_PORTS)
#define VGA_EXT_DAC_OFFSET (VGA_EXT_ATTRIB_CONT_OFFSET + \
         EXT_NUM_ATTRIB_CONT_PORTS)

#define VGA_VALIDATOR_OFFSET (VGA_EXT_DAC_OFFSET + 4 * EXT_NUM_DAC_ENTRIES)

#define VGA_VALIDATOR_AREA_SIZE  sizeof (ULONG) + (VGA_MAX_VALIDATOR_DATA * \
                                 sizeof (VGA_VALIDATOR_DATA)) +             \
                                 sizeof (ULONG) +                           \
                                 sizeof (ULONG) +                           \
                                 sizeof (PVIDEO_ACCESS_RANGE)

#define VGA_MISC_DATA_AREA_OFFSET VGA_VALIDATOR_OFFSET + VGA_VALIDATOR_AREA_SIZE

#define VGA_MISC_DATA_AREA_SIZE  0

#define VGA_PLANE_0_OFFSET VGA_MISC_DATA_AREA_OFFSET + VGA_MISC_DATA_AREA_SIZE

#define VGA_PLANE_1_OFFSET VGA_PLANE_0_OFFSET + VGA_PLANE_SIZE
#define VGA_PLANE_2_OFFSET VGA_PLANE_1_OFFSET + VGA_PLANE_SIZE
#define VGA_PLANE_3_OFFSET VGA_PLANE_2_OFFSET + VGA_PLANE_SIZE

//
// Space needed to store all state data.
//

#define VGA_TOTAL_STATE_SIZE VGA_PLANE_3_OFFSET + VGA_PLANE_SIZE

//
// We will always assume 128 byte edid's
//

#define EDID_BUFFER_SIZE 128


//
// Device extension for the driver object.  This data is only used
// locally, so this structure can be added to as needed.
//

typedef struct _HW_DEVICE_EXTENSION {

    PUCHAR IOAddress;              // base I/O address of VGA ports
    PVOID VideoMemoryAddress;      // base virtual memory address of VGA memory
    ULONG   ModeIndex;             // index of current mode in ModesVGA[]
    PVIDEOMODE CurrentMode;        // pointer to VIDEOMODE structure for
                                   // current mode

    USHORT  FontPelColumns;        // Width of the font in pels
    USHORT  FontPelRows;           // height of the font in pels

    VIDEO_CURSOR_POSITION CursorPosition;     // current cursor position

    UCHAR CursorEnable;            // whether cursor is enabled or not
    UCHAR CursorTopScanLine;       // Cursor Start register setting (top scan)
    UCHAR CursorBottomScanLine;    // Cursor End register setting (bottom scan)

    PHYSICAL_ADDRESS PhysicalVideoMemoryBase; // physical memory address and
    ULONG PhysicalVideoMemoryLength;          // length of display memory
    PHYSICAL_ADDRESS PhysicalFrameBaseOffset; // physical memory address and
    ULONG PhysicalFrameLength;                // length of display memory for
                                              // the current mode.

    //
    // These 4 fields must be at the end of the device extension and must be
    // kept in this order since this data will be copied to and from the save
    // state buffer that is passed to and from the VDM.
    //

    ULONG TrappedValidatorCount;   // number of entries in the Trapped
                                   // validator data Array.
    VGA_VALIDATOR_DATA TrappedValidatorData[VGA_MAX_VALIDATOR_DATA];
                                   // Data trapped by the validator routines
                                   // but not yet played back into the VGA
                                   // register.

    ULONG SequencerAddressValue;   // Determines if the Sequencer Address Port
                                   // is currently selecting the SyncReset data
                                   // register.

    ULONG CurrentNumVdmAccessRanges;           // Number of access ranges in
                                               // the access range array pointed
                                               // to by the next field
    PVIDEO_ACCESS_RANGE CurrentVdmAccessRange; // Access range currently
                                               // associated to the VDM

    VIDEO_PORT_INT10_INTERFACE Int10; // Int10 interface

#if defined(PLUG_AND_PLAY)
    ULONG MonitorPowerCapabilities;   // contains vesa power capabilites for
                                      // the monitor
    ULONG MonitorPowerState;          // track the current monitor power
                                      // state
    UCHAR EdidBuffer[EDID_BUFFER_SIZE];        // cache the monitor edid
    BOOLEAN AlwaysUseCachedEdid;            // use cache monitor edid when set
    USHORT VendorID;                  // pci vendor id
    USHORT DeviceID;                  // pci device id

#endif

} HW_DEVICE_EXTENSION, *PHW_DEVICE_EXTENSION;


//
// Function prototypes.
//

VP_STATUS
VgaFindAdapter(
    PVOID HwDeviceExtension,
    PVOID HwContext,
    PWSTR ArgumentString,
    PVIDEO_PORT_CONFIG_INFO ConfigInfo,
    PUCHAR Again
    );

BOOLEAN
VgaInitialize(
    PVOID HwDeviceExtension
    );

BOOLEAN
VgaStartIO(
    PVOID HwDeviceExtension,
    PVIDEO_REQUEST_PACKET RequestPacket
    );

//
// Private function prototypes.
//

VP_STATUS
VgaQueryAvailableModes(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_MODE_INFORMATION ModeInformation,
    ULONG ModeInformationSize,
    PULONG OutputSize
    );

VP_STATUS
VgaQueryNumberOfAvailableModes(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_NUM_MODES NumModes,
    ULONG NumModesSize,
    PULONG OutputSize
    );

VP_STATUS
VgaQueryCurrentMode(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_MODE_INFORMATION ModeInformation,
    ULONG ModeInformationSize,
    PULONG OutputSize
    );

VP_STATUS
VgaSetMode(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_MODE Mode,
    ULONG ModeSize,
    PULONG FrameBufferIsMoved
    );

VP_STATUS
VgaLoadAndSetFont(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_LOAD_FONT_INFORMATION FontInformation,
    ULONG FontInformationSize
    );

VP_STATUS
VgaQueryCursorPosition(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_CURSOR_POSITION CursorPosition,
    ULONG CursorPositionSize,
    PULONG OutputSize
    );

VP_STATUS
VgaSetCursorPosition(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_CURSOR_POSITION CursorPosition,
    ULONG CursorPositionSize
    );

VP_STATUS
VgaQueryCursorAttributes(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_CURSOR_ATTRIBUTES CursorAttributes,
    ULONG CursorAttributesSize,
    PULONG OutputSize
    );

VP_STATUS
VgaSetCursorAttributes(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_CURSOR_ATTRIBUTES CursorAttributes,
    ULONG CursorAttributesSize
    );

BOOLEAN
VgaIsPresent(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    );

VP_STATUS
VgaInterpretCmdStream(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PUSHORT pusCmdStream
    );

VP_STATUS
VgaSetPaletteReg(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_PALETTE_DATA PaletteBuffer,
    ULONG PaletteBufferSize
    );

VP_STATUS
VgaSetColorLookup(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_CLUT ClutBuffer,
    ULONG ClutBufferSize
    );

VP_STATUS
VgaRestoreHardwareState(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_HARDWARE_STATE HardwareState,
    ULONG HardwareStateSize
    );

VP_STATUS
VgaSaveHardwareState(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_HARDWARE_STATE HardwareState,
    ULONG HardwareStateSize,
    PULONG OutputSize
    );

VP_STATUS
VgaGetBankSelectCode(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_BANK_SELECT BankSelect,
    ULONG BankSelectSize,
    PULONG OutputSize
    );

VOID
VgaZeroVideoMemory(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    );

//
// Entry points for the VGA validator. Used in VgaEmulatorAccessEntries[].
//

VP_STATUS
VgaValidatorUcharEntry (
    ULONG_PTR Context,
    ULONG Port,
    UCHAR AccessMode,
    PUCHAR Data
    );

VP_STATUS
VgaValidatorUshortEntry (
    ULONG_PTR Context,
    ULONG Port,
    UCHAR AccessMode,
    PUSHORT Data
    );

VP_STATUS
VgaValidatorUlongEntry (
    ULONG_PTR Context,
    ULONG Port,
    UCHAR AccessMode,
    PULONG Data
    );

BOOLEAN
VgaPlaybackValidatorData (
    PVOID Context
    );

VP_STATUS
VgaSetBankPosition(
    PHW_DEVICE_EXTENSION hwDeviceExtension,
    PBANK_POSITION BankPosition
    );

USHORT
RaiseToPower2(
    USHORT x
    );

ULONG
RaiseToPower2Ulong(
    ULONG x
    );

BOOLEAN
IsPower2(
    USHORT x
    );

VP_STATUS
VgaGetPowerState(
    PVOID HwDeviceExtension,
    ULONG HwId,
    PVIDEO_POWER_MANAGEMENT VideoPowerControl
    );

VP_STATUS
VgaSetPowerState (
    PVOID HwDeviceExtension,
    ULONG HwId,
    PVIDEO_POWER_MANAGEMENT VideoPowerControl
    );

ULONG
VgaGetChildDescriptor(
    PVOID HwDeviceExtension,
    PVIDEO_CHILD_ENUM_INFO ChildEnumInfo,
    PVIDEO_CHILD_TYPE pChildType,
    PVOID pChildDescriptor,
    PULONG pUId,
    PULONG pUnused
    );

VOID
VgaGetMonitorEdid(
    PHW_DEVICE_EXTENSION hwDeviceExtension,
    PUCHAR Buffer,
    ULONG Size
    );

VP_STATUS
VgaAcquireResources(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    );

VOID
VgaInitializeSpecialCase(
    PHW_DEVICE_EXTENSION hwDeviceExtension
    );

//
// Global to make sure driver is only loaded once.
//

extern ULONG VgaLoaded;

#if DBG
#define MAX_CONTROL_HISTORY 512
extern ULONG giControlCode;
extern ULONG gaIOControlCode[];
#endif



//
// Bank switch code start and end labels, define in HARDWARE.ASM
//

extern UCHAR BankSwitchStart;
extern UCHAR BankSwitchEnd;

//
// Vga init scripts for font loading
//

extern USHORT EnableA000Data[];
extern USHORT DisableA000Color[];


extern USHORT VGA_640x480[];
extern USHORT VGA_TEXT_0[];
extern USHORT VGA_TEXT_1[];
extern USHORT ModeX240[];
extern USHORT ModeX200[];
extern USHORT ModeXDoubleScans[];

extern VIDEOMODE ModesVGA[];
extern ULONG NumVideoModes;
extern PVIDEOMODE VgaModeList;

#define NUM_VGA_ACCESS_RANGES  5
#define NUM_STD_VGA_ACCESS_RANGES 3
extern VIDEO_ACCESS_RANGE VgaAccessRange[];

#define VGA_NUM_EMULATOR_ACCESS_ENTRIES     8
extern EMULATOR_ACCESS_ENTRY VgaEmulatorAccessEntries[];

#define NUM_MINIMAL_VGA_VALIDATOR_ACCESS_RANGE 5
extern VIDEO_ACCESS_RANGE MinimalVgaValidatorAccessRange[];

#define NUM_FULL_VGA_VALIDATOR_ACCESS_RANGE 3
extern VIDEO_ACCESS_RANGE FullVgaValidatorAccessRange[];
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\vga\mini\vga.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    vga.c

Abstract:

    This is the miniport driver for the VGA card.

Environment:

    kernel mode only

Notes:

Revision History:

--*/

#include "dderror.h"
#include "devioctl.h"
#include "miniport.h"

#include "ntddvdeo.h"
#include "video.h"
#include "vga.h"
#include "vesa.h"

#define DEBUG_CODE
#if defined(DEBUG_CODE)
ULONG TrapRoutineEntered = 0;
#if defined(_X86_)
#define MY_ASSERT __asm {int 3}
#else
#define MY_ASSERT
#endif
#endif

VP_STATUS
GetDeviceDataCallback(
    PVOID HwDeviceExtension,
    PVOID Context,
    VIDEO_DEVICE_DATA_TYPE DeviceDataType,
    PVOID Identifier,
    ULONG IdentifierLength,
    PVOID ConfigurationData,
    ULONG ConfigurationDataLength,
    PVOID ComponentInformation,
    ULONG ComponentInformationLength
    );


#if defined(ALLOC_PRAGMA)
#pragma alloc_text(INIT,DriverEntry)
#pragma alloc_text(PAGE,VgaFindAdapter)
#pragma alloc_text(PAGE,VgaInitialize)
#pragma alloc_text(PAGE,VgaStartIO)
#pragma alloc_text(PAGE,VgaLoadAndSetFont)
#pragma alloc_text(PAGE,VgaQueryCursorPosition)
#pragma alloc_text(PAGE,VgaSetCursorPosition)
#pragma alloc_text(PAGE,VgaQueryCursorAttributes)
#pragma alloc_text(PAGE,VgaSetCursorAttributes)
#pragma alloc_text(PAGE,VgaIsPresent)
#pragma alloc_text(PAGE,VgaSetPaletteReg)
#pragma alloc_text(PAGE,VgaSetColorLookup)
#pragma alloc_text(PAGE,VgaRestoreHardwareState)
#pragma alloc_text(PAGE,VgaSaveHardwareState)
#pragma alloc_text(PAGE,VgaGetBankSelectCode)
#pragma alloc_text(PAGE,VgaValidatorUcharEntry)
#pragma alloc_text(PAGE,VgaValidatorUshortEntry)
#pragma alloc_text(PAGE,VgaValidatorUlongEntry)
#pragma alloc_text(PAGE,GetDeviceDataCallback)
#pragma alloc_text(PAGE,VgaSetBankPosition)
#pragma alloc_text(PAGE,VgaAcquireResources)
#pragma alloc_text(PAGE,VgaGetPowerState)
#pragma alloc_text(PAGE,VgaSetPowerState)
#pragma alloc_text(PAGE,VgaGetChildDescriptor)
#pragma alloc_text(PAGE,VgaGetMonitorEdid)
#endif



ULONG
DriverEntry(
    PVOID Context1,
    PVOID Context2
    )

/*++

Routine Description:

    Installable driver initialization entry point.
    This entry point is called directly by the I/O system.

Arguments:

    Context1 - First context value passed by the operating system. This is
        the value with which the miniport driver calls VideoPortInitialize().

    Context2 - Second context value passed by the operating system. This is
        the value with which the miniport driver calls VideoPortInitialize().

Return Value:

    Status from VideoPortInitialize()

--*/

{

    VIDEO_HW_INITIALIZATION_DATA hwInitData;
    ULONG initializationStatus;

    //
    // Zero out structure.
    //

    VideoPortZeroMemory(&hwInitData, sizeof(VIDEO_HW_INITIALIZATION_DATA));

    //
    // Specify sizes of structure and extension.
    //

    hwInitData.HwInitDataSize = sizeof(VIDEO_HW_INITIALIZATION_DATA);

    //
    // Set entry points.
    //

    hwInitData.HwFindAdapter = VgaFindAdapter;
    hwInitData.HwInitialize = VgaInitialize;
    hwInitData.HwInterrupt = NULL;
    hwInitData.HwStartIO = VgaStartIO;

#if defined(PLUG_AND_PLAY)

    hwInitData.HwGetPowerState           = VgaGetPowerState;
    hwInitData.HwSetPowerState           = VgaSetPowerState;
    hwInitData.HwGetVideoChildDescriptor = VgaGetChildDescriptor;

    hwInitData.HwLegacyResourceList      = VgaAccessRange;
    hwInitData.HwLegacyResourceCount     = NUM_STD_VGA_ACCESS_RANGES;

#endif

    //
    // Determine the size we require for the device extension.
    //

    hwInitData.HwDeviceExtensionSize = sizeof(HW_DEVICE_EXTENSION);

    //
    // Both numbers for these fields are zero since they are allocated
    // statically in the driver. We will pass pointers and sizes later in
    // the find adapter routine.
    //

//    hwInitData.NumberOfAccessRanges = 0;
//    hwInitData.NumEmulatorAccessEntries = 0;

    //
    // Always start with parameters for device0 in this case.
    // We can leave it like this since we know we will only ever find one
    // VGA type adapter in a machine.
    //

//    hwInitData.StartingDeviceNumber = 0;

    //
    // Once all the relevant information has been stored, call the video
    // port driver to do the initialization.
    //

    hwInitData.AdapterInterfaceType = Isa;

    initializationStatus = VideoPortInitialize(Context1,
                                               Context2,
                                               &hwInitData,
                                               NULL);
    if (initializationStatus == NO_ERROR)
    {
        return initializationStatus;
    }

    hwInitData.AdapterInterfaceType = PCIBus;

    initializationStatus = VideoPortInitialize(Context1,
                                               Context2,
                                               &hwInitData,
                                               NULL);

    if (initializationStatus == NO_ERROR)
    {
        return initializationStatus;
    }

    hwInitData.AdapterInterfaceType = Eisa;

    initializationStatus = VideoPortInitialize(Context1,
                                               Context2,
                                               &hwInitData,
                                               NULL);

    if (initializationStatus == NO_ERROR)
    {
        return initializationStatus;
    }

    hwInitData.AdapterInterfaceType = MicroChannel;

    initializationStatus = VideoPortInitialize(Context1,
                                               Context2,
                                               &hwInitData,
                                               NULL);

    if (initializationStatus == NO_ERROR)
    {
        return initializationStatus;
    }

    //
    // For MIPS ACER machines
    //
    // *** Must keep this at the end since it will cause the global access
    // range structure to change in the driver. ***
    //

    hwInitData.AdapterInterfaceType = Internal;

    initializationStatus = VideoPortInitialize(Context1,
                                               Context2,
                                               &hwInitData,
                                               NULL);

    return initializationStatus;

} // end DriverEntry()

VP_STATUS
GetDeviceDataCallback(
    PVOID HwDeviceExtension,
    PVOID Context,
    VIDEO_DEVICE_DATA_TYPE DeviceDataType,
    PVOID Identifier,
    ULONG IdentifierLength,
    PVOID ConfigurationData,
    ULONG ConfigurationDataLength,
    PVOID ComponentInformation,
    ULONG ComponentInformationLength
    )
{
    PVIDEO_ACCESS_RANGE accessRange = Context;
    PVIDEO_HARDWARE_CONFIGURATION_DATA configData = ConfigurationData;
    ULONG i;

    VideoDebugPrint((2, "VGA: controller information is present\n"));

    //
    // We do not want to try to detect the vga if there isn't one present.
    // (Kind of a paradox?)  The only MIPS box I am aware of which has
    // an vga on the internal bus is the NeTPower NeTstation 100 and the Acer.
    // It has an identifier of "ALI_S3".
    //

    if (!Identifier)
    {
        return ERROR_DEV_NOT_EXIST;
    }

    if (VideoPortCompareMemory(L"ALI_S3",
                               Identifier,
                               sizeof(L"ALI_S3")) != sizeof(L"ALI_S3"))
    {
        return ERROR_DEV_NOT_EXIST;
    }


    //
    // Now lets get the base for the IO ports and memory location out of the
    // configuration information.
    //

    VideoDebugPrint((2, "VGA: Internal Bus, get new IO bases\n"));

    //
    // For MIPS machine with an Internal Bus, adjust the access ranges.
    //

    VideoDebugPrint((3, "VGA: FrameBase Offset = %08lx\n", configData->FrameBase));
    VideoDebugPrint((3, "VGA: IoBase Offset = %08lx\n", configData->ControlBase));

    for (i=0; i < NUM_VGA_ACCESS_RANGES; i++)
    {
        if (accessRange[i].RangeInIoSpace)
        {
            accessRange[i].RangeStart.LowPart += configData->ControlBase;
            accessRange[i].RangeInIoSpace = 0;
        }
        else
        {
            accessRange[i].RangeStart.LowPart += configData->FrameBase;
        }
    }

    return NO_ERROR;

} //end GetDeviceDataCallback()

#if !defined(PLUG_AND_PLAY)

VP_STATUS
VgaAcquireResources(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    )

/*++

Routine Description:

    This routine tries to acquire the vga resources.

Arguments:

    Pointer to HwDeviceExtension

Returns:

    Status code indicating whether or not the resources where acquired.

--*/

{
    VP_STATUS status;
    ULONG i, NumVgaAccessRanges = NUM_VGA_ACCESS_RANGES;

    //
    // We only want the vga to claim resources if it loaded because
    // no other drivers were present.  If other drivers were present,
    // and claimed VGA resources, then we should only function as a
    // vga compatible driver (provide full screen support).
    //
    // We'll do the following:
    //
    // (1) We'll try to grab VGA resources exclusively.
    //
    // (2) If we get the resources then we are operating as the fall
    //     back device.  No other video drivers loaded.  Keep resources.
    //
    // (3) If we do not get the resources exclusively, try to claim
    //     them shared.
    //
    // (4) If we get the resources then we are loading to provide vga
    //     full screen support.  Free the resource so that we aren't
    //     holding legacy resources (so system can sleep/undock/etc).
    //
    // (5) If we still couldn't get the resources, then fail to load!
    //

    for (i=0; i<NUM_VGA_ACCESS_RANGES; i++) {
        VgaAccessRange[i].RangeShareable = FALSE;
    }

    status = VideoPortVerifyAccessRanges(HwDeviceExtension,
                                         NumVgaAccessRanges,
                                         VgaAccessRange);

    if (status != NO_ERROR) {

        //
        // Deal with the fact that the ATI HACK doesn't work
        // if the device is on the other side of a PCI bridge.
        //

        NumVgaAccessRanges -= 2;

        status = VideoPortVerifyAccessRanges(HwDeviceExtension,
                                             NumVgaAccessRanges,
                                             VgaAccessRange);

        if (status != NO_ERROR) {

            //
            // We couldn't get the resource exclusively.  Try to get
            // them shared.
            //

            for (i=0; i<NumVgaAccessRanges; i++) {
                VgaAccessRange[i].RangeShareable = TRUE;
            }

            status = VideoPortVerifyAccessRanges(HwDeviceExtension,
                                                 NumVgaAccessRanges,
                                                 VgaAccessRange);

            if (status == NO_ERROR) {

                //
                // We were able to get the resource shared so we must be
                // providing vga full screen support.  Release our claim
                // on resources.
                //

                VideoPortVerifyAccessRanges(HwDeviceExtension,
                                            0,
                                            NULL);


                return NO_ERROR;

            } else {

                //
                // If we haven't gotten the resources by now, that means we
                // couldn't get them shared.  This means we can't load at all.
                //

                return status;
            }
        }
    }

    //
    // We got the resources exclusively which means we are acting
    // as a fall back driver.  But lets claim the resources as
    // shared so that a PnP Driver that uses the resources can still
    // load.
    //

    for (i=0; i<NumVgaAccessRanges; i++) {
        VgaAccessRange[i].RangeShareable = TRUE;
    }

    status = VideoPortVerifyAccessRanges(HwDeviceExtension,
                                         NumVgaAccessRanges,
                                         VgaAccessRange);

    return status;
}

#endif


VP_STATUS
VgaFindAdapter(
    PVOID HwDeviceExtension,
    PVOID HwContext,
    PWSTR ArgumentString,
    PVIDEO_PORT_CONFIG_INFO ConfigInfo,
    PUCHAR Again
    )

/*++

Routine Description:

    This routine is called to determine if the adapter for this driver
    is present in the system.
    If it is present, the function fills out some information describing
    the adapter.

Arguments:

    HwDeviceExtension - Supplies the miniport driver's adapter storage. This
        storage is initialized to zero before this call.

    HwContext - Supplies the context value which was passed to
        VideoPortInitialize().

    ArgumentString - Supplies a NULL terminated ASCII string. This string
        originates from the user.

    ConfigInfo - Returns the configuration information structure which is
        filled by the miniport driver. This structure is initialized with
        any known configuration information (such as SystemIoBusNumber) by
        the port driver. Where possible, drivers should have one set of
        defaults which do not require any supplied configuration information.

    Again - Indicates if the miniport driver wants the port driver to call
        its VIDEO_HW_FIND_ADAPTER function again with a new device extension
        and the same config info. This is used by the miniport drivers which
        can search for several adapters on a bus.

Return Value:

    This routine must return:

    NO_ERROR - Indicates a host adapter was found and the
        configuration information was successfully determined.

    ERROR_INVALID_PARAMETER - Indicates an adapter was found but there was an
        error obtaining the configuration information. If possible an error
        should be logged.

    ERROR_DEV_NOT_EXIST - Indicates no host adapter was found for the
        supplied configuration information.

--*/

{

    PHW_DEVICE_EXTENSION hwDeviceExtension = HwDeviceExtension;
    VP_STATUS status;

#if defined(PLUG_AND_PLAY)
    ULONG VgaStatus;
#endif

    //
    // Make sure the size of the structure is at least as large as what we
    // are expecting (check version of the config info structure).
    //

    if (ConfigInfo->Length < sizeof(VIDEO_PORT_CONFIG_INFO)) {

        return ERROR_INVALID_PARAMETER;

    }

    //
    // Make sure we only load one copy of the vga driver
    //

    if (VgaLoaded) {

        return ERROR_DEV_NOT_EXIST;

    }

    //
    // No interrupt information is necessary.
    //

    if (ConfigInfo->AdapterInterfaceType == Internal) {

        //
        // First check if there is a video adapter on the internal bus.
        // Exit right away if there is not.
        //

        if (NO_ERROR != VideoPortGetDeviceData(hwDeviceExtension,
                                               VpControllerData,
                                               &GetDeviceDataCallback,
                                               VgaAccessRange)) {

            VideoDebugPrint((2, "VGA: VideoPort get controller info failed\n"));

            return ERROR_INVALID_PARAMETER;

        }

    }

#if !defined(PLUG_AND_PLAY)

    //
    // If this is a Plug and Play driver, then we got our resources from
    // Plug and Play.  If we are a legacy driver, we need to report our
    // resources here.
    //

    status = VgaAcquireResources(hwDeviceExtension);

    if (status != NO_ERROR) {
        return status;
    }

#endif


    //
    // Get logical IO port addresses.
    //

    if ( (hwDeviceExtension->IOAddress =
              VideoPortGetDeviceBase(hwDeviceExtension,
                                     VgaAccessRange->RangeStart,
                                     VGA_MAX_IO_PORT - VGA_BASE_IO_PORT + 1,
                                     VgaAccessRange->RangeInIoSpace)) == NULL) {

        VideoDebugPrint((2, "VgaFindAdapter - Fail to get io address\n"));

        return ERROR_INVALID_PARAMETER;

    }

#if !defined(PLUG_AND_PLAY)

    //
    // Determine whether a VGA is present.
    //

    if (!VgaIsPresent(hwDeviceExtension)) {

        return ERROR_DEV_NOT_EXIST;

    }

#else

    //
    // If we are running as a Plug and Play driver, then make sure we
    // aren't being loaded for a disabled device.  If the device is
    // disabled, then fail to load.
    //

    VideoPortGetVgaStatus(hwDeviceExtension, &VgaStatus);

    if (VgaStatus == 0) {

        return ERROR_DEV_NOT_EXIST;
    }

#endif

    //
    // Pass a pointer to the emulator range we are using.
    //

    ConfigInfo->NumEmulatorAccessEntries = VGA_NUM_EMULATOR_ACCESS_ENTRIES;
    ConfigInfo->EmulatorAccessEntries = VgaEmulatorAccessEntries;
    ConfigInfo->EmulatorAccessEntriesContext = (ULONG_PTR) hwDeviceExtension;

    ConfigInfo->VdmPhysicalVideoMemoryAddress = VgaAccessRange[VGA_MEMORY].RangeStart;
    ConfigInfo->VdmPhysicalVideoMemoryLength = VgaAccessRange[VGA_MEMORY].RangeLength;

    //
    // Minimum size of the buffer required to store the hardware state
    // information returned by IOCTL_VIDEO_SAVE_HARDWARE_STATE.
    //

    ConfigInfo->HardwareStateSize = VGA_TOTAL_STATE_SIZE;

    //
    // Map the video memory into the system virtual address space so we can
    // clear it out and use it for save and restore.
    //

    if ( (hwDeviceExtension->VideoMemoryAddress =
              VideoPortGetDeviceBase(hwDeviceExtension,
              VgaAccessRange[VGA_MEMORY].RangeStart,
              VgaAccessRange[VGA_MEMORY].RangeLength, FALSE)) == NULL) {

        VideoDebugPrint((1, "VgaFindAdapter - Fail to get memory address\n"));

        return ERROR_INVALID_PARAMETER;

    }

    //
    // Indicate we do not wish to be called again for another initialization.
    //

    *Again = 0;

    //
    // Keep track of if we already got loaded, since we can be called back
    // for a secondary bus (some machines have 2 PCI buses).
    // If *we* acquired the resources, then we won't conflict with ourselves
    // since we grabbed the resources as shared.
    //

    VgaLoaded = 1;

    //
    // Indicate a successful completion status.
    //

    return NO_ERROR;

} // VgaFindAdapter()

BOOLEAN
VgaInitialize(
    PVOID HwDeviceExtension
    )

/*++

Routine Description:

    This routine does one time initialization of the device.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's adapter information.

Return Value:

    None.

--*/

{
    PHW_DEVICE_EXTENSION hwDeviceExtension = HwDeviceExtension;
    VIDEO_X86_BIOS_ARGUMENTS biosArguments;
    VP_STATUS Status;

    //
    // set up the default cursor position and type.
    //

    hwDeviceExtension->CursorPosition.Column = 0;
    hwDeviceExtension->CursorPosition.Row = 0;
    hwDeviceExtension->CursorTopScanLine = 0;
    hwDeviceExtension->CursorBottomScanLine = 31;
    hwDeviceExtension->CursorEnable = TRUE;

    InitializeModeTable(hwDeviceExtension);

#if defined(PLUG_AND_PLAY)

    //
    // Set initial monitor power state
    //

    hwDeviceExtension->MonitorPowerState = VideoPowerOn;

    //
    // Retrieve and cache away the monitor power states we support
    //

    VideoPortZeroMemory(&biosArguments, sizeof(VIDEO_X86_BIOS_ARGUMENTS));

    biosArguments.Eax = VESA_POWER_FUNCTION;
    biosArguments.Ebx = VESA_GET_POWER_FUNC;

    Status = VideoPortInt10(HwDeviceExtension, &biosArguments);

    if ((Status == NO_ERROR) &&
        VESA_SUCCESS(biosArguments.Eax)) {

        hwDeviceExtension->MonitorPowerCapabilities = biosArguments.Ebx;
    }

    VgaInitializeSpecialCase(HwDeviceExtension);

#endif

    return TRUE;

} // VgaInitialize()

BOOLEAN
VgaStartIO(
    PVOID HwDeviceExtension,
    PVIDEO_REQUEST_PACKET RequestPacket
    )

/*++

Routine Description:

    This routine is the main execution routine for the miniport driver. It
    acceptss a Video Request Packet, performs the request, and then returns
    with the appropriate status.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's adapter information.

    RequestPacket - Pointer to the video request packet. This structure
        contains all the parameters passed to the VideoIoControl function.

Return Value:

    This routine will return error codes from the various support routines
    and will also return ERROR_INSUFFICIENT_BUFFER for incorrectly sized
    buffers and ERROR_INVALID_FUNCTION for unsupported functions.

--*/

{
    PHW_DEVICE_EXTENSION hwDeviceExtension = HwDeviceExtension;
    VP_STATUS status;
    VIDEO_MODE videoMode;
    PVIDEO_MEMORY_INFORMATION memoryInformation;
    ULONG inIoSpace;

#if DBG
    //
    // Keep a history of the commands.
    // This will help track down the chip being in a DOS session while
    // GDI and the S3 display driver "think" it's in GUI mode.

    gaIOControlCode[giControlCode++] = RequestPacket->IoControlCode;
    giControlCode                   %= MAX_CONTROL_HISTORY;
#endif

    //
    // Switch on the IoContolCode in the RequestPacket. It indicates which
    // function must be performed by the driver.
    //

    switch (RequestPacket->IoControlCode) {


    case IOCTL_VIDEO_MAP_VIDEO_MEMORY:

        VideoDebugPrint((2, "VgaStartIO - MapVideoMemory\n"));

        if ( (RequestPacket->OutputBufferLength <
              (RequestPacket->StatusBlock->Information =
                                     sizeof(VIDEO_MEMORY_INFORMATION))) ||
             (RequestPacket->InputBufferLength < sizeof(VIDEO_MEMORY)) ) {

            status = ERROR_INSUFFICIENT_BUFFER;
        }

        memoryInformation = RequestPacket->OutputBuffer;

        memoryInformation->VideoRamBase = ((PVIDEO_MEMORY)
                (RequestPacket->InputBuffer))->RequestedVirtualAddress;

        memoryInformation->VideoRamLength =
                hwDeviceExtension->PhysicalVideoMemoryLength;

        inIoSpace = 0;

#if defined(PLUG_AND_PLAY)

        //
        // Let try to take advantage of write combining if using a VESA mode.
        //
        // We only do this for the PnP version of the VGA driver because,
        // the videoprt can only detect if we can safely do USWC when we
        // use a PnP driver.
        //
        // We'll also only do this if we are using a linear frame buffer
        // because the Intel i810 hard hangs if you try to use USWC on it's
        // banked frame buffer.
        //

        if (IS_LINEAR_MODE(hwDeviceExtension->CurrentMode)) {
            inIoSpace |= VIDEO_MEMORY_SPACE_P6CACHE;
        }
#endif

        status = VideoPortMapMemory(hwDeviceExtension,
                                    hwDeviceExtension->PhysicalVideoMemoryBase,
                                    &(memoryInformation->VideoRamLength),
                                    &inIoSpace,
                                    &(memoryInformation->VideoRamBase));

        memoryInformation->FrameBufferBase =
                ((PUCHAR) (memoryInformation->VideoRamBase)) +
                hwDeviceExtension->PhysicalFrameBaseOffset.LowPart;

        memoryInformation->FrameBufferLength =
            hwDeviceExtension->PhysicalFrameLength;


        break;


    case IOCTL_VIDEO_UNMAP_VIDEO_MEMORY:

        VideoDebugPrint((2, "VgaStartIO - UnMapVideoMemory\n"));

        if (RequestPacket->InputBufferLength < sizeof(VIDEO_MEMORY)) {

            status = ERROR_INSUFFICIENT_BUFFER;
        }

        status = VideoPortUnmapMemory(hwDeviceExtension,
                                      ((PVIDEO_MEMORY)
                                       (RequestPacket->InputBuffer))->
                                           RequestedVirtualAddress,
                                      0);

        break;


    case IOCTL_VIDEO_QUERY_AVAIL_MODES:

        VideoDebugPrint((2, "VgaStartIO - QueryAvailableModes\n"));

        RequestPacket->StatusBlock->Information = 0;
        status = VgaQueryAvailableModes(hwDeviceExtension,
                                        (PVIDEO_MODE_INFORMATION)
                                            RequestPacket->OutputBuffer,
                                        RequestPacket->OutputBufferLength,
                                        (PULONG)(&RequestPacket->StatusBlock->Information));

        break;


    case IOCTL_VIDEO_QUERY_NUM_AVAIL_MODES:

        VideoDebugPrint((2, "VgaStartIO - QueryNumAvailableModes\n"));

        RequestPacket->StatusBlock->Information = 0;
        status = VgaQueryNumberOfAvailableModes(hwDeviceExtension,
                                                (PVIDEO_NUM_MODES)
                                                    RequestPacket->OutputBuffer,
                                                RequestPacket->OutputBufferLength,
                                                (PULONG)(&RequestPacket->StatusBlock->Information));

        break;


    case IOCTL_VIDEO_QUERY_CURRENT_MODE:

        VideoDebugPrint((2, "VgaStartIO - QueryCurrentMode\n"));

        RequestPacket->StatusBlock->Information = 0;
        status = VgaQueryCurrentMode(hwDeviceExtension,
                                     (PVIDEO_MODE_INFORMATION) RequestPacket->OutputBuffer,
                                     RequestPacket->OutputBufferLength,
                                     (PULONG)(&RequestPacket->StatusBlock->Information));

        break;


    case IOCTL_VIDEO_SET_CURRENT_MODE:

        VideoDebugPrint((2, "VgaStartIO - SetCurrentModes\n"));

        {
            ULONG FrameBufferIsMoved = 0;

            status = VgaSetMode(hwDeviceExtension,
                                (PVIDEO_MODE) RequestPacket->InputBuffer,
                                RequestPacket->InputBufferLength,
                                &FrameBufferIsMoved);

            if (RequestPacket->OutputBufferLength >= sizeof(ULONG)) {

                RequestPacket->StatusBlock->Information = sizeof(ULONG);
                *(PULONG)RequestPacket->OutputBuffer = FrameBufferIsMoved;
            }
        }

        break;


    case IOCTL_VIDEO_RESET_DEVICE:

        VideoDebugPrint((2, "VgaStartIO - Reset Device\n"));

        videoMode.RequestedMode = DEFAULT_MODE;

        {
            ULONG FrameBufferIsMoved = 0;

            status = VgaSetMode(hwDeviceExtension,
                                (PVIDEO_MODE) &videoMode,
                                sizeof(videoMode),
                                &FrameBufferIsMoved);
        }

        break;


    case IOCTL_VIDEO_LOAD_AND_SET_FONT:

        VideoDebugPrint((2, "VgaStartIO - LoadAndSetFont\n"));

        status = VgaLoadAndSetFont(hwDeviceExtension,
                                   (PVIDEO_LOAD_FONT_INFORMATION) RequestPacket->InputBuffer,
                                   RequestPacket->InputBufferLength);

        break;


    case IOCTL_VIDEO_QUERY_CURSOR_POSITION:

        VideoDebugPrint((2, "VgaStartIO - QueryCursorPosition\n"));

        RequestPacket->StatusBlock->Information = 0;
        status = VgaQueryCursorPosition(hwDeviceExtension,
                                        (PVIDEO_CURSOR_POSITION) RequestPacket->OutputBuffer,
                                        RequestPacket->OutputBufferLength,
                                        (PULONG)(&RequestPacket->StatusBlock->Information));

        break;


    case IOCTL_VIDEO_SET_CURSOR_POSITION:

        VideoDebugPrint((2, "VgaStartIO - SetCursorPosition\n"));

        status = VgaSetCursorPosition(hwDeviceExtension,
                                      (PVIDEO_CURSOR_POSITION)
                                          RequestPacket->InputBuffer,
                                      RequestPacket->InputBufferLength);

        break;


    case IOCTL_VIDEO_QUERY_CURSOR_ATTR:

        VideoDebugPrint((2, "VgaStartIO - QueryCursorAttributes\n"));

        RequestPacket->StatusBlock->Information = 0;
        status = VgaQueryCursorAttributes(hwDeviceExtension,
                                          (PVIDEO_CURSOR_ATTRIBUTES) RequestPacket->OutputBuffer,
                                          RequestPacket->OutputBufferLength,
                                          (PULONG)(&RequestPacket->StatusBlock->Information));

        break;


    case IOCTL_VIDEO_SET_CURSOR_ATTR:

        VideoDebugPrint((2, "VgaStartIO - SetCursorAttributes\n"));

        status = VgaSetCursorAttributes(hwDeviceExtension,
                                        (PVIDEO_CURSOR_ATTRIBUTES) RequestPacket->InputBuffer,
                                        RequestPacket->InputBufferLength);

        break;


    case IOCTL_VIDEO_SET_PALETTE_REGISTERS:

        VideoDebugPrint((2, "VgaStartIO - SetPaletteRegs\n"));

        status = VgaSetPaletteReg(hwDeviceExtension,
                                  (PVIDEO_PALETTE_DATA) RequestPacket->InputBuffer,
                                  RequestPacket->InputBufferLength);

        break;


    case IOCTL_VIDEO_SET_COLOR_REGISTERS:

        VideoDebugPrint((2, "VgaStartIO - SetColorRegs\n"));

        status = VgaSetColorLookup(hwDeviceExtension,
                                   (PVIDEO_CLUT) RequestPacket->InputBuffer,
                                   RequestPacket->InputBufferLength);

        break;


    case IOCTL_VIDEO_ENABLE_VDM:

        VideoDebugPrint((2, "VgaStartIO - EnableVDM\n"));

        hwDeviceExtension->TrappedValidatorCount = 0;
        hwDeviceExtension->SequencerAddressValue = 0;

        hwDeviceExtension->CurrentNumVdmAccessRanges =
            NUM_MINIMAL_VGA_VALIDATOR_ACCESS_RANGE;
        hwDeviceExtension->CurrentVdmAccessRange =
            MinimalVgaValidatorAccessRange;

        VideoPortSetTrappedEmulatorPorts(hwDeviceExtension,
                                         hwDeviceExtension->CurrentNumVdmAccessRanges,
                                         hwDeviceExtension->CurrentVdmAccessRange);

        status = NO_ERROR;

        break;


    case IOCTL_VIDEO_RESTORE_HARDWARE_STATE:

        VideoDebugPrint((2, "VgaStartIO - RestoreHardwareState\n"));

        try {

            if(IsSavedModeVesa((PVIDEO_HARDWARE_STATE) RequestPacket->InputBuffer)){

                status = VesaRestoreHardwareState(hwDeviceExtension,
                                                  (PVIDEO_HARDWARE_STATE) RequestPacket->InputBuffer,
                                                  RequestPacket->InputBufferLength);
            } else {

                status = VgaRestoreHardwareState(hwDeviceExtension,
                                                 (PVIDEO_HARDWARE_STATE) RequestPacket->InputBuffer,
                                                 RequestPacket->InputBufferLength);
            }
        } 
        except (1) {

            status = ERROR_INVALID_PARAMETER;
        }

        break;


    case IOCTL_VIDEO_SAVE_HARDWARE_STATE:

        VideoDebugPrint((2, "VgaStartIO - SaveHardwareState\n"));

        RequestPacket->StatusBlock->Information = 0;

        {
            USHORT ModeNumber;
    
            ModeNumber = VBEGetMode(hwDeviceExtension);

            try {

                if (ModeNumber & 0x100) {
    
                    status = VesaSaveHardwareState(hwDeviceExtension,
                                                  (PVIDEO_HARDWARE_STATE) RequestPacket->OutputBuffer,
                                                  RequestPacket->OutputBufferLength,
                                                  ModeNumber);
                } else {

                    status = VgaSaveHardwareState(hwDeviceExtension,
                                                  (PVIDEO_HARDWARE_STATE) RequestPacket->OutputBuffer,
                                                  RequestPacket->OutputBufferLength,
                                                  (PULONG)(&RequestPacket->StatusBlock->Information));
                }

            } except (1) {  

                status = ERROR_INVALID_PARAMETER;
            }
        }

        break;

    case IOCTL_VIDEO_GET_BANK_SELECT_CODE:

        VideoDebugPrint((2, "VgaStartIO - GetBankSelectCode\n"));

        RequestPacket->StatusBlock->Information = 0;
        status = VgaGetBankSelectCode(hwDeviceExtension,
                                        (PVIDEO_BANK_SELECT) RequestPacket->OutputBuffer,
                                        RequestPacket->OutputBufferLength,
                                        (PULONG)(&RequestPacket->StatusBlock->Information));

        break;

    case IOCTL_VIDEO_QUERY_PUBLIC_ACCESS_RANGES:

        VideoDebugPrint((2, "VgaStartIO - Query Public Address Ranges\n"));

        if (RequestPacket->OutputBufferLength <
            (RequestPacket->StatusBlock->Information =
                                 sizeof(VIDEO_PUBLIC_ACCESS_RANGES)) )
        {
            status = ERROR_INSUFFICIENT_BUFFER;
        }
        else
        {
            PVIDEO_PUBLIC_ACCESS_RANGES publicAccessRanges;
            PHYSICAL_ADDRESS PhysicalRegisterAddress;
            ULONG RegisterLength;
            PVOID MappedAddress;

            publicAccessRanges = RequestPacket->OutputBuffer;

            PhysicalRegisterAddress.LowPart = VGA_END_BREAK_PORT;
            PhysicalRegisterAddress.HighPart = 0;
            RegisterLength = VGA_MAX_IO_PORT - VGA_END_BREAK_PORT;
            publicAccessRanges->InIoSpace = TRUE;
            MappedAddress = NULL;

            status = VideoPortMapMemory(
                                HwDeviceExtension,
                                PhysicalRegisterAddress,
                                &RegisterLength,
                                &(publicAccessRanges->InIoSpace),
                                &MappedAddress
                                );

            publicAccessRanges->VirtualAddress = (PVOID)((ULONG_PTR)MappedAddress - VGA_END_BREAK_PORT);
        }

        break;

    case IOCTL_VIDEO_FREE_PUBLIC_ACCESS_RANGES:

        VideoDebugPrint((2, "VgaStartIO - Free Public Address Ranges\n"));

        if (RequestPacket->InputBufferLength < sizeof(VIDEO_MEMORY))
        {
            status = ERROR_INSUFFICIENT_BUFFER;
        }
        else
        {
            PVIDEO_MEMORY mappedMemory;

            mappedMemory = RequestPacket->InputBuffer;

            status = VideoPortUnmapMemory(
                          HwDeviceExtension,
                          (PVOID)((ULONG_PTR)(mappedMemory->RequestedVirtualAddress)
                                                          + VGA_END_BREAK_PORT),
                          0);
        }

        break;

    case IOCTL_VIDEO_SET_BANK_POSITION:

        VideoDebugPrint((2, "VgaStartIO - Set Bank Position\n"));

        if (RequestPacket->InputBufferLength < sizeof(BANK_POSITION)) {

            status = ERROR_INSUFFICIENT_BUFFER;

        } else {

            PBANK_POSITION BankPosition;

            BankPosition = RequestPacket->InputBuffer;

            status = VgaSetBankPosition(
                         HwDeviceExtension,
                         BankPosition);
        }

        break;

    //
    // if we get here, an invalid IoControlCode was specified.
    //

    default:

        VideoDebugPrint((1, "Fell through vga startIO routine - invalid command\n"));

        status = ERROR_INVALID_FUNCTION;

        break;

    }

#if DBG

    //
    // Keep a history of the commands.
    // This will help track down the chip being in a DOS session while
    // GDI and the S3 display driver "think" it's in GUI mode.

    gaIOControlCode[giControlCode++] = 0x00005555;
    giControlCode                   %= MAX_CONTROL_HISTORY;

#endif

    RequestPacket->StatusBlock->Status = status;

    return TRUE;

} // VgaStartIO()

//
// private routines
//

VP_STATUS
VgaLoadAndSetFont(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_LOAD_FONT_INFORMATION FontInformation,
    ULONG FontInformationSize
    )

/*++

Routine Description:

    Takes a buffer containing a user-defined font and loads it into the
    VGA soft font memory and programs the VGA to the appropriate character
    cell size.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

    FontInformation - Pointer to the structure containing the information
        about the loadable ROM font to be set.

    FontInformationSize - Length of the input buffer supplied by the user.

Return Value:

    NO_ERROR - information returned successfully

    ERROR_INSUFFICIENT_BUFFER - input buffer not large enough for input data.

    ERROR_INVALID_PARAMETER - invalid video mode

--*/

{
    PUCHAR destination;
    PUCHAR source;
    USHORT width;
    ULONG i;
    UCHAR cr9;

    //
    // check if a mode has been set
    //

    if (HwDeviceExtension->CurrentMode == NULL) {

        return ERROR_INVALID_FUNCTION;

    }

    //
    // Text mode only; If we are in a graphics mode, return an error
    //

    if (HwDeviceExtension->CurrentMode->fbType & VIDEO_MODE_GRAPHICS) {

        return ERROR_INVALID_PARAMETER;

    }

    //
    // Check if the size of the data in the input buffer is large enough
    // and that it contains all the data.
    //

    if ( (FontInformationSize < sizeof(VIDEO_LOAD_FONT_INFORMATION)) ||
         (FontInformationSize < sizeof(VIDEO_LOAD_FONT_INFORMATION) +
                        sizeof(UCHAR) * (FontInformation->FontSize - 1)) ) {

        return ERROR_INSUFFICIENT_BUFFER;

    }

    //
    // Check for the width and height of the font
    //

    if ( ((FontInformation->WidthInPixels != 8) &&
          (FontInformation->WidthInPixels != 9)) ||
         (FontInformation->HeightInPixels > 32) ) {

        return ERROR_INVALID_PARAMETER;

    }

    //
    // Check the size of the font buffer is the right size for the size
    // font being passed down.
    //

    if (FontInformation->FontSize < FontInformation->HeightInPixels * 256 *
                                    sizeof(UCHAR) ) {

        return ERROR_INSUFFICIENT_BUFFER;

    }

    //
    // Since the font parameters are valid, store the parameters in the
    // device extension and load the font.
    //

    HwDeviceExtension->FontPelRows = FontInformation->HeightInPixels;
    HwDeviceExtension->FontPelColumns = FontInformation->WidthInPixels;

    HwDeviceExtension->CurrentMode->row =
        HwDeviceExtension->CurrentMode->vres / HwDeviceExtension->FontPelRows;

    width =
      HwDeviceExtension->CurrentMode->hres / HwDeviceExtension->FontPelColumns;

    if (width < (USHORT)HwDeviceExtension->CurrentMode->col) {

        HwDeviceExtension->CurrentMode->col = width;

    }

    source = &(FontInformation->Font[0]);

    //
    // Set up the destination and source pointers for the font
    //

    destination = (PUCHAR)HwDeviceExtension->VideoMemoryAddress;

    //
    // Map font buffer at A0000
    //

    VgaInterpretCmdStream(HwDeviceExtension, EnableA000Data);

    //
    // Move the font to its destination
    //

    for (i = 1; i <= 256; i++) {

        VideoPortWriteRegisterBufferUchar(destination,
                                          source,
                                          FontInformation->HeightInPixels);

        destination += 32;
        source += FontInformation->HeightInPixels;

    }

    VgaInterpretCmdStream(HwDeviceExtension, DisableA000Color);

    //
    // Restore to a text mode.
    //

    //
    // Set Height of font.
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            CRTC_ADDRESS_PORT_COLOR, 0x9);

    cr9 = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
            CRTC_DATA_PORT_COLOR) & 0xE0;

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            CRTC_DATA_PORT_COLOR,
            (UCHAR)(cr9 | (FontInformation->HeightInPixels - 1)));

    //
    // Set Width of font.
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            CRTC_ADDRESS_PORT_COLOR, 0x12);
    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            CRTC_DATA_PORT_COLOR,
            (UCHAR)(((USHORT)FontInformation->HeightInPixels *
            (USHORT)HwDeviceExtension->CurrentMode->row) - 1));

    i = HwDeviceExtension->CurrentMode->vres /
        HwDeviceExtension->CurrentMode->row;

    //
    // Set Cursor End
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            CRTC_ADDRESS_PORT_COLOR, 0xb);
    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            CRTC_DATA_PORT_COLOR, (UCHAR)--i);

    //
    // Set Cursor Statr
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            CRTC_ADDRESS_PORT_COLOR, 0xa);
    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            CRTC_DATA_PORT_COLOR, (UCHAR)--i);

    return NO_ERROR;

} //end VgaLoadAndSetFont()

VP_STATUS
VgaQueryCursorPosition(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_CURSOR_POSITION CursorPosition,
    ULONG CursorPositionSize,
    PULONG OutputSize
    )

/*++

Routine Description:

    This routine returns the row and column of the cursor.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

    CursorPosition - Pointer to the output buffer supplied by the user. This
        is where the cursor position is stored.

    CursorPositionSize - Length of the output buffer supplied by the user.

    OutputSize - Pointer to a buffer in which to return the actual size of
        the data in the buffer. If the buffer was not large enough, this
        contains the minimum required buffer size.

Return Value:

    NO_ERROR - information returned successfully

    ERROR_INSUFFICIENT_BUFFER - output buffer not large enough to return
        any useful data

    ERROR_INVALID_PARAMETER - invalid video mode

--*/

{
    //
    // check if a mode has been set
    //

    if (HwDeviceExtension->CurrentMode == NULL) {

        return ERROR_INVALID_FUNCTION;

    }

    //
    // Text mode only; If we are in a graphics mode, return an error
    //

    if (HwDeviceExtension->CurrentMode->fbType & VIDEO_MODE_GRAPHICS) {

        *OutputSize = 0;
        return ERROR_INVALID_PARAMETER;

    }

    //
    // If the buffer passed in is not large enough return an
    // appropriate error code.
    //

    if (CursorPositionSize < (*OutputSize = sizeof(VIDEO_CURSOR_POSITION)) ) {

        *OutputSize = 0;
        return ERROR_INSUFFICIENT_BUFFER;

    }

    //
    // Store the postition of the cursor into the buffer.
    //

    CursorPosition->Column = HwDeviceExtension->CursorPosition.Column;
    CursorPosition->Row = HwDeviceExtension->CursorPosition.Row;

    return NO_ERROR;

} // end VgaQueryCursorPosition()

VP_STATUS
VgaSetCursorPosition(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_CURSOR_POSITION CursorPosition,
    ULONG CursorPositionSize
    )

/*++

Routine Description:

    This routine verifies that the requested cursor position is within
    the row and column bounds of the current mode and font. If valid, then
    it sets the row and column of the cursor.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

    CursorPosition - Pointer to the structure containing the cursor position.

    CursorPositionSize - Length of the input buffer supplied by the user.

Return Value:

    NO_ERROR - information returned successfully

    ERROR_INSUFFICIENT_BUFFER - input buffer not large enough for input data

    ERROR_INVALID_PARAMETER - invalid video mode

--*/

{
    USHORT position;

    //
    // check if a mode has been set
    //

    if (HwDeviceExtension->CurrentMode == NULL) {

        return ERROR_INVALID_FUNCTION;

    }

    //
    // Text mode only; If we are in a graphics mode, return an error
    //

    if (HwDeviceExtension->CurrentMode->fbType & VIDEO_MODE_GRAPHICS) {

        return ERROR_INVALID_PARAMETER;

    }

    //
    // Check if the size of the data in the input buffer is large enough.
    //

    if (CursorPositionSize < sizeof(VIDEO_CURSOR_POSITION)) {

            return ERROR_INSUFFICIENT_BUFFER;

    }

    //
    // Check if the new values for the cursor positions are in the valid
    // bounds for the screen.
    //

    if ((CursorPosition->Column >= HwDeviceExtension->CurrentMode->col) ||
        (CursorPosition->Row >= HwDeviceExtension->CurrentMode->row)) {

        return ERROR_INVALID_PARAMETER;

    }

    //
    // Store these new values in the device extension so we can use them in
    // a QUERY.
    //

    HwDeviceExtension->CursorPosition.Column = CursorPosition->Column;
    HwDeviceExtension->CursorPosition.Row = CursorPosition->Row;

    //
    // Calculate the position on the screen at which the cursor must be
    // be displayed
    //

    position = (USHORT) (HwDeviceExtension->CurrentMode->col *
                         CursorPosition->Row + CursorPosition->Column);


    //
    // Address Cursor Location Low Register in CRT Controller Registers
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            CRTC_ADDRESS_PORT_COLOR, IND_CURSOR_LOW_LOC);

    //
    // Set Cursor Location Low Register
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            CRTC_DATA_PORT_COLOR, (UCHAR) (position & 0x00FF));

    //
    // Address Cursor Location High Register in CRT Controller Registers
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            CRTC_ADDRESS_PORT_COLOR, IND_CURSOR_HIGH_LOC);

    //
    // Set Cursor Location High Register
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            CRTC_DATA_PORT_COLOR, (UCHAR) (position >> 8));

    return NO_ERROR;

} // end VgaSetCursorPosition()

VP_STATUS
VgaQueryCursorAttributes(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_CURSOR_ATTRIBUTES CursorAttributes,
    ULONG CursorAttributesSize,
    PULONG OutputSize
    )

/*++

Routine Description:

    This routine returns information about the height and visibility of the
    cursor.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

    CursorAttributes - Pointer to the output buffer supplied by the user.
        This is where the cursor type is stored.

    CursorAttributesSize - Length of the output buffer supplied by the user.

    OutputSize - Pointer to a buffer in which to return the actual size of
        the data in the buffer. If the buffer was not large enough, this
        contains the minimum required buffer size.

Return Value:

    NO_ERROR - information returned successfully

    ERROR_INSUFFICIENT_BUFFER - output buffer not large enough to return
        any useful data

    ERROR_INVALID_PARAMETER - invalid video mode

--*/

{
    //
    // check if a mode has been set
    //

    if (HwDeviceExtension->CurrentMode == NULL) {

        return ERROR_INVALID_FUNCTION;

    }

    //
    // Text mode only; If we are in a graphics mode, return an error
    //

    if (HwDeviceExtension->CurrentMode->fbType & VIDEO_MODE_GRAPHICS) {

        *OutputSize = 0;
        return ERROR_INVALID_PARAMETER;

    }

    //
    // Find out the size of the data to be put in the the buffer and return
    // that in the status information (whether or not the information is
    // there). If the buffer passed in is not large enough return an
    // appropriate error code.
    //

    if (CursorAttributesSize < (*OutputSize =
            sizeof(VIDEO_CURSOR_ATTRIBUTES)) ) {

        *OutputSize = 0;
        return ERROR_INSUFFICIENT_BUFFER;

    }

    //
    // Store the cursor information into the buffer.
    //

    CursorAttributes->Height = (USHORT) HwDeviceExtension->CursorTopScanLine;
    CursorAttributes->Width = (USHORT) HwDeviceExtension->CursorBottomScanLine;
    CursorAttributes->Enable = HwDeviceExtension->CursorEnable;

    return NO_ERROR;

} // end VgaQueryCursorAttributes()

VP_STATUS
VgaSetCursorAttributes(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_CURSOR_ATTRIBUTES CursorAttributes,
    ULONG CursorAttributesSize
    )

/*++

Routine Description:

    This routine verifies that the requested cursor height is within the
    bounds of the character cell. If valid, then it sets the new
    visibility and height of the cursor.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

    CursorType - Pointer to the structure containing the cursor information.

    CursorTypeSize - Length of the input buffer supplied by the user.

Return Value:

    NO_ERROR - information returned successfully

    ERROR_INSUFFICIENT_BUFFER - input buffer not large enough for input data

    ERROR_INVALID_PARAMETER - invalid video mode

--*/

{
    UCHAR cursorLine;

    //
    // check if a mode has been set
    //

    if (HwDeviceExtension->CurrentMode == NULL) {

        return ERROR_INVALID_FUNCTION;

    }

    //
    // Text mode only; If we are in a graphics mode, return an error
    //

    if (HwDeviceExtension->CurrentMode->fbType & VIDEO_MODE_GRAPHICS) {

        return ERROR_INVALID_PARAMETER;

    }

    //
    // Check if the size of the data in the input buffer is large enough.
    //

    if (CursorAttributesSize < sizeof(VIDEO_CURSOR_ATTRIBUTES)) {

            return ERROR_INSUFFICIENT_BUFFER;

    }

    //
    // Check if the new values for the cursor type are in the valid range.
    //

    if ((CursorAttributes->Height >= HwDeviceExtension->FontPelRows) ||
        (CursorAttributes->Width > 31)) {

        return ERROR_INVALID_PARAMETER;

    }

    //
    // Store the cursor information in the device extension so we can use
    // them in a QUERY.
    //

    HwDeviceExtension->CursorTopScanLine = (UCHAR) CursorAttributes->Height;
    HwDeviceExtension->CursorBottomScanLine = (UCHAR) CursorAttributes->Width;
    HwDeviceExtension->CursorEnable = CursorAttributes->Enable;

    //
    // Address Cursor Start Register in CRT Controller Registers
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                                CRTC_ADDRESS_PORT_COLOR,
                            IND_CURSOR_START);

    //
    // Set Cursor Start Register by writting to CRTCtl Data Register
    // Preserve the high three bits of this register.
    //
    // Only the Five low bits are used for the cursor height.
    // Bit 5 is cursor enable, bit 6 and 7 preserved.
    //

    cursorLine = (UCHAR) CursorAttributes->Height & 0x1F;

    cursorLine |= VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
        CRTC_DATA_PORT_COLOR) & 0xC0;

    if (!CursorAttributes->Enable) {

        cursorLine |= 0x20; // Flip cursor off bit

    }

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress + CRTC_DATA_PORT_COLOR,
                                cursorLine);

    //
    // Address Cursor End Register in CRT Controller Registers
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                                CRTC_ADDRESS_PORT_COLOR,
                            IND_CURSOR_END);

    //
    // Set Cursor End Register. Preserve the high three bits of this
    // register.
    //

    cursorLine =
        (CursorAttributes->Width < (USHORT)(HwDeviceExtension->FontPelRows - 1)) ?
        CursorAttributes->Width : (HwDeviceExtension->FontPelRows - 1);

    cursorLine &= 0x1f;

    cursorLine |= VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
            CRTC_DATA_PORT_COLOR) & 0xE0;

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress + CRTC_DATA_PORT_COLOR,
                            cursorLine);

    return NO_ERROR;

} // end VgaSetCursorAttributes()

BOOLEAN
VgaIsPresent(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    )

/*++

Routine Description:

    This routine returns TRUE if a VGA is present. Determining whether a VGA
    is present is a two-step process. First, this routine walks bits through
    the Bit Mask register, to establish that there are readable indexed
    registers (EGAs normally don't have readable registers, and other adapters
    are unlikely to have indexed registers). This test is done first because
    it's a non-destructive EGA rejection test (correctly rejects EGAs, but
    doesn't potentially mess up the screen or the accessibility of display
    memory). Normally, this would be an adequate test, but some EGAs have
    readable registers, so next, we check for the existence of the Chain4 bit
    in the Memory Mode register; this bit doesn't exist in EGAs. It's
    conceivable that there are EGAs with readable registers and a register bit
    where Chain4 is stored, although I don't know of any; if a better test yet
    is needed, memory could be written to in Chain4 mode, and then examined
    plane by plane in non-Chain4 mode to make sure the Chain4 bit did what it's
    supposed to do. However, the current test should be adequate to eliminate
    just about all EGAs, and 100% of everything else.

    If this function fails to find a VGA, it attempts to undo any damage it
    may have inadvertently done while testing. The underlying assumption for
    the damage control is that if there's any non-VGA adapter at the tested
    ports, it's an EGA or an enhanced EGA, because: a) I don't know of any
    other adapters that use 3C4/5 or 3CE/F, and b), if there are other
    adapters, I certainly don't know how to restore their original states. So
    all error recovery is oriented toward putting an EGA back in a writable
    state, so that error messages are visible. The EGA's state on entry is
    assumed to be text mode, so the Memory Mode register is restored to the
    default state for text mode.

    If a VGA is found, the VGA is returned to its original state after
    testing is finished.

Arguments:

    None.

Return Value:

    TRUE if a VGA is present, FALSE if not.

--*/

{
    UCHAR originalGCAddr;
    UCHAR originalSCAddr;
    UCHAR originalBitMask;
    UCHAR originalReadMap;
    UCHAR originalMemoryMode;
    UCHAR testMask;
    BOOLEAN returnStatus;

    //
    // Remember the original state of the Graphics Controller Address register.
    //

    originalGCAddr = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
            GRAPH_ADDRESS_PORT);

    //
    // Write the Read Map register with a known state so we can verify
    // that it isn't changed after we fool with the Bit Mask. This ensures
    // that we're dealing with indexed registers, since both the Read Map and
    // the Bit Mask are addressed at GRAPH_DATA_PORT.
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            GRAPH_ADDRESS_PORT, IND_READ_MAP);

    //
    // If we can't read back the Graphics Address register setting we just
    // performed, it's not readable and this isn't a VGA.
    //

    if ((VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
        GRAPH_ADDRESS_PORT) & GRAPH_ADDR_MASK) != IND_READ_MAP) {

        return FALSE;
    }

    //
    // Set the Read Map register to a known state.
    //

    originalReadMap = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
            GRAPH_DATA_PORT);
    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            GRAPH_DATA_PORT, READ_MAP_TEST_SETTING);

    if (VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
            GRAPH_DATA_PORT) != READ_MAP_TEST_SETTING) {

        //
        // The Read Map setting we just performed can't be read back; not a
        // VGA. Restore the default Read Map state.
        //

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                GRAPH_DATA_PORT, READ_MAP_DEFAULT);

        return FALSE;
    }

    //
    // Remember the original setting of the Bit Mask register.
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            GRAPH_ADDRESS_PORT, IND_BIT_MASK);
    if ((VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                GRAPH_ADDRESS_PORT) & GRAPH_ADDR_MASK) != IND_BIT_MASK) {

        //
        // The Graphics Address register setting we just made can't be read
        // back; not a VGA. Restore the default Read Map state.
        //

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                GRAPH_ADDRESS_PORT, IND_READ_MAP);
        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                GRAPH_DATA_PORT, READ_MAP_DEFAULT);

        return FALSE;
    }

    originalBitMask = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
            GRAPH_DATA_PORT);

    //
    // Set up the initial test mask we'll write to and read from the Bit Mask.
    //

    testMask = 0xBB;

    do {

        //
        // Write the test mask to the Bit Mask.
        //

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                GRAPH_DATA_PORT, testMask);

        //
        // Make sure the Bit Mask remembered the value.
        //

        if (VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                    GRAPH_DATA_PORT) != testMask) {

            //
            // The Bit Mask is not properly writable and readable; not a VGA.
            // Restore the Bit Mask and Read Map to their default states.
            //

            VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                    GRAPH_DATA_PORT, BIT_MASK_DEFAULT);
            VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                    GRAPH_ADDRESS_PORT, IND_READ_MAP);
            VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                    GRAPH_DATA_PORT, READ_MAP_DEFAULT);

            return FALSE;
        }

        //
        // Cycle the mask for next time.
        //

        testMask >>= 1;

    } while (testMask != 0);

    //
    // There's something readable at GRAPH_DATA_PORT; now switch back and
    // make sure that the Read Map register hasn't changed, to verify that
    // we're dealing with indexed registers.
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            GRAPH_ADDRESS_PORT, IND_READ_MAP);
    if (VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                GRAPH_DATA_PORT) != READ_MAP_TEST_SETTING) {

        //
        // The Read Map is not properly writable and readable; not a VGA.
        // Restore the Bit Mask and Read Map to their default states, in case
        // this is an EGA, so subsequent writes to the screen aren't garbled.
        //

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                GRAPH_DATA_PORT, READ_MAP_DEFAULT);
        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                GRAPH_ADDRESS_PORT, IND_BIT_MASK);
        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                GRAPH_DATA_PORT, BIT_MASK_DEFAULT);

        return FALSE;
    }

    //
    // We've pretty surely verified the existence of the Bit Mask register.
    // Put the Graphics Controller back to the original state.
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            GRAPH_DATA_PORT, originalReadMap);
    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            GRAPH_ADDRESS_PORT, IND_BIT_MASK);
    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            GRAPH_DATA_PORT, originalBitMask);
    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            GRAPH_ADDRESS_PORT, originalGCAddr);

    //
    // Now, check for the existence of the Chain4 bit.
    //

    //
    // Remember the original states of the Sequencer Address and Memory Mode
    // registers.
    //

    originalSCAddr = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
            SEQ_ADDRESS_PORT);
    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            SEQ_ADDRESS_PORT, IND_MEMORY_MODE);
    if ((VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
            SEQ_ADDRESS_PORT) & SEQ_ADDR_MASK) != IND_MEMORY_MODE) {

        //
        // Couldn't read back the Sequencer Address register setting we just
        // performed.
        //

        return FALSE;
    }
    originalMemoryMode = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
            SEQ_DATA_PORT);

    //
    // Toggle the Chain4 bit and read back the result. This must be done during
    // sync reset, since we're changing the chaining state.
    //

    //
    // Begin sync reset.
    //

    VideoPortWritePortUshort((PUSHORT)(HwDeviceExtension->IOAddress +
             SEQ_ADDRESS_PORT),
             (IND_SYNC_RESET + (START_SYNC_RESET_VALUE << 8)));

    //
    // Toggle the Chain4 bit.
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            SEQ_ADDRESS_PORT, IND_MEMORY_MODE);
    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            SEQ_DATA_PORT, (UCHAR)(originalMemoryMode ^ CHAIN4_MASK));

    if (VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                SEQ_DATA_PORT) != (UCHAR) (originalMemoryMode ^ CHAIN4_MASK)) {

        //
        // Chain4 bit not there; not a VGA.
        // Set text mode default for Memory Mode register.
        //

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                SEQ_DATA_PORT, MEMORY_MODE_TEXT_DEFAULT);
        //
        // End sync reset.
        //

        VideoPortWritePortUshort((PUSHORT) (HwDeviceExtension->IOAddress +
                SEQ_ADDRESS_PORT),
                (IND_SYNC_RESET + (END_SYNC_RESET_VALUE << 8)));

        returnStatus = FALSE;

    } else {

        //
        // It's a VGA.
        //

        //
        // Restore the original Memory Mode setting.
        //

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                SEQ_DATA_PORT, originalMemoryMode);

        //
        // End sync reset.
        //

        VideoPortWritePortUshort((PUSHORT)(HwDeviceExtension->IOAddress +
                SEQ_ADDRESS_PORT),
                (USHORT)(IND_SYNC_RESET + (END_SYNC_RESET_VALUE << 8)));

        //
        // Restore the original Sequencer Address setting.
        //

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                SEQ_ADDRESS_PORT, originalSCAddr);

        returnStatus = TRUE;
    }

    return returnStatus;

} // VgaIsPresent()

VP_STATUS
VgaSetPaletteReg(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_PALETTE_DATA PaletteBuffer,
    ULONG PaletteBufferSize
    )

/*++

Routine Description:

    This routine sets a specified portion of the EGA (not DAC) palette
    registers.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

    PaletteBuffer - Pointer to the structure containing the palette data.

    PaletteBufferSize - Length of the input buffer supplied by the user.

Return Value:

    NO_ERROR - information returned successfully

    ERROR_INSUFFICIENT_BUFFER - input buffer not large enough for input data.

    ERROR_INVALID_PARAMETER - invalid palette size.

--*/

{
    USHORT i;

    //
    // Check if the size of the data in the input buffer is large enough.
    //

    if ((PaletteBufferSize) < (sizeof(VIDEO_PALETTE_DATA)) ||
        (PaletteBufferSize < (sizeof(VIDEO_PALETTE_DATA) +
                (sizeof(USHORT) * (PaletteBuffer->NumEntries -1)) ))) {

        return ERROR_INSUFFICIENT_BUFFER;

    }

    //
    // Check to see if the parameters are valid.
    //

    if ( (PaletteBuffer->FirstEntry > VIDEO_MAX_COLOR_REGISTER ) ||
         (PaletteBuffer->NumEntries == 0) ||
         (PaletteBuffer->FirstEntry + PaletteBuffer->NumEntries >
             VIDEO_MAX_PALETTE_REGISTER + 1 ) ) {

        return ERROR_INVALID_PARAMETER;

    }

    //
    // Reset ATC to index mode
    //

    VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                           ATT_INITIALIZE_PORT_COLOR);

    //
    // Blast out our palette values.
    //

    for (i = 0; i < PaletteBuffer->NumEntries; i++) {

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress + ATT_ADDRESS_PORT,
                                (UCHAR)(i+PaletteBuffer->FirstEntry));

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                                    ATT_DATA_WRITE_PORT,
                                (UCHAR)PaletteBuffer->Colors[i]);
    }

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress + ATT_ADDRESS_PORT,
                            VIDEO_ENABLE);


    return NO_ERROR;

} // end VgaSetPaletteReg()


VP_STATUS
VgaSetColorLookup(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_CLUT ClutBuffer,
    ULONG ClutBufferSize
    )

/*++

Routine Description:

    This routine sets a specified portion of the DAC color lookup table
    settings.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

    ClutBufferSize - Length of the input buffer supplied by the user.

    ClutBuffer - Pointer to the structure containing the color lookup table.

Return Value:

    NO_ERROR - information returned successfully

    ERROR_INSUFFICIENT_BUFFER - input buffer not large enough for input data.

    ERROR_INVALID_PARAMETER - invalid clut size.

--*/

{
    USHORT i;
    BOOLEAN PaletteIsSet = FALSE;
    VP_STATUS status;

    //
    // Check if the size of the data in the input buffer is large enough.
    //

    if ( (ClutBufferSize < sizeof(VIDEO_CLUT) - sizeof(ULONG)) ||
         (ClutBufferSize < sizeof(VIDEO_CLUT) +
                     (sizeof(ULONG) * (ClutBuffer->NumEntries - 1)) ) ) {

        return ERROR_INSUFFICIENT_BUFFER;

    }

    //
    // Check to see if the parameters are valid.
    //

    if ( (ClutBuffer->NumEntries == 0) ||
         (ClutBuffer->FirstEntry > VIDEO_MAX_COLOR_REGISTER) ||
         (ClutBuffer->FirstEntry + ClutBuffer->NumEntries >
                                     VIDEO_MAX_COLOR_REGISTER + 1) ) {

        return ERROR_INVALID_PARAMETER;

    }

    if (HwDeviceExtension->CurrentMode->bitsPerPlane >= 8) {

        INT10_BIOS_ARGUMENTS BiosArguments;
        PVIDEO_PORT_INT10_INTERFACE pInt10 = &HwDeviceExtension->Int10;
        PPALETTE_ENTRY Palette = VideoPortAllocatePool(HwDeviceExtension,
                                                       VpPagedPool,
                                                       ClutBuffer->NumEntries *
                                                           sizeof(PALETTE_ENTRY),
                                                       ' agV');

        if (Palette) {

            USHORT VdmSeg;
            USHORT VdmOff;
            ULONG  Length = 0x1000;


            if (pInt10->Size && 
                pInt10->Int10AllocateBuffer(pInt10->Context,
                                            &VdmSeg,
                                            &VdmOff,
                                            &Length) == NO_ERROR) {

                for (i=0; i<ClutBuffer->NumEntries; i++) {
                    Palette[i].Blue  = ClutBuffer->LookupTable[i].RgbArray.Blue;
                    Palette[i].Green = ClutBuffer->LookupTable[i].RgbArray.Green;
                    Palette[i].Red   = ClutBuffer->LookupTable[i].RgbArray.Red;
                    Palette[i].Alignment = 0;
                }

                if( NO_ERROR == pInt10->Int10WriteMemory(pInt10->Context,
                                                         VdmSeg,
                                                         VdmOff,
                                                         Palette,
                                                         sizeof(PALETTE_ENTRY) * ClutBuffer->NumEntries)) {
	
                    BiosArguments.Eax = 0x4f09;
                    BiosArguments.Ebx = 0x0000;
                    BiosArguments.Ecx = ClutBuffer->NumEntries;
                    BiosArguments.Edx = ClutBuffer->FirstEntry;
                    BiosArguments.Edi = VdmOff;
                    BiosArguments.SegEs = VdmSeg;

                    status = pInt10->Int10CallBios(pInt10->Context, &BiosArguments);

                    if (status == NO_ERROR && VESA_SUCCESS(BiosArguments.Eax)) {
                        PaletteIsSet = TRUE;
                    }
                }

                pInt10->Int10FreeBuffer(pInt10->Context,
                                        VdmSeg,
                                        VdmOff);
            }

            VideoPortFreePool(HwDeviceExtension, Palette);
        }
    } 

    if(!PaletteIsSet && !(HwDeviceExtension->CurrentMode->NonVgaHardware)) {

        //
        //  Set CLUT registers directly on the hardware
        //

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                DAC_ADDRESS_WRITE_PORT, (UCHAR) ClutBuffer->FirstEntry);

        //
        // Now write the data entries, relying on auto-increment.
        //

        for (i = 0; i < ClutBuffer->NumEntries; i++) {

            VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                                    DAC_DATA_REG_PORT,
                                    ClutBuffer->LookupTable[i].RgbArray.Red);

            VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                                    DAC_DATA_REG_PORT,
                                    ClutBuffer->LookupTable[i].RgbArray.Green);

            VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                                    DAC_DATA_REG_PORT,
                                    ClutBuffer->LookupTable[i].RgbArray.Blue);

        }

        PaletteIsSet = TRUE;

    } 

    if(PaletteIsSet) {

        return NO_ERROR;

    } else {

        return ERROR_INVALID_PARAMETER;
    }


} // end VgaSetColorLookup()

VP_STATUS
VgaRestoreHardwareState(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_HARDWARE_STATE HardwareState,
    ULONG HardwareStateSize
    )

/*++

Routine Description:

    Restores all registers and memory of the VGA.

    Note: HardwareState points to the actual buffer from which the state
    is to be restored. This buffer will always be big enough (we specified
    the required size at DriverEntry).

    Note: The offset in the hardware state header from which each general
    register is restored is the offset of the write address of that register
    from the base I/O address of the VGA.


Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

    HardwareState - Pointer to a structure from which the saved state is to be
        restored (actually only info about and a pointer to the actual save
        buffer).

    HardwareStateSize - Length of the input buffer supplied by the user.
        (Actually only the size of the HardwareState structure, not the
        buffer it points to from which the state is actually restored. The
        pointed-to buffer is assumed to be big enough.)

Return Value:

    NO_ERROR - restore performed successfully

    ERROR_INSUFFICIENT_BUFFER - input buffer not large enough to provide data

--*/

{
    PVIDEO_HARDWARE_STATE_HEADER hardwareStateHeader;
    ULONG i;
    UCHAR dummy;
    PUCHAR pScreen;
    PUCHAR pucLatch;
    PULONG pulBuffer;
    PUCHAR port;
    PUCHAR portValue;
    PUCHAR portValueDAC;
    ULONG bIsColor;

    //
    // Check if the size of the data in the input buffer is large enough.
    //

    if ((HardwareStateSize < sizeof(VIDEO_HARDWARE_STATE)) ||
            (HardwareState->StateLength < VGA_TOTAL_STATE_SIZE)) {

            return ERROR_INSUFFICIENT_BUFFER;

    }

    //
    // Point to the buffer where the restore data is actually stored.
    //

    hardwareStateHeader = HardwareState->StateHeader;

    //
    // Make sure the offset are in the structure ...
    //

    if ((hardwareStateHeader->BasicSequencerOffset + VGA_NUM_SEQUENCER_PORTS >
            HardwareState->StateLength) ||

        (hardwareStateHeader->BasicCrtContOffset + VGA_NUM_CRTC_PORTS >
            HardwareState->StateLength) ||

        (hardwareStateHeader->BasicGraphContOffset + VGA_NUM_GRAPH_CONT_PORTS >
            HardwareState->StateLength) ||

        (hardwareStateHeader->BasicAttribContOffset + VGA_NUM_ATTRIB_CONT_PORTS >
            HardwareState->StateLength) ||

        (hardwareStateHeader->BasicDacOffset + (3 * VGA_NUM_DAC_ENTRIES) >
            HardwareState->StateLength) ||

        (hardwareStateHeader->BasicLatchesOffset + 4 >
            HardwareState->StateLength) ||

        (hardwareStateHeader->ExtendedSequencerOffset + EXT_NUM_SEQUENCER_PORTS >
            HardwareState->StateLength) ||

        (hardwareStateHeader->ExtendedCrtContOffset + EXT_NUM_CRTC_PORTS >
            HardwareState->StateLength) ||

        (hardwareStateHeader->ExtendedGraphContOffset + EXT_NUM_GRAPH_CONT_PORTS >
            HardwareState->StateLength) ||

        (hardwareStateHeader->ExtendedAttribContOffset + EXT_NUM_ATTRIB_CONT_PORTS >
            HardwareState->StateLength) ||

        (hardwareStateHeader->ExtendedDacOffset + (4 * EXT_NUM_DAC_ENTRIES) >
            HardwareState->StateLength) ||

        //
        // Only check the validator state offset if there is unemulated data.
        //

        ((hardwareStateHeader->VGAStateFlags & VIDEO_STATE_UNEMULATED_VGA_STATE) &&
            (hardwareStateHeader->ExtendedValidatorStateOffset + VGA_VALIDATOR_AREA_SIZE >
            HardwareState->StateLength)) ||

        (hardwareStateHeader->ExtendedMiscDataOffset + VGA_MISC_DATA_AREA_OFFSET >
            HardwareState->StateLength) ||

        (hardwareStateHeader->Plane1Offset + hardwareStateHeader->PlaneLength >
            HardwareState->StateLength) ||

        (hardwareStateHeader->Plane2Offset + hardwareStateHeader->PlaneLength >
            HardwareState->StateLength) ||

        (hardwareStateHeader->Plane3Offset + hardwareStateHeader->PlaneLength >
            HardwareState->StateLength) ||

        (hardwareStateHeader->Plane4Offset + hardwareStateHeader->PlaneLength >
            HardwareState->StateLength) ||

        (hardwareStateHeader->DIBOffset +
            hardwareStateHeader->DIBBitsPerPixel / 8 *
            hardwareStateHeader->DIBXResolution *
            hardwareStateHeader->DIBYResolution  > HardwareState->StateLength) ||

        (hardwareStateHeader->DIBXlatOffset + hardwareStateHeader->DIBXlatLength >
            HardwareState->StateLength)) {

        return ERROR_INVALID_PARAMETER;

    }

    //
    // Turn off the screen to avoid flickering. The screen will turn back on
    // when we restore the DAC state at the end of this routine.
    //

    //
    // Set DAC register 0 to display black.
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            DAC_ADDRESS_WRITE_PORT, 0);
    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            DAC_DATA_REG_PORT, 0);
    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            DAC_DATA_REG_PORT, 0);
    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            DAC_DATA_REG_PORT, 0);

    //
    // Set the DAC mask register to force DAC register 0 to display all the
    // time (this is the register we just set to display black). From now on,
    // nothing but black will show up on the screen.
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            DAC_PIXEL_MASK_PORT, 0);


    //
    // Restore the latches and the contents of display memory.
    //
    // Set up the VGA's hardware to allow us to copy to each plane in turn.
    //
    // Begin sync reset.
    //

    VideoPortWritePortUshort((PUSHORT) (HwDeviceExtension->IOAddress +
            SEQ_ADDRESS_PORT),
            (USHORT) (IND_SYNC_RESET + (START_SYNC_RESET_VALUE << 8)));

    //
    // Turn off Chain mode and map display memory at A0000 for 64K.
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            GRAPH_ADDRESS_PORT, IND_GRAPH_MISC);
    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            GRAPH_DATA_PORT, (UCHAR) ((VideoPortReadPortUchar(
            HwDeviceExtension->IOAddress + GRAPH_DATA_PORT) & 0xF1) | 0x04));

    //
    // Turn off Chain4 mode and odd/even.
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            SEQ_ADDRESS_PORT, IND_MEMORY_MODE);
    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            SEQ_DATA_PORT,
            (UCHAR) ((VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
            SEQ_DATA_PORT) & 0xF3) | 0x04));

    //
    // End sync reset.
    //

    VideoPortWritePortUshort((PUSHORT) (HwDeviceExtension->IOAddress +
            SEQ_ADDRESS_PORT), (USHORT) (IND_SYNC_RESET +
            (END_SYNC_RESET_VALUE << 8)));

    //
    // Set the write mode to 0, the read mode to 0, and turn off odd/even.
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            GRAPH_ADDRESS_PORT, IND_GRAPH_MODE);
    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            GRAPH_DATA_PORT,
            (UCHAR) ((VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
            GRAPH_DATA_PORT) & 0xE4) | 0x00));

    //
    // Set the Bit Mask to 0xFF to allow all CPU bits through.
    //

    VideoPortWritePortUshort((PUSHORT) (HwDeviceExtension->IOAddress +
            GRAPH_ADDRESS_PORT), (USHORT) (IND_BIT_MASK + (0xFF << 8)));

    //
    // Set the Data Rotation and Logical Function fields to 0 to allow CPU
    // data through unmodified.
    //

    VideoPortWritePortUshort((PUSHORT)(HwDeviceExtension->IOAddress +
            GRAPH_ADDRESS_PORT), (USHORT) (IND_DATA_ROTATE + (0 << 8)));

    //
    // Set Set/Reset Enable to 0 to select CPU data for all planes.
    //

    VideoPortWritePortUshort((PUSHORT) (HwDeviceExtension->IOAddress +
            GRAPH_ADDRESS_PORT), (USHORT) (IND_SET_RESET_ENABLE + (0 << 8)));

    //
    // Point the Sequencer Index to the Map Mask register.
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
             SEQ_ADDRESS_PORT, IND_MAP_MASK);

    //
    // Restore the latches.
    //
    // Point to the saved data for the first latch.
    //

    pucLatch = ((PUCHAR) (hardwareStateHeader)) +
            hardwareStateHeader->BasicLatchesOffset;

    //
    // Point to first byte of display memory.
    //

    pScreen = (PUCHAR) HwDeviceExtension->VideoMemoryAddress;

    //
    // Write the contents to be restored to each of the four latches in turn.
    //

    for (i = 0; i < 4; i++) {

        //
        // Set the Map Mask to select the plane we want to restore next.
        //

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                SEQ_DATA_PORT, (UCHAR)(1<<i));

        //
        // Write this plane's latch.
        //

        VideoPortWriteRegisterUchar(pScreen, *pucLatch++);

    }

    //
    // Read the latched data into the latches, and the latches are set.
    //

    dummy = VideoPortReadRegisterUchar(pScreen);


    //
    // Point to the offset of the saved data for the first plane.
    //

    pulBuffer = &(hardwareStateHeader->Plane1Offset);

    //
    // Restore each of the four planes in turn.
    //

    for (i = 0; i < 4; i++) {

        //
        // Set the Map Mask to select the plane we want to restore next.
        //

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                SEQ_DATA_PORT, (UCHAR)(1<<i));

        //
        // Restore this plane from the buffer.
        //

        VideoPortMoveMemory((PUCHAR) HwDeviceExtension->VideoMemoryAddress,
                           ((PUCHAR) (hardwareStateHeader)) + *pulBuffer,
                           hardwareStateHeader->PlaneLength);

        pulBuffer++;

    }

    //
    // If we have some unemulated data, put it back into the buffer
    //

    if (hardwareStateHeader->VGAStateFlags & VIDEO_STATE_UNEMULATED_VGA_STATE) {

        if (!hardwareStateHeader->ExtendedValidatorStateOffset) {

            ASSERT(FALSE);
            return ERROR_INVALID_PARAMETER;

        }

        //
        // Get the right offset in the struct and save all the data associated
        // with the trapped validator data.
        //

        VideoPortMoveMemory(&(HwDeviceExtension->TrappedValidatorCount),
                            ((PUCHAR) (hardwareStateHeader)) +
                                hardwareStateHeader->ExtendedValidatorStateOffset,
                            VGA_VALIDATOR_AREA_SIZE);

        //
        // Check to see if this is an appropriate access range.
        // We are trapping - so we must have the trapping access range enabled.
        //

        if (((HwDeviceExtension->CurrentVdmAccessRange != FullVgaValidatorAccessRange) ||
             (HwDeviceExtension->CurrentNumVdmAccessRanges != NUM_FULL_VGA_VALIDATOR_ACCESS_RANGE)) &&
            ((HwDeviceExtension->CurrentVdmAccessRange != MinimalVgaValidatorAccessRange) ||
             (HwDeviceExtension->CurrentNumVdmAccessRanges != NUM_MINIMAL_VGA_VALIDATOR_ACCESS_RANGE))) {

            ASSERT (FALSE);
            return ERROR_INVALID_PARAMETER;

        }

        VideoPortSetTrappedEmulatorPorts(HwDeviceExtension,
                                         HwDeviceExtension->CurrentNumVdmAccessRanges,
                                         HwDeviceExtension->CurrentVdmAccessRange);

    }

    //
    // Set the critical registers (clock and timing states) during sync reset.
    //
    // Begin sync reset.
    //

    VideoPortWritePortUshort((PUSHORT) (HwDeviceExtension->IOAddress +
            SEQ_ADDRESS_PORT), (USHORT) (IND_SYNC_RESET +
            (START_SYNC_RESET_VALUE << 8)));

    //
    // Restore the Miscellaneous Output register.
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            MISC_OUTPUT_REG_WRITE_PORT,
            (UCHAR) (hardwareStateHeader->PortValue[MISC_OUTPUT_REG_WRITE_PORT] & 0xF7));

    //
    // Restore all Sequencer registers except the Sync Reset register, which
    // is always not in reset (except when we send out a batched sync reset
    // register set, but that can't be interrupted, so we know we're never in
    // sync reset at save/restore time).
    //

    portValue = ((PUCHAR) hardwareStateHeader) +
            hardwareStateHeader->BasicSequencerOffset + 1;

    for (i = 1; i < VGA_NUM_SEQUENCER_PORTS; i++) {

        VideoPortWritePortUshort((PUSHORT) (HwDeviceExtension->IOAddress +
                SEQ_ADDRESS_PORT), (USHORT) (i + ((*portValue++) << 8)) );

    }

    //
    // Restore the Graphics Controller Miscellaneous register, which contains
    // the Chain bit.
    //

    portValue = ((PUCHAR) hardwareStateHeader) +
                hardwareStateHeader->BasicGraphContOffset + IND_GRAPH_MISC;

    VideoPortWritePortUshort((PUSHORT) (HwDeviceExtension->IOAddress +
            GRAPH_ADDRESS_PORT), (USHORT)(IND_GRAPH_MISC + (*portValue << 8)));

    //
    // End sync reset.
    //

    VideoPortWritePortUshort((PUSHORT) (HwDeviceExtension->IOAddress +
            SEQ_ADDRESS_PORT), (USHORT) (IND_SYNC_RESET +
            (END_SYNC_RESET_VALUE << 8)));

    //
    // Figure out if color/mono switchable registers are at 3BX or 3DX.
    // At the same time, save the state of the Miscellaneous Output register
    // which is read from 3CC but written at 3C2.
    //

    if (hardwareStateHeader->PortValue[MISC_OUTPUT_REG_WRITE_PORT] & 0x01) {
        bIsColor = TRUE;
    } else {
        bIsColor = FALSE;
    }


    //
    // Restore the CRT Controller indexed registers.
    //
    // Unlock CRTC registers 0-7.
    //

    portValue = (PUCHAR) hardwareStateHeader +
            hardwareStateHeader->BasicCrtContOffset;

    if (bIsColor) {

        VideoPortWritePortUshort((PUSHORT) (HwDeviceExtension->IOAddress +
                CRTC_ADDRESS_PORT_COLOR), (USHORT) (IND_CRTC_PROTECT +
                (((*(portValue + IND_CRTC_PROTECT)) & 0x7F) << 8)));

    } else {

        VideoPortWritePortUshort((PUSHORT) (HwDeviceExtension->IOAddress +
                CRTC_ADDRESS_PORT_MONO), (USHORT) (IND_CRTC_PROTECT +
                (((*(portValue + IND_CRTC_PROTECT)) & 0x7F) << 8)));

    }


    //
    // Now restore the CRTC registers.
    //

    for (i = 0; i < VGA_NUM_CRTC_PORTS; i++) {

        if (bIsColor) {

            VideoPortWritePortUshort((PUSHORT) (HwDeviceExtension->IOAddress +
                    CRTC_ADDRESS_PORT_COLOR),
                    (USHORT) (i + ((*portValue++) << 8)));

        } else {

            VideoPortWritePortUshort((PUSHORT) (HwDeviceExtension->IOAddress +
                    CRTC_ADDRESS_PORT_MONO),
                    (USHORT) (i + ((*portValue++) << 8)));

        }

    }


    //
    // Restore the Graphics Controller indexed registers.
    //

    portValue = (PUCHAR) hardwareStateHeader +
            hardwareStateHeader->BasicGraphContOffset;

    for (i = 0; i < VGA_NUM_GRAPH_CONT_PORTS; i++) {

        VideoPortWritePortUshort((PUSHORT) (HwDeviceExtension->IOAddress +
                GRAPH_ADDRESS_PORT), (USHORT) (i + ((*portValue++) << 8)));

    }


    //
    // Restore the Attribute Controller indexed registers.
    //

    portValue = (PUCHAR) hardwareStateHeader +
            hardwareStateHeader->BasicAttribContOffset;

    //
    // Reset the AC index/data toggle, then blast out all the register
    // settings.
    //

    if (bIsColor) {
        dummy = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                INPUT_STATUS_1_COLOR);
    } else {
        dummy = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                INPUT_STATUS_1_MONO);
    }

    for (i = 0; i < VGA_NUM_ATTRIB_CONT_PORTS; i++) {

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                ATT_ADDRESS_PORT, (UCHAR)i);
        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                ATT_DATA_WRITE_PORT, *portValue++);

    }

    //
    // Restore DAC registers 1 through 255. We'll do register 0, the DAC Mask,
    // and the index registers later.
    // Set the DAC address port Index, then write out the DAC Data registers.
    // Each three reads get Red, Green, and Blue components for that register.
    //
    // Write them one at a time due to problems on local bus machines.
    //

    portValueDAC = (PUCHAR) hardwareStateHeader +
                   hardwareStateHeader->BasicDacOffset + 3;

    for (i = 1; i < VGA_NUM_DAC_ENTRIES; i++) {

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                                DAC_ADDRESS_WRITE_PORT, (UCHAR)i);

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                                DAC_DATA_REG_PORT, *portValueDAC++);

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                                DAC_DATA_REG_PORT, *portValueDAC++);

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                                DAC_DATA_REG_PORT, *portValueDAC++);

    }


    //
    // Extended registers are not supported in this driver.
    //


    //
    // Restore the Feature Control register.
    //

    if (bIsColor) {

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                FEAT_CTRL_WRITE_PORT_COLOR,
                hardwareStateHeader->PortValue[FEAT_CTRL_WRITE_PORT_COLOR]);

    } else {

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                FEAT_CTRL_WRITE_PORT_MONO,
                hardwareStateHeader->PortValue[FEAT_CTRL_WRITE_PORT_MONO]);

    }


    //
    // Restore the Sequencer Index.
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            SEQ_ADDRESS_PORT,
            hardwareStateHeader->PortValue[SEQ_ADDRESS_PORT]);

    //
    // Restore the CRT Controller Index.
    //

    if (bIsColor) {

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                CRTC_ADDRESS_PORT_COLOR,
                hardwareStateHeader->PortValue[CRTC_ADDRESS_PORT_COLOR]);

    } else {

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                CRTC_ADDRESS_PORT_MONO,
                hardwareStateHeader->PortValue[CRTC_ADDRESS_PORT_MONO]);

    }


    //
    // Restore the Graphics Controller Index.
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            GRAPH_ADDRESS_PORT,
            hardwareStateHeader->PortValue[GRAPH_ADDRESS_PORT]);


    //
    // Restore the Attribute Controller Index and index/data toggle state.
    //

    if (bIsColor) {
        port = HwDeviceExtension->IOAddress + INPUT_STATUS_1_COLOR;
    } else {
        port = HwDeviceExtension->IOAddress + INPUT_STATUS_1_MONO;
    }

    VideoPortReadPortUchar(port);  // reset the toggle to Index state

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            ATT_ADDRESS_PORT,  // restore the AC Index
            hardwareStateHeader->PortValue[ATT_ADDRESS_PORT]);

    //
    // If the toggle should be in Data state, we're all set. If it should be in
    // Index state, reset it to that condition.
    //

    if (hardwareStateHeader->AttribIndexDataState == 0) {

        //
        // Reset the toggle to Index state.
        //

        VideoPortReadPortUchar(port);

    }


    //
    // Restore DAC register 0 and the DAC Mask, to unblank the screen.
    //

    portValueDAC = (PUCHAR) hardwareStateHeader +
            hardwareStateHeader->BasicDacOffset;

    //
    // Restore the DAC Mask register.
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            DAC_PIXEL_MASK_PORT,
            hardwareStateHeader->PortValue[DAC_PIXEL_MASK_PORT]);

    //
    // Restore DAC register 0.
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            DAC_ADDRESS_WRITE_PORT, 0);
    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            DAC_DATA_REG_PORT, *portValueDAC++);
    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            DAC_DATA_REG_PORT, *portValueDAC++);
    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            DAC_DATA_REG_PORT, *portValueDAC++);


    //
    // Restore the read/write state and the current index of the DAC.
    //
    // See whether the Read or Write Index was written to most recently.
    // (The upper nibble stored at DAC_STATE_PORT is the # of reads/writes
    // for the current index.)
    //

    if ((hardwareStateHeader->PortValue[DAC_STATE_PORT] & 0x0F) == 3) {

        //
        // The DAC Read Index was written to last. Restore the DAC by setting
        // up to read from the saved index - 1, because the way the Read
        // Index works is that it autoincrements after reading, so you actually
        // end up reading the data for the index you read at the DAC Write
        // Mask register - 1.
        //
        // Set the Read Index to the index we read, minus 1, accounting for
        // wrap from 255 back to 0. The DAC hardware immediately reads this
        // register into a temporary buffer, then adds 1 to the index.
        //

        if (hardwareStateHeader->PortValue[DAC_ADDRESS_WRITE_PORT] == 0) {

            VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                    DAC_ADDRESS_READ_PORT, 255);

        } else {

            VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                    DAC_ADDRESS_READ_PORT, (UCHAR)
                    (hardwareStateHeader->PortValue[DAC_ADDRESS_WRITE_PORT] -
                    1));

        }

        //
        // Now read the hardware however many times are required to get to
        // the partial read state we saved.
        //

        for (i = hardwareStateHeader->PortValue[DAC_STATE_PORT] >> 4;
                i > 0; i--) {

            dummy = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                    DAC_DATA_REG_PORT);

        }

    } else {

        //
        // The DAC Write Index was written to last. Set the Write Index to the
        // index value we read out of the DAC. Then, if a partial write
        // (partway through an RGB triplet) was in place, write the partial
        // values, which we obtained by writing them to the current DAC
        // register. This DAC register will be wrong until the write is
        // completed, but at least the values will be right once the write is
        // finished, and most importantly we won't have messed up the sequence
        // of RGB writes (which can be as long as 768 in a row).
        //

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                DAC_ADDRESS_WRITE_PORT,
                hardwareStateHeader->PortValue[DAC_ADDRESS_WRITE_PORT]);

        //
        // Now write to the hardware however many times are required to get to
        // the partial write state we saved (if any).
        //
        // Point to the saved value for the DAC register that was in the
        // process of being written to; we wrote the partial value out, so now
        // we can restore it.
        //

        portValueDAC = (PUCHAR) hardwareStateHeader +
                hardwareStateHeader->BasicDacOffset +
                (hardwareStateHeader->PortValue[DAC_ADDRESS_WRITE_PORT] * 3);

        for (i = hardwareStateHeader->PortValue[DAC_STATE_PORT] >> 4;
                i > 0; i--) {

            VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                    DAC_DATA_REG_PORT, *portValueDAC++);

        }

    }

    return NO_ERROR;

} // end VgaRestoreHardwareState()

VP_STATUS
VgaSaveHardwareState(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_HARDWARE_STATE HardwareState,
    ULONG HardwareStateSize,
    PULONG OutputSize
    )

/*++

Routine Description:

    Saves all registers and memory of the VGA.

    Note: HardwareState points to the actual buffer in which the state
    is saved. This buffer will always be big enough (we specified
    the required size at DriverEntry).

    Note: This routine leaves registers in any state it cares to, except
    that it will not mess with any of the CRT or Sequencer parameters that
    might make the monitor unhappy. It leaves the screen blanked by setting
    the DAC Mask and DAC register 0 to all zero values. The next video
    operation we expect after this is a mode set to take us back to Win32.

    Note: The offset in the hardware state header in which each general
    register is saved is the offset of the write address of that register from
    the base I/O address of the VGA.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

    HardwareState - Pointer to a structure in which the saved state will be
        returned (actually only info about and a pointer to the actual save
        buffer).

    HardwareStateSize - Length of the output buffer supplied by the user.
        (Actually only the size of the HardwareState structure, not the
        buffer it points to where the state is actually saved. The pointed-
        to buffer is assumed to be big enough.)

    OutputSize - Pointer to a buffer in which to return the actual size of
        the data returned in the buffer.

Return Value:

    NO_ERROR - information returned successfully

    ERROR_INSUFFICIENT_BUFFER - output buffer not large enough to return
        any useful data

--*/

{
    PVIDEO_HARDWARE_STATE_HEADER hardwareStateHeader;
    PUCHAR pScreen;
    PUCHAR portValue;
    PUCHAR portValueDAC;
    PUCHAR bufferPointer;
    ULONG i;
    UCHAR dummy, originalACIndex, originalACData;
    UCHAR ucCRTC03;
    ULONG bIsColor;


    //
    // See if the buffer is big enough to hold the hardware state structure.
    // (This is only the HardwareState structure itself, not the buffer it
    // points to.)
    //

    if (HardwareStateSize < sizeof(VIDEO_HARDWARE_STATE) ) {

        *OutputSize = 0;  // nothing returned
        return ERROR_INSUFFICIENT_BUFFER;

    }

    //
    // Amount of data we're going to return in the output buffer.
    // (The VIDEO_HARDWARE_STATE in the output buffer points to the actual
    // buffer in which the state is stored, which is assumed to be large
    // enough.)
    //

    *OutputSize = sizeof(VIDEO_HARDWARE_STATE);

    //
    // Indicate the size of the full state save info.
    //

    HardwareState->StateLength = VGA_TOTAL_STATE_SIZE;

    //
    // hardwareStateHeader is a structure of offsets at the start of the
    // actual save area that indicates the locations in which various VGA
    // register and memory components are saved.
    //

    hardwareStateHeader = HardwareState->StateHeader;

    //
    // Zero out the structure.
    //

    VideoPortZeroMemory(hardwareStateHeader, sizeof(VIDEO_HARDWARE_STATE_HEADER));

    //
    // Set the Length field, which is basically a version ID.
    //

    hardwareStateHeader->Length = sizeof(VIDEO_HARDWARE_STATE_HEADER);

    //
    // Set the basic register offsets properly.
    //

    hardwareStateHeader->BasicSequencerOffset = VGA_BASIC_SEQUENCER_OFFSET;
    hardwareStateHeader->BasicCrtContOffset = VGA_BASIC_CRTC_OFFSET;
    hardwareStateHeader->BasicGraphContOffset = VGA_BASIC_GRAPH_CONT_OFFSET;
    hardwareStateHeader->BasicAttribContOffset = VGA_BASIC_ATTRIB_CONT_OFFSET;
    hardwareStateHeader->BasicDacOffset = VGA_BASIC_DAC_OFFSET;
    hardwareStateHeader->BasicLatchesOffset = VGA_BASIC_LATCHES_OFFSET;

    //
    // Set the entended register offsets properly.
    //

    hardwareStateHeader->ExtendedSequencerOffset = VGA_EXT_SEQUENCER_OFFSET;
    hardwareStateHeader->ExtendedCrtContOffset = VGA_EXT_CRTC_OFFSET;
    hardwareStateHeader->ExtendedGraphContOffset = VGA_EXT_GRAPH_CONT_OFFSET;
    hardwareStateHeader->ExtendedAttribContOffset = VGA_EXT_ATTRIB_CONT_OFFSET;
    hardwareStateHeader->ExtendedDacOffset = VGA_EXT_DAC_OFFSET;

    //
    // Figure out if color/mono switchable registers are at 3BX or 3DX.
    // At the same time, save the state of the Miscellaneous Output register
    // which is read from 3CC but written at 3C2.
    //

    if ((hardwareStateHeader->PortValue[MISC_OUTPUT_REG_WRITE_PORT] =
            VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                    MISC_OUTPUT_REG_READ_PORT))
            & 0x01) {
        bIsColor = TRUE;
    } else {
        bIsColor = FALSE;
    }

    //
    // Force the video subsystem enable state to enabled.
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            VIDEO_SUBSYSTEM_ENABLE_PORT, 1);

    //
    // Save the DAC state first, so we can set the DAC to blank the screen
    // so nothing after this shows up at all.
    //
    // Save the DAC Mask register.
    //

    hardwareStateHeader->PortValue[DAC_PIXEL_MASK_PORT] =
            VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                    DAC_PIXEL_MASK_PORT);

    //
    // Save the DAC Index register. Note that there is actually only one DAC
    // Index register, which functions as either the Read Index or the Write
    // Index as needed.
    //

    hardwareStateHeader->PortValue[DAC_ADDRESS_WRITE_PORT] =
            VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                    DAC_ADDRESS_WRITE_PORT);

    //
    // Save the DAC read/write state. We determine if the DAC has been written
    // to or read from at the current index 0, 1, or 2 times (the application
    // is in the middle of reading or writing a DAC register triplet if the
    // count is 1 or 2), and save enough info so we can restore things
    // properly. The only hole is if the application writes to the Write Index,
    // then reads from instead of writes to the Data register, or vice-versa,
    // or if they do a partial read write, then never finish it.
    // This is fairly ridiculous behavior, however, and anyway there's nothing
    // we can do about it.
    //

    hardwareStateHeader->PortValue[DAC_STATE_PORT] =
             VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                    DAC_STATE_PORT);

    if (hardwareStateHeader->PortValue[DAC_STATE_PORT] == 3) {

        //
        // The DAC Read Index was written to last. Figure out how many reads
        // have been done from the current index. We'll restart this on restore
        // by setting the Read Index to the current index - 1 (the read index
        // is one greater than the index being read), then doing the proper
        // number of reads.
        //
        // Read the Data register once, and see if the index changes.
        //

        dummy = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                DAC_DATA_REG_PORT);

        if (VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                    DAC_ADDRESS_WRITE_PORT) !=
                hardwareStateHeader->PortValue[DAC_ADDRESS_WRITE_PORT]) {

            //
            // The DAC Index changed, so two reads had already been done from
            // the current index. Store the count "2" in the upper nibble of
            // the read/write state field.
            //

            hardwareStateHeader->PortValue[DAC_STATE_PORT] |= 0x20;

        } else {

            //
            // Read the Data register again, and see if the index changes.
            //

            dummy = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                    DAC_DATA_REG_PORT);

            if (VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                        DAC_ADDRESS_WRITE_PORT) !=
                    hardwareStateHeader->PortValue[DAC_ADDRESS_WRITE_PORT]) {

                //
                // The DAC Index changed, so one read had already been done
                // from the current index. Store the count "1" in the upper
                // nibble of the read/write state field.
                //

                hardwareStateHeader->PortValue[DAC_STATE_PORT] |= 0x10;
            }

            //
            // If neither 2 nor 1 reads had been done from the current index,
            // then 0 reads were done, and we're all set, since the upper
            // nibble of the read/write state field is already 0.
            //

        }

    } else {

        //
        // The DAC Write Index was written to last. Figure out how many writes
        // have been done to the current index. We'll restart this on restore
        // by setting the Write Index to the proper index, then doing the
        // proper number of writes. When we do the DAC register save, we'll
        // read out the value that gets written (if there was a partial write
        // in progress), so we can restore the proper data later. This will
        // cause this current DAC location to be briefly wrong in the 1- and
        // 2-bytes-written case (until the app finishes the write), but that's
        // better than having the wrong DAC values written for good.
        //
        // Write the Data register once, and see if the index changes.
        //

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                DAC_DATA_REG_PORT, 0);

        if (VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                    DAC_ADDRESS_WRITE_PORT) !=
                hardwareStateHeader->PortValue[DAC_ADDRESS_WRITE_PORT]) {

            //
            // The DAC Index changed, so two writes had already been done to
            // the current index. Store the count "2" in the upper nibble of
            // the read/write state field.
            //

            hardwareStateHeader->PortValue[DAC_STATE_PORT] |= 0x20;

        } else {

            //
            // Write the Data register again, and see if the index changes.
            //

            VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                    DAC_DATA_REG_PORT, 0);

            if (VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                        DAC_ADDRESS_WRITE_PORT) !=
                    hardwareStateHeader->PortValue[DAC_ADDRESS_WRITE_PORT]) {

                //
                // The DAC Index changed, so one write had already been done
                // to the current index. Store the count "1" in the upper
                // nibble of the read/write state field.
                //

                hardwareStateHeader->PortValue[DAC_STATE_PORT] |= 0x10;
            }

            //
            // If neither 2 nor 1 writes had been done to the current index,
            // then 0 writes were done, and we're all set.
            //

        }

    }


    //
    // Now, read out the 256 18-bit DAC palette registers (256 RGB triplets),
    // and blank the screen.
    //

    portValueDAC = (PUCHAR) hardwareStateHeader + VGA_BASIC_DAC_OFFSET;

    //
    // Read out DAC register 0, so we can set it to black.
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                DAC_ADDRESS_READ_PORT, 0);
    *portValueDAC++ = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
            DAC_DATA_REG_PORT);
    *portValueDAC++ = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
            DAC_DATA_REG_PORT);
    *portValueDAC++ = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
            DAC_DATA_REG_PORT);

    //
    // Set DAC register 0 to display black.
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            DAC_ADDRESS_WRITE_PORT, 0);
    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            DAC_DATA_REG_PORT, 0);
    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            DAC_DATA_REG_PORT, 0);
    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            DAC_DATA_REG_PORT, 0);

    //
    // Set the DAC mask register to force DAC register 0 to display all the
    // time (this is the register we just set to display black). From now on,
    // nothing but black will show up on the screen.
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            DAC_PIXEL_MASK_PORT, 0);

    //
    // Read out the Attribute Controller Index state, and deduce the Index/Data
    // toggle state at the same time.
    //
    // Save the state of the Attribute Controller, both Index and Data,
    // so we can test in which state the toggle currently is.
    //

    originalACIndex = hardwareStateHeader->PortValue[ATT_ADDRESS_PORT] =
            VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                    ATT_ADDRESS_PORT);
    originalACData = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
            ATT_DATA_READ_PORT);

    //
    // Sequencer Index.
    //

    hardwareStateHeader->PortValue[SEQ_ADDRESS_PORT] =
             VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                     SEQ_ADDRESS_PORT);

    //
    // Begin sync reset, just in case this is an SVGA and the currently
    // indexed Attribute Controller register controls clocking stuff (a
    // normal VGA won't require this).
    //

    VideoPortWritePortUshort((PUSHORT) (HwDeviceExtension->IOAddress +
            SEQ_ADDRESS_PORT),
            (USHORT) (IND_SYNC_RESET + (START_SYNC_RESET_VALUE << 8)));

    //
    // Now, write a different Index setting to the Attribute Controller, and
    // see if the Index changes.
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            ATT_ADDRESS_PORT, (UCHAR) (originalACIndex ^ 0x10));

    if (VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                ATT_ADDRESS_PORT) == originalACIndex) {

        //
        // The Index didn't change, so the toggle was in the Data state.
        //

        hardwareStateHeader->AttribIndexDataState = 1;

        //
        // Restore the original Data state; we just corrupted it, and we need
        // to read it out later; also, it may glitch the screen if not
        // corrected. The toggle is already in the Index state.
        //

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                ATT_ADDRESS_PORT, originalACIndex);
        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                ATT_DATA_WRITE_PORT, originalACData);

    } else {

        //
        // The Index did change, so the toggle was in the Index state.
        // No need to restore anything, because the Data register didn't
        // change, and we've already read out the Index register.
        //

        hardwareStateHeader->AttribIndexDataState = 0;

    }

    //
    // End sync reset.
    //

    VideoPortWritePortUshort((PUSHORT) (HwDeviceExtension->IOAddress +
            SEQ_ADDRESS_PORT),
            (USHORT) (IND_SYNC_RESET + (END_SYNC_RESET_VALUE << 8)));



    //
    // Save the rest of the DAC registers.
    // Set the DAC address port Index, then read out the DAC Data registers.
    // Each three reads get Red, Green, and Blue components for that register.
    //
    // Read them one at a time due to problems on local bus machines.
    //

    for (i = 1; i < VGA_NUM_DAC_ENTRIES; i++) {

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                                DAC_ADDRESS_READ_PORT, (UCHAR)i);

        *portValueDAC++ = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                                                 DAC_DATA_REG_PORT);

        *portValueDAC++ = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                                                 DAC_DATA_REG_PORT);

        *portValueDAC++ = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                                                 DAC_DATA_REG_PORT);

    }


    //
    // The Feature Control register is read from 3CA but written at 3BA/3DA.
    //

    if (bIsColor) {

        hardwareStateHeader->PortValue[FEAT_CTRL_WRITE_PORT_COLOR] =
                VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                        FEAT_CTRL_READ_PORT);

    } else {

        hardwareStateHeader->PortValue[FEAT_CTRL_WRITE_PORT_MONO] =
                VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                        FEAT_CTRL_READ_PORT);

    }



    //
    // CRT Controller Index.
    //

    if (bIsColor) {

        hardwareStateHeader->PortValue[CRTC_ADDRESS_PORT_COLOR] =
                VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                        CRTC_ADDRESS_PORT_COLOR);

    } else {

        hardwareStateHeader->PortValue[CRTC_ADDRESS_PORT_MONO] =
                VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                        CRTC_ADDRESS_PORT_MONO);

    }


    //
    // Graphics Controller Index.
    //

    hardwareStateHeader->PortValue[GRAPH_ADDRESS_PORT] =
            VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                    GRAPH_ADDRESS_PORT);


    //
    // Sequencer indexed registers.
    //

    portValue = ((PUCHAR) hardwareStateHeader) + VGA_BASIC_SEQUENCER_OFFSET;

    for (i = 0; i < VGA_NUM_SEQUENCER_PORTS; i++) {

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                SEQ_ADDRESS_PORT, (UCHAR)i);
        *portValue++ = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                SEQ_DATA_PORT);

    }


    //
    // CRT Controller indexed registers.
    //

    //
    // Remember the state of CRTC register 3, then force bit 7
    // to 1 so we will read back the Vertical Retrace start and
    // end registers rather than the light pen info.
    //

    if (bIsColor) {

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                CRTC_ADDRESS_PORT_COLOR, 3);
        ucCRTC03 = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                        CRTC_DATA_PORT_COLOR);
        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                    CRTC_DATA_PORT_COLOR, (UCHAR) (ucCRTC03 | 0x80));
    } else {

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                CRTC_ADDRESS_PORT_MONO, 3);
        ucCRTC03 = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                        CRTC_DATA_PORT_MONO);
        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                CRTC_DATA_PORT_MONO, (UCHAR) (ucCRTC03 | 0x80));
    }

    portValue = (PUCHAR) hardwareStateHeader + VGA_BASIC_CRTC_OFFSET;

    for (i = 0; i < VGA_NUM_CRTC_PORTS; i++) {

        if (bIsColor) {

            VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                    CRTC_ADDRESS_PORT_COLOR, (UCHAR)i);
            *portValue++ =
                    VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                            CRTC_DATA_PORT_COLOR);
        } else {

            VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                    CRTC_ADDRESS_PORT_MONO, (UCHAR)i);
            *portValue++ =
                    VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                            CRTC_DATA_PORT_MONO);
        }

    }

    portValue = (PUCHAR) hardwareStateHeader + VGA_BASIC_CRTC_OFFSET;
    portValue[3] = ucCRTC03;


    //
    // Graphics Controller indexed registers.
    //

    portValue = (PUCHAR) hardwareStateHeader + VGA_BASIC_GRAPH_CONT_OFFSET;

    for (i = 0; i < VGA_NUM_GRAPH_CONT_PORTS; i++) {

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                GRAPH_ADDRESS_PORT, (UCHAR)i);
        *portValue++ = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                GRAPH_DATA_PORT);

    }


    //
    // Attribute Controller indexed registers.
    //

    portValue = (PUCHAR) hardwareStateHeader + VGA_BASIC_ATTRIB_CONT_OFFSET;

    //
    // For each indexed AC register, reset the flip-flop for reading the
    // attribute register, then write the desired index to the AC Index,
    // then read the value of the indexed register from the AC Data register.
    //

    for (i = 0; i < VGA_NUM_ATTRIB_CONT_PORTS; i++) {

        if (bIsColor) {
            dummy = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                    INPUT_STATUS_1_COLOR);
        } else {
            dummy = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                    INPUT_STATUS_1_MONO);
        }

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                ATT_ADDRESS_PORT, (UCHAR)i);
        *portValue++ = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                ATT_DATA_READ_PORT);

    }

    //
    // Save the latches. This destroys one byte of display memory in each
    // plane, which is unfortunate but unavoidable. Chips that provide
    // a way to read back the latches can avoid this problem.
    //
    // Set up the VGA's hardware so we can write the latches, then read them
    // back.
    //

    //
    // Begin sync reset.
    //

    VideoPortWritePortUshort((PUSHORT) (HwDeviceExtension->IOAddress +
            SEQ_ADDRESS_PORT),
            (USHORT) (IND_SYNC_RESET + (START_SYNC_RESET_VALUE << 8)));

    //
    // Set the Miscellaneous register to make sure we can access video RAM.
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            MISC_OUTPUT_REG_WRITE_PORT, (UCHAR)(
            hardwareStateHeader->PortValue[MISC_OUTPUT_REG_WRITE_PORT] |
            0x02));

    //
    // Turn off Chain mode and map display memory at A0000 for 64K.
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            GRAPH_ADDRESS_PORT, IND_GRAPH_MISC);
    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            GRAPH_DATA_PORT,
            (UCHAR) ((VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
            GRAPH_DATA_PORT) & 0xF1) | 0x04));

    //
    // Turn off Chain4 mode and odd/even.
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            SEQ_ADDRESS_PORT, IND_MEMORY_MODE);
    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            SEQ_DATA_PORT,
            (UCHAR) ((VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
            SEQ_DATA_PORT) & 0xF3) | 0x04));

    //
    // End sync reset.
    //

    VideoPortWritePortUshort((PUSHORT) (HwDeviceExtension->IOAddress +
            SEQ_ADDRESS_PORT),
            (USHORT) (IND_SYNC_RESET + (END_SYNC_RESET_VALUE << 8)));

    //
    // Set the Map Mask to write to all planes.
    //

    VideoPortWritePortUshort((PUSHORT) (HwDeviceExtension->IOAddress +
            SEQ_ADDRESS_PORT), (USHORT) (IND_MAP_MASK + (0x0F << 8)));

    //
    // Set the write mode to 0, the read mode to 0, and turn off odd/even.
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            GRAPH_ADDRESS_PORT, IND_GRAPH_MODE);
    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            GRAPH_DATA_PORT,
            (UCHAR) ((VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
            GRAPH_DATA_PORT) & 0xE4) | 0x01));

    //
    // Point to the last byte of display memory.
    //

    pScreen = (PUCHAR) HwDeviceExtension->VideoMemoryAddress +
            VGA_PLANE_SIZE - 1;

    //
    // Write the latches to the last byte of display memory.
    //

    VideoPortWriteRegisterUchar(pScreen, 0);

    //
    // Cycle through the four planes, reading the latch data from each plane.
    //

    //
    // Point the Graphics Controller Index to the Read Map register.
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            GRAPH_ADDRESS_PORT, IND_READ_MAP);

    portValue = (PUCHAR) hardwareStateHeader + VGA_BASIC_LATCHES_OFFSET;

    for (i=0; i<4; i++) {

        //
        // Set the Read Map for the current plane.
        //

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                GRAPH_DATA_PORT, (UCHAR)i);

        //
        // Read the latched data we've written to memory.
        //

        *portValue++ = VideoPortReadRegisterUchar(pScreen);

    }

    //
    // Set the VDM flags
    // We are a standard VGA, and then check if we have unemulated state.
    //

    hardwareStateHeader->VGAStateFlags = 0;

    if (HwDeviceExtension->TrappedValidatorCount) {

        hardwareStateHeader->VGAStateFlags |= VIDEO_STATE_UNEMULATED_VGA_STATE;

        //
        // Save the VDM Emulator data
        // No need to save the state of the sequencer port register for our
        // emulated data since it may change when we come back. It will be
        // recomputed.
        //

        hardwareStateHeader->ExtendedValidatorStateOffset = VGA_VALIDATOR_OFFSET;

        VideoPortMoveMemory(((PUCHAR) (hardwareStateHeader)) +
                                hardwareStateHeader->ExtendedValidatorStateOffset,
                            &(HwDeviceExtension->TrappedValidatorCount),
                            VGA_VALIDATOR_AREA_SIZE);

    } else {

        hardwareStateHeader->ExtendedValidatorStateOffset = 0;

    }

    //
    // Set the size of each plane.
    //

    hardwareStateHeader->PlaneLength = VGA_PLANE_SIZE;

    //
    // Store all the offsets for the planes in the structure.
    //

    hardwareStateHeader->Plane1Offset = VGA_PLANE_0_OFFSET;
    hardwareStateHeader->Plane2Offset = VGA_PLANE_1_OFFSET;
    hardwareStateHeader->Plane3Offset = VGA_PLANE_2_OFFSET;
    hardwareStateHeader->Plane4Offset = VGA_PLANE_3_OFFSET;

    //
    // Now copy the contents of video VRAM into the buffer.
    //
    // The VGA hardware is already set up so that video memory is readable;
    // we already turned off Chain mode, mapped in at A0000, turned off Chain4,
    // turned off odd/even, and set read mode 0 when we saved the latches.
    //
    // Point the Graphics Controller Index to the Read Map register.
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            GRAPH_ADDRESS_PORT, IND_READ_MAP);

    //
    // Point to the save area for the first plane.
    //

    bufferPointer = ((PUCHAR) (hardwareStateHeader)) +
                     hardwareStateHeader->Plane1Offset;

    //
    // Save the four planes consecutively.
    //

    for (i = 0; i < 4; i++) {

        //
        // Set the Read Map to select the plane we want to save next.
        //

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                GRAPH_DATA_PORT, (UCHAR)i);

        //
        // Copy this plane into the buffer.
        //

        VideoPortMoveMemory(bufferPointer,
                           (PUCHAR) HwDeviceExtension->VideoMemoryAddress,
                           VGA_PLANE_SIZE);
        //
        // Point to the next plane's save area.
        //

        bufferPointer += VGA_PLANE_SIZE;
    }

    //
    // Reenable video output
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            DAC_PIXEL_MASK_PORT, 0xff);


    return NO_ERROR;

} // end VgaSaveHardwareState()

VP_STATUS
VgaGetBankSelectCode(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_BANK_SELECT BankSelect,
    ULONG BankSelectSize,
    PULONG OutputSize
    )

/*++

Routine Description:

    Returns information needed in order for caller to implement bank
         management.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

    BankSelect - Pointer to a VIDEO_BANK_SELECT structure in which the bank
             select data will be returned (output buffer).

    BankSelectSize - Length of the output buffer supplied by the user.

    OutputSize - Pointer to a variable in which to return the actual size of
        the data returned in the output buffer.

Return Value:

    NO_ERROR - information returned successfully

    ERROR_MORE_DATA - output buffer not large enough to hold all info (but
        Size is returned, so caller can tell how large a buffer to allocate)

    ERROR_INSUFFICIENT_BUFFER - output buffer not large enough to return
        any useful data

--*/

{
    PUCHAR pCode = (PUCHAR)BankSelect + sizeof(VIDEO_BANK_SELECT);

    //
    // check if a mode has been set
    //

    if (HwDeviceExtension->CurrentMode == NULL) {

        return ERROR_INVALID_FUNCTION;

    }

    //
    // The minimum passed buffer size is a VIDEO_BANK_SELECT
    // structure, so that we can return the required size; we can't do
    // anything if we don't have at least that much buffer.
    //

    if (BankSelectSize < sizeof(VIDEO_BANK_SELECT)) {

        return ERROR_INSUFFICIENT_BUFFER;

    }

    //
    // Size of banking info.
    //

    BankSelect->Length = sizeof(VIDEO_BANK_SELECT);
    BankSelect->Size = sizeof(VIDEO_BANK_SELECT);

    //
    // There's room enough for everything, so fill in required fields in
    // VIDEO_BANK_SELECT.
    //
    // That's pretty easy in this case, since there's no banking; only
    // the banking type, the bitmap width, and the bitmap size need to be
    // filled in. We'll provide dummy bank switch code, too, that just
    // returns, because it shouldn't ever be called.
    //

    BankSelect->BankingFlags = 0;
    BankSelect->BankingType = VideoBanked1RW;
    BankSelect->PlanarHCBankingType = VideoBanked1RW;
    BankSelect->BitmapWidthInBytes = HwDeviceExtension->CurrentMode->wbytes;
    BankSelect->BitmapSize = HwDeviceExtension->CurrentMode->sbytes;

    BankSelect->Granularity = HwDeviceExtension->CurrentMode->Granularity;
    if(! BankSelect->Granularity ) 
         BankSelect->Granularity = 0x10000;
    BankSelect->PlanarHCGranularity = BankSelect->Granularity >> 2;

    //
    // If the buffer isn't big enough to hold all info, just return
    // ERROR_MORE_DATA; Size is already set.
    //

    if (BankSelectSize < BankSelect->Size ) {

        //
        // We're returning only the VIDEO_BANK_SELECT structure.
        //

        *OutputSize = sizeof(VIDEO_BANK_SELECT);
        return ERROR_MORE_DATA;
    }

    //
    // Set the bank switch code's location in the returned buffer.
    //

    BankSelect->CodeOffset = sizeof(VIDEO_BANK_SELECT);
    BankSelect->PlanarHCBankCodeOffset = sizeof(VIDEO_BANK_SELECT);
    BankSelect->PlanarHCEnableCodeOffset = sizeof(VIDEO_BANK_SELECT);
    BankSelect->PlanarHCDisableCodeOffset = sizeof(VIDEO_BANK_SELECT);

    //
    // Number of bytes we're returning is the full banking info size.
    //

    *OutputSize = BankSelect->Size;

    return NO_ERROR;

} // end VgaGetBankSelectCode()

VP_STATUS
VgaValidatorUcharEntry(
    ULONG_PTR Context,
    ULONG Port,
    UCHAR AccessMode,
    PUCHAR Data
    )

/*++

Routine Description:

    Entry point into the validator for byte I/O operations.

    The entry point will be called whenever a byte operation was performed
    by a DOS application on one of the specified Video ports. The kernel
    emulator will forward these requests.

Arguments:

    Context - Context value that is passed to each call made to the validator
        function. This is the value the miniport driver specified in the
        MiniportConfigInfo->EmulatorAccessEntriesContext.

    Port - Port on which the operation is to be performed.

    AccessMode - Determines if it is a read or write operation.

    Data - Pointer to a variable containing the data to be written or a
        variable into which the read data should be stored.

Return Value:

    NO_ERROR.

--*/

{

    PHW_DEVICE_EXTENSION hwDeviceExtension = (PHW_DEVICE_EXTENSION) Context;
    ULONG endEmulation;
    UCHAR temp;

#if defined(DEBUG_CODE)
    if(TrapRoutineEntered)
       {MY_ASSERT;}
    else
        TrapRoutineEntered = 1;
#endif
     
    Port -= VGA_BASE_IO_PORT;

    if (hwDeviceExtension->TrappedValidatorCount) {

        //
        // If we are processing a WRITE instruction, then store it in the
        // playback buffer. If the buffer is full, then play it back right
        // away, end sync reset and reinitialize the buffer with a sync
        // reset instruction.
        //
        // If we have a READ, we must flush the buffer (which has the side
        // effect of starting SyncReset), perform the read operation, stop
        // sync reset, and put back a sync reset instruction in the buffer
        // so we can go on appropriately
        //

        if (AccessMode & EMULATOR_WRITE_ACCESS) {

            //
            // Make sure Bit 3 of the Miscellaneous register is always 0.
            // If it is 1 it could select a non-existent clock, and kill the
            // system
            //

            if (Port == MISC_OUTPUT_REG_WRITE_PORT) {

                *Data &= 0xF7;

            }

#if defined(DEBUG_CODE)
            if(hwDeviceExtension->TrappedValidatorCount > VGA_MAX_VALIDATOR_DATA - 1)
                 {MY_ASSERT;}
#endif
            hwDeviceExtension->TrappedValidatorData[hwDeviceExtension->
                TrappedValidatorCount].Port = Port;

            hwDeviceExtension->TrappedValidatorData[hwDeviceExtension->
                TrappedValidatorCount].AccessType = VGA_VALIDATOR_UCHAR_ACCESS;

            hwDeviceExtension->TrappedValidatorData[hwDeviceExtension->
                TrappedValidatorCount].Data = *Data;

            hwDeviceExtension->TrappedValidatorCount++;

            //
            // Check to see if this instruction was ending sync reset.
            // If it did, we must flush the buffer and reset the trapped
            // IO ports to the minimal set.
            //

            if ( (Port == SEQ_DATA_PORT) &&
                 ((*Data & END_SYNC_RESET_VALUE) == END_SYNC_RESET_VALUE) &&
                 (hwDeviceExtension->SequencerAddressValue == IND_SYNC_RESET)) {

                endEmulation = 1;

            } else {

                //
                // If we are accessing the seq address port, keep track of the
                // data value
                //

                if (Port == SEQ_ADDRESS_PORT) {

                    hwDeviceExtension->SequencerAddressValue = *Data;

                }

                //
                // If the buffer is not full, then just return right away.
                //

                if (hwDeviceExtension->TrappedValidatorCount <
                       VGA_MAX_VALIDATOR_DATA - 1) {

#if defined(DEBUG_CODE)
                    TrapRoutineEntered = 0;
#endif
                    return NO_ERROR;

                }

                endEmulation = 0;
            }
        }

        //
        // We are either in a READ path or a WRITE path that caused a
        // a full buffer. So flush the buffer either way.
        //
        // To do this put an END_SYNC_RESET at the end since we want to make
        // the buffer is ended sync reset ended.
        //

#if defined(DEBUG_CODE)
        if(hwDeviceExtension->TrappedValidatorCount > VGA_MAX_VALIDATOR_DATA - 1)
            {MY_ASSERT;}
#endif

        hwDeviceExtension->TrappedValidatorData[hwDeviceExtension->
            TrappedValidatorCount].Port = SEQ_ADDRESS_PORT;

        hwDeviceExtension->TrappedValidatorData[hwDeviceExtension->
            TrappedValidatorCount].AccessType = VGA_VALIDATOR_USHORT_ACCESS;

        hwDeviceExtension->TrappedValidatorData[hwDeviceExtension->
            TrappedValidatorCount].Data = (USHORT) (IND_SYNC_RESET +
                                          (END_SYNC_RESET_VALUE << 8));

        hwDeviceExtension->TrappedValidatorCount++;

        VideoPortSynchronizeExecution(hwDeviceExtension,
                                      VpHighPriority,
                                      (PMINIPORT_SYNCHRONIZE_ROUTINE)
                                          VgaPlaybackValidatorData,
                                      hwDeviceExtension);

        //
        // Write back the real value of the sequencer address port.
        //

        VideoPortWritePortUchar(hwDeviceExtension->IOAddress +
                                    SEQ_ADDRESS_PORT,
                                (UCHAR) hwDeviceExtension->SequencerAddressValue);

        //
        // If we are in a READ path, read the data
        //

        if (AccessMode & EMULATOR_READ_ACCESS) {

            *Data = VideoPortReadPortUchar(hwDeviceExtension->IOAddress + Port);

            endEmulation = 0;

        }

        //
        // If we are ending emulation, reset trapping to the minimal amount
        // and exit.
        //

        if (endEmulation) {

            VideoPortSetTrappedEmulatorPorts(hwDeviceExtension,
                                             NUM_MINIMAL_VGA_VALIDATOR_ACCESS_RANGE,
                                             MinimalVgaValidatorAccessRange);

#if defined(DEBUG_CODE)
            TrapRoutineEntered = 0;
#endif
            return NO_ERROR;

        }

        //
        // For both cases, put back a START_SYNC_RESET in the buffer.
        //

        hwDeviceExtension->TrappedValidatorCount = 1;

        hwDeviceExtension->TrappedValidatorData[0].Port = SEQ_ADDRESS_PORT;

        hwDeviceExtension->TrappedValidatorData[0].AccessType =
                VGA_VALIDATOR_USHORT_ACCESS;

        hwDeviceExtension->TrappedValidatorData[0].Data =
                (ULONG) (IND_SYNC_RESET + (START_SYNC_RESET_VALUE << 8));

    } else {

        //
        // Nothing trapped.
        // Lets check is the IO is trying to do something that would require
        // us to stop trapping
        //

        if (AccessMode & EMULATOR_WRITE_ACCESS) {

            //
            // Make sure Bit 3 of the Miscelaneous register is always 0.
            // If it is 1 it could select a non-existant clock, and kill the
            // system
            //

            if (Port == MISC_OUTPUT_REG_WRITE_PORT) {

                temp = VideoPortReadPortUchar(hwDeviceExtension->IOAddress +
                                                  SEQ_ADDRESS_PORT);

                VideoPortWritePortUshort((PUSHORT) (hwDeviceExtension->IOAddress +
                                             SEQ_ADDRESS_PORT),
                                         (USHORT) (IND_SYNC_RESET +
                                             (START_SYNC_RESET_VALUE << 8)));

                VideoPortWritePortUchar(hwDeviceExtension->IOAddress + Port,
                                         (UCHAR) (*Data & 0xF7) );

                VideoPortWritePortUshort((PUSHORT) (hwDeviceExtension->IOAddress +
                                             SEQ_ADDRESS_PORT),
                                         (USHORT) (IND_SYNC_RESET +
                                             (END_SYNC_RESET_VALUE << 8)));

                VideoPortWritePortUchar(hwDeviceExtension->IOAddress +
                                            SEQ_ADDRESS_PORT,
                                        temp);

#if defined(DEBUG_CODE)
                TrapRoutineEntered = 0;
#endif
                return NO_ERROR;

            }

            //
            // If we get an access to the sequencer register, start trapping.
            //

            if ( (Port == SEQ_DATA_PORT) &&
                 ((*Data & END_SYNC_RESET_VALUE) != END_SYNC_RESET_VALUE) &&
                 (VideoPortReadPortUchar(hwDeviceExtension->IOAddress +
                                         SEQ_ADDRESS_PORT) == IND_SYNC_RESET)) {

                VideoPortSetTrappedEmulatorPorts(hwDeviceExtension,
                                                 NUM_FULL_VGA_VALIDATOR_ACCESS_RANGE,
                                                 FullVgaValidatorAccessRange);

                hwDeviceExtension->TrappedValidatorCount = 1;
                hwDeviceExtension->TrappedValidatorData[0].Port = Port;
                hwDeviceExtension->TrappedValidatorData[0].AccessType =
                    VGA_VALIDATOR_UCHAR_ACCESS;

                hwDeviceExtension->TrappedValidatorData[0].Data = *Data;

                //
                // Start keeping track of the state of the sequencer port.
                //

                hwDeviceExtension->SequencerAddressValue = IND_SYNC_RESET;

            } else {

                VideoPortWritePortUchar(hwDeviceExtension->IOAddress + Port,
                                        *Data);

            }

        } else {

            *Data = VideoPortReadPortUchar(hwDeviceExtension->IOAddress + Port);

        }
    }

#if defined(DEBUG_CODE)
    TrapRoutineEntered = 0;
#endif
    return NO_ERROR;

} // end VgaValidatorUcharEntry()

VP_STATUS
VgaValidatorUshortEntry(
    ULONG_PTR Context,
    ULONG Port,
    UCHAR AccessMode,
    PUSHORT Data
    )

/*++

Routine Description:

    Entry point into the validator for word I/O operations.

    The entry point will be called whenever a byte operation was performed
    by a DOS application on one of the specified Video ports. The kernel
    emulator will forward these requests.

Arguments:

    Context - Context value that is passed to each call made to the validator
        function. This is the value the miniport driver specified in the
        MiniportConfigInfo->EmulatorAccessEntriesContext.

    Port - Port on which the operation is to be performed.

    AccessMode - Determines if it is a read or write operation.

    Data - Pointer to a variable containing the data to be written or a
        variable into which the read data should be stored.

Return Value:

    NO_ERROR.

--*/

{

    PHW_DEVICE_EXTENSION hwDeviceExtension = (PHW_DEVICE_EXTENSION) Context;
    ULONG endEmulation;
    UCHAR temp;

#if defined(DEBUG_CODE)
    if(TrapRoutineEntered)
       {MY_ASSERT;}
    else
        TrapRoutineEntered = 1;
#endif
     
    Port -= VGA_BASE_IO_PORT;

    if (hwDeviceExtension->TrappedValidatorCount) {

        //
        // If we are processing a WRITE instruction, then store it in the
        // playback buffer. If the buffer is full, then play it back right
        // away, end sync reset and reinitialize the buffer with a sync
        // reset instruction.
        //
        // If we have a READ, we must flush the buffer (which has the side
        // effect of starting SyncReset), perform the read operation, stop
        // sync reset, and put back a sync reset instruction in the buffer
        // so we can go on appropriately
        //

        if (AccessMode & EMULATOR_WRITE_ACCESS) {

            //
            // Make sure Bit 3 of the Miscellaneous register is always 0.
            // If it is 1 it could select a non-existent clock, and kill the
            // system
            //

            if (Port == MISC_OUTPUT_REG_WRITE_PORT) {

                *Data &= 0xFFF7;

            }

#if defined(DEBUG_CODE)
            if(hwDeviceExtension->TrappedValidatorCount > VGA_MAX_VALIDATOR_DATA - 1)
                {MY_ASSERT;}
#endif

            hwDeviceExtension->TrappedValidatorData[hwDeviceExtension->
                TrappedValidatorCount].Port = Port;

            hwDeviceExtension->TrappedValidatorData[hwDeviceExtension->
                TrappedValidatorCount].AccessType = VGA_VALIDATOR_USHORT_ACCESS;

            hwDeviceExtension->TrappedValidatorData[hwDeviceExtension->
                TrappedValidatorCount].Data = *Data;

            hwDeviceExtension->TrappedValidatorCount++;

            //
            // Check to see if this instruction was ending sync reset.
            // If it did, we must flush the buffer and reset the trapped
            // IO ports to the minimal set.
            //

            if (Port == SEQ_ADDRESS_PORT) {

                //
                // If we are accessing the seq address port, keep track of its
                // value
                //

                hwDeviceExtension->SequencerAddressValue = (*Data & 0xFF);

            }

            if ((Port == SEQ_ADDRESS_PORT) &&
                ( ((*Data >> 8) & END_SYNC_RESET_VALUE) ==
                   END_SYNC_RESET_VALUE) &&
                (hwDeviceExtension->SequencerAddressValue == IND_SYNC_RESET)) {

                endEmulation = 1;

            } else {

                //
                // If the buffer is not full, then just return right away.
                //

                if (hwDeviceExtension->TrappedValidatorCount <
                       VGA_MAX_VALIDATOR_DATA - 1) {

#if defined(DEBUG_CODE)
                    TrapRoutineEntered = 0;
#endif
                    return NO_ERROR;

                }

                endEmulation = 0;
            }
        }

        //
        // We are either in a READ path or a WRITE path that caused a
        // a full buffer. So flush the buffer either way.
        //
        // To do this put an END_SYNC_RESET at the end since we want to make
        // the buffer is ended sync reset ended.
        //

#if defined(DEBUG_CODE)
        if(hwDeviceExtension->TrappedValidatorCount > VGA_MAX_VALIDATOR_DATA - 1)
            {MY_ASSERT;}
#endif

        hwDeviceExtension->TrappedValidatorData[hwDeviceExtension->
            TrappedValidatorCount].Port = SEQ_ADDRESS_PORT;

        hwDeviceExtension->TrappedValidatorData[hwDeviceExtension->
            TrappedValidatorCount].AccessType = VGA_VALIDATOR_USHORT_ACCESS;

        hwDeviceExtension->TrappedValidatorData[hwDeviceExtension->
            TrappedValidatorCount].Data = (USHORT) (IND_SYNC_RESET +
                                          (END_SYNC_RESET_VALUE << 8));

        hwDeviceExtension->TrappedValidatorCount++;

        VideoPortSynchronizeExecution(hwDeviceExtension,
                                      VpHighPriority,
                                      (PMINIPORT_SYNCHRONIZE_ROUTINE)
                                          VgaPlaybackValidatorData,
                                      hwDeviceExtension);

        //
        // Write back the real value of the sequencer address port.
        //

        VideoPortWritePortUchar((PUCHAR) (hwDeviceExtension->IOAddress +
                                    SEQ_ADDRESS_PORT),
                                (UCHAR) hwDeviceExtension->SequencerAddressValue);

        //
        // If we are in a READ path, read the data
        //

        if (AccessMode & EMULATOR_READ_ACCESS) {

            *Data = VideoPortReadPortUshort((PUSHORT)(hwDeviceExtension->IOAddress
                                                + Port));

            endEmulation = 0;

        }

        //
        // If we are ending emulation, reset trapping to the minimal amount
        // and exit.
        //

        if (endEmulation) {

            VideoPortSetTrappedEmulatorPorts(hwDeviceExtension,
                                             NUM_MINIMAL_VGA_VALIDATOR_ACCESS_RANGE,
                                             MinimalVgaValidatorAccessRange);

#if defined(DEBUG_CODE)
            TrapRoutineEntered = 0;
#endif
            return NO_ERROR;

        }

        //
        // For both cases, put back a START_SYNC_RESET in the buffer.
        //

        hwDeviceExtension->TrappedValidatorCount = 1;

        hwDeviceExtension->TrappedValidatorData[0].Port = SEQ_ADDRESS_PORT;

        hwDeviceExtension->TrappedValidatorData[0].AccessType =
                VGA_VALIDATOR_USHORT_ACCESS;

        hwDeviceExtension->TrappedValidatorData[0].Data =
                (ULONG) (IND_SYNC_RESET + (START_SYNC_RESET_VALUE << 8));

    } else {

        //
        // Nothing trapped.
        // Lets check is the IO is trying to do something that would require
        // us to stop trapping
        //

        if (AccessMode & EMULATOR_WRITE_ACCESS) {

            //
            // Make sure Bit 3 of the Miscelaneous register is always 0.
            // If it is 1 it could select a non-existant clock, and kill the
            // system
            //

            if (Port == MISC_OUTPUT_REG_WRITE_PORT) {

                temp = VideoPortReadPortUchar(hwDeviceExtension->IOAddress +
                                                  SEQ_ADDRESS_PORT);

                VideoPortWritePortUshort((PUSHORT) (hwDeviceExtension->IOAddress +
                                             SEQ_ADDRESS_PORT),
                                         (USHORT) (IND_SYNC_RESET +
                                             (START_SYNC_RESET_VALUE << 8)));

                VideoPortWritePortUshort((PUSHORT) (hwDeviceExtension->IOAddress +
                                             (ULONG)Port),
                                         (USHORT) (*Data & 0xFFF7) );

                VideoPortWritePortUshort((PUSHORT) (hwDeviceExtension->IOAddress +
                                             SEQ_ADDRESS_PORT),
                                         (USHORT) (IND_SYNC_RESET +
                                             (END_SYNC_RESET_VALUE << 8)));

                VideoPortWritePortUchar(hwDeviceExtension->IOAddress + SEQ_ADDRESS_PORT,
                                        temp);

#if defined(DEBUG_CODE)
                TrapRoutineEntered = 0;
#endif
                return NO_ERROR;

            }

            if ( (Port == SEQ_ADDRESS_PORT) &&
                 (((*Data>> 8) & END_SYNC_RESET_VALUE) != END_SYNC_RESET_VALUE) &&
                 ((*Data & 0xFF) == IND_SYNC_RESET)) {

                VideoPortSetTrappedEmulatorPorts(hwDeviceExtension,
                                                 NUM_FULL_VGA_VALIDATOR_ACCESS_RANGE,
                                                 FullVgaValidatorAccessRange);

                hwDeviceExtension->TrappedValidatorCount = 1;
                hwDeviceExtension->TrappedValidatorData[0].Port = Port;
                hwDeviceExtension->TrappedValidatorData[0].AccessType =
                    VGA_VALIDATOR_USHORT_ACCESS;

                hwDeviceExtension->TrappedValidatorData[0].Data = *Data;

                //
                // Start keeping track of the state of the sequencer port.
                //

                hwDeviceExtension->SequencerAddressValue = IND_SYNC_RESET;

            } else {

                VideoPortWritePortUshort((PUSHORT)(hwDeviceExtension->IOAddress +
                                             Port),
                                         *Data);

            }

        } else {

            *Data = VideoPortReadPortUshort((PUSHORT)(hwDeviceExtension->IOAddress +
                                            Port));

        }
    }

#if defined(DEBUG_CODE)
    TrapRoutineEntered = 0;
#endif
    return NO_ERROR;

} // end VgaValidatorUshortEntry()

VP_STATUS
VgaValidatorUlongEntry(
    ULONG_PTR Context,
    ULONG Port,
    UCHAR AccessMode,
    PULONG Data
    )

/*++

Routine Description:

    Entry point into the validator for dword I/O operations.

    The entry point will be called whenever a byte operation was performed
    by a DOS application on one of the specified Video ports. The kernel
    emulator will forward these requests.

Arguments:

    Context - Context value that is passed to each call made to the validator
        function. This is the value the miniport driver specified in the
        MiniportConfigInfo->EmulatorAccessEntriesContext.

    Port - Port on which the operation is to be performed.

    AccessMode - Determines if it is a read or write operation.

    Data - Pointer to a variable containing the data to be written or a
        variable into which the read data should be stored.

Return Value:

    NO_ERROR.

--*/

{

    PHW_DEVICE_EXTENSION hwDeviceExtension = (PHW_DEVICE_EXTENSION) Context;
    ULONG endEmulation;
    UCHAR temp;

#if defined(DEBUG_CODE)
    if(TrapRoutineEntered)
       {MY_ASSERT;}
    else
        TrapRoutineEntered = 1;
#endif

    Port -= VGA_BASE_IO_PORT;

    if (hwDeviceExtension->TrappedValidatorCount) {

        //
        // If we are processing a WRITE instruction, then store it in the
        // playback buffer. If the buffer is full, then play it back right
        // away, end sync reset and reinitialize the buffer with a sync
        // reset instruction.
        //
        // If we have a READ, we must flush the buffer (which has the side
        // effect of starting SyncReset), perform the read operation, stop
        // sync reset, and put back a sync reset instruction in the buffer
        // so we can go on appropriately
        //

        if (AccessMode & EMULATOR_WRITE_ACCESS) {

            //
            // Make sure Bit 3 of the Miscellaneous register is always 0.
            // If it is 1 it could select a non-existent clock, and kill the
            // system
            //

            if (Port == MISC_OUTPUT_REG_WRITE_PORT) {

                *Data &= 0xFFFFFFF7;

            }

#if defined(DEBUG_CODE)
            if(hwDeviceExtension->TrappedValidatorCount > VGA_MAX_VALIDATOR_DATA - 1)
                {MY_ASSERT;}
#endif

            hwDeviceExtension->TrappedValidatorData[hwDeviceExtension->
                TrappedValidatorCount].Port = Port;

            hwDeviceExtension->TrappedValidatorData[hwDeviceExtension->
                TrappedValidatorCount].AccessType = VGA_VALIDATOR_ULONG_ACCESS;

            hwDeviceExtension->TrappedValidatorData[hwDeviceExtension->
                TrappedValidatorCount].Data = *Data;

            hwDeviceExtension->TrappedValidatorCount++;

            //
            // Check to see if this instruction was ending sync reset.
            // If it did, we must flush the buffer and reset the trapped
            // IO ports to the minimal set.
            //

            if (Port == SEQ_ADDRESS_PORT) {

                //
                // If we are accessing the seq address port, keep track of its
                // value
                //

                hwDeviceExtension->SequencerAddressValue = (*Data & 0xFF);

            }

            if ((Port == SEQ_ADDRESS_PORT) &&
                ( ((*Data >> 8) & END_SYNC_RESET_VALUE) ==
                   END_SYNC_RESET_VALUE) &&
                (hwDeviceExtension->SequencerAddressValue == IND_SYNC_RESET)) {

                endEmulation = 1;

            } else {

                //
                // If the buffer is not full, then just return right away.
                //

                if (hwDeviceExtension->TrappedValidatorCount <
                       VGA_MAX_VALIDATOR_DATA - 1) {

#if defined(DEBUG_CODE)
                    TrapRoutineEntered = 0;
#endif
                    return NO_ERROR;

                }

                endEmulation = 0;
            }
        }

        //
        // We are either in a READ path or a WRITE path that caused a
        // a full buffer. So flush the buffer either way.
        //
        // To do this put an END_SYNC_RESET at the end since we want to make
        // the buffer is ended sync reset ended.
        //

#if defined(DEBUG_CODE)
        if(hwDeviceExtension->TrappedValidatorCount > VGA_MAX_VALIDATOR_DATA - 1)
            {MY_ASSERT;}
#endif

        hwDeviceExtension->TrappedValidatorData[hwDeviceExtension->
            TrappedValidatorCount].Port = SEQ_ADDRESS_PORT;

        hwDeviceExtension->TrappedValidatorData[hwDeviceExtension->
            TrappedValidatorCount].AccessType = VGA_VALIDATOR_USHORT_ACCESS;

        hwDeviceExtension->TrappedValidatorData[hwDeviceExtension->
            TrappedValidatorCount].Data = (USHORT) (IND_SYNC_RESET +
                                          (END_SYNC_RESET_VALUE << 8));

        hwDeviceExtension->TrappedValidatorCount++;

        VideoPortSynchronizeExecution(hwDeviceExtension,
                                      VpHighPriority,
                                      (PMINIPORT_SYNCHRONIZE_ROUTINE)
                                          VgaPlaybackValidatorData,
                                      hwDeviceExtension);

        //
        // Write back the real value of the sequencer address port.
        //

        VideoPortWritePortUchar(hwDeviceExtension->IOAddress +
                                    SEQ_ADDRESS_PORT,
                                (UCHAR) hwDeviceExtension->SequencerAddressValue);

        //
        // If we are in a READ path, read the data
        //

        if (AccessMode & EMULATOR_READ_ACCESS) {

            *Data = VideoPortReadPortUlong((PULONG) (hwDeviceExtension->IOAddress +
                                               Port));

            endEmulation = 0;

        }

        //
        // If we are ending emulation, reset trapping to the minimal amount
        // and exit.
        //

        if (endEmulation) {

            VideoPortSetTrappedEmulatorPorts(hwDeviceExtension,
                                             NUM_MINIMAL_VGA_VALIDATOR_ACCESS_RANGE,
                                             MinimalVgaValidatorAccessRange);

#if defined(DEBUG_CODE)
            TrapRoutineEntered = 0;
#endif
            return NO_ERROR;

        }

        //
        // For both cases, put back a START_SYNC_RESET in the buffer.
        //

        hwDeviceExtension->TrappedValidatorCount = 1;

        hwDeviceExtension->TrappedValidatorData[0].Port = SEQ_ADDRESS_PORT;

        hwDeviceExtension->TrappedValidatorData[0].AccessType =
                VGA_VALIDATOR_USHORT_ACCESS;

        hwDeviceExtension->TrappedValidatorData[0].Data =
                (ULONG) (IND_SYNC_RESET + (START_SYNC_RESET_VALUE << 8));

    } else {

        //
        // Nothing trapped.
        // Lets check is the IO is trying to do something that would require
        // us to stop trapping
        //

        if (AccessMode & EMULATOR_WRITE_ACCESS) {

            //
            // Make sure Bit 3 of the Miscelaneous register is always 0.
            // If it is 1 it could select a non-existant clock, and kill the
            // system
            //

            if (Port == MISC_OUTPUT_REG_WRITE_PORT) {

                temp = VideoPortReadPortUchar(hwDeviceExtension->IOAddress +
                                                  SEQ_ADDRESS_PORT);

                VideoPortWritePortUshort((PUSHORT) (hwDeviceExtension->IOAddress +
                                             SEQ_ADDRESS_PORT),
                                         (USHORT) (IND_SYNC_RESET +
                                             (START_SYNC_RESET_VALUE << 8)));

                VideoPortWritePortUlong((PULONG) (hwDeviceExtension->IOAddress +
                                             Port),
                                         (ULONG) (*Data & 0xFFFFFFF7) );

                VideoPortWritePortUshort((PUSHORT) (hwDeviceExtension->IOAddress +
                                             SEQ_ADDRESS_PORT),
                                         (USHORT) (IND_SYNC_RESET +
                                             (END_SYNC_RESET_VALUE << 8)));

                VideoPortWritePortUchar(hwDeviceExtension->IOAddress + SEQ_ADDRESS_PORT,
                                        temp);

#if defined(DEBUG_CODE)
                TrapRoutineEntered = 0;
#endif
                return NO_ERROR;

            }

            if ( (Port == SEQ_ADDRESS_PORT) &&
                 (((*Data>> 8) & END_SYNC_RESET_VALUE) != END_SYNC_RESET_VALUE) &&
                 ((*Data & 0xFF) == IND_SYNC_RESET)) {

                VideoPortSetTrappedEmulatorPorts(hwDeviceExtension,
                                                 NUM_FULL_VGA_VALIDATOR_ACCESS_RANGE,
                                                 FullVgaValidatorAccessRange);

                hwDeviceExtension->TrappedValidatorCount = 1;
                hwDeviceExtension->TrappedValidatorData[0].Port = Port;
                hwDeviceExtension->TrappedValidatorData[0].AccessType =
                    VGA_VALIDATOR_ULONG_ACCESS;

                hwDeviceExtension->TrappedValidatorData[0].Data = *Data;

                //
                // Start keeping track of the state of the sequencer port.
                //

                hwDeviceExtension->SequencerAddressValue = IND_SYNC_RESET;

            } else {

                VideoPortWritePortUlong((PULONG) (hwDeviceExtension->IOAddress +
                                            Port),
                                        *Data);

            }

        } else {

            *Data = VideoPortReadPortUlong((PULONG) (hwDeviceExtension->IOAddress +
                                               Port));

        }
    }

#if defined(DEBUG_CODE)
    TrapRoutineEntered = 0;
#endif
    return NO_ERROR;

} // end VgaValidatorUlongEntry()

BOOLEAN
VgaPlaybackValidatorData(
    PVOID Context
    )

/*++

Routine Description:

    Performs all the DOS apps IO port accesses that were trapped by the
    validator. Only IO accesses that can be processed are WRITEs

    The number of outstanding IO access in deviceExtension is set to
    zero as a side effect.

    This function must be called via a call to VideoPortSynchronizeRoutine.

Arguments:

    Context - Context parameter passed to the synchronized routine.
        Must be a pointer to the miniport driver's device extension.

Return Value:

    TRUE.

--*/

{
    PHW_DEVICE_EXTENSION hwDeviceExtension = Context;
    ULONG_PTR ioBaseAddress = (ULONG_PTR) hwDeviceExtension->IOAddress;
    ULONG i;
    PVGA_VALIDATOR_DATA validatorData = hwDeviceExtension->TrappedValidatorData;

    //
    // Loop through the array of data and do instructions one by one.
    //

    for (i = 0; i < hwDeviceExtension->TrappedValidatorCount;
         i++, validatorData++) {

        //
        // Calculate base address first
        //

        ioBaseAddress = (ULONG_PTR)hwDeviceExtension->IOAddress +
                            validatorData->Port;


        //
        // This is a write operation. We will automatically stop when the
        // buffer is empty.
        //

        switch (validatorData->AccessType) {

        case VGA_VALIDATOR_UCHAR_ACCESS :

            VideoPortWritePortUchar((PUCHAR)ioBaseAddress,
                                    (UCHAR) validatorData->Data);

            break;

        case VGA_VALIDATOR_USHORT_ACCESS :

            VideoPortWritePortUshort((PUSHORT)ioBaseAddress,
                                     (USHORT) validatorData->Data);

            break;

        case VGA_VALIDATOR_ULONG_ACCESS :

            VideoPortWritePortUlong((PULONG)ioBaseAddress,
                                    (ULONG) validatorData->Data);

            break;

        default:

            VideoDebugPrint((0, "InvalidValidatorAccessType\n" ));

        }
    }

    hwDeviceExtension->TrappedValidatorCount = 0;

    return TRUE;

} // end VgaPlaybackValidatorData()

VP_STATUS
VgaSetBankPosition(
    PHW_DEVICE_EXTENSION hwDeviceExtension,
    PBANK_POSITION BankPosition
    )

{
    PVIDEO_PORT_INT10_INTERFACE Int10 = &hwDeviceExtension->Int10;
    INT10_BIOS_ARGUMENTS BiosArguments;
    VP_STATUS status;

    if(!Int10->Size) {

        return ERROR_INVALID_FUNCTION;
    }

    BiosArguments.Eax = 0x4f05;
    BiosArguments.Ebx = 0;
    BiosArguments.Edx = BankPosition->WriteBankPosition;
    status = Int10->Int10CallBios(Int10->Context, &BiosArguments);

    if ((status != NO_ERROR) || 
        !VESA_SUCCESS(BiosArguments.Eax)) {

       //
       // This could fail if the video hardware is still in linear 
       // mode. This could also fail if the bios is buggy. We don't 
       // want to return a failure code in either case. (Please read 
       // the code around "BankIoctlSupported" in display driver for
       // more details).
       //
    }

    BiosArguments.Eax = 0x4f05;
    BiosArguments.Ebx = 1;
    BiosArguments.Edx = BankPosition->ReadBankPosition;
    status = Int10->Int10CallBios(Int10->Context, &BiosArguments);

    if ((status != NO_ERROR) || 
        !VESA_SUCCESS(BiosArguments.Eax)) {

        //
        // See comment above
        //

    }

    return NO_ERROR;
}

#if defined(PLUG_AND_PLAY)

VP_STATUS
VgaGetPowerState(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    ULONG HwDeviceId,
    PVIDEO_POWER_MANAGEMENT VideoPowerManagement
    )

/*++

Routine Description:

    Returns power state information.

Arguments:

    HwDeviceExtension    - Pointer to our hardware device extension structure.

    HwDeviceId           - Private unique 32 bit ID identifing the device.

    VideoPowerControl    - Points to a VIDEO_POWER_MANAGEMENT structure that
                           specifies the power state for which support is
                           being queried.

Return Value:

    VP_STATUS value (NO_ERROR or error value)

--*/

{
    //
    // We only support power setting for the monitor.  Make sure the
    // HwDeviceId matches one the the monitors we could report.
    //

    if (HwDeviceId == VGA_MONITOR_ID) {

        ULONG MonitorPowerCapabilities = HwDeviceExtension->MonitorPowerCapabilities;

        //
        // We are querying the power support for the monitor.
        //

        if ((VideoPowerManagement->PowerState == VideoPowerOn) ||
            (VideoPowerManagement->PowerState == VideoPowerHibernate) ||
            (VideoPowerManagement->PowerState == VideoPowerShutdown)) {

            return NO_ERROR;
        }

        switch (VideoPowerManagement->PowerState) {

        case VideoPowerStandBy:
            return (MonitorPowerCapabilities & VESA_POWER_STANDBY) ?
                   NO_ERROR : ERROR_INVALID_FUNCTION;

        case VideoPowerSuspend:
            return (MonitorPowerCapabilities & VESA_POWER_SUSPEND) ?
                   NO_ERROR : ERROR_INVALID_FUNCTION;

        case VideoPowerOff:
            return (MonitorPowerCapabilities & VESA_POWER_OFF) ?
                   NO_ERROR : ERROR_INVALID_FUNCTION;

        default:

            break;
        }

        VideoDebugPrint((1, "This device does not support Power Management.\n"));
        return ERROR_INVALID_FUNCTION;

    } else if (HwDeviceId == DISPLAY_ADAPTER_HW_ID) {

        //
        // We are querying power support for the graphics card.
        //

        switch (VideoPowerManagement->PowerState) {

            case VideoPowerOn:
            case VideoPowerHibernate:
            case VideoPowerShutdown:

                return NO_ERROR;

            case VideoPowerStandBy:
            case VideoPowerOff:
            case VideoPowerSuspend:

                //
                // Indicate that we can't do VideoPowerOff, because
                // we have no way of coming back when power is re-applied
                // to the card.
                //

                return ERROR_INVALID_FUNCTION;

            default:

                ASSERT(FALSE);
                return ERROR_INVALID_PARAMETER;
        }

    } else {

        VideoDebugPrint((1, "Unknown HwDeviceId"));
        ASSERT(FALSE);
        return ERROR_INVALID_PARAMETER;
    }
}

VP_STATUS
VgaSetPowerState(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    ULONG HwDeviceId,
    PVIDEO_POWER_MANAGEMENT VideoPowerManagement
    )

/*++

Routine Description:

    Set the power state for a given device.

Arguments:

    HwDeviceExtension - Pointer to our hardware device extension structure.

    HwDeviceId        - Private unique 32 bit ID identifing the device.

    VideoPowerControl - Points to a VIDEO_POWER_MANAGEMENT structure that
                            specifies the power state to be set.

Return Value:

    VP_STATUS value (NO_ERROR, if all's well)

--*/

{
    //
    // Make sure we recognize the device.
    //

    if (HwDeviceId == VGA_MONITOR_ID) {

        VIDEO_X86_BIOS_ARGUMENTS biosArguments;

        VideoPortZeroMemory(&biosArguments, sizeof(VIDEO_X86_BIOS_ARGUMENTS));

        biosArguments.Eax = VESA_POWER_FUNCTION;
        biosArguments.Ebx = VESA_SET_POWER_FUNC;

        switch (VideoPowerManagement->PowerState) {

        case VideoPowerOn:
        case VideoPowerHibernate:
            biosArguments.Ebx |= VESA_POWER_ON;
            break;

        case VideoPowerStandBy:
            biosArguments.Ebx |= VESA_POWER_STANDBY;
            break;

        case VideoPowerSuspend:
            biosArguments.Ebx |= VESA_POWER_SUSPEND;
            break;

        case VideoPowerOff:
            biosArguments.Ebx |= VESA_POWER_OFF;
            break;

        case VideoPowerShutdown:
            return NO_ERROR;

        default:
            VideoDebugPrint((1, "Unknown power state.\n"));
            ASSERT(FALSE);
            return ERROR_INVALID_PARAMETER;
        }

        VideoPortInt10(HwDeviceExtension, &biosArguments);

        //
        // track the current monitor power state
        //

        HwDeviceExtension->MonitorPowerState = VideoPowerManagement->PowerState;

        return NO_ERROR;

    } else if (HwDeviceId == DISPLAY_ADAPTER_HW_ID) {

        switch (VideoPowerManagement->PowerState) {
            case VideoPowerOn:
            case VideoPowerHibernate:
            case VideoPowerShutdown:

                return NO_ERROR;

            case VideoPowerStandBy:
            case VideoPowerSuspend:
            case VideoPowerOff:

                return ERROR_INVALID_PARAMETER;

            default:

                //
                // We indicated in S3GetPowerState that we couldn't
                // do VideoPowerOff.  So we should not get a call to
                // do it here.
                //

                ASSERT(FALSE);
                return ERROR_INVALID_PARAMETER;

        }

    } else {

        VideoDebugPrint((1, "Unknown HwDeviceId"));
        ASSERT(FALSE);
        return ERROR_INVALID_PARAMETER;
    }
}

ULONG
VgaGetChildDescriptor(
    PVOID HwDeviceExtension,
    PVIDEO_CHILD_ENUM_INFO ChildEnumInfo,
    PVIDEO_CHILD_TYPE pChildType,
    PVOID pChildDescriptor,
    PULONG pUId,
    PULONG pUnused
    )


/*++

Routine Description:

    Enumerate all child devices controlled by the Permedia 2 chip.

    This includes DDC monitors attached to the board, as well as other devices
        which may be connected to a proprietary bus.

Arguments:

    HwDeviceExtension -
            Pointer to our hardware device extension structure.

    ChildEnumInfo -
            Information about the device that should be enumerated.

    pChildType -
            Type of child we are enumerating - monitor, I2C ...

    pChildDescriptor -
            Identification structure of the device (EDID, string)

    pUId -
            Private unique 32 bit ID to passed back to the miniport

    pUnused -
            Do not use

Return Value:

    ERROR_NO_MORE_DEVICES -
            if no more child devices exist.

    ERROR_INVALID_NAME -
            The miniport could not enumerate the child device identified in
                    ChildEnumInfo but does have more devices to be enumerated.

    ERROR_MORE_DATA -
            There are more devices to be enumerated.

Note:

    In the event of a failure return, none of the fields are valid except for
        the return value and the pMoreChildren field.

--*/

{
    PHW_DEVICE_EXTENSION hwDeviceExtension = HwDeviceExtension;

    switch(ChildEnumInfo->ChildIndex)
    {
        case 0:

            //
            // Case 0 is used to enumerate devices found by the ACPI bios.
            // We don't support these, so return appropriate error.
            //

            return ERROR_NO_MORE_DEVICES;

        case 1:

            //
            // Enumerate the monitor
            //

            *pChildType = Monitor;

            //
            // Try to read the EDID from the monitor using the video BIOS
            //

            VgaGetMonitorEdid(hwDeviceExtension,
                              pChildDescriptor,
                              ChildEnumInfo->ChildDescriptorSize);

            *pUId = VGA_MONITOR_ID;

            break;

        default:

            return ERROR_NO_MORE_DEVICES;
    }

    return ERROR_MORE_DATA;
}

VOID
VgaGetMonitorEdid(
    PHW_DEVICE_EXTENSION hwDeviceExtension,
    PUCHAR Buffer,
    ULONG Size
    )

/*++

--*/

{
    PVIDEO_PORT_INT10_INTERFACE pInt10;
    INT10_BIOS_ARGUMENTS BiosArguments;
    VP_STATUS status;
    USHORT VdmSeg;
    USHORT VdmOff;
    ULONG Length = 0x1000;

    pInt10 = &hwDeviceExtension->Int10;

    //
    // Some video bios's get stuck in an infinite loop if we try to
    // read the edid while the monitor is powered off.  If the
    // monitor is off, we'll return the most recently retrieved EDID
    // value instead of trying to retrieve it again.
    //

    if ((hwDeviceExtension->MonitorPowerState == VideoPowerOn) &&
        !(hwDeviceExtension->AlwaysUseCachedEdid)) {

        //
        // Zero initialize the buffer
        //

        memset(Buffer, 0, Size);

        if (pInt10->Size) {

            if (pInt10->Int10AllocateBuffer(pInt10->Context,
                                            &VdmSeg,
                                            &VdmOff,
                                            &Length) != NO_ERROR) {

                return;
            }

            //
            // Call VESA BIOS to get read EDID
            //

            BiosArguments.Eax = 0x4f15;
            BiosArguments.Ebx = 1;
            BiosArguments.Ecx = 0;
            BiosArguments.Edx = 0;

            BiosArguments.SegEs = VdmSeg;
            BiosArguments.Edi   = VdmOff;

            status = pInt10->Int10CallBios(pInt10->Context, &BiosArguments);

            //
            // Check to see if DDC is supported
            //

            if (status == NO_ERROR && VESA_SUCCESS(BiosArguments.Eax)) {

                //
                // We retrieved a valid EDID block.  Copy it into
                // our buffer.
                //

                if (pInt10->Int10ReadMemory(pInt10->Context,
                                            VdmSeg,
                                            VdmOff,
                                            Buffer,
                                            min(Size, EDID_BUFFER_SIZE)) == NO_ERROR) {

                    //
                    // copy the edid into our edid cache
                    //

                    memcpy(hwDeviceExtension->EdidBuffer, Buffer, EDID_BUFFER_SIZE);
                }
            }

            pInt10->Int10FreeBuffer(pInt10->Context,
                                    VdmSeg,
                                    VdmOff);
        }

    } else {

        //
        // return the cached edid.  If we haven't cached an edid yet, the
        // zero initialized buffer will be copied.
        //

        memcpy(Buffer, hwDeviceExtension->EdidBuffer, EDID_BUFFER_SIZE);
    }
}

#define S3_VENDORID     0x5333
#define SAV4_DEVICEID   0x8a22
#define NV3_VENDORID    0x12D2
#define NV3_DEVICEID    0x0018
#define NV3_SUBVENDORID 0x8086 
#define NV3_SUBSYSTEMID 0x5243


VOID
VgaInitializeSpecialCase(
     PHW_DEVICE_EXTENSION hwDeviceExtension
     )
{
    PCI_COMMON_CONFIG ConfigSpace;

    hwDeviceExtension->AlwaysUseCachedEdid = FALSE;        

    if (PCI_COMMON_HDR_LENGTH ==
        VideoPortGetBusData(hwDeviceExtension,
                            PCIConfiguration,
                            0,
                            &ConfigSpace,
                            0,
                            PCI_COMMON_HDR_LENGTH)) {
	
        hwDeviceExtension->DeviceID = ConfigSpace.DeviceID;
        hwDeviceExtension->VendorID = ConfigSpace.VendorID;

        if(hwDeviceExtension->VendorID == S3_VENDORID && 
           hwDeviceExtension->DeviceID == SAV4_DEVICEID) {

            //
            //  System hard hangs if we retrieve EDID through SAV4's bios while 
            //  GDI or driver is accessing framebuffer. So we only read EDID once
            //  at HwInitialize time.
            //

            VgaGetMonitorEdid (hwDeviceExtension, hwDeviceExtension->EdidBuffer, EDID_BUFFER_SIZE);  
            hwDeviceExtension->AlwaysUseCachedEdid = TRUE;        
        } 

        if(hwDeviceExtension->VendorID == NV3_VENDORID && 
           hwDeviceExtension->DeviceID == NV3_DEVICEID &&
           ConfigSpace.u.type0.SubVendorID == NV3_SUBVENDORID &&
           ConfigSpace.u.type0.SubSystemID == NV3_SUBSYSTEMID) {

            //
            // The video bios of this device spins while we try to retrive
            // EDID with VESA function 0x4f15. We'll avoid to call this VESA 
            // function for this device.
            //

            hwDeviceExtension->AlwaysUseCachedEdid = TRUE;        
        } 
    }
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\vga\mini\vesa.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    vesa.h

Abstract:

    This module implements VESA support.

Author:

    Erick Smith (ericks) Sep. 2000

Environment:

    kernel mode only

Revision History:

--*/

#define VBE_GET_CONTROLLER_INFO 0x4F00
#define VBE_GET_MODE_INFO       0x4F01
#define VBE_SET_MODE            0x4F02
#define VBE_GET_MODE            0x4F03
#define VBE_SAVE_RESTORE_STATE  0x4F04
#define VBE_WINDOW_CONTROL      0x4F05
#define VBE_SCANLINE            0x4F06
#define VBE_DISPLAY_START       0x4F07
#define VBE_PALLET_FORMAT       0x4F08
#define VBE_PALLET_DATA         0x4F09
#define VBE_PROTECTED_MODE      0x4F0A
#define VBE_PIXEL_CLOCK         0x4F0B

#define VESA_POWER_FUNCTION 0x4f10
#define VESA_POWER_ON       0x0000
#define VESA_POWER_STANDBY  0x0100
#define VESA_POWER_SUSPEND  0x0200
#define VESA_POWER_OFF      0x0400
#define VESA_GET_POWER_FUNC 0x0000
#define VESA_SET_POWER_FUNC 0x0001

#define VESA_STATUS_SUCCESS 0x004F
#define VESA_SUCCESS(Status) (((Status) & 0xFFFF) == VESA_STATUS_SUCCESS)

//
// VESA SuperVGA structures
//

#pragma pack(1)
typedef struct _VGA_INFO_BLOCK
{
    ULONG VesaSignature;
    USHORT VbeVersion;
    ULONG OemStringPtr;
    ULONG Capabilities;
    ULONG VideoModePtr;
    USHORT TotalMemory;

    //
    // VBE 2.0
    //

    USHORT OemSoftwareRev;
    ULONG OemVendorNamePtr;
    ULONG OemProductNamePtr;
    ULONG OemProductRevPtr;
    UCHAR Reserved[222];

    UCHAR OemData[256];

} VGA_INFO_BLOCK, *PVGA_INFO_BLOCK;

typedef struct _MODE_INFO_BLOCK
{
    USHORT ModeAttributes;
    UCHAR WinAAttributes;
    UCHAR WinBAttributes;
    USHORT WinGranularity;
    USHORT WinSize;
    USHORT WinASegment;
    USHORT WinBSegment;
    ULONG WinFuncPtr;
    USHORT BytesPerScanLine;

    USHORT XResolution;
    USHORT YResolution;
    UCHAR XCharSize;
    UCHAR YCharSize;
    UCHAR NumberOfPlanes;
    UCHAR BitsPerPixel;
    UCHAR NumberOfBanks;
    UCHAR MemoryModel;
    UCHAR BankSize;
    UCHAR NumberOfImagePages;
    UCHAR Reserved1;

    UCHAR RedMaskSize;
    UCHAR RedFieldPosition;
    UCHAR GreenMaskSize;
    UCHAR GreenFieldPosition;
    UCHAR BlueMaskSize;
    UCHAR BlueFieldPosition;
    UCHAR RsvdMaskSize;
    UCHAR RsvdFieldPosition;
    UCHAR DirectColorModeInfo;

    //
    // VBE 2.0
    //

    ULONG PhysBasePtr;
    ULONG Reserved2;
    USHORT Reserved3;

    //
    // VBE 3.0
    //

    USHORT LinBytesPerScanLine;
    UCHAR BnkNumberOfImagePages;
    UCHAR LinNumberOfImagePages;
    UCHAR LinRedMaskSize;
    UCHAR LinRedFieldPosition;
    UCHAR LinGreenMaskSize;
    UCHAR LinGreenFieldPosition;
    UCHAR LinBlueMaskSize;
    UCHAR LinBlueFieldPosition;
    UCHAR LinRsvdMaskSize;
    UCHAR LinRsvdFieldPosition;
    ULONG MaxPixelClock;

    UCHAR Reserved4[190];

} MODE_INFO_BLOCK, *PMODE_INFO_BLOCK;

typedef struct _PALETTE_ENTRY
{
    UCHAR Blue;
    UCHAR Green;
    UCHAR Red;
    UCHAR Alignment;
} PALETTE_ENTRY, *PPALETTE_ENTRY;

#pragma pack()

typedef struct _VESA_INFO
{
    USHORT ModeNumber;
    ULONG FrameBufferSize;
    MODE_INFO_BLOCK ModeInfoBlock;
    ULONG HardwareStateSize;
    UCHAR HardwareState[];
} VESA_INFO, *PVESA_INFO;


#define VDM_TRANSFER_SEGMENT 0x2000
#define VDM_TRANSFER_OFFSET  0x0000

#define VBE_CAP_DAC_WIDTH_8BPP              0x01
#define VBE_CAP_NOT_VGA                     0x02
#define VBE_CAP_VSYNC_ON_PALETTE_UPDATE     0x04
#define VBE_CAP_STEREO_SIGNAL               0x08
#define VBE_CAP_STEREO_EVC_CONNECTOR        0x10

#define SEG(x) ((x) >> 16)
#define OFF(x) ((x) & 0xffff)

#define TRANSFER_ADDRESS ((VDM_TRANSFER_SEGMENT << 4) + VDM_TRANSFER_OFFSET)
#define INFOBLOCK_OFFSET(x) ((SEG((x)) << 4) + OFF((x)) - TRANSFER_ADDRESS)

#define IS_LINEAR_MODE(x) (((x)->fbType & VIDEO_MODE_LINEAR) ? TRUE : FALSE)

VOID
InitializeModeTable(
    PVOID HwDeviceExtension
    );

BOOLEAN
ValidateVbeInfo(
    PHW_DEVICE_EXTENSION hwDeviceExtension,
    PVGA_INFO_BLOCK InfoBlock
    );

VOID
UpdateRegistry(
    PHW_DEVICE_EXTENSION hwDeviceExtension,
    PWSTR ValueName,
    PUCHAR Value
    );

ULONG
GetVideoMemoryBaseAddress(
    PHW_DEVICE_EXTENSION hwDeviceExtension,
    PVIDEOMODE pRequestedMode
    );

VP_STATUS
VBESetMode(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    USHORT VesaModeNumber
    );

USHORT
VBEGetMode(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    );

VP_STATUS
VBEGetModeInfo(
    PHW_DEVICE_EXTENSION hwDeviceExtension,
    USHORT ModeNumber,
    PMODE_INFO_BLOCK ModeInfoBlock
    );

ULONG
VBESaveState(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PCHAR StateBuffer
    );

VP_STATUS
VBERestoreState(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PCHAR StateBuffer,
    ULONG Size
    );

VP_STATUS
VBESetDisplayWindow(
    PHW_DEVICE_EXTENSION hwDeviceExtension,
    UCHAR WindowSelect,
    USHORT WindowNumber
    );

USHORT
VBEGetDisplayWindow(
    PHW_DEVICE_EXTENSION hwDeviceExtension,
    UCHAR WindowSelect
    );

USHORT
VBEGetScanLineLength(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    );

VP_STATUS
VesaSaveHardwareState(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_HARDWARE_STATE HardwareState,
    ULONG HardwareStateSize,
    USHORT ModeNumber
    );

PCHAR
SaveFrameBuffer(
    PHW_DEVICE_EXTENSION hwDeviceExtension, 
    PVESA_INFO pVesaInfo
    );

BOOLEAN
IsSavedModeVesa(
    PVIDEO_HARDWARE_STATE HardwareState
    );

VP_STATUS
VesaRestoreHardwareState(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_HARDWARE_STATE HardwareState,
    ULONG HardwareStateSize
    );

ULONG
RestoreFrameBuffer(
    PHW_DEVICE_EXTENSION hwDeviceExtension, 
    PVESA_INFO pVesaInfo,
    PCHAR FrameBufferData
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\vga\mini\vgadata.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    vgadata.c

Abstract:

    This module contains all the global data used by the VGA driver.

Environment:

    Kernel mode

Revision History:


--*/

#include "dderror.h"
#include "devioctl.h"
#include "miniport.h"

#include "ntddvdeo.h"
#include "video.h"
#include "vga.h"

#include "cmdcnst.h"

#if defined(ALLOC_PRAGMA)
#pragma data_seg("PAGE_DATA")
#endif


//
// Global to make sure driver is only loaded once.
//

ULONG VgaLoaded = 0;

#if DBG
ULONG giControlCode;
ULONG gaIOControlCode[MAX_CONTROL_HISTORY];
#endif


//
// This structure describes to which ports access is required.
//

VIDEO_ACCESS_RANGE VgaAccessRange[] = {
{
    VGA_BASE_IO_PORT, 0x00000000,                // 64-bit linear base address
                                                 // of range
    VGA_START_BREAK_PORT - VGA_BASE_IO_PORT + 1, // # of ports
    1,                                           // range is in I/O space
    1,                                           // range should be visible
#if defined(PLUG_AND_PLAY)
    0                                            // range should NOT be shareable
#else
    1                                            // range should be shareable
#endif
},
{
    VGA_END_BREAK_PORT, 0x00000000,
    VGA_MAX_IO_PORT - VGA_END_BREAK_PORT + 1,
    1,
    1,
#if defined(PLUG_AND_PLAY)
    0
#else
    1
#endif
},
{
    MEM_VGA, 0x00000000,
    MEM_VGA_SIZE,
    0,
    1,
#if defined(PLUG_AND_PLAY)
    0
#else
    1
#endif
},
    // HACK Allow our standard VGA to be used with ATI cards:
    // ATI uses an extra IO port at location 1CE on pretty much all of its
    // video boards
{
    0x000001CE, 0x00000000,
    2,
    1,
    1,
    1
},
    // Another HACK to fix ATI problems.  During GUI mode setup
    // Network detection may touch ports in the 0x2e8 to 0x2ef range.  ATI
    // decodes these ports, and the video goes out of sync when network
    // detection runs.
    //
    // NOTE: We don't need to add this to validator routines since the
    // ATI bios won't touch these registers.
{
    0x000002E8, 0x00000000,
    8,
    1,
    1,
    1
}
};


//
// Validator Port list.
// This structure describes all the ports that must be hooked out of the V86
// emulator when a DOS app goes to full-screen mode.
// The structure determines to which routine the data read or written to a
// specific port should be sent.
//

EMULATOR_ACCESS_ENTRY VgaEmulatorAccessEntries[] = {

    //
    // Traps for byte OUTs.
    //

    {
        0x000003b0,                   // range start I/O address
        0xC,                          // range length
        Uchar,                        // access size to trap
        EMULATOR_READ_ACCESS | EMULATOR_WRITE_ACCESS, // types of access to trap
        FALSE,                        // does not support string accesses
        (PVOID)VgaValidatorUcharEntry // routine to which to trap
    },

    {
        0x000003c0,                   // range start I/O address
        0x20,                         // range length
        Uchar,                        // access size to trap
        EMULATOR_READ_ACCESS | EMULATOR_WRITE_ACCESS, // types of access to trap
        FALSE,                        // does not support string accesses
        (PVOID)VgaValidatorUcharEntry // routine to which to trap
    },

    //
    // Traps for word OUTs.
    //

    {
        0x000003b0,
        0x06,
        Ushort,
        EMULATOR_READ_ACCESS | EMULATOR_WRITE_ACCESS,
        FALSE,
        (PVOID)VgaValidatorUshortEntry
    },

    {
        0x000003c0,
        0x10,
        Ushort,
        EMULATOR_READ_ACCESS | EMULATOR_WRITE_ACCESS,
        FALSE,
        (PVOID)VgaValidatorUshortEntry
    },

    //
    // Traps for dword OUTs.
    //

    {
        0x000003b0,
        0x03,
        Ulong,
        EMULATOR_READ_ACCESS | EMULATOR_WRITE_ACCESS,
        FALSE,
        (PVOID)VgaValidatorUlongEntry
    },

    {
        0x000003c0,
        0x08,
        Ulong,
        EMULATOR_READ_ACCESS | EMULATOR_WRITE_ACCESS,
        FALSE,
        (PVOID)VgaValidatorUlongEntry
    },

    //
    // ATI hack for port 1CE
    //

    {
        0x000001ce,
        0x2,
        Uchar,
        EMULATOR_READ_ACCESS | EMULATOR_WRITE_ACCESS,
        FALSE,
        (PVOID)VgaValidatorUcharEntry
    },

    {
        0x000001ce,
        0x1,
        Ushort,
        EMULATOR_READ_ACCESS | EMULATOR_WRITE_ACCESS,
        FALSE,
        (PVOID)VgaValidatorUshortEntry
    }

};


//
// Used to trap only the sequncer and the misc output registers
//

VIDEO_ACCESS_RANGE MinimalVgaValidatorAccessRange[] = {
{
    VGA_BASE_IO_PORT, 0x00000000,
    VGA_START_BREAK_PORT - VGA_BASE_IO_PORT + 1,
    1,
    1,        // <- enable range IOPM so that it is not trapped.
    1
},
{
    VGA_END_BREAK_PORT, 0x00000000,
    VGA_MAX_IO_PORT - VGA_END_BREAK_PORT + 1,
    1,
    1,
    1
},
{
    VGA_BASE_IO_PORT + MISC_OUTPUT_REG_WRITE_PORT, 0x00000000,
    0x00000001,
    1,
    0,
    1
},
{
    VGA_BASE_IO_PORT + SEQ_ADDRESS_PORT, 0x00000000,
    0x00000002,
    1,
    0,
    1
},
    // HACK Allow our standard VGA to be used with ATI cards:
    // ATI uses an extra IO port at location 1CE on pretty much all of its
    // video boards
{
    0x000001CE, 0x00000000,
    2,
    1,
    1,
    1
}
};

//
// Used to trap all registers
//

VIDEO_ACCESS_RANGE FullVgaValidatorAccessRange[] = {
{
    VGA_BASE_IO_PORT, 0x00000000,
    VGA_START_BREAK_PORT - VGA_BASE_IO_PORT + 1,
    1,
    0,        // <- disable range in the IOPM so that it is trapped.
    1
},
{
    VGA_END_BREAK_PORT, 0x00000000,
    VGA_MAX_IO_PORT - VGA_END_BREAK_PORT + 1,
    1,
    0,
    1
},
    // HACK Allow our standard VGA to be used with ATI cards:
    // ATI uses an extra IO port at location 1CE on pretty much all of its
    // video boards
{
    0x000001CE, 0x00000000,
    2,
    1,
    0,
    1
}
};


//
// Color graphics mode 0x12, 640x480 16 colors.
//

USHORT VGA_640x480[] = {
    OWM,                            // start sync reset program up sequencer
    SEQ_ADDRESS_PORT,
    5,
    0x0100,0x0101,0x0f02,0x0003,0x0604,

    OB,
    MISC_OUTPUT_REG_WRITE_PORT,     // Misc output register
    0xe3,

    OW,                             // Set chain mode in sync reset
    GRAPH_ADDRESS_PORT,
    0x0506,

    OB,                             // EndSyncResetCmd
    SEQ_ADDRESS_PORT,
    IND_SYNC_RESET,

    OB,
    SEQ_DATA_PORT,
    END_SYNC_RESET_VALUE,

    OW,                             // Unlock CRTC registers 0-7
    CRTC_ADDRESS_PORT_COLOR,
    0x0511,

    METAOUT+INDXOUT,                // program crtc registers
    CRTC_ADDRESS_PORT_COLOR,
    VGA_NUM_CRTC_PORTS,             // count
    0,                              // start index
    0x5F,0x4F,0x50,0x82,0x54,0x80,0x0B,0x3E,0x00,0x40,0x0,0x0,0x0,0x0,0x0,0x0,
    0xEA,0x8C,0xDF,0x28,0x0,0xE7,0x4,0xE3,0xFF,

    IB,                             // prepare atc for writing
    INPUT_STATUS_1_COLOR,

    METAOUT+ATCOUT,                 // program attribute controller registers
    ATT_ADDRESS_PORT,               // port
    VGA_NUM_ATTRIB_CONT_PORTS,      // count
    0,                              // start index
    0x0,0x1,0x2,0x3,0x4,0x5,0x14,0x7,0x38,0x39,0x3A,0x3B,0x3C,0x3D,0x3E,0x3F,
    0x01,0x0,0x0F,0x0,0x0,

    METAOUT+INDXOUT,                // program graphics controller registers
    GRAPH_ADDRESS_PORT,             // port
    VGA_NUM_GRAPH_CONT_PORTS,       // count
    0,                              // start index
    0x00,0x0,0x0,0x0,0x0,0x0,0x05,0x0F,0x0FF,

    OB,                             // DAC mask registers
    DAC_PIXEL_MASK_PORT,
    0xFF,

    IB,                             // prepare atc for writing
    INPUT_STATUS_1_COLOR,

    OB,                             // turn video on.
    ATT_ADDRESS_PORT,
    VIDEO_ENABLE,

    EOD
};

//
// Color text mode, 720x480
//

USHORT VGA_TEXT_0[] = {

    OWM,
    SEQ_ADDRESS_PORT,
    5,
    0x0100,0x0001,0x0302,0x0003,0x0204,    // program up sequencer

    OB,
    MISC_OUTPUT_REG_WRITE_PORT,
    0x67,

    OW,
    GRAPH_ADDRESS_PORT,
    0x0e06,

//  EndSyncResetCmd
    OB,
    SEQ_ADDRESS_PORT,
    IND_SYNC_RESET,

    OB,
    SEQ_DATA_PORT,
    END_SYNC_RESET_VALUE,

    OW,
    CRTC_ADDRESS_PORT_COLOR,
    0x0E11,

    METAOUT+INDXOUT,                // program crtc registers
    CRTC_ADDRESS_PORT_COLOR,
    VGA_NUM_CRTC_PORTS,             // count
    0,                              // start index
    0x5F,0x4f,0x50,0x82,0x55,0x81,0xbf,0x1f,0x00,0x4f,0xd,0xe,0x0,0x0,0x0,0x0,
    0x9c,0x8e,0x8f,0x28,0x1f,0x96,0xb9,0xa3,0xFF,

    IB,                             // prepare atc for writing
    INPUT_STATUS_1_COLOR,

    METAOUT+ATCOUT,                 //
    ATT_ADDRESS_PORT,               // port
    VGA_NUM_ATTRIB_CONT_PORTS,      // count
    0,                              // start index
    0x0,0x1,0x2,0x3,0x4,0x5,0x14,0x7,0x38,0x39,0x3a,0x3b,0x3c,0x3d,0x3e,0x3f,
    0x04,0x0,0x0F,0x8,0x0,

    METAOUT+INDXOUT,                //
    GRAPH_ADDRESS_PORT,             // port
    VGA_NUM_GRAPH_CONT_PORTS,       // count
    0,                              // start index
    0x00,0x0,0x0,0x0,0x0,0x10,0x0e,0x0,0x0FF,

    OB,
    DAC_PIXEL_MASK_PORT,
    0xFF,

    IB,                             // prepare atc for writing
    INPUT_STATUS_1_COLOR,

    OB,                             // turn video on.
    ATT_ADDRESS_PORT,
    VIDEO_ENABLE,

    EOD
};


//
// Color text mode, 640x480
//

USHORT VGA_TEXT_1[] = {
    OWM,
    SEQ_ADDRESS_PORT,
    5,
    0x0100,0x0101,0x0302,0x0003,0x0204,    // program up sequencer

    OB,
    MISC_OUTPUT_REG_WRITE_PORT,
    0xa3,

    OW,
    GRAPH_ADDRESS_PORT,
    0x0e06,

//  EndSyncResetCmd
    OB,
    SEQ_ADDRESS_PORT,
    IND_SYNC_RESET,

    OB,
    SEQ_DATA_PORT,
    END_SYNC_RESET_VALUE,

    OW,
    CRTC_ADDRESS_PORT_COLOR,
    0x0511,

    METAOUT+INDXOUT,                // program crtc registers
    CRTC_ADDRESS_PORT_COLOR,
    VGA_NUM_CRTC_PORTS,             // count
    0,                              // start index
    0x5F,0x4f,0x50,0x82,0x55,0x81,0xbf,0x1f,0x00,0x4d,0xb,0xc,0x0,0x0,0x0,0x0,
    0x83,0x85,0x5d,0x28,0x1f,0x63,0xba,0xa3,0xFF,

    IB,                             // prepare atc for writing
    INPUT_STATUS_1_COLOR,

    METAOUT+ATCOUT,                 //
    ATT_ADDRESS_PORT,               // port
    VGA_NUM_ATTRIB_CONT_PORTS,      // count
    0,                              // start index
    0x0,0x1,0x2,0x3,0x4,0x5,0x14,0x7,0x38,0x39,0x3a,0x3b,0x3c,0x3d,0x3e,0x3f,
    0x00,0x0,0x0F,0x0,0x0,

    METAOUT+INDXOUT,                //
    GRAPH_ADDRESS_PORT,             // port
    VGA_NUM_GRAPH_CONT_PORTS,       // count
    0,                              // start index
    0x00,0x0,0x0,0x0,0x0,0x10,0x0e,0x0,0x0FF,

    OB,
    DAC_PIXEL_MASK_PORT,
    0xFF,

    IB,                             // prepare atc for writing
    INPUT_STATUS_1_COLOR,

    OB,                             // turn video on.
    ATT_ADDRESS_PORT,
    VIDEO_ENABLE,

    EOD
};

USHORT ModeX200[] = {
    OW,
    SEQ_ADDRESS_PORT,
    0x0604,

    OWM,
    CRTC_ADDRESS_PORT_COLOR,
    2,
    0xe317,
    0x0014,

    EOD
};

USHORT ModeX240[] = {
    OWM,
    SEQ_ADDRESS_PORT,
    2,
    0x0604,
    0x0100,

    OB,
    MISC_OUTPUT_REG_WRITE_PORT,
    0xe3,

    OW,
    SEQ_ADDRESS_PORT,
    0x0300,

    OB,
    CRTC_ADDRESS_PORT_COLOR,
    0x11,

    METAOUT+MASKOUT,
    CRTC_DATA_PORT_COLOR,
    0x7f, 0x00,

    OWM,
    CRTC_ADDRESS_PORT_COLOR,
    10,
    0x0d06,
    0x3e07,
    0x4109,
    0xea10,
    0xac11,
    0xdf12,
    0x0014,
    0xe715,
    0x0616,
    0xe317,

    OW,
    SEQ_ADDRESS_PORT,
    0x0f02,

    EOD
};

USHORT ModeXDoubleScans[] = {

    OW, CRTC_ADDRESS_PORT_COLOR,    0x4009,

    EOD
};

//
// We will dynamically build a list of supported modes, based on the VESA
// modes the card supports.
//

PVIDEOMODE VgaModeList;

//
// Video mode table - contains information and commands for initializing each
// mode. These entries must correspond with those in VIDEO_MODE_VGA. The first
// entry is commented; the rest follow the same format, but are not so
// heavily commented.
//


VIDEOMODE ModesVGA[] = {

//
// Mode index 0
// Color text mode 3, 720x400, 9x16 char cell (VGA).
//

{
  VIDEO_MODE_COLOR |
  VIDEO_MODE_BANKED,  // flags that this mode is a color mode, but not graphics
  4,                 // four planes
  1,                 // one bit of color per plane
  80, 25,            // 80x25 text resolution
  720, 400,          // 720x400 pixels on screen
  1,                 // Frequency in Hz
  160, 0x10000,      // 160 bytes per scan line, 64K of CPU-addressable bitmap
  NoBanking,         // no banking supported or needed in this mode
  0x3,
  VGA_TEXT_0,              // pointer to the command strings
  MEM_VGA, 0x18000, 0x08000, MEM_VGA_SIZE,
  720
},

//
// Mode index 1.
// Color text mode 3, 640x350, 8x14 char cell (EGA).
//

{
  VIDEO_MODE_COLOR | VIDEO_MODE_BANKED, 4, 1, 80, 25, 640, 350, 1, 160, 0x10000, NoBanking,
  0x3,
  VGA_TEXT_1,              // pointer to the command strings
  MEM_VGA, 0x18000, 0x08000, MEM_VGA_SIZE,
  640
},

//
//
// Mode index 2
// Standard VGA Color graphics mode 0x12, 640x480 16 colors.
//

{
  VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS | VIDEO_MODE_BANKED, 4, 1, 80, 30,
  640, 480, 1, 80, 0x10000, NoBanking,
  0x12,
  VGA_640x480,             // pointer to the command strings
  MEM_VGA, 0x0000, MEM_VGA_SIZE, MEM_VGA_SIZE,
  640
},


//
// 320x200 256 colors ModeX
//

{ VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS | VIDEO_MODE_BANKED, 8, 1, 0, 0,
  320, 200, 70, 80, 0x10000, NoBanking,
  0x13,
  NULL,
  MEM_VGA, 0x0000, MEM_VGA_SIZE, MEM_VGA_SIZE,
  320
},

//
// 320x240 256 colors ModeX
//

{ VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS | VIDEO_MODE_BANKED, 8, 1, 0, 0,
  320, 240, 60, 80, 0x10000, NoBanking,
  0x13,
  NULL,
  MEM_VGA, 0x0000, MEM_VGA_SIZE, MEM_VGA_SIZE,
  320
},

//
// 320x400 256 colors ModeX
//

{ VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS | VIDEO_MODE_BANKED, 8, 1, 0, 0,
  320, 400, 70, 80, 0x10000, NoBanking,
  0x13,
  NULL,
  MEM_VGA, 0x0000, MEM_VGA_SIZE,
  320
},

//
// 320x480 256 colors ModeX
//

{ VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS | VIDEO_MODE_BANKED, 8, 1, 0, 0,
  320, 480, 60, 80, 0x10000, NoBanking,
  0x13,
  NULL,
  MEM_VGA, 0x0000, MEM_VGA_SIZE,
  320
},

//
// 800x600 16 colors.
//
// NOTE: This must be the last mode in our static mode table.
//

{ VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS | VIDEO_MODE_BANKED, 4, 1, 100, 37,
  800, 600, 1, 100, 0x10000, NoBanking,
  0x01024F02,
  NULL,
  MEM_VGA, 0x0000, MEM_VGA_SIZE, MEM_VGA_SIZE,
  800
},

};

ULONG NumVideoModes = sizeof(ModesVGA) / sizeof(VIDEOMODE);

//
//
// Data used to set the Graphics and Sequence Controllers to put the
// VGA into a planar state at A0000 for 64K, with plane 2 enabled for
// reads and writes, so that a font can be loaded, and to disable that mode.
//

// Settings to enable planar mode with plane 2 enabled.
//

USHORT EnableA000Data[] = {
    OWM,
    SEQ_ADDRESS_PORT,
    1,
    0x0100,

    OWM,
    GRAPH_ADDRESS_PORT,
    3,
    0x0204,     // Read Map = plane 2
    0x0005, // Graphics Mode = read mode 0, write mode 0
    0x0406, // Graphics Miscellaneous register = A0000 for 64K, not odd/even,
            //  graphics mode
    OWM,
    SEQ_ADDRESS_PORT,
    3,
    0x0402, // Map Mask = write to plane 2 only
    0x0404, // Memory Mode = not odd/even, not full memory, graphics mode
    0x0300,  // end sync reset
    EOD
};

//
// Settings to disable the font-loading planar mode.
//

USHORT DisableA000Color[] = {
    OWM,
    SEQ_ADDRESS_PORT,
    1,
    0x0100,

    OWM,
    GRAPH_ADDRESS_PORT,
    3,
    0x0004, 0x1005, 0x0E06,

    OWM,
    SEQ_ADDRESS_PORT,
    3,
    0x0302, 0x0204, 0x0300,  // end sync reset
    EOD

};


#if defined(ALLOC_PRAGMA)
#pragma data_seg()
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\vgarisc\disp\draw.c ===
/******************************Module*Header*******************************\
* Module Name: draw.c
*
* The drawing guts of a portable 16-colour VGA driver for Windows NT.  The
* implementation herein may possibly be the simplest method of bringing
* up a driver whose surface is not directly writable by GDI.  One might
* use the phrase "quick and dirty" when describing it.
*
* We create a 4bpp bitmap that is the size of the screen, and simply
* have GDI do all the drawing to it.  We update the screen directly
* from the bitmap, based on the bounds of the drawing (basically
* employing "dirty rectangles").
*
* In total, the only hardware-specific code we had to write was the
* initialization code, and a routine for doing aligned srccopy blts
* from a DIB to the screen.
*
* Obvious Note: This approach is definitely not recommended if you want
*               to get decent performance.
*
* Copyright (c) 1994-1995 Microsoft Corporation
\**************************************************************************/

#include "precomp.h"

/******************************Public*Routine******************************\
* DrvStrokePath
*
\**************************************************************************/

BOOL DrvStrokePath(
SURFOBJ*   pso,
PATHOBJ*   ppo,
CLIPOBJ*   pco,
XFORMOBJ*  pxo,
BRUSHOBJ*  pbo,
POINTL*    pptlBrush,
LINEATTRS* pla,
MIX        mix)
{
    BOOL        b;
    PDEV*       ppdev;
    RECTFX      rcfxBounds;
    RECTL       rclBounds;

    ppdev = (PDEV*) pso->dhpdev;

    b = EngStrokePath(ppdev->pso, ppo, pco, pxo, pbo, pptlBrush, pla, mix);

    // Get the path bounds and make it lower-right exclusive:

    PATHOBJ_vGetBounds(ppo, &rcfxBounds);

    rclBounds.left   = (rcfxBounds.xLeft   >> 4);
    rclBounds.top    = (rcfxBounds.yTop    >> 4);
    rclBounds.right  = (rcfxBounds.xRight  >> 4) + 2;
    rclBounds.bottom = (rcfxBounds.yBottom >> 4) + 2;

    vUpdate(ppdev, &rclBounds, pco);

    return(b);
}

/******************************Public*Routine******************************\
* DrvBitBlt
*
\**************************************************************************/

BOOL DrvBitBlt(
SURFOBJ*  psoDst,
SURFOBJ*  psoSrc,
SURFOBJ*  psoMask,
CLIPOBJ*  pco,
XLATEOBJ* pxlo,
RECTL*    prclDst,
POINTL*   pptlSrc,
POINTL*   pptlMask,
BRUSHOBJ* pbo,
POINTL*   pptlBrush,
ROP4      rop4)
{
    BOOL        bUpdate;
    BOOL        b;
    PDEV*       ppdev;

    bUpdate = FALSE;
    if (psoDst->iType == STYPE_DEVICE)
    {
        bUpdate = TRUE;
        ppdev   = (PDEV*) psoDst->dhpdev;
        psoDst  = ppdev->pso;
    }
    if ((psoSrc != NULL) && (psoSrc->iType == STYPE_DEVICE))
    {
        ppdev   = (PDEV*) psoSrc->dhpdev;
        psoSrc  = ppdev->pso;
    }

    b = EngBitBlt(psoDst, psoSrc, psoMask, pco, pxlo, prclDst, pptlSrc,
                  pptlMask, pbo, pptlBrush, rop4);

    if (bUpdate)
    {
        vUpdate(ppdev, prclDst, pco);
    }

    return(b);
}

/******************************Public*Routine******************************\
* DrvCopyBits
*
\**************************************************************************/

BOOL DrvCopyBits(
SURFOBJ*  psoDst,
SURFOBJ*  psoSrc,
CLIPOBJ*  pco,
XLATEOBJ* pxlo,
RECTL*    prclDst,
POINTL*   pptlSrc)
{
    BOOL        bUpdate;
    BOOL        b;
    PDEV*       ppdev;

    return(DrvBitBlt(psoDst, psoSrc, NULL, pco, pxlo, prclDst, pptlSrc,
                     NULL, NULL, NULL, 0xcccc));
}

/******************************Public*Routine******************************\
* DrvTextOut
*
\**************************************************************************/

BOOL DrvTextOut(
SURFOBJ*  pso,
STROBJ*   pstro,
FONTOBJ*  pfo,
CLIPOBJ*  pco,
RECTL*    prclExtra,
RECTL*    prclOpaque,
BRUSHOBJ* pboFore,
BRUSHOBJ* pboOpaque,
POINTL*   pptlOrg,
MIX       mix)
{
    BOOL        b;
    PDEV*       ppdev;

    ppdev = (PDEV*) pso->dhpdev;

    b = EngTextOut(ppdev->pso, pstro, pfo, pco, prclExtra, prclOpaque,
                   pboFore, pboOpaque, pptlOrg, mix);

    vUpdate(ppdev, (prclOpaque != NULL) ? prclOpaque : &pstro->rclBkGround, pco);

    return(b);
}

/******************************Public*Routine******************************\
* DrvPaint
*
\**************************************************************************/

BOOL DrvPaint(
SURFOBJ*  pso,
CLIPOBJ*  pco,
BRUSHOBJ* pbo,
POINTL*   pptlBrush,
MIX       mix)
{
    BOOL        b;
    PDEV*       ppdev;

    ppdev = (PDEV*) pso->dhpdev;

    b = EngPaint(ppdev->pso, pco, pbo, pptlBrush, mix);

    vUpdate(ppdev, &pco->rclBounds, pco);

    return(b);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\vgarisc\disp\enable.c ===
/******************************Module*Header*******************************\
* Module Name: enable.c
*
* The initialization guts of the portable 16-colour VGA driver.
*
* The drawing guts of a portable 16-colour VGA driver for Windows NT.  The
* implementation herein may possibly be the simplest method of bringing
* up a driver whose surface is not directly writable by GDI.  One might
* use the phrase "quick and dirty" when describing it.
*
* We create a 4bpp bitmap that is the size of the screen, and simply
* have GDI do all the drawing to it.  We update the screen directly
* from the bitmap, based on the bounds of the drawing (basically
* employing "dirty rectangles").
*
* In total, the only hardware-specific code we had to write was the
* initialization code, and a routine for doing aligned srccopy blts
* from a DIB to the screen.
*
* Obvious Note: This approach is definitely not recommended for decent
*               driver performance.
*
* Copyright (c) 1994-1995 Microsoft Corporation
\**************************************************************************/

#include "precomp.h"

/******************************Public*Structure****************************\
* DFVFN gadrvfn[]
*
* Build the driver function table gadrvfn with function index/address
* pairs.  This table tells GDI which DDI calls we support, and their
* location (GDI does an indirect call through this table to call us).
*
\**************************************************************************/

static DRVFN gadrvfn[] = {
    {   INDEX_DrvEnablePDEV,            (PFN) DrvEnablePDEV             },
    {   INDEX_DrvCompletePDEV,          (PFN) DrvCompletePDEV           },
    {   INDEX_DrvDisablePDEV,           (PFN) DrvDisablePDEV            },
    {   INDEX_DrvEnableSurface,         (PFN) DrvEnableSurface          },
    {   INDEX_DrvDisableSurface,        (PFN) DrvDisableSurface         },
    {   INDEX_DrvDitherColor,           (PFN) DrvDitherColor            },
    {   INDEX_DrvAssertMode,            (PFN) DrvAssertMode             },
    {   INDEX_DrvGetModes,              (PFN) DrvGetModes               },
    {   INDEX_DrvBitBlt,                (PFN) DrvBitBlt                 },
    {   INDEX_DrvTextOut,               (PFN) DrvTextOut                },
    {   INDEX_DrvStrokePath,            (PFN) DrvStrokePath             },
    {   INDEX_DrvCopyBits,              (PFN) DrvCopyBits               },
    {   INDEX_DrvPaint,                 (PFN) DrvPaint                  },
    {   INDEX_DrvDisableDriver,         (PFN) DrvDisableDriver          }
};

ULONG gcdrvfn = sizeof(gadrvfn) / sizeof(DRVFN);

/******************************Public*Structure****************************\
* GDIINFO ggdiDefault
*
* This contains the default GDIINFO fields that are passed back to GDI
* during DrvEnablePDEV.
*
* NOTE: This structure defaults to values for a 4bpp non-palette device.
\**************************************************************************/

GDIINFO ggdiDefault = {
     GDI_DRIVER_VERSION,
     DT_RASDISPLAY,         // ulTechnology
     0,                     // ulHorzSize
     0,                     // ulVertSize
     0,                     // ulHorzRes (filled in at initialization)
     0,                     // ulVertRes (filled in at initialization)
     4,                     // cBitsPixel
     1,                     // cPlanes
     16,                    // ulNumColors
     0,                     // flRaster (DDI reserved field)

     0,                     // ulLogPixelsX (filled in at initialization)
     0,                     // ulLogPixelsY (filled in at initialization)

     TC_RA_ABLE,            // flTextCaps

     6,                     // ulDACRed
     6,                     // ulDACGree
     6,                     // ulDACBlue

     0x0024,                // ulAspectX  (one-to-one aspect ratio)
     0x0024,                // ulAspectY
     0x0033,                // ulAspectXY

     1,                     // xStyleStep
     1,                     // yStyleSte;
     3,                     // denStyleStep

     { 0, 0 },              // ptlPhysOffset
     { 0, 0 },              // szlPhysSize

     0,                     // ulNumPalReg (win3.1 16 color drivers say 0 too)

// These fields are for halftone initialization.

     {                                          // ciDevice, ColorInfo
        { 6700, 3300, 0 },                      // Red
        { 2100, 7100, 0 },                      // Green
        { 1400,  800, 0 },                      // Blue
        { 1750, 3950, 0 },                      // Cyan
        { 4050, 2050, 0 },                      // Magenta
        { 4400, 5200, 0 },                      // Yellow
        { 3127, 3290, 0 },                      // AlignmentWhite
        20000,                                  // RedGamma
        20000,                                  // GreenGamma
        20000,                                  // BlueGamma
        0, 0, 0, 0, 0, 0
     },

     0,                      // ulDevicePelsDPI  (filled in at initialization)
     PRIMARY_ORDER_CBA,                         // ulPrimaryOrder
     HT_PATSIZE_4x4_M,                          // ulHTPatternSize
     HT_FORMAT_4BPP_IRGB,                       // ulHTOutputFormat
     HT_FLAG_ADDITIVE_PRIMS,                    // flHTFlags

     0,                                         // ulVRefresh
     1,                      // ulBltAlignment (preferred window alignment
                             //   for fast-text routines)
     0,                                         // ulPanningHorzRes
     0,                                         // ulPanningVertRes
};

/******************************Public*Structure****************************\
* DEVINFO gdevinfoDefault
*
* This contains the default DEVINFO fields that are passed back to GDI
* during DrvEnablePDEV.
*
* NOTE: This structure defaults to values for a 4bpp non-palette device.
\**************************************************************************/

#define SYSTM_LOGFONT {16,7,0,0,700,0,0,0,ANSI_CHARSET,OUT_DEFAULT_PRECIS, \
                       CLIP_DEFAULT_PRECIS,DEFAULT_QUALITY, \
                       VARIABLE_PITCH | FF_DONTCARE,L"System"}
#define HELVE_LOGFONT {12,9,0,0,400,0,0,0,ANSI_CHARSET,OUT_DEFAULT_PRECIS, \
                       CLIP_STROKE_PRECIS,PROOF_QUALITY, \
                       VARIABLE_PITCH | FF_DONTCARE,  L"MS Sans Serif"}
#define COURI_LOGFONT {12,9,0,0,400,0,0,0,ANSI_CHARSET,OUT_DEFAULT_PRECIS, \
                       CLIP_STROKE_PRECIS,PROOF_QUALITY, \
                       FIXED_PITCH | FF_DONTCARE, L"Courier"}

DEVINFO gdevinfoDefault =
{
    (GCAPS_MONO_DITHER | GCAPS_COLOR_DITHER),
                    // Graphics capabilities

    SYSTM_LOGFONT,  // Default font description
    HELVE_LOGFONT,  // ANSI variable font description
    COURI_LOGFONT,  // ANSI fixed font description
    0,              // Count of device fonts
    BMF_4BPP,       // preferred DIB format
    8,              // Width of color dither
    8,              // Height of color dither
    0               // Default palette to use for this device
};

/******************************Public*Data*Struct*************************\
* VGALOGPALETTE logPalVGA
*
* This is the palette for the VGA.
*
\**************************************************************************/

typedef struct _VGALOGPALETTE
{
    USHORT          ident;
    USHORT          NumEntries;
    PALETTEENTRY    palPalEntry[16];
} VGALOGPALETTE;

const VGALOGPALETTE logPalVGA =
{
    0x400,  // Driver version
    16,     // Number of entries
    {
        { 0,   0,   0,   0 },       // 0
        { 0x80,0,   0,   0 },       // 1
        { 0,   0x80,0,   0 },       // 2
        { 0x80,0x80,0,   0 },       // 3
        { 0,   0,   0x80,0 },       // 4
        { 0x80,0,   0x80,0 },       // 5
        { 0,   0x80,0x80,0 },       // 6
        { 0x80,0x80,0x80,0 },       // 7

        { 0xC0,0xC0,0xC0,0 },       // 8
        { 0xFF,0,   0,   0 },       // 9
        { 0,   0xFF,0,   0 },       // 10
        { 0xFF,0xFF,0,   0 },       // 11
        { 0,   0,   0xFF,0 },       // 12
        { 0xFF,0,   0xFF,0 },       // 13
        { 0,   0xFF,0xFF,0 },       // 14
        { 0xFF,0xFF,0xFF,0 }        // 15
    }
};

/******************************Public*Routine******************************\
* BOOL DrvEnableDriver
*
* Enables the driver by retrieving the drivers function table and version.
*
\**************************************************************************/

BOOL DrvEnableDriver(
ULONG          iEngineVersion,
ULONG          cj,
DRVENABLEDATA* pded)
{
    // Engine Version is passed down so future drivers can support previous
    // engine versions.  A next generation driver can support both the old
    // and new engine conventions if told what version of engine it is
    // working with.  For the first version the driver does nothing with it.

    // Fill in as much as we can.

    if (cj >= sizeof(DRVENABLEDATA))
        pded->pdrvfn = gadrvfn;

    if (cj >= (sizeof(ULONG) * 2))
        pded->c = gcdrvfn;

    // DDI version this driver was targeted for is passed back to engine.
    // Future graphic's engine may break calls down to old driver format.

    if (cj >= sizeof(ULONG))
        pded->iDriverVersion = DDI_DRIVER_VERSION_NT4;

    return(TRUE);
}

/******************************Public*Routine******************************\
* VOID DrvDisableDriver
*
* Tells the driver it is being disabled. Release any resources allocated in
* DrvEnableDriver.
*
\**************************************************************************/

VOID DrvDisableDriver(VOID)
{
    return;
}

/******************************Public*Routine******************************\
* DWORD getAvailableModes
*
* Calls the miniport to get the list of modes supported by the kernel driver,
* and returns the list of modes supported by the diplay driver among those
*
* returns the number of entries in the videomode buffer.
* 0 means no modes are supported by the miniport or that an error occured.
*
* NOTE: the buffer must be freed up by the caller.
*
\**************************************************************************/

DWORD getAvailableModes(
HANDLE                   hDriver,
PVIDEO_MODE_INFORMATION* modeInformation,
DWORD*                   cbModeSize)
{
    ULONG ulTemp;
    VIDEO_NUM_MODES modes;
    PVIDEO_MODE_INFORMATION pVideoTemp;
    DWORD status;

    //
    // Get the number of modes supported by the mini-port
    //

    if (status = EngDeviceIoControl(hDriver,
            IOCTL_VIDEO_QUERY_NUM_AVAIL_MODES,
            NULL,
            0,
            &modes,
            sizeof(VIDEO_NUM_MODES),
            &ulTemp))
    {
        DISPDBG((0, "getAvailableModes failed VIDEO_QUERY_NUM_AVAIL_MODES"));
        DISPDBG((0, "Win32 Status = %x", status));
        return(0);
    }

    *cbModeSize = modes.ModeInformationLength;

    //
    // Allocate the buffer for the mini-port to write the modes in.
    //

    *modeInformation = (PVIDEO_MODE_INFORMATION)
                        EngAllocMem(FL_ZERO_MEMORY,
                                   modes.NumModes *
                                   modes.ModeInformationLength, ALLOC_TAG);

    if (*modeInformation == (PVIDEO_MODE_INFORMATION) NULL)
    {
        DISPDBG((0, "getAvailableModes failed EngAllocMem"));
        return(0);
    }

    //
    // Ask the mini-port to fill in the available modes.
    //

    if (status = EngDeviceIoControl(hDriver,
            IOCTL_VIDEO_QUERY_AVAIL_MODES,
            NULL,
            0,
            *modeInformation,
            modes.NumModes * modes.ModeInformationLength,
            &ulTemp))
    {

        DISPDBG((0, "getAvailableModes failed VIDEO_QUERY_AVAIL_MODES"));
        DISPDBG((0, "Win32 Status = %x", status));

        EngFreeMem(*modeInformation);
        *modeInformation = (PVIDEO_MODE_INFORMATION) NULL;

        return(0);
    }

    //
    // Now see which of these modes are supported by the display driver.
    // As an internal mechanism, set the length to 0 for the modes we
    // DO NOT support.
    //

    ulTemp = modes.NumModes;
    pVideoTemp = *modeInformation;

    //
    // Mode is rejected if it is not 4 planes, or not graphics, or is not
    // one of 1 bits per pel.
    //

    while (ulTemp--)
    {
        if ((pVideoTemp->NumberOfPlanes != 4 ) ||
            !(pVideoTemp->AttributeFlags & VIDEO_MODE_GRAPHICS) ||
            (pVideoTemp->BitsPerPlane != 1) ||
            (pVideoTemp->VisScreenWidth > 800))
        {
            pVideoTemp->Length = 0;
        }

        pVideoTemp = (PVIDEO_MODE_INFORMATION)
            (((PUCHAR)pVideoTemp) + modes.ModeInformationLength);
    }

    return(modes.NumModes);

}

/******************************Public*Routine******************************\
* BOOL bInitializeModeFields
*
* Initializes a bunch of fields in the pdev, devcaps (aka gdiinfo), and
* devinfo based on the requested mode.
*
\**************************************************************************/

BOOL bInitializeModeFields(
PDEV*     ppdev,
GDIINFO*  pgdi,
DEVINFO*  pdi,
DEVMODEW* pdm)
{
    ULONG                   cModes;
    PVIDEO_MODE_INFORMATION pVideoBuffer;
    PVIDEO_MODE_INFORMATION pVideoModeSelected;
    PVIDEO_MODE_INFORMATION pVideoTemp;
    BOOL                    bSelectDefault;
    VIDEO_MODE_INFORMATION  VideoModeInformation;
    ULONG                   cbModeSize;

    // Call the miniport to get mode information

    cModes = getAvailableModes(ppdev->hDriver, &pVideoBuffer, &cbModeSize);
    if (cModes == 0)
        goto ReturnFalse;

    // Now see if the requested mode has a match in that table.

    pVideoModeSelected = NULL;
    pVideoTemp = pVideoBuffer;

    if ((pdm->dmPelsWidth        == 0) &&
        (pdm->dmPelsHeight       == 0) &&
        (pdm->dmBitsPerPel       == 0) &&
        (pdm->dmDisplayFrequency == 0))
    {
        DISPDBG((1, "Default mode requested"));
        bSelectDefault = TRUE;
    }
    else
    {
        DISPDBG((1, "Requested mode..."));
        DISPDBG((1, "   Screen width  -- %li", pdm->dmPelsWidth));
        DISPDBG((1, "   Screen height -- %li", pdm->dmPelsHeight));
        DISPDBG((1, "   Bits per pel  -- %li", pdm->dmBitsPerPel));
        DISPDBG((1, "   Frequency     -- %li", pdm->dmDisplayFrequency));

        bSelectDefault = FALSE;
    }

    while (cModes--)
    {
        if (pVideoTemp->Length != 0)
        {
            DISPDBG((2, "   Checking against miniport mode:"));
            DISPDBG((2, "      Screen width  -- %li", pVideoTemp->VisScreenWidth));
            DISPDBG((2, "      Screen height -- %li", pVideoTemp->VisScreenHeight));
            DISPDBG((2, "      Bits per pel  -- %li", pVideoTemp->BitsPerPlane *
                                                      pVideoTemp->NumberOfPlanes));
            DISPDBG((2, "      Frequency     -- %li", pVideoTemp->Frequency));

            if (bSelectDefault ||
                ((pVideoTemp->VisScreenWidth  == pdm->dmPelsWidth) &&
                 (pVideoTemp->VisScreenHeight == pdm->dmPelsHeight) &&
                 (pVideoTemp->BitsPerPlane *
                  pVideoTemp->NumberOfPlanes  == pdm->dmBitsPerPel) &&
                 (pVideoTemp->Frequency       == pdm->dmDisplayFrequency)))
            {
                pVideoModeSelected = pVideoTemp;
                DISPDBG((1, "...Found a mode match!"));
                break;
            }
        }

        pVideoTemp = (PVIDEO_MODE_INFORMATION)
            (((PUCHAR)pVideoTemp) + cbModeSize);

    }

    // If no mode has been found, return an error

    if (pVideoModeSelected == NULL)
    {
        DISPDBG((1, "...Couldn't find a mode match!"));
        EngFreeMem(pVideoBuffer);
        goto ReturnFalse;
    }

    // We have chosen the one we want.  Save it in a stack buffer and
    // get rid of allocated memory before we forget to free it.

    VideoModeInformation = *pVideoModeSelected;
    EngFreeMem(pVideoBuffer);

    // Set up screen information from the mini-port:

    ppdev->ulMode           = VideoModeInformation.ModeIndex;
    ppdev->cxScreen         = VideoModeInformation.VisScreenWidth;
    ppdev->cyScreen         = VideoModeInformation.VisScreenHeight;
    ppdev->iBitmapFormat    = BMF_4BPP;

    DISPDBG((1, "ScreenStride: %lx", VideoModeInformation.ScreenStride));

    ppdev->flHooks          = (HOOK_BITBLT     |
                               HOOK_TEXTOUT    |
                               HOOK_COPYBITS   |
                               HOOK_STROKEPATH |
                               HOOK_PAINT);

    ppdev->pjBase = INVALID_BASE_ADDRESS;

    // Fill in the GDIINFO data structure with the default 4bpp values:

    *pgdi = ggdiDefault;

    // Now overwrite the defaults with the relevant information returned
    // from the kernel driver:

    pgdi->ulHorzSize        = VideoModeInformation.XMillimeter;
    pgdi->ulVertSize        = VideoModeInformation.YMillimeter;

    pgdi->ulHorzRes         = VideoModeInformation.VisScreenWidth;
    pgdi->ulVertRes         = VideoModeInformation.VisScreenHeight;
    pgdi->ulPanningHorzRes  = VideoModeInformation.VisScreenWidth;
    pgdi->ulPanningVertRes  = VideoModeInformation.VisScreenHeight;

    pgdi->cBitsPixel        = VideoModeInformation.BitsPerPlane;
    pgdi->cPlanes           = VideoModeInformation.NumberOfPlanes;
    pgdi->ulVRefresh        = VideoModeInformation.Frequency;

    pgdi->ulDACRed          = VideoModeInformation.NumberRedBits;
    pgdi->ulDACGreen        = VideoModeInformation.NumberGreenBits;
    pgdi->ulDACBlue         = VideoModeInformation.NumberBlueBits;

    pgdi->ulLogPixelsX      = pdm->dmLogPixels;
    pgdi->ulLogPixelsY      = pdm->dmLogPixels;

    // Fill in the devinfo structure with the default 4bpp values:

    *pdi = gdevinfoDefault;

    return(TRUE);

ReturnFalse:

    DISPDBG((0, "Failed bInitializeModeFields"));

    return(FALSE);
}

/******************************Public*Routine******************************\
* BOOL bInitializePalette
*
* Initializes default palette for PDEV.
*
\**************************************************************************/

BOOL bInitializePalette(
PDEV*    ppdev,
DEVINFO* pdi)
{
    HPALETTE    hpal;

    hpal = EngCreatePalette(PAL_INDEXED, 16, (ULONG*) (logPalVGA.palPalEntry),
                            0, 0, 0);

    if (hpal == 0)
        goto ReturnFalse;

    ppdev->hpalDefault = hpal;
    pdi->hpalDefault   = hpal;

    return(TRUE);

ReturnFalse:

    DISPDBG((0, "Failed bInitializePalette"));
    return(FALSE);
}

/******************************Public*Routine******************************\
* VOID vUninitializePalette
*
* Frees resources allocated by bInitializePalette.
*
* Note: In an error case, this may be called before bInitializePalette.
*
\**************************************************************************/

VOID vUninitializePalette(PDEV* ppdev)
{
    // Delete the default palette if we created one:

    if (ppdev->hpalDefault != 0)
        EngDeletePalette(ppdev->hpalDefault);
}

/******************************Public*Routine******************************\
* DHPDEV DrvEnablePDEV
*
* Initializes a bunch of fields for GDI, based on the mode we've been asked
* to do.  This is the first thing called after DrvEnableDriver, when GDI
* wants to get some information about us.
*
* (This function mostly returns back information; DrvEnableSurface is used
* for initializing the hardware and driver components.)
*
\**************************************************************************/

DHPDEV DrvEnablePDEV(
DEVMODEW*   pdm,            // Contains data pertaining to requested mode
PWSTR       pwszLogAddr,    // Logical address
ULONG       cPat,           // Count of standard patterns
HSURF*      phsurfPatterns, // Buffer for standard patterns
ULONG       cjCaps,         // Size of buffer for device caps 'pdevcaps'
ULONG*      pdevcaps,       // Buffer for device caps, also known as 'gdiinfo'
ULONG       cjDevInfo,      // Number of bytes in device info 'pdi'
DEVINFO*    pdi,            // Device information
HDEV        hdev,           // HDEV, used for callbacks
PWSTR       pwszDeviceName, // Device name
HANDLE      hDriver)        // Kernel driver handle
{
    PDEV*   ppdev;

    // Future versions of NT had better supply 'devcaps' and 'devinfo'
    // structures that are the same size or larger than the current
    // structures:

    if ((cjCaps < sizeof(GDIINFO)) || (cjDevInfo < sizeof(DEVINFO)))
    {
        DISPDBG((0, "DrvEnablePDEV - Buffer size too small"));
        goto ReturnFailure0;
    }

    // Allocate a physical device structure.  Note that we definitely
    // rely on the zero initialization:

    ppdev = (PDEV*) EngAllocMem(FL_ZERO_MEMORY, sizeof(PDEV), ALLOC_TAG);
    if (ppdev == NULL)
    {
        DISPDBG((0, "DrvEnablePDEV - Failed EngAllocMem"));
        goto ReturnFailure0;
    }

    ppdev->hDriver = hDriver;

    // Get the current screen mode information.  Set up device caps and
    // devinfo:

    if (!bInitializeModeFields(ppdev, (GDIINFO*) pdevcaps, pdi, pdm))
    {
        DISPDBG((0, "DrvEnablePDEV - Failed bInitializeModeFields"));
        goto ReturnFailure1;
    }

    // Initialize palette information.

    if (!bInitializePalette(ppdev, pdi))
    {
        DISPDBG((0, "DrvEnablePDEV - Failed bInitializePalette"));
        goto ReturnFailure1;
    }

    return((DHPDEV) ppdev);

ReturnFailure1:
    DrvDisablePDEV((DHPDEV) ppdev);

ReturnFailure0:
    DISPDBG((0, "Failed DrvEnablePDEV"));

    return(0);
}

/******************************Public*Routine******************************\
* DrvDisablePDEV
*
* Release the resources allocated in DrvEnablePDEV.  If a surface has been
* enabled DrvDisableSurface will have already been called.
*
* Note: In an error, we may call this before DrvEnablePDEV is done.
*
\**************************************************************************/

VOID DrvDisablePDEV(
DHPDEV  dhpdev)
{
    PDEV*   ppdev;

    ppdev = (PDEV*) dhpdev;

    vUninitializePalette(ppdev);
    EngFreeMem(ppdev);
}

/******************************Public*Routine******************************\
* VOID DrvCompletePDEV
*
* Store the HPDEV, the engines handle for this PDEV, in the DHPDEV.
*
\**************************************************************************/

VOID DrvCompletePDEV(
DHPDEV dhpdev,
HDEV   hdev)
{
    ((PDEV*) dhpdev)->hdevEng = hdev;
}

/******************************Public*Routine******************************\
* HSURF DrvEnableSurface
*
* Creates the drawing surface, initializes the hardware, and initializes
* driver components.  This function is called after DrvEnablePDEV, and
* performs the final device initialization.
*
\**************************************************************************/

HSURF DrvEnableSurface(
DHPDEV dhpdev)
{
    PDEV*   ppdev;
    HSURF   hsurfShadow;
    HSURF   hsurfDevice;
    SIZEL   sizl;

    ppdev = (PDEV*) dhpdev;

    /////////////////////////////////////////////////////////////////////
    // Have GDI create the actual SURFOBJ.
    //
    // Our drawing surface is going to be 'device-managed', meaning that
    // GDI cannot draw on the framebuffer bits directly, and as such we
    // create the surface via EngCreateSurface.  By doing this, we ensure
    // that GDI will only ever access the bitmaps bits via the Drv calls
    // that we've HOOKed.

    sizl.cx = ppdev->cxScreen;
    sizl.cy = ppdev->cyScreen;

    hsurfDevice = EngCreateDeviceSurface(NULL, sizl, ppdev->iBitmapFormat);
    if (hsurfDevice == 0)
    {
        DISPDBG((0, "DrvEnableSurface - Failed EngCreateSurface"));
        return(0);
    }

    ppdev->hsurfScreen = hsurfDevice;       // Remember it for clean-up

    /////////////////////////////////////////////////////////////////////
    // Now associate the surface and the PDEV.
    //
    // We have to associate the surface we just created with our physical
    // device so that GDI can get information related to the PDEV when
    // it's drawing to the surface (such as, for example, the length of
    // styles on the device when simulating styled lines).
    //

    if (!EngAssociateSurface(hsurfDevice, ppdev->hdevEng, ppdev->flHooks))
    {
        DISPDBG((0, "DrvEnableSurface - Failed EngAssociateSurface"));
        goto ReturnFailure;
    }

    // Create the 4bpp DIB on which we'll have GDI do all the drawing.
    // We'll merely occasionally blt portions to the screen to update.

    sizl.cx = ppdev->cxScreen;
    sizl.cy = ppdev->cyScreen;

    hsurfShadow = (HSURF) EngCreateBitmap(sizl, 0, ppdev->iBitmapFormat, 0,
                                          NULL);
    if (hsurfShadow == 0)
        goto ReturnFailure;

    if (!EngAssociateSurface(hsurfShadow, ppdev->hdevEng, 0))
    {
        DISPDBG((0, "DrvEnableSurface - Failed second EngAssociateSurface"));
        goto ReturnFailure;
    }

    ppdev->pso = EngLockSurface(hsurfShadow);
    if (ppdev->pso == NULL)
        goto ReturnFailure;

    /////////////////////////////////////////////////////////////////////
    // Now enable all the subcomponents.
    //
    // Note that the order in which these 'Enable' functions are called
    // may be significant in low off-screen memory conditions, because
    // the off-screen heap manager may fail some of the later
    // allocations...

    if (!bEnableHardware(ppdev))
        goto ReturnFailure;

    DISPDBG((5, "Passed DrvEnableSurface"));

    return(hsurfDevice);

ReturnFailure:
    DrvDisableSurface((DHPDEV) ppdev);

    DISPDBG((0, "Failed DrvEnableSurface"));

    return(0);
}

/******************************Public*Routine******************************\
* VOID DrvDisableSurface
*
* Free resources allocated by DrvEnableSurface.  Release the surface.
*
* Note: In an error case, we may call this before DrvEnableSurface is
*       completely done.
*
\**************************************************************************/

VOID DrvDisableSurface(
DHPDEV dhpdev)
{
    PDEV*   ppdev;
    HSURF   hsurf;

    ppdev = (PDEV*) dhpdev;

    // Note: In an error case, some of the following relies on the
    //       fact that the PDEV is zero-initialized, so fields like
    //       'hsurfScreen' will be zero unless the surface has been
    //       sucessfully initialized, and makes the assumption that
    //       EngDeleteSurface can take '0' as a parameter.

    vDisableHardware(ppdev);

    if (ppdev->pso) {
        hsurf = ppdev->pso->hsurf;

        EngUnlockSurface(ppdev->pso);
        EngDeleteSurface(hsurf);
    }

    EngDeleteSurface(ppdev->hsurfScreen);
}

/******************************Public*Routine******************************\
* VOID DrvAssertMode
*
* This asks the device to reset itself to the mode of the pdev passed in.
*
\**************************************************************************/

BOOL DrvAssertMode(
DHPDEV  dhpdev,
BOOL    bEnable)
{
    PDEV* ppdev;

    ppdev = (PDEV*) dhpdev;

    if (!bEnable)
    {
        //////////////////////////////////////////////////////////////
        // Disable - Switch to full-screen mode

        return(bAssertModeHardware(ppdev, FALSE));
    }
    else
    {
        //////////////////////////////////////////////////////////////
        // Enable - Switch back to graphics mode

        // We have to enable every subcomponent in the reverse order
        // in which it was disabled:

        return(bAssertModeHardware(ppdev, TRUE));
    }
}

/******************************Public*Routine******************************\
* ULONG DrvGetModes
*
* Returns the list of available modes for the device.
*
\**************************************************************************/

ULONG DrvGetModes(
HANDLE      hDriver,
ULONG       cjSize,
DEVMODEW*   pdm)
{

    DWORD cModes;
    DWORD cbOutputSize;
    PVIDEO_MODE_INFORMATION pVideoModeInformation;
    PVIDEO_MODE_INFORMATION pVideoTemp;
    DWORD cOutputModes = cjSize / (sizeof(DEVMODEW) + DRIVER_EXTRA_SIZE);
    DWORD cbModeSize;

    cModes = getAvailableModes(hDriver,
                            (PVIDEO_MODE_INFORMATION *) &pVideoModeInformation,
                            &cbModeSize);
    if (cModes == 0)
    {
        DISPDBG((0, "DrvGetModes failed to get mode information"));
        return(0);
    }

    if (pdm == NULL)
    {
        cbOutputSize = cModes * (sizeof(DEVMODEW) + DRIVER_EXTRA_SIZE);
    }
    else
    {
        //
        // Now copy the information for the supported modes back into the
        // output buffer
        //

        cbOutputSize = 0;

        pVideoTemp = pVideoModeInformation;

        do
        {
            if (pVideoTemp->Length != 0)
            {
                if (cOutputModes == 0)
                {
                    break;
                }

                //
                // Zero the entire structure to start off with.
                //

                memset(pdm, 0, sizeof(DEVMODEW));

                //
                // Set the name of the device to the name of the DLL.
                //

                memcpy(pdm->dmDeviceName, DLL_NAME, sizeof(DLL_NAME));

                pdm->dmSpecVersion      = DM_SPECVERSION;
                pdm->dmDriverVersion    = DM_SPECVERSION;
                pdm->dmSize             = sizeof(DEVMODEW);
                pdm->dmDriverExtra      = DRIVER_EXTRA_SIZE;

                pdm->dmBitsPerPel       = pVideoTemp->NumberOfPlanes *
                                          pVideoTemp->BitsPerPlane;
                pdm->dmPelsWidth        = pVideoTemp->VisScreenWidth;
                pdm->dmPelsHeight       = pVideoTemp->VisScreenHeight;
                pdm->dmDisplayFrequency = pVideoTemp->Frequency;
                pdm->dmDisplayFlags     = 0;

                pdm->dmFields           = DM_BITSPERPEL       |
                                          DM_PELSWIDTH        |
                                          DM_PELSHEIGHT       |
                                          DM_DISPLAYFREQUENCY |
                                          DM_DISPLAYFLAGS     ;

                //
                // Go to the next DEVMODE entry in the buffer.
                //

                cOutputModes--;

                pdm = (LPDEVMODEW) ( ((ULONG_PTR)pdm) + sizeof(DEVMODEW) +
                                                   DRIVER_EXTRA_SIZE);

                cbOutputSize += (sizeof(DEVMODEW) + DRIVER_EXTRA_SIZE);

            }

            pVideoTemp = (PVIDEO_MODE_INFORMATION)
                (((PUCHAR)pVideoTemp) + cbModeSize);


        } while (--cModes);
    }

    EngFreeMem(pVideoModeInformation);

    return(cbOutputSize);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\vgarisc\disp\color.c ===
/******************************Module*Header*******************************\
* Module Name: color.c
*
* This algorithm for color dithering is patent pending and its use is
* restricted to Microsoft products and drivers for Microsoft products.
* Use in non-Microsoft products or in drivers for non-Microsoft product is
* prohibited without written permission from Microsoft.
*
* The patent application is the primary reference for the operation of the
* color dithering code.
*
* Note that in the comments and variable names, "vertex" means "vertex of
* either the inner (half intensity) or outer (full intensity) color cube."
* Vertices map to colors 0-7 and 9-15 of the Windows standard (required)
* 16-color palette, where vertices 0-7 are the vertices of the inner color
* cube, and 0 plus 9-15 are the vertices of the full color cube. Vertex 8 is
* 75% gray; this could be used in the dither, but that would break apps that
* depend on the exact Windows 3.1 dithering. This code is Window 3.1
* compatible.
*
* Copyright (c) 1992-1995 Microsoft Corporation
\**************************************************************************/

#include "precomp.h"

/**************************************************************************\
* This function takes a value from 0 - 255 and uses it to create an
* 8x8 pile of bits in the form of a 1BPP bitmap.  It can also take an
* RGB value and make an 8x8 bitmap.  These can then be used as brushes
* to simulate color unavaible on the device.
*
* For monochrome the basic algorithm is equivalent to turning on bits
* in the 8x8 array according to the following order:
*
*  00 32 08 40 02 34 10 42
*  48 16 56 24 50 18 58 26
*  12 44 04 36 14 46 06 38
*  60 28 52 20 62 30 54 22
*  03 35 11 43 01 33 09 41
*  51 19 59 27 49 17 57 25
*  15 47 07 39 13 45 05 37
*  63 31 55 23 61 29 53 21
*
* Reference: A Survey of Techniques for the Display of Continous
*            Tone Pictures on Bilevel Displays,;
*            Jarvis, Judice, & Ninke;
*            COMPUTER GRAPHICS AND IMAGE PROCESSING 5, pp 13-40, (1976)
\**************************************************************************/

#define SWAP_RB 0x00000004
#define SWAP_GB 0x00000002
#define SWAP_RG 0x00000001

#define SWAPTHEM(a,b) (ulTemp = a, a = b, b = ulTemp)

// PATTERNSIZE is the number of pixels in a dither pattern.
#define PATTERNSIZE 64

typedef union _PAL_ULONG {
    PALETTEENTRY pal;
    ULONG ul;
} PAL_ULONG;

// Tells which row to turn a pel on in when dithering for monochrome bitmaps.
static BYTE ajByte[] = {
    0, 4, 0, 4, 2, 6, 2, 6,
    0, 4, 0, 4, 2, 6, 2, 6,
    1, 5, 1, 5, 3, 7, 3, 7,
    1, 5, 1, 5, 3, 7, 3, 7,
    0, 4, 0, 4, 2, 6, 2, 6,
    0, 4, 0, 4, 2, 6, 2, 6,
    1, 5, 1, 5, 3, 7, 3, 7,
    1, 5, 1, 5, 3, 7, 3, 7
};

// The array of monochrome bits used for monc
static BYTE ajBits[] = {
    0x80, 0x08, 0x08, 0x80, 0x20, 0x02, 0x02, 0x20,
    0x20, 0x02, 0x02, 0x20, 0x80, 0x08, 0x08, 0x80,
    0x40, 0x04, 0x04, 0x40, 0x10, 0x01, 0x01, 0x10,
    0x10, 0x01, 0x01, 0x10, 0x40, 0x04, 0x04, 0x40,
    0x40, 0x04, 0x04, 0x40, 0x10, 0x01, 0x01, 0x10,
    0x10, 0x01, 0x01, 0x10, 0x40, 0x04, 0x04, 0x40,
    0x80, 0x08, 0x08, 0x80, 0x20, 0x02, 0x02, 0x20,
    0x20, 0x02, 0x02, 0x20, 0x80, 0x08, 0x08, 0x80
};

// Translates vertices back to the original subspace. Each row is a subspace,
// as encoded in ulSymmetry, and each column is a vertex between 0 and 15.
BYTE jSwapSubSpace[8*16] = {
    0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
    0, 2, 1, 3, 4, 6, 5, 7, 8, 10, 9, 11, 12, 14, 13, 15,
    0, 1, 4, 5, 2, 3, 6, 7, 8, 9, 12, 13, 10, 11, 14, 15,
    0, 4, 1, 5, 2, 6, 3, 7, 8, 12, 9, 13, 10, 14, 11, 15,
    0, 4, 2, 6, 1, 5, 3, 7, 8, 12, 10, 14, 9, 13, 11, 15,
    0, 2, 4, 6, 1, 3, 5, 7, 8, 10, 12, 14, 9, 11, 13, 15,
    0, 4, 1, 5, 2, 6, 3, 7, 8, 12, 9, 13, 10, 14, 11, 15,
    0, 1, 4, 5, 2, 3, 6, 7, 8, 9, 12, 13, 10, 11, 14, 15,
};

// Converts a nibble value in the range 0-15 to a dword value containing the
// nibble value packed 8 times.
ULONG ulNibbleToDword[16] = {
    0x00000000,
    0x01010101,
    0x02020202,
    0x03030303,
    0x04040404,
    0x05050505,
    0x06060606,
    0x07070707,
    0x08080808,
    0x09090909,
    0x0A0A0A0A,
    0x0B0B0B0B,
    0x0C0C0C0C,
    0x0D0D0D0D,
    0x0E0E0E0E,
    0x0F0F0F0F
};

// Specifies where in the dither pattern colors should be placed in order
// of increasing intensity. This is organized in the following form, for
// efficiency: every set of 8 pixels (0-7, 8-15, 16-23, ... ,56-63) is
// placed in the dither pattern in the order: 0 2 4 6 1 3 5 7. This is
// done so that two longs can be combined to put 8 pixels in DIB4 format
// at once (the first dword is shifted left 4, then the two dwords are
// ORed, to produce 0 1 2 3 4 5 6 7 order in memory), which is much faster than
// combining the output of the straight dither ordering.
// The effective dither ordering after we combine each pair of ULONGS at the
// end (the desired dither ordering) is:
//
//  0, 36,  4, 32, 18, 54, 22, 50,
//  2, 38,  6, 34, 16, 52, 20, 48,
//  9, 45, 13, 41, 27, 63, 31, 59,
// 11, 47, 15, 43, 25, 61, 29, 57,
//  1, 37,  5, 33, 19, 55, 23, 51,
//  3, 39,  7, 35, 17, 53, 21, 49,
//  8, 44, 12, 40, 26, 62, 30, 58,
// 10, 46, 14, 42, 24, 60, 28, 56,
//
ULONG aulDitherOrder[] = {
  0, 34,  2, 32, 17, 51, 19, 49,
  1, 35,  3, 33, 16, 50, 18, 48,
 12, 46, 14, 44, 29, 63, 31, 61,
 13, 47, 15, 45, 28, 62, 30, 60,
  4, 38,  6, 36, 21, 55, 23, 53,
  5, 39,  7, 37, 20, 54, 22, 52,
  8, 42, 10, 40, 25, 59, 27, 57,
  9, 43, 11, 41, 24, 58, 26, 56,
};

/******************************Public*Routine******************************\
* ComputeSubspaces
*
* Calculates the subspace data associated with rgb, stores the data at
* pvVertexData, in the form of an array of VERTEX_DATA structures,
* suitable for vDitherColor. Returns a pointer to the byte after the
* last VERTEX_DATA structure.
*
* Ignores the high byte of rgb.
*
\**************************************************************************/

VERTEX_DATA * ComputeSubspaces(ULONG rgb, VERTEX_DATA *pvVertexData)
{
    ULONG   ulRedTemp, ulGreenTemp, ulBlueTemp, ulSymmetry;
    ULONG   ulRed, ulGre, ulBlu, ulTemp;
    ULONG   ulVertex0Temp, ulVertex1Temp, ulVertex2Temp, ulVertex3Temp;

    // Split the color into red, green, and blue components
    ulRedTemp   = ((PAL_ULONG *)&rgb)->pal.peRed;
    ulGreenTemp   = ((PAL_ULONG *)&rgb)->pal.peGreen;
    ulBlueTemp   = ((PAL_ULONG *)&rgb)->pal.peBlue;

    // Sort the RGB so that the point is transformed into subspace 0, and
    // keep track of the swaps in ulSymmetry so we can unravel it again
    // later.  We want r >= g >= b (subspace 0).
    ulSymmetry = 0;
    if (ulBlueTemp > ulRedTemp) {
        SWAPTHEM(ulBlueTemp,ulRedTemp);
        ulSymmetry = SWAP_RB;
    }

    if (ulBlueTemp > ulGreenTemp) {
        SWAPTHEM(ulBlueTemp,ulGreenTemp);
        ulSymmetry |= SWAP_GB;
    }

    if (ulGreenTemp > ulRedTemp) {
        SWAPTHEM(ulGreenTemp,ulRedTemp);
        ulSymmetry |= SWAP_RG;
    }

    ulSymmetry <<= 4;   // for lookup purposes

    // Scale the values from 0-255 to 0-64. Note that the scaling is not
    // symmetric at the ends; this is done to match Windows 3.1 dithering
    ulRed = (ulRedTemp + 1) >> 2;
    ulGre = (ulGreenTemp + 1) >> 2;
    ulBlu = (ulBlueTemp + 1) >> 2;

    // Compute the subsubspace within subspace 0 in which the point lies,
    // then calculate the # of pixels to dither in the colors that are the
    // four vertexes of the tetrahedron bounding the color we're emulating.
    // Only vertices with more than zero pixels are stored, and the
    // vertices are stored in order of increasing intensity, saving us the
    // need to sort them later
    if ((ulRedTemp + ulGreenTemp) > 256) {
        // Subsubspace 2 or 3
        if ((ulRedTemp + ulBlueTemp) > 256) {
            // Subsubspace 3
            // Calculate the number of pixels per vertex, still in
            // subsubspace 3, then convert to original subspace. The pixel
            // counts and vertex numbers are matching pairs, stored in
            // ascending intensity order, skipping vertices with zero
            // pixels. The vertex intensity order for subsubspace 3 is:
            // 7, 9, 0x0B, 0x0F
            if ((ulVertex0Temp = (64 - ulRed) << 1) != 0) {
                pvVertexData->ulCount = ulVertex0Temp;
                pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x07];
            }
            ulVertex2Temp = ulGre - ulBlu;
            ulVertex3Temp = (ulRed - 64) + ulBlu;
            if ((ulVertex1Temp = ((PATTERNSIZE - ulVertex0Temp) -
                    ulVertex2Temp) - ulVertex3Temp) != 0) {
                pvVertexData->ulCount = ulVertex1Temp;
                pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x09];
            }
            if (ulVertex2Temp != 0) {
                pvVertexData->ulCount = ulVertex2Temp;
                pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x0B];
            }
            if (ulVertex3Temp != 0) {
                pvVertexData->ulCount = ulVertex3Temp;
                pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x0F];
            }
        } else {
            // Subsubspace 2
            // Calculate the number of pixels per vertex, still in
            // subsubspace 2, then convert to original subspace. The pixel
            // counts and vertex numbers are matching pairs, stored in
            // ascending intensity order, skipping vertices with zero
            // pixels. The vertex intensity order for subsubspace 2 is:
            // 3, 7, 9, 0x0B
            ulVertex1Temp = ulBlu << 1;
            ulVertex2Temp = ulRed - ulGre;
            ulVertex3Temp = (ulRed - 32) + (ulGre - 32);
            if ((ulVertex0Temp = ((PATTERNSIZE - ulVertex1Temp) -
                        ulVertex2Temp) - ulVertex3Temp) != 0) {
                pvVertexData->ulCount = ulVertex0Temp;
                pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x03];
            }
            if (ulVertex1Temp != 0) {
                pvVertexData->ulCount = ulVertex1Temp;
                pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x07];
            }
            if (ulVertex2Temp != 0) {
                pvVertexData->ulCount = ulVertex2Temp;
                pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x09];
            }
            if (ulVertex3Temp != 0) {
                pvVertexData->ulCount = ulVertex3Temp;
                pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x0B];
            }
        }
    } else {
        // Subsubspace 0 or 1
        if (ulRedTemp > 128) {
            // Subsubspace 1
            // Calculate the number of pixels per vertex, still in
            // subsubspace 1, then convert to original subspace. The pixel
            // counts and vertex numbers are matching pairs, stored in
            // ascending intensity order, skipping vertices with zero
            // pixels. The vertex intensity order for subsubspace 1 is:
            // 1, 3, 7, 9
            if ((ulVertex0Temp = ((32 - ulGre) + (32 - ulRed)) << 1) != 0) {
                pvVertexData->ulCount = ulVertex0Temp;
                pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x01];
            }
            ulVertex2Temp = ulBlu << 1;
            ulVertex3Temp = (ulRed - 32) << 1;
            if ((ulVertex1Temp = ((PATTERNSIZE - ulVertex0Temp) -
                    ulVertex2Temp) - ulVertex3Temp) != 0) {
                pvVertexData->ulCount = ulVertex1Temp;
                pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x03];
            }
            if (ulVertex2Temp != 0) {
                pvVertexData->ulCount = ulVertex2Temp;
                pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x07];
            }
            if (ulVertex3Temp != 0) {
                pvVertexData->ulCount = ulVertex3Temp;
                pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x09];
            }
        } else {
            // Subsubspace 0
            // Calculate the number of pixels per vertex, still in
            // subsubspace 0, then convert to original subspace. The pixel
            // counts and vertex numbers are matching pairs, stored in
            // ascending intensity order, skipping vertices with zero
            // pixels. The vertex intensity order for subsubspace 0 is:
            // 0, 1, 3, 7
            if ((ulVertex0Temp = (32 - ulRed) << 1) != 0) {
                pvVertexData->ulCount = ulVertex0Temp;
                pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x00];
            }
            if ((ulVertex1Temp = (ulRed - ulGre) << 1) != 0) {
                pvVertexData->ulCount = ulVertex1Temp;
                pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x01];
            }
            ulVertex3Temp = ulBlu << 1;
            if ((ulVertex2Temp = ((PATTERNSIZE - ulVertex0Temp) -
                    ulVertex1Temp) - ulVertex3Temp) != 0) {
                pvVertexData->ulCount = ulVertex2Temp;
                pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x03];
            }
            if (ulVertex3Temp != 0) {
                pvVertexData->ulCount = ulVertex3Temp;
                pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x07];
            }
        }
    }

    return(pvVertexData);
}

/******************************Public*Routine******************************\
* vDitherColor
*
* Dithers the ulNumVertices vertices described by vVertexData into pulDest.
*
\**************************************************************************/

VOID vDitherColor(ULONG * pulDest, VERTEX_DATA * vVertexData,
    VERTEX_DATA * pvVertexDataEnd, ULONG ulNumVertices)
{
    ULONG ulTemp, ulNumPixels, ulColor;
    VERTEX_DATA *pvMaxVertex, *pvVertexData;
    ULONG  *pulTemp, *pulDitherOrder;
    BYTE    jColor;
    BYTE    ajDither[64];

    if (ulNumVertices > 2) {

        // There are 3 or 4 vertices in this dither
        if (ulNumVertices == 3) {

            // There are 3 vertices in this dither

            // Find the vertex with the most pixels, and fill the whole
            // destination bitmap with that vertex's color, which is faster
            // than dithering it
            if (vVertexData[1].ulCount >= vVertexData[2].ulCount) {
                pvMaxVertex = &vVertexData[1];
                ulTemp = vVertexData[1].ulCount;
            } else {
                pvMaxVertex = &vVertexData[2];
                ulTemp = vVertexData[2].ulCount;
            }

        } else {

            // There are 4 vertices in this dither

            // Find the vertex with the most pixels, and fill the whole
            // destination bitmap with that vertex's color, which is faster
            // than dithering it
            if (vVertexData[2].ulCount >= vVertexData[3].ulCount) {
                pvMaxVertex = &vVertexData[2];
                ulTemp = vVertexData[2].ulCount;
            } else {
                pvMaxVertex = &vVertexData[3];
                ulTemp = vVertexData[3].ulCount;
            }
        }

        if (vVertexData[1].ulCount > ulTemp) {
            pvMaxVertex = &vVertexData[1];
            ulTemp = vVertexData[1].ulCount;
        }
        if (vVertexData[0].ulCount > ulTemp) {
            pvMaxVertex = &vVertexData[0];
        }

        // Prepare a dword version of the most common vertex number (color)
        ulColor = ulNibbleToDword[pvMaxVertex->ulVertex];

        // Mark that the vertex we're about to do doesn't need to be done
        // later
        pvMaxVertex->ulVertex = 0xFF;

        // Block fill the dither pattern with the more common vertex
        pulTemp = (ULONG *)ajDither;
        *pulTemp = ulColor;
        *(pulTemp+1) = ulColor;
        *(pulTemp+2) = ulColor;
        *(pulTemp+3) = ulColor;
        *(pulTemp+4) = ulColor;
        *(pulTemp+5) = ulColor;
        *(pulTemp+6) = ulColor;
        *(pulTemp+7) = ulColor;
        *(pulTemp+8) = ulColor;
        *(pulTemp+9) = ulColor;
        *(pulTemp+10) = ulColor;
        *(pulTemp+11) = ulColor;
        *(pulTemp+12) = ulColor;
        *(pulTemp+13) = ulColor;
        *(pulTemp+14) = ulColor;
        *(pulTemp+15) = ulColor;

        // Now dither all the remaining vertices in order 0->2 or 0->3
        // (in order of increasing intensity)
        pulDitherOrder = aulDitherOrder;
        pvVertexData = vVertexData;
        do {
            if (pvVertexData->ulVertex == 0xFF) {
                // This is the max vertex, which we already did, but we
                // have to account for it in the dither order
                pulDitherOrder += pvVertexData->ulCount;
            } else {
                jColor = (BYTE) pvVertexData->ulVertex;
                ulNumPixels = pvVertexData->ulCount;
                switch (ulNumPixels & 3) {
                    case 3:
                        ajDither[*(pulDitherOrder+2)] = jColor;
                    case 2:
                        ajDither[*(pulDitherOrder+1)] = jColor;
                    case 1:
                        ajDither[*(pulDitherOrder+0)] = jColor;
                        pulDitherOrder += ulNumPixels & 3;
                    case 0:
                        break;
                }
                if ((ulNumPixels >>= 2) != 0) {
                    do {
                        ajDither[*pulDitherOrder] = jColor;
                        ajDither[*(pulDitherOrder+1)] = jColor;
                        ajDither[*(pulDitherOrder+2)] = jColor;
                        ajDither[*(pulDitherOrder+3)] = jColor;
                        pulDitherOrder += 4;
                    } while (--ulNumPixels);
                }
            }
        } while (++pvVertexData < pvVertexDataEnd);

    } else if (ulNumVertices == 2) {

        // There are exactly two vertices with more than zero pixels; fill
        // in the dither array as follows: block fill with vertex with more
        // points first, then dither in the other vertex
        if (vVertexData[0].ulCount >= vVertexData[1].ulCount) {
            // There are no more vertex 1 than vertex 0 pixels, so do
            // the block fill with vertex 0
            ulColor = ulNibbleToDword[vVertexData[0].ulVertex];
            // Do the dither with vertex 1
            jColor = (BYTE) vVertexData[1].ulVertex;
            ulNumPixels = vVertexData[1].ulCount;
            // Set where to start dithering with vertex 1 (vertex 0 is
            // lower intensity, so its pixels come first in the dither
            // order)
            pulDitherOrder = aulDitherOrder + vVertexData[0].ulCount;
        } else {
            // There are more vertex 1 pixels, so do the block fill
            // with vertex 1
            ulColor = ulNibbleToDword[vVertexData[1].ulVertex];
            // Do the dither with vertex 0
            jColor = (BYTE) vVertexData[0].ulVertex;
            ulNumPixels = vVertexData[0].ulCount;
            // Set where to start dithering with vertex 0 (vertex 0 is
            // lower intensity, so its pixels come first in the dither
            // order)
            pulDitherOrder = aulDitherOrder;
        }

        // Block fill the dither pattern with the more common vertex
        pulTemp = (ULONG *)ajDither;
        *pulTemp = ulColor;
        *(pulTemp+1) = ulColor;
        *(pulTemp+2) = ulColor;
        *(pulTemp+3) = ulColor;
        *(pulTemp+4) = ulColor;
        *(pulTemp+5) = ulColor;
        *(pulTemp+6) = ulColor;
        *(pulTemp+7) = ulColor;
        *(pulTemp+8) = ulColor;
        *(pulTemp+9) = ulColor;
        *(pulTemp+10) = ulColor;
        *(pulTemp+11) = ulColor;
        *(pulTemp+12) = ulColor;
        *(pulTemp+13) = ulColor;
        *(pulTemp+14) = ulColor;
        *(pulTemp+15) = ulColor;

        // Dither in the less common vertex
        switch (ulNumPixels & 3) {
            case 3:
                ajDither[*(pulDitherOrder+2)] = jColor;
            case 2:
                ajDither[*(pulDitherOrder+1)] = jColor;
            case 1:
                ajDither[*(pulDitherOrder+0)] = jColor;
                pulDitherOrder += ulNumPixels & 3;
            case 0:
                break;
        }
        if ((ulNumPixels >>= 2) != 0) {
            do {
                ajDither[*pulDitherOrder] = jColor;
                ajDither[*(pulDitherOrder+1)] = jColor;
                ajDither[*(pulDitherOrder+2)] = jColor;
                ajDither[*(pulDitherOrder+3)] = jColor;
                pulDitherOrder += 4;
            } while (--ulNumPixels);
        }

    } else {

        // There is only one vertex in this dither

        // No sorting or dithering is needed for just one color; we can
        // just generate the final DIB directly
        ulColor = ulNibbleToDword[vVertexData[0].ulVertex];
        ulColor |= ulColor << 4;
        *pulDest = ulColor;
        *(pulDest+1) = ulColor;
        *(pulDest+2) = ulColor;
        *(pulDest+3) = ulColor;
        *(pulDest+4) = ulColor;
        *(pulDest+5) = ulColor;
        *(pulDest+6) = ulColor;
        *(pulDest+7) = ulColor;

        return;
    }

    // Now convert the 64 bytes into the 4BPP Engine Format Bitmap
    pulTemp = (ULONG *)ajDither;

    *pulDest = (*pulTemp << 4) | *(pulTemp + 1);
    *(pulDest + 1) = (*(pulTemp + 2) << 4) | *(pulTemp + 3);
    *(pulDest + 2) = (*(pulTemp + 4) << 4) | *(pulTemp + 5);
    *(pulDest + 3) = (*(pulTemp + 6) << 4) | *(pulTemp + 7);
    *(pulDest + 4) = (*(pulTemp + 8) << 4) | *(pulTemp + 9);
    *(pulDest + 5) = (*(pulTemp + 10) << 4) | *(pulTemp + 11);
    *(pulDest + 6) = (*(pulTemp + 12) << 4) | *(pulTemp + 13);
    *(pulDest + 7) = (*(pulTemp + 14) << 4) | *(pulTemp + 15);
}

/******************************Public*Routine******************************\
* DrvDitherColor
*
* Dithers an RGB color to an 8X8 approximation using the reserved VGA colors
*
\**************************************************************************/

ULONG DrvDitherColor(
DHPDEV dhpdev,
ULONG  iMode,
ULONG  rgb,
ULONG *pul)
{
    ULONG   ulGrey, ulRed, ulGre, ulBlu, ulTemp;
    VERTEX_DATA vVertexData[4];
    VERTEX_DATA *pvVertexData;

    // Figure out if we need a full color dither or only a monochrome dither
    if (iMode != DM_MONOCHROME) {

        // Full color dither

        // Calculate what color subspaces are involved in the dither
        pvVertexData = ComputeSubspaces(rgb, vVertexData);

        // Now that we have found the bounding vertices and the number of
        // pixels to dither for each vertex, we can create the dither pattern

        // Handle 1, 2, and 3 & 4 vertices per dither separately
        ulTemp = (ULONG)(pvVertexData - vVertexData); // # of vertices with more than
                                                //  zero pixels in the dither

        vDitherColor(pul, vVertexData, pvVertexData, ulTemp);

    } else {

        // For monochrome we will only use the Intensity (grey level)
        RtlFillMemory((PVOID) pul, PATTERNSIZE/2, 0);  // zero the dither bits

        ulRed   = (ULONG) ((PALETTEENTRY *) &rgb)->peRed;
        ulGre = (ULONG) ((PALETTEENTRY *) &rgb)->peGreen;
        ulBlu  = (ULONG) ((PALETTEENTRY *) &rgb)->peBlue;

        // I = .30R + .59G + .11B
        // For convience the following ratios are used:
        //
        //  77/256 = 30.08%
        // 151/256 = 58.98%
        //  28/256 = 10.94%

        ulGrey  = (((ulRed * 77) + (ulGre * 151) + (ulBlu * 28)) >> 8) & 255;

        // Convert the RGBI from 0-255 to 0-64 notation.

        ulGrey = (ulGrey + 1) >> 2;

        while(ulGrey) {
            ulGrey--;
            pul[ajByte[ulGrey]] |= ((ULONG) ajBits[ulGrey]);
        }
    }

    return(DCR_DRIVER);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\vgarisc\disp\driver.h ===
/******************************Module*Header*******************************\
* Module Name: driver.h
*
* Contains prototypes for the display driver.
*
* Copyright (c) 1992-1995 Microsoft Corporation
\**************************************************************************/

typedef struct _PDEV PDEV;      // Handy forward declaration
//////////////////////////////////////////////////////////////////////
// Miscellaneous shared stuff

#define DLL_NAME                L"vga"          // Name of the DLL in UNICODE
#define STANDARD_DEBUG_PREFIX   "Vga risc: "    // All debug output is prefixed
                                                //   by this string
#define ALLOC_TAG               'rgvD'          // Dvgr
                                                // Four byte tag (characters in
                                                // reverse order) used for
                                                // memory allocations

#define DRIVER_EXTRA_SIZE   0   // Size of the DriverExtra information in the
                                //   DEVMODE structure

// Describes a single color tetrahedron vertex for dithering

typedef struct _VERTEX_DATA {
    ULONG ulCount;  // # of pixels in this vertex
    ULONG ulVertex; // vertex #
} VERTEX_DATA;

////////////////////////////////////////////////////////////////////////
// The Physical Device data structure

typedef struct  _PDEV
{
    ULONG       iBitmapFormat;          // BMF_4BPP (our current colour depth)
    BYTE*       pjScreen;               // Points to base screen address
    LONG        lDelta;                 // Screen stride
    HANDLE      hDriver;                // Handle to \Device\Screen
    HDEV        hdevEng;                // Engine's handle to PDEV
    HSURF       hsurfScreen;            // Engine's handle to screen surface
    FLONG       flHooks;                // What we're hooking from GDI
    UCHAR*      pjBase;                 // Mapped IO port base for this PDEV

    LONG        cxScreen;               // Visible screen width
    LONG        cyScreen;               // Visible screen height
    ULONG       ulMode;                 // Mode the mini-port driver is in.

    HPALETTE    hpalDefault;            // GDI handle to the default palette.
    SURFOBJ*    pso;                    // DIB copy of our surface to which we
                                        //   have GDI draw everything

} PDEV, *PPDEV;

/////////////////////////////////////////////////////////////////////////
// Miscellaneous prototypes:

VOID vUpdate(PDEV*, RECTL*, CLIPOBJ*);
BOOL bAssertModeHardware(PDEV*, BOOL);
BOOL bEnableHardware(PDEV*);
VOID vDisableHardware(PDEV*);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\vgarisc\disp\precomp.h ===
/******************************Module*Header*******************************\
* Module Name: precomp.h
*
* Common headers used throughout the display driver.  This entire include
* file will typically be pre-compiled.
*
* Copyright (c) 1993-1995 Microsoft Corporation
\**************************************************************************/

#include <stddef.h>
#include <stdarg.h>
#include <limits.h>
#include <windef.h>
#include <wingdi.h>
#include <winddi.h>
#include <devioctl.h>
#include <ntddvdeo.h>
#include <ioaccess.h>

#include "driver.h"
#include "debug.h"
#include "hw.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\vgarisc\disp\hardware.c ===
/******************************Module*Header*******************************\
* Module Name: hardware.c
*
* Contains all the code that touches the display hardware.
*
* Copyright (c) 1994-1995 Microsoft Corporation
\**************************************************************************/

#include "precomp.h"

// Values for the internal, EGA-compatible palette.

static WORD gPaletteBuffer[] = {

        16, // 16 entries
        0,  // start with first palette register

// On the VGA, the palette contains indices into the array of color DACs.
// Since we can program the DACs as we please, we'll just put all the indices
// down at the beginning of the DAC array (that is, pass pixel values through
// the internal palette unchanged).

        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15
};


// These are the values for the first 16 DAC registers, the only ones we'll
// work with. These correspond to the RGB colors (6 bits for each primary, with
// the fourth entry unused) for pixel values 0-15.

static BYTE gColorBuffer[] = {

      16, // 16 entries
      0,
      0,
      0,  // start with first palette register
                0x00, 0x00, 0x00, 0x00, // black
                0x2A, 0x00, 0x15, 0x00, // red
                0x00, 0x2A, 0x15, 0x00, // green
                0x2A, 0x2A, 0x15, 0x00, // mustard/brown
                0x00, 0x00, 0x2A, 0x00, // blue
                0x2A, 0x15, 0x2A, 0x00, // magenta
                0x15, 0x2A, 0x2A, 0x00, // cyan
                0x21, 0x22, 0x23, 0x00, // dark gray   2A
                0x30, 0x31, 0x32, 0x00, // light gray  39
                0x3F, 0x00, 0x00, 0x00, // bright red
                0x00, 0x3F, 0x00, 0x00, // bright green
                0x3F, 0x3F, 0x00, 0x00, // bright yellow
                0x00, 0x00, 0x3F, 0x00, // bright blue
                0x3F, 0x00, 0x3F, 0x00, // bright magenta
                0x00, 0x3F, 0x3F, 0x00, // bright cyan
                0x3F, 0x3F, 0x3F, 0x00  // bright white
};

/******************************Public*Routine******************************\
* BOOL bAssertModeHardware
*
* Sets the appropriate hardware state for graphics mode or full-screen.
*
\**************************************************************************/

BOOL bAssertModeHardware(
PDEV* ppdev,
BOOL  bEnable)
{
    DWORD   ReturnedDataLength;
    BYTE*   pjBase;

    pjBase = ppdev->pjBase;

    if (bEnable)
    {
        // Set the desired mode.

        if (EngDeviceIoControl(ppdev->hDriver,
                             IOCTL_VIDEO_SET_CURRENT_MODE,
                             &ppdev->ulMode,  // input buffer
                             sizeof(VIDEO_MODE),
                             NULL,
                             0,
                             &ReturnedDataLength))
        {
            DISPDBG((0, "bAssertModeHardware - Failed VIDEO_SET_CURRENT_MODE"));
            goto ReturnFalse;
        }

        // Set up the internal palette.

        if (EngDeviceIoControl(ppdev->hDriver,
                             IOCTL_VIDEO_SET_PALETTE_REGISTERS,
                             (PVOID) gPaletteBuffer, // input buffer
                             sizeof(gPaletteBuffer),
                             NULL,    // output buffer
                             0,
                             &ReturnedDataLength))
        {
            DISPDBG((0, "bAssertModeHardware - Failed VIDEO_SET_PALETTE_REGISTERS"));
            return(FALSE);
        }

        // Set up the DAC.

        if (EngDeviceIoControl(ppdev->hDriver,
                             IOCTL_VIDEO_SET_COLOR_REGISTERS,
                             (PVOID) gColorBuffer, // input buffer
                             sizeof(gColorBuffer),
                             NULL,    // output buffer
                             0,
                             &ReturnedDataLength))
        {
            DISPDBG((0, "bAssertModeHardware - Failed VIDEO_SET_COLOR_REGISTERS"));
            return(FALSE);
        }

        // Initialize sequencer to its defaults (all planes enabled, index
        // pointing to Map Mask).

        OUT_WORD(pjBase, VGA_BASE + SEQ_ADDR, (MM_ALL << 8) + SEQ_MAP_MASK);

        // Initialize graphics controller to its defaults (set/reset disabled for
        // all planes, no rotation & ALU function == replace, write mode 0 & read
        // mode 0, color compare ignoring all planes (read mode 1 reads always
        // return 0ffh, handy for ANDing), and the bit mask == 0ffh, gating all
        // bytes from the CPU.

        OUT_WORD(pjBase, VGA_BASE + GRAF_ADDR, GRAF_ENAB_SR);

        OUT_WORD(pjBase, VGA_BASE + GRAF_ADDR, (DR_SET << 8) + GRAF_DATA_ROT);

        OUT_WORD(pjBase, VGA_BASE + GRAF_ADDR, ((M_PROC_WRITE | M_DATA_READ) << 8)
                                              + GRAF_MODE);

        OUT_WORD(pjBase, VGA_BASE + GRAF_ADDR, GRAF_CDC);

        OUT_WORD(pjBase, VGA_BASE + GRAF_ADDR, (0xffL << 8) + GRAF_BIT_MASK);

        DISPDBG((5, "Passed bAssertModeHardware"));
    }
    else
    {
        // Call the kernel driver to reset the device to a known state.
        // NTVDM will take things from there:

        if (EngDeviceIoControl(ppdev->hDriver,
                             IOCTL_VIDEO_RESET_DEVICE,
                             NULL,
                             0,
                             NULL,
                             0,
                             &ReturnedDataLength))
        {
            DISPDBG((0, "bAssertModeHardware - Failed reset IOCTL"));
            goto ReturnFalse;
        }
    }

    return(TRUE);

ReturnFalse:

    DISPDBG((0, "Failed bAssertModeHardware"));

    return(FALSE);
}

/******************************Public*Routine******************************\
* BOOL bEnableHardware
*
* Puts the hardware into the requested mode and initializes it.
*
* Note: Should be called before any access is done to the hardware from
*       the display driver.
*
\**************************************************************************/

BOOL bEnableHardware(
PDEV*   ppdev)
{
    VIDEO_MEMORY                VideoMemory;
    VIDEO_MEMORY_INFORMATION    VideoMemoryInfo;
    VIDEO_MODE_INFORMATION      VideoModeInfo;
    DWORD                       ReturnedDataLength;
    VIDEO_PUBLIC_ACCESS_RANGES  VideoAccessRange;
    DWORD                       status;

    // Map io ports into virtual memory:

    VideoMemory.RequestedVirtualAddress = NULL;

    if (EngDeviceIoControl(ppdev->hDriver,
                         IOCTL_VIDEO_QUERY_PUBLIC_ACCESS_RANGES,
                         NULL,                      // input buffer
                         0,
                         &VideoAccessRange,         // output buffer
                         sizeof (VideoAccessRange),
                         &ReturnedDataLength))
    {
        DISPDBG((0, "bEnableHardware - Initialization error mapping IO port base"));
        goto ReturnFalse;
    }

    ppdev->pjBase = (UCHAR*) VideoAccessRange.VirtualAddress;

    // Set the desired mode. (Must come before IOCTL_VIDEO_MAP_VIDEO_MEMORY;
    // that IOCTL returns information for the current mode, so there must be a
    // current mode for which to return information.)

    if (EngDeviceIoControl(ppdev->hDriver,
                         IOCTL_VIDEO_SET_CURRENT_MODE,
                         &ppdev->ulMode,        // input buffer
                         sizeof(VIDEO_MODE),
                         NULL,
                         0,
                         &ReturnedDataLength))
    {
        DISPDBG((0, "bEnableHardware - Set current mode"));
        goto ReturnFalse;
    }

    // Get the linear memory address range.

    VideoMemory.RequestedVirtualAddress = NULL;

    if (EngDeviceIoControl(ppdev->hDriver,
                         IOCTL_VIDEO_MAP_VIDEO_MEMORY,
                         &VideoMemory,      // input buffer
                         sizeof(VIDEO_MEMORY),
                         &VideoMemoryInfo,  // output buffer
                         sizeof(VideoMemoryInfo),
                         &ReturnedDataLength))
    {
        DISPDBG((0, "bEnableHardware - Error mapping buffer address"));
        goto ReturnFalse;
    }

    DISPDBG((1, "FrameBufferBase: %lx", VideoMemoryInfo.FrameBufferBase));

    // Record the Frame Buffer Linear Address.

    ppdev->pjScreen = (BYTE*) VideoMemoryInfo.FrameBufferBase;

    if (EngDeviceIoControl(ppdev->hDriver,
                         IOCTL_VIDEO_QUERY_CURRENT_MODE,
                         NULL,
                         0,
                         &VideoModeInfo,
                         sizeof(VideoModeInfo),
                         &ReturnedDataLength))
    {
        DISPDBG((0, "bEnableHardware - failed VIDEO_QUERY_CURRENT_MODE"));
        goto ReturnFalse;
    }

    // Store the width of the screen in bytes

    ppdev->lDelta = VideoModeInfo.ScreenStride;

    if (!bAssertModeHardware(ppdev, TRUE))
        goto ReturnFalse;

    DISPDBG((5, "Passed bEnableHardware"));

    return(TRUE);

ReturnFalse:

    DISPDBG((0, "Failed bEnableHardware"));

    return(FALSE);
}

/******************************Public*Routine******************************\
* VOID vDisableHardware
*
* Undoes anything done in bEnableHardware.
*
* Note: In an error case, we may call this before bEnableHardware is
*       completely done.
*
\**************************************************************************/

VOID vDisableHardware(
PDEV*   ppdev)
{
    DWORD        ReturnedDataLength;
    VIDEO_MEMORY VideoMemory;

    if ((VideoMemory.RequestedVirtualAddress = ppdev->pjScreen) != NULL) {

        if (EngDeviceIoControl(ppdev->hDriver,
                             IOCTL_VIDEO_UNMAP_VIDEO_MEMORY,
                             &VideoMemory,
                             sizeof(VIDEO_MEMORY),
                             NULL,
                             0,
                             &ReturnedDataLength))
        {
            DISPDBG((0, "vDisableHardware failed IOCTL_VIDEO_UNMAP_VIDEO"));
        }
    }

    if((VideoMemory.RequestedVirtualAddress = ppdev->pjBase) != INVALID_BASE_ADDRESS) 
    {
        if (EngDeviceIoControl(ppdev->hDriver,
                               IOCTL_VIDEO_FREE_PUBLIC_ACCESS_RANGES,
                               &VideoMemory,
                               sizeof(VIDEO_MEMORY),
                               NULL,
                               0,
                               &ReturnedDataLength))
        {
            DISPDBG((0, "vDisableHardware failed IOCTL_VIDEO_FREE_PUBLIC_ACCESS"));
        }

        ppdev->pjBase = INVALID_BASE_ADDRESS;
    }
}

/******************************Public*Routine******************************\
* VOID vUpdate(ppdev, prcl, pco)
*
* Updates the screen from the DIB surface for the given rectangle.
* Increases the rectangle size if necessary for easy alignment.
*
\**************************************************************************/

#define STRIP_SIZE 32

// This little macro returns the 'PositionInNibble' bit of the
// 'NibbleNumber' nibble of the given 'Dword', and aligns it so that
// it's in the 'PositionInResult' bit of the result.  Numbering is done
// in the order '7 6 5 4 3 2 1 0'.
//
// Given constants for everything but 'Dword', this will amount to an
// AND and a SHIFT.

#define BITPOS(Dword, PositionInNibble, NibbleNumber, PositionInResult) \
(WORD) (((((PositionInNibble) + (NibbleNumber) * 4) > (PositionInResult)) ? \
 (((Dword) & (1 << ((PositionInNibble) + (NibbleNumber) * 4)))          \
  >> ((PositionInNibble) + (NibbleNumber) * 4 - (PositionInResult))) :  \
 (((Dword) & (1 << ((PositionInNibble) + (NibbleNumber) * 4)))          \
  << ((PositionInResult) - (PositionInNibble) - (NibbleNumber) * 4))))

VOID vUpdate(PDEV* ppdev, RECTL* prcl, CLIPOBJ* pco)
{
    BYTE*       pjBase;
    RECTL       rcl;
    SURFOBJ*    pso;
    LONG        cy;
    LONG        cyThis;
    LONG        cw;
    ULONG*      pulSrcStart;
    ULONG*      pulSrc;
    WORD*       pwDstStart;
    WORD*       pwDst;
    LONG        i;
    LONG        j;
    ULONG       ul;
    WORD        w;
    LONG        lSrcDelta;
    LONG        lDstDelta;
    LONG        lSrcSkip;
    LONG        lDstSkip;

    pjBase = ppdev->pjBase;

    if ((pco == NULL) || (pco->iDComplexity == DC_TRIVIAL))
    {
        // We have to clip to the screen dimensions because we may have
        // been a bit loose when we guessed the bounds of the drawing:

        rcl.left   = max(0,               prcl->left);
        rcl.top    = max(0,               prcl->top);
        rcl.right  = min(ppdev->cxScreen, prcl->right);
        rcl.bottom = min(ppdev->cyScreen, prcl->bottom);
    }
    else
    {
        // We may as well save ourselves some blting by clipping to
        // the clip object's maximum extent.  The clip object's bounds
        // are guaranteed to be contained within the dimensions of the
        // screen:

        rcl.left   = max(pco->rclBounds.left,   prcl->left);
        rcl.top    = max(pco->rclBounds.top,    prcl->top);
        rcl.right  = min(pco->rclBounds.right,  prcl->right);
        rcl.bottom = min(pco->rclBounds.bottom, prcl->bottom);
    }

    // Be paranoid:

    if ((rcl.left >= rcl.right) || (rcl.top >= rcl.bottom))
        return;

    // Align to words so that we don't have to do any read-modify-write
    // operations.

    rcl.left  = (rcl.left) & ~15;
    rcl.right = (rcl.right + 15) & ~15;

    pso = ppdev->pso;
    lSrcDelta = pso->lDelta;
    pulSrcStart = (ULONG*) ((BYTE*) pso->pvScan0 + (rcl.top * lSrcDelta)
                                                 + (rcl.left >> 1));

    lDstDelta = ppdev->lDelta;
    pwDstStart = (WORD*) (ppdev->pjScreen + (rcl.top * lDstDelta)
                                          + (rcl.left >> 3));

    cy = (rcl.bottom - rcl.top);
    cw = (rcl.right - rcl.left) >> 4;

    lSrcSkip = lSrcDelta - (8 * cw);
    lDstSkip = lDstDelta - (2 * cw);

    do {
        cyThis = STRIP_SIZE;
        cy -= STRIP_SIZE;
        if (cy < 0)
            cyThis += cy;

        // Map in plane 0:

        OUT_BYTE(pjBase, VGA_BASE + SEQ_DATA, MM_C0);

        pwDst = pwDstStart;
        pulSrc = pulSrcStart;

        for (j = cyThis; j != 0; j--)
        {
            for (i = cw; i != 0; i--)
            {
                ul = *(pulSrc);

                w = BITPOS(ul, 0, 6, 0) |
                    BITPOS(ul, 0, 7, 1) |
                    BITPOS(ul, 0, 4, 2) |
                    BITPOS(ul, 0, 5, 3) |
                    BITPOS(ul, 0, 2, 4) |
                    BITPOS(ul, 0, 3, 5) |
                    BITPOS(ul, 0, 0, 6) |
                    BITPOS(ul, 0, 1, 7);

                ul = *(pulSrc + 1);

                w |= BITPOS(ul, 0, 6, 8)  |
                     BITPOS(ul, 0, 7, 9)  |
                     BITPOS(ul, 0, 4, 10) |
                     BITPOS(ul, 0, 5, 11) |
                     BITPOS(ul, 0, 2, 12) |
                     BITPOS(ul, 0, 3, 13) |
                     BITPOS(ul, 0, 0, 14) |
                     BITPOS(ul, 0, 1, 15);

                WRITE_WORD(pwDst, w);

                pwDst  += 1;
                pulSrc += 2;
            }

            pwDst  = (WORD*)  ((BYTE*) pwDst  + lDstSkip);
            pulSrc = (ULONG*) ((BYTE*) pulSrc + lSrcSkip);
        }

        // Map in plane 1:

        OUT_BYTE(pjBase, VGA_BASE + SEQ_DATA, MM_C1);

        pwDst = pwDstStart;
        pulSrc = pulSrcStart;

        for (j = cyThis; j != 0; j--)
        {
            for (i = cw; i != 0; i--)
            {
                ul = *(pulSrc);

                w = BITPOS(ul, 1, 6, 0) |
                    BITPOS(ul, 1, 7, 1) |
                    BITPOS(ul, 1, 4, 2) |
                    BITPOS(ul, 1, 5, 3) |
                    BITPOS(ul, 1, 2, 4) |
                    BITPOS(ul, 1, 3, 5) |
                    BITPOS(ul, 1, 0, 6) |
                    BITPOS(ul, 1, 1, 7);

                ul = *(pulSrc + 1);

                w |= BITPOS(ul, 1, 6, 8)  |
                     BITPOS(ul, 1, 7, 9)  |
                     BITPOS(ul, 1, 4, 10) |
                     BITPOS(ul, 1, 5, 11) |
                     BITPOS(ul, 1, 2, 12) |
                     BITPOS(ul, 1, 3, 13) |
                     BITPOS(ul, 1, 0, 14) |
                     BITPOS(ul, 1, 1, 15);

                WRITE_WORD(pwDst, w);

                pwDst  += 1;
                pulSrc += 2;
            }

            pwDst  = (WORD*)  ((BYTE*) pwDst  + lDstSkip);
            pulSrc = (ULONG*) ((BYTE*) pulSrc + lSrcSkip);
        }

        // Map in plane 2:

        OUT_BYTE(pjBase, VGA_BASE + SEQ_DATA, MM_C2);

        pwDst = pwDstStart;
        pulSrc = pulSrcStart;

        for (j = cyThis; j != 0; j--)
        {
            for (i = cw; i != 0; i--)
            {
                ul = *(pulSrc);

                w = BITPOS(ul, 2, 6, 0) |
                    BITPOS(ul, 2, 7, 1) |
                    BITPOS(ul, 2, 4, 2) |
                    BITPOS(ul, 2, 5, 3) |
                    BITPOS(ul, 2, 2, 4) |
                    BITPOS(ul, 2, 3, 5) |
                    BITPOS(ul, 2, 0, 6) |
                    BITPOS(ul, 2, 1, 7);

                ul = *(pulSrc + 1);

                w |= BITPOS(ul, 2, 6, 8)  |
                     BITPOS(ul, 2, 7, 9)  |
                     BITPOS(ul, 2, 4, 10) |
                     BITPOS(ul, 2, 5, 11) |
                     BITPOS(ul, 2, 2, 12) |
                     BITPOS(ul, 2, 3, 13) |
                     BITPOS(ul, 2, 0, 14) |
                     BITPOS(ul, 2, 1, 15);

                WRITE_WORD(pwDst, w);

                pwDst  += 1;
                pulSrc += 2;
            }

            pwDst  = (WORD*)  ((BYTE*) pwDst  + lDstSkip);
            pulSrc = (ULONG*) ((BYTE*) pulSrc + lSrcSkip);
        }

        // Map in plane 3:

        OUT_BYTE(pjBase, VGA_BASE + SEQ_DATA, MM_C3);

        pwDst = pwDstStart;
        pulSrc = pulSrcStart;

        for (j = cyThis; j != 0; j--)
        {
            for (i = cw; i != 0; i--)
            {
                ul = *(pulSrc);

                w = BITPOS(ul, 3, 6, 0) |
                    BITPOS(ul, 3, 7, 1) |
                    BITPOS(ul, 3, 4, 2) |
                    BITPOS(ul, 3, 5, 3) |
                    BITPOS(ul, 3, 2, 4) |
                    BITPOS(ul, 3, 3, 5) |
                    BITPOS(ul, 3, 0, 6) |
                    BITPOS(ul, 3, 1, 7);

                ul = *(pulSrc + 1);

                w |= BITPOS(ul, 3, 6, 8)  |
                     BITPOS(ul, 3, 7, 9)  |
                     BITPOS(ul, 3, 4, 10) |
                     BITPOS(ul, 3, 5, 11) |
                     BITPOS(ul, 3, 2, 12) |
                     BITPOS(ul, 3, 3, 13) |
                     BITPOS(ul, 3, 0, 14) |
                     BITPOS(ul, 3, 1, 15);

                WRITE_WORD(pwDst, w);

                pwDst  += 1;
                pulSrc += 2;
            }

            pwDst  = (WORD*)  ((BYTE*) pwDst  + lDstSkip);
            pulSrc = (ULONG*) ((BYTE*) pulSrc + lSrcSkip);
        }

        // Get ready for next strip:

        pulSrcStart = (ULONG*) ((BYTE*) pulSrcStart + (cyThis * lSrcDelta));
        pwDstStart  = (WORD*)  ((BYTE*) pwDstStart  + (cyThis * lDstDelta));

    } while (cy > 0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\videosim\videodat.c ===
/*++

Copyright (c) 1992-1994  Microsoft Corporation

Module Name:

    videosim.c

Abstract:

    mode table for the simulation driver.

Environment:

    Kernel mode

Revision History:

--*/

#define _NTDRIVER_

#ifndef FAR
#define FAR
#endif

#include "dderror.h"
#include "ntosp.h"
#include "stdarg.h"
#include "stdio.h"

#include "ntddvdeo.h"
#include "video.h"
#include "videosim.h"


#if defined(ALLOC_PRAGMA)
#pragma data_seg("PAGE")
#endif


ULONG bLoaded = 0;

//
// sim mode information Tables.
//

VIDEO_MODE_INFORMATION SimModes[] = {
{
      sizeof(VIDEO_MODE_INFORMATION),
      0,
      2000,
      1600,
      4000,
      1,
      16,
      0,
      320,
      240,
      8,
      8,
      8,
      0x00007c00,
      0x000003e0,
      0x0000001f,
      VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS
},
{
      sizeof(VIDEO_MODE_INFORMATION),
      0,
      1280,
      1024,
      2560,
      1,
      16,
      72,
      320,
      240,
      8,
      8,
      8,
      0x0000fc00,
      0x000003f0,
      0x0000000f,
      VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS
},
{
      sizeof(VIDEO_MODE_INFORMATION),
      0,
      1280,
      1024,
      1280,
      1,
      8,
      60,
      320,
      240,
      8,
      8,
      8,
      0x00000000,
      0x00000000,
      0x00000000,
      VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS | VIDEO_MODE_PALETTE_DRIVEN |
          VIDEO_MODE_MANAGED_PALETTE
},
{
      sizeof(VIDEO_MODE_INFORMATION),
      0,
      1152,
      900,
      2304,
      1,
      16,
      66,
      320,
      240,
      8,
      8,
      8,
      0x0000fc00,
      0x000003f0,
      0x0000000f,
      VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS
},
{
      sizeof(VIDEO_MODE_INFORMATION),
      0,
      1152,
      900,
      1152,
      1,
      8,
      66,
      320,
      240,
      8,
      8,
      8,
      0x00000000,
      0x00000000,
      0x00000000,
      VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS | VIDEO_MODE_PALETTE_DRIVEN |
          VIDEO_MODE_MANAGED_PALETTE
},
{
      sizeof(VIDEO_MODE_INFORMATION),
      0,
      800,
      600,
      1600,
      1,
      16,
      72,
      320,
      240,
      8,
      8,
      8,
      0x0000fc00,
      0x000003f0,
      0x0000000f,
      VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS
},
{
      sizeof(VIDEO_MODE_INFORMATION),
      0,
      800,
      600,
      800,
      1,
      8,
      72,
      320,
      240,
      8,
      8,
      8,
      0x00000000,
      0x00000000,
      0x00000000,
      VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS | VIDEO_MODE_PALETTE_DRIVEN |
          VIDEO_MODE_MANAGED_PALETTE
},
{
      sizeof(VIDEO_MODE_INFORMATION),
      0,
      640,
      480,
      2560,
      1,
      32,
      0,
      320,
      240,
      8,
      8,
      8,
      0x00ff0000,
      0x0000ff00,
      0x000000ff,
      VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS
},
{
      sizeof(VIDEO_MODE_INFORMATION),
      0,
      640,
      480,
      640,
      1,
      8,
      45,
      320,
      240,
      8,
      8,
      8,
      0x00000000,
      0x00000000,
      0x00000000,
      VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS | VIDEO_MODE_PALETTE_DRIVEN |
          VIDEO_MODE_MANAGED_PALETTE
},
{
      sizeof(VIDEO_MODE_INFORMATION),
      0,
      100,
      100,
      100,
      1,
      8,
      45,
      320,
      240,
      8,
      8,
      8,
      0x00000000,
      0x00000000,
      0x00000000,
      VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS | VIDEO_MODE_PALETTE_DRIVEN |
          VIDEO_MODE_MANAGED_PALETTE
}
};

ULONG SimNumModes = sizeof(SimModes) / sizeof(VIDEO_MODE_INFORMATION);

#if defined(ALLOC_PRAGMA)
#pragma data_seg()
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\vgarisc\disp\hw.h ===
/******************************Module*Header*******************************\
* Module Name: hw.h
*
* All the hardware specific driver file stuff.
*
* Copyright (c) 1992-1995 Microsoft Corporation
\**************************************************************************/

//  Miscellaneous Registers used only at EGA/VGA initialization time

#define MISC_OUTPUT         0x0C2       // Miscellaneous Output Register
#define CRTC_ADDR           0x0D4       // CRTC Address Register for color mode
#define CRTC_DATA           0x0D5       // CRTC Data    Register for color mode
#define GRAF_1_POS          0x0CC       // Graphics 1 Address Register
#define GRAF_2_POS          0x0CA       // Graphics 2 Address Register
#define ATTR_READ           0x0DA       // Attribute Controler Read  Address
#define ATTR_WRITE          0x0C0       // Attribute Controler Write Address
#define IN_STAT_0           0x0C2       // Input Status Register 0
#define IN_STAT_1           0x0DA       // Input Status Register 1

//  EGA/VGA Register Definitions.
//
//  The following definitions are the EGA/VGA registers and values
//  used by this driver.  All other registers are set up at
//  when the EGA/VGA is placed into graphics mode and never altered
//  afterwards.
//
//  All unspecified bits in the following registers must be 0.

#define EGA_BASE            0x300       // Base address of the EGA (3xx)
#define VGA_BASE            0x300       // Base address of the VGA (3xx)

//  SEQUencer Registers Used

#define SEQ_ADDR            0xC4        // SEQUencer Address Register
#define SEQ_DATA            0xC5        // SEQUencer Data    Register

#define SEQ_MAP_MASK        0x02        // Write Plane Enable Mask
#define MM_C0               0x01        // C0 plane enable
#define MM_C1               0x02        // C1 plane enable
#define MM_C2               0x04        // C2 plane enable
#define MM_C3               0x08        // C3 plane enable
#define MM_ALL              0x0f        // All planes

#define SEQ_MODE            0x04        // Memory Mode
#define SM_ALPHA            0x01        // Char map select enable
#define SM_EXTENDED         0x02        // Extended memory present
#define SM_ODD_PLANE        0x04        // Odd/even bytes to same plane

//  Graphics Controller Registers Used

#define GRAF_ADDR           0xCE        // Graphics Controller Address Register
#define GRAF_DATA           0xCF        // Graphics Controller Data    Register

#define GRAF_SET_RESET      0x00        // Set/Reset Plane Color
#define GRAF_ENAB_SR        0x01        // Set/Reset Enable
#define GRAF_COL_COMP       0x02        // Color Compare Register

#define GRAF_DATA_ROT       0x03        // Data Rotate Register
#define DR_ROT_CNT          0x07        //   Data Rotate Count
#define DR_SET              0x00        //   Data Unmodified
#define DR_AND              0x08        //   Data ANDed with latches
#define DR_OR               0x10        //   Data ORed  with latches
#define DR_XOR              0x18        //   Data XORed with latches

#define GRAF_READ_MAP       0x04        // Read Map Select Register
#define RM_C0               0x00        //   Read C0 plane
#define RM_C1               0x01        //   Read C1 plane
#define RM_C2               0x02        //   Read C2 plane
#define RM_C3               0x03        //   Read C3 plane

#define GRAF_MODE           0x05        // Mode Register
#define M_PROC_WRITE        0x00        //   Write processor data rotated
#define M_LATCH_WRITE       0x01        //   Write latched data
#define M_COLOR_WRITE       0x02        //   Write processor data as color
#define M_AND_WRITE         0x03        //   Write (procdata AND bitmask)
#define M_DATA_READ         0x00        //   Read selected plane
#define M_COLOR_READ        0x08        //   Read color compare

#define GRAF_MISC           0x06        // Miscellaneous Register
#define MS_NON_ALPHA        0x01        //   Char generator disabled
#define MS_ODD_EVEN         0x02        //   Map odd addresses to even
#define MS_A0000_128K       0x00        //   Memory present at A0000, 128kb
#define MS_A0000_64K        0x04        //   Memory present at A0000, 64kb
#define MS_B0000_32K        0x08        //   Memory present at B0000, 32kb
#define MS_B8000_32K        0x0C        //   Memory present at B8000, 32kb
#define MS_ADDR_MASK        0x0C

#define GRAF_CDC            0x07        // Color Don't Care Register
#define GRAF_BIT_MASK       0x08        // Bit Mask Register

// pdev->pjBase is set to this value before it is actually initialized

#define INVALID_BASE_ADDRESS (UCHAR *)( -1 )

////////////////////////////////////////////////////////////////////////
// Direct access macros
//

#define OUT_WORD(pjBase, addr, w)                           \
{                                                           \
    MEMORY_BARRIER();                                       \
    WRITE_PORT_USHORT((BYTE*) (pjBase) + (addr), (USHORT) (w)); \
}

#define OUT_BYTE(pjBase, addr, j)                           \
{                                                           \
    MEMORY_BARRIER();                                       \
    WRITE_PORT_UCHAR((BYTE*) (pjBase) + (addr), (UCHAR) (j)); \
}

#define WRITE_WORD(pwAddr, w)                               \
    WRITE_REGISTER_USHORT((USHORT*) (pwAddr), (USHORT) (w))
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\videosim\videosim.h ===
/*++

Copyright (c) 1992-1994  Microsoft Corporation

Module Name:

    videosim.h

Abstract:

    definitions for the simulation driver.

Environment:

    Kernel mode

Revision History:

--*/

//
// Define device extension structure. This is device dependant/private
// information.
//

typedef struct _HW_DEVICE_EXTENSION {
    PVOID VideoRamBase;
    ULONG VideoRamLength;
    ULONG CurrentModeNumber;
    PVOID SectionPointer;
    PMDL  Mdl;
} HW_DEVICE_EXTENSION, *PHW_DEVICE_EXTENSION;


#define ONE_MEG 0x100000

extern VIDEO_MODE_INFORMATION SimModes[];
extern ULONG SimNumModes;

extern ULONG bLoaded;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\watchdog\gdisup.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    gdisup.c

Abstract:

    This is the NT Watchdog driver implementation.
    This module implements support routines for
    watchdog in win32k.

Author:

    Michael Maciesowicz (mmacie) 05-May-2000

Environment:

    Kernel mode only.

Notes:

    This module cannot be moved to win32k since routines defined here can
    be called at any time and it is possible that win32k may not be mapped
    into running process space at this time (e.g. TS session).

Revision History:

--*/

//
// TODO: This module needs major rework.
//
// 1. We should eliminate all global variables from here and move them into
// GDI context structure.
//
// 2. We should extract generic logging routines
// (e.g. WdWriteErrorLogEntry(pdo, className), WdWriteEventToRegistry(...),
// WdBreakPoint(...) so we can use them for any device class, not just Display.
//
// 3. We should use IoAllocateWorkItem - we could drop some globals then.
//

#include "gdisup.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text (PAGE, WdpBugCheckStuckDriver)
#endif

WD_BUGCHECK_DATA
g_WdpBugCheckData = {0, 0, 0, 0, 0};

WORK_QUEUE_ITEM
g_WdpWorkQueueItem;

LONG 
g_lWdpDisplayHandlerState = WD_HANDLER_IDLE;

WATCHDOGAPI
VOID
WdDdiWatchdogDpcCallback(
    IN PKDPC pDpc,
    IN PVOID pDeferredContext,
    IN PVOID pSystemArgument1,
    IN PVOID pSystemArgument2
    )

/*++

Routine Description:

    This function is a DPC callback routine for GDI watchdog. It is only
    called when GDI watchdog times out before it is cancelled. It schedules
    a work item to bugcheck the machine in the context of system worker
    thread.

Arguments:

    pDpc - Supplies a pointer to a DPC object.

    pDeferredContext - Supplies a pointer to a GDI defined context.

    pSystemArgument1 - Supplies a pointer to a spinning thread object (PKTHREAD).

    pSystemArgument2 - Supplies a pointer to a watchdog object (PDEFERRED_WATCHDOG).

Return Value:

    None.

--*/

{
    //
    // Make sure we handle only one event at the time.
    //
    // Note: Timeout and recovery events for the same watchdog object are
    // synchronized already in timer DPC.
    //

    WDD_TRACE_CALL((PDEFERRED_WATCHDOG)pSystemArgument1, WddWdDdiWatchdogDpcCallback);

    if (InterlockedCompareExchange(&g_lWdpDisplayHandlerState,
                                   WD_HANDLER_BUSY,
                                   WD_HANDLER_IDLE) == WD_HANDLER_IDLE)
    {
        g_WdpBugCheckData.ulBugCheckCode = THREAD_STUCK_IN_DEVICE_DRIVER;
        g_WdpBugCheckData.ulpBugCheckParameter1 = (ULONG_PTR)pSystemArgument1;
        g_WdpBugCheckData.ulpBugCheckParameter2 = (ULONG_PTR)pSystemArgument2;
        g_WdpBugCheckData.ulpBugCheckParameter3 = (ULONG_PTR)pDeferredContext;
        g_WdpBugCheckData.ulpBugCheckParameter4++;

        ExInitializeWorkItem(&g_WdpWorkQueueItem, WdpBugCheckStuckDriver, &g_WdpBugCheckData);
        ExQueueWorkItem(&g_WdpWorkQueueItem, CriticalWorkQueue);
    }
    else
    {
        //
        // Resume watchdog event processing.
        //

        WdCompleteEvent(pSystemArgument2, (PKTHREAD)pSystemArgument1);
    }

    return;
}   // WdDdiWatchdogDpcCallback()

VOID
WdpBugCheckStuckDriver(
    IN PVOID pvContext
    )

/*++

Routine Description:

    This function is a worker callback routine for GDI watchdog DPC.

Arguments:

    pvContext - Supplies a pointer to a watchdog defined context.

Return Value:

    None.

--*/

{
    static BOOLEAN s_bFirstTime = TRUE;
    static BOOLEAN s_bDbgBreak = FALSE;
    static BOOLEAN s_bEventLogged = FALSE;
    static ULONG s_ulTrapOnce = WD_DEFAULT_TRAP_ONCE;
    static ULONG s_ulDisableBugcheck = WD_DEFAULT_DISABLE_BUGCHECK;
    static ULONG s_ulBreakPointDelay = WD_GDI_STRESS_BREAK_POINT_DELAY;
    static ULONG s_ulCurrentBreakPointDelay = WD_GDI_STRESS_BREAK_POINT_DELAY;
    static ULONG s_ulBreakCount = 0;
    static ULONG s_ulEventCount = 0;
    static ULONG s_ulEaRecovery = 0;
    static ULONG s_ulFullRecovery = 0;
    PWD_BUGCHECK_DATA pBugCheckData;
    PKTHREAD pThread;
    PDEFERRED_WATCHDOG pWatch;
    PUNICODE_STRING pUnicodeDriverName;
    PDEVICE_OBJECT pFdo;
    PDEVICE_OBJECT pPdo;
    PWD_GDI_DPC_CONTEXT pDpcContext;
    NTSTATUS ntStatus;
    WD_EVENT_TYPE lastEvent;
    
    PAGED_CODE();
    ASSERT(NULL != pvContext);

    pBugCheckData = (PWD_BUGCHECK_DATA)pvContext;
    pThread = (PKTHREAD)(pBugCheckData->ulpBugCheckParameter1);
    pWatch = (PDEFERRED_WATCHDOG)(pBugCheckData->ulpBugCheckParameter2);
    pDpcContext = (PWD_GDI_DPC_CONTEXT)(pBugCheckData->ulpBugCheckParameter3);
    ASSERT(NULL != pDpcContext);
    pUnicodeDriverName = &(pDpcContext->DisplayDriverName);

    WDD_TRACE_CALL(pWatch, WddWdpBugCheckStuckDriver);

    //
    // Note: pThread is NULL for recovery events.
    //

    ASSERT(NULL != pWatch);
    ASSERT(NULL != pUnicodeDriverName);

    pFdo = WdGetDeviceObject(pWatch);
    pPdo = WdGetLowestDeviceObject(pWatch);

    ASSERT(NULL != pFdo);
    ASSERT(NULL != pPdo);

    lastEvent = WdGetLastEvent(pWatch);

    ASSERT((WdTimeoutEvent == lastEvent) || (WdRecoveryEvent == lastEvent));

    //
    // Grab configuration data from the registry on first timeout.
    //

    if (TRUE == s_bFirstTime)
    {
        ULONG ulDefaultTrapOnce = WD_DEFAULT_TRAP_ONCE;
        ULONG ulDefaultDisableBugcheck = WD_DEFAULT_DISABLE_BUGCHECK;
        ULONG ulDefaultBreakPointDelay = WD_GDI_STRESS_BREAK_POINT_DELAY;
        ULONG ulDefaultBreakCount = 0;
        ULONG ulDefaultEventCount = 0;
        ULONG ulDefaultEaRecovery = 0;
        ULONG ulDefaultFullRecovery = 0;
        RTL_QUERY_REGISTRY_TABLE queryTable[] =
        {
            {NULL, RTL_QUERY_REGISTRY_DIRECT, L"TrapOnce", &s_ulTrapOnce, REG_DWORD, &ulDefaultTrapOnce, 4},
            {NULL, RTL_QUERY_REGISTRY_DIRECT, L"DisableBugcheck", &s_ulDisableBugcheck, REG_DWORD, &ulDefaultDisableBugcheck, 4},
            {NULL, RTL_QUERY_REGISTRY_DIRECT, L"BreakPointDelay", &s_ulBreakPointDelay, REG_DWORD, &ulDefaultBreakPointDelay, 4},
            {NULL, RTL_QUERY_REGISTRY_DIRECT, L"BreakCount", &s_ulBreakCount, REG_DWORD, &ulDefaultBreakCount, 4},
            {NULL, RTL_QUERY_REGISTRY_DIRECT, L"EaRecovery", &s_ulEaRecovery, REG_DWORD, &ulDefaultEaRecovery, 4},
            {NULL, RTL_QUERY_REGISTRY_DIRECT, L"FullRecovery", &s_ulFullRecovery, REG_DWORD, &ulDefaultFullRecovery, 4},
            {NULL, 0, NULL}
        };

        //
        // Get configurable values and accumulated statistics from registry.
        //

        RtlQueryRegistryValues(RTL_REGISTRY_ABSOLUTE,
                               WD_KEY_WATCHDOG_DISPLAY,
                               queryTable,
                               NULL,
                               NULL);

        //
        // Rolling down counter to workaround GDI slowness in some stress cases.
        //

        s_ulCurrentBreakPointDelay = s_ulBreakPointDelay;

#if !defined(_X86_) && !defined(_IA64_)

        //
        // For now, only recover on x86 and ia64.
        //

        s_ulEaRecovery = 0;

#endif

    }

    //
    // Handle current event.
    //

    if (WdTimeoutEvent == lastEvent)
    {
        //
        // Timeout.
        //

        ULONG ulDebuggerNotPresent;
        BOOLEAN bBreakIn;

        ASSERT(NULL != pThread);

        ulDebuggerNotPresent = 1;
        bBreakIn = FALSE;

        KdRefreshDebuggerNotPresent();

        if ((TRUE == KD_DEBUGGER_ENABLED) && (FALSE == KD_DEBUGGER_NOT_PRESENT))
        {
            //
            // Give a chance to debug a spinning code if kernel debugger is connected.
            //

            ulDebuggerNotPresent = 0;

            if ((0 == s_ulTrapOnce) || (FALSE == s_bDbgBreak))
            {
                //
                // Print out info to debugger and break in if we timed out enought times already.
                // Hopefuly one day GDI becomes fast enough and we won't have to set any delays.
                //

                if (0 == s_ulCurrentBreakPointDelay)
                {
                    s_ulCurrentBreakPointDelay = s_ulBreakPointDelay;

                    DbgPrint("\n");
                    DbgPrint("*******************************************************************************\n");
                    DbgPrint("*                                                                             *\n");
                    DbgPrint("*  The watchdog detected a timeout condition. We broke into the debugger to   *\n");
                    DbgPrint("*  allow a chance for debugging this failure.                                 *\n");
                    DbgPrint("*                                                                             *\n");
                    DbgPrint("*  Intercepted bugcheck code and arguments are listed below this message.     *\n");
                    DbgPrint("*  You can use them the same way as you would in case of the actual break,    *\n");
                    DbgPrint("*  i.e. execute .thread Arg1 then kv to identify an offending thread.         *\n");
                    DbgPrint("*                                                                             *\n");
                    DbgPrint("*******************************************************************************\n");
                    DbgPrint("\n");
                    DbgPrint("*** Intercepted Fatal System Error: 0x%08X\n", pBugCheckData->ulBugCheckCode);
                    DbgPrint("    (0x%p,0x%p,0x%p,0x%p)\n\n",
                             pBugCheckData->ulpBugCheckParameter1,
                             pBugCheckData->ulpBugCheckParameter2,
                             pBugCheckData->ulpBugCheckParameter3,
                             pBugCheckData->ulpBugCheckParameter4);
                    DbgPrint("Driver at fault: %ws\n\n", pUnicodeDriverName->Buffer);

                    bBreakIn = TRUE;
                    s_bDbgBreak = TRUE;
                    s_ulBreakCount++;
                }
                else
                {
                    DbgPrint("Watchdog: Timeout in %ws. Break in %d\n",
                             pUnicodeDriverName->Buffer,
                             s_ulCurrentBreakPointDelay);

                    s_ulCurrentBreakPointDelay--;
                }
            }

            //
            // Make sure we won't bugcheck if we have kernel debugger connected.
            //

            s_ulDisableBugcheck = 1;
        }
        else if (0 == s_ulDisableBugcheck)
        {
            s_ulBreakCount++;
        }

        //
        // Log error (only once unless we recover).
        //

        if ((FALSE == s_bEventLogged) && ((TRUE == bBreakIn) || ulDebuggerNotPresent))
        {
            PIO_ERROR_LOG_PACKET pIoErrorLogPacket;
            ULONG ulPacketSize;
            USHORT usNumberOfStrings;
            PWCHAR wszDeviceClass = L"display";
            ULONG ulClassSize = sizeof (L"display");

            ulPacketSize = sizeof (IO_ERROR_LOG_PACKET);
            usNumberOfStrings = 0;

            //
            // For event log message:
            //
            // %1 = fixed device description (this is set by event log itself)
            // %2 = string 1 = device class starting in lower case
            // %3 = string 2 = driver name
            //

            if ((ulPacketSize + ulClassSize) <= ERROR_LOG_MAXIMUM_SIZE)
            {
                ulPacketSize += ulClassSize;
                usNumberOfStrings++;

                //
                // We're looking at MaximumLength since it includes terminating UNICODE_NULL.
                //

                if ((ulPacketSize + pUnicodeDriverName->MaximumLength) <= ERROR_LOG_MAXIMUM_SIZE)
                {
                    ulPacketSize += pUnicodeDriverName->MaximumLength;
                    usNumberOfStrings++;
                }
            }

            pIoErrorLogPacket = IoAllocateErrorLogEntry(pFdo, (UCHAR)ulPacketSize);

            if (pIoErrorLogPacket)
            {
                pIoErrorLogPacket->MajorFunctionCode = 0;
                pIoErrorLogPacket->RetryCount = 0;
                pIoErrorLogPacket->DumpDataSize = 0;
                pIoErrorLogPacket->NumberOfStrings = usNumberOfStrings;
                pIoErrorLogPacket->StringOffset = (USHORT)FIELD_OFFSET(IO_ERROR_LOG_PACKET, DumpData);
                pIoErrorLogPacket->EventCategory = 0;
                pIoErrorLogPacket->ErrorCode = IO_ERR_THREAD_STUCK_IN_DEVICE_DRIVER;
                pIoErrorLogPacket->UniqueErrorValue = 0;
                pIoErrorLogPacket->FinalStatus = STATUS_SUCCESS;
                pIoErrorLogPacket->SequenceNumber = 0;
                pIoErrorLogPacket->IoControlCode = 0;
                pIoErrorLogPacket->DeviceOffset.QuadPart = 0;

                if (usNumberOfStrings > 0)
                {
                    RtlCopyMemory(&(pIoErrorLogPacket->DumpData[0]),
                                  wszDeviceClass,
                                  ulClassSize);

                    if (usNumberOfStrings > 1)
                    {
                        RtlCopyMemory((PUCHAR)&(pIoErrorLogPacket->DumpData[0]) + ulClassSize,
                                      pUnicodeDriverName->Buffer,
                                      pUnicodeDriverName->MaximumLength);
                    }
                }

                IoWriteErrorLogEntry(pIoErrorLogPacket);

                s_bEventLogged = TRUE;
            }
        }

        //
        // Write reliability info into registry. Setting ShutdownEventPending will trigger winlogon
        // to run savedump where we're doing our boot-time handling of watchdog events for DrWatson.
        //
        // Note: We are only allowed to set ShutdownEventPending, savedump is the only component
        // allowed to clear this value. Even if we recover from watchdog timeout we'll keep this
        // value set, savedump will be able to figure out if we recovered or not.
        //

        if (TRUE == s_bFirstTime)
        {
            ULONG ulValue = 1;

            //
            // Set ShutdownEventPending flag.
            //

            ntStatus = RtlWriteRegistryValue(RTL_REGISTRY_ABSOLUTE,
                                             WD_KEY_RELIABILITY,
                                             L"ShutdownEventPending",
                                             REG_DWORD,
                                             &ulValue,
                                             sizeof (ulValue));

            if (NT_SUCCESS(ntStatus))
            {
                WdpFlushRegistryKey(pWatch, WD_KEY_RELIABILITY);
            }
            else
            {
                //
                // Reliability key should be always reliable there.
                //

                ASSERT(FALSE);
            }
        }

        //
        // Write watchdog event info into registry.
        //

        if ((0 == s_ulTrapOnce) || (TRUE == s_bFirstTime))
        {
            //
            // Is Watchdog\Display key already there?
            //

            ntStatus = RtlCheckRegistryKey(RTL_REGISTRY_ABSOLUTE,
                                           WD_KEY_WATCHDOG_DISPLAY);

            if (!NT_SUCCESS(ntStatus))
            {
                //
                // Is Watchdog key already there?
                //

                ntStatus = RtlCheckRegistryKey(RTL_REGISTRY_ABSOLUTE,
                                               WD_KEY_WATCHDOG);

                if (!NT_SUCCESS(ntStatus))
                {
                    //
                    // Create a new key.
                    //

                    ntStatus = RtlCreateRegistryKey(RTL_REGISTRY_ABSOLUTE,
                                                    WD_KEY_WATCHDOG);
                }

                if (NT_SUCCESS(ntStatus))
                {
                    //
                    // Create a new key.
                    //

                    ntStatus = RtlCreateRegistryKey(RTL_REGISTRY_ABSOLUTE,
                                                    WD_KEY_WATCHDOG_DISPLAY);
                }
            }

            if (NT_SUCCESS(ntStatus))
            {
                PVOID pvPropertyBuffer;
                ULONG ulLength;
                ULONG ulValue;

                //
                // Set values maintained by watchdog.
                //

                ulValue = 1;

                RtlWriteRegistryValue(RTL_REGISTRY_ABSOLUTE,
                                      WD_KEY_WATCHDOG_DISPLAY,
                                      L"EventFlag",
                                      REG_DWORD,
                                      &ulValue,
                                      sizeof (ulValue));

                s_ulEventCount++;

                RtlWriteRegistryValue(RTL_REGISTRY_ABSOLUTE,
                                      WD_KEY_WATCHDOG_DISPLAY,
                                      L"EventCount",
                                      REG_DWORD,
                                      &s_ulEventCount,
                                      sizeof (s_ulEventCount));

                RtlWriteRegistryValue(RTL_REGISTRY_ABSOLUTE,
                                      WD_KEY_WATCHDOG_DISPLAY,
                                      L"BreakCount",
                                      REG_DWORD,
                                      &s_ulBreakCount,
                                      sizeof (s_ulBreakCount));

                ulValue = !s_ulDisableBugcheck;

                RtlWriteRegistryValue(RTL_REGISTRY_ABSOLUTE,
                                      WD_KEY_WATCHDOG_DISPLAY,
                                      L"BugcheckTriggered",
                                      REG_DWORD,
                                      &ulValue,
                                      sizeof (ulValue));

                RtlWriteRegistryValue(RTL_REGISTRY_ABSOLUTE,
                                      WD_KEY_WATCHDOG_DISPLAY,
                                      L"DebuggerNotPresent",
                                      REG_DWORD,
                                      &ulDebuggerNotPresent,
                                      sizeof (ulDebuggerNotPresent));

                RtlWriteRegistryValue(RTL_REGISTRY_ABSOLUTE,
                                      WD_KEY_WATCHDOG_DISPLAY,
                                      L"DriverName",
                                      REG_SZ,
                                      pUnicodeDriverName->Buffer,
                                      pUnicodeDriverName->MaximumLength);

                //
                // Delete other values in case allocation or property read fails.
                //

                RtlDeleteRegistryValue(RTL_REGISTRY_ABSOLUTE,
                                       WD_KEY_WATCHDOG_DISPLAY,
                                       L"DeviceClass");

                RtlDeleteRegistryValue(RTL_REGISTRY_ABSOLUTE,
                                       WD_KEY_WATCHDOG_DISPLAY,
                                       L"DeviceDescription");

                RtlDeleteRegistryValue(RTL_REGISTRY_ABSOLUTE,
                                       WD_KEY_WATCHDOG_DISPLAY,
                                       L"DeviceFriendlyName");

                RtlDeleteRegistryValue(RTL_REGISTRY_ABSOLUTE,
                                       WD_KEY_WATCHDOG_DISPLAY,
                                       L"HardwareID");

                RtlDeleteRegistryValue(RTL_REGISTRY_ABSOLUTE,
                                       WD_KEY_WATCHDOG_DISPLAY,
                                       L"Manufacturer");

                //
                // Allocate buffer for device properties reads.
                //
                // Note: Legacy devices don't have PDOs and we can't query properties
                // for them. Calling IoGetDeviceProperty() with FDO upsets Verifier.
                // In legacy case lowest device object is the same as FDO, we check
                // against this and if this is the case we won't allocate property
                // buffer and we'll skip the next block.
                //

                if (pFdo != pPdo)
                {
                    pvPropertyBuffer = ExAllocatePoolWithTag(PagedPool,
                                                             WD_MAX_PROPERTY_SIZE,
                                                             WD_TAG);
                }
                else
                {
                    pvPropertyBuffer = NULL;
                }

                if (pvPropertyBuffer)
                {
                    //
                    // Read and save device properties.
                    //

                    ntStatus = IoGetDeviceProperty(pPdo,
                                                   DevicePropertyClassName,
                                                   WD_MAX_PROPERTY_SIZE,
                                                   pvPropertyBuffer,
                                                   &ulLength);

                    if (NT_SUCCESS(ntStatus))
                    {
                        RtlWriteRegistryValue(RTL_REGISTRY_ABSOLUTE,
                                              WD_KEY_WATCHDOG_DISPLAY,
                                              L"DeviceClass",
                                              REG_SZ,
                                              pvPropertyBuffer,
                                              ulLength);
                    }

                    ntStatus = IoGetDeviceProperty(pPdo,
                                                   DevicePropertyDeviceDescription,
                                                   WD_MAX_PROPERTY_SIZE,
                                                   pvPropertyBuffer,
                                                   &ulLength);

                    if (NT_SUCCESS(ntStatus))
                    {
                        RtlWriteRegistryValue(RTL_REGISTRY_ABSOLUTE,
                                              WD_KEY_WATCHDOG_DISPLAY,
                                              L"DeviceDescription",
                                              REG_SZ,
                                              pvPropertyBuffer,
                                              ulLength);
                    }

                    ntStatus = IoGetDeviceProperty(pPdo,
                                                   DevicePropertyFriendlyName,
                                                   WD_MAX_PROPERTY_SIZE,
                                                   pvPropertyBuffer,
                                                   &ulLength);

                    if (NT_SUCCESS(ntStatus))
                    {
                        RtlWriteRegistryValue(RTL_REGISTRY_ABSOLUTE,
                                              WD_KEY_WATCHDOG_DISPLAY,
                                              L"DeviceFriendlyName",
                                              REG_SZ,
                                              pvPropertyBuffer,
                                              ulLength);
                    }

                    ntStatus = IoGetDeviceProperty(pPdo,
                                                   DevicePropertyHardwareID,
                                                   WD_MAX_PROPERTY_SIZE,
                                                   pvPropertyBuffer,
                                                   &ulLength);

                    if (NT_SUCCESS(ntStatus))
                    {
                        RtlWriteRegistryValue(RTL_REGISTRY_ABSOLUTE,
                                              WD_KEY_WATCHDOG_DISPLAY,
                                              L"HardwareID",
                                              REG_MULTI_SZ,
                                              pvPropertyBuffer,
                                              ulLength);
                    }

                    ntStatus = IoGetDeviceProperty(pPdo,
                                                   DevicePropertyManufacturer,
                                                   WD_MAX_PROPERTY_SIZE,
                                                   pvPropertyBuffer,
                                                   &ulLength);

                    if (NT_SUCCESS(ntStatus))
                    {
                        RtlWriteRegistryValue(RTL_REGISTRY_ABSOLUTE,
                                              WD_KEY_WATCHDOG_DISPLAY,
                                              L"Manufacturer",
                                              REG_SZ,
                                              pvPropertyBuffer,
                                              ulLength);
                    }

                    //
                    // Release property buffer.
                    //

                    ExFreePool(pvPropertyBuffer);
                    pvPropertyBuffer = NULL;
                }
            }

            //
            // Flush registry in case we're going to break in / bugcheck or if this is first time.
            //

            if ((TRUE == s_bFirstTime) || (TRUE == bBreakIn) || (0 == s_ulDisableBugcheck))
            {
                WdpFlushRegistryKey(pWatch, WD_KEY_WATCHDOG_DISPLAY);
            }
        }

        //
        // Bugcheck machine without kernel debugger connected and with bugcheck EA enabled.
        // Bugcheck EA is enabled on SKUs below Server.
        //

        if (1 == ulDebuggerNotPresent)
        {
            if (0 == s_ulDisableBugcheck)
            {
                if (s_ulEaRecovery == FALSE)
                {
                    KeBugCheckEx(pBugCheckData->ulBugCheckCode,
                                 pBugCheckData->ulpBugCheckParameter1,
                                 pBugCheckData->ulpBugCheckParameter2,
                                 (ULONG_PTR)pUnicodeDriverName,
                                 pBugCheckData->ulpBugCheckParameter4);
                }
            }

            if (s_ulEaRecovery)
            {
                //
                // Try to recover from the EA hang.
                //

                WdpInjectExceptionIntoThread(pThread, pDpcContext);
            }
        }
        else
        {
            if (TRUE == bBreakIn)
            {
                DbgBreakPoint();

                if (s_ulEaRecovery)
                {
                    WdpInjectExceptionIntoThread(pThread, pDpcContext);
                }
            }
        }
    }
    else
    {
        if (FALSE == s_ulEaRecovery)
        {
            //
            // Recovery - knock down EventFlag in registry and update statics.
            //

            RtlDeleteRegistryValue(RTL_REGISTRY_ABSOLUTE,
                                   WD_KEY_WATCHDOG_DISPLAY,
                                   L"EventFlag");
        }

        s_bEventLogged = FALSE;
        s_ulCurrentBreakPointDelay = s_ulBreakPointDelay;
    }

    //
    // Reenable event processing in this module.
    //

    s_bFirstTime = FALSE;
    InterlockedExchange(&g_lWdpDisplayHandlerState, WD_HANDLER_IDLE);

    //
    // Dereference objects and resume watchdog event processing.
    //

    ObDereferenceObject(pFdo);
    ObDereferenceObject(pPdo);
    WdCompleteEvent(pWatch, pThread);

    return;
}   // WdpBugCheckStuckDriver()

VOID
WdpKernelApc(
    IN PKAPC pApc,
    OUT PKNORMAL_ROUTINE *pNormalRoutine,
    IN OUT PVOID pvNormalContext,
    IN OUT PVOID *ppvSystemArgument1,
    IN OUT PVOID *ppvSystemArgument2
    )

/*++

Routine Description:

    This APC runs in the context of spinning thread and is responsible
    for raising THREAD_STUCK exception.

Arguments:

    pApc - Not used.

    pNormalRoutine - Not used.

    pvNormalContext - Not used.

    ppvSystemArgument1 - Supplies a pointer to WD_GDI_CONTEXT_DATA.

    ppvSystemArgument2 - Not used.

Return Value:

    None.

--*/

{
    PKEVENT pInjectionEvent;
    CONTEXT context;
    PWD_GDI_CONTEXT_DATA pContextData;
    ULONG_PTR ulpImageStart;
    ULONG_PTR ulpImageStop;
    PETHREAD pThread;
    NTSTATUS ntStatus;
    PLDEV pldev;

    ASSERT(NULL != ppvSystemArgument1);
    UNREFERENCED_PARAMETER(pApc);
    UNREFERENCED_PARAMETER(pNormalRoutine);
    UNREFERENCED_PARAMETER(pvNormalContext);
    UNREFERENCED_PARAMETER(ppvSystemArgument2);

    pContextData = (PWD_GDI_CONTEXT_DATA)*ppvSystemArgument1;
    pInjectionEvent = pContextData->pInjectionEvent;
    pldev = *pContextData->ppldevDrivers;
    pThread = PsGetCurrentThread();

    //
    // Initialize the context.
    //

    RtlZeroMemory(&context, sizeof (context));
    context.ContextFlags = CONTEXT_CONTROL;

    //
    // Get the kernel context for this thread.
    //

    if (NT_SUCCESS(PsGetContextThread(pThread, &context, KernelMode)))
    {

        //
        // We can safely touch the pldev's (which live in session space)
        // because this thread came from a process that has the session
        // space mapped in.
        //

        while (pldev)
        {
            if (pldev->pGdiDriverInfo)
            {
                ulpImageStart = (ULONG_PTR)pldev->pGdiDriverInfo->ImageAddress;
                ulpImageStop = ulpImageStart + (ULONG_PTR)pldev->pGdiDriverInfo->ImageLength - 1;

                //
                // Modify the context to inject a fault into the thread
                // when it starts running again (after APC returns).
                //

#if defined (_X86_)

                    if ((context.Eip >= ulpImageStart) && (context.Eip <= ulpImageStop))
                    {
                        //
                        // We should decrement the stack pointer, and store the
                        // return address to "fake" a call instruction.  However,
                        // this is not allowed.  So instead, lets just put the
                        // return address in the current stack location.  This isn't
                        // quite right, but should make the stack unwind code happier
                        // then if we do nothing.
                        //

                        //context.Esp -= 4;
                        //*((PULONG)context.Esp) = context.Eip;
                        context.Eip = (ULONG)WdpRaiseExceptionInThread;

                        //
                        // Set the modified context record.
                        //

                        PsSetContextThread(pThread, &context, KernelMode);
                        pContextData->bRecoveryAttempted = TRUE;
                        break;
                    }

#elif defined (_IA64_)

                    if ((context.StIIP >= ulpImageStart) && (context.StIIP <= ulpImageStop))
                    {
                        FRAME_MARKER cfm;
                        PULONGLONG pullTemp = (PULONGLONG)WdpRaiseExceptionInThread;

                        //
                        // Set the return address.
                        //

                        context.BrRp = context.StIIP;

                        //
                        // Update the frame markers.
                        //

                        context.RsPFS = context.StIFS & 0x3fffffffffi64;
                        context.RsPFS |= (context.ApEC & (0x3fi64 << 52));
                        context.RsPFS |= (((context.StIPSR >> PSR_CPL) & 0x3) << 62);

                        cfm.u.Ulong64 = context.StIFS;
                        cfm.u.f.sof -= cfm.u.f.sol;
                        cfm.u.f.sol = 0;
                        cfm.u.f.sor = 0;
                        cfm.u.f.rrbgr = 0;
                        cfm.u.f.rrbfr = 0;
                        cfm.u.f.rrbpr = 0;

                        context.StIFS = cfm.u.Ulong64;
                        context.StIFS |= 0x8000000000000000;

                        //
                        // Emulate the call.
                        //

                        context.StIIP = *pullTemp;
                        context.IntGp = *(pullTemp+1);
                        context.StIPSR &= ~((ULONGLONG) 3 << PSR_RI);

                        //
                        // Set the modified context record.
                        //

                        PsSetContextThread(pThread, &context, KernelMode);
                        pContextData->bRecoveryAttempted = TRUE;
                        break;
                    }

#endif

            }

            pldev = pldev->pldevNext;
        }

        //
        // Single our event so the caller knows we did something.
        //

        KeSetEvent(pInjectionEvent, 0, FALSE);
    }
}   // WdpKernelApc()

VOID
WdpInjectExceptionIntoThread(
    PKTHREAD pThread,
    PWD_GDI_DPC_CONTEXT pDpcContext
    )

/*++

Routine Description:

    This routine schedules APC to run in the spinning thread's context.

Arguments:

    pThread - Supplies a pointer to the spinning thread.

    ppvSystemArgument1 - Supplies a pointer to WD_GDI_DPC_CONTEXT.

Return Value:

    None.

--*/

{
    KAPC apc;
    KEVENT injectionEvent;
    WD_GDI_CONTEXT_DATA contextData;

    ASSERT(NULL != pThread);
    ASSERT(NULL != pDpcContext);

    KeInitializeEvent(&injectionEvent, NotificationEvent, FALSE);

    KeInitializeApc(&apc,
                    pThread,
                    OriginalApcEnvironment,
                    WdpKernelApc,
                    NULL,
                    NULL,
                    KernelMode,
                    NULL);

    contextData.pThread = pThread;
    contextData.pInjectionEvent = &injectionEvent;
    contextData.ppldevDrivers = pDpcContext->ppldevDrivers;
    contextData.bRecoveryAttempted = FALSE;

    if (KeInsertQueueApc(&apc, &contextData, NULL, 0))
    {
        KeWaitForSingleObject(&injectionEvent,
                              Executive,
                              KernelMode,
                              FALSE,
                              NULL);

        //
        // If we attempted a recovery, raise a hard error dialog, to
        // notify the user of the situation.
        //

        if (contextData.bRecoveryAttempted)
        {
            ULONG Response;
            PUNICODE_STRING DriverName = &pDpcContext->DisplayDriverName;

            ExRaiseHardError(STATUS_HUNG_DISPLAY_DRIVER_THREAD,
                             1,
                             1,
                             (PULONG_PTR)&DriverName,
                             OptionOk,
                             &Response);
        }

        //
        // BUGBUG: Is this required?
        //

        KeClearEvent(&injectionEvent);
    }
}   // WdpInjectExceptionIntoThread()

VOID
WdpRaiseExceptionInThread()

/*++

Routine Description:

    This routine raises THREAD_STUCK exception in the spinning thread's context.

Arguments:

    None.

Return Value:

    None.

--*/

{
    ExRaiseStatus(WD_SE_THREAD_STUCK);
}   // WdpRaiseExceptionInThread()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\videosim\videosim.c ===
/*++

Copyright (c) 1992-1998  Microsoft Corporation

Module Name:

    videosim.c

Abstract:

    Minport to simulate a frame buffer miniport driver.
    video driver.

Environment:

    Kernel mode

Revision History:

--*/

#define _NTDRIVER_

#ifndef FAR
#define FAR
#endif

#include "dderror.h"
#include "ntosp.h"
#include "stdarg.h"
#include "stdio.h"
#include "zwapi.h"

#include "ntddvdeo.h"
#include "video.h"
#include "videosim.h"

//
// Function Prototypes
//
// Functions that start with 'Sim' are entry points for the OS port driver.
//

ULONG
DriverEntry(
    PVOID Context1,
    PVOID Context2
    );

VP_STATUS
SimFindAdapter(
    PVOID HwDeviceExtension,
    PVOID HwContext,
    PWSTR ArgumentString,
    PVIDEO_PORT_CONFIG_INFO ConfigInfo,
    PUCHAR Again
    );

BOOLEAN
SimInitialize(
    PVOID HwDeviceExtension
    );

BOOLEAN
SimStartIO(
    PVOID HwDeviceExtension,
    PVIDEO_REQUEST_PACKET RequestPacket
    );


#if defined(ALLOC_PRAGMA)
#pragma alloc_text(PAGE,DriverEntry)
#pragma alloc_text(PAGE,SimFindAdapter)
#pragma alloc_text(PAGE,SimInitialize)
#pragma alloc_text(PAGE,SimStartIO)
#endif


ULONG
DriverEntry (
    PVOID Context1,
    PVOID Context2
    )

/*++

Routine Description:

    Installable driver initialization entry point.
    This entry point is called directly by the I/O system.

Arguments:

    Context1 - First context value passed by the operating system. This is
        the value with which the miniport driver calls VideoPortInitialize().

    Context2 - Second context value passed by the operating system. This is
        the value with which the miniport driver calls VideoPortInitialize().

Return Value:

    Status from VideoPortInitialize()

--*/

{

    VIDEO_HW_INITIALIZATION_DATA hwInitData;
    ULONG status;
    ULONG initializationStatus;

    //
    // Zero out structure.
    //

    VideoPortZeroMemory(&hwInitData, sizeof(VIDEO_HW_INITIALIZATION_DATA));

    //
    // Specify sizes of structure and extension.
    //

    hwInitData.HwInitDataSize = sizeof(VIDEO_HW_INITIALIZATION_DATA);

    //
    // Set entry points.
    //

    hwInitData.HwFindAdapter = SimFindAdapter;
    hwInitData.HwInitialize = SimInitialize;
    hwInitData.HwInterrupt = NULL;
    hwInitData.HwStartIO = SimStartIO;

    //
    // Determine the size we require for the device extension.
    //

    hwInitData.HwDeviceExtensionSize = sizeof(HW_DEVICE_EXTENSION);

    //
    // Always start with parameters for device0 in this case.
    //

//    hwInitData.StartingDeviceNumber = 0;

    //
    // Once all the relevant information has been stored, call the video
    // port driver to do the initialization.
    // For this device we will repeat this call three times, for ISA, EISA
    // and MCA.
    // We will return the minimum of all return values.
    //

    hwInitData.AdapterInterfaceType = PCIBus;

    return (VideoPortInitialize(Context1,
                                Context2,
                                &hwInitData,
                                NULL));

} // end DriverEntry()

VP_STATUS
SimFindAdapter(
    PVOID HwDeviceExtension,
    PVOID HwContext,
    PWSTR ArgumentString,
    PVIDEO_PORT_CONFIG_INFO ConfigInfo,
    PUCHAR Again
    )

/*++

Routine Description:

    This routine is called to determine if the adapter for this driver
    is present in the system.
    If it is present, the function fills out some information describing
    the adapter.

Arguments:

    HwDeviceExtension - Supplies the miniport driver's adapter storage. This
        storage is initialized to zero before this call.

    HwContext - Supplies the context value which was passed to
        VideoPortInitialize().

    ArgumentString - Suuplies a NULL terminated ASCII string. This string
        originates from the user.

    ConfigInfo - Returns the configuration information structure which is
        filled by the miniport driver. This structure is initialized with
        any knwon configuration information (such as SystemIoBusNumber) by
        the port driver. Where possible, drivers should have one set of
        defaults which do not require any supplied configuration information.

    Again - Indicates if the miniport driver wants the port driver to call
        its VIDEO_HW_FIND_ADAPTER function again with a new device extension
        and the same config info. This is used by the miniport drivers which
        can search for several adapters on a bus.

Return Value:

    This routine must return:

    NO_ERROR - Indicates a host adapter was found and the
        configuration information was successfully determined.

    ERROR_INVALID_PARAMETER - Indicates an adapter was found but there was an
        error obtaining the configuration information. If possible an error
        should be logged.

    ERROR_DEV_NOT_EXIST - Indicates no host adapter was found for the
        supplied configuration information.

--*/

{

    PHW_DEVICE_EXTENSION hwDeviceExtension = HwDeviceExtension;
    NTSTATUS Status;
    HANDLE SectionHandle;
    ACCESS_MASK SectionAccess;
    ULONGLONG SectionSize = 0x100000;

    //
    // Make sure the size of the structure is at least as large as what we
    // are expecting (check version of the config info structure).
    //

    if (ConfigInfo->Length < sizeof(VIDEO_PORT_CONFIG_INFO)) {

        return ERROR_INVALID_PARAMETER;

    }

    //
    // Only create a device once.
    //

    if (bLoaded++)
    {
        return ERROR_DEV_NOT_EXIST;
    }

#if 0
    //
    // Create the frame buffer
    //

    SectionAccess = SECTION_ALL_ACCESS;

    Status = ZwCreateSection(&SectionHandle,
                             SectionAccess,
                             (POBJECT_ATTRIBUTES) NULL,
                             (PLARGE_INTEGER) &SectionSize,
                             PAGE_READWRITE,
                             SEC_COMMIT,
                             NULL);

    if (!NT_SUCCESS(Status))
    {
         return ERROR_DEV_NOT_EXIST;
    }

    //
    // Now reference the section handle.
    //

    Status = ObReferenceObjectByHandle(SectionHandle,
                                       SECTION_ALL_ACCESS,
                                       NULL,
                                       KernelMode,
                                       &(hwDeviceExtension->SectionPointer),
                                       (POBJECT_HANDLE_INFORMATION) NULL );


    ZwClose(SectionHandle);

    if (!NT_SUCCESS(Status))
    {
         return ERROR_DEV_NOT_EXIST;
    }
#endif

    //
    // Clear out the Emulator entries and the state size since this driver
    // does not support them.
    //

    ConfigInfo->NumEmulatorAccessEntries = 0;
    ConfigInfo->EmulatorAccessEntries = NULL;
    ConfigInfo->EmulatorAccessEntriesContext = 0;

    ConfigInfo->HardwareStateSize = 0;

    ConfigInfo->VdmPhysicalVideoMemoryAddress.LowPart = 0x00000000;
    ConfigInfo->VdmPhysicalVideoMemoryAddress.HighPart = 0x00000000;
    ConfigInfo->VdmPhysicalVideoMemoryLength = 0x00000000;

    //
    // Initialize the current mode number.
    //

    hwDeviceExtension->CurrentModeNumber = 0;

    //
    // Indicate we do not wish to be called over
    //

    *Again = 0;

    //
    // Indicate a successful completion status.
    //

    return NO_ERROR;

} // end SimFindAdapter()


BOOLEAN
SimInitialize(
    PVOID HwDeviceExtension
    )

/*++

Routine Description:

    This routine does one time initialization of the device.

Arguments:

    HwDeviceExtension - Supplies a pointer to the miniport's device extension.

Return Value:


    Always returns TRUE since this routine can never fail.

--*/

{
    ULONG i;

    //
    // Walk through the list of modes and mark the indexes properly
    //

    for (i = 0; i < SimNumModes; i++) {

        SimModes[i].ModeIndex = i;

    }

    return TRUE;

} // end SimInitialize()


BOOLEAN
SimStartIO(
    PVOID HwDeviceExtension,
    PVIDEO_REQUEST_PACKET RequestPacket
    )

/*++

Routine Description:

    This routine is the main execution routine for the miniport driver. It
    acceptss a Video Request Packet, performs the request, and then returns
    with the appropriate status.

Arguments:

    HwDeviceExtension - Supplies a pointer to the miniport's device extension.

    RequestPacket - Pointer to the video request packet. This structure
    contains all the parameters passed to the VideoIoControl function.

Return Value:


--*/

{
    PHW_DEVICE_EXTENSION hwDeviceExtension = HwDeviceExtension;
    VP_STATUS status;
    PVIDEO_MODE_INFORMATION modeInformation;
    PVIDEO_MEMORY_INFORMATION memoryInformation;
    PVIDEO_SHARE_MEMORY pShareMemory;
    PVIDEO_SHARE_MEMORY_INFORMATION pShareMemoryInformation;
    ULONG ulTemp;
    NTSTATUS ntStatus;
    ULONG ViewSize;
    PVOID ViewBase;
    LARGE_INTEGER ViewOffset;
    HANDLE sectionHandle;

    //
    // Switch on the IoContolCode in the RequestPacket. It indicates which
    // function must be performed by the driver.
    //

    switch (RequestPacket->IoControlCode) {


    case IOCTL_VIDEO_MAP_VIDEO_MEMORY:

        VideoDebugPrint((2, "SimStartIO - MapVideoMemory\n"));

        if ( (RequestPacket->OutputBufferLength <
                                     sizeof(VIDEO_MEMORY_INFORMATION)) ||
             (RequestPacket->InputBufferLength < sizeof(VIDEO_MEMORY)) ) {

            RequestPacket->StatusBlock->Information = 0;
            status = ERROR_INSUFFICIENT_BUFFER;
            break;
        }

        if (hwDeviceExtension->VideoRamBase == 0)
        {
            //
            // Allocate this once, and hang on to forever after, reusing it
            // through successive launches of NetMeeting.
            //
            hwDeviceExtension->VideoRamBase = ExAllocatePoolWithTag(
                NonPagedPool, ONE_MEG, 'ddmN');
        }

        if (hwDeviceExtension->VideoRamBase == 0)
        {
             status = ERROR_INVALID_PARAMETER;
             break;
        }

        RequestPacket->StatusBlock->Information =
                                     sizeof(VIDEO_MEMORY_INFORMATION);

        memoryInformation = RequestPacket->OutputBuffer;

#if 0
        status = ERROR_INVALID_PARAMETER;

        ViewSize = 0x100000;
        ViewBase = NULL;
        ViewOffset.QuadPart = 0;

        if (NT_SUCCESS(ObOpenObjectByPointer(hwDeviceExtension->SectionPointer,
                                             0L,
                                             (PACCESS_STATE) NULL,
                                             SECTION_ALL_ACCESS,
                                             (POBJECT_TYPE) NULL,
                                             KernelMode,
                                             &sectionHandle)))
        {
            if (NT_SUCCESS(ZwMapViewOfSection(sectionHandle,
                                              NtCurrentProcess(),
                                              &ViewBase,
                                              0,
                                              ViewSize,
                                              &ViewOffset,
                                              &ViewSize,
                                              ViewUnmap,
                                              0,
                                              PAGE_READWRITE)))
            {
            }

            ZwClose(sectionHandle);
        }
#endif

        memoryInformation->VideoRamBase =
        memoryInformation->FrameBufferBase = hwDeviceExtension->VideoRamBase;

        memoryInformation->VideoRamLength =
       