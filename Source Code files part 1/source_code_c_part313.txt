VICE_EXTENSION		pCard = pFDO->DeviceExtension;
	PDEVICE_OBJECT				pLowerDevObj = pCard->LowerDeviceObject;
	NTSTATUS					status;
	PDEVICE_CAPABILITIES		pDevCaps = NULL;
	PIO_STACK_LOCATION			pIrpStack = IoGetCurrentIrpStackLocation(pIrp);
	PDEVICE_RELATIONS			pRelations = NULL;
	ULONG						length = 0;
	ULONG						i = 0;

	PAGED_CODE();	// Macro in checked build to assert if pagable code is run at or above dispatch IRQL 


	switch(pIrpStack->MinorFunction)
	{	

/*****************************************************************************
***************************   IRP_MN_START_DEVICE   **************************
*****************************************************************************/
	
	case	IRP_MN_START_DEVICE:
			SpxDbgMsg(SPX_TRACE_PNP_IRPS,("%s: Got IRP_MN_START_DEVICE Irp for Card %d.\n",
				PRODUCT_NAME,pCard->CardNumber));

/* Call driver below first... */

			status = Spx_CallDriverBelow(pLowerDevObj,pIrp);

/* If successful, then start the card... */

			if(NT_SUCCESS(status))		// Must use NT_SUCCESS() here!!
				status = Spx_Card_StartDevice(pFDO,pIrp);	/* Start the card */

			pIrp->IoStatus.Status = status;
			pIrp->IoStatus.Information = 0;
			IoCompleteRequest(pIrp,IO_NO_INCREMENT);
			break;

/*****************************************************************************
**********************   IRP_MN_QUERY_DEVICE_RELATIONS   *********************
*****************************************************************************/

	case	IRP_MN_QUERY_DEVICE_RELATIONS:
			SpxDbgMsg(SPX_TRACE_PNP_IRPS,("%s: Got IRP_MN_QUERY_DEVICE_RELATIONS Irp for Card %d.\n",
				PRODUCT_NAME,pCard->CardNumber));
			
			if(pIrpStack->Parameters.QueryDeviceRelations.Type != BusRelations)	/* Only handle BusRelations */
			{
				SpxDbgMsg(SPX_TRACE_PNP_IRPS,("%s: IRP_MN_QUERY_DEVICE_RELATIONS for Card - Non bus.\n",PRODUCT_NAME));
				IoSkipCurrentIrpStackLocation(pIrp);
				status = IoCallDriver(pLowerDevObj,pIrp);
				break;
			}

/* Enumerate devices on the card... */

			Spx_EnumPorts(pFDO);								/* Enumerate and create port device objects */

/* Tell the Plug and Play Manager any found ports... */

			i = 0;
			if(pIrp->IoStatus.Information)						/* Get current device object count */
				i = ((PDEVICE_RELATIONS)pIrp->IoStatus.Information)->Count;

			length = sizeof(DEVICE_RELATIONS)+((pCard->NumPDOs+i)*sizeof(PDEVICE_OBJECT));
			if(pRelations = SpxAllocateMem(NonPagedPool, length))/* Allocate new structure */
			{

/* Copy in the device objects so far... */

				if(i)
					RtlCopyMemory
					(
						pRelations->Objects,
						((PDEVICE_RELATIONS)pIrp->IoStatus.Information)->Objects,
						i * sizeof (PDEVICE_OBJECT)
					);

				pRelations->Count = i;								/* Update device count */

/* Add specialix ports to the device relations... */

				if(pCard->NumPDOs)
				{
					for(i=0; i<PRODUCT_MAX_PORTS; i++)
					{
						if(pCard->AttachedPDO[i])					/* If object exists */
						{											/* add to table */
							pRelations->Objects[pRelations->Count++] = pCard->AttachedPDO[i];
							ObReferenceObject(pCard->AttachedPDO[i]);
						}
					}
				}

				if(pIrp->IoStatus.Information != 0)					/* If previous structure */
					SpxFreeMem((PVOID)pIrp->IoStatus.Information);	/* then free */

				pIrp->IoStatus.Information = (ULONG_PTR)pRelations;	/* Set new structure */

			}
			else
			{
				CHAR szErrorMsg[MAX_ERROR_LOG_INSERT];	// Limited to 51 characters + 1 null 

				sprintf(szErrorMsg, "Card at %08X%08X: Insufficient resources.", pCard->PhysAddr.HighPart, pCard->PhysAddr.LowPart);
				
				Spx_LogMessage(	STATUS_SEVERITY_ERROR,
								pCard->DriverObject,			// Driver Object
								pCard->DeviceObject,			// Device Object (Optional)
								PhysicalZero,					// Physical Address 1
								PhysicalZero,					// Physical Address 2
								0,								// SequenceNumber
								pIrpStack->MajorFunction,		// Major Function Code
								0,								// RetryCount
								FILE_ID | __LINE__,				// UniqueErrorValue
								STATUS_SUCCESS,					// FinalStatus
								szErrorMsg);					// Error Message
			}

			pIrp->IoStatus.Status = STATUS_SUCCESS;
			IoSkipCurrentIrpStackLocation(pIrp);				/* Copy parameters to next stack */
			status = IoCallDriver(pLowerDevObj,pIrp);			/* Call driver below */
			break;

/*****************************************************************************
**********************   IRP_MN_QUERY_PNP_DEVICE_STATE   *********************
*****************************************************************************/

	case	IRP_MN_QUERY_PNP_DEVICE_STATE:
			SpxDbgMsg(SPX_TRACE_PNP_IRPS,("%s: Got IRP_MN_QUERY_PNP_DEVICE_STATE Irp for Card %d.\n",
				PRODUCT_NAME,pCard->CardNumber));
			IoSkipCurrentIrpStackLocation(pIrp);
			status = IoCallDriver(pLowerDevObj,pIrp);
			break;

/*****************************************************************************
************************   IRP_MN_QUERY_CAPABILITIES   ***********************
*****************************************************************************/

	case	IRP_MN_QUERY_CAPABILITIES:
			SpxDbgMsg(SPX_TRACE_PNP_IRPS,("%s: Got IRP_MN_QUERY_CAPABILITIES Irp for Card %d.\n",
				PRODUCT_NAME,pCard->CardNumber));
			IoSkipCurrentIrpStackLocation(pIrp);
			status = IoCallDriver(pLowerDevObj,pIrp);
			break;

/*****************************************************************************
************************   IRP_MN_QUERY_STOP_DEVICE   ************************
*****************************************************************************/

	case	IRP_MN_QUERY_STOP_DEVICE:
			SpxDbgMsg(SPX_TRACE_PNP_IRPS,("%s: Got IRP_MN_QUERY_STOP_DEVICE Irp for Card %d.\n",
				PRODUCT_NAME,pCard->CardNumber));

			status = STATUS_SUCCESS;
			SetPnpPowerFlags(pCard,PPF_STOP_PENDING);	// We must now expect a STOP IRP

			if(SPX_SUCCESS(status))						// If we can stop, pass IRP on down
			{
				pIrp->IoStatus.Status = status;
				IoSkipCurrentIrpStackLocation(pIrp);
				status = IoCallDriver(pLowerDevObj,pIrp);
			}
			else										// If we can't then complete
			{
				pIrp->IoStatus.Status = status;
				IoCompleteRequest(pIrp, IO_NO_INCREMENT);
			}
			break;

/*****************************************************************************
************************   IRP_MN_CANCEL_STOP_DEVICE   ***********************
*****************************************************************************/

	case	IRP_MN_CANCEL_STOP_DEVICE:
			SpxDbgMsg(SPX_TRACE_PNP_IRPS,("%s: Got IRP_MN_CANCEL_STOP_DEVICE Irp for Card %d.\n",
				PRODUCT_NAME,pCard->CardNumber));

/* Call driver below first... */

			status = Spx_CallDriverBelow(pLowerDevObj,pIrp);

			if(NT_SUCCESS(status))
			{
				// we return the device to its working state here.
				ClearPnpPowerFlags(pCard,PPF_STOP_PENDING);	// We are no longer expecting a STOP IRP.
				status = STATUS_SUCCESS;
			}

			pIrp->IoStatus.Status = status;
			IoCompleteRequest(pIrp, IO_NO_INCREMENT);
			break;

/*****************************************************************************
****************************   IRP_MN_STOP_DEVICE   **************************
*****************************************************************************/

	case	IRP_MN_STOP_DEVICE: 
			SpxDbgMsg(SPX_TRACE_PNP_IRPS, ("%s: Got IRP_MN_STOP_DEVICE Irp for Card %d.\n", 
				PRODUCT_NAME, pCard->CardNumber));

			Spx_Card_StopDevice(pCard);				/* Stop the card hardware */

			pIrp->IoStatus.Status = STATUS_SUCCESS;	/* Cannot fail this request */
			IoSkipCurrentIrpStackLocation(pIrp);		
			status = IoCallDriver(pLowerDevObj,pIrp);
			break;

/*****************************************************************************
************************   IRP_MN_QUERY_REMOVE_DEVICE   **********************
*****************************************************************************/
				
	case	IRP_MN_QUERY_REMOVE_DEVICE:
			SpxDbgMsg(SPX_TRACE_PNP_IRPS, ("%s: Got IRP_MN_QUERY_REMOVE_DEVICE Irp for Card %d.\n", 
				PRODUCT_NAME, pCard->CardNumber));

			status = STATUS_SUCCESS;

			if(SPX_SUCCESS(status))					// If we can stop, pass IRP on down
			{
				SetPnpPowerFlags(pCard,PPF_REMOVE_PENDING);	// We are now ready to remove the card
				pIrp->IoStatus.Status	= status;
				IoSkipCurrentIrpStackLocation(pIrp);
				status = IoCallDriver(pLowerDevObj,pIrp);
			}
			else									// If we can't then complete
			{
				pIrp->IoStatus.Status = status;
				IoCompleteRequest(pIrp, IO_NO_INCREMENT);
			}

			break;

/*****************************************************************************
***********************   IRP_MN_CANCEL_REMOVE_DEVICE   **********************
*****************************************************************************/

	case	IRP_MN_CANCEL_REMOVE_DEVICE:
			SpxDbgMsg(SPX_TRACE_PNP_IRPS, ("%s: Got IRP_MN_CANCEL_REMOVE_DEVICE Irp for Card %d.\n", 
				PRODUCT_NAME, pCard->CardNumber));

/* Call driver below first... */

			status = Spx_CallDriverBelow(pLowerDevObj,pIrp);

			if(NT_SUCCESS(status))
			{
				ClearPnpPowerFlags(pCard,PPF_REMOVE_PENDING);	// We are no longer expecting to remove the device.
			}

			pIrp->IoStatus.Status = status;
			IoCompleteRequest(pIrp,IO_NO_INCREMENT);
			break;

/*****************************************************************************
*************************   IRP_MN_SURPRISE_REMOVAL   ************************
*****************************************************************************/

	case	IRP_MN_SURPRISE_REMOVAL:
			SpxDbgMsg(SPX_TRACE_PNP_IRPS, ("%s: Got IRP_MN_SURPRISE_REMOVAL Irp for Card %d.\n", 
				PRODUCT_NAME, pCard->CardNumber));

			status = Spx_Card_StopDevice(pCard);	// Lets stop the port ready for the REMOVE IRP if we are not already.

			SetPnpPowerFlags(pCard,PPF_REMOVE_PENDING);	// We are now ready to remove the card
			pIrp->IoStatus.Status = status;
			IoSkipCurrentIrpStackLocation(pIrp);
			status = IoCallDriver(pLowerDevObj,pIrp);
			break;

/*****************************************************************************
**************************   IRP_MN_REMOVE_DEVICE   **************************
*****************************************************************************/

	case IRP_MN_REMOVE_DEVICE: 
			SpxDbgMsg(SPX_TRACE_PNP_IRPS, ("%s: Got IRP_MN_REMOVE_DEVICE Irp for Card %d.\n", 
				PRODUCT_NAME, pCard->CardNumber));

			status = Spx_Card_RemoveDevice(pFDO);

			pIrp->IoStatus.Status = status;
			IoSkipCurrentIrpStackLocation(pIrp);
			status = IoCallDriver(pLowerDevObj,pIrp);
			break;

	default:
			SpxDbgMsg(SPX_TRACE_PNP_IRPS,("%s: Got PnP Irp - MinorFunction=0x%02X for Card %d.\n",
				PRODUCT_NAME,pIrpStack->MinorFunction,pCard->CardNumber));
			
			IoSkipCurrentIrpStackLocation(pIrp);
			status = IoCallDriver(pLowerDevObj,pIrp);
			break;

	}

	return(status);

} /* Spx_Card_FDO_DispatchPnp */

/*****************************************************************************
**************************                         ***************************
**************************   Spx_CallDriverBelow   ***************************
**************************                         ***************************
******************************************************************************

prototype:		NTSTATUS Spx_CallDriverBelow(IN PDEVICE_OBJECT pLowerDevObj,IN PIRP pIrp)

description:	Pass the IRP to the driver below this first and wait for it to complete.

parameters:		pLowerDevObj points to a device object for the device below
				pIrp points to the Plug and Play I/O Request (IRP) to be processed

returns:		NT Status Code

*/

NTSTATUS Spx_CallDriverBelow(IN PDEVICE_OBJECT pLowerDevObj,IN PIRP pIrp)
{
	KEVENT		eventWaitLowerDrivers;
	NTSTATUS	status;

	PAGED_CODE();	// Macro in checked build to assert if pagable code is run at or above dispatch IRQL 

	IoCopyCurrentIrpStackLocationToNext(pIrp);								/* Copy parameters to the stack below */
	KeInitializeEvent(&eventWaitLowerDrivers,SynchronizationEvent,FALSE);	/* Initialise event if need to wait */
	IoSetCompletionRoutine(pIrp,Spx_DispatchPnpPowerComplete,&eventWaitLowerDrivers,TRUE,TRUE,TRUE);

	if((status = IoCallDriver(pLowerDevObj,pIrp)) == STATUS_PENDING)
	{
		KeWaitForSingleObject(&eventWaitLowerDrivers,Executive,KernelMode,FALSE,NULL);
		status = pIrp->IoStatus.Status;
	}

	return(status);

} /* Spx_CallDriverBelow */

/************************************************************************************
************************									*************************
************************   Spx_DispatchPnpPowerComplete		*************************
************************									*************************
*************************************************************************************

prototype:		NTSTATUS Spx_DispatchPnpPowerComplete(IN PDEVICE_OBJECT pDevObject,IN PIRP pIrp,IN PVOID Context)

description:	The PnP IRP was completed by the lower-level drivers.
				Signal this to whoever registered us.

parameters:		pDevObject point to the device completing the IRP
				pIrp points to the Plug and Play I/O Request (IRP) to be completed
				Context was set when the lower driver was called (actually event)

returns:		NT Status Code

*/

NTSTATUS Spx_DispatchPnpPowerComplete(IN PDEVICE_OBJECT pDevObject,IN PIRP pIrp,IN PVOID Context)
{

	PIO_STACK_LOCATION	stack = NULL;
	PKEVENT				event = (PKEVENT) Context;
	NTSTATUS			status;

	
	UNREFERENCED_PARAMETER(pDevObject);

	SpxDbgMsg(SPX_TRACE_CALLS,("%s: Entering DispatchPnpComplete.\n",PRODUCT_NAME));

	status = STATUS_SUCCESS;
	stack = IoGetCurrentIrpStackLocation(pIrp);

    switch(stack->MajorFunction) 
	{
		case IRP_MJ_PNP:

			switch(stack->MinorFunction) 
			{
				case IRP_MN_START_DEVICE:		// Codes which need processing after lower drivers 
				case IRP_MN_QUERY_CAPABILITIES:
				case IRP_MN_CANCEL_STOP_DEVICE:
				case IRP_MN_CANCEL_REMOVE_DEVICE:
					KeSetEvent(event,0,FALSE);		// Wake up waiting process //
					return(STATUS_MORE_PROCESSING_REQUIRED);

				default:
					break;
			}
			break;

		case IRP_MJ_POWER:
				KeSetEvent(event, 0, FALSE);		// Wake up waiting process 
				return(STATUS_MORE_PROCESSING_REQUIRED);

		default:
			break;

	}

    return(status);

} /* Spx_DispatchPnpPowerComplete */

/*****************************************************************************
**************************                          **************************
**************************   Spx_Card_StartDevice   **************************
**************************                          **************************
******************************************************************************

prototype:		NTSTATUS Spx_Card_StartDevice(IN PDEVICE_OBJECT pDevObject,IN PIRP pIrp)

description:	Start the card device:
					Process resources (interrupt, I/O, memory)
					Initialise and start the hardware

parameters:		pDevObject point to the card device to start
				pIrp points to the start I/O Request (IRP)

returns:		NT Status Code

*/

NTSTATUS Spx_Card_StartDevice(IN PDEVICE_OBJECT pDevObject,IN PIRP pIrp)
{
	PCARD_DEVICE_EXTENSION	pCard = pDevObject->DeviceExtension;
	PIO_STACK_LOCATION		pIrpStack = IoGetCurrentIrpStackLocation(pIrp);

	NTSTATUS status = STATUS_SUCCESS;

	PAGED_CODE();	// Macro in checked build to assert if pagable code is run at or above dispatch IRQL 

	SpxDbgMsg(SPX_TRACE_CALLS,("%s: Entering Spx_Card_StartDevice for Card %d.\n",PRODUCT_NAME,pCard->CardNumber));

/* Translate the card resources... */

	status = XXX_CardGetResources(	pDevObject,
									pIrpStack->Parameters.StartDevice.AllocatedResources,
									pIrpStack->Parameters.StartDevice.AllocatedResourcesTranslated);
	
	if(!SPX_SUCCESS(status))
		return(status);


/* Start the hardware... */

	if(!SPX_SUCCESS(status = XXX_CardStart(pCard)))
		return(status);

	SetPnpPowerFlags(pCard,PPF_STARTED);	/* Card has been started */

	return(status);

} /* Spx_Card_StartDevice */

/*****************************************************************************
*****************************                   ******************************
*****************************   Spx_EnumPorts   ******************************
*****************************                   ******************************
******************************************************************************

prototype:		NTSTATUS Spx_EnumPorts(IN PDEVICE_OBJECT pDevObject)

description:	Enumerate port devices found on the card device:

parameters:		pDevObject point to the card device to enumerate

returns:		NT Status Code

*/

NTSTATUS Spx_EnumPorts(IN PDEVICE_OBJECT pDevObject)
{
	PCARD_DEVICE_EXTENSION	pCard = pDevObject->DeviceExtension;
	PPORT_DEVICE_EXTENSION	pPort = NULL;

	NTSTATUS				status = STATUS_SUCCESS;
	PDEVICE_OBJECT			PortPDO = NULL;

	UNICODE_STRING			PortPDOName;
	static ULONG			CurrentInstance = 0;

	UNICODE_STRING			InstanceStr;
	WCHAR					InstanceNumberBuffer[10];
	POWER_STATE				PowerState;
	USHORT					PortNumber	= 0;

	PAGED_CODE();	// Macro in checked build to assert if pagable code is run at or above dispatch IRQL 

	SpxDbgMsg(SPX_TRACE_CALLS,("%s: Entering Spx_EnumPorts for Card %d.\n",PRODUCT_NAME,pCard->CardNumber));

// Name and create device objects for each port on the card... 
	
	for(PortNumber=0;PortNumber<pCard->NumberOfPorts;PortNumber++)
	{

		if(pCard->AttachedPDO[PortNumber] == NULL)			// Only create if not already present 
		{

// Create the base port name ("XxPort")... 
		
			RtlZeroMemory(&PortPDOName, sizeof(UNICODE_STRING));
			PortPDOName.MaximumLength = DEVICE_OBJECT_NAME_LENGTH * sizeof(WCHAR);
			PortPDOName.Buffer = SpxAllocateMem(PagedPool, PortPDOName.MaximumLength+sizeof(WCHAR));
			if(PortPDOName.Buffer == NULL) continue;
			RtlZeroMemory(PortPDOName.Buffer, PortPDOName.MaximumLength+sizeof(WCHAR));
			RtlAppendUnicodeToString(&PortPDOName, PORT_PDO_NAME_BASE);

// Create the instance ("0")... 

			RtlInitUnicodeString(&InstanceStr,NULL);
			InstanceStr.MaximumLength = sizeof(InstanceNumberBuffer);
			InstanceStr.Buffer = InstanceNumberBuffer;
			RtlIntegerToUnicodeString(CurrentInstance++, 10, &InstanceStr);

// Append instance to the device name ("XxPort0")... 

			RtlAppendUnicodeStringToString(&PortPDOName, &InstanceStr);

// Create the port device object with this name... 

			status = IoCreateDevice(pDevObject->DriverObject, 
									sizeof(PORT_DEVICE_EXTENSION),
									&PortPDOName,  				// Object Name 
									FILE_DEVICE_SERIAL_PORT, 
									FILE_DEVICE_SECURE_OPEN, 
									TRUE, 
									&PortPDO);

 			if(!SPX_SUCCESS(status))
			{
				SpxDbgMsg(SPX_ERRORS,("%s: Create Device failed = %wZ\n",PRODUCT_NAME,&PortPDOName));
				SpxFreeMem(PortPDOName.Buffer);
				continue;
			}

			ASSERT(PortPDO != NULL);

// Increment the pdo's stacksize so that it can pass irps through... 

			PortPDO->StackSize += pDevObject->StackSize;

// Keep a pointer to the device in the card structure... 

			pCard->NumPDOs++;
			pCard->AttachedPDO[PortNumber] = PortPDO;
			ObReferenceObject(PortPDO);

// Initialise port device object and extension... 

			pPort = PortPDO->DeviceExtension;
			RtlZeroMemory(pPort,sizeof(PORT_DEVICE_EXTENSION));		// Clear the device extension 

			pPort->DeviceName = PortPDOName;

			KeInitializeSpinLock(&pPort->PnpPowerFlagsLock);		// Initialise the PNP flags lock 
			ClearPnpPowerFlags(pPort,PPF_STARTED);					// Not started yet 
			ClearPnpPowerFlags(pPort,PPF_STOP_PENDING);				// Not pending a stop 
			ClearPnpPowerFlags(pPort,PPF_REMOVE_PENDING);			// Not pending a remove 
			ClearPnpPowerFlags(pPort,PPF_REMOVED);					// Not removed 
			SetPnpPowerFlags(pPort,PPF_POWERED);					// Initially powered up 

			InitializeListHead(&pPort->StalledIrpQueue);			// Initialise the stalled IRP list 
			KeInitializeSpinLock(&pPort->StalledIrpLock);			// Initialise the StalledIrpLock flags lock 
			pPort->UnstallingFlag = FALSE;							// Initialise UnstallingIrps Flag.

			pPort->IsFDO = FALSE;
			pPort->PortNumber = PortNumber;							// system port number 
			pPort->UniqueInstanceID = FALSE;						// Instance ID not unique by default.
			pPort->DeviceIsOpen = FALSE;							// Port is closed to start with 
			pPort->DeviceObject = PortPDO;							// Backpointer to device object 
			pPort->DeviceState = PowerDeviceD0;						// Port device in full power state 
			pPort->SystemState = PowerSystemWorking;				// System in full power State 
			pPort->pParentCardExt = pCard;							// Point to the parent card extension 
			ExInitializeFastMutex(&pPort->OpenMutex);

			if(!SPX_SUCCESS(status = XXX_PortInit(pPort)))			// Initialise hardware 
				continue;

			// Inform Power Manager the of the new power state.
			PowerState.DeviceState = pPort->DeviceState;
			PoSetPowerState(pPort->DeviceObject, DevicePowerState, PowerState);

			PortPDO->Flags &= ~DO_DEVICE_INITIALIZING;				// Finished Initialising 
			PortPDO->Flags |= DO_BUFFERED_IO;						// Do Buffered IO 
			PortPDO->Flags |= DO_BUS_ENUMERATED_DEVICE;				// Bus enumerated 
			PortPDO->Flags |= DO_POWER_PAGABLE;						// Get power IRPs at IRQL PASSIVE_LEVEL 

		}
		else
		{
			PortPDO = pCard->AttachedPDO[PortNumber];
			pPort = PortPDO->DeviceExtension;

			if(pPort->PnpPowerFlags & PPF_REMOVED)
				ClearPnpPowerFlags(pPort,PPF_REMOVED);
		}
	}

	return(status);

} // End Spx_EnumPorts 

/*****************************************************************************
**************************                         ***************************
**************************   Spx_Card_StopDevice   ***************************
**************************                         ***************************
******************************************************************************

prototype:		NTSTATUS Spx_Card_StopDevice(IN PCARD_DEVICE_EXTENSION pCard)

description:	Stop the card device:
					Stop the hardware
					Deinitialise card resources (interrupt, I/O, memory)

parameters:		pCard points to the card device to stop

returns:		NT Status Code

*/

NTSTATUS Spx_Card_StopDevice(IN PCARD_DEVICE_EXTENSION pCard)
{
	NTSTATUS	status = STATUS_SUCCESS;

	PAGED_CODE();	// Macro in checked build to assert if pagable code is run at or above dispatch IRQL 

	SpxDbgMsg(SPX_TRACE_CALLS,("%s: Entering Spx_Card_StopDevice for Card %d.\n",PRODUCT_NAME,pCard->CardNumber));

	if(pCard->PnpPowerFlags & PPF_STARTED)		/* If card is running */
	{
		XXX_CardStop(pCard);					/* Stop the card */
	}

	ClearPnpPowerFlags(pCard,PPF_STARTED);		/* Indicate card is stopped */
	ClearPnpPowerFlags(pCard,PPF_STOP_PENDING);	/* Clear stop pending flag */

	return(status);

} /* Spx_Card_StopDevice */

/*****************************************************************************
*************************                           **************************
*************************   Spx_Card_RemoveDevice   **************************
*************************                           **************************
******************************************************************************

prototype:		NTSTATUS Spx_Card_RemoveDevice(IN PDEVICE_OBJECT pDevObject)

description:	Remove the card device:
					Deallocate any resources
					Delete device object

parameters:		pDevObject points to the card device object to remove

returns:		NT Status Code

*/


NTSTATUS Spx_Card_RemoveDevice(IN PDEVICE_OBJECT pDevObject)
{
	PCARD_DEVICE_EXTENSION	pCard = pDevObject->DeviceExtension;
	PDEVICE_OBJECT			pPortPdo;
	PPORT_DEVICE_EXTENSION	pPort;
	NTSTATUS				status = STATUS_SUCCESS;
	int						loop;

	PAGED_CODE();	// Macro in checked build to assert if pagable code is run at or above dispatch IRQL 

	SpxDbgMsg(SPX_TRACE_CALLS, ("%s: Entering Spx_Card_RemoveDevice for Card %d.\n", 
		PRODUCT_NAME, pCard->CardNumber));

/* First remove all "removed" port device objects... */

	for(loop=0; loop<PRODUCT_MAX_PORTS; loop++)
	{
		if(pPortPdo = pCard->AttachedPDO[loop])			/* Enumerated port PDO ? */
		{
			pPort = pPortPdo->DeviceExtension;			/* Get the device extension */
			XXX_PortDeInit(pPort);						/* Deinitialise port structure */
			if(pPort->DeviceName.Buffer)
			{
				SpxFreeMem(pPort->DeviceName.Buffer);	/* Free device name buffer */
				pPort->DeviceName.Buffer = NULL;
			}
			pCard->AttachedPDO[loop] = NULL;			/* Remove the port PDO pointer */
			pCard->NumPDOs--;							/* One less port attached */
			IoDeleteDevice(pPortPdo);					/* Delete the port device object */
			ObDereferenceObject(pPortPdo);				/* Dereference the object */
		}
	}

/* Now, remove the card device object... */

	Spx_Card_StopDevice(pCard);							/* Stop the card and release resources */
	XXX_CardDeInit(pCard);								/* Deinitialise non-hardware fields */
	IoDetachDevice(pCard->LowerDeviceObject);			/* Detach card device from the device stack. */
	IoDeleteDevice(pDevObject);							/* Delete Card FDO from system. */

	return(status);

} /* Spx_Card_RemoveDevice */



/*****************************************************************************
************************                              ************************
************************   Spx_Port_PDO_DispatchPnp   ************************
************************                              ************************
******************************************************************************

prototype:		NTSTATUS Spx_Port_PDO_DispatchPnp(IN PDEVICE_OBJECT pPDO,IN PIRP pIrp)

description:	The plug and play dispatch routine to handle IRPs for port devices.

parameters:		pDevObject points to a port device object for this driver
				pIrp points to the Plug and Play I/O Request (IRP) to be processed

returns:		NT Status Code

*/

NTSTATUS Spx_Port_PDO_DispatchPnp(IN PDEVICE_OBJECT pPDO,IN PIRP pIrp)
{
	PPORT_DEVICE_EXTENSION	pPort = pPDO->DeviceExtension;
	PCARD_DEVICE_EXTENSION	pCard = pPort->pParentCardExt;
	PIO_STACK_LOCATION		pIrpStack = IoGetCurrentIrpStackLocation(pIrp);
	NTSTATUS				status;
	PWCHAR					ReturnBuffer = NULL;

	PAGED_CODE();	// Macro in checked build to assert if pagable code is run at or above dispatch IRQL 

	status = pIrp->IoStatus.Status;

	switch (pIrpStack->MinorFunction) 
	{
   
/*****************************************************************************
***************************   IRP_MN_START_DEVICE   **************************
*****************************************************************************/
	
	case	IRP_MN_START_DEVICE: 
			SpxDbgMsg(SPX_TRACE_PNP_IRPS,("%s: Got IRP_MN_START_DEVICE Irp for Port %d.\n",
				PRODUCT_NAME,pPort->PortNumber));

			status = STATUS_UNSUCCESSFUL;

			if(SPX_SUCCESS(status = Spx_Port_StartDevice(pPDO)))
				Spx_UnstallIrps(pPort);					// Restart any queued IRPs (from a previous start) 

			break;

/*****************************************************************************
*****************************   IRP_MN_QUERY_ID   ****************************
*****************************************************************************/
	
	case	IRP_MN_QUERY_ID:
	{
		PUNICODE_STRING pId	= NULL;
		CHAR szErrorMsg[MAX_ERROR_LOG_INSERT];	// Limited to 51 characters + 1 null 

		switch(pIrpStack->Parameters.QueryId.IdType)
		{
		case	BusQueryCompatibleIDs:
		case	BusQueryDeviceID:
		case	BusQueryInstanceID:
		case	BusQueryHardwareIDs:
			{
				status = STATUS_SUCCESS;

				switch(pIrpStack->Parameters.QueryId.IdType)
				{
				case	BusQueryDeviceID:
						SpxDbgMsg(SPX_TRACE_PNP_IRPS,("%s: Got IRP_MN_QUERY_ID - BusQueryDeviceID Irp for Port %d.\n",
							PRODUCT_NAME,pPort->PortNumber));
						SpxDbgMsg(SPX_MISC_DBG,("%s: Device ID %wZ.\n", PRODUCT_NAME,&pPort->DeviceID));
						pId = &pPort->DeviceID;
						break;

				case	BusQueryInstanceID:
						SpxDbgMsg(SPX_TRACE_PNP_IRPS,("%s: Got IRP_MN_QUERY_ID - BusQueryInstanceID Irp for Port %d.\n",
							PRODUCT_NAME, pPort->PortNumber));
						SpxDbgMsg(SPX_MISC_DBG,("%s: Instance ID %wZ.\n",PRODUCT_NAME,&pPort->InstanceID));
						pId = &pPort->InstanceID;
						break;

				case	BusQueryCompatibleIDs:
						SpxDbgMsg(SPX_TRACE_PNP_IRPS,("%s: Got IRP_MN_QUERY_ID - BusQueryCompatibleIDs Irp for Port %d.\n",
							PRODUCT_NAME, pPort->PortNumber));
						pId = &pPort->CompatibleIDs;
						break;

				case	BusQueryHardwareIDs:
						SpxDbgMsg(SPX_TRACE_PNP_IRPS,("%s: Got IRP_MN_QUERY_ID - BusQueryHardwareIDs Irp for Port %d.\n",
							PRODUCT_NAME, pPort->PortNumber));
						pId = &pPort->HardwareIDs;
						break;
				
				default:
					break;
				}

				if(pId)
				{
					if(pId->Buffer)
					{
						if(ReturnBuffer = SpxAllocateMem(PagedPool, pId->Length + sizeof(WCHAR)))
								RtlCopyMemory(ReturnBuffer, pId->Buffer, pId->Length + sizeof(WCHAR));
						else	
						{
							sprintf(szErrorMsg, "Port %d on card at %08X%08X: Insufficient resources", 
									pPort->PortNumber+1, pCard->PhysAddr.HighPart, pCard->PhysAddr.LowPart);

							Spx_LogMessage(	STATUS_SEVERITY_ERROR,
											pPort->DriverObject,			// Driver Object
											pPort->DeviceObject,			// Device Object (Optional)
											PhysicalZero,					// Physical Address 1
											PhysicalZero,					// Physical Address 2
											0,								// SequenceNumber
											pIrpStack->MajorFunction,		// Major Function Code
											0,								// RetryCount
											FILE_ID | __LINE__,				// UniqueErrorValue
											STATUS_SUCCESS,					// FinalStatus
											szErrorMsg);					// Error Message

							status = STATUS_INSUFFICIENT_RESOURCES;
						}
					}

					pIrp->IoStatus.Information = (ULONG_PTR)ReturnBuffer;
				}
				break;
			}
		
		default:
			break;
		}
		break;

	}

/*****************************************************************************
*************************   IRP_MN_QUERY_DEVICE_TEXT   ***********************
*****************************************************************************/

	case	IRP_MN_QUERY_DEVICE_TEXT:
	{
		PUNICODE_STRING	pText = NULL;
		CHAR szErrorMsg[MAX_ERROR_LOG_INSERT];	// Limited to 51 characters + 1 null 

		SpxDbgMsg(SPX_TRACE_PNP_IRPS,("%s: Got IRP_MN_QUERY_DEVICE_TEXT Irp for Port %d.\n",
				PRODUCT_NAME,pPort->PortNumber));

			if(pIrpStack->Parameters.QueryDeviceText.DeviceTextType == DeviceTextDescription)
				pText = &pPort->DevDesc;

			if(pIrpStack->Parameters.QueryDeviceText.DeviceTextType == DeviceTextLocationInformation)
				pText = &pPort->DevLocation;

			if((pText == NULL)||(pText->Buffer == NULL))
				break;

			if(!(ReturnBuffer = SpxAllocateMem(PagedPool, pText->Length + sizeof(WCHAR))))
			{
				sprintf(szErrorMsg, "Port %d on card at %08X%08X: Insufficient resources", 
						pPort->PortNumber+1, pCard->PhysAddr.HighPart, pCard->PhysAddr.LowPart);

				Spx_LogMessage(	STATUS_SEVERITY_ERROR,
								pPort->DriverObject,			// Driver Object
								pPort->DeviceObject,			// Device Object (Optional)
								PhysicalZero,					// Physical Address 1
								PhysicalZero,					// Physical Address 2
								0,								// SequenceNumber
								pIrpStack->MajorFunction,		// Major Function Code
								0,								// RetryCount
								FILE_ID | __LINE__,				// UniqueErrorValue
								STATUS_SUCCESS,					// FinalStatus
								szErrorMsg);					// Error Message

				status = STATUS_INSUFFICIENT_RESOURCES;
				break;
			}

			status = STATUS_SUCCESS;
			RtlCopyMemory(ReturnBuffer, pText->Buffer, pText->Length + sizeof(WCHAR));
			pIrp->IoStatus.Information = (ULONG_PTR)ReturnBuffer;
			break;
	}

/*****************************************************************************
************************   IRP_MN_QUERY_CAPABILITIES   ***********************
*****************************************************************************/

	case	IRP_MN_QUERY_CAPABILITIES:
	{
			PDEVICE_CAPABILITIES	pDevCaps = NULL;

			SpxDbgMsg(SPX_TRACE_PNP_IRPS,("%s: Got IRP_MN_QUERY_CAPABILITIES Irp for Port %d.\n", 
				PRODUCT_NAME,pPort->PortNumber));
			
			// Get the packet
			pDevCaps = pIrpStack->Parameters.DeviceCapabilities.Capabilities;

			// Set the capabilities.
			pDevCaps->Version = 1;
			pDevCaps->Size = sizeof(DEVICE_CAPABILITIES);

			// We cannot wake the system.
			pDevCaps->SystemWake = PowerSystemUnspecified;
			pDevCaps->DeviceWake = PowerSystemUnspecified;

			// Set device state mapping...

			pDevCaps->DeviceState[PowerSystemWorking] = PowerDeviceD0;
			pDevCaps->DeviceState[PowerSystemSleeping1] = PowerDeviceD3;
			pDevCaps->DeviceState[PowerSystemSleeping2] = PowerDeviceD3;
			pDevCaps->DeviceState[PowerSystemSleeping3] = PowerDeviceD3;
			pDevCaps->DeviceState[PowerSystemHibernate] = PowerDeviceD3;
			pDevCaps->DeviceState[PowerSystemShutdown] = PowerDeviceD3;

			// We have no latencies.
			pDevCaps->D1Latency = 0;
			pDevCaps->D2Latency = 0;
			pDevCaps->D3Latency = 0;

			// No locking or ejection.
			pDevCaps->LockSupported = FALSE;
			pDevCaps->EjectSupported = FALSE;

			// Removable
			pDevCaps->Removable = FALSE;

			// Not a Docking device.
			pDevCaps->DockDevice = FALSE;

			// System wide unique ID.
			pDevCaps->UniqueID = pPort->UniqueInstanceID;

			//UINumber
			pDevCaps->UINumber = pPort->PortNumber+1;

			// Raw capable
			pDevCaps->RawDeviceOK = TRUE;

			// Silent Install
			pDevCaps->SilentInstall = FALSE;

			// Surprise Removal
			pDevCaps->SurpriseRemovalOK = FALSE;

			status = STATUS_SUCCESS;
			break;
	}

/*****************************************************************************
************************   IRP_MN_QUERY_STOP_DEVICE   ************************
*****************************************************************************/

	case	IRP_MN_QUERY_STOP_DEVICE: 
			SpxDbgMsg(SPX_TRACE_PNP_IRPS,("%s: Got IRP_MN_QUERY_STOP_DEVICE Irp for Port %d.\n", 
				PRODUCT_NAME,pPort->PortNumber));

			status = STATUS_UNSUCCESSFUL;

			if(pPort->PnpPowerFlags & PPF_STARTED)
			{
				ExAcquireFastMutex(&pPort->OpenMutex);

				if(pPort->DeviceIsOpen) 
				{
					ExReleaseFastMutex(&pPort->OpenMutex);
					status = STATUS_DEVICE_BUSY;

					SpxDbgMsg(SPX_TRACE_PNP_IRPS, ("%s: ------- failing; Port %d open\n", 
						PRODUCT_NAME, pPort->PortNumber));
				}
				else
				{
					SetPnpPowerFlags(pPort,PPF_STOP_PENDING);
					status = STATUS_SUCCESS;
					ExReleaseFastMutex(&pPort->OpenMutex);
				}
			}
			break;

/*****************************************************************************
************************   IRP_MN_CANCEL_STOP_DEVICE   ***********************
*****************************************************************************/

	case	IRP_MN_CANCEL_STOP_DEVICE:
			SpxDbgMsg(SPX_TRACE_PNP_IRPS, ("%s: Got IRP_MN_CANCEL_STOP_DEVICE Irp for Port %d.\n", 
				PRODUCT_NAME,pPort->PortNumber));

			status = STATUS_SUCCESS;
			ClearPnpPowerFlags(pPort,PPF_STOP_PENDING);	// Clear the stop pending flag 
			Spx_UnstallIrps(pPort);						// Restart any queued IRPs 
			break;

/*****************************************************************************
***************************   IRP_MN_STOP_DEVICE   ***************************
*****************************************************************************/

	case	IRP_MN_STOP_DEVICE: 
			SpxDbgMsg(SPX_TRACE_PNP_IRPS,("%s: Got IRP_MN_STOP_DEVICE Irp for Port %d\n",
				PRODUCT_NAME,pPort->PortNumber));

			status = STATUS_SUCCESS;		// we must never fail this IRP (if we do we will probably unload).
			status = Spx_Port_StopDevice(pPort);
			ClearPnpPowerFlags(pPort,PPF_STOP_PENDING);	// Clear the stop pending flag 
			break;

/*****************************************************************************
***********************   IRP_MN_QUERY_REMOVE_DEVICE   ***********************
*****************************************************************************/

	case	IRP_MN_QUERY_REMOVE_DEVICE: 
			SpxDbgMsg(SPX_TRACE_PNP_IRPS,("%s: Got IRP_MN_QUERY_REMOVE_DEVICE Irp for Port %d.\n", 
				PRODUCT_NAME,pPort->PortNumber));

			ExAcquireFastMutex(&pPort->OpenMutex);

			if(pPort->DeviceIsOpen) 
			{
				ExReleaseFastMutex(&pPort->OpenMutex);
				status = STATUS_DEVICE_BUSY;

				SpxDbgMsg(SPX_TRACE_PNP_IRPS, ("%s: ------- failing; Port %d open\n", 
					PRODUCT_NAME, pPort->PortNumber));
			}
			else
			{
				SetPnpPowerFlags(pPort,PPF_REMOVE_PENDING);	// We are now ready to remove the port
				status = STATUS_SUCCESS;
				ExReleaseFastMutex(&pPort->OpenMutex);
			}

			break; 

/*****************************************************************************
***********************   IRP_MN_CANCEL_REMOVE_DEVICE   **********************
*****************************************************************************/

	case	IRP_MN_CANCEL_REMOVE_DEVICE:
			SpxDbgMsg(SPX_TRACE_PNP_IRPS, ("%s: Got IRP_MN_CANCEL_REMOVE_DEVICE Irp for Port %d.\n", 
				PRODUCT_NAME, pPort->PortNumber));
			
			status = STATUS_SUCCESS;
			ClearPnpPowerFlags(pPort,PPF_REMOVE_PENDING);	// We are no longer expecting to remove the device.
			break; 

/*****************************************************************************
*************************   IRP_MN_SURPRISE_REMOVAL   ************************
*****************************************************************************/

	case	IRP_MN_SURPRISE_REMOVAL:
			SpxDbgMsg(SPX_TRACE_PNP_IRPS,("%s: Got IRP_MN_SURPRISE_REMOVAL Irp for Port %d\n",
				PRODUCT_NAME,pPort->PortNumber));

			status = STATUS_SUCCESS;		// we must never fail this IRP (if we do we will probably unload).
			status = Spx_Port_StopDevice(pPort);
			SetPnpPowerFlags(pPort,PPF_REMOVE_PENDING);	// We are now ready to remove the port
			break;

/*****************************************************************************
**************************   IRP_MN_REMOVE_DEVICE   **************************
*****************************************************************************/

	case	IRP_MN_REMOVE_DEVICE:
			SpxDbgMsg(SPX_TRACE_PNP_IRPS,("%s: Got IRP_MN_REMOVE_DEVICE Irp for Port %d\n",
				PRODUCT_NAME,pPort->PortNumber));

			status = STATUS_SUCCESS;		// we must never fail this IRP (if we do we will probably unload).
			Spx_KillStalledIRPs(pPDO);		// Kill off any waiting IRPS on the stalled list 
			status = Spx_Port_RemoveDevice(pPDO);
			ClearPnpPowerFlags(pPort,PPF_REMOVE_PENDING);	// Clear the pending flag 
			break;

/*****************************************************************************
**********************   IRP_MN_QUERY_DEVICE_RELATIONS   *********************
*****************************************************************************/

	case	IRP_MN_QUERY_DEVICE_RELATIONS:
			SpxDbgMsg(SPX_TRACE_PNP_IRPS,("%s: Got IRP_MN_QUERY_DEVICE_RELATIONS Irp for Port %d.\n", 
				PRODUCT_NAME, pPort->PortNumber));

			switch(pIrpStack->Parameters.QueryDeviceRelations.Type)
			{
			case TargetDeviceRelation:
				{
					PDEVICE_RELATIONS pDevRel = NULL;

					if(pIrp->IoStatus.Information != 0)
						break;

					if(!(pDevRel = SpxAllocateMem(PagedPool, sizeof(DEVICE_RELATIONS))))
					{
						CHAR szErrorMsg[MAX_ERROR_LOG_INSERT];	// Limited to 51 characters + 1 null 

						sprintf(szErrorMsg, "Port %d on card at %08X%08X: Insufficient resources", 
								pPort->PortNumber+1, pCard->PhysAddr.HighPart, pCard->PhysAddr.LowPart);

						Spx_LogMessage(	STATUS_SEVERITY_ERROR,
										pPort->DriverObject,			// Driver Object
										pPort->DeviceObject,			// Device Object (Optional)
										PhysicalZero,					// Physical Address 1
										PhysicalZero,					// Physical Address 2
										0,								// SequenceNumber
										pIrpStack->MajorFunction,		// Major Function Code
										0,								// RetryCount
										FILE_ID | __LINE__,				// UniqueErrorValue
										STATUS_SUCCESS,					// FinalStatus
										szErrorMsg);					// Error Message

						status = STATUS_INSUFFICIENT_RESOURCES;
						break;
					}

					pDevRel->Count = 1;
					pDevRel->Objects[0] = pPDO;
					ObReferenceObject(pPDO);

					status = STATUS_SUCCESS;
					pIrp->IoStatus.Information = (ULONG_PTR)pDevRel;
					break;
				}

			case BusRelations:
				{
					PDEVICE_RELATIONS pDevRel = NULL;

					if(pIrp->IoStatus.Information != 0)
						break;

					if(!(pDevRel = SpxAllocateMem(PagedPool, sizeof(DEVICE_RELATIONS))))
					{
						CHAR szErrorMsg[MAX_ERROR_LOG_INSERT];	// Limited to 51 characters + 1 null 

						sprintf(szErrorMsg, "Port %d on card at %08X%08X: Insufficient resources", 
								pPort->PortNumber+1, pCard->PhysAddr.HighPart, pCard->PhysAddr.LowPart);
						
						Spx_LogMessage(	STATUS_SEVERITY_ERROR,
										pPort->DriverObject,			// Driver Object
										pPort->DeviceObject,			// Device Object (Optional)
										PhysicalZero,					// Physical Address 1
										PhysicalZero,					// Physical Address 2
										0,								// SequenceNumber
										pIrpStack->MajorFunction,		// Major Function Code
										0,								// RetryCount
										FILE_ID | __LINE__,				// UniqueErrorValue
										STATUS_SUCCESS,					// FinalStatus
										szErrorMsg);					// Error Message

						status = STATUS_INSUFFICIENT_RESOURCES;
						break;
					}

					pDevRel->Count = 0;
					status = STATUS_SUCCESS;
					pIrp->IoStatus.Information = (ULONG_PTR)pDevRel;
					break;

				}

			default:
				break;
			}
			break;


	default:
			SpxDbgMsg(SPX_TRACE_PNP_IRPS,("%s: Got PnP Irp - MinorFunction=0x%02X for Port %d.\n", 
				PRODUCT_NAME,pIrpStack->MinorFunction, pPort->PortNumber));
			break;
	}

	pIrp->IoStatus.Status = status;
	IoCompleteRequest(pIrp, IO_NO_INCREMENT);

	return(status);

} /* Spx_Port_PDO_DispatchPnp */

/*****************************************************************************
**************************                          **************************
**************************   Spx_Port_StartDevice   **************************
**************************                          **************************
******************************************************************************

prototype:		NTSTATUS Spx_Port_StartDevice(IN PDEVICE_OBJECT pDevObject)

description:	Start the port device:
					Setup external naming
					Initialise and start the hardware

parameters:		pDevObject point to the card device to start
				pIrp points to the start I/O Request (IRP)

returns:		NT Status Code

*/

NTSTATUS Spx_Port_StartDevice(IN PDEVICE_OBJECT pDevObject)
{

	PPORT_DEVICE_EXTENSION	pPort = pDevObject->DeviceExtension;	
	NTSTATUS				status = STATUS_SUCCESS;

	PAGED_CODE();	// Macro in checked build to assert if pagable code is run at or above dispatch IRQL 

	SpxDbgMsg(SPX_TRACE_CALLS,("%s: Entering Spx_Port_StartDevice for Port %d.\n", PRODUCT_NAME, pPort->PortNumber));

	if(!pPort->CreatedSymbolicLink)
	{
		if(!SPX_SUCCESS(status = Spx_DoExternalNaming(pDevObject)))		// Set up external name for device 
			return(status);
	}

	if(!SPX_SUCCESS(status = XXX_PortStart(pPort)))				// Start hardware. 
	{
		Spx_RemoveExternalNaming(pDevObject);					// Remove external naming.
		return(status);
	}

	SetPnpPowerFlags(pPort,PPF_STARTED);						// Port has been started.
	ClearPnpPowerFlags(pPort,PPF_REMOVED);						// Port is not removed...yet. 
	ClearPnpPowerFlags(pPort,PPF_STOP_PENDING);					// Not pending a stop. 
	ClearPnpPowerFlags(pPort,PPF_REMOVE_PENDING);				// Not pending a remove. 

	return(status);

} // Spx_Port_StartDevice 


/*****************************************************************************
**************************                          **************************
**************************   Spx_GetExternalName   **************************
**************************                          **************************
******************************************************************************

prototype:		NTSTATUS Spx_GetExternalName(IN PDEVICE_OBJECT pDevObject)

description:	Setup external naming for a port:
					get Dos Name for port 
					form symbolic link name

parameters:		pDevObject points to the device object for the port to be named

returns:		NT Status Code

*/
NTSTATUS Spx_GetExternalName(IN PDEVICE_OBJECT pDevObject)
{
	PPORT_DEVICE_EXTENSION	pPort = pDevObject->DeviceExtension;
	PCARD_DEVICE_EXTENSION	pCard = pPort->pParentCardExt;
	NTSTATUS				status = STATUS_SUCCESS;
	HANDLE					PnPKeyHandle;
	UNICODE_STRING			TmpLinkName;
	WCHAR					*pRegName = NULL;
	ULONG					BuffLen = 0;
	CHAR					szErrorMsg[MAX_ERROR_LOG_INSERT];	// Limited to 51 characters + 1 null 
		
	PAGED_CODE();	// Macro in checked build to assert if pagable code is run at or above dispatch IRQL 

	SpxDbgMsg(SPX_TRACE_CALLS,("%s: Entering Spx_GetExternalName for Port %d.\n", PRODUCT_NAME, pPort->PortNumber));

	status = IoOpenDeviceRegistryKey(pDevObject, PLUGPLAY_REGKEY_DEVICE, STANDARD_RIGHTS_READ, &PnPKeyHandle);

	if(!SPX_SUCCESS(status))
		return(status);

// Get the device name allocated by the PNP manager from the registry... 
	if(pRegName = SpxAllocateMem(PagedPool,SYMBOLIC_NAME_LENGTH * sizeof(WCHAR) + sizeof(WCHAR)))
	{
		status = Spx_GetRegistryKeyValue(	PnPKeyHandle,
											L"PortName",
											wcslen(L"PortName") * sizeof(WCHAR),
											pRegName,
											SYMBOLIC_NAME_LENGTH * sizeof(WCHAR));
	}
	else
	{
		status = STATUS_INSUFFICIENT_RESOURCES;
	}

	ZwClose(PnPKeyHandle);

	if(!SPX_SUCCESS(status))
	{
		if(pRegName != NULL) 
			SpxFreeMem(pRegName);

		return(STATUS_SUCCESS);			// Port has not been given a name yet but we must not fail.
	}

	RtlZeroMemory(&TmpLinkName, sizeof(UNICODE_STRING));

	if(!SPX_SUCCESS(status))
		goto NamingError;
	
	TmpLinkName.MaximumLength	= SYMBOLIC_NAME_LENGTH * sizeof(WCHAR);
	TmpLinkName.Buffer			= SpxAllocateMem(PagedPool, TmpLinkName.MaximumLength + sizeof(WCHAR));
	
	if(!TmpLinkName.Buffer)
	{
		sprintf(szErrorMsg, "Port %d on card at %08X%08X Insufficient resources", 
				pPort->PortNumber+1, pCard->PhysAddr.HighPart, pCard->PhysAddr.LowPart);

		Spx_LogMessage(	STATUS_SEVERITY_ERROR,
						pPort->DriverObject,			// Driver Object
						pPort->DeviceObject,			// Device Object (Optional)
						PhysicalZero,					// Physical Address 1
						PhysicalZero,					// Physical Address 2
						0,								// SequenceNumber
						0,								// Major Function Code
						0,								// RetryCount
						FILE_ID | __LINE__,				// UniqueErrorValue
						STATUS_SUCCESS,					// FinalStatus
						szErrorMsg);					// Error Message

		status = STATUS_INSUFFICIENT_RESOURCES;
		goto NamingError;
	}

	RtlZeroMemory(TmpLinkName.Buffer, TmpLinkName.MaximumLength + sizeof(WCHAR));

	// Create the "\\DosDevices\\<SymbolicName>" string.
	RtlAppendUnicodeToString(&TmpLinkName, L"\\");
	RtlAppendUnicodeToString(&TmpLinkName, DEFAULT_DIRECTORY);
	RtlAppendUnicodeToString(&TmpLinkName, L"\\");
	RtlAppendUnicodeToString(&TmpLinkName, pRegName);

	pPort->SymbolicLinkName.Length			= 0;
	pPort->SymbolicLinkName.MaximumLength	= TmpLinkName.Length + sizeof(WCHAR);
	pPort->SymbolicLinkName.Buffer			= SpxAllocateMem(PagedPool, pPort->SymbolicLinkName.MaximumLength);
	
	if(!pPort->SymbolicLinkName.Buffer)
	{
		sprintf(szErrorMsg, "Port %d on card at %08X%08X: Insufficient resources", 
				pPort->PortNumber+1, pCard->PhysAddr.HighPart, pCard->PhysAddr.LowPart);

		Spx_LogMessage(	STATUS_SEVERITY_ERROR,
						pPort->DriverObject,			// Driver Object
						pPort->DeviceObject,			// Device Object (Optional)
						PhysicalZero,					// Physical Address 1
						PhysicalZero,					// Physical Address 2
						0,								// SequenceNumber
						0,								// Major Function Code
						0,								// RetryCount
						FILE_ID | __LINE__,				// UniqueErrorValue
						STATUS_SUCCESS,					// FinalStatus
						szErrorMsg);					// Error Message

		status = STATUS_INSUFFICIENT_RESOURCES;
		goto NamingError;
	}

	RtlZeroMemory(pPort->SymbolicLinkName.Buffer, pPort->SymbolicLinkName.MaximumLength);
	RtlAppendUnicodeStringToString(&pPort->SymbolicLinkName, &TmpLinkName);


	pPort->DosName.Buffer = SpxAllocateMem(PagedPool, 64 + sizeof(WCHAR));

	if(!pPort->DosName.Buffer)
	{
		sprintf(szErrorMsg, "Port %d on card at %08X%08X:: Insufficient resources", 
				pPort->PortNumber+1, pCard->PhysAddr.HighPart, pCard->PhysAddr.LowPart);
		
		Spx_LogMessage(	STATUS_SEVERITY_ERROR,
						pPort->DriverObject,			// Driver Object
						pPort->DeviceObject,			// Device Object (Optional)
						PhysicalZero,					// Physical Address 1
						PhysicalZero,					// Physical Address 2
						0,								// SequenceNumber
						0,								// Major Function Code
						0,								// RetryCount
						FILE_ID | __LINE__,				// UniqueErrorValue
						STATUS_SUCCESS,					// FinalStatus
						szErrorMsg);					// Error Message

		status = STATUS_INSUFFICIENT_RESOURCES;
		goto NamingError;
	}

	pPort->DosName.MaximumLength = 64 + sizeof(WCHAR);

	pPort->DosName.Length = 0;
	RtlZeroMemory(pPort->DosName.Buffer, pPort->DosName.MaximumLength);
	RtlAppendUnicodeToString(&pPort->DosName, pRegName);
	RtlZeroMemory(((PUCHAR) (&pPort->DosName.Buffer[0])) + pPort->DosName.Length, sizeof(WCHAR));

	SpxDbgMsg(SPX_MISC_DBG, ("%s: DeviceName is %wZ\n", PRODUCT_NAME, &pPort->DeviceName));
	SpxDbgMsg(SPX_MISC_DBG, ("%s: DosName is %wZ\n", PRODUCT_NAME, &pPort->DosName));
	SpxDbgMsg(SPX_MISC_DBG, ("%s: SymbolicName is %wZ\n", PRODUCT_NAME, &pPort->SymbolicLinkName));

	if(pRegName != NULL)
		SpxFreeMem(pRegName);	// Free pRegName

	if(TmpLinkName.Buffer != NULL)
		SpxFreeMem(TmpLinkName.Buffer);	// Free TmpLinkName

	return(status);


NamingError:;

	if(TmpLinkName.Buffer != NULL)
		SpxFreeMem(TmpLinkName.Buffer);

	if(pRegName != NULL)
		SpxFreeMem(pRegName);

	return(status);
}

/*****************************************************************************
**************************                          **************************
**************************   Spx_DoExternalNaming   **************************
**************************                          **************************
******************************************************************************

prototype:		NTSTATUS Spx_DoExternalNaming(IN PDEVICE_OBJECT pDevObject)

description:	Setup external naming for a port:
					create symbolic link
					add to registry
					register and enable interface

parameters:		pDevObject points to the device object for the port to be named

returns:		NT Status Code

*/
NTSTATUS Spx_DoExternalNaming(IN PDEVICE_OBJECT pDevObject)
{
	PPORT_DEVICE_EXTENSION	pPort = pDevObject->DeviceExtension;
	PCARD_DEVICE_EXTENSION	pCard = pPort->pParentCardExt;
	NTSTATUS				status = STATUS_SUCCESS;
	CHAR					szErrorMsg[MAX_ERROR_LOG_INSERT];	// Limited to 51 characters + 1 null 
		
	PAGED_CODE();	// Macro in checked build to assert if pagable code is run at or above dispatch IRQL 

	SpxDbgMsg(SPX_TRACE_CALLS,("%s: Entering Spx_DoExternalNaming for Port %d.\n",PRODUCT_NAME,pPort->PortNumber));

// Get external name...
	if( !SPX_SUCCESS(status = Spx_GetExternalName(pDevObject)) || (pPort->DosName.Buffer == NULL))
		return(status);


	status = IoCreateSymbolicLink(&pPort->SymbolicLinkName, &pPort->DeviceName);  // Create the symbolic link... 

	if(!SPX_SUCCESS(status))
	{
		sprintf(szErrorMsg, "Port %d on card at %08X%08X:: Insufficient resources", 
				pPort->PortNumber+1, pCard->PhysAddr.HighPart, pCard->PhysAddr.LowPart);
		
		Spx_LogMessage(	STATUS_SEVERITY_ERROR,
						pPort->DriverObject,			// Driver Object
						pPort->DeviceObject,			// Device Object (Optional)
						PhysicalZero,					// Physical Address 1
						PhysicalZero,					// Physical Address 2
						0,								// SequenceNumber
						0,								// Major Function Code
						0,								// RetryCount
						FILE_ID | __LINE__,				// UniqueErrorValue
						STATUS_SUCCESS,					// FinalStatus
						szErrorMsg);					// Error Message

		goto ExternalNamingError;
	}

// Add mapping to "SERIALCOMM" section of registry... 
	pPort->CreatedSymbolicLink = TRUE;
	
	status = RtlWriteRegistryValue(	RTL_REGISTRY_DEVICEMAP,
									L"SERIALCOMM",
									pPort->DeviceName.Buffer,
									REG_SZ,
									pPort->DosName.Buffer,
									pPort->DosName.Length + sizeof(WCHAR));

	if(!SPX_SUCCESS(status))
	{
		sprintf(szErrorMsg, "Port %d on card at %08X%08X: Registry error.", 
				pPort->PortNumber+1, pCard->PhysAddr.HighPart, pCard->PhysAddr.LowPart);
		
		Spx_LogMessage(	STATUS_SEVERITY_ERROR,
						pPort->DriverObject,			// Driver Object
						pPort->DeviceObject,			// Device Object (Optional)
						PhysicalZero,					// Physical Address 1
						PhysicalZero,					// Physical Address 2
						0,								// SequenceNumber
						0,								// Major Function Code
						0,								// RetryCount
						FILE_ID | __LINE__,				// UniqueErrorValue
						STATUS_SUCCESS,					// FinalStatus
						szErrorMsg);					// Error Message

		goto ExternalNamingError;
	}

	status = IoRegisterDeviceInterface(	pDevObject, (LPGUID)&GUID_CLASS_COMPORT,
										NULL, &pPort->DeviceClassSymbolicName);

	if(!NT_SUCCESS(status)) // Could return good values of STATUS_SUCCESS or STATUS_OBJECT_NAME_EXISTS 
	{
		sprintf(szErrorMsg, "Port %d on card at %08X%08X: Interface error.", 
				pPort->PortNumber+1, pCard->PhysAddr.HighPart, pCard->PhysAddr.LowPart);
		
		Spx_LogMessage(	STATUS_SEVERITY_ERROR,
						pPort->DriverObject,			// Driver Object
						pPort->DeviceObject,			// Device Object (Optional)
						PhysicalZero,					// Physical Address 1
						PhysicalZero,					// Physical Address 2
						0,								// SequenceNumber
						0,								// Major Function Code
						0,								// RetryCount
						FILE_ID | __LINE__,				// UniqueErrorValue
						STATUS_SUCCESS,					// FinalStatus
						szErrorMsg);					// Error Message

		pPort->DeviceClassSymbolicName.Buffer = NULL;
		
		goto ExternalNamingError;
	}

	// Enable the device interface.
	status = IoSetDeviceInterfaceState(&pPort->DeviceClassSymbolicName, TRUE);

	if(!NT_SUCCESS(status)) // Could return good values of STATUS_SUCCESS or STATUS_OBJECT_NAME_EXISTS 
	{
		sprintf(szErrorMsg, "Port %d on card at %08X%08X: Interface error.", 
				pPort->PortNumber+1, pCard->PhysAddr.HighPart, pCard->PhysAddr.LowPart);
		
		Spx_LogMessage(	STATUS_SEVERITY_ERROR,
						pPort->DriverObject,			// Driver Object
						pPort->DeviceObject,			// Device Object (Optional)
						PhysicalZero,					// Physical Address 1
						PhysicalZero,					// Physical Address 2
						0,								// SequenceNumber
						0,								// Major Function Code
						0,								// RetryCount
						FILE_ID | __LINE__,				// UniqueErrorValue
						STATUS_SUCCESS,					// FinalStatus
						szErrorMsg);					// Error Message

		
		goto ExternalNamingError;
	}



	pPort->CreatedSerialCommEntry = TRUE;				// Set flag.

	return(status);


ExternalNamingError:;

	if(!SPX_SUCCESS(status))
		Spx_RemoveExternalNaming(pDevObject);			// Remove and tidy up any allocations 


	return(status);

} // End Spx_DoExternalNaming 

/*****************************************************************************
************************                              ************************
************************   Spx_RemoveExternalNaming   ************************
************************                              ************************
******************************************************************************

prototype:		NTSTATUS Spx_RemoveExternalNaming(IN PDEVICE_OBJECT pDevObject)

description:	Remove external naming:
					remove symbolic link
					remove from registry
					stop interface

parameters:		pDevObject points to the device object for the port to be named.

returns:		NT Status Code

*/
NTSTATUS Spx_RemoveExternalNaming(IN PDEVICE_OBJECT pDevObject)
{
	PPORT_DEVICE_EXTENSION	pPort = pDevObject->DeviceExtension;
	PCARD_DEVICE_EXTENSION	pCard = pPort->pParentCardExt;
	NTSTATUS status = STATUS_UNSUCCESSFUL;

	PAGED_CODE();	// Macro in checked build to assert if pagable code is run at or above dispatch IRQL 

	if(pPort->CreatedSymbolicLink)
	{
		if(pPort->DosName.Buffer)
		{
			SpxFreeMem(pPort->DosName.Buffer);						// Free DOS name buffer. 
			pPort->DosName.Buffer = NULL;
		}

		if(pPort->SymbolicLinkName.Buffer)
		{
			SpxFreeMem(pPort->SymbolicLinkName.Buffer);				// Free symbolic link name buffer. 
			pPort->SymbolicLinkName.Buffer = NULL;
		}

		Spx_GetExternalName(pDevObject);	// Get external name..

		if(pPort->SymbolicLinkName.Buffer)
			status = IoDeleteSymbolicLink(&pPort->SymbolicLinkName);	// Delete Symbolic Link. 

		if(pPort->DeviceClassSymbolicName.Buffer)	// Device Interface name
			IoSetDeviceInterfaceState(&pPort->DeviceClassSymbolicName, FALSE);	// Disable Device Interface.


		pPort->CreatedSymbolicLink = FALSE;												// Reset created flag. 
	}

	if(pPort->DosName.Buffer)
	{
		SpxFreeMem(pPort->DosName.Buffer);					// Free DOS name buffer. 
		pPort->DosName.Buffer = NULL;
	}

	if(pPort->SymbolicLinkName.Buffer)
	{
		SpxFreeMem(pPort->SymbolicLinkName.Buffer);			// Free symbolic link name buffer. 
		pPort->SymbolicLinkName.Buffer = NULL;
	}

	if(pPort->CreatedSerialCommEntry && pPort->DeviceName.Buffer)
	{
		RtlDeleteRegistryValue(	RTL_REGISTRY_DEVICEMAP,		// Delete SERIALCOMM registry entry. 
								SERIAL_DEVICE_MAP,
								pPort->DeviceName.Buffer);

		pPort->CreatedSerialCommEntry = FALSE;				// Reset created flag.
	}

	if(pPort->DeviceClassSymbolicName.Buffer)	// Device Interface name
	{			
		SpxFreeMem(pPort->DeviceClassSymbolicName.Buffer);					// Free Device Interface Name.
		pPort->DeviceClassSymbolicName.Buffer = NULL;
	}

	return(STATUS_SUCCESS);

} // End Spx_RemoveExternalNaming 

/*****************************************************************************
**************************                         ***************************
**************************   Spx_Port_StopDevice   ***************************
**************************                         ***************************
******************************************************************************

prototype:		NTSTATUS Spx_Port_StopDevice(IN PPORT_DEVICE_EXTENSION pPort)

description:	Stop the port device:
					Stop the hardware
					Remove external naming

parameters:		pPort points to the port device extension to be stopped

returns:		NT Status Code

*/

NTSTATUS Spx_Port_StopDevice(IN PPORT_DEVICE_EXTENSION pPort)
{
	NTSTATUS	status	= STATUS_SUCCESS;

	PAGED_CODE();	// Macro in checked build to assert if pagable code is run at or above dispatch IRQL 

	SpxDbgMsg(SPX_TRACE_CALLS,("%s: Entering Spx_Port_StopDevice for Port %d.\n",PRODUCT_NAME,pPort->PortNumber));

	if(pPort->PnpPowerFlags & PPF_STARTED)
		XXX_PortStop(pPort);									// Stop the port hardware. 

	ClearPnpPowerFlags(pPort,PPF_STARTED);						// Indicate card is stopped. 
	ClearPnpPowerFlags(pPort,PPF_STOP_PENDING);					// Clear stop pending flag.

	return(status);

} // End Spx_Port_StopDevice

/*****************************************************************************
*************************                           **************************
*************************   Spx_Port_RemoveDevice   **************************
*************************                           **************************
******************************************************************************

prototype:		NTSTATUS Spx_Port_RemoveDevice(IN PDEVICE_OBJECT pDevObject)

description:	Remove the port device object:
					Remove PDO pointer from card structure
					Deinitialise port hardware
					Delete the device object

parameters:		pDevObject points to the port device object to be stopped

returns:		NT Status Code

*/
NTSTATUS Spx_Port_RemoveDevice(IN PDEVICE_OBJECT pDevObject)
{
	PPORT_DEVICE_EXTENSION	pPort	= pDevObject->DeviceExtension;
	PCARD_DEVICE_EXTENSION	pCard	= pPort->pParentCardExt;
	NTSTATUS				status	= STATUS_SUCCESS;

	PAGED_CODE();	// Macro in checked build to assert if pagable code is run at or above dispatch IRQL 

	SpxDbgMsg(SPX_TRACE_CALLS,("%s: Entering Spx_Port_RemoveDevice for Port %d.\n",PRODUCT_NAME,pPort->PortNumber));

	if(pPort->PnpPowerFlags & PPF_REMOVED)					// Has device been removed already?
		return(STATUS_SUCCESS);

	Spx_Port_StopDevice(pPort);								// Stop the hardware.
	ClearPnpPowerFlags(pPort,PPF_STARTED);					// Mark the PDO as stopped.

	Spx_RemoveExternalNaming(pDevObject);					// Remove external naming. 


// Mark the port device as "removed", but don't delete the PDO until the card device is removed...
	SetPnpPowerFlags(pPort,PPF_REMOVED);					// Mark the PDO as "removed".

	return(status);

} // End Spx_Port_RemoveDevice 




/////////////////////////////////////////////////////////////////////////////////////////////
// Create an Instance ID for the port and try to make it globally unique if possible.
//
NTSTATUS
Spx_CreatePortInstanceID(IN PPORT_DEVICE_EXTENSION pPort)
{
	PCARD_DEVICE_EXTENSION	pCard = pPort->pParentCardExt;
	NTSTATUS				status = STATUS_SUCCESS;
	CHAR					szTemp[100];		// Space to hold string 
	int						szTempPos = 0;
	HANDLE					PnPKeyHandle;
	BOOLEAN					UseBusWideInstanceID = FALSE;  // Try to create system wide unique instance IDs

	PAGED_CODE();	// Macro in checked build to assert if pagable code is run at or above dispatch IRQL 

	SpxDbgMsg(SPX_TRACE_CALLS,("%s: Entering Spx_CreatePortInstanceID for Port %d.\n", PRODUCT_NAME, pPort->PortNumber));

	status = IoOpenDeviceRegistryKey(pCard->PDO, PLUGPLAY_REGKEY_DRIVER, STANDARD_RIGHTS_READ, &PnPKeyHandle);

	if(SPX_SUCCESS(status))
	{
		ULONG Data = 0;

		if(SPX_SUCCESS(Spx_GetRegistryKeyValue(PnPKeyHandle, L"UseBusWideInstanceID", 
							wcslen(L"UseBusWideInstanceID") * sizeof(WCHAR), &Data, sizeof(ULONG))))
		{
			if(Data > 0)
				UseBusWideInstanceID = TRUE;  // Installer has told us to use a bus wide instance ID 
											  // because child devices already exist with that type of ID.
		}
		

		ZwClose(PnPKeyHandle);
	}

	if(UseBusWideInstanceID)
	{
		pPort->UniqueInstanceID = FALSE;	// ID created is not unique system wide.
		status = STATUS_SUCCESS;
	}
	else
	{
		switch(pCard->InterfaceType)
		{
		case Isa:
			// Start Instance ID with ISA address
			szTempPos += sprintf(szTemp,"ISA&%08X%08X&", pCard->PhysAddr.HighPart, pCard->PhysAddr.LowPart);
			pPort->UniqueInstanceID = TRUE;	// ID created is unique system wide.
			status = STATUS_SUCCESS;
			break;

		case PCIBus:
			{
				ULONG PCI_BusNumber = 0;
				ULONG PCI_DeviceFunction = 0;
				ULONG ResultLength;

				// Try to get DevicePropertyBusNumber
				if(!SPX_SUCCESS(status = IoGetDeviceProperty(pCard->PDO, DevicePropertyBusNumber, 
											sizeof(PCI_BusNumber), &PCI_BusNumber, &ResultLength)))
					break;


				// Start Instance ID with PCI bus number
				szTempPos += sprintf(szTemp,"PCI&%04X&", PCI_BusNumber);

				// Try to get DevicePropertyAddress
				if(!SPX_SUCCESS(status = IoGetDeviceProperty(pCard->PDO, DevicePropertyAddress, 
											sizeof(PCI_DeviceFunction),	&PCI_DeviceFunction, &ResultLength)))
					break;
				

				// Add on PCI Device and Function IDs
				szTempPos += sprintf(szTemp + szTempPos,"%08X&", PCI_DeviceFunction);
				pPort->UniqueInstanceID = TRUE;	// ID created is unique system wide.

				status = STATUS_SUCCESS;
				break;
			}
		
		default:
			pPort->UniqueInstanceID = FALSE;	// ID created is not unique system wide.
			status = STATUS_SUCCESS;
			break;

		}

	}

	// Finish off the InstanceID with the port number on the card.
	sprintf(szTemp + szTempPos,"%04X", pPort->PortNumber);

	status = Spx_InitMultiString(FALSE, &pPort->InstanceID, szTemp, NULL);


	return status;
}



// End of SPX_PNP.C
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\spx\mps\sx\spx_powr.c ===
#include "precomp.h"	// Precompiled header

/****************************************************************************************
*																						*
*	Module:			SPX_POWER.C															*
*																						*
*	Creation:		15th October 1998													*
*																						*
*	Author:			Paul Smith															*
*																						*
*	Version:		1.0.0																*
*																						*
*	Description:	Handle all Power IRPS.												*
*																						*
****************************************************************************************/
/* History...

1.0.0	27/09/98 PBS	Creation.

*/
#define FILE_ID	SPX_POWR_C		// File ID for Event Logging see SPX_DEFS.H for values.

BOOLEAN	BREAK_ON_POWER_UP = FALSE;

// Prototypes
NTSTATUS Spx_Card_FDO_DispatchPower(IN PDEVICE_OBJECT pFDO, IN PIRP pIrp);
NTSTATUS Spx_CardSetSystemPowerState(IN PDEVICE_OBJECT pDevObject, IN PIRP pIrp);
NTSTATUS Spx_CardSetDevicePowerState(IN PDEVICE_OBJECT pDevObject, IN PIRP pIrp);
NTSTATUS Spx_CardSetPowerStateD0(IN PDEVICE_OBJECT pDevObject, IN PIRP pIrp);
NTSTATUS Spx_CardSetPowerStateD3(IN PDEVICE_OBJECT pDevObject, IN PIRP pIrp);

NTSTATUS Spx_Port_PDO_DispatchPower(IN PDEVICE_OBJECT pPDO, IN PIRP pIrp);
NTSTATUS Spx_PortQuerySystemPowerState(IN PDEVICE_OBJECT pDevObject, IN PIRP pIrp);
NTSTATUS Spx_PortSetSystemPowerState(IN PDEVICE_OBJECT pDevObject, IN PIRP pIrp);
NTSTATUS Spx_PortSetDevicePowerState(IN PDEVICE_OBJECT pDevObject, IN PIRP pIrp);
NTSTATUS Spx_PortSetPowerStateD0(IN PDEVICE_OBJECT pDevObject, IN PIRP pIrp);
NTSTATUS Spx_PortSetPowerStateD3(IN PDEVICE_OBJECT pDevObject, IN PIRP pIrp);

NTSTATUS Spx_PowerWaitForDriverBelow(IN PDEVICE_OBJECT pLowerDevObj, IN PIRP pIrp);
// End of prototypes


// Paging.. 
#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, Spx_DispatchPower)

#pragma alloc_text(PAGE, Spx_Card_FDO_DispatchPower)
#pragma alloc_text(PAGE, Spx_CardSetSystemPowerState)
#pragma alloc_text(PAGE, Spx_CardSetDevicePowerState)
#pragma alloc_text(PAGE, Spx_CardSetPowerStateD0)
#pragma alloc_text(PAGE, Spx_CardSetPowerStateD3)

#pragma alloc_text(PAGE, Spx_Port_PDO_DispatchPower)
#pragma alloc_text(PAGE, Spx_PortQuerySystemPowerState)
#pragma alloc_text(PAGE, Spx_PortSetSystemPowerState)
#pragma alloc_text(PAGE, Spx_PortSetDevicePowerState)
#pragma alloc_text(PAGE, Spx_PortSetPowerStateD0)
#pragma alloc_text(PAGE, Spx_PortSetPowerStateD3)

#endif // ALLOC_PRAGMA


//////////////////////////////////////////////////////////////////////////////////////////
//																						
//	Routine Description:
//		The power dispatch routine determine if the IRP is for a card or a port and 
//		then call the correct dispatch routine.
//
//	Arguments:
//		pDevObject	- pointer to a device object.
//		pIrp		- pointer to an I/O request packet.
//
//	Return value:
//		NT status code.
//
//////////////////////////////////////////////////////////////////////////////////////////
NTSTATUS
Spx_DispatchPower(IN PDEVICE_OBJECT pDevObject, IN PIRP pIrp)
{
    PCOMMON_OBJECT_DATA		CommonData	= (PCOMMON_OBJECT_DATA) pDevObject->DeviceExtension;
    NTSTATUS				status		= STATUS_SUCCESS;

	PAGED_CODE();	// Macro in checked build to assert if pagable code is run at or above dispatch IRQL 

    if(CommonData->IsFDO) 
        status = Spx_Card_FDO_DispatchPower(pDevObject, pIrp);
	else 
        status = Spx_Port_PDO_DispatchPower(pDevObject, pIrp);

    return status;
}	// Spx_DispatchPower


	
//////////////////////////////////////////////////////////////////////////////////////////
//
//	Routine Description:
//		The power dispatch routine to handle power IRPs for card devices.
//
//	Arguments:
//		pFDO - pointer to a device object.
//		pIrp - pointer to an I/O request packet.
//
//	Return value:
//		NT status code.
//
//////////////////////////////////////////////////////////////////////////////////////////
NTSTATUS
Spx_Card_FDO_DispatchPower(IN PDEVICE_OBJECT pFDO, IN PIRP pIrp)
{
	PCARD_DEVICE_EXTENSION	pCard		= pFDO->DeviceExtension;
	NTSTATUS				status		= STATUS_SUCCESS;
	PIO_STACK_LOCATION		pIrpStack	= IoGetCurrentIrpStackLocation(pIrp);

	PAGED_CODE();	// Macro in checked build to assert if pagable code is run at or above dispatch IRQL 

	switch (pIrpStack->MinorFunction) 
	{
    case IRP_MN_SET_POWER:	// Driver MUST never fail this IRP.
		{
			switch(pIrpStack->Parameters.Power.Type)
			{
			case SystemPowerState:
				SpxDbgMsg(SPX_TRACE_POWER_IRPS, ("%s: Got IRP_MN_SET_POWER Irp - Type SystemPowerState for Card %d.\n", 
					PRODUCT_NAME, pCard->CardNumber));
				return Spx_CardSetSystemPowerState(pFDO, pIrp);

			case DevicePowerState:
				SpxDbgMsg(SPX_TRACE_POWER_IRPS, ("%s: Got IRP_MN_SET_POWER Irp - Type DevicePowerState for Card %d.\n", 
					PRODUCT_NAME, pCard->CardNumber));
				return Spx_CardSetDevicePowerState(pFDO, pIrp);
			
			default:
				SpxDbgMsg(SPX_TRACE_POWER_IRPS, ("%s: Got IRP_MN_SET_POWER - Type 0x%02X Irp for Card %d.\n", 
					PRODUCT_NAME, pIrpStack->Parameters.Power.Type, pCard->CardNumber));
				
				status = STATUS_SUCCESS;
				pIrp->IoStatus.Status = status;
				break;
			}

			break;
		}

	case IRP_MN_QUERY_POWER:
		{
			switch(pIrpStack->Parameters.Power.Type)
			{
			case SystemPowerState:
				SpxDbgMsg(SPX_TRACE_POWER_IRPS, ("%s: Got IRP_MN_QUERY_POWER Irp - Type SystemPowerState for Card %d.\n", 
					PRODUCT_NAME, pCard->CardNumber));
				
				status = STATUS_SUCCESS;
				pIrp->IoStatus.Status = status;
				break;

			case DevicePowerState:
				SpxDbgMsg(SPX_TRACE_POWER_IRPS, ("%s: Got IRP_MN_QUERY_POWER Irp - Type DevicePowerState for Card %d.\n", 
					PRODUCT_NAME, pCard->CardNumber));

				status = STATUS_SUCCESS;
				pIrp->IoStatus.Status = status;
				break; 
			
			default:
				SpxDbgMsg(SPX_TRACE_POWER_IRPS, ("%s: Got IRP_MN_QUERY_POWER - Type 0x%02X Irp for Card %d.\n", 
					PRODUCT_NAME, pIrpStack->Parameters.Power.Type, pCard->CardNumber));
			
				status = STATUS_SUCCESS;
				pIrp->IoStatus.Status = status;
				break;
			}

			break;
		}
		
    case IRP_MN_WAIT_WAKE:
			SpxDbgMsg(SPX_TRACE_POWER_IRPS, ("%s: Got IRP_MN_WAIT_WAKE Irp for Card %d.\n", 
				PRODUCT_NAME, pCard->CardNumber));
			
			status = STATUS_NOT_SUPPORTED;
			pIrp->IoStatus.Status = status;
			break;

    case IRP_MN_POWER_SEQUENCE:
			SpxDbgMsg(SPX_TRACE_POWER_IRPS, ("%s: Got IRP_MN_POWER_SEQUENCE Irp for Card %d.\n", 
				PRODUCT_NAME, pCard->CardNumber));
			
			status = STATUS_NOT_IMPLEMENTED;
			pIrp->IoStatus.Status = status;
			break;

	default:
			SpxDbgMsg(SPX_TRACE_POWER_IRPS, ("%s: Got an UNKNOWN POWER Irp for Card %d.\n", 
				PRODUCT_NAME, pCard->CardNumber));
			status = STATUS_NOT_SUPPORTED;
			break;

	}

	PoStartNextPowerIrp(pIrp);
	IoSkipCurrentIrpStackLocation(pIrp);
	PoCallDriver(pCard->LowerDeviceObject, pIrp);

	return status;
}	// Spx_Card_FDO_DispatchPower


//////////////////////////////////////////////////////////////////////////////////////////
// Spx_CardSetSystemPowerState
//////////////////////////////////////////////////////////////////////////////////////////
NTSTATUS
Spx_CardSetSystemPowerState(IN PDEVICE_OBJECT pDevObject, IN PIRP pIrp)
{
	PCARD_DEVICE_EXTENSION	pCard		= pDevObject->DeviceExtension;
	NTSTATUS				status		= STATUS_SUCCESS;
	PIO_STACK_LOCATION		pIrpStack	= IoGetCurrentIrpStackLocation(pIrp);
	POWER_STATE				PowerState;

	PAGED_CODE();	// Macro in checked build to assert if pagable code is run at or above dispatch IRQL 

	SpxDbgMsg(SPX_TRACE_CALLS, ("%s: Entering Spx_CardSetSystemPowerState for Card %d.\n", 
		PRODUCT_NAME, pCard->CardNumber));

	switch (pIrpStack->Parameters.Power.State.SystemState) 
	{
		case PowerSystemUnspecified:
			PowerState.DeviceState = PowerDeviceUnspecified;
			PoRequestPowerIrp(pCard->PDO, IRP_MN_SET_POWER, PowerState, NULL, NULL, NULL);
			break;

        case PowerSystemWorking:
			PowerState.DeviceState = PowerDeviceD0;
			PoRequestPowerIrp(pCard->PDO, IRP_MN_SET_POWER, PowerState, NULL, NULL, NULL);
			break;	
				
        case PowerSystemSleeping1:
        case PowerSystemSleeping2:
        case PowerSystemSleeping3:
        case PowerSystemHibernate:
        case PowerSystemShutdown:
        case PowerSystemMaximum:
			PowerState.DeviceState = PowerDeviceD3;
			PoRequestPowerIrp(pCard->PDO, IRP_MN_SET_POWER, PowerState, NULL, NULL, NULL);
			break;

		default:
			break;
	}

	pIrp->IoStatus.Status = STATUS_SUCCESS;
	PoStartNextPowerIrp(pIrp);
	IoSkipCurrentIrpStackLocation(pIrp);
	PoCallDriver(pCard->LowerDeviceObject, pIrp);

	return status;
}	// Spx_CardSetSystemPowerState


//////////////////////////////////////////////////////////////////////////////////////////
// Spx_CardSetDevicePowerState
//////////////////////////////////////////////////////////////////////////////////////////
NTSTATUS
Spx_CardSetDevicePowerState(IN PDEVICE_OBJECT pDevObject, IN PIRP pIrp)
{
	PCARD_DEVICE_EXTENSION	pCard		= pDevObject->DeviceExtension;
	NTSTATUS				status		= STATUS_SUCCESS;
	PIO_STACK_LOCATION		pIrpStack	= IoGetCurrentIrpStackLocation(pIrp);

	PAGED_CODE();	// Macro in checked build to assert if pagable code is run at or above dispatch IRQL 

	SpxDbgMsg(SPX_TRACE_CALLS, ("%s: Entering Spx_CardSetDevicePowerState for Card %d.\n", 
		PRODUCT_NAME, pCard->CardNumber));

	switch(pIrpStack->Parameters.Power.State.DeviceState)
	{
	case PowerDeviceD0:
		SpxDbgMsg(SPX_TRACE_POWER_IRPS, ("%s: System requests Card %d goes into power state D0.\n", 
			PRODUCT_NAME, pCard->CardNumber));
		
		if(pCard->DeviceState == pIrpStack->Parameters.Power.State.DeviceState)
			SpxDbgMsg(SPX_TRACE_POWER_IRPS, ("%s: Card %d is already in power state D0.\n", 
				PRODUCT_NAME, pCard->CardNumber));
		else
			return Spx_CardSetPowerStateD0(pDevObject, pIrp);	// Switch ON

		break;

	case PowerDeviceD1:
		SpxDbgMsg(SPX_TRACE_POWER_IRPS, ("%s: System requests Card %d goes into power state D1.\n", 
			PRODUCT_NAME, pCard->CardNumber));

		if(pCard->DeviceState >= pIrpStack->Parameters.Power.State.DeviceState)
			SpxDbgMsg(SPX_TRACE_POWER_IRPS, ("%s: Card %d is already in power state D1 or lower.\n", 
				PRODUCT_NAME, pCard->CardNumber));
		else
			return Spx_CardSetPowerStateD3(pDevObject, pIrp);	// Switch OFF

		break;

	case PowerDeviceD2:
		SpxDbgMsg(SPX_TRACE_POWER_IRPS, ("%s: System requests Card %d goes into power state D2.\n", 
			PRODUCT_NAME, pCard->CardNumber));

		if(pCard->DeviceState >= pIrpStack->Parameters.Power.State.DeviceState)
			SpxDbgMsg(SPX_TRACE_POWER_IRPS, ("%s: Card %d is already in power state D2 or lower.\n", 
				PRODUCT_NAME, pCard->CardNumber));
		else
			return Spx_CardSetPowerStateD3(pDevObject, pIrp);	// Switch OFF

		break;

	case PowerDeviceD3:
		SpxDbgMsg(SPX_TRACE_POWER_IRPS, ("%s: System requests Card %d goes into power state D3.\n", 
			PRODUCT_NAME, pCard->CardNumber));

		if(pCard->DeviceState == pIrpStack->Parameters.Power.State.DeviceState)
			SpxDbgMsg(SPX_TRACE_POWER_IRPS, ("%s: Card %d is already in power state D3.\n", 
				PRODUCT_NAME, pCard->CardNumber));
		else
			return Spx_CardSetPowerStateD3(pDevObject, pIrp);	// Switch OFF

		break;

	default:
		break;

	}


	pIrp->IoStatus.Status = STATUS_SUCCESS;
	PoStartNextPowerIrp(pIrp);
	IoSkipCurrentIrpStackLocation(pIrp);
	PoCallDriver(pCard->LowerDeviceObject, pIrp);

	return status;
}	// Spx_CardSetDevicePowerState




//////////////////////////////////////////////////////////////////////////////////////////
// Spx_SetPowerStateD0 -  Sets power state D0 for Card - ON
//////////////////////////////////////////////////////////////////////////////////////////
NTSTATUS
Spx_CardSetPowerStateD0(IN PDEVICE_OBJECT pDevObject, IN PIRP pIrp)
{
	PIO_STACK_LOCATION		pIrpStack	= IoGetCurrentIrpStackLocation(pIrp);
	PCARD_DEVICE_EXTENSION	pCard		= pDevObject->DeviceExtension;
	NTSTATUS				status		= STATUS_SUCCESS;

	PAGED_CODE();	// Macro in checked build to assert if pagable code is run at or above dispatch IRQL 

	SpxDbgMsg(SPX_TRACE_CALLS, ("%s: Entering Spx_CardSetPowerStateD0 for Card %d.\n", 
		PRODUCT_NAME, pCard->CardNumber));

	status = Spx_PowerWaitForDriverBelow(pCard->LowerDeviceObject, pIrp);

	
#if DBG
	if(BREAK_ON_POWER_UP)
	{
		BREAK_ON_POWER_UP = FALSE;
	    KdPrint(("%s: Breaking debugger whilst powering up Card %d to debug after a hibernate\n", PRODUCT_NAME, pCard->CardNumber)); 
		DbgBreakPoint();
	}
#endif

	SetPnpPowerFlags(pCard, PPF_POWERED); 

	if(SPX_SUCCESS(pIrp->IoStatus.Status = XXX_CardPowerUp(pCard)))		// RESTORE HARDWARE STATE HERE & START CARD
	{
		// Inform Power Manager the of the new power state.
		PoSetPowerState(pDevObject, pIrpStack->Parameters.Power.Type, pIrpStack->Parameters.Power.State);

		pCard->DeviceState = PowerDeviceD0;	// Store new power state.
	}

	PoStartNextPowerIrp(pIrp);					// Ready for next power IRP.
	IoCompleteRequest(pIrp, IO_NO_INCREMENT);	// Complete current IRP.

	return status;
}	// Spx_SetPowerStateD0


//////////////////////////////////////////////////////////////////////////////////////////
// Spx_SetPowerStateD3 -  Sets power state D3 for Card - OFF
//////////////////////////////////////////////////////////////////////////////////////////
NTSTATUS
Spx_CardSetPowerStateD3(IN PDEVICE_OBJECT pDevObject, IN PIRP pIrp)
{
	PIO_STACK_LOCATION		pIrpStack	= IoGetCurrentIrpStackLocation(pIrp);
	PCARD_DEVICE_EXTENSION	pCard		= pDevObject->DeviceExtension;
	NTSTATUS				status		= STATUS_SUCCESS;

	PAGED_CODE();	// Macro in checked build to assert if pagable code is run at or above dispatch IRQL 

	SpxDbgMsg(SPX_TRACE_CALLS, ("%s: Entering Spx_CardSetPowerStateD3 for Card %d.\n", 
		PRODUCT_NAME, pCard->CardNumber));

	ClearPnpPowerFlags(pCard, PPF_POWERED);		

	if(SPX_SUCCESS(pIrp->IoStatus.Status	= XXX_CardPowerDown(pCard))) // SAVE HARDWARE STATE HERE & STOP CARD
	{
		// Inform Power Manager the of the new power state.
		PoSetPowerState(pDevObject, pIrpStack->Parameters.Power.Type, pIrpStack->Parameters.Power.State);

		pCard->DeviceState = PowerDeviceD3;		// Store new power state.
	}

	PoStartNextPowerIrp(pIrp);						// Ready for next power IRP.
	IoSkipCurrentIrpStackLocation(pIrp);
	PoCallDriver(pCard->LowerDeviceObject, pIrp);	// Pass IRP on down.

	return status;
}	// Spx_SetPowerStateD3







	
//////////////////////////////////////////////////////////////////////////////////////////
//
// Routine Description:
//	The power dispatch routine to handle power IRPs for port devices.
//
//	Arguments:
//		pPDO - pointer to a device object.
//		pIrp - pointer to an I/O request packet.
//
//	Return value:
//		NT status code.
//
//////////////////////////////////////////////////////////////////////////////////////////
NTSTATUS
Spx_Port_PDO_DispatchPower(IN PDEVICE_OBJECT pPDO, IN PIRP pIrp)
{
	PPORT_DEVICE_EXTENSION	pPort		= pPDO->DeviceExtension;
	NTSTATUS				status		= STATUS_SUCCESS;
	PIO_STACK_LOCATION		pIrpStack	= IoGetCurrentIrpStackLocation(pIrp);
	POWER_STATE				PowerState;

	PAGED_CODE();	// Macro in checked build to assert if pagable code is run at or above dispatch IRQL 

	switch (pIrpStack->MinorFunction) 
	{
    case IRP_MN_SET_POWER:
		{
			switch(pIrpStack->Parameters.Power.Type)
			{
			case SystemPowerState:
				SpxDbgMsg(SPX_TRACE_POWER_IRPS, ("%s: Got IRP_MN_SET_POWER Irp - Type SystemPowerState for Port %d.\n", 
					PRODUCT_NAME, pPort->PortNumber));
				return Spx_PortSetSystemPowerState(pPDO, pIrp);
				
			case DevicePowerState:
				SpxDbgMsg(SPX_TRACE_POWER_IRPS, ("%s: Got IRP_MN_SET_POWER Irp - Type DevicePowerState for Port %d.\n", 
					PRODUCT_NAME, pPort->PortNumber));
				return Spx_PortSetDevicePowerState(pPDO, pIrp);
			
			default:
				SpxDbgMsg(SPX_TRACE_POWER_IRPS, ("%s: Got IRP_MN_SET_POWER - Type 0x%02X Irp for Port %d.\n", 
					PRODUCT_NAME, pIrpStack->Parameters.Power.Type, pPort->PortNumber));

				status = STATUS_SUCCESS;
				pIrp->IoStatus.Status = status;
				break;
				
			}

			break;
		}

	case IRP_MN_QUERY_POWER:
		{
			switch(pIrpStack->Parameters.Power.Type)
			{
			case SystemPowerState:
				SpxDbgMsg(SPX_TRACE_POWER_IRPS, ("%s: Got IRP_MN_QUERY_POWER Irp - Type SystemPowerState for Port %d.\n", 
					PRODUCT_NAME, pPort->PortNumber));
				return Spx_PortQuerySystemPowerState(pPDO, pIrp);

			case DevicePowerState:
				SpxDbgMsg(SPX_TRACE_POWER_IRPS, ("%s: Got IRP_MN_QUERY_POWER Irp - Type DevicePowerState for Port %d.\n", 
					PRODUCT_NAME, pPort->PortNumber));

				switch(pIrpStack->Parameters.Power.State.DeviceState)
				{
				case PowerDeviceD0:
					SpxDbgMsg(SPX_TRACE_POWER_IRPS, ("%s: System is asking if Port %d can go to power state D0.\n", 
						PRODUCT_NAME, pPort->PortNumber));

					status = STATUS_SUCCESS;
					break;

				case PowerDeviceD1:
				case PowerDeviceD2:
				case PowerDeviceD3:
					SpxDbgMsg(SPX_TRACE_POWER_IRPS, ("%s: System is asking if Port %d can go to low power state D1, D2 or D3.\n", 
						PRODUCT_NAME, pPort->PortNumber));

					status = XXX_PortQueryPowerDown(pPort);
					break;

				default:
					status = STATUS_SUCCESS;
					break;
					
				}

				break;
			
			default:
				SpxDbgMsg(SPX_TRACE_POWER_IRPS, ("%s: Got IRP_MN_QUERY_POWER - Type 0x%02X Irp for Port %d.\n", 
					PRODUCT_NAME, pIrpStack->Parameters.Power.Type, pPort->PortNumber));
				break;
			}

			pIrp->IoStatus.Status = status;
			break;
		}
		
    case IRP_MN_WAIT_WAKE:
			SpxDbgMsg(SPX_TRACE_POWER_IRPS, ("%s: Got IRP_MN_WAIT_WAKE Irp for Port %d.\n", 
				PRODUCT_NAME, pPort->PortNumber));
			
			status = STATUS_NOT_SUPPORTED;
			pIrp->IoStatus.Status = status;
			break;

    case IRP_MN_POWER_SEQUENCE:
			SpxDbgMsg(SPX_TRACE_POWER_IRPS, ("%s: Got IRP_MN_POWER_SEQUENCE Irp for Port %d.\n", 
				PRODUCT_NAME, pPort->PortNumber));

			status = STATUS_NOT_IMPLEMENTED;
			pIrp->IoStatus.Status = status;
			break;

	default:
			SpxDbgMsg(SPX_TRACE_POWER_IRPS, ("%s: Got an UNKNOWN POWER Irp for Port %d.\n", 
				PRODUCT_NAME, pPort->PortNumber));

			status = STATUS_NOT_SUPPORTED;
			break;
	}

	PoStartNextPowerIrp(pIrp);
	IoCompleteRequest(pIrp, IO_NO_INCREMENT);	// Complete current IRP.

	return status;
}	// Spx_Port_PDO_DispatchPower


//////////////////////////////////////////////////////////////////////////////////////////
//	Spx_PortSetSystemPowerState													
//////////////////////////////////////////////////////////////////////////////////////////
NTSTATUS
Spx_PortSetSystemPowerState(IN PDEVICE_OBJECT pDevObject, IN PIRP pIrp)
{
	PPORT_DEVICE_EXTENSION	pPort		= pDevObject->DeviceExtension;
	NTSTATUS				status		= STATUS_SUCCESS;
	PIO_STACK_LOCATION		pIrpStack	= IoGetCurrentIrpStackLocation(pIrp);
	POWER_STATE				PowerState;

	PAGED_CODE();	// Macro in checked build to assert if pagable code is run at or above dispatch IRQL 

	SpxDbgMsg(SPX_TRACE_CALLS, ("%s: Entering Spx_PortSetSystemPowerState for Port %d.\n", 
		PRODUCT_NAME, pPort->PortNumber));

	switch (pIrpStack->Parameters.Power.State.SystemState) 
	{
		case PowerSystemUnspecified:
			PowerState.DeviceState = PowerDeviceUnspecified;
			PoRequestPowerIrp(pDevObject, IRP_MN_SET_POWER, PowerState, NULL, NULL, NULL);
			break;

        case PowerSystemWorking:
			PowerState.DeviceState = PowerDeviceD0;
			PoRequestPowerIrp(pDevObject, IRP_MN_SET_POWER, PowerState, NULL, NULL, NULL);
			break;	
				
        case PowerSystemSleeping1:
        case PowerSystemSleeping2:
        case PowerSystemSleeping3:
        case PowerSystemHibernate:
        case PowerSystemShutdown:
        case PowerSystemMaximum:
			PowerState.DeviceState = PowerDeviceD3;
			PoRequestPowerIrp(pDevObject, IRP_MN_SET_POWER, PowerState, NULL, NULL, NULL);
			break;

		default:
			break;
	}

	pIrp->IoStatus.Status = STATUS_SUCCESS;
	PoStartNextPowerIrp(pIrp);
	IoCompleteRequest(pIrp, IO_NO_INCREMENT);	// Complete current IRP.

	return status;
}	// Spx_PortSetSystemPowerState

//////////////////////////////////////////////////////////////////////////////////////////
//	Spx_PortQuerySystemPowerState													
//////////////////////////////////////////////////////////////////////////////////////////
NTSTATUS
Spx_PortQuerySystemPowerState(IN PDEVICE_OBJECT pDevObject, IN PIRP pIrp)
{
	PPORT_DEVICE_EXTENSION	pPort		= pDevObject->DeviceExtension;
	NTSTATUS				status		= STATUS_SUCCESS;
	PIO_STACK_LOCATION		pIrpStack	= IoGetCurrentIrpStackLocation(pIrp);
	POWER_STATE				PowerState;

	PAGED_CODE();	// Macro in checked build to assert if pagable code is run at or above dispatch IRQL 

	SpxDbgMsg(SPX_TRACE_CALLS, ("%s: Entering Spx_PortQuerySystemPowerState for Port %d.\n", 
		PRODUCT_NAME, pPort->PortNumber));

	switch (pIrpStack->Parameters.Power.State.SystemState) 
	{
		case PowerSystemUnspecified:
			PowerState.DeviceState = PowerDeviceUnspecified;
			PoRequestPowerIrp(pDevObject, IRP_MN_QUERY_POWER, PowerState, NULL, NULL, NULL);
			break;

        case PowerSystemWorking:
			PowerState.DeviceState = PowerDeviceD0;
			PoRequestPowerIrp(pDevObject, IRP_MN_QUERY_POWER, PowerState, NULL, NULL, NULL);
			break;	
				
        case PowerSystemSleeping1:
        case PowerSystemSleeping2:
        case PowerSystemSleeping3:
        case PowerSystemHibernate:
        case PowerSystemShutdown:
        case PowerSystemMaximum:
			PowerState.DeviceState = PowerDeviceD3;
			PoRequestPowerIrp(pDevObject, IRP_MN_QUERY_POWER, PowerState, NULL, NULL, NULL);
			break;

		default:
			break;
	}

	pIrp->IoStatus.Status = STATUS_SUCCESS;
	PoStartNextPowerIrp(pIrp);
	IoCompleteRequest(pIrp, IO_NO_INCREMENT);	// Complete current IRP.

	return status;
}	// Spx_PortQuerySystemPowerState



//////////////////////////////////////////////////////////////////////////////////////////
// Spx_PortSetDevicePowerState 
//////////////////////////////////////////////////////////////////////////////////////////
NTSTATUS
Spx_PortSetDevicePowerState(IN PDEVICE_OBJECT pDevObject, IN PIRP pIrp)
{
	PPORT_DEVICE_EXTENSION	pPort		= pDevObject->DeviceExtension;
	NTSTATUS				status		= STATUS_SUCCESS;
	PIO_STACK_LOCATION		pIrpStack	= IoGetCurrentIrpStackLocation(pIrp);

	PAGED_CODE();	// Macro in checked build to assert if pagable code is run at or above dispatch IRQL 

	SpxDbgMsg(SPX_TRACE_CALLS, ("%s: Entering Spx_PortSetDevicePowerState for Port %d.\n", 
		PRODUCT_NAME, pPort->PortNumber));

	switch(pIrpStack->Parameters.Power.State.DeviceState)
	{
	case PowerDeviceD0:
		SpxDbgMsg(SPX_TRACE_POWER_IRPS, ("%s: System requests Port %d goes into power state D0.\n", 
			PRODUCT_NAME, pPort->PortNumber));
		
		if(pPort->DeviceState == pIrpStack->Parameters.Power.State.DeviceState)
			SpxDbgMsg(SPX_TRACE_POWER_IRPS, ("%s: Port %d is already in power state D0.\n", 
				PRODUCT_NAME, pPort->PortNumber));
		else
			return Spx_PortSetPowerStateD0(pDevObject, pIrp);	// Switch ON

		break;

	case PowerDeviceD1:
		SpxDbgMsg(SPX_TRACE_POWER_IRPS, ("%s: System requests Port %d goes into power state D1.\n", 
			PRODUCT_NAME, pPort->PortNumber));

		if(pPort->DeviceState >= pIrpStack->Parameters.Power.State.DeviceState)
			SpxDbgMsg(SPX_TRACE_POWER_IRPS, ("%s: Port %d is already in power state D1 or lower.\n", 
				PRODUCT_NAME, pPort->PortNumber));
		else
			return Spx_PortSetPowerStateD3(pDevObject, pIrp);	// Switch OFF

		break;

	case PowerDeviceD2:
		SpxDbgMsg(SPX_TRACE_POWER_IRPS, ("%s: System requests Port %d goes into power state D2.\n", 
			PRODUCT_NAME, pPort->PortNumber));

		if(pPort->DeviceState >= pIrpStack->Parameters.Power.State.DeviceState)
			SpxDbgMsg(SPX_TRACE_POWER_IRPS, ("%s: Port %d is already in power state D2 or lower.\n", 
				PRODUCT_NAME, pPort->PortNumber));
		else
			return Spx_PortSetPowerStateD3(pDevObject, pIrp);	// Switch OFF

		break;

	case PowerDeviceD3:
		SpxDbgMsg(SPX_TRACE_POWER_IRPS, ("%s: System requests Port %d goes into power state D3.\n", 
			PRODUCT_NAME, pPort->PortNumber));

		if(pPort->DeviceState == pIrpStack->Parameters.Power.State.DeviceState)
			SpxDbgMsg(SPX_TRACE_POWER_IRPS, ("%s: Port %d is already in power state D3.\n", 
				PRODUCT_NAME, pPort->PortNumber));
		else
			return Spx_PortSetPowerStateD3(pDevObject, pIrp);	// Switch OFF

		break;

	default:
		break;

	}

	pIrp->IoStatus.Status = STATUS_SUCCESS;
	PoStartNextPowerIrp(pIrp);
	IoCompleteRequest(pIrp, IO_NO_INCREMENT);	// Complete current IRP.

	return status;
}	// Spx_PortSetDevicePowerState 


//////////////////////////////////////////////////////////////////////////////////////////
// Spx_PortSetPowerStateD0 -  Sets power state D0 for Port - ON
//////////////////////////////////////////////////////////////////////////////////////////
NTSTATUS
Spx_PortSetPowerStateD0(IN PDEVICE_OBJECT pDevObject, IN PIRP pIrp)
{
	PIO_STACK_LOCATION		pIrpStack	= IoGetCurrentIrpStackLocation(pIrp);
	PPORT_DEVICE_EXTENSION	pPort		= pDevObject->DeviceExtension;
	NTSTATUS				status		= STATUS_SUCCESS;

	PAGED_CODE();	// Macro in checked build to assert if pagable code is run at or above dispatch IRQL 

	SpxDbgMsg(SPX_TRACE_CALLS, ("%s: Entering Spx_PortSetPowerStateD0 for Port %d.\n", 
		PRODUCT_NAME, pPort->PortNumber));

	SetPnpPowerFlags(pPort, PPF_POWERED); 

	if(SPX_SUCCESS(pIrp->IoStatus.Status = XXX_PortPowerUp(pPort)))		// RESTORE HARDWARE STATE HERE & START PORT
	{
		// Inform Power Manager the of the new power state.
		PoSetPowerState(pDevObject, pIrpStack->Parameters.Power.Type, pIrpStack->Parameters.Power.State);

		pPort->DeviceState = PowerDeviceD0;	// Store new power state.
		Spx_UnstallIrps(pPort);				// Restart any queued IRPs (from a previous start)  
	}

	PoStartNextPowerIrp(pIrp);					// Ready for next power IRP.
	IoCompleteRequest(pIrp, IO_NO_INCREMENT);	// Complete current IRP.

	return status;
}	// Spx_PortSetPowerStateD0


//////////////////////////////////////////////////////////////////////////////////////////
// Spx_PortSetPowerStateD3 -  Sets power state D3 for Port - OFF
//////////////////////////////////////////////////////////////////////////////////////////
NTSTATUS
Spx_PortSetPowerStateD3(IN PDEVICE_OBJECT pDevObject, IN PIRP pIrp)
{
	PIO_STACK_LOCATION		pIrpStack	= IoGetCurrentIrpStackLocation(pIrp);
	PPORT_DEVICE_EXTENSION	pPort		= pDevObject->DeviceExtension;
	NTSTATUS				status		= STATUS_SUCCESS;

	PAGED_CODE();	// Macro in checked build to assert if pagable code is run at or above dispatch IRQL 

	SpxDbgMsg(SPX_TRACE_CALLS, ("%s: Entering Spx_PortSetPowerStateD3 for Port %d.\n", 
		PRODUCT_NAME, pPort->PortNumber));

	ClearPnpPowerFlags(pPort, PPF_POWERED); 

	if(SPX_SUCCESS(pIrp->IoStatus.Status = XXX_PortPowerDown(pPort)))	// SAVE HARDWARE STATE HERE & STOP PORT
	{   
		// Inform Power Manager the of the new power state. 
		PoSetPowerState(pDevObject, pIrpStack->Parameters.Power.Type, pIrpStack->Parameters.Power.State);
		pPort->DeviceState  = PowerDeviceD3;		// Store new power state.
	}

	PoStartNextPowerIrp(pIrp);					// Ready for next power IRP.
	IoCompleteRequest(pIrp, IO_NO_INCREMENT);	// Complete current IRP.

	return status;
}	// Spx_PortSetPowerStateD3



//////////////////////////////////////////////////////////////////////////////////////////
// Spx_PowerWaitForDriverBelow -  Waits for lower driver.
//////////////////////////////////////////////////////////////////////////////////////////
NTSTATUS 
Spx_PowerWaitForDriverBelow(IN PDEVICE_OBJECT pLowerDevObj, IN PIRP pIrp)
{
	KEVENT		EventWaitLowerDrivers;
	NTSTATUS	status;

	pIrp->IoStatus.Status = STATUS_SUCCESS;
	IoCopyCurrentIrpStackLocationToNext(pIrp);								// Copy parameters to the stack below 
	KeInitializeEvent(&EventWaitLowerDrivers, SynchronizationEvent, FALSE);	// Initialise event if need to wait 
	IoSetCompletionRoutine(pIrp, Spx_DispatchPnpPowerComplete, &EventWaitLowerDrivers, TRUE, TRUE, TRUE);

	if((status = PoCallDriver(pLowerDevObj, pIrp)) == STATUS_PENDING)
	{
		KeWaitForSingleObject(&EventWaitLowerDrivers, Executive, KernelMode, FALSE, NULL);
		status = pIrp->IoStatus.Status;
	}

	return(status);

} // Spx_PowerWaitForDriverBelow
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\spx\mps\sx\spx_wmi.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    wmi.c

Abstract:

    This module contains the code that handles the wmi IRPs for the
    serial driver.

Environment:

    Kernel mode

Revision History :
--*/

#include "precomp.h"


// Prototypes

NTSTATUS
SpxPort_WmiQueryRegInfo(IN PDEVICE_OBJECT pDevObject, OUT PULONG pRegFlags,
						OUT PUNICODE_STRING pInstanceName,
						OUT PUNICODE_STRING *pRegistryPath,
						OUT PUNICODE_STRING pMofResourceName,
						OUT PDEVICE_OBJECT *pPdo);
NTSTATUS
SpxPort_WmiQueryDataBlock(IN PDEVICE_OBJECT pDevObject, IN PIRP pIrp,
						  IN ULONG GuidIndex, IN ULONG InstanceIndex,
						  IN ULONG InstanceCount, IN OUT PULONG pInstanceLengthArray,
						  IN ULONG OutBufferSize, OUT PUCHAR pBuffer);
NTSTATUS
SpxPort_WmiSetDataBlock(IN PDEVICE_OBJECT pDevObject, IN PIRP pIrp,
						IN ULONG GuidIndex, IN ULONG InstanceIndex,
						IN ULONG BufferSize, IN PUCHAR pBuffer);

NTSTATUS
SpxPort_WmiSetDataItem(IN PDEVICE_OBJECT pDevObject, IN PIRP pIrp,
					   IN ULONG GuidIndex, IN ULONG InstanceIndex,
					   IN ULONG DataItemId, IN ULONG BufferSize,
					   IN PUCHAR pBuffer);

// End of prototypes.


#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, Spx_DispatchSystemControl)
#pragma alloc_text(PAGE, SpxPort_WmiInitializeWmilibContext)
#pragma alloc_text(PAGE, SpxPort_WmiQueryRegInfo)
#pragma alloc_text(PAGE, SpxPort_WmiQueryDataBlock)
#pragma alloc_text(PAGE, SpxPort_WmiSetDataBlock)
#pragma alloc_text(PAGE, SpxPort_WmiSetDataItem)
#endif




/********************************************************************************
********************								*****************************
********************	Spx_SystemControlDispatch	*****************************
********************								*****************************
********************************************************************************/
NTSTATUS
Spx_DispatchSystemControl(IN PDEVICE_OBJECT pDevObject, IN PIRP pIrp)
{
    PCOMMON_OBJECT_DATA		pCommonData = (PCOMMON_OBJECT_DATA) pDevObject->DeviceExtension;
    SYSCTL_IRP_DISPOSITION	IrpDisposition;
	PDEVICE_OBJECT			pLowerDevObj = pCommonData->LowerDeviceObject;
    NTSTATUS				status = pIrp->IoStatus.Status;

    PAGED_CODE();

	SpxDbgMsg(SPX_TRACE_CALLS,("%s: Entering Spx_DispatchSystemControl.\n", PRODUCT_NAME));

    status = WmiSystemControl(&pCommonData->WmiLibInfo, pDevObject, pIrp, &IrpDisposition);
                                 
    switch(IrpDisposition)
    {
        case IrpProcessed:
        {
            // This irp has been processed and may be completed or pending.
            break;
        }
        
        case IrpNotCompleted:
        {
            // This irp has not been completed, but has been fully processed, we will complete it now.
            IoCompleteRequest(pIrp, IO_NO_INCREMENT);                
            break;
        }
        
        case IrpForward:
        case IrpNotWmi:
        {
            // This irp is either not a WMI irp or is a WMI irp targetted at a device lower in the stack.

			if(pLowerDevObj)	// If we can pass the IRP down we must do so.
			{
				IoSkipCurrentIrpStackLocation(pIrp);
				status = IoCallDriver(pLowerDevObj, pIrp);
			}
			else	// Otherwise complete the IRP.
			{
				status = pIrp->IoStatus.Status;
				//pIrp->IoStatus.Information = 0;
				IoCompleteRequest(pIrp,IO_NO_INCREMENT);
			}

            break;
        }
                                    
        default:
        {
            // We really should never get here, but if we do just forward....
            ASSERT(FALSE);
			
			if(pLowerDevObj)	// If we can pass the IRP down we must do so.
			{
				IoSkipCurrentIrpStackLocation(pIrp);
				status = IoCallDriver(pLowerDevObj, pIrp);
			}
			else	// Otherwise complete the IRP.
			{
				status = pIrp->IoStatus.Status;
				//pIrp->IoStatus.Information = 0;
				IoCompleteRequest(pIrp,IO_NO_INCREMENT);
			}

            break;
        }        
    }
    
	return(status);
}







// End of prototypes.


#define WMI_SERIAL_PORT_NAME_INFORMATION 0
#define WMI_SERIAL_PORT_COMM_INFORMATION 1
#define WMI_SERIAL_PORT_HW_INFORMATION   2
#define WMI_SERIAL_PORT_PERF_INFORMATION 3
#define WMI_SERIAL_PORT_PROPERTIES       4

GUID StdSerialPortNameGuid				= SERIAL_PORT_WMI_NAME_GUID;			// Standard Serial WMI
GUID StdSerialPortCommGuid				= SERIAL_PORT_WMI_COMM_GUID;			// Standard Serial WMI
GUID StdSerialPortHWGuid				= SERIAL_PORT_WMI_HW_GUID;				// Standard Serial WMI
GUID StdSerialPortPerfGuid				= SERIAL_PORT_WMI_PERF_GUID;			// Standard Serial WMI
GUID StdSerialPortPropertiesGuid		= SERIAL_PORT_WMI_PROPERTIES_GUID;		// Standard Serial WMI

WMIGUIDREGINFO SpxPort_WmiGuidList[] =
{
    { &StdSerialPortNameGuid, 1, 0 },
    { &StdSerialPortCommGuid, 1, 0 },
    { &StdSerialPortHWGuid, 1, 0 },
    { &StdSerialPortPerfGuid, 1, 0 },
    { &StdSerialPortPropertiesGuid, 1, 0}
};


#define SpxPort_WmiGuidCount (sizeof(SpxPort_WmiGuidList) / sizeof(WMIGUIDREGINFO))




NTSTATUS
SpxPort_WmiInitializeWmilibContext(IN PWMILIB_CONTEXT WmilibContext)
/*++

Routine Description:

    This routine will initialize the wmilib context structure with the
    guid list and the pointers to the wmilib callback functions. This routine
    should be called before calling IoWmiRegistrationControl to register
    your device object.

Arguments:

    WmilibContext is pointer to the wmilib context.

Return Value:

    status

--*/
{
	PAGED_CODE();

    RtlZeroMemory(WmilibContext, sizeof(WMILIB_CONTEXT));
  
    WmilibContext->GuidCount			= SpxPort_WmiGuidCount;
    WmilibContext->GuidList				= SpxPort_WmiGuidList;    
    
    WmilibContext->QueryWmiRegInfo		= SpxPort_WmiQueryRegInfo;
    WmilibContext->QueryWmiDataBlock	= SpxPort_WmiQueryDataBlock;
    WmilibContext->SetWmiDataBlock		= SpxPort_WmiSetDataBlock;
    WmilibContext->SetWmiDataItem		= SpxPort_WmiSetDataItem;
	WmilibContext->ExecuteWmiMethod		= NULL;	
    WmilibContext->WmiFunctionControl	= NULL;	

    return(STATUS_SUCCESS);
}





//
// WMI System Call back functions
//


NTSTATUS
SpxPort_WmiQueryRegInfo(IN PDEVICE_OBJECT pDevObject, OUT PULONG pRegFlags,
						OUT PUNICODE_STRING pInstanceName,
						OUT PUNICODE_STRING *pRegistryPath,
						OUT PUNICODE_STRING MofResourceName,
						OUT PDEVICE_OBJECT *pPdo)
{
	NTSTATUS status = STATUS_SUCCESS;
	PPORT_DEVICE_EXTENSION pPort = (PPORT_DEVICE_EXTENSION)pDevObject->DeviceExtension;
   
	PAGED_CODE();

	*pRegFlags = WMIREG_FLAG_INSTANCE_PDO;
	*pRegistryPath = &SavedRegistryPath;
	*pPdo = pDevObject;  // Port device object is a PDO.


	return(status);
}





NTSTATUS
SpxPort_WmiQueryDataBlock(IN PDEVICE_OBJECT pDevObject, IN PIRP pIrp,
						  IN ULONG GuidIndex, IN ULONG InstanceIndex,
						  IN ULONG InstanceCount, IN OUT PULONG pInstanceLengthArray,
						  IN ULONG OutBufferSize, OUT PUCHAR pBuffer)
{
    PPORT_DEVICE_EXTENSION pPort = (PPORT_DEVICE_EXTENSION)pDevObject->DeviceExtension;
	NTSTATUS status;
    ULONG size = 0;

    PAGED_CODE();

    switch(GuidIndex) 
	{
    case WMI_SERIAL_PORT_NAME_INFORMATION:
		{
			size = pPort->DosName.Length;

			if(OutBufferSize < (size + sizeof(USHORT))) 
			{
				size += sizeof(USHORT);
				status = STATUS_BUFFER_TOO_SMALL;
				break;
			}

			if(pPort->DosName.Buffer == NULL) 
			{
				status = STATUS_INSUFFICIENT_RESOURCES;
				break;
			}

			// First, copy the string over containing our identifier
			*(USHORT *)pBuffer = (USHORT)size;
			(UCHAR *)pBuffer += sizeof(USHORT);

			RtlCopyMemory(pBuffer, pPort->DosName.Buffer, size);

			// Increment total size to include the WORD containing our len
			size += sizeof(USHORT);
			*pInstanceLengthArray = size;
                
			status = STATUS_SUCCESS;

			break;
		}

    case WMI_SERIAL_PORT_COMM_INFORMATION: 
		{
			size = sizeof(SERIAL_WMI_COMM_DATA);

			if(OutBufferSize < size) 
			{
				status = STATUS_BUFFER_TOO_SMALL;
				break;
			}

			*pInstanceLengthArray = size;
			*(PSERIAL_WMI_COMM_DATA)pBuffer = pPort->WmiCommData;

			status = STATUS_SUCCESS;

			break;
		}

    case WMI_SERIAL_PORT_HW_INFORMATION:
		{
			size = sizeof(SERIAL_WMI_HW_DATA);

			if(OutBufferSize < size) 
			{
				status = STATUS_BUFFER_TOO_SMALL;
				break;
			}

			*pInstanceLengthArray = size;
			*(PSERIAL_WMI_HW_DATA)pBuffer = pPort->WmiHwData;

			status = STATUS_SUCCESS;

			break;
		}

    case WMI_SERIAL_PORT_PERF_INFORMATION: 
		{
			size = sizeof(SERIAL_WMI_PERF_DATA);

			if(OutBufferSize < size) 
			{
				status = STATUS_BUFFER_TOO_SMALL;
				break;
			}

			*pInstanceLengthArray = size;
			*(PSERIAL_WMI_PERF_DATA)pBuffer = pPort->WmiPerfData;

			status = STATUS_SUCCESS;

			break;
		}

    case WMI_SERIAL_PORT_PROPERTIES: 
		{
			size = sizeof(SERIAL_COMMPROP) + sizeof(ULONG);

			if(OutBufferSize < size) 
			{
				status = STATUS_BUFFER_TOO_SMALL;
				break;
			}

			*pInstanceLengthArray = size;
			SerialGetProperties(pPort, (PSERIAL_COMMPROP)pBuffer);
       
			*((PULONG)(((PSERIAL_COMMPROP)pBuffer)->ProvChar)) = 0;

			status = STATUS_SUCCESS;

			break;
		}


	default:
		status = STATUS_WMI_GUID_NOT_FOUND;
		break;

    }

    status = WmiCompleteRequest(pDevObject, pIrp, status, size, IO_NO_INCREMENT);
	
	return(status);
}







NTSTATUS
SpxPort_WmiSetDataBlock(IN PDEVICE_OBJECT pDevObject, IN PIRP pIrp,
						IN ULONG GuidIndex, IN ULONG InstanceIndex,
						IN ULONG BufferSize, IN PUCHAR pBuffer)
{
    PPORT_DEVICE_EXTENSION pPort = (PPORT_DEVICE_EXTENSION)pDevObject->DeviceExtension;
	NTSTATUS status;
    ULONG size = 0;

	PAGED_CODE();

	switch(GuidIndex)
	{
	case WMI_SERIAL_PORT_NAME_INFORMATION:
	case WMI_SERIAL_PORT_COMM_INFORMATION:
	case WMI_SERIAL_PORT_HW_INFORMATION:
	case WMI_SERIAL_PORT_PERF_INFORMATION:
	case WMI_SERIAL_PORT_PROPERTIES:
		status = STATUS_WMI_READ_ONLY;		
		break;										


	default:
		status = STATUS_WMI_GUID_NOT_FOUND;
		break;
	}

    status = WmiCompleteRequest(pDevObject, pIrp, status, size, IO_NO_INCREMENT);
	
	return(status);
}





NTSTATUS
SpxPort_WmiSetDataItem(IN PDEVICE_OBJECT pDevObject, IN PIRP pIrp,
					   IN ULONG GuidIndex, IN ULONG InstanceIndex,
					   IN ULONG DataItemId, IN ULONG BufferSize,
					   IN PUCHAR pBuffer)
{
    PPORT_DEVICE_EXTENSION pPort = (PPORT_DEVICE_EXTENSION)pDevObject->DeviceExtension;
	NTSTATUS status;
    ULONG size = 0;

	PAGED_CODE();

	switch(GuidIndex)
	{
	case WMI_SERIAL_PORT_NAME_INFORMATION:
	case WMI_SERIAL_PORT_COMM_INFORMATION:
	case WMI_SERIAL_PORT_HW_INFORMATION:
	case WMI_SERIAL_PORT_PERF_INFORMATION:
	case WMI_SERIAL_PORT_PROPERTIES:
		status = STATUS_WMI_READ_ONLY;		
		break;										


	default:
		status = STATUS_WMI_GUID_NOT_FOUND;
		break;
	}

    status = WmiCompleteRequest(pDevObject, pIrp, status, size, IO_NO_INCREMENT);
	
	return(status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\spx\mps\sx\sx_iioc.c ===
/************************************************************************/
/*									*/
/*	Title		:	SX support functions for INTERNAL IOCTLs*/
/*									*/
/*	Author		:	N.P.Vassallo				*/
/*									*/
/*	Creation	:	14th October 1998			*/
/*									*/
/*	Version		:	1.0.0					*/
/*									*/
/*	Description	:	Support functions to support the	*/
/*				INTERNAL IOCTLs for specific hardware:	*/
/*					XXX_SetHandFlow			*/
/*									*/
/************************************************************************/

/* History...

1.0.0	14/20/98 NPV	Creation.

*/

#include "precomp.h"

/*****************************************************************************
*****************************                     ****************************
*****************************   XXX_SetHandFlow   ****************************
*****************************                     ****************************
******************************************************************************

prototype:	void	XXX_SetHandFlow(IN PPORT_DEVICE_EXTENSION pPort,IN SERIAL_IOCTL_SYNC *pS)

description:	Call to set the handshaking and flow control

parameters:	pPort points to the port device extension structure
		pS points to a serial ioctl synchronization structure

returns:	STATUS_SUCCESS

*/

void	XXX_SetHandFlow(IN PPORT_DEVICE_EXTENSION pPort,IN PSERIAL_IOCTL_SYNC pS)
{
	Slxos_SyncExec(pPort,SerialSetHandFlow,pS,0x0E);

} /* XXX_SetHandFlow */
                                                        
/* End of SX_IIOC.C */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\spx\mps\sx\sx_log.h ===
/*++

Copyright (c) 1998  Specialix International Ltd.

Abstract:

    Constant definitions for the I/O error code log values.

--*/

#ifndef SX_LOG_H
#define SX_LOG_H

//
//  Status values are 32 bit values layed out as follows:
//
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +---+-+-------------------------+-------------------------------+
//  |Sev|C|       Facility          |               Code            |
//  +---+-+-------------------------+-------------------------------+
//
//  where
//
//      Sev - is the severity code
//
//          00 - Success
//          01 - Informational
//          10 - Warning
//          11 - Error
//
//      C - is the Customer code flag
//
//      Facility - is the facility code
//
//      Code - is the facility's status code
//


//
//  Values are 32 bit values layed out as follows:
//
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +---+-+-+-----------------------+-------------------------------+
//  |Sev|C|R|     Facility          |               Code            |
//  +---+-+-+-----------------------+-------------------------------+
//
//  where
//
//      Sev - is the severity code
//
//          00 - Success
//          01 - Informational
//          10 - Warning
//          11 - Error
//
//      C - is the Customer code flag
//
//      R - is a reserved bit
//
//      Facility - is the facility code
//
//      Code - is the facility's status code
//
//
// Define the facility codes
//
#define FACILITY_SERIAL_ERROR_CODE       0x6
#define FACILITY_RPC_STUBS               0x3
#define FACILITY_RPC_RUNTIME             0x2
#define FACILITY_IO_ERROR_CODE           0x4


//
// Define the severity codes
//
#define STATUS_SEVERITY_WARNING          0x2
#define STATUS_SEVERITY_SUCCESS          0x0
#define STATUS_SEVERITY_INFORMATIONAL    0x1
#define STATUS_SEVERITY_ERROR            0x3


//
// MessageId: SPX_SEVERITY_SUCCESS
//
// MessageText:
//
//  %2
//
#define SPX_SEVERITY_SUCCESS             ((NTSTATUS)0x00060001L)

//
// MessageId: SPX_SEVERITY_INFORMATIONAL
//
// MessageText:
//
//  %2
//
#define SPX_SEVERITY_INFORMATIONAL       ((NTSTATUS)0x40060002L)

//
// MessageId: SPX_SEVERITY_WARNING
//
// MessageText:
//
//  %2
//
#define SPX_SEVERITY_WARNING             ((NTSTATUS)0x80060003L)

//
// MessageId: SPX_SEVERITY_ERROR
//
// MessageText:
//
//  %2
//
#define SPX_SEVERITY_ERROR               ((NTSTATUS)0xC0060004L)


#endif // End of SX_LOG.H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\spx\mps\sx\waitmask.c ===
/*++

Copyright (c) 1991, 1992, 1993 Microsoft Corporation

Module Name:

    waitmask.c

Abstract:

    This module contains the code that is very specific to get/set/wait
    on event mask operations in the serial driver

Author:

    Anthony V. Ercolano 26-Sep-1991

Environment:

    Kernel mode

Revision History :

--*/

#include "precomp.h"			/* Precompiled Headers */

BOOLEAN
SerialGrabWaitFromIsr(
    IN PVOID Context
    );

BOOLEAN
SerialGiveWaitToIsr(
    IN PVOID Context
    );

BOOLEAN
SerialFinishOldWait(
    IN PVOID Context
    );


NTSTATUS
SerialStartMask(
    IN PPORT_DEVICE_EXTENSION pPort
    )

/*++

Routine Description:

    This routine is used to process the set mask and wait
    mask ioctls.  Calls to this routine are serialized by
    placing irps in the list under the protection of the
    cancel spin lock.

Arguments:

    pPort - A pointer to the serial device extension.

Return Value:

    Will return pending for everything put the first
    request that we actually process.  Even in that
    case it will return pending unless it can complete
    it right away.


--*/

{

    //
    // The current stack location.  This contains much of the
    // information we need to process this particular request.
    //
    PIO_STACK_LOCATION IrpSp;

    PIRP NewIrp;

    BOOLEAN SetFirstStatus = FALSE;
    NTSTATUS FirstStatus;

    SpxDbgMsg(
        SERDIAG3,
        ("SERIAL: In SerialStartMask\n")
        );

    ASSERT(pPort->CurrentMaskIrp);

    do {

        SpxDbgMsg(
            SERDIAG4,
            ("SERIAL: STARMASK - CurrentMaskIrp: %x\n",pPort->CurrentMaskIrp)
            );
        IrpSp = IoGetCurrentIrpStackLocation(pPort->CurrentMaskIrp);

        ASSERT((IrpSp->Parameters.DeviceIoControl.IoControlCode ==
                IOCTL_SERIAL_WAIT_ON_MASK) ||
               (IrpSp->Parameters.DeviceIoControl.IoControlCode ==
                IOCTL_SERIAL_SET_WAIT_MASK));

        if (IrpSp->Parameters.DeviceIoControl.IoControlCode ==
            IOCTL_SERIAL_SET_WAIT_MASK) {

            SpxDbgMsg(
                SERDIAG4,
                ("SERIAL - %x is a SETMASK irp\n",pPort->CurrentMaskIrp)
                );

            //
            // Complete the old wait if there is one.
            //

	    Slxos_SyncExec(pPort,SerialFinishOldWait,pPort,0x1D);

            //
            // Any current waits should be on its way to completion
            // at this point.  There certainly shouldn't be any
            // irp mask location.
            //

            ASSERT(!pPort->IrpMaskLocation);

            pPort->CurrentMaskIrp->IoStatus.Status = STATUS_SUCCESS;

            if (!SetFirstStatus) {

                SpxDbgMsg(
                    SERDIAG4,
                    ("SERIAL: %x was the first irp processed by this\n"
                     "------- invocation of startmask\n",pPort->CurrentMaskIrp)
                    );
                FirstStatus = STATUS_SUCCESS;
                SetFirstStatus = TRUE;

            }

            //
            // The following call will also cause the current
            // call to be completed.
            //

            SerialGetNextIrp(pPort, &pPort->CurrentMaskIrp, &pPort->MaskQueue, &NewIrp, TRUE);
               
                
            SpxDbgMsg(
                SERDIAG4,
                ("SERIAL: Perhaps another mask irp was found in the queue\n"
                 "------- %x/%x <- values should be the same\n",
                 pPort->CurrentMaskIrp,NewIrp)
                );


        } else {

            //
            // First make sure that we have a non-zero mask.
            // If the app queues a wait on a zero mask it can't
            // be satisfied so it makes no sense to start it.
            //

            if ((!pPort->IsrWaitMask) || (pPort->CurrentWaitIrp)) {

                SpxDbgMsg(
                    SERDIAG4,
                    ("SERIAL: WaitIrp is invalid\n"
                     "------- IsrWaitMask: %x\n"
                     "------- CurrentWaitIrp: %x\n",
                     pPort->IsrWaitMask,
                     pPort->CurrentWaitIrp)
                    );

                pPort->CurrentMaskIrp->IoStatus.Status = STATUS_INVALID_PARAMETER;

                if (!SetFirstStatus) {

                    SpxDbgMsg(
                        SERDIAG4,
                        ("SERIAL: %x was the first irp processed by this\n"
                         "------- invocation of startmask\n",pPort->CurrentMaskIrp)
                        );
                    FirstStatus = STATUS_INVALID_PARAMETER;
                    SetFirstStatus = TRUE;

                }

                SerialGetNextIrp(pPort, &pPort->CurrentMaskIrp, &pPort->MaskQueue, &NewIrp, TRUE);
                    
                SpxDbgMsg(
                    SERDIAG4,
                    ("SERIAL: Perhaps another mask irp was found in the queue\n"
                     "------- %x/%x <- values should be the same\n",
                     pPort->CurrentMaskIrp,NewIrp)
                    );

            } else {

                KIRQL OldIrql;

                //
                // Make the current mask irp the current wait irp and
                // get a new current mask irp.  Note that when we get
                // the new current mask irp we DO NOT complete the
                // old current mask irp (which is now the current wait
                // irp.
                //
                // Then under the protection of the cancel spin lock
                // we check to see if the current wait irp needs to
                // be cancelled.
                //

                IoAcquireCancelSpinLock(&OldIrql);

                if (pPort->CurrentMaskIrp->Cancel) {

                    SpxDbgMsg(
                        SERDIAG4,
                        ("SERIAL: %x irp was already marked as cancelled\n",
                         pPort->CurrentMaskIrp)
                        );
                    IoReleaseCancelSpinLock(OldIrql);
                    pPort->CurrentMaskIrp->IoStatus.Status = STATUS_CANCELLED;

                    if (!SetFirstStatus) {

                        SpxDbgMsg(
                            SERDIAG4,
                            ("SERIAL: %x was the first irp processed by this\n"
                             "------- invocation of startmask\n",pPort->CurrentMaskIrp)
                            );
                        FirstStatus = STATUS_CANCELLED;
                        SetFirstStatus = TRUE;

                    }

                    SerialGetNextIrp(pPort, &pPort->CurrentMaskIrp, &pPort->MaskQueue, &NewIrp, TRUE);
                        
                    SpxDbgMsg(
                        SERDIAG4,
                        ("SERIAL: Perhaps another mask irp was found in the queue\n"
                         "------- %x/%x <- values should be the same\n",
                         pPort->CurrentMaskIrp,NewIrp)
                        );

                } else {

                    SpxDbgMsg(
                        SERDIAG4,
                        ("SERIAL: %x will become the current wait irp\n",
                         pPort->CurrentMaskIrp)
                        );
                    if (!SetFirstStatus) {

                        SpxDbgMsg(
                            SERDIAG4,
                            ("SERIAL: %x was the first irp processed by this\n"
                             "------- invocation of startmask\n",pPort->CurrentMaskIrp)
                            );
                        FirstStatus = STATUS_PENDING;
                        SetFirstStatus = TRUE;

                        //
                        // If we haven't already set a first status
                        // then there is a chance that this packet
                        // was never on the queue.  We should mark
                        // it as pending.
                        //

                        IoMarkIrpPending(pPort->CurrentMaskIrp);

                    }

                    //
                    // There should never be a mask location when
                    // there isn't a current wait irp.  At this point
                    // there shouldn't be a current wait irp also.
                    //

                    ASSERT(!pPort->IrpMaskLocation);
                    ASSERT(!pPort->CurrentWaitIrp);

                    pPort->CurrentWaitIrp = pPort->CurrentMaskIrp;
                    SERIAL_INIT_REFERENCE(pPort->CurrentWaitIrp);
                    IoSetCancelRoutine(
                        pPort->CurrentWaitIrp,
                        SerialCancelWait
                        );

                    //
                    // Since the cancel routine has a reference to the
                    // irp we need to update the reference count.
                    //

                    SERIAL_INC_REFERENCE(pPort->CurrentWaitIrp);

		    Slxos_SyncExec(pPort,SerialGiveWaitToIsr,pPort,0x1E);

                    IoReleaseCancelSpinLock(OldIrql);

                    SerialGetNextIrp(pPort, &pPort->CurrentMaskIrp, &pPort->MaskQueue, &NewIrp, FALSE);
                        
                    SpxDbgMsg(
                        SERDIAG4,
                        ("SERIAL: Perhaps another mask irp was found in the queue\n"
                         "------- %x/%x <- values should be the same\n",
                         pPort->CurrentMaskIrp,NewIrp)
                        );

                }

            }

        }

    } while (NewIrp);

    return FirstStatus;

}

BOOLEAN
SerialGrabWaitFromIsr(
    IN PVOID Context
    )

/*++

Routine Description:

    This routine will check to see if the ISR still knows about
    a wait irp by checking to see if the IrpMaskLocation is non-null.
    If it is then it will zero the IrpMaskLocation (which in effect
    grabs the irp away from the isr).  This routine is only called
    by the cancel code for the wait.

    NOTE: This is called by KeSynchronizeExecution.

Arguments:

    Context - A pointer to the device extension

Return Value:

    Always FALSE.

--*/

{

    PPORT_DEVICE_EXTENSION pPort = Context;

    SpxDbgMsg(
        SERDIAG3,
        ("SERIAL: In SerialGrabWaitFromIsr\n")
        );

    if (pPort->IrpMaskLocation) {

        SpxDbgMsg(
            SERDIAG4,
            ("SERIAL: The isr still owns the irp %x, mask location is %x\n"
             "------- and system buffer is %x\n",
             pPort->CurrentWaitIrp,pPort->IrpMaskLocation,
             pPort->CurrentWaitIrp->AssociatedIrp.SystemBuffer)
            );

        //
        // The isr still "owns" the irp.
        //

        *pPort->IrpMaskLocation = 0;
        pPort->IrpMaskLocation = NULL;

        pPort->CurrentWaitIrp->IoStatus.Information = sizeof(ULONG);

        //
        // Since the isr no longer references the irp we need to
        // decrement the reference count.
        //

        SERIAL_DEC_REFERENCE(pPort->CurrentWaitIrp);

    }

    return FALSE;
}

BOOLEAN
SerialGiveWaitToIsr(
    IN PVOID Context
    )

/*++

Routine Description:

    This routine simply sets a variable in the device extension
    so that the isr knows that we have a wait irp.

    NOTE: This is called by KeSynchronizeExecution.

    NOTE: This routine assumes that it is called with the
          cancel spinlock held.

Arguments:

    Context - Simply a pointer to the device extension.

Return Value:

    Always FALSE.

--*/

{

    PPORT_DEVICE_EXTENSION pPort = Context;

    SpxDbgMsg(
        SERDIAG3,
        ("SERIAL: In SerialGiveWaitToIsr\n")
        );
    //
    // There certainly shouldn't be a current mask location at
    // this point since we have a new current wait irp.
    //

    ASSERT(!pPort->IrpMaskLocation);

    //
    // The isr may or may not actually reference this irp.  It
    // won't if the wait can be satisfied immediately.  However,
    // since it will then go through the normal completion sequence,
    // we need to have an incremented reference count anyway.
    //

    SERIAL_INC_REFERENCE(pPort->CurrentWaitIrp);

    if (!pPort->HistoryMask) {

        SpxDbgMsg(
            SERDIAG4,
            ("SERIAL: No events occurred prior to the wait call\n")
            );

        //
        // Although this wait might not be for empty transmit
        // queue, it doesn't hurt anything to set it to false.
        //

        pPort->EmptiedTransmit = FALSE;

        //
        // Record where the "completion mask" should be set.
        //

        pPort->IrpMaskLocation =
            pPort->CurrentWaitIrp->AssociatedIrp.SystemBuffer;
        SpxDbgMsg(
            SERDIAG4,
            ("SERIAL: The isr owns the irp %x, mask location is %x\n"
             "------- and system buffer is %x\n",
             pPort->CurrentWaitIrp,pPort->IrpMaskLocation,
             pPort->CurrentWaitIrp->AssociatedIrp.SystemBuffer)
            );

    } else {

        SpxDbgMsg(
            SERDIAG4,
            ("SERIAL: %x occurred prior to the wait - starting the\n"
             "------- completion code for %x\n",
             pPort->HistoryMask,pPort->CurrentWaitIrp)
            );

        *((ULONG *)pPort->CurrentWaitIrp->AssociatedIrp.SystemBuffer) =
            pPort->HistoryMask;

        pPort->HistoryMask = 0;
        pPort->CurrentWaitIrp->IoStatus.Information = sizeof(ULONG);
        pPort->CurrentWaitIrp->IoStatus.Status = STATUS_SUCCESS;


        KeInsertQueueDpc(
            &pPort->CommWaitDpc,
            NULL,
            NULL
            );

    }

    return FALSE;
}

BOOLEAN
SerialFinishOldWait(
    IN PVOID Context
    )

/*++

Routine Description:

    This routine will check to see if the ISR still knows about
    a wait irp by checking to see if the Irpmasklocation is non-null.
    If it is then it will zero the Irpmasklocation (which in effect
    grabs the irp away from the isr).  This routine is only called
    buy the cancel code for the wait.

    NOTE: This is called by KeSynchronizeExecution.

Arguments:

    Context - A pointer to the device extension

Return Value:

    Always FALSE.

--*/

{

    PPORT_DEVICE_EXTENSION pPort = Context;

    SpxDbgMsg(
        SERDIAG3,
        ("SERIAL: In SerialFinishOldWait\n")
        );
    if (pPort->IrpMaskLocation) {

        SpxDbgMsg(
            SERDIAG4,
            ("SERIAL: The isr still owns the irp %x, mask location is %x\n"
             "------- and system buffer is %x\n",
             pPort->CurrentWaitIrp,pPort->IrpMaskLocation,
             pPort->CurrentWaitIrp->AssociatedIrp.SystemBuffer)
            );
        //
        // The isr still "owns" the irp.
        //

        *pPort->IrpMaskLocation = 0;
        pPort->IrpMaskLocation = NULL;

        pPort->CurrentWaitIrp->IoStatus.Information = sizeof(ULONG);

        //
        // We don't decrement the reference since the completion routine
        // will do that.
        //

        KeInsertQueueDpc(
            &pPort->CommWaitDpc,
            NULL,
            NULL
            );

    }

    //
    // Don't wipe out any historical data we are still interested in.
    //

    pPort->HistoryMask &= *((ULONG *)pPort->CurrentMaskIrp->
                                            AssociatedIrp.SystemBuffer);

    pPort->IsrWaitMask = *((ULONG *)pPort->CurrentMaskIrp->
                                            AssociatedIrp.SystemBuffer);
    SpxDbgMsg(
        SERDIAG4,
        ("SERIAL: Set mask location of %x, in irp %x, with system buffer of %x\n",
         pPort->IrpMaskLocation,
         pPort->CurrentMaskIrp,pPort->CurrentMaskIrp->AssociatedIrp.SystemBuffer)
        );
    return FALSE;
}

VOID
SerialCancelWait(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is used to cancel a irp that is waiting on
    a comm event.

Arguments:

    DeviceObject - Pointer to the device object for this device

    Irp - Pointer to the IRP for the current request

Return Value:

    None.

--*/

{

    PPORT_DEVICE_EXTENSION pPort = DeviceObject->DeviceExtension;

    SpxDbgMsg(
        SERDIAG3,
        ("SERIAL: In SerialCancelWait\n")
        );

    SpxDbgMsg(
        SERDIAG4,
        ("SERIAL: Canceling wait for irp %x\n",pPort->CurrentWaitIrp)
        );
    SerialTryToCompleteCurrent(
        pPort,
        SerialGrabWaitFromIsr,
        Irp->CancelIrql,
        STATUS_CANCELLED,
        &pPort->CurrentWaitIrp,
        NULL,
        NULL,
        NULL,
        NULL,
        NULL
        );

}

VOID
SerialCompleteWait(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemContext1,
    IN PVOID SystemContext2
    )

{

    PPORT_DEVICE_EXTENSION pPort = DeferredContext;
    KIRQL OldIrql;

    SpxDbgMsg(
        SERDIAG3,
        ("SERIAL: In SerialCompleteWait\n")
        );
    UNREFERENCED_PARAMETER(Dpc);
    UNREFERENCED_PARAMETER(SystemContext1);
    UNREFERENCED_PARAMETER(SystemContext2);

    IoAcquireCancelSpinLock(&OldIrql);

    SpxDbgMsg(
        SERDIAG4,
        ("SERIAL: Completing wait for irp %x\n",pPort->CurrentWaitIrp)
        );
    SerialTryToCompleteCurrent(
        pPort,
        NULL,
        OldIrql,
        STATUS_SUCCESS,
        &pPort->CurrentWaitIrp,
        NULL,
        NULL,
        NULL,
        NULL,
        NULL
        );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\spx\mps\sx\utils.c ===
/*++

Copyright (c) 1991, 1992, 1993 Microsoft Corporation

Module Name:

    utils.c

Abstract:

    This module contains code that perform queueing and completion
    manipulation on requests.

Author:

    Anthony V. Ercolano 26-Sep-1991

Environment:

    Kernel mode

Revision History :

--*/

#include "precomp.h"			/* Precompiled Headers */

VOID
SerialRundownIrpRefs(
    IN PIRP *CurrentOpIrp,
    IN PKTIMER IntervalTimer,
    IN PKTIMER TotalTimer
    );


VOID
SerialKillAllReadsOrWrites(
    IN PDEVICE_OBJECT DeviceObject,
    IN PLIST_ENTRY QueueToClean,
    IN PIRP *CurrentOpIrp
    )

/*++

Routine Description:

    This function is used to cancel all queued and the current irps
    for reads or for writes.

Arguments:

    DeviceObject - A pointer to the serial device object.

    QueueToClean - A pointer to the queue which we're going to clean out.

    CurrentOpIrp - Pointer to a pointer to the current irp.

Return Value:

    None.

--*/

{

    KIRQL cancelIrql;
    PDRIVER_CANCEL cancelRoutine;
    PPORT_DEVICE_EXTENSION pPort = DeviceObject->DeviceExtension;

    //
    // We acquire the cancel spin lock.  This will prevent the
    // irps from moving around.
    //

    IoAcquireCancelSpinLock(&cancelIrql);

    //
    // Clean the list from back to front.
    //

    while(!IsListEmpty(QueueToClean)) 
	{
        PIRP currentLastIrp = CONTAINING_RECORD(QueueToClean->Blink, IRP, Tail.Overlay.ListEntry);

        RemoveEntryList(QueueToClean->Blink);
		SpxIRPCounter(pPort, currentLastIrp, IRP_DEQUEUED);		// Decrement counter for performance stats.

        cancelRoutine = currentLastIrp->CancelRoutine;
        currentLastIrp->CancelIrql = cancelIrql;
        currentLastIrp->CancelRoutine = NULL;
        currentLastIrp->Cancel = TRUE;

        cancelRoutine(DeviceObject,currentLastIrp);

        IoAcquireCancelSpinLock(&cancelIrql);
    }

    //
    // The queue is clean.  Now go after the current if
    // it's there.
    //

    if(*CurrentOpIrp) 
	{
        cancelRoutine = (*CurrentOpIrp)->CancelRoutine;
        (*CurrentOpIrp)->Cancel = TRUE;

        //
        // If the current irp is not in a cancellable state
        // then it *will* try to enter one and the above
        // assignment will kill it.  If it already is in
        // a cancellable state then the following will kill it.
        //

        if(cancelRoutine) 
		{
            (*CurrentOpIrp)->CancelRoutine = NULL;
            (*CurrentOpIrp)->CancelIrql = cancelIrql;

            //
            // This irp is already in a cancellable state.  We simply
            // mark it as cancelled and call the cancel routine for
            // it.
            //

            cancelRoutine(DeviceObject, *CurrentOpIrp);
        } 
		else 
		{
            IoReleaseCancelSpinLock(cancelIrql);
        }

    } 
	else 
	{
        IoReleaseCancelSpinLock(cancelIrql);
    }

}

VOID
SerialGetNextIrp(
	IN PPORT_DEVICE_EXTENSION pPort,
    IN PIRP *CurrentOpIrp,
    IN PLIST_ENTRY QueueToProcess,
    OUT PIRP *NextIrp,
    IN BOOLEAN CompleteCurrent
    )

/*++

Routine Description:

    This function is used to make the head of the particular
    queue the current irp.  It also completes what was the old
    current irp if desired.

Arguments:

    CurrentOpIrp - Pointer to a pointer to the currently active
                   irp for the particular work list.  Note that
                   this item is not actually part of the list.

    QueueToProcess - The list to pull the new item off of.

    NextIrp - The next Irp to process.  Note that CurrentOpIrp
              will be set to this value under protection of the
              cancel spin lock.  However, if *NextIrp is NULL when
              this routine returns, it is not necessaryly true the
              what is pointed to by CurrentOpIrp will also be NULL.
              The reason for this is that if the queue is empty
              when we hold the cancel spin lock, a new irp may come
              in immediately after we release the lock.

    CompleteCurrent - If TRUE then this routine will complete the
                      irp pointed to by the pointer argument
                      CurrentOpIrp.

Return Value:

    None.

--*/

{

    PIRP oldIrp;
    KIRQL oldIrql;

    IoAcquireCancelSpinLock(&oldIrql);

    oldIrp = *CurrentOpIrp;

    if(CompleteCurrent) 
	{
        ASSERT(!oldIrp->CancelRoutine);
    }

    //
    // Check to see if there is a new irp to start up.
    //

    if (!IsListEmpty(QueueToProcess)) 
	{
        PLIST_ENTRY headOfList;

        headOfList = RemoveHeadList(QueueToProcess);

        *CurrentOpIrp = CONTAINING_RECORD(headOfList,IRP,Tail.Overlay.ListEntry);
		SpxIRPCounter(pPort, *CurrentOpIrp, IRP_DEQUEUED);		// Decrement counter for performance stats.

        IoSetCancelRoutine(*CurrentOpIrp,NULL);
    } 
	else 
	{
        *CurrentOpIrp = NULL;
    }

    *NextIrp = *CurrentOpIrp;
    IoReleaseCancelSpinLock(oldIrql);

    if(CompleteCurrent) 
	{
        SpxDbgMsg(SERIRPPATH,("SERIAL: Complete Irp: %x\n",oldIrp));
            
#ifdef	CHECK_COMPLETED
	DisplayCompletedIrp(oldIrp,12);
#endif
		SpxIRPCounter(pPort, oldIrp, IRP_COMPLETED);	// Increment counter for performance stats.
		IoCompleteRequest(oldIrp,IO_SERIAL_INCREMENT);

    }

}

VOID
SerialTryToCompleteCurrent(
    IN PPORT_DEVICE_EXTENSION pPort,
    IN PKSYNCHRONIZE_ROUTINE SynchRoutine OPTIONAL,
    IN KIRQL IrqlForRelease,
    IN NTSTATUS StatusToUse,
    IN PIRP *CurrentOpIrp,
    IN PLIST_ENTRY QueueToProcess OPTIONAL,
    IN PKTIMER IntervalTimer OPTIONAL,
    IN PKTIMER TotalTimer OPTIONAL,
    IN PSERIAL_START_ROUTINE Starter OPTIONAL,
    IN PSERIAL_GET_NEXT_ROUTINE GetNextIrp OPTIONAL
    )

/*++

Routine Description:

    This routine attempts to kill all of the reasons there are
    references on the current read/write.  If everything can be killed
    it will complete this read/write and try to start another.

    NOTE: This routine assumes that it is called with the cancel
          spinlock held.

Arguments:

    pPort - Simply a pointer to the device extension.

    SynchRoutine - A routine that will synchronize with the isr
                   and attempt to remove the knowledge of the
                   current irp from the isr.  NOTE: This pointer
                   can be null.

    IrqlForRelease - This routine is called with the cancel spinlock held.
                     This is the irql that was current when the cancel
                     spinlock was acquired.

    StatusToUse - The irp's status field will be set to this value, if
                  this routine can complete the irp.


Return Value:

    None.

--*/

{

    //
    // We can decrement the reference to "remove" the fact
    // that the caller no longer will be accessing this irp.
    //

    SERIAL_DEC_REFERENCE(*CurrentOpIrp);

    if(SynchRoutine) 
	{
		Slxos_SyncExec(pPort,SynchRoutine,pPort,0x1C);
    }

    //
    // Try to run down all other references to this irp.
    //

    SerialRundownIrpRefs(CurrentOpIrp,IntervalTimer,TotalTimer);
        
        

    //
    // See if the ref count is zero after trying to kill everybody else.
    //

    if(!SERIAL_REFERENCE_COUNT(*CurrentOpIrp)) 
	{
        PIRP newIrp;


        //
        // The ref count was zero so we should complete this
        // request.
        //
        // The following call will also cause the current irp to be
        // completed.
        //

        (*CurrentOpIrp)->IoStatus.Status = StatusToUse;

        if(StatusToUse == STATUS_CANCELLED) 
		{
            (*CurrentOpIrp)->IoStatus.Information = 0;
        }

        if(GetNextIrp) 
		{
            IoReleaseCancelSpinLock(IrqlForRelease);
            GetNextIrp(pPort, CurrentOpIrp, QueueToProcess, &newIrp, TRUE);
                

            if(newIrp) 
			{
                Starter(pPort);
            }

        } 
		else 
		{
            PIRP oldIrp = *CurrentOpIrp;

            //
            // There was no get next routine.  We will simply complete
            // the irp.  We should make sure that we null out the
            // pointer to the pointer to this irp.
            //

            *CurrentOpIrp = NULL;

            IoReleaseCancelSpinLock(IrqlForRelease);
            SpxDbgMsg(SERIRPPATH,("SERIAL: Complete Irp: %x\n",oldIrp));
                
                
                
#ifdef	CHECK_COMPLETED
	DisplayCompletedIrp(oldIrp,13);
#endif
			SpxIRPCounter(pPort, oldIrp, IRP_COMPLETED);	// Increment counter for performance stats.
            IoCompleteRequest(oldIrp, IO_SERIAL_INCREMENT);

        }

    } 
	else 
	{
        IoReleaseCancelSpinLock(IrqlForRelease);
    }

}
 
VOID
SerialRundownIrpRefs(
    IN PIRP *CurrentOpIrp,
    IN PKTIMER IntervalTimer OPTIONAL,
    IN PKTIMER TotalTimer OPTIONAL
    )

/*++

Routine Description:

    This routine runs through the various items that *could*
    have a reference to the current read/write.  It tries to kill
    the reason.  If it does succeed in killing the reason it
    will decrement the reference count on the irp.

    NOTE: This routine assumes that it is called with the cancel
          spin lock held.

Arguments:

    CurrentOpIrp - Pointer to a pointer to current irp for the
                   particular operation.

    IntervalTimer - Pointer to the interval timer for the operation.
                    NOTE: This could be null.

    TotalTimer - Pointer to the total timer for the operation.
                 NOTE: This could be null.

Return Value:

    None.

--*/


{

    //
    // This routine is called with the cancel spin lock held
    // so we know only one thread of execution can be in here
    // at one time.
    //

    //
    // First we see if there is still a cancel routine.  If
    // so then we can decrement the count by one.
    //

    if((*CurrentOpIrp)->CancelRoutine) 
	{
        SERIAL_DEC_REFERENCE(*CurrentOpIrp);

        IoSetCancelRoutine(*CurrentOpIrp, NULL);
    }

    if(IntervalTimer) 
	{
        //
        // Try to cancel the operations interval timer.  If the operation
        // returns true then the timer did have a reference to the
        // irp.  Since we've cancelled this timer that reference is
        // no longer valid and we can decrement the reference count.
        //
        // If the cancel returns false then this means either of two things:
        //
        // a) The timer has already fired.
        //
        // b) There never was an interval timer.
        //
        // In the case of "b" there is no need to decrement the reference
        // count since the "timer" never had a reference to it.
        //
        // In the case of "a", then the timer itself will be coming
        // along and decrement its reference.  Note that the caller
        // of this routine might actually be the this timer, but it
        // has already decremented the reference.
        //

        if(KeCancelTimer(IntervalTimer)) 
		{
            SERIAL_DEC_REFERENCE(*CurrentOpIrp);
        }

    }

    if(TotalTimer) 
	{

        //
        // Try to cancel the operations total timer.  If the operation
        // returns true then the timer did have a reference to the
        // irp.  Since we've cancelled this timer that reference is
        // no longer valid and we can decrement the reference count.
        //
        // If the cancel returns false then this means either of two things:
        //
        // a) The timer has already fired.
        //
        // b) There never was an total timer.
        //
        // In the case of "b" there is no need to decrement the reference
        // count since the "timer" never had a reference to it.
        //
        // In the case of "a", then the timer itself will be coming
        // along and decrement its reference.  Note that the caller
        // of this routine might actually be the this timer, but it
        // has already decremented the reference.
        //

        if(KeCancelTimer(TotalTimer)) 
		{

            SERIAL_DEC_REFERENCE(*CurrentOpIrp);

        }
    }

}

NTSTATUS
SerialStartOrQueue(
    IN PPORT_DEVICE_EXTENSION pPort,
    IN PIRP Irp,
    IN PLIST_ENTRY QueueToExamine,
    IN PIRP *CurrentOpIrp,
    IN PSERIAL_START_ROUTINE Starter
    )

/*++

Routine Description:

    This routine is used to either start or queue any requst
    that can be queued in the driver.

Arguments:

    pPort - Points to the serial device extension.

    Irp - The irp to either queue or start.  In either
          case the irp will be marked pending.

    QueueToExamine - The queue the irp will be place on if there
                     is already an operation in progress.

    CurrentOpIrp - Pointer to a pointer to the irp the is current
                   for the queue.  The pointer pointed to will be
                   set with to Irp if what CurrentOpIrp points to
                   is NULL.

    Starter - The routine to call if the queue is empty.

Return Value:

    This routine will return STATUS_PENDING if the queue is
    not empty.  Otherwise, it will return the status returned
    from the starter routine (or cancel, if the cancel bit is
    on in the irp).


--*/

{

    KIRQL oldIrql;
    PIO_STACK_LOCATION irpSp;

    IoAcquireCancelSpinLock(&oldIrql);

    irpSp = IoGetCurrentIrpStackLocation(Irp);

    //
    // If this is a write irp then take the amount of characters
    // to write and add it to the count of characters to write.
    //

    if(irpSp->MajorFunction == IRP_MJ_WRITE) 
	{
        pPort->TotalCharsQueued += irpSp->Parameters.Write.Length;

    } 
	else 
		if((irpSp->MajorFunction == IRP_MJ_DEVICE_CONTROL) 
			&& ((irpSp->Parameters.DeviceIoControl.IoControlCode == IOCTL_SERIAL_IMMEDIATE_CHAR) 
			|| (irpSp->Parameters.DeviceIoControl.IoControlCode == IOCTL_SERIAL_XOFF_COUNTER))) 
		{
	        pPort->TotalCharsQueued++;
	    }

    if((IsListEmpty(QueueToExamine)) && !(*CurrentOpIrp)) 
	{
        //
        // There were no current operation.  Mark this one as
        // current and start it up.
        //

        *CurrentOpIrp = Irp;

        IoReleaseCancelSpinLock(oldIrql);

        return Starter(pPort);

    } 
	else 
	{
        //
        // We don't know how long the irp will be in the
        // queue.  So we need to handle cancel.
        //

        if(Irp->Cancel) 
		{
            IoReleaseCancelSpinLock(oldIrql);

            Irp->IoStatus.Status = STATUS_CANCELLED;

            SpxDbgMsg(SERIRPPATH,("SERIAL: Complete Irp: %x\n",Irp));
                
                
#ifdef	CHECK_COMPLETED
	DisplayCompletedIrp(Irp,14);
#endif
			SpxIRPCounter(pPort, Irp, IRP_COMPLETED);	// Increment counter for performance stats.
            IoCompleteRequest(Irp,0);

            return STATUS_CANCELLED;

        } 
		else 
		{
            Irp->IoStatus.Status = STATUS_PENDING;
            IoMarkIrpPending(Irp);

            InsertTailList(QueueToExamine, &Irp->Tail.Overlay.ListEntry);
            IoSetCancelRoutine(Irp, SerialCancelQueued);

			SpxIRPCounter(pPort, Irp, IRP_QUEUED);	// Increment counter for performance stats.
            IoReleaseCancelSpinLock(oldIrql);

            return STATUS_PENDING;

        }

    }

}

VOID
SerialCancelQueued(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp
    )

/*++

Routine Description:

    This routine is used to cancel Irps that currently reside on
    a queue.

Arguments:

    DeviceObject - Pointer to the device object for this device

    Irp - Pointer to the IRP to be cancelled.

Return Value:

    None.

--*/

{

    PPORT_DEVICE_EXTENSION pPort = DeviceObject->DeviceExtension;
    PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation(Irp);

    Irp->IoStatus.Status = STATUS_CANCELLED;
    Irp->IoStatus.Information = 0;

    RemoveEntryList(&Irp->Tail.Overlay.ListEntry);
	SpxIRPCounter(pPort, Irp, IRP_DEQUEUED);	// Decrement counter for performance stats.

    //
    // If this is a write irp then take the amount of characters
    // to write and subtract it from the count of characters to write.
    //

    if(irpSp->MajorFunction == IRP_MJ_WRITE) 
	{
        pPort->TotalCharsQueued -= irpSp->Parameters.Write.Length;
    } 
	else 
		if(irpSp->MajorFunction == IRP_MJ_DEVICE_CONTROL) 
		{

        //
        // If it's an immediate then we need to decrement the
        // count of chars queued.  If it's a resize then we
        // need to deallocate the pool that we're passing on
        // to the "resizing" routine.
        //

			if((irpSp->Parameters.DeviceIoControl.IoControlCode == IOCTL_SERIAL_IMMEDIATE_CHAR) 
				 || (irpSp->Parameters.DeviceIoControl.IoControlCode == IOCTL_SERIAL_XOFF_COUNTER))
			{
				pPort->TotalCharsQueued--;
			} 
			else 
				if(irpSp->Parameters.DeviceIoControl.IoControlCode == IOCTL_SERIAL_SET_QUEUE_SIZE)
				{

					//
					// We shoved the pointer to the memory into the
					// the type 3 buffer pointer which we KNOW we
					// never use.
					//

					ASSERT(irpSp->Parameters.DeviceIoControl.Type3InputBuffer);

					SpxFreeMem(irpSp->Parameters.DeviceIoControl.Type3InputBuffer);

					irpSp->Parameters.DeviceIoControl.Type3InputBuffer = NULL;

				}

		}

    IoReleaseCancelSpinLock(Irp->CancelIrql);

    SpxDbgMsg(SERIRPPATH,("SERIAL: Complete Irp: %x\n",Irp));
        
#ifdef	CHECK_COMPLETED
	DisplayCompletedIrp(Irp,15);
#endif
	SpxIRPCounter(pPort, Irp, IRP_COMPLETED);	// Increment counter for performance stats.
    IoCompleteRequest(Irp,IO_SERIAL_INCREMENT);

}


NTSTATUS
SerialCompleteIfError(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp
    )

/*++

Routine Description:

    If the current irp is not an IOCTL_SERIAL_GET_COMMSTATUS request and
    there is an error and the application requested abort on errors,
    then cancel the irp.

Arguments:

    DeviceObject - Pointer to the device object for this device

    Irp - Pointer to the IRP to test.

Return Value:

    STATUS_SUCCESS or STATUS_CANCELLED.

--*/

{

    PPORT_DEVICE_EXTENSION pPort = DeviceObject->DeviceExtension;

    NTSTATUS status = STATUS_SUCCESS;

    if((pPort->HandFlow.ControlHandShake & SERIAL_ERROR_ABORT) && pPort->ErrorWord)
	{

        PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation(Irp);

        //
        // There is a current error in the driver.  No requests should
        // come through except for the GET_COMMSTATUS.
        //

        if((irpSp->MajorFunction != IRP_MJ_DEVICE_CONTROL) 
			|| (irpSp->Parameters.DeviceIoControl.IoControlCode != IOCTL_SERIAL_GET_COMMSTATUS)) 
		{

            status = STATUS_CANCELLED;
            Irp->IoStatus.Status = STATUS_CANCELLED;
            Irp->IoStatus.Information = 0;

            SpxDbgMsg(SERIRPPATH,("SERIAL: Complete Irp: %x\n",Irp));
                
#ifdef	CHECK_COMPLETED
	DisplayCompletedIrp(Irp,16);
#endif
			SpxIRPCounter(pPort, Irp, IRP_COMPLETED);	// Increment counter for performance stats.
            IoCompleteRequest(Irp,0);

        }

    }

    return status;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\spx\mps\sx\sx_pnp.c ===
/************************************************************************/
/*									*/
/*	Title		:	SX Plug and Play Functions		*/
/*									*/
/*	Author		:	N.P.Vassallo				*/
/*									*/
/*	Creation	:	21st September 1998			*/
/*									*/
/*	Version		:	1.0.0					*/
/*									*/
/*	Description	:	SX specfic Plug and Play Functions:	*/
/*					XXX_CardGetResources()		*/
/*					XXX_CardInit()			*/
/*					XXX_CardDeInit()		*/
/*					XXX_CardStart()			*/
/*					XXX_CardStop()			*/
/*					XXX_PortInit()			*/
/*					XXX_PortDeInit()		*/
/*					XXX_PortStart()			*/
/*					XXX_PortStop()			*/
/*									*/
/*					CardFindType()			*/
/*									*/
/************************************************************************/

/* History...

1.0.0	21/09/98 NPV	Creation.

*/

#include "precomp.h"


#define FILE_ID		SX_PNP_C		// File ID for Event Logging see SX_DEFS.H for values.


/*****************************************************************************
*******************************                *******************************
*******************************   Prototypes   *******************************
*******************************                *******************************
*****************************************************************************/

BOOLEAN	CheckMemoryWindow(IN PCARD_DEVICE_EXTENSION pCard);

#ifdef	ALLOC_PRAGMA
#pragma alloc_text (PAGE, CheckMemoryWindow)
#endif

/*****************************************************************************
**************************                          **************************
**************************   XXX_CardGetResources   **************************
**************************                          **************************
******************************************************************************

prototype:		NTSTATUS XXX_CardGetResources(	IN PDEVICE_OBJECT pDevObject, 
												IN PCM_RESOURCE_LIST pResList,
												IN PCM_RESOURCE_LIST pTrResList)

description:	Interpret the raw and translated resources and store in the device extension structure
				of the specified device object.

parameters:		pDevObject points to the card device object structure
				pResList points to the raw resource list
				pTrResList points to the translated resource list

returns:		STATUS_SUCCESS

*/

NTSTATUS XXX_CardGetResources(	IN PDEVICE_OBJECT pDevObject, 
								IN PCM_RESOURCE_LIST pResList,
								IN PCM_RESOURCE_LIST pTrResList)
{
	PCARD_DEVICE_EXTENSION			pCard = pDevObject->DeviceExtension;
	PCM_FULL_RESOURCE_DESCRIPTOR	pFullResourceDesc = NULL;
	PCM_PARTIAL_RESOURCE_LIST		pPartialResourceList;
	PCM_PARTIAL_RESOURCE_DESCRIPTOR	pPartialResourceDesc;

	CHAR szErrorMsg[MAX_ERROR_LOG_INSERT];	// Limited to 51 characters + 1 null 
	NTSTATUS	status = STATUS_NOT_IMPLEMENTED;
	ULONG		count, loop;

	SpxDbgMsg(SPX_TRACE_CALLS,("%s: Entering CardGetResources\n", PRODUCT_NAME));
	SpxDbgMsg(SPX_MISC_DBG,("%s: Resource pointer is 0x%X\n", PRODUCT_NAME,pResList));
	SpxDbgMsg(SPX_MISC_DBG,("%s: Translated resource pointer is 0x%X\n", PRODUCT_NAME, pTrResList));

// Check that the resource lists are valid... 
	if((pResList == NULL)||(pTrResList == NULL))	// Do the resource lists exist?
	{	// No 					
		ASSERT(pResList != NULL);
		ASSERT(pTrResList != NULL);

		sprintf(szErrorMsg, "Card %d has been given no resources.", pCard->CardNumber);
		
		Spx_LogMessage(	STATUS_SEVERITY_ERROR,
						pCard->DriverObject,	// Driver Object
						pCard->DeviceObject,	// Device Object (Optional)
						PhysicalZero,			// Physical Address 1
						PhysicalZero,			// Physical Address 2
						0,						// SequenceNumber
						0,						// Major Function Code
						0,						// RetryCount
						FILE_ID | __LINE__,		// UniqueErrorValue
						STATUS_SUCCESS,			// FinalStatus
						szErrorMsg);			// Error Message

		return(STATUS_INSUFFICIENT_RESOURCES);
	}

	ASSERT(pResList->Count >= 1);			// Should be at least one resource
	ASSERT(pTrResList->Count >= 1);			// for raw and translated 

	// Find out the card type... 
	if((pCard->CardType = SpxGetNtCardType(pCard->DeviceObject)) == -1)
	{
		sprintf(szErrorMsg, "Card %d is unrecognised.", pCard->CardNumber);

		Spx_LogMessage(	STATUS_SEVERITY_ERROR,
						pCard->DriverObject,			// Driver Object
						pCard->DeviceObject,			// Device Object (Optional)
						PhysicalZero,					// Physical Address 1
						PhysicalZero,					// Physical Address 2
						0,								// SequenceNumber
						0,								// Major Function Code
						0,								// RetryCount
						FILE_ID | __LINE__,				// UniqueErrorValue
						STATUS_SUCCESS,					// FinalStatus
						szErrorMsg);					// Error Message


		return(STATUS_DEVICE_DOES_NOT_EXIST);
	}


// Process the raw resource list...
	if(pFullResourceDesc = &pResList->List[0])	// Point to raw resource list
	{
		pPartialResourceList = &pFullResourceDesc->PartialResourceList;
		pPartialResourceDesc = pPartialResourceList->PartialDescriptors;
		count = pPartialResourceList->Count;	// number of partial resource descriptors 

		pCard->InterfaceType = pFullResourceDesc->InterfaceType;	// Bus type
		pCard->BusNumber = pFullResourceDesc->BusNumber;			// Bus number 

		for(loop = 0; loop < count; loop++, pPartialResourceDesc++)
		{
			switch(pPartialResourceDesc->Type)
			{
			case CmResourceTypeMemory:		// Memory resource
				pCard->RawPhysAddr = pPartialResourceDesc->u.Memory.Start;
				break;

			case CmResourceTypePort:		// I/O resource
				break;

			case CmResourceTypeInterrupt:
				pCard->OriginalIrql = pPartialResourceDesc->u.Interrupt.Level;
				pCard->OriginalVector = pPartialResourceDesc->u.Interrupt.Vector;
				pCard->ProcessorAffinity = pPartialResourceDesc->u.Interrupt.Affinity;
				break;

			default:
				break;
			}
		}

	} // Raw Descriptors 


// Process the translated resource list... 
	if(pFullResourceDesc = &pTrResList->List[0])	// Point to translated resource list
	{
		pPartialResourceList = &pFullResourceDesc->PartialResourceList;
		pPartialResourceDesc = pPartialResourceList->PartialDescriptors;
		count = pPartialResourceList->Count;		// number of partial resource descriptors 

		pCard->InterfaceType = pFullResourceDesc->InterfaceType;	// Bus type 
		pCard->BusNumber = pFullResourceDesc->BusNumber;			// Bus number 

		for(loop = 0; loop < count; loop++, pPartialResourceDesc++)
		{
			switch(pPartialResourceDesc->Type)
			{
			case CmResourceTypeMemory:		// Memory resource
				{
					if(pPartialResourceDesc->u.Memory.Length == 0x80)	// Must be config space 
					{
						pCard->PCIConfigRegisters = pPartialResourceDesc->u.Memory.Start;
						pCard->SpanOfPCIConfigRegisters = pPartialResourceDesc->u.Memory.Length;
					}
					else
					{
						pCard->PhysAddr = pPartialResourceDesc->u.Memory.Start;
						pCard->SpanOfController = pPartialResourceDesc->u.Memory.Length;
					}
					break;
				}

			case CmResourceTypePort:		// I/O resource
				break;

			case CmResourceTypeInterrupt:
				pCard->TrIrql = (KIRQL)pPartialResourceDesc->u.Interrupt.Level;
				pCard->TrVector = pPartialResourceDesc->u.Interrupt.Vector;
				pCard->ProcessorAffinity = pPartialResourceDesc->u.Interrupt.Affinity;
				pCard->PolledMode = 0;		// Switch off polled mode 
				break;

			default:
				break;
			}
		}

	} // Translated Descriptors 

	return(STATUS_SUCCESS);

} // End XXX_CardGetResources. 

/*****************************************************************************
******************************                  ******************************
******************************   XXX_CardInit   ******************************
******************************                  ******************************
******************************************************************************

prototype:		NTSTATUS XXX_CardInit(IN PCARD_DEVICE_EXTENSION pCard)

description:	Initialise non-hardware fields of the card extension to a known state

parameters:		pCard points to the CARD_DEVICE_EXTENSION structure

returns:		STATUS_SUCCESS

*/

NTSTATUS XXX_CardInit(IN PCARD_DEVICE_EXTENSION pCard)
{
	NTSTATUS	status = STATUS_SUCCESS;

	SpxDbgMsg(SPX_TRACE_CALLS,("%s: Entering XXX_CardInit\n", PRODUCT_NAME));

	pCard->PolledMode = 1;					// Poll by default 
	pCard->InterruptMode = Latched;			// Default interrupt mode 
	pCard->InterruptShareable = FALSE;		// Default interrupt share mode 
	pCard->OurIsr = SerialISR;				// Interrupt Service Routine 
	pCard->OurIsrContext = pCard;			// ISR data context 

	// Initialise spinlock for the DPC... 
	KeInitializeSpinLock(&pCard->DpcLock);		// Initialise DPC lock for the card 
	pCard->DpcFlag = FALSE;						// Initialise DPC ownership for this card 

	return(status);

} // End XXX_CardInit.

/*****************************************************************************
*****************************                    *****************************
*****************************   XXX_CardDeInit   *****************************
*****************************                    *****************************
******************************************************************************

prototype:		NTSTATUS XXX_CardDeInit(IN PCARD_DEVICE_EXTENSION pCard)

description:	De-Initialise any non-hardware allocations made during XXX_CardInit

parameters:		pCard points to the CARD_DEVICE_EXTENSION structure

returns:		STATUS_SUCCESS

*/

NTSTATUS XXX_CardDeInit(IN PCARD_DEVICE_EXTENSION pCard)
{
	NTSTATUS	status = STATUS_SUCCESS;

	SpxDbgMsg(SPX_TRACE_CALLS,("%s: Entering XXX_CardDeInit\n",PRODUCT_NAME));

	return(status);

} // End XXX_CardDeInit.

/*****************************************************************************
******************************                  ******************************
******************************   CardFindType   ******************************
******************************                  ******************************
******************************************************************************

prototype:		BOOLEAN	CheckMemoryWindow(IN PCARD_DEVICE_EXTENSION pCard)

description:	Perform checking where possible on memory window.

parameters:		pCard points to a card device extension structure with following entries:
				BaseController points to valid virtual address for shared memory window

returns:		FALSE to recognise card at memory loaction
				TRUE SUCCESS
*/

BOOLEAN	CheckMemoryWindow(IN PCARD_DEVICE_EXTENSION pCard)
{
	_u32	offset;
	pu8		pAddr;
	_u8		*cp;
	BOOLEAN	CardPresent;

	SpxDbgMsg(SPX_TRACE_CALLS,("%s: Entering CardFindType\n", PRODUCT_NAME));
	SpxDbgMsg(SPX_MISC_DBG,("%s: pCard->PhysAddr = 0x%08lX\n", PRODUCT_NAME, pCard->PhysAddr));
	SpxDbgMsg(SPX_MISC_DBG,("%s: pCard->BaseController = 0x%08lX\n", PRODUCT_NAME, pCard->BaseController));

	pAddr = pCard->BaseController;		// Point to base of memory window 

	switch(pCard->CardType)
	{
	case SiHost_1:	// ISA card phase 1
		{
            pAddr[0x8000] = 0;
            for(offset = 0; offset < 0x8000; offset++)
                pAddr[offset] = 0;

            for(offset = 0; offset < 0x8000; offset++) 
			{
                if(pAddr[offset] != 0) 
                    return FALSE;
            }

            for(offset = 0; offset < 0x8000; offset++) 
                pAddr[offset] = 0xff;

            for(offset = 0; offset < 0x8000; offset++) 
			{
                if(pAddr[offset] != 0xff) 
                    return FALSE;
            }

            return TRUE;

		}

	case SiHost_2:	// SI/XIO ISA card phase 2
		{
			// Examine memory window for SI2 ISA signature... 
			CardPresent = TRUE;		// Assume card is there 
			for(offset=SI2_ISA_ID_BASE; offset<SI2_ISA_ID_BASE+8; offset++)
			{
				if((pAddr[offset]&0x7) != ((_u8)(~offset)&0x7)) 
					CardPresent = FALSE;
			}

			if(CardPresent)
				return TRUE;	// Card is present

			break;
		}

	case SiPCI:		// SI/XIO PCI card
		{
			if(pCard->SpanOfController == SI2_PCI_WINDOW_LEN)	// Only card with this memory window size 
				return TRUE;

			break;
		}

	case Si3Isa:	// SX ISA card
	case Si3Pci:	// SX PCI card
		{
			// Examine memory window for SX VPD PROM contents... 
			CardPresent = TRUE;						// Assume card is present
			offset = SX_VPD_ROM|2*SX_VPD_IDENT;		// Offset of ID string 
			for(cp = SX_VPD_IDENT_STRING;*cp != '\0';++cp)
			{
				if(pAddr[offset] != *cp) 
					CardPresent = FALSE;	// Mismatch 

				offset += 2;
			}

			if(CardPresent)				// Found an SX card 
			{
				// Set SX Unique Id
				pCard->UniqueId = (pAddr[SX_VPD_ROM+SX_VPD_UNIQUEID1*2]<<24)
								+ (pAddr[SX_VPD_ROM+SX_VPD_UNIQUEID2*2]<<16)
								+ (pAddr[SX_VPD_ROM+SX_VPD_UNIQUEID3*2]<<8)
								+ (pAddr[SX_VPD_ROM+SX_VPD_UNIQUEID4*2]);

				if(pCard->CardType == Si3Isa)	// SX ISA card 
				{
					if((pAddr[SX_VPD_ROM+SX_VPD_UNIQUEID1*2]&SX_UNIQUEID_MASK) == SX_ISA_UNIQUEID1)
						return TRUE;
				}

				if(pCard->CardType == Si3Pci)	// SX PCI card 
				{
					if((pAddr[SX_VPD_ROM+SX_VPD_UNIQUEID1*2]&SX_UNIQUEID_MASK) == SX_PCI_UNIQUEID1)
						return TRUE;
				}
			}

			break;
		}

	case Si_2:		// MCA card
	case SiEisa:	// EISA card
	case SxPlusPci:	// SX+ PCI card
		return TRUE;
	}

	SpxDbgMsg(SPX_MISC_DBG,("%s: Card not at memory location or card type is not recognised.\n", PRODUCT_NAME));

	return FALSE;	// Check Failed

} // End CheckMemoryWindow.

/*****************************************************************************
*****************************                   ******************************
*****************************   XXX_CardStart   ******************************
*****************************                   ******************************
******************************************************************************

prototype:		NTSTATUS XXX_CardStart(IN PCARD_DEVICE_EXTENSION pCard)

description:	Start card operations:
				map in memory
				initialise hardware
				initialise interrupts/polling
				start interrupts/polling

parameters:		pCard points to the CARD_DEVICE_EXTENSION structure

returns:		STATUS_SUCCESS

*/

NTSTATUS XXX_CardStart(IN PCARD_DEVICE_EXTENSION pCard)
{

	NTSTATUS status = STATUS_SUCCESS;
	CHAR szErrorMsg[MAX_ERROR_LOG_INSERT];	// Limited to 51 characters + 1 null 
	int SlxosStatus = SUCCESS;
	BOOLEAN bInterruptConnnected = FALSE;

	SpxDbgMsg(SPX_TRACE_CALLS,("%s: Entering XXX_CardStart\n", PRODUCT_NAME));


// Map in the virtual memory address... 
	pCard->BaseController = MmMapIoSpace(pCard->PhysAddr, pCard->SpanOfController, FALSE);

	if(!pCard->BaseController)
	{
		status = STATUS_INSUFFICIENT_RESOURCES;
		goto Error;
	}


	if(pCard->CardType == Si3Pci)
	{
		if(!SPX_SUCCESS(status = PLX_9050_CNTRL_REG_FIX(pCard)))	// Apply PLX9050 fix 
			goto Error;
	}

	if(!CheckMemoryWindow(pCard))	// Check if card is present at memory location.
	{
		status = STATUS_UNSUCCESSFUL;
		goto Error;
	}

	if(pCard->CardType == SiPCI)				// SI/XIO PCI card? 
		pCard->PolledMode = 1;					// Yes, polled mode only

	pCard->Controller = pCard->BaseController;	// Default 

	if(pCard->CardType == SxPlusPci)	
		pCard->Controller = pCard->BaseController + pCard->SpanOfController/2 - SX_WINDOW_LEN;


	ResetBoardInt(pCard);				// Reset the board interrupt to prevent problems when sharing 

// Set up interrupt mode, if not possible, switch to polled... 

	if(!(pCard->PolledMode))				// Set up interrupt mode 
	{	
		// MCA and PCI card interrupts 	
		if((pCard->InterfaceType == MicroChannel) || (pCard->InterfaceType == PCIBus))		
		{
			pCard->InterruptMode = LevelSensitive;	// are level sensitive and 
			pCard->InterruptShareable = TRUE;		// can share interrupts 
		}

		// Try to connect to interrupt.
		if(SPX_SUCCESS(status = IoConnectInterrupt(	&pCard->Interrupt,			// Interrupt object
													pCard->OurIsr,				// Service routine  
													pCard->OurIsrContext,		// Service context 
													NULL,						// SpinLock (optional) 
													pCard->TrVector,			// Vector 
													pCard->TrIrql,				// IRQL 
													pCard->TrIrql,				// Synchronize IRQL
													pCard->InterruptMode,		// Mode (Latched/Level Sensitive) 
													pCard->InterruptShareable,	// Sharing mode 
													pCard->ProcessorAffinity,	// Processors to handle ints 
													FALSE)))					// Floating point save 	
		{						
			IoInitializeDpcRequest(pCard->DeviceObject, Slxos_IsrDpc);	// Initialise DPC
			bInterruptConnnected = TRUE;	// Set Interrupt Connected flag. 
		}
		else
		{	
			// Tell user the problem 
			sprintf(szErrorMsg, "Card at %08X%08X: Interrupt unavailable, Polling.", pCard->PhysAddr.HighPart, pCard->PhysAddr.LowPart);

			Spx_LogMessage(	STATUS_SEVERITY_ERROR,
							pCard->DriverObject,		// Driver Object
							pCard->DeviceObject,		// Device Object (Optional)
							PhysicalZero,				// Physical Address 1
							PhysicalZero,				// Physical Address 2
							0,							// SequenceNumber
							0,							// Major Function Code
							0,							// RetryCount
							FILE_ID | __LINE__,			// UniqueErrorValue
							STATUS_SUCCESS,				// FinalStatus
							szErrorMsg);				// Error Message

			pCard->PolledMode = 1;			// No interrupt, poll instead 
		}
	}



	SlxosStatus = Slxos_ResetBoard(pCard);		// Reset the card and start download 
	
	if(SlxosStatus != SUCCESS)	
	{
		status = STATUS_UNSUCCESSFUL;		// Error 
		goto Error;
	}

// Set up polled mode operation and Start timer with a period of 10ms (100Hz)...

	if(pCard->PolledMode)	// Set up polled mode 
	{
		LARGE_INTEGER	PolledPeriod;

		KeInitializeTimer(&pCard->PolledModeTimer);
		KeInitializeDpc(&pCard->PolledModeDpc, Slxos_PolledDpc, pCard);
		PolledPeriod.QuadPart = -100000;		// 100,000*100nS = 10mS 
		KeSetTimer(&pCard->PolledModeTimer, PolledPeriod, &pCard->PolledModeDpc);
	}


	return status;




Error:

	if(bInterruptConnnected)
		IoDisconnectInterrupt(pCard->Interrupt);	// Disconnect Interrupt.

	if(pCard->BaseController)	// If mapped in.
		MmUnmapIoSpace(pCard->BaseController, pCard->SpanOfController);	// Unmap.

	switch(SlxosStatus)	
	{
	case MODULE_MIXTURE_ERROR:
		{
			sprintf(szErrorMsg, "Card at %08X%08X: Incompatible module mixture.", pCard->PhysAddr.HighPart, pCard->PhysAddr.LowPart);

			Spx_LogMessage(	STATUS_SEVERITY_ERROR,
							pCard->DriverObject,			// Driver Object
							pCard->DeviceObject,			// Device Object (Optional)
							PhysicalZero,					// Physical Address 1
							PhysicalZero,					// Physical Address 2
							0,								// SequenceNumber
							0,								// Major Function Code
							0,								// RetryCount
							FILE_ID | __LINE__,				// UniqueErrorValue
							STATUS_SUCCESS,					// FinalStatus
							szErrorMsg);					// Error Message

			return(status);
		}

	case NON_SX_HOST_CARD_ERROR:
		{
			sprintf(szErrorMsg, "Card at %08X%08X: SXDCs not supported by this card.", pCard->PhysAddr.HighPart, pCard->PhysAddr.LowPart);

			Spx_LogMessage(	STATUS_SEVERITY_ERROR,
							pCard->DriverObject,			// Driver Object
							pCard->DeviceObject,			// Device Object (Optional)
							PhysicalZero,					// Physical Address 1
							PhysicalZero,					// Physical Address 2
							0,								// SequenceNumber
							0,								// Major Function Code
							0,								// RetryCount
							FILE_ID | __LINE__,				// UniqueErrorValue
							STATUS_SUCCESS,					// FinalStatus
							szErrorMsg);					// Error Message

			return(status);
		}

	case DCODE_OR_NO_MODULES_ERROR:
		{
			sprintf(szErrorMsg, "Card at %08X%08X: No ports found.", pCard->PhysAddr.HighPart, pCard->PhysAddr.LowPart);

			Spx_LogMessage(	STATUS_SEVERITY_ERROR,
							pCard->DriverObject,			// Driver Object
							pCard->DeviceObject,			// Device Object (Optional)
							PhysicalZero,					// Physical Address 1
							PhysicalZero,					// Physical Address 2
							0,								// SequenceNumber
							0,								// Major Function Code
							0,								// RetryCount
							FILE_ID | __LINE__,				// UniqueErrorValue
							STATUS_SUCCESS,					// FinalStatus
							szErrorMsg);					// Error Message

			return(status);
		}

	default:
		break;
	}


	switch(status)
	{
	case STATUS_DEVICE_DOES_NOT_EXIST:
	case STATUS_UNSUCCESSFUL:
		{
			sprintf(szErrorMsg, "Card at %08X%08X: Unrecognised or malfunctioning.", pCard->PhysAddr.HighPart, pCard->PhysAddr.LowPart);

			Spx_LogMessage(	STATUS_SEVERITY_ERROR,
							pCard->DriverObject,			// Driver Object
							pCard->DeviceObject,			// Device Object (Optional)
							PhysicalZero,					// Physical Address 1
							PhysicalZero,					// Physical Address 2
							0,								// SequenceNumber
							0,								// Major Function Code
							0,								// RetryCount
							FILE_ID | __LINE__,				// UniqueErrorValue
							STATUS_SUCCESS,					// FinalStatus
							szErrorMsg);					// Error Message

			break;
		}

	case STATUS_INSUFFICIENT_RESOURCES:
		{
			sprintf(szErrorMsg, "Card at %08X%08X:: Insufficient resources.", pCard->PhysAddr.HighPart, pCard->PhysAddr.LowPart);

			Spx_LogMessage(	STATUS_SEVERITY_ERROR,
							pCard->DriverObject,			// Driver Object
							pCard->DeviceObject,			// Device Object (Optional)
							PhysicalZero,					// Physical Address 1
							PhysicalZero,					// Physical Address 2
							0,								// SequenceNumber
							0,								// Major Function Code
							0,								// RetryCount
							FILE_ID | __LINE__,				// UniqueErrorValue
							STATUS_SUCCESS,					// FinalStatus
							szErrorMsg);					// Error Message

			break;
		}

	default:
		break;

	}

	return status;


} // End XXX_CardStart.

/*****************************************************************************
******************************                  ******************************
******************************   XXX_CardStop   ******************************
******************************                  ******************************
******************************************************************************

prototype:		NTSTATUS XXX_StopCardDevice(IN PCARD_DEVICE_EXTENSION pCard)

description:	Stop card operations:
				stop interrupts/polling
				disconnect interrupts/polling
				stop hardware
				unmap memory
				free any hardware related allocations

parameters:		pCard points to the CARD_DEVICE_EXTENSION structure

returns:		STATUS_SUCCESS

*/

NTSTATUS XXX_CardStop(IN PCARD_DEVICE_EXTENSION pCard)
{
	NTSTATUS status = STATUS_SUCCESS;

	SpxDbgMsg(SPX_TRACE_CALLS,("%s: Entering XXX_CardStop\n", PRODUCT_NAME));

// Stop interrupts...
	if(!(pCard->PolledMode))
		IoDisconnectInterrupt(pCard->Interrupt);

// Stop polling... 
    if(pCard->PolledMode)
    {
		SpxDbgMsg(SERDIAG5,("%s: Extension is polled.  Cancelling.\n", PRODUCT_NAME));
		KeCancelTimer(&pCard->PolledModeTimer);
    }

// Unmap virtual memory address...
	if(pCard->BaseController)	// If mapped in - almost certainly.
		MmUnmapIoSpace(pCard->BaseController, pCard->SpanOfController);

	return(status);

} // End XXX_CardStop.

/*****************************************************************************
******************************                  ******************************
******************************   XXX_PortInit   ******************************
******************************                  ******************************
******************************************************************************

prototype:		NTSTATUS XXX_PortInit(PPORT_DEVICE_EXTENSION pPort)

description:	Initialise non-hardware fields of the port extension:
				identifier strings

parameters:		pPort points to the PORT_DEVICE_EXTENSION structure
				the following fields are initialised on entry:
					PortNumber	Card relative port number (0 based)
					pCard		Pointer to parent card extension

returns:		STATUS_SUCCESS
				The following PORT_DEVICE_EXTENSION fields must be set up:
					pPort->DeviceID
					pPort->HardwareIDs
					pPort->InstanceID
					pPort->DevDesc
*/

NTSTATUS XXX_PortInit(PPORT_DEVICE_EXTENSION pPort)
{
	PCARD_DEVICE_EXTENSION	pCard = pPort->pParentCardExt;
	PSXCARD		pSxCard = (PSXCARD)pCard->Controller;
	NTSTATUS	status = STATUS_SUCCESS;
	PMOD		pMod;
	PCHAN		pChan;
	int			nModules = 0;
	int			nChannels = 0;
	_u8			loop;
	char		szTemp[30];			// Space to hold string 
	char		szCard[10];			// Space to hold card type string 
	char		szModule[20];		// Space to hold module type string 
	int			i = 0;				// String index 
	char		*ptr;

	SpxDbgMsg(SPX_TRACE_CALLS,("%s: Entering XXX_PortInit\n",PRODUCT_NAME));

	if(pSxCard->cc_init_status == NO_ADAPTERS_FOUND)
	{
		SpxDbgMsg(SPX_MISC_DBG,("%s: No modules found on card.\n",PRODUCT_NAME));
		return(STATUS_NOT_FOUND);			// No modules/ports found on this card 
	}

// Scan through the module and channel structures until the specfied port is reached... 
	pMod = (PMOD)(pCard->Controller + sizeof(SXCARD));	// First module structure on card 

	while(nModules++ < SLXOS_MAX_MODULES)
	{
		pChan = (PCHAN)((pu8)pMod + sizeof(SXMODULE));	// First channel on module 

		for(loop = 0; loop < pMod->mc_type; loop++)
		{
			if(nChannels++ == (int)pPort->PortNumber)	// Match with port number?
			{
				pPort->pChannel = (PUCHAR)pChan;		// Yes, store channel pointer
				break;	// Stop scan 
			}

			pChan = (PCHAN)((pu8)pChan + sizeof(SXCHANNEL));
		}

		if(pPort->pChannel) 
			break;			// If channel found, stop scan 

		if(pMod->mc_next & 0x8000) 
			pMod = (PMOD)pChan;	// Next module structure 
		else	
			break;
	}

	if(!(pPort->pChannel)) 
		return(STATUS_NOT_FOUND);	// No port found 

// Initialise the card type string... 

	switch(pCard->CardType)
	{
	case SiHost_1:
	case SiHost_2:
	case Si_2:
	case SiEisa:
	case SiPCI:
		switch(pMod->mc_chip)				// SI/XIO card type depends on module type 
		{
		case TA4:
		case TA4_ASIC:
		case TA8:
		case TA8_ASIC:	
			sprintf(szCard,"SI"); 
			break;

		case MTA_CD1400:
		case SXDC:		
			sprintf(szCard,"XIO"); 
			break;

		default:		
			sprintf(szCard,"XIO"); 
			break;
		}
		break;

	case Si3Isa:
	case Si3Pci:
		pPort->DetectEmptyTxBuffer = TRUE;	
		sprintf(szCard,"SX");
		break;

	case SxPlusPci:
		pPort->DetectEmptyTxBuffer = TRUE;	
		sprintf(szCard,"SX");
		break;

	default:
		sprintf(szCard,"Unknown");
		break;
	}


	//if(pCard->PolledMode)
	//	pPort->DetectEmptyTxBuffer = TRUE;


// Initialise the module type string...

	switch(pMod->mc_chip)			// Set the module type
	{
	case TA4:
	case TA4_ASIC:				
		sprintf(szModule,"TA4"); 
		break;

	case TA8:
	case TA8_ASIC:				
		sprintf(szModule,"TA8"); 
		break;

	case MTA_CD1400:
	{
		_u8	ModType;

		i = sprintf(szModule,"MTA8");			// Generic name root

		pChan = (PCHAN)pPort->pChannel;
		if((pMod->mc_mods == MOD_RS232RJ45_OI)||(pMod->mc_mods == MOD_2_RS232RJ45S))
			ModType = pMod->mc_mods;		// Use full type field 
		else
		{
			if(pChan->chan_number <= 3)
				ModType = pMod->mc_mods & 0xF;		// First module type 
			else	
				ModType = pMod->mc_mods >> 4;		// Second module type 
		}

		switch(ModType)
		{
		case MOD_RS232DB25:
		case MOD_2_RS232DB25:		
			sprintf(szModule+i,"&DM"); 
			break;

		case MOD_RS232RJ45:
		case MOD_2_RS232RJ45:		
			sprintf(szModule+i,"&RJ"); 
			break;

		case MOD_2_RS232RJ45S:		
			sprintf(szModule+i,"&RJX"); 
			break;

		case MOD_RS232RJ45_OI:		
			sprintf(szModule+i,"&O"); 
			break;

		case MOD_PARALLEL:
		case MOD_2_PARALLEL:
			if(pChan->chan_number > 0)	
				sprintf(szModule+i,"&PR");
			else				
				sprintf(szModule+i,"&PP");
			break;

		case MOD_RS422DB25:
		case MOD_2_RS422DB25:		
			sprintf(szModule+i,"&422"); 
			break;

		default:
			break;
		}
		break;
	}
	case SXDC:
	{
		_u8	ModType;

		i = sprintf(szModule,"SXDC8");			// Generic name root

		pChan = (PCHAN)pPort->pChannel;
		ModType = pMod->mc_mods & 0xF;			// Only look at first module type for SXDC

		switch(ModType)
		{
		case MOD_2_RS232DB25:		
			sprintf(szModule+i,"&DX"); 
			break;

		case MOD_2_RS232RJ45:	
			sprintf(szModule+i,"&RJX"); 
			break;

		case MOD_2_RS232DB25_DTE:		
			sprintf(szModule+i,"&MX"); 
			break;

		case MOD_2_PARALLEL:
			if(pChan->chan_number > 3)	
				sprintf(szModule+i,"&DX");
			else 
			{
				if(pChan->chan_number > 0)	
					sprintf(szModule+i,"&PXR");
				else				
					sprintf(szModule+i,"&PXP");
			}
			break;

		case MOD_2_RS422DB25:
			sprintf(szModule+i,"&422DX"); 
			break;

		default:
			break;
		}
		break;
	}

	default:
		i += sprintf(szModule,"Unknown"); 
		break;
	}

// Initialise device identifiers... 
	sprintf(szTemp,"%s\\%s",szCard,szModule);	// Set the card name 
	Spx_InitMultiString(FALSE,&pPort->DeviceID,szTemp,NULL);
	Spx_InitMultiString(TRUE,&pPort->HardwareIDs,szTemp,NULL);

#ifndef BUILD_SPXMINIPORT
	// Form an InstanceID for the port.
	if(!SPX_SUCCESS(status = Spx_CreatePortInstanceID(pPort)))
		return status;
#endif

	sprintf(szTemp,"%s\\",szCard);
	Spx_InitMultiString(TRUE,&pPort->CompatibleIDs,szTemp,NULL);

	sprintf(szTemp,"Perle %s Port %d",szModule,pPort->PortNumber+1);

	ptr = szTemp;
	while(*ptr)		
	{
		if(*ptr=='&')		// Replace all "&" with "/" in the device description.
			*ptr = '/';

		ptr++;
	}

	Spx_InitMultiString(FALSE,&pPort->DevDesc,szTemp,NULL);


/* Not required as we are using INF file 
	i = sprintf(szTemp, "Port %d on ", pPort->PortNumber + 1);

	switch(pCard->InterfaceType)
	{
	case Isa:
		sprintf(szTemp+i, "ISA Card 0x%08lX", pCard->PhysAddr);
		break;

	case PCIBus:
		sprintf(szTemp+i, "PCI Card 0x%08lX", pCard->PhysAddr);
		break;

	default:
		sprintf(szTemp+i, "Card 0x%08lX", pCard->PhysAddr);
		break;
	}


	Spx_InitMultiString(FALSE,&pPort->DevLocation,szTemp,NULL);
*/

	return(status);	// Done 

} // End XXX_PortInit.

/*****************************************************************************
*****************************                    *****************************
*****************************   XXX_PortDeInit   *****************************
*****************************                    *****************************
******************************************************************************

prototype:		NTSTATUS XXX_PortDeInit(PPORT_DEVICE_EXTENSION pPort)

description:	De-Initialise any port extension allocations made during XXX_PortInit

parameters:		pPort points to the PORT_DEVICE_EXTENSION structure
				the following fields are initialised on entry:
					PortNumber	Card relative port number (0 based)
					pCard		Pointer to parent card extension

returns:		STATUS_SUCCESS

*/

NTSTATUS XXX_PortDeInit(PPORT_DEVICE_EXTENSION pPort)
{
	NTSTATUS status = STATUS_SUCCESS;

	SpxDbgMsg(SPX_TRACE_CALLS,("%s: Entering XXX_PortDeInit\n",PRODUCT_NAME));

// Free identifier string allocations... 

	if(pPort->DeviceID.Buffer)		SpxFreeMem(pPort->DeviceID.Buffer);
	if(pPort->CompatibleIDs.Buffer)	SpxFreeMem(pPort->CompatibleIDs.Buffer);
	if(pPort->HardwareIDs.Buffer)	SpxFreeMem(pPort->HardwareIDs.Buffer);
	if(pPort->InstanceID.Buffer)	SpxFreeMem(pPort->InstanceID.Buffer);
	if(pPort->DevDesc.Buffer)		SpxFreeMem(pPort->DevDesc.Buffer);
	if(pPort->DevLocation.Buffer)	SpxFreeMem(pPort->DevLocation.Buffer);

	return(status);	// Done 

} // End XXX_PortDeInit 

/*****************************************************************************
*****************************                   ******************************
*****************************   XXX_PortStart   ******************************
*****************************                   ******************************
******************************************************************************

prototype:		NTSTATUS XXX_PortStart(IN PPORT_DEVICE_EXTENSION pPort)

description:	Start port operations after port has been initialised

parameters:		pPort points to the PORT_DEVICE_EXTENSION structure

returns:		STATUS_SUCCESS

*/

NTSTATUS XXX_PortStart(IN PPORT_DEVICE_EXTENSION pPort)
{
	PCARD_DEVICE_EXTENSION	pCard = pPort->pParentCardExt;
	NTSTATUS		status = STATUS_SUCCESS;

	SpxDbgMsg(SPX_TRACE_CALLS,("%s: Entering XXX_PortStart\n",PRODUCT_NAME));

/* Initialize the list heads for the read, write, and mask queues... */

	InitializeListHead(&pPort->ReadQueue);
	InitializeListHead(&pPort->WriteQueue);
	InitializeListHead(&pPort->MaskQueue);
	InitializeListHead(&pPort->PurgeQueue);

/* Initialize the spinlock associated with fields read (& set) by IO Control functions... */

	KeInitializeSpinLock(&pPort->ControlLock);
	KeInitializeSpinLock(&pPort->BufferLock);

/* Initialize the timers used to timeout operations... */

	KeInitializeTimer(&pPort->ReadRequestTotalTimer);
	KeInitializeTimer(&pPort->ReadRequestIntervalTimer);
	KeInitializeTimer(&pPort->WriteRequestTotalTimer);
	KeInitializeTimer(&pPort->ImmediateTotalTimer);
	KeInitializeTimer(&pPort->XoffCountTimer);
	KeInitializeTimer(&pPort->LowerRTSTimer);

/* Initialise the dpcs that will be used to complete or timeout various IO operations... */

	KeInitializeDpc(&pPort->CompleteWriteDpc,SerialCompleteWrite,pPort);
	KeInitializeDpc(&pPort->CompleteReadDpc,SerialCompleteRead,pPort);
	KeInitializeDpc(&pPort->TotalReadTimeoutDpc,SerialReadTimeout,pPort);
	KeInitializeDpc(&pPort->IntervalReadTimeoutDpc,SerialIntervalReadTimeout,pPort);
	KeInitializeDpc(&pPort->TotalWriteTimeoutDpc,SerialWriteTimeout,pPort);
	KeInitializeDpc(&pPort->CommErrorDpc,SerialCommError,pPort);
	KeInitializeDpc(&pPort->CompleteImmediateDpc,SerialCompleteImmediate,pPort);
	KeInitializeDpc(&pPort->TotalImmediateTimeoutDpc,SerialTimeoutImmediate,pPort);
	KeInitializeDpc(&pPort->CommWaitDpc,SerialCompleteWait,pPort);
	KeInitializeDpc(&pPort->XoffCountTimeoutDpc,SerialTimeoutXoff,pPort);
	KeInitializeDpc(&pPort->XoffCountCompleteDpc,SerialCompleteXoff,pPort);
	KeInitializeDpc(&pPort->StartTimerLowerRTSDpc,SerialStartTimerLowerRTS,pPort);
	KeInitializeDpc(&pPort->PerhapsLowerRTSDpc,SerialInvokePerhapsLowerRTS,pPort);

/* Specify that this driver only supports buffered IO.  This basically means that the IO */
/* system copies the users data to and from system supplied buffers. */

	pPort->DeviceObject->Flags |= DO_BUFFERED_IO;
	pPort->OriginalController = pCard->PhysAddr;

/* Default device control fields... */

	pPort->SpecialChars.XonChar = SERIAL_DEF_XON;
	pPort->SpecialChars.XoffChar = SERIAL_DEF_XOFF;
	pPort->HandFlow.ControlHandShake = SERIAL_DTR_CONTROL;
	pPort->HandFlow.FlowReplace = SERIAL_RTS_CONTROL;

/* Default line configuration: 1200,E,7,1 */

	pPort->CurrentBaud = 1200;
	pPort->LineControl = SERIAL_7_DATA | SERIAL_EVEN_PARITY | SERIAL_1_STOP;
	pPort->ValidDataMask = 0x7F;

/* Default xon/xoff limits... */

	pPort->HandFlow.XoffLimit = pPort->BufferSize >> 3;
	pPort->HandFlow.XonLimit = pPort->BufferSize >> 1;
	pPort->BufferSizePt8 = ((3*(pPort->BufferSize>>2))+(pPort->BufferSize>>4));

/* Define which baud rates can be supported... */

	pPort->SupportedBauds = SERIAL_BAUD_USER;
	pPort->SupportedBauds |= SERIAL_BAUD_075;
	pPort->SupportedBauds |= SERIAL_BAUD_110;
	pPort->SupportedBauds |= SERIAL_BAUD_150;
	pPort->SupportedBauds |= SERIAL_BAUD_300;
	pPort->SupportedBauds |= SERIAL_BAUD_600;
	pPort->SupportedBauds |= SERIAL_BAUD_1200;
	pPort->SupportedBauds |= SERIAL_BAUD_1800;
	pPort->SupportedBauds |= SERIAL_BAUD_2400;
	pPort->SupportedBauds |= SERIAL_BAUD_4800;
	pPort->SupportedBauds |= SERIAL_BAUD_9600;
	pPort->SupportedBauds |= SERIAL_BAUD_19200;
	pPort->SupportedBauds |= SERIAL_BAUD_38400;
	pPort->SupportedBauds |= SERIAL_BAUD_57600;
	pPort->SupportedBauds |= SERIAL_BAUD_115200;

/* Set up values for interval timing... */

	pPort->ShortIntervalAmount.LowPart = 1;
	pPort->ShortIntervalAmount.HighPart = 0;
	pPort->ShortIntervalAmount = RtlLargeIntegerNegate(pPort->ShortIntervalAmount);
	pPort->LongIntervalAmount.LowPart = 10000000;
	pPort->LongIntervalAmount.HighPart = 0;
	pPort->LongIntervalAmount = RtlLargeIntegerNegate(pPort->LongIntervalAmount);
	pPort->CutOverAmount.LowPart = 200000000;
	pPort->CutOverAmount.HighPart = 0;

#ifdef WMI_SUPPORT
	//
	// Fill in WMI hardware data
	//

	pPort->WmiHwData.IrqNumber			= pCard->TrIrql;
	pPort->WmiHwData.IrqVector			= pCard->TrVector;
	pPort->WmiHwData.IrqLevel			= pCard->TrIrql;
	pPort->WmiHwData.IrqAffinityMask	= pCard->ProcessorAffinity;
	
	if(pCard->InterruptMode == Latched)
		pPort->WmiHwData.InterruptType = SERIAL_WMI_INTTYPE_LATCHED;
	else
		pPort->WmiHwData.InterruptType = SERIAL_WMI_INTTYPE_LEVEL;

	pPort->WmiHwData.BaseIOAddress = (ULONG_PTR)pCard->Controller;


	//
	// Fill in WMI device state data (as defaults)
	//

	pPort->WmiCommData.BaudRate					= pPort->CurrentBaud;
	UPDATE_WMI_LINE_CONTROL(pPort->WmiCommData, pPort->LineControl);
	UPDATE_WMI_XON_XOFF_CHARS(pPort->WmiCommData, pPort->SpecialChars);
	UPDATE_WMI_XMIT_THRESHOLDS(pPort->WmiCommData, pPort->HandFlow);

	pPort->WmiCommData.MaximumBaudRate			= 115200U;	// 115200k baud max
	pPort->WmiCommData.MaximumOutputBufferSize	= (UINT32)((ULONG)-1);
	pPort->WmiCommData.MaximumInputBufferSize	= (UINT32)((ULONG)-1);

	pPort->WmiCommData.Support16BitMode			= FALSE;
	pPort->WmiCommData.SupportDTRDSR			= TRUE;
	pPort->WmiCommData.SupportIntervalTimeouts	= TRUE;
	pPort->WmiCommData.SupportParityCheck		= TRUE;
	pPort->WmiCommData.SupportRTSCTS			= TRUE;
	pPort->WmiCommData.SupportXonXoff			= TRUE;
	pPort->WmiCommData.SettableBaudRate			= TRUE;
	pPort->WmiCommData.SettableDataBits			= TRUE;
	pPort->WmiCommData.SettableFlowControl		= TRUE;
	pPort->WmiCommData.SettableParity			= TRUE;
	pPort->WmiCommData.SettableParityCheck		= TRUE;
	pPort->WmiCommData.SettableStopBits			= TRUE;
	pPort->WmiCommData.IsBusy					= FALSE;


	// Fill in wmi perf data (all zero's)
	RtlZeroMemory(&pPort->WmiPerfData, sizeof(pPort->WmiPerfData));


	//
    // Register for WMI
	//
	
	SpxPort_WmiInitializeWmilibContext(&pPort->WmiLibInfo);

	IoWMIRegistrationControl(pPort->DeviceObject, WMIREG_ACTION_REGISTER);
#endif

/* Initialise the port hardware... */

	Slxos_SyncExec(pPort,Slxos_ResetChannel,pPort,0x02);	/* Apply initial port settings */
	Slxos_SyncExec(pPort,SerialClrRTS,pPort,0x03);		/* Clear RTS signal */
	Slxos_SyncExec(pPort,SerialClrDTR,pPort,0x04);		/* Cleat DTR signal */

	return(status);

} // End XXX_PortStart.

/*****************************************************************************
******************************                  ******************************
******************************   XXX_PortStop   ******************************
******************************                  ******************************
******************************************************************************

prototype:	NTSTATUS XXX_PortStop(IN PPORT_DEVICE_EXTENSION pPort)

description:	Stop port operations

parameters:	pPort points to the PORT_DEVICE_EXTENSION structure

returns:	STATUS_SUCCESS

*/


NTSTATUS XXX_PortStop(IN PPORT_DEVICE_EXTENSION pPort)
{
	NTSTATUS status = STATUS_SUCCESS;

	SpxDbgMsg(SPX_TRACE_CALLS,("%s: Entering XXX_PortStop\n",PRODUCT_NAME));

#ifdef WMI_SUPPORT
	IoWMIRegistrationControl(pPort->DeviceObject, WMIREG_ACTION_DEREGISTER);
#endif

/* Cancel timers... */
	
	KeCancelTimer(&pPort->ReadRequestTotalTimer);
	KeCancelTimer(&pPort->ReadRequestIntervalTimer);
	KeCancelTimer(&pPort->WriteRequestTotalTimer);
	KeCancelTimer(&pPort->ImmediateTotalTimer);
	KeCancelTimer(&pPort->XoffCountTimer);
	KeCancelTimer(&pPort->LowerRTSTimer);

/* Cancel pending DPCs... */

	KeRemoveQueueDpc(&pPort->CompleteWriteDpc);
	KeRemoveQueueDpc(&pPort->CompleteReadDpc);
	KeRemoveQueueDpc(&pPort->TotalReadTimeoutDpc);
	KeRemoveQueueDpc(&pPort->IntervalReadTimeoutDpc);
	KeRemoveQueueDpc(&pPort->TotalWriteTimeoutDpc);
	KeRemoveQueueDpc(&pPort->CommErrorDpc);
	KeRemoveQueueDpc(&pPort->CompleteImmediateDpc);
	KeRemoveQueueDpc(&pPort->TotalImmediateTimeoutDpc);
	KeRemoveQueueDpc(&pPort->CommWaitDpc);
	KeRemoveQueueDpc(&pPort->XoffCountTimeoutDpc);
	KeRemoveQueueDpc(&pPort->XoffCountCompleteDpc);
	KeRemoveQueueDpc(&pPort->StartTimerLowerRTSDpc);
	KeRemoveQueueDpc(&pPort->PerhapsLowerRTSDpc);

	return(status);

} // End XXX_PortStop.


/* End of SX_PNP.C */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\spx\mps\sx\sx_w2k.c ===
#include "precomp.h"	// Precompiled header

/****************************************************************************************
*																						*
*	Module:			SX_W2K.C															*
*																						*
*	Creation:		14th April 1999														*
*																						*
*	Author:			Paul Smith															*
*																						*
*	Version:		1.0.0																*
*																						*
*	Description:	Functions specific to SX and Windows 2000							*
*																						*
****************************************************************************************/

// Paging... 
#ifdef ALLOC_PRAGMA
#pragma alloc_text (PAGE, SpxGetNtCardType)
#endif


#define FILE_ID		SX_W2K_C		// File ID for Event Logging see SX_DEFS.H for values.


/*****************************************************************************
****************************                      ****************************
****************************   SpxGetNtCardType   ****************************
****************************                      ****************************
******************************************************************************

prototype:		ULONG	SpxGetNtCardType(IN PDEVICE_OBJECT pDevObject)
	
description:	Return the NT defined card type for the specified card
				device object.

parameters:		pDevObject points to the NT device object for the card

returns:		NT defined card type,
				or -1 if not identified
*/

ULONG	SpxGetNtCardType(IN PDEVICE_OBJECT pDevObject)
{
	PCARD_DEVICE_EXTENSION	pCard	= pDevObject->DeviceExtension;
	ULONG					NtCardType = -1;
	PVOID					pPropertyBuffer = NULL;
	ULONG					ResultLength = 0; 
	NTSTATUS				status = STATUS_SUCCESS;
	ULONG					BufferLength = 1;	// Initial size.

	PAGED_CODE();	// Macro in checked build to assert if pagable code is run at or above dispatch IRQL 

	pPropertyBuffer = SpxAllocateMem(PagedPool, BufferLength);	// Allocate the buffer

	if(pPropertyBuffer == NULL)									// SpxAllocateMem failed.
		return -1;

	// Try to get HardwareID
	status = IoGetDeviceProperty(pCard->PDO, DevicePropertyHardwareID , BufferLength, 
									pPropertyBuffer, &ResultLength);

	if(!SPX_SUCCESS(status))					// IoGetDeviceProperty failed.
	{
		if(status == STATUS_BUFFER_TOO_SMALL)	// Buffer was too small.
		{
			SpxFreeMem(pPropertyBuffer);			// Free old buffer that was not big enough.
			BufferLength = ResultLength + 1;		// Set BufferLength to size required.

			pPropertyBuffer = SpxAllocateMem(PagedPool, BufferLength);	// Allocate a bigger buffer.

			if(pPropertyBuffer == NULL)			// SpxAllocateMem failed.
				return -1;

			// Try again.
			status = IoGetDeviceProperty(pCard->PDO, DevicePropertyHardwareID , BufferLength, 
											pPropertyBuffer, &ResultLength);

			if(!SPX_SUCCESS(status))			// IoGetDeviceProperty failed a second time.
			{
				SpxFreeMem(pPropertyBuffer);	// Free buffer.
				return -1;
			}
		}
		else
		{
			SpxFreeMem(pPropertyBuffer);			// Free buffer.
			return -1;
		}
	}



	// If we get to here then there is something in the PropertyBuffer.

	_wcsupr(pPropertyBuffer);		// Convert HardwareID to uppercase


	// SX
	if(wcsstr(pPropertyBuffer, SIXIO_ISA_HWID) != NULL)
		NtCardType = SiHost_2;

	if(wcsstr(pPropertyBuffer, SIXIO_PCI_HWID) != NULL)
		NtCardType = SiPCI;

	if(wcsstr(pPropertyBuffer, SX_ISA_HWID) != NULL)
		NtCardType = Si3Isa;

	if(wcsstr(pPropertyBuffer, SX_PCI_HWID) != NULL)
		NtCardType = Si3Pci;

	if(wcsstr(pPropertyBuffer, SXPLUS_PCI_HWID) != NULL)
		NtCardType = SxPlusPci;	


	SpxFreeMem(pPropertyBuffer);			// Free buffer.

	return(NtCardType);

} // SpxGetNtCardType
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\spx\mps\sx\inc\serialp.h ===
/*++

Copyright (c) 1990, 1991, 1992, 1993 Microsoft Corporation

Module Name :
	
    serialp.h

Abstract:

    Prototypes and macros that are used throughout the driver.

Author:

    Anthony V. Ercolano                 September 26, 1991

Revision History:
--*/

typedef
NTSTATUS
(*PSERIAL_START_ROUTINE) (
    IN PPORT_DEVICE_EXTENSION
    );

typedef
VOID
(*PSERIAL_GET_NEXT_ROUTINE) (
	IN PPORT_DEVICE_EXTENSION,
    IN PIRP *CurrentOpIrp,
    IN PLIST_ENTRY QueueToProcess,
    OUT PIRP *NewIrp,
    IN BOOLEAN CompleteCurrent
    );

BOOLEAN SerialGetStats(IN PVOID Context);	// Get stats
BOOLEAN SerialClearStats(IN PVOID Context);	// Clear Stats called during open

NTSTATUS
SerialRead(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
SerialStartRead(
    IN PPORT_DEVICE_EXTENSION pPort
    );

VOID
SerialCompleteRead(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemContext1,
    IN PVOID SystemContext2
    );

VOID
SerialReadTimeout(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemContext1,
    IN PVOID SystemContext2
    );

VOID
SerialIntervalReadTimeout(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemContext1,
    IN PVOID SystemContext2
    );

NTSTATUS
SerialFlush(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
SerialWrite(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
SerialStartWrite(
    IN PPORT_DEVICE_EXTENSION pPort
    );

VOID
SerialGetNextWrite(
    IN PPORT_DEVICE_EXTENSION,
    IN PIRP *CurrentOpIrp,
    IN PLIST_ENTRY QueueToProcess,
    IN PIRP *NewIrp,
    IN BOOLEAN CompleteCurrent
    );

VOID
SerialCompleteWrite(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemContext1,
    IN PVOID SystemContext2
    );

BOOLEAN
SerialProcessEmptyTransmit(
    IN PVOID Context
    );

VOID
SerialWriteTimeout(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemContext1,
    IN PVOID SystemContext2
    );

VOID
SerialCommError(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemContext1,
    IN PVOID SystemContext2
    );

NTSTATUS
SerialCleanup(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
SerialCreateOpen(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
SerialClose(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

BOOLEAN
SerialSetDTR(
    IN PVOID Context
    );

BOOLEAN
SerialClrDTR(
    IN PVOID Context
    );

BOOLEAN
SerialSetRTS(
    IN PVOID Context
    );

BOOLEAN
SerialClrRTS(
    IN PVOID Context
    );

BOOLEAN
SerialSetChars(
    IN PVOID Context
    );

BOOLEAN
SerialSetupNewHandFlow(
    IN PPORT_DEVICE_EXTENSION pPort,
    IN PSERIAL_HANDFLOW NewHandFlow
    );

BOOLEAN
SerialSetHandFlow(
    IN PVOID Context
    );

BOOLEAN
SerialTurnOnBreak(
    IN PVOID Context
    );

BOOLEAN
SerialTurnOffBreak(
    IN PVOID Context
    );

BOOLEAN
SerialPretendXoff(
    IN PVOID Context
    );

BOOLEAN
SerialPretendXon(
    IN PVOID Context
    );

VOID
SerialHandleReducedIntBuffer(
    IN PPORT_DEVICE_EXTENSION pPort
    );

NTSTATUS
SerialIoControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
SerialStartMask(
    IN PPORT_DEVICE_EXTENSION pPort
    );

VOID
SerialCancelWait(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

VOID
SerialCompleteWait(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemContext1,
    IN PVOID SystemContext2
    );

VOID
SerialStartImmediate(
    IN PPORT_DEVICE_EXTENSION pPort
    );

VOID
SerialCompleteImmediate(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemContext1,
    IN PVOID SystemContext2
    );

VOID
SerialTimeoutImmediate(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemContext1,
    IN PVOID SystemContext2
    );

VOID
SerialTimeoutXoff(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemContext1,
    IN PVOID SystemContext2
    );

VOID
SerialCompleteXoff(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemContext1,
    IN PVOID SystemContext2
    );

NTSTATUS
SerialStartPurge(
    IN PPORT_DEVICE_EXTENSION pPort
    );

BOOLEAN
SerialPurgeInterruptBuff(
    IN PVOID Context
    );

NTSTATUS
SerialQueryInformationFile(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
SerialSetInformationFile(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

VOID
SerialKillAllReadsOrWrites(
    IN PDEVICE_OBJECT DeviceObject,
    IN PLIST_ENTRY QueueToClean,
    IN PIRP *CurrentOpIrp
    );

VOID
SerialGetNextIrp(
    IN PPORT_DEVICE_EXTENSION,
    IN PIRP *CurrentOpIrp,
    IN PLIST_ENTRY QueueToProcess,
    OUT PIRP *NextIrp,
    IN BOOLEAN CompleteCurrent
    );

VOID
SerialTryToCompleteCurrent(
    IN PPORT_DEVICE_EXTENSION pPort,
    IN PKSYNCHRONIZE_ROUTINE SynchRoutine OPTIONAL,
    IN KIRQL IrqlForRelease,
    IN NTSTATUS StatusToUse,
    IN PIRP *CurrentOpIrp,
    IN PLIST_ENTRY QueueToProcess,
    IN PKTIMER IntervalTimer,
    IN PKTIMER TotalTimer,
    IN PSERIAL_START_ROUTINE Starter,
    IN PSERIAL_GET_NEXT_ROUTINE GetNextIrp
    );

NTSTATUS
SerialStartOrQueue(
    IN PPORT_DEVICE_EXTENSION pPort,
    IN PIRP Irp,
    IN PLIST_ENTRY QueueToExamine,
    IN PIRP *CurrentOpIrp,
    IN PSERIAL_START_ROUTINE Starter
    );

VOID
SerialCancelQueued(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp
    );

NTSTATUS
SerialCompleteIfError(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp
    );

ULONG
SerialHandleModemUpdate(
    IN PPORT_DEVICE_EXTENSION pPort
    );

BOOLEAN
SerialISR(
    IN PKINTERRUPT InterruptObject,
    IN PVOID Context
    );

VOID
DriverUnload(
    IN PDRIVER_OBJECT DriverObject
    );

BOOLEAN
SerialPerhapsLowerRTS(
    IN PVOID Context
    );

VOID
SerialStartTimerLowerRTS(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemContext1,
    IN PVOID SystemContext2
    );

VOID
SerialInvokePerhapsLowerRTS(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemContext1,
    IN PVOID SystemContext2
    );

VOID
slxos_dpc(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2 
    );

VOID
SerialCleanupDevice(
    IN PPORT_DEVICE_EXTENSION pPort
    );

UCHAR
SerialProcessLSR(
    IN PPORT_DEVICE_EXTENSION pPort,
    UCHAR LineStatus
    );

LARGE_INTEGER
SerialGetCharTime(
    IN PPORT_DEVICE_EXTENSION pPort
    );

BOOLEAN
SerialMarkClose(
    IN PVOID Context
    );


VOID SerialGetProperties(
	IN PPORT_DEVICE_EXTENSION pPort, 
	IN PSERIAL_COMMPROP Properties
	);

UCHAR	SerialPutBlock(IN PPORT_DEVICE_EXTENSION pPort,IN PUCHAR pBlock,IN UCHAR BlockLen,BOOLEAN Filter);
USHORT	SerialTransferReadChar(IN PPORT_DEVICE_EXTENSION pExt,IN PUCHAR pFrom,IN PUCHAR pTo);

typedef struct _SERIAL_UPDATE_CHAR {
    PPORT_DEVICE_EXTENSION pPort;
    ULONG CharsCopied;
    BOOLEAN Completed;
    } SERIAL_UPDATE_CHAR,*PSERIAL_UPDATE_CHAR;

//
// The following simple structure is used to send a pointer
// the device extension and an ioctl specific pointer
// to data.
//
typedef struct _SERIAL_IOCTL_SYNC {
    PPORT_DEVICE_EXTENSION pPort;
    PVOID Data;
    } SERIAL_IOCTL_SYNC,*PSERIAL_IOCTL_SYNC;

//
// The following three macros are used to initialize, increment
// and decrement reference counts in IRPs that are used by
// this driver.  The reference count is stored in the fourth
// argument of the irp, which is never used by any operation
// accepted by this driver.
//

#define SERIAL_INIT_REFERENCE(Irp) { \
    ASSERT(sizeof(LONG) <= sizeof(PVOID)); \
    IoGetCurrentIrpStackLocation((Irp))->Parameters.Others.Argument4 = NULL; \
    }

#define SERIAL_INC_REFERENCE(Irp) \
   ((*((LONG *)(&(IoGetCurrentIrpStackLocation((Irp)))->Parameters.Others.Argument4)))++)

#define SERIAL_DEC_REFERENCE(Irp) \
   ((*((LONG *)(&(IoGetCurrentIrpStackLocation((Irp)))->Parameters.Others.Argument4)))--)

#define SERIAL_REFERENCE_COUNT(Irp) \
    ((LONG)((IoGetCurrentIrpStackLocation((Irp))->Parameters.Others.Argument4)))
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\spx\mps\sx\sx_powr.c ===
/************************************************************************/
/*									*/
/*	Title		:	SX Power Management Functions		*/
/*									*/
/*	Author		:	N.P.Vassallo				*/
/*									*/
/*	Creation	:	14th October 1998			*/
/*									*/
/*	Version		:	1.0.0					*/
/*									*/
/*	Description	:	SX specfic Power Functions:		*/
/*					XXX_CardPowerDown()		*/
/*					XXX_CardPowerUp()		*/
/*					XXX_PortPowerDown()		*/
/*					XXX_PortPowerUp()		*/
/*									*/
/************************************************************************/

/* History...

1.0.0	14/20/98 NPV	Creation.

*/

#include "precomp.h"

/*****************************************************************************
*******************************                *******************************
*******************************   Prototypes   *******************************
*******************************                *******************************
*****************************************************************************/

void	CardStop(IN PCARD_DEVICE_EXTENSION pCard);

/*****************************************************************************
***************************                       ****************************
***************************   XXX_CardPowerDown   ****************************
***************************                       ****************************
******************************************************************************

prototype:	NTSTATUS XXX_CardPowerDown(IN PCARD_DEVICE_EXTENSION pCard)

description:	Power is about to be removed from the device, do the following:
		-	save any card context not already contained in device extension
		-	switch off polling and interrupts
		-	set flag to prevent access the card memory (it may not be there)
		-	set card to a non-active state

assumptions:	Assume that all of the ports have been powered down and the
		PPF_POWERED flag cleared, so that IRPs are queued for the device

parameters:	pCard points to the card device extension structure

returns:	STATUS_SUCCESS

*/

NTSTATUS XXX_CardPowerDown(IN PCARD_DEVICE_EXTENSION pCard)
{
	SpxDbgMsg(SPX_TRACE_CALLS,("%s[card=%d]: Entering XXX_CardPowerDown\n",
		PRODUCT_NAME,pCard->CardNumber));

/* Stop polling/interrupts... */

        if(pCard->PolledMode)
        {
		SpxDbgMsg(SPX_MISC_DBG,("%s: Extension is polled.  Cancelling.\n",PRODUCT_NAME));
		KeCancelTimer(&pCard->PolledModeTimer);
        }

/* Prevent driver from trying to access hardware... */

/* Set hardware to known, non-active state... */

	CardStop(pCard);			/* Stop the hardware */

	return(STATUS_SUCCESS);

} /* XXX_CardPowerDown */

/*****************************************************************************
****************************                     *****************************
****************************   XXX_CardPowerUp   *****************************
****************************                     *****************************
******************************************************************************

prototype:	NTSTATUS XXX_CardPowerUp(IN PCARD_DEVICE_EXTENSION pCard)

description:	Power is about to be restored to the device, after a power down:
		-	re-allow access to the card memory
		-	reset card hardware and reload download code
		-	switch polling/interrupts back on
		-	restore port settings/context from current device extension values

assumptions:	calling code should reset the PPF_POWERED flag after calling this function
		and unstall any IRPs waiting on the queue

		assume this function is only called after an XXX_SavePowerState,
		i.e.	resources are still translated
			memory is still mapped in
			dpcs and timers initialized

parameters:	pCard points to the card device extension structure

returns:	STATUS_SUCCESS

*/

NTSTATUS XXX_CardPowerUp(IN PCARD_DEVICE_EXTENSION pCard)
{
	NTSTATUS	status = STATUS_SUCCESS;

	SpxDbgMsg(SPX_TRACE_CALLS,("%s[card=%d]: Entering XXX_CardPowerUp\n",
		PRODUCT_NAME,pCard->CardNumber));

/* Re-allow access to card hardware... */

/* reset card hardware and reload download code... */

	if(Slxos_ResetBoard(pCard) != SUCCESS)		/* Reset the card and start download */
		return(STATUS_DEVICE_NOT_READY);	/* Error */

/* Restart polled timer/interrupt... */

	if(pCard->PolledMode)				/* Set up polled mode */
	{
		LARGE_INTEGER	PolledPeriod;

		PolledPeriod.QuadPart = -100000;	/* 100,000*100nS = 10mS */
		KeSetTimer(&pCard->PolledModeTimer,PolledPeriod,&pCard->PolledModeDpc);
	}

	return(status);

} /* XXX_CardPowerUp */

/*****************************************************************************
*************************                            *************************
*************************   XXX_PortQueryPowerDown   *************************
*************************                            *************************
******************************************************************************

prototype:	NTSTATUS XXX_PortQueryPowerDown(IN PPORT_DEVICE_EXTENSION pPort)

description:	System is asking if its OK to power down the port, say NO if:
		-	port is open and data in the transmit buffer, and not flowed off

parameters:	pPort points to the port device extension structure

returns:	STATUS_SUCCESS
		STATUS_DEVICE_BUSY

*/

NTSTATUS XXX_PortQueryPowerDown(IN PPORT_DEVICE_EXTENSION pPort)
{

	SpxDbgMsg(SPX_TRACE_CALLS,("%s[card=%d,port=%d]: Entering XXX_PortQueryPowerDown\n",
		PRODUCT_NAME,pPort->pParentCardExt->CardNumber,pPort->PortNumber));

	return(STATUS_SUCCESS);

} /* XXX_PortQueryPowerDown */

/*****************************************************************************
***************************                       ****************************
***************************   XXX_PortPowerDown   ****************************
***************************                       ****************************
******************************************************************************

prototype:	NTSTATUS XXX_PortPowerDown(IN PPORT_DEVICE_EXTENSION pPort)

description:	Power is about to be removed from the port, do the following:
		-	save any port context not already contained in device extension
		-	actual powering off the port hardware occurs in XXX_CardPowerDown

assumptions:	Assume that PPF_POWERED flag cleared, so that IRPs are queued for the device

parameters:	pPort points to the port device extension structure

returns:	STATUS_SUCCESS

*/

NTSTATUS XXX_PortPowerDown(IN PPORT_DEVICE_EXTENSION pPort)
{
	PCARD_DEVICE_EXTENSION	pCard = pPort->pParentCardExt;
	PCHAN			pChan = (PCHAN)pPort->pChannel;
	KIRQL			OldIrql;
	ULONG			loop;

	SpxDbgMsg(SPX_TRACE_CALLS,("%s[card=%d,port=%d]: Entering XXX_PortPowerDown\n",
		PRODUCT_NAME,pPort->pParentCardExt->CardNumber,pPort->PortNumber));

	if(pPort->DeviceIsOpen)			/* Was port opened before ? */
	{

/* Save the current modem signals... */

		pPort->SavedModemControl = Slxos_GetModemControl(pPort);

/* Save the current transmit & receive buffer contents... */

		KeAcquireSpinLock(&pCard->DpcLock,&OldIrql);	/* Protect Dpc for this board */

		for(loop = 0; loop < BUFFER_SIZE; loop++)	/* Save transmit buffer */
			pPort->saved_hi_txbuf[loop] = pChan->hi_txbuf[loop];
		pPort->saved_hi_txipos = pChan->hi_txipos;	/* Save transmit input pointer */
		pPort->saved_hi_txopos = pChan->hi_txopos;	/* Save transmit output pointer */

		for(loop = 0; loop < BUFFER_SIZE; loop++)	/* Save receive buffer */
			pPort->saved_hi_txbuf[loop] = pChan->hi_txbuf[loop];
		pPort->saved_hi_rxipos = pChan->hi_rxipos;	/* Save receive input pointer */
		pPort->saved_hi_rxopos = pChan->hi_rxopos;	/* Save receive output pointer */

		KeReleaseSpinLock(&pCard->DpcLock,OldIrql);	/* Free the Dpc lock */
	}

	return(STATUS_SUCCESS);

} /* XXX_PortPowerDown */

/*****************************************************************************
****************************                     *****************************
****************************   XXX_PortPowerUp   *****************************
****************************                     *****************************
******************************************************************************

prototype:	NTSTATUS XXX_PortPowerUp(IN PCARD_DEVICE_EXTENSION pCard)

description:	Power is about to be restored to the port, after a power down:
		-	restore port settings/context from current device extension values
		-	reopen the card port, if open in the extension

assumptions:	calling code should reset the PPF_POWERED flag after calling this function
		and unstall any IRPs waiting on the queue

		assume this function is only called after an XXX_SavePowerState,
		i.e.	resources are still translated
			memory is still mapped in
			dpcs and timers initialized

		assume that either the transmit buffer was empty or blocked by flow
		control when saving its contents.  can't fail the power down, but
		an earlier query would have been refused if actively sending data.

parameters:	pPort points to the port device extension structure

returns:	STATUS_SUCCESS

*/

NTSTATUS XXX_PortPowerUp(IN PPORT_DEVICE_EXTENSION pPort)
{
	PCARD_DEVICE_EXTENSION	pCard = pPort->pParentCardExt;
	PCHAN			pChan = (PCHAN)pPort->pChannel;
	KIRQL			OldIrql;
	ULONG			loop;
	NTSTATUS		status = STATUS_SUCCESS;

	SpxDbgMsg(SPX_TRACE_CALLS,("%s[card=%d,port=%d]: Entering XXX_PortPowerUp\n",
		PRODUCT_NAME,pPort->pParentCardExt->CardNumber,pPort->PortNumber));

	if(pPort->DeviceIsOpen)			/* Was port opened before ? */
	{
		Slxos_EnableAllInterrupts(pPort);	/* Yes, re-open */

		if(pPort->SavedModemControl & SERIAL_MCR_RTS)	/* RTS active ? */
			Slxos_SetRTS(pPort);			/* Yes */
		else
			Slxos_ClearRTS(pPort);			/* No */

		if(pPort->SavedModemControl & SERIAL_MCR_DTR)	/* DTR active ? */
			Slxos_SetDTR(pPort);			/* Yes */
		else
			Slxos_ClearDTR(pPort);			/* No */
	}

	Slxos_ResetChannel(pPort);			/* Apply initial port settings */
	
/* Restore saved transmit buffer contents... */

	if(pPort->DeviceIsOpen)			/* Was port opened before ? */
	{
		KeAcquireSpinLock(&pCard->DpcLock,&OldIrql);	/* Protect Dpc for this board */

		for(loop = 0; loop < BUFFER_SIZE; loop++)	/* Restore transmit buffer */
			pChan->hi_txbuf[loop] = pPort->saved_hi_txbuf[loop];
		pChan->hi_txipos = pPort->saved_hi_txipos;	/* Restore transmit input pointer */
		pChan->hi_txopos = pPort->saved_hi_txopos;	/* Restore transmit output pointer */

/* As port could be receiving data from open, restore saved rx buffer in Slxos_PollForInterrupt */

		KeReleaseSpinLock(&pCard->DpcLock,OldIrql);	/* Free the Dpc lock */
	}

	return(status);

} /* XXX_PortPowerUp */

/*****************************************************************************
********************************              ********************************
********************************   CardStop   ********************************
********************************              ********************************
******************************************************************************

prototype:	void	CardStop(IN PCARD_DEVICE_EXTENSION pCard)

description:	Stops the cards processor, placing card in known non-active state

parameters:	pCard points to the card extension structure

returns:	none

*/

void	CardStop(IN PCARD_DEVICE_EXTENSION pCard)
{
	LARGE_INTEGER	delay;
	ULONG		loop;

	SpxDbgMsg(SPX_TRACE_CALLS,("%s[card=%d]: Entering CardStop\n",
		PRODUCT_NAME,pCard->CardNumber));

	switch(pCard->CardType)
	{
	case	SiHost_2:
		pCard->Controller[SI2_ISA_RESET] = SI2_ISA_RESET_SET;	/* Put card in reset */
		pCard->Controller[SI2_ISA_IRQ11] = SI2_ISA_IRQ11_CLEAR;	/* Disable interrupt 11 */
		pCard->Controller[SI2_ISA_IRQ12] = SI2_ISA_IRQ12_CLEAR;	/* Disable interrupt 12 */
		pCard->Controller[SI2_ISA_IRQ15] = SI2_ISA_IRQ15_CLEAR;	/* Disable interrupt 15 */
		pCard->Controller[SI2_ISA_INTCLEAR] = SI2_ISA_INTCLEAR_CLEAR;/* Disable Z280 interrupts */
		pCard->Controller[SI2_ISA_IRQSET] = SI2_ISA_IRQSET_CLEAR;	/* Disable ISA interrupts */
		break;

	case	SiPCI:
		pCard->Controller[SI2_PCI_SET_IRQ] = 0;			/* clear any interrupts */
		pCard->Controller[SI2_PCI_RESET] = 0;			/* put z280 into reset */
		break;

	case	Si3Isa:
	case	Si3Pci:
		pCard->Controller[SX_CONFIG] = 0;
		pCard->Controller[SX_RESET] = 0;

		loop = 0;
		delay = RtlLargeIntegerNegate(RtlConvertUlongToLargeInteger(1000000));/* 1mS */
		while((pCard->Controller[SX_RESET]&1) && loop++<10000)	/* spin 'til done */
			KeDelayExecutionThread(KernelMode,FALSE,&delay);/* Wait */
		break;

	default:
		break;
	}

	return;						/* Stopped OK */

} /* CardStop */

/* End of SX_POWR.C */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\spx\mps\sx\write.c ===
/*++

Copyright (c) 1991, 1992, 1993 Microsoft Corporation

Module Name:

    write.c

Abstract:

    This module contains the code that is very specific to write
    operations in the serial driver

Author:

    Anthony V. Ercolano 26-Sep-1991

Environment:

    Kernel mode

Revision History :

--*/

#include "precomp.h"			/* Precompiled Headers */

BOOLEAN
SerialGiveWriteToIsr(
    IN PVOID Context
    );

VOID
SerialCancelCurrentWrite(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp
    );

BOOLEAN
SerialGrabWriteFromIsr(
    IN PVOID Context
    );

BOOLEAN
SerialGrabXoffFromIsr(
    IN PVOID Context
    );

VOID
SerialCancelCurrentXoff(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp
    );

BOOLEAN
SerialGiveXoffToIsr(
    IN PVOID Context
    );



NTSTATUS
SerialWrite(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This is the dispatch routine for write.  It validates the parameters
    for the write request and if all is ok then it places the request
    on the work queue.

Arguments:

    DeviceObject - Pointer to the device object for this device

    Irp - Pointer to the IRP for the current request

Return Value:

    If the io is zero length then it will return STATUS_SUCCESS,
    otherwise this routine will return STATUS_PENDING.

--*/

{

    PPORT_DEVICE_EXTENSION pPort = DeviceObject->DeviceExtension;

    SpxDbgMsg(SERIRPPATH,("SERIAL: SerialWrite dispatch entry for: %x\n",Irp));
 	SpxIRPCounter(pPort, Irp, IRP_SUBMITTED);	// Increment counter for performance stats.
       
#ifdef	CHECK_COMPLETED
	SpxDbgMsg(SERDEBUG,("Start WRITE %lX\n",Irp));
#endif

    if(SerialCompleteIfError(DeviceObject,Irp) != STATUS_SUCCESS) 
        return STATUS_CANCELLED;


    Irp->IoStatus.Information = 0L;

    //
    // Quick check for a zero length write.  If it is zero length
    // then we are already done!
    //

    if(IoGetCurrentIrpStackLocation(Irp)->Parameters.Write.Length) 
	{

        //
        // Well it looks like we actually have to do some
        // work.  Put the write on the queue so that we can
        // process it when our previous writes are done.
        //

        return SerialStartOrQueue(
                   pPort,
                   Irp,
                   &pPort->WriteQueue,
                   &pPort->CurrentWriteIrp,
                   SerialStartWrite
                   );

    } 
	else 
	{

        Irp->IoStatus.Status = STATUS_SUCCESS;
        SpxDbgMsg(SERIRPPATH,("SERIAL: Complete Irp: %x\n",Irp));
            
            
           
#ifdef	CHECK_COMPLETED
	DisplayCompletedIrp(Irp,17);
#endif
		SpxIRPCounter(pPort, Irp, IRP_COMPLETED);	// Increment counter for performance stats.
        IoCompleteRequest(Irp,0);

        return STATUS_SUCCESS;
    }

}

NTSTATUS
SerialStartWrite(
    IN PPORT_DEVICE_EXTENSION pPort
    )

/*++

Routine Description:

    This routine is used to start off any write.  It initializes
    the Iostatus fields of the irp.  It will set up any timers
    that are used to control the write.

Arguments:

    pPort - Points to the serial device extension

Return Value:

    This routine will return STATUS_PENDING for all writes
    other than those that we find are cancelled.

--*/

{

    PIRP NewIrp;
    KIRQL OldIrql;
    LARGE_INTEGER TotalTime;
    BOOLEAN UseATimer;
    SERIAL_TIMEOUTS Timeouts;
    BOOLEAN SetFirstStatus = FALSE;
    NTSTATUS FirstStatus;

    do 
	{
        //
        // If there is an xoff counter then complete it.
        //

        IoAcquireCancelSpinLock(&OldIrql);

        //
        // We see if there is a actually an Xoff counter irp.
        //
        // If there is, we put the write irp back on the head
        // of the write list.  We then kill the xoff counter.
        // The xoff counter killing code will actually make the
        // xoff counter back into the current write irp, and
        // in the course of completing the xoff (which is now
        // the current write) we will restart this irp.
        //

        if(pPort->CurrentXoffIrp) 
		{
            InsertHeadList(&pPort->WriteQueue,&pPort->CurrentWriteIrp->Tail.Overlay.ListEntry);
			SpxIRPCounter(pPort, pPort->CurrentWriteIrp, IRP_QUEUED);

            if(!SetFirstStatus) 
			{
                IoMarkIrpPending(pPort->CurrentWriteIrp);
                SetFirstStatus = TRUE;
                FirstStatus = STATUS_PENDING;
            }

            if(SERIAL_REFERENCE_COUNT(pPort->CurrentXoffIrp)) 
			{
                //
                // The reference count is non-zero.  This implies that
                // the xoff irp has not made it through the completion
                // path yet.  We will increment the reference count
                // and attempt to complete it ourseleves.
                //

                SERIAL_INC_REFERENCE(pPort->CurrentXoffIrp);

                pPort->CurrentWriteIrp = pPort->CurrentXoffIrp;

                //
                // The following call will actually release the
                // cancel spin lock.
                //

                SerialTryToCompleteCurrent(
                    pPort,
                    SerialGrabXoffFromIsr,
                    OldIrql,
                    STATUS_SERIAL_MORE_WRITES,
                    &pPort->CurrentWriteIrp,
                    &pPort->WriteQueue,
                    NULL,
                    &pPort->XoffCountTimer,
                    SerialStartWrite,
                    SerialGetNextWrite
                    );

                return FirstStatus;

            } 
			else 
			{
                //
                // The irp is well on its way to being finished.
                // We can let the regular completion code do the
                // work.  Just release the spin lock.
                //

                IoReleaseCancelSpinLock(OldIrql);

                return FirstStatus;

            }

        } 
		else 
		{
            IoReleaseCancelSpinLock(OldIrql);
        }

        UseATimer = FALSE;

        //
        // Calculate the timeout value needed for the
        // request.  Note that the values stored in the
        // timeout record are in milliseconds.  Note that
        // if the timeout values are zero then we won't start
        // the timer.
        //

        KeAcquireSpinLock(&pPort->ControlLock, &OldIrql);
            
        Timeouts = pPort->Timeouts;

        KeReleaseSpinLock(&pPort->ControlLock, OldIrql);
            

        if(Timeouts.WriteTotalTimeoutConstant || Timeouts.WriteTotalTimeoutMultiplier)
		{
            PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation(pPort->CurrentWriteIrp);
                                           
            UseATimer = TRUE;

            //
            // We have some timer values to calculate.
            //
            // Take care, we might have an xoff counter masquerading
            // as a write.
            //

            TotalTime = RtlEnlargedUnsignedMultiply(
                            (IrpSp->MajorFunction == IRP_MJ_WRITE)?(IrpSp->Parameters.Write.Length):(1),
                            Timeouts.WriteTotalTimeoutMultiplier);    

            TotalTime = RtlLargeIntegerAdd(
							TotalTime,
							RtlConvertUlongToLargeInteger(Timeouts.WriteTotalTimeoutConstant));

            TotalTime = RtlExtendedIntegerMultiply(TotalTime,-10000);

        }

        //
        // The irp may be going to the isr shortly.  Now
        // is a good time to initialize its reference counts.
        //

        SERIAL_INIT_REFERENCE(pPort->CurrentWriteIrp);

        //
        // We need to see if this irp should be cancelled.
        //

        IoAcquireCancelSpinLock(&OldIrql);

        if(pPort->CurrentWriteIrp->Cancel) 
		{
            IoReleaseCancelSpinLock(OldIrql);
            pPort->CurrentWriteIrp->IoStatus.Status = STATUS_CANCELLED;

            if(!SetFirstStatus) 
			{
                FirstStatus = STATUS_CANCELLED;
                SetFirstStatus = TRUE;
            }

        } 
		else 
		{
            if(!SetFirstStatus) 
			{

                //
                // If we haven't set our first status, then
                // this is the only irp that could have possibly
                // not been on the queue.  (It could have been
                // on the queue if this routine is being invoked
                // from the completion routine.)  Since this
                // irp might never have been on the queue we
                // should mark it as pending.
                //

                IoMarkIrpPending(pPort->CurrentWriteIrp);
                SetFirstStatus = TRUE;
                FirstStatus = STATUS_PENDING;

            }

            //
            // We give the irp to to the isr to write out.
            // We set a cancel routine that knows how to
            // grab the current write away from the isr.
            //
            // Since the cancel routine has an implicit reference
            // to this irp up the reference count.
            //

            IoSetCancelRoutine(pPort->CurrentWriteIrp,SerialCancelCurrentWrite);
                
                
                

            SERIAL_INC_REFERENCE(pPort->CurrentWriteIrp);

            if(UseATimer) 
			{
                KeSetTimer(&pPort->WriteRequestTotalTimer,TotalTime,&pPort->TotalWriteTimeoutDpc);

                //
                // This timer now has a reference to the irp.
                //

                SERIAL_INC_REFERENCE(pPort->CurrentWriteIrp);
            }

			Slxos_SyncExec(pPort,SerialGiveWriteToIsr,pPort,0x1F);

            IoReleaseCancelSpinLock(OldIrql);
            break;
        }

        //
        // Well the write was cancelled before we could start it up.
        // Try to get another.
        //

        SerialGetNextWrite(pPort, &pPort->CurrentWriteIrp, &pPort->WriteQueue, &NewIrp, TRUE);

    } while (NewIrp);

    return FirstStatus;

}

VOID
SerialGetNextWrite(
    IN PPORT_DEVICE_EXTENSION pPort,
    IN PIRP *CurrentOpIrp,
    IN PLIST_ENTRY QueueToProcess,
    IN PIRP *NewIrp,
    IN BOOLEAN CompleteCurrent
    )

/*++

Routine Description:

    This routine completes the old write as well as getting
    a pointer to the next write.

    The reason that we have have pointers to the current write
    queue as well as the current write irp is so that this
    routine may be used in the common completion code for
    read and write.

Arguments:

    CurrentOpIrp - Pointer to the pointer that points to the
                   current write irp.

    QueueToProcess - Pointer to the write queue.

    NewIrp - A pointer to a pointer to the irp that will be the
             current irp.  Note that this could end up pointing
             to a null pointer.  This does NOT necessarily mean
             that there is no current write.  What could occur
             is that while the cancel lock is held the write
             queue ended up being empty, but as soon as we release
             the cancel spin lock a new irp came in from
             SerialStartWrite.

    CompleteCurrent - Flag indicates whether the CurrentOpIrp should
                      be completed.

Return Value:

    None.

--*/
{

	pPort = CONTAINING_RECORD(QueueToProcess, PORT_DEVICE_EXTENSION, WriteQueue);

    do 
	{
        //
        // We could be completing a flush.
        //

        if(IoGetCurrentIrpStackLocation(*CurrentOpIrp)->MajorFunction == IRP_MJ_WRITE) 
		{

            KIRQL OldIrql;

            ASSERT(pPort->TotalCharsQueued >= (IoGetCurrentIrpStackLocation(*CurrentOpIrp)
					->Parameters.Write.Length));
			
            IoAcquireCancelSpinLock(&OldIrql);
            pPort->TotalCharsQueued -= IoGetCurrentIrpStackLocation(*CurrentOpIrp)->Parameters.Write.Length;
                
            IoReleaseCancelSpinLock(OldIrql);

        } 
		else if(IoGetCurrentIrpStackLocation(*CurrentOpIrp)->MajorFunction == IRP_MJ_DEVICE_CONTROL) 
		{

            KIRQL OldIrql;

            IoAcquireCancelSpinLock(&OldIrql);

            //
            // If CurrentXoffIrp is not equal to null, this
            // implies that this is the "second" time around
            // for this irp, which implies that we should really
            // be completing it this time.
            //

            if(pPort->CurrentXoffIrp) 
			{
                pPort->CurrentXoffIrp = NULL;
                IoReleaseCancelSpinLock(OldIrql);
            } 
			else 
			{
                PIRP Irp = *CurrentOpIrp;

                PSERIAL_XOFF_COUNTER Xc = Irp->AssociatedIrp.SystemBuffer;

                // We absolutely shouldn't have a cancel routine at this point.
                ASSERT(!Irp->CancelRoutine);

                // This could only be a xoff counter masquerading as a write irp.
                pPort->TotalCharsQueued--;

                //
                // Check to see of the xoff irp has been set with success.
                // This means that the write completed normally.  If that
                // is the case, and it hasn't been set to cancel in the
                // meanwhile, then go on and make it the CurrentXoffIrp.
                //

                if(Irp->IoStatus.Status != STATUS_SUCCESS) 
				{
                    NOTHING;	// Oh well, we can just finish it off.
                } 
				else if(Irp->Cancel) 
				{
                    Irp->IoStatus.Status = STATUS_CANCELLED;
                } 
				else 
				{

                    //
                    // Give it a new cancel routine, and increment the
                    // reference count because the cancel routine has
                    // a reference to it.
                    //

                    IoSetCancelRoutine(Irp, SerialCancelCurrentXoff);
                     

                    SERIAL_INC_REFERENCE(Irp);

                    //
                    // We don't want to complete the current irp now.  This
                    // will now get completed by the Xoff counter code.
                    //

                    CompleteCurrent = FALSE;

                    //
                    // Give the counter to the isr.
                    //

                    pPort->CurrentXoffIrp = Irp;
					Slxos_SyncExec(pPort, SerialGiveXoffToIsr, pPort,0x20);

                    //
                    // Start the timer for the counter and increment the reference
                    // count since the timer has a reference to the irp.
                    //

                    if(Xc->Timeout) 
					{
                        KeSetTimer(	&pPort->XoffCountTimer,
									RtlLargeIntegerNegate(RtlEnlargedUnsignedMultiply(10000,Xc->Timeout)),
									&pPort->XoffCountTimeoutDpc);

                        SERIAL_INC_REFERENCE(Irp);
                    }

                }

                IoReleaseCancelSpinLock(OldIrql);

            }

        }

        //
        // Note that the following call will (probably) also cause
        // the current irp to be completed.
        //

        SerialGetNextIrp(pPort, CurrentOpIrp, QueueToProcess, NewIrp, CompleteCurrent);
            

        if(!*NewIrp) 
		{
            KIRQL OldIrql;

            IoAcquireCancelSpinLock(&OldIrql);
			Slxos_SyncExec(pPort, SerialProcessEmptyTransmit, pPort,0x21);
            IoReleaseCancelSpinLock(OldIrql);

            break;
        } 
		else if(IoGetCurrentIrpStackLocation(*NewIrp)->MajorFunction == IRP_MJ_FLUSH_BUFFERS) 
		{
            //
            // If we encounter a flush request we just want to get
            // the next irp and complete the flush.
            //
            // Note that if NewIrp is non-null then it is also
            // equal to CurrentWriteIrp.
            //

            ASSERT((*NewIrp) == (*CurrentOpIrp));
            (*NewIrp)->IoStatus.Status = STATUS_SUCCESS;
        } 
		else 
		{
            break;
        }

    } while (TRUE);

}

VOID
SerialCompleteWrite(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemContext1,
    IN PVOID SystemContext2
    )

/*++

Routine Description:

    This routine is merely used to complete any write.  It
    assumes that the status and the information fields of
    the irp are already correctly filled in.

Arguments:

    Dpc - Not Used.

    DeferredContext - Really points to the device extension.

    SystemContext1 - Not Used.

    SystemContext2 - Not Used.

Return Value:

    None.

--*/

{

    PPORT_DEVICE_EXTENSION pPort = DeferredContext;
    KIRQL OldIrql;

    UNREFERENCED_PARAMETER(Dpc);
    UNREFERENCED_PARAMETER(SystemContext1);
    UNREFERENCED_PARAMETER(SystemContext2);

    IoAcquireCancelSpinLock(&OldIrql);

    SerialTryToCompleteCurrent(
        pPort,
        NULL,
        OldIrql,
        STATUS_SUCCESS,
        &pPort->CurrentWriteIrp,
        &pPort->WriteQueue,
        NULL,
        &pPort->WriteRequestTotalTimer,
        SerialStartWrite,
        SerialGetNextWrite
        );

}

BOOLEAN
SerialProcessEmptyTransmit(
    IN PVOID Context
    )

/*++

Routine Description:

    This routine is used to determine if conditions are appropriate
    to satisfy a wait for transmit empty event, and if so to complete
    the irp that is waiting for that event.  It also call the code
    that checks to see if we should lower the RTS line if we are
    doing transmit toggling.

    NOTE: This routine is called by KeSynchronizeExecution.

    NOTE: This routine assumes that it is called with the cancel
          spinlock held.

Arguments:

    Context - Really a pointer to the device extension.

Return Value:

    This routine always returns FALSE.

--*/

{

    PPORT_DEVICE_EXTENSION pPort = Context;
	PCARD_DEVICE_EXTENSION pCard = pPort->pParentCardExt;

    if (pPort->IsrWaitMask && (pPort->IsrWaitMask & SERIAL_EV_TXEMPTY) 
	&& pPort->EmptiedTransmit && (!pPort->TransmitImmediate) 
	&& (!pPort->CurrentWriteIrp) && IsListEmpty(&pPort->WriteQueue)) 
	{

#if USE_NEW_TX_BUFFER_EMPTY_DETECT
		// On cards that are polled or interrupt when the card's Tx Buffer empties we 
		// can detect the Tx Empty Event very accurately otherwise we have to just signal the 
		// event when all the Write IRPs have been completed.  In this case there could and will  
		// still be data left in the card's buffer and UART FIFO when we signal the event.
		if(pPort->DetectEmptyTxBuffer)
		{
			if(Slxos_GetCharsInTxBuffer(pPort) || ((PCHAN)pPort->pChannel)->tx_fifo_count)	// Only if there is no data in the Tx Buffer will we signal.  
				return FALSE;				
		}
#endif
		pPort->HistoryMask |= SERIAL_EV_TXEMPTY;
    
		if(pPort->IrpMaskLocation) 
		{
            *pPort->IrpMaskLocation = pPort->HistoryMask;
            pPort->IrpMaskLocation = NULL;
            pPort->HistoryMask = 0;

            pPort->CurrentWaitIrp->IoStatus.Information = sizeof(ULONG);

			pPort->EmptiedTransmit = FALSE;

            KeInsertQueueDpc(&pPort->CommWaitDpc, NULL, NULL);
        }
    }

    return FALSE;

}

BOOLEAN
SerialGiveWriteToIsr(
    IN PVOID Context
    )

/*++

Routine Description:

    Try to start off the write by polling the interrupt routine.
    This will slip it in behind a transmit immediate char, or if
    that isn't available, the next write.

    NOTE: This routine is called by KeSynchronizeExecution.

    NOTE: This routine assumes that it is called with the
          cancel spin lock held.

Arguments:

    Context - Really a pointer to the device extension.

Return Value:

    This routine always returns FALSE.

--*/

{

    PPORT_DEVICE_EXTENSION pPort = Context;

    //
    // The current stack location.  This contains all of the
    // information we need to process this particular request.
    //
    PIO_STACK_LOCATION IrpSp;

    IrpSp = IoGetCurrentIrpStackLocation(pPort->CurrentWriteIrp);

    //
    // We might have a xoff counter request masquerading as a
    // write.  The length of these requests will always be one
    // and we can get a pointer to the actual character from
    // the data supplied by the user.
    //

    if (IrpSp->MajorFunction == IRP_MJ_WRITE) 
	{
        pPort->WriteLength = IrpSp->Parameters.Write.Length;
        pPort->WriteCurrentChar = pPort->CurrentWriteIrp->AssociatedIrp.SystemBuffer;
    } 
	else 
	{
        pPort->WriteLength = 1;
        pPort->WriteCurrentChar = ((PUCHAR)pPort->CurrentWriteIrp->AssociatedIrp.SystemBuffer) 
			+ FIELD_OFFSET(SERIAL_XOFF_COUNTER, XoffChar);
    }

    //
    // The isr now has a reference to the irp.
    //

    SERIAL_INC_REFERENCE(pPort->CurrentWriteIrp);

    //
    // Do a poll to start things going.
    //

    Slxos_PollForInterrupt(pPort->pParentCardExt,FALSE);

    return FALSE;

}

VOID
SerialCancelCurrentWrite(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp
    )

/*++

Routine Description:

    This routine is used to cancel the current write.

Arguments:

    DeviceObject - Pointer to the device object for this device

    Irp - Pointer to the IRP to be canceled.

Return Value:

    None.

--*/

{

    PPORT_DEVICE_EXTENSION pPort = DeviceObject->DeviceExtension;

    SerialTryToCompleteCurrent(
        pPort,
        SerialGrabWriteFromIsr,
        Irp->CancelIrql,
        STATUS_CANCELLED,
        &pPort->CurrentWriteIrp,
        &pPort->WriteQueue,
        NULL,
        &pPort->WriteRequestTotalTimer,
        SerialStartWrite,
        SerialGetNextWrite
        );

}

VOID
SerialWriteTimeout(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemContext1,
    IN PVOID SystemContext2
    )

/*++

Routine Description:

    This routine will try to timeout the current write.

Arguments:

    Dpc - Not Used.

    DeferredContext - Really points to the device extension.

    SystemContext1 - Not Used.

    SystemContext2 - Not Used.

Return Value:

    None.

--*/

{

    PPORT_DEVICE_EXTENSION pPort = DeferredContext;
    KIRQL OldIrql;

    UNREFERENCED_PARAMETER(Dpc);
    UNREFERENCED_PARAMETER(SystemContext1);
    UNREFERENCED_PARAMETER(SystemContext2);

    IoAcquireCancelSpinLock(&OldIrql);

    SerialTryToCompleteCurrent(
        pPort,
        SerialGrabWriteFromIsr,
        OldIrql,
        STATUS_TIMEOUT,
        &pPort->CurrentWriteIrp,
        &pPort->WriteQueue,
        NULL,
        &pPort->WriteRequestTotalTimer,
        SerialStartWrite,
        SerialGetNextWrite
        );

}

BOOLEAN
SerialGrabWriteFromIsr(
    IN PVOID Context
    )

/*++

Routine Description:


    This routine is used to grab the current irp, which could be timing
    out or cancelling, from the ISR

    NOTE: This routine is being called from KeSynchronizeExecution.

    NOTE: This routine assumes that the cancel spin lock is held
          when this routine is called.

Arguments:

    Context - Really a pointer to the device extension.

Return Value:

    Always false.

--*/

{

    PPORT_DEVICE_EXTENSION pPort = Context;

    //
    // Check if the write length is non-zero.  If it is non-zero
    // then the ISR still owns the irp.  We calculate the the number
    // of characters written and update the information field of the
    // irp with the characters written.  We then clear the write length
    // the isr sees.
    //

    if (pPort->WriteLength) 
	{
        //
        // We could have an xoff counter masquerading as a
        // write irp.  If so, don't update the write length.
        //

        if (IoGetCurrentIrpStackLocation(pPort->CurrentWriteIrp)->MajorFunction == IRP_MJ_WRITE) 
		{
            pPort->CurrentWriteIrp->IoStatus.Information 
				= IoGetCurrentIrpStackLocation(pPort->CurrentWriteIrp)->Parameters.Write.Length
				- pPort->WriteLength;
        } 
		else 
		{
            pPort->CurrentWriteIrp->IoStatus.Information = 0;
        }

        //
        // Since the isr no longer references this irp, we can
        // decrement its reference count.
        //

        SERIAL_DEC_REFERENCE(pPort->CurrentWriteIrp);

        pPort->WriteLength = 0;

    }

    return FALSE;

}

BOOLEAN
SerialGrabXoffFromIsr(
    IN PVOID Context
    )

/*++

Routine Description:

    This routine is used to grab an xoff counter irp from the
    isr when it is no longer masquerading as a write irp.  This
    routine is called by the cancel and timeout code for the
    xoff counter ioctl.


    NOTE: This routine is being called from KeSynchronizeExecution.

    NOTE: This routine assumes that the cancel spin lock is held
          when this routine is called.

Arguments:

    Context - Really a pointer to the device extension.

Return Value:

    Always false.

--*/

{

    PPORT_DEVICE_EXTENSION pPort = Context;

    if (pPort->CountSinceXoff) 
	{
        //
        // This is only non-zero when there actually is a Xoff ioctl
        // counting down.
        //

        pPort->CountSinceXoff = 0;

        //
        // We decrement the count since the isr no longer owns
        // the irp.
        //

        SERIAL_DEC_REFERENCE(pPort->CurrentXoffIrp);
    }

    return FALSE;

}

VOID
SerialCompleteXoff(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemContext1,
    IN PVOID SystemContext2
    )

/*++

Routine Description:

    This routine is merely used to truely complete an xoff counter irp.  It
    assumes that the status and the information fields of the irp are
    already correctly filled in.

Arguments:

    Dpc - Not Used.

    DeferredContext - Really points to the device extension.

    SystemContext1 - Not Used.

    SystemContext2 - Not Used.

Return Value:

    None.

--*/

{

    PPORT_DEVICE_EXTENSION pPort = DeferredContext;
    KIRQL OldIrql;

    UNREFERENCED_PARAMETER(Dpc);
    UNREFERENCED_PARAMETER(SystemContext1);
    UNREFERENCED_PARAMETER(SystemContext2);

    IoAcquireCancelSpinLock(&OldIrql);

    //
    // Turn this irp back into the current write irp so
    // that it will start of any writes behind it.
    //

    pPort->CurrentWriteIrp = pPort->CurrentXoffIrp;

    SerialTryToCompleteCurrent(
        pPort,
        NULL,
        OldIrql,
        STATUS_SUCCESS,
        &pPort->CurrentWriteIrp,
        &pPort->WriteQueue,
        NULL,
        &pPort->XoffCountTimer,
        SerialStartWrite,
        SerialGetNextWrite
        );

}

VOID
SerialTimeoutXoff(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemContext1,
    IN PVOID SystemContext2
    )

/*++

Routine Description:

    This routine is merely used to truely complete an xoff counter irp,
    if its timer has run out.

Arguments:

    Dpc - Not Used.

    DeferredContext - Really points to the device extension.

    SystemContext1 - Not Used.

    SystemContext2 - Not Used.

Return Value:

    None.

--*/

{

    PPORT_DEVICE_EXTENSION pPort = DeferredContext;
    KIRQL OldIrql;

    UNREFERENCED_PARAMETER(Dpc);
    UNREFERENCED_PARAMETER(SystemContext1);
    UNREFERENCED_PARAMETER(SystemContext2);

    IoAcquireCancelSpinLock(&OldIrql);

    //
    // Turn this irp back into the current write irp so
    // that it will start of any writes behind it.
    //

    pPort->CurrentWriteIrp = pPort->CurrentXoffIrp;

	SerialTryToCompleteCurrent(
        pPort,
        SerialGrabXoffFromIsr,
        OldIrql,
        STATUS_SERIAL_COUNTER_TIMEOUT,
        &pPort->CurrentWriteIrp,
        &pPort->WriteQueue,
        NULL,
        &pPort->XoffCountTimer,
        SerialStartWrite,
        SerialGetNextWrite
        );

}

VOID
SerialCancelCurrentXoff(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp
    )

/*++

Routine Description:

    This routine is used to cancel the current write.

Arguments:

    DeviceObject - Pointer to the device object for this device

    Irp - Pointer to the IRP to be canceled.

Return Value:

    None.

--*/

{

    PPORT_DEVICE_EXTENSION pPort = DeviceObject->DeviceExtension;

    //
    // Turn this irp back into the current write irp so
    // that it will start of any writes behind it.
    //

    pPort->CurrentWriteIrp = pPort->CurrentXoffIrp;

	SerialTryToCompleteCurrent(
        pPort,
        SerialGrabXoffFromIsr,
        Irp->CancelIrql,
        STATUS_CANCELLED,
        &pPort->CurrentWriteIrp,
        &pPort->WriteQueue,
        NULL,
        &pPort->XoffCountTimer,
        SerialStartWrite,
        SerialGetNextWrite
        );

}

BOOLEAN
SerialGiveXoffToIsr(
    IN PVOID Context
    )

/*++

Routine Description:


    This routine starts off the xoff counter.  It merely
    has to set the xoff count and increment the reference
    count to denote that the isr has a reference to the irp.

    NOTE: This routine is called by KeSynchronizeExecution.

    NOTE: This routine assumes that it is called with the
          cancel spin lock held.

Arguments:

    Context - Really a pointer to the device extension.

Return Value:

    This routine always returns FALSE.

--*/

{

    PPORT_DEVICE_EXTENSION pPort = Context;

    //
    // The current stack location.  This contains all of the
    // information we need to process this particular request.
    //
    PSERIAL_XOFF_COUNTER Xc = pPort->CurrentXoffIrp->AssociatedIrp.SystemBuffer;
    pPort->CountSinceXoff = Xc->Counter;

    //
    // The isr now has a reference to the irp.
    //

    SERIAL_INC_REFERENCE(pPort->CurrentXoffIrp);

    return FALSE;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\spx\mps\sx\incl\spx.h ===
//////////////////////////////////////////////////////////////////////////////////////////
//																						
//	File: SPX.H 
//
//	Contains:	Prototypes of functions to be supplied by a specific  
//				driver to integrate into NT generic PnP code.
//
//	Note:	All generic NT PnP code is prefixed by Spx_.
//			All funcions that are required to integrate into the generic 
//			code are prefixed by XXX_.
//
//
//////////////////////////////////////////////////////////////////////////////////////////
#ifndef SPX_H
#define SPX_H	


// Purpose:		Interpret resources given to card by PnP Manager.
//
// Must:		Store resource details in card extension.
NTSTATUS
XXX_CardGetResources(	
	IN PDEVICE_OBJECT pDevObject, 
	IN PCM_RESOURCE_LIST PResList,
	IN PCM_RESOURCE_LIST PTrResList
	);

// Purpose:		Initialise card.
//				Find out how many ports are attached.
// 
// Must:		Fill in NumberOfPorts field in card extension.
NTSTATUS
XXX_CardInit(IN PCARD_DEVICE_EXTENSION pCard);


// Purpose:		Start up the card.
//
// Must:		Connect up any interrupts.
NTSTATUS
XXX_CardStart(IN PCARD_DEVICE_EXTENSION pCard);

// Purpose:		Stop the card.
//
// Must:		Stop Card from interrupting.
NTSTATUS
XXX_CardStop(IN PCARD_DEVICE_EXTENSION pCard);


// Purpose:		Deinitialise the card.
//
// Must:		Disconnect any interrupts.
NTSTATUS
XXX_CardDeInit(IN PCARD_DEVICE_EXTENSION pCard);

// Purpose:		Initialise the port extension.
//
// Must:		Store DeviceID, HardwareIDs, DevDesc into the port extension.
//					
NTSTATUS
XXX_PortInit(PPORT_DEVICE_EXTENSION pPort);

// Purpose:		Start up the port.
//
// Must:		Get port ready to receive read and write commands.
NTSTATUS
XXX_PortStart(IN PPORT_DEVICE_EXTENSION pPort);


// Purpose:		Stop the port.
//
// Must:		Disconnect any resources and stop DPCs.
//				Do not delete the device object or symbolic link.
NTSTATUS
XXX_PortStop(IN PPORT_DEVICE_EXTENSION pPort);

// Purpose:		Deinitialise the port.
//
// Must:		Delete the device object & symbolic link.
NTSTATUS
XXX_PortDeInit(IN PPORT_DEVICE_EXTENSION pPort);

// Purpose:		Save the state of the card hardware.
//
// Must:		Save enough info to restore the hardware to exactly the 
//				same state when	full power resumes.
NTSTATUS
XXX_CardPowerDown(IN PCARD_DEVICE_EXTENSION pCard);

// Purpose:		Restore the state of the card hardware.
//
// Must:		Restore the hardware when full power resumes.			
NTSTATUS
XXX_CardPowerUp(IN PCARD_DEVICE_EXTENSION pCard);

// Purpose:		Save the state of the port hardware.
//
// Must:		Save enough info to restore the hardware to exactly the 
//				same state when	full power resumes.
NTSTATUS
XXX_PortPowerDown(IN PPORT_DEVICE_EXTENSION pPort);

// Purpose:		Restore the state of the port hardware.
//
// Must:		Restore the hardware when full power resumes.			
NTSTATUS
XXX_PortPowerUp(IN PPORT_DEVICE_EXTENSION pPort);

// Purpose:		Queries whether it is safe for the port to power down.
//
// Must:		Return STATUS_SUCCESS if OK to power down.			
NTSTATUS
XXX_PortQueryPowerDown(IN PPORT_DEVICE_EXTENSION pPort);

// Purpose:		Set hand shaking and flow control on a port.
VOID 
XXX_SetHandFlow(IN PPORT_DEVICE_EXTENSION pPort, IN PSERIAL_IOCTL_SYNC pS);

// Paging 
#ifdef ALLOC_PRAGMA
#pragma alloc_text (PAGE, XXX_CardGetResources)
#pragma alloc_text (PAGE, XXX_CardInit)
#pragma alloc_text (PAGE, XXX_CardDeInit)
#pragma alloc_text (PAGE, XXX_CardStart)
#pragma alloc_text (PAGE, XXX_CardStop)
#pragma alloc_text (PAGE, XXX_PortInit)
#pragma alloc_text (PAGE, XXX_PortDeInit)
#pragma alloc_text (PAGE, XXX_PortStart)
#pragma alloc_text (PAGE, XXX_PortStop)
#endif  


#endif	// End of SPX.H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\spx\mps\sx\inc\sx_card.h ===
/************************************************************************/
/*									*/
/*	Title		:	Card and Port Prototypes & Definitions	*/
/*									*/
/*	Author		:	N.P.Vassallo				*/
/*									*/
/*	Creation	:	18th September 1998			*/
/*									*/
/*	Version		:	1.1.0					*/
/*									*/
/*	Copyright	:	(c) Specialix International Ltd. 1998	*/
/*									*/
/*	Description	:	Prototypes, structures and definitions:	*/
/*					CARD_DEVICE_EXTENSION		*/
/*					PORT_DEVICE_EXTENSION		*/
/*									*/
/************************************************************************/

/* History...

1.0.0	18/09/98 NPV	Creation.

*/

#define		SLXOS_MAX_PORTS		(32)
#define		SLXOS_MAX_BOARDS	(4)
#define		SLXOS_MAX_MODULES	(4)
#define		SLXOS_REGISTER_SPAN	((ULONG)65536)

/*****************************************************************************
**************************                         ***************************
**************************   General Definitions   ***************************
**************************                         ***************************
*****************************************************************************/

#ifndef	_common_defs				/* If common definitions not already defined */
#define	_common_defs

#ifndef	_sx_defs				/* If SX definitions not already defined */
#define	_sx_defs
typedef	unsigned long	_u32;
typedef	unsigned short	_u16;
typedef	unsigned char	_u8;

#define	POINTER *
typedef _u32 POINTER pu32;
typedef _u16 POINTER pu16;
typedef _u8 POINTER pu8;
#endif

#define	DWORD	_u32
#define	ulong	_u32

#define	WORD	_u16
#define	ushort	_u16
#define	uint	_u16

#define	BYTE	_u8
#define	uchar	_u8

typedef char POINTER PSTR;
typedef	void POINTER PVOID;

#endif


#define		SERDIAG1	((ULONG)0x00000001)
#define		SERDIAG2	((ULONG)0x00000002)
#define		SERDIAG3	((ULONG)0x00000004)
#define		SERDIAG4	((ULONG)0x00000008)
#define		SERDIAG5	((ULONG)0x00000010)
#define		SERIRPPATH	((ULONG)0x00000020)
#define		SERINTERRUPT	((ULONG)0x04000000)
#define		SERPERFORM	((ULONG)0x08000000)
#define		SERDEBUG	((ULONG)0x10000000)
#define		SERFLOW		((ULONG)0x20000000)
#define		SERERRORS	((ULONG)0x40000000)
#define		SERBUGCHECK	((ULONG)0x80000000)

#ifndef	ESIL_XXX0				/* ESIL_XXX0 21/09/98 */
#if	DBG
extern ULONG SerialDebugLevel;
#define SpxDbgMsg(LEVEL,STRING)			\
	do					\
	{					\
		ULONG _level = (LEVEL);		\
		if(SerialDebugLevel & _level)	\
		{				\
			DbgPrint STRING;	\
		}				\
		if(_level == SERBUGCHECK)	\
		{				\
			ASSERT(FALSE);		\
		}				\
	} while (0)
#else
#define SpxDbgMsg(LEVEL,STRING) do {NOTHING;} while (0)
#endif
#endif						/* ESIL_XXX0 21/09/98 */


#ifndef	ESIL_XXX0				/* ESIL_XXX0 21/09/98 */
//
// This define gives the default Object directory
// that we should use to insert the symbolic links
// between the NT device name and namespace used by
// that object directory.

#define DEFAULT_DIRECTORY L"DosDevices"

typedef struct _CONFIG_DATA
{
	UNICODE_STRING	ObjectDirectory;
	UNICODE_STRING	NtNameForPort;
	UNICODE_STRING	SymbolicLinkName;
	UNICODE_STRING	ExternalNamePath;	/* Registry path for the external device name mapping */
	UCHAR		ChannelNumber;

} CONFIG_DATA,*PCONFIG_DATA;
#endif						/* ESIL_XXX0 21/09/98 */

/*****************************************************************************
**************************                           *************************
**************************   CARD_DEVICE_EXTENSION   *************************
**************************                           *************************
*****************************************************************************/

/* Card Device Extension Structure... */
   
typedef struct _CARD_DEVICE_EXTENSION
{
	COMMON_CARD_DEVICE_EXTENSION;			/* Common device extension structure */

#ifndef	ESIL_XXX0					/* ESIL_XXX0 21/09/98 */
	PDEVICE_OBJECT		DeviceObject;		/* Points to owning device object */
	UNICODE_STRING		DeviceName;		/* NT internal device name */
#endif							/* ESIL_XXX0 21/09/98 */

	PHYSICAL_ADDRESS	PCIConfigRegisters;
	ULONG				SpanOfPCIConfigRegisters;

/* Physical parameters... */

#ifdef	ESIL_XXX0					/* ESIL_XXX0 21/09/98 */
	PUCHAR			BaseController;		/* Pointer to base of card memory window */
#else							/* ESIL_XXX0 21/09/98 */
	PHYSICAL_ADDRESS	PhysAddr;		/* Physical address of card shared memory window */
	PUCHAR			Controller;		/* Pointer to base of card shared memory window */
	ULONG			SpanOfController;	/* Size of card shared memory window (in bytes) */
	ULONG			BusNumber;		/* Bus number */
	ULONG			SlotNumber;		/* Slot number in EISA/PCI system */
	ULONG			AddressSpace;		/* Type of address space (memory/IO) */
	KINTERRUPT_MODE		InterruptMode;		/* Interrupt mode (sharable/non-sharable) */
	INTERFACE_TYPE		InterfaceType;		/* Bus interface type */
	ULONG			OriginalVector;		/* Original (unmapped) interrupt vector */
	ULONG			OriginalIrql;		/* Original (unmapped) interrupt request level */
	ULONG			TrVector;		/* Interrupt vector */
	KIRQL			TrIrql;			/* Interrupt request level */
	KAFFINITY		ProcessorAffinity;	/* Interrupt processor affinity */
	PKINTERRUPT		Interrupt;		/* Points to interrupt object used by the card */
	BOOLEAN			InterruptShareable;	/* Indicates if card can share interrupts */
	PKSERVICE_ROUTINE	OurIsr;			/* Function pointer to Interrupt Service Routine */
	PVOID			OurIsrContext;		/* Context to be passed to "OurIsr" */
#endif							/* ESIL_XXX0 21/09/98 */
//	ULONG			CardType;		/* Defines the type of host card */
	BOOLEAN			UnMapRegisters;		/* Indicates if "controller" needs to be unmapped */
#ifdef	ESIL_XXX0					/* ESIL_XXX0 22/09/98 */
	_u32			UniqueId;		/* Unique hardware ID of card */
#endif							/* ESIL_XXX0 22/09/98 */

/* Functional parameters... */

	ULONG			PolledMode;		/* Indicates polled/interrupt mode */
	KTIMER			PolledModeTimer;	/* Used for polled mode processing */
	KDPC			PolledModeDpc;		/* Called to perform polled processing */
	ULONG			AutoIRQ;		/* Indicates auto IRQ selection */
	KSPIN_LOCK		DpcLock;		/* Lock for the DPC */
	BOOLEAN			DpcFlag;		/* Ownership flag for DPC */
	ULONG			MemoryHole;		/* If !0, don't report board memory usage */

/* Attached port details... */
	
	ULONG			ConfiguredNumberOfPorts;/* Number of ports expected on card */
	PPORT_DEV_EXT		PortExtTable[SLXOS_MAX_PORTS];
#ifndef	ESIL_XXX0					/* ESIL_XXX0 21/09/98 */
	ULONG			NumberOfPorts;		/* Number of ports on card */
	PCONFIG_DATA		Config[SLXOS_MAX_PORTS];
#endif							/* ESIL_XXX0 21/09/98 */

} CARD_DEVICE_EXTENSION, *PCARD_DEVICE_EXTENSION;


/*****************************************************************************
**************************                           *************************
**************************   PORT_DEVICE_EXTENSION   *************************
**************************                           *************************
*****************************************************************************/

/* Serial Port Device Extension Structure... */

typedef struct _PORT_DEVICE_EXTENSION
{
	COMMON_PORT_DEVICE_EXTENSION;			/* Common device extension structure */

#ifndef	ESIL_XXX0					/* ESIL_XXX0 21/09/98 */
	PDEVICE_OBJECT		DeviceObject;		/* Pointer to owning device object */
	UNICODE_STRING		DeviceName;		/* NT internal device name */
	UNICODE_STRING		SymbolicLinkName;	/* External device name */
	BOOLEAN			CreatedSymbolicLink;	/* Indicates if symbolic link was created */
	PCARD_DEV_EXT		pParentCardExt;		/* Pointer to owning card CARD_DEVICE_EXTENSION structure */
#endif							/* ESIL_XXX0 21/09/98 */
	_u32			SysPortNumber;		/* System port number */
	UNICODE_STRING		ObjectDirectory;	/* Pointer to object directory for symbolic name */
	UNICODE_STRING		NtNameForPort;		/* NT name for port without device prefix */
	UNICODE_STRING		ExternalNamePath;	/* Registry path for the external device name mapping */

/* Card related details... */

	PUCHAR			pChannel;		/* Pointer to CHANNEL structure in memory window */
	PKINTERRUPT		Interrupt;		/* Pointer to card interrupt object */
	PHYSICAL_ADDRESS	OriginalController;	/* Physical addresss of owning card */

/* Timing variables... */

	LARGE_INTEGER		IntervalTime;		/* Read interval time */
	LARGE_INTEGER		ShortIntervalAmount;	/* Short tread interval time */
	LARGE_INTEGER		LongIntervalAmount;	/* Long read interval time */
	LARGE_INTEGER		CutOverAmount;		/* Used to determine short/long interval time */
	LARGE_INTEGER		LastReadTime;		/* System time of last read */
	PLARGE_INTEGER		IntervalTimeToUse;	/* Interval timing delta time delay */

/* Queued IRP lists... */

	LIST_ENTRY		ReadQueue;		/* Head of read IRP list, protected by cancel spinlock */
	LIST_ENTRY		WriteQueue;		/* Head of write IRP list, protected by cancel spinlock */
	LIST_ENTRY		MaskQueue;		/* Head of set/wait mask IRP list, protected by cancel spinlock */
	LIST_ENTRY		PurgeQueue;		/* Head of purge IRP list, protected by cancel spinlock */

/* Current IRPs... */

	PIRP			CurrentReadIrp;		/* Pointer to current read IRP */
	PIRP			CurrentWriteIrp;	/* Pointer to current write IRP */
	PIRP			CurrentMaskIrp;		/* Pointer to current mask IRP */
	PIRP			CurrentPurgeIrp;	/* Pointer to current purge IRP */
	PIRP			CurrentWaitIrp;		/* Pointer to current wait IRP */
	PIRP			CurrentImmediateIrp;	/* Pointer to current send immediate IRP */
	PIRP			CurrentXoffIrp;		/* Pointer to current XOFF_COUNTER IRP */

/* Write IRP variables... */

	ULONG			WriteLength;		/* Write character count in current write IRP */
	PUCHAR			WriteCurrentChar;	/* Pointer to write character in current write IRP */

/* Read IRP variables... */

	PUCHAR			InterruptReadBuffer;	/* Read buffer current pointer in current read IRP */
	PUCHAR			ReadBufferBase;		/* Read buffer base pointer in current read IRP */
	ULONG			CharsInInterruptBuffer;	/* Characters read into read buffer */
	KSPIN_LOCK		BufferLock;		/* Spinlock protecting "CharsInInterruptBuffer" */
	PUCHAR			CurrentCharSlot;	/* Pointer at space to store new read data */
	PUCHAR			LastCharSlot;		/* Last valid position in read buffer */
	PUCHAR			FirstReadableChar;	/* First read character in read buffer */
	ULONG			BufferSize;		/* Read buffer size */
	ULONG			BufferSizePt8;		/* 80% read buffer size */
	ULONG			NumberNeededForRead;	/* Number of characters requested in current read IRP */

/* Mask IRP variables... */

	ULONG			IsrWaitMask;		/* Wait mask in current wait IRP */
	ULONG			HistoryMask;		/* History of masked events */
	ULONG			*IrpMaskLocation;	/* Pointer to mask location */

/* Serial port configuration... */

	ULONG			CurrentBaud;		/* Current baud rate */
	ULONG			SupportedBauds;		/* Bitmask defining supported baud rates */
	SERIAL_HANDFLOW		HandFlow;		/* Current handshaking and flow control settings */
	UCHAR			LineControl;		/* Current parity,databits,stopbits */
	SERIAL_CHARS		SpecialChars;		/* Current Special error/replacement characters */
	SERIAL_TIMEOUTS		Timeouts;		/* Read and write timeouts */
	UCHAR			ValidDataMask;		/* Read data mask */
	UCHAR			EscapeChar;		/* Escape character used with line/modem status strings */
	BOOLEAN			InsertEscChar;		/* Indicates of EscapeChar should be inserted */

/* Serial port status... */

	LONG			CountSinceXoff;		/* Nun chars read since XOFF counter started */
	ULONG			CountOfTryingToLowerRTS;/* Count of processes trying to lower RTS */
	BOOLEAN			TransmitImmediate;	/* Indicates of transmit immediate is pending */
	BOOLEAN			EmptiedTransmit;	/* Indicates transmit empty */
	BOOLEAN			DataInTxBuffer;		/* Indicates data has been placed in the card's Tx Buffer */
	BOOLEAN			DetectEmptyTxBuffer;/* Indicates we can detect when the card's Tx Buffer is empty */

	UCHAR			PendingOperation;	/* Pending CHANNEL hi_hstat operation */
	UCHAR			ImmediateChar;		/* Character to be transmitted immediately */
	UCHAR			LastStatus;		/* Last modem status (SX format) */
	UCHAR			LastModemStatus;	/* Last modem status (NT format) */
	ULONG			TXHolding;		/* Reasons for transmit blocked */
	ULONG			RXHolding;		/* Reasons for receive blocked */
	ULONG			ErrorWord;		/* Error conditions */
	ULONG			TotalCharsQueued;	/* Total number of queued characters in all write IRPs */
	LONG			CountOnLastRead;	/* Number of chars read last time interval timer DPC ran */
	ULONG			ReadByIsr;		/* Number of characters read during ISR */

	KSPIN_LOCK		ControlLock;		/* Used to protect certain fields */

#ifdef	ESIL_XXX0					/* ESIL_XXX0 15/10/98 */

/* Saved data during power down... */

	_u8		saved_hi_rxipos;		/* Saved Receive buffer input index */
	_u8		saved_hi_rxopos;		/* Saved Receive buffer output index */
	_u8		saved_hi_txopos;		/* Saved Transmit buffer output index */
	_u8		saved_hi_txipos;		/* Saved Transmit buffer input index */
	_u8		saved_hi_txbuf[256];		/* Saved Transmit buffer */
	_u8		saved_hi_rxbuf[256];		/* Saved Receive buffer */

#endif							/* ESIL_XXX0 15/10/98 */

/* Deferred procedure calls... */
	
	KDPC			CompleteWriteDpc;	/* DPC used to complete write IRPs */
	KDPC			CompleteReadDpc;	/* DPC used to complete read IRPs */
	KDPC			TotalReadTimeoutDpc;	/* DPC used to handle read total timeout */
	KDPC			IntervalReadTimeoutDpc;	/* DPC used to handle read interval timeout */
	KDPC			TotalWriteTimeoutDpc;	/* DPC used to handle write total timeout */
	KDPC			CommErrorDpc;		/* DPC used to handle cancel on error */
	KDPC			CommWaitDpc;		/* DPC used to handle waking IRPs waiting on an event */
	KDPC			CompleteImmediateDpc;	/* DPC used to handle transmitting an immediate character */
	KDPC			TotalImmediateTimeoutDpc;/* DPC used to handle immediate char timeout */
	KDPC			XoffCountTimeoutDpc;	/* DPC used to handle XOFF_COUNT timeout */
	KDPC			XoffCountCompleteDpc;	/* DPC used to complete XOFF_COUNT IRP */
	KDPC			StartTimerLowerRTSDpc;	/* DPC used to check for RTS lowering */
	KDPC			PerhapsLowerRTSDpc;	/* DPC used to check for RTS lowering */
	KDPC			SlxosDpc;		/* DPC used to handle interface with card */

/* Timers... */

	KTIMER			ReadRequestTotalTimer;	/* Timer used to handle total read request timeout */
	KTIMER			ReadRequestIntervalTimer;/* Timer used to handle interval read timeout */
	KTIMER			WriteRequestTotalTimer;	/* Timer used to handle total write request timeout */
	KTIMER			ImmediateTotalTimer;	/* Timer used to handle send immediate timeout */
	KTIMER			XoffCountTimer;		/* Timer used to handle XOFF_COUNT timeout */
	KTIMER			LowerRTSTimer;		/* Timer used to handle lower RTS timing */

	
	
} PORT_DEVICE_EXTENSION, *PPORT_DEVICE_EXTENSION;

/* PORT_DEVICE_EXTENSION.CountOnLastRead definitions... */
#define		SERIAL_COMPLETE_READ_CANCEL	((LONG)-1)
#define		SERIAL_COMPLETE_READ_TOTAL	((LONG)-2)
#define		SERIAL_COMPLETE_READ_COMPLETE	((LONG)-3)

/* PORT_DEVICE_EXTENSION.LineControl definitions... */
#define		SERIAL_5_DATA		((UCHAR)0x00)
#define		SERIAL_6_DATA		((UCHAR)0x01)
#define		SERIAL_7_DATA		((UCHAR)0x02)
#define		SERIAL_8_DATA		((UCHAR)0x03)
#define		SERIAL_DATA_MASK	((UCHAR)0x03)

#define		SERIAL_1_STOP		((UCHAR)0x00)
#define		SERIAL_1_5_STOP		((UCHAR)0x04) // Only valid for 5 data bits
#define		SERIAL_2_STOP		((UCHAR)0x04) // Not valid for 5 data bits
#define		SERIAL_STOP_MASK	((UCHAR)0x04)

#define		SERIAL_NONE_PARITY	((UCHAR)0x00)
#define		SERIAL_ODD_PARITY	((UCHAR)0x08)
#define		SERIAL_EVEN_PARITY	((UCHAR)0x18)
#define		SERIAL_MARK_PARITY	((UCHAR)0x28)
#define		SERIAL_SPACE_PARITY	((UCHAR)0x38)
#define		SERIAL_PARITY_MASK	((UCHAR)0x38)
#define		SERIAL_LCR_BREAK	0x40

/* PORT_DEVICE_EXTENSION.SpecialChars default xon/xoff characters... */
#define		SERIAL_DEF_XON		0x11
#define		SERIAL_DEF_XOFF		0x13

/* PORT_DEVICE_EXTENSION.TXHolding definitions... */
#define		SERIAL_TX_CTS		((ULONG)0x01)
#define		SERIAL_TX_DSR		((ULONG)0x02)
#define		SERIAL_TX_DCD		((ULONG)0x04)
#define		SERIAL_TX_XOFF		((ULONG)0x08)
#define		SERIAL_TX_BREAK		((ULONG)0x10)

/* PORT_DEVICE_EXTENSION.RXHolding definitions... */
#define		SERIAL_RX_DTR		((ULONG)0x01)
#define		SERIAL_RX_XOFF		((ULONG)0x02)
#define		SERIAL_RX_RTS		((ULONG)0x04)
#define		SERIAL_RX_DSR		((ULONG)0x08)

/* PORT_DEVICE_EXTENSION.LastStatus definitions... */
#define		SERIAL_LSR_OE		0x02
#define		SERIAL_LSR_PE		0x04
#define		SERIAL_LSR_FE		0x08
#define		SERIAL_LSR_BI		0x10

/* 16550 Modem Control Register definitions... */
#define		SERIAL_MCR_DTR		0x01
#define		SERIAL_MCR_RTS		0x02

/* 16550 Modem Status Register definitions... */
#define		SERIAL_MSR_DCTS		0x01
#define		SERIAL_MSR_DDSR		0x02
#define		SERIAL_MSR_TERI		0x04
#define		SERIAL_MSR_DDCD		0x08
#define		SERIAL_MSR_CTS		0x10
#define		SERIAL_MSR_DSR		0x20
#define		SERIAL_MSR_RI		0x40
#define		SERIAL_MSR_DCD		0x80

/* End of SX_CARD.H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\spx\mps\sx\inc\sx_ver.h ===
/************************************************************************
*									
*	Title:		Version and ESIL Log File for SX NT Driver.	
*									
*	Author:		N.P.Vassallo					
*									
*	Creation:	21st September 1998				
*									
*	Description:	This file has three sections:			
*					Current version definition,		
*					Previous version changes,		
*					ESIL modification definitions		
*									
************************************************************************/

/*****************************************************************************
*****************************                     ****************************
*****************************   Current Version   ****************************
*****************************                     ****************************
*****************************************************************************/

/* The following definitions are used to define the driver "properties" */

#define	VER_MAJOR			01
#define	VER_MINOR			01
#define	VER_REVISION		02

#define VER_BUILD			0039
#define VER_BUILDSTR		"0039"

#define	VERSION_NUMBER		VER_MAJOR,VER_MINOR,VER_REVISION,VER_BUILD
#define VERSION_NUMBER_STR	"1.1.2." VER_BUILDSTR

#define COMPANY_NAME		"Perle Systems Ltd. " 
#define COPYRIGHT_YEARS		"2002 "
#define COPYRIGHT_SYMBOL	" "

#define PRODUCT_NAME		"SX"

#define SOFTWARE_NAME		" Serial Device Driver "
#define DRIVER_FILENAME 	"SX.SYS"


/* Latest changes...

Version		Date	 Author	Description
=======		====	 ======	===========

*/

/*****************************************************************************
****************************                       ***************************
****************************   Previous Versions   ***************************
****************************                       ***************************
******************************************************************************

Version		Date	 Author	Description
=======		====	 ======	===========

*/

/*****************************************************************************
****************************                      ****************************
****************************   ESIL Definitions   ****************************
****************************                      ****************************
*****************************************************************************/

//#define	CHECK_COMPLETED

#ifdef	CHECK_COMPLETED
void	DisplayCompletedIrp(struct _IRP *Irp,int index);
#endif

/* ESIL	Date	 Author		Description */
/* ====	====	 ======		=========== */

/* XXX0 21/09/98 NPV		Conditional compilation for NT5 driver. */
#define	ESIL_XXX0

/* End of VERSIONS.H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\spx\mps\sx\inc\slxosexp.h ===
/***************************************************************************\
*                                                                           *
* SLXOSEXP.H                                                                *
*                                                                           *
* SI Intelligent I/O Board driver                                           *
*	Copyright (c) Specialix 1993                                        *
*                                                                           *
* Prototypes and macros that are used throughout the driver.                *
*                                                                           *
\***************************************************************************/

BOOLEAN Slxos_Present (IN PVOID Context);

int Slxos_ResetBoard (IN PVOID Context);
#define CARD_RESET_ERROR 		1
#define DCODE_OR_NO_MODULES_ERROR	2 	
#define MODULE_MIXTURE_ERROR		3
#define NON_SX_HOST_CARD_ERROR		4
#define SUCCESS 			0

BOOLEAN Slxos_ResetChannel (IN PVOID Context);
VOID    Slxos_EnableAllInterrupts (IN PVOID Context);

BOOLEAN Slxos_SetDTR (IN PVOID Context);
BOOLEAN Slxos_ClearDTR (IN PVOID Context);
BOOLEAN Slxos_SetRTS (IN PVOID Context);
BOOLEAN Slxos_ClearRTS (IN PVOID Context);
BOOLEAN	Slxos_FlushTxBuff(IN PVOID Context);

BOOLEAN Slxos_Interrupt (IN PVOID Context);
VOID	Slxos_IsrDpc				/* SLXOS_NT.C */
(
	IN PKDPC 		Dpc,
	IN PDEVICE_OBJECT	DeviceObject,
	IN PIRP 		Irp,
	IN PVOID 		Context
);
VOID	Slxos_PolledDpc(IN PKDPC Dpc,IN PVOID Context,IN PVOID SysArg1,IN PVOID SysArg2);
VOID	Slxos_SyncExec(PPORT_DEVICE_EXTENSION pPort,PKSYNCHRONIZE_ROUTINE SyncRoutine,PVOID SyncContext,int index);

BOOLEAN	Slxos_PollForInterrupt(IN PVOID Context,IN BOOLEAN Obsolete);
void	SpxCopyBytes(PUCHAR To,PUCHAR From,ULONG Count);

BOOLEAN	Slxos_CheckBaud(PPORT_DEVICE_EXTENSION pPort,ULONG BaudRate);
BOOLEAN Slxos_SetBaud (IN PVOID Context);
BOOLEAN Slxos_SetLineControl (IN PVOID Context);
BOOLEAN Slxos_SendXon (IN PVOID Context);
BOOLEAN Slxos_SetFlowControl (IN PVOID Context);
VOID    Slxos_SetChars (IN PVOID Context);

VOID    Slxos_DisableAllInterrupts (IN PVOID Context);

BOOLEAN Slxos_TurnOnBreak (IN PVOID Context);
BOOLEAN Slxos_TurnOffBreak (IN PVOID Context);

UCHAR   Slxos_GetModemStatus (IN PVOID Context);
ULONG   Slxos_GetModemControl (IN PVOID Context);

VOID    Slxos_Resume (IN PVOID Context);
ULONG   Slxos_GetCharsInTxBuffer(IN PVOID Context);

UCHAR	si2_z280_download[];
int	si2_z280_dsize;

UCHAR	si3_t225_download[];			/* SI3_T225.C */
int	si3_t225_dsize;				/* SI3_T225.C */
USHORT	si3_t225_downloadaddr;			/* SI3_T225.C */

UCHAR	si3_t225_bootstrap[];			/* SI3_T225.C */
int	si3_t225_bsize;				/* SI3_T225.C */
USHORT	si3_t225_bootloadaddr;			/* SI3_T225.C */

UCHAR	si4_cf_download[];				/* SX_CSX.C */
int	si4_cf_dsize;				/* SX_CSX.C */
USHORT	si4_cf_downloadaddr;			/* SX_CSX.C */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\spx\mps\sx\incl\spx_defs.h ===
/****************************************************************************************
*																						*
*	Header:		SPX_DEFS.H 																*
*																						*
*	Creation:	15th October 1998														*
*																						*
*	Author:		Paul Smith																*
*																						*
*	Version:	1.0.0																	*
*																						*
*	Contains:	Definitions for all the common PnP and power code.						*
*																						*
****************************************************************************************/

#if	!defined(SPX_DEFS_H)
#define SPX_DEFS_H	

static const PHYSICAL_ADDRESS PhysicalZero = {0};

#define DEVICE_OBJECT_NAME_LENGTH       128
#define SYMBOLIC_NAME_LENGTH            128

#define SERIAL_DEVICE_MAP               L"SERIALCOMM"


// This define gives the default Object directory
// that we should use to insert the symbolic links
// between the NT device name and namespace used by
// that object directory.
#define DEFAULT_DIRECTORY		L"DosDevices"

#define MAX_ERROR_LOG_INSERT	52


// File IDs for Event Logging (top 8 bits only).
#define SPX_INIT_C		((ULONG)0x01000000)
#define SPX_PNP_C		((ULONG)0x02000000)
#define SPX_POWR_C		((ULONG)0x03000000)
#define SPX_DISP_C		((ULONG)0x04000000)
#define SPX_UTILS_C		((ULONG)0x05000000)
#define SPX_IIOC_C		((ULONG)0x06000000)




// COMMON_OBJECT_DATA.PnpPowerFlags definitions... 
#define	PPF_STARTED			0x00000001		// Device has been started 
#define	PPF_STOP_PENDING	0x00000002		// Device stop is pending 
#define	PPF_REMOVE_PENDING	0x00000004		// Device remove is pending 
#define	PPF_REMOVED			0x00000008		// Device has been removed 
#define	PPF_POWERED			0x00000010		// Device has been powered up 
			
typedef enum _SPX_MEM_COMPARES 
{
	AddressesAreEqual,
	AddressesOverlap,
	AddressesAreDisjoint

}SPX_MEM_COMPARES, *PSPX_MEM_COMPARES;

// IRP Counters
#define IRP_SUBMITTED		0x00000001	
#define IRP_COMPLETED		0x00000002
#define IRP_QUEUED			0x00000003
#define IRP_DEQUEUED		0x00000004


extern UNICODE_STRING SavedRegistryPath;	// Driver Registry Path.


#endif	// End of SPX_DEFS.H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\spx\mps\sx\inc\slxos_nt.h ===
/*

    #########     ##              ##        ##      ########        #########
   ##########     ##              ##        ##     ##########      ##########
  ##              ##                ##    ##      ##        ##    ##
  ##              ##                ##    ##      ##        ##    ##
   #########      ##                  ####        ##        ##     #########
    #########     ##                  ####        ##        ##      #########
            ##    ##                  ####        ##        ##              ##
            ##    ##                  ####        ##        ##              ##
  ##        ##    ##                ##    ##      ##        ##    ##        ##
  ##        ##    ##                ##    ##      ##        ##    ##        ##
   ##########     ############    ##        ##     ##########      ##########
    ########      ############    ##        ##      ########        ########

	  SI Intelligent I/O Board driver
	  Copyright (c) Specialix International 1993
*/

#include	"sxwindow.h"				/* Shared Memory Window Definitions */
#include	"sxboards.h"				/* SX Board Hardware Definitions */

#define	ResetBoardInt(pCard)												\
	switch(pCard->CardType)													\
	{																		\
	case SiHost_1:															\
		pCard->Controller[0xa000] = 0;										\
		pCard->Controller[0xe000] = 0;										\
		break;																\
																			\
	case Si_2:																\
	{																		\
		UCHAR	c;															\
		WRITE_PORT_UCHAR((PUCHAR)0x96, (UCHAR)((pCard->SlotNumber-1) | 8));	\
		c = READ_PORT_UCHAR((PUCHAR)0x102);									\
		c &= ~0x08;															\
		WRITE_PORT_UCHAR((PUCHAR)0x102, c);									\
		c |= 0x08;															\
		WRITE_PORT_UCHAR((PUCHAR)0x102, c);									\
		WRITE_PORT_UCHAR((PUCHAR)0x96, 0);									\
		break;																\
	}																		\
																			\
	case SiHost_2:															\
		pCard->Controller[0x7FFD] = 0x00;									\
		pCard->Controller[0x7FFD] = 0x10;									\
		break;																\
																			\
	case SiEisa:															\
		READ_PORT_UCHAR((PUCHAR)((pCard->SlotNumber << 12) | 0xc03));		\
		break;																\
																			\
	case SiPCI:																\
		pCard->Controller[SI2_PCI_SET_IRQ] = 0;								\
		break;																\
																			\
	case Si3Isa:															\
	case Si3Eisa:															\
	case Si3Pci:															\
	case SxPlusPci:															\
		pCard->Controller[SX_RESET_IRQ]=0;									\
		break;																\
																			\
	default:																\
		break;																\
	}



/////////////////////////////////////////////////////////////////////////////
// Macro to sent configure port command to firmware
//
// If in IDLE_OPEN then we can configure it right now.
// If we are in a transient state that the firmware will return to IDLE_OPEN 
// soon we can do the config next.  So we set PendingOperation to HS_CONFIG.
//
#define SX_CONFIGURE_PORT(pPort, channelControl)			\
	switch (channelControl->hi_hstat)						\
	{														\
	case HS_IDLE_OPEN:										\
		channelControl->hi_hstat = HS_CONFIG;				\
		pPort->PendingOperation = HS_IDLE_OPEN;				\
		break;												\
															\
	case HS_LOPEN:											\
	case HS_MOPEN:											\
	case HS_IDLE_MPEND:										\
	case HS_CONFIG:											\
	case HS_STOP:											\
	case HS_RESUME:											\
	case HS_WFLUSH:											\
	case HS_RFLUSH:											\
	case HS_SUSPEND:										\
	case HS_CLOSE:											\
		pPort->PendingOperation = HS_CONFIG;				\
		break;												\
															\
	default:												\
		break;												\
	}		

/* End of SLXOS_NT.H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\spx\mps\sx\inc\sx_defs.h ===
/* SX Card and Port definitions... */

#define PRODUCT_MAX_PORTS		32

/* Port device object name... */
#define PORT_PDO_NAME_BASE		L"\\Device\\SXPort"

// File IDs for Event Logging (top 8 bits only).
#define SX_PNP_C		((ULONG)0x010000)
#define SX_W2K_C		((ULONG)0x020000)

// Tag used for memory allocations (must be 4 bytes in reverse).
#define MEMORY_TAG				'*XS*'


// SX HardwareIDs
#define SX_ISA_HWID		L"SPX_SX001"								// SX ISA (T225) card
#define SX_PCI_HWID		L"PCI\\VEN_11CB&DEV_2000&SUBSYS_020011CB"	// SX PCI (T225) card
#define SXPLUS_PCI_HWID	L"PCI\\VEN_11CB&DEV_2000&SUBSYS_030011CB"	// SX+ PCI (MCF5206e) card

#define SIXIO_ISA_HWID	L"SPX_SIXIO001"								// SIXIO ISA (Z280) card
#define SIXIO_PCI_HWID	L"PCI\\VEN_11CB&DEV_4000&SUBSYS_040011CB"	// SIXIO PCI (Z280) card


// SX CardTypes
#define	SiHost_1	0
#define	SiHost_2	1
#define	Si_2		2
#define	SiEisa		3
#define	SiPCI		4
#define	Si3Isa		5
#define	Si3Eisa		6
#define	Si3Pci		7
#define	SxPlusPci	8


/* End of SXDEFS.H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\spx\mps\sx\inc\sxboards.h ===
/************************************************************************/
/*									*/
/*	Title		:	SX/SI/XIO Board Hardware Definitions	*/
/*									*/
/*	Author		:	N.P.Vassallo				*/
/*									*/
/*	Creation	:	16th March 1998				*/
/*									*/
/*	Version		:	3.0.0					*/
/*									*/
/*	Copyright	:	(c) Specialix International Ltd. 1998	*/
/*									*/
/*	Description	:	Prototypes, structures and definitions	*/
/*				describing the SX/SI/XIO board hardware	*/
/*									*/
/************************************************************************/

/* History...

3.0.0	16/03/98 NPV	Creation.

*/

#ifndef	_sxboards_h				/* If SXBOARDS.H not already defined */
#define	_sxboards_h    1

/*****************************************************************************
*******************************                 ******************************
*******************************   Board Types   ******************************
*******************************                 ******************************
*****************************************************************************/

/* BUS types... */
#define		BUS_ISA		0
#define		BUS_MCA		1
#define		BUS_EISA	2
#define		BUS_PCI		3

/* Board phases... */
#define		SI1_Z280	1
#define		SI2_Z280	2
#define		SI3_T225	3
 /* @@@ Changes for CSX 22/1/99 */
#define    SI4_MCF5206E 4
/* end */

/* Board types... */
#define		CARD_TYPE(bus,phase)	(bus<<4|phase)
#define		CARD_BUS(type)		((type>>4)&0xF)
#define		CARD_PHASE(type)	(type&0xF)

#define		TYPE_SI2_ISA		CARD_TYPE(BUS_ISA,SI2_Z280)
#define		TYPE_SI2_EISA		CARD_TYPE(BUS_EISA,SI2_Z280)
#define		TYPE_SI2_PCI		CARD_TYPE(BUS_PCI,SI2_Z280)
 /* @@@ Changes for CSX 22/1/99 */
/* end */

#define		TYPE_SX_ISA		CARD_TYPE(BUS_ISA,SI3_T225)
#define		TYPE_SX_PCI		CARD_TYPE(BUS_PCI,SI3_T225)
 /* @@@ Changes for CSX 22/1/99 */
 #define  TYPE_CSX_PCI    CARD_TYPE(BUS_PCI,SI4_MCF5206E)
/* end */
/*****************************************************************************
******************************                  ******************************
******************************   Phase 2 Z280   ******************************
******************************                  ******************************
*****************************************************************************/

/* ISA board details... */
#define		SI2_ISA_WINDOW_LEN	0x8000		/* 32 Kbyte shared memory window */
#define 	SI2_ISA_MEMORY_LEN	0x7FF8		/* Usable memory */
#define		SI2_ISA_ADDR_LOW	0x0A0000	/* Lowest address = 640 Kbyte */
#define		SI2_ISA_ADDR_HIGH	0xFF8000	/* Highest address = 16Mbyte - 32Kbyte */
#define		SI2_ISA_ADDR_STEP	SI2_ISA_WINDOW_LEN/* ISA board address step */
#define		SI2_ISA_IRQ_MASK	0x9800		/* IRQs 15,12,11 */

/* ISA board, register definitions... */
#define		SI2_ISA_ID_BASE		0x7FF8			/* READ:  Board ID string */
#define		SI2_ISA_RESET		SI2_ISA_ID_BASE		/* WRITE: Host Reset */
#define		SI2_ISA_IRQ11		(SI2_ISA_ID_BASE+1)	/* WRITE: Set IRQ11 */
#define		SI2_ISA_IRQ12		(SI2_ISA_ID_BASE+2)	/* WRITE: Set IRQ12 */
#define		SI2_ISA_IRQ15		(SI2_ISA_ID_BASE+3)	/* WRITE: Set IRQ15 */
#define		SI2_ISA_IRQSET		(SI2_ISA_ID_BASE+4)	/* WRITE: Set Host Interrupt */
#define		SI2_ISA_INTCLEAR	(SI2_ISA_ID_BASE+5)	/* WRITE: Enable Host Interrupt */

#define		SI2_ISA_IRQ11_SET	0x10
#define		SI2_ISA_IRQ11_CLEAR	0x00
#define		SI2_ISA_IRQ12_SET	0x10
#define		SI2_ISA_IRQ12_CLEAR	0x00
#define		SI2_ISA_IRQ15_SET	0x10
#define		SI2_ISA_IRQ15_CLEAR	0x00
#define		SI2_ISA_INTCLEAR_SET	0x10
#define		SI2_ISA_INTCLEAR_CLEAR	0x00
#define		SI2_ISA_IRQSET_CLEAR	0x10
#define		SI2_ISA_IRQSET_SET	0x00
#define		SI2_ISA_RESET_SET	0x00
#define		SI2_ISA_RESET_CLEAR	0x10

/* PCI board details... */
#define		SI2_PCI_WINDOW_LEN	0x100000	/* 1 Mbyte memory window */

/* PCI board register definitions... */
#define		SI2_PCI_SET_IRQ		0x40001		/* Set Host Interrupt  */
#define		SI2_PCI_RESET		0xC0001		/* Host Reset */

/*****************************************************************************
******************************                  ******************************
******************************   Phase 3 T225   ******************************
******************************                  ******************************
*****************************************************************************/

/* General board details... */
#define		SX_WINDOW_LEN		32*1024		/* 32 Kbyte memory window */

/* ISA board details... */
#define		SX_ISA_ADDR_LOW		0x0A0000	/* Lowest address = 640 Kbyte */
#define		SX_ISA_ADDR_HIGH	0xFF8000	/* Highest address = 16Mbyte - 32Kbyte */
#define		SX_ISA_ADDR_STEP	SX_WINDOW_LEN	/* ISA board address step */
#define		SX_ISA_IRQ_MASK		0x9E00		/* IRQs 15,12,11,10,9 */

/* Hardware register definitions... */
#define		SX_EVENT_STATUS		0x7800		/* READ:  T225 Event Status */
#define		SX_EVENT_STROBE		0x7800		/* WRITE: T225 Event Strobe */
#define		SX_EVENT_ENABLE		0x7880		/* WRITE: T225 Event Enable */
#define		SX_VPD_ROM		0x7C00		/* READ:  Vital Product Data ROM */
#define		SX_CONFIG		0x7C00		/* WRITE: Host Configuration Register */
#define		SX_IRQ_STATUS		0x7C80		/* READ:  Host Interrupt Status */
#define		SX_SET_IRQ		0x7C80		/* WRITE: Set Host Interrupt */
#define		SX_RESET_STATUS		0x7D00		/* READ:  Host Reset Status */
#define		SX_RESET		0x7D00		/* WRITE: Host Reset */
#define		SX_RESET_IRQ		0x7D80		/* WRITE: Reset Host Interrupt */

/* SX_VPD_ROM definitions... */
#define		SX_VPD_SLX_ID1		0x00
#define		SX_VPD_SLX_ID2		0x01
#define		SX_VPD_HW_REV		0x02
#define		SX_VPD_HW_ASSEM		0x03
#define		SX_VPD_UNIQUEID4	0x04
#define		SX_VPD_UNIQUEID3	0x05
#define		SX_VPD_UNIQUEID2	0x06
#define		SX_VPD_UNIQUEID1	0x07
#define		SX_VPD_MANU_YEAR	0x08
#define		SX_VPD_MANU_WEEK	0x09
#define		SX_VPD_IDENT		0x10
#define		SX_VPD_IDENT_STRING	"JET HOST BY KEV#"

/* SX unique identifiers... */
#define		SX_UNIQUEID_MASK	0xF0
#define		SX_ISA_UNIQUEID1	0x20
#define		SX_PCI_UNIQUEID1	0x50

/* SX_CONFIG definitions... */
#define		SX_CONF_BUSEN		0x02		/* Enable T225 memory and I/O */
#define		SX_CONF_HOSTIRQ		0x04		/* Enable board to host interrupt */

/* SX bootstrap... */
#define		SX_BOOTSTRAP		"\x28\x20\x21\x02\x60\x0a"
#define		SX_BOOTSTRAP_SIZE	6
#define		SX_BOOTSTRAP_ADDR	(0x8000-SX_BOOTSTRAP_SIZE)

/* @@@ Changes for CSX 22/1/99 */
/*****************************************************************************
******************************                  ******************************
******************************   Phase 4 MCF5206e Coldfire   *****************
******************************                  ******************************
*****************************************************************************/

/* General board details... */
#define		CSX_WINDOW_LEN		128*1024		/* 128 Kbyte memory window ?shadow? */
#define    CSX_SM_OFFSET 0x18000   /* i.e 92k  which is the offset of the shared memory window within the 128k  card window */

/* Hardware register definitions... */
/* #define		SX_EVENT_STATUS		0x7800	*/	/* READ:  T225 Event Status */
/* #define		SX_EVENT_STROBE		0x7800	*/	/* WRITE: T225 Event Strobe */
/* #define		SX_EVENT_ENABLE		0x7880	*/	/* WRITE: T225 Event Enable */
/* #define		SX_VPD_ROM		      0x7C00	*/	/* READ:  Vital Product Data ROM */
/* #define		SX_CONFIG		      0x7C00	*/	/* WRITE: Host Configuration Register */
/* #define		SX_IRQ_STATUS		   0x7C80	*/	/* READ:  Host Interrupt Status */
/* #define		SX_SET_IRQ		      0x7C80	*/	/* WRITE: Set Host Interrupt */
/* #define		SX_RESET_STATUS		0x7D00	*/	/* READ:  Host Reset Status */
/* #define		SX_RESET		         0x7D00	*/	/* WRITE: Host Reset */
/* #define		SX_RESET_IRQ		   0x7D80	*/	/* WRITE: Reset Host Interrupt */

/* SX_VPD_ROM definitions... */
/*
 #define		SX_VPD_SLX_ID1		0x00
 #define		SX_VPD_SLX_ID2		0x01
 #define		SX_VPD_HW_REV		0x02
 #define		SX_VPD_HW_ASSEM		0x03
 #define		SX_VPD_UNIQUEID4	0x04
 #define		SX_VPD_UNIQUEID3	0x05
 #define		SX_VPD_UNIQUEID2	0x06
 #define		SX_VPD_UNIQUEID1	0x07
 #define		SX_VPD_MANU_YEAR	0x08
 #define		SX_VPD_MANU_WEEK	0x09
 #define		SX_VPD_IDENT		0x10
 #define		SX_VPD_IDENT_STRING	"JET HOST BY KEV#"
*/

/* SX unique identifiers... */
#define		CSX_UNIQUEID_MASK	0xF0
#define		CSX_PCI_UNIQUEID1	0x70

/* SX_CONFIG definitions... */
/* #define		SX_CONF_BUSEN		0x02	   */	 /* Enable T225 memory and I/O */
/* #define		SX_CONF_HOSTIRQ		0x04	*/ 	/* Enable board to host interrupt */


/* end changes */

/*****************************************************************************
**********************************          **********************************
**********************************   EISA   **********************************
**********************************          **********************************
*****************************************************************************/

/* EISA ID definitions... */
#define		SI2_EISA_ID_BASE	0xC80			/* EISA ID base address */
#define		SI2_EISA_ID_LO		SI2_EISA_ID_BASE	/* EISA ID Ports LOW */
#define		SI2_EISA_ID_MI		(SI2_EISA_ID_BASE+1)	/* EISA ID Ports MIDDLE */
#define		SI2_EISA_ID_HI		(SI2_EISA_ID_BASE+2)	/* EISA ID Ports HIGH */
#define		SI2_EISA_ID_REV		(SI2_EISA_ID_BASE+3)	/* EISA Revision number */
#define		SI2_EISA_ID		0x04984D		/* Actual ID string */

/* EISA download code "magic" value... */
#define		SI2_EISA_OFF		0x42			/* Magic offset to set for EISA */
#define		SI2_EISA_VAL		0x01

/* EISA Address and Interrupt definitions... */
#define		SI2_EISA_ADDR_LO	0xC00			/* Base address low */
#define		SI2_EISA_ADDR_HI	0xC01			/* Base address high */
#define		SI2_EISA_IVEC		0xC02			/* Interrupt vector */
#define		SI2_EISA_IRQ_CNTRL	0xC03			/* Interrupt control */

/* EISA_IVEC bits 7-4 = irq level */
#define		SI2_EISA_IVEC_MASK	0xF0			/* irq = (EISA_IVEC & EISA_IVEC_MASK) >> 4 */

/* EISA_IVEC bit 2 = Z280 control */
#define		SI2_EISA_REL_Z280	0x04
#define		SI2_EISA_RESET_Z280	0x00

/* EISA_IRQ_CNTRL, read to clear interrupt state */
#define		SI2_EISA_IRQ_SET	0x00

/*****************************************************************************
***********************************         **********************************
***********************************   PCI   **********************************
***********************************         **********************************
*****************************************************************************/

/* General definitions... */

#define		SPX_VENDOR_ID		0x11CB		/* Assigned by the PCI SIG */
#define		SPX_DEVICE_ID		0x4000		/* SI/XIO boards */
#define		SPX_PLXDEVICE_ID	0x2000		/* SX boards */

#define		SPX_SUB_VENDOR_ID	SPX_VENDOR_ID	/* Same as vendor id */
#define		SI2_SUB_SYS_ID		0x400		/* Phase 2 (Z280) board */
#define		SX_SUB_SYS_ID		0x200		/* Phase 3 (t225) board */

/* @@@ Changes for CSX 22/1/99 */
#define   CSX_SUB_SYS_ID     0x300  /* Phase 4 (MCF5206e) board */
/* end changes */

#endif						/*_sxboards_h */

/* End of SXBOARDS.H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\spx\mps\sx\inc\sxwindow.h ===
/************************************************************************/
/*									*/
/*	Title		:	SX Shared Memory Window Structure	*/
/*									*/
/*	Author		:	N.P.Vassallo				*/
/*									*/
/*	Creation	:	16th March 1998				*/
/*									*/
/*	Version		:	3.0.8					*/
/*									*/
/*	Copyright	:	(c) Specialix International Ltd. 1998	*/
/*									*/
/*	Description	:	Prototypes, structures and definitions	*/
/*				describing the SX/SI/XIO cards shared	*/
/*				memory window structure:		*/
/*					SXCARD				*/
/*					SXMODULE			*/
/*					SXCHANNEL			*/
/*									*/
/************************************************************************/

/* History...

3.0.0	16/03/98 NPV	Creation. (based on STRUCT.H)
3.0.1	30/04/98 NPV	Add SP_DSR_TXFLOW to SXCHANNEL.hi_prtcl field
3.0.2	14/07/98 NPV	Add flow_state field to SXCHANNEL structure
3.0.3	17/07/98 NPV	Use new typedefs _u8, _u16 etc.
3.0.4	24/07/98 NPV	Add hi_err_replace to SXCHANNEL structure
3.0.5	05/10/98 NPV	Add new module type RS232 DTE.
3.0.6	10/08/99 NPV	Add io_state field to SXCHANNEL structure
3.0.7	28/07/00 NPV	Add tx_fifo_size, tx_fifo_level and tx_fifo_count to SXCHANNEL structure
3.0.8	18-Sep-00 NPV	Add hs_config_mask field to refine the operations during HS_CONFIG command

*/

#ifndef	_sxwindow_h				/* If SXWINDOW.H not already defined */
#define	_sxwindow_h    1

/*****************************************************************************
***************************                        ***************************
***************************   Common Definitions   ***************************
***************************                        ***************************
*****************************************************************************/

#ifndef	_sx_defs				/* If SX definitions not already defined */
#define	_sx_defs
typedef	unsigned long	_u32;
typedef	unsigned short	_u16;
typedef	unsigned char	_u8;

#define	POINTER *
typedef _u32 POINTER pu32;
typedef _u16 POINTER pu16;
typedef _u8 POINTER pu8;
#endif

typedef	struct	_SXCARD		*PSXCARD;	/* SXCARD structure pointer */
typedef	struct	_SXMODULE	*PMOD;		/* SXMODULE structure pointer */
typedef	struct	_SXCHANNEL	*PCHAN;		/* SXCHANNEL structure pointer */

/*****************************************************************************
*********************************            *********************************
*********************************   SXCARD   *********************************
*********************************            *********************************
*****************************************************************************/
 #ifdef COLDFIRE_SX
 typedef	__packed__(1,1,1) struct	_SXCARD 
/* typedef	struct	_SXCARD */
#else
typedef	struct	_SXCARD
#endif
{
	_u8	cc_init_status;			/* 0x00 Initialisation status */
	_u8	cc_mem_size;			/* 0x01 Size of memory on card */
	_u16	cc_int_count;			/* 0x02 Interrupt count */
	_u16	cc_revision;			/* 0x04 Download code revision */
	_u8	cc_isr_count;			/* 0x06 Count when ISR is run */
	_u8	cc_main_count;			/* 0x07 Count when main loop is run */
	_u16	cc_int_pending;			/* 0x08 Interrupt pending */
	_u16	cc_poll_count;			/* 0x0A Count when poll is run */
	_u8	cc_int_set_count;		/* 0x0C Count when host interrupt is set */
	_u8	cc_rfu[0x80 - 0x0D];		/* 0x0D Pad structure to 128 bytes (0x80) */

} SXCARD;

/* SXCARD.cc_init_status definitions... */
#define 	ADAPTERS_FOUND		(_u8)0x01
#define 	NO_ADAPTERS_FOUND	(_u8)0xFF

/* SXCARD.cc_mem_size definitions... */
#define 	SX_MEMORY_SIZE		(_u8)0x40
#define    SXC_MEMORY_SIZE   (_u8)0x80

/* SXCARD.cc_int_count definitions... */
#define 	INT_COUNT_DEFAULT	100	/* Hz */

/*****************************************************************************
********************************              ********************************
********************************   SXMODULE   ********************************
********************************              ********************************
*****************************************************************************/

#define	TOP_POINTER(a)		((a)|0x8000)	/* Sets top bit of word */
#define UNTOP_POINTER(a)	((a)&~0x8000)	/* Clears top bit of word */

#ifdef COLDFIRE_SX
typedef	__packed__(1,1,1) struct	_SXMODULE 
/* typedef	struct	_SXMODULE */
#else
typedef	struct	_SXMODULE
#endif
{
	_u16	mc_next;			/* 0x00 Next module "pointer" (ORed with 0x8000) */
	_u8	mc_type;			/* 0x02 Type of TA in terms of number of channels */
	_u8	mc_mod_no;			/* 0x03 Module number on SI bus cable (0 closest to card) */
	_u8	mc_dtr;				/* 0x04 Private DTR copy (TA only) */
	_u8	mc_rfu1;			/* 0x05 Reserved */
	_u16	mc_uart;			/* 0x06 UART base address for this module */
	_u8	mc_chip;			/* 0x08 Chip type / number of ports */
	_u8	mc_current_uart;		/* 0x09 Current uart selected for this module */
#ifdef	DOWNLOAD
	PCHAN	mc_chan_pointer[8];		/* 0x0A Pointer to each channel structure */
#else
	_u16	mc_chan_pointer[8];		/* 0x0A Define as WORD if not compiling into download */
#endif
	_u16	mc_rfu2;			/* 0x1A Reserved */
	_u8	mc_opens1;			/* 0x1C Number of open ports on first four ports on MTA/SXDC */
	_u8	mc_opens2;			/* 0x1D Number of open ports on second four ports on MTA/SXDC */
	_u8	mc_mods;			/* 0x1E Types of connector module attached to MTA/SXDC */
	_u8	mc_rev1;			/* 0x1F Revision of first CD1400 on MTA/SXDC */
	_u8	mc_rev2;			/* 0x20 Revision of second CD1400 on MTA/SXDC */
	_u8	mc_mtaasic_rev;			/* 0x21 Revision of MTA ASIC 1..4 -> A, B, C, D */
	_u8	mc_rfu3[0x100 - 0x22];		/* 0x22 Pad structure to 256 bytes (0x100) */

} SXMODULE;

/* SXMODULE.mc_type definitions... */
#define		FOUR_PORTS	(_u8)4
#define 	EIGHT_PORTS	(_u8)8

/* SXMODULE.mc_chip definitions... */
#define 	CHIP_MASK	0xF0
#define		TA		(_u8)0
#define 	TA4		(TA | FOUR_PORTS)
#define 	TA8		(TA | EIGHT_PORTS)
#define		TA4_ASIC	(_u8)0x0A
#define		TA8_ASIC	(_u8)0x0B
#define 	MTA_CD1400	(_u8)0x28
#define 	SXDC		(_u8)0x48

/* SXMODULE.mc_mods definitions... */
#define		MOD_RS232DB25		0x00	/* RS232 DB25 (socket/plug) */
#define		MOD_RS232RJ45		0x01	/* RS232 RJ45 (shielded/opto-isolated) */
#define		MOD_RESERVED_2		0x02	/* Reserved (RS485) */
#define		MOD_RS422DB25		0x03	/* RS422 DB25 Socket */
#define		MOD_RESERVED_4		0x04	/* Reserved */
#define		MOD_PARALLEL		0x05	/* Parallel */
#define		MOD_RESERVED_6		0x06	/* Reserved (RS423) */
#define		MOD_RESERVED_7		0x07	/* Reserved */
#define		MOD_2_RS232DB25		0x08	/* Rev 2.0 RS232 DB25 (socket/plug) */
#define		MOD_2_RS232RJ45		0x09	/* Rev 2.0 RS232 RJ45 */
#define		MOD_2_RS232DB25_DTE	0x0A	/* Rev 2.0 Reserved */
#define		MOD_2_RS422DB25		0x0B	/* Rev 2.0 RS422 DB25 */
#define		MOD_RESERVED_C		0x0C	/* Rev 2.0 Reserved */
#define		MOD_2_PARALLEL		0x0D	/* Rev 2.0 Parallel */
#define		MOD_RESERVED_E		0x0E	/* Rev 2.0 Reserved */
#define		MOD_BLANK		0x0F	/* Blank Panel */

/* Mapped module types...*/
#define		MOD_RS232RJ45_OI	0x10	/* RS232 RJ45 Opto-Isolated */
#define		MOD_2_RS232RJ45S	0x11	/* RS232 RJ45 Shielded Rev 2.0 */

/*****************************************************************************
********************************               *******************************
********************************   SXCHANNEL   *******************************
********************************               *******************************
*****************************************************************************/

#define		TX_BUFF_OFFSET		0x60	/* Transmit buffer offset in channel structure */
#define		BUFF_POINTER(a)		(((a)+TX_BUFF_OFFSET)|0x8000)
#define		UNBUFF_POINTER(a)	(jet_channel*)(((a)&~0x8000)-TX_BUFF_OFFSET) 
#define 	BUFFER_SIZE		256
#define 	HIGH_WATER		((BUFFER_SIZE / 4) * 3)
#define 	LOW_WATER		(BUFFER_SIZE / 4)

#ifdef COLDFIRE_SX
typedef	__packed__(1,1,1) struct	_SXCHANNEL 
/* typedef	struct	_SXCHANNEL */
#else
typedef	struct	_SXCHANNEL
#endif
{
	_u16	next_item;			/* 0x00 Offset from window base of next channels hi_txbuf (ORred with 0x8000) */
	_u16 	addr_uart;			/* 0x02 INTERNAL pointer to uart address. Includes FASTPATH bit */
	_u16	module;				/* 0x04 Offset from window base of parent SXMODULE structure */
	_u8 	type;				/* 0x06 Chip type / number of ports (copy of mc_chip) */
	_u8	chan_number;			/* 0x07 Channel number on the TA/MTA/SXDC */
	_u16	xc_status;			/* 0x08 Flow control and I/O status */
	_u8	hi_rxipos;			/* 0x0A Receive buffer input index */
	_u8	hi_rxopos;			/* 0x0B Receive buffer output index */
	_u8	hi_txopos;			/* 0x0C Transmit buffer output index */
	_u8	hi_txipos;			/* 0x0D Transmit buffer input index */
	_u8	hi_hstat;			/* 0x0E Command register */
	_u8	dtr_bit;			/* 0x0F INTERNAL DTR control byte (TA only) */
	_u8	txon;				/* 0x10 INTERNAL copy of hi_txon */
	_u8	txoff;				/* 0x11 INTERNAL copy of hi_txoff */
	_u8	rxon;				/* 0x12 INTERNAL copy of hi_rxon */
	_u8	rxoff;				/* 0x13 INTERNAL copy of hi_rxoff */
	_u8	hi_mr1;				/* 0x14 Mode Register 1 (databits,parity,RTS rx flow)*/
	_u8	hi_mr2;				/* 0x15 Mode Register 2 (stopbits,local,CTS tx flow)*/
	_u8	hi_csr;				/* 0x16 Clock Select Register (baud rate) */
	_u8	hi_op;				/* 0x17 Modem Output Signal */
	_u8	hi_ip;				/* 0x18 Modem Input Signal */
	_u8	hi_state;			/* 0x19 Channel status */
	_u8	hi_prtcl;			/* 0x1A Channel protocol (flow control) */
	_u8	hi_txon;			/* 0x1B Transmit XON character */
	_u8	hi_txoff;			/* 0x1C Transmit XOFF character */
	_u8	hi_rxon;			/* 0x1D Receive XON character */
	_u8	hi_rxoff;			/* 0x1E Receive XOFF character */
	_u8	close_prev;			/* 0x1F INTERNAL channel previously closed flag */
	_u8	hi_break;			/* 0x20 Break and error control */
	_u8	break_state;			/* 0x21 INTERNAL copy of hi_break */
	_u8	hi_mask;			/* 0x22 Mask for received data */
	_u8	mask;				/* 0x23 INTERNAL copy of hi_mask */
	_u8	mod_type;			/* 0x24 MTA/SXDC hardware module type */
	_u8	ccr_state;			/* 0x25 INTERNAL MTA/SXDC state of CCR register */
	_u8	ip_mask;			/* 0x26 Input handshake mask */
	_u8	hi_parallel;			/* 0x27 Parallel port flag */
	_u8	par_error;			/* 0x28 Error code for parallel loopback test */
	_u8	any_sent;			/* 0x29 INTERNAL data sent flag */
	_u8	asic_txfifo_size;		/* 0x2A INTERNAL SXDC transmit FIFO size */
	_u8	hi_err_replace;			/* 0x2B Error replacement character (enabled by BR_ERR_REPLACE) */
	_u8	rfu1[1];			/* 0x2C Reserved */
	_u8	csr;				/* 0x2D INTERNAL copy of hi_csr */
#ifdef	DOWNLOAD
	PCHAN	nextp;				/* 0x2E Offset from window base of next channel structure */
#else
	_u16	nextp;				/* 0x2E Define as WORD if not compiling into download */
#endif
	_u8	prtcl;				/* 0x30 INTERNAL copy of hi_prtcl */
	_u8	mr1;				/* 0x31 INTERNAL copy of hi_mr1 */
	_u8	mr2;				/* 0x32 INTERNAL copy of hi_mr2 */
	_u8	hi_txbaud;			/* 0x33 Extended transmit baud rate (SXDC only if((hi_csr&0x0F)==0x0F) */
	_u8	hi_rxbaud;			/* 0x34 Extended receive baud rate  (SXDC only if((hi_csr&0xF0)==0xF0) */
	_u8	txbreak_state;			/* 0x35 INTERNAL MTA/SXDC transmit break state */
	_u8	txbaud;				/* 0x36 INTERNAL copy of hi_txbaud */
	_u8	rxbaud;				/* 0x37 INTERNAL copy of hi_rxbaud */
	_u16	err_framing;			/* 0x38 Count of receive framing errors */
	_u16	err_parity;			/* 0x3A Count of receive parity errors */
	_u16	err_overrun;			/* 0x3C Count of receive overrun errors */
	_u16	err_overflow;			/* 0x3E Count of receive buffer overflow errors */
	_u8	flow_state;			/* 0x40 INTERNAL state of flow control */
	_u8	io_state;			/* 0x41 INTERNAL state of transmit/receive data */
	_u8	tx_fifo_size;			/* 0x42 Size of the channels transmit FIFO */
	_u8	tx_fifo_level;			/* 0x43 Level of transmit FIFO to use */
	_u8	tx_fifo_count;			/* 0x44 Count of characters currently in the transmit FIFO */
	_u8	hs_config_mask;			/* 0x45 Mask used to refine HS_CONFIG operation */
	_u8	rfu2[TX_BUFF_OFFSET - 0x46];	/* 0x46 Reserved until hi_txbuf */
	_u8	hi_txbuf[BUFFER_SIZE];		/* 0x060 Transmit buffer */
	_u8	hi_rxbuf[BUFFER_SIZE];		/* 0x160 Receive buffer */
	_u8	rfu3[0x300 - 0x260];		/* 0x260 Reserved until 768 bytes (0x300) */

} SXCHANNEL;

/* SXCHANNEL.addr_uart definitions... */
#define		FASTPATH	0x1000		/* Set to indicate fast rx/tx processing (TA only) */

/* SXCHANNEL.xc_status definitions... */
#define		X_TANY		0x0001		/* XON is any character (TA only) */
#define		X_TION		0x0001		/* Tx interrupts on (MTA only) */
#define		X_TXEN		0x0002		/* Tx XON/XOFF enabled (TA only) */
#define		X_RTSEN		0x0002		/* RTS FLOW enabled (MTA only) */
#define		X_TXRC		0x0004		/* XOFF received (TA only) */
#define		X_RTSLOW	0x0004		/* RTS dropped (MTA only) */
#define		X_RXEN		0x0008		/* Rx XON/XOFF enabled */
#define		X_ANYXO		0x0010		/* XOFF pending/sent or RTS dropped */
#define		X_RXSE		0x0020		/* Rx XOFF sent */
#define		X_NPEND		0x0040		/* Rx XON pending or XOFF pending */
#define		X_FPEND		0x0080		/* Rx XOFF pending */
#define		C_CRSE		0x0100		/* Carriage return sent (TA only) */
#define		C_TEMR		0x0100		/* Tx empty requested (MTA only) */
#define		C_TEMA		0x0200		/* Tx empty acked (MTA only) */
#define		C_ANYP		0x0200		/* Any protocol bar tx XON/XOFF (TA only) */
#define		C_EN		0x0400		/* Cooking enabled (on MTA means port is also || */
#define		C_HIGH		0x0800		/* Buffer previously hit high water */
#define		C_CTSEN		0x1000		/* CTS automatic flow-control enabled */
#define		C_DCDEN		0x2000		/* DCD/DTR checking enabled */
#define		C_BREAK		0x4000		/* Break detected */
#define		C_RTSEN		0x8000		/* RTS automatic flow control enabled (MTA only) */
#define		C_PARITY	0x8000		/* Parity checking enabled (TA only) */

/* SXCHANNEL.hi_hstat definitions... */
#define		HS_IDLE_OPEN	0x00		/* Channel open state */
#define		HS_LOPEN	0x02		/* Local open command (no modem monitoring) */
#define		HS_MOPEN	0x04		/* Modem open command (wait for DCD signal) */
#define		HS_IDLE_MPEND	0x06		/* Waiting for DCD signal state */
#define		HS_CONFIG	0x08		/* Configuration command */
#define		HS_CLOSE	0x0A		/* Close command */
#define		HS_START	0x0C		/* Start transmit break command */
#define		HS_STOP		0x0E		/* Stop transmit break command */
#define		HS_IDLE_CLOSED	0x10		/* Closed channel state */
#define		HS_IDLE_BREAK	0x12		/* Transmit break state */
#define		HS_FORCE_CLOSED	0x14		/* Force close command */
#define		HS_RESUME	0x16		/* Clear pending XOFF command */
#define		HS_WFLUSH	0x18		/* Flush transmit buffer command */
#define		HS_RFLUSH	0x1A		/* Flush receive buffer command */
#define		HS_SUSPEND	0x1C		/* Suspend output command (like XOFF received) */
#define		PARALLEL	0x1E		/* Parallel port loopback test command (Diagnostics Only) */
#define		ENABLE_RX_INTS	0x20		/* Enable receive interrupts command (Diagnostics Only) */
#define		ENABLE_TX_INTS	0x22		/* Enable transmit interrupts command (Diagnostics Only) */
#define		ENABLE_MDM_INTS	0x24		/* Enable modem interrupts command (Diagnostics Only) */
#define		DISABLE_INTS	0x26		/* Disable interrupts command (Diagnostics Only) */

/* SXCHANNEL.hi_mr1 definitions... */
#define		MR1_BITS	0x03		/* Data bits mask */
#define		MR1_5_BITS	0x00		/* 5 data bits */
#define		MR1_6_BITS	0x01		/* 6 data bits */
#define		MR1_7_BITS	0x02		/* 7 data bits */
#define		MR1_8_BITS	0x03		/* 8 data bits */
#define		MR1_PARITY	0x1C		/* Parity mask */
#define		MR1_ODD		0x04		/* Odd parity */
#define		MR1_EVEN	0x00		/* Even parity */
#define		MR1_WITH	0x00		/* Parity enabled */
#define		MR1_FORCE	0x08		/* Force parity */
#define		MR1_NONE	0x10		/* No parity */
#define		MR1_NOPARITY	MR1_NONE		/* No parity */
#define		MR1_ODDPARITY	(MR1_WITH|MR1_ODD)	/* Odd parity */
#define		MR1_EVENPARITY	(MR1_WITH|MR1_EVEN)	/* Even parity */
#define		MR1_MARKPARITY	(MR1_FORCE|MR1_ODD)	/* Mark parity */
#define		MR1_SPACEPARITY	(MR1_FORCE|MR1_EVEN)	/* Space parity */
#define		MR1_RTS_RXFLOW	0x80		/* RTS receive flow control */

/* SXCHANNEL.hi_mr2 definitions... */
#define		MR2_STOP	0x0F		/* Stop bits mask */
#define		MR2_1_STOP	0x07		/* 1 stop bit */
#define		MR2_2_STOP	0x0F		/* 2 stop bits */
#define		MR2_CTS_TXFLOW	0x10		/* CTS transmit flow control */
#define		MR2_RTS_TOGGLE	0x20		/* RTS toggle on transmit */
#define		MR2_NORMAL	0x00		/* Normal mode */
#define		MR2_AUTO	0x40		/* Auto-echo mode (TA only) */
#define		MR2_LOCAL	0x80		/* Local echo mode */
#define		MR2_REMOTE	0xC0		/* Remote echo mode (TA only) */

/* SXCHANNEL.hi_csr definitions... */
#define		CSR_75		0x0		/*    75 baud */
#define		CSR_110		0x1		/*   110 baud (TA), 115200 (MTA/SXDC) */
#define		CSR_38400	0x2		/* 38400 baud */
#define		CSR_150		0x3		/*   150 baud */
#define		CSR_300		0x4		/*   300 baud */
#define		CSR_600		0x5		/*   600 baud */
#define		CSR_1200	0x6		/*  1200 baud */
#define		CSR_2000	0x7		/*  2000 baud */
#define		CSR_2400	0x8		/*  2400 baud */
#define		CSR_4800	0x9		/*  4800 baud */
#define		CSR_1800	0xA		/*  1800 baud */
#define		CSR_9600	0xB		/*  9600 baud */
#define		CSR_19200	0xC		/* 19200 baud */
#define		CSR_57600	0xD		/* 57600 baud */
#define		CSR_EXTBAUD	0xF		/* Extended baud rate (hi_txbaud/hi_rxbaud) */

/* SXCHANNEL.hi_op definitions... */
#define		OP_RTS		0x01		/* RTS modem output signal */
#define		OP_DTR		0x02		/* DTR modem output signal */

/* SXCHANNEL.hi_ip definitions... */
#define		IP_CTS		0x02		/* CTS modem input signal */
#define		IP_DCD		0x04		/* DCD modem input signal */
#define		IP_DSR		0x20		/* DSR modem input signal */
#define		IP_RI		0x40		/* RI modem input signal */

/* SXCHANNEL.hi_state definitions... */
#define		ST_BREAK	0x01		/* Break received (clear with config) */
#define		ST_DCD		0x02		/* DCD signal changed state */

/* SXCHANNEL.hi_prtcl definitions... */
#define		SP_TANY		0x01		/* Transmit XON/XANY (if SP_TXEN enabled) */
#define		SP_TXEN		0x02		/* Transmit XON/XOFF flow control */
#define		SP_CEN		0x04		/* Cooking enabled */
#define		SP_RXEN		0x08		/* Rx XON/XOFF enabled */
#define		SP_DSR_TXFLOW	0x10		/* DSR transmit flow control */
#define		SP_DCEN		0x20		/* Enable modem signal reporting (DCD / DTR check) */
#define		SP_DTR_RXFLOW	0x40		/* DTR receive flow control */
#define		SP_PAEN		0x80		/* Parity checking enabled */

/* SXCHANNEL.hi_break definitions... */
#define		BR_IGN		0x01		/* Ignore any received breaks */
#define		BR_INT		0x02		/* Interrupt on received break */
#define		BR_PARMRK	0x04		/* Enable parmrk parity error processing */
#define		BR_PARIGN	0x08		/* Ignore chars with parity errors */
#define		BR_ERR_REPLACE	0x40		/* Replace errors with hi_err_replace character */
#define 	BR_ERRINT	0x80		/* Treat parity/framing/overrun errors as exceptions */

/* SXCHANNEL.par_error definitions.. */
#define		DIAG_IRQ_RX	0x01		/* Indicate serial receive interrupt (diags only) */
#define		DIAG_IRQ_TX	0x02		/* Indicate serial transmit interrupt (diags only) */
#define		DIAG_IRQ_MD	0x04		/* Indicate serial modem interrupt (diags only) */

/* SXCHANNEL.hi_txbaud/hi_rxbaud definitions... (SXDC only) */
#define		BAUD_75		0x00		/*     75 baud */
#define		BAUD_115200	0x01		/* 115200 baud */
#define		BAUD_38400	0x02		/*  38400 baud */
#define		BAUD_150	0x03		/*    150 baud */
#define		BAUD_300	0x04		/*    300 baud */
#define		BAUD_600	0x05		/*    600 baud */
#define		BAUD_1200	0x06		/*   1200 baud */
#define		BAUD_2000	0x07		/*   2000 baud */
#define		BAUD_2400	0x08		/*   2400 baud */
#define		BAUD_4800	0x09		/*   4800 baud */
#define		BAUD_1800	0x0A		/*   1800 baud */
#define		BAUD_9600	0x0B		/*   9600 baud */
#define		BAUD_19200	0x0C		/*  19200 baud */
#define		BAUD_57600	0x0D		/*  57600 baud */
#define		BAUD_230400	0x0E		/* 230400 baud */
#define		BAUD_460800	0x0F		/* 460800 baud */
#define		BAUD_921600	0x10		/* 921600 baud */
#define		BAUD_50		0x11    	/*     50 baud */
#define		BAUD_110	0x12		/*    110 baud */
#define		BAUD_134_5	0x13		/*  134.5 baud */
#define		BAUD_200	0x14		/*    200 baud */
#define		BAUD_7200	0x15		/*   7200 baud */
#define		BAUD_56000	0x16		/*  56000 baud */
#define		BAUD_64000	0x17		/*  64000 baud */
#define		BAUD_76800	0x18		/*  76800 baud */
#define		BAUD_128000	0x19		/* 128000 baud */
#define		BAUD_150000	0x1A		/* 150000 baud */
#define		BAUD_14400	0x1B		/*  14400 baud */
#define		BAUD_256000	0x1C		/* 256000 baud */
#define		BAUD_28800	0x1D		/*  28800 baud */

/* SXCHANNEL.txbreak_state definiions... */
#define		TXBREAK_OFF	0		/* Not sending break */
#define		TXBREAK_START	1		/* Begin sending break */
#define		TXBREAK_START1	2		/* Begin sending break, part 1 */
#define		TXBREAK_ON	3		/* Sending break */
#define		TXBREAK_STOP	4		/* Stop sending break */
#define		TXBREAK_STOP1	5		/* Stop sending break, part 1 */

/* SXCHANNEL.flow_state definitions... */
#define		FS_TXBLOCKEDDSR		0x01	/* Transmit blocked by DSR flow control */
#define		FS_PENDING		0x10	/* Flow state check pending */

/* SXCHANNEL.io_state definitions... */
#define		IO_TXNOTEMPTY		0x01	/* Data present in the transmit buffer */

/* SXCHANNEL.hs_config_mask definitions... */
#define		CFGMASK_ALL		0xFF	/* Configure all parameters (set initially and at end of HS_CONFIG) */
#define		CFGMASK_BAUD		0x01	/* Configure baud rate if set */
#define		CFGMASK_LINE		0x02	/* Configure parity/start/stop bits if set */
#define		CFGMASK_MODEM		0x10	/* Configure DTR/RTS modem signals if set */
#define		CFGMASK_FLOW		0x20	/* Configure flow control if set */

#endif						/* _sxwindow_h */

/* End of SXWINDOW.H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\spx\mps\sx\incl\spx_card.h ===
//////////////////////////////////////////////////////////////////////////////////////////
//  Card and Port device extension structures.
// 
//////////////////////////////////////////////////////////////////////////////////////////
#ifndef SPX_CARD_H
#define SPX_CARD_H	

typedef	struct _CARD_DEVICE_EXTENSION *PCARD_DEV_EXT;
typedef	struct _PORT_DEVICE_EXTENSION *PPORT_DEV_EXT;

//////////////////////////////////////////////////////////////////////////////////////////
// Common header for all the device extensions 
// Common to all the PDOs and FDOs (cards and ports).
//////////////////////////////////////////////////////////////////////////////////////////
typedef struct _COMMON_OBJECT_DATA
{
    PDEVICE_OBJECT	DeviceObject;			// A backpointer to the device object that contains this device extension.
    PDRIVER_OBJECT	DriverObject;			// Pointer to Driver Object
    BOOLEAN         IsFDO;					// A boolean to distringuish between PDO and FDO.
	PDEVICE_OBJECT	LowerDeviceObject;		// This is a pointer to the next lower device in the IRP stack.

    ULONG           DebugLevel;

	ULONG			PnpPowerFlags;			// Plug & Play / Power flags
	KSPIN_LOCK		PnpPowerFlagsLock;		// Lock for protecting the flags
	BOOLEAN         PowerQueryLock;			// Are we currently in a query power state? 
    LIST_ENTRY		StalledIrpQueue;		// List of stalled IRPs
	KSPIN_LOCK		StalledIrpLock;			// Lock for protecting stalled IRPs
	BOOLEAN			UnstallingFlag;			// Flag set if we are unstalling IRPs currently queued.

#ifndef	BUILD_SPXMINIPORT
	SYSTEM_POWER_STATE  SystemState;		// Current System Power State
    DEVICE_POWER_STATE  DeviceState;		// Current Device Power State
#endif

#ifdef WMI_SUPPORT
    WMILIB_CONTEXT		WmiLibInfo;			// WMI Information
#endif

} COMMON_OBJECT_DATA, *PCOMMON_OBJECT_DATA;


//////////////////////////////////////////////////////////////////////////////////////////
// Common Card Configuration Data.
// Information not specific to product.
//////////////////////////////////////////////////////////////////////////////////////////
typedef struct _CONFIG_DATA 
{
	PHYSICAL_ADDRESS	RawPhysAddr;		// Raw physical address of card 
    PHYSICAL_ADDRESS    PhysAddr;			// Translated Physical address of card.
	PUCHAR				Controller;			// Virtual mapped sddress of card.
    ULONG               SpanOfController;	// Size of memory used by Cord.
    INTERFACE_TYPE      InterfaceType;		// Type of card (Isa or Pci)
    ULONG               BusNumber;			// Bus number card is using.
	ULONG				SlotNumber;			// Slot number on bus.		
    ULONG               AddressSpace;		// Flag used by SX
    ULONG               OriginalVector;		// Original Vector (bus relative)
    ULONG               OriginalIrql;		// Original Irql (bus relative)
    ULONG               TrVector;			// Translated Vector (system relative).
    KIRQL               TrIrql;				// Translated Irql (system relative).
    KINTERRUPT_MODE     InterruptMode;		// Interrupt mode (LevelSensitive or Latched)
	BOOLEAN				InterruptShareable;	// Interrupt shareable flag.
    KAFFINITY           ProcessorAffinity;	// Processor affintity.
	PKSERVICE_ROUTINE	OurIsr;				// Points to interrupt service routine.
    PVOID				OurIsrContext;		// Points to card device extension.
    PKINTERRUPT			Interrupt;			// Points to the interrupt object used by the card.
    ULONG               ClockRate;			// ClockRate.
} CONFIG_DATA,*PCONFIG_DATA;


//////////////////////////////////////////////////////////////////////////////////////////
// Common Card Device Extenstion.
// Information not specific to product.
//////////////////////////////////////////////////////////////////////////////////////////
typedef struct _COMMON_CARD_DEVICE_EXTENSION 
{

	COMMON_OBJECT_DATA;								// Common Object Data 
	CONFIG_DATA;									// Card Config Data
	PDEVICE_OBJECT PDO;								// Pointer to Physical Device Object 

	UNICODE_STRING	DeviceName;						// Device name.
	ULONG			CardNumber;
	ULONG			NumberOfPorts;					// Number of ports attached to card.
	ULONG			NumPDOs;						// The PDOs currently enumerated.
	ULONG			CardType;						// Defines the type of host card.

	PDEVICE_OBJECT  AttachedPDO[PRODUCT_MAX_PORTS];	// Array of pointers to PDOs for ports attached to card.

} COMMON_CARD_DEVICE_EXTENSION, *PCOMMON_CARD_DEVICE_EXTENSION;



typedef struct _PORT_PERFORMANCE_STATS
{
    SERIALPERF_STATS;

	// IRPs with a Major Function of IRP_MJ_WRITE
	ULONG WriteIrpsSubmitted;
	ULONG WriteIrpsCompleted;
	ULONG WriteIrpsCancelled;
	ULONG WriteIrpsTimedOut;
	ULONG WriteIrpsQueued;

	// IRPs with a Major Function of IRP_MJ_READ
	ULONG ReadIrpsSubmitted;
	ULONG ReadIrpsCompleted;
	ULONG ReadIrpsCancelled;
	ULONG ReadIrpsTimedOut;
	ULONG ReadIrpsQueued;

	// IRPs with a Major Function of IRP_MJ_FLUSH_BUFFERS
	ULONG FlushIrpsSubmitted;
	ULONG FlushIrpsCompleted;
	ULONG FlushIrpsCancelled;
	ULONG FlushIrpsQueued;

	// IRPs with a Major Function of IRP_MJ_DEVICE_CONTROL
	ULONG IoctlIrpsSubmitted;
	ULONG IoctlIrpsCompleted;
	ULONG IoctlIrpsCancelled;

	// IRPs with a Major Function of IRP_MJ_INTERNAL_DEVICE_CONTROL
	ULONG InternalIoctlIrpsSubmitted;
	ULONG InternalIoctlIrpsCompleted;
	ULONG InternalIoctlIrpsCancelled;

	// IRPs with a Major Function of IRP_MJ_CREATE
	ULONG CreateIrpsSubmitted;
	ULONG CreateIrpsCompleted;
	ULONG CreateIrpsCancelled;

	// IRPs with a Major Function of IRP_MJ_CLOSE
	ULONG CloseIrpsSubmitted;
	ULONG CloseIrpsCompleted;
	ULONG CloseIrpsCancelled;

	// IRPs with a Major Function of IRP_MJ_CLEANUP
	ULONG CleanUpIrpsSubmitted;
	ULONG CleanUpIrpsCompleted;
	ULONG CleanUpIrpsCancelled;

	// IRPs with a Major Function of IRP_MJ_QUERY_INFORMATION and IRP_MJ_SET_INFORMATION 
	ULONG InfoIrpsSubmitted;
	ULONG InfoIrpsCompleted;
	ULONG InfoIrpsCancelled;

} PORT_PERFORMANCE_STATS, *PPORT_PERFORMANCE_STATS;

//////////////////////////////////////////////////////////////////////////////////////////
// Common Port Device Extenstion.
// Information not specific to product.
//////////////////////////////////////////////////////////////////////////////////////////
typedef struct _COMMON_PORT_DEVICE_EXTENSION 
{

	COMMON_OBJECT_DATA;								// Common Object Data 
	PDEVICE_OBJECT		ParentFDO;					// A back pointer to the bus FDO  (this will be the LowerDeviceObject) 
	PCARD_DEV_EXT		pParentCardExt;				// Pointer to parent card device structure
	UNICODE_STRING		DeviceName;					// Device name eg. "\Device\PortName#".
	UNICODE_STRING		DeviceClassSymbolicName;	// Device Interface Name
	UNICODE_STRING		SerialCommEntry;			// Device name in SERIALCOMM Reg key eg. "PortName#".
	ULONG				PortNumber;					// Port number.
	UNICODE_STRING		DeviceID;					// Format: bus\device (must be most specific HardwareID)
	UNICODE_STRING		InstanceID;					// Instance ID 
	BOOLEAN				UniqueInstanceID;			// TRUE if InstanceID is gloablly unique, FALSE otherwise.
    UNICODE_STRING		HardwareIDs;				// Format bus\device or *PNPXXXX - meaning root enumerated
    UNICODE_STRING		CompatibleIDs;				// Compatible IDs to the Hardware ID
    UNICODE_STRING		DevDesc;					// Text describing device
    UNICODE_STRING		DevLocation;				// Text describing device location
	UNICODE_STRING		DosName;					// Dos device name "COM#" 
	UNICODE_STRING		SymbolicLinkName;			// External Device Name eg."\DosDevices\COM#".
	BOOLEAN				CreatedSymbolicLink;		// Flag to indicate that a symbolic link has been created.
	BOOLEAN				CreatedSerialCommEntry;		// Flag to indicate that a reg entry has been created in "SERIALCOMM"
	BOOLEAN				DeviceIsOpen;				// Flag to indicate when the port is open	
	ULONG				SavedModemControl;			// DTR/RTS signal states saved during power down
    FAST_MUTEX			OpenMutex;					// Mutex on open status

	    
#ifdef WMI_SUPPORT
	SERIAL_WMI_COMM_DATA	WmiCommData;			// WMI Comm Data
    SERIAL_WMI_HW_DATA		WmiHwData;				// WMI HW Data
	SERIAL_WMI_PERF_DATA	WmiPerfData;			// WMI Performance Data
#endif

    //
    // Holds performance statistics that applications can query.
    // Reset on each open.  Only set at device level.
    //
	PORT_PERFORMANCE_STATS PerfStats;

} COMMON_PORT_DEVICE_EXTENSION, *PCOMMON_PORT_DEVICE_EXTENSION;


#endif	// End of SPX_CARD.H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\spx\mps\sx\incl\spx_misc.h ===
/****************************************************************************************
*																						*
*	Header:		SPX_MISC.H 																*
*																						*
*	Creation:	15th October 1998														*
*																						*
*	Author:		Paul Smith																*
*																						*
*	Version:	1.0.0																	*
*																						*
*	Contains:	All Macros and function prototypes for the common PnP and power code.	*
*																						*
****************************************************************************************/

#if	!defined(SPX_MISC_H)
#define SPX_MISC_H	


// Prototypes for common PnP code.
NTSTATUS
Spx_AddDevice(IN PDRIVER_OBJECT pDriverObject, IN PDEVICE_OBJECT pPDO);

NTSTATUS
Spx_DispatchPnp(IN PDEVICE_OBJECT pDevObject, IN PIRP pIrp);

NTSTATUS
Spx_DispatchPower(IN PDEVICE_OBJECT pDevObject, IN PIRP	pIrp);

NTSTATUS 
Spx_DispatchPnpPowerComplete(IN PDEVICE_OBJECT pDevObject, IN PIRP pIrp, IN PVOID Context);

NTSTATUS 
Spx_SerialInternalIoControl(IN PDEVICE_OBJECT pDevObj, IN PIRP pIrp);

NTSTATUS
Spx_InitMultiString(BOOLEAN multi, PUNICODE_STRING MultiString, ...);

NTSTATUS 
Spx_GetRegistryKeyValue(
	IN HANDLE	Handle,
	IN PWCHAR	KeyNameString,
	IN ULONG	KeyNameStringLength,
	IN PVOID	Data,
	IN ULONG	DataLength
	);

NTSTATUS 
Spx_PutRegistryKeyValue(
	IN HANDLE Handle, 
	IN PWCHAR PKeyNameString,
	IN ULONG KeyNameStringLength, 
	IN ULONG Dtype,
    IN PVOID PData, 
	IN ULONG DataLength
	);

VOID
Spx_LogMessage(
	IN ULONG MessageSeverity,				
	IN PDRIVER_OBJECT DriverObject,
	IN PDEVICE_OBJECT DeviceObject OPTIONAL,
	IN PHYSICAL_ADDRESS P1,
	IN PHYSICAL_ADDRESS P2,
	IN ULONG SequenceNumber,
	IN UCHAR MajorFunctionCode,
	IN UCHAR RetryCount,
	IN ULONG UniqueErrorValue,
	IN NTSTATUS FinalStatus,
	IN PCHAR szTemp);

VOID
Spx_LogError(
	IN PDRIVER_OBJECT DriverObject,
	IN PDEVICE_OBJECT DeviceObject OPTIONAL,
	IN PHYSICAL_ADDRESS P1,
	IN PHYSICAL_ADDRESS P2,
	IN ULONG SequenceNumber,
	IN UCHAR MajorFunctionCode,
	IN UCHAR RetryCount,
	IN ULONG UniqueErrorValue,
	IN NTSTATUS FinalStatus,
	IN NTSTATUS SpecificIOStatus,
	IN ULONG LengthOfInsert1,
	IN PWCHAR Insert1,
	IN ULONG LengthOfInsert2,
	IN PWCHAR Insert2
	);

ULONG	SpxGetNtCardType(PDEVICE_OBJECT pNtDevObj);
NTSTATUS Spx_CreatePortInstanceID(IN PPORT_DEVICE_EXTENSION pPort);

SPX_MEM_COMPARES Spx_MemCompare(IN PHYSICAL_ADDRESS A, IN ULONG SpanOfA, IN PHYSICAL_ADDRESS B, IN ULONG SpanOfB);

NTSTATUS PLX_9050_CNTRL_REG_FIX(IN PCARD_DEVICE_EXTENSION pCard);

VOID SpxSetOrClearPnpPowerFlags(IN PCOMMON_OBJECT_DATA pDevExt, IN ULONG Value, IN BOOLEAN Set);
VOID SpxSetOrClearUnstallingFlag(IN PCOMMON_OBJECT_DATA pDevExt, IN BOOLEAN Set);

BOOLEAN 
SpxCheckPnpPowerFlags(IN PCOMMON_OBJECT_DATA pDevExt, IN ULONG ulSetFlags, IN ULONG ulClearedFlags, IN BOOLEAN bAll);


PVOID SpxAllocateMem(IN POOL_TYPE PoolType, IN ULONG NumberOfBytes);
PVOID SpxAllocateMemWithQuota(IN POOL_TYPE PoolType, IN ULONG NumberOfBytes);

#ifndef BUILD_SPXMINIPORT
void SpxFreeMem(PVOID pMem);
#endif
						   
VOID SpxIRPCounter(IN PPORT_DEVICE_EXTENSION pPort, IN PIRP pIrp, IN ULONG IrpCondition);
BOOLEAN SpxClearAllPortStats(IN PPORT_DEVICE_EXTENSION pPort);


// Filtered dispatch entry points... 
NTSTATUS Spx_Flush(IN PDEVICE_OBJECT pDevObject,IN PIRP pIrp);					// SPX_DISP.C 
NTSTATUS Spx_Write(IN PDEVICE_OBJECT pDevObject,IN PIRP pIrp);					// SPX_DISP.C 
NTSTATUS Spx_Read(IN PDEVICE_OBJECT pDevObject,IN PIRP pIrp);					// SPX_DISP.C 
NTSTATUS Spx_IoControl(IN PDEVICE_OBJECT pDevObject,IN PIRP pIrp);				// SPX_DISP.C 
NTSTATUS Spx_InternalIoControl(IN PDEVICE_OBJECT pDevObject,IN PIRP pIrp);		// SPX_DISP.C 
NTSTATUS Spx_CreateOpen(IN PDEVICE_OBJECT pDevObject,IN PIRP pIrp);				// SPX_DISP.C 
NTSTATUS Spx_Close(IN PDEVICE_OBJECT pDevObject,IN PIRP pIrp);					// SPX_DISP.C 
NTSTATUS Spx_Cleanup(IN PDEVICE_OBJECT pDevObject,IN PIRP pIrp);				// SPX_DISP.C 
NTSTATUS Spx_QueryInformationFile(IN PDEVICE_OBJECT pDevObject,IN PIRP pIrp);	// SPX_DISP.C 
NTSTATUS Spx_SetInformationFile(IN PDEVICE_OBJECT pDevObject,IN PIRP pIrp);		// SPX_DISP.C 

VOID Spx_UnstallIrps(IN PPORT_DEVICE_EXTENSION pPort);							// SPX_DISP.C 
VOID Spx_KillStalledIRPs(IN PDEVICE_OBJECT pDevObj);							// SPX_DISP.C 


// End of prototypes for common PnP code.


#ifdef WMI_SUPPORT

NTSTATUS Spx_DispatchSystemControl(IN PDEVICE_OBJECT pDevObject, IN PIRP pIrp);
NTSTATUS SpxPort_WmiInitializeWmilibContext(IN PWMILIB_CONTEXT WmilibContext);

#define UPDATE_WMI_LINE_CONTROL(WmiCommData, LineControl)						\
do																				\
{																				\
																				\
	WmiCommData.BitsPerByte			= (LineControl & SERIAL_DATA_MASK) + 5;		\
	WmiCommData.ParityCheckEnable	= (LineControl & 0x08) ? TRUE : FALSE;		\
																				\
	switch(LineControl & SERIAL_PARITY_MASK)									\
	{																			\
	case SERIAL_ODD_PARITY:														\
		WmiCommData.Parity = SERIAL_WMI_PARITY_ODD;								\
		break;																	\
																				\
	case SERIAL_EVEN_PARITY:													\
		WmiCommData.Parity = SERIAL_WMI_PARITY_EVEN;							\
		break;																	\
																				\
	case SERIAL_MARK_PARITY:													\
		WmiCommData.Parity = SERIAL_WMI_PARITY_MARK;							\
		break;																	\
																				\
	case SERIAL_SPACE_PARITY:													\
		WmiCommData.Parity = SERIAL_WMI_PARITY_SPACE;							\
		break;																	\
																				\
	case SERIAL_NONE_PARITY:													\
	default:																	\
		WmiCommData.Parity = SERIAL_WMI_PARITY_NONE;							\
		break;																	\
	}																			\
																				\
																				\
	if(LineControl & SERIAL_STOP_MASK)											\
	{																			\
		if((LineControl & SERIAL_DATA_MASK) == SERIAL_5_DATA)					\
			WmiCommData.StopBits = SERIAL_WMI_STOP_1_5;							\
		else																	\
			WmiCommData.StopBits = SERIAL_WMI_STOP_2;							\
	}																			\
	else																		\
		WmiCommData.StopBits = SERIAL_WMI_STOP_1;								\
																				\
} while (0)


#define UPDATE_WMI_XON_XOFF_CHARS(WmiCommData, SpecialChars)					\
do																				\
{																				\
	WmiCommData.XoffCharacter	= SpecialChars.XoffChar;						\
	WmiCommData.XonCharacter	= SpecialChars.XonChar;							\
																				\
} while (0)


#define UPDATE_WMI_XMIT_THRESHOLDS(WmiCommData, HandFlow)						\
do																				\
{																				\
	WmiCommData.XoffXmitThreshold	= HandFlow.XoffLimit;						\
	WmiCommData.XonXmitThreshold	= HandFlow.XonLimit;						\
																				\
} while (0)

#endif



// Macros 

// Debug Messages
#if DBG
#define SPX_TRACE_CALLS			((ULONG)0x00000001)
#define SPX_TRACE_PNP_IRPS		((ULONG)0x00000002)
#define SPX_ERRORS				((ULONG)0x00000004)
#define SPX_MISC_DBG			((ULONG)0x00000008)
#define SPX_TRACE_POWER_IRPS	((ULONG)0x00000010)
#define	SPX_TRACE_IRP_PATH		((ULONG)0x00000020)
#define	SPX_TRACE_FILTER_IRPS	((ULONG)0x00000040)
//#define SERFLOW				((ULONG)0x00000080)
//#define SERERRORS				((ULONG)0x00000100)
//#define SERBUGCHECK			((ULONG)0x00000200)

extern ULONG SpxDebugLevel;		// Global Debug Level 

#define SpxDbgMsg(LEVEL, STRING)			\
        do{									\
            if(SpxDebugLevel & (LEVEL))		\
			{								\
                DbgPrint STRING;			\
            }								\
            if((LEVEL) == SERBUGCHECK)		\
			{								\
                ASSERT(FALSE);				\
            }								\
        }while (0)
#else
#define SpxDbgMsg(LEVEL, STRING) do {NOTHING;} while (0)
#endif




#define	SetPnpPowerFlags(pDevExt,Value)		\
		SpxSetOrClearPnpPowerFlags( (PCOMMON_OBJECT_DATA)(pDevExt), (Value), TRUE);		

#define	ClearPnpPowerFlags(pDevExt,Value)	\
		SpxSetOrClearPnpPowerFlags( (PCOMMON_OBJECT_DATA)(pDevExt), (Value), FALSE);	

#define SPX_SUCCESS(Status) ((NTSTATUS)(Status) == 0)

#define	SetUnstallingFlag(pDevExt)	\
		SpxSetOrClearUnstallingFlag( (PCOMMON_OBJECT_DATA)(pDevExt), TRUE);		

#define	ClearUnstallingFlag(pDevExt)	\
		SpxSetOrClearUnstallingFlag( (PCOMMON_OBJECT_DATA)(pDevExt), FALSE);	

// End of macros.

#endif	// End of SPX_MISC_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\spx\speed\driver\flush.c ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) 1991, 1992, 1993 Microsoft Corporation

Module Name:

    flush.c

Abstract:

    This module contains the code that is very specific to flush
    operations in the serial driver

Author:

    Anthony V. Ercolano 26-Sep-1991

Environment:

    Kernel mode

Revision History :

-----------------------------------------------------------------------------*/

#include "precomp.h"

// Prototypes
NTSTATUS SerialStartFlush(IN PPORT_DEVICE_EXTENSION pPort);
// End of prototypes    
    

#ifdef ALLOC_PRAGMA
#endif


NTSTATUS
SerialFlush(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp)
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

    This is the dispatch routine for flush.  Flushing works by placing
    this request in the write queue.  When this request reaches the
    front of the write queue we simply complete it since this implies
    that all previous writes have completed.

Arguments:

    DeviceObject - Pointer to the device object for this device

    Irp - Pointer to the IRP for the current request

Return Value:

    Could return status success, cancelled, or pending.

-----------------------------------------------------------------------------*/
{

    PPORT_DEVICE_EXTENSION pPort = DeviceObject->DeviceExtension;

    SerialDump(SERIRPPATH, ("Dispatch entry for: %x\n", Irp));
	SpxIRPCounter(pPort, Irp, IRP_SUBMITTED);	// Increment counter for performance stats.
    Irp->IoStatus.Information = 0L;

    if(SerialCompleteIfError(DeviceObject, Irp) != STATUS_SUCCESS)
        return STATUS_CANCELLED;

    return SerialStartOrQueue(pPort, Irp, &pPort->WriteQueue, &pPort->CurrentWriteIrp, SerialStartFlush);
}



NTSTATUS
SerialStartFlush(IN PPORT_DEVICE_EXTENSION pPort)
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

    This routine is called if there were no writes in the queue.
    The flush became the current write because there was nothing
    in the queue.  Note however that does not mean there is
    nothing in the queue now!  So, we will start off the write
    that might follow us.

Arguments:

    Extension - Points to the serial device extension

Return Value:

    This will always return STATUS_SUCCESS.

-----------------------------------------------------------------------------*/
{
    PIRP NewIrp;

    pPort->CurrentWriteIrp->IoStatus.Status = STATUS_SUCCESS;

    // The following call will actually complete the flush.
    SerialGetNextWrite(pPort, &pPort->CurrentWriteIrp, &pPort->WriteQueue, &NewIrp, TRUE);
        
    if(NewIrp) 
	{
        ASSERT(NewIrp == pPort->CurrentWriteIrp);
        SerialStartWrite(pPort);
    }

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\spx\speed\driver\immediat.c ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) 1991, 1992, 1993 Microsoft Corporation

Module Name:

    immediat.c

Abstract:

    This module contains the code that is very specific to transmit
    immediate character operations in the serial driver

Author:

    Anthony V. Ercolano 26-Sep-1991

Environment:

    Kernel mode

Revision History :

-----------------------------------------------------------------------------*/

#include "precomp.h"

// Prototypes
VOID SerialGetNextImmediate(IN PPORT_DEVICE_EXTENSION pPort,
							IN PIRP *CurrentOpIrp, 
							IN PLIST_ENTRY QueueToProcess, 
							IN PIRP *NewIrp, 
							IN BOOLEAN CompleteCurrent);

VOID SerialCancelImmediate(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp);
BOOLEAN SerialGiveImmediateToIsr(IN PVOID Context);
BOOLEAN SerialGrabImmediateFromIsr(IN PVOID Context);
BOOLEAN SerialGiveImmediateToIsr(IN PVOID Context);
BOOLEAN SerialGrabImmediateFromIsr(IN PVOID Context);
// End of prototypes

// Paging
#ifdef ALLOC_PRAGMA
#endif


VOID
SerialStartImmediate(IN PPORT_DEVICE_EXTENSION pPort)
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

    This routine will calculate the timeouts needed for the
    write.  It will then hand the irp off to the isr.  It
    will need to be careful incase the irp has been canceled.

Arguments:

    Extension - A pointer to the serial device extension.

Return Value:

    None.

-----------------------------------------------------------------------------*/
{
    KIRQL OldIrql;
    LARGE_INTEGER TotalTime;
    BOOLEAN UseATimer;
    SERIAL_TIMEOUTS Timeouts;


    UseATimer = FALSE;
    pPort->CurrentImmediateIrp->IoStatus.Status = STATUS_PENDING;
    IoMarkIrpPending(pPort->CurrentImmediateIrp);

    //
    // Calculate the timeout value needed for the
    // request.  Note that the values stored in the
    // timeout record are in milliseconds.  Note that
    // if the timeout values are zero then we won't start
    // the timer.
    //
    KeAcquireSpinLock(&pPort->ControlLock, &OldIrql);
        
    Timeouts = pPort->Timeouts;

    KeReleaseSpinLock(&pPort->ControlLock, OldIrql);
        

    if(Timeouts.WriteTotalTimeoutConstant || Timeouts.WriteTotalTimeoutMultiplier)
	{
        UseATimer = TRUE;

        // We have some timer values to calculate.
        TotalTime.QuadPart = (LONGLONG)((ULONG)Timeouts.WriteTotalTimeoutMultiplier);

        TotalTime.QuadPart += Timeouts.WriteTotalTimeoutConstant;

        TotalTime.QuadPart *= -10000;
    }

    //
    // As the irp might be going to the isr, this is a good time
    // to initialize the reference count.
    //

    SERIAL_INIT_REFERENCE(pPort->CurrentImmediateIrp);

    //
    // We need to see if this irp should be canceled.
    //

    IoAcquireCancelSpinLock(&OldIrql);

    if(pPort->CurrentImmediateIrp->Cancel) 
	{
        PIRP OldIrp = pPort->CurrentImmediateIrp;

        pPort->CurrentImmediateIrp = NULL;
        IoReleaseCancelSpinLock(OldIrql);

        OldIrp->IoStatus.Status = STATUS_CANCELLED;
        OldIrp->IoStatus.Information = 0;

        SerialDump(SERIRPPATH,("Complete Irp: %x\n",OldIrp));
		SpxIRPCounter(pPort, OldIrp, IRP_COMPLETED);	// Increment counter for performance stats.
        IoCompleteRequest(OldIrp, 0);

    } 
	else 
	{
        //
        // We give the irp to to the isr to write out.
        // We set a cancel routine that knows how to
        // grab the current write away from the isr.
        //
        IoSetCancelRoutine(pPort->CurrentImmediateIrp, SerialCancelImmediate);
            

        //
        // Since the cancel routine knows about the irp we increment the reference count.
        //
        SERIAL_SET_REFERENCE(pPort->CurrentImmediateIrp, SERIAL_REF_CANCEL);
            

        if(UseATimer) 
		{
            KeSetTimer(&pPort->ImmediateTotalTimer, TotalTime, &pPort->TotalImmediateTimeoutDpc);

            // Since the timer knows about the irp we increment the reference count.
            SERIAL_SET_REFERENCE(pPort->CurrentImmediateIrp, SERIAL_REF_TOTAL_TIMER);
        }

        KeSynchronizeExecution(pPort->Interrupt, SerialGiveImmediateToIsr, pPort);

        IoReleaseCancelSpinLock(OldIrql);
    }

}

VOID
SerialCompleteImmediate(IN PKDPC Dpc, IN PVOID DeferredContext, IN PVOID SystemContext1, IN PVOID SystemContext2)
{
    PPORT_DEVICE_EXTENSION pPort = DeferredContext;
    KIRQL OldIrql;

    UNREFERENCED_PARAMETER(Dpc);
    UNREFERENCED_PARAMETER(SystemContext1);
    UNREFERENCED_PARAMETER(SystemContext2);

    IoAcquireCancelSpinLock(&OldIrql);

	// Clear the normal complete reference.
	SERIAL_CLEAR_REFERENCE(pPort->CurrentImmediateIrp, SERIAL_REF_COMPLETING);

    SerialTryToCompleteCurrent(	pPort, NULL, OldIrql, STATUS_SUCCESS, &pPort->CurrentImmediateIrp,
								NULL, NULL, &pPort->ImmediateTotalTimer, NULL, SerialGetNextImmediate, 
								SERIAL_REF_ISR);
}

VOID
SerialTimeoutImmediate(IN PKDPC Dpc, IN PVOID DeferredContext, IN PVOID SystemContext1, IN PVOID SystemContext2)
{
    PPORT_DEVICE_EXTENSION pPort = DeferredContext;
    KIRQL OldIrql;

    UNREFERENCED_PARAMETER(Dpc);
    UNREFERENCED_PARAMETER(SystemContext1);
    UNREFERENCED_PARAMETER(SystemContext2);

    IoAcquireCancelSpinLock(&OldIrql);

    SerialTryToCompleteCurrent(	pPort, SerialGrabImmediateFromIsr, OldIrql, STATUS_TIMEOUT, 
								&pPort->CurrentImmediateIrp, NULL, NULL, &pPort->ImmediateTotalTimer, 
								NULL, SerialGetNextImmediate, SERIAL_REF_TOTAL_TIMER);
}

VOID
SerialGetNextImmediate(IN PPORT_DEVICE_EXTENSION pPort,
					   IN PIRP *CurrentOpIrp, 
					   IN PLIST_ENTRY QueueToProcess, 
					   IN PIRP *NewIrp, 
					   IN BOOLEAN CompleteCurrent)
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

    This routine is used to complete the current immediate
    irp.  Even though the current immediate will always
    be completed and there is no queue associated with it,
    we use this routine so that we can try to satisfy
    a wait for transmit queue empty event.

Arguments:

    CurrentOpIrp - Pointer to the pointer that points to the
                   current write irp.  This should point
                   to CurrentImmediateIrp.

    QueueToProcess - Always NULL.

    NewIrp - Always NULL on exit to this routine.

    CompleteCurrent - Should always be true for this routine.


Return Value:

    None.

-----------------------------------------------------------------------------*/
{

    KIRQL OldIrql;
                                             
    PIRP OldIrp = *CurrentOpIrp;

    UNREFERENCED_PARAMETER(QueueToProcess);
    UNREFERENCED_PARAMETER(CompleteCurrent);
    pPort = CONTAINING_RECORD(CurrentOpIrp, PORT_DEVICE_EXTENSION, CurrentImmediateIrp);

    IoAcquireCancelSpinLock(&OldIrql);

    ASSERT(pPort->TotalCharsQueued >= 1);
    pPort->TotalCharsQueued--;

    *CurrentOpIrp = NULL;
    *NewIrp = NULL;

    KeSynchronizeExecution(pPort->Interrupt, SerialProcessEmptyTransmit, pPort);
        
    IoReleaseCancelSpinLock(OldIrql);

    SerialDump(SERIRPPATH,("SERIAL: Complete Irp: %x\n", OldIrp));
	SpxIRPCounter(pPort, OldIrp, IRP_COMPLETED);	// Increment counter for performance stats.
    IoCompleteRequest(OldIrp, IO_SERIAL_INCREMENT);
}



VOID
SerialCancelImmediate(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp)
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

    This routine is used to cancel a irp that is waiting on
    a comm event.

Arguments:

    DeviceObject - Pointer to the device object for this device

    Irp - Pointer to the IRP for the current request

Return Value:

    None.

-----------------------------------------------------------------------------*/
{
    PPORT_DEVICE_EXTENSION pPort = DeviceObject->DeviceExtension;

    SerialTryToCompleteCurrent(	pPort, SerialGrabImmediateFromIsr, Irp->CancelIrql, STATUS_CANCELLED,
								&pPort->CurrentImmediateIrp, NULL, NULL, &pPort->ImmediateTotalTimer, 
								NULL, SerialGetNextImmediate, SERIAL_REF_CANCEL);
}


BOOLEAN
SerialGiveImmediateToIsr(IN PVOID Context)
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

    Try to start off the write by slipping it in behind
    a transmit immediate char, or if that isn't available
    and the transmit holding register is empty, "tickle"
    the UART into interrupting with a transmit buffer
    empty.

    NOTE: This routine is called by KeSynchronizeExecution.

    NOTE: This routine assumes that it is called with the
          cancel spin lock held.

Arguments:

    Context - Really a pointer to the device extension.

Return Value:

    This routine always returns FALSE.

-----------------------------------------------------------------------------*/
{

    PPORT_DEVICE_EXTENSION pPort = Context;

    pPort->TransmitImmediate = TRUE;

	pPort->ImmediateIndex = *((UCHAR *)(pPort->CurrentImmediateIrp->AssociatedIrp.SystemBuffer));
	
    // The isr now has a reference to the irp.
    SERIAL_SET_REFERENCE(pPort->CurrentImmediateIrp, SERIAL_REF_ISR);
        
	pPort->pUartLib->UL_ImmediateByte_XXXX(pPort->pUart, &pPort->ImmediateIndex, UL_IM_OP_WRITE);
    return FALSE;

}


BOOLEAN
SerialGrabImmediateFromIsr(IN PVOID Context)
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:


    This routine is used to grab the current irp, which could be timing
    out or canceling, from the ISR

    NOTE: This routine is being called from KeSynchronizeExecution.

    NOTE: This routine assumes that the cancel spin lock is held
          when this routine is called.

Arguments:

    Context - Really a pointer to the device extension.

Return Value:

    Always false.

-----------------------------------------------------------------------------*/
{
    PPORT_DEVICE_EXTENSION pPort = Context;

    if(pPort->TransmitImmediate) 
	{
        // Since the isr no longer references this irp, we can
        // decrement it's reference count.
        SERIAL_CLEAR_REFERENCE(pPort->CurrentImmediateIrp, SERIAL_REF_ISR);

        pPort->TransmitImmediate = FALSE;

		pPort->pUartLib->UL_ImmediateByte_XXXX(pPort->pUart, &pPort->ImmediateIndex, UL_IM_OP_CANCEL);

		pPort->ImmediateIndex = 0;

    }

    return FALSE;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\spx\speed\driver\error.c ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) 1991, 1992, 1993 Microsoft Corporation

Module Name:

    error.c

Abstract:

    This module contains the code that is very specific to error
    operations in the serial driver

Author:

    Anthony V. Ercolano 26-Sep-1991

Environment:

    Kernel mode

Revision History :

-----------------------------------------------------------------------------*/

#include "precomp.h"

#ifdef ALLOC_PRAGMA
#endif


VOID
SerialCommError(IN PKDPC Dpc, IN PVOID DeferredContext, IN PVOID SystemContext1, IN PVOID SystemContext2)
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

    This routine is invoked at dpc level to in response to
    a comm error.  All comm errors kill all read and writes

Arguments:

    Dpc - Not Used.

    DeferredContext - Really points to the device object.

    SystemContext1 - Not Used.

    SystemContext2 - Not Used.

Return Value:

    None.

-----------------------------------------------------------------------------*/

{

    PPORT_DEVICE_EXTENSION pPort = DeferredContext;

    UNREFERENCED_PARAMETER(Dpc);
    UNREFERENCED_PARAMETER(SystemContext1);
    UNREFERENCED_PARAMETER(SystemContext2);

    SerialKillAllReadsOrWrites(pPort->DeviceObject, &pPort->WriteQueue, &pPort->CurrentWriteIrp);

    SerialKillAllReadsOrWrites(pPort->DeviceObject, &pPort->ReadQueue, &pPort->CurrentReadIrp);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\spx\speed\driver\makefile.inc ===
#
# generate auxilary files from the binary mof (bmf) file
#
# speedwmi.h has definitions for the guids, data structures and definitions
#                of the method ids.
#
# speedwmi.vbs is a ready to run vbscript applet that will query all classes
#            in the mof. Once you install your driver, run the script
#            at the command line by typing: filter.vbs.

speedwmi.vbs speedwmi.h speedwmi.hex: speedwmi.bmf
    md wmi	
    wmimofck -hinc\speedwmi.h -xwmi\speedwmi.hex -twmi\speedwmi.vbs -wwmi\speedwmi.htm speedwmi.bmf
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\spx\speed\driver\isr.c ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) 1991, 1992, 1993 Microsoft Corporation

Module Name:

    isr.c

Abstract:

    This module contains the interrupt service routine for the
    serial driver.

Author:

    Anthony V. Ercolano 26-Sep-1991

Environment:

    Kernel mode

Revision History :

-----------------------------------------------------------------------------*/

#include "precomp.h"




BOOLEAN
SerialISR(IN PKINTERRUPT InterruptObject, IN PVOID Context)
{
    // Holds the information specific to handling this device.
    PCARD_DEVICE_EXTENSION	pCard = Context;
    PPORT_DEVICE_EXTENSION	pPort; 
    BOOLEAN					ServicedAnInterrupt = FALSE;

	PUART_OBJECT pUart = pCard->pFirstUart;
	DWORD IntsPending = 0;
	
	UNREFERENCED_PARAMETER(InterruptObject);

#ifndef	BUILD_SPXMINIPORT
	// If the card is not powered, delay interrupt service until it is.
	if(!(pCard->PnpPowerFlags & PPF_POWERED) && (pCard->PnpPowerFlags & PPF_STARTED))
		return ServicedAnInterrupt;	// Most likely the interrupt is not ours anyway.
#endif


	switch(pCard->CardType)
	{	
	case Fast4_Isa:
	case Fast4_Pci:
	case RAS4_Pci:
		{
			if((READ_PORT_UCHAR(pCard->Controller + FAST_UARTS_0_TO_7_INTS_REG) & FAST_UARTS_0_TO_3_INT_PENDING) == 0)	
				return ServicedAnInterrupt;	// If no Uarts have interrupts pending then return.

			break;
		}

	case Fast8_Isa:
	case Fast8_Pci:
	case RAS8_Pci:
		{
			if(READ_PORT_UCHAR(pCard->Controller + FAST_UARTS_0_TO_7_INTS_REG) == 0)	
				return ServicedAnInterrupt;	// If no Uarts have interrupts pending then return.

			break;
		}

	case Fast16_Isa:
	case Fast16_Pci:
	case Fast16FMC_Pci:
		{
			if((READ_PORT_UCHAR(pCard->Controller + FAST_UARTS_0_TO_7_INTS_REG) == 0) 
			&& (READ_PORT_UCHAR(pCard->Controller + FAST_UARTS_9_TO_16_INTS_REG) == 0))	
				return ServicedAnInterrupt;	// If no Uarts have interrupts pending then return.

			break;
		}

		break;

	case Speed2_Pci:
	case Speed2P_Pci:
	case Speed4_Pci:
	case Speed4P_Pci:
		{
			if((READ_REGISTER_ULONG( (PULONG)(pCard->LocalConfigRegisters + SPEED_GIS_REG)) & INTERNAL_UART_INT_PENDING) == 0)
				return ServicedAnInterrupt;	// If no Uarts have interrupts pending then return.

			break;
		}

	case Speed2and4_Pci_8BitBus:
	case Speed2P_Pci_8BitBus:
	case Speed4P_Pci_8BitBus:
		return ServicedAnInterrupt;	// No UARTs therefore NO interrupts that are ours - we hope.
		break;

	default:
		break;
	}




	if(pUart)
	{
		while((IntsPending = pCard->UartLib.UL_IntsPending_XXXX(&pUart)))
		{
			pPort = (PPORT_DEVICE_EXTENSION) pCard->UartLib.UL_GetAppBackPtr_XXXX(pUart);	// Get Port Extension for UART.

			SpxDbgMsg(ISRINFO, ("%s: Int on 0x%lX", PRODUCT_NAME, IntsPending));

			// Service receive status interrupts
			if(IntsPending & UL_IP_RX_STAT)
			{	
				BYTE LineStatus = 0;
				DWORD RxStatus;
				pPort->pUartLib->UL_GetStatus_XXXX(pUart, &RxStatus, UL_GS_OP_LINESTATUS);
				
				// If OVERRUN/PARITY/FRAMING/DATA/BREAK error
				if(RxStatus & (UL_US_OVERRUN_ERROR | UL_US_PARITY_ERROR | UL_US_FRAMING_ERROR | UL_US_DATA_ERROR | UL_US_BREAK_ERROR))
				{
					BYTE TmpByte;

					// If the application has requested it, abort all the reads and writes on an error.
					if(pPort->HandFlow.ControlHandShake & SERIAL_ERROR_ABORT)
						KeInsertQueueDpc(&pPort->CommErrorDpc, NULL, NULL);
/*
					if(pPort->EscapeChar) 
					{
						TmpByte = pPort->EscapeChar;
						pPort->pUartLib->UL_ImmediateByte_XXXX(pPort->pUart, &TmpByte, UL_IM_OP_WRITE);

						
						if(RxStatus & UL_US_DATA_ERROR)
						{
							TmpByte = SERIAL_LSRMST_LSR_DATA
							pPort->pUartLib->UL_ImmediateByte_XXXX(pPort->pUart, &TmpByte, UL_IM_OP_WRITE);
						}
						else
						{
							TmpByte = SERIAL_LSRMST_LSR_NODATA
							pPort->pUartLib->UL_ImmediateByte_XXXX(pPort->pUart, &TmpByte, UL_IM_OP_WRITE);
						}
					}

*/
					if(RxStatus & UL_US_OVERRUN_ERROR) 
					{
						pPort->ErrorWord |= SERIAL_ERROR_OVERRUN;
						LineStatus |= SERIAL_LSR_OE; 
						pPort->PerfStats.SerialOverrunErrorCount++;
#ifdef WMI_SUPPORT 
						pPort->WmiPerfData.SerialOverrunErrorCount++;
#endif
					}

					if(RxStatus & UL_US_PARITY_ERROR) 
					{
						pPort->ErrorWord |= SERIAL_ERROR_PARITY;
						LineStatus |= SERIAL_LSR_PE; 
						pPort->PerfStats.ParityErrorCount++;
#ifdef WMI_SUPPORT 
						pPort->WmiPerfData.ParityErrorCount++;
#endif
					}

					if(RxStatus & UL_US_FRAMING_ERROR) 
					{
						pPort->ErrorWord |= SERIAL_ERROR_FRAMING;
						LineStatus |= SERIAL_LSR_FE; 
						pPort->PerfStats.FrameErrorCount++;
#ifdef WMI_SUPPORT 
						pPort->WmiPerfData.FrameErrorCount++;
#endif
					}

					if(RxStatus & UL_US_DATA_ERROR) 
					{
						LineStatus |= SERIAL_LSR_DR; 
					}


					if(RxStatus & UL_US_BREAK_ERROR)
					{
						pPort->ErrorWord |= SERIAL_ERROR_BREAK;
						LineStatus |= SERIAL_LSR_BI;
					}

/*
					if(pPort->EscapeChar)
					{
							TmpByte = LineStatus;
							pPort->pUartLib->UL_ImmediateByte_XXXX(pPort->pUart, &TmpByte, UL_IM_OP_WRITE);
					}

					if(RxStatus & (UL_US_OVERRUN_ERROR | UL_US_PARITY_ERROR | UL_US_FRAMING_ERROR | UL_US_DATA_ERROR))
					{
						if(pPort->HandFlow.FlowReplace & SERIAL_ERROR_CHAR)
						{
							TmpByte = pPort->SpecialChars.ErrorChar;
							pPort->pUartLib->UL_ImmediateByte_XXXX(pPort->pUart, &TmpByte, UL_IM_OP_WRITE);
						}
					}
*/
				}

		        if(pPort->IsrWaitMask) 
				{
					if((pPort->IsrWaitMask & SERIAL_EV_ERR) 
						&& (RxStatus & (UL_US_OVERRUN_ERROR | UL_US_PARITY_ERROR | UL_US_FRAMING_ERROR | UL_US_DATA_ERROR)))
					{
						// if we detected a overrun/parity/framing/data error
						pPort->HistoryMask |= SERIAL_EV_ERR;
					}

					// if we detected a break error
					if((pPort->IsrWaitMask & SERIAL_EV_BREAK) && (RxStatus & UL_US_BREAK_ERROR)) 
						pPort->HistoryMask |= SERIAL_EV_BREAK;
#ifdef USE_HW_TO_DETECT_CHAR
					// if we detected the special char
					if((pPort->IsrWaitMask & SERIAL_EV_RXFLAG) && (RxStatus & UL_RS_SPECIAL_CHAR_DETECTED)) 
						pPort->HistoryMask |= SERIAL_EV_RXFLAG;
#endif
					if(pPort->IrpMaskLocation && pPort->HistoryMask)
					{
						*pPort->IrpMaskLocation = pPort->HistoryMask;
                
						pPort->IrpMaskLocation = NULL;
						pPort->HistoryMask = 0;

						pPort->CurrentWaitIrp->IoStatus.Information = sizeof(ULONG);
						
						// Mark IRP as about to complete normally to prevent cancel & timer DPCs
						// from doing so before DPC is allowed to run.
						//SERIAL_SET_REFERENCE(pPort->CurrentWaitIrp, SERIAL_REF_COMPLETING);
							
						KeInsertQueueDpc(&pPort->CommWaitDpc, NULL, NULL);
					}
				}
			}


			// Service receive and receive timeout interrupts.
			if((IntsPending & UL_IP_RX) || (IntsPending & UL_IP_RXTO))
			{
				DWORD StatusFlags = 0;
				int BytesReceived = pPort->pUartLib->UL_InputData_XXXX(pUart, &StatusFlags);

			
				if(StatusFlags & UL_RS_BUFFER_OVERRUN)
				{
					// We have a new character but no room for it.
					pPort->ErrorWord |= SERIAL_ERROR_QUEUEOVERRUN;
					pPort->PerfStats.BufferOverrunErrorCount++;
#ifdef WMI_SUPPORT 
					pPort->WmiPerfData.BufferOverrunErrorCount++;
#endif
				}

				if(BytesReceived) 
				{
					ULONG AmountInBuffer = 0;
					GET_BUFFER_STATE BufferState;

					pPort->ReadByIsr += BytesReceived;
					pPort->PerfStats.ReceivedCount += BytesReceived;	// Increment Rx Counter
#ifdef WMI_SUPPORT 
					pPort->WmiPerfData.ReceivedCount += BytesReceived;
#endif

					pPort->pUartLib->UL_BufferControl_XXXX(pUart, &BufferState, UL_BC_OP_GET, UL_BC_BUFFER | UL_BC_IN);
					AmountInBuffer = BufferState.BytesInINBuffer; 


					if(pPort->IsrWaitMask) 
					{
						// Check to see if we should note the receive character
						if(pPort->IsrWaitMask & SERIAL_EV_RXCHAR)
							pPort->HistoryMask |= SERIAL_EV_RXCHAR;

						// If we've become 80% full on this character and this is an interesting event, note it.
						if((pPort->IsrWaitMask & SERIAL_EV_RX80FULL) && (AmountInBuffer >= pPort->BufferSizePt8)) 
							pPort->HistoryMask |= SERIAL_EV_RX80FULL;

#ifndef USE_HW_TO_DETECT_CHAR
						// if we detected the special char
						if((pPort->IsrWaitMask & SERIAL_EV_RXFLAG) && (StatusFlags & UL_RS_SPECIAL_CHAR_DETECTED)) 
							pPort->HistoryMask |= SERIAL_EV_RXFLAG;
#endif
						if(pPort->IrpMaskLocation && pPort->HistoryMask)
						{
							*pPort->IrpMaskLocation = pPort->HistoryMask;
            
							pPort->IrpMaskLocation = NULL;
							pPort->HistoryMask = 0;

							pPort->CurrentWaitIrp->IoStatus.Information = sizeof(ULONG);
               
							// Mark IRP as about to complete normally to prevent cancel & timer DPCs
							// from doing so before DPC is allowed to run.
							//SERIAL_SET_REFERENCE(pPort->CurrentWaitIrp, SERIAL_REF_COMPLETING);

							KeInsertQueueDpc(&pPort->CommWaitDpc, NULL, NULL);
						}
					}


					// If we have a current Read IRP. 
					if(pPort->CurrentReadIrp && pPort->NumberNeededForRead)
					{
						// If our ISR currently owns the IRP the we are allowed to do something with it,
						// But we only need to do something if we need to make room in the buffer
						// or we have enough bytes in the buffer to complete the current read IRP.
						if((SERIAL_REFERENCE_COUNT(pPort->CurrentReadIrp) & SERIAL_REF_ISR) 
							&& ((AmountInBuffer >= pPort->BufferSizePt8) 
							|| (AmountInBuffer >= pPort->NumberNeededForRead)))
						{
							ULONG NumberOfBytes = 0;

							NumberOfBytes = pPort->pUartLib->UL_ReadData_XXXX(pPort->pUart, 
									(PUCHAR)(pPort->CurrentReadIrp->AssociatedIrp.SystemBuffer)
									+ pPort->CurrentReadIrp->IoStatus.Information,
									IoGetCurrentIrpStackLocation(pPort->CurrentReadIrp)->Parameters.Read.Length 
									- pPort->CurrentReadIrp->IoStatus.Information);

							if(NumberOfBytes > pPort->NumberNeededForRead)
								pPort->NumberNeededForRead = 0;
							else
								pPort->NumberNeededForRead -= NumberOfBytes;


							pPort->CurrentReadIrp->IoStatus.Information += NumberOfBytes;

							if(pPort->NumberNeededForRead == 0)
							{
								ASSERT(pPort->CurrentReadIrp->IoStatus.Information 
									== IoGetCurrentIrpStackLocation(pPort->CurrentReadIrp)->Parameters.Read.Length);
							
								// Mark IRP as about to complete normally to prevent cancel & timer DPCs
								// from doing so before DPC is allowed to run.
								SERIAL_SET_REFERENCE(pPort->CurrentReadIrp, SERIAL_REF_COMPLETING);

								KeInsertQueueDpc(&pPort->CompleteReadDpc, NULL, NULL);
							}
						}
					}

				}

			}

			// Service transmitt and transmitt empty interrupts.
			if((IntsPending & UL_IP_TX) || (IntsPending & UL_IP_TX_EMPTY))
			{
				// No need to clear the INT it was already cleared by reading the IIR.
				DWORD BytesRemaining = pPort->pUartLib->UL_OutputData_XXXX(pUart);	// Output some bytes


				// If we have a current Write Immediate IRP. 
				if(pPort->CurrentImmediateIrp)
				{
					if(SERIAL_REFERENCE_COUNT(pPort->CurrentImmediateIrp) & SERIAL_REF_ISR)
					{
						if(pPort->TransmitImmediate == TRUE)
						{
							// Check if the byte has been sent.
							if(pPort->pUartLib->UL_ImmediateByte_XXXX(pUart, &pPort->ImmediateIndex, UL_IM_OP_STATUS) == UL_IM_NO_BYTE_TO_SEND)
							{
								pPort->TransmitImmediate = FALSE;
								pPort->EmptiedTransmit = TRUE;

								pPort->PerfStats.TransmittedCount++;	// Increment Tx Counter
#ifdef WMI_SUPPORT 
								pPort->WmiPerfData.TransmittedCount++;
#endif

								// Mark IRP as about to complete normally to prevent cancel & timer DPCs
								// from doing so before DPC is allowed to run.
								SERIAL_SET_REFERENCE(pPort->CurrentImmediateIrp, SERIAL_REF_COMPLETING);

								// Ask to complete the IRP.
								KeInsertQueueDpc(&pPort->CompleteImmediateDpc, NULL, NULL);
							}
						}
					}
				}



				// If we have a current Write IRP. 
				if(pPort->CurrentWriteIrp && pPort->WriteLength)
				{
					//
                    // Even though all of the characters being
                    // sent haven't all been sent, this variable
                    // will be checked when the transmit queue is
                    // empty.  If it is still true and there is a
                    // wait on the transmit queue being empty then
                    // we know we finished transmitting all characters
                    // following the initiation of the wait since
                    // the code that initiates the wait will set
                    // this variable to false.
                    //
                    // One reason it could be false is that
                    // the writes were cancelled before they
                    // actually started, or that the writes
                    // failed due to timeouts.  This variable
                    // basically says a character was written
                    // by the isr at some point following the
                    // initiation of the wait.
                    //

					if(SERIAL_REFERENCE_COUNT(pPort->CurrentWriteIrp) & SERIAL_REF_ISR)
					{
						if(pPort->WriteLength > BytesRemaining)
						{
							pPort->PerfStats.TransmittedCount += (pPort->WriteLength - BytesRemaining);	// Increment Tx Counter
#ifdef WMI_SUPPORT 
							pPort->WmiPerfData.TransmittedCount  += (pPort->WriteLength - BytesRemaining);
#endif	
						}
						else
						{
							pPort->PerfStats.TransmittedCount += pPort->WriteLength;	// Increment Tx Counter
#ifdef WMI_SUPPORT 
							pPort->WmiPerfData.TransmittedCount += pPort->WriteLength;
#endif	
						}

						pPort->WriteLength = BytesRemaining;
						pPort->EmptiedTransmit = TRUE;


						if(pPort->WriteLength == 0)		// If write is complete - lets complete the IRP
						{
							PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation(pPort->CurrentWriteIrp);
					
							// No More characters left. This write is complete. Take care when 
							// updating the information field, we could have an xoff
							// counter masquerading as a write irp.
									
							pPort->CurrentWriteIrp->IoStatus.Information 
								= (IrpSp->MajorFunction == IRP_MJ_WRITE) 
								? (IrpSp->Parameters.Write.Length) : (1);

							// Mark IRP as about to complete normally to prevent cancel & timer DPCs
							// from doing so before DPC is allowed to run.
							SERIAL_SET_REFERENCE(pPort->CurrentWriteIrp, SERIAL_REF_COMPLETING);

							KeInsertQueueDpc(&pPort->CompleteWriteDpc, NULL, NULL);
						}
					}
				}
			}


			// Service modem interrupts.
			if(IntsPending & UL_IP_MODEM)
			{
				SerialHandleModemUpdate(pPort, FALSE);
			}


			// Save a pointer to the UART serviced so it can be the first UART serviced 
			// in the list the next time the ISR is called.  
			//pCard->pFirstUart = pUart;

			ServicedAnInterrupt = TRUE;
		}
		
	}


	return ServicedAnInterrupt;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\spx\speed\driver\ioctl.c ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) 1991, 1992, 1993 Microsoft Corporation

Module Name:

    ioctl.c

Abstract:

    This module contains the ioctl dispatcher as well as a couple
    of routines that are generally just called in response to
    ioctl calls.

Author:

    Anthony V. Ercolano 26-Sep-1991

Environment:

    Kernel mode

Revision History :

-----------------------------------------------------------------------------*/

#include "precomp.h"

BOOLEAN SerialGetModemUpdate(IN PVOID Context);
BOOLEAN SerialGetCommStatus(IN PVOID Context);
VOID SerialGetProperties(IN PPORT_DEVICE_EXTENSION pPort, IN PSERIAL_COMMPROP Properties);
BOOLEAN SerialSetEscapeChar(IN PVOID Context);

#ifdef ALLOC_PRAGMA
#endif



BOOLEAN
SerialGetStats(IN PVOID Context)
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

    In sync with the interrpt service routine (which sets the perf stats)
    return the perf stats to the caller.

Arguments:

    Context - Pointer to a the irp.

Return Value:

    This routine always returns FALSE.

-----------------------------------------------------------------------------*/

{
    PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation((PIRP)Context);
    PPORT_DEVICE_EXTENSION pPort = irpSp->DeviceObject->DeviceExtension;
    PSERIALPERF_STATS sp = ((PIRP)Context)->AssociatedIrp.SystemBuffer;

	*sp = *((PSERIALPERF_STATS) &pPort->PerfStats);

    return FALSE;
}



BOOLEAN
SerialClearStats(IN PVOID Context)
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

    In sync with the interrpt service routine (which sets the perf stats)
    clear the perf stats.


Arguments:

    Context - Pointer to a the extension.

Return Value:

    This routine always returns FALSE.

-----------------------------------------------------------------------------*/
{
	PPORT_DEVICE_EXTENSION pPort = (PPORT_DEVICE_EXTENSION)Context;

    RtlZeroMemory(&pPort->PerfStats, sizeof(SERIALPERF_STATS));

#ifdef WMI_SUPPORT
	RtlZeroMemory(&pPort->WmiPerfData, sizeof(pPort->WmiPerfData));	
#endif

    return FALSE;
}



BOOLEAN
SerialSetChars(IN PVOID Context)
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

    This routine is used to set the special characters for the driver.

Arguments:

    Context - Pointer to a structure that contains a pointer to
              the device extension and a pointer to a special characters
              structure.

Return Value:

    This routine always returns FALSE.

-----------------------------------------------------------------------------*/
{
    PPORT_DEVICE_EXTENSION pPort = ((PSERIAL_IOCTL_SYNC)Context)->pPort;
    
	pPort->SpecialChars = *((PSERIAL_CHARS)(((PSERIAL_IOCTL_SYNC)Context)->Data));

	pPort->UartConfig.XON = pPort->SpecialChars.XonChar;	
	pPort->UartConfig.XOFF = pPort->SpecialChars.XoffChar;
	pPort->UartConfig.SpecialCharDetect = pPort->SpecialChars.EventChar;

	pPort->pUartLib->UL_SetConfig_XXXX(pPort->pUart, &pPort->UartConfig, UC_SPECIAL_CHARS_MASK);

    return FALSE;
}




BOOLEAN
SerialSetBaud(IN PVOID Context)
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

    This routine is used to set the buad rate of the device.

Arguments:

    Context - Pointer to a structure that contains a pointer to
              the device extension and what should be the current
              baud rate.

Return Value:

    This routine returns TRUE if it succeeds otherwise FALSE.

-----------------------------------------------------------------------------*/
{
    PPORT_DEVICE_EXTENSION pPort = Context;

	if(pPort->pUartLib->UL_SetConfig_XXXX(pPort->pUart, &pPort->UartConfig, UC_TX_BAUD_RATE_MASK) == UL_STATUS_SUCCESS)
	{
		// If baud rate is 300 or less then reduce the Tx FIFO size. 
		if(pPort->UartConfig.TxBaud <= 75)
		{
			pPort->BufferSizes.TxFIFOSize = 16;
			pPort->BufferSizes.TxFIFOTrigLevel = 4;
		}
		else if(pPort->UartConfig.TxBaud <= 300)
		{
			pPort->BufferSizes.TxFIFOSize = 32;
			pPort->BufferSizes.TxFIFOTrigLevel = 8;
		}
		else
		{
			pPort->BufferSizes.TxFIFOSize = pPort->TxFIFOSize;
			pPort->BufferSizes.TxFIFOTrigLevel = (BYTE) pPort->TxFIFOTrigLevel;
		}

		// Set Tx FIFO size.
		pPort->pUartLib->UL_BufferControl_XXXX(pPort->pUart, &pPort->BufferSizes, UL_BC_OP_SET, UL_BC_FIFO | UL_BC_OUT);

		return TRUE;
	}

	// It failed so lets revert the config settings back to those currently set.
	pPort->pUartLib->UL_GetConfig_XXXX(pPort->pUart, &pPort->UartConfig);

    return FALSE;
}



BOOLEAN
SerialSetLineControl(IN PVOID Context)
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

    This routine is used to set the buad rate of the device.

Arguments:

    Context - Pointer to the device extension.

Return Value:

    This routine always returns FALSE.

-----------------------------------------------------------------------------*/
{
    PPORT_DEVICE_EXTENSION pPort = Context;

	pPort->pUartLib->UL_SetConfig_XXXX(pPort->pUart, &pPort->UartConfig, UC_FRAME_CONFIG_MASK);
	
	return FALSE;
}



BOOLEAN
SerialGetModemUpdate(IN PVOID Context)
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

    This routine is simply used to call the interrupt level routine
    that handles modem status update.

Arguments:

    Context - Pointer to a structure that contains a pointer to
              the device extension and a pointer to a ulong.

Return Value:

    This routine always returns FALSE.

-----------------------------------------------------------------------------*/

{
    PPORT_DEVICE_EXTENSION pPort = ((PSERIAL_IOCTL_SYNC)Context)->pPort;
    ULONG *Result = (ULONG *)(((PSERIAL_IOCTL_SYNC)Context)->Data);

    *Result = SerialHandleModemUpdate(pPort, FALSE);

    return FALSE;
}



BOOLEAN
SerialGetCommStatus(IN PVOID Context)
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

    This is used to get the current state of the serial driver.

Arguments:

    Context - Pointer to a structure that contains a pointer to
              the device extension and a pointer to a serial status
              record.

Return Value:

    This routine always returns FALSE.

-----------------------------------------------------------------------------*/

{
    PPORT_DEVICE_EXTENSION pPort = ((PSERIAL_IOCTL_SYNC)Context)->pPort;
    PSERIAL_STATUS Stat = ((PSERIAL_IOCTL_SYNC)Context)->Data;
	GET_BUFFER_STATE BufferState;
	DWORD HoldingReasons = 0;

    Stat->Errors = pPort->ErrorWord;
    pPort->ErrorWord = 0;


    // BUG BUG We need to do something about eof (binary mode).
	Stat->EofReceived = FALSE;

	pPort->pUartLib->UL_BufferControl_XXXX(pPort->pUart, &BufferState, UL_BC_OP_GET, UL_BC_IN | UL_BC_BUFFER);
	Stat->AmountInInQueue = BufferState.BytesInINBuffer; 
    Stat->AmountInOutQueue = pPort->TotalCharsQueued;

    if(pPort->WriteLength) 
	{
        // By definition if we have a writelength, then we have a current write irp.
        ASSERT(pPort->CurrentWriteIrp);
        ASSERT(Stat->AmountInOutQueue >= pPort->WriteLength);
        ASSERT((IoGetCurrentIrpStackLocation(pPort->CurrentWriteIrp)->Parameters.Write.Length)
			>= pPort->WriteLength);

        Stat->AmountInOutQueue -= IoGetCurrentIrpStackLocation(pPort->CurrentWriteIrp)->Parameters.Write.Length 
			- (pPort->WriteLength);
    }

    Stat->WaitForImmediate = pPort->TransmitImmediate;



    Stat->HoldReasons = 0;
	pPort->pUartLib->UL_GetStatus_XXXX(pPort->pUart, &HoldingReasons, UL_GS_OP_HOLDING_REASONS);

	// Transmit holding reasons
    if(HoldingReasons & UL_TX_WAITING_FOR_CTS) 
        Stat->HoldReasons |= SERIAL_TX_WAITING_FOR_CTS;

    if(HoldingReasons & UL_TX_WAITING_FOR_DSR) 
        Stat->HoldReasons |= SERIAL_TX_WAITING_FOR_DSR;

    if(HoldingReasons & UL_TX_WAITING_FOR_DCD) 
        Stat->HoldReasons |= SERIAL_TX_WAITING_FOR_DCD;

    if(HoldingReasons & UL_TX_WAITING_FOR_XON) 
        Stat->HoldReasons |= SERIAL_TX_WAITING_FOR_XON;

    if(HoldingReasons & UL_TX_WAITING_ON_BREAK)
        Stat->HoldReasons |= SERIAL_TX_WAITING_ON_BREAK;


	// Receive holding reasons
    if(HoldingReasons & UL_RX_WAITING_FOR_DSR) 
        Stat->HoldReasons |= SERIAL_RX_WAITING_FOR_DSR;

    if(HoldingReasons & UL_TX_WAITING_XOFF_SENT)
        Stat->HoldReasons |= SERIAL_TX_WAITING_XOFF_SENT;

    return FALSE;
}



BOOLEAN
SerialSetEscapeChar(IN PVOID Context)
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

    This is used to set the character that will be used to escape
    line status and modem status information when the application
    has set up that line status and modem status should be passed
    back in the data stream.

Arguments:

    Context - Pointer to the irp that is specify the escape character.
              Implicitly - An escape character of 0 means no escaping
              will occur.

Return Value:

    This routine always returns FALSE.

-----------------------------------------------------------------------------*/

{
    PPORT_DEVICE_EXTENSION pPort = IoGetCurrentIrpStackLocation((PIRP)Context)->DeviceObject->DeviceExtension;

    pPort->EscapeChar = *(PUCHAR)((PIRP)Context)->AssociatedIrp.SystemBuffer;

    return FALSE;
}




NTSTATUS
SerialIoControl(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp)
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

    This routine provides the initial processing for all of the
    Ioctrls for the serial device.

Arguments:

    DeviceObject - Pointer to the device object for this device

    Irp - Pointer to the IRP for the current request

Return Value:

    The function value is the final status of the call

-----------------------------------------------------------------------------*/

{
    // The status that gets returned to the caller and
    // set in the Irp.
    NTSTATUS Status;

    // The current stack location.  This contains all of the
    // information we need to process this particular request.
    PIO_STACK_LOCATION IrpSp;

    // Just what it says.  This is the serial specific device
    // extension of the device object create for the serial driver.
    PPORT_DEVICE_EXTENSION pPort = DeviceObject->DeviceExtension;
    
    // A temporary to hold the old IRQL so that it can be
    // restored once we complete/validate this request.
    KIRQL OldIrql;

    SerialDump(SERIRPPATH, ("Serial I/O Ctrl Dispatch entry for Irp: %x\n",Irp));
	SpxIRPCounter(pPort, Irp, IRP_SUBMITTED);	// Increment counter for performance stats.

    if(SerialCompleteIfError(DeviceObject, Irp) != STATUS_SUCCESS)
        return STATUS_CANCELLED;

    IrpSp = IoGetCurrentIrpStackLocation(Irp);
    Irp->IoStatus.Information = 0L;
    Status = STATUS_SUCCESS;

    switch (IrpSp->Parameters.DeviceIoControl.IoControlCode) 
	{

    case IOCTL_SERIAL_SET_BAUD_RATE: 
		{

			ULONG BaudRate;
			// Will hold the value of the appropriate divisor for
			// the requested baud rate.  If the baudrate is invalid
			// (because the device won't support that baud rate) then
			// this value is undefined.
			//
			// Note: in one sense the concept of a valid baud rate
			// is cloudy.  We could allow the user to request any
			// baud rate.  We could then calculate the divisor needed
			// for that baud rate.  As long as the divisor wasn't less
			// than one we would be "ok".  (The percentage difference
			// between the "true" divisor and the "rounded" value given
			// to the hardware might make it unusable, but... )  It would
			// really be up to the user to "Know" whether the baud rate
			// is suitable.  So much for theory, *We* only support a given
			// set of baud rates.
        
			SHORT AppropriateDivisor;

			if(IrpSp->Parameters.DeviceIoControl.InputBufferLength < sizeof(SERIAL_BAUD_RATE))
			{
				Status = STATUS_BUFFER_TOO_SMALL;
				break;
			} 
			else 
			{
				BaudRate = ((PSERIAL_BAUD_RATE)(Irp->AssociatedIrp.SystemBuffer))->BaudRate;
			}

			// Get the baud rate from the irp.  We pass it
			// to a routine which will set the correct divisor.

			pPort->UartConfig.TxBaud = BaudRate;
			
			SpxDbgMsg(BAUDINFO,("%s: Requested Baud Rate: %d\n", PRODUCT_NAME, BaudRate)); 
		
			KeAcquireSpinLock(&pPort->ControlLock, &OldIrql);
			
			if(KeSynchronizeExecution(pPort->Interrupt, SerialSetBaud, pPort))
			{
				Status = STATUS_SUCCESS;
#ifdef WMI_SUPPORT
				pPort->WmiCommData.BaudRate = BaudRate;
#endif
			}
			else
			{
				Status = STATUS_INVALID_PARAMETER;
			}

			KeReleaseSpinLock(&pPort->ControlLock, OldIrql);

			break;
		}

    case IOCTL_SERIAL_GET_BAUD_RATE: 
		{
			PSERIAL_BAUD_RATE Br = (PSERIAL_BAUD_RATE)Irp->AssociatedIrp.SystemBuffer;
			
			if(IrpSp->Parameters.DeviceIoControl.OutputBufferLength < sizeof(SERIAL_BAUD_RATE)) 
			{
				Status = STATUS_BUFFER_TOO_SMALL;
				break;
			}

			KeAcquireSpinLock(&pPort->ControlLock, &OldIrql);
			Br->BaudRate = pPort->UartConfig.TxBaud;
			KeReleaseSpinLock(&pPort->ControlLock, OldIrql);

			Irp->IoStatus.Information = sizeof(SERIAL_BAUD_RATE);

			break;
		}

    case IOCTL_SERIAL_SET_LINE_CONTROL: 
		{
			// Points to the line control record in the Irp.
			PSERIAL_LINE_CONTROL Lc = ((PSERIAL_LINE_CONTROL)(Irp->AssociatedIrp.SystemBuffer));

			ULONG FCData;
			ULONG FCStop;
			ULONG FCParity;
			UCHAR LData;
			UCHAR LStop;
			UCHAR LParity;
			UCHAR Mask = 0xff;

			if(IrpSp->Parameters.DeviceIoControl.InputBufferLength < sizeof(SERIAL_LINE_CONTROL)) 
			{
				Status = STATUS_BUFFER_TOO_SMALL;
				break;
			}

			switch(Lc->WordLength) 
			{
				case 5:
					FCData = UC_FCFG_DATALEN_5;
					LData = SERIAL_5_DATA;
					Mask = 0x1f;
					break;

				case 6: 
					FCData = UC_FCFG_DATALEN_6;
					LData = SERIAL_6_DATA;
					Mask = 0x3f;
					break;

				case 7: 
					FCData = UC_FCFG_DATALEN_7;
					LData = SERIAL_7_DATA;
					Mask = 0x7f;
					break;

				case 8: 
					FCData = UC_FCFG_DATALEN_8;
					LData = SERIAL_8_DATA;
					break;

				default: 
					Status = STATUS_INVALID_PARAMETER;
					goto DoneWithIoctl;
			}

			switch(Lc->Parity) 
			{

				case NO_PARITY: 
					FCParity = UC_FCFG_NO_PARITY;
					LParity = SERIAL_NONE_PARITY;
					break;

				case EVEN_PARITY:
					FCParity = UC_FCFG_EVEN_PARITY;
					LParity = SERIAL_EVEN_PARITY;
					break;

				case ODD_PARITY: 
					FCParity = UC_FCFG_ODD_PARITY;
					LParity = SERIAL_ODD_PARITY;
					break;

				case SPACE_PARITY: 
					FCParity = UC_FCFG_SPACE_PARITY;
					LParity = SERIAL_SPACE_PARITY;
					break;

				case MARK_PARITY: 
					FCParity = UC_FCFG_MARK_PARITY;
					LParity = SERIAL_MARK_PARITY;
					break;

				default:
					Status = STATUS_INVALID_PARAMETER;
					goto DoneWithIoctl;
					break;
			}

			switch(Lc->StopBits) 
			{
				case STOP_BIT_1: 
					FCStop = UC_FCFG_STOPBITS_1;
					LStop = SERIAL_1_STOP;
					break;

				case STOP_BITS_1_5: 
					{
						if(LData != SERIAL_5_DATA) 
						{
							Status = STATUS_INVALID_PARAMETER;
							goto DoneWithIoctl;
						}

						FCStop = UC_FCFG_STOPBITS_1_5;
						LStop = SERIAL_1_5_STOP;
						break;
					}

				case STOP_BITS_2: 
					{
						if(LData == SERIAL_5_DATA) 
						{
							Status = STATUS_INVALID_PARAMETER;
							goto DoneWithIoctl;
						}

						FCStop = UC_FCFG_STOPBITS_2;
						LStop = SERIAL_2_STOP;
						break;
					}

				default:
					Status = STATUS_INVALID_PARAMETER;
					goto DoneWithIoctl;
			}

			KeAcquireSpinLock(&pPort->ControlLock, &OldIrql);

			pPort->UartConfig.FrameConfig = (pPort->UartConfig.FrameConfig & ~UC_FCFG_DATALEN_MASK) | FCData;
			pPort->UartConfig.FrameConfig = (pPort->UartConfig.FrameConfig & ~UC_FCFG_PARITY_MASK) | FCParity;
			pPort->UartConfig.FrameConfig = (pPort->UartConfig.FrameConfig & ~UC_FCFG_STOPBITS_MASK) | FCStop;
			
			pPort->LineControl 	= (UCHAR)((pPort->LineControl & SERIAL_LCR_BREAK) | (LData | LParity | LStop));
			pPort->ValidDataMask = Mask;

			KeSynchronizeExecution(pPort->Interrupt, SerialSetLineControl, pPort);


#ifdef WMI_SUPPORT
			UPDATE_WMI_LINE_CONTROL(pPort->WmiCommData, pPort->LineControl);
#endif
				
			KeReleaseSpinLock(&pPort->ControlLock, OldIrql);

			break;
		}

    case IOCTL_SERIAL_GET_LINE_CONTROL: 
		{
			PSERIAL_LINE_CONTROL Lc = (PSERIAL_LINE_CONTROL)Irp->AssociatedIrp.SystemBuffer;

			if(IrpSp->Parameters.DeviceIoControl.OutputBufferLength < sizeof(SERIAL_LINE_CONTROL))
			{
				Status = STATUS_BUFFER_TOO_SMALL;
				break;
			}

			KeAcquireSpinLock(&pPort->ControlLock, &OldIrql);

		
			switch(pPort->UartConfig.FrameConfig & UC_FCFG_DATALEN_MASK)
			{
			case UC_FCFG_DATALEN_5:
				Lc->WordLength = 5;
				break;

			case UC_FCFG_DATALEN_6:
				Lc->WordLength = 6;
				break;

			case UC_FCFG_DATALEN_7:
				Lc->WordLength = 7;
				break;

			case UC_FCFG_DATALEN_8:
				Lc->WordLength = 8;
				break;

			default:
				break;
			}

			switch(pPort->UartConfig.FrameConfig & UC_FCFG_PARITY_MASK)
			{
			case UC_FCFG_NO_PARITY:
				Lc->Parity = NO_PARITY;
				break;

			case UC_FCFG_ODD_PARITY:
				Lc->Parity = ODD_PARITY;
				break;

			case UC_FCFG_EVEN_PARITY:
				Lc->Parity = EVEN_PARITY;
				break;

			case UC_FCFG_MARK_PARITY:
				Lc->Parity = MARK_PARITY;
				break;

			case UC_FCFG_SPACE_PARITY:
				Lc->Parity = SPACE_PARITY;
				break;

			default:
				break;
			}

			switch(pPort->UartConfig.FrameConfig & UC_FCFG_STOPBITS_MASK)
			{
			case UC_FCFG_STOPBITS_1:
				Lc->StopBits = STOP_BIT_1;
				break;

			case UC_FCFG_STOPBITS_1_5:
				Lc->StopBits = STOP_BITS_1_5;
				break;

			case UC_FCFG_STOPBITS_2:
				Lc->StopBits = STOP_BITS_2;
				break;

			default:
				break;
			}


			Irp->IoStatus.Information = sizeof(SERIAL_LINE_CONTROL);

			KeReleaseSpinLock(&pPort->ControlLock, OldIrql);
			break;
		}

    case IOCTL_SERIAL_SET_TIMEOUTS: 
		{
			PSERIAL_TIMEOUTS NewTimeouts = ((PSERIAL_TIMEOUTS)(Irp->AssociatedIrp.SystemBuffer));

			if(IrpSp->Parameters.DeviceIoControl.InputBufferLength < sizeof(SERIAL_TIMEOUTS))
			{
				Status = STATUS_BUFFER_TOO_SMALL;
				break;
			}

			if((NewTimeouts->ReadIntervalTimeout == MAXULONG) 
				&& (NewTimeouts->ReadTotalTimeoutMultiplier == MAXULONG) 
				&& (NewTimeouts->ReadTotalTimeoutConstant == MAXULONG)) 
			{
				Status = STATUS_INVALID_PARAMETER;
				break;
			}

			KeAcquireSpinLock(&pPort->ControlLock, &OldIrql);

			pPort->Timeouts.ReadIntervalTimeout			= NewTimeouts->ReadIntervalTimeout;
			pPort->Timeouts.ReadTotalTimeoutMultiplier	= NewTimeouts->ReadTotalTimeoutMultiplier;
			pPort->Timeouts.ReadTotalTimeoutConstant	= NewTimeouts->ReadTotalTimeoutConstant;
			pPort->Timeouts.WriteTotalTimeoutMultiplier = NewTimeouts->WriteTotalTimeoutMultiplier;
			pPort->Timeouts.WriteTotalTimeoutConstant	= NewTimeouts->WriteTotalTimeoutConstant;

			KeReleaseSpinLock(&pPort->ControlLock,OldIrql);
				
			break;
		}

    case IOCTL_SERIAL_GET_TIMEOUTS: 
		{

			if(IrpSp->Parameters.DeviceIoControl.OutputBufferLength < sizeof(SERIAL_TIMEOUTS))
			{
				Status = STATUS_BUFFER_TOO_SMALL;
				break;
			}

			KeAcquireSpinLock(&pPort->ControlLock, &OldIrql);
            
			*((PSERIAL_TIMEOUTS)Irp->AssociatedIrp.SystemBuffer) = pPort->Timeouts;
			Irp->IoStatus.Information = sizeof(SERIAL_TIMEOUTS);

			KeReleaseSpinLock(&pPort->ControlLock, OldIrql);
            
			break;
		}

    case IOCTL_SERIAL_SET_CHARS: 
		{

			SERIAL_IOCTL_SYNC S;
			PSERIAL_CHARS NewChars = ((PSERIAL_CHARS)(Irp->AssociatedIrp.SystemBuffer));
            
			if(IrpSp->Parameters.DeviceIoControl.InputBufferLength < sizeof(SERIAL_CHARS)) 
			{
				Status = STATUS_BUFFER_TOO_SMALL;
				break;
			}

			//
			// The only thing that can be wrong with the chars
			// is that the xon and xoff characters are the
			// same.
			//
#if 0
			if(NewChars->XonChar == NewChars->XoffChar) 
			{
				Status = STATUS_INVALID_PARAMETER;
				break;
			}
#endif

			//
			// We acquire the control lock so that only
			// one request can GET or SET the characters
			// at a time.  The sets could be synchronized
			// by the interrupt spinlock, but that wouldn't
			// prevent multiple gets at the same time.
			//

			S.pPort = pPort;
			S.Data = NewChars;

			KeAcquireSpinLock(&pPort->ControlLock, &OldIrql);
            
			//
			// Under the protection of the lock, make sure that
			// the xon and xoff characters aren't the same as
			// the escape character.
			//

			if(pPort->EscapeChar) 
			{
				if((pPort->EscapeChar == NewChars->XonChar) || (pPort->EscapeChar == NewChars->XoffChar))
				{
					Status = STATUS_INVALID_PARAMETER;
					KeReleaseSpinLock(&pPort->ControlLock, OldIrql);
					break;
				}
			}

			KeSynchronizeExecution(pPort->Interrupt, SerialSetChars, &S);
#ifdef WMI_SUPPORT
			UPDATE_WMI_XON_XOFF_CHARS(pPort->WmiCommData, pPort->SpecialChars);
#endif

			KeReleaseSpinLock(&pPort->ControlLock, OldIrql);
			break;
		}

    case IOCTL_SERIAL_GET_CHARS: 
		{
			if(IrpSp->Parameters.DeviceIoControl.OutputBufferLength < sizeof(SERIAL_CHARS))
			{
				Status = STATUS_BUFFER_TOO_SMALL;
				break;
			}

			KeAcquireSpinLock(&pPort->ControlLock, &OldIrql);

			*((PSERIAL_CHARS)Irp->AssociatedIrp.SystemBuffer) = pPort->SpecialChars;
			Irp->IoStatus.Information = sizeof(SERIAL_CHARS);

			KeReleaseSpinLock(&pPort->ControlLock, OldIrql);
				
			break;
		}

    case IOCTL_SERIAL_SET_DTR:
    case IOCTL_SERIAL_CLR_DTR: 
		{
			//
			// We acquire the lock so that we can check whether
			// automatic dtr flow control is enabled.  If it is
			// then we return an error since the app is not allowed
			// to touch this if it is automatic.
			//

			KeAcquireSpinLock(&pPort->ControlLock, &OldIrql);
				
			if((pPort->HandFlow.ControlHandShake & SERIAL_DTR_MASK) == SERIAL_DTR_HANDSHAKE)
			{
				Irp->IoStatus.Status = STATUS_INVALID_PARAMETER;
			} 
			else 
			{
				KeSynchronizeExecution(pPort->Interrupt,
					((IrpSp->Parameters.DeviceIoControl.IoControlCode == IOCTL_SERIAL_SET_DTR)
					 ? (SerialSetDTR) : (SerialClrDTR)) , pPort);
			}

			KeReleaseSpinLock(&pPort->ControlLock, OldIrql);
				
			break;
		}

    case IOCTL_SERIAL_RESET_DEVICE: 
		{
			break;
		}

    case IOCTL_SERIAL_SET_RTS:
    case IOCTL_SERIAL_CLR_RTS: 
		{
			//
			// We acquire the lock so that we can check whether automatic rts flow control 
			// or transmit toggleing is enabled.  If it is then we return an error since
			// the app is not allowed to touch this if it is automatic or toggling.
			//

			KeAcquireSpinLock(&pPort->ControlLock, &OldIrql);
				
			if(((pPort->HandFlow.FlowReplace & SERIAL_RTS_MASK) == SERIAL_RTS_HANDSHAKE)
				|| ((pPort->HandFlow.FlowReplace & SERIAL_RTS_MASK) == SERIAL_TRANSMIT_TOGGLE))
			{	
				Irp->IoStatus.Status = STATUS_INVALID_PARAMETER;
			} 
			else 
			{
				KeSynchronizeExecution(pPort->Interrupt,
					((IrpSp->Parameters.DeviceIoControl.IoControlCode == IOCTL_SERIAL_SET_RTS)
					? (SerialSetRTS) : (SerialClrRTS)), pPort);		
			}

			KeReleaseSpinLock(&pPort->ControlLock, OldIrql);
			break;
		}

    case IOCTL_SERIAL_SET_XOFF: 
		{
			KeSynchronizeExecution(pPort->Interrupt, SerialPretendXoff, pPort);
			break;
		}

    case IOCTL_SERIAL_SET_XON: 
		{
			KeSynchronizeExecution(pPort->Interrupt, SerialPretendXon, pPort);
			break;
		}

    case IOCTL_SERIAL_SET_BREAK_ON: 
		{

			KeSynchronizeExecution(pPort->Interrupt, SerialTurnOnBreak, pPort);
			break;
		}

    case IOCTL_SERIAL_SET_BREAK_OFF: 
		{

			KeSynchronizeExecution(pPort->Interrupt, SerialTurnOffBreak, pPort);
			break;
		}

    case IOCTL_SERIAL_SET_QUEUE_SIZE: 
		{

			// Type ahead buffer is fixed, so we just validate
			// the the users request is not bigger that our
			// own internal buffer size.
        
			PSERIAL_QUEUE_SIZE Rs = ((PSERIAL_QUEUE_SIZE)(Irp->AssociatedIrp.SystemBuffer));
				

			if(IrpSp->Parameters.DeviceIoControl.InputBufferLength < sizeof(SERIAL_QUEUE_SIZE)) 
			{
				Status = STATUS_BUFFER_TOO_SMALL;
				break;
			}

			// We have to allocate the memory for the new
			// buffer while we're still in the context of the
			// caller.  We don't even try to protect this
			// with a lock because the value could be stale
			// as soon as we release the lock - The only time
			// we will know for sure is when we actually try
			// to do the resize.
        
			if(Rs->InSize <= pPort->BufferSize) 
			{
				Status = STATUS_SUCCESS;
				break;
			}

			try 
			{
				IrpSp->Parameters.DeviceIoControl.Type3InputBuffer 
					= SpxAllocateMemWithQuota(NonPagedPool, Rs->InSize);
			} 
			except (EXCEPTION_EXECUTE_HANDLER) 
			{
				IrpSp->Parameters.DeviceIoControl.Type3InputBuffer = NULL;
				Status = GetExceptionCode();
			}

			
			if(!IrpSp->Parameters.DeviceIoControl.Type3InputBuffer) 
			{
				break;
			}

			//
			// Well the data passed was big enough.  Do the request.
			//
			// There are two reason we place it in the read queue:
			//
			// 1) We want to serialize these resize requests so that
			//    they don't contend with each other.
			//
			// 2) We want to serialize these requests with reads since
			//    we don't want reads and resizes contending over the
			//    read buffer.
			//
			
			return SerialStartOrQueue(pPort, Irp, &pPort->ReadQueue, 
						&pPort->CurrentReadIrp, SerialStartRead);
					   
			break;

		}

    case IOCTL_SERIAL_GET_WAIT_MASK: 
		{

			if (IrpSp->Parameters.DeviceIoControl.OutputBufferLength < sizeof(ULONG)) 
			{
				Status = STATUS_BUFFER_TOO_SMALL;
				break;
			}

			// Simple scalar read.  No reason to acquire a lock.
			Irp->IoStatus.Information = sizeof(ULONG);

			*((ULONG *)Irp->AssociatedIrp.SystemBuffer) = pPort->IsrWaitMask;

			break;
		}

    case IOCTL_SERIAL_SET_WAIT_MASK: 
		{
			ULONG NewMask;

			SerialDump(SERDIAG3 | SERIRPPATH,	("In Ioctl processing for set mask\n"));
				
			if(IrpSp->Parameters.DeviceIoControl.InputBufferLength < sizeof(ULONG))
			{
				SerialDump(SERDIAG3, ("Invalid size for the buffer %d\n", IrpSp->Parameters.DeviceIoControl.InputBufferLength));
					
				Status = STATUS_BUFFER_TOO_SMALL;
				break;
			} 
			else 
			{
				NewMask = *((ULONG *)Irp->AssociatedIrp.SystemBuffer);
			}

			// Make sure that the mask only contains valid
			// waitable events.

			if(NewMask & ~(	SERIAL_EV_RXCHAR   |
							SERIAL_EV_RXFLAG   |
							SERIAL_EV_TXEMPTY  |
							SERIAL_EV_CTS      |
							SERIAL_EV_DSR      |
							SERIAL_EV_RLSD     |
							SERIAL_EV_BREAK    |
							SERIAL_EV_ERR      |
							SERIAL_EV_RING     |
							SERIAL_EV_PERR     |
							SERIAL_EV_RX80FULL |
							SERIAL_EV_EVENT1   |
							SERIAL_EV_EVENT2)) 
			{

				SerialDump(SERDIAG3,("Unknown mask %x\n", NewMask));
				Status = STATUS_INVALID_PARAMETER;
				break;
			}

			// Either start this irp or put it on the
			// queue.

			SerialDump(SERDIAG3 | SERIRPPATH, ("Starting or queuing set mask irp %x\n", Irp));
				
				
				
			return SerialStartOrQueue(pPort, Irp, &pPort->MaskQueue, 
						&pPort->CurrentMaskIrp, SerialStartMask);
					   
		}

    case IOCTL_SERIAL_WAIT_ON_MASK: 
		{
			SerialDump(SERDIAG3 | SERIRPPATH, ("In Ioctl processing for wait mask\n"));

			if(IrpSp->Parameters.DeviceIoControl.OutputBufferLength < sizeof(ULONG)) 
			{

				SerialDump(SERDIAG3,("Invalid size fo the buffer %d\n", 
					IrpSp->Parameters.DeviceIoControl.InputBufferLength));

				Status = STATUS_BUFFER_TOO_SMALL;
				break;
			}

			// Either start this irp or put it on the queue.
			SerialDump(SERDIAG3 | SERIRPPATH,("Starting or queuing wait mask irp %x\n", Irp));
            
			return SerialStartOrQueue(pPort, Irp, &pPort->MaskQueue, 
						&pPort->CurrentMaskIrp, SerialStartMask);
                  
	    }

	case IOCTL_SERIAL_IMMEDIATE_CHAR: 
		{
			if(IrpSp->Parameters.DeviceIoControl.InputBufferLength < sizeof(UCHAR))
			{
				Status = STATUS_BUFFER_TOO_SMALL;
				break;
			}

			IoAcquireCancelSpinLock(&OldIrql);
			
			if(pPort->CurrentImmediateIrp) 
			{
				Status = STATUS_INVALID_PARAMETER;
				IoReleaseCancelSpinLock(OldIrql);
			} 
			else 
			{
				// We can queue the char.  We need to set
				// a cancel routine because flow control could
				// keep the char from transmitting.  Make sure
				// that the irp hasn't already been canceled.

				if(Irp->Cancel) 
				{
					IoReleaseCancelSpinLock(OldIrql);
					Status = STATUS_CANCELLED;
				} 
				else 
				{
					pPort->CurrentImmediateIrp = Irp;
					pPort->TotalCharsQueued++;
					IoReleaseCancelSpinLock(OldIrql);
					SerialStartImmediate(pPort);

					return STATUS_PENDING;
				}
			}

			break;
		}

    case IOCTL_SERIAL_PURGE: 
		{
	        ULONG Mask;

		    if(IrpSp->Parameters.DeviceIoControl.InputBufferLength < sizeof(ULONG))
			{
				Status = STATUS_BUFFER_TOO_SMALL;
				break;
			}

			// Check to make sure that the mask only has
			// 0 or the other appropriate values.

			Mask = *((ULONG *)(Irp->AssociatedIrp.SystemBuffer));

			if((!Mask) || (Mask & (~( SERIAL_PURGE_TXABORT |
									  SERIAL_PURGE_RXABORT |
									  SERIAL_PURGE_TXCLEAR |
									  SERIAL_PURGE_RXCLEAR ))))
			{

				Status = STATUS_INVALID_PARAMETER;
				break;

			}

			// Either start this irp or put it on the queue.
			return SerialStartOrQueue(pPort, Irp, &pPort->PurgeQueue, 
						&pPort->CurrentPurgeIrp, SerialStartPurge);

		}

    case IOCTL_SERIAL_GET_HANDFLOW: 
		{
			if(IrpSp->Parameters.DeviceIoControl.OutputBufferLength < sizeof(SERIAL_HANDFLOW))
			{
				Status = STATUS_BUFFER_TOO_SMALL;
				break;
			}

			Irp->IoStatus.Information = sizeof(SERIAL_HANDFLOW);

			KeAcquireSpinLock(&pPort->ControlLock, &OldIrql);
			*((PSERIAL_HANDFLOW)Irp->AssociatedIrp.SystemBuffer) = pPort->HandFlow;
			KeReleaseSpinLock(&pPort->ControlLock, OldIrql);
				
			break;
		}

    case IOCTL_SERIAL_SET_HANDFLOW: 
		{
			SERIAL_IOCTL_SYNC S;
			PSERIAL_HANDFLOW HandFlow = Irp->AssociatedIrp.SystemBuffer;

			// Make sure that the hand shake and control is the right size.
			if(IrpSp->Parameters.DeviceIoControl.InputBufferLength < sizeof(SERIAL_HANDFLOW))
			{
				Status = STATUS_BUFFER_TOO_SMALL;
				break;
			}

			// Make sure that there are no invalid bits set in the control and handshake.
			if(HandFlow->ControlHandShake & SERIAL_CONTROL_INVALID) 
			{
				Status = STATUS_INVALID_PARAMETER;
				break;
			}

			if(HandFlow->FlowReplace & SERIAL_FLOW_INVALID) 
			{
				Status = STATUS_INVALID_PARAMETER;
				break;
			}

			// Make sure that the app hasn't set an invlid DTR mode.
			if((HandFlow->ControlHandShake & SERIAL_DTR_MASK) == SERIAL_DTR_MASK)
			{
				Status = STATUS_INVALID_PARAMETER;
				break;
			}

			// Make sure that haven't set totally invalid xon/xoff limits.
			if((HandFlow->XonLimit < 0) || ((ULONG)HandFlow->XonLimit > pPort->BufferSize)) 
			{
				Status = STATUS_INVALID_PARAMETER;
				break;
			}

			if((HandFlow->XoffLimit < 0) || ((ULONG)HandFlow->XoffLimit > pPort->BufferSize)) 
			{
				Status = STATUS_INVALID_PARAMETER;
				break;
			}

			S.pPort = pPort;
			S.Data = HandFlow;

			KeAcquireSpinLock(&pPort->ControlLock, &OldIrql);

			// Under the protection of the lock, make sure that we aren't turning on error 
			// replacement when we are doing line status/modem status insertion.

			if(pPort->EscapeChar) 
			{
				if(HandFlow->FlowReplace & SERIAL_ERROR_CHAR) 
				{
					Status = STATUS_INVALID_PARAMETER;
					KeReleaseSpinLock(&pPort->ControlLock, OldIrql);
					break;
				}
			}

			KeSynchronizeExecution(pPort->Interrupt, SerialSetHandFlow, &S);
#ifdef WMI_SUPPORT
			UPDATE_WMI_XMIT_THRESHOLDS(pPort->WmiCommData, pPort->HandFlow);
#endif

			KeReleaseSpinLock(&pPort->ControlLock, OldIrql);

			break;
		}

    case IOCTL_SERIAL_GET_MODEMSTATUS: 
		{
			SERIAL_IOCTL_SYNC S;

			if(IrpSp->Parameters.DeviceIoControl.OutputBufferLength < sizeof(ULONG)) 
			{
				Status = STATUS_BUFFER_TOO_SMALL;
				break;
			}

			Irp->IoStatus.Information = sizeof(ULONG);

			S.pPort = pPort;
			S.Data = Irp->AssociatedIrp.SystemBuffer;

			KeAcquireSpinLock(&pPort->ControlLock, &OldIrql);
			KeSynchronizeExecution(pPort->Interrupt, SerialGetModemUpdate, &S);
			KeReleaseSpinLock(&pPort->ControlLock, OldIrql);
			break;

		}

    case IOCTL_SERIAL_GET_DTRRTS: 
		{
			ULONG ModemControl = 0;

			if(IrpSp->Parameters.DeviceIoControl.OutputBufferLength < sizeof(ULONG))
			{
				Status = STATUS_BUFFER_TOO_SMALL;
				break;
			}

			Irp->IoStatus.Information = sizeof(ULONG);
			Status = STATUS_SUCCESS;

			// Reading this hardware has no effect on the device.

			if(pPort->DTR_Set)
				ModemControl |= SERIAL_DTR_STATE;

			if(pPort->RTS_Set)
				ModemControl |= SERIAL_RTS_STATE;

			*(PULONG)Irp->AssociatedIrp.SystemBuffer = ModemControl;
			break;
		}

    case IOCTL_SERIAL_GET_COMMSTATUS: 
		{
			SERIAL_IOCTL_SYNC S;

			if(IrpSp->Parameters.DeviceIoControl.OutputBufferLength <sizeof(SERIAL_STATUS))
			{
				Status = STATUS_BUFFER_TOO_SMALL;
				break;
			}

			Irp->IoStatus.Information = sizeof(SERIAL_STATUS);

			S.pPort	= pPort;
			S.Data	= Irp->AssociatedIrp.SystemBuffer;

			//
			// Acquire the cancel spin lock so nothing much
			// changes while were getting the state.
			//

			IoAcquireCancelSpinLock(&OldIrql);

			KeSynchronizeExecution(pPort->Interrupt, SerialGetCommStatus, &S);
				
			IoReleaseCancelSpinLock(OldIrql);
			break;
		}

    case IOCTL_SERIAL_GET_PROPERTIES: 
		{
			if(IrpSp->Parameters.DeviceIoControl.OutputBufferLength <sizeof(SERIAL_COMMPROP))
			{
				Status = STATUS_BUFFER_TOO_SMALL;
				break;
			}

			// No synchronization is required since this information is "static".
			SerialGetProperties(pPort, Irp->AssociatedIrp.SystemBuffer);

			Irp->IoStatus.Information = sizeof(SERIAL_COMMPROP);
			Status = STATUS_SUCCESS;

			break;
		}

    case IOCTL_SERIAL_XOFF_COUNTER: 
		{
			PSERIAL_XOFF_COUNTER Xc = Irp->AssociatedIrp.SystemBuffer;

            Status = STATUS_NOT_IMPLEMENTED;

			/*
			if (IrpSp->Parameters.DeviceIoControl.InputBufferLength < sizeof(SERIAL_XOFF_COUNTER))
			{
				Status = STATUS_BUFFER_TOO_SMALL;
				break;
			}

			if(Xc->Counter <= 0) 
			{
				Status = STATUS_INVALID_PARAMETER;
				break;
			}

			// So far so good.  Put the irp onto the write queue.

			return SerialStartOrQueue(pPort, Irp, &pPort->WriteQueue, 
						&pPort->CurrentWriteIrp,SerialStartWrite);

			*/

			break;
		}

    case IOCTL_SERIAL_LSRMST_INSERT: 
		{

			PUCHAR escapeChar = Irp->AssociatedIrp.SystemBuffer;

			// Make sure we get a byte.

			if(IrpSp->Parameters.DeviceIoControl.InputBufferLength < sizeof(UCHAR))
			{
				Status = STATUS_BUFFER_TOO_SMALL;
				break;
			}

			KeAcquireSpinLock(&pPort->ControlLock, &OldIrql);
				
			if(*escapeChar) 
			{
				// We've got some escape work to do.  We will make sure that
				// the character is not the same as the Xon or Xoff character,
				// or that we are already doing error replacement.

				if((*escapeChar == pPort->SpecialChars.XoffChar) 
					|| (*escapeChar == pPort->SpecialChars.XonChar) 
					|| (pPort->HandFlow.FlowReplace & SERIAL_ERROR_CHAR)) 
				{
					Status = STATUS_INVALID_PARAMETER;

					KeReleaseSpinLock(&pPort->ControlLock,OldIrql);

					break;
				}
			}

			KeSynchronizeExecution(pPort->Interrupt, SerialSetEscapeChar, Irp);
				
			KeReleaseSpinLock(&pPort->ControlLock, OldIrql);

			break;
		}

    case IOCTL_SERIAL_CONFIG_SIZE:
		{
			if(IrpSp->Parameters.DeviceIoControl.OutputBufferLength < sizeof(ULONG))
			{
				Status = STATUS_BUFFER_TOO_SMALL;
				break;
			}

			Irp->IoStatus.Information = sizeof(ULONG);
			Status = STATUS_SUCCESS;

			*(PULONG)Irp->AssociatedIrp.SystemBuffer = 0;
			break;
		}

    case IOCTL_SERIAL_GET_STATS: 
		{
			if(IrpSp->Parameters.DeviceIoControl.OutputBufferLength < sizeof(SERIALPERF_STATS))
			{
				Status = STATUS_BUFFER_TOO_SMALL;
				break;
			}

			Irp->IoStatus.Information = sizeof(SERIALPERF_STATS);
			Status = STATUS_SUCCESS;

			KeSynchronizeExecution(pPort->Interrupt, SerialGetStats, Irp);
			break;
		}

    case IOCTL_SERIAL_CLEAR_STATS: 
		{
			KeSynchronizeExecution(pPort->Interrupt, SerialClearStats, pPort);
			break;
		}

    default: 
		{

			Status = STATUS_INVALID_PARAMETER;
			break;
		}
    }

DoneWithIoctl:;

    Irp->IoStatus.Status = Status;

    SerialDump(SERIRPPATH, ("Complete Irp: %x\n",Irp));
	SpxIRPCounter(pPort, Irp, IRP_COMPLETED);	// Increment counter for performance stats.
    IoCompleteRequest(Irp, 0);

    return Status;

}



VOID
SerialGetProperties(IN PPORT_DEVICE_EXTENSION pPort, IN PSERIAL_COMMPROP Properties)
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

    This function returns the capabilities of this particular
    serial device.

Arguments:

    Extension - The serial device extension.

    Properties - The structure used to return the properties

Return Value:

    None.

-----------------------------------------------------------------------------*/
{

    RtlZeroMemory(Properties, sizeof(SERIAL_COMMPROP));

    Properties->PacketLength = sizeof(SERIAL_COMMPROP);
    Properties->PacketVersion = 2;
    Properties->ServiceMask = SERIAL_SP_SERIALCOMM;
    Properties->MaxTxQueue = 0;
    Properties->MaxRxQueue = 0;

    Properties->MaxBaud = SERIAL_BAUD_USER;
    Properties->SettableBaud = pPort->SupportedBauds;

    Properties->ProvSubType = SERIAL_SP_RS232;

    Properties->ProvCapabilities = SERIAL_PCF_DTRDSR		|
                                   SERIAL_PCF_RTSCTS		|
                                   SERIAL_PCF_CD			|
                                   SERIAL_PCF_PARITY_CHECK	|
                                   SERIAL_PCF_XONXOFF		|
                                   SERIAL_PCF_SETXCHAR		|
                                   SERIAL_PCF_TOTALTIMEOUTS |
                                   SERIAL_PCF_INTTIMEOUTS	|
								   SERIAL_PCF_SPECIALCHARS;

    Properties->SettableParams = SERIAL_SP_PARITY		|
                                 SERIAL_SP_BAUD			|
                                 SERIAL_SP_DATABITS		|
                                 SERIAL_SP_STOPBITS		|
                                 SERIAL_SP_HANDSHAKING	|
                                 SERIAL_SP_PARITY_CHECK |
                                 SERIAL_SP_CARRIER_DETECT;


    Properties->SettableData = SERIAL_DATABITS_5 |
                               SERIAL_DATABITS_6 |
                               SERIAL_DATABITS_7 |
                               SERIAL_DATABITS_8;

    Properties->SettableStopParity = SERIAL_STOPBITS_10 |
                                     SERIAL_STOPBITS_15 |
                                     SERIAL_STOPBITS_20 |
                                     SERIAL_PARITY_NONE |
                                     SERIAL_PARITY_ODD  |
                                     SERIAL_PARITY_EVEN |
                                     SERIAL_PARITY_MARK |
                                     SERIAL_PARITY_SPACE;
    Properties->CurrentTxQueue = 0;
    Properties->CurrentRxQueue = pPort->BufferSize;

}




// Set Fast 16 and Fast 16 FMC cards to delay UART interrupts by 1.1 ms
// to improve performance when more than 50% of the ports are in full use.
// This is the default option.
BOOLEAN SetCardToDelayInterrupt(PCARD_DEVICE_EXTENSION pCard)
{
	if((pCard->CardType == Fast16_Pci) || pCard->CardType == Fast16FMC_Pci)
	{	
		/* NOTE: If bit 7 of the PLX9050 config space physical address is set in either I/O Space or Memory... 
		* ...then reads from the registers will only return 0.  However, writes are OK. */
		if(READ_REGISTER_UCHAR(pCard->LocalConfigRegisters + PLX9050_INT_CNTRL_REG_OFFSET) == 0)
		{
			// We have to blindly write the value to the register.
			WRITE_REGISTER_UCHAR((pCard->LocalConfigRegisters + PLX9050_INT_CNTRL_REG_OFFSET), 0x59);
		}
		else
		{
			// Read Register Value and set bit 2 to enable RTS on Fast 16 PCI card.
			UCHAR Val = READ_REGISTER_UCHAR(pCard->LocalConfigRegisters + PLX9050_INT_CNTRL_REG_OFFSET) | 0x8;

			// Write the new value back to the register.
			WRITE_REGISTER_UCHAR((pCard->LocalConfigRegisters + PLX9050_INT_CNTRL_REG_OFFSET), Val);
		}

		return TRUE;
	}


	return FALSE;
}


// Set Fast 16 and Fast 16 FMC cards not to delay UART interrupts by 1.1 ms.
BOOLEAN SetCardNotToDelayInterrupt(PCARD_DEVICE_EXTENSION pCard)
{
	if((pCard->CardType == Fast16_Pci) || pCard->CardType == Fast16FMC_Pci)
	{	
		/* NOTE: If bit 7 of the PLX9050 config space physical address is set in either I/O Space or Memory... 
		* ...then reads from the registers will only return 0.  However, writes are OK. */
		if(READ_REGISTER_UCHAR(pCard->LocalConfigRegisters + PLX9050_INT_CNTRL_REG_OFFSET) == 0)
		{
			// We have to blindly write the value to the register.
			WRITE_REGISTER_UCHAR((pCard->LocalConfigRegisters + PLX9050_INT_CNTRL_REG_OFFSET), 0x51);
		}
		else
		{
			// Read Register Value and set bit 2 to enable RTS on Fast 16 PCI card.
			UCHAR Val = READ_REGISTER_UCHAR(pCard->LocalConfigRegisters + PLX9050_INT_CNTRL_REG_OFFSET) & ~0x8;

			// Write the new value back to the register.
			WRITE_REGISTER_UCHAR((pCard->LocalConfigRegisters + PLX9050_INT_CNTRL_REG_OFFSET), Val);
		}

		return TRUE;
	}

	return FALSE;
}




// Sets card not to use DTR instead of RTS on Fast 16 PCI cards only.
// This is the default option.
BOOLEAN SetCardNotToUseDTRInsteadOfRTS(PCARD_DEVICE_EXTENSION pCard)
{
	if(pCard->CardType == Fast16_Pci)
	{	
		/* NOTE: If bit 7 of the PLX9050 config space physical address is set in either I/O Space or Memory... 
		* ...then reads from the registers will only return 0.  However, writes are OK. */
		if(READ_REGISTER_UCHAR(pCard->LocalConfigRegisters + PLX9050_CNTRL_REG_OFFSET) == 0)
		{
			// We have to blindly write the value to the register.
			WRITE_REGISTER_UCHAR((pCard->LocalConfigRegisters + PLX9050_CNTRL_REG_OFFSET), 0x56);
		}
		else
		{
			// Read Register Value and set bit 2 to enable RTS on Fast 16 PCI card.
			UCHAR Val = READ_REGISTER_UCHAR(pCard->LocalConfigRegisters + PLX9050_CNTRL_REG_OFFSET) | 0x4;

			// Write the new value back to the register.
			WRITE_REGISTER_UCHAR((pCard->LocalConfigRegisters + PLX9050_CNTRL_REG_OFFSET), Val);
		}

		return TRUE;
	}


	return FALSE;
}


// Sets card to use DTR instead of RTS on Fast 16 PCI cards only.
BOOLEAN SetCardToUseDTRInsteadOfRTS(PCARD_DEVICE_EXTENSION pCard)
{
	if(pCard->CardType == Fast16_Pci)
	{	
		/* NOTE: If bit 7 of the PLX9050 config space physical address is set in either I/O Space or Memory... 
		* ...then reads from the registers will only return 0.  However, writes are OK. */
		if(READ_REGISTER_UCHAR(pCard->LocalConfigRegisters + PLX9050_CNTRL_REG_OFFSET) == 0)
		{
			// We have to blindly write the value to the register.
			WRITE_REGISTER_UCHAR((pCard->LocalConfigRegisters + PLX9050_CNTRL_REG_OFFSET), 0x52);
		}
		else
		{
			// Read Register Value and clear bit 2 to enable DTR on Fast 16 PCI card.
			UCHAR Val = READ_REGISTER_UCHAR(pCard->LocalConfigRegisters + PLX9050_CNTRL_REG_OFFSET) & ~0x4;

			// Write the new value back to the register.
			WRITE_REGISTER_UCHAR((pCard->LocalConfigRegisters + PLX9050_CNTRL_REG_OFFSET), Val);
		}

		return TRUE;
	}

	return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\spx\speed\driver\openclos.c ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) 1991, 1992, 1993 Microsoft Corporation

Module Name:

    openclos.c

Abstract:

    This module contains the code that is very specific to
    opening, closing, and cleaning up in the serial driver.

Author:

    Anthony V. Ercolano 26-Sep-1991

Environment:

    Kernel mode

Revision History :

-----------------------------------------------------------------------------*/

#include "precomp.h"


BOOLEAN SerialMarkOpen(IN PVOID Context);
BOOLEAN SerialNullSynch(IN PVOID Context);
BOOLEAN GetFifoStatus(IN PVOID Context);


#ifdef ALLOC_PRAGMA
#endif

typedef struct _SERIAL_CHECK_OPEN
{
    PPORT_DEVICE_EXTENSION pPort;
    NTSTATUS *StatusOfOpen;

} SERIAL_CHECK_OPEN,*PSERIAL_CHECK_OPEN;


typedef struct _FIFO_STATUS
{
    PPORT_DEVICE_EXTENSION pPort;
    ULONG	BytesInTxFIFO;
    ULONG	BytesInRxFIFO;

} FIFO_STATUS,*PFIFO_STATUS;



// Just a bogus little routine to make sure that we can synch with the ISR.
BOOLEAN
SerialNullSynch(IN PVOID Context)
{
    UNREFERENCED_PARAMETER(Context);
    return FALSE;
}



NTSTATUS
SerialCreateOpen(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp)
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

    We connect up to the interrupt for the create/open and initialize
    the structures needed to maintain an open for a device.

Arguments:

    DeviceObject - Pointer to the device object for this device

    Irp - Pointer to the IRP for the current request

Return Value:

    The function value is the final status of the call

-----------------------------------------------------------------------------*/
{
    PPORT_DEVICE_EXTENSION pPort = DeviceObject->DeviceExtension;
    SERIAL_CHECK_OPEN checkOpen;
    NTSTATUS status;

    SerialDump(SERIRPPATH, ("Dispatch entry for: %x\n", Irp));
    SerialDump(SERDIAG3, ("In SerialCreateOpen\n"));
	SpxIRPCounter(pPort, Irp, IRP_SUBMITTED);	// Increment counter for performance stats.

    // Before we do anything, let's make sure they aren't trying
    // to create a directory.  This is a silly, but what's a driver to do!?

    if(IoGetCurrentIrpStackLocation(Irp)->Parameters.Create.Options & FILE_DIRECTORY_FILE)
	{
        Irp->IoStatus.Status = STATUS_NOT_A_DIRECTORY;
        Irp->IoStatus.Information = 0;

        SerialDump(SERIRPPATH, ("Complete Irp: %x\n",Irp));
		SpxIRPCounter(pPort, Irp, IRP_COMPLETED);	// Increment counter for performance stats.
        IoCompleteRequest(Irp, IO_NO_INCREMENT);

        return STATUS_NOT_A_DIRECTORY;
    }

	// Do not allow any software to open the card object.
	if(DeviceObject->DeviceType != FILE_DEVICE_SERIAL_PORT)
	{
	    Irp->IoStatus.Status = STATUS_ACCESS_DENIED;
        Irp->IoStatus.Information = 0;
		SpxIRPCounter(pPort, Irp, IRP_COMPLETED);	// Increment counter for performance stats.
        IoCompleteRequest(Irp, IO_NO_INCREMENT);

		return(STATUS_ACCESS_DENIED);
	}

  	if(pPort->DeviceIsOpen)					// Is port already open? 
	{
		status = STATUS_ACCESS_DENIED;		// Yes, deny access 
		Irp->IoStatus.Status = status;
        Irp->IoStatus.Information = 0;
		SpxIRPCounter(pPort, Irp, IRP_COMPLETED);
		IoCompleteRequest(Irp,IO_NO_INCREMENT);

		return(status);
	}


    // Create a buffer for the RX data when no reads are outstanding.
    pPort->InterruptReadBuffer = NULL;
    pPort->BufferSize = 0;

    switch(MmQuerySystemSize())
	{
        case MmLargeSystem:
			pPort->BufferSize = 4096;
			break;

        case MmMediumSystem:
			pPort->BufferSize = 1024;
			break;

        case MmSmallSystem:
			pPort->BufferSize = 128;

		default:
			break;
    }


	if(pPort->BufferSize)
	{
		pPort->BufferSizes.pINBuffer = SpxAllocateMem(NonPagedPool, pPort->BufferSize);
	 	pPort->BufferSizes.INBufferSize = pPort->BufferSize;
    }
	else
	{
        pPort->BufferSize = 0;
        Irp->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;
        Irp->IoStatus.Information = 0;

        SerialDump(SERIRPPATH, ("Complete Irp: %x\n",Irp));
		SpxIRPCounter(pPort, Irp, IRP_COMPLETED);	// Increment counter for performance stats.
        IoCompleteRequest(Irp, IO_NO_INCREMENT);

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    // On a new open we "flush" the read queue by initializing the count of characters.

    pPort->CharsInInterruptBuffer = 0;

    pPort->ReadBufferBase		= pPort->InterruptReadBuffer;
    pPort->CurrentCharSlot		= pPort->InterruptReadBuffer;
    pPort->FirstReadableChar	= pPort->InterruptReadBuffer;

    pPort->TotalCharsQueued = 0;

    // We set up the default xon/xoff limits.
    pPort->HandFlow.XoffLimit = pPort->BufferSize >> 3;
    pPort->HandFlow.XonLimit = pPort->BufferSize >> 1;
    pPort->BufferSizePt8 = ((3*(pPort->BufferSize>>2)) + (pPort->BufferSize>>4));

	SpxDbgMsg(SPX_MISC_DBG,	("%s: The default interrupt read buffer size is: %d\n"
								"------  The XoffLimit is                         : %d\n"
								"------  The XonLimit is                          : %d\n"
								"------  The pt 8 size is                         : %d\n",
								PRODUCT_NAME,
								pPort->BufferSize,
								pPort->HandFlow.XoffLimit,
								pPort->HandFlow.XonLimit,
								pPort->BufferSizePt8 ));


    pPort->IrpMaskLocation = NULL;
    pPort->HistoryMask = 0;
    pPort->IsrWaitMask = 0;

    pPort->SendXonChar = FALSE;
    pPort->SendXoffChar = FALSE;


    // Clear out the statistics.
    KeSynchronizeExecution(pPort->Interrupt, SerialClearStats, pPort);

    // The escape char replacement must be reset upon every open
	pPort->EscapeChar = 0;

	GetPortSettings(pPort->DeviceObject);	// Get Saved Port Settings if present.


    // Synchronize with the ISR and let it know that the device has been successfully opened.
    KeSynchronizeExecution(pPort->Interrupt, SerialMarkOpen, pPort);

	status = STATUS_SUCCESS;

	Irp->IoStatus.Status = status;
    Irp->IoStatus.Information = 0L;

    SerialDump(SERIRPPATH, ("Complete Irp: %x\n", Irp));
	SpxIRPCounter(pPort, Irp, IRP_COMPLETED);	// Increment counter for performance stats.
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    return status;
}



NTSTATUS
SerialClose(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp)
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

    We simply disconnect the interrupt for now.

Arguments:

    DeviceObject - Pointer to the device object for this device

    Irp - Pointer to the IRP for the current request

Return Value:

    The function value is the final status of the call

-----------------------------------------------------------------------------*/
{

    // This "timer value" is used to wait 10 character times
    // after the hardware is empty before we actually "run down"
    // all of the flow control/break junk.
    LARGE_INTEGER tenCharDelay;

    LARGE_INTEGER charTime;   // Holds a character time.
	FIFO_STATUS FifoStatus;

    // Just what it says.  This is the serial specific device
    // extension of the device object create for the serial driver.
    PPORT_DEVICE_EXTENSION pPort = DeviceObject->DeviceExtension;

    SerialDump(SERIRPPATH, ("Dispatch entry for: %x\n", Irp));
    SerialDump(SERDIAG3, ("In SerialClose\n"));
	SpxIRPCounter(pPort, Irp, IRP_SUBMITTED);	// Increment counter for performance stats.


    charTime.QuadPart = -SerialGetCharTime(pPort).QuadPart;

    // Do this now so that if the isr gets called it won't do anything
    // to cause more chars to get sent.  We want to run down the hardware.
    pPort->DeviceIsOpen = FALSE;


    // Synchronize with the isr to turn off break if it is already on.
    KeSynchronizeExecution(pPort->Interrupt, SerialTurnOffBreak, pPort);


    // Wait until all characters have been emptied out of the hardware.

	FifoStatus.pPort = pPort;
	// Get the number of characters left to send in the Tx FIFO
	if(KeSynchronizeExecution(pPort->Interrupt, GetFifoStatus, &FifoStatus))
	{
		ULONG i = 0;

		// Wait the appropriate time
		for(i = 0; i<FifoStatus.BytesInTxFIFO; i++)
			KeDelayExecutionThread(KernelMode, FALSE, &charTime);
	}

    // Synchronize with the ISR to let it know that interrupts are no longer important.
    KeSynchronizeExecution(pPort->Interrupt, SerialMarkClose, pPort);


    // The hardware is empty.  Delay 10 character times before
    // shut down all the flow control.

    tenCharDelay.QuadPart = charTime.QuadPart * 10;

    KeDelayExecutionThread(KernelMode, TRUE, &tenCharDelay);

    SerialClrDTR(pPort);

    SerialClrRTS(pPort);

    // Clean out the holding reasons (since we are closed).
    pPort->RXHolding = 0;
    pPort->TXHolding = 0;

    // All is done.  The port has been disabled from interrupting
    // so there is no point in keeping the memory around.

    pPort->BufferSize = 0;

	SpxFreeMem(pPort->BufferSizes.pINBuffer);

    Irp->IoStatus.Status = STATUS_SUCCESS;
    Irp->IoStatus.Information = 0L;

    SerialDump(SERIRPPATH, ("Complete Irp: %x\n",Irp));
	SpxIRPCounter(pPort, Irp, IRP_COMPLETED);	// Increment counter for performance stats.
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    return STATUS_SUCCESS;
}




BOOLEAN
SerialMarkOpen(IN PVOID Context)
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

    This routine merely sets a boolean to true to mark the fact that
    somebody opened the device and its worthwhile to pay attention
    to interrupts.

Arguments:

    Context - Really a pointer to the device extension.

Return Value:

    This routine always returns FALSE.

-----------------------------------------------------------------------------*/
{
    PPORT_DEVICE_EXTENSION pPort = Context;

	SerialReset(pPort);

	// Set Buffer sizes.
	pPort->pUartLib->UL_BufferControl_XXXX(pPort->pUart, &pPort->BufferSizes, UL_BC_OP_SET, UL_BC_BUFFER | UL_BC_IN | UL_BC_OUT);

	// Apply settings.
	ApplyInitialPortSettings(pPort);

	// Enable interrupts.
	pPort->UartConfig.InterruptEnable = UC_IE_RX_INT | UC_IE_TX_INT | UC_IE_RX_STAT_INT | UC_IE_MODEM_STAT_INT;
	pPort->pUartLib->UL_SetConfig_XXXX(pPort->pUart, &pPort->UartConfig, UC_INT_ENABLE_MASK);


	SpxDbgMsg(SERINFO,("%s: PORT OPENED: (%.8X)\n", PRODUCT_NAME, pPort->Controller));

	pPort->DeviceIsOpen = TRUE;
    pPort->ErrorWord = 0;

#ifdef WMI_SUPPORT
	UPDATE_WMI_XMIT_THRESHOLDS(pPort->WmiCommData, pPort->HandFlow);
	pPort->WmiCommData.IsBusy = TRUE;
#endif

    return FALSE;
}



BOOLEAN
SerialMarkClose(IN PVOID Context)
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

    This routine merely sets a boolean to false to mark the fact that
    somebody closed the device and it's no longer worthwhile to pay attention
    to interrupts.

Arguments:

    Context - Really a pointer to the device extension.

Return Value:

    This routine always returns FALSE.
-----------------------------------------------------------------------------*/
{
    PPORT_DEVICE_EXTENSION pPort = Context;


	// CONCERN!!
	// We used to disable interrupts here by writing OUT2 to zero, this bit has
	// no effect on the PCI device so what happens if we get an interrupt after
	// the port has been closed?

	// Just reset the device
	SpxDbgMsg(SPX_TRACE_CALLS, ("%s: Serial Mark Close\n", PRODUCT_NAME));
   	pPort->pUartLib->UL_ResetUart_XXXX(pPort->pUart);	// Reset UART and turn off interrupts.
	ApplyInitialPortSettings(pPort);

	pPort->DeviceIsOpen = FALSE;
#ifdef WMI_SUPPORT
	pPort->WmiCommData.IsBusy	= FALSE;
#endif

	pPort->BufferSizes.pINBuffer = NULL;	// We are now finished with the IN Buffer
 	pPort->BufferSizes.INBufferSize = 0;
	pPort->pUartLib->UL_BufferControl_XXXX(pPort->pUart, &pPort->BufferSizes, UL_BC_OP_SET, UL_BC_BUFFER | UL_BC_IN);


    return FALSE;
}





NTSTATUS
SerialCleanup(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp)
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

    This function is used to kill all longstanding IO operations.

Arguments:

    DeviceObject - Pointer to the device object for this device

    Irp - Pointer to the IRP for the current request

Return Value:

    The function value is the final status of the call

-----------------------------------------------------------------------------*/
{
    PPORT_DEVICE_EXTENSION pPort = DeviceObject->DeviceExtension;
    KIRQL oldIrql;

    SerialDump(SERIRPPATH,("Dispatch entry for: %x\n", Irp));
 	SpxIRPCounter(pPort, Irp, IRP_SUBMITTED);	// Increment counter for performance stats.

    // First kill all the reads and writes.
    SerialKillAllReadsOrWrites(DeviceObject, &pPort->WriteQueue, &pPort->CurrentWriteIrp);
    SerialKillAllReadsOrWrites(DeviceObject, &pPort->ReadQueue, &pPort->CurrentReadIrp);

    // Next get rid of purges.
    SerialKillAllReadsOrWrites(DeviceObject, &pPort->PurgeQueue, &pPort->CurrentPurgeIrp);

    // Get rid of any mask operations.
    SerialKillAllReadsOrWrites(DeviceObject, &pPort->MaskQueue, &pPort->CurrentMaskIrp);

    // Now get rid a pending wait mask irp.
    IoAcquireCancelSpinLock(&oldIrql);

    if(pPort->CurrentWaitIrp)
	{
        PDRIVER_CANCEL cancelRoutine;

        cancelRoutine = pPort->CurrentWaitIrp->CancelRoutine;
        pPort->CurrentWaitIrp->Cancel = TRUE;

        if(cancelRoutine)
		{
            pPort->CurrentWaitIrp->CancelIrql = oldIrql;
            pPort->CurrentWaitIrp->CancelRoutine = NULL;

            cancelRoutine(DeviceObject, pPort->CurrentWaitIrp);
        }
    }
	else
	{
        IoReleaseCancelSpinLock(oldIrql);
    }

    Irp->IoStatus.Status = STATUS_SUCCESS;
    Irp->IoStatus.Information = 0L;

    SerialDump(SERIRPPATH,("Complete Irp: %x\n", Irp));
	SpxIRPCounter(pPort, Irp, IRP_COMPLETED);	// Increment counter for performance stats.
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    return STATUS_SUCCESS;

}



LARGE_INTEGER
SerialGetCharTime(IN PPORT_DEVICE_EXTENSION pPort)
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

    This function will return the number of 100 nanosecond intervals
    there are in one character time (based on the present form
    of flow control.

Arguments:

    Extension - Just what it says.

Return Value:

    100 nanosecond intervals in a character time.

-----------------------------------------------------------------------------*/
{
    ULONG dataSize;
    ULONG paritySize;
    ULONG stopSize;
    ULONG charTime;
    ULONG bitTime;
    LARGE_INTEGER tmp;

	switch(pPort->UartConfig.FrameConfig & UC_FCFG_DATALEN_MASK)
	{
	case UC_FCFG_DATALEN_5:
		dataSize = 5;
		break;

	case UC_FCFG_DATALEN_6:
		dataSize = 6;
		break;

	case UC_FCFG_DATALEN_7:
		dataSize = 7;
		break;

	case UC_FCFG_DATALEN_8:
		dataSize = 8;
		break;

	default:
		break;
	}

	if((pPort->UartConfig.FrameConfig & UC_FCFG_PARITY_MASK) == UC_FCFG_NO_PARITY)
		paritySize = 0;
	else
		paritySize = 1;

	if((pPort->UartConfig.FrameConfig & UC_FCFG_STOPBITS_MASK) == UC_FCFG_STOPBITS_1)
		stopSize = 1;
	else
		stopSize = 2; // Even if it is 1.5, for sanities sake were going to say 2.


    // First we calculate the number of 100 nanosecond intervals
    // are in a single bit time (Approximately).
    bitTime = (10000000 + (pPort->UartConfig.TxBaud - 1)) / pPort->UartConfig.TxBaud;
    charTime = bitTime + ((dataSize + paritySize + stopSize) * bitTime);

    tmp.QuadPart = charTime;
    return tmp;
}



BOOLEAN
GetFifoStatus(IN PVOID Context)
{
	PFIFO_STATUS pFifoStatus = Context;
    PPORT_DEVICE_EXTENSION pPort = pFifoStatus->pPort;
	GET_BUFFER_STATE GetBufferState;

	// Get the FIFO status.
	pPort->pUartLib->UL_BufferControl_XXXX(pPort->pUart, &GetBufferState, UL_BC_OP_GET, UL_BC_FIFO | UL_BC_IN | UL_BC_OUT);

	pFifoStatus->BytesInTxFIFO = GetBufferState.BytesInTxFIFO;
	pFifoStatus->BytesInRxFIFO = GetBufferState.BytesInRxFIFO;

	if(pFifoStatus->BytesInTxFIFO || pFifoStatus->BytesInRxFIFO)
		return TRUE;

	return FALSE;
}


BOOLEAN
ApplyInitialPortSettings(IN PVOID Context)
{
    PPORT_DEVICE_EXTENSION pPort = Context;
	UART_CONFIG UartConfig = {0};

	// Set FIFO Flow Control Levels
	pPort->UartConfig.LoFlowCtrlThreshold = pPort->LoFlowCtrlThreshold;
	pPort->UartConfig.HiFlowCtrlThreshold = pPort->HiFlowCtrlThreshold;

	// Apply Flow control thresholds.
	pPort->pUartLib->UL_SetConfig_XXXX(pPort->pUart, &pPort->UartConfig, UC_FC_THRESHOLD_SETTING_MASK);

	// Fill BufferSizes Struct and apply FIFO settings.
	pPort->BufferSizes.TxFIFOSize		= pPort->TxFIFOSize;
	pPort->BufferSizes.RxFIFOSize		= pPort->RxFIFOSize;
	pPort->BufferSizes.TxFIFOTrigLevel	= (BYTE)pPort->TxFIFOTrigLevel;
	pPort->BufferSizes.RxFIFOTrigLevel	= (BYTE)pPort->RxFIFOTrigLevel;

	// Set Buffer sizes and FIFO depths.
	pPort->pUartLib->UL_BufferControl_XXXX(pPort->pUart, &pPort->BufferSizes, UL_BC_OP_SET, UL_BC_FIFO | UL_BC_IN | UL_BC_OUT);

	// Just do a quick get config to see if flow threshold have 
	// changed as a result of changing the FIFO triggers.
	pPort->pUartLib->UL_GetConfig_XXXX(pPort->pUart, &UartConfig);

	// Update FIFO Flow Control Levels in port extension
	pPort->LoFlowCtrlThreshold = UartConfig.LoFlowCtrlThreshold;
	pPort->HiFlowCtrlThreshold = UartConfig.HiFlowCtrlThreshold;	

	// Set FIFO Flow Control Levels
	pPort->UartConfig.LoFlowCtrlThreshold = pPort->LoFlowCtrlThreshold;
	pPort->UartConfig.HiFlowCtrlThreshold = pPort->HiFlowCtrlThreshold;

	// Set UART up with special chars.
	pPort->UartConfig.XON = pPort->SpecialChars.XonChar;
	pPort->UartConfig.XOFF = pPort->SpecialChars.XoffChar;

	// Apply any special UART Settings and Flow control thresholds.
	pPort->pUartLib->UL_SetConfig_XXXX(pPort->pUart, &pPort->UartConfig, UC_SPECIAL_MODE_MASK | UC_SPECIAL_CHARS_MASK | UC_FC_THRESHOLD_SETTING_MASK);


    SerialSetLineControl(pPort);
	SerialSetBaud(pPort);
    SerialSetupNewHandFlow(pPort, &pPort->HandFlow);

	//SerialHandleModemUpdate(pPort, FALSE);


	
	return FALSE;
}



BOOLEAN
SerialReset(IN PVOID Context)
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

    This places the hardware in a standard configuration.

    NOTE: This assumes that it is called at interrupt level.


Arguments:

    Context - The device extension for serial device
    being managed.

Return Value:

    Always FALSE.

-----------------------------------------------------------------------------*/
{
    PPORT_DEVICE_EXTENSION pPort = Context;

	SerialDump(SERDIAG3, ("Serial Reset\n"));

   	pPort->pUartLib->UL_ResetUart_XXXX(pPort->pUart);	// Reset UART


    // Now we know that nothing could be transmitting at this point
    // so we set the HoldingEmpty indicator.

    pPort->HoldingEmpty = TRUE;

    return FALSE;
}


BOOLEAN SerialResetAndVerifyUart(PDEVICE_OBJECT pDevObj)
{
	if(pDevObj->DeviceType == FILE_DEVICE_CONTROLLER)
	{
		PCARD_DEVICE_EXTENSION pCard = (PCARD_DEVICE_EXTENSION) pDevObj->DeviceExtension;
   		
		if(pCard->UartLib.UL_VerifyUart_XXXX(pCard->pFirstUart) == UL_STATUS_SUCCESS)	// Verify UART
			return TRUE;
		else	
			return FALSE;
	}
	else if(pDevObj->DeviceType == FILE_DEVICE_SERIAL_PORT)
	{
		PPORT_DEVICE_EXTENSION pPort = (PPORT_DEVICE_EXTENSION) pDevObj->DeviceExtension;

		if(pPort->pUartLib->UL_VerifyUart_XXXX(pPort->pUart) == UL_STATUS_SUCCESS)	// Verify UART
			return TRUE;
		else	
			return FALSE;
	}

	return FALSE;	

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\spx\speed\driver\precomp.h ===
/////////////////////////////////////////////////////////////////////////////
//	Precompiled Header
/////////////////////////////////////////////////////////////////////////////

//#include <osrddk.h>
#include <ntddk.h>
#include <ntddser.h>
#include <stddef.h>
#include <stdarg.h>
#include "stdio.h"
#include "string.h"

#define WMI_SUPPORT	// Include WMI Support code
#include <wmilib.h>
#include <wmidata.h>
#include <wmistr.h>


typedef unsigned char	BYTE;	// 8-bits 
typedef unsigned short	WORD;	// 16-bits 
typedef unsigned long	DWORD;	// 32-bits
typedef unsigned char	UCHAR; 	// 8-bits 
typedef unsigned short	USHORT;	// 16-bits 
typedef unsigned long	ULONG;	// 32-bits

typedef BYTE	*PBYTE;
typedef WORD	*PWORD;
typedef DWORD	*PDWORD;
typedef UCHAR	*PUCHAR; 
typedef USHORT	*PUSHORT;
typedef ULONG	*PULONG; 



// Definitions and Macros.
#include "esils.h"		// Esils
#include "spd_ver.h"	// Dirver Version Information
#include "spx_defs.h"	// SPX Generic Definitions
#include "spd_defs.h"	// SPEED Specific Definitions
#include "speedwmi.h"	// SPEED Specific WMI Definitions	

#include "uartlib.h"
#include "lib95x.h"

//Structures  
#include "spx_card.h"	// Common Card Info
#include "spd_card.h"	// SPEED card device structure
#include "spx_misc.h"	// Misc 
#include "serialp.h"	// Serial prototypes and macros

// Common PnP function prototypes.
#include "spx.h"		// Common PnP header


// SPEED specific function prototypes
#include "spd_proto.h"	// Exportable Function Prototypes

#if defined(i386)
#include "spd_log.h"	// SPEED Specific Error Log Messages
#endif // i386
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\spx\speed\driver\spd_log.h ===
/*++

Copyright (c) 1998  Specialix International Ltd.

Abstract:

    Constant definitions for the I/O error code log values.

--*/

#ifndef IO8_LOG_H
#define IO8_LOG_H

//
//  Status values are 32 bit values layed out as follows:
//
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +---+-+-------------------------+-------------------------------+
//  |Sev|C|       Facility          |               Code            |
//  +---+-+-------------------------+-------------------------------+
//
//  where
//
//      Sev - is the severity code
//
//          00 - Success
//          01 - Informational
//          10 - Warning
//          11 - Error
//
//      C - is the Customer code flag
//
//      Facility - is the facility code
//
//      Code - is the facility's status code
//


//
//  Values are 32 bit values layed out as follows:
//
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +---+-+-+-----------------------+-------------------------------+
//  |Sev|C|R|     Facility          |               Code            |
//  +---+-+-+-----------------------+-------------------------------+
//
//  where
//
//      Sev - is the severity code
//
//          00 - Success
//          01 - Informational
//          10 - Warning
//          11 - Error
//
//      C - is the Customer code flag
//
//      R - is a reserved bit
//
//      Facility - is the facility code
//
//      Code - is the facility's status code
//
//
// Define the facility codes
//
#define FACILITY_SERIAL_ERROR_CODE       0x6
#define FACILITY_RPC_STUBS               0x3
#define FACILITY_RPC_RUNTIME             0x2
#define FACILITY_IO_ERROR_CODE           0x4


//
// Define the severity codes
//
#define STATUS_SEVERITY_WARNING          0x2
#define STATUS_SEVERITY_SUCCESS          0x0
#define STATUS_SEVERITY_INFORMATIONAL    0x1
#define STATUS_SEVERITY_ERROR            0x3


//
// MessageId: SPX_SEVERITY_SUCCESS
//
// MessageText:
//
//  %2
//
#define SPX_SEVERITY_SUCCESS             ((NTSTATUS)0x00060001L)

//
// MessageId: SPX_SEVERITY_INFORMATIONAL
//
// MessageText:
//
//  %2
//
#define SPX_SEVERITY_INFORMATIONAL       ((NTSTATUS)0x40060002L)

//
// MessageId: SPX_SEVERITY_WARNING
//
// MessageText:
//
//  %2
//
#define SPX_SEVERITY_WARNING             ((NTSTATUS)0x80060003L)

//
// MessageId: SPX_SEVERITY_ERROR
//
// MessageText:
//
//  %2
//
#define SPX_SEVERITY_ERROR               ((NTSTATUS)0xC0060004L)


#endif // End of IO8_LOG.H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\spx\speed\driver\modmflow.c ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) 1991, 1992, 1993 Microsoft Corporation

Module Name:

    modmflow.c

Abstract:

    This module contains *MOST* of the code used to manipulate
    the modem control and status registers.  The vast majority
    of the remainder of flow control is concentrated in the
    Interrupt service routine.  A very small amount resides
    in the read code that pull characters out of the interrupt
    buffer.

Author:

    Anthony V. Ercolano 26-Sep-1991

Environment:

    Kernel mode

Revision History :

-----------------------------------------------------------------------------*/

#include "precomp.h"

// Prototypes
BOOLEAN SerialDecrementRTSCounter(IN PVOID Context);
// End of prototypes.    
    

#ifdef ALLOC_PRAGMA
#endif


BOOLEAN
SerialSetDTR(IN PVOID Context)
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

    This routine which is only called at interrupt level is used
    to set the DTR in the modem control register.

Arguments:

    Context - Really a pointer to the device extension.

Return Value:

    This routine always returns FALSE.

-----------------------------------------------------------------------------*/
{
    PPORT_DEVICE_EXTENSION pPort = Context;
	DWORD ModemSignals = UL_MC_DTR;

    SpxDbgMsg(SERFLOW, ("%s: Setting DTR for port %d\n", PRODUCT_NAME, pPort->PortNumber));
	pPort->pUartLib->UL_ModemControl_XXXX(pPort->pUart, &ModemSignals, UL_MC_OP_BIT_SET);
	pPort->DTR_Set = TRUE;

    return FALSE;
}



BOOLEAN
SerialClrDTR(IN PVOID Context)
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

    This routine which is only called at interrupt level is used
    to clear the DTR in the modem control register.

Arguments:

    Context - Really a pointer to the device extension.

Return Value:

    This routine always returns FALSE.

-----------------------------------------------------------------------------*/
{
    PPORT_DEVICE_EXTENSION pPort = Context;
	DWORD ModemSignals = UL_MC_DTR;

    SpxDbgMsg(SERFLOW, ("%s: Clearing DTR for port %d\n", PRODUCT_NAME, pPort->PortNumber));
	pPort->pUartLib->UL_ModemControl_XXXX(pPort->pUart, &ModemSignals, UL_MC_OP_BIT_CLEAR);
	pPort->DTR_Set = FALSE;

    return FALSE;
}



BOOLEAN
SerialSetRTS(IN PVOID Context)
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

    This routine which is only called at interrupt level is used
    to set the RTS in the modem control register.

Arguments:

    Context - Really a pointer to the device extension.

Return Value:

    This routine always returns FALSE.

-----------------------------------------------------------------------------*/
{
    PPORT_DEVICE_EXTENSION pPort = Context;
	DWORD ModemSignals = UL_MC_RTS;

    SpxDbgMsg(SERFLOW, ("%s: Setting RTS for port %d\n", PRODUCT_NAME, pPort->PortNumber));
	pPort->pUartLib->UL_ModemControl_XXXX(pPort->pUart, &ModemSignals, UL_MC_OP_BIT_SET);
	pPort->RTS_Set = TRUE;

    return FALSE;
}



BOOLEAN
SerialClrRTS(IN PVOID Context)
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

    This routine which is only called at interrupt level is used
    to clear the RTS in the modem control register.

Arguments:

    Context - Really a pointer to the device extension.

Return Value:

    This routine always returns FALSE.

-----------------------------------------------------------------------------*/
{
    PPORT_DEVICE_EXTENSION pPort = Context;
	DWORD ModemSignals = UL_MC_RTS;

    SpxDbgMsg(SERFLOW, ("%s: Clearing RTS for port %d\n", PRODUCT_NAME, pPort->PortNumber));
	pPort->pUartLib->UL_ModemControl_XXXX(pPort->pUart, &ModemSignals, UL_MC_OP_BIT_CLEAR);
	pPort->RTS_Set = FALSE;

    return FALSE;
}



BOOLEAN
SerialSetupNewHandFlow(IN PPORT_DEVICE_EXTENSION pPort, IN PSERIAL_HANDFLOW NewHandFlow)
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

    This routine adjusts the flow control based on new control flow.

Arguments:

    Extension - A pointer to the serial device extension.

    NewHandFlow - A pointer to a serial handflow structure
                  that is to become the new setup for flow
                  control.

Return Value:

    This routine always returns FALSE.

-----------------------------------------------------------------------------*/

{

    SERIAL_HANDFLOW New = *NewHandFlow;

    // If the Extension->DeviceIsOpen is FALSE that means
    // we are entering this routine in response to an open request.
    // If that is so, then we always proceed with the work regardless
    // of whether things have changed.


	if((!pPort->DeviceIsOpen) 
		|| (pPort->HandFlow.ControlHandShake != New.ControlHandShake) 
		|| (pPort->HandFlow.FlowReplace != New.FlowReplace))
	{
		
		// First we take care of the DTR flow control.  We only do work if something has changed.
        SerialDump(SERFLOW, ("Processing DTR flow for %x\n", pPort->Controller));

		switch(New.ControlHandShake & SERIAL_DTR_MASK)
		{
		case SERIAL_DTR_HANDSHAKE:
			pPort->UartConfig.FlowControl = (pPort->UartConfig.FlowControl & ~UC_FLWC_DTR_FLOW_MASK) | UC_FLWC_DTR_HS;
			break;

		case SERIAL_DTR_CONTROL:
			pPort->UartConfig.FlowControl = (pPort->UartConfig.FlowControl & ~UC_FLWC_DTR_FLOW_MASK) | UC_FLWC_NO_DTR_FLOW;
			SerialSetDTR(pPort);
			break;

		default:
			pPort->UartConfig.FlowControl = (pPort->UartConfig.FlowControl & ~UC_FLWC_DTR_FLOW_MASK) | UC_FLWC_NO_DTR_FLOW;
			SerialClrDTR(pPort);
			break;
		}


		// Time to take care of the RTS Flow control.
        SerialDump(SERFLOW,("Processing RTS flow for %x\n", pPort->Controller));
	
		switch(New.FlowReplace & SERIAL_RTS_MASK)
		{
		case SERIAL_RTS_HANDSHAKE:
			pPort->UartConfig.FlowControl = (pPort->UartConfig.FlowControl & ~UC_FLWC_RTS_FLOW_MASK) | UC_FLWC_RTS_HS;
			break;

		case SERIAL_RTS_CONTROL:
			pPort->UartConfig.FlowControl = (pPort->UartConfig.FlowControl & ~UC_FLWC_RTS_FLOW_MASK) | UC_FLWC_NO_RTS_FLOW;
			SerialSetRTS(pPort);
			break;

		case SERIAL_TRANSMIT_TOGGLE:
			pPort->UartConfig.FlowControl = (pPort->UartConfig.FlowControl & ~UC_FLWC_RTS_FLOW_MASK) | UC_FLWC_RTS_TOGGLE;
			break;

		default:
			pPort->UartConfig.FlowControl = (pPort->UartConfig.FlowControl & ~UC_FLWC_RTS_FLOW_MASK) | UC_FLWC_NO_RTS_FLOW;
			SerialClrRTS(pPort);
			break;
		}



		if(New.ControlHandShake & SERIAL_CTS_HANDSHAKE) 
			pPort->UartConfig.FlowControl = (pPort->UartConfig.FlowControl & ~UC_FLWC_CTS_FLOW_MASK) | UC_FLWC_CTS_HS;
		else
			pPort->UartConfig.FlowControl = (pPort->UartConfig.FlowControl & ~UC_FLWC_CTS_FLOW_MASK) | UC_FLWC_NO_CTS_FLOW;
		
		if(New.ControlHandShake & SERIAL_DSR_HANDSHAKE)
			pPort->UartConfig.FlowControl = (pPort->UartConfig.FlowControl & ~UC_FLWC_DSR_FLOW_MASK) | UC_FLWC_DSR_HS;
		else
			pPort->UartConfig.FlowControl = (pPort->UartConfig.FlowControl & ~UC_FLWC_DSR_FLOW_MASK) | UC_FLWC_NO_DSR_FLOW;

	    //if(New.ControlHandShake & SERIAL_DCD_HANDSHAKE)

		if(New.FlowReplace & SERIAL_NULL_STRIPPING)
			pPort->UartConfig.SpecialMode |= UC_SM_DO_NULL_STRIPPING;
		else
			pPort->UartConfig.SpecialMode &= ~UC_SM_DO_NULL_STRIPPING;


		//
		// We now take care of automatic receive flow control.
		//

        if(New.FlowReplace & SERIAL_AUTO_RECEIVE) 
			pPort->UartConfig.FlowControl = (pPort->UartConfig.FlowControl & ~UC_FLWC_RX_XON_XOFF_FLOW_MASK) | UC_FLWC_RX_XON_XOFF_FLOW;
		else 
			pPort->UartConfig.FlowControl = (pPort->UartConfig.FlowControl & ~UC_FLWC_RX_XON_XOFF_FLOW_MASK) | UC_FLWC_RX_NO_XON_XOFF_FLOW;

		//
		// We now take care of automatic transmit flow control.
		//

        if(New.FlowReplace & SERIAL_AUTO_TRANSMIT) 
			pPort->UartConfig.FlowControl = (pPort->UartConfig.FlowControl & ~UC_FLWC_TX_XON_XOFF_FLOW_MASK) | UC_FLWC_TX_XON_XOFF_FLOW;
		else 
			pPort->UartConfig.FlowControl = (pPort->UartConfig.FlowControl & ~UC_FLWC_TX_XON_XOFF_FLOW_MASK) | UC_FLWC_TX_NO_XON_XOFF_FLOW;


		pPort->pUartLib->UL_SetConfig_XXXX(pPort->pUart, &pPort->UartConfig, UC_FLOW_CTRL_MASK | UC_SPECIAL_MODE_MASK);


	}



    //
    // At this point we can simply make sure that entire
    // handflow structure in the extension is updated.
    //

    pPort->HandFlow = New;

    return FALSE;

}

BOOLEAN
SerialSetHandFlow(IN PVOID Context)
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

    This routine is used to set the handshake and control
    flow in the device extension.

Arguments:

    Context - Pointer to a structure that contains a pointer to
              the device extension and a pointer to a handflow
              structure..

Return Value:

    This routine always returns FALSE.

-----------------------------------------------------------------------------*/
{
    PSERIAL_IOCTL_SYNC S = Context;
    PPORT_DEVICE_EXTENSION pPort = S->pPort;
    PSERIAL_HANDFLOW HandFlow = S->Data;

    SerialSetupNewHandFlow(pPort, HandFlow);

    SerialHandleModemUpdate(pPort, FALSE);

    return FALSE;
}



BOOLEAN
SerialTurnOnBreak(IN PVOID Context)
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

    This routine will turn on break in the hardware and
    record the fact the break is on, in the extension variable
    that holds reasons that transmission is stopped.

Arguments:

    Context - Really a pointer to the device extension.

Return Value:

    This routine always returns FALSE.

-----------------------------------------------------------------------------*/
{
    PPORT_DEVICE_EXTENSION pPort = Context;

    if((pPort->HandFlow.FlowReplace & SERIAL_RTS_MASK) == SERIAL_TRANSMIT_TOGGLE)
        SerialSetRTS(pPort);

	// Set break.
	pPort->UartConfig.SpecialMode |= UC_SM_TX_BREAK;
	pPort->pUartLib->UL_SetConfig_XXXX(pPort->pUart, &pPort->UartConfig, UC_SPECIAL_MODE_MASK);

    return FALSE;
}



BOOLEAN
SerialTurnOffBreak(IN PVOID Context)
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

    This routine will turn off break in the hardware and
    record the fact the break is off, in the extension variable
    that holds reasons that transmission is stopped.

Arguments:

    Context - Really a pointer to the device extension.

Return Value:

    This routine always returns FALSE.

-----------------------------------------------------------------------------*/
{
    PPORT_DEVICE_EXTENSION pPort = Context;

	// Clear break.
	pPort->UartConfig.SpecialMode &= ~UC_SM_TX_BREAK;
	pPort->pUartLib->UL_SetConfig_XXXX(pPort->pUart, &pPort->UartConfig, UC_SPECIAL_MODE_MASK);

    return FALSE;
}



BOOLEAN
SerialPretendXoff(IN PVOID Context)
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

    This routine is used to process the Ioctl that request the
    driver to act as if an Xoff was received.  Even if the
    driver does not have automatic Xoff/Xon flowcontrol - This
    will still stop the transmission.  This is the OS/2 behavior
    and is not well specified for Windows.  Therefore we adopt
    the OS/2 behavior.

    Note: If the driver does not have automatic Xoff/Xon enabled
    then the only way to restart transmission is for the
    application to request we "act" as if we saw the xon.

Arguments:

    Context - Really a pointer to the device extension.

Return Value:

    This routine always returns FALSE.

-----------------------------------------------------------------------------*/
{

    PPORT_DEVICE_EXTENSION pPort = Context;

    pPort->TXHolding |= SERIAL_TX_XOFF;

    if((pPort->HandFlow.FlowReplace & SERIAL_RTS_MASK) == SERIAL_TRANSMIT_TOGGLE) 
	{
        KeInsertQueueDpc(&pPort->StartTimerLowerRTSDpc, NULL, NULL) ? pPort->CountOfTryingToLowerRTS++ : 0;
    }

    return FALSE;
}



BOOLEAN
SerialPretendXon(IN PVOID Context)
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

    This routine is used to process the Ioctl that request the
    driver to act as if an Xon was received.

    Note: If the driver does not have automatic Xoff/Xon enabled
    then the only way to restart transmission is for the
    application to request we "act" as if we saw the xon.

Arguments:

    Context - Really a pointer to the device extension.

Return Value:

    This routine always returns FALSE.

-----------------------------------------------------------------------------*/

{
    PPORT_DEVICE_EXTENSION pPort = Context;

    if(pPort->TXHolding) 
	{
        // We actually have a good reason for testing if transmission
        // is holding instead of blindly clearing the bit.
        //
        // If transmission actually was holding and the result of
        // clearing the bit is that we should restart transmission
        // then we will poke the interrupt enable bit, which will
        // cause an actual interrupt and transmission will then
        // restart on its own.
        //
        // If transmission wasn't holding and we poked the bit
        // then we would interrupt before a character actually made
        // it out and we could end up over writing a character in
        // the transmission hardware.

        pPort->TXHolding &= ~SERIAL_TX_XOFF;

    }

    return FALSE;
}



VOID
SerialHandleReducedIntBuffer(IN PPORT_DEVICE_EXTENSION pPort)
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

    This routine is called to handle a reduction in the number
    of characters in the interrupt (typeahead) buffer.  It
    will check the current output flow control and re-enable transmission
    as needed.

    NOTE: This routine assumes that it is working at interrupt level.

Arguments:

    Extension - A pointer to the device extension.

Return Value:

    None.

-----------------------------------------------------------------------------*/
{


    //
    // If we are doing receive side flow control and we are
    // currently "holding" then because we've emptied out
    // some characters from the interrupt buffer we need to
    // see if we can "re-enable" reception.
    //

    if(pPort->RXHolding) 
	{
        if(pPort->CharsInInterruptBuffer <= (ULONG)pPort->HandFlow.XonLimit)
		{
            if(pPort->RXHolding & SERIAL_RX_DTR) 
			{
                pPort->RXHolding &= ~SERIAL_RX_DTR;
                SerialSetDTR(pPort);
            }

            if(pPort->RXHolding & SERIAL_RX_RTS) 
			{
                pPort->RXHolding &= ~SERIAL_RX_RTS;
                SerialSetRTS(pPort);
            }

            if(pPort->RXHolding & SERIAL_RX_XOFF) 
			{
                // Prod the transmit code to send xon.
                SerialProdXonXoff(pPort, TRUE);
            }

        }

    }

}



VOID
SerialProdXonXoff(IN PPORT_DEVICE_EXTENSION pPort, IN BOOLEAN SendXon)
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

    This routine will set up the SendXxxxChar variables if
    necessary and determine if we are going to be interrupting
    because of current transmission state.  It will cause an
    interrupt to occur if neccessary, to send the xon/xoff char.

    NOTE: This routine assumes that it is called at interrupt
          level.

Arguments:

    Extension - A pointer to the serial device extension.

    SendXon - If a character is to be send, this indicates whether
              it should be an Xon or an Xoff.

Return Value:

    None.

-----------------------------------------------------------------------------*/
{
    //
    // We assume that if the prodding is called more than
    // once that the last prod has set things up appropriately.
    //
    // We could get called before the character is sent out
    // because the send of the character was blocked because
    // of hardware flow control (or break).
    //


    if(SendXon) 
	{
        pPort->SendXonChar = TRUE;
        pPort->SendXoffChar = FALSE;
    } 
	else 
	{
        pPort->SendXonChar = FALSE;
		pPort->SendXoffChar = TRUE;
    }

}



ULONG
SerialHandleModemUpdate(IN PPORT_DEVICE_EXTENSION pPort, IN BOOLEAN DoingTX)
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

    This routine will be to check on the modem status, and
    handle any appropriate event notification as well as
    any flow control appropriate to modem status lines.

    NOTE: This routine assumes that it is called at interrupt
          level.

Arguments:

    Extension - A pointer to the serial device extension.

    DoingTX - This boolean is used to indicate that this call
              came from the transmit processing code.  If this
              is true then there is no need to cause a new interrupt
              since the code will be trying to send the next
              character as soon as this call finishes.

Return Value:

    This returns the old value of the modem status register
    (extended into a ULONG).

-----------------------------------------------------------------------------*/
{
    // We keep this local so that after we are done
    // examining the modem status and we've updated
    // the transmission holding value, we know whether
    // we've changed from needing to hold up transmission
    // to transmission being able to proceed.

    ULONG OldTXHolding = pPort->TXHolding;

    // Holds the value in the mode status register.
    UCHAR ModemStatus = 0;
	DWORD ModemSignals = 0;

	pPort->pUartLib->UL_ModemControl_XXXX(pPort->pUart, &ModemSignals, UL_MC_OP_STATUS);


	// Put data in 16x5x format.
	if(ModemSignals & UL_MC_DELTA_CTS)
		ModemStatus |= SERIAL_MSR_DCTS;
	
	if(ModemSignals & UL_MC_DELTA_DSR)
		ModemStatus |= SERIAL_MSR_DDSR;
	
	if(ModemSignals & UL_MC_TRAILING_RI_EDGE)
		ModemStatus |= SERIAL_MSR_TERI;

	if(ModemSignals & UL_MC_DELTA_DCD)
		ModemStatus |= SERIAL_MSR_DDCD;

	if(ModemSignals & UL_MC_CTS)
		ModemStatus |= SERIAL_MSR_CTS;
	
	if(ModemSignals & UL_MC_DSR)
		ModemStatus |= SERIAL_MSR_DSR;
	
	if(ModemSignals & UL_MC_RI)
		ModemStatus |= SERIAL_MSR_RI;

	if(ModemSignals & UL_MC_DCD)
		ModemStatus |= SERIAL_MSR_DCD;


    // If we are placing the modem status into the data stream
    // on every change, we should do it now.
    if(pPort->EscapeChar) 
	{
		// If a signal changed...
		if(ModemStatus & (SERIAL_MSR_DCTS | SERIAL_MSR_DDSR | SERIAL_MSR_TERI | SERIAL_MSR_DDCD)) 
		{
			BYTE TmpByte;

			TmpByte = pPort->EscapeChar;
			pPort->pUartLib->UL_ImmediateByte_XXXX(pPort->pUart, &TmpByte, UL_IM_OP_WRITE);

			TmpByte = SERIAL_LSRMST_MST;
			pPort->pUartLib->UL_ImmediateByte_XXXX(pPort->pUart, &TmpByte, UL_IM_OP_WRITE);

			TmpByte = ModemStatus;
			pPort->pUartLib->UL_ImmediateByte_XXXX(pPort->pUart, &TmpByte, UL_IM_OP_WRITE);
        }
    }


    // Check to see if we have a wait pending on the modem status events.  If we
    // do then we schedule a dpc to satisfy that wait.

    if(pPort->IsrWaitMask) 
	{
        if((pPort->IsrWaitMask & SERIAL_EV_CTS) && (ModemStatus & SERIAL_MSR_DCTS))
            pPort->HistoryMask |= SERIAL_EV_CTS;

        if((pPort->IsrWaitMask & SERIAL_EV_DSR) && (ModemStatus & SERIAL_MSR_DDSR))
            pPort->HistoryMask |= SERIAL_EV_DSR;

        if((pPort->IsrWaitMask & SERIAL_EV_RING) && (ModemStatus & SERIAL_MSR_TERI)) 
            pPort->HistoryMask |= SERIAL_EV_RING;

        if((pPort->IsrWaitMask & SERIAL_EV_RLSD) && (ModemStatus & SERIAL_MSR_DDCD))
            pPort->HistoryMask |= SERIAL_EV_RLSD;

        if(pPort->IrpMaskLocation && pPort->HistoryMask)
		{
            *pPort->IrpMaskLocation = pPort->HistoryMask;
            pPort->IrpMaskLocation = NULL;
            pPort->HistoryMask = 0;

            pPort->CurrentWaitIrp->IoStatus.Information = sizeof(ULONG);

 			// Mark IRP as about to complete normally to prevent cancel & timer DPCs
			// from doing so before DPC is allowed to run.
			//SERIAL_SET_REFERENCE(pPort->CurrentWaitIrp, SERIAL_REF_COMPLETING);
           
			KeInsertQueueDpc(&pPort->CommWaitDpc, NULL, NULL);
        }
    }


    return ((ULONG)ModemStatus);
}



BOOLEAN
SerialPerhapsLowerRTS(IN PVOID Context)
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

    This routine checks that the software reasons for lowering
    the RTS lines are present.  If so, it will then cause the
    line status register to be read (and any needed processing
    implied by the status register to be done), and if the
    shift register is empty it will lower the line.  If the
    shift register isn't empty, this routine will queue off
    a dpc that will start a timer, that will basically call
    us back to try again.

    NOTE: This routine assumes that it is called at interrupt
          level.

Arguments:

    Context - Really a pointer to the device extension.

Return Value:

    Always FALSE.

-----------------------------------------------------------------------------*/
{
    PPORT_DEVICE_EXTENSION pPort = Context;
    return FALSE;
}



VOID
SerialStartTimerLowerRTS(IN PKDPC Dpc, 
						 IN PVOID DeferredContext, 
						 IN PVOID SystemContext1, 
						 IN PVOID SystemContext2)
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

    This routine starts a timer that when it expires will start
    a dpc that will check if it can lower the rts line because
    there are no characters in the hardware.

Arguments:

    Dpc - Not Used.

    DeferredContext - Really points to the device extension.

    SystemContext1 - Not Used.

    SystemContext2 - Not Used.

Return Value:

    None.

-----------------------------------------------------------------------------*/
{

    PPORT_DEVICE_EXTENSION pPort = DeferredContext;
    LARGE_INTEGER CharTime;
    KIRQL OldIrql;

    UNREFERENCED_PARAMETER(Dpc);
    UNREFERENCED_PARAMETER(SystemContext1);
    UNREFERENCED_PARAMETER(SystemContext2);


    // Take out the lock to prevent the line control
    // from changing out from under us while we calculate
    // a character time.

    KeAcquireSpinLock(&pPort->ControlLock, &OldIrql);

    CharTime = SerialGetCharTime(pPort);

    KeReleaseSpinLock(&pPort->ControlLock, OldIrql);

    CharTime.QuadPart = -CharTime.QuadPart;

    if(KeSetTimer(&pPort->LowerRTSTimer, CharTime, &pPort->PerhapsLowerRTSDpc))
	{
        // The timer was already in the timer queue.  This implies
        // that one path of execution that was trying to lower
        // the RTS has "died".  Synchronize with the ISR so that
        // we can lower the count.
        KeSynchronizeExecution(pPort->Interrupt, SerialDecrementRTSCounter, pPort);
    }
}



VOID
SerialInvokePerhapsLowerRTS(IN PKDPC Dpc,
							IN PVOID DeferredContext, 
							IN PVOID SystemContext1,
							IN PVOID SystemContext2)
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

    This dpc routine exists solely to call the code that
    tests if the rts line should be lowered when TRANSMIT
    TOGGLE flow control is being used.

Arguments:

    Dpc - Not Used.

    DeferredContext - Really points to the device extension.

    SystemContext1 - Not Used.

    SystemContext2 - Not Used.

Return Value:

    None.

-----------------------------------------------------------------------------*/
{
    PPORT_DEVICE_EXTENSION pPort = DeferredContext;

    UNREFERENCED_PARAMETER(Dpc);
    UNREFERENCED_PARAMETER(SystemContext1);
    UNREFERENCED_PARAMETER(SystemContext2);

    KeSynchronizeExecution(pPort->Interrupt, SerialPerhapsLowerRTS, pPort);
}



BOOLEAN
SerialDecrementRTSCounter(IN PVOID Context)
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

    This routine checks that the software reasons for lowering
    the RTS lines are present.  If so, it will then cause the
    line status register to be read (and any needed processing
    implied by the status register to be done), and if the
    shift register is empty it will lower the line.  If the
    shift register isn't empty, this routine will queue off
    a dpc that will start a timer, that will basically call
    us back to try again.

    NOTE: This routine assumes that it is called at interrupt
          level.

Arguments:

    Context - Really a pointer to the device extension.

Return Value:

    Always FALSE.

-----------------------------------------------------------------------------*/
{
    PPORT_DEVICE_EXTENSION pPort = Context;
    
	pPort->CountOfTryingToLowerRTS--;

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\spx\speed\driver\purge.c ===
/*++

Copyright (c) 1991, 1992, 1993 Microsoft Corporation

Module Name:

    purge.c

Abstract:

    This module contains the code that is very specific to purge
    operations in the serial driver

Author:

    Anthony V. Ercolano 26-Sep-1991

Environment:

    Kernel mode

Revision History :

--*/

#include "precomp.h"

#ifdef ALLOC_PRAGMA
#endif


NTSTATUS
SerialStartPurge(IN PPORT_DEVICE_EXTENSION pPort)
/*++

Routine Description:

    Depending on the mask in the current irp, purge the interrupt
    buffer, the read queue, or the write queue, or all of the above.

Arguments:

    Extension - Pointer to the device extension.

Return Value:

    Will return STATUS_SUCCESS always.  This is reasonable
    since the DPC completion code that calls this routine doesn't
    care and the purge request always goes through to completion
    once it's started.

--*/
{

    PIRP NewIrp;

    do 
	{
        ULONG Mask;

        Mask = *((ULONG *)(pPort->CurrentPurgeIrp->AssociatedIrp.SystemBuffer));
                 

        if(Mask & SERIAL_PURGE_TXABORT) 
		{
            SerialKillAllReadsOrWrites(pPort->DeviceObject, &pPort->WriteQueue, &pPort->CurrentWriteIrp);

            SerialKillAllReadsOrWrites(pPort->DeviceObject, &pPort->WriteQueue, &pPort->CurrentXoffIrp);
        }


        if(Mask & SERIAL_PURGE_RXABORT) 
            SerialKillAllReadsOrWrites(pPort->DeviceObject, &pPort->ReadQueue, &pPort->CurrentReadIrp);


        if(Mask & SERIAL_PURGE_RXCLEAR) 
		{
            KIRQL OldIrql;

            // Clean out the interrupt buffer.
            //
            // Note that we do this under protection of the
            // the drivers control lock so that we don't hose
            // the pointers if there is currently a read that
            // is reading out of the buffer.

            KeAcquireSpinLock(&pPort->ControlLock, &OldIrql);
                
            KeSynchronizeExecution(pPort->Interrupt, SerialPurgeInterruptBuff, pPort);

            KeReleaseSpinLock(&pPort->ControlLock, OldIrql);
        }

        pPort->CurrentPurgeIrp->IoStatus.Status = STATUS_SUCCESS;
        pPort->CurrentPurgeIrp->IoStatus.Information = 0;

        SerialGetNextIrp(pPort, &pPort->CurrentPurgeIrp, &pPort->PurgeQueue, &NewIrp, TRUE);

    } while (NewIrp);

    return STATUS_SUCCESS;
}


BOOLEAN
SerialPurgeInterruptBuff(IN PVOID Context)
/*++

Routine Description:

    This routine simply resets the interrupt (typeahead) buffer.

    NOTE: This routine is being called from KeSynchronizeExecution.

Arguments:

    Context - Really a pointer to the device extension.

Return Value:

    Always false.

--*/
{

    PPORT_DEVICE_EXTENSION pPort = Context;

	// Flush the IN buffer	
	pPort->pUartLib->UL_BufferControl_XXXX(pPort->pUart, NULL, UL_BC_OP_FLUSH, UL_BC_BUFFER | UL_BC_IN);

    SerialHandleReducedIntBuffer(pPort);

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\spx\speed\driver\qsfile.c ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) 1991, 1992, 1993 Microsoft Corporation

Module Name:

    qsfile.c

Abstract:

    This module contains the code that is very specific to query/set file
    operations in the serial driver.

Author:

    Anthony V. Ercolano 26-Sep-1991

Environment:

    Kernel mode

Revision History :

-----------------------------------------------------------------------------*/

#include "precomp.h"

#ifdef ALLOC_PRAGMA
#endif


NTSTATUS
SerialQueryInformationFile(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp)
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

    This routine is used to query the end of file information on
    the opened serial port.  Any other file information request
    is retured with an invalid parameter.

    This routine always returns an end of file of 0.

Arguments:

    DeviceObject - Pointer to the device object for this device

    Irp - Pointer to the IRP for the current request

Return Value:

    The function value is the final status of the call

-----------------------------------------------------------------------------*/

{
    NTSTATUS Status;	// The status that gets returned to the caller and set in the Irp.

    // The current stack location.  This contains all of the
    // information we need to process this particular request.
    PIO_STACK_LOCATION IrpSp;
    PPORT_DEVICE_EXTENSION pPort = DeviceObject->DeviceExtension;


    SerialDump(SERIRPPATH,("Dispatch entry for: %x\n", Irp));
	SpxIRPCounter(pPort, Irp, IRP_SUBMITTED);	// Increment counter for performance stats.
        
    if(SerialCompleteIfError(DeviceObject, Irp) != STATUS_SUCCESS)
        return STATUS_CANCELLED;


    IrpSp = IoGetCurrentIrpStackLocation(Irp);
    Irp->IoStatus.Information = 0L;
    Status = STATUS_SUCCESS;

    if(IrpSp->Parameters.QueryFile.FileInformationClass == FileStandardInformation) 
	{
        PFILE_STANDARD_INFORMATION Buf = Irp->AssociatedIrp.SystemBuffer;

        Buf->AllocationSize.QuadPart = 0;
        Buf->EndOfFile = Buf->AllocationSize;
        Buf->NumberOfLinks = 0;
        Buf->DeletePending = FALSE;
        Buf->Directory = FALSE;
        Irp->IoStatus.Information = sizeof(FILE_STANDARD_INFORMATION);

    } 
	else if (IrpSp->Parameters.QueryFile.FileInformationClass == FilePositionInformation)
	{
        ((PFILE_POSITION_INFORMATION)Irp->AssociatedIrp.SystemBuffer)->CurrentByteOffset.QuadPart = 0;
           
        Irp->IoStatus.Information = sizeof(FILE_POSITION_INFORMATION);

    } 
	else 
	{
        Status = STATUS_INVALID_PARAMETER;
    }

	Irp->IoStatus.Status = Status;

    SerialDump(SERIRPPATH, ("Complete Irp: %x\n", Irp));
	SpxIRPCounter(pPort, Irp, IRP_COMPLETED);	// Increment counter for performance stats.
    IoCompleteRequest(Irp, 0);

    return Status;

}

NTSTATUS
SerialSetInformationFile(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp)
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

    This routine is used to set the end of file information on
    the opened parallel port.  Any other file information request
    is retured with an invalid parameter.

    This routine always ignores the actual end of file since
    the query information code always returns an end of file of 0.

Arguments:

    DeviceObject - Pointer to the device object for this device

    Irp - Pointer to the IRP for the current request

Return Value:

The function value is the final status of the call

-----------------------------------------------------------------------------*/

{
    //
    // The status that gets returned to the caller and
    // set in the Irp.
    //
    NTSTATUS Status;
    PPORT_DEVICE_EXTENSION pPort = DeviceObject->DeviceExtension;


    SerialDump(SERIRPPATH, ("Dispatch entry for: %x\n", Irp));
 	SpxIRPCounter(pPort, Irp, IRP_SUBMITTED);	// Increment counter for performance stats.
       
        
    if(SerialCompleteIfError(DeviceObject,Irp) != STATUS_SUCCESS) 
        return STATUS_CANCELLED;

    Irp->IoStatus.Information = 0L;
    
	if((IoGetCurrentIrpStackLocation(Irp)->Parameters.SetFile.FileInformationClass == FileEndOfFileInformation)
		|| (IoGetCurrentIrpStackLocation(Irp)->Parameters.SetFile.FileInformationClass == FileAllocationInformation))
	{
        Status = STATUS_SUCCESS;
    } 
	else 
	{
        Status = STATUS_INVALID_PARAMETER;
    }

    Irp->IoStatus.Status = Status;

    SerialDump(SERIRPPATH,("Complete Irp: %x\n", Irp));
	SpxIRPCounter(pPort, Irp, IRP_COMPLETED);	// Increment counter for performance stats.
    IoCompleteRequest(Irp, 0);

    return Status;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\spx\speed\driver\spd_cwmi.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    wmi.c

Abstract:

    This module contains the code that handles the wmi IRPs for the
    serial driver.

Environment:

    Kernel mode

Revision History :
--*/

#include "precomp.h"


// Prototypes


// -- CARD WMI Routines -- 
NTSTATUS
SpeedCard_WmiQueryRegInfo(IN PDEVICE_OBJECT pDevObject, OUT PULONG pRegFlags,
						  OUT PUNICODE_STRING pInstanceName,
						  OUT PUNICODE_STRING *pRegistryPath,
						  OUT PUNICODE_STRING pMofResourceName,
						  OUT PDEVICE_OBJECT *pPdo);
NTSTATUS
SpeedCard_WmiQueryDataBlock(IN PDEVICE_OBJECT pDevObject, IN PIRP pIrp,
							IN ULONG GuidIndex, IN ULONG InstanceIndex,
							IN ULONG InstanceCount, IN OUT PULONG pInstanceLengthArray,
							IN ULONG OutBufferSize, OUT PUCHAR pBuffer);
NTSTATUS
SpeedCard_WmiSetDataBlock(IN PDEVICE_OBJECT pDevObject, IN PIRP pIrp,
						  IN ULONG GuidIndex, IN ULONG InstanceIndex,
						  IN ULONG BufferSize, IN PUCHAR pBuffer);

NTSTATUS
SpeedCard_WmiSetDataItem(IN PDEVICE_OBJECT pDevObject, IN PIRP pIrp,
						 IN ULONG GuidIndex, IN ULONG InstanceIndex,
						 IN ULONG DataItemId, IN ULONG BufferSize,
						 IN PUCHAR pBuffer);

// End of prototypes.


#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, SpeedCard_WmiInitializeWmilibContext)
#pragma alloc_text(PAGE, SpeedCard_WmiQueryRegInfo)
#pragma alloc_text(PAGE, SpeedCard_WmiQueryDataBlock)
#pragma alloc_text(PAGE, SpeedCard_WmiSetDataBlock)
#pragma alloc_text(PAGE, SpeedCard_WmiSetDataItem)
#endif






#define WMI_FAST_CARD_PROP			0

GUID FastCardWmiPropGuid				= SPX_SPEED_WMI_FAST_CARD_PROP_GUID;	// Fast Card Properties 


WMIGUIDREGINFO SpeedCard_WmiGuidList[] =
{
    { &FastCardWmiPropGuid, 1, 0 },
};


#define SpeedCard_WmiGuidCount (sizeof(SpeedCard_WmiGuidList) / sizeof(WMIGUIDREGINFO))




NTSTATUS
SpeedCard_WmiInitializeWmilibContext(IN PWMILIB_CONTEXT WmilibContext)
/*++

Routine Description:

    This routine will initialize the wmilib context structure with the
    guid list and the pointers to the wmilib callback functions. This routine
    should be called before calling IoWmiRegistrationControl to register
    your device object.

Arguments:

    WmilibContext is pointer to the wmilib context.

Return Value:

    status

--*/
{
	PAGED_CODE();

    RtlZeroMemory(WmilibContext, sizeof(WMILIB_CONTEXT));
  
    WmilibContext->GuidCount			= SpeedCard_WmiGuidCount;
    WmilibContext->GuidList				= SpeedCard_WmiGuidList;    
    
    WmilibContext->QueryWmiRegInfo		= SpeedCard_WmiQueryRegInfo;
    WmilibContext->QueryWmiDataBlock	= SpeedCard_WmiQueryDataBlock;
    WmilibContext->SetWmiDataBlock		= SpeedCard_WmiSetDataBlock;
    WmilibContext->SetWmiDataItem		= SpeedCard_WmiSetDataItem;
	WmilibContext->ExecuteWmiMethod		= NULL;	//SpeedCard_WmiExecuteMethod
    WmilibContext->WmiFunctionControl	= NULL;	//SpeedCard_WmiFunctionControl;

    return(STATUS_SUCCESS);
}





//
// WMI System Call back functions
//


NTSTATUS
SpeedCard_WmiQueryRegInfo(IN PDEVICE_OBJECT pDevObject, OUT PULONG pRegFlags,
						  OUT PUNICODE_STRING pInstanceName,
						  OUT PUNICODE_STRING *pRegistryPath,
						  OUT PUNICODE_STRING MofResourceName,
						  OUT PDEVICE_OBJECT *pPdo)
{
	NTSTATUS status = STATUS_SUCCESS;
	PCARD_DEVICE_EXTENSION pCard = (PCARD_DEVICE_EXTENSION)pDevObject->DeviceExtension;
   
	PAGED_CODE();

	*pRegFlags = WMIREG_FLAG_INSTANCE_PDO;
	*pRegistryPath = &SavedRegistryPath;
	*pPdo = pCard->PDO;  // Card device object's PDO.

    RtlInitUnicodeString(MofResourceName, L"MofResource");

	return(status);
}





NTSTATUS
SpeedCard_WmiQueryDataBlock(IN PDEVICE_OBJECT pDevObject, IN PIRP pIrp,
							IN ULONG GuidIndex, IN ULONG InstanceIndex,
							IN ULONG InstanceCount, IN OUT PULONG pInstanceLengthArray,
							IN ULONG OutBufferSize, OUT PUCHAR pBuffer)
{
    PCARD_DEVICE_EXTENSION pCard = (PCARD_DEVICE_EXTENSION)pDevObject->DeviceExtension;
	NTSTATUS status;
    ULONG size = 0;

    PAGED_CODE();

    switch(GuidIndex) 
	{
	case WMI_FAST_CARD_PROP:
		{
			size = sizeof(SPX_SPEED_WMI_FAST_CARD_PROP);

			if(OutBufferSize < size) 
			{
				status = STATUS_BUFFER_TOO_SMALL;
				break;
			}

			*pInstanceLengthArray = size;

			// Update items that may have changed.

			if(pCard->CardOptions & DELAY_INTERRUPT_OPTION)
				((PSPX_SPEED_WMI_FAST_CARD_PROP)pBuffer)->DelayCardIntrrupt = TRUE;
			else
				((PSPX_SPEED_WMI_FAST_CARD_PROP)pBuffer)->DelayCardIntrrupt = FALSE;

			if(pCard->CardOptions & SWAP_RTS_FOR_DTR_OPTION)
				((PSPX_SPEED_WMI_FAST_CARD_PROP)pBuffer)->SwapRTSForDTR = TRUE;
			else
				((PSPX_SPEED_WMI_FAST_CARD_PROP)pBuffer)->SwapRTSForDTR = FALSE;

			status = STATUS_SUCCESS;
			break;
		}


	default:
		status = STATUS_WMI_GUID_NOT_FOUND;
		break;

    }

    status = WmiCompleteRequest(pDevObject, pIrp, status, size, IO_NO_INCREMENT);
	
	return(status);
}







NTSTATUS
SpeedCard_WmiSetDataBlock(IN PDEVICE_OBJECT pDevObject, IN PIRP pIrp,
						IN ULONG GuidIndex, IN ULONG InstanceIndex,
						IN ULONG BufferSize, IN PUCHAR pBuffer)
{
	PCARD_DEVICE_EXTENSION pCard = (PCARD_DEVICE_EXTENSION)pDevObject->DeviceExtension;
	NTSTATUS status;
    ULONG size = 0;

	PAGED_CODE();

	switch(GuidIndex)
	{
	case WMI_FAST_CARD_PROP:
		{
			// Device stopping?, Device not powered?, Device not started?
			if(SpxCheckPnpPowerFlags((PCOMMON_OBJECT_DATA)pCard, PPF_STOP_PENDING, PPF_POWERED | PPF_STARTED, FALSE))
			{
				status = STATUS_WMI_SET_FAILURE;	
				break;
			}


			size = sizeof(SPX_SPEED_WMI_FAST_CARD_PROP);
			
			if(BufferSize < size) 
			{
				status = STATUS_BUFFER_TOO_SMALL;
				break;
			}

			// Currently these options are only settable on PCI-Fast 16 and PCI-Fast 16 FMC
			if((pCard->CardType != Fast16_Pci) && (pCard->CardType != Fast16FMC_Pci))
			{
				status = STATUS_WMI_READ_ONLY;
				break;
			}

			
			if(((PSPX_SPEED_WMI_FAST_CARD_PROP)pBuffer)->SwapRTSForDTR)
			{
				// This option is not settable on PCI-Fast 16 FMC
				if((pCard->CardType != Fast16_Pci))
				{
					status = STATUS_WMI_READ_ONLY;
					break;
				}
			}


			if(((PSPX_SPEED_WMI_FAST_CARD_PROP)pBuffer)->DelayCardIntrrupt)
			{
				if(!(pCard->CardOptions & DELAY_INTERRUPT_OPTION))	// If not already set then set the option
				{
					if(KeSynchronizeExecution(pCard->Interrupt, SetCardToDelayInterrupt, pCard))
					{
						pCard->CardOptions |= DELAY_INTERRUPT_OPTION;
					}
					else
					{
						status = STATUS_WMI_SET_FAILURE;
						break;
					}
				}
					
				status = STATUS_SUCCESS;
			}
			else
			{
				if(pCard->CardOptions & DELAY_INTERRUPT_OPTION)	// If set then unset the option.
				{
					if(KeSynchronizeExecution(pCard->Interrupt, SetCardNotToDelayInterrupt, pCard))
					{
						pCard->CardOptions &= ~DELAY_INTERRUPT_OPTION;
					}
					else
					{
						status = STATUS_WMI_SET_FAILURE;
						break;
					}
				}
						
				status = STATUS_SUCCESS;
			}


			if(((PSPX_SPEED_WMI_FAST_CARD_PROP)pBuffer)->SwapRTSForDTR)
			{
				if(!(pCard->CardOptions & SWAP_RTS_FOR_DTR_OPTION))	// If not already set then set the option
				{
					if(KeSynchronizeExecution(pCard->Interrupt, SetCardToUseDTRInsteadOfRTS, pCard))
					{
						pCard->CardOptions |= SWAP_RTS_FOR_DTR_OPTION;
					}
					else
					{
						status = STATUS_WMI_SET_FAILURE;
						break;
					}
				}
					
				status = STATUS_SUCCESS;
			}
			else
			{
				if(pCard->CardOptions & SWAP_RTS_FOR_DTR_OPTION)	// If set then unset the option.
				{
					if(KeSynchronizeExecution(pCard->Interrupt, SetCardNotToUseDTRInsteadOfRTS, pCard))
					{
						pCard->CardOptions &= ~SWAP_RTS_FOR_DTR_OPTION;
					}
					else
					{
						status = STATUS_WMI_SET_FAILURE;
						break;
					}
				}
					
				status = STATUS_SUCCESS;
			}
			
			

			if(SPX_SUCCESS(status))	// If set was successful then save setting to registry.
			{
				HANDLE PnPKeyHandle;

				// Open PnP Reg Key and save new setting to registry.
				if(SPX_SUCCESS(IoOpenDeviceRegistryKey(pCard->PDO, PLUGPLAY_REGKEY_DEVICE, STANDARD_RIGHTS_WRITE, &PnPKeyHandle)))
				{					
					ULONG TmpReg = 0;

					if(pCard->CardOptions & DELAY_INTERRUPT_OPTION)
						TmpReg = 0x1;
					else
						TmpReg = 0x0;

					Spx_PutRegistryKeyValue(	PnPKeyHandle, DELAY_INTERRUPT, wcslen(DELAY_INTERRUPT) * sizeof(WCHAR), REG_DWORD, 
												&TmpReg, sizeof(ULONG));


					if(pCard->CardOptions & SWAP_RTS_FOR_DTR_OPTION)
						TmpReg = 0x1;
					else
						TmpReg = 0x0;

					
					Spx_PutRegistryKeyValue(	PnPKeyHandle, SWAP_RTS_FOR_DTR, wcslen(SWAP_RTS_FOR_DTR) * sizeof(WCHAR), REG_DWORD, 
												&TmpReg, sizeof(ULONG));

					ZwClose(PnPKeyHandle);
				}

			}

			break;
		}

	default:
		status = STATUS_WMI_GUID_NOT_FOUND;
		break;
	}

    status = WmiCompleteRequest(pDevObject, pIrp, status, size, IO_NO_INCREMENT);
	
	return(status);
}





NTSTATUS
SpeedCard_WmiSetDataItem(IN PDEVICE_OBJECT pDevObject, IN PIRP pIrp,
					   IN ULONG GuidIndex, IN ULONG InstanceIndex,
					   IN ULONG DataItemId, IN ULONG BufferSize,
					   IN PUCHAR pBuffer)
{
    PCARD_DEVICE_EXTENSION pCard = (PCARD_DEVICE_EXTENSION)pDevObject->DeviceExtension;
	NTSTATUS status;
    ULONG size = 0;

	PAGED_CODE();

	switch(GuidIndex)
	{
	case WMI_FAST_CARD_PROP:
		{
			HANDLE	PnPKeyHandle;

			// Device stopping?, Device not powered?, Device not started?
			if(SpxCheckPnpPowerFlags((PCOMMON_OBJECT_DATA)pCard, PPF_STOP_PENDING, PPF_POWERED | PPF_STARTED, FALSE))
			{
				status = STATUS_WMI_SET_FAILURE;	
				break;
			}


			switch(DataItemId)
			{
			case SPX_SPEED_WMI_FAST_CARD_PROP_DelayCardIntrrupt_ID:
				{
					size = sizeof(SPX_SPEED_WMI_FAST_CARD_PROP_DelayCardIntrrupt_SIZE);
					
					if(BufferSize < size) 
					{
						status = STATUS_BUFFER_TOO_SMALL;
						break;
					}

					if((pCard->CardType != Fast16_Pci) && (pCard->CardType != Fast16FMC_Pci))
					{
						status = STATUS_WMI_READ_ONLY;
						break;
					}


					if(*pBuffer)
					{
						if(!(pCard->CardOptions & DELAY_INTERRUPT_OPTION))	// If not already set then set the option
						{
							if(KeSynchronizeExecution(pCard->Interrupt, SetCardToDelayInterrupt, pCard))
							{
								pCard->CardOptions |= DELAY_INTERRUPT_OPTION;
							}
							else
							{
								status = STATUS_WMI_SET_FAILURE;
								break;
							}
						}
							
						status = STATUS_SUCCESS;
					}
					else
					{
						if(pCard->CardOptions & DELAY_INTERRUPT_OPTION)	// If set then unset the option.
						{
							if(KeSynchronizeExecution(pCard->Interrupt, SetCardNotToDelayInterrupt, pCard))
							{
								pCard->CardOptions &= ~DELAY_INTERRUPT_OPTION;
							}
							else
							{
								status = STATUS_WMI_SET_FAILURE;
								break;
							}
						}
								
						status = STATUS_SUCCESS;
					}

					if(SPX_SUCCESS(status))	// If we set the option successfully then save the setting to the registry.
					{
						// Open PnP Reg Key and save new setting to registry.
						if(SPX_SUCCESS(IoOpenDeviceRegistryKey(pCard->PDO, PLUGPLAY_REGKEY_DEVICE, STANDARD_RIGHTS_WRITE, &PnPKeyHandle)))
						{
							ULONG TmpReg = 0;

							if(pCard->CardOptions & DELAY_INTERRUPT_OPTION)
								TmpReg = 0x1;
							else
								TmpReg = 0x0;

							Spx_PutRegistryKeyValue(	PnPKeyHandle, DELAY_INTERRUPT, wcslen(DELAY_INTERRUPT) * sizeof(WCHAR), REG_DWORD, 
														&TmpReg, sizeof(ULONG));

							ZwClose(PnPKeyHandle);
						}
					}


					break;
				}

			case SPX_SPEED_WMI_FAST_CARD_PROP_SwapRTSForDTR_ID:
				{
					size = sizeof(SPX_SPEED_WMI_FAST_CARD_PROP_SwapRTSForDTR_SIZE);
					
					if(BufferSize < size) 
					{
						status = STATUS_BUFFER_TOO_SMALL;
						break;
					}

					if(pCard->CardType != Fast16_Pci)
					{
						status = STATUS_WMI_READ_ONLY;
						break;
					}

					if(*pBuffer)
					{
						if(!(pCard->CardOptions & SWAP_RTS_FOR_DTR_OPTION))	// If not already set then set the option
						{
							if(KeSynchronizeExecution(pCard->Interrupt, SetCardToUseDTRInsteadOfRTS, pCard))
							{
								pCard->CardOptions |= SWAP_RTS_FOR_DTR_OPTION;
							}
							else
							{
								status = STATUS_WMI_SET_FAILURE;
								break;
							}
						}
							
						status = STATUS_SUCCESS;
					}
					else
					{
						if(pCard->CardOptions & SWAP_RTS_FOR_DTR_OPTION)	// If set then unset the option.
						{
							if(KeSynchronizeExecution(pCard->Interrupt, SetCardNotToUseDTRInsteadOfRTS, pCard))
							{
								pCard->CardOptions &= ~SWAP_RTS_FOR_DTR_OPTION;
							}
							else
							{
								status = STATUS_WMI_SET_FAILURE;
								break;
							}
						}
							
						status = STATUS_SUCCESS;
					}


					if(SPX_SUCCESS(status))	// If we set the option successfully then save the setting to the registry.
					{
						// Open PnP Reg Key and save new setting to registry.
						if(SPX_SUCCESS(IoOpenDeviceRegistryKey(pCard->PDO, PLUGPLAY_REGKEY_DEVICE, STANDARD_RIGHTS_WRITE, &PnPKeyHandle)))
						{
							ULONG TmpReg = 0;

							if(pCard->CardOptions & SWAP_RTS_FOR_DTR_OPTION)
								TmpReg = 0x1;
							else
								TmpReg = 0x0;

							Spx_PutRegistryKeyValue(	PnPKeyHandle, SWAP_RTS_FOR_DTR, wcslen(SWAP_RTS_FOR_DTR) * sizeof(WCHAR), REG_DWORD, 
														&TmpReg, sizeof(ULONG));

							ZwClose(PnPKeyHandle);
						}

					}

					break;
				}
			

			default:
				{
					status = STATUS_WMI_ITEMID_NOT_FOUND;
					break;
				}
			}

			break;
		}

	default:
		status = STATUS_WMI_GUID_NOT_FOUND;
		break;
	}

    status = WmiCompleteRequest(pDevObject, pIrp, status, size, IO_NO_INCREMENT);
	
	return(status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\spx\speed\driver\spd_powr.c ===
#include "precomp.h"

// Paging 
#pragma alloc_text (PAGE, XXX_CardPowerDown)
#pragma alloc_text (PAGE, XXX_CardPowerUp)
#pragma alloc_text (PAGE, XXX_PortQueryPowerDown)
#pragma alloc_text (PAGE, XXX_PortPowerDown)
#pragma alloc_text (PAGE, XXX_PortPowerUp)
// End paging


////////////////////////////////////////////////////////////////////////
// XXX_CardPowerDown - Restores the state of the hardware & starts card.
////////////////////////////////////////////////////////////////////////
NTSTATUS
XXX_CardPowerDown(IN PCARD_DEVICE_EXTENSION pCard)
{
	NTSTATUS status = STATUS_SUCCESS;

	// Stop Card from interrupting

	return status;
}


//////////////////////////////////////////////////////////////////////
// XXX_CardPowerUp - Saves the state of the hardware & stops card. 
//////////////////////////////////////////////////////////////////////
NTSTATUS
XXX_CardPowerUp(IN PCARD_DEVICE_EXTENSION pCard)
{
	NTSTATUS status = STATUS_SUCCESS;

	// Reset card and allow it to interrupt again.

	return status;
}



////////////////////////////////////////////////////////////////////////
// XXX_PortPowerDown - Decides whether it is safe to power down a port.
////////////////////////////////////////////////////////////////////////
NTSTATUS
XXX_PortQueryPowerDown(IN PPORT_DEVICE_EXTENSION pPort)
{
	NTSTATUS status = STATUS_SUCCESS;


	return status;
}


////////////////////////////////////////////////////////////////////////
// XXX_PortPowerDown - Restores the state of the hardware & starts port.
////////////////////////////////////////////////////////////////////////
NTSTATUS
XXX_PortPowerDown(IN PPORT_DEVICE_EXTENSION pPort)
{
	NTSTATUS status = STATUS_SUCCESS;
	DWORD ModemSignals = 0;
	PCARD_DEVICE_EXTENSION pCard	= pPort->pParentCardExt;


	if(pPort->DeviceIsOpen)			// Is the port open? 
	{
		// Stop port from interrupting 
		pPort->UartConfig.InterruptEnable = 0;
		pPort->pUartLib->UL_SetConfig_XXXX(pPort->pUart, &pPort->UartConfig, UC_INT_ENABLE_MASK);

		// Get the current modem signals... 
		pPort->pUartLib->UL_ModemControl_XXXX(pPort->pUart, &ModemSignals, UL_MC_OP_STATUS);

		// Save the current modem signals... 
		pPort->SavedModemControl = ModemSignals;
	}

#ifdef MANAGE_HARDWARE_POWER_STATES
	// Power down RS232 line drivers
	switch(pPort->PortNumber)
	{
	case 0:
		pCard->LocalConfigRegisters[0x4 + 0x1] &= 0xFC;
		break;
	case 1:
		pCard->LocalConfigRegisters[0x4 + 0x1] &= 0xF3;
		break;
	case 2:
		pCard->LocalConfigRegisters[0x4 + 0x1] &= 0xCF;
		break;
	case 3:
		pCard->LocalConfigRegisters[0x4 + 0x1] &= 0x3F;
		break;

	default:
		break;
	}

	// Power down UART.
	pPort->UartConfig.SpecialMode = pPort->UartConfig.SpecialMode |= UC_SM_LOW_POWER_MODE;
	pPort->pUartLib->UL_SetConfig_XXXX(pPort->pUart, &pPort->UartConfig, UC_SPECIAL_MODE_MASK);
#endif

	return status;
}

//////////////////////////////////////////////////////////////////////
// XXX_PortPowerUp - Saves the state of the hardware & stops port. 
//////////////////////////////////////////////////////////////////////
NTSTATUS
XXX_PortPowerUp(IN PPORT_DEVICE_EXTENSION pPort)
{
	NTSTATUS status = STATUS_SUCCESS;
	PCARD_DEVICE_EXTENSION pCard	= pPort->pParentCardExt;



#ifdef MANAGE_HARDWARE_POWER_STATES
	// Wake up the UART
	pPort->UartConfig.SpecialMode = pPort->UartConfig.SpecialMode &= ~UC_SM_LOW_POWER_MODE;
	pPort->pUartLib->UL_SetConfig_XXXX(pPort->pUart, &pPort->UartConfig, UC_SPECIAL_MODE_MASK);

	// Wake up the RS232 line drivers.
	switch(pPort->PortNumber)
	{
	case 0:
		pCard->LocalConfigRegisters[0x4 + 0x1] |= 0x3;
		break;
	case 1:
		pCard->LocalConfigRegisters[0x4 + 0x1] |= 0xC;
		break;
	case 2:
		pCard->LocalConfigRegisters[0x4 + 0x1] |= 0x30;
		break;
	case 3:
		pCard->LocalConfigRegisters[0x4 + 0x1] |= 0xC0;
		break;

	default:
		break;
	}
#endif

	SerialReset(pPort);
	ApplyInitialPortSettings(pPort);


	if(pPort->DeviceIsOpen)			// Was port open before? 
	{
		if(pPort->SavedModemControl & UL_MC_DTR)	// DTR active? 
			SerialSetDTR(pPort);	// Yes 
		else
			SerialClrDTR(pPort);	// No 


		if(pPort->SavedModemControl & UL_MC_RTS)	// RTS active? 
			SerialSetRTS(pPort);	// Yes 
		else
			SerialClrRTS(pPort);	// No 

		pPort->pUartLib->UL_SetConfig_XXXX(pPort->pUart, &pPort->UartConfig, UC_FC_THRESHOLD_SETTING_MASK);

		// Re-enable interrupts  
		pPort->UartConfig.InterruptEnable = UC_IE_RX_INT | UC_IE_TX_INT | UC_IE_RX_STAT_INT | UC_IE_MODEM_STAT_INT;
		pPort->pUartLib->UL_SetConfig_XXXX(pPort->pUart, &pPort->UartConfig, UC_INT_ENABLE_MASK);
	}
	else
	{
		SerialClrDTR(pPort);
		SerialClrRTS(pPort);	
	}


	return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\spx\speed\driver\spd_w2k.c ===
#include "precomp.h"	// Precompiled header

/****************************************************************************************
*																						*
*	Module:			SPD_W2K.C															*
*																						*
*	Creation:		14th April 1999														*
*																						*
*	Author:			Paul Smith															*
*																						*
*	Version:		1.0.0																*
*																						*
*	Description:	Functions specific to SPEED and Windows 2000						*
*																						*
****************************************************************************************/

// Paging... 
#ifdef ALLOC_PRAGMA
#pragma alloc_text (PAGE, SpxGetNtCardType)
#endif


#define FILE_ID		SPD_W2K_C		// File ID for Event Logging see SPD_DEFS.H for values.


/*****************************************************************************
****************************                      ****************************
****************************   SpxGetNtCardType   ****************************
****************************                      ****************************
******************************************************************************

prototype:		ULONG	SpxGetNtCardType(IN PDEVICE_OBJECT pDevObject)
	
description:	Return the NT defined card type for the specified card
				device object.

parameters:		pDevObject points to the NT device object for the card

returns:		NT defined card type,
				or -1 if not identified
*/

ULONG	SpxGetNtCardType(IN PDEVICE_OBJECT pDevObject)
{
	PCARD_DEVICE_EXTENSION	pCard	= pDevObject->DeviceExtension;
	ULONG					NtCardType = -1;
	PVOID					pPropertyBuffer = NULL;
	ULONG					ResultLength = 0; 
	NTSTATUS				status = STATUS_SUCCESS;
	ULONG					BufferLength = 1;	// Initial size.

	PAGED_CODE();	// Macro in checked build to assert if pagable code is run at or above dispatch IRQL 

	pPropertyBuffer = SpxAllocateMem(PagedPool, BufferLength);	// Allocate the buffer

	if(pPropertyBuffer == NULL)									// SpxAllocateMem failed.
		return -1;

	// Try to get HardwareID
	status = IoGetDeviceProperty(pCard->PDO, DevicePropertyHardwareID , BufferLength, 
									pPropertyBuffer, &ResultLength);

	if(!SPX_SUCCESS(status))					// IoGetDeviceProperty failed.
	{
		if(status == STATUS_BUFFER_TOO_SMALL)	// Buffer was too small.
		{
			ExFreePool(pPropertyBuffer);			// Free old buffer that was not big enough.
			BufferLength = ResultLength + 1;		// Set BufferLength to size required.

			pPropertyBuffer = SpxAllocateMem(PagedPool, BufferLength);	// Allocate a bigger buffer.

			if(pPropertyBuffer == NULL)			// SpxAllocateMem failed.
				return -1;

			// Try again.
			status = IoGetDeviceProperty(pCard->PDO, DevicePropertyHardwareID , BufferLength, 
											pPropertyBuffer, &ResultLength);

			if(!SPX_SUCCESS(status))			// IoGetDeviceProperty failed a second time.
			{
				ExFreePool(pPropertyBuffer);	// Free buffer.
				return -1;
			}
		}
		else
		{
			ExFreePool(pPropertyBuffer);			// Free buffer.
			return -1;
		}
	}



	// If we get to here then there is something in the PropertyBuffer.

	_wcsupr(pPropertyBuffer);		// Convert HardwareID to uppercase


	// Speed 2 adapters 
	if(wcsstr(pPropertyBuffer, SPD2_PCI_PCI954_HWID) != NULL)	// SPEED 2 Port Adapter
		NtCardType = Speed2_Pci;

	if(wcsstr(pPropertyBuffer, SPD2AND4_PCI_NO_F1_HWID) != NULL) // SPEED 2/4 Port Adapter Local Bus (unused)
		NtCardType = Speed2and4_Pci_8BitBus;
	

	if(wcsstr(pPropertyBuffer, SPD2P_PCI_PCI954_HWID) != NULL)	// SPEED+ 2 Port Adapter
		NtCardType = Speed2P_Pci;

	if(wcsstr(pPropertyBuffer, SPD2P_PCI_8BIT_LOCALBUS_HWID) != NULL)	// SPEED+ 2 Port Adapter Local bus (not used)
		NtCardType = Speed2P_Pci_8BitBus;


	// SPEED 4 adapters
	if(wcsstr(pPropertyBuffer, SPD4_PCI_PCI954_HWID) != NULL)	// SPEED 4 Port Adapter
		NtCardType = Speed4_Pci;


	if(wcsstr(pPropertyBuffer, SPD4P_PCI_PCI954_HWID) != NULL)	// SPEED+ 4 Port Adapter
		NtCardType = Speed4P_Pci;

	if(wcsstr(pPropertyBuffer, SPD4P_PCI_8BIT_LOCALBUS_HWID) != NULL)	// SPEED+ 4 Port Adapter Local bus (not used)
		NtCardType = Speed4P_Pci_8BitBus;



	// Chase Fast Cards
	if(wcsstr(pPropertyBuffer, FAST4_PCI_HWID) != NULL)		// PCI-Fast 4 Port Adapter
		NtCardType = Fast4_Pci;

	if(wcsstr(pPropertyBuffer, FAST8_PCI_HWID) != NULL)		// PCI-Fast 8 Port Adapter
		NtCardType = Fast8_Pci;

	if(wcsstr(pPropertyBuffer, FAST16_PCI_HWID) != NULL)	// PCI-Fast 16 Port Adapter
		NtCardType = Fast16_Pci;

	if(wcsstr(pPropertyBuffer, FAST16FMC_PCI_HWID) != NULL)	// PCI-Fast 16 FMC Port Adapter
		NtCardType = Fast16FMC_Pci;

	if(wcsstr(pPropertyBuffer, AT_FAST4_HWID) != NULL)		// AT-Fast 4 Port Adapter
		NtCardType = Fast4_Isa;

	if(wcsstr(pPropertyBuffer, AT_FAST8_HWID) != NULL)		// AT-Fast 8 Port Adapter
		NtCardType = Fast8_Isa;

	if(wcsstr(pPropertyBuffer, AT_FAST16_HWID) != NULL)		// AT-Fast 16 Port Adapter
		NtCardType = Fast16_Isa;

	if(wcsstr(pPropertyBuffer, RAS4_PCI_HWID) != NULL)		// PCI-RAS 4 Multi-modem Adapter
		NtCardType = RAS4_Pci;

	if(wcsstr(pPropertyBuffer, RAS8_PCI_HWID) != NULL)		// PCI-RAS 8 Multi-modem Adapter
		NtCardType = RAS8_Pci;

	ExFreePool(pPropertyBuffer);			// Free buffer.

	return(NtCardType);

} // SpxGetNtCardType 



//////////////////////////////////////////////////////////////////////////////
// SetPortFiFoSettings
//
BOOLEAN SetPortFiFoSettings(PPORT_DEVICE_EXTENSION pPort)
{
	// Store current settings.
	ULONG TxFIFOSize				= pPort->BufferSizes.TxFIFOSize; 
	ULONG TxFIFOTrigLevel			= pPort->BufferSizes.TxFIFOTrigLevel; 
	ULONG RxFIFOTrigLevel			= pPort->BufferSizes.RxFIFOTrigLevel; 
	ULONG LoFlowCtrlThreshold		= pPort->UartConfig.LoFlowCtrlThreshold; 
	ULONG HiFlowCtrlThreshold		= pPort->UartConfig.HiFlowCtrlThreshold; 
	

	// Get Tx FIFO Limit.
	if((pPort->TxFIFOSize > 0) && (pPort->TxFIFOSize <= pPort->MaxTxFIFOSize))	// Check for good value.
	{	
		pPort->BufferSizes.TxFIFOSize = pPort->TxFIFOSize;
	}
	else
		goto SetFailure;


	// Get Tx FIFO Trigger Level.
	if(pPort->TxFIFOSize <= pPort->MaxTxFIFOSize)	// Check for good value.
	{
		pPort->BufferSizes.TxFIFOTrigLevel = (BYTE) pPort->TxFIFOTrigLevel;
	}
	else
		goto SetFailure;

	// Get Rx FIFO Trigger Level.
	if(pPort->RxFIFOTrigLevel <= pPort->MaxRxFIFOSize)	// Check for good value.
	{
		pPort->BufferSizes.RxFIFOTrigLevel = (BYTE) pPort->RxFIFOTrigLevel;
	}
	else
		goto SetFailure;

	// Attempt to change FIFO settings.
	if(pPort->pUartLib->UL_BufferControl_XXXX(pPort->pUart, &pPort->BufferSizes, UL_BC_OP_SET, UL_BC_FIFO | UL_BC_IN | UL_BC_OUT) != UL_STATUS_SUCCESS)
	{
		goto SetFailure;
	}





	// Get Low Flow Control Threshold Level.
	if(pPort->LoFlowCtrlThreshold <= pPort->MaxRxFIFOSize)	// Check for good value.
	{
		pPort->UartConfig.LoFlowCtrlThreshold = (BYTE) pPort->LoFlowCtrlThreshold;
	}
	else
		goto SetFailure;

	// Get High Flow Control Threshold Level.
	if(pPort->HiFlowCtrlThreshold <= pPort->MaxRxFIFOSize)	// Check for good value.
	{
		pPort->UartConfig.HiFlowCtrlThreshold = (BYTE) pPort->HiFlowCtrlThreshold;
	}
	else
		goto SetFailure;

	// Attempt to set the configuration.
	if(pPort->pUartLib->UL_SetConfig_XXXX(pPort->pUart, &pPort->UartConfig, UC_FC_THRESHOLD_SETTING_MASK) != UL_STATUS_SUCCESS)
	{
		goto SetFailure;
	}

	// Just do a quick get config to see if flow threshold have 
	// changed as a result of changing the FIFO triggers.
	pPort->pUartLib->UL_GetConfig_XXXX(pPort->pUart, &pPort->UartConfig);

	// Update FIFO Flow Control Levels
	pPort->LoFlowCtrlThreshold = pPort->UartConfig.LoFlowCtrlThreshold;
	pPort->HiFlowCtrlThreshold = pPort->UartConfig.HiFlowCtrlThreshold;	

	return TRUE;




// Restore all settings to the way they were.
SetFailure:

	// Restore settings.
	pPort->TxFIFOSize			= TxFIFOSize; 
	pPort->TxFIFOTrigLevel		= TxFIFOTrigLevel; 
	pPort->RxFIFOTrigLevel		= RxFIFOTrigLevel; 

	pPort->BufferSizes.TxFIFOSize		= TxFIFOSize;
	pPort->BufferSizes.TxFIFOTrigLevel	= (BYTE) TxFIFOTrigLevel;
	pPort->BufferSizes.RxFIFOTrigLevel	= (BYTE) RxFIFOTrigLevel;

	pPort->pUartLib->UL_BufferControl_XXXX(pPort->pUart, &pPort->BufferSizes, UL_BC_OP_SET, UL_BC_FIFO | UL_BC_IN | UL_BC_OUT);


	// Restore settings.
	pPort->LoFlowCtrlThreshold = LoFlowCtrlThreshold; 
	pPort->HiFlowCtrlThreshold = HiFlowCtrlThreshold; 

	pPort->UartConfig.LoFlowCtrlThreshold = LoFlowCtrlThreshold; 
	pPort->UartConfig.HiFlowCtrlThreshold = HiFlowCtrlThreshold; 

	pPort->pUartLib->UL_SetConfig_XXXX(pPort->pUart, &pPort->UartConfig, UC_FC_THRESHOLD_SETTING_MASK);


	return FALSE;

}



NTSTATUS GetPortSettings(PDEVICE_OBJECT pDevObject)
{
    PPORT_DEVICE_EXTENSION pPort = (PPORT_DEVICE_EXTENSION)pDevObject->DeviceExtension;
	HANDLE	PnPKeyHandle;
	ULONG	Data = 0;


	// Open PnP Reg Key
	if(SPX_SUCCESS(IoOpenDeviceRegistryKey(pDevObject, PLUGPLAY_REGKEY_DEVICE, STANDARD_RIGHTS_READ, &PnPKeyHandle)))
	{
		if(SPX_SUCCESS(Spx_GetRegistryKeyValue(PnPKeyHandle, TX_FIFO_LIMIT, wcslen(TX_FIFO_LIMIT) * sizeof(WCHAR), &Data, sizeof(ULONG))))
		{
			if((Data > 0) && (Data <= pPort->MaxTxFIFOSize))	// Check for good value.
				pPort->TxFIFOSize = Data;
		}
											
		if(SPX_SUCCESS(Spx_GetRegistryKeyValue(PnPKeyHandle, TX_FIFO_TRIG_LEVEL, wcslen(TX_FIFO_TRIG_LEVEL) * sizeof(WCHAR), &Data, sizeof(ULONG))))
		{
			if(Data <= pPort->MaxTxFIFOSize)	// Check for good value.
				pPort->TxFIFOTrigLevel = Data;
		}

		if(SPX_SUCCESS(Spx_GetRegistryKeyValue(PnPKeyHandle, RX_FIFO_TRIG_LEVEL, wcslen(RX_FIFO_TRIG_LEVEL) * sizeof(WCHAR), &Data, sizeof(ULONG))))
		{
			if(Data <= pPort->MaxRxFIFOSize)	// Check for good value.
				pPort->RxFIFOTrigLevel = Data;
		}

		if(SPX_SUCCESS(Spx_GetRegistryKeyValue(PnPKeyHandle, LO_FLOW_CTRL_LEVEL, wcslen(LO_FLOW_CTRL_LEVEL) * sizeof(WCHAR), &Data, sizeof(ULONG))))
		{
			if(Data <= pPort->MaxRxFIFOSize)	// Check for good value.
				pPort->LoFlowCtrlThreshold = Data;
		}

		if(SPX_SUCCESS(Spx_GetRegistryKeyValue(PnPKeyHandle, HI_FLOW_CTRL_LEVEL, wcslen(HI_FLOW_CTRL_LEVEL) * sizeof(WCHAR), &Data, sizeof(ULONG))))
		{
			if(Data <= pPort->MaxRxFIFOSize)	// Check for good value.
				pPort->HiFlowCtrlThreshold = Data;
		}

		ZwClose(PnPKeyHandle);
	}



	return STATUS_SUCCESS;
}



NTSTATUS GetCardSettings(PDEVICE_OBJECT pDevObject)
{
    PCARD_DEVICE_EXTENSION pCard = (PCARD_DEVICE_EXTENSION)pDevObject->DeviceExtension;
	HANDLE	PnPKeyHandle;
	ULONG	Data = 0;

	// Open PnP Reg Key
	if(SPX_SUCCESS(IoOpenDeviceRegistryKey(pCard->PDO, PLUGPLAY_REGKEY_DEVICE, STANDARD_RIGHTS_READ, &PnPKeyHandle)))
	{

		if((pCard->CardType == Fast16_Pci) || (pCard->CardType == Fast16FMC_Pci))
		{
			if(SPX_SUCCESS(Spx_GetRegistryKeyValue(PnPKeyHandle, DELAY_INTERRUPT, wcslen(DELAY_INTERRUPT) * sizeof(WCHAR), &Data, sizeof(ULONG))))
			{
				if(Data)
				{
					if(!(pCard->CardOptions & DELAY_INTERRUPT_OPTION))	// If not already set then set the option
					{
						if(KeSynchronizeExecution(pCard->Interrupt, SetCardToDelayInterrupt, pCard))
						{
							pCard->CardOptions |= DELAY_INTERRUPT_OPTION;
						}
					}
				}
				else
				{
					if(pCard->CardOptions & DELAY_INTERRUPT_OPTION)	// If set then unset the option.
					{
						if(KeSynchronizeExecution(pCard->Interrupt, SetCardNotToDelayInterrupt, pCard))
						{
							pCard->CardOptions &= ~DELAY_INTERRUPT_OPTION;
						}
					}
							
				}
			}
		}



		if(pCard->CardType == Fast16_Pci)	
		{
			if(SPX_SUCCESS(Spx_GetRegistryKeyValue(PnPKeyHandle, SWAP_RTS_FOR_DTR, wcslen(SWAP_RTS_FOR_DTR) * sizeof(WCHAR), &Data, sizeof(ULONG))))
			{
				if(Data)
				{
					if(!(pCard->CardOptions & SWAP_RTS_FOR_DTR_OPTION))	// If not already set then set the option
					{
						if(KeSynchronizeExecution(pCard->Interrupt, SetCardToUseDTRInsteadOfRTS, pCard))
						{
							pCard->CardOptions |= SWAP_RTS_FOR_DTR_OPTION;
						}
					}
				}
				else
				{
					if(pCard->CardOptions & SWAP_RTS_FOR_DTR_OPTION)	// If set then unset the option.
					{
						if(KeSynchronizeExecution(pCard->Interrupt, SetCardNotToUseDTRInsteadOfRTS, pCard))
						{
							pCard->CardOptions &= ~SWAP_RTS_FOR_DTR_OPTION;
						}
					}
						
				}
			}
		}




		if(SPX_SUCCESS(Spx_GetRegistryKeyValue(PnPKeyHandle, CLOCK_FREQ_OVERRIDE, wcslen(CLOCK_FREQ_OVERRIDE) * sizeof(WCHAR), &Data, sizeof(ULONG))))
		{
			if(Data > 0)
				pCard->ClockRate = Data;	// Store new clock rate to use.
		}


		ZwClose(PnPKeyHandle);
	}



	return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\spx\speed\driver\spx_iioc.c ===
#include "precomp.h"	// Precompiled header

/************************************************************************/
/*																		*/
/*	Title		:	Dispatch Entry for INTERNAL IOCTLs					*/
/*																		*/
/*	Author		:	N.P.Vassallo										*/
/*																		*/
/*	Creation	:	14th October 1998									*/
/*																		*/
/*	Version		:	1.0.0												*/
/*																		*/
/*	Description	:	Internal IOCTLs support the SERENUM					*/
/*					attached serial device enumerator:					*/
/*					IOCTL_SERIAL_INTERNAL_BASIC_SETTINGS				*/
/*					IOCTL_SERIAL_INTERNAL_RESTORE_SETTINGS				*/
/*																		*/
/************************************************************************/

/* History...

1.0.0	14/20/98 NPV	Creation.

*/

#define FILE_ID	SPX_IIOC_C		// File ID for Event Logging see SPX_DEFS.H for values.



/*****************************************************************************
**********************                                 ***********************
**********************   Spx_SerialInternalIoControl   ***********************
**********************                                 ***********************
******************************************************************************
	
prototype:		NTSTATUS Spx_SerialInternalIoControl(IN PDEVICE_OBJECT pDevObj, IN PIRP pIrp)

description:	Internal IOCTL dipatch routine.
				These IOCTLs are only issued from know trusted system components such as
				the SERENUM.SYS attached serial device enumerator and the mouse driver:

parameters:		pDevObj points to the device object structure
				pIrp points to the IOCTL Irp packet

returns:		STATUS_SUCCESS

*/

NTSTATUS Spx_SerialInternalIoControl(IN PDEVICE_OBJECT pDevObj, IN PIRP pIrp)
{
	NTSTATUS				status;
	PIO_STACK_LOCATION		pIrpStack;
	PPORT_DEVICE_EXTENSION	pPort = pDevObj->DeviceExtension;
	KIRQL					OldIrql;

	SpxDbgMsg(SPX_TRACE_IRP_PATH,("%s[card=%d,port=%d]: Internal IOCTL Dispatch Entry\n",
		PRODUCT_NAME, pPort->pParentCardExt->CardNumber, pPort->PortNumber));

	if(SerialCompleteIfError(pDevObj, pIrp) != STATUS_SUCCESS)
		return(STATUS_CANCELLED);

	pIrpStack = IoGetCurrentIrpStackLocation(pIrp);
	pIrp->IoStatus.Information = 0L;
	status = STATUS_SUCCESS;

	switch(pIrpStack->Parameters.DeviceIoControl.IoControlCode)
	{
	case IOCTL_SERIAL_INTERNAL_BASIC_SETTINGS:
	case IOCTL_SERIAL_INTERNAL_RESTORE_SETTINGS:
		{
			SERIAL_BASIC_SETTINGS	Basic;
			PSERIAL_BASIC_SETTINGS	pBasic;
			SERIAL_IOCTL_SYNC	S;

			if (pIrpStack->Parameters.DeviceIoControl.IoControlCode 
				== IOCTL_SERIAL_INTERNAL_BASIC_SETTINGS)
			{
          
/* Check the buffer size... */

				if(pIrpStack->Parameters.DeviceIoControl.OutputBufferLength 
					< sizeof(SERIAL_BASIC_SETTINGS))
				{
					status = STATUS_BUFFER_TOO_SMALL;
					break;
				}

/* Everything is 0 -- timeouts and flow control. */
/* If we add additional features, this zero memory method may not work. */

				RtlZeroMemory(&Basic,sizeof(SERIAL_BASIC_SETTINGS));
				pIrp->IoStatus.Information = sizeof(SERIAL_BASIC_SETTINGS);
				pBasic = (PSERIAL_BASIC_SETTINGS)pIrp->AssociatedIrp.SystemBuffer;

/* Save off the old settings... */

				RtlCopyMemory(&pBasic->Timeouts, &pPort->Timeouts, sizeof(SERIAL_TIMEOUTS));
				RtlCopyMemory(&pBasic->HandFlow, &pPort->HandFlow, sizeof(SERIAL_HANDFLOW));

/* Point to our new settings... */

				pBasic = &Basic;
			}
			else
			{
				if(pIrpStack->Parameters.DeviceIoControl.InputBufferLength < sizeof(SERIAL_BASIC_SETTINGS))
				{
					status = STATUS_BUFFER_TOO_SMALL;
					break;
				}

				pBasic = (PSERIAL_BASIC_SETTINGS)pIrp->AssociatedIrp.SystemBuffer;
			}

			KeAcquireSpinLock(&pPort->ControlLock,&OldIrql);

/* Set the timeouts...	*/

			RtlCopyMemory(&pPort->Timeouts, &pBasic->Timeouts, sizeof(SERIAL_TIMEOUTS));

/* Set flowcontrol... */

			S.pPort = pPort;
			S.Data = &pBasic->HandFlow;
			XXX_SetHandFlow(pPort, &S);		/* Set the handflow for specific hardware */

			KeReleaseSpinLock(&pPort->ControlLock, OldIrql);
			break;
		}

	default:
		status = STATUS_INVALID_PARAMETER;
		break;
	}

	pIrp->IoStatus.Status = status;

	SpxDbgMsg(SPX_TRACE_IRP_PATH,("%s[card=%d,port=%d]: Internal IOCTL Dispatch Complete\n",
		PRODUCT_NAME, pPort->pParentCardExt->CardNumber, pPort->PortNumber));

	IoCompleteRequest(pIrp,0);

	return(status);

} /* Spx_SerialInternalIoControl */
                                                        
/* End of SPX_IIOC.C */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\spx\speed\driver\read.c ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) 1991, 1992, 1993 Microsoft Corporation

Module Name:

    read.c

Abstract:

    This module contains the code that is very specific to read
    operations in the serial driver

Author:

    Anthony V. Ercolano 26-Sep-1991

Environment:

    Kernel mode

Revision History :

-----------------------------------------------------------------------------*/

#include "precomp.h"

// Prototypes
VOID SerialCancelCurrentRead(PDEVICE_OBJECT DeviceObject, PIRP Irp);
BOOLEAN SerialGrabReadFromIsr(IN PVOID Context);
BOOLEAN SerialUpdateReadByIsr(IN PVOID Context);
BOOLEAN ReadDataFromIntBuffer(IN PVOID Context);
BOOLEAN UpdateAndWaitForMoreData(IN PVOID Context);
NTSTATUS SerialResizeBuffer(IN PPORT_DEVICE_EXTENSION pPort);
BOOLEAN SerialUpdateAndSwitchToNew(IN PVOID Context);
// End of Prototypes    
    

#ifdef ALLOC_PRAGMA
#endif


NTSTATUS
SerialRead(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp)
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

    This is the dispatch routine for reading.  It validates the parameters
    for the read request and if all is ok then it places the request
    on the work queue.

Arguments:

    DeviceObject - Pointer to the device object for this device

    Irp - Pointer to the IRP for the current request

Return Value:

    If the io is zero length then it will return STATUS_SUCCESS,
    otherwise this routine will return the status returned by
    the actual start read routine.

-----------------------------------------------------------------------------*/
{
    PPORT_DEVICE_EXTENSION pPort = DeviceObject->DeviceExtension;

	SpxDbgMsg(SPX_TRACE_CALLS,("%s: Read Irp dispatch entry for Irp: %x\n", PRODUCT_NAME, Irp));
	SpxIRPCounter(pPort, Irp, IRP_SUBMITTED);	// Increment counter for performance stats.

    if(SerialCompleteIfError(DeviceObject, Irp) != STATUS_SUCCESS)
        return STATUS_CANCELLED;

    Irp->IoStatus.Information = 0L;

    //
    // Quick check for a zero length read.  If it is zero length then we are already done!
    //
    if(IoGetCurrentIrpStackLocation(Irp)->Parameters.Read.Length) 
	{
        //
        // Well it looks like we actually have to do some work.  
        // Put the read on the queue so that we can process it when our previous reads are done.
        //
        return SerialStartOrQueue(pPort, Irp, &pPort->ReadQueue, &pPort->CurrentReadIrp, SerialStartRead);
    } 
	else 
	{
        Irp->IoStatus.Status = STATUS_SUCCESS;
		SpxDbgMsg(SPX_TRACE_CALLS,("%s: Complete Read for Irp: %x\n", PRODUCT_NAME, Irp));
       	SpxIRPCounter(pPort, Irp, IRP_COMPLETED);	// Increment counter for performance stats.
        IoCompleteRequest(Irp, 0);

        return STATUS_SUCCESS;
    }
}

NTSTATUS
SerialStartRead(IN PPORT_DEVICE_EXTENSION pPort)
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

    This routine is used to start off any read.  It initializes
    the Iostatus fields of the irp.  It will set up any timers
    that are used to control the read.  It will attempt to complete
    the read from data already in the interrupt buffer.  If the
    read can be completed quickly it will start off another if
    necessary.

Arguments:

    Extension - Simply a pointer to the serial device extension.

Return Value:

    This routine will return the status of the first read
    irp.  This is useful in that if we have a read that can
    complete right away (AND there had been nothing in the
    queue before it) the read could return SUCCESS and the
    application won't have to do a wait.

-----------------------------------------------------------------------------*/

{

    SERIAL_UPDATE_CHAR updateChar;

    PIRP newIrp;
    KIRQL oldIrql;
    KIRQL controlIrql;

    BOOLEAN returnWithWhatsPresent;
    BOOLEAN os2ssreturn;
    BOOLEAN crunchDownToOne;
    BOOLEAN useTotalTimer;
    BOOLEAN useIntervalTimer;

    ULONG multiplierVal;
    ULONG constantVal;

    LARGE_INTEGER totalTime;

    SERIAL_TIMEOUTS timeoutsForIrp;

    BOOLEAN setFirstStatus = FALSE;
    NTSTATUS firstStatus;


    updateChar.pPort = pPort;

	SpxDbgMsg(SPX_TRACE_CALLS,("SerialStartRead - Irp: %x\n", pPort->CurrentReadIrp));


    do 
	{

        //
        // Check to see if this is a resize request.  If it is then go to a routine that specializes in that.
        //
        if(IoGetCurrentIrpStackLocation(pPort->CurrentReadIrp)->MajorFunction != IRP_MJ_READ)
		{
            NTSTATUS localStatus = SerialResizeBuffer(pPort);

            if(!setFirstStatus) 
			{
                firstStatus = localStatus;
                setFirstStatus = TRUE;
            }
        } 
		else 
		{
			//
			// The irp might go under control of the isr.  
			// It won't hurt to initialize the reference count right now.
			//
			SERIAL_INIT_REFERENCE(pPort->CurrentReadIrp);

            pPort->NumberNeededForRead = IoGetCurrentIrpStackLocation(pPort->CurrentReadIrp)->Parameters.Read.Length;

            // Calculate the timeout value needed for the request.  
            // Note that the values stored in the timeout record are in milliseconds.
            useTotalTimer			= FALSE;
            returnWithWhatsPresent	= FALSE;
            os2ssreturn				= FALSE;
            crunchDownToOne			= FALSE;
            useIntervalTimer		= FALSE;


            // Always initialize the timer objects so that the completion code can tell when it 
            // attempts to cancel the timers whether the timers had ever been Set.
            KeInitializeTimer(&pPort->ReadRequestTotalTimer);
            KeInitializeTimer(&pPort->ReadRequestIntervalTimer);


            // We get the *current* timeout values to use for timing this read.
            KeAcquireSpinLock(&pPort->ControlLock, &controlIrql);
            timeoutsForIrp = pPort->Timeouts;
            KeReleaseSpinLock(&pPort->ControlLock, controlIrql);
                

            // Calculate the interval timeout for the read.
            if(timeoutsForIrp.ReadIntervalTimeout && (timeoutsForIrp.ReadIntervalTimeout != MAXULONG)) 
			{
                useIntervalTimer = TRUE;

                pPort->IntervalTime.QuadPart = UInt32x32To64(timeoutsForIrp.ReadIntervalTimeout, 10000);

                if(pPort->IntervalTime.QuadPart >= pPort->CutOverAmount.QuadPart)
                    pPort->IntervalTimeToUse = &pPort->LongIntervalAmount;
				else 
                    pPort->IntervalTimeToUse = &pPort->ShortIntervalAmount;
            }

            if(timeoutsForIrp.ReadIntervalTimeout == MAXULONG) 
			{

                //
                // We need to do special return quickly stuff here.
                //
                // 1) If both constant and multiplier are
                //    0 then we return immediately with whatever
                //    we've got, even if it was zero.
                //
                // 2) If constant and multiplier are not MAXULONG
                //    then return immediately if any characters
                //    are present, but if nothing is there, then
                //    use the timeouts as specified.
                //
                // 3) If multiplier is MAXULONG then do as in
                //    "2" but return when the first character
                //    arrives.
                //

                if(!timeoutsForIrp.ReadTotalTimeoutConstant && !timeoutsForIrp.ReadTotalTimeoutMultiplier) 
				{
                    returnWithWhatsPresent = TRUE;
                } 
				else if((timeoutsForIrp.ReadTotalTimeoutConstant != MAXULONG)
					&& (timeoutsForIrp.ReadTotalTimeoutMultiplier != MAXULONG))
				{
                    useTotalTimer = TRUE;
                    os2ssreturn = TRUE;
                    multiplierVal = timeoutsForIrp.ReadTotalTimeoutMultiplier;
                    constantVal = timeoutsForIrp.ReadTotalTimeoutConstant;

                } 
				else if((timeoutsForIrp.ReadTotalTimeoutConstant != MAXULONG)
					&& (timeoutsForIrp.ReadTotalTimeoutMultiplier == MAXULONG)) 
				{
                    useTotalTimer = TRUE;
                    os2ssreturn = TRUE;
                    crunchDownToOne = TRUE;
                    multiplierVal = 0;
                    constantVal = timeoutsForIrp.ReadTotalTimeoutConstant;
                }
            } 
			else 
			{
                //
                // If both the multiplier and the constant are
                // zero then don't do any total timeout processing.
                //

                if(timeoutsForIrp.ReadTotalTimeoutMultiplier || timeoutsForIrp.ReadTotalTimeoutConstant)
				{
                    // We have some timer values to calculate.
                    useTotalTimer = TRUE;
                    multiplierVal = timeoutsForIrp.ReadTotalTimeoutMultiplier;
                    constantVal = timeoutsForIrp.ReadTotalTimeoutConstant;
                }
            }

            if(useTotalTimer) 
			{
                totalTime.QuadPart = ((LONGLONG)(UInt32x32To64(pPort->NumberNeededForRead, multiplierVal) 
									+ constantVal)) * -10000;
            }


			//
            // If we are supposed to crunch the read down to one character, then update 
            // the number needed for read down to one.
            //

            if(crunchDownToOne) 
                pPort->NumberNeededForRead = 1;


            //
            // We do this copy in the hope of getting most (if not
            // all) of the characters out of the interrupt buffer.
            //
            // Note that we need to protect this operation with a
            // spinlock since we don't want a purge to hose us.
            //
            KeAcquireSpinLock(&pPort->ControlLock, &controlIrql);

            KeSynchronizeExecution(pPort->Interrupt, ReadDataFromIntBuffer, pPort);

            //
            // See if we have any cause to return immediately.
            //

            if(returnWithWhatsPresent || (!pPort->NumberNeededForRead) 
				|| (os2ssreturn && pPort->CurrentReadIrp->IoStatus.Information))
			{
                // We got all we needed for this read.

                KeReleaseSpinLock(&pPort->ControlLock, controlIrql);

                pPort->CurrentReadIrp->IoStatus.Status = STATUS_SUCCESS;
                
				if(!setFirstStatus) 
				{
                    firstStatus = STATUS_SUCCESS;
                    setFirstStatus = TRUE;
                }
            } 
			else 
			{

                IoAcquireCancelSpinLock(&oldIrql);

                //
                // We need to see if this irp should be canceled.
                //

                if(pPort->CurrentReadIrp->Cancel) 
				{
                    IoReleaseCancelSpinLock(oldIrql);
                    KeReleaseSpinLock(&pPort->ControlLock, controlIrql);
                        
                    pPort->CurrentReadIrp->IoStatus.Status = STATUS_CANCELLED;
                       
                    pPort->CurrentReadIrp->IoStatus.Information = 0;

                    if(!setFirstStatus) 
					{
                        firstStatus = STATUS_CANCELLED;
                        setFirstStatus = TRUE;
                    }
                } 
				else 
				{


                    //
                    // We still need to get more characters for this read.
                    // synchronize with the isr so that we can update the
                    // number of characters and if necessary it will have the
                    // isr switch to copying into the users buffer.
                    //

                    KeSynchronizeExecution(pPort->Interrupt, UpdateAndWaitForMoreData, pPort);
                        
                    //
                    // The irp still isn't complete.  The
                    // completion routines will end up reinvoking
                    // this routine.  So we simply leave.
                    //
                    // First thought we should start off the total
                    // timer for the read and increment the reference
                    // count that the total timer has on the current
                    // irp.  Note that this is safe, because even if
                    // the io has been satisfied by the isr it can't
                    // complete yet because we still own the cancel
                    // spinlock.
                    //

                    if(useTotalTimer) 
					{
                        SERIAL_SET_REFERENCE(pPort->CurrentReadIrp, SERIAL_REF_TOTAL_TIMER);

                        KeSetTimer(&pPort->ReadRequestTotalTimer, totalTime, &pPort->TotalReadTimeoutDpc);
                    }

                    if(useIntervalTimer) 
					{
                        SERIAL_SET_REFERENCE(pPort->CurrentReadIrp, SERIAL_REF_INT_TIMER);

                        KeQuerySystemTime(&pPort->LastReadTime);

                        KeSetTimer(&pPort->ReadRequestIntervalTimer,
							*pPort->IntervalTimeToUse,
							&pPort->IntervalReadTimeoutDpc);
                    }

                    IoMarkIrpPending(pPort->CurrentReadIrp);
                    IoReleaseCancelSpinLock(oldIrql);
                    KeReleaseSpinLock(&pPort->ControlLock, controlIrql);
                        
                    if(!setFirstStatus) 
                        firstStatus = STATUS_PENDING;

					if(firstStatus == STATUS_PENDING)
						SpxDbgMsg(SPX_TRACE_CALLS,("End SerialStartRead - STATUS_PENDING - Irp: %x\n", pPort->CurrentReadIrp));

					if(firstStatus == STATUS_SUCCESS)
						SpxDbgMsg(SPX_TRACE_CALLS,("End SerialStartRead - STATUS_SUCCESS - Irp: %x\n", pPort->CurrentReadIrp));
					
					if(firstStatus == STATUS_CANCELLED)
						SpxDbgMsg(SPX_TRACE_CALLS,("End SerialStartRead - STATUS_CANCELLED - Irp: %x\n", pPort->CurrentReadIrp));

                    return firstStatus;

                }

            }

        }

        //
        // Well the operation is complete.
        //

        SerialGetNextIrp(pPort, &pPort->CurrentReadIrp, &pPort->ReadQueue, &newIrp, TRUE);
            

    } while (newIrp);


	if(firstStatus == STATUS_PENDING)
		SpxDbgMsg(SPX_TRACE_CALLS,("End SerialStartRead 2 - STATUS_PENDING - Irp: %x\n", pPort->CurrentReadIrp));

	if(firstStatus == STATUS_SUCCESS)
		SpxDbgMsg(SPX_TRACE_CALLS,("End SerialStartRead 2 - STATUS_SUCCESS - Irp: %x\n", pPort->CurrentReadIrp));
	
	if(firstStatus == STATUS_CANCELLED)
		SpxDbgMsg(SPX_TRACE_CALLS,("End SerialStartRead 2 - STATUS_CANCELLED - Irp: %x\n", pPort->CurrentReadIrp));

    return firstStatus;

}

VOID
SerialCompleteRead(IN PKDPC Dpc, IN PVOID DeferredContext, IN PVOID SystemContext1, IN PVOID SystemContext2)
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

    This routine is merely used to complete any read that
    ended up being used by the Isr.  It assumes that the
    status and the information fields of the irp are already
    correctly filled in.

Arguments:

    Dpc - Not Used.

    DeferredContext - Really points to the device extension.

    SystemContext1 - Not Used.

    SystemContext2 - Not Used.

Return Value:

    None.

-----------------------------------------------------------------------------*/
{

    PPORT_DEVICE_EXTENSION pPort = DeferredContext;
    KIRQL oldIrql;

    UNREFERENCED_PARAMETER(Dpc);
    UNREFERENCED_PARAMETER(SystemContext1);
    UNREFERENCED_PARAMETER(SystemContext2);

	SpxDbgMsg(SPX_TRACE_CALLS,("SerialCompleteRead - Irp: %x\n", pPort->CurrentReadIrp));

    IoAcquireCancelSpinLock(&oldIrql);

    // We set this to indicate to the interval timer that the read has completed.
    // Recall that the interval timer dpc can be lurking in some DPC queue.
    pPort->CountOnLastRead = SERIAL_COMPLETE_READ_COMPLETE;

	// Clear the normal complete reference.
	SERIAL_CLEAR_REFERENCE(pPort->CurrentReadIrp, SERIAL_REF_COMPLETING);

	// Clear reference to ISR on completion
	SerialTryToCompleteCurrent(	pPort,
								NULL,
								oldIrql,
								STATUS_SUCCESS,
								&pPort->CurrentReadIrp,
								&pPort->ReadQueue,
								&pPort->ReadRequestIntervalTimer,
								&pPort->ReadRequestTotalTimer,
								SerialStartRead,
								SerialGetNextIrp,
								SERIAL_REF_ISR);
        
}

VOID
SerialCancelCurrentRead(PDEVICE_OBJECT DeviceObject, PIRP Irp)
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

    This routine is used to cancel the current read.

Arguments:

    DeviceObject - Pointer to the device object for this device

    Irp - Pointer to the IRP to be canceled.

Return Value:

    None.

-----------------------------------------------------------------------------*/
{
    PPORT_DEVICE_EXTENSION pPort = DeviceObject->DeviceExtension;

	SpxDbgMsg(SPX_TRACE_CALLS,("SerialCancelCurrentRead - Irp: %x\n", pPort->CurrentReadIrp));

    // We set this to indicate to the interval timer that the read has encountered a cancel.
    // Recall that the interval timer dpc can be lurking in some DPC queue.
    pPort->CountOnLastRead = SERIAL_COMPLETE_READ_CANCEL;

    SerialTryToCompleteCurrent(	pPort,
								SerialGrabReadFromIsr,
								Irp->CancelIrql,
								STATUS_CANCELLED,
								&pPort->CurrentReadIrp,
								&pPort->ReadQueue,
								&pPort->ReadRequestIntervalTimer,
								&pPort->ReadRequestTotalTimer,
								SerialStartRead,
								SerialGetNextIrp,
								SERIAL_REF_CANCEL);
        
}

BOOLEAN
SerialGrabReadFromIsr(IN PVOID Context)
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

    This routine is used to grab (if possible) the irp from the
    isr.  If it finds that the isr still owns the irp it grabs
    the irp away (updating the number of characters copied into the
    users buffer).  If it grabs it away it also decrements the
    reference count on the irp since it no longer belongs to the
    isr (and the dpc that would complete it).

    NOTE: This routine assumes that if the current buffer that the
          ISR is copying characters into is the interrupt buffer then
          the dpc has already been queued.

    NOTE: This routine is being called from KeSynchronizeExecution.

    NOTE: This routine assumes that it is called with the cancel spin
          lock held.

Arguments:

    Context - Really a pointer to the device extension.

Return Value:

    Always false.

-----------------------------------------------------------------------------*/
{
    PPORT_DEVICE_EXTENSION pPort = Context;
	SpxDbgMsg(SPX_TRACE_CALLS,("SerialGrabReadFromIsr - Irp: %x\n", pPort->CurrentReadIrp));

	ReadDataFromIntBuffer(pPort);

	SERIAL_CLEAR_REFERENCE(pPort->CurrentReadIrp, SERIAL_REF_ISR);

    return FALSE;
}


VOID
SerialReadTimeout(IN PKDPC Dpc, IN PVOID DeferredContext, IN PVOID SystemContext1, IN PVOID SystemContext2)
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

    This routine is used to complete a read because its total
    timer has expired.

Arguments:

    Dpc - Not Used.

    DeferredContext - Really points to the device extension.

    SystemContext1 - Not Used.

    SystemContext2 - Not Used.

Return Value:

    None.

-----------------------------------------------------------------------------*/
{
    PPORT_DEVICE_EXTENSION pPort = DeferredContext;
    KIRQL oldIrql;

    UNREFERENCED_PARAMETER(Dpc);
    UNREFERENCED_PARAMETER(SystemContext1);
    UNREFERENCED_PARAMETER(SystemContext2);

	SpxDbgMsg(SPX_TRACE_CALLS,("SerialReadTimeout - Irp: %x\n", pPort->CurrentReadIrp));

    IoAcquireCancelSpinLock(&oldIrql);

    // We set this to indicate to the interval timer that the read has completed due to total timeout.
    // Recall that the interval timer dpc can be lurking in some DPC queue.
    pPort->CountOnLastRead = SERIAL_COMPLETE_READ_TOTAL;

    SerialTryToCompleteCurrent(	pPort,
								SerialGrabReadFromIsr,
								oldIrql,
								STATUS_TIMEOUT,
								&pPort->CurrentReadIrp,
								&pPort->ReadQueue,
								&pPort->ReadRequestIntervalTimer,
								&pPort->ReadRequestTotalTimer,
								SerialStartRead,
								SerialGetNextIrp,
								SERIAL_REF_TOTAL_TIMER);
        

}

BOOLEAN
SerialUpdateReadByIsr(IN PVOID Context)
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

    This routine is used to update the count of characters read
    by the isr since the last interval timer experation.

    NOTE: This routine is being called from KeSynchronizeExecution.

    NOTE: This routine assumes that it is called with the cancel spin
          lock held.

Arguments:

    Context - Really a pointer to the device extension.

Return Value:

    Always false.

-----------------------------------------------------------------------------*/
{

    PPORT_DEVICE_EXTENSION pPort = Context;
	SpxDbgMsg(SPX_TRACE_CALLS,("SerialUpdateReadByIsr - Irp: %x\n", pPort->CurrentReadIrp));

    pPort->CountOnLastRead = pPort->ReadByIsr;
    pPort->ReadByIsr = 0;

    return FALSE;

}

VOID
SerialIntervalReadTimeout(IN PKDPC Dpc, 
						  IN PVOID DeferredContext, 
						  IN PVOID SystemContext1, 
						  IN PVOID SystemContext2)
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

    This routine is used timeout the request if the time between
    characters exceed the interval time.  A global is kept in
    the device extension that records the count of characters read
    the last the last time this routine was invoked (This dpc
    will resubmit the timer if the count has changed).  If the
    count has not changed then this routine will attempt to complete
    the irp.  Note the special case of the last count being zero.
    The timer isn't really in effect until the first character is
    read.

Arguments:

    Dpc - Not Used.

    DeferredContext - Really points to the device extension.

    SystemContext1 - Not Used.

    SystemContext2 - Not Used.

Return Value:

    None.

-----------------------------------------------------------------------------*/
{

    PPORT_DEVICE_EXTENSION pPort = DeferredContext;
    KIRQL oldIrql;

    UNREFERENCED_PARAMETER(Dpc);
    UNREFERENCED_PARAMETER(SystemContext1);
    UNREFERENCED_PARAMETER(SystemContext2);

	SpxDbgMsg(SPX_TRACE_CALLS,("SerialIntervalReadTimeout - Irp: %x\n", pPort->CurrentReadIrp));

    IoAcquireCancelSpinLock(&oldIrql);

    if(pPort->CountOnLastRead == SERIAL_COMPLETE_READ_TOTAL) 
	{
        // This value is only set by the total timer to indicate that it has fired.
        // If so, then we should simply try to complete.
        SerialTryToCompleteCurrent(	pPort,
									SerialGrabReadFromIsr,
									oldIrql,
									STATUS_TIMEOUT,
									&pPort->CurrentReadIrp,
									&pPort->ReadQueue,
									&pPort->ReadRequestIntervalTimer,
									&pPort->ReadRequestTotalTimer,
									SerialStartRead,
									SerialGetNextIrp,
									SERIAL_REF_INT_TIMER);
    } 
	else if(pPort->CountOnLastRead == SERIAL_COMPLETE_READ_COMPLETE) 
	{

        // This value is only set by the regular completion routine.
        // If so, then we should simply try to complete.
        SerialTryToCompleteCurrent(	pPort,
									SerialGrabReadFromIsr,
									oldIrql,
									STATUS_SUCCESS,
									&pPort->CurrentReadIrp,
									&pPort->ReadQueue,
									&pPort->ReadRequestIntervalTimer,
									&pPort->ReadRequestTotalTimer,
									SerialStartRead,
									SerialGetNextIrp,
									SERIAL_REF_INT_TIMER);
    } 
	else if(pPort->CountOnLastRead == SERIAL_COMPLETE_READ_CANCEL) 
	{

        // This value is only set by the cancel read routine.
        // If so, then we should simply try to complete.
        SerialTryToCompleteCurrent(	pPort,
									SerialGrabReadFromIsr,
									oldIrql,
									STATUS_CANCELLED,
									&pPort->CurrentReadIrp,
									&pPort->ReadQueue,
									&pPort->ReadRequestIntervalTimer,
									&pPort->ReadRequestTotalTimer,
									SerialStartRead,
									SerialGetNextIrp,
									SERIAL_REF_INT_TIMER);
    } 
	else if(pPort->CountOnLastRead || pPort->ReadByIsr) 
	{
        //
        // Something has happened since we last came here.  We
        // check to see if the ISR has read in any more characters.
        // If it did then we should update the isr's read count
        // and resubmit the timer.
        //

        if(pPort->ReadByIsr) 
		{

            KeSynchronizeExecution(pPort->Interrupt, SerialUpdateReadByIsr, pPort);
                
            //
            // Save off the "last" time something was read.
            // As we come back to this routine we will compare
            // the current time to the "last" time.  If the
            // difference is ever larger then the interval
            // requested by the user, then time out the request.
            //

            KeQuerySystemTime(&pPort->LastReadTime);

            KeSetTimer(	&pPort->ReadRequestIntervalTimer,
						*pPort->IntervalTimeToUse,
						&pPort->IntervalReadTimeoutDpc);

            IoReleaseCancelSpinLock(oldIrql);

        } 
		else 
		{
            //
            // Take the difference between the current time
            // and the last time we had characters and
            // see if it is greater then the interval time.
            // if it is, then time out the request.  Otherwise
            // go away again for a while.
            //

            // No characters read in the interval time.  Kill this read.

            LARGE_INTEGER currentTime;

            KeQuerySystemTime(&currentTime);

            if((currentTime.QuadPart - pPort->LastReadTime.QuadPart) >= pPort->IntervalTime.QuadPart) 
			{
                SerialTryToCompleteCurrent(	pPort,
											SerialGrabReadFromIsr,
											oldIrql,
											STATUS_TIMEOUT,
											&pPort->CurrentReadIrp,
											&pPort->ReadQueue,
											&pPort->ReadRequestIntervalTimer,
											&pPort->ReadRequestTotalTimer,
											SerialStartRead,
											SerialGetNextIrp,
											SERIAL_REF_INT_TIMER);
            } 
			else 
			{
                KeSetTimer(	&pPort->ReadRequestIntervalTimer,
							*pPort->IntervalTimeToUse,
							&pPort->IntervalReadTimeoutDpc);
                
                IoReleaseCancelSpinLock(oldIrql);
            }


        }

    } 
	else 
	{

        //
        // Timer doesn't really start until the first character.
        // So we should simply resubmit ourselves.
        //

        KeSetTimer(&pPort->ReadRequestIntervalTimer, *pPort->IntervalTimeToUse, &pPort->IntervalReadTimeoutDpc);

        IoReleaseCancelSpinLock(oldIrql);
    }

}

BOOLEAN
ReadDataFromIntBuffer(IN PVOID Context)
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

    This routine is used to copy any characters out of the interrupt
    buffer into the users buffer.  It will be reading values that
    are updated with the ISR but this is safe since this value is
    only decremented by synchronization routines.  This routine will
    return the number of characters copied so some other routine
    can call a synchronization routine to update what is seen at
    interrupt level.

Arguments:

    Extension - A pointer to the device extension.

Return Value:

    The number of characters that were copied into the user
    buffer.

-----------------------------------------------------------------------------*/
{
	PPORT_DEVICE_EXTENSION pPort = Context;
	ULONG NumberOfBytes = 0;

	SpxDbgMsg(SPX_TRACE_CALLS,("ReadDataFromIntBuffer - Irp: %x\n", pPort->CurrentReadIrp));
	NumberOfBytes = pPort->pUartLib->UL_ReadData_XXXX(pPort->pUart, 
						(PUCHAR)(pPort->CurrentReadIrp->AssociatedIrp.SystemBuffer)
						+ pPort->CurrentReadIrp->IoStatus.Information,
						IoGetCurrentIrpStackLocation(pPort->CurrentReadIrp)->Parameters.Read.Length 
						- pPort->CurrentReadIrp->IoStatus.Information);

	if(NumberOfBytes)
	{
		if(NumberOfBytes > pPort->NumberNeededForRead)
			pPort->NumberNeededForRead = 0;
		else
			pPort->NumberNeededForRead -= NumberOfBytes;

		pPort->CurrentReadIrp->IoStatus.Information += NumberOfBytes;

		// Deal with flow control if necessary.
		SerialHandleReducedIntBuffer(pPort);

		return TRUE;
	}
	
    return FALSE;
}



BOOLEAN
UpdateAndWaitForMoreData(IN PVOID Context)
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

    This routine gets the (hopefully) few characters that
    remain in the interrupt buffer after the first time we tried
    to get them out.  If we still don't have enough characters
    to satisfy the read it will then we set things up so that the
    ISR uses the user buffer copy into.

    This routine is also used to update a count that is maintained
    by the ISR to keep track of the number of characters in its buffer.

    NOTE: This is called by KeSynchronizeExecution.

Arguments:

    Context - Points to a structure that contains a pointer to the
              device extension, a count of the number of characters
              that we previously copied into the users buffer, and
              a boolean that we will set that defines whether we
              switched the ISR to copy into the users buffer.

Return Value:


-----------------------------------------------------------------------------*/
{
    PPORT_DEVICE_EXTENSION pPort = Context;

	SpxDbgMsg(SPX_TRACE_CALLS,("UpdateAndWaitForMoreData - Irp: %x\n", pPort->CurrentReadIrp));

    // There are more characters to get to satisfy this read.
    // Copy any characters that have arrived since we got the last batch.
    ReadDataFromIntBuffer(pPort);

    //
    // No more new characters will be "received" until we exit this routine.  
    // We again check to make sure that we haven't satisfied this read,
    // and if we haven't, we wait for the ISR to get some more data.
    //

    if(pPort->NumberNeededForRead) 
	{
		pPort->CountOnLastRead = pPort->CurrentReadIrp->IoStatus.Information;
        pPort->ReadByIsr = 0;

        // Mark the irp as being in a cancelable state.
        IoSetCancelRoutine(pPort->CurrentReadIrp, SerialCancelCurrentRead);
            
        // Increment the reference count twice.
        // Once for the Isr owning the irp and once because the cancel routine has a reference to it.
        SERIAL_SET_REFERENCE(pPort->CurrentReadIrp, SERIAL_REF_ISR);
        SERIAL_SET_REFERENCE(pPort->CurrentReadIrp, SERIAL_REF_CANCEL);

        return FALSE;
    } 


    return TRUE;
}




//
// We use this structure only to communicate to the synchronization
// routine when we are switching to the resized buffer.
//
typedef struct _SERIAL_RESIZE_PARAMS 
{
    PPORT_DEVICE_EXTENSION pPort;
    PUCHAR OldBuffer;
    PUCHAR NewBuffer;
    ULONG NewBufferSize;
    ULONG NumberMoved;
    
} SERIAL_RESIZE_PARAMS,*PSERIAL_RESIZE_PARAMS;


NTSTATUS
SerialResizeBuffer(IN PPORT_DEVICE_EXTENSION pPort)
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

    This routine will process the resize buffer request.
    If size requested for the RX buffer is smaller than
    the current buffer then we will simply return
    STATUS_SUCCESS.  (We don't want to make buffers smaller.
    If we did that then we all of a sudden have "overrun"
    problems to deal with as well as flow control to deal
    with - very painful.)  We ignore the TX buffer size
    request since we don't use a TX buffer.

Arguments:

    Extension - Pointer to the device extension for the port.

Return Value:

    STATUS_SUCCESS if everything worked out ok.
    STATUS_INSUFFICIENT_RESOURCES if we couldn't allocate the
    memory for the buffer.

-----------------------------------------------------------------------------*/
{

    PSERIAL_QUEUE_SIZE rs = pPort->CurrentReadIrp->AssociatedIrp.SystemBuffer;
                                                       
    PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation(pPort->CurrentReadIrp);
                                   
    PVOID newBuffer = irpSp->Parameters.DeviceIoControl.Type3InputBuffer;

    irpSp->Parameters.DeviceIoControl.Type3InputBuffer = NULL;
    pPort->CurrentReadIrp->IoStatus.Information = 0L;
    pPort->CurrentReadIrp->IoStatus.Status = STATUS_SUCCESS;

    if(rs->InSize <= pPort->BufferSize) 
	{

        //
        // Nothing to do.  We don't make buffers smaller.  Just
        // agree with the user.  We must deallocate the memory
        // that was already allocated in the ioctl dispatch routine.
        //
        ExFreePool(newBuffer);
    } 
	else 
	{
        SERIAL_RESIZE_PARAMS rp;
        KIRQL controlIrql;

        //
        // Hmmm, looks like we actually have to go
        // through with this.  We need to move all the
        // data that is in the current buffer into this
        // new buffer.  We'll do this in two steps.
        //
        // First we go up to dispatch level and try to
        // move as much as we can without stopping the
        // ISR from running.  We go up to dispatch level
        // by acquiring the control lock.  We do it at
        // dispatch using the control lock so that:
        //
        //    1) We can't be context switched in the middle
        //       of the move.  Our pointers into the buffer
        //       could be *VERY* stale by the time we got back.
        //
        //    2) We use the control lock since we don't want
        //       some pesky purge irp to come along while
        //       we are trying to move.
        //
        // After the move, but while we still hold the control
        // lock, we synch with the ISR and get those last
        // (hopefully) few characters that have come in since
        // we started the copy.  We switch all of our pointers,
        // counters, and such to point to this new buffer.  NOTE:
        // we need to be careful.  If the buffer we were using
        // was not the default one created when we initialized
        // the device (i.e. it was created via a previous IRP of
        // this type), we should deallocate it.
        //

        rp.pPort = pPort;
        rp.OldBuffer = NULL;
        rp.NewBuffer = newBuffer;
        rp.NewBufferSize = rs->InSize;

        KeAcquireSpinLock(&pPort->ControlLock, &controlIrql);

        KeSynchronizeExecution(pPort->Interrupt, SerialUpdateAndSwitchToNew, &rp);

        KeReleaseSpinLock( &pPort->ControlLock, controlIrql);
           

        // Free up the memory that the old buffer consumed.
        ExFreePool(rp.OldBuffer);

    }

    return STATUS_SUCCESS;

}



BOOLEAN
SerialUpdateAndSwitchToNew(IN PVOID Context)
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

    This routine gets the (hopefully) few characters that
    remain in the interrupt buffer after the first time we tried
    to get them out.

    NOTE: This is called by KeSynchronizeExecution.

Arguments:

    Context - Points to a structure that contains a pointer to the
              device extension, a pointer to the buffer we are moving
              to, and a count of the number of characters
              that we previously copied into the new buffer, and the
              actual size of the new buffer.

Return Value:

    Always FALSE.

-----------------------------------------------------------------------------*/
{
    PSERIAL_RESIZE_PARAMS params = Context;
    PPORT_DEVICE_EXTENSION pPort = params->pPort;

	pPort->BufferSizes.pINBuffer = params->NewBuffer; 
	pPort->BufferSizes.INBufferSize = params->NewBufferSize;

	pPort->pUartLib->UL_BufferControl_XXXX(pPort->pUart, &pPort->BufferSizes, UL_BC_OP_SET, UL_BC_BUFFER | UL_BC_IN);

	params->OldBuffer = pPort->BufferSizes.pINBuffer;
	
    pPort->BufferSize = params->NewBufferSize;

    // We set up the default xon/xoff limits.
    pPort->HandFlow.XoffLimit = pPort->BufferSize >> 3;
    pPort->HandFlow.XonLimit = pPort->BufferSize >> 1;

    pPort->BufferSizePt8 = ((3*(pPort->BufferSize>>2)) + (pPort->BufferSize>>4));

#ifdef WMI_SUPPORT
	UPDATE_WMI_XMIT_THRESHOLDS(pPort->WmiCommData, pPort->HandFlow);
#endif                                 

    // Since we (essentially) reduced the percentage of the interrupt
    // buffer being full, we need to handle any flow control.
    SerialHandleReducedIntBuffer(pPort);

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\spx\speed\driver\spd_iioc.c ===
/************************************************************************/
/*																		*/
/*	Title		:	SPEED support funcs for INTERNAL IOCTLs			*/
/*																		*/
/*	Author		:	N.P.Vassallo										*/
/*																		*/
/*	Creation	:	14th October 1998									*/
/*																		*/
/*	Version		:	1.0.0												*/
/*																		*/
/*	Description	:	Support functions to support the					*/
/*					INTERNAL IOCTLs for specific hardware:				*/
/*					XXX_SetHandFlow										*/
/*																		*/
/************************************************************************/

/* History...

1.0.0	14/20/98 NPV	Creation.

*/

#include "precomp.h"

/*****************************************************************************
*****************************                     ****************************
*****************************   XXX_SetHandFlow   ****************************
*****************************                     ****************************
******************************************************************************

prototype:		void XXX_SetHandFlow(IN PPORT_DEVICE_EXTENSION pPort, IN PSERIAL_IOCTL_SYNC pS)

description:	Call to set the handshaking and flow control

parameters:		pPort points to the port device extension structure
				pS points to a serial ioctl synchronization structure

returns:		STATUS_SUCCESS

*/

void XXX_SetHandFlow(IN PPORT_DEVICE_EXTENSION pPort,IN PSERIAL_IOCTL_SYNC pS)
{
	PCARD_DEVICE_EXTENSION pCard = pPort->pParentCardExt;

	KeSynchronizeExecution(pCard->Interrupt, SerialSetHandFlow, pS);

}	/* XXX_SetHandFlow */
                                                        
/* End of IO8_IIOC.C */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\spx\speed\driver\spxutils.c ===
#include "precomp.h"	// Precompiled header

/****************************************************************************************
*																						*
*	Module:			SPX_UTILS.C															*
*																						*
*	Creation:		15th October 1998													*
*																						*
*	Author:			Paul Smith															*
*																						*
*	Version:		1.0.0																*
*																						*
*	Description:	Utility functions.													*
*																						*
****************************************************************************************/

#define FILE_ID	SPX_UTILS_C		// File ID for Event Logging see SPX_DEFS.H for values.

// Paging...  
#ifdef ALLOC_PRAGMA
#pragma alloc_text (PAGE, Spx_InitMultiString)
#pragma alloc_text (PAGE, Spx_GetRegistryKeyValue)
#pragma alloc_text (PAGE, Spx_PutRegistryKeyValue)
#pragma alloc_text (PAGE, Spx_LogMessage)
#pragma alloc_text (PAGE, Spx_LogError)
#pragma alloc_text (PAGE, Spx_MemCompare)
#endif


/////////////////////////////////////////////////////////////////////////////////////////
//	
//	Description:
//
//		This routine will take a null terminated list of ascii strings and combine
//		them together to generate a unicode multi-string block
//
//	Arguments:
//
//		Multi		- TRUE if a MULTI_SZ list is required, FALSE for a simple UNICODE
//
//		MultiString - a unicode structure in which a multi-string will be built
//		...         - a null terminated list of narrow strings which will be
//			       combined together. This list must contain at least a trailing NULL
//
//	Return Value:
//
//		NTSTATUS
//
/////////////////////////////////////////////////////////////////////////////////////////
NTSTATUS
Spx_InitMultiString(BOOLEAN multi, PUNICODE_STRING MultiString, ...)
{

	ANSI_STRING ansiString;
	NTSTATUS status;
	PCSTR rawString;
	PWSTR unicodeLocation;
	ULONG multiLength = 0;
	UNICODE_STRING unicodeString;
	va_list ap;
	ULONG i;

	PAGED_CODE();	// Macro in checked build to assert if pagable code is run at or above dispatch IRQL 

	va_start(ap,MultiString);
  
	// Make sure that we won't leak memory
	ASSERT(MultiString->Buffer == NULL);

	rawString = va_arg(ap, PCSTR);

	while (rawString != NULL) 
	{
		RtlInitAnsiString(&ansiString, rawString);
		multiLength += RtlAnsiStringToUnicodeSize(&(ansiString));
		rawString = va_arg(ap, PCSTR);
	}

	va_end( ap );

	if (multiLength == 0) 
	{
		// Done
		RtlInitUnicodeString(MultiString, NULL);
		SpxDbgMsg(SPX_TRACE_CALLS, ("%s: Leaving Spx_InitMultiString (1)\n", PRODUCT_NAME));

		return STATUS_SUCCESS;
	}

	

	if(multi)
		multiLength += sizeof(WCHAR);	// We need an extra null if we want a MULTI_SZ list


	MultiString->MaximumLength = (USHORT)multiLength;
	MultiString->Buffer = SpxAllocateMem(PagedPool, multiLength);
	MultiString->Length = 0;

	if (MultiString->Buffer == NULL) 
	{
		SpxDbgMsg(SPX_TRACE_CALLS, ("%s: Leaving Spx_InitMultiString (2) - FAILURE\n", PRODUCT_NAME));

		return STATUS_INSUFFICIENT_RESOURCES;
	}


	SpxDbgMsg(SPX_MISC_DBG, ("%s: Allocated %lu bytes for buffer\n", PRODUCT_NAME, multiLength));

#if DBG
	RtlFillMemory(MultiString->Buffer, multiLength, 0xff);
#endif

	unicodeString.Buffer = MultiString->Buffer;
	unicodeString.MaximumLength = (USHORT) multiLength;

	va_start(ap, MultiString);
	rawString = va_arg(ap, PCSTR);

	while (rawString != NULL) 
	{

		RtlInitAnsiString(&ansiString,rawString);
		status = RtlAnsiStringToUnicodeString(&unicodeString, &ansiString, FALSE);

		// We don't allocate memory, so if something goes wrong here,
		// its the function that's at fault
		ASSERT(SPX_SUCCESS(status));

		// Check for any commas and replace them with NULLs
		ASSERT(unicodeString.Length % sizeof(WCHAR) == 0);

		for (i = 0; i < (unicodeString.Length / sizeof(WCHAR)); i++) 
		{
			if (unicodeString.Buffer[i] == L'\x2C' || unicodeString.Buffer[i] == L'\x0C' ) 
			{
				unicodeString.Buffer[i] = L'\0'; 
			}
		}


		SpxDbgMsg(SPX_MISC_DBG, ("%s: unicode buffer: %ws\n", PRODUCT_NAME, unicodeString.Buffer));

		// Move the buffers along
		unicodeString.Buffer += ((unicodeString.Length / sizeof(WCHAR)) + 1);
		unicodeString.MaximumLength -= (unicodeString.Length + sizeof(WCHAR));
		unicodeString.Length = 0;

		// Next
		rawString = va_arg(ap, PCSTR);

	} // while

	va_end(ap);

	if(multi)
	{
		ASSERT(unicodeString.MaximumLength == sizeof(WCHAR));
	}
	else
	{
		ASSERT(unicodeString.MaximumLength == 0);
	}


	// Stick the final null there
 	SpxDbgMsg(SPX_MISC_DBG, ("%s: unicode buffer last addr: 0x%X\n", PRODUCT_NAME, unicodeString.Buffer));

	if(multi)
		unicodeString.Buffer[0] = L'\0'; 		// We need an extra null if we want a MULTI_SZ list


	MultiString->Length = (USHORT)multiLength - sizeof(WCHAR);
	MultiString->MaximumLength = (USHORT)multiLength;

	SpxDbgMsg(SPX_TRACE_CALLS, ("%s: Leaving Spx_InitMultiString (3) - SUCCESS\n", PRODUCT_NAME));

	return STATUS_SUCCESS;
}


/////////////////////////////////////////////////////////////////////////////////////////
//
//	Routine Description:	
//		Reads a registry key value from an already opened registry key.
//    
//	Arguments:
//
//		Handle              Handle to the opened registry key
//    
//		KeyNameString       ANSI string to the desired key
//
//		KeyNameStringLength Length of the KeyNameString
//
//		Data                Buffer to place the key value in
//
//		DataLength          Length of the data buffer
//
//	Return Value:
//
//		STATUS_SUCCESS if all works, otherwise status of system call that
//		went wrong.
//
/////////////////////////////////////////////////////////////////////////////////////////
NTSTATUS 
Spx_GetRegistryKeyValue(
	IN HANDLE	Handle,
	IN PWCHAR	KeyNameString,
	IN ULONG	KeyNameStringLength,
	IN PVOID	Data,
	IN ULONG	DataLength
	)

{

	UNICODE_STRING              keyName;
	ULONG                       length;
	PKEY_VALUE_FULL_INFORMATION fullInfo;

	NTSTATUS                    status = STATUS_INSUFFICIENT_RESOURCES;

	PAGED_CODE();	// Macro in checked build to assert if pagable code is run at or above dispatch IRQL 

	SpxDbgMsg(SPX_TRACE_CALLS, ("%s: Enter Spx_GetRegistryKeyValue\n", PRODUCT_NAME));


	RtlInitUnicodeString (&keyName, KeyNameString);

	length = sizeof(KEY_VALUE_FULL_INFORMATION) + KeyNameStringLength + DataLength;
	fullInfo = SpxAllocateMem(PagedPool, length); 

	if(fullInfo) 
	{
		status = ZwQueryValueKey(	Handle,
									&keyName,
									KeyValueFullInformation,
									fullInfo,
									length,
									&length);

		if(SPX_SUCCESS(status)) 
		{
			// If there is enough room in the data buffer, copy the output
			if(DataLength >= fullInfo->DataLength) 
				RtlCopyMemory (Data, ((PUCHAR) fullInfo) + fullInfo->DataOffset, fullInfo->DataLength);
		}

		SpxFreeMem(fullInfo);
	}

	return status;
}


/////////////////////////////////////////////////////////////////////////////////////////
//
//	Routine Description:
//
//		Writes a registry key value to an already opened registry key.
//    
//	Arguments:
//
//		Handle              Handle to the opened registry key
//    
//		PKeyNameString      ANSI string to the desired key
//
//		KeyNameStringLength Length of the KeyNameString
//    
//		Dtype				REG_XYZ value type
//
//		PData               Buffer to place the key value in
//
//		DataLength          Length of the data buffer
//
//	Return Value:
//
//		STATUS_SUCCESS if all works, otherwise status of system call that
//		went wrong.
//
/////////////////////////////////////////////////////////////////////////////////////////

NTSTATUS 
Spx_PutRegistryKeyValue(
	IN HANDLE Handle, 
	IN PWCHAR PKeyNameString,
	IN ULONG KeyNameStringLength, 
	IN ULONG Dtype,
    IN PVOID PData, 
	IN ULONG DataLength
	)
{

	NTSTATUS status;
	UNICODE_STRING keyname;

	PAGED_CODE();	// Macro in checked build to assert if pagable code is run at or above dispatch IRQL 

	SpxDbgMsg(SPX_TRACE_CALLS,("%s: Enter Spx_PutRegistryKeyValue\n", PRODUCT_NAME));

	RtlInitUnicodeString(&keyname, NULL);
	keyname.MaximumLength = (USHORT)(KeyNameStringLength + sizeof(WCHAR));
	keyname.Buffer = SpxAllocateMem(PagedPool, keyname.MaximumLength);

	if(keyname.Buffer == NULL) 
		  return STATUS_INSUFFICIENT_RESOURCES;

	RtlAppendUnicodeToString(&keyname, PKeyNameString);

	status = ZwSetValueKey(Handle, &keyname, 0, Dtype, PData, DataLength);

	SpxFreeMem(keyname.Buffer);

	return status;
}




VOID
Spx_LogMessage(
	IN ULONG MessageSeverity,				
	IN PDRIVER_OBJECT DriverObject,
	IN PDEVICE_OBJECT DeviceObject OPTIONAL,
	IN PHYSICAL_ADDRESS P1,
	IN PHYSICAL_ADDRESS P2,
	IN ULONG SequenceNumber,
	IN UCHAR MajorFunctionCode,
	IN UCHAR RetryCount,
	IN ULONG UniqueErrorValue,
	IN NTSTATUS FinalStatus,
	IN PCHAR szTemp)	// Limited to 51 characters + 1 null
{
	
	UNICODE_STRING ErrorMsg;

	ErrorMsg.Length = 0;
	ErrorMsg.Buffer = 0;
	Spx_InitMultiString(FALSE, &ErrorMsg, szTemp, NULL);


	switch(MessageSeverity)
	{
	case STATUS_SEVERITY_SUCCESS:
		Spx_LogError(	DriverObject,						// Driver Object
						DeviceObject,						// Device Object (Optional)
						P1,									// Physical Address 1
						P2,									// Physical Address 2
						SequenceNumber,						// SequenceNumber
						MajorFunctionCode,					// Major Function Code
						RetryCount,							// RetryCount
						UniqueErrorValue,					// UniqueErrorValue
						FinalStatus,						// FinalStatus
						SPX_SEVERITY_SUCCESS,				// SpecificIOStatus
						ErrorMsg.Length + sizeof(WCHAR),	// LengthOfInsert1
						ErrorMsg.Buffer,					// Insert1
						0,									// LengthOfInsert2
						NULL);								// Insert2
		break;
	
	case STATUS_SEVERITY_INFORMATIONAL:
		Spx_LogError(	DriverObject,						// Driver Object
						DeviceObject,						// Device Object (Optional)
						P1,									// Physical Address 1
						P2,									// Physical Address 2
						SequenceNumber,						// SequenceNumber
						MajorFunctionCode,					// Major Function Code
						RetryCount,							// RetryCount
						UniqueErrorValue,					// UniqueErrorValue
						FinalStatus,						// FinalStatus
						SPX_SEVERITY_INFORMATIONAL,			// SpecificIOStatus
						ErrorMsg.Length + sizeof(WCHAR),	// LengthOfInsert1
						ErrorMsg.Buffer,					// Insert1
						0,									// LengthOfInsert2
						NULL);								// Insert2
		break;

	case STATUS_SEVERITY_WARNING:
		Spx_LogError(	DriverObject,						// Driver Object
						DeviceObject,						// Device Object (Optional)
						P1,									// Physical Address 1
						P2,									// Physical Address 2
						SequenceNumber,						// SequenceNumber
						MajorFunctionCode,					// Major Function Code
						RetryCount,							// RetryCount
						UniqueErrorValue,					// UniqueErrorValue
						FinalStatus,						// FinalStatus
						SPX_SEVERITY_WARNING,				// SpecificIOStatus
						ErrorMsg.Length + sizeof(WCHAR),	// LengthOfInsert1
						ErrorMsg.Buffer,					// Insert1
						0,									// LengthOfInsert2
						NULL);								// Insert2
		break;

	case STATUS_SEVERITY_ERROR:
	default:
		Spx_LogError(	DriverObject,						// Driver Object
						DeviceObject,						// Device Object (Optional)
						P1,									// Physical Address 1
						P2,									// Physical Address 2
						SequenceNumber,						// SequenceNumber
						MajorFunctionCode,					// Major Function Code
						RetryCount,							// RetryCount
						UniqueErrorValue,					// UniqueErrorValue
						FinalStatus,						// FinalStatus
						SPX_SEVERITY_ERROR,					// SpecificIOStatus
						ErrorMsg.Length + sizeof(WCHAR),	// LengthOfInsert1
						ErrorMsg.Buffer,					// Insert1
						0,									// LengthOfInsert2
						NULL);								// Insert2
		break;

	}

	if(ErrorMsg.Buffer != NULL)
		SpxFreeMem(ErrorMsg.Buffer);

}

/////////////////////////////////////////////////////////////////////////////////////////
//																
//	Spx_LogError														
//															
/////////////////////////////////////////////////////////////////////////////////////////
/*
	Routine Description:

		This routine allocates an error log entry, copies the supplied data
		to it, and requests that it be written to the error log file.

	Arguments:

		DriverObject - A pointer to the driver object for the device.

		DeviceObject - A pointer to the device object associated with the
		device that had the error, early in initialization, one may not
		yet exist.

		P1,P2 - If phyical addresses for the controller ports involved
		with the error are available, put them through as dump data.

		SequenceNumber - A ulong value that is unique to an IRP over the
		life of the irp in this driver - 0 generally means an error not
		associated with an irp.

		MajorFunctionCode - If there is an error associated with the irp,
		this is the major function code of that irp.

		RetryCount - The number of times a particular operation has been retried.

		UniqueErrorValue - A unique long word that identifies the particular
		call to this function.

		FinalStatus - The final status given to the irp that was associated
		with this error.  If this log entry is being made during one of
		the retries this value will be STATUS_SUCCESS.

		SpecificIOStatus - The IO status for a particular error.

		LengthOfInsert1 - The length in bytes (including the terminating NULL)
						  of the first insertion string.

		Insert1 - The first insertion string.

		LengthOfInsert2 - The length in bytes (including the terminating NULL)
						  of the second insertion string.  NOTE, there must
						  be a first insertion string for their to be
						  a second insertion string.

		Insert2 - The second insertion string.

	Return Value:	None.
*/


VOID
Spx_LogError(
	IN PDRIVER_OBJECT DriverObject,
	IN PDEVICE_OBJECT DeviceObject OPTIONAL,
	IN PHYSICAL_ADDRESS P1,
	IN PHYSICAL_ADDRESS P2,
	IN ULONG SequenceNumber,
	IN UCHAR MajorFunctionCode,
	IN UCHAR RetryCount,
	IN ULONG UniqueErrorValue,
	IN NTSTATUS FinalStatus,
	IN NTSTATUS SpecificIOStatus,
	IN ULONG LengthOfInsert1,
	IN PWCHAR Insert1,
	IN ULONG LengthOfInsert2,
	IN PWCHAR Insert2
	)
{

	PIO_ERROR_LOG_PACKET ErrorLogEntry;

	PVOID objectToUse;
	SHORT dumpToAllocate = 0;
	PUCHAR ptrToFirstInsert;
	PUCHAR ptrToSecondInsert;

	PAGED_CODE();	// Macro in checked build to assert if pagable code is run at or above dispatch IRQL 

	if(Insert1 == NULL) 
		LengthOfInsert1 = 0;

	if(Insert2 == NULL) 
		LengthOfInsert2 = 0;


	if(ARGUMENT_PRESENT(DeviceObject)) 
		objectToUse = DeviceObject;
	else 
		objectToUse = DriverObject;


	if(Spx_MemCompare(P1, (ULONG)1, PhysicalZero, (ULONG)1 ) != AddressesAreEqual) 
	{
		dumpToAllocate = (SHORT)sizeof(PHYSICAL_ADDRESS);
	}

	if(Spx_MemCompare(P2, (ULONG)1, PhysicalZero, (ULONG)1 ) != AddressesAreEqual) 
	{
		dumpToAllocate += (SHORT)sizeof(PHYSICAL_ADDRESS);
	}

	ErrorLogEntry = IoAllocateErrorLogEntry(objectToUse,
											(UCHAR)(sizeof(IO_ERROR_LOG_PACKET) + dumpToAllocate 
											+ LengthOfInsert1 + LengthOfInsert2)	
											);

	if(ErrorLogEntry != NULL) 
	{
		ErrorLogEntry->ErrorCode			= SpecificIOStatus;
		ErrorLogEntry->SequenceNumber		= SequenceNumber;
		ErrorLogEntry->MajorFunctionCode	= MajorFunctionCode;
		ErrorLogEntry->RetryCount			= RetryCount;
		ErrorLogEntry->UniqueErrorValue		= UniqueErrorValue;
		ErrorLogEntry->FinalStatus			= FinalStatus;
		ErrorLogEntry->DumpDataSize			= dumpToAllocate;

		
		if(dumpToAllocate) 
		{
			RtlCopyMemory(&ErrorLogEntry->DumpData[0], &P1,	sizeof(PHYSICAL_ADDRESS));

			if(dumpToAllocate > sizeof(PHYSICAL_ADDRESS)) 
			{
				RtlCopyMemory(	((PUCHAR)&ErrorLogEntry->DumpData[0]) + sizeof(PHYSICAL_ADDRESS),
								&P2,
								sizeof(PHYSICAL_ADDRESS)
								);

				ptrToFirstInsert = ((PUCHAR)&ErrorLogEntry->DumpData[0]) + (2*sizeof(PHYSICAL_ADDRESS));

			} 
			else 
			{
				ptrToFirstInsert = ((PUCHAR)&ErrorLogEntry->DumpData[0]) + sizeof(PHYSICAL_ADDRESS);
			}

		} 
		else 
		{
			ptrToFirstInsert = (PUCHAR)&ErrorLogEntry->DumpData[0];
		}

		ptrToSecondInsert = ptrToFirstInsert + LengthOfInsert1;

		if(LengthOfInsert1) 
		{
			ErrorLogEntry->NumberOfStrings	= 1;
			ErrorLogEntry->StringOffset		= (USHORT)(ptrToFirstInsert - (PUCHAR)ErrorLogEntry);

			RtlCopyMemory(ptrToFirstInsert, Insert1, LengthOfInsert1);

			if(LengthOfInsert2) 
			{
				ErrorLogEntry->NumberOfStrings = 2;
				RtlCopyMemory(ptrToSecondInsert, Insert2, LengthOfInsert2);
			}
		}


		IoWriteErrorLogEntry(ErrorLogEntry);

	}

}



SPX_MEM_COMPARES
Spx_MemCompare(IN PHYSICAL_ADDRESS A, IN ULONG SpanOfA, IN PHYSICAL_ADDRESS B, IN ULONG SpanOfB)
/*++
Routine Description:

    Compare two phsical address.

Arguments:

    A - One half of the comparison.

    SpanOfA - In units of bytes, the span of A.

    B - One half of the comparison.

    SpanOfB - In units of bytes, the span of B.


Return Value:

    The result of the comparison.
--*/
{
	LARGE_INTEGER a;
	LARGE_INTEGER b;

	LARGE_INTEGER lower;
	ULONG lowerSpan;
	LARGE_INTEGER higher;

	PAGED_CODE();	// Macro in checked build to assert if pagable code is run at or above dispatch IRQL 

	a = A;
	b = B;

	if(a.QuadPart == b.QuadPart) 
	  return AddressesAreEqual;


	if(a.QuadPart > b.QuadPart) 
	{
		higher = a;
		lower = b;
		lowerSpan = SpanOfB;
	} 
	else 
	{
		higher = b;
		lower = a;
		lowerSpan = SpanOfA;
	}

	if((higher.QuadPart - lower.QuadPart) >= lowerSpan)
      return AddressesAreDisjoint;


	return AddressesOverlap;
}


NTSTATUS
PLX_9050_CNTRL_REG_FIX(IN PCARD_DEVICE_EXTENSION pCard)
{
	/******************************************************** 
	* Setting bit 17 in the CNTRL register of the PLX 9050	* 
	* chip forces a retry on writes while a read is pending.*
	* This is to prevent the card locking up on Intel Xeon  *
	* multiprocessor systems with the NX chipset.			*
	********************************************************/

	#define CNTRL_REG_OFFSET	0x14	// DWORD Offset (BYTE Offset 0x50) 
	
	NTSTATUS	status = STATUS_SUCCESS;
	PULONG		pPCIConfigRegisters = NULL;			// Pointer to PCI Config Registers.
	CHAR		szErrorMsg[MAX_ERROR_LOG_INSERT];	// Limited to 51 characters + 1 null 

	SpxDbgMsg(SPX_TRACE_CALLS, ("%s: Entering PLX_9050_CNTRL_REG_FIX for Card %d.\n", 
		PRODUCT_NAME, pCard->CardNumber));

	pPCIConfigRegisters = MmMapIoSpace(pCard->PCIConfigRegisters, pCard->SpanOfPCIConfigRegisters, FALSE);

	if(pPCIConfigRegisters != NULL)
	{
		/* NOTE: If bit 7 of the PLX9050 config space physical address is set in either I/O Space or Memory... 
		* ...then reads from the registers will only return 0.  However, writes are OK. */

		if(pPCIConfigRegisters[CNTRL_REG_OFFSET] == 0)	// If bit 7 is set Config Registers are zero (unreadable) 
		{
			// We have to blindly write the value to the register.
			((PUCHAR)pPCIConfigRegisters)[CNTRL_REG_OFFSET*4 + 2] |= 0x26;	// Set bits 17 & 21 of PLX CNTRL register 
		}
		else
		{	
			((PUCHAR)pPCIConfigRegisters)[CNTRL_REG_OFFSET*4 + 1] &= ~0x40;		// Clear bit 14 of PLX CNTRL register
			((PUCHAR)pPCIConfigRegisters)[CNTRL_REG_OFFSET*4 + 2] |= 0x26;		// Set bits 17 & 21 of PLX CNTRL register
		}

		MmUnmapIoSpace(pPCIConfigRegisters, pCard->SpanOfPCIConfigRegisters);
	}
	else
	{
		SpxDbgMsg(SPX_TRACE_CALLS, ("%s: Insufficient resources available for Card %d.\n", 
			PRODUCT_NAME, pCard->CardNumber));
	
		sprintf(szErrorMsg, "Card at %08X%08X: Insufficient resources.", pCard->PhysAddr.HighPart, pCard->PhysAddr.LowPart);

		Spx_LogMessage(	STATUS_SEVERITY_ERROR,
						pCard->DriverObject,			// Driver Object
						pCard->DeviceObject,			// Device Object (Optional)
						PhysicalZero,					// Physical Address 1
						PhysicalZero,					// Physical Address 2
						0,								// SequenceNumber
						0,								// Major Function Code
						0,								// RetryCount
						FILE_ID | __LINE__,				// UniqueErrorValue
						STATUS_SUCCESS,					// FinalStatus
						szErrorMsg);					// Error Message

		return STATUS_INSUFFICIENT_RESOURCES;
	}


	return status;
}


//
// Definitely NON PAGABLE !!!
//
VOID
SpxSetOrClearPnpPowerFlags(IN PCOMMON_OBJECT_DATA pDevExt, IN ULONG Value, IN BOOLEAN Set)
{
	KIRQL oldIrql;

	KeAcquireSpinLock(&pDevExt->PnpPowerFlagsLock, &oldIrql);	

	if(Set) 
		pDevExt->PnpPowerFlags |= Value;			
	else 
		pDevExt->PnpPowerFlags &= ~Value;	

	KeReleaseSpinLock(&pDevExt->PnpPowerFlagsLock, oldIrql);	
}


// Definitely NON PAGABLE !!!
//
VOID
SpxSetOrClearUnstallingFlag(IN PCOMMON_OBJECT_DATA pDevExt, IN BOOLEAN Set)
{
	KIRQL oldIrql;

	KeAcquireSpinLock(&pDevExt->StalledIrpLock, &oldIrql);	

	pDevExt->UnstallingFlag = Set;			

	KeReleaseSpinLock(&pDevExt->StalledIrpLock, oldIrql);	
}


// Definitely NON PAGABLE !!!
//
BOOLEAN
SpxCheckPnpPowerFlags(IN PCOMMON_OBJECT_DATA pDevExt, IN ULONG ulSetFlags, IN ULONG ulClearedFlags, IN BOOLEAN bAll)
{
	KIRQL oldIrql;
	BOOLEAN bRet = FALSE; 

	KeAcquireSpinLock(&pDevExt->PnpPowerFlagsLock, &oldIrql);	
	
	if(bAll)
	{
		// If all the requested SetFlags are set
		// and if all of the requested ClearedFlags are cleared then return true.
		if(((ulSetFlags & pDevExt->PnpPowerFlags) == ulSetFlags) && !(ulClearedFlags & pDevExt->PnpPowerFlags))
			bRet = TRUE;
	}
	else
	{
		// If any of the requested SetFlags are set 
		// or if any of the requested ClearedFlags are cleared then return true.
		if((ulSetFlags & pDevExt->PnpPowerFlags) || (ulClearedFlags & ~pDevExt->PnpPowerFlags))
			bRet = TRUE;
	}


	KeReleaseSpinLock(&pDevExt->PnpPowerFlagsLock, oldIrql);
	
	return bRet;
}




PVOID 
SpxAllocateMem(IN POOL_TYPE PoolType, IN ULONG NumberOfBytes)
{
	PVOID pRet = NULL; 

	pRet = ExAllocatePoolWithTag(PoolType, NumberOfBytes, MEMORY_TAG);

	if(pRet)
		RtlZeroMemory(pRet, NumberOfBytes);				// Zero memory.

	return pRet;
}     


PVOID 
SpxAllocateMemWithQuota(IN POOL_TYPE PoolType, IN ULONG NumberOfBytes)
{
	PVOID pRet = NULL; 
	
	pRet = ExAllocatePoolWithQuotaTag(PoolType, NumberOfBytes, MEMORY_TAG);

	if(pRet)
		RtlZeroMemory(pRet, NumberOfBytes);				// Zero memory.

	return pRet;
}     


#ifndef BUILD_SPXMINIPORT
void
SpxFreeMem(PVOID pMem)
{
	ASSERT(pMem != NULL);	// Assert if the pointer is NULL.

	ExFreePool(pMem);
}
#endif

///////////////////////////////////////////////////////////////////////////////////////////
// Must be called just before an IoCompleteRequest if IrpCondition == IRP_SUBMITTED
//
///////////////////////////////////////////////////////////////////////////////////////////
VOID
SpxIRPCounter(IN PPORT_DEVICE_EXTENSION pPort, IN PIRP pIrp, IN ULONG IrpCondition)
{
	PIO_STACK_LOCATION	pIrpStack = IoGetCurrentIrpStackLocation(pIrp);

	switch(pIrpStack->MajorFunction)		// Don't filter Plug and Play IRPs 
	{

	case IRP_MJ_FLUSH_BUFFERS:
		{
			switch(IrpCondition)
			{
			case IRP_SUBMITTED:
				pPort->PerfStats.FlushIrpsSubmitted++;	// Increment counter for performance stats.
				break;
			
			case IRP_COMPLETED:
				{
					switch(pIrp->IoStatus.Status)
					{	
					case STATUS_SUCCESS:
						pPort->PerfStats.FlushIrpsCompleted++;	// Increment counter for performance stats.
						break;

					case STATUS_CANCELLED:
						pPort->PerfStats.FlushIrpsCancelled++;	// Increment counter for performance stats.
						break;

					default:
						pPort->PerfStats.FlushIrpsCompleted++;	// Increment counter for performance stats.
						break;
					}
				
					break;
				}

			case IRP_QUEUED:
//				InterlockedIncrement(&pPort->PerfStats.FlushIrpsQueued);
				pPort->PerfStats.FlushIrpsQueued++;		// Increment counter for performance stats.
				break;
			
			case IRP_DEQUEUED:
//				InterlockedDecrement(&pPort->PerfStats.FlushIrpsQueued);
				if(pPort->PerfStats.FlushIrpsQueued) 
					pPort->PerfStats.FlushIrpsQueued--;		// Decrement counter for performance stats.

				break;


			default:
				break;
			}

			break;
		}


	case IRP_MJ_WRITE:
		{
			switch(IrpCondition)
			{
			case IRP_SUBMITTED:
				pPort->PerfStats.WriteIrpsSubmitted++;	// Increment counter for performance stats.
				break;
			
			case IRP_COMPLETED:
				{
					switch(pIrp->IoStatus.Status)
					{	
					case STATUS_SUCCESS:
						pPort->PerfStats.WriteIrpsCompleted++;	// Increment counter for performance stats.
						break;

					case STATUS_CANCELLED:
						pPort->PerfStats.WriteIrpsCancelled++;	// Increment counter for performance stats.
						break;

					case STATUS_TIMEOUT:
						pPort->PerfStats.WriteIrpsTimedOut++;	// Increment counter for performance stats.
						break;

					default:
						pPort->PerfStats.WriteIrpsCompleted++;	// Increment counter for performance stats.
						break;
					}
				
					break;
				}

			case IRP_QUEUED:
//				InterlockedIncrement(&pPort->PerfStats.WriteIrpsQueued);
				pPort->PerfStats.WriteIrpsQueued++;		// Increment counter for performance stats.
				break;
			
			case IRP_DEQUEUED:
//				InterlockedDecrement(&pPort->PerfStats.WriteIrpsQueued);
				if(pPort->PerfStats.WriteIrpsQueued) 
					pPort->PerfStats.WriteIrpsQueued--;		// Decrement counter for performance stats.

				break;

			default:
				break;
			}

			break;
		}

	case IRP_MJ_READ:
		{
			switch(IrpCondition)
			{
			case IRP_SUBMITTED:
				pPort->PerfStats.ReadIrpsSubmitted++;	// Increment counter for performance stats.
				break;
			
			case IRP_COMPLETED:
				{
					switch(pIrp->IoStatus.Status)
					{	
					case STATUS_SUCCESS:
						pPort->PerfStats.ReadIrpsCompleted++;	// Increment counter for performance stats.
						break;

					case STATUS_CANCELLED:
						pPort->PerfStats.ReadIrpsCancelled++;	// Increment counter for performance stats.
						break;

					case STATUS_TIMEOUT:
						pPort->PerfStats.ReadIrpsTimedOut++;	// Increment counter for performance stats.
						break;

					default:
						pPort->PerfStats.ReadIrpsCompleted++;	// Increment counter for performance stats.
						break;
					}
				
					break;
				}

			case IRP_QUEUED:
//				InterlockedIncrement(&pPort->PerfStats.ReadIrpsQueued);
				pPort->PerfStats.ReadIrpsQueued++;		// Increment counter for performance stats.
				break;
			
			case IRP_DEQUEUED:
//				InterlockedDecrement(&pPort->PerfStats.ReadIrpsQueued);
				if(pPort->PerfStats.ReadIrpsQueued) 
					pPort->PerfStats.ReadIrpsQueued--;		// Decrement counter for performance stats.
				
				break;


			default:
				break;
			}

			break;
		}

	case IRP_MJ_DEVICE_CONTROL:
		{
			switch(IrpCondition)
			{
			case IRP_SUBMITTED:
				pPort->PerfStats.IoctlIrpsSubmitted++;	// Increment counter for performance stats.
				break;
			
			case IRP_COMPLETED:
				{
					switch(pIrp->IoStatus.Status)
					{	
					case STATUS_SUCCESS:
						pPort->PerfStats.IoctlIrpsCompleted++;	// Increment counter for performance stats.
						break;

					case STATUS_CANCELLED:
						pPort->PerfStats.IoctlIrpsCancelled++;	// Increment counter for performance stats.
						break;

					default:
						pPort->PerfStats.IoctlIrpsCompleted++;	// Increment counter for performance stats.
						break;
					}
				
					break;
				}

			default:
				break;
			}

			break;
		}

	case IRP_MJ_INTERNAL_DEVICE_CONTROL:
		{
			switch(IrpCondition)
			{
			case IRP_SUBMITTED:
				pPort->PerfStats.InternalIoctlIrpsSubmitted++;	// Increment counter for performance stats.
				break;
			
			case IRP_COMPLETED:
				{
					switch(pIrp->IoStatus.Status)
					{	
					case STATUS_SUCCESS:
						pPort->PerfStats.InternalIoctlIrpsCompleted++;	// Increment counter for performance stats.
						break;

					case STATUS_CANCELLED:
						pPort->PerfStats.InternalIoctlIrpsCancelled++;	// Increment counter for performance stats.
						break;

					default:
						pPort->PerfStats.InternalIoctlIrpsCompleted++;	// Increment counter for performance stats.
						break;
					}
				
					break;
				}

			default:
				break;
			}

			break;
		}


	case IRP_MJ_CREATE:
		{
			switch(IrpCondition)
			{
			case IRP_SUBMITTED:
				pPort->PerfStats.CreateIrpsSubmitted++;	// Increment counter for performance stats.
				break;
			
			case IRP_COMPLETED:
				{
					switch(pIrp->IoStatus.Status)
					{	
					case STATUS_SUCCESS:
						pPort->PerfStats.CreateIrpsCompleted++;	// Increment counter for performance stats.
						break;

					case STATUS_CANCELLED:
						pPort->PerfStats.CreateIrpsCancelled++;	// Increment counter for performance stats.
						break;

					default:
						pPort->PerfStats.CreateIrpsCompleted++;	// Increment counter for performance stats.
						break;
					}
				
					break;
				}

			default:
				break;
			}

			break;
		}

	case IRP_MJ_CLOSE:
		{
			switch(IrpCondition)
			{
			case IRP_SUBMITTED:
				pPort->PerfStats.CloseIrpsSubmitted++;	// Increment counter for performance stats.
				break;
			
			case IRP_COMPLETED:
				{
					switch(pIrp->IoStatus.Status)
					{	
					case STATUS_SUCCESS:
						pPort->PerfStats.CloseIrpsCompleted++;	// Increment counter for performance stats.
						break;

					case STATUS_CANCELLED:
						pPort->PerfStats.CloseIrpsCancelled++;	// Increment counter for performance stats.
						break;

					default:
						pPort->PerfStats.CloseIrpsCompleted++;	// Increment counter for performance stats.
						break;
					}
				
					break;
				}

			default:
				break;
			}

			break;
		}

	case IRP_MJ_CLEANUP:
		{
			switch(IrpCondition)
			{
			case IRP_SUBMITTED:
				pPort->PerfStats.CleanUpIrpsSubmitted++;	// Increment counter for performance stats.
				break;
			
			case IRP_COMPLETED:
				{
					switch(pIrp->IoStatus.Status)
					{	
					case STATUS_SUCCESS:
						pPort->PerfStats.CleanUpIrpsCompleted++;	// Increment counter for performance stats.
						break;

					case STATUS_CANCELLED:
						pPort->PerfStats.CleanUpIrpsCancelled++;	// Increment counter for performance stats.
						break;

					default:
						pPort->PerfStats.CleanUpIrpsCompleted++;	// Increment counter for performance stats.
						break;
					}
				
					break;
				}

			default:
				break;
			}

			break;
		}

	case IRP_MJ_QUERY_INFORMATION:
	case IRP_MJ_SET_INFORMATION:
		{
			switch(IrpCondition)
			{
			case IRP_SUBMITTED:
				pPort->PerfStats.InfoIrpsSubmitted++;	// Increment counter for performance stats.
				break;
			
			case IRP_COMPLETED:
				{
					switch(pIrp->IoStatus.Status)
					{	
					case STATUS_SUCCESS:
						pPort->PerfStats.InfoIrpsCompleted++;	// Increment counter for performance stats.
						break;

					case STATUS_CANCELLED:
						pPort->PerfStats.InfoIrpsCancelled++;	// Increment counter for performance stats.
						break;

					default:
						pPort->PerfStats.InfoIrpsCompleted++;	// Increment counter for performance stats.
						break;
					}
				
					break;
				}

			default:
				break;
			}

			break;
		}
	
	default:
		break;

	}
}


////////////////////////////////////////////////////////////////////////////////
// Prototype: BOOLEAN SpxClearAllPortStats(IN PPORT_DEVICE_EXTENSION pPort)
//
// Routine Description:
//    In sync with the interrpt service routine (which sets the perf stats)
//    clear the perf stats.
//
// Arguments:
//    pPort - Pointer to a the Port Device Extension.
//
////////////////////////////////////////////////////////////////////////////////
BOOLEAN SpxClearAllPortStats(IN PPORT_DEVICE_EXTENSION pPort)
{
    RtlZeroMemory(&pPort->PerfStats, sizeof(PORT_PERFORMANCE_STATS));

	return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\spx\speed\driver\spx_init.c ===
#include "precomp.h"	// Precompiled header

/****************************************************************************************
*																						*
*	Module:			SPX_INIT.C															*
*																						*
*	Creation:		27th September 1998													*
*																						*
*	Author:			Paul Smith															*
*																						*
*	Version:		1.0.0																*
*																						*
*	Description:	This module contains the code that load the driver.					*
*																						*
****************************************************************************************/


#define FILE_ID	SPX_INIT_C		// File ID for Event Logging see SPX_DEFS.H for values.


// Function Prototypes 
NTSTATUS DriverEntry(IN PDRIVER_OBJECT DriverObject, IN PUNICODE_STRING RegistryPath);
// End function prototypes.

// Paging.. 
#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, DriverEntry)
#pragma alloc_text(PAGE, DriverUnload)
#endif

// Gloabal Driver Data
UNICODE_STRING	SavedRegistryPath;

#if DBG
ULONG SpxDebugLevel = 0;		// Debug level for checked build
#endif


//////////////////////////////////////////////////////////////////////////////////////////
//	DriverEntry - Load first and initialises entry points.								//
//////////////////////////////////////////////////////////////////////////////////////////
/*
Routine Description:

    The entry point that the system point calls to initialize
    any driver.

Arguments:

    DriverObject - Just what it says,  really of little use
    to the driver itself, it is something that the IO system
    cares more about.

    RegistryPath - points to the entry for this driver
    in the current control set of the registry.

Return Value:

    STATUS_SUCCESS 
*/
NTSTATUS
DriverEntry(IN PDRIVER_OBJECT DriverObject, IN PUNICODE_STRING RegistryPath)
{
	// Holds status information return by various OS and driver initialization routines.
	NTSTATUS status;

	// We use this to query into the registry as to whether we should break at driver entry.
	RTL_QUERY_REGISTRY_TABLE paramTable[3];
	ULONG zero			= 0;
	ULONG debugLevel	= 0;
	ULONG shouldBreak	= 0;		
	PWCHAR path			= NULL;

	PAGED_CODE();	// Macro in checked build to assert if pagable code is run at or above dispatch IRQL 

	#if DBG
		DbgPrint( "%s: In DriverEntry\n", PRODUCT_NAME);
	#endif


	// Store Registry Path
	SavedRegistryPath.MaximumLength	= RegistryPath->MaximumLength;
	SavedRegistryPath.Length		= RegistryPath->Length;
	SavedRegistryPath.Buffer		= SpxAllocateMem(PagedPool, SavedRegistryPath.MaximumLength);

	if(SavedRegistryPath.Buffer)
	{
		RtlMoveMemory(SavedRegistryPath.Buffer, RegistryPath->Buffer, RegistryPath->Length);
	
		RtlZeroMemory(&paramTable[0], sizeof(paramTable));
		paramTable[0].Flags = RTL_QUERY_REGISTRY_DIRECT;
		paramTable[0].Name = L"BreakOnEntry";
		paramTable[0].EntryContext = &shouldBreak;
		paramTable[0].DefaultType = REG_DWORD;
		paramTable[0].DefaultData = &zero;
		paramTable[0].DefaultLength = sizeof(ULONG);
		paramTable[1].Flags = RTL_QUERY_REGISTRY_DIRECT;
		paramTable[1].Name = L"DebugLevel";
		paramTable[1].EntryContext = &debugLevel;
		paramTable[1].DefaultType = REG_DWORD;
		paramTable[1].DefaultData = &zero;
		paramTable[1].DefaultLength = sizeof(ULONG);

		if(!SPX_SUCCESS(status = RtlQueryRegistryValues(RTL_REGISTRY_ABSOLUTE | RTL_REGISTRY_OPTIONAL,
														RegistryPath->Buffer, &paramTable[0], 
														NULL, NULL)))
		{
			shouldBreak = 0;
			debugLevel	= 0;
		}

	}
	else
		status = STATUS_INSUFFICIENT_RESOURCES;


 	#if DBG
		SpxDebugLevel = debugLevel;	
	//	SpxDebugLevel = (ULONG)-1;			// Prints all debug messages

	//	shouldBreak = 1;	// HARD CODED BREAKPOINT WITH CHECKED BUILD !!!
	#endif


	if(shouldBreak)
	{
		DbgBreakPoint();	// Break Debugger.
	}


	if(SPX_SUCCESS(status))
	{
		// Initialize the Driver Object with driver's entry points
		DriverObject->DriverUnload									= DriverUnload;
		DriverObject->DriverExtension->AddDevice					= Spx_AddDevice;
		DriverObject->MajorFunction[IRP_MJ_PNP]						= Spx_DispatchPnp;
		DriverObject->MajorFunction[IRP_MJ_POWER]					= Spx_DispatchPower;
		DriverObject->MajorFunction[IRP_MJ_FLUSH_BUFFERS]			= Spx_Flush;
		DriverObject->MajorFunction[IRP_MJ_WRITE]					= Spx_Write;
		DriverObject->MajorFunction[IRP_MJ_READ]					= Spx_Read;
		DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL]			= Spx_IoControl;
		DriverObject->MajorFunction[IRP_MJ_INTERNAL_DEVICE_CONTROL]	= Spx_InternalIoControl;
		DriverObject->MajorFunction[IRP_MJ_CREATE]					= Spx_CreateOpen;
		DriverObject->MajorFunction[IRP_MJ_CLOSE]					= Spx_Close;
		DriverObject->MajorFunction[IRP_MJ_CLEANUP]					= Spx_Cleanup;
		DriverObject->MajorFunction[IRP_MJ_QUERY_INFORMATION]		= Spx_QueryInformationFile;
		DriverObject->MajorFunction[IRP_MJ_SET_INFORMATION]			= Spx_SetInformationFile;
#ifdef WMI_SUPPORT
		DriverObject->MajorFunction[IRP_MJ_SYSTEM_CONTROL]			= Spx_DispatchSystemControl;
#endif
		
	}
	else
	{
		// Free
		if(SavedRegistryPath.Buffer)
		{
			SpxFreeMem(SavedRegistryPath.Buffer);
			SavedRegistryPath.Buffer = NULL;
		}
	}


	return(status);

}	// DriverEntry 




//////////////////////////////////////////////////////////////////////////////////////////
//	DriverUnload - Called as driver unloads.											
//////////////////////////////////////////////////////////////////////////////////////////
VOID 
DriverUnload(IN PDRIVER_OBJECT pDriverObject)
/*++

Routine Description:

    This routine cleans up all of the resources allocated in DriverEntry.

Arguments:

    pDriverObject - Pointer to the driver object controling all of the
					devices.

Return Value:

    None.

--*/
{
	PAGED_CODE();
	
	SpxDbgMsg(SPX_TRACE_CALLS, ("%s: Entering DriverUnload\n", PRODUCT_NAME));

	// All Device Objects must have been deleted by now.
    ASSERT (pDriverObject->DeviceObject == NULL);

	// Free
	if(SavedRegistryPath.Buffer)
	{
		SpxFreeMem(SavedRegistryPath.Buffer);
		SavedRegistryPath.Buffer = NULL;
	}


	return;
}


// End of SPX_INIT.C
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\spx\speed\driver\spd_pnp.c ===
#include "precomp.h"

/////////////////////////////////////////////////////////////////////////////////////
//  This file contains all functions that are needed to integrate between the 
//  generic PnP code and the product specific code.
/////////////////////////////////////////////////////////////////////////////////////

#define FILE_ID		SPD_PNP_C		// File ID for Event Logging see SPD_DEFS.H for values.


// Prototypes
// End of Prototypes

NTSTATUS
XXX_CardGetResources(IN PDEVICE_OBJECT pDevObject,
					 IN PCM_RESOURCE_LIST PResList,
					 IN PCM_RESOURCE_LIST PTrResList) 	
/* ++
Routine Description:

	Stores resources given to us by the PnP manager 
	in the card's device extension.

Arguments:

    pDevObject - Pointer to the device object.
    
    PResList - Pointer to the untranslated resources requested.
    
    PTrResList - Pointer to the translated resources requested.

Return Value:

    STATUS_SUCCESS.

--*/
{

	PCARD_DEVICE_EXTENSION pCard		= pDevObject->DeviceExtension;
	NTSTATUS status						= STATUS_NOT_IMPLEMENTED;

	CHAR szErrorMsg[MAX_ERROR_LOG_INSERT];	// Limited to 51 characters + 1 null 
	ULONG count				= 0;
	ULONG i					= 0;
	USHORT MemoryResource	= 0;
	USHORT IOResource		= 0;

	PCM_FULL_RESOURCE_DESCRIPTOR	pFullResourceDesc		= NULL;
	PCM_PARTIAL_RESOURCE_LIST		pPartialResourceList	= NULL;
	PCM_PARTIAL_RESOURCE_DESCRIPTOR	pPartialResourceDesc	= NULL;

	PAGED_CODE();	// Macro in checked build to assert if pagable code is run at or above dispatch IRQL 

	SpxDbgMsg(SPX_TRACE_CALLS, ("%s: Entering XXX_CardGetResources for Card %d.\n", 
		PRODUCT_NAME, pCard->CardNumber));

	SpxDbgMsg(SPX_MISC_DBG, ("%s: Resource pointer is 0x%X\n", PRODUCT_NAME, PResList));
	SpxDbgMsg(SPX_MISC_DBG, ("%s: Translated resource pointer is 0x%X\n", PRODUCT_NAME, PTrResList));

	if((PResList == NULL) || (PTrResList == NULL)) 
	{
		// This shouldn't happen in theory
		ASSERT(PResList != NULL);
		ASSERT(PTrResList != NULL);

		sprintf(szErrorMsg, "Card %d has been given no resources.", pCard->CardNumber);
		
		Spx_LogMessage(	STATUS_SEVERITY_ERROR,
						pCard->DriverObject,		// Driver Object
						pCard->DeviceObject,		// Device Object (Optional)
						PhysicalZero,				// Physical Address 1
						PhysicalZero,				// Physical Address 2
						0,							// SequenceNumber
						0,							// Major Function Code
						0,							// RetryCount
						FILE_ID | __LINE__,			// UniqueErrorValue
						STATUS_SUCCESS,				// FinalStatus
						szErrorMsg);				// Error Message

		// This status is as appropriate as I can think of
		return STATUS_INSUFFICIENT_RESOURCES;
	}

	// Each resource list should have only one set of resources
	ASSERT(PResList->Count == 1);
	ASSERT(PTrResList->Count == 1);

	// Find out the card type... 
	if((pCard->CardType = SpxGetNtCardType(pCard->DeviceObject)) == -1)
	{
		sprintf(szErrorMsg, "Card %d is unrecognised.", pCard->CardNumber);

		Spx_LogMessage(	STATUS_SEVERITY_ERROR,
						pCard->DriverObject,			// Driver Object
						pCard->DeviceObject,			// Device Object (Optional)
						PhysicalZero,					// Physical Address 1
						PhysicalZero,					// Physical Address 2
						0,								// SequenceNumber
						0,								// Major Function Code
						0,								// RetryCount
						FILE_ID | __LINE__,				// UniqueErrorValue
						STATUS_SUCCESS,					// FinalStatus
						szErrorMsg);					// Error Message


		return(STATUS_DEVICE_DOES_NOT_EXIST);
	}


	// Find out which raw resources have been given to us.
	pFullResourceDesc = &PResList->List[0];

	if(pFullResourceDesc)
	{
		pPartialResourceList    = &pFullResourceDesc->PartialResourceList;
		pPartialResourceDesc    = pPartialResourceList->PartialDescriptors;
		count                   = pPartialResourceList->Count;	// Number of Partial Resource Descriptors

		// Pull out the stuff that is in the full descriptor.
		pCard->InterfaceType	= pFullResourceDesc->InterfaceType;
		pCard->BusNumber		= pFullResourceDesc->BusNumber;

		// Now run through the partial resource descriptors looking for the port and interrupt.
		for(i = 0; i < count; i++, pPartialResourceDesc++) 
		{
			switch(pPartialResourceDesc->Type) 
			{

			case CmResourceTypeMemory:
				break;

			case CmResourceTypePort: 
				{
					switch(pCard->CardType)
					{
					case Fast4_Isa:
					case Fast8_Isa:
					case Fast16_Isa:
					case Fast4_Pci:
					case Fast8_Pci:
					case Fast16_Pci:
					case Fast16FMC_Pci:
					case RAS4_Pci:
					case RAS8_Pci:
						pCard->PhysAddr			= pPartialResourceDesc->u.Memory.Start;
						pCard->SpanOfController	= pPartialResourceDesc->u.Memory.Length;
						break;

					default:	// Speed cards
						break;
					}

					IOResource++;
					break;
				}

			case CmResourceTypeInterrupt: 
				{
					pCard->OriginalIrql		= pPartialResourceDesc->u.Interrupt.Level;
					pCard->OriginalVector	= pPartialResourceDesc->u.Interrupt.Vector;
					pCard->ProcessorAffinity= pPartialResourceDesc->u.Interrupt.Affinity;

					if(pPartialResourceDesc->Flags & CM_RESOURCE_INTERRUPT_LATCHED)
						pCard->InterruptMode	= Latched;
					else
						pCard->InterruptMode	= LevelSensitive; 

					switch(pPartialResourceDesc->ShareDisposition)
					{
					case CmResourceShareDeviceExclusive:
						pCard->InterruptShareable	= FALSE;
						break;

					case CmResourceShareDriverExclusive:
						pCard->InterruptShareable	= FALSE;
						break;

					case CmResourceShareShared:
					default:
						pCard->InterruptShareable	= TRUE;
						break;
					}

					break;
				}

			default:
				break;

			}

		}
	}

	// Do the same for the translated resources.
	pFullResourceDesc = &PTrResList->List[0];

	if(pFullResourceDesc)
	{
		pPartialResourceList	= &pFullResourceDesc->PartialResourceList;
		pPartialResourceDesc	= pPartialResourceList->PartialDescriptors;
		count					= pPartialResourceList->Count;	// Number of Partial Resource Descriptors

		// Pull out the stuff that is in the full descriptor.
		pCard->InterfaceType		= pFullResourceDesc->InterfaceType;
		pCard->BusNumber			= pFullResourceDesc->BusNumber;

		// Now run through the partial resource descriptors looking for the interrupt,
		for(i = 0; i < count; i++, pPartialResourceDesc++) 
		{
			switch(pPartialResourceDesc->Type) 
			{

			case CmResourceTypeMemory: 
				{
					switch(pCard->CardType)
					{
					case Fast4_Isa:
					case Fast8_Isa:
					case Fast16_Isa:
						break;		// No Memory resource for these

					case Fast4_Pci:
					case Fast8_Pci:
					case Fast16_Pci:
					case Fast16FMC_Pci:
					case RAS4_Pci:
					case RAS8_Pci:
						{	// Must be config space 
							pCard->PCIConfigRegisters		= pPartialResourceDesc->u.Memory.Start;
							pCard->SpanOfPCIConfigRegisters	= pPartialResourceDesc->u.Memory.Length;
							break;
						}

					default:	// Speed cards
						{
							if(MemoryResource == 0)	
							{
								pCard->PhysAddr			= pPartialResourceDesc->u.Memory.Start;
								pCard->SpanOfController	= pPartialResourceDesc->u.Memory.Length;
							}
							else
							{	// Must be config space 
								pCard->PCIConfigRegisters		= pPartialResourceDesc->u.Memory.Start;
								pCard->SpanOfPCIConfigRegisters	= pPartialResourceDesc->u.Memory.Length;
							}

							break;
						}

					}
		
					MemoryResource++;
					break;
				}
			
			case CmResourceTypePort: 
				break;

			case CmResourceTypeInterrupt: 
				{
					pCard->TrIrql				= (KIRQL) pPartialResourceDesc->u.Interrupt.Level;
					pCard->TrVector				= pPartialResourceDesc->u.Interrupt.Vector;
					pCard->ProcessorAffinity	= pPartialResourceDesc->u.Interrupt.Affinity;
					break;
				}

			default:
				break;
			}
		}
	}

	// If we have 1 Mem or 1 I/O Resources and an interrupt the resource allocation most probably succeeded.
	if(((MemoryResource >= 1) || (IOResource >= 1)) && (pCard->TrVector))
		status = STATUS_SUCCESS;

	return status;
}




NTSTATUS
XXX_CardInit(IN PCARD_DEVICE_EXTENSION pCard)
{
	NTSTATUS status = STATUS_SUCCESS;

	PAGED_CODE();	// Macro in checked build to assert if pagable code is run at or above dispatch IRQL 

	SpxDbgMsg(SPX_TRACE_CALLS, ("%s: Entering XXX_CardInit for Card %d.\n", 
		PRODUCT_NAME, pCard->CardNumber));



    pCard->OurIsr			= SerialISR;
    pCard->OurIsrContext	= pCard;


	return status;
}

NTSTATUS
XXX_CardStart(IN PCARD_DEVICE_EXTENSION pCard)
{
	NTSTATUS status = STATUS_SUCCESS;
	UCHAR CardID	= 0;
	CHAR szErrorMsg[MAX_ERROR_LOG_INSERT];	// Limited to 51 characters + 1 null 
	BOOLEAN bInterruptConnnected = FALSE;
	
	PAGED_CODE();	// Macro in checked build to assert if pagable code is run at or above dispatch IRQL 

	SpxDbgMsg(SPX_TRACE_CALLS, ("%s: Entering XXX_CardStart for Card %d.\n", 
		PRODUCT_NAME, pCard->CardNumber));

	switch(pCard->CardType)
	{	
	case Fast4_Isa:
	case Fast4_Pci:
	case RAS4_Pci:
		pCard->UARTOffset = 8;			// I/O address offset between UARTs
		pCard->UARTRegStride = 1;
		pCard->NumberOfPorts = 4;
		pCard->ClockRate = CLOCK_FREQ_7M3728Hz;		// 7.3728 MHz
		pCard->Controller = (PUCHAR) pCard->PhysAddr.LowPart;

		if(UL_InitUartLibrary(&pCard->UartLib, UL_LIB_16C65X_UART) != UL_STATUS_SUCCESS)	// Init table of UART library functions pointers.
			goto Error;

		break;

	case Fast8_Isa:
	case Fast8_Pci:
	case RAS8_Pci:
		pCard->UARTOffset = 8;			// I/O address offset between UARTs
		pCard->UARTRegStride = 1;
		pCard->NumberOfPorts = 8;
		pCard->ClockRate = CLOCK_FREQ_7M3728Hz;		// 7.3728 MHz
		pCard->Controller = (PUCHAR) pCard->PhysAddr.LowPart;

		if(UL_InitUartLibrary(&pCard->UartLib, UL_LIB_16C65X_UART) != UL_STATUS_SUCCESS)	// Init table of UART library functions pointers.
			goto Error;

		break;

	case Fast16_Isa:
	case Fast16_Pci:
	case Fast16FMC_Pci:
		pCard->UARTOffset = 8;			// I/O address offset between UARTs
		pCard->UARTRegStride = 1;
		pCard->NumberOfPorts = 16;
		pCard->ClockRate = CLOCK_FREQ_7M3728Hz;		// 7.3728 MHz
		pCard->Controller = (PUCHAR) pCard->PhysAddr.LowPart;

		if(UL_InitUartLibrary(&pCard->UartLib, UL_LIB_16C65X_UART) != UL_STATUS_SUCCESS)	// Init table of UART library functions pointers.
			goto Error;

		break;

	case Speed2_Pci:
		pCard->UARTOffset = OXPCI_INTERNAL_MEM_OFFSET;		// Memory address offset between internal UARTs
		pCard->UARTRegStride = 4;
		pCard->NumberOfPorts = 2;
		pCard->ClockRate = CLOCK_FREQ_1M8432Hz;		// 1.8432 MHz
		pCard->Controller = MmMapIoSpace(pCard->PhysAddr, pCard->SpanOfController, FALSE);	// Map in the card's memory base address

		if(UL_InitUartLibrary(&pCard->UartLib, UL_LIB_16C95X_UART) != UL_STATUS_SUCCESS)	// Init table of UART library functions pointers.
			goto Error;

		break;

	case Speed2P_Pci:
		pCard->UARTOffset = OXPCI_INTERNAL_MEM_OFFSET;		// Memory address offset between internal UARTs
		pCard->UARTRegStride = 4;
		pCard->NumberOfPorts = 2;
		pCard->ClockRate = CLOCK_FREQ_14M7456Hz;	// 14.7456 MHz
		pCard->Controller = MmMapIoSpace(pCard->PhysAddr, pCard->SpanOfController, FALSE);	// Map in the card's memory base address

		if(UL_InitUartLibrary(&pCard->UartLib, UL_LIB_16C95X_UART) != UL_STATUS_SUCCESS)	// Init table of UART library functions pointers.
			goto Error;

		break;

	case Speed4_Pci:
		pCard->UARTOffset = OXPCI_INTERNAL_MEM_OFFSET;		// Memory address offset between internal UARTs
		pCard->UARTRegStride = 4;
		pCard->NumberOfPorts = 4;
		pCard->ClockRate = CLOCK_FREQ_1M8432Hz;		// 1.8432 MHz
		pCard->Controller = MmMapIoSpace(pCard->PhysAddr, pCard->SpanOfController, FALSE);	// Map in the card's memory base address

		if(UL_InitUartLibrary(&pCard->UartLib, UL_LIB_16C95X_UART) != UL_STATUS_SUCCESS)	// Init table of UART library functions pointers.
			goto Error;

		break;

	case Speed4P_Pci:
		pCard->UARTOffset = OXPCI_INTERNAL_MEM_OFFSET;		// Memory address offset between internal UARTs
		pCard->UARTRegStride = 4;
		pCard->NumberOfPorts = 4;
		pCard->ClockRate = CLOCK_FREQ_14M7456Hz;	// 14.7456 MHz
		pCard->Controller = MmMapIoSpace(pCard->PhysAddr, pCard->SpanOfController, FALSE);	// Map in the card's memory base address

		if(UL_InitUartLibrary(&pCard->UartLib, UL_LIB_16C95X_UART) != UL_STATUS_SUCCESS)	// Init table of UART library functions pointers.
			goto Error;

		break;

	case Speed2and4_Pci_8BitBus:
		pCard->UARTOffset = OXPCI_LOCAL_MEM_OFFSET;			// Memory address offset between local bus UARTs
		pCard->UARTRegStride = 4;
		pCard->NumberOfPorts = 0;	// No ports.
		pCard->ClockRate = CLOCK_FREQ_1M8432Hz;
		pCard->Controller = MmMapIoSpace(pCard->PhysAddr, pCard->SpanOfController, FALSE);	// Map in the card's memory base address
		break;

	case Speed2P_Pci_8BitBus:
	case Speed4P_Pci_8BitBus:
		pCard->UARTOffset = OXPCI_LOCAL_MEM_OFFSET;			// Memory address offset between local bus UARTs
		pCard->UARTRegStride = 4;
		pCard->NumberOfPorts = 0;	// No ports on a Speed2/4+ card.
		pCard->ClockRate = CLOCK_FREQ_14M7456Hz;
		pCard->Controller = MmMapIoSpace(pCard->PhysAddr, pCard->SpanOfController, FALSE);	// Map in the card's memory base address
		break;

	default:
		pCard->NumberOfPorts = 0;	// Default = No ports.
		break;
	}



// Map in the card's memory base address

	if(!pCard->Controller)
	{
		status = STATUS_INSUFFICIENT_RESOURCES;
		goto Error;
	}

// Map in the card's Local Configuration Registers... 
	if(pCard->InterfaceType == PCIBus)	// If we have some PCI config registers
	{
		pCard->LocalConfigRegisters = MmMapIoSpace(pCard->PCIConfigRegisters, pCard->SpanOfPCIConfigRegisters, FALSE);

		if(!pCard->LocalConfigRegisters)
		{
			status = STATUS_INSUFFICIENT_RESOURCES;
			goto Error;
		}
	}


	// Try to connect to interrupt.
	if(SPX_SUCCESS(status = IoConnectInterrupt(&pCard->Interrupt,			// Interrupt object
												pCard->OurIsr,				// Service routine  
												pCard->OurIsrContext,		// Service context 
												NULL,						// SpinLock (optional) 
												pCard->TrVector,			// Vector 
												pCard->TrIrql,				// IRQL 
												pCard->TrIrql,				// Synchronize IRQL
												pCard->InterruptMode,		// Mode (Latched/Level Sensitive) 
												pCard->InterruptShareable,	// Sharing mode 
												pCard->ProcessorAffinity,	// Processors to handle ints 
												FALSE)))					// Floating point save 	
	{
		bInterruptConnnected = TRUE;	// Set Interrupt Connected flag. 
	}
	else
	{	
		// Tell user the problem 
		sprintf(szErrorMsg, "Card at %08X%08X: Interrupt unavailable.", pCard->PhysAddr.HighPart, pCard->PhysAddr.LowPart);

		Spx_LogMessage(	STATUS_SEVERITY_ERROR,
						pCard->DriverObject,		// Driver Object
						pCard->DeviceObject,		// Device Object (Optional)
						PhysicalZero,				// Physical Address 1
						PhysicalZero,				// Physical Address 2
						0,							// SequenceNumber
						0,							// Major Function Code
						0,							// RetryCount
						FILE_ID | __LINE__,			// UniqueErrorValue
						STATUS_SUCCESS,				// FinalStatus
						szErrorMsg);				// Error Message
		
		goto Error;
	}


	switch(pCard->CardType)
	{	
	case Fast4_Isa:		// If ISA card try to verify the card is present at selected address
	case Fast8_Isa:		// by trying to verify first UART on the Card.
	case Fast16_Isa:
		{
			INIT_UART InitUart = {0};

			// Set base address of 1st UART
			InitUart.UartNumber		= 0;
			InitUart.BaseAddress	= pCard->Controller;
			InitUart.RegisterStride = pCard->UARTRegStride;
			InitUart.ClockFreq		= pCard->ClockRate; 
			
			pCard->pFirstUart = NULL;

			// Init a UART structure.
			if(pCard->UartLib.UL_InitUart_XXXX(&InitUart, pCard->pFirstUart, &(pCard->pFirstUart)) != UL_STATUS_SUCCESS)
			{
				status = STATUS_INSUFFICIENT_RESOURCES;
				goto Error;
			}

			// Reset and try to verify the UART.
			if(!KeSynchronizeExecution(pCard->Interrupt, SerialResetAndVerifyUart, pCard->DeviceObject))	// Verify UART exists.
			{
				SpxDbgMsg(SPX_TRACE_CALLS, ("%s: Failed to find 1st UART on Card %d.\n", PRODUCT_NAME, pCard->CardNumber));
				pCard->UartLib.UL_DeInitUart_XXXX(pCard->pFirstUart);	// DeInit UART
				status = STATUS_DEVICE_DOES_NOT_EXIST;
				goto Error;
			}

			// DeInit the UART structure.
			pCard->UartLib.UL_DeInitUart_XXXX(pCard->pFirstUart);	// DeInit UART
			
			pCard->pFirstUart = NULL;
		}
	
	default:
		break;
	}



	switch(pCard->CardType)
	{	
	case Speed2and4_Pci_8BitBus:
	case Speed2P_Pci_8BitBus:
	case Speed4P_Pci_8BitBus:
		break;

	default:
		GetCardSettings(pCard->DeviceObject);	// Get Card settings if present.

#ifdef WMI_SUPPORT
		// Register for WMI
		SpeedCard_WmiInitializeWmilibContext(&pCard->WmiLibInfo);
		IoWMIRegistrationControl(pCard->DeviceObject, WMIREG_ACTION_REGISTER);
#endif
		break;
	}


	return status;


Error:

	if(bInterruptConnnected)
		IoDisconnectInterrupt(pCard->Interrupt);	// Disconnect Interrupt.

	switch(pCard->CardType)
	{	
	case Fast4_Isa:
	case Fast8_Isa:
	case Fast16_Isa:	
	case Fast4_Pci:
	case Fast8_Pci:
	case Fast16_Pci:
	case Fast16FMC_Pci:
	case RAS4_Pci:
	case RAS8_Pci:
		pCard->Controller = NULL;
		break;

	default:	// Speed cards
		if(pCard->Controller)	// If mapped in.
		{
			MmUnmapIoSpace(pCard->Controller, pCard->SpanOfController);	// Unmap.
			pCard->Controller = NULL;
		}

		break;
	}


	if(pCard->LocalConfigRegisters)	// If PCI Config registers are mapped in.
	{
		MmUnmapIoSpace(pCard->LocalConfigRegisters, pCard->SpanOfPCIConfigRegisters);	// Unmap.
		pCard->LocalConfigRegisters = NULL;
	}


	UL_DeInitUartLibrary(&pCard->UartLib);	// DeInit table of UART library functions pointers.

	switch(status)
	{
	case STATUS_DEVICE_DOES_NOT_EXIST:
	case STATUS_UNSUCCESSFUL:
		{
			sprintf(szErrorMsg, "Card at %08X%08X: Unrecognised or malfunctioning.", pCard->PhysAddr.HighPart, pCard->PhysAddr.LowPart);
			Spx_LogMessage(	STATUS_SEVERITY_ERROR,
							pCard->DriverObject,			// Driver Object
							pCard->DeviceObject,			// Device Object (Optional)
							PhysicalZero,					// Physical Address 1
							PhysicalZero,					// Physical Address 2
							0,								// SequenceNumber
							0,								// Major Function Code
							0,								// RetryCount
							FILE_ID | __LINE__,				// UniqueErrorValue
							STATUS_SUCCESS,					// FinalStatus
							szErrorMsg);					// Error Message

			break;
		}

	case STATUS_INSUFFICIENT_RESOURCES:
		{
			sprintf(szErrorMsg, "Card at %08X%08X: Insufficient resources.", pCard->PhysAddr.HighPart, pCard->PhysAddr.LowPart);

			Spx_LogMessage(	STATUS_SEVERITY_ERROR,
							pCard->DriverObject,			// Driver Object
							pCard->DeviceObject,			// Device Object (Optional)
							PhysicalZero,					// Physical Address 1
							PhysicalZero,					// Physical Address 2
							0,								// SequenceNumber
							0,								// Major Function Code
							0,								// RetryCount
							FILE_ID | __LINE__,				// UniqueErrorValue
							STATUS_SUCCESS,					// FinalStatus
							szErrorMsg);					// Error Message

			break;
		}

	default:
		break;

	}



	return status;
}

NTSTATUS
XXX_CardStop(IN PCARD_DEVICE_EXTENSION pCard)
{
	NTSTATUS status = STATUS_SUCCESS;

	PAGED_CODE();	// Macro in checked build to assert if pagable code is run at or above dispatch IRQL 

	SpxDbgMsg(SPX_TRACE_CALLS, ("%s: Entering XXX_CardStop for Card %d.\n", 
		PRODUCT_NAME, pCard->CardNumber));
	
	// Stop Card from interrupting

	IoDisconnectInterrupt(pCard->Interrupt);		// Disconnect from Interrupt.
	
	
#ifdef WMI_SUPPORT
	switch(pCard->CardType)
	{	
	case Speed2and4_Pci_8BitBus:
	case Speed2P_Pci_8BitBus:
	case Speed4P_Pci_8BitBus:
		break;

	default:
		// Deregister for WMI
		IoWMIRegistrationControl(pCard->DeviceObject, WMIREG_ACTION_DEREGISTER);
		break;
	}
#endif


	switch(pCard->CardType)
	{	
	case Fast4_Isa:
	case Fast8_Isa:
	case Fast16_Isa:	
	case Fast4_Pci:
	case Fast8_Pci:
	case Fast16_Pci:
	case Fast16FMC_Pci:
	case RAS4_Pci:
	case RAS8_Pci:
		pCard->Controller = NULL;
		break;

	default:	// Speed cards
		if(pCard->Controller)	// If mapped in.
		{
			MmUnmapIoSpace(pCard->Controller, pCard->SpanOfController);	// Unmap.
			pCard->Controller = NULL;
		}

		break;
	}

	// Unmap PCI card's Local Configuration Registers...
	if(pCard->LocalConfigRegisters)	// If mapped in.
	{
		MmUnmapIoSpace(pCard->LocalConfigRegisters, pCard->SpanOfPCIConfigRegisters);
		pCard->LocalConfigRegisters = NULL;
	}

	UL_DeInitUartLibrary(&pCard->UartLib);	// DeInit table of UART library functions pointers.


	pCard->InterfaceType			= InterfaceTypeUndefined;
	pCard->PhysAddr					= PhysicalZero;
	pCard->SpanOfController			= 0;
	pCard->OriginalIrql				= 0;
	pCard->OriginalVector			= 0;
	pCard->ProcessorAffinity		= 0;
	pCard->TrIrql					= 0;
	pCard->TrVector					= 0;
	pCard->Controller				= NULL;
	pCard->LocalConfigRegisters		= NULL;
	pCard->SpanOfPCIConfigRegisters = 0;

	return status;
}


NTSTATUS
XXX_CardDeInit(IN PCARD_DEVICE_EXTENSION pCard)
{
	NTSTATUS status = STATUS_SUCCESS;

	PAGED_CODE();	// Macro in checked build to assert if pagable code is run at or above dispatch IRQL 

	SpxDbgMsg(SPX_TRACE_CALLS, ("%s: Entering XXX_CardDeInit for Card %d.\n", 
		PRODUCT_NAME, pCard->CardNumber));

    pCard->OurIsr				= NULL;
    pCard->OurIsrContext		= NULL;

	pCard->pFirstUart = NULL;

	return status;
}


NTSTATUS
XXX_PortInit(IN	PPORT_DEVICE_EXTENSION pPort)
{
	// Initialise port device extension.	

	PCARD_DEVICE_EXTENSION pCard	= pPort->pParentCardExt;
	NTSTATUS status					= STATUS_SUCCESS;
	SHORT PortType = 0;
	CHAR szTemp[50];		// Space to hold string 
	CHAR szCard[10];		// Space to hold card type string 
	SHORT i = 0;
	int Result = 0;
	INIT_UART InitUart;

	PAGED_CODE();	// Macro in checked build to assert if pagable code is run at or above dispatch IRQL 

	SpxDbgMsg(SPX_TRACE_CALLS, ("%s: Entering XXX_PortInit for Port %d.\n", 
		PRODUCT_NAME, pPort->PortNumber));
	
#ifndef BUILD_SPXMINIPORT
	// Form an InstanceID for the port.
	if(!SPX_SUCCESS(status = Spx_CreatePortInstanceID(pPort)))
		return status;
#endif

	switch(pCard->CardType)
	{
	case Fast4_Isa:
	case Fast4_Pci:
		sprintf(szCard, "FAST");	// Fast card
		PortType = FAST_8PIN_RJ45;	// 8 pin RJ45 ports	with Chase pinouts
		break;

	case Fast8_Isa:
	case Fast8_Pci:
		sprintf(szCard, "FAST");	// Fast card
		PortType = FAST_8PIN_XXXX;	// 8 pin ports 
		break;

	case Fast16_Isa:
	case Fast16_Pci:
		sprintf(szCard, "FAST");	// Fast card
		PortType = FAST_6PIN_XXXX;	// 6 pin ports 
		break;

	case Fast16FMC_Pci:
		sprintf(szCard, "FAST");	// Fast card
		PortType = FAST_8PIN_XXXX;	// 8 pin Full Modem Control (FMC) ports 
		break;

 	case RAS4_Pci:
	case RAS8_Pci:
		sprintf(szCard, "SPDRAS");	// RAS card
		PortType = MODEM_PORT;		// Modem Ports
		break;

	case Speed2_Pci:
		sprintf(szCard, "SPD2");	// Speed 2 card
		PortType = SPD_8PIN_RJ45;	// 8 pin RJ45 ports
		break;

	case Speed2P_Pci:
		sprintf(szCard, "SPD2P");	// Speed 2+ card
		PortType = SPD_10PIN_RJ45;	// 10 pin RJ45 ports
		break;

	case Speed4_Pci:
		sprintf(szCard, "SPD4");	// Speed 4 card
		PortType = SPD_8PIN_RJ45;	// 8 pin RJ45 ports
		break;

	case Speed4P_Pci:
		sprintf(szCard, "SPD4P");	// Speed 4+ card
		PortType = SPD_10PIN_RJ45;	// 10 pin RJ45 ports
		break;

	default:
		sprintf(szCard, "XXX");		// Unknown card type
		break;
	}



	// Initialise device identifiers... 
	switch(PortType)
	{	
	case FAST_8PIN_RJ45:
		sprintf(szTemp,"FAST\\%s&8PINRJ45", szCard);
		Spx_InitMultiString(FALSE, &pPort->DeviceID, szTemp, NULL);

		sprintf(szTemp,"FAST\\%s&8PINRJ45", szCard);
		Spx_InitMultiString(TRUE, &pPort->HardwareIDs, szTemp, NULL);
		
		sprintf(szTemp,"Perle FAST Serial Port %d", pPort->PortNumber+1);
		Spx_InitMultiString(FALSE, &pPort->DevDesc, szTemp, NULL);
		break;

	case FAST_8PIN_XXXX:
		sprintf(szTemp,"FAST\\%s&8PINXXXX", szCard);
		Spx_InitMultiString(FALSE, &pPort->DeviceID, szTemp, NULL);

		sprintf(szTemp,"FAST\\%s&8PINXXXX", szCard);
		Spx_InitMultiString(TRUE, &pPort->HardwareIDs, szTemp, NULL);
		
		sprintf(szTemp,"Perle FAST Serial Port %d", pPort->PortNumber+1);
		Spx_InitMultiString(FALSE, &pPort->DevDesc, szTemp, NULL);
		break;

	case FAST_6PIN_XXXX:
		sprintf(szTemp,"FAST\\%s&6PINXXXX", szCard);
		Spx_InitMultiString(FALSE, &pPort->DeviceID, szTemp, NULL);

		sprintf(szTemp,"FAST\\%s&6PINXXXX", szCard);
		Spx_InitMultiString(TRUE, &pPort->HardwareIDs, szTemp, NULL);
		
		sprintf(szTemp,"Perle FAST Serial Port %d", pPort->PortNumber+1);
		Spx_InitMultiString(FALSE, &pPort->DevDesc, szTemp, NULL);
		break;

	case MODEM_PORT:
		sprintf(szTemp,"SPDRAS\\RASPort");
		Spx_InitMultiString(FALSE, &pPort->DeviceID, szTemp, NULL);

		sprintf(szTemp,"SPDRAS\\RASPort");
		Spx_InitMultiString(TRUE, &pPort->HardwareIDs, szTemp, NULL);
		
		sprintf(szTemp,"Perle RAS Port %d", pPort->PortNumber+1);
		Spx_InitMultiString(FALSE, &pPort->DevDesc, szTemp, NULL);
		break;

	case SPD_8PIN_RJ45:
		sprintf(szTemp,"SPEED\\%s&8PINRJ45", szCard);
		Spx_InitMultiString(FALSE, &pPort->DeviceID, szTemp, NULL);

		sprintf(szTemp,"SPEED\\%s&8PINRJ45", szCard);
		Spx_InitMultiString(TRUE, &pPort->HardwareIDs, szTemp, NULL);
		
		sprintf(szTemp,"Perle SPEED Serial Port %d", pPort->PortNumber+1);
		Spx_InitMultiString(FALSE, &pPort->DevDesc, szTemp, NULL);
		break;

	case SPD_10PIN_RJ45:
		sprintf(szTemp,"SPEED\\%s&10PINRJ45", szCard);
		Spx_InitMultiString(FALSE, &pPort->DeviceID, szTemp, NULL);

		sprintf(szTemp,"SPEED\\%s&10PINRJ45", szCard);
		Spx_InitMultiString(TRUE, &pPort->HardwareIDs, szTemp, NULL);
		
		sprintf(szTemp,"Perle SPEED Serial Port %d", pPort->PortNumber+1);
		Spx_InitMultiString(FALSE, &pPort->DevDesc, szTemp, NULL);
		break;

	default:
		sprintf(szTemp,"SPEED\\%s&XXXXXXXX", szCard);
		Spx_InitMultiString(FALSE, &pPort->DeviceID, szTemp, NULL);

		sprintf(szTemp,"SPEED\\%s&XXXXXXXX", szCard);
		Spx_InitMultiString(TRUE, &pPort->HardwareIDs, szTemp, NULL);

		sprintf(szTemp,"Perle Serial Port %d of Unknown Type.", pPort->PortNumber + 1);
		Spx_InitMultiString(FALSE, &pPort->DevDesc, szTemp, NULL);

		status = STATUS_UNSUCCESSFUL;
		break;
	}


/* Not required as we are using INF file 
	i = sprintf(szTemp, "Port %d on ", pPort->PortNumber + 1);

	sprintf(szTemp+i, "PCI Card 0x%08lX", pCard->PhysAddr);

	Spx_InitMultiString(FALSE, &pPort->DevLocation, szTemp, NULL);
*/



	pPort->pUartLib = &pCard->UartLib;	// Store pointer to UART library functions in port.

	// Set base address of port
	InitUart.UartNumber		= pPort->PortNumber;
	InitUart.BaseAddress	= pCard->Controller + (pPort->PortNumber * pCard->UARTOffset);
	InitUart.RegisterStride = pCard->UARTRegStride;
	InitUart.ClockFreq		= pCard->ClockRate; 
	
	if(pPort->pUartLib->UL_InitUart_XXXX(&InitUart, pCard->pFirstUart, &(pPort->pUart)) != UL_STATUS_SUCCESS)
	{
		pPort->pUartLib = NULL;	// NULL pointer to UART library functions.
		return STATUS_UNSUCCESSFUL;
	}

	pPort->pUartLib->UL_SetAppBackPtr_XXXX(pPort->pUart, pPort);	// Set back ptr.

	if(pCard->pFirstUart == NULL)
		pCard->pFirstUart = pPort->pUart;

	pPort->Interrupt = pCard->Interrupt;



/*	pPort->RFLAddress = pCard->LocalConfigRegisters + URL + pPort->PortNumber;
	pPort->TFLAddress = pCard->LocalConfigRegisters + UTL + pPort->PortNumber;
//	pPort->InterruptStatus = pCard->LocalConfigRegisters
*/
	return status;
}




NTSTATUS
XXX_PortStart(IN PPORT_DEVICE_EXTENSION pPort)
{
	NTSTATUS status = STATUS_SUCCESS;
	PCARD_DEVICE_EXTENSION pCard = pPort->pParentCardExt;
	SET_BUFFER_SIZES BufferSizes;
	UART_INFO	UartInfo;
	
	PAGED_CODE();	// Macro in checked build to assert if pagable code is run at or above dispatch IRQL 

	SpxDbgMsg(SPX_TRACE_CALLS, ("%s: Entering XXX_PortStart for Port %d.\n", 
		PRODUCT_NAME, pPort->PortNumber));

	if(!KeSynchronizeExecution(pPort->Interrupt, SerialResetAndVerifyUart, pPort->DeviceObject))	// Verify UART exists.
	{
		SpxDbgMsg(SPX_TRACE_CALLS, ("%s: Failed to find 16Cx5x Port %d.\n", PRODUCT_NAME, pPort->PortNumber));
		return STATUS_UNSUCCESSFUL;
	}

	SpxDbgMsg(SPX_TRACE_CALLS, ("%s: Found 16Cx5x Port %d.\n", PRODUCT_NAME, pPort->PortNumber));
	
	KeSynchronizeExecution(pPort->Interrupt, SerialReset, pPort);		// Resets the port

	pPort->pUartLib->UL_GetUartInfo_XXXX(pPort->pUart, &UartInfo);	// Get UART Capabilities


	switch(pCard->CardType)
	{
	case Fast4_Isa:
	case Fast4_Pci:
	case Fast8_Isa:
	case Fast8_Pci:
	case Fast16_Isa:
	case Fast16_Pci:
	case Fast16FMC_Pci:
	case RAS4_Pci:
	case RAS8_Pci:
		{
			pPort->MaxTxFIFOSize		= UartInfo.MaxTxFIFOSize;	// Max Tx FIFO Size.
			pPort->MaxRxFIFOSize		= UartInfo.MaxRxFIFOSize;	// Max Rx FIFO Size.
			pPort->TxFIFOSize			= pPort->MaxTxFIFOSize;		// Default Tx FIFO Size.
			pPort->RxFIFOSize			= pPort->MaxRxFIFOSize;		// Default Rx FIFO Size.
			pPort->TxFIFOTrigLevel		= 8;						// Default Tx FIFO Trigger Level. 
			pPort->RxFIFOTrigLevel		= 56;						// Default Rx FIFO Trigger Level.
			pPort->LoFlowCtrlThreshold	= 16;						// Default Low Flow Control Threshold.
			pPort->HiFlowCtrlThreshold	= 60;						// Default High Flow Control Threshold.
			break;
		}

	case Speed2_Pci:
	case Speed2P_Pci:
	case Speed4_Pci:
	case Speed4P_Pci:
		{
			pPort->MaxTxFIFOSize		= UartInfo.MaxTxFIFOSize;	// Max Tx FIFO Size.
			pPort->MaxRxFIFOSize		= UartInfo.MaxRxFIFOSize;	// Max Rx FIFO Size.
			pPort->TxFIFOSize			= pPort->MaxTxFIFOSize;		// Default Tx FIFO Size.
			pPort->RxFIFOSize			= pPort->MaxRxFIFOSize;		// Default Rx FIFO Size.
			pPort->TxFIFOTrigLevel		= 16;						// Default Tx FIFO Trigger Level. 
			pPort->RxFIFOTrigLevel		= 100;						// Default Rx FIFO Trigger Level.
			pPort->LoFlowCtrlThreshold	= 16;						// Default Low Flow Control Threshold.
			pPort->HiFlowCtrlThreshold	= 112;						// Default High Flow Control Threshold.
			break;
		}

	default:
		break;
	}


#ifdef WMI_SUPPORT
	// Store Default FIFO settings for WMI
	pPort->SpeedWmiFifoProp.MaxTxFiFoSize				= pPort->MaxTxFIFOSize;
	pPort->SpeedWmiFifoProp.MaxRxFiFoSize				= pPort->MaxRxFIFOSize;
	pPort->SpeedWmiFifoProp.DefaultTxFiFoLimit			= pPort->TxFIFOSize;
	pPort->SpeedWmiFifoProp.DefaultTxFiFoTrigger		= pPort->TxFIFOTrigLevel;
	pPort->SpeedWmiFifoProp.DefaultRxFiFoTrigger		= pPort->RxFIFOTrigLevel;
	pPort->SpeedWmiFifoProp.DefaultLoFlowCtrlThreshold	= pPort->LoFlowCtrlThreshold;
	pPort->SpeedWmiFifoProp.DefaultHiFlowCtrlThreshold	= pPort->HiFlowCtrlThreshold;
#endif

	GetPortSettings(pPort->DeviceObject);	// Get Saved Port Settings if present.

	// Initialize the list heads for the read, write, and mask queues... 
	InitializeListHead(&pPort->ReadQueue);
	InitializeListHead(&pPort->WriteQueue);
	InitializeListHead(&pPort->MaskQueue);
	InitializeListHead(&pPort->PurgeQueue);

	// Initialize the spinlock associated with fields read (& set) by IO Control functions... 
	KeInitializeSpinLock(&pPort->ControlLock);

	// Initialize the timers used to timeout operations... 
	KeInitializeTimer(&pPort->ReadRequestTotalTimer);
	KeInitializeTimer(&pPort->ReadRequestIntervalTimer);
	KeInitializeTimer(&pPort->WriteRequestTotalTimer);
	KeInitializeTimer(&pPort->ImmediateTotalTimer);
	KeInitializeTimer(&pPort->XoffCountTimer);
	KeInitializeTimer(&pPort->LowerRTSTimer);

	// Initialise the dpcs that will be used to complete or timeout various IO operations... 
	KeInitializeDpc(&pPort->CommWaitDpc, SerialCompleteWait, pPort);
	KeInitializeDpc(&pPort->CompleteReadDpc, SerialCompleteRead, pPort);
	KeInitializeDpc(&pPort->CompleteWriteDpc, SerialCompleteWrite, pPort);
	KeInitializeDpc(&pPort->TotalImmediateTimeoutDpc, SerialTimeoutImmediate, pPort);
	KeInitializeDpc(&pPort->TotalReadTimeoutDpc, SerialReadTimeout, pPort);
	KeInitializeDpc(&pPort->IntervalReadTimeoutDpc, SerialIntervalReadTimeout, pPort);
	KeInitializeDpc(&pPort->TotalWriteTimeoutDpc, SerialWriteTimeout, pPort);
	KeInitializeDpc(&pPort->CommErrorDpc, SerialCommError, pPort);
	KeInitializeDpc(&pPort->CompleteImmediateDpc, SerialCompleteImmediate, pPort);
	KeInitializeDpc(&pPort->XoffCountTimeoutDpc, SerialTimeoutXoff, pPort);
	KeInitializeDpc(&pPort->XoffCountCompleteDpc, SerialCompleteXoff, pPort);
	KeInitializeDpc(&pPort->StartTimerLowerRTSDpc, SerialStartTimerLowerRTS, pPort);
	KeInitializeDpc(&pPort->PerhapsLowerRTSDpc, SerialInvokePerhapsLowerRTS, pPort);


	// Default device control fields... 
	pPort->SpecialChars.XonChar			= SERIAL_DEF_XON;
	pPort->SpecialChars.XoffChar		= SERIAL_DEF_XOFF;
	pPort->HandFlow.ControlHandShake	= SERIAL_DTR_CONTROL;
	pPort->HandFlow.FlowReplace			= SERIAL_RTS_CONTROL;


	// Define which baud rates can be supported... 
	pPort->SupportedBauds = SERIAL_BAUD_USER;

	pPort->UartConfig.TxBaud = 75;
	if(KeSynchronizeExecution(pPort->Interrupt, SerialSetBaud, pPort) == TRUE)
		pPort->SupportedBauds |= SERIAL_BAUD_075;

	pPort->UartConfig.TxBaud = 110;
	if(KeSynchronizeExecution(pPort->Interrupt, SerialSetBaud, pPort) == TRUE)
		pPort->SupportedBauds |= SERIAL_BAUD_110;

	pPort->UartConfig.TxBaud = 134;
	if(KeSynchronizeExecution(pPort->Interrupt, SerialSetBaud, pPort) == TRUE)
		pPort->SupportedBauds |= SERIAL_BAUD_134_5;

	pPort->UartConfig.TxBaud = 150;
	if(KeSynchronizeExecution(pPort->Interrupt, SerialSetBaud, pPort) == TRUE)
		pPort->SupportedBauds |= SERIAL_BAUD_150;

	pPort->UartConfig.TxBaud = 300;
	if(KeSynchronizeExecution(pPort->Interrupt, SerialSetBaud, pPort) == TRUE)
		pPort->SupportedBauds |= SERIAL_BAUD_300;

	pPort->UartConfig.TxBaud = 600;
	if(KeSynchronizeExecution(pPort->Interrupt, SerialSetBaud, pPort) == TRUE)
		pPort->SupportedBauds |= SERIAL_BAUD_600;

	pPort->UartConfig.TxBaud = 1200;
	if(KeSynchronizeExecution(pPort->Interrupt, SerialSetBaud, pPort) == TRUE)
		pPort->SupportedBauds |= SERIAL_BAUD_1200;

	pPort->UartConfig.TxBaud = 1800;
	if(KeSynchronizeExecution(pPort->Interrupt, SerialSetBaud, pPort) == TRUE)
		pPort->SupportedBauds |= SERIAL_BAUD_1800;

	pPort->UartConfig.TxBaud = 2400;
	if(KeSynchronizeExecution(pPort->Interrupt, SerialSetBaud, pPort) == TRUE)
		pPort->SupportedBauds |= SERIAL_BAUD_2400;

	pPort->UartConfig.TxBaud = 4800;
	if(KeSynchronizeExecution(pPort->Interrupt, SerialSetBaud, pPort) == TRUE)
		pPort->SupportedBauds |= SERIAL_BAUD_4800;

	pPort->UartConfig.TxBaud = 7200;
	if(KeSynchronizeExecution(pPort->Interrupt, SerialSetBaud, pPort) == TRUE)
		pPort->SupportedBauds |= SERIAL_BAUD_7200;

	pPort->UartConfig.TxBaud = 9600;
	if(KeSynchronizeExecution(pPort->Interrupt, SerialSetBaud, pPort) == TRUE)
		pPort->SupportedBauds |= SERIAL_BAUD_9600;

	pPort->UartConfig.TxBaud = 14400;
	if(KeSynchronizeExecution(pPort->Interrupt, SerialSetBaud, pPort) == TRUE)
		pPort->SupportedBauds |= SERIAL_BAUD_14400;

	pPort->UartConfig.TxBaud = 19200;
	if(KeSynchronizeExecution(pPort->Interrupt, SerialSetBaud, pPort) == TRUE)
		pPort->SupportedBauds |= SERIAL_BAUD_19200;

	pPort->UartConfig.TxBaud = 38400;
	if(KeSynchronizeExecution(pPort->Interrupt, SerialSetBaud, pPort) == TRUE)
		pPort->SupportedBauds |= SERIAL_BAUD_38400;

	pPort->UartConfig.TxBaud = 56000;
	if(KeSynchronizeExecution(pPort->Interrupt, SerialSetBaud, pPort) == TRUE)
		pPort->SupportedBauds |= SERIAL_BAUD_56K;

	pPort->UartConfig.TxBaud = 57600;
	if(KeSynchronizeExecution(pPort->Interrupt, SerialSetBaud, pPort) == TRUE)
		pPort->SupportedBauds |= SERIAL_BAUD_57600;

	pPort->UartConfig.TxBaud = 115200;
	if(KeSynchronizeExecution(pPort->Interrupt, SerialSetBaud, pPort) == TRUE)
		pPort->SupportedBauds |= SERIAL_BAUD_115200;

	pPort->UartConfig.TxBaud = 128000;
	if(KeSynchronizeExecution(pPort->Interrupt, SerialSetBaud, pPort) == TRUE)
		pPort->SupportedBauds |= SERIAL_BAUD_128K;


	// Default line configuration: 1200,E,7,1 
	pPort->UartConfig.TxBaud	= 1200;
	pPort->LineControl			= SERIAL_EVEN_PARITY | SERIAL_7_DATA | SERIAL_1_STOP;
	pPort->ValidDataMask		= 0x7F;

	// Set Frame Config 
	pPort->UartConfig.FrameConfig = (pPort->UartConfig.FrameConfig & ~UC_FCFG_DATALEN_MASK) | UC_FCFG_DATALEN_7;
	pPort->UartConfig.FrameConfig = (pPort->UartConfig.FrameConfig & ~UC_FCFG_PARITY_MASK) | UC_FCFG_EVEN_PARITY;
	pPort->UartConfig.FrameConfig = (pPort->UartConfig.FrameConfig & ~UC_FCFG_STOPBITS_MASK) | UC_FCFG_STOPBITS_1;




    // Mark this device as not being opened by anyone.  We keep a variable
	// around so that spurious interrupts are easily dismissed by the ISR.
    pPort->DeviceIsOpen		= FALSE;


//	pPort->UartConfig.SpecialMode |= UC_SM_LOOPBACK_MODE;   // Internal Loopback mode

	// Set up values for interval timing... 
	
	// Store values into the extension for interval timing. If the interval
	// timer is less than a second then come in with a short "polling" loop.
    // For large (> then 2 seconds) use a 1 second poller.
    pPort->ShortIntervalAmount.QuadPart = -1;
    pPort->LongIntervalAmount.QuadPart	= -10000000;
    pPort->CutOverAmount.QuadPart		= 200000000;


#ifdef WMI_SUPPORT
	//
	// Fill in WMI hardware data
	//

	pPort->WmiHwData.IrqNumber			= pCard->TrIrql;
	pPort->WmiHwData.IrqVector			= pCard->TrVector;
	pPort->WmiHwData.IrqLevel			= pCard->TrIrql;
	pPort->WmiHwData.IrqAffinityMask	= pCard->ProcessorAffinity;
	
	if(pCard->InterruptMode == Latched)
		pPort->WmiHwData.InterruptType = SERIAL_WMI_INTTYPE_LATCHED;
	else
		pPort->WmiHwData.InterruptType = SERIAL_WMI_INTTYPE_LEVEL;

	pPort->WmiHwData.BaseIOAddress = (ULONG_PTR)pCard->Controller;


	//
	// Fill in WMI device state data (as defaults)
	//

	pPort->WmiCommData.BaudRate					= pPort->UartConfig.TxBaud;
	UPDATE_WMI_LINE_CONTROL(pPort->WmiCommData, pPort->LineControl);
	UPDATE_WMI_XON_XOFF_CHARS(pPort->WmiCommData, pPort->SpecialChars);
	UPDATE_WMI_XMIT_THRESHOLDS(pPort->WmiCommData, pPort->HandFlow);

	pPort->WmiCommData.MaximumBaudRate			= 115200U;	// 115200k baud max
	pPort->WmiCommData.MaximumOutputBufferSize	= (UINT32)((ULONG)-1);
	pPort->WmiCommData.MaximumInputBufferSize	= (UINT32)((ULONG)-1);

	pPort->WmiCommData.Support16BitMode			= FALSE;
	pPort->WmiCommData.SupportDTRDSR			= TRUE;
	pPort->WmiCommData.SupportIntervalTimeouts	= TRUE;
	pPort->WmiCommData.SupportParityCheck		= TRUE;
	pPort->WmiCommData.SupportRTSCTS			= TRUE;
	pPort->WmiCommData.SupportXonXoff			= TRUE;
	pPort->WmiCommData.SettableBaudRate			= TRUE;
	pPort->WmiCommData.SettableDataBits			= TRUE;
	pPort->WmiCommData.SettableFlowControl		= TRUE;
	pPort->WmiCommData.SettableParity			= TRUE;
	pPort->WmiCommData.SettableParityCheck		= TRUE;
	pPort->WmiCommData.SettableStopBits			= TRUE;
	pPort->WmiCommData.IsBusy					= FALSE;


	// Fill in wmi perf data (all zero's)
	RtlZeroMemory(&pPort->WmiPerfData, sizeof(pPort->WmiPerfData));



	//
    // Register for WMI
	//
	
	SpeedPort_WmiInitializeWmilibContext(&pPort->WmiLibInfo);

	IoWMIRegistrationControl(pPort->DeviceObject, WMIREG_ACTION_REGISTER);
#endif


	// Initialise the port hardware... 
	KeSynchronizeExecution(pPort->Interrupt, SerialReset, pPort);					// Resets the port
	KeSynchronizeExecution(pPort->Interrupt, ApplyInitialPortSettings, pPort);		// Apply settings
	KeSynchronizeExecution(pPort->Interrupt, SerialMarkClose, pPort);				// Disables the FIFO 
	KeSynchronizeExecution(pPort->Interrupt, SerialClrRTS, pPort);					// Clear RTS signal
	KeSynchronizeExecution(pPort->Interrupt, SerialClrDTR, pPort);					// Clear DTR signal 
	
	return status;
}


NTSTATUS
XXX_PortStop(IN PPORT_DEVICE_EXTENSION pPort)
{
	NTSTATUS status = STATUS_SUCCESS;

	PAGED_CODE();	// Macro in checked build to assert if pagable code is run at or above dispatch IRQL 

	SpxDbgMsg(SPX_TRACE_CALLS, ("%s: Entering XXX_PortStop for Port %d.\n", 
		PRODUCT_NAME, pPort->PortNumber));

#ifdef WMI_SUPPORT
	IoWMIRegistrationControl(pPort->DeviceObject, WMIREG_ACTION_DEREGISTER);

	RtlZeroMemory(&pPort->WmiLibInfo, sizeof(WMILIB_CONTEXT));
#endif

	// Cancel timers...
    KeCancelTimer(&pPort->ReadRequestTotalTimer);
    KeCancelTimer(&pPort->ReadRequestIntervalTimer);
    KeCancelTimer(&pPort->WriteRequestTotalTimer);
    KeCancelTimer(&pPort->ImmediateTotalTimer);
    KeCancelTimer(&pPort->XoffCountTimer);
	KeCancelTimer(&pPort->LowerRTSTimer);

	// Cancel pending DPCs...
	KeRemoveQueueDpc(&pPort->CommWaitDpc);
	KeRemoveQueueDpc(&pPort->CompleteReadDpc);
	KeRemoveQueueDpc(&pPort->CompleteWriteDpc);
	KeRemoveQueueDpc(&pPort->TotalReadTimeoutDpc);
	KeRemoveQueueDpc(&pPort->IntervalReadTimeoutDpc);
	KeRemoveQueueDpc(&pPort->TotalWriteTimeoutDpc);
	KeRemoveQueueDpc(&pPort->CommErrorDpc);
	KeRemoveQueueDpc(&pPort->CompleteImmediateDpc);
	KeRemoveQueueDpc(&pPort->TotalImmediateTimeoutDpc);
	KeRemoveQueueDpc(&pPort->XoffCountTimeoutDpc);
	KeRemoveQueueDpc(&pPort->XoffCountCompleteDpc);
	KeRemoveQueueDpc(&pPort->StartTimerLowerRTSDpc);
	KeRemoveQueueDpc(&pPort->PerhapsLowerRTSDpc);

	KeSynchronizeExecution(pPort->Interrupt, SerialReset, pPort);		// Resets the port

	return status;
}

NTSTATUS
XXX_PortDeInit(IN PPORT_DEVICE_EXTENSION pPort)
{
	PCARD_DEVICE_EXTENSION pCard = pPort->pParentCardExt;
	NTSTATUS status = STATUS_SUCCESS;

	PAGED_CODE();	// Macro in checked build to assert if pagable code is run at or above dispatch IRQL 

	SpxDbgMsg(SPX_TRACE_CALLS, ("%s: Entering XXX_PortDeInit for Port %d.\n", 
		PRODUCT_NAME, pPort->PortNumber));

	// If we are about to DeInit the first UART object to be serviced next
	// Make the pFirstUart point to the next UART in the list.
	if(pPort->pUart == pCard->pFirstUart)
		pCard->pFirstUart = pCard->UartLib.UL_GetUartObject_XXXX(pPort->pUart, UL_OP_GET_NEXT_UART);

	pCard->UartLib.UL_DeInitUart_XXXX(pPort->pUart);	// DeInit UART
	pPort->pUart = NULL;

	pPort->pUartLib = NULL;	// NULL pointer to UART library functions.


	// Free identifier string allocations... 
	if(pPort->DeviceID.Buffer != NULL)
		ExFreePool(pPort->DeviceID.Buffer);

	if(pPort->InstanceID.Buffer != NULL)
		ExFreePool(pPort->InstanceID.Buffer);
	
	if(pPort->HardwareIDs.Buffer != NULL)	
		ExFreePool(pPort->HardwareIDs.Buffer);

	if(pPort->DevDesc.Buffer != NULL)
		ExFreePool(pPort->DevDesc.Buffer);

	if(pPort->DevLocation.Buffer != NULL)
		ExFreePool(pPort->DevLocation.Buffer);


	return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\spx\speed\driver\spd_wmi.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    wmi.c

Abstract:

    This module contains the code that handles the wmi IRPs for the
    serial driver.

Environment:

    Kernel mode

Revision History :
--*/

#include "precomp.h"


// Prototypes

// -- PORT WMI Routines -- 
NTSTATUS
SpeedPort_WmiQueryRegInfo(IN PDEVICE_OBJECT pDevObject, OUT PULONG pRegFlags,
						  OUT PUNICODE_STRING pInstanceName,
						  OUT PUNICODE_STRING *pRegistryPath,
						  OUT PUNICODE_STRING pMofResourceName,
						  OUT PDEVICE_OBJECT *pPdo);
NTSTATUS
SpeedPort_WmiQueryDataBlock(IN PDEVICE_OBJECT pDevObject, IN PIRP pIrp,
							IN ULONG GuidIndex, IN ULONG InstanceIndex,
							IN ULONG InstanceCount, IN OUT PULONG pInstanceLengthArray,
							IN ULONG OutBufferSize, OUT PUCHAR pBuffer);
NTSTATUS
SpeedPort_WmiSetDataBlock(IN PDEVICE_OBJECT pDevObject, IN PIRP pIrp,
						  IN ULONG GuidIndex, IN ULONG InstanceIndex,
						  IN ULONG BufferSize, IN PUCHAR pBuffer);

NTSTATUS
SpeedPort_WmiSetDataItem(IN PDEVICE_OBJECT pDevObject, IN PIRP pIrp,
						 IN ULONG GuidIndex, IN ULONG InstanceIndex,
						 IN ULONG DataItemId, IN ULONG BufferSize,
						 IN PUCHAR pBuffer);



// End of prototypes.


#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, SpeedPort_WmiInitializeWmilibContext)
#pragma alloc_text(PAGE, SpeedPort_WmiQueryRegInfo)
#pragma alloc_text(PAGE, SpeedPort_WmiQueryDataBlock)
#pragma alloc_text(PAGE, SpeedPort_WmiSetDataBlock)
#pragma alloc_text(PAGE, SpeedPort_WmiSetDataItem)
#endif





#define WMI_SERIAL_PORT_NAME_INFORMATION	0
#define WMI_SERIAL_PORT_COMM_INFORMATION	1
#define WMI_SERIAL_PORT_HW_INFORMATION		2
#define WMI_SERIAL_PORT_PERF_INFORMATION	3
#define WMI_SERIAL_PORT_PROPERTIES			4
#define WMI_SPEED_PORT_FIFO_PROP			5

GUID SpeedPortStdSerialWmiPortNameGuid				= SERIAL_PORT_WMI_NAME_GUID;			// Standard Serial WMI
GUID SpeedPortStdSerialWmiPortCommGuid				= SERIAL_PORT_WMI_COMM_GUID;			// Standard Serial WMI
GUID SpeedPortStdSerialWmiPortHWGuid				= SERIAL_PORT_WMI_HW_GUID;				// Standard Serial WMI
GUID SpeedPortStdSerialWmiPortPerfGuid				= SERIAL_PORT_WMI_PERF_GUID;			// Standard Serial WMI
GUID SpeedPortStdSerialWmiPortPropertiesGuid		= SERIAL_PORT_WMI_PROPERTIES_GUID;		// Standard Serial WMI
GUID SpeedPortWmiFifoPropGuid						= SPX_SPEED_WMI_FIFO_PROP_GUID;			// Speed WMI


WMIGUIDREGINFO SpeedPort_WmiGuidList[] =
{
    { &SpeedPortStdSerialWmiPortNameGuid, 1, 0 },
    { &SpeedPortStdSerialWmiPortCommGuid, 1, 0 },
    { &SpeedPortStdSerialWmiPortHWGuid, 1, 0 },
    { &SpeedPortStdSerialWmiPortPerfGuid, 1, 0 },
    { &SpeedPortStdSerialWmiPortPropertiesGuid, 1, 0},
    { &SpeedPortWmiFifoPropGuid, 1, 0 },
};


#define SpeedPort_WmiGuidCount (sizeof(SpeedPort_WmiGuidList) / sizeof(WMIGUIDREGINFO))




NTSTATUS
SpeedPort_WmiInitializeWmilibContext(IN PWMILIB_CONTEXT WmilibContext)
/*++

Routine Description:

    This routine will initialize the wmilib context structure with the
    guid list and the pointers to the wmilib callback functions. This routine
    should be called before calling IoWmiRegistrationControl to register
    your device object.

Arguments:

    WmilibContext is pointer to the wmilib context.

Return Value:

    status

--*/
{
	PAGED_CODE();

    RtlZeroMemory(WmilibContext, sizeof(WMILIB_CONTEXT));
  
    WmilibContext->GuidCount			= SpeedPort_WmiGuidCount;
    WmilibContext->GuidList				= SpeedPort_WmiGuidList;    
    
    WmilibContext->QueryWmiRegInfo		= SpeedPort_WmiQueryRegInfo;
    WmilibContext->QueryWmiDataBlock	= SpeedPort_WmiQueryDataBlock;
    WmilibContext->SetWmiDataBlock		= SpeedPort_WmiSetDataBlock;
    WmilibContext->SetWmiDataItem		= SpeedPort_WmiSetDataItem;
	WmilibContext->ExecuteWmiMethod		= NULL;	//SpeedPort_WmiExecuteMethod
    WmilibContext->WmiFunctionControl	= NULL;	//SpeedPort_WmiFunctionControl;

    return(STATUS_SUCCESS);
}





//
// WMI System Call back functions
//


NTSTATUS
SpeedPort_WmiQueryRegInfo(IN PDEVICE_OBJECT pDevObject, OUT PULONG pRegFlags,
						OUT PUNICODE_STRING pInstanceName,
						OUT PUNICODE_STRING *pRegistryPath,
						OUT PUNICODE_STRING MofResourceName,
						OUT PDEVICE_OBJECT *pPdo)
{
	NTSTATUS status = STATUS_SUCCESS;
	PPORT_DEVICE_EXTENSION pPort = (PPORT_DEVICE_EXTENSION)pDevObject->DeviceExtension;
   
	PAGED_CODE();

	*pRegFlags = WMIREG_FLAG_INSTANCE_PDO;
	*pRegistryPath = &SavedRegistryPath;
	*pPdo = pDevObject;  // Port device object is a PDO.

    RtlInitUnicodeString(MofResourceName, L"MofResource");

	return(status);
}





NTSTATUS
SpeedPort_WmiQueryDataBlock(IN PDEVICE_OBJECT pDevObject, IN PIRP pIrp,
						  IN ULONG GuidIndex, IN ULONG InstanceIndex,
						  IN ULONG InstanceCount, IN OUT PULONG pInstanceLengthArray,
						  IN ULONG OutBufferSize, OUT PUCHAR pBuffer)
{
    PPORT_DEVICE_EXTENSION pPort = (PPORT_DEVICE_EXTENSION)pDevObject->DeviceExtension;
	NTSTATUS status;
    ULONG size = 0;

    PAGED_CODE();

    switch(GuidIndex) 
	{
    case WMI_SERIAL_PORT_NAME_INFORMATION:
		{
			size = pPort->DosName.Length;

			if(OutBufferSize < (size + sizeof(USHORT))) 
			{
				size += sizeof(USHORT);
				status = STATUS_BUFFER_TOO_SMALL;
				break;
			}

			if(pPort->DosName.Buffer == NULL) 
			{
				status = STATUS_INSUFFICIENT_RESOURCES;
				break;
			}

			// First, copy the string over containing our identifier
			*(USHORT *)pBuffer = (USHORT)size;
			(UCHAR *)pBuffer += sizeof(USHORT);

			RtlCopyMemory(pBuffer, pPort->DosName.Buffer, size);

			// Increment total size to include the WORD containing our len
			size += sizeof(USHORT);
			*pInstanceLengthArray = size;
                
			status = STATUS_SUCCESS;

			break;
		}

    case WMI_SERIAL_PORT_COMM_INFORMATION: 
		{
			size = sizeof(SERIAL_WMI_COMM_DATA);

			if(OutBufferSize < size) 
			{
				status = STATUS_BUFFER_TOO_SMALL;
				break;
			}

			*pInstanceLengthArray = size;
			*(PSERIAL_WMI_COMM_DATA)pBuffer = pPort->WmiCommData;

			status = STATUS_SUCCESS;

			break;
		}

    case WMI_SERIAL_PORT_HW_INFORMATION:
		{
			size = sizeof(SERIAL_WMI_HW_DATA);

			if(OutBufferSize < size) 
			{
				status = STATUS_BUFFER_TOO_SMALL;
				break;
			}

			*pInstanceLengthArray = size;
			*(PSERIAL_WMI_HW_DATA)pBuffer = pPort->WmiHwData;

			status = STATUS_SUCCESS;

			break;
		}

    case WMI_SERIAL_PORT_PERF_INFORMATION: 
		{
			size = sizeof(SERIAL_WMI_PERF_DATA);

			if(OutBufferSize < size) 
			{
				status = STATUS_BUFFER_TOO_SMALL;
				break;
			}

			*pInstanceLengthArray = size;
			*(PSERIAL_WMI_PERF_DATA)pBuffer = pPort->WmiPerfData;

			status = STATUS_SUCCESS;

			break;
		}

    case WMI_SERIAL_PORT_PROPERTIES: 
		{
			size = sizeof(SERIAL_COMMPROP) + sizeof(ULONG);

			if(OutBufferSize < size) 
			{
				status = STATUS_BUFFER_TOO_SMALL;
				break;
			}

			*pInstanceLengthArray = size;
			SerialGetProperties(pPort, (PSERIAL_COMMPROP)pBuffer);
       
			*((PULONG)(((PSERIAL_COMMPROP)pBuffer)->ProvChar)) = 0;

			status = STATUS_SUCCESS;

			break;
		}

	case WMI_SPEED_PORT_FIFO_PROP:
		{
			size = sizeof(SPX_SPEED_WMI_FIFO_PROP);

			if(OutBufferSize < size) 
			{
				status = STATUS_BUFFER_TOO_SMALL;
				break;
			}

			*pInstanceLengthArray = size;

			// Update items that may have changed.
			pPort->SpeedWmiFifoProp.TxFiFoLimit			= pPort->TxFIFOSize;
			pPort->SpeedWmiFifoProp.TxFiFoTrigger		= pPort->TxFIFOTrigLevel;
			pPort->SpeedWmiFifoProp.RxFiFoTrigger		= pPort->RxFIFOTrigLevel;
			pPort->SpeedWmiFifoProp.LoFlowCtrlThreshold	= pPort->LoFlowCtrlThreshold;
			pPort->SpeedWmiFifoProp.HiFlowCtrlThreshold	= pPort->HiFlowCtrlThreshold;

			*(PSPX_SPEED_WMI_FIFO_PROP)pBuffer = pPort->SpeedWmiFifoProp;

			status = STATUS_SUCCESS;

			break;
		}


	default:
		status = STATUS_WMI_GUID_NOT_FOUND;
		break;

    }

    status = WmiCompleteRequest(pDevObject, pIrp, status, size, IO_NO_INCREMENT);
	
	return(status);
}







NTSTATUS
SpeedPort_WmiSetDataBlock(IN PDEVICE_OBJECT pDevObject, IN PIRP pIrp,
						IN ULONG GuidIndex, IN ULONG InstanceIndex,
						IN ULONG BufferSize, IN PUCHAR pBuffer)
{
    PPORT_DEVICE_EXTENSION pPort = (PPORT_DEVICE_EXTENSION)pDevObject->DeviceExtension;
	PCARD_DEVICE_EXTENSION pCard = pPort->pParentCardExt;
	NTSTATUS status;
    ULONG size = 0;

	PAGED_CODE();

	switch(GuidIndex)
	{
	case WMI_SERIAL_PORT_NAME_INFORMATION:
	case WMI_SERIAL_PORT_COMM_INFORMATION:
	case WMI_SERIAL_PORT_HW_INFORMATION:
	case WMI_SERIAL_PORT_PERF_INFORMATION:
	case WMI_SERIAL_PORT_PROPERTIES:
		status = STATUS_WMI_READ_ONLY;		
		break;										

	case WMI_SPEED_PORT_FIFO_PROP:
		{
			// Device stopping?, Device not powered?, Device not started?
			if(SpxCheckPnpPowerFlags((PCOMMON_OBJECT_DATA)pPort, PPF_STOP_PENDING, PPF_POWERED | PPF_STARTED, FALSE))
			{
				status = STATUS_WMI_SET_FAILURE;	
				break;
			}

			if(BufferSize < sizeof(SPX_SPEED_WMI_FIFO_PROP)) 
			{
				status = STATUS_BUFFER_TOO_SMALL;
				break;
			}

			// These Items are read only - If we have been asked to change them fail request.
			if((pPort->SpeedWmiFifoProp.MaxTxFiFoSize				!= ((PSPX_SPEED_WMI_FIFO_PROP)pBuffer)->MaxTxFiFoSize)
			|| (pPort->SpeedWmiFifoProp.MaxRxFiFoSize				!= ((PSPX_SPEED_WMI_FIFO_PROP)pBuffer)->MaxRxFiFoSize)
			|| (pPort->SpeedWmiFifoProp.DefaultTxFiFoLimit			!= ((PSPX_SPEED_WMI_FIFO_PROP)pBuffer)->DefaultTxFiFoLimit)
			|| (pPort->SpeedWmiFifoProp.DefaultTxFiFoTrigger		!= ((PSPX_SPEED_WMI_FIFO_PROP)pBuffer)->DefaultTxFiFoTrigger)
			|| (pPort->SpeedWmiFifoProp.DefaultRxFiFoTrigger		!= ((PSPX_SPEED_WMI_FIFO_PROP)pBuffer)->DefaultRxFiFoTrigger)
			|| (pPort->SpeedWmiFifoProp.DefaultLoFlowCtrlThreshold	!= ((PSPX_SPEED_WMI_FIFO_PROP)pBuffer)->DefaultLoFlowCtrlThreshold)
			|| (pPort->SpeedWmiFifoProp.DefaultHiFlowCtrlThreshold	!= ((PSPX_SPEED_WMI_FIFO_PROP)pBuffer)->DefaultHiFlowCtrlThreshold))
			{
				status = STATUS_WMI_READ_ONLY;
				break;
			}

			if((pCard->CardType == Fast4_Isa)  || (pCard->CardType == Fast4_Pci)  || (pCard->CardType == RAS4_Pci) 
			|| (pCard->CardType == Fast8_Isa)  || (pCard->CardType == Fast8_Pci)  || (pCard->CardType == RAS8_Pci)  
			|| (pCard->CardType == Fast16_Isa) || (pCard->CardType == Fast16_Pci) || (pCard->CardType == Fast16FMC_Pci))
			{
				if((pPort->LoFlowCtrlThreshold	!= ((PSPX_SPEED_WMI_FIFO_PROP)pBuffer)->LoFlowCtrlThreshold)
				|| (pPort->HiFlowCtrlThreshold	!= ((PSPX_SPEED_WMI_FIFO_PROP)pBuffer)->HiFlowCtrlThreshold))
				{
					status = STATUS_WMI_READ_ONLY;	// Flow ctrl threshold cannot be modified on Fast cards.
					break;
				}
			}


			pPort->TxFIFOSize				= ((PSPX_SPEED_WMI_FIFO_PROP)pBuffer)->TxFiFoLimit;
			pPort->TxFIFOTrigLevel			= ((PSPX_SPEED_WMI_FIFO_PROP)pBuffer)->TxFiFoTrigger;
			pPort->RxFIFOTrigLevel			= ((PSPX_SPEED_WMI_FIFO_PROP)pBuffer)->RxFiFoTrigger;
			pPort->LoFlowCtrlThreshold		= ((PSPX_SPEED_WMI_FIFO_PROP)pBuffer)->LoFlowCtrlThreshold;
			pPort->HiFlowCtrlThreshold		= ((PSPX_SPEED_WMI_FIFO_PROP)pBuffer)->HiFlowCtrlThreshold;
			
			// Make settings
			if(KeSynchronizeExecution(pPort->Interrupt, SetPortFiFoSettings, pPort))
			{
				HANDLE					PnPKeyHandle;

				// Open PnP Reg Key and save new setting to registry.
				if(SPX_SUCCESS(IoOpenDeviceRegistryKey(pDevObject, PLUGPLAY_REGKEY_DEVICE, STANDARD_RIGHTS_WRITE, &PnPKeyHandle)))
				{
					Spx_PutRegistryKeyValue(	PnPKeyHandle, TX_FIFO_LIMIT, wcslen(TX_FIFO_LIMIT) * sizeof(WCHAR), REG_DWORD, 
												&pPort->TxFIFOSize, sizeof(ULONG));

					Spx_PutRegistryKeyValue(	PnPKeyHandle, TX_FIFO_TRIG_LEVEL, wcslen(TX_FIFO_TRIG_LEVEL) * sizeof(WCHAR), REG_DWORD, 
												&pPort->TxFIFOTrigLevel, sizeof(ULONG));

					Spx_PutRegistryKeyValue(	PnPKeyHandle, RX_FIFO_TRIG_LEVEL, wcslen(RX_FIFO_TRIG_LEVEL) * sizeof(WCHAR), REG_DWORD, 
												&pPort->RxFIFOTrigLevel, sizeof(ULONG));

					Spx_PutRegistryKeyValue(	PnPKeyHandle, LO_FLOW_CTRL_LEVEL, wcslen(LO_FLOW_CTRL_LEVEL) * sizeof(WCHAR), REG_DWORD, 
												&pPort->LoFlowCtrlThreshold, sizeof(ULONG));

					Spx_PutRegistryKeyValue(	PnPKeyHandle, HI_FLOW_CTRL_LEVEL, wcslen(HI_FLOW_CTRL_LEVEL) * sizeof(WCHAR), REG_DWORD, 
												&pPort->HiFlowCtrlThreshold, sizeof(ULONG));

					ZwClose(PnPKeyHandle);
				}

				status = STATUS_SUCCESS;
			}
			else
			{
				status = STATUS_WMI_SET_FAILURE;
			}

			break;
		}

	default:
		status = STATUS_WMI_GUID_NOT_FOUND;
		break;
	}


    status = WmiCompleteRequest(pDevObject, pIrp, status, size, IO_NO_INCREMENT);
	
	return(status);
}





NTSTATUS
SpeedPort_WmiSetDataItem(IN PDEVICE_OBJECT pDevObject, IN PIRP pIrp,
					   IN ULONG GuidIndex, IN ULONG InstanceIndex,
					   IN ULONG DataItemId, IN ULONG BufferSize,
					   IN PUCHAR pBuffer)
{
    PPORT_DEVICE_EXTENSION pPort = (PPORT_DEVICE_EXTENSION)pDevObject->DeviceExtension;
	PCARD_DEVICE_EXTENSION pCard = pPort->pParentCardExt;
	NTSTATUS status;
    ULONG size = 0;

	PAGED_CODE();

	switch(GuidIndex)
	{
	case WMI_SERIAL_PORT_NAME_INFORMATION:
	case WMI_SERIAL_PORT_COMM_INFORMATION:
	case WMI_SERIAL_PORT_HW_INFORMATION:
	case WMI_SERIAL_PORT_PERF_INFORMATION:
	case WMI_SERIAL_PORT_PROPERTIES:
		status = STATUS_WMI_READ_ONLY;		
		break;										

	case WMI_SPEED_PORT_FIFO_PROP:
		{
			HANDLE	PnPKeyHandle;

			// Device stopping?, Device not powered?, Device not started?
			if(SpxCheckPnpPowerFlags((PCOMMON_OBJECT_DATA)pPort, PPF_STOP_PENDING, PPF_POWERED | PPF_STARTED, FALSE))
			{
				status = STATUS_WMI_SET_FAILURE;	
				break;
			}

			switch(DataItemId)
			{
			case SPX_SPEED_WMI_FIFO_PROP_MaxTxFiFoSize_ID:
			case SPX_SPEED_WMI_FIFO_PROP_MaxRxFiFoSize_ID:
			case SPX_SPEED_WMI_FIFO_PROP_DefaultTxFiFoLimit_ID:
			case SPX_SPEED_WMI_FIFO_PROP_DefaultTxFiFoTrigger_ID:
			case SPX_SPEED_WMI_FIFO_PROP_DefaultRxFiFoTrigger_ID:
			case SPX_SPEED_WMI_FIFO_PROP_DefaultLoFlowCtrlThreshold_ID:
			case SPX_SPEED_WMI_FIFO_PROP_DefaultHiFlowCtrlThreshold_ID:
				status = STATUS_WMI_READ_ONLY;
				break;

			case SPX_SPEED_WMI_FIFO_PROP_TxFiFoLimit_ID:
				pPort->TxFIFOSize = *pBuffer;

				if(KeSynchronizeExecution(pPort->Interrupt, SetPortFiFoSettings, pPort))
				{
					// Open PnP Reg Key and save new setting to registry.
					if(SPX_SUCCESS(IoOpenDeviceRegistryKey(pDevObject, PLUGPLAY_REGKEY_DEVICE, STANDARD_RIGHTS_WRITE, &PnPKeyHandle)))
					{
						Spx_PutRegistryKeyValue(	PnPKeyHandle, TX_FIFO_LIMIT, wcslen(TX_FIFO_LIMIT) * sizeof(WCHAR), REG_DWORD, 
													&pPort->TxFIFOSize, sizeof(ULONG));

						ZwClose(PnPKeyHandle);
					}

					status = STATUS_SUCCESS;
				}
				else
				{
					status = STATUS_WMI_SET_FAILURE;
				}

				break;

			case SPX_SPEED_WMI_FIFO_PROP_TxFiFoTrigger_ID:
				pPort->TxFIFOTrigLevel = *pBuffer;
				
				if(KeSynchronizeExecution(pPort->Interrupt, SetPortFiFoSettings, pPort))
				{
					// Open PnP Reg Key and save new setting to registry.
					if(SPX_SUCCESS(IoOpenDeviceRegistryKey(pDevObject, PLUGPLAY_REGKEY_DEVICE, STANDARD_RIGHTS_WRITE, &PnPKeyHandle)))
					{
						Spx_PutRegistryKeyValue(	PnPKeyHandle, TX_FIFO_TRIG_LEVEL, wcslen(TX_FIFO_TRIG_LEVEL) * sizeof(WCHAR), REG_DWORD, 
													&pPort->TxFIFOTrigLevel, sizeof(ULONG));

						ZwClose(PnPKeyHandle);
					}

					status = STATUS_SUCCESS;
				}
				else
				{
					status = STATUS_WMI_SET_FAILURE;
				}

				break;

			case SPX_SPEED_WMI_FIFO_PROP_RxFiFoTrigger_ID:
				pPort->RxFIFOTrigLevel = *pBuffer;
				
				if(KeSynchronizeExecution(pPort->Interrupt, SetPortFiFoSettings, pPort))
				{
					// Open PnP Reg Key and save new setting to registry.
					if(SPX_SUCCESS(IoOpenDeviceRegistryKey(pDevObject, PLUGPLAY_REGKEY_DEVICE, STANDARD_RIGHTS_WRITE, &PnPKeyHandle)))
					{
						Spx_PutRegistryKeyValue(	PnPKeyHandle, RX_FIFO_TRIG_LEVEL, wcslen(RX_FIFO_TRIG_LEVEL) * sizeof(WCHAR), REG_DWORD, 
													&pPort->RxFIFOTrigLevel, sizeof(ULONG));

						ZwClose(PnPKeyHandle);
					}

					status = STATUS_SUCCESS;
				}
				else
				{
					status = STATUS_WMI_SET_FAILURE;
				}

				break;
			
			case SPX_SPEED_WMI_FIFO_PROP_LoFlowCtrlThreshold_ID:

				if((pCard->CardType == Fast4_Isa)  || (pCard->CardType == Fast4_Pci)  || (pCard->CardType == RAS4_Pci)  
				|| (pCard->CardType == Fast8_Isa)  || (pCard->CardType == Fast8_Pci)  || (pCard->CardType == RAS8_Pci)  
				|| (pCard->CardType == Fast16_Isa) || (pCard->CardType == Fast16_Pci) || (pCard->CardType == Fast16FMC_Pci))
				{
					if(pPort->SpeedWmiFifoProp.LoFlowCtrlThreshold != *pBuffer)
					{
						status = STATUS_WMI_READ_ONLY;	// Flow ctrl threshold cannot be modified on Fast cards.
						break;
					}
				}

				pPort->LoFlowCtrlThreshold = *pBuffer;
				
				if(KeSynchronizeExecution(pPort->Interrupt, SetPortFiFoSettings, pPort))
				{
					// Open PnP Reg Key and save new setting to registry.
					if(SPX_SUCCESS(IoOpenDeviceRegistryKey(pDevObject, PLUGPLAY_REGKEY_DEVICE, STANDARD_RIGHTS_WRITE, &PnPKeyHandle)))
					{
						Spx_PutRegistryKeyValue(	PnPKeyHandle, LO_FLOW_CTRL_LEVEL, wcslen(LO_FLOW_CTRL_LEVEL) * sizeof(WCHAR), REG_DWORD, 
													&pPort->LoFlowCtrlThreshold, sizeof(ULONG));

						ZwClose(PnPKeyHandle);
					}

					status = STATUS_SUCCESS;
				}
				else
				{
					status = STATUS_WMI_SET_FAILURE;
				}

				break;
			
			case SPX_SPEED_WMI_FIFO_PROP_HiFlowCtrlThreshold_ID:

				if((pCard->CardType == Fast4_Isa)  || (pCard->CardType == Fast4_Pci)  || (pCard->CardType == RAS4_Pci)  
				|| (pCard->CardType == Fast8_Isa)  || (pCard->CardType == Fast8_Pci)  || (pCard->CardType == RAS8_Pci)  
				|| (pCard->CardType == Fast16_Isa) || (pCard->CardType == Fast16_Pci) || (pCard->CardType == Fast16FMC_Pci))
				{
					if(pPort->SpeedWmiFifoProp.HiFlowCtrlThreshold != *pBuffer)
					{
						status = STATUS_WMI_READ_ONLY;	// Flow ctrl threshold cannot be modified on Fast cards.
						break;
					}
				}

				pPort->HiFlowCtrlThreshold = *pBuffer;
				
				if(KeSynchronizeExecution(pPort->Interrupt, SetPortFiFoSettings, pPort))
				{
					// Open PnP Reg Key and save new setting to registry.
					if(SPX_SUCCESS(IoOpenDeviceRegistryKey(pDevObject, PLUGPLAY_REGKEY_DEVICE, STANDARD_RIGHTS_WRITE, &PnPKeyHandle)))
					{
						Spx_PutRegistryKeyValue(	PnPKeyHandle, HI_FLOW_CTRL_LEVEL, wcslen(HI_FLOW_CTRL_LEVEL) * sizeof(WCHAR), REG_DWORD, 
													&pPort->HiFlowCtrlThreshold, sizeof(ULONG));

						ZwClose(PnPKeyHandle);
					}

					status = STATUS_SUCCESS;
				}
				else
				{
					status = STATUS_WMI_SET_FAILURE;
				}

				break;

			default:
				status = STATUS_WMI_ITEMID_NOT_FOUND;
				break;
			}

			break;
		}

	default:
		status = STATUS_WMI_GUID_NOT_FOUND;
		break;
	}


    status = WmiCompleteRequest(pDevObject, pIrp, status, size, IO_NO_INCREMENT);
	
	return(status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\spx\speed\driver\spx_wmi.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    wmi.c

Abstract:

    This module contains the code that handles the wmi IRPs for the
    serial driver.

Environment:

    Kernel mode

Revision History :
--*/

#include "precomp.h"


// Prototypes

NTSTATUS
SpxPort_WmiQueryRegInfo(IN PDEVICE_OBJECT pDevObject, OUT PULONG pRegFlags,
						OUT PUNICODE_STRING pInstanceName,
						OUT PUNICODE_STRING *pRegistryPath,
						OUT PUNICODE_STRING pMofResourceName,
						OUT PDEVICE_OBJECT *pPdo);
NTSTATUS
SpxPort_WmiQueryDataBlock(IN PDEVICE_OBJECT pDevObject, IN PIRP pIrp,
						  IN ULONG GuidIndex, IN ULONG InstanceIndex,
						  IN ULONG InstanceCount, IN OUT PULONG pInstanceLengthArray,
						  IN ULONG OutBufferSize, OUT PUCHAR pBuffer);
NTSTATUS
SpxPort_WmiSetDataBlock(IN PDEVICE_OBJECT pDevObject, IN PIRP pIrp,
						IN ULONG GuidIndex, IN ULONG InstanceIndex,
						IN ULONG BufferSize, IN PUCHAR pBuffer);

NTSTATUS
SpxPort_WmiSetDataItem(IN PDEVICE_OBJECT pDevObject, IN PIRP pIrp,
					   IN ULONG GuidIndex, IN ULONG InstanceIndex,
					   IN ULONG DataItemId, IN ULONG BufferSize,
					   IN PUCHAR pBuffer);

// End of prototypes.


#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, Spx_DispatchSystemControl)
#pragma alloc_text(PAGE, SpxPort_WmiInitializeWmilibContext)
#pragma alloc_text(PAGE, SpxPort_WmiQueryRegInfo)
#pragma alloc_text(PAGE, SpxPort_WmiQueryDataBlock)
#pragma alloc_text(PAGE, SpxPort_WmiSetDataBlock)
#pragma alloc_text(PAGE, SpxPort_WmiSetDataItem)
#endif




/********************************************************************************
********************								*****************************
********************	Spx_SystemControlDispatch	*****************************
********************								*****************************
********************************************************************************/
NTSTATUS
Spx_DispatchSystemControl(IN PDEVICE_OBJECT pDevObject, IN PIRP pIrp)
{
    PCOMMON_OBJECT_DATA		pCommonData = (PCOMMON_OBJECT_DATA) pDevObject->DeviceExtension;
    SYSCTL_IRP_DISPOSITION	IrpDisposition;
	PDEVICE_OBJECT			pLowerDevObj = pCommonData->LowerDeviceObject;
    NTSTATUS				status = pIrp->IoStatus.Status;

    PAGED_CODE();

	SpxDbgMsg(SPX_TRACE_CALLS,("%s: Entering Spx_DispatchSystemControl.\n", PRODUCT_NAME));

    status = WmiSystemControl(&pCommonData->WmiLibInfo, pDevObject, pIrp, &IrpDisposition);
                                 
    switch(IrpDisposition)
    {
        case IrpProcessed:
        {
            // This irp has been processed and may be completed or pending.
            break;
        }
        
        case IrpNotCompleted:
        {
            // This irp has not been completed, but has been fully processed, we will complete it now.
            IoCompleteRequest(pIrp, IO_NO_INCREMENT);                
            break;
        }
        
        case IrpForward:
        case IrpNotWmi:
        {
            // This irp is either not a WMI irp or is a WMI irp targetted at a device lower in the stack.

			if(pLowerDevObj)	// If we can pass the IRP down we must do so.
			{
				IoSkipCurrentIrpStackLocation(pIrp);
				status = IoCallDriver(pLowerDevObj, pIrp);
			}
			else	// Otherwise complete the IRP.
			{
				status = pIrp->IoStatus.Status;
				//pIrp->IoStatus.Information = 0;
				IoCompleteRequest(pIrp,IO_NO_INCREMENT);
			}

            break;
        }
                                    
        default:
        {
            // We really should never get here, but if we do just forward....
            ASSERT(FALSE);
			
			if(pLowerDevObj)	// If we can pass the IRP down we must do so.
			{
				IoSkipCurrentIrpStackLocation(pIrp);
				status = IoCallDriver(pLowerDevObj, pIrp);
			}
			else	// Otherwise complete the IRP.
			{
				status = pIrp->IoStatus.Status;
				//pIrp->IoStatus.Information = 0;
				IoCompleteRequest(pIrp,IO_NO_INCREMENT);
			}

            break;
        }        
    }
    
	return(status);
}







// End of prototypes.


#define WMI_SERIAL_PORT_NAME_INFORMATION 0
#define WMI_SERIAL_PORT_COMM_INFORMATION 1
#define WMI_SERIAL_PORT_HW_INFORMATION   2
#define WMI_SERIAL_PORT_PERF_INFORMATION 3
#define WMI_SERIAL_PORT_PROPERTIES       4

GUID StdSerialPortNameGuid				= SERIAL_PORT_WMI_NAME_GUID;			// Standard Serial WMI
GUID StdSerialPortCommGuid				= SERIAL_PORT_WMI_COMM_GUID;			// Standard Serial WMI
GUID StdSerialPortHWGuid				= SERIAL_PORT_WMI_HW_GUID;				// Standard Serial WMI
GUID StdSerialPortPerfGuid				= SERIAL_PORT_WMI_PERF_GUID;			// Standard Serial WMI
GUID StdSerialPortPropertiesGuid		= SERIAL_PORT_WMI_PROPERTIES_GUID;		// Standard Serial WMI

WMIGUIDREGINFO SpxPort_WmiGuidList[] =
{
    { &StdSerialPortNameGuid, 1, 0 },
    { &StdSerialPortCommGuid, 1, 0 },
    { &StdSerialPortHWGuid, 1, 0 },
    { &StdSerialPortPerfGuid, 1, 0 },
    { &StdSerialPortPropertiesGuid, 1, 0}
};


#define SpxPort_WmiGuidCount (sizeof(SpxPort_WmiGuidList) / sizeof(WMIGUIDREGINFO))




NTSTATUS
SpxPort_WmiInitializeWmilibContext(IN PWMILIB_CONTEXT WmilibContext)
/*++

Routine Description:

    This routine will initialize the wmilib context structure with the
    guid list and the pointers to the wmilib callback functions. This routine
    should be called before calling IoWmiRegistrationControl to register
    your device object.

Arguments:

    WmilibContext is pointer to the wmilib context.

Return Value:

    status

--*/
{
	PAGED_CODE();

    RtlZeroMemory(WmilibContext, sizeof(WMILIB_CONTEXT));
  
    WmilibContext->GuidCount			= SpxPort_WmiGuidCount;
    WmilibContext->GuidList				= SpxPort_WmiGuidList;    
    
    WmilibContext->QueryWmiRegInfo		= SpxPort_WmiQueryRegInfo;
    WmilibContext->QueryWmiDataBlock	= SpxPort_WmiQueryDataBlock;
    WmilibContext->SetWmiDataBlock		= SpxPort_WmiSetDataBlock;
    WmilibContext->SetWmiDataItem		= SpxPort_WmiSetDataItem;
	WmilibContext->ExecuteWmiMethod		= NULL;	
    WmilibContext->WmiFunctionControl	= NULL;	

    return(STATUS_SUCCESS);
}





//
// WMI System Call back functions
//


NTSTATUS
SpxPort_WmiQueryRegInfo(IN PDEVICE_OBJECT pDevObject, OUT PULONG pRegFlags,
						OUT PUNICODE_STRING pInstanceName,
						OUT PUNICODE_STRING *pRegistryPath,
						OUT PUNICODE_STRING MofResourceName,
						OUT PDEVICE_OBJECT *pPdo)
{
	NTSTATUS status = STATUS_SUCCESS;
	PPORT_DEVICE_EXTENSION pPort = (PPORT_DEVICE_EXTENSION)pDevObject->DeviceExtension;
   
	PAGED_CODE();

	*pRegFlags = WMIREG_FLAG_INSTANCE_PDO;
	*pRegistryPath = &SavedRegistryPath;
	*pPdo = pDevObject;  // Port device object is a PDO.


	return(status);
}





NTSTATUS
SpxPort_WmiQueryDataBlock(IN PDEVICE_OBJECT pDevObject, IN PIRP pIrp,
						  IN ULONG GuidIndex, IN ULONG InstanceIndex,
						  IN ULONG InstanceCount, IN OUT PULONG pInstanceLengthArray,
						  IN ULONG OutBufferSize, OUT PUCHAR pBuffer)
{
    PPORT_DEVICE_EXTENSION pPort = (PPORT_DEVICE_EXTENSION)pDevObject->DeviceExtension;
	NTSTATUS status;
    ULONG size = 0;

    PAGED_CODE();

    switch(GuidIndex) 
	{
    case WMI_SERIAL_PORT_NAME_INFORMATION:
		{
			size = pPort->DosName.Length;

			if(OutBufferSize < (size + sizeof(USHORT))) 
			{
				size += sizeof(USHORT);
				status = STATUS_BUFFER_TOO_SMALL;
				break;
			}

			if(pPort->DosName.Buffer == NULL) 
			{
				status = STATUS_INSUFFICIENT_RESOURCES;
				break;
			}

			// First, copy the string over containing our identifier
			*(USHORT *)pBuffer = (USHORT)size;
			(UCHAR *)pBuffer += sizeof(USHORT);

			RtlCopyMemory(pBuffer, pPort->DosName.Buffer, size);

			// Increment total size to include the WORD containing our len
			size += sizeof(USHORT);
			*pInstanceLengthArray = size;
                
			status = STATUS_SUCCESS;

			break;
		}

    case WMI_SERIAL_PORT_COMM_INFORMATION: 
		{
			size = sizeof(SERIAL_WMI_COMM_DATA);

			if(OutBufferSize < size) 
			{
				status = STATUS_BUFFER_TOO_SMALL;
				break;
			}

			*pInstanceLengthArray = size;
			*(PSERIAL_WMI_COMM_DATA)pBuffer = pPort->WmiCommData;

			status = STATUS_SUCCESS;

			break;
		}

    case WMI_SERIAL_PORT_HW_INFORMATION:
		{
			size = sizeof(SERIAL_WMI_HW_DATA);

			if(OutBufferSize < size) 
			{
				status = STATUS_BUFFER_TOO_SMALL;
				break;
			}

			*pInstanceLengthArray = size;
			*(PSERIAL_WMI_HW_DATA)pBuffer = pPort->WmiHwData;

			status = STATUS_SUCCESS;

			break;
		}

    case WMI_SERIAL_PORT_PERF_INFORMATION: 
		{
			size = sizeof(SERIAL_WMI_PERF_DATA);

			if(OutBufferSize < size) 
			{
				status = STATUS_BUFFER_TOO_SMALL;
				break;
			}

			*pInstanceLengthArray = size;
			*(PSERIAL_WMI_PERF_DATA)pBuffer = pPort->WmiPerfData;

			status = STATUS_SUCCESS;

			break;
		}

    case WMI_SERIAL_PORT_PROPERTIES: 
		{
			size = sizeof(SERIAL_COMMPROP) + sizeof(ULONG);

			if(OutBufferSize < size) 
			{
				status = STATUS_BUFFER_TOO_SMALL;
				break;
			}

			*pInstanceLengthArray = size;
			SerialGetProperties(pPort, (PSERIAL_COMMPROP)pBuffer);
       
			*((PULONG)(((PSERIAL_COMMPROP)pBuffer)->ProvChar)) = 0;

			status = STATUS_SUCCESS;

			break;
		}


	default:
		status = STATUS_WMI_GUID_NOT_FOUND;
		break;

    }

    status = WmiCompleteRequest(pDevObject, pIrp, status, size, IO_NO_INCREMENT);
	
	return(status);
}







NTSTATUS
SpxPort_WmiSetDataBlock(IN PDEVICE_OBJECT pDevObject, IN PIRP pIrp,
						IN ULONG GuidIndex, IN ULONG InstanceIndex,
						IN ULONG BufferSize, IN PUCHAR pBuffer)
{
    PPORT_DEVICE_EXTENSION pPort = (PPORT_DEVICE_EXTENSION)pDevObject->DeviceExtension;
	NTSTATUS status;
    ULONG size = 0;

	PAGED_CODE();

	switch(GuidIndex)
	{
	case WMI_SERIAL_PORT_NAME_INFORMATION:
	case WMI_SERIAL_PORT_COMM_INFORMATION:
	case WMI_SERIAL_PORT_HW_INFORMATION:
	case WMI_SERIAL_PORT_PERF_INFORMATION:
	case WMI_SERIAL_PORT_PROPERTIES:
		status = STATUS_WMI_READ_ONLY;		
		break;										


	default:
		status = STATUS_WMI_GUID_NOT_FOUND;
		break;
	}

    status = WmiCompleteRequest(pDevObject, pIrp, status, size, IO_NO_INCREMENT);
	
	return(status);
}





NTSTATUS
SpxPort_WmiSetDataItem(IN PDEVICE_OBJECT pDevObject, IN PIRP pIrp,
					   IN ULONG GuidIndex, IN ULONG InstanceIndex,
					   IN ULONG DataItemId, IN ULONG BufferSize,
					   IN PUCHAR pBuffer)
{
    PPORT_DEVICE_EXTENSION pPort = (PPORT_DEVICE_EXTENSION)pDevObject->DeviceExtension;
	NTSTATUS status;
    ULONG size = 0;

	PAGED_CODE();

	switch(GuidIndex)
	{
	case WMI_SERIAL_PORT_NAME_INFORMATION:
	case WMI_SERIAL_PORT_COMM_INFORMATION:
	case WMI_SERIAL_PORT_HW_INFORMATION:
	case WMI_SERIAL_PORT_PERF_INFORMATION:
	case WMI_SERIAL_PORT_PROPERTIES:
		status = STATUS_WMI_READ_ONLY;		
		break;										


	default:
		status = STATUS_WMI_GUID_NOT_FOUND;
		break;
	}

    status = WmiCompleteRequest(pDevObject, pIrp, status, size, IO_NO_INCREMENT);
	
	return(status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\spx\speed\driver\inc\esils.h ===
/************************************************************************/
/*																		*/
/*	Title:		Engineering Services Incident Log (ESIL)				*/
/*																		*/
/*	Author:		P.B Smith												*/
/*																		*/
/*	Version:	1.0.0 (SPEED NT Driver Version)							*/
/*																		*/
/*	Creation:	12th April 1999											*/
/*																		*/
/*	Description:	Contains descriptions and definitions of all		*/
/*					ESIL reports and modifications applied to the		*/
/*					SPEED NT Driver.									*/
/*																		*/
/************************************************************************/
#ifndef ESILS_H
#define ESILS_H

/* ESIL Log...
	
	ESIL		Date	 Author		Description
	====		====	 ======		=========== */




#endif	// End of ESILS.H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\spx\speed\driver\waitmask.c ===
/*++

Copyright (c) 1991, 1992, 1993 Microsoft Corporation

Module Name:

    waitmask.c

Abstract:

    This module contains the code that is very specific to get/set/wait
    on event mask operations in the serial driver

Author:

    Anthony V. Ercolano 26-Sep-1991

Environment:

    Kernel mode

Revision History :

--*/

#include "precomp.h"

// Prototypes
BOOLEAN SerialGrabWaitFromIsr(IN PVOID Context);
BOOLEAN SerialGiveWaitToIsr(IN PVOID Context);
BOOLEAN SerialFinishOldWait(IN PVOID Context);
// End of prototypes    
    

#ifdef ALLOC_PRAGMA
#endif


NTSTATUS
SerialStartMask(IN PPORT_DEVICE_EXTENSION pPort)
/*++

Routine Description:

    This routine is used to process the set mask and wait
    mask ioctls.  Calls to this routine are serialized by
    placing irps in the list under the protection of the
    cancel spin lock.

Arguments:

    Extension - A pointer to the serial device extension.

Return Value:

    Will return pending for everything put the first
    request that we actually process.  Even in that
    case it will return pending unless it can complete
    it right away.


--*/
{

    //
    // The current stack location.  This contains much of the
    // information we need to process this particular request.
    //
    PIO_STACK_LOCATION IrpSp;

    PIRP NewIrp;

    BOOLEAN SetFirstStatus = FALSE;
    NTSTATUS FirstStatus;

    SerialDump(SERDIAG3,("In SerialStartMask\n"));

    ASSERT(pPort->CurrentMaskIrp);

    do 
	{
        SerialDump(SERDIAG4,("STARTMASK - CurrentMaskIrp: %x\n", pPort->CurrentMaskIrp));

        IrpSp = IoGetCurrentIrpStackLocation(pPort->CurrentMaskIrp);

        ASSERT((IrpSp->Parameters.DeviceIoControl.IoControlCode == IOCTL_SERIAL_WAIT_ON_MASK) 
			|| (IrpSp->Parameters.DeviceIoControl.IoControlCode == IOCTL_SERIAL_SET_WAIT_MASK));
                

        if(IrpSp->Parameters.DeviceIoControl.IoControlCode == IOCTL_SERIAL_SET_WAIT_MASK)
		{

            SerialDump(SERDIAG4, ("SERIAL - %x is a SETMASK irp\n", pPort->CurrentMaskIrp));
                
            // Complete the old wait if there is one.
            KeSynchronizeExecution(pPort->Interrupt, SerialFinishOldWait, pPort);
                

            //
            // Any current waits should be on its way to completion
            // at this point.  There certainly shouldn't be any
            // irp mask location.
            //

            ASSERT(!pPort->IrpMaskLocation);

            pPort->CurrentMaskIrp->IoStatus.Status = STATUS_SUCCESS;

            if(!SetFirstStatus) 
			{
                SerialDump(SERDIAG4,("%x was the first irp processed by this\n"
									   "------- invocation of startmask\n", pPort->CurrentMaskIrp));
                    
                FirstStatus = STATUS_SUCCESS;
                SetFirstStatus = TRUE;
            }

            // The following call will also cause the current call to be completed.
            SerialGetNextIrp(pPort, &pPort->CurrentMaskIrp, &pPort->MaskQueue, &NewIrp, TRUE);
                
                
            SerialDump(SERDIAG4,("Perhaps another mask irp was found in the queue\n"
                "------- %x/%x <- values should be the same\n", pPort->CurrentMaskIrp, NewIrp));

        } 
		else 
		{
            //
            // First make sure that we have a non-zero mask.
            // If the app queues a wait on a zero mask it can't
            // be statisfied so it makes no sense to start it.
            //

            if((!pPort->IsrWaitMask) || (pPort->CurrentWaitIrp)) 
			{

                SerialDump(SERDIAG4,("WaitIrp is invalid\n"
                    "------- IsrWaitMask: %x\n"
                    "------- CurrentWaitIrp: %x\n",
                     pPort->IsrWaitMask,
                     pPort->CurrentWaitIrp));
                     

                pPort->CurrentMaskIrp->IoStatus.Status = STATUS_INVALID_PARAMETER;

                if(!SetFirstStatus) 
				{
                    SerialDump(SERDIAG4,("%x was the first irp processed by this\n"
                         "------- invocation of startmask\n", pPort->CurrentMaskIrp));
                        
                    FirstStatus = STATUS_INVALID_PARAMETER;
                    SetFirstStatus = TRUE;
                }

                SerialGetNextIrp(pPort, &pPort->CurrentMaskIrp, &pPort->MaskQueue, &NewIrp, TRUE);
                    
                    
                    
                SerialDump(SERDIAG4,("Perhaps another mask irp was found in the queue\n"
                    "------- %x/%x <- values should be the same\n",
                    pPort->CurrentMaskIrp,NewIrp));

            } 
			else 
			{
                KIRQL OldIrql;

                //
                // Make the current mask irp the current wait irp and
                // get a new current mask irp.  Note that when we get
                // the new current mask irp we DO NOT complete the
                // old current mask irp (which is now the current wait
                // irp.
                //
                // Then under the protection of the cancel spin lock
                // we check to see if the current wait irp needs to
                // be canceled
                //

                IoAcquireCancelSpinLock(&OldIrql);

                if(pPort->CurrentMaskIrp->Cancel) 
				{
                    SerialDump(SERDIAG4, ("%x irp was already marked as cancelled\n", pPort->CurrentMaskIrp));
                         
                    IoReleaseCancelSpinLock(OldIrql);
                    pPort->CurrentMaskIrp->IoStatus.Status = STATUS_CANCELLED;

                    if(!SetFirstStatus) 
					{
                        SerialDump(SERDIAG4, ("%x was the first irp processed by this\n"
                             "------- invocation of startmask\n", pPort->CurrentMaskIrp));
                            
                        FirstStatus = STATUS_CANCELLED;
                        SetFirstStatus = TRUE;
                    }

                    SerialGetNextIrp(pPort, &pPort->CurrentMaskIrp, &pPort->MaskQueue, &NewIrp, TRUE);
                        
                    SerialDump(SERDIAG4,("Perhaps another mask irp was found in the queue\n"
                        "------- %x/%x <- values should be the same\n", pPort->CurrentMaskIrp, NewIrp));
                } 
				else 
				{

                    SerialDump(SERDIAG4, ("%x will become the current wait irp\n", pPort->CurrentMaskIrp));
                        
                    if(!SetFirstStatus) 
					{

                        SerialDump(SERDIAG4,("%x was the first irp processed by this\n"
                            "------- invocation of startmask\n", pPort->CurrentMaskIrp));
                            
                        FirstStatus = STATUS_PENDING;
                        SetFirstStatus = TRUE;

                        //
                        // If we haven't already set a first status
                        // then there is a chance that this packet
                        // was never on the queue.  We should mark
                        // it as pending.
                        //

                        IoMarkIrpPending(pPort->CurrentMaskIrp);
                    }

                    //
                    // There should never be a mask location when
                    // there isn't a current wait irp.  At this point
                    // there shouldn't be a current wait irp also.
                    //

                    ASSERT(!pPort->IrpMaskLocation);
                    ASSERT(!pPort->CurrentWaitIrp);

                    pPort->CurrentWaitIrp = pPort->CurrentMaskIrp;
                    SERIAL_INIT_REFERENCE(pPort->CurrentWaitIrp);
                    IoSetCancelRoutine(pPort->CurrentWaitIrp, SerialCancelWait);
                        
                    //
                    // Since the cancel routine has a reference to#
                    // the irp we need to update the reference
                    // count.
                    //

                    SERIAL_SET_REFERENCE(pPort->CurrentWaitIrp, SERIAL_REF_CANCEL);

                    KeSynchronizeExecution(pPort->Interrupt, SerialGiveWaitToIsr, pPort);
                        

                    //
                    // Since it isn't really the mask irp anymore,
                    // null out that pointer.
                    //

                    pPort->CurrentMaskIrp = NULL;

                    IoReleaseCancelSpinLock(OldIrql);

                    SerialGetNextIrp(pPort, &pPort->CurrentMaskIrp, &pPort->MaskQueue, &NewIrp, FALSE);
                       
                    SerialDump(SERDIAG4,("Perhaps another mask irp was found in the queue\n"
                        "------- %x/%x <- values should be the same\n", pPort->CurrentMaskIrp, NewIrp));
                       
                }

            }

        }

    } while (NewIrp);

    return FirstStatus;

}


BOOLEAN
SerialGrabWaitFromIsr(IN PVOID Context)
/*++

Routine Description:

    This routine will check to see if the ISR still knows about
    a wait irp by checking to see if the IrpMaskLocation is non-null.
    If it is then it will zero the Irpmasklocation (which in effect
    grabs the irp away from the isr).  This routine is only called
    buy the cancel code for the wait.

    NOTE: This is called by KeSynchronizeExecution.

Arguments:

    Context - A pointer to the device extension

Return Value:

    Always FALSE.

--*/

{

    PPORT_DEVICE_EXTENSION pPort = Context;

    SerialDump(SERDIAG3,("In SerialGrabWaitFromIsr\n"));
        
        
        

    if(pPort->IrpMaskLocation) 
	{
        SerialDump(SERDIAG4,("The isr still owns the irp %x, mask location is %x\n"
             "------- and system buffer is %x\n",
             pPort->CurrentWaitIrp, pPort->IrpMaskLocation,
             pPort->CurrentWaitIrp->AssociatedIrp.SystemBuffer));
            

        // The isr still "owns" the irp.

        *pPort->IrpMaskLocation = 0;
        pPort->IrpMaskLocation = NULL;

        pPort->CurrentWaitIrp->IoStatus.Information = sizeof(ULONG);

        //
        // Since the isr no longer references the irp we need to
        // decrement the reference count.
        //

        SERIAL_CLEAR_REFERENCE(pPort->CurrentWaitIrp, SERIAL_REF_ISR);
            
    }

    return FALSE;
}


BOOLEAN
SerialGiveWaitToIsr(IN PVOID Context)
/*++

Routine Description:

    This routine simply sets a variable in the device extension
    so that the isr knows that we have a wait irp.

    NOTE: This is called by KeSynchronizeExecution.

    NOTE: This routine assumes that it is called with the
          cancel spinlock held.

Arguments:

    Context - Simply a pointer to the device extension.

Return Value:

    Always FALSE.

--*/

{

    PPORT_DEVICE_EXTENSION pPort = Context;

    SerialDump(SERDIAG3,("In SerialGiveWaitToIsr\n"));
        
    //
    // There certainly shouldn't be a current mask location at
    // this point since we have a new current wait irp.
    //

    ASSERT(!pPort->IrpMaskLocation);

    //
    // The isr may or may not actually reference this irp.  It
    // won't if the wait can be satisfied immediately.  However,
    // since it will then go through the normal completion sequence,
    // we need to have an incremented reference count anyway.
    //

    SERIAL_SET_REFERENCE(pPort->CurrentWaitIrp, SERIAL_REF_ISR);
        
        
       

    if(!pPort->HistoryMask) 
	{
        SerialDump(SERDIAG4, ("No events occured prior to the wait call\n"));
            
        //
        // Although this wait might not be for empty transmit
        // queue, it doesn't hurt anything to set it to false.
        //

        pPort->EmptiedTransmit = FALSE;

        //
        // Record where the "completion mask" should be set.
        //

        pPort->IrpMaskLocation = pPort->CurrentWaitIrp->AssociatedIrp.SystemBuffer;
        

        SerialDump(SERDIAG4,("The isr owns the irp %x, mask location is %x\n"
             "------- and system buffer is %x\n",
             pPort->CurrentWaitIrp, pPort->IrpMaskLocation,
             pPort->CurrentWaitIrp->AssociatedIrp.SystemBuffer));
    } 
	else 
	{

        SerialDump(SERDIAG4, ("%x occurred prior to the wait - starting the\n"
             "------- completion code for %x\n",
             pPort->HistoryMask, pPort->CurrentWaitIrp));
            
        *((ULONG *)pPort->CurrentWaitIrp->AssociatedIrp.SystemBuffer) = pPort->HistoryMask;
           
        pPort->HistoryMask = 0;
        pPort->CurrentWaitIrp->IoStatus.Information = sizeof(ULONG);
        pPort->CurrentWaitIrp->IoStatus.Status = STATUS_SUCCESS;

 		// Mark IRP as about to complete normally to prevent cancel & timer DPCs
		// from doing so before DPC is allowed to run.
		//SERIAL_SET_REFERENCE(pPort->CurrentWaitIrp, SERIAL_REF_COMPLETING);
       
		KeInsertQueueDpc(&pPort->CommWaitDpc, NULL, NULL);
            
    }

    return FALSE;
}


BOOLEAN
SerialFinishOldWait(IN PVOID Context)
/*++

Routine Description:

    This routine will check to see if the ISR still knows about
    a wait irp by checking to see if the Irpmasklocation is non-null.
    If it is then it will zero the Irpmasklocation (which in effect
    grabs the irp away from the isr).  This routine is only called
    buy the cancel code for the wait.

    NOTE: This is called by KeSynchronizeExecution.

Arguments:

    Context - A pointer to the device extension

Return Value:

    Always FALSE.

--*/

{

    PPORT_DEVICE_EXTENSION pPort = Context;

    SerialDump(SERDIAG3,("In SerialFinishOldWait\n"));
        
        
       
    if(pPort->IrpMaskLocation) 
	{

        SerialDump(SERDIAG4, ("The isr still owns the irp %x, mask location is %x\n"
             "------- and system buffer is %x\n",
             pPort->CurrentWaitIrp, pPort->IrpMaskLocation,
             pPort->CurrentWaitIrp->AssociatedIrp.SystemBuffer));
   
		//
        // The isr still "owns" the irp.
        //
        *pPort->IrpMaskLocation = 0;
        pPort->IrpMaskLocation = NULL;

        pPort->CurrentWaitIrp->IoStatus.Information = sizeof(ULONG);

        //
        // We don't decrement the reference since the completion routine
        // will do that.
        //

		// Mark IRP as about to complete normally to prevent cancel & timer DPCs
		// from doing so before DPC is allowed to run.
		//SERIAL_SET_REFERENCE(pPort->CurrentWaitIrp, SERIAL_REF_COMPLETING);

        KeInsertQueueDpc(&pPort->CommWaitDpc, NULL, NULL);
            
    }

    //
    // Don't wipe out any historical data we are still interested in.
    //

    pPort->HistoryMask &= *((ULONG *)pPort->CurrentMaskIrp->AssociatedIrp.SystemBuffer);
                                            
    pPort->IsrWaitMask = *((ULONG *)pPort->CurrentMaskIrp->AssociatedIrp.SystemBuffer);

	// Setup UART for special character detection
	if(pPort->IsrWaitMask & SERIAL_EV_RXFLAG)
	{
		pPort->UartConfig.SpecialMode |= UC_SM_DETECT_SPECIAL_CHAR;
		pPort->pUartLib->UL_SetConfig_XXXX(pPort->pUart, &pPort->UartConfig, UC_SPECIAL_MODE_MASK);
	}
	else
	{
		pPort->UartConfig.SpecialMode &= ~UC_SM_DETECT_SPECIAL_CHAR;
		pPort->pUartLib->UL_SetConfig_XXXX(pPort->pUart, &pPort->UartConfig, UC_SPECIAL_MODE_MASK);
	}

    SerialDump(SERDIAG4, ("Set mask location of %x, in irp %x, with system buffer of %x\n",
         pPort->IrpMaskLocation,
         pPort->CurrentMaskIrp, pPort->CurrentMaskIrp->AssociatedIrp.SystemBuffer));
        
        
    return FALSE;
}


VOID
SerialCancelWait(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp)
/*++

Routine Description:

    This routine is used to cancel a irp that is waiting on
    a comm event.

Arguments:

    DeviceObject - Pointer to the device object for this device

    Irp - Pointer to the IRP for the current request

Return Value:

    None.

--*/

{
    PPORT_DEVICE_EXTENSION pPort = DeviceObject->DeviceExtension;

    SerialDump(SERDIAG3, ("In SerialCancelWait\n"));
        
    SerialDump(SERDIAG4, ("Canceling wait for irp %x\n", pPort->CurrentWaitIrp));
        
    SerialTryToCompleteCurrent(	pPort,
								SerialGrabWaitFromIsr,
								Irp->CancelIrql,
								STATUS_CANCELLED,
								&pPort->CurrentWaitIrp,
								NULL,
								NULL,
								NULL,
								NULL,
								NULL,
								SERIAL_REF_CANCEL);
        

}


VOID
SerialCompleteWait(IN PKDPC Dpc,
				   IN PVOID DeferredContext,
				   IN PVOID SystemContext1,
				   IN PVOID SystemContext2)
{

    PPORT_DEVICE_EXTENSION pPort = DeferredContext;
    KIRQL OldIrql;

    SerialDump(SERDIAG3, ("In SerialCompleteWait\n"));
       
        
    UNREFERENCED_PARAMETER(Dpc);
    UNREFERENCED_PARAMETER(SystemContext1);
    UNREFERENCED_PARAMETER(SystemContext2);

    IoAcquireCancelSpinLock(&OldIrql);

    SerialDump(SERDIAG4, ("Completing wait for irp %x\n", pPort->CurrentWaitIrp));
   
	// Clear the normal complete reference.
	//SERIAL_CLEAR_REFERENCE(pPort->CurrentWaitIrp, SERIAL_REF_COMPLETING);

    SerialTryToCompleteCurrent(	pPort,
								NULL,
								OldIrql,
								STATUS_SUCCESS,
								&pPort->CurrentWaitIrp,
								NULL,
								NULL,
								NULL,
								NULL,
								NULL,
								SERIAL_REF_ISR);
								

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\spx\speed\driver\write.c ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) 1991, 1992, 1993 Microsoft Corporation

Module Name:

    write.c

Abstract:

    This module contains the code that is very specific to write
    operations in the serial driver

Author:

    Anthony V. Ercolano 26-Sep-1991

Environment:

    Kernel mode

Revision History :

-----------------------------------------------------------------------------*/

#include "precomp.h"

//Prototypes
BOOLEAN SerialGiveWriteToIsr(IN PVOID Context);
VOID SerialCancelCurrentWrite(PDEVICE_OBJECT DeviceObject, PIRP Irp);
BOOLEAN SerialGrabWriteFromIsr(IN PVOID Context);
BOOLEAN SerialGrabXoffFromIsr(IN PVOID Context);
VOID SerialCancelCurrentXoff(PDEVICE_OBJECT DeviceObject, PIRP Irp);
BOOLEAN SerialGiveXoffToIsr(IN PVOID Context);
//End of prototypes.    
    

#ifdef ALLOC_PRAGMA
#endif


NTSTATUS
SerialWrite(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp)
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

    This is the dispatch routine for write.  It validates the parameters
    for the write request and if all is ok then it places the request
    on the work queue.

Arguments:

    DeviceObject - Pointer to the device object for this device

    Irp - Pointer to the IRP for the current request

Return Value:

    If the io is zero length then it will return STATUS_SUCCESS,
    otherwise this routine will return STATUS_PENDING.

-----------------------------------------------------------------------------*/
{
    PPORT_DEVICE_EXTENSION pPort = DeviceObject->DeviceExtension;

    SerialDump(SERIRPPATH, ("Write Irp dispatch entry for: %x\n", Irp));
	SpxIRPCounter(pPort, Irp, IRP_SUBMITTED);	// Increment counter for performance stats.

    if(SerialCompleteIfError(DeviceObject, Irp) != STATUS_SUCCESS) 
        return STATUS_CANCELLED;

    Irp->IoStatus.Information = 0L;

    //
    // Quick check for a zero length write.  If it is zero length
    // then we are already done!
    //

    if(IoGetCurrentIrpStackLocation(Irp)->Parameters.Write.Length) 
	{
        //
        // Well it looks like we actually have to do some
        // work.  Put the write on the queue so that we can
        // process it when our previous writes are done.
        //

        return SerialStartOrQueue(	pPort,
									Irp,
									&pPort->WriteQueue,
									&pPort->CurrentWriteIrp,
									SerialStartWrite);
    } 
	else 
	{
        Irp->IoStatus.Status = STATUS_SUCCESS;
        SerialDump(SERIRPPATH,("Complete Write Irp: %x\n",Irp));
       	SpxIRPCounter(pPort, Irp, IRP_COMPLETED);	// Increment counter for performance stats.
        IoCompleteRequest(Irp,0);

        return STATUS_SUCCESS;
    }

}

NTSTATUS
SerialStartWrite(IN PPORT_DEVICE_EXTENSION pPort)
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

    This routine is used to start off any write.  It initializes
    the Iostatus fields of the irp.  It will set up any timers
    that are used to control the write.

Arguments:

    Extension - Points to the serial device extension

Return Value:

    This routine will return STATUS_PENDING for all writes
    other than those that we find are cancelled.

-----------------------------------------------------------------------------*/
{

    PIRP NewIrp;
    KIRQL OldIrql;
    LARGE_INTEGER TotalTime;
    BOOLEAN UseATimer;
    SERIAL_TIMEOUTS Timeouts;
    BOOLEAN SetFirstStatus = FALSE;
    NTSTATUS FirstStatus;

    do 
	{
        // If there is an xoff counter then complete it.
        IoAcquireCancelSpinLock(&OldIrql);

        //
        // We see if there is a actually an Xoff counter irp.
        //
        // If there is, we put the write irp back on the head
        // of the write list.  We then kill the xoff counter.
        // The xoff counter killing code will actually make the
        // xoff counter back into the current write irp, and
        // in the course of completing the xoff (which is now
        // the current write) we will restart this irp.
        //

        if(pPort->CurrentXoffIrp) 
		{
            if(SERIAL_REFERENCE_COUNT(pPort->CurrentXoffIrp)) 
			{
                //
                // The reference count is non-zero.  This implies that
                // the xoff irp has not made it through the completion
                // path yet.  We will increment the reference count
                // and attempt to complete it ourseleves.
                //
                SERIAL_SET_REFERENCE(pPort->CurrentXoffIrp, SERIAL_REF_XOFF_REF);

                //
                // The following call will actually release the
                // cancel spin lock.
                //

                SerialTryToCompleteCurrent(	pPort,
											SerialGrabXoffFromIsr,
											OldIrql,
											STATUS_SERIAL_MORE_WRITES,
											&pPort->CurrentXoffIrp,
											NULL,
											NULL,
											&pPort->XoffCountTimer,
											NULL,
											NULL,
											SERIAL_REF_XOFF_REF);
            } 
			else 
			{

                //
                // The irp is well on its way to being finished.
                // We can let the regular completion code do the
                // work.  Just release the spin lock.
                //

                IoReleaseCancelSpinLock(OldIrql);

            }

        } 
		else 
		{
            IoReleaseCancelSpinLock(OldIrql);
        }

        UseATimer = FALSE;

        //
        // Calculate the timeout value needed for the
        // request.  Note that the values stored in the
        // timeout record are in milliseconds.  Note that
        // if the timeout values are zero then we won't start
        // the timer.
        //

        KeAcquireSpinLock(&pPort->ControlLock, &OldIrql);
        Timeouts = pPort->Timeouts;
        KeReleaseSpinLock(&pPort->ControlLock, OldIrql);
            

        if(Timeouts.WriteTotalTimeoutConstant ||  Timeouts.WriteTotalTimeoutMultiplier)
		{
            PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation(pPort->CurrentWriteIrp);
                                           
            UseATimer = TRUE;

            //
            // We have some timer values to calculate.
            //
            // Take care, we might have an xoff counter masquerading
            // as a write.
            //

            TotalTime.QuadPart = ((LONGLONG)((UInt32x32To64((IrpSp->MajorFunction == IRP_MJ_WRITE) 
								? (IrpSp->Parameters.Write.Length) : (1), 
								Timeouts.WriteTotalTimeoutMultiplier) + Timeouts.WriteTotalTimeoutConstant))) 
								* -10000;

        }

        //
        // The irp may be going to the isr shortly.  Now
        // is a good time to initialize its reference counts.
        //
        SERIAL_INIT_REFERENCE(pPort->CurrentWriteIrp);

        //
        // We need to see if this irp should be canceled.
        //

        IoAcquireCancelSpinLock(&OldIrql);

        if(pPort->CurrentWriteIrp->Cancel) 
		{
            IoReleaseCancelSpinLock(OldIrql);
            pPort->CurrentWriteIrp->IoStatus.Status = STATUS_CANCELLED;

            if(!SetFirstStatus) 
			{
                FirstStatus = STATUS_CANCELLED;
                SetFirstStatus = TRUE;
            }
        }
		else 
		{
            if(!SetFirstStatus) 
			{
                //
                // If we haven't set our first status, then
                // this is the only irp that could have possibly
                // not been on the queue.  (It could have been
                // on the queue if this routine is being invoked
                // from the completion routine.)  Since this
                // irp might never have been on the queue we
                // should mark it as pending.
                //

                IoMarkIrpPending(pPort->CurrentWriteIrp);
                SetFirstStatus = TRUE;
                FirstStatus = STATUS_PENDING;
            }

            //
            // We give the irp to to the isr to write out.
            // We set a cancel routine that knows how to
            // grab the current write away from the isr.
            //
            // Since the cancel routine has an implicit reference
            // to this irp up the reference count.
            //

            IoSetCancelRoutine(pPort->CurrentWriteIrp, SerialCancelCurrentWrite);

            SERIAL_SET_REFERENCE(pPort->CurrentWriteIrp, SERIAL_REF_CANCEL);

            if(UseATimer) 
			{
                KeSetTimer(&pPort->WriteRequestTotalTimer, TotalTime, &pPort->TotalWriteTimeoutDpc);
                    
                // This timer now has a reference to the irp.
                SERIAL_SET_REFERENCE(pPort->CurrentWriteIrp, SERIAL_REF_TOTAL_TIMER);
            }

            KeSynchronizeExecution(pPort->Interrupt, SerialGiveWriteToIsr, pPort);
                
            IoReleaseCancelSpinLock(OldIrql);
            break;
        }

        //
        // Well the write was canceled before we could start it up.
        // Try to get another.
        //

        SerialGetNextWrite(pPort, &pPort->CurrentWriteIrp, &pPort->WriteQueue, &NewIrp, TRUE);

    } while (NewIrp);

    return FirstStatus;

}

VOID
SerialGetNextWrite(IN PPORT_DEVICE_EXTENSION pPort,
				   IN PIRP *CurrentOpIrp,
				   IN PLIST_ENTRY QueueToProcess,
				   IN PIRP *NewIrp,
				   IN BOOLEAN CompleteCurrent)
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

    This routine completes the old write as well as getting
    a pointer to the next write.

    The reason that we have have pointers to the current write
    queue as well as the current write irp is so that this
    routine may be used in the common completion code for
    read and write.

Arguments:

    CurrentOpIrp - Pointer to the pointer that points to the
                   current write irp.

    QueueToProcess - Pointer to the write queue.

    NewIrp - A pointer to a pointer to the irp that will be the
             current irp.  Note that this could end up pointing
             to a null pointer.  This does NOT necessaryly mean
             that there is no current write.  What could occur
             is that while the cancel lock is held the write
             queue ended up being empty, but as soon as we release
             the cancel spin lock a new irp came in from
             SerialStartWrite.

    CompleteCurrent - Flag indicates whether the CurrentOpIrp should
                      be completed.

Return Value:

    None.

-----------------------------------------------------------------------------*/
{
	PCARD_DEVICE_EXTENSION pCard = NULL;
    pPort = CONTAINING_RECORD(QueueToProcess, PORT_DEVICE_EXTENSION, WriteQueue);
	pCard = pPort->pParentCardExt;

    do 
	{
        // We could be completing a flush.
        if(IoGetCurrentIrpStackLocation(*CurrentOpIrp)->MajorFunction == IRP_MJ_WRITE)
		{
            KIRQL OldIrql;

            ASSERT(pPort->TotalCharsQueued 
				>= (IoGetCurrentIrpStackLocation(*CurrentOpIrp)->Parameters.Write.Length));
                  
                    

            IoAcquireCancelSpinLock(&OldIrql);

            pPort->TotalCharsQueued -= IoGetCurrentIrpStackLocation(*CurrentOpIrp)->Parameters.Write.Length;
                
            IoReleaseCancelSpinLock(OldIrql);

        } 
		else if(IoGetCurrentIrpStackLocation(*CurrentOpIrp)->MajorFunction == IRP_MJ_DEVICE_CONTROL)
		{

            KIRQL OldIrql;
            PIRP Irp;
            PSERIAL_XOFF_COUNTER Xc;

            IoAcquireCancelSpinLock(&OldIrql);

            Irp = *CurrentOpIrp;
            Xc = Irp->AssociatedIrp.SystemBuffer;

            // We should never have a xoff counter when we get to this point.
            ASSERT(!pPort->CurrentXoffIrp);

            // We absolutely shouldn't have a cancel routine at this point.
            ASSERT(!Irp->CancelRoutine);

            // This could only be a xoff counter masquerading as a write irp.
            pPort->TotalCharsQueued--;

            //
            // Check to see of the xoff irp has been set with success.
            // This means that the write completed normally.  If that
            // is the case, and it hasn't been set to cancel in the
            // meanwhile, then go on and make it the CurrentXoffIrp.
            //

            if(Irp->IoStatus.Status != STATUS_SUCCESS) 
			{
                NOTHING; // Oh well, we can just finish it off.
            } 
			else if(Irp->Cancel) 
			{
                Irp->IoStatus.Status = STATUS_CANCELLED;
            } 
			else 
			{
                // Give it a new cancel routine, and increment the
                // reference count because the cancel routine has
                // a reference to it.
                IoSetCancelRoutine(Irp, SerialCancelCurrentXoff);
                SERIAL_SET_REFERENCE(Irp, SERIAL_REF_CANCEL);
                    

                // We don't want to complete the current irp now.  This
                // will now get completed by the Xoff counter code.
                CompleteCurrent = FALSE;


                // Give the counter to the isr.
                pPort->CurrentXoffIrp = Irp;
                KeSynchronizeExecution(pPort->Interrupt, SerialGiveXoffToIsr, pPort);
                    

                //
                // Start the timer for the counter and increment
                // the reference count since the timer has a
                // reference to the irp.
                //

                if(Xc->Timeout) 
				{
                    LARGE_INTEGER delta;

                    delta.QuadPart = -((LONGLONG)UInt32x32To64(1000, Xc->Timeout));

                    KeSetTimer(&pPort->XoffCountTimer, delta, &pPort->XoffCountTimeoutDpc);

                    SERIAL_SET_REFERENCE(Irp, SERIAL_REF_TOTAL_TIMER);
                }

            }

            IoReleaseCancelSpinLock(OldIrql);

        }

        //
        // Note that the following call will (probably) also cause
        // the current irp to be completed.
        //

        SerialGetNextIrp(pPort, CurrentOpIrp, QueueToProcess, NewIrp, CompleteCurrent);

        if(!*NewIrp) 
		{
            KIRQL OldIrql;

            IoAcquireCancelSpinLock(&OldIrql);
            KeSynchronizeExecution(pPort->Interrupt, SerialProcessEmptyTransmit, pPort);
            IoReleaseCancelSpinLock(OldIrql);

            break;

        } 
		else if(IoGetCurrentIrpStackLocation(*NewIrp)->MajorFunction == IRP_MJ_FLUSH_BUFFERS)
		{

            //
            // If we encounter a flush request we just want to get
            // the next irp and complete the flush.
            //
            // Note that if NewIrp is non-null then it is also
            // equal to CurrentWriteIrp.
            //
            ASSERT((*NewIrp) == (*CurrentOpIrp));
            (*NewIrp)->IoStatus.Status = STATUS_SUCCESS;
        } 
		else 
		{
            break;
        }

    } while (TRUE);

}

VOID
SerialCompleteWrite(IN PKDPC Dpc,
					IN PVOID DeferredContext,
					IN PVOID SystemContext1,
					IN PVOID SystemContext2)
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

    This routine is merely used to complete any write.  It
    assumes that the status and the information fields of
    the irp are already correctly filled in.

Arguments:

    Dpc - Not Used.

    DeferredContext - Really points to the device extension.

    SystemContext1 - Not Used.

    SystemContext2 - Not Used.

Return Value:

    None.
-----------------------------------------------------------------------------*/
{
    PPORT_DEVICE_EXTENSION pPort = DeferredContext;
    KIRQL OldIrql;

    UNREFERENCED_PARAMETER(Dpc);
    UNREFERENCED_PARAMETER(SystemContext1);
    UNREFERENCED_PARAMETER(SystemContext2);

    IoAcquireCancelSpinLock(&OldIrql);

	// Clear the normal complete reference.
	SERIAL_CLEAR_REFERENCE(pPort->CurrentWriteIrp, SERIAL_REF_COMPLETING);

    SerialTryToCompleteCurrent(	pPort,
								NULL,
								OldIrql,
								STATUS_SUCCESS,
								&pPort->CurrentWriteIrp,
								&pPort->WriteQueue,
								NULL,
								&pPort->WriteRequestTotalTimer,
								SerialStartWrite,
								SerialGetNextWrite,
								SERIAL_REF_ISR);
}

BOOLEAN
SerialProcessEmptyTransmit(IN PVOID Context)
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

    This routine is used to determine if conditions are appropriate
    to satisfy a wait for transmit empty event, and if so to complete
    the irp that is waiting for that event.  It also call the code
    that checks to see if we should lower the RTS line if we are
    doing transmit toggling.

    NOTE: This routine is called by KeSynchronizeExecution.

    NOTE: This routine assumes that it is called with the cancel
          spinlock held.

Arguments:

    Context - Really a pointer to the device extension.

Return Value:

    This routine always returns FALSE.

-----------------------------------------------------------------------------*/

{
    PPORT_DEVICE_EXTENSION pPort = Context;

    if(pPort->IsrWaitMask && (pPort->IsrWaitMask & SERIAL_EV_TXEMPTY) 
		&& pPort->EmptiedTransmit && (!pPort->TransmitImmediate) 
		&& (!pPort->CurrentWriteIrp) && IsListEmpty(&pPort->WriteQueue)) 
	{
        pPort->HistoryMask |= SERIAL_EV_TXEMPTY;
        
		if(pPort->IrpMaskLocation) 
		{

            *pPort->IrpMaskLocation = pPort->HistoryMask;
            pPort->IrpMaskLocation = NULL;
            pPort->HistoryMask = 0;

            pPort->CurrentWaitIrp->IoStatus.Information = sizeof(ULONG);

			// Mark IRP as about to complete normally to prevent cancel & timer DPCs
			// from doing so before DPC is allowed to run.
			//SERIAL_SET_REFERENCE(pPort->CurrentWaitIrp, SERIAL_REF_COMPLETING);
           
			KeInsertQueueDpc(&pPort->CommWaitDpc, NULL, NULL);
        }

        pPort->CountOfTryingToLowerRTS++;
        SerialPerhapsLowerRTS(pPort);
    }

    return FALSE;

}



BOOLEAN
SerialGiveWriteToIsr(IN PVOID Context)
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

    Try to start off the write by slipping it in behind a transmit immediate
	char, or if that isn't available and the transmit holding register is empty,
	"tickle" the UART into interrupting with a transmit buffer empty.

    NOTE: This routine is called by KeSynchronizeExecution.
    NOTE: This routine assumes that it is called with the
          cancel spin lock held.

Arguments:

    Context - Really a pointer to the device extension.

Return Value:

    This routine always returns FALSE.

-----------------------------------------------------------------------------*/
{
    PPORT_DEVICE_EXTENSION pPort = Context;

    // The current stack location.  This contains all of the
    // information we need to process this particular request.

    PIO_STACK_LOCATION IrpSp;

    IrpSp = IoGetCurrentIrpStackLocation(pPort->CurrentWriteIrp);

    // We might have a xoff counter request masquerading as a
    // write.  The length of these requests will always be one
    // and we can get a pointer to the actual character from
    // the data supplied by the user.
    if(IrpSp->MajorFunction == IRP_MJ_WRITE) 
	{
        pPort->WriteLength = IrpSp->Parameters.Write.Length;
        pPort->WriteCurrentChar = pPort->CurrentWriteIrp->AssociatedIrp.SystemBuffer;
    } 
	else 
	{
        pPort->WriteLength = 1;
        pPort->WriteCurrentChar = ((PUCHAR)pPort->CurrentWriteIrp->AssociatedIrp.SystemBuffer) 
								+ FIELD_OFFSET(SERIAL_XOFF_COUNTER, XoffChar);
    }

    // The isr now has a reference to the irp.
    SERIAL_SET_REFERENCE(pPort->CurrentWriteIrp, SERIAL_REF_ISR);

	pPort->pUartLib->UL_WriteData_XXXX(pPort->pUart, pPort->WriteCurrentChar, pPort->WriteLength);

    // The rts line may already be up from previous writes,
    // however, it won't take much additional time to turn
    // on the RTS line if we are doing transmit toggling.
    if((pPort->HandFlow.FlowReplace & SERIAL_RTS_MASK) == SERIAL_TRANSMIT_TOGGLE) 
        SerialSetRTS(pPort);


    return FALSE;

}



VOID
SerialCancelCurrentWrite(PDEVICE_OBJECT DeviceObject, PIRP Irp)
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

    This routine is used to cancel the current write.

Arguments:

    DeviceObject - Pointer to the device object for this device

    Irp - Pointer to the IRP to be canceled.

Return Value:

    None.

-----------------------------------------------------------------------------*/
{
    PPORT_DEVICE_EXTENSION pPort = DeviceObject->DeviceExtension;

    SerialTryToCompleteCurrent(	pPort,
								SerialGrabWriteFromIsr,
								Irp->CancelIrql,
								STATUS_CANCELLED,
								&pPort->CurrentWriteIrp,
								&pPort->WriteQueue,
								NULL,
								&pPort->WriteRequestTotalTimer,
								SerialStartWrite,
								SerialGetNextWrite,
								SERIAL_REF_CANCEL);
        
}

VOID
SerialWriteTimeout(IN PKDPC Dpc,
				   IN PVOID DeferredContext,
				   IN PVOID SystemContext1,
				   IN PVOID SystemContext2)
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

    This routine will try to timeout the current write.

Arguments:

    Dpc - Not Used.

    DeferredContext - Really points to the device extension.

    SystemContext1 - Not Used.

    SystemContext2 - Not Used.

Return Value:

    None.

-----------------------------------------------------------------------------*/

{

    PPORT_DEVICE_EXTENSION pPort = DeferredContext;
    KIRQL OldIrql;

    UNREFERENCED_PARAMETER(Dpc);
    UNREFERENCED_PARAMETER(SystemContext1);
    UNREFERENCED_PARAMETER(SystemContext2);

    IoAcquireCancelSpinLock(&OldIrql);

    SerialTryToCompleteCurrent(	pPort,
								SerialGrabWriteFromIsr,
								OldIrql,
								STATUS_TIMEOUT,
								&pPort->CurrentWriteIrp,
								&pPort->WriteQueue,
								NULL,
								&pPort->WriteRequestTotalTimer,
								SerialStartWrite,
								SerialGetNextWrite,
								SERIAL_REF_TOTAL_TIMER);
}

BOOLEAN
SerialGrabWriteFromIsr(IN PVOID Context)
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:


    This routine is used to grab the current irp, which could be timing
    out or canceling, from the ISR

    NOTE: This routine is being called from KeSynchronizeExecution.

    NOTE: This routine assumes that the cancel spin lock is held
          when this routine is called.

Arguments:

    Context - Really a pointer to the device extension.

Return Value:

    Always false.

-----------------------------------------------------------------------------*/
{

    PPORT_DEVICE_EXTENSION pPort = Context;

    // Check if the write length is non-zero.  If it is non-zero
    // then the ISR still owns the irp. We calculate the the number
    // of characters written and update the information field of the
    // irp with the characters written.  We then clear the write length
    // the isr sees.

    if(pPort->WriteLength) 
	{
        //
        // We could have an xoff counter masquerading as a
        // write irp.  If so, don't update the write length.
        //

        if(IoGetCurrentIrpStackLocation(pPort->CurrentWriteIrp)->MajorFunction == IRP_MJ_WRITE)
		{

            pPort->CurrentWriteIrp->IoStatus.Information 
				= IoGetCurrentIrpStackLocation(pPort->CurrentWriteIrp)->Parameters.Write.Length 
				- pPort->WriteLength;
        } 
		else 
		{
            pPort->CurrentWriteIrp->IoStatus.Information = 0;
        }

        //
        // Since the isr no longer references this irp, we can
        // decrement it's reference count.
        //

        SERIAL_CLEAR_REFERENCE(pPort->CurrentWriteIrp, SERIAL_REF_ISR);

		// Flush the output buffer.
		pPort->pUartLib->UL_BufferControl_XXXX(pPort->pUart, NULL, UL_BC_OP_FLUSH, UL_BC_BUFFER | UL_BC_OUT);

        pPort->WriteLength = 0;

    }

    return FALSE;
}

BOOLEAN
SerialGrabXoffFromIsr(IN PVOID Context)
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

    This routine is used to grab an xoff counter irp from the
    isr when it is no longer masquerading as a write irp.  This
    routine is called by the cancel and timeout code for the
    xoff counter ioctl.


    NOTE: This routine is being called from KeSynchronizeExecution.

    NOTE: This routine assumes that the cancel spin lock is held
          when this routine is called.

Arguments:

    Context - Really a pointer to the device extension.

Return Value:

    Always false.

-----------------------------------------------------------------------------*/
{

    PPORT_DEVICE_EXTENSION pPort = Context;

    if(pPort->CountSinceXoff) 
	{
        // This is only non-zero when there actually is a Xoff ioctl counting down.
        pPort->CountSinceXoff = 0;

        // We decrement the count since the isr no longer owns the irp.
        SERIAL_CLEAR_REFERENCE(pPort->CurrentXoffIrp, SERIAL_REF_ISR);
    }

    return FALSE;
}


VOID
SerialCompleteXoff(IN PKDPC Dpc,
				   IN PVOID DeferredContext,
				   IN PVOID SystemContext1,
				   IN PVOID SystemContext2)
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

    This routine is merely used to truely complete an xoff counter irp.  It
    assumes that the status and the information fields of the irp are
    already correctly filled in.

Arguments:

    Dpc - Not Used.

    DeferredContext - Really points to the device extension.

    SystemContext1 - Not Used.

    SystemContext2 - Not Used.

Return Value:

    None.

-----------------------------------------------------------------------------*/
{
    PPORT_DEVICE_EXTENSION pPort = DeferredContext;
    KIRQL OldIrql;

    UNREFERENCED_PARAMETER(Dpc);
    UNREFERENCED_PARAMETER(SystemContext1);
    UNREFERENCED_PARAMETER(SystemContext2);

    IoAcquireCancelSpinLock(&OldIrql);

	// Clear the normal complete reference.
	SERIAL_CLEAR_REFERENCE(pPort->CurrentXoffIrp, SERIAL_REF_COMPLETING);

    SerialTryToCompleteCurrent(	pPort,
								NULL,
								OldIrql,
								STATUS_SUCCESS,
								&pPort->CurrentXoffIrp,
								NULL,
								NULL,
								&pPort->XoffCountTimer,
								NULL,
								NULL,
								SERIAL_REF_ISR);
}

VOID
SerialTimeoutXoff(IN PKDPC Dpc,
				  IN PVOID DeferredContext,
				  IN PVOID SystemContext1,
				  IN PVOID SystemContext2)
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

    This routine is merely used to truely complete an xoff counter irp,
    if its timer has run out.

Arguments:

    Dpc - Not Used.

    DeferredContext - Really points to the device extension.

    SystemContext1 - Not Used.

    SystemContext2 - Not Used.

Return Value:

    None.

-----------------------------------------------------------------------------*/
{

    PPORT_DEVICE_EXTENSION pPort = DeferredContext;
    KIRQL OldIrql;

    UNREFERENCED_PARAMETER(Dpc);
    UNREFERENCED_PARAMETER(SystemContext1);
    UNREFERENCED_PARAMETER(SystemContext2);

    IoAcquireCancelSpinLock(&OldIrql);

    SerialTryToCompleteCurrent(	pPort,
								SerialGrabXoffFromIsr,
								OldIrql,
								STATUS_SERIAL_COUNTER_TIMEOUT,
								&pPort->CurrentXoffIrp,
								NULL,
								NULL,
								NULL,
								NULL,
								NULL,
								SERIAL_REF_TOTAL_TIMER);
}

VOID
SerialCancelCurrentXoff(PDEVICE_OBJECT DeviceObject, PIRP Irp)
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

    This routine is used to cancel the current write.

Arguments:

    DeviceObject - Pointer to the device object for this device

    Irp - Pointer to the IRP to be canceled.

Return Value:

    None.

-----------------------------------------------------------------------------*/

{
    PPORT_DEVICE_EXTENSION pPort = DeviceObject->DeviceExtension;

    SerialTryToCompleteCurrent(	pPort,
								SerialGrabXoffFromIsr,
								Irp->CancelIrql,
								STATUS_CANCELLED,
								&pPort->CurrentXoffIrp,
								NULL,
								NULL,
								&pPort->XoffCountTimer,
								NULL,
								NULL,
								SERIAL_REF_CANCEL);
}

BOOLEAN
SerialGiveXoffToIsr(IN PVOID Context)
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:


    This routine starts off the xoff counter.  It merely
    has to set the xoff count and increment the reference
    count to denote that the isr has a reference to the irp.

    NOTE: This routine is called by KeSynchronizeExecution.

    NOTE: This routine assumes that it is called with the
          cancel spin lock held.

Arguments:

    Context - Really a pointer to the device extension.

Return Value:

    This routine always returns FALSE.

-----------------------------------------------------------------------------*/
{
    PPORT_DEVICE_EXTENSION pPort = Context;

    // The current stack location.  This contains all of the
    // information we need to process this particular request.
    PSERIAL_XOFF_COUNTER Xc = pPort->CurrentXoffIrp->AssociatedIrp.SystemBuffer;

    ASSERT(pPort->CurrentXoffIrp);
    pPort->CountSinceXoff = Xc->Counter;

    // The isr now has a reference to the irp.
    SERIAL_SET_REFERENCE(pPort->CurrentXoffIrp, SERIAL_REF_ISR);

    return FALSE;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\spx\speed\driver\spx_disp.c ===
#include "precomp.h"	// Precompiled header

/************************************************************************/
/*																		*/
/*	Title		:	Specialix Generic Dispatch Functions.				*/
/*																		*/
/*	Author		:	N.P.Vassallo										*/
/*																		*/
/*	Creation	:	29th September 1998									*/
/*																		*/
/*	Version		:	1.0.0												*/
/*																		*/
/*	Description	:	Dispatch entry points are routed here				*/
/*					for PnP/Power filtering before being				*/
/*					passed to the main functions:						*/
/*						Spx_Flush										*/
/*						Spx_Write										*/
/*						Spx_Read										*/
/*						Spx_IoControl									*/
/*						Spx_InternalIoControl							*/
/*						Spx_CreateOpen									*/
/*						Spx_Close										*/
/*						Spx_Cleanup										*/
/*						Spx_QueryInformationFile						*/
/*						Spx_SetInformationFile							*/
/*																		*/
/*						Spx_UnstallIRPs									*/
/*						Spx_KillStalledIRPs								*/
/*																		*/
/************************************************************************/

/* History...

1.0.0	29/09/98 NPV	Creation.

*/

#define FILE_ID	SPX_DISP_C		// File ID for Event Logging see SPX_DEFS.H for values.

/*****************************************************************************
*******************************                *******************************
*******************************   Prototypes   *******************************
*******************************                *******************************
*****************************************************************************/

NTSTATUS Spx_FilterIRPs(IN PDEVICE_OBJECT pDevObject,IN PIRP pIrp);
VOID Spx_FilterCancelQueued(IN PDEVICE_OBJECT pDevObj,IN PIRP pIrp);



/*****************************************************************************
********************************   Spx_Flush   *******************************
*****************************************************************************/

NTSTATUS Spx_Flush(IN PDEVICE_OBJECT pDevObject,IN PIRP pIrp)
{
	NTSTATUS	status;

	if(!SPX_SUCCESS(status = Spx_FilterIRPs(pDevObject,pIrp)))
	{
		pIrp->IoStatus.Status = status;

		if(status != STATUS_PENDING)
			IoCompleteRequest(pIrp, IO_NO_INCREMENT);

		if((status == STATUS_PENDING) || (status == STATUS_CANCELLED))
			ClearUnstallingFlag(pDevObject->DeviceExtension);
	}
	else	
		status = SerialFlush(pDevObject,pIrp);

	return(status);

} // End Spx_Flush 

/*****************************************************************************
********************************   Spx_Write   *******************************
*****************************************************************************/

NTSTATUS Spx_Write(IN PDEVICE_OBJECT pDevObject,IN PIRP pIrp)
{
	PPORT_DEVICE_EXTENSION	pPort = pDevObject->DeviceExtension;
	NTSTATUS	status;

	if(!SPX_SUCCESS(status = Spx_FilterIRPs(pDevObject,pIrp)))
	{
		pIrp->IoStatus.Status = status;

		if(status != STATUS_PENDING)
			IoCompleteRequest(pIrp, IO_NO_INCREMENT);

		if((status == STATUS_PENDING) || (status == STATUS_CANCELLED))
			ClearUnstallingFlag(pDevObject->DeviceExtension);
	}
	else	
		status = SerialWrite(pDevObject,pIrp);

	return(status);

} // End Spx_Write 

/*****************************************************************************
********************************   Spx_Read   ********************************
*****************************************************************************/

NTSTATUS Spx_Read(IN PDEVICE_OBJECT pDevObject,IN PIRP pIrp)
{
	NTSTATUS	status;

	if(!SPX_SUCCESS(status = Spx_FilterIRPs(pDevObject,pIrp)))
	{
		pIrp->IoStatus.Status = status;

		if(status != STATUS_PENDING)
			IoCompleteRequest(pIrp, IO_NO_INCREMENT);

		if((status == STATUS_PENDING) || (status == STATUS_CANCELLED))
			ClearUnstallingFlag(pDevObject->DeviceExtension);
	}
	else	
		status = SerialRead(pDevObject,pIrp);

	return(status);

} // End Spx_Read 

/*****************************************************************************
******************************   Spx_IoControl   *****************************
*****************************************************************************/

NTSTATUS Spx_IoControl(IN PDEVICE_OBJECT pDevObject,IN PIRP pIrp)
{
	NTSTATUS	status;

	if(!SPX_SUCCESS(status = Spx_FilterIRPs(pDevObject,pIrp)))
	{
		pIrp->IoStatus.Status = status;

		if(status != STATUS_PENDING)
			IoCompleteRequest(pIrp, IO_NO_INCREMENT);

		if((status == STATUS_PENDING) || (status == STATUS_CANCELLED))
			ClearUnstallingFlag(pDevObject->DeviceExtension);
	}
	else	
		status = SerialIoControl(pDevObject,pIrp);

	return(status);

} // End Spx_IoControl 

/*****************************************************************************
**************************   Spx_InternalIoControl   *************************
*****************************************************************************/

NTSTATUS Spx_InternalIoControl(IN PDEVICE_OBJECT pDevObject,IN PIRP pIrp)
{
	NTSTATUS	status;

	if(!SPX_SUCCESS(status = Spx_FilterIRPs(pDevObject,pIrp)))
	{
		pIrp->IoStatus.Status = status;

		if(status != STATUS_PENDING)
			IoCompleteRequest(pIrp, IO_NO_INCREMENT);

		if((status == STATUS_PENDING) || (status == STATUS_CANCELLED))
			ClearUnstallingFlag(pDevObject->DeviceExtension);
	}
	else	
		status = Spx_SerialInternalIoControl(pDevObject,pIrp);

	return(status);

} // Spx_InternalIoControl 

/*****************************************************************************
*****************************   Spx_CreateOpen   *****************************
*****************************************************************************/

NTSTATUS Spx_CreateOpen(IN PDEVICE_OBJECT pDevObject,IN PIRP pIrp)
{
	PPORT_DEVICE_EXTENSION	pPort = pDevObject->DeviceExtension;
	NTSTATUS				status;


	if(pDevObject->DeviceType != FILE_DEVICE_SERIAL_PORT)	
	{
	    pIrp->IoStatus.Status = STATUS_ACCESS_DENIED;
        pIrp->IoStatus.Information = 0;
        IoCompleteRequest(pIrp, IO_NO_INCREMENT);
		return(STATUS_ACCESS_DENIED);
	}


	// Lock out state Query stop and Query remove IRPs from changing the state 
	// of the port part way through openening the port.
	ExAcquireFastMutex(&pPort->OpenMutex);
	
	if(!SPX_SUCCESS(status = Spx_FilterIRPs(pDevObject,pIrp)))
	{
		pIrp->IoStatus.Status = status;

		if(status != STATUS_PENDING)
			IoCompleteRequest(pIrp, IO_NO_INCREMENT);

		if((status == STATUS_PENDING) || (status == STATUS_CANCELLED))
			ClearUnstallingFlag(pDevObject->DeviceExtension);
	}
	else
	{
		if(pPort->DeviceIsOpen)					// Is port already open? 
		{
			status = STATUS_ACCESS_DENIED;		// Yes, deny access 
			pIrp->IoStatus.Status = status;
			IoCompleteRequest(pIrp,IO_NO_INCREMENT);
		}
		else
			status = SerialCreateOpen(pDevObject,pIrp);

	}

	ExReleaseFastMutex(&pPort->OpenMutex);

	return(status);

} // End Spx_CreateOpen 

/*****************************************************************************
********************************   Spx_Close   *******************************
*****************************************************************************/

NTSTATUS Spx_Close(IN PDEVICE_OBJECT pDevObject,IN PIRP pIrp)
{
	PPORT_DEVICE_EXTENSION	pPort = pDevObject->DeviceExtension;
	NTSTATUS				status;

	if(!SPX_SUCCESS(status = Spx_FilterIRPs(pDevObject,pIrp)))
	{
		if(status == STATUS_DELETE_PENDING)		// Successful close if device is removed 
		{
			pPort->BufferSize = 0;
			SpxFreeMem(pPort->InterruptReadBuffer);
			pPort->InterruptReadBuffer = NULL;
			status = STATUS_SUCCESS;
		}
		pIrp->IoStatus.Status = status;

		if(status != STATUS_PENDING)
			IoCompleteRequest(pIrp, IO_NO_INCREMENT);

		if((status == STATUS_PENDING) || (status == STATUS_CANCELLED))
			ClearUnstallingFlag(pDevObject->DeviceExtension);
	}
	else	
		status = SerialClose(pDevObject,pIrp);

	return(status);

} // End Spx_Close 

/*****************************************************************************
*******************************   Spx_Cleanup   ******************************
*****************************************************************************/

NTSTATUS Spx_Cleanup(IN PDEVICE_OBJECT pDevObject,IN PIRP pIrp)
{
	NTSTATUS	status;

	if(!SPX_SUCCESS(status = Spx_FilterIRPs(pDevObject,pIrp)))
	{
		if(status == STATUS_DELETE_PENDING)
		{
			status = STATUS_SUCCESS;
		}
		pIrp->IoStatus.Status = status;

		if(status != STATUS_PENDING)
			IoCompleteRequest(pIrp, IO_NO_INCREMENT);

		if((status == STATUS_PENDING) || (status == STATUS_CANCELLED))
			ClearUnstallingFlag(pDevObject->DeviceExtension);
	}
	else
	{
		Spx_KillStalledIRPs(pDevObject);
		status = SerialCleanup(pDevObject,pIrp);
	}

	return(status);

} // End Spx_Cleanup 

/*****************************************************************************
************************   Spx_QueryInformationFile   ************************
*****************************************************************************/

NTSTATUS Spx_QueryInformationFile(IN PDEVICE_OBJECT pDevObject,IN PIRP pIrp)
{
	NTSTATUS	status;

	if(!SPX_SUCCESS(status = Spx_FilterIRPs(pDevObject,pIrp)))
	{
		pIrp->IoStatus.Status = status;

		if(status != STATUS_PENDING)
			IoCompleteRequest(pIrp, IO_NO_INCREMENT);

		if((status == STATUS_PENDING) || (status == STATUS_CANCELLED))
			ClearUnstallingFlag(pDevObject->DeviceExtension);
	}
	else	status = SerialQueryInformationFile(pDevObject,pIrp);

	return(status);

} // End Spx_QueryInformationFile 

/*****************************************************************************
*************************   Spx_SetInformationFile   *************************
*****************************************************************************/

NTSTATUS Spx_SetInformationFile(IN PDEVICE_OBJECT pDevObject,IN PIRP pIrp)
{
	NTSTATUS	status;

	if(!SPX_SUCCESS(status = Spx_FilterIRPs(pDevObject,pIrp)))
	{
		pIrp->IoStatus.Status = status;

		if(status != STATUS_PENDING)
			IoCompleteRequest(pIrp, IO_NO_INCREMENT);

		if((status == STATUS_PENDING) || (status == STATUS_CANCELLED))
			ClearUnstallingFlag(pDevObject->DeviceExtension);
	}
	else	
		status = SerialSetInformationFile(pDevObject,pIrp);

	return(status);

} // End Spx_SetInformationFile 

/*****************************************************************************
*****************************                    *****************************
*****************************   Spx_FilterIRPs   *****************************
*****************************                    *****************************
******************************************************************************

prototype:		NTSTATUS Spx_FilterIRPs(IN PDEVICE_OBJECT pDevObject,IN PIRP pIrp)

description:	Filter incoming SERIAL IRPs (except PNP and POWER) to check
				the current PNP/POWER states and return an NT status code to
				just complete the IRP if device is blocked for the following reasons:

parameters:		pDevObject points to the device object for this IRP
				pIrp points to the IRP to filter

returns:		NT Status Code

*/

NTSTATUS Spx_FilterIRPs(IN PDEVICE_OBJECT pDevObject,IN PIRP pIrp)
{
	PPORT_DEVICE_EXTENSION	pPort = pDevObject->DeviceExtension;
	PIO_STACK_LOCATION		pIrpStack = IoGetCurrentIrpStackLocation(pIrp);
	KIRQL					oldIrqlFlags;
	KIRQL					StalledOldIrql;
	LARGE_INTEGER delay;

	if(pIrpStack->MajorFunction == IRP_MJ_PNP)			// Don't filter Plug and Play IRPs 
		return(STATUS_SUCCESS);

	if(pIrpStack->MajorFunction == IRP_MJ_POWER)		// Don't filter Plug and Play IRPs 
		return(STATUS_SUCCESS);

	if(pIrpStack->MajorFunction == IRP_MJ_SYSTEM_CONTROL)	// Don't filter WMI IRPs 
		return(STATUS_SUCCESS);


	if(pPort->IsFDO)									// Don't filter card IRPs	
		return(STATUS_SUCCESS);

	if(pIrpStack->MajorFunction != IRP_MJ_PNP)
	{
		SpxDbgMsg(SPX_TRACE_FILTER_IRPS,("%s[card=%d,port=%d]: Spx_FilterIRPs for Major %02X, Minor %02X\n",
			PRODUCT_NAME,pPort->pParentCardExt->CardNumber,pPort->PortNumber,pIrpStack->MajorFunction,pIrpStack->MinorFunction));
	}


	KeAcquireSpinLock(&pPort->PnpPowerFlagsLock, &oldIrqlFlags);

	if(pPort->PnpPowerFlags & PPF_REMOVED)				// Has this object been "removed"? 
	{
		KeReleaseSpinLock(&pPort->PnpPowerFlagsLock,oldIrqlFlags);
		SpxDbgMsg(SPX_TRACE_FILTER_IRPS,("%s[card=%d,port=%d]: Spx_FilterIRPs for Major %02X, Minor %02X STATUS_SUCCESS\n",
			PRODUCT_NAME,pPort->pParentCardExt->CardNumber,pPort->PortNumber,pIrpStack->MajorFunction,pIrpStack->MinorFunction));

		return(STATUS_NO_SUCH_DEVICE);
	}

	if(pPort->PnpPowerFlags & PPF_REMOVE_PENDING)		// Removing the device? 
	{
		KeReleaseSpinLock(&pPort->PnpPowerFlagsLock,oldIrqlFlags);
		SpxDbgMsg(SPX_TRACE_FILTER_IRPS,("%s[card=%d,port=%d]: Spx_FilterIRPs for Major %02X, Minor %02X STATUS_DELETE_PENDING\n",
			PRODUCT_NAME,pPort->pParentCardExt->CardNumber,pPort->PortNumber,pIrpStack->MajorFunction,pIrpStack->MinorFunction));
			
		return(STATUS_DELETE_PENDING);
	}


	if((pPort->PnpPowerFlags & PPF_STOP_PENDING)		// Device stopping?
	||(!(pPort->PnpPowerFlags & PPF_POWERED))			// Device not powered?
	||(!(pPort->PnpPowerFlags & PPF_STARTED)))			// Device not started?
	{
		KIRQL	oldIrql;

		KeReleaseSpinLock(&pPort->PnpPowerFlagsLock,oldIrqlFlags);


		KeAcquireSpinLock(&pPort->StalledIrpLock, &StalledOldIrql);
		
		while(pPort->UnstallingFlag) // We do not wish to add any more IRPs to the queue if have started unstalling those currently queued.
		{
			KeReleaseSpinLock(&pPort->StalledIrpLock, StalledOldIrql);	

			delay = RtlLargeIntegerNegate(RtlConvertUlongToLargeInteger(1000000));		// 1mS 
			
			KeDelayExecutionThread(KernelMode, FALSE, &delay);

			KeAcquireSpinLock(&pPort->StalledIrpLock, &StalledOldIrql);
		}

		pPort->UnstallingFlag = TRUE;

		KeReleaseSpinLock(&pPort->StalledIrpLock, StalledOldIrql);	


		IoAcquireCancelSpinLock(&oldIrql);

		if(pIrp->Cancel)				// Has IRP been cancelled? 
		{								// Yes 
			IoReleaseCancelSpinLock(oldIrql);
			SpxDbgMsg(SPX_TRACE_FILTER_IRPS,("%s[card=%d,port=%d]: Spx_FilterIRPs for Major %02X, Minor %02X STATUS_CANCELLED\n",
				PRODUCT_NAME,pPort->pParentCardExt->CardNumber,pPort->PortNumber,pIrpStack->MajorFunction,pIrpStack->MinorFunction));
				
			return(STATUS_CANCELLED);
		}

// Mark the IRP as pending and queue on the stalled list... 
		pIrp->IoStatus.Status = STATUS_PENDING;		// Mark IRP as pending 
		IoMarkIrpPending(pIrp);
		InsertTailList(&pPort->StalledIrpQueue,&pIrp->Tail.Overlay.ListEntry);
		IoSetCancelRoutine(pIrp,Spx_FilterCancelQueued);
		IoReleaseCancelSpinLock(oldIrql);
		SpxDbgMsg(SPX_TRACE_FILTER_IRPS,("%s[card=%d,port=%d]: Spx_FilterIRPs for Major %02X, Minor %02X STATUS_PENDING\n",
			PRODUCT_NAME,pPort->pParentCardExt->CardNumber,pPort->PortNumber,pIrpStack->MajorFunction,pIrpStack->MinorFunction));
			
		return(STATUS_PENDING);
	}

	KeReleaseSpinLock(&pPort->PnpPowerFlagsLock,oldIrqlFlags);
	SpxDbgMsg(SPX_TRACE_FILTER_IRPS,("%s[card=%d,port=%d]: Spx_FilterIRPs for Major %02X, Minor %02X STATUS_SUCCESS\n",
		PRODUCT_NAME,pPort->pParentCardExt->CardNumber,pPort->PortNumber,pIrpStack->MajorFunction,pIrpStack->MinorFunction));

	return(STATUS_SUCCESS);

} // End Spx_FilterIRPs 

/*****************************************************************************
*****************************                     ****************************
*****************************   Spx_UnstallIRPs   ****************************
*****************************                     ****************************
******************************************************************************

prototype:		VOID Spx_UnstallIrps(IN PPORT_DEVICE_EXTENSION pPort)

description:	Restart all IRPs stored on the temporary stalled list.

parameters:		pPort points to the device extension to unstall

returns:		None

*/

VOID Spx_UnstallIrps(IN PPORT_DEVICE_EXTENSION pPort)
{
	PLIST_ENTRY			pIrpLink;
	PIRP				pIrp;
	PIO_STACK_LOCATION	pIrpStack;
	PDEVICE_OBJECT		pDevObj;
	PDRIVER_OBJECT		pDrvObj;
	KIRQL				oldIrql;
	KIRQL				StalledOldIrql;
	LARGE_INTEGER		delay;

	SpxDbgMsg(SPX_TRACE_FILTER_IRPS,("%s[card=%d,port=%d]: Spx_UnstallIRPs Entry\n",
		PRODUCT_NAME,pPort->pParentCardExt->CardNumber,pPort->PortNumber));


	KeAcquireSpinLock(&pPort->StalledIrpLock, &StalledOldIrql);
	
	while(pPort->UnstallingFlag)	// We do not unstall any queued IRPs if some one is just about to be added to the queue.
	{
		KeReleaseSpinLock(&pPort->StalledIrpLock, StalledOldIrql);	

		delay = RtlLargeIntegerNegate(RtlConvertUlongToLargeInteger(1000000));		// 1mS 
		
		KeDelayExecutionThread(KernelMode, FALSE, &delay);

		KeAcquireSpinLock(&pPort->StalledIrpLock, &StalledOldIrql);
	}

	pPort->UnstallingFlag = TRUE;

	KeReleaseSpinLock(&pPort->StalledIrpLock, StalledOldIrql);	





	IoAcquireCancelSpinLock(&oldIrql);
	pIrpLink = pPort->StalledIrpQueue.Flink;

// Restart each waiting IRP on the stalled list... 

	while(pIrpLink != &pPort->StalledIrpQueue)
	{
		pIrp = CONTAINING_RECORD(pIrpLink,IRP,Tail.Overlay.ListEntry);
		pIrpLink = pIrp->Tail.Overlay.ListEntry.Flink;
		RemoveEntryList(&pIrp->Tail.Overlay.ListEntry);

		pIrpStack = IoGetCurrentIrpStackLocation(pIrp);
		pDevObj = pIrpStack->DeviceObject;
		pDrvObj = pDevObj->DriverObject;
		IoSetCancelRoutine(pIrp,NULL);
		IoReleaseCancelSpinLock(oldIrql);

		SpxDbgMsg(SPX_TRACE_FILTER_IRPS,("%s[card=%d,port=%d]: Unstalling IRP 0x%X, Major %02X, Minor %02X\n",
			PRODUCT_NAME,pPort->pParentCardExt->CardNumber,pPort->PortNumber,
			pIrp,pIrpStack->MajorFunction,pIrpStack->MinorFunction));

		pDrvObj->MajorFunction[pIrpStack->MajorFunction](pDevObj,pIrp);
		IoAcquireCancelSpinLock(&oldIrql);
	}

	IoReleaseCancelSpinLock(oldIrql);

	ClearUnstallingFlag(pPort);

	SpxDbgMsg(SPX_TRACE_FILTER_IRPS,("%s[card=%d,port=%d]: Spx_UnstallIRPs Exit\n",
		PRODUCT_NAME,pPort->pParentCardExt->CardNumber,pPort->PortNumber));

} // End Spx_UnstallIRPs 

/*****************************************************************************
*************************                            *************************
*************************   Spx_FilterCancelQueued   *************************
*************************                            *************************
******************************************************************************

prototype:		VOID Spx_FilterCancelQueued(IN PDEVICE_OBJECT pDevObj,IN PIRP pIrp)

description:	Routine to cancel IRPs queued on the stalled list

parameters:		pDevObj the device object containing the queue
				pIrp points to the IRP to cancel

returns:		None

*/

VOID Spx_FilterCancelQueued(IN PDEVICE_OBJECT pDevObj,IN PIRP pIrp)
{
	PPORT_DEVICE_EXTENSION	pPort = pDevObj->DeviceExtension;
	PIO_STACK_LOCATION		pIrpSp = IoGetCurrentIrpStackLocation(pIrp);

	pIrp->IoStatus.Status = STATUS_CANCELLED;
	pIrp->IoStatus.Information = 0;

	RemoveEntryList(&pIrp->Tail.Overlay.ListEntry);
	IoReleaseCancelSpinLock(pIrp->CancelIrql);

} // End Spx_FilterCancelQueued 


/*****************************************************************************
***************************                         **************************
***************************   Spx_KillStalledIRPs   **************************
***************************                         **************************
******************************************************************************

prototype:		VOID Spx_KillStalledIRPs(IN PDEVICE_OBJECT pDevObj)

description:	Kill all IRPs queued on the stalled list

parameters:		pDevObj the device object containing the queue

returns:		None

*/

VOID Spx_KillStalledIRPs(IN PDEVICE_OBJECT pDevObj)
{
	PPORT_DEVICE_EXTENSION	pPort = pDevObj->DeviceExtension;
	PDRIVER_CANCEL			cancelRoutine;
	KIRQL					cancelIrql;

	IoAcquireCancelSpinLock(&cancelIrql);

// Call the cancel routine of all IRPs queued on the stalled list... 

	while(!IsListEmpty(&pPort->StalledIrpQueue))
	{
		PIRP	pIrp = CONTAINING_RECORD(pPort->StalledIrpQueue.Blink, IRP, Tail.Overlay.ListEntry);

		RemoveEntryList(pPort->StalledIrpQueue.Blink);
		cancelRoutine = pIrp->CancelRoutine;		// Get the cancel routine for this IRP 
		pIrp->CancelIrql = cancelIrql;
		pIrp->CancelRoutine = NULL;
		pIrp->Cancel = TRUE;

		cancelRoutine(pDevObj,pIrp);				// Call the cancel routine 

		IoAcquireCancelSpinLock(&cancelIrql);
	}

	IoReleaseCancelSpinLock(cancelIrql);

} // End Spx_KillStalledIRPs 

// End of SPX_DISP.C
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\spx\speed\driver\spx_powr.c ===
#include "precomp.h"	// Precompiled header

/****************************************************************************************
*																						*
*	Module:			SPX_POWER.C															*
*																						*
*	Creation:		15th October 1998													*
*																						*
*	Author:			Paul Smith															*
*																						*
*	Version:		1.0.0																*
*																						*
*	Description:	Handle all Power IRPS.												*
*																						*
****************************************************************************************/
/* History...

1.0.0	27/09/98 PBS	Creation.

*/
#define FILE_ID	SPX_POWR_C		// File ID for Event Logging see SPX_DEFS.H for values.

BOOLEAN	BREAK_ON_POWER_UP = FALSE;

// Prototypes
NTSTATUS Spx_Card_FDO_DispatchPower(IN PDEVICE_OBJECT pFDO, IN PIRP pIrp);
NTSTATUS Spx_CardSetSystemPowerState(IN PDEVICE_OBJECT pDevObject, IN PIRP pIrp);
NTSTATUS Spx_CardSetDevicePowerState(IN PDEVICE_OBJECT pDevObject, IN PIRP pIrp);
NTSTATUS Spx_CardSetPowerStateD0(IN PDEVICE_OBJECT pDevObject, IN PIRP pIrp);
NTSTATUS Spx_CardSetPowerStateD3(IN PDEVICE_OBJECT pDevObject, IN PIRP pIrp);

NTSTATUS Spx_Port_PDO_DispatchPower(IN PDEVICE_OBJECT pPDO, IN PIRP pIrp);
NTSTATUS Spx_PortQuerySystemPowerState(IN PDEVICE_OBJECT pDevObject, IN PIRP pIrp);
NTSTATUS Spx_PortSetSystemPowerState(IN PDEVICE_OBJECT pDevObject, IN PIRP pIrp);
NTSTATUS Spx_PortSetDevicePowerState(IN PDEVICE_OBJECT pDevObject, IN PIRP pIrp);
NTSTATUS Spx_PortSetPowerStateD0(IN PDEVICE_OBJECT pDevObject, IN PIRP pIrp);
NTSTATUS Spx_PortSetPowerStateD3(IN PDEVICE_OBJECT pDevObject, IN PIRP pIrp);

NTSTATUS Spx_PowerWaitForDriverBelow(IN PDEVICE_OBJECT pLowerDevObj, IN PIRP pIrp);
// End of prototypes


// Paging.. 
#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, Spx_DispatchPower)

#pragma alloc_text(PAGE, Spx_Card_FDO_DispatchPower)
#pragma alloc_text(PAGE, Spx_CardSetSystemPowerState)
#pragma alloc_text(PAGE, Spx_CardSetDevicePowerState)
#pragma alloc_text(PAGE, Spx_CardSetPowerStateD0)
#pragma alloc_text(PAGE, Spx_CardSetPowerStateD3)

#pragma alloc_text(PAGE, Spx_Port_PDO_DispatchPower)
#pragma alloc_text(PAGE, Spx_PortQuerySystemPowerState)
#pragma alloc_text(PAGE, Spx_PortSetSystemPowerState)
#pragma alloc_text(PAGE, Spx_PortSetDevicePowerState)
#pragma alloc_text(PAGE, Spx_PortSetPowerStateD0)
#pragma alloc_text(PAGE, Spx_PortSetPowerStateD3)

#endif // ALLOC_PRAGMA


//////////////////////////////////////////////////////////////////////////////////////////
//																						
//	Routine Description:
//		The power dispatch routine determine if the IRP is for a card or a port and 
//		then call the correct dispatch routine.
//
//	Arguments:
//		pDevObject	- pointer to a device object.
//		pIrp		- pointer to an I/O request packet.
//
//	Return value:
//		NT status code.
//
//////////////////////////////////////////////////////////////////////////////////////////
NTSTATUS
Spx_DispatchPower(IN PDEVICE_OBJECT pDevObject, IN PIRP pIrp)
{
    PCOMMON_OBJECT_DATA		CommonData	= (PCOMMON_OBJECT_DATA) pDevObject->DeviceExtension;
    NTSTATUS				status		= STATUS_SUCCESS;

	PAGED_CODE();	// Macro in checked build to assert if pagable code is run at or above dispatch IRQL 

    if(CommonData->IsFDO) 
        status = Spx_Card_FDO_DispatchPower(pDevObject, pIrp);
	else 
        status = Spx_Port_PDO_DispatchPower(pDevObject, pIrp);

    return status;
}	// Spx_DispatchPower


	
//////////////////////////////////////////////////////////////////////////////////////////
//
//	Routine Description:
//		The power dispatch routine to handle power IRPs for card devices.
//
//	Arguments:
//		pFDO - pointer to a device object.
//		pIrp - pointer to an I/O request packet.
//
//	Return value:
//		NT status code.
//
//////////////////////////////////////////////////////////////////////////////////////////
NTSTATUS
Spx_Card_FDO_DispatchPower(IN PDEVICE_OBJECT pFDO, IN PIRP pIrp)
{
	PCARD_DEVICE_EXTENSION	pCard		= pFDO->DeviceExtension;
	NTSTATUS				status		= STATUS_SUCCESS;
	PIO_STACK_LOCATION		pIrpStack	= IoGetCurrentIrpStackLocation(pIrp);

	PAGED_CODE();	// Macro in checked build to assert if pagable code is run at or above dispatch IRQL 

	switch (pIrpStack->MinorFunction) 
	{
    case IRP_MN_SET_POWER:	// Driver MUST never fail this IRP.
		{
			switch(pIrpStack->Parameters.Power.Type)
			{
			case SystemPowerState:
				SpxDbgMsg(SPX_TRACE_POWER_IRPS, ("%s: Got IRP_MN_SET_POWER Irp - Type SystemPowerState for Card %d.\n", 
					PRODUCT_NAME, pCard->CardNumber));
				return Spx_CardSetSystemPowerState(pFDO, pIrp);

			case DevicePowerState:
				SpxDbgMsg(SPX_TRACE_POWER_IRPS, ("%s: Got IRP_MN_SET_POWER Irp - Type DevicePowerState for Card %d.\n", 
					PRODUCT_NAME, pCard->CardNumber));
				return Spx_CardSetDevicePowerState(pFDO, pIrp);
			
			default:
				SpxDbgMsg(SPX_TRACE_POWER_IRPS, ("%s: Got IRP_MN_SET_POWER - Type 0x%02X Irp for Card %d.\n", 
					PRODUCT_NAME, pIrpStack->Parameters.Power.Type, pCard->CardNumber));
				
				status = STATUS_SUCCESS;
				pIrp->IoStatus.Status = status;
				break;
			}

			break;
		}

	case IRP_MN_QUERY_POWER:
		{
			switch(pIrpStack->Parameters.Power.Type)
			{
			case SystemPowerState:
				SpxDbgMsg(SPX_TRACE_POWER_IRPS, ("%s: Got IRP_MN_QUERY_POWER Irp - Type SystemPowerState for Card %d.\n", 
					PRODUCT_NAME, pCard->CardNumber));
				
				status = STATUS_SUCCESS;
				pIrp->IoStatus.Status = status;
				break;

			case DevicePowerState:
				SpxDbgMsg(SPX_TRACE_POWER_IRPS, ("%s: Got IRP_MN_QUERY_POWER Irp - Type DevicePowerState for Card %d.\n", 
					PRODUCT_NAME, pCard->CardNumber));

				status = STATUS_SUCCESS;
				pIrp->IoStatus.Status = status;
				break; 
			
			default:
				SpxDbgMsg(SPX_TRACE_POWER_IRPS, ("%s: Got IRP_MN_QUERY_POWER - Type 0x%02X Irp for Card %d.\n", 
					PRODUCT_NAME, pIrpStack->Parameters.Power.Type, pCard->CardNumber));
			
				status = STATUS_SUCCESS;
				pIrp->IoStatus.Status = status;
				break;
			}

			break;
		}
		
    case IRP_MN_WAIT_WAKE:
			SpxDbgMsg(SPX_TRACE_POWER_IRPS, ("%s: Got IRP_MN_WAIT_WAKE Irp for Card %d.\n", 
				PRODUCT_NAME, pCard->CardNumber));
			
			status = STATUS_NOT_SUPPORTED;
			pIrp->IoStatus.Status = status;
			break;

    case IRP_MN_POWER_SEQUENCE:
			SpxDbgMsg(SPX_TRACE_POWER_IRPS, ("%s: Got IRP_MN_POWER_SEQUENCE Irp for Card %d.\n", 
				PRODUCT_NAME, pCard->CardNumber));
			
			status = STATUS_NOT_IMPLEMENTED;
			pIrp->IoStatus.Status = status;
			break;

	default:
			SpxDbgMsg(SPX_TRACE_POWER_IRPS, ("%s: Got an UNKNOWN POWER Irp for Card %d.\n", 
				PRODUCT_NAME, pCard->CardNumber));
			status = STATUS_NOT_SUPPORTED;
			break;

	}

	PoStartNextPowerIrp(pIrp);
	IoSkipCurrentIrpStackLocation(pIrp);
	PoCallDriver(pCard->LowerDeviceObject, pIrp);

	return status;
}	// Spx_Card_FDO_DispatchPower


//////////////////////////////////////////////////////////////////////////////////////////
// Spx_CardSetSystemPowerState
//////////////////////////////////////////////////////////////////////////////////////////
NTSTATUS
Spx_CardSetSystemPowerState(IN PDEVICE_OBJECT pDevObject, IN PIRP pIrp)
{
	PCARD_DEVICE_EXTENSION	pCard		= pDevObject->DeviceExtension;
	NTSTATUS				status		= STATUS_SUCCESS;
	PIO_STACK_LOCATION		pIrpStack	= IoGetCurrentIrpStackLocation(pIrp);
	POWER_STATE				PowerState;

	PAGED_CODE();	// Macro in checked build to assert if pagable code is run at or above dispatch IRQL 

	SpxDbgMsg(SPX_TRACE_CALLS, ("%s: Entering Spx_CardSetSystemPowerState for Card %d.\n", 
		PRODUCT_NAME, pCard->CardNumber));

	switch (pIrpStack->Parameters.Power.State.SystemState) 
	{
		case PowerSystemUnspecified:
			PowerState.DeviceState = PowerDeviceUnspecified;
			PoRequestPowerIrp(pCard->PDO, IRP_MN_SET_POWER, PowerState, NULL, NULL, NULL);
			break;

        case PowerSystemWorking:
			PowerState.DeviceState = PowerDeviceD0;
			PoRequestPowerIrp(pCard->PDO, IRP_MN_SET_POWER, PowerState, NULL, NULL, NULL);
			break;	
				
        case PowerSystemSleeping1:
        case PowerSystemSleeping2:
        case PowerSystemSleeping3:
        case PowerSystemHibernate:
        case PowerSystemShutdown:
        case PowerSystemMaximum:
			PowerState.DeviceState = PowerDeviceD3;
			PoRequestPowerIrp(pCard->PDO, IRP_MN_SET_POWER, PowerState, NULL, NULL, NULL);
			break;

		default:
			break;
	}

	pIrp->IoStatus.Status = STATUS_SUCCESS;
	PoStartNextPowerIrp(pIrp);
	IoSkipCurrentIrpStackLocation(pIrp);
	PoCallDriver(pCard->LowerDeviceObject, pIrp);

	return status;
}	// Spx_CardSetSystemPowerState


//////////////////////////////////////////////////////////////////////////////////////////
// Spx_CardSetDevicePowerState
//////////////////////////////////////////////////////////////////////////////////////////
NTSTATUS
Spx_CardSetDevicePowerState(IN PDEVICE_OBJECT pDevObject, IN PIRP pIrp)
{
	PCARD_DEVICE_EXTENSION	pCard		= pDevObject->DeviceExtension;
	NTSTATUS				status		= STATUS_SUCCESS;
	PIO_STACK_LOCATION		pIrpStack	= IoGetCurrentIrpStackLocation(pIrp);

	PAGED_CODE();	// Macro in checked build to assert if pagable code is run at or above dispatch IRQL 

	SpxDbgMsg(SPX_TRACE_CALLS, ("%s: Entering Spx_CardSetDevicePowerState for Card %d.\n", 
		PRODUCT_NAME, pCard->CardNumber));

	switch(pIrpStack->Parameters.Power.State.DeviceState)
	{
	case PowerDeviceD0:
		SpxDbgMsg(SPX_TRACE_POWER_IRPS, ("%s: System requests Card %d goes into power state D0.\n", 
			PRODUCT_NAME, pCard->CardNumber));
		
		if(pCard->DeviceState == pIrpStack->Parameters.Power.State.DeviceState)
			SpxDbgMsg(SPX_TRACE_POWER_IRPS, ("%s: Card %d is already in power state D0.\n", 
				PRODUCT_NAME, pCard->CardNumber));
		else
			return Spx_CardSetPowerStateD0(pDevObject, pIrp);	// Switch ON

		break;

	case PowerDeviceD1:
		SpxDbgMsg(SPX_TRACE_POWER_IRPS, ("%s: System requests Card %d goes into power state D1.\n", 
			PRODUCT_NAME, pCard->CardNumber));

		if(pCard->DeviceState >= pIrpStack->Parameters.Power.State.DeviceState)
			SpxDbgMsg(SPX_TRACE_POWER_IRPS, ("%s: Card %d is already in power state D1 or lower.\n", 
				PRODUCT_NAME, pCard->CardNumber));
		else
			return Spx_CardSetPowerStateD3(pDevObject, pIrp);	// Switch OFF

		break;

	case PowerDeviceD2:
		SpxDbgMsg(SPX_TRACE_POWER_IRPS, ("%s: System requests Card %d goes into power state D2.\n", 
			PRODUCT_NAME, pCard->CardNumber));

		if(pCard->DeviceState >= pIrpStack->Parameters.Power.State.DeviceState)
			SpxDbgMsg(SPX_TRACE_POWER_IRPS, ("%s: Card %d is already in power state D2 or lower.\n", 
				PRODUCT_NAME, pCard->CardNumber));
		else
			return Spx_CardSetPowerStateD3(pDevObject, pIrp);	// Switch OFF

		break;

	case PowerDeviceD3:
		SpxDbgMsg(SPX_TRACE_POWER_IRPS, ("%s: System requests Card %d goes into power state D3.\n", 
			PRODUCT_NAME, pCard->CardNumber));

		if(pCard->DeviceState == pIrpStack->Parameters.Power.State.DeviceState)
			SpxDbgMsg(SPX_TRACE_POWER_IRPS, ("%s: Card %d is already in power state D3.\n", 
				PRODUCT_NAME, pCard->CardNumber));
		else
			return Spx_CardSetPowerStateD3(pDevObject, pIrp);	// Switch OFF

		break;

	default:
		break;

	}


	pIrp->IoStatus.Status = STATUS_SUCCESS;
	PoStartNextPowerIrp(pIrp);
	IoSkipCurrentIrpStackLocation(pIrp);
	PoCallDriver(pCard->LowerDeviceObject, pIrp);

	return status;
}	// Spx_CardSetDevicePowerState




//////////////////////////////////////////////////////////////////////////////////////////
// Spx_SetPowerStateD0 -  Sets power state D0 for Card - ON
//////////////////////////////////////////////////////////////////////////////////////////
NTSTATUS
Spx_CardSetPowerStateD0(IN PDEVICE_OBJECT pDevObject, IN PIRP pIrp)
{
	PIO_STACK_LOCATION		pIrpStack	= IoGetCurrentIrpStackLocation(pIrp);
	PCARD_DEVICE_EXTENSION	pCard		= pDevObject->DeviceExtension;
	NTSTATUS				status		= STATUS_SUCCESS;

	PAGED_CODE();	// Macro in checked build to assert if pagable code is run at or above dispatch IRQL 

	SpxDbgMsg(SPX_TRACE_CALLS, ("%s: Entering Spx_CardSetPowerStateD0 for Card %d.\n", 
		PRODUCT_NAME, pCard->CardNumber));

	status = Spx_PowerWaitForDriverBelow(pCard->LowerDeviceObject, pIrp);

	
#if DBG
	if(BREAK_ON_POWER_UP)
	{
		BREAK_ON_POWER_UP = FALSE;
	    KdPrint(("%s: Breaking debugger whilst powering up Card %d to debug after a hibernate\n", PRODUCT_NAME, pCard->CardNumber)); 
		DbgBreakPoint();
	}
#endif

	SetPnpPowerFlags(pCard, PPF_POWERED); 

	if(SPX_SUCCESS(pIrp->IoStatus.Status = XXX_CardPowerUp(pCard)))		// RESTORE HARDWARE STATE HERE & START CARD
	{
		// Inform Power Manager the of the new power state.
		PoSetPowerState(pDevObject, pIrpStack->Parameters.Power.Type, pIrpStack->Parameters.Power.State);

		pCard->DeviceState = PowerDeviceD0;	// Store new power state.
	}

	PoStartNextPowerIrp(pIrp);					// Ready for next power IRP.
	IoCompleteRequest(pIrp, IO_NO_INCREMENT);	// Complete current IRP.

	return status;
}	// Spx_SetPowerStateD0


//////////////////////////////////////////////////////////////////////////////////////////
// Spx_SetPowerStateD3 -  Sets power state D3 for Card - OFF
//////////////////////////////////////////////////////////////////////////////////////////
NTSTATUS
Spx_CardSetPowerStateD3(IN PDEVICE_OBJECT pDevObject, IN PIRP pIrp)
{
	PIO_STACK_LOCATION		pIrpStack	= IoGetCurrentIrpStackLocation(pIrp);
	PCARD_DEVICE_EXTENSION	pCard		= pDevObject->DeviceExtension;
	NTSTATUS				status		= STATUS_SUCCESS;

	PAGED_CODE();	// Macro in checked build to assert if pagable code is run at or above dispatch IRQL 

	SpxDbgMsg(SPX_TRACE_CALLS, ("%s: Entering Spx_CardSetPowerStateD3 for Card %d.\n", 
		PRODUCT_NAME, pCard->CardNumber));

	ClearPnpPowerFlags(pCard, PPF_POWERED);		

	if(SPX_SUCCESS(pIrp->IoStatus.Status	= XXX_CardPowerDown(pCard))) // SAVE HARDWARE STATE HERE & STOP CARD
	{
		// Inform Power Manager the of the new power state.
		PoSetPowerState(pDevObject, pIrpStack->Parameters.Power.Type, pIrpStack->Parameters.Power.State);

		pCard->DeviceState = PowerDeviceD3;		// Store new power state.
	}

	PoStartNextPowerIrp(pIrp);						// Ready for next power IRP.
	IoSkipCurrentIrpStackLocation(pIrp);
	PoCallDriver(pCard->LowerDeviceObject, pIrp);	// Pass IRP on down.

	return status;
}	// Spx_SetPowerStateD3







	
//////////////////////////////////////////////////////////////////////////////////////////
//
// Routine Description:
//	The power dispatch routine to handle power IRPs for port devices.
//
//	Arguments:
//		pPDO - pointer to a device object.
//		pIrp - pointer to an I/O request packet.
//
//	Return value:
//		NT status code.
//
//////////////////////////////////////////////////////////////////////////////////////////
NTSTATUS
Spx_Port_PDO_DispatchPower(IN PDEVICE_OBJECT pPDO, IN PIRP pIrp)
{
	PPORT_DEVICE_EXTENSION	pPort		= pPDO->DeviceExtension;
	NTSTATUS				status		= STATUS_SUCCESS;
	PIO_STACK_LOCATION		pIrpStack	= IoGetCurrentIrpStackLocation(pIrp);
	POWER_STATE				PowerState;

	PAGED_CODE();	// Macro in checked build to assert if pagable code is run at or above dispatch IRQL 

	switch (pIrpStack->MinorFunction) 
	{
    case IRP_MN_SET_POWER:
		{
			switch(pIrpStack->Parameters.Power.Type)
			{
			case SystemPowerState:
				SpxDbgMsg(SPX_TRACE_POWER_IRPS, ("%s: Got IRP_MN_SET_POWER Irp - Type SystemPowerState for Port %d.\n", 
					PRODUCT_NAME, pPort->PortNumber));
				return Spx_PortSetSystemPowerState(pPDO, pIrp);
				
			case DevicePowerState:
				SpxDbgMsg(SPX_TRACE_POWER_IRPS, ("%s: Got IRP_MN_SET_POWER Irp - Type DevicePowerState for Port %d.\n", 
					PRODUCT_NAME, pPort->PortNumber));
				return Spx_PortSetDevicePowerState(pPDO, pIrp);
			
			default:
				SpxDbgMsg(SPX_TRACE_POWER_IRPS, ("%s: Got IRP_MN_SET_POWER - Type 0x%02X Irp for Port %d.\n", 
					PRODUCT_NAME, pIrpStack->Parameters.Power.Type, pPort->PortNumber));

				status = STATUS_SUCCESS;
				pIrp->IoStatus.Status = status;
				break;
				
			}

			break;
		}

	case IRP_MN_QUERY_POWER:
		{
			switch(pIrpStack->Parameters.Power.Type)
			{
			case SystemPowerState:
				SpxDbgMsg(SPX_TRACE_POWER_IRPS, ("%s: Got IRP_MN_QUERY_POWER Irp - Type SystemPowerState for Port %d.\n", 
					PRODUCT_NAME, pPort->PortNumber));
				return Spx_PortQuerySystemPowerState(pPDO, pIrp);

			case DevicePowerState:
				SpxDbgMsg(SPX_TRACE_POWER_IRPS, ("%s: Got IRP_MN_QUERY_POWER Irp - Type DevicePowerState for Port %d.\n", 
					PRODUCT_NAME, pPort->PortNumber));

				switch(pIrpStack->Parameters.Power.State.DeviceState)
				{
				case PowerDeviceD0:
					SpxDbgMsg(SPX_TRACE_POWER_IRPS, ("%s: System is asking if Port %d can go to power state D0.\n", 
						PRODUCT_NAME, pPort->PortNumber));

					status = STATUS_SUCCESS;
					break;

				case PowerDeviceD1:
				case PowerDeviceD2:
				case PowerDeviceD3:
					SpxDbgMsg(SPX_TRACE_POWER_IRPS, ("%s: System is asking if Port %d can go to low power state D1, D2 or D3.\n", 
						PRODUCT_NAME, pPort->PortNumber));

					status = XXX_PortQueryPowerDown(pPort);
					break;

				default:
					status = STATUS_SUCCESS;
					break;
					
				}

				break;
			
			default:
				SpxDbgMsg(SPX_TRACE_POWER_IRPS, ("%s: Got IRP_MN_QUERY_POWER - Type 0x%02X Irp for Port %d.\n", 
					PRODUCT_NAME, pIrpStack->Parameters.Power.Type, pPort->PortNumber));
				break;
			}

			pIrp->IoStatus.Status = status;
			break;
		}
		
    case IRP_MN_WAIT_WAKE:
			SpxDbgMsg(SPX_TRACE_POWER_IRPS, ("%s: Got IRP_MN_WAIT_WAKE Irp for Port %d.\n", 
				PRODUCT_NAME, pPort->PortNumber));
			
			status = STATUS_NOT_SUPPORTED;
			pIrp->IoStatus.Status = status;
			break;

    case IRP_MN_POWER_SEQUENCE:
			SpxDbgMsg(SPX_TRACE_POWER_IRPS, ("%s: Got IRP_MN_POWER_SEQUENCE Irp for Port %d.\n", 
				PRODUCT_NAME, pPort->PortNumber));

			status = STATUS_NOT_IMPLEMENTED;
			pIrp->IoStatus.Status = status;
			break;

	default:
			SpxDbgMsg(SPX_TRACE_POWER_IRPS, ("%s: Got an UNKNOWN POWER Irp for Port %d.\n", 
				PRODUCT_NAME, pPort->PortNumber));

			status = STATUS_NOT_SUPPORTED;
			break;
	}

	PoStartNextPowerIrp(pIrp);
	IoCompleteRequest(pIrp, IO_NO_INCREMENT);	// Complete current IRP.

	return status;
}	// Spx_Port_PDO_DispatchPower


//////////////////////////////////////////////////////////////////////////////////////////
//	Spx_PortSetSystemPowerState													
//////////////////////////////////////////////////////////////////////////////////////////
NTSTATUS
Spx_PortSetSystemPowerState(IN PDEVICE_OBJECT pDevObject, IN PIRP pIrp)
{
	PPORT_DEVICE_EXTENSION	pPort		= pDevObject->DeviceExtension;
	NTSTATUS				status		= STATUS_SUCCESS;
	PIO_STACK_LOCATION		pIrpStack	= IoGetCurrentIrpStackLocation(pIrp);
	POWER_STATE				PowerState;

	PAGED_CODE();	// Macro in checked build to assert if pagable code is run at or above dispatch IRQL 

	SpxDbgMsg(SPX_TRACE_CALLS, ("%s: Entering Spx_PortSetSystemPowerState for Port %d.\n", 
		PRODUCT_NAME, pPort->PortNumber));

	switch (pIrpStack->Parameters.Power.State.SystemState) 
	{
		case PowerSystemUnspecified:
			PowerState.DeviceState = PowerDeviceUnspecified;
			PoRequestPowerIrp(pDevObject, IRP_MN_SET_POWER, PowerState, NULL, NULL, NULL);
			break;

        case PowerSystemWorking:
			PowerState.DeviceState = PowerDeviceD0;
			PoRequestPowerIrp(pDevObject, IRP_MN_SET_POWER, PowerState, NULL, NULL, NULL);
			break;	
				
        case PowerSystemSleeping1:
        case PowerSystemSleeping2:
        case PowerSystemSleeping3:
        case PowerSystemHibernate:
        case PowerSystemShutdown:
        case PowerSystemMaximum:
			PowerState.DeviceState = PowerDeviceD3;
			PoRequestPowerIrp(pDevObject, IRP_MN_SET_POWER, PowerState, NULL, NULL, NULL);
			break;

		default:
			break;
	}

	pIrp->IoStatus.Status = STATUS_SUCCESS;
	PoStartNextPowerIrp(pIrp);
	IoCompleteRequest(pIrp, IO_NO_INCREMENT);	// Complete current IRP.

	return status;
}	// Spx_PortSetSystemPowerState

//////////////////////////////////////////////////////////////////////////////////////////
//	Spx_PortQuerySystemPowerState													
//////////////////////////////////////////////////////////////////////////////////////////
NTSTATUS
Spx_PortQuerySystemPowerState(IN PDEVICE_OBJECT pDevObject, IN PIRP pIrp)
{
	PPORT_DEVICE_EXTENSION	pPort		= pDevObject->DeviceExtension;
	NTSTATUS				status		= STATUS_SUCCESS;
	PIO_STACK_LOCATION		pIrpStack	= IoGetCurrentIrpStackLocation(pIrp);
	POWER_STATE				PowerState;

	PAGED_CODE();	// Macro in checked build to assert if pagable code is run at or above dispatch IRQL 

	SpxDbgMsg(SPX_TRACE_CALLS, ("%s: Entering Spx_PortQuerySystemPowerState for Port %d.\n", 
		PRODUCT_NAME, pPort->PortNumber));

	switch (pIrpStack->Parameters.Power.State.SystemState) 
	{
		case PowerSystemUnspecified:
			PowerState.DeviceState = PowerDeviceUnspecified;
			PoRequestPowerIrp(pDevObject, IRP_MN_QUERY_POWER, PowerState, NULL, NULL, NULL);
			break;

        case PowerSystemWorking:
			PowerState.DeviceState = PowerDeviceD0;
			PoRequestPowerIrp(pDevObject, IRP_MN_QUERY_POWER, PowerState, NULL, NULL, NULL);
			break;	
				
        case PowerSystemSleeping1:
        case PowerSystemSleeping2:
        case PowerSystemSleeping3:
        case PowerSystemHibernate:
        case PowerSystemShutdown:
        case PowerSystemMaximum:
			PowerState.DeviceState = PowerDeviceD3;
			PoRequestPowerIrp(pDevObject, IRP_MN_QUERY_POWER, PowerState, NULL, NULL, NULL);
			break;

		default:
			break;
	}

	pIrp->IoStatus.Status = STATUS_SUCCESS;
	PoStartNextPowerIrp(pIrp);
	IoCompleteRequest(pIrp, IO_NO_INCREMENT);	// Complete current IRP.

	return status;
}	// Spx_PortQuerySystemPowerState



//////////////////////////////////////////////////////////////////////////////////////////
// Spx_PortSetDevicePowerState 
//////////////////////////////////////////////////////////////////////////////////////////
NTSTATUS
Spx_PortSetDevicePowerState(IN PDEVICE_OBJECT pDevObject, IN PIRP pIrp)
{
	PPORT_DEVICE_EXTENSION	pPort		= pDevObject->DeviceExtension;
	NTSTATUS				status		= STATUS_SUCCESS;
	PIO_STACK_LOCATION		pIrpStack	= IoGetCurrentIrpStackLocation(pIrp);

	PAGED_CODE();	// Macro in checked build to assert if pagable code is run at or above dispatch IRQL 

	SpxDbgMsg(SPX_TRACE_CALLS, ("%s: Entering Spx_PortSetDevicePowerState for Port %d.\n", 
		PRODUCT_NAME, pPort->PortNumber));

	switch(pIrpStack->Parameters.Power.State.DeviceState)
	{
	case PowerDeviceD0:
		SpxDbgMsg(SPX_TRACE_POWER_IRPS, ("%s: System requests Port %d goes into power state D0.\n", 
			PRODUCT_NAME, pPort->PortNumber));
		
		if(pPort->DeviceState == pIrpStack->Parameters.Power.State.DeviceState)
			SpxDbgMsg(SPX_TRACE_POWER_IRPS, ("%s: Port %d is already in power state D0.\n", 
				PRODUCT_NAME, pPort->PortNumber));
		else
			return Spx_PortSetPowerStateD0(pDevObject, pIrp);	// Switch ON

		break;

	case PowerDeviceD1:
		SpxDbgMsg(SPX_TRACE_POWER_IRPS, ("%s: System requests Port %d goes into power state D1.\n", 
			PRODUCT_NAME, pPort->PortNumber));

		if(pPort->DeviceState >= pIrpStack->Parameters.Power.State.DeviceState)
			SpxDbgMsg(SPX_TRACE_POWER_IRPS, ("%s: Port %d is already in power state D1 or lower.\n", 
				PRODUCT_NAME, pPort->PortNumber));
		else
			return Spx_PortSetPowerStateD3(pDevObject, pIrp);	// Switch OFF

		break;

	case PowerDeviceD2:
		SpxDbgMsg(SPX_TRACE_POWER_IRPS, ("%s: System requests Port %d goes into power state D2.\n", 
			PRODUCT_NAME, pPort->PortNumber));

		if(pPort->DeviceState >= pIrpStack->Parameters.Power.State.DeviceState)
			SpxDbgMsg(SPX_TRACE_POWER_IRPS, ("%s: Port %d is already in power state D2 or lower.\n", 
				PRODUCT_NAME, pPort->PortNumber));
		else
			return Spx_PortSetPowerStateD3(pDevObject, pIrp);	// Switch OFF

		break;

	case PowerDeviceD3:
		SpxDbgMsg(SPX_TRACE_POWER_IRPS, ("%s: System requests Port %d goes into power state D3.\n", 
			PRODUCT_NAME, pPort->PortNumber));

		if(pPort->DeviceState == pIrpStack->Parameters.Power.State.DeviceState)
			SpxDbgMsg(SPX_TRACE_POWER_IRPS, ("%s: Port %d is already in power state D3.\n", 
				PRODUCT_NAME, pPort->PortNumber));
		else
			return Spx_PortSetPowerStateD3(pDevObject, pIrp);	// Switch OFF

		break;

	default:
		break;

	}

	pIrp->IoStatus.Status = STATUS_SUCCESS;
	PoStartNextPowerIrp(pIrp);
	IoCompleteRequest(pIrp, IO_NO_INCREMENT);	// Complete current IRP.

	return status;
}	// Spx_PortSetDevicePowerState 


//////////////////////////////////////////////////////////////////////////////////////////
// Spx_PortSetPowerStateD0 -  Sets power state D0 for Port - ON
//////////////////////////////////////////////////////////////////////////////////////////
NTSTATUS
Spx_PortSetPowerStateD0(IN PDEVICE_OBJECT pDevObject, IN PIRP pIrp)
{
	PIO_STACK_LOCATION		pIrpStack	= IoGetCurrentIrpStackLocation(pIrp);
	PPORT_DEVICE_EXTENSION	pPort		= pDevObject->DeviceExtension;
	NTSTATUS				status		= STATUS_SUCCESS;

	PAGED_CODE();	// Macro in checked build to assert if pagable code is run at or above dispatch IRQL 

	SpxDbgMsg(SPX_TRACE_CALLS, ("%s: Entering Spx_PortSetPowerStateD0 for Port %d.\n", 
		PRODUCT_NAME, pPort->PortNumber));

	SetPnpPowerFlags(pPort, PPF_POWERED); 

	if(SPX_SUCCESS(pIrp->IoStatus.Status = XXX_PortPowerUp(pPort)))		// RESTORE HARDWARE STATE HERE & START PORT
	{
		// Inform Power Manager the of the new power state.
		PoSetPowerState(pDevObject, pIrpStack->Parameters.Power.Type, pIrpStack->Parameters.Power.State);

		pPort->DeviceState = PowerDeviceD0;	// Store new power state.
		Spx_UnstallIrps(pPort);				// Restart any queued IRPs (from a previous start)  
	}

	PoStartNextPowerIrp(pIrp);					// Ready for next power IRP.
	IoCompleteRequest(pIrp, IO_NO_INCREMENT);	// Complete current IRP.

	return status;
}	// Spx_PortSetPowerStateD0


//////////////////////////////////////////////////////////////////////////////////////////
// Spx_PortSetPowerStateD3 -  Sets power state D3 for Port - OFF
//////////////////////////////////////////////////////////////////////////////////////////
NTSTATUS
Spx_PortSetPowerStateD3(IN PDEVICE_OBJECT pDevObject, IN PIRP pIrp)
{
	PIO_STACK_LOCATION		pIrpStack	= IoGetCurrentIrpStackLocation(pIrp);
	PPORT_DEVICE_EXTENSION	pPort		= pDevObject->DeviceExtension;
	NTSTATUS				status		= STATUS_SUCCESS;

	PAGED_CODE();	// Macro in checked build to assert if pagable code is run at or above dispatch IRQL 

	SpxDbgMsg(SPX_TRACE_CALLS, ("%s: Entering Spx_PortSetPowerStateD3 for Port %d.\n", 
		PRODUCT_NAME, pPort->PortNumber));

	ClearPnpPowerFlags(pPort, PPF_POWERED); 

	if(SPX_SUCCESS(pIrp->IoStatus.Status = XXX_PortPowerDown(pPort)))	// SAVE HARDWARE STATE HERE & STOP PORT
	{   
		// Inform Power Manager the of the new power state. 
		PoSetPowerState(pDevObject, pIrpStack->Parameters.Power.Type, pIrpStack->Parameters.Power.State);
		pPort->DeviceState  = PowerDeviceD3;		// Store new power state.
	}

	PoStartNextPowerIrp(pIrp);					// Ready for next power IRP.
	IoCompleteRequest(pIrp, IO_NO_INCREMENT);	// Complete current IRP.

	return status;
}	// Spx_PortSetPowerStateD3



//////////////////////////////////////////////////////////////////////////////////////////
// Spx_PowerWaitForDriverBelow -  Waits for lower driver.
//////////////////////////////////////////////////////////////////////////////////////////
NTSTATUS 
Spx_PowerWaitForDriverBelow(IN PDEVICE_OBJECT pLowerDevObj, IN PIRP pIrp)
{
	KEVENT		EventWaitLowerDrivers;
	NTSTATUS	status;

	pIrp->IoStatus.Status = STATUS_SUCCESS;
	IoCopyCurrentIrpStackLocationToNext(pIrp);								// Copy parameters to the stack below 
	KeInitializeEvent(&EventWaitLowerDrivers, SynchronizationEvent, FALSE);	// Initialise event if need to wait 
	IoSetCompletionRoutine(pIrp, Spx_DispatchPnpPowerComplete, &EventWaitLowerDrivers, TRUE, TRUE, TRUE);

	if((status = PoCallDriver(pLowerDevObj, pIrp)) == STATUS_PENDING)
	{
		KeWaitForSingleObject(&EventWaitLowerDrivers, Executive, KernelMode, FALSE, NULL);
		status = pIrp->IoStatus.Status;
	}

	return(status);

} // Spx_PowerWaitForDriverBelow
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\spx\speed\driver\spx_pnp.c ===
#include "precomp.h"	// Precompiled header

/****************************************************************************************
*																						*
*	Module:			SPX_PNP.C															*
*																						*
*	Creation:		27th September 1998													*
*																						*
*	Author:			Paul Smith															*
*																						*
*	Version:		1.0.0																*
*																						*
*	Description:	Generic Plug and Play Functions	to handle PnP IRPS.					*
*																						*
****************************************************************************************/
/* History...

1.0.0	27/09/98 PBS	Creation.

*/

#define FILE_ID		SPX_PNP_C		// File ID for Event Logging see SPX_DEFS.H for values.

 
/*****************************************************************************
*******************************                *******************************
*******************************   Prototypes   *******************************
*******************************                *******************************
*****************************************************************************/

NTSTATUS Spx_Card_FDO_DispatchPnp(IN PDEVICE_OBJECT pFDO,IN PIRP pIrp);
NTSTATUS Spx_Card_StartDevice(IN PDEVICE_OBJECT pDevObject,IN PIRP pIrp);
NTSTATUS Spx_Card_StopDevice(IN PCARD_DEVICE_EXTENSION pCard);
NTSTATUS Spx_Card_RemoveDevice(IN PDEVICE_OBJECT pDevObject);

NTSTATUS Spx_CallDriverBelow(IN PDEVICE_OBJECT pLowerDevObj,IN PIRP pIrp);

NTSTATUS Spx_Port_PDO_DispatchPnp(IN PDEVICE_OBJECT pPDO,IN PIRP pIrp);
NTSTATUS Spx_Port_StartDevice(IN PDEVICE_OBJECT pDevObject);
NTSTATUS Spx_Port_StopDevice(IN PPORT_DEVICE_EXTENSION pPort);
NTSTATUS Spx_Port_RemoveDevice(IN PDEVICE_OBJECT pDevObject);

NTSTATUS Spx_EnumPorts(IN PDEVICE_OBJECT pDevObject);
NTSTATUS Spx_DoExternalNaming(IN PDEVICE_OBJECT pDevObject);
NTSTATUS Spx_GetExternalName(IN PDEVICE_OBJECT pDevObject);
NTSTATUS Spx_RemoveExternalNaming(IN PDEVICE_OBJECT pDevObject);


// Paging... 
#ifdef ALLOC_PRAGMA
#pragma alloc_text (PAGE, Spx_AddDevice)
#pragma alloc_text (PAGE, Spx_DispatchPnp)

#pragma alloc_text (PAGE, Spx_Card_FDO_DispatchPnp)
#pragma alloc_text (PAGE, Spx_Card_StartDevice)
#pragma alloc_text (PAGE, Spx_Card_StopDevice)
#pragma alloc_text (PAGE, Spx_Card_RemoveDevice)

#pragma alloc_text (PAGE, Spx_CallDriverBelow)

#pragma alloc_text (PAGE, Spx_Port_PDO_DispatchPnp)
#pragma alloc_text (PAGE, Spx_Port_StartDevice)
#pragma alloc_text (PAGE, Spx_Port_StopDevice)
#pragma alloc_text (PAGE, Spx_Port_RemoveDevice)

#pragma alloc_text (PAGE, Spx_EnumPorts)
#pragma alloc_text (PAGE, Spx_DoExternalNaming)
#pragma alloc_text (PAGE, Spx_GetExternalName)
#pragma alloc_text (PAGE, Spx_RemoveExternalNaming)
#pragma alloc_text (PAGE, Spx_CreatePortInstanceID)
#endif


#include <initguid.h>
#include <ntddser.h>


/*****************************************************************************
*****************************                   ******************************
*****************************   Spx_AddDevice   ******************************
*****************************                   ******************************
******************************************************************************

prototype:		NTSTATUS Spx_AddDevice(IN PDRIVER_OBJECT pDriverObject,IN PDEVICE_OBJECT pPDO)

description:	Create a functional device object (FDO) for the specified card physical device object.

parameters:		pDriver point to the driver object
				pPDO points to a card physical device object (PDO)

returns:		STATUS_SUCCESS
				STATUS_NO_MORE_ENTRIES
*/

NTSTATUS Spx_AddDevice(IN PDRIVER_OBJECT pDriverObject,IN PDEVICE_OBJECT pPDO)
{
	NTSTATUS				status = STATUS_SUCCESS;
	PDEVICE_OBJECT			pDevObject = NULL;
	PCARD_DEVICE_EXTENSION	pCard = NULL;
	PDEVICE_OBJECT			pLowerDevObject = NULL;
	static ULONG			CardNumber = 0;
	ULONG					i = 0;

	PAGED_CODE();	// Macro in checked build to assert if pagable code is run at or above dispatch IRQL 

	SpxDbgMsg(SPX_TRACE_CALLS, ("%s: Entering Spx_AddDevice.\n", PRODUCT_NAME));

	if(pPDO == NULL)
	{
		SpxDbgMsg(SPX_MISC_DBG, ("%s: In Spx_AddDevice - No more entries.\n", PRODUCT_NAME));
		return(STATUS_NO_MORE_ENTRIES);
	}

/* Create the device object... */

	status = IoCreateDevice(pDriverObject,
							sizeof(CARD_DEVICE_EXTENSION),
							NULL, 							// Doesn't need a name.
							FILE_DEVICE_CONTROLLER, 
							FILE_DEVICE_SECURE_OPEN, 
							TRUE, 
							&pDevObject);

	if(!SPX_SUCCESS(status))
	{
		CHAR szErrorMsg[MAX_ERROR_LOG_INSERT];	// Limited to 51 characters + 1 null 

		SpxDbgMsg(SPX_ERRORS,("%s: Create Device failed for card %d. CardExt at 0x%X.\n",
			PRODUCT_NAME,CardNumber++,&pDevObject));

		sprintf(szErrorMsg, "Card %d: Failed IoCreateDevice.", CardNumber++);
		
		Spx_LogMessage(	STATUS_SEVERITY_ERROR,
						pDriverObject,					// Driver Object
						NULL,							// Device Object (Optional)
						PhysicalZero,					// Physical Address 1
						PhysicalZero,					// Physical Address 2
						0,								// SequenceNumber
						0,								// Major Function Code
						0,								// RetryCount
						FILE_ID | __LINE__,				// UniqueErrorValue
						STATUS_SUCCESS,					// FinalStatus
						szErrorMsg);					// Error Message

		if(pDevObject)					// Clean up Device Object
			IoDeleteDevice(pDevObject);

		SpxDbgMsg(SPX_ERRORS, ("%s: Leaving Spx_AddDevice - FAILURE.\n", PRODUCT_NAME));
		return(status);
	}


	ASSERT(pDevObject != NULL);

/* Initialise the device extension... */

	pCard = pDevObject->DeviceExtension;							/* Point to card extension */
	RtlZeroMemory(pCard,sizeof(CARD_DEVICE_EXTENSION));				/* Zero extension structure */

	pDevObject->Flags |= DO_POWER_PAGABLE;				// Get power IRPs at IRQL PASSIVE_LEVEL 
	pDevObject->Flags &= ~DO_DEVICE_INITIALIZING;
	pLowerDevObject = IoAttachDeviceToDeviceStack(pDevObject,pPDO);	/* Attach to device stack */
	ASSERT(pLowerDevObject != NULL);

	KeInitializeSpinLock(&pCard->PnpPowerFlagsLock);	/* Initialise the PNP flags lock */
	ClearPnpPowerFlags(pCard,PPF_STARTED);				/* Not started yet */
	ClearPnpPowerFlags(pCard,PPF_STOP_PENDING);			/* Not pending a stop */
	ClearPnpPowerFlags(pCard,PPF_REMOVE_PENDING);		/* Not pending a remove */

	pCard->IsFDO = TRUE;								/* Card Object is a Functional Device Object (FDO) */
	pCard->CardNumber = CardNumber++;					/* Enumerate card devices */
	pCard->DeviceObject = pDevObject;					/* Back pointer to device object */
	pCard->LowerDeviceObject= pLowerDevObject;			/* Pointer to device below in device stack */
	pCard->DriverObject = pDriverObject;				/* Pointer to driver object */
	pCard->PDO = pPDO;									/* Pointer to card physical device object (PDO) */
    pCard->DeviceState = PowerDeviceD0;					/* Initial power state */
	pCard->SystemState = PowerSystemWorking;			/* System in full power State */
	pCard->NumPDOs = 0;									/* Initialise attached port PDO pointers */

	for(i=0; i<PRODUCT_MAX_PORTS; i++)
		pCard->AttachedPDO[i] = NULL;

	SetPnpPowerFlags(pCard,PPF_POWERED);				/* Initially assumed we are powered */

	XXX_CardInit(pCard);								/* Initialise non-hardware extension fields */

	SpxDbgMsg(SPX_TRACE_CALLS,("%s: Leaving Spx_AddDevice - SUCCESS.\n",PRODUCT_NAME));

	return(status);

} /* Spx_AddDevice */

/*****************************************************************************
****************************                     *****************************
****************************   Spx_DispatchPnp   *****************************
****************************                     *****************************
******************************************************************************

prototype:		NTSTATUS Spx_DispatchPnp(IN PDEVICE_OBJECT pDevObject,IN PIRP pIrp)

description:	The plug and play dispatch routine.
				Determines whether IRP is for a card or a port and calls other functions to handle it. 

parameters:		pDevObject points to a device object for this driver
				pIrp points to the Plug and Play I/O Request (IRP) to be processed

returns:		NT Status Code

*/

NTSTATUS Spx_DispatchPnp(IN PDEVICE_OBJECT pDevObject,IN PIRP pIrp)
{
	PCOMMON_OBJECT_DATA		CommonData = (PCOMMON_OBJECT_DATA) pDevObject->DeviceExtension;
	NTSTATUS				status = STATUS_SUCCESS;
	
	PAGED_CODE();	// Macro in checked build to assert if pagable code is run at or above dispatch IRQL 

	if(CommonData->IsFDO)									/* Functional Device Object ? */
		status = Spx_Card_FDO_DispatchPnp(pDevObject,pIrp);	/* Yes, must be card device */
	else	
		status = Spx_Port_PDO_DispatchPnp(pDevObject,pIrp);	/* No, must be port device */

	return(status);

} /* Spx_DispatchPnp */

/*****************************************************************************
************************                              ************************
************************   Spx_Card_FDO_DispatchPnp   ************************
************************                              ************************
******************************************************************************

prototype:		NTSTATUS Spx_Card_FDO_DispatchPnp(IN PDEVICE_OBJECT pFDO,IN PIRP pIrp)

description:	The plug and play dispatch routine to handle IRPs for card devices.

parameters:		pDevObject points to a card device object for this driver
				pIrp points to the Plug and Play I/O Request (IRP) to be processed

returns:		NT Status Code

*/

NTSTATUS Spx_Card_FDO_DispatchPnp(IN PDEVICE_OBJECT pFDO,IN PIRP pIrp)
{
	PCARD_DEVICE_EXTENSION		pCard = pFDO->DeviceExtension;
	PDEVICE_OBJECT				pLowerDevObj = pCard->LowerDeviceObject;
	NTSTATUS					status;
	PDEVICE_CAPABILITIES		pDevCaps = NULL;
	PIO_STACK_LOCATION			pIrpStack = IoGetCurrentIrpStackLocation(pIrp);
	PDEVICE_RELATIONS			pRelations = NULL;
	ULONG						length = 0;
	ULONG						i = 0;

	PAGED_CODE();	// Macro in checked build to assert if pagable code is run at or above dispatch IRQL 


	switch(pIrpStack->MinorFunction)
	{	

/*****************************************************************************
***************************   IRP_MN_START_DEVICE   **************************
*****************************************************************************/
	
	case	IRP_MN_START_DEVICE:
			SpxDbgMsg(SPX_TRACE_PNP_IRPS,("%s: Got IRP_MN_START_DEVICE Irp for Card %d.\n",
				PRODUCT_NAME,pCard->CardNumber));

/* Call driver below first... */

			status = Spx_CallDriverBelow(pLowerDevObj,pIrp);

/* If successful, then start the card... */

			if(NT_SUCCESS(status))		// Must use NT_SUCCESS() here!!
				status = Spx_Card_StartDevice(pFDO,pIrp);	/* Start the card */

			pIrp->IoStatus.Status = status;
			pIrp->IoStatus.Information = 0;
			IoCompleteRequest(pIrp,IO_NO_INCREMENT);
			break;

/*****************************************************************************
**********************   IRP_MN_QUERY_DEVICE_RELATIONS   *********************
*****************************************************************************/

	case	IRP_MN_QUERY_DEVICE_RELATIONS:
			SpxDbgMsg(SPX_TRACE_PNP_IRPS,("%s: Got IRP_MN_QUERY_DEVICE_RELATIONS Irp for Card %d.\n",
				PRODUCT_NAME,pCard->CardNumber));
			
			if(pIrpStack->Parameters.QueryDeviceRelations.Type != BusRelations)	/* Only handle BusRelations */
			{
				SpxDbgMsg(SPX_TRACE_PNP_IRPS,("%s: IRP_MN_QUERY_DEVICE_RELATIONS for Card - Non bus.\n",PRODUCT_NAME));
				IoSkipCurrentIrpStackLocation(pIrp);
				status = IoCallDriver(pLowerDevObj,pIrp);
				break;
			}

/* Enumerate devices on the card... */

			Spx_EnumPorts(pFDO);								/* Enumerate and create port device objects */

/* Tell the Plug and Play Manager any found ports... */

			i = 0;
			if(pIrp->IoStatus.Information)						/* Get current device object count */
				i = ((PDEVICE_RELATIONS)pIrp->IoStatus.Information)->Count;

			length = sizeof(DEVICE_RELATIONS)+((pCard->NumPDOs+i)*sizeof(PDEVICE_OBJECT));
			if(pRelations = SpxAllocateMem(NonPagedPool, length))/* Allocate new structure */
			{

/* Copy in the device objects so far... */

				if(i)
					RtlCopyMemory
					(
						pRelations->Objects,
						((PDEVICE_RELATIONS)pIrp->IoStatus.Information)->Objects,
						i * sizeof (PDEVICE_OBJECT)
					);

				pRelations->Count = i;								/* Update device count */

/* Add specialix ports to the device relations... */

				if(pCard->NumPDOs)
				{
					for(i=0; i<PRODUCT_MAX_PORTS; i++)
					{
						if(pCard->AttachedPDO[i])					/* If object exists */
						{											/* add to table */
							pRelations->Objects[pRelations->Count++] = pCard->AttachedPDO[i];
							ObReferenceObject(pCard->AttachedPDO[i]);
						}
					}
				}

				if(pIrp->IoStatus.Information != 0)					/* If previous structure */
					SpxFreeMem((PVOID)pIrp->IoStatus.Information);	/* then free */

				pIrp->IoStatus.Information = (ULONG_PTR)pRelations;	/* Set new structure */

			}
			else
			{
				CHAR szErrorMsg[MAX_ERROR_LOG_INSERT];	// Limited to 51 characters + 1 null 

				sprintf(szErrorMsg, "Card at %08X%08X: Insufficient resources.", pCard->PhysAddr.HighPart, pCard->PhysAddr.LowPart);
				
				Spx_LogMessage(	STATUS_SEVERITY_ERROR,
								pCard->DriverObject,			// Driver Object
								pCard->DeviceObject,			// Device Object (Optional)
								PhysicalZero,					// Physical Address 1
								PhysicalZero,					// Physical Address 2
								0,								// SequenceNumber
								pIrpStack->MajorFunction,		// Major Function Code
								0,								// RetryCount
								FILE_ID | __LINE__,				// UniqueErrorValue
								STATUS_SUCCESS,					// FinalStatus
								szErrorMsg);					// Error Message
			}

			pIrp->IoStatus.Status = STATUS_SUCCESS;
			IoSkipCurrentIrpStackLocation(pIrp);				/* Copy parameters to next stack */
			status = IoCallDriver(pLowerDevObj,pIrp);			/* Call driver below */
			break;

/*****************************************************************************
**********************   IRP_MN_QUERY_PNP_DEVICE_STATE   *********************
*****************************************************************************/

	case	IRP_MN_QUERY_PNP_DEVICE_STATE:
			SpxDbgMsg(SPX_TRACE_PNP_IRPS,("%s: Got IRP_MN_QUERY_PNP_DEVICE_STATE Irp for Card %d.\n",
				PRODUCT_NAME,pCard->CardNumber));
			IoSkipCurrentIrpStackLocation(pIrp);
			status = IoCallDriver(pLowerDevObj,pIrp);
			break;

/*****************************************************************************
************************   IRP_MN_QUERY_CAPABILITIES   ***********************
*****************************************************************************/

	case	IRP_MN_QUERY_CAPABILITIES:
			SpxDbgMsg(SPX_TRACE_PNP_IRPS,("%s: Got IRP_MN_QUERY_CAPABILITIES Irp for Card %d.\n",
				PRODUCT_NAME,pCard->CardNumber));
			IoSkipCurrentIrpStackLocation(pIrp);
			status = IoCallDriver(pLowerDevObj,pIrp);
			break;

/*****************************************************************************
************************   IRP_MN_QUERY_STOP_DEVICE   ************************
*****************************************************************************/

	case	IRP_MN_QUERY_STOP_DEVICE:
			SpxDbgMsg(SPX_TRACE_PNP_IRPS,("%s: Got IRP_MN_QUERY_STOP_DEVICE Irp for Card %d.\n",
				PRODUCT_NAME,pCard->CardNumber));

			status = STATUS_SUCCESS;
			SetPnpPowerFlags(pCard,PPF_STOP_PENDING);	// We must now expect a STOP IRP

			if(SPX_SUCCESS(status))						// If we can stop, pass IRP on down
			{
				pIrp->IoStatus.Status = status;
				IoSkipCurrentIrpStackLocation(pIrp);
				status = IoCallDriver(pLowerDevObj,pIrp);
			}
			else										// If we can't then complete
			{
				pIrp->IoStatus.Status = status;
				IoCompleteRequest(pIrp, IO_NO_INCREMENT);
			}
			break;

/*****************************************************************************
************************   IRP_MN_CANCEL_STOP_DEVICE   ***********************
*****************************************************************************/

	case	IRP_MN_CANCEL_STOP_DEVICE:
			SpxDbgMsg(SPX_TRACE_PNP_IRPS,("%s: Got IRP_MN_CANCEL_STOP_DEVICE Irp for Card %d.\n",
				PRODUCT_NAME,pCard->CardNumber));

/* Call driver below first... */

			status = Spx_CallDriverBelow(pLowerDevObj,pIrp);

			if(NT_SUCCESS(status))
			{
				// we return the device to its working state here.
				ClearPnpPowerFlags(pCard,PPF_STOP_PENDING);	// We are no longer expecting a STOP IRP.
				status = STATUS_SUCCESS;
			}

			pIrp->IoStatus.Status = status;
			IoCompleteRequest(pIrp, IO_NO_INCREMENT);
			break;

/*****************************************************************************
****************************   IRP_MN_STOP_DEVICE   **************************
*****************************************************************************/

	case	IRP_MN_STOP_DEVICE: 
			SpxDbgMsg(SPX_TRACE_PNP_IRPS, ("%s: Got IRP_MN_STOP_DEVICE Irp for Card %d.\n", 
				PRODUCT_NAME, pCard->CardNumber));

			Spx_Card_StopDevice(pCard);				/* Stop the card hardware */

			pIrp->IoStatus.Status = STATUS_SUCCESS;	/* Cannot fail this request */
			IoSkipCurrentIrpStackLocation(pIrp);		
			status = IoCallDriver(pLowerDevObj,pIrp);
			break;

/*****************************************************************************
************************   IRP_MN_QUERY_REMOVE_DEVICE   **********************
*****************************************************************************/
				
	case	IRP_MN_QUERY_REMOVE_DEVICE:
			SpxDbgMsg(SPX_TRACE_PNP_IRPS, ("%s: Got IRP_MN_QUERY_REMOVE_DEVICE Irp for Card %d.\n", 
				PRODUCT_NAME, pCard->CardNumber));

			status = STATUS_SUCCESS;

			if(SPX_SUCCESS(status))					// If we can stop, pass IRP on down
			{
				SetPnpPowerFlags(pCard,PPF_REMOVE_PENDING);	// We are now ready to remove the card
				pIrp->IoStatus.Status	= status;
				IoSkipCurrentIrpStackLocation(pIrp);
				status = IoCallDriver(pLowerDevObj,pIrp);
			}
			else									// If we can't then complete
			{
				pIrp->IoStatus.Status = status;
				IoCompleteRequest(pIrp, IO_NO_INCREMENT);
			}

			break;

/*****************************************************************************
***********************   IRP_MN_CANCEL_REMOVE_DEVICE   **********************
*****************************************************************************/

	case	IRP_MN_CANCEL_REMOVE_DEVICE:
			SpxDbgMsg(SPX_TRACE_PNP_IRPS, ("%s: Got IRP_MN_CANCEL_REMOVE_DEVICE Irp for Card %d.\n", 
				PRODUCT_NAME, pCard->CardNumber));

/* Call driver below first... */

			status = Spx_CallDriverBelow(pLowerDevObj,pIrp);

			if(NT_SUCCESS(status))
			{
				ClearPnpPowerFlags(pCard,PPF_REMOVE_PENDING);	// We are no longer expecting to remove the device.
			}

			pIrp->IoStatus.Status = status;
			IoCompleteRequest(pIrp,IO_NO_INCREMENT);
			break;

/*****************************************************************************
*************************   IRP_MN_SURPRISE_REMOVAL   ************************
*****************************************************************************/

	case	IRP_MN_SURPRISE_REMOVAL:
			SpxDbgMsg(SPX_TRACE_PNP_IRPS, ("%s: Got IRP_MN_SURPRISE_REMOVAL Irp for Card %d.\n", 
				PRODUCT_NAME, pCard->CardNumber));

			status = Spx_Card_StopDevice(pCard);	// Lets stop the port ready for the REMOVE IRP if we are not already.

			SetPnpPowerFlags(pCard,PPF_REMOVE_PENDING);	// We are now ready to remove the card
			pIrp->IoStatus.Status = status;
			IoSkipCurrentIrpStackLocation(pIrp);
			status = IoCallDriver(pLowerDevObj,pIrp);
			break;

/*****************************************************************************
**************************   IRP_MN_REMOVE_DEVICE   **************************
*****************************************************************************/

	case IRP_MN_REMOVE_DEVICE: 
			SpxDbgMsg(SPX_TRACE_PNP_IRPS, ("%s: Got IRP_MN_REMOVE_DEVICE Irp for Card %d.\n", 
				PRODUCT_NAME, pCard->CardNumber));

			status = Spx_Card_RemoveDevice(pFDO);

			pIrp->IoStatus.Status = status;
			IoSkipCurrentIrpStackLocation(pIrp);
			status = IoCallDriver(pLowerDevObj,pIrp);
			break;

	default:
			SpxDbgMsg(SPX_TRACE_PNP_IRPS,("%s: Got PnP Irp - MinorFunction=0x%02X for Card %d.\n",
				PRODUCT_NAME,pIrpStack->MinorFunction,pCard->CardNumber));
			
			IoSkipCurrentIrpStackLocation(pIrp);
			status = IoCallDriver(pLowerDevObj,pIrp);
			break;

	}

	return(status);

} /* Spx_Card_FDO_DispatchPnp */

/*****************************************************************************
**************************                         ***************************
**************************   Spx_CallDriverBelow   ***************************
**************************                         ***************************
******************************************************************************

prototype:		NTSTATUS Spx_CallDriverBelow(IN PDEVICE_OBJECT pLowerDevObj,IN PIRP pIrp)

description:	Pass the IRP to the driver below this first and wait for it to complete.

parameters:		pLowerDevObj points to a device object for the device below
				pIrp points to the Plug and Play I/O Request (IRP) to be processed

returns:		NT Status Code

*/

NTSTATUS Spx_CallDriverBelow(IN PDEVICE_OBJECT pLowerDevObj,IN PIRP pIrp)
{
	KEVENT		eventWaitLowerDrivers;
	NTSTATUS	status;

	PAGED_CODE();	// Macro in checked build to assert if pagable code is run at or above dispatch IRQL 

	IoCopyCurrentIrpStackLocationToNext(pIrp);								/* Copy parameters to the stack below */
	KeInitializeEvent(&eventWaitLowerDrivers,SynchronizationEvent,FALSE);	/* Initialise event if need to wait */
	IoSetCompletionRoutine(pIrp,Spx_DispatchPnpPowerComplete,&eventWaitLowerDrivers,TRUE,TRUE,TRUE);

	if((status = IoCallDriver(pLowerDevObj,pIrp)) == STATUS_PENDING)
	{
		KeWaitForSingleObject(&eventWaitLowerDrivers,Executive,KernelMode,FALSE,NULL);
		status = pIrp->IoStatus.Status;
	}

	return(status);

} /* Spx_CallDriverBelow */

/************************************************************************************
************************									*************************
************************   Spx_DispatchPnpPowerComplete		*************************
************************									*************************
*************************************************************************************

prototype:		NTSTATUS Spx_DispatchPnpPowerComplete(IN PDEVICE_OBJECT pDevObject,IN PIRP pIrp,IN PVOID Context)

description:	The PnP IRP was completed by the lower-level drivers.
				Signal this to whoever registered us.

parameters:		pDevObject point to the device completing the IRP
				pIrp points to the Plug and Play I/O Request (IRP) to be completed
				Context was set when the lower driver was called (actually event)

returns:		NT Status Code

*/

NTSTATUS Spx_DispatchPnpPowerComplete(IN PDEVICE_OBJECT pDevObject,IN PIRP pIrp,IN PVOID Context)
{

	PIO_STACK_LOCATION	stack = NULL;
	PKEVENT				event = (PKEVENT) Context;
	NTSTATUS			status;

	
	UNREFERENCED_PARAMETER(pDevObject);

	SpxDbgMsg(SPX_TRACE_CALLS,("%s: Entering DispatchPnpComplete.\n",PRODUCT_NAME));

	status = STATUS_SUCCESS;
	stack = IoGetCurrentIrpStackLocation(pIrp);

    switch(stack->MajorFunction) 
	{
		case IRP_MJ_PNP:

			switch(stack->MinorFunction) 
			{
				case IRP_MN_START_DEVICE:		// Codes which need processing after lower drivers 
				case IRP_MN_QUERY_CAPABILITIES:
				case IRP_MN_CANCEL_STOP_DEVICE:
				case IRP_MN_CANCEL_REMOVE_DEVICE:
					KeSetEvent(event,0,FALSE);		// Wake up waiting process //
					return(STATUS_MORE_PROCESSING_REQUIRED);

				default:
					break;
			}
			break;

		case IRP_MJ_POWER:
				KeSetEvent(event, 0, FALSE);		// Wake up waiting process 
				return(STATUS_MORE_PROCESSING_REQUIRED);

		default:
			break;

	}

    return(status);

} /* Spx_DispatchPnpPowerComplete */

/*****************************************************************************
**************************                          **************************
**************************   Spx_Card_StartDevice   **************************
**************************                          **************************
******************************************************************************

prototype:		NTSTATUS Spx_Card_StartDevice(IN PDEVICE_OBJECT pDevObject,IN PIRP pIrp)

description:	Start the card device:
					Process resources (interrupt, I/O, memory)
					Initialise and start the hardware

parameters:		pDevObject point to the card device to start
				pIrp points to the start I/O Request (IRP)

returns:		NT Status Code

*/

NTSTATUS Spx_Card_StartDevice(IN PDEVICE_OBJECT pDevObject,IN PIRP pIrp)
{
	PCARD_DEVICE_EXTENSION	pCard = pDevObject->DeviceExtension;
	PIO_STACK_LOCATION		pIrpStack = IoGetCurrentIrpStackLocation(pIrp);

	NTSTATUS status = STATUS_SUCCESS;

	PAGED_CODE();	// Macro in checked build to assert if pagable code is run at or above dispatch IRQL 

	SpxDbgMsg(SPX_TRACE_CALLS,("%s: Entering Spx_Card_StartDevice for Card %d.\n",PRODUCT_NAME,pCard->CardNumber));

/* Translate the card resources... */

	status = XXX_CardGetResources(	pDevObject,
									pIrpStack->Parameters.StartDevice.AllocatedResources,
									pIrpStack->Parameters.StartDevice.AllocatedResourcesTranslated);
	
	if(!SPX_SUCCESS(status))
		return(status);


/* Start the hardware... */

	if(!SPX_SUCCESS(status = XXX_CardStart(pCard)))
		return(status);

	SetPnpPowerFlags(pCard,PPF_STARTED);	/* Card has been started */

	return(status);

} /* Spx_Card_StartDevice */

/*****************************************************************************
*****************************                   ******************************
*****************************   Spx_EnumPorts   ******************************
*****************************                   ******************************
******************************************************************************

prototype:		NTSTATUS Spx_EnumPorts(IN PDEVICE_OBJECT pDevObject)

description:	Enumerate port devices found on the card device:

parameters:		pDevObject point to the card device to enumerate

returns:		NT Status Code

*/

NTSTATUS Spx_EnumPorts(IN PDEVICE_OBJECT pDevObject)
{
	PCARD_DEVICE_EXTENSION	pCard = pDevObject->DeviceExtension;
	PPORT_DEVICE_EXTENSION	pPort = NULL;

	NTSTATUS				status = STATUS_SUCCESS;
	PDEVICE_OBJECT			PortPDO = NULL;

	UNICODE_STRING			PortPDOName;
	static ULONG			CurrentInstance = 0;

	UNICODE_STRING			InstanceStr;
	WCHAR					InstanceNumberBuffer[10];
	POWER_STATE				PowerState;
	USHORT					PortNumber	= 0;

	PAGED_CODE();	// Macro in checked build to assert if pagable code is run at or above dispatch IRQL 

	SpxDbgMsg(SPX_TRACE_CALLS,("%s: Entering Spx_EnumPorts for Card %d.\n",PRODUCT_NAME,pCard->CardNumber));

// Name and create device objects for each port on the card... 
	
	for(PortNumber=0;PortNumber<pCard->NumberOfPorts;PortNumber++)
	{

		if(pCard->AttachedPDO[PortNumber] == NULL)			// Only create if not already present 
		{

// Create the base port name ("XxPort")... 
		
			RtlZeroMemory(&PortPDOName, sizeof(UNICODE_STRING));
			PortPDOName.MaximumLength = DEVICE_OBJECT_NAME_LENGTH * sizeof(WCHAR);
			PortPDOName.Buffer = SpxAllocateMem(PagedPool, PortPDOName.MaximumLength+sizeof(WCHAR));
			if(PortPDOName.Buffer == NULL) continue;
			RtlZeroMemory(PortPDOName.Buffer, PortPDOName.MaximumLength+sizeof(WCHAR));
			RtlAppendUnicodeToString(&PortPDOName, PORT_PDO_NAME_BASE);

// Create the instance ("0")... 

			RtlInitUnicodeString(&InstanceStr,NULL);
			InstanceStr.MaximumLength = sizeof(InstanceNumberBuffer);
			InstanceStr.Buffer = InstanceNumberBuffer;
			RtlIntegerToUnicodeString(CurrentInstance++, 10, &InstanceStr);

// Append instance to the device name ("XxPort0")... 

			RtlAppendUnicodeStringToString(&PortPDOName, &InstanceStr);

// Create the port device object with this name... 

			status = IoCreateDevice(pDevObject->DriverObject, 
									sizeof(PORT_DEVICE_EXTENSION),
									&PortPDOName,  				// Object Name 
									FILE_DEVICE_SERIAL_PORT, 
									FILE_DEVICE_SECURE_OPEN, 
									TRUE, 
									&PortPDO);

 			if(!SPX_SUCCESS(status))
			{
				SpxDbgMsg(SPX_ERRORS,("%s: Create Device failed = %wZ\n",PRODUCT_NAME,&PortPDOName));
				SpxFreeMem(PortPDOName.Buffer);
				continue;
			}

			ASSERT(PortPDO != NULL);

// Increment the pdo's stacksize so that it can pass irps through... 

			PortPDO->StackSize += pDevObject->StackSize;

// Keep a pointer to the device in the card structure... 

			pCard->NumPDOs++;
			pCard->AttachedPDO[PortNumber] = PortPDO;
			ObReferenceObject(PortPDO);

// Initialise port device object and extension... 

			pPort = PortPDO->DeviceExtension;
			RtlZeroMemory(pPort,sizeof(PORT_DEVICE_EXTENSION));		// Clear the device extension 

			pPort->DeviceName = PortPDOName;

			KeInitializeSpinLock(&pPort->PnpPowerFlagsLock);		// Initialise the PNP flags lock 
			ClearPnpPowerFlags(pPort,PPF_STARTED);					// Not started yet 
			ClearPnpPowerFlags(pPort,PPF_STOP_PENDING);				// Not pending a stop 
			ClearPnpPowerFlags(pPort,PPF_REMOVE_PENDING);			// Not pending a remove 
			ClearPnpPowerFlags(pPort,PPF_REMOVED);					// Not removed 
			SetPnpPowerFlags(pPort,PPF_POWERED);					// Initially powered up 

			InitializeListHead(&pPort->StalledIrpQueue);			// Initialise the stalled IRP list 
			KeInitializeSpinLock(&pPort->StalledIrpLock);			// Initialise the StalledIrpLock flags lock 
			pPort->UnstallingFlag = FALSE;							// Initialise UnstallingIrps Flag.

			pPort->IsFDO = FALSE;
			pPort->PortNumber = PortNumber;							// system port number 
			pPort->UniqueInstanceID = FALSE;						// Instance ID not unique by default.
			pPort->DeviceIsOpen = FALSE;							// Port is closed to start with 
			pPort->DeviceObject = PortPDO;							// Backpointer to device object 
			pPort->DeviceState = PowerDeviceD0;						// Port device in full power state 
			pPort->SystemState = PowerSystemWorking;				// System in full power State 
			pPort->pParentCardExt = pCard;							// Point to the parent card extension 
			ExInitializeFastMutex(&pPort->OpenMutex);

			if(!SPX_SUCCESS(status = XXX_PortInit(pPort)))			// Initialise hardware 
				continue;

			// Inform Power Manager the of the new power state.
			PowerState.DeviceState = pPort->DeviceState;
			PoSetPowerState(pPort->DeviceObject, DevicePowerState, PowerState);

			PortPDO->Flags &= ~DO_DEVICE_INITIALIZING;				// Finished Initialising 
			PortPDO->Flags |= DO_BUFFERED_IO;						// Do Buffered IO 
			PortPDO->Flags |= DO_BUS_ENUMERATED_DEVICE;				// Bus enumerated 
			PortPDO->Flags |= DO_POWER_PAGABLE;						// Get power IRPs at IRQL PASSIVE_LEVEL 

		}
		else
		{
			PortPDO = pCard->AttachedPDO[PortNumber];
			pPort = PortPDO->DeviceExtension;

			if(pPort->PnpPowerFlags & PPF_REMOVED)
				ClearPnpPowerFlags(pPort,PPF_REMOVED);
		}
	}

	return(status);

} // End Spx_EnumPorts 

/*****************************************************************************
**************************                         ***************************
**************************   Spx_Card_StopDevice   ***************************
**************************                         ***************************
******************************************************************************

prototype:		NTSTATUS Spx_Card_StopDevice(IN PCARD_DEVICE_EXTENSION pCard)

description:	Stop the card device:
					Stop the hardware
					Deinitialise card resources (interrupt, I/O, memory)

parameters:		pCard points to the card device to stop

returns:		NT Status Code

*/

NTSTATUS Spx_Card_StopDevice(IN PCARD_DEVICE_EXTENSION pCard)
{
	NTSTATUS	status = STATUS_SUCCESS;

	PAGED_CODE();	// Macro in checked build to assert if pagable code is run at or above dispatch IRQL 

	SpxDbgMsg(SPX_TRACE_CALLS,("%s: Entering Spx_Card_StopDevice for Card %d.\n",PRODUCT_NAME,pCard->CardNumber));

	if(pCard->PnpPowerFlags & PPF_STARTED)		/* If card is running */
	{
		XXX_CardStop(pCard);					/* Stop the card */
	}

	ClearPnpPowerFlags(pCard,PPF_STARTED);		/* Indicate card is stopped */
	ClearPnpPowerFlags(pCard,PPF_STOP_PENDING);	/* Clear stop pending flag */

	return(status);

} /* Spx_Card_StopDevice */

/*****************************************************************************
*************************                           **************************
*************************   Spx_Card_RemoveDevice   **************************
*************************                           **************************
******************************************************************************

prototype:		NTSTATUS Spx_Card_RemoveDevice(IN PDEVICE_OBJECT pDevObject)

description:	Remove the card device:
					Deallocate any resources
					Delete device object

parameters:		pDevObject points to the card device object to remove

returns:		NT Status Code

*/


NTSTATUS Spx_Card_RemoveDevice(IN PDEVICE_OBJECT pDevObject)
{
	PCARD_DEVICE_EXTENSION	pCard = pDevObject->DeviceExtension;
	PDEVICE_OBJECT			pPortPdo;
	PPORT_DEVICE_EXTENSION	pPort;
	NTSTATUS				status = STATUS_SUCCESS;
	int						loop;

	PAGED_CODE();	// Macro in checked build to assert if pagable code is run at or above dispatch IRQL 

	SpxDbgMsg(SPX_TRACE_CALLS, ("%s: Entering Spx_Card_RemoveDevice for Card %d.\n", 
		PRODUCT_NAME, pCard->CardNumber));

/* First remove all "removed" port device objects... */

	for(loop=0; loop<PRODUCT_MAX_PORTS; loop++)
	{
		if(pPortPdo = pCard->AttachedPDO[loop])			/* Enumerated port PDO ? */
		{
			pPort = pPortPdo->DeviceExtension;			/* Get the device extension */
			XXX_PortDeInit(pPort);						/* Deinitialise port structure */
			if(pPort->DeviceName.Buffer)
			{
				SpxFreeMem(pPort->DeviceName.Buffer);	/* Free device name buffer */
				pPort->DeviceName.Buffer = NULL;
			}
			pCard->AttachedPDO[loop] = NULL;			/* Remove the port PDO pointer */
			pCard->NumPDOs--;							/* One less port attached */
			IoDeleteDevice(pPortPdo);					/* Delete the port device object */
			ObDereferenceObject(pPortPdo);				/* Dereference the object */
		}
	}

/* Now, remove the card device object... */

	Spx_Card_StopDevice(pCard);							/* Stop the card and release resources */
	XXX_CardDeInit(pCard);								/* Deinitialise non-hardware fields */
	IoDetachDevice(pCard->LowerDeviceObject);			/* Detach card device from the device stack. */
	IoDeleteDevice(pDevObject);							/* Delete Card FDO from system. */

	return(status);

} /* Spx_Card_RemoveDevice */



/*****************************************************************************
************************                              ************************
************************   Spx_Port_PDO_DispatchPnp   ************************
************************                              ************************
******************************************************************************

prototype:		NTSTATUS Spx_Port_PDO_DispatchPnp(IN PDEVICE_OBJECT pPDO,IN PIRP pIrp)

description:	The plug and play dispatch routine to handle IRPs for port devices.

parameters:		pDevObject points to a port device object for this driver
				pIrp points to the Plug and Play I/O Request (IRP) to be processed

returns:		NT Status Code

*/

NTSTATUS Spx_Port_PDO_DispatchPnp(IN PDEVICE_OBJECT pPDO,IN PIRP pIrp)
{
	PPORT_DEVICE_EXTENSION	pPort = pPDO->DeviceExtension;
	PCARD_DEVICE_EXTENSION	pCard = pPort->pParentCardExt;
	PIO_STACK_LOCATION		pIrpStack = IoGetCurrentIrpStackLocation(pIrp);
	NTSTATUS				status;
	PWCHAR					ReturnBuffer = NULL;

	PAGED_CODE();	// Macro in checked build to assert if pagable code is run at or above dispatch IRQL 

	status = pIrp->IoStatus.Status;

	switch (pIrpStack->MinorFunction) 
	{
   
/*****************************************************************************
***************************   IRP_MN_START_DEVICE   **************************
*****************************************************************************/
	
	case	IRP_MN_START_DEVICE: 
			SpxDbgMsg(SPX_TRACE_PNP_IRPS,("%s: Got IRP_MN_START_DEVICE Irp for Port %d.\n",
				PRODUCT_NAME,pPort->PortNumber));

			status = STATUS_UNSUCCESSFUL;

			if(SPX_SUCCESS(status = Spx_Port_StartDevice(pPDO)))
				Spx_UnstallIrps(pPort);					// Restart any queued IRPs (from a previous start) 

			break;

/*****************************************************************************
*****************************   IRP_MN_QUERY_ID   ****************************
*****************************************************************************/
	
	case	IRP_MN_QUERY_ID:
	{
		PUNICODE_STRING pId	= NULL;
		CHAR szErrorMsg[MAX_ERROR_LOG_INSERT];	// Limited to 51 characters + 1 null 

		switch(pIrpStack->Parameters.QueryId.IdType)
		{
		case	BusQueryCompatibleIDs:
		case	BusQueryDeviceID:
		case	BusQueryInstanceID:
		case	BusQueryHardwareIDs:
			{
				status = STATUS_SUCCESS;

				switch(pIrpStack->Parameters.QueryId.IdType)
				{
				case	BusQueryDeviceID:
						SpxDbgMsg(SPX_TRACE_PNP_IRPS,("%s: Got IRP_MN_QUERY_ID - BusQueryDeviceID Irp for Port %d.\n",
							PRODUCT_NAME,pPort->PortNumber));
						SpxDbgMsg(SPX_MISC_DBG,("%s: Device ID %wZ.\n", PRODUCT_NAME,&pPort->DeviceID));
						pId = &pPort->DeviceID;
						break;

				case	BusQueryInstanceID:
						SpxDbgMsg(SPX_TRACE_PNP_IRPS,("%s: Got IRP_MN_QUERY_ID - BusQueryInstanceID Irp for Port %d.\n",
							PRODUCT_NAME, pPort->PortNumber));
						SpxDbgMsg(SPX_MISC_DBG,("%s: Instance ID %wZ.\n",PRODUCT_NAME,&pPort->InstanceID));
						pId = &pPort->InstanceID;
						break;

				case	BusQueryCompatibleIDs:
						SpxDbgMsg(SPX_TRACE_PNP_IRPS,("%s: Got IRP_MN_QUERY_ID - BusQueryCompatibleIDs Irp for Port %d.\n",
							PRODUCT_NAME, pPort->PortNumber));
						pId = &pPort->CompatibleIDs;
						break;

				case	BusQueryHardwareIDs:
						SpxDbgMsg(SPX_TRACE_PNP_IRPS,("%s: Got IRP_MN_QUERY_ID - BusQueryHardwareIDs Irp for Port %d.\n",
							PRODUCT_NAME, pPort->PortNumber));
						pId = &pPort->HardwareIDs;
						break;
				
				default:
					break;
				}

				if(pId)
				{
					if(pId->Buffer)
					{
						if(ReturnBuffer = SpxAllocateMem(PagedPool, pId->Length + sizeof(WCHAR)))
								RtlCopyMemory(ReturnBuffer, pId->Buffer, pId->Length + sizeof(WCHAR));
						else	
						{
							sprintf(szErrorMsg, "Port %d on card at %08X%08X: Insufficient resources", 
									pPort->PortNumber+1, pCard->PhysAddr.HighPart, pCard->PhysAddr.LowPart);

							Spx_LogMessage(	STATUS_SEVERITY_ERROR,
											pPort->DriverObject,			// Driver Object
											pPort->DeviceObject,			// Device Object (Optional)
											PhysicalZero,					// Physical Address 1
											PhysicalZero,					// Physical Address 2
											0,								// SequenceNumber
											pIrpStack->MajorFunction,		// Major Function Code
											0,								// RetryCount
											FILE_ID | __LINE__,				// UniqueErrorValue
											STATUS_SUCCESS,					// FinalStatus
											szErrorMsg);					// Error Message

							status = STATUS_INSUFFICIENT_RESOURCES;
						}
					}

					pIrp->IoStatus.Information = (ULONG_PTR)ReturnBuffer;
				}
				break;
			}
		
		default:
			break;
		}
		break;

	}

/*****************************************************************************
*************************   IRP_MN_QUERY_DEVICE_TEXT   ***********************
*****************************************************************************/

	case	IRP_MN_QUERY_DEVICE_TEXT:
	{
		PUNICODE_STRING	pText = NULL;
		CHAR szErrorMsg[MAX_ERROR_LOG_INSERT];	// Limited to 51 characters + 1 null 

		SpxDbgMsg(SPX_TRACE_PNP_IRPS,("%s: Got IRP_MN_QUERY_DEVICE_TEXT Irp for Port %d.\n",
				PRODUCT_NAME,pPort->PortNumber));

			if(pIrpStack->Parameters.QueryDeviceText.DeviceTextType == DeviceTextDescription)
				pText = &pPort->DevDesc;

			if(pIrpStack->Parameters.QueryDeviceText.DeviceTextType == DeviceTextLocationInformation)
				pText = &pPort->DevLocation;

			if((pText == NULL)||(pText->Buffer == NULL))
				break;

			if(!(ReturnBuffer = SpxAllocateMem(PagedPool, pText->Length + sizeof(WCHAR))))
			{
				sprintf(szErrorMsg, "Port %d on card at %08X%08X: Insufficient resources", 
						pPort->PortNumber+1, pCard->PhysAddr.HighPart, pCard->PhysAddr.LowPart);

				Spx_LogMessage(	STATUS_SEVERITY_ERROR,
								pPort->DriverObject,			// Driver Object
								pPort->DeviceObject,			// Device Object (Optional)
								PhysicalZero,					// Physical Address 1
								PhysicalZero,					// Physical Address 2
								0,								// SequenceNumber
								pIrpStack->MajorFunction,		// Major Function Code
								0,								// RetryCount
								FILE_ID | __LINE__,				// UniqueErrorValue
								STATUS_SUCCESS,					// FinalStatus
								szErrorMsg);					// Error Message

				status = STATUS_INSUFFICIENT_RESOURCES;
				break;
			}

			status = STATUS_SUCCESS;
			RtlCopyMemory(ReturnBuffer, pText->Buffer, pText->Length + sizeof(WCHAR));
			pIrp->IoStatus.Information = (ULONG_PTR)ReturnBuffer;
			break;
	}

/*****************************************************************************
************************   IRP_MN_QUERY_CAPABILITIES   ***********************
*****************************************************************************/

	case	IRP_MN_QUERY_CAPABILITIES:
	{
			PDEVICE_CAPABILITIES	pDevCaps = NULL;

			SpxDbgMsg(SPX_TRACE_PNP_IRPS,("%s: Got IRP_MN_QUERY_CAPABILITIES Irp for Port %d.\n", 
				PRODUCT_NAME,pPort->PortNumber));
			
			// Get the packet
			pDevCaps = pIrpStack->Parameters.DeviceCapabilities.Capabilities;

			// Set the capabilities.
			pDevCaps->Version = 1;
			pDevCaps->Size = sizeof(DEVICE_CAPABILITIES);

			// We cannot wake the system.
			pDevCaps->SystemWake = PowerSystemUnspecified;
			pDevCaps->DeviceWake = PowerSystemUnspecified;

			// Set device state mapping...

			pDevCaps->DeviceState[PowerSystemWorking] = PowerDeviceD0;
			pDevCaps->DeviceState[PowerSystemSleeping1] = PowerDeviceD3;
			pDevCaps->DeviceState[PowerSystemSleeping2] = PowerDeviceD3;
			pDevCaps->DeviceState[PowerSystemSleeping3] = PowerDeviceD3;
			pDevCaps->DeviceState[PowerSystemHibernate] = PowerDeviceD3;
			pDevCaps->DeviceState[PowerSystemShutdown] = PowerDeviceD3;

			// We have no latencies.
			pDevCaps->D1Latency = 0;
			pDevCaps->D2Latency = 0;
			pDevCaps->D3Latency = 0;

			// No locking or ejection.
			pDevCaps->LockSupported = FALSE;
			pDevCaps->EjectSupported = FALSE;

			// Removable
			pDevCaps->Removable = FALSE;

			// Not a Docking device.
			pDevCaps->DockDevice = FALSE;

			// System wide unique ID.
			pDevCaps->UniqueID = pPort->UniqueInstanceID;

			//UINumber
			pDevCaps->UINumber = pPort->PortNumber+1;

			// Raw capable
			pDevCaps->RawDeviceOK = TRUE;

			// Silent Install
			pDevCaps->SilentInstall = FALSE;

			// Surprise Removal
			pDevCaps->SurpriseRemovalOK = FALSE;

			status = STATUS_SUCCESS;
			break;
	}

/*****************************************************************************
************************   IRP_MN_QUERY_STOP_DEVICE   ************************
*****************************************************************************/

	case	IRP_MN_QUERY_STOP_DEVICE: 
			SpxDbgMsg(SPX_TRACE_PNP_IRPS,("%s: Got IRP_MN_QUERY_STOP_DEVICE Irp for Port %d.\n", 
				PRODUCT_NAME,pPort->PortNumber));

			status = STATUS_UNSUCCESSFUL;

			if(pPort->PnpPowerFlags & PPF_STARTED)
			{
				ExAcquireFastMutex(&pPort->OpenMutex);

				if(pPort->DeviceIsOpen) 
				{
					ExReleaseFastMutex(&pPort->OpenMutex);
					status = STATUS_DEVICE_BUSY;

					SpxDbgMsg(SPX_TRACE_PNP_IRPS, ("%s: ------- failing; Port %d open\n", 
						PRODUCT_NAME, pPort->PortNumber));
				}
				else
				{
					SetPnpPowerFlags(pPort,PPF_STOP_PENDING);
					status = STATUS_SUCCESS;
					ExReleaseFastMutex(&pPort->OpenMutex);
				}
			}
			break;

/*****************************************************************************
************************   IRP_MN_CANCEL_STOP_DEVICE   ***********************
*****************************************************************************/

	case	IRP_MN_CANCEL_STOP_DEVICE:
			SpxDbgMsg(SPX_TRACE_PNP_IRPS, ("%s: Got IRP_MN_CANCEL_STOP_DEVICE Irp for Port %d.\n", 
				PRODUCT_NAME,pPort->PortNumber));

			status = STATUS_SUCCESS;
			ClearPnpPowerFlags(pPort,PPF_STOP_PENDING);	// Clear the stop pending flag 
			Spx_UnstallIrps(pPort);						// Restart any queued IRPs 
			break;

/*****************************************************************************
***************************   IRP_MN_STOP_DEVICE   ***************************
*****************************************************************************/

	case	IRP_MN_STOP_DEVICE: 
			SpxDbgMsg(SPX_TRACE_PNP_IRPS,("%s: Got IRP_MN_STOP_DEVICE Irp for Port %d\n",
				PRODUCT_NAME,pPort->PortNumber));

			status = STATUS_SUCCESS;		// we must never fail this IRP (if we do we will probably unload).
			status = Spx_Port_StopDevice(pPort);
			ClearPnpPowerFlags(pPort,PPF_STOP_PENDING);	// Clear the stop pending flag 
			break;

/*****************************************************************************
***********************   IRP_MN_QUERY_REMOVE_DEVICE   ***********************
*****************************************************************************/

	case	IRP_MN_QUERY_REMOVE_DEVICE: 
			SpxDbgMsg(SPX_TRACE_PNP_IRPS,("%s: Got IRP_MN_QUERY_REMOVE_DEVICE Irp for Port %d.\n", 
				PRODUCT_NAME,pPort->PortNumber));

			ExAcquireFastMutex(&pPort->OpenMutex);

			if(pPort->DeviceIsOpen) 
			{
				ExReleaseFastMutex(&pPort->OpenMutex);
				status = STATUS_DEVICE_BUSY;

				SpxDbgMsg(SPX_TRACE_PNP_IRPS, ("%s: ------- failing; Port %d open\n", 
					PRODUCT_NAME, pPort->PortNumber));
			}
			else
			{
				SetPnpPowerFlags(pPort,PPF_REMOVE_PENDING);	// We are now ready to remove the port
				status = STATUS_SUCCESS;
				ExReleaseFastMutex(&pPort->OpenMutex);
			}

			break; 

/*****************************************************************************
***********************   IRP_MN_CANCEL_REMOVE_DEVICE   **********************
*****************************************************************************/

	case	IRP_MN_CANCEL_REMOVE_DEVICE:
			SpxDbgMsg(SPX_TRACE_PNP_IRPS, ("%s: Got IRP_MN_CANCEL_REMOVE_DEVICE Irp for Port %d.\n", 
				PRODUCT_NAME, pPort->PortNumber));
			
			status = STATUS_SUCCESS;
			ClearPnpPowerFlags(pPort,PPF_REMOVE_PENDING);	// We are no longer expecting to remove the device.
			break; 

/*****************************************************************************
*************************   IRP_MN_SURPRISE_REMOVAL   ************************
*****************************************************************************/

	case	IRP_MN_SURPRISE_REMOVAL:
			SpxDbgMsg(SPX_TRACE_PNP_IRPS,("%s: Got IRP_MN_SURPRISE_REMOVAL Irp for Port %d\n",
				PRODUCT_NAME,pPort->PortNumber));

			status = STATUS_SUCCESS;		// we must never fail this IRP (if we do we will probably unload).
			status = Spx_Port_StopDevice(pPort);
			SetPnpPowerFlags(pPort,PPF_REMOVE_PENDING);	// We are now ready to remove the port
			break;

/*****************************************************************************
**************************   IRP_MN_REMOVE_DEVICE   **************************
*****************************************************************************/

	case	IRP_MN_REMOVE_DEVICE:
			SpxDbgMsg(SPX_TRACE_PNP_IRPS,("%s: Got IRP_MN_REMOVE_DEVICE Irp for Port %d\n",
				PRODUCT_NAME,pPort->PortNumber));

			status = STATUS_SUCCESS;		// we must never fail this IRP (if we do we will probably unload).
			Spx_KillStalledIRPs(pPDO);		// Kill off any waiting IRPS on the stalled list 
			status = Spx_Port_RemoveDevice(pPDO);
			ClearPnpPowerFlags(pPort,PPF_REMOVE_PENDING);	// Clear the pending flag 
			break;

/*****************************************************************************
**********************   IRP_MN_QUERY_DEVICE_RELATIONS   *********************
*****************************************************************************/

	case	IRP_MN_QUERY_DEVICE_RELATIONS:
			SpxDbgMsg(SPX_TRACE_PNP_IRPS,("%s: Got IRP_MN_QUERY_DEVICE_RELATIONS Irp for Port %d.\n", 
				PRODUCT_NAME, pPort->PortNumber));

			switch(pIrpStack->Parameters.QueryDeviceRelations.Type)
			{
			case TargetDeviceRelation:
				{
					PDEVICE_RELATIONS pDevRel = NULL;

					if(pIrp->IoStatus.Information != 0)
						break;

					if(!(pDevRel = SpxAllocateMem(PagedPool, sizeof(DEVICE_RELATIONS))))
					{
						CHAR szErrorMsg[MAX_ERROR_LOG_INSERT];	// Limited to 51 characters + 1 null 

						sprintf(szErrorMsg, "Port %d on card at %08X%08X: Insufficient resources", 
								pPort->PortNumber+1, pCard->PhysAddr.HighPart, pCard->PhysAddr.LowPart);

						Spx_LogMessage(	STATUS_SEVERITY_ERROR,
										pPort->DriverObject,			// Driver Object
										pPort->DeviceObject,			// Device Object (Optional)
										PhysicalZero,					// Physical Address 1
										PhysicalZero,					// Physical Address 2
										0,								// SequenceNumber
										pIrpStack->MajorFunction,		// Major Function Code
										0,								// RetryCount
										FILE_ID | __LINE__,				// UniqueErrorValue
										STATUS_SUCCESS,					// FinalStatus
										szErrorMsg);					// Error Message

						status = STATUS_INSUFFICIENT_RESOURCES;
						break;
					}

					pDevRel->Count = 1;
					pDevRel->Objects[0] = pPDO;
					ObReferenceObject(pPDO);

					status = STATUS_SUCCESS;
					pIrp->IoStatus.Information = (ULONG_PTR)pDevRel;
					break;
				}

			case BusRelations:
				{
					PDEVICE_RELATIONS pDevRel = NULL;

					if(pIrp->IoStatus.Information != 0)
						break;

					if(!(pDevRel = SpxAllocateMem(PagedPool, sizeof(DEVICE_RELATIONS))))
					{
						CHAR szErrorMsg[MAX_ERROR_LOG_INSERT];	// Limited to 51 characters + 1 null 

						sprintf(szErrorMsg, "Port %d on card at %08X%08X: Insufficient resources", 
								pPort->PortNumber+1, pCard->PhysAddr.HighPart, pCard->PhysAddr.LowPart);
						
						Spx_LogMessage(	STATUS_SEVERITY_ERROR,
										pPort->DriverObject,			// Driver Object
										pPort->DeviceObject,			// Device Object (Optional)
										PhysicalZero,					// Physical Address 1
										PhysicalZero,					// Physical Address 2
										0,								// SequenceNumber
										pIrpStack->MajorFunction,		// Major Function Code
										0,								// RetryCount
										FILE_ID | __LINE__,				// UniqueErrorValue
										STATUS_SUCCESS,					// FinalStatus
										szErrorMsg);					// Error Message

						status = STATUS_INSUFFICIENT_RESOURCES;
						break;
					}

					pDevRel->Count = 0;
					status = STATUS_SUCCESS;
					pIrp->IoStatus.Information = (ULONG_PTR)pDevRel;
					break;

				}

			default:
				break;
			}
			break;


	default:
			SpxDbgMsg(SPX_TRACE_PNP_IRPS,("%s: Got PnP Irp - MinorFunction=0x%02X for Port %d.\n", 
				PRODUCT_NAME,pIrpStack->MinorFunction, pPort->PortNumber));
			break;
	}

	pIrp->IoStatus.Status = status;
	IoCompleteRequest(pIrp, IO_NO_INCREMENT);

	return(status);

} /* Spx_Port_PDO_DispatchPnp */

/*****************************************************************************
**************************                          **************************
**************************   Spx_Port_StartDevice   **************************
**************************                          **************************
******************************************************************************

prototype:		NTSTATUS Spx_Port_StartDevice(IN PDEVICE_OBJECT pDevObject)

description:	Start the port device:
					Setup external naming
					Initialise and start the hardware

parameters:		pDevObject point to the card device to start
				pIrp points to the start I/O Request (IRP)

returns:		NT Status Code

*/

NTSTATUS Spx_Port_StartDevice(IN PDEVICE_OBJECT pDevObject)
{

	PPORT_DEVICE_EXTENSION	pPort = pDevObject->DeviceExtension;	
	NTSTATUS				status = STATUS_SUCCESS;

	PAGED_CODE();	// Macro in checked build to assert if pagable code is run at or above dispatch IRQL 

	SpxDbgMsg(SPX_TRACE_CALLS,("%s: Entering Spx_Port_StartDevice for Port %d.\n", PRODUCT_NAME, pPort->PortNumber));

	if(!pPort->CreatedSymbolicLink)
	{
		if(!SPX_SUCCESS(status = Spx_DoExternalNaming(pDevObject)))		// Set up external name for device 
			return(status);
	}

	if(!SPX_SUCCESS(status = XXX_PortStart(pPort)))				// Start hardware. 
	{
		Spx_RemoveExternalNaming(pDevObject);					// Remove external naming.
		return(status);
	}

	SetPnpPowerFlags(pPort,PPF_STARTED);						// Port has been started.
	ClearPnpPowerFlags(pPort,PPF_REMOVED);						// Port is not removed...yet. 
	ClearPnpPowerFlags(pPort,PPF_STOP_PENDING);					// Not pending a stop. 
	ClearPnpPowerFlags(pPort,PPF_REMOVE_PENDING);				// Not pending a remove. 

	return(status);

} // Spx_Port_StartDevice 


/*****************************************************************************
**************************                          **************************
**************************   Spx_GetExternalName   **************************
**************************                          **************************
******************************************************************************

prototype:		NTSTATUS Spx_GetExternalName(IN PDEVICE_OBJECT pDevObject)

description:	Setup external naming for a port:
					get Dos Name for port 
					form symbolic link name

parameters:		pDevObject points to the device object for the port to be named

returns:		NT Status Code

*/
NTSTATUS Spx_GetExternalName(IN PDEVICE_OBJECT pDevObject)
{
	PPORT_DEVICE_EXTENSION	pPort = pDevObject->DeviceExtension;
	PCARD_DEVICE_EXTENSION	pCard = pPort->pParentCardExt;
	NTSTATUS				status = STATUS_SUCCESS;
	HANDLE					PnPKeyHandle;
	UNICODE_STRING			TmpLinkName;
	WCHAR					*pRegName = NULL;
	ULONG					BuffLen = 0;
	CHAR					szErrorMsg[MAX_ERROR_LOG_INSERT];	// Limited to 51 characters + 1 null 
		
	PAGED_CODE();	// Macro in checked build to assert if pagable code is run at or above dispatch IRQL 

	SpxDbgMsg(SPX_TRACE_CALLS,("%s: Entering Spx_GetExternalName for Port %d.\n", PRODUCT_NAME, pPort->PortNumber));

	status = IoOpenDeviceRegistryKey(pDevObject, PLUGPLAY_REGKEY_DEVICE, STANDARD_RIGHTS_READ, &PnPKeyHandle);

	if(!SPX_SUCCESS(status))
		return(status);

// Get the device name allocated by the PNP manager from the registry... 
	if(pRegName = SpxAllocateMem(PagedPool,SYMBOLIC_NAME_LENGTH * sizeof(WCHAR) + sizeof(WCHAR)))
	{
		status = Spx_GetRegistryKeyValue(	PnPKeyHandle,
											L"PortName",
											wcslen(L"PortName") * sizeof(WCHAR),
											pRegName,
											SYMBOLIC_NAME_LENGTH * sizeof(WCHAR));
	}
	else
	{
		status = STATUS_INSUFFICIENT_RESOURCES;
	}

	ZwClose(PnPKeyHandle);

	if(!SPX_SUCCESS(status))
	{
		if(pRegName != NULL) 
			SpxFreeMem(pRegName);

		return(STATUS_SUCCESS);			// Port has not been given a name yet but we must not fail.
	}

	RtlZeroMemory(&TmpLinkName, sizeof(UNICODE_STRING));

	if(!SPX_SUCCESS(status))
		goto NamingError;
	
	TmpLinkName.MaximumLength	= SYMBOLIC_NAME_LENGTH * sizeof(WCHAR);
	TmpLinkName.Buffer			= SpxAllocateMem(PagedPool, TmpLinkName.MaximumLength + sizeof(WCHAR));
	
	if(!TmpLinkName.Buffer)
	{
		sprintf(szErrorMsg, "Port %d on card at %08X%08X Insufficient resources", 
				pPort->PortNumber+1, pCard->PhysAddr.HighPart, pCard->PhysAddr.LowPart);

		Spx_LogMessage(	STATUS_SEVERITY_ERROR,
						pPort->DriverObject,			// Driver Object
						pPort->DeviceObject,			// Device Object (Optional)
						PhysicalZero,					// Physical Address 1
						PhysicalZero,					// Physical Address 2
						0,								// SequenceNumber
						0,								// Major Function Code
						0,								// RetryCount
						FILE_ID | __LINE__,				// UniqueErrorValue
						STATUS_SUCCESS,					// FinalStatus
						szErrorMsg);					// Error Message

		status = STATUS_INSUFFICIENT_RESOURCES;
		goto NamingError;
	}

	RtlZeroMemory(TmpLinkName.Buffer, TmpLinkName.MaximumLength + sizeof(WCHAR));

	// Create the "\\DosDevices\\<SymbolicName>" string.
	RtlAppendUnicodeToString(&TmpLinkName, L"\\");
	RtlAppendUnicodeToString(&TmpLinkName, DEFAULT_DIRECTORY);
	RtlAppendUnicodeToString(&TmpLinkName, L"\\");
	RtlAppendUnicodeToString(&TmpLinkName, pRegName);

	pPort->SymbolicLinkName.Length			= 0;
	pPort->SymbolicLinkName.MaximumLength	= TmpLinkName.Length + sizeof(WCHAR);
	pPort->SymbolicLinkName.Buffer			= SpxAllocateMem(PagedPool, pPort->SymbolicLinkName.MaximumLength);
	
	if(!pPort->SymbolicLinkName.Buffer)
	{
		sprintf(szErrorMsg, "Port %d on card at %08X%08X: Insufficient resources", 
				pPort->PortNumber+1, pCard->PhysAddr.HighPart, pCard->PhysAddr.LowPart);

		Spx_LogMessage(	STATUS_SEVERITY_ERROR,
						pPort->DriverObject,			// Driver Object
						pPort->DeviceObject,			// Device Object (Optional)
						PhysicalZero,					// Physical Address 1
						PhysicalZero,					// Physical Address 2
						0,								// SequenceNumber
						0,								// Major Function Code
						0,								// RetryCount
						FILE_ID | __LINE__,				// UniqueErrorValue
						STATUS_SUCCESS,					// FinalStatus
						szErrorMsg);					// Error Message

		status = STATUS_INSUFFICIENT_RESOURCES;
		goto NamingError;
	}

	RtlZeroMemory(pPort->SymbolicLinkName.Buffer, pPort->SymbolicLinkName.MaximumLength);
	RtlAppendUnicodeStringToString(&pPort->SymbolicLinkName, &TmpLinkName);


	pPort->DosName.Buffer = SpxAllocateMem(PagedPool, 64 + sizeof(WCHAR));

	if(!pPort->DosName.Buffer)
	{
		sprintf(szErrorMsg, "Port %d on card at %08X%08X:: Insufficient resources", 
				pPort->PortNumber+1, pCard->PhysAddr.HighPart, pCard->PhysAddr.LowPart);
		
		Spx_LogMessage(	STATUS_SEVERITY_ERROR,
						pPort->DriverObject,			// Driver Object
						pPort->DeviceObject,			// Device Object (Optional)
						PhysicalZero,					// Physical Address 1
						PhysicalZero,					// Physical Address 2
						0,								// SequenceNumber
						0,								// Major Function Code
						0,								// RetryCount
						FILE_ID | __LINE__,				// UniqueErrorValue
						STATUS_SUCCESS,					// FinalStatus
						szErrorMsg);					// Error Message

		status = STATUS_INSUFFICIENT_RESOURCES;
		goto NamingError;
	}

	pPort->DosName.MaximumLength = 64 + sizeof(WCHAR);

	pPort->DosName.Length = 0;
	RtlZeroMemory(pPort->DosName.Buffer, pPort->DosName.MaximumLength);
	RtlAppendUnicodeToString(&pPort->DosName, pRegName);
	RtlZeroMemory(((PUCHAR) (&pPort->DosName.Buffer[0])) + pPort->DosName.Length, sizeof(WCHAR));

	SpxDbgMsg(SPX_MISC_DBG, ("%s: DeviceName is %wZ\n", PRODUCT_NAME, &pPort->DeviceName));
	SpxDbgMsg(SPX_MISC_DBG, ("%s: DosName is %wZ\n", PRODUCT_NAME, &pPort->DosName));
	SpxDbgMsg(SPX_MISC_DBG, ("%s: SymbolicName is %wZ\n", PRODUCT_NAME, &pPort->SymbolicLinkName));

	if(pRegName != NULL)
		SpxFreeMem(pRegName);	// Free pRegName

	if(TmpLinkName.Buffer != NULL)
		SpxFreeMem(TmpLinkName.Buffer);	// Free TmpLinkName

	return(status);


NamingError:;

	if(TmpLinkName.Buffer != NULL)
		SpxFreeMem(TmpLinkName.Buffer);

	if(pRegName != NULL)
		SpxFreeMem(pRegName);

	return(status);
}

/*****************************************************************************
**************************                          **************************
**************************   Spx_DoExternalNaming   **************************
**************************                          **************************
******************************************************************************

prototype:		NTSTATUS Spx_DoExternalNaming(IN PDEVICE_OBJECT pDevObject)

description:	Setup external naming for a port:
					create symbolic link
					add to registry
					register and enable interface

parameters:		pDevObject points to the device object for the port to be named

returns:		NT Status Code

*/
NTSTATUS Spx_DoExternalNaming(IN PDEVICE_OBJECT pDevObject)
{
	PPORT_DEVICE_EXTENSION	pPort = pDevObject->DeviceExtension;
	PCARD_DEVICE_EXTENSION	pCard = pPort->pParentCardExt;
	NTSTATUS				status = STATUS_SUCCESS;
	CHAR					szErrorMsg[MAX_ERROR_LOG_INSERT];	// Limited to 51 characters + 1 null 
		
	PAGED_CODE();	// Macro in checked build to assert if pagable code is run at or above dispatch IRQL 

	SpxDbgMsg(SPX_TRACE_CALLS,("%s: Entering Spx_DoExternalNaming for Port %d.\n",PRODUCT_NAME,pPort->PortNumber));

// Get external name...
	if( !SPX_SUCCESS(status = Spx_GetExternalName(pDevObject)) || (pPort->DosName.Buffer == NULL))
		return(status);


	status = IoCreateSymbolicLink(&pPort->SymbolicLinkName, &pPort->DeviceName);  // Create the symbolic link... 

	if(!SPX_SUCCESS(status))
	{
		sprintf(szErrorMsg, "Port %d on card at %08X%08X:: Insufficient resources", 
				pPort->PortNumber+1, pCard->PhysAddr.HighPart, pCard->PhysAddr.LowPart);
		
		Spx_LogMessage(	STATUS_SEVERITY_ERROR,
						pPort->DriverObject,			// Driver Object
						pPort->DeviceObject,			// Device Object (Optional)
						PhysicalZero,					// Physical Address 1
						PhysicalZero,					// Physical Address 2
						0,								// SequenceNumber
						0,								// Major Function Code
						0,								// RetryCount
						FILE_ID | __LINE__,				// UniqueErrorValue
						STATUS_SUCCESS,					// FinalStatus
						szErrorMsg);					// Error Message

		goto ExternalNamingError;
	}

// Add mapping to "SERIALCOMM" section of registry... 
	pPort->CreatedSymbolicLink = TRUE;
	
	status = RtlWriteRegistryValue(	RTL_REGISTRY_DEVICEMAP,
									L"SERIALCOMM",
									pPort->DeviceName.Buffer,
									REG_SZ,
									pPort->DosName.Buffer,
									pPort->DosName.Length + sizeof(WCHAR));

	if(!SPX_SUCCESS(status))
	{
		sprintf(szErrorMsg, "Port %d on card at %08X%08X: Registry error.", 
				pPort->PortNumber+1, pCard->PhysAddr.HighPart, pCard->PhysAddr.LowPart);
		
		Spx_LogMessage(	STATUS_SEVERITY_ERROR,
						pPort->DriverObject,			// Driver Object
						pPort->DeviceObject,			// Device Object (Optional)
						PhysicalZero,					// Physical Address 1
						PhysicalZero,					// Physical Address 2
						0,								// SequenceNumber
						0,								// Major Function Code
						0,								// RetryCount
						FILE_ID | __LINE__,				// UniqueErrorValue
						STATUS_SUCCESS,					// FinalStatus
						szErrorMsg);					// Error Message

		goto ExternalNamingError;
	}

	status = IoRegisterDeviceInterface(	pDevObject, (LPGUID)&GUID_CLASS_COMPORT,
										NULL, &pPort->DeviceClassSymbolicName);

	if(!NT_SUCCESS(status)) // Could return good values of STATUS_SUCCESS or STATUS_OBJECT_NAME_EXISTS 
	{
		sprintf(szErrorMsg, "Port %d on card at %08X%08X: Interface error.", 
				pPort->PortNumber+1, pCard->PhysAddr.HighPart, pCard->PhysAddr.LowPart);
		
		Spx_LogMessage(	STATUS_SEVERITY_ERROR,
						pPort->DriverObject,			// Driver Object
						pPort->DeviceObject,			// Device Object (Optional)
						PhysicalZero,					// Physical Address 1
						PhysicalZero,					// Physical Address 2
						0,								// SequenceNumber
						0,								// Major Function Code
						0,								// RetryCount
						FILE_ID | __LINE__,				// UniqueErrorValue
						STATUS_SUCCESS,					// FinalStatus
						szErrorMsg);					// Error Message

		pPort->DeviceClassSymbolicName.Buffer = NULL;
		
		goto ExternalNamingError;
	}

	// Enable the device interface.
	status = IoSetDeviceInterfaceState(&pPort->DeviceClassSymbolicName, TRUE);

	if(!NT_SUCCESS(status)) // Could return good values of STATUS_SUCCESS or STATUS_OBJECT_NAME_EXISTS 
	{
		sprintf(szErrorMsg, "Port %d on card at %08X%08X: Interface error.", 
				pPort->PortNumber+1, pCard->PhysAddr.HighPart, pCard->PhysAddr.LowPart);
		
		Spx_LogMessage(	STATUS_SEVERITY_ERROR,
						pPort->DriverObject,			// Driver Object
						pPort->DeviceObject,			// Device Object (Optional)
						PhysicalZero,					// Physical Address 1
						PhysicalZero,					// Physical Address 2
						0,								// SequenceNumber
						0,								// Major Function Code
						0,								// RetryCount
						FILE_ID | __LINE__,				// UniqueErrorValue
						STATUS_SUCCESS,					// FinalStatus
						szErrorMsg);					// Error Message

		
		goto ExternalNamingError;
	}



	pPort->CreatedSerialCommEntry = TRUE;				// Set flag.

	return(status);


ExternalNamingError:;

	if(!SPX_SUCCESS(status))
		Spx_RemoveExternalNaming(pDevObject);			// Remove and tidy up any allocations 


	return(status);

} // End Spx_DoExternalNaming 

/*****************************************************************************
************************                              ************************
************************   Spx_RemoveExternalNaming   ************************
************************                              ************************
******************************************************************************

prototype:		NTSTATUS Spx_RemoveExternalNaming(IN PDEVICE_OBJECT pDevObject)

description:	Remove external naming:
					remove symbolic link
					remove from registry
					stop interface

parameters:		pDevObject points to the device object for the port to be named.

returns:		NT Status Code

*/
NTSTATUS Spx_RemoveExternalNaming(IN PDEVICE_OBJECT pDevObject)
{
	PPORT_DEVICE_EXTENSION	pPort = pDevObject->DeviceExtension;
	PCARD_DEVICE_EXTENSION	pCard = pPort->pParentCardExt;
	NTSTATUS status = STATUS_UNSUCCESSFUL;

	PAGED_CODE();	// Macro in checked build to assert if pagable code is run at or above dispatch IRQL 

	if(pPort->CreatedSymbolicLink)
	{
		if(pPort->DosName.Buffer)
		{
			SpxFreeMem(pPort->DosName.Buffer);						// Free DOS name buffer. 
			pPort->DosName.Buffer = NULL;
		}

		if(pPort->SymbolicLinkName.Buffer)
		{
			SpxFreeMem(pPort->SymbolicLinkName.Buffer);				// Free symbolic link name buffer. 
			pPort->SymbolicLinkName.Buffer = NULL;
		}

		Spx_GetExternalName(pDevObject);	// Get external name..

		if(pPort->SymbolicLinkName.Buffer)
			status = IoDeleteSymbolicLink(&pPort->SymbolicLinkName);	// Delete Symbolic Link. 

		if(pPort->DeviceClassSymbolicName.Buffer)	// Device Interface name
			IoSetDeviceInterfaceState(&pPort->DeviceClassSymbolicName, FALSE);	// Disable Device Interface.


		pPort->CreatedSymbolicLink = FALSE;												// Reset created flag. 
	}

	if(pPort->DosName.Buffer)
	{
		SpxFreeMem(pPort->DosName.Buffer);					// Free DOS name buffer. 
		pPort->DosName.Buffer = NULL;
	}

	if(pPort->SymbolicLinkName.Buffer)
	{
		SpxFreeMem(pPort->SymbolicLinkName.Buffer);			// Free symbolic link name buffer. 
		pPort->SymbolicLinkName.Buffer = NULL;
	}

	if(pPort->CreatedSerialCommEntry && pPort->DeviceName.Buffer)
	{
		RtlDeleteRegistryValue(	RTL_REGISTRY_DEVICEMAP,		// Delete SERIALCOMM registry entry. 
								SERIAL_DEVICE_MAP,
								pPort->DeviceName.Buffer);

		pPort->CreatedSerialCommEntry = FALSE;				// Reset created flag.
	}

	if(pPort->DeviceClassSymbolicName.Buffer)	// Device Interface name
	{			
		SpxFreeMem(pPort->DeviceClassSymbolicName.Buffer);					// Free Device Interface Name.
		pPort->DeviceClassSymbolicName.Buffer = NULL;
	}

	return(STATUS_SUCCESS);

} // End Spx_RemoveExternalNaming 

/*****************************************************************************
**************************                         ***************************
**************************   Spx_Port_StopDevice   ***************************
**************************                         ***************************
******************************************************************************

prototype:		NTSTATUS Spx_Port_StopDevice(IN PPORT_DEVICE_EXTENSION pPort)

description:	Stop the port device:
					Stop the hardware
					Remove external naming

parameters:		pPort points to the port device extension to be stopped

returns:		NT Status Code

*/

NTSTATUS Spx_Port_StopDevice(IN PPORT_DEVICE_EXTENSION pPort)
{
	NTSTATUS	status	= STATUS_SUCCESS;

	PAGED_CODE();	// Macro in checked build to assert if pagable code is run at or above dispatch IRQL 

	SpxDbgMsg(SPX_TRACE_CALLS,("%s: Entering Spx_Port_StopDevice for Port %d.\n",PRODUCT_NAME,pPort->PortNumber));

	if(pPort->PnpPowerFlags & PPF_STARTED)
		XXX_PortStop(pPort);									// Stop the port hardware. 

	ClearPnpPowerFlags(pPort,PPF_STARTED);						// Indicate card is stopped. 
	ClearPnpPowerFlags(pPort,PPF_STOP_PENDING);					// Clear stop pending flag.

	return(status);

} // End Spx_Port_StopDevice

/*****************************************************************************
*************************                           **************************
*************************   Spx_Port_RemoveDevice   **************************
*************************                           **************************
******************************************************************************

prototype:		NTSTATUS Spx_Port_RemoveDevice(IN PDEVICE_OBJECT pDevObject)

description:	Remove the port device object:
					Remove PDO pointer from card structure
					Deinitialise port hardware
					Delete the device object

parameters:		pDevObject points to the port device object to be stopped

returns:		NT Status Code

*/
NTSTATUS Spx_Port_RemoveDevice(IN PDEVICE_OBJECT pDevObject)
{
	PPORT_DEVICE_EXTENSION	pPort	= pDevObject->DeviceExtension;
	PCARD_DEVICE_EXTENSION	pCard	= pPort->pParentCardExt;
	NTSTATUS				status	= STATUS_SUCCESS;

	PAGED_CODE();	// Macro in checked build to assert if pagable code is run at or above dispatch IRQL 

	SpxDbgMsg(SPX_TRACE_CALLS,("%s: Entering Spx_Port_RemoveDevice for Port %d.\n",PRODUCT_NAME,pPort->PortNumber));

	if(pPort->PnpPowerFlags & PPF_REMOVED)					// Has device been removed already?
		return(STATUS_SUCCESS);

	Spx_Port_StopDevice(pPort);								// Stop the hardware.
	ClearPnpPowerFlags(pPort,PPF_STARTED);					// Mark the PDO as stopped.

	Spx_RemoveExternalNaming(pDevObject);					// Remove external naming. 


// Mark the port device as "removed", but don't delete the PDO until the card device is removed...
	SetPnpPowerFlags(pPort,PPF_REMOVED);					// Mark the PDO as "removed".

	return(status);

} // End Spx_Port_RemoveDevice 




/////////////////////////////////////////////////////////////////////////////////////////////
// Create an Instance ID for the port and try to make it globally unique if possible.
//
NTSTATUS
Spx_CreatePortInstanceID(IN PPORT_DEVICE_EXTENSION pPort)
{
	PCARD_DEVICE_EXTENSION	pCard = pPort->pParentCardExt;
	NTSTATUS				status = STATUS_SUCCESS;
	CHAR					szTemp[100];		// Space to hold string 
	int						szTempPos = 0;
	HANDLE					PnPKeyHandle;
	BOOLEAN					UseBusWideInstanceID = FALSE;  // Try to create system wide unique instance IDs

	PAGED_CODE();	// Macro in checked build to assert if pagable code is run at or above dispatch IRQL 

	SpxDbgMsg(SPX_TRACE_CALLS,("%s: Entering Spx_CreatePortInstanceID for Port %d.\n", PRODUCT_NAME, pPort->PortNumber));

	status = IoOpenDeviceRegistryKey(pCard->PDO, PLUGPLAY_REGKEY_DRIVER, STANDARD_RIGHTS_READ, &PnPKeyHandle);

	if(SPX_SUCCESS(status))
	{
		ULONG Data = 0;

		if(SPX_SUCCESS(Spx_GetRegistryKeyValue(PnPKeyHandle, L"UseBusWideInstanceID", 
							wcslen(L"UseBusWideInstanceID") * sizeof(WCHAR), &Data, sizeof(ULONG))))
		{
			if(Data > 0)
				UseBusWideInstanceID = TRUE;  // Installer has told us to use a bus wide instance ID 
											  // because child devices already exist with that type of ID.
		}
		

		ZwClose(PnPKeyHandle);
	}

	if(UseBusWideInstanceID)
	{
		pPort->UniqueInstanceID = FALSE;	// ID created is not unique system wide.
		status = STATUS_SUCCESS;
	}
	else
	{
		switch(pCard->InterfaceType)
		{
		case Isa:
			// Start Instance ID with ISA address
			szTempPos += sprintf(szTemp,"ISA&%08X%08X&", pCard->PhysAddr.HighPart, pCard->PhysAddr.LowPart);
			pPort->UniqueInstanceID = TRUE;	// ID created is unique system wide.
			status = STATUS_SUCCESS;
			break;

		case PCIBus:
			{
				ULONG PCI_BusNumber = 0;
				ULONG PCI_DeviceFunction = 0;
				ULONG ResultLength;

				// Try to get DevicePropertyBusNumber
				if(!SPX_SUCCESS(status = IoGetDeviceProperty(pCard->PDO, DevicePropertyBusNumber, 
											sizeof(PCI_BusNumber), &PCI_BusNumber, &ResultLength)))
					break;


				// Start Instance ID with PCI bus number
				szTempPos += sprintf(szTemp,"PCI&%04X&", PCI_BusNumber);

				// Try to get DevicePropertyAddress
				if(!SPX_SUCCESS(status = IoGetDeviceProperty(pCard->PDO, DevicePropertyAddress, 
											sizeof(PCI_DeviceFunction),	&PCI_DeviceFunction, &ResultLength)))
					break;
				

				// Add on PCI Device and Function IDs
				szTempPos += sprintf(szTemp + szTempPos,"%08X&", PCI_DeviceFunction);
				pPort->UniqueInstanceID = TRUE;	// ID created is unique system wide.

				status = STATUS_SUCCESS;
				break;
			}
		
		default:
			pPort->UniqueInstanceID = FALSE;	// ID created is not unique system wide.
			status = STATUS_SUCCESS;
			break;

		}

	}

	// Finish off the InstanceID with the port number on the card.
	sprintf(szTemp + szTempPos,"%04X", pPort->PortNumber);

	status = Spx_InitMultiString(FALSE, &pPort->InstanceID, szTemp, NULL);


	return status;
}



// End of SPX_PNP.C
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\spx\speed\driver\utils.c ===
/*++

Copyright (c) 1991, 1992, 1993 Microsoft Corporation

Module Name:

    utils.c

Abstract:

    This module contains code that perform queueing and completion
    manipulation on requests.

Author:

    Anthony V. Ercolano 26-Sep-1991

Environment:

    Kernel mode

Revision History :

--*/

#include "precomp.h"

VOID SerialRundownIrpRefs(IN PIRP *CurrentOpIrp, IN PKTIMER IntervalTimer, IN PKTIMER TotalTimer);
    

#ifdef ALLOC_PRAGMA
#endif


VOID
SerialKillAllReadsOrWrites(IN PDEVICE_OBJECT DeviceObject, 
						   IN PLIST_ENTRY QueueToClean, 
						   IN PIRP *CurrentOpIrp)
/*++

Routine Description:

    This function is used to cancel all queued and the current irps
    for reads or for writes.

Arguments:

    DeviceObject - A pointer to the serial device object.

    QueueToClean - A pointer to the queue which we're going to clean out.

    CurrentOpIrp - Pointer to a pointer to the current irp.

Return Value:

    None.

--*/

{

    KIRQL cancelIrql;
    PDRIVER_CANCEL cancelRoutine;
    PPORT_DEVICE_EXTENSION pPort = DeviceObject->DeviceExtension;

    //
    // We acquire the cancel spin lock.  This will prevent the
    // irps from moving around.
    //

    IoAcquireCancelSpinLock(&cancelIrql);

    //
    // Clean the list from back to front.
    //

    while (!IsListEmpty(QueueToClean)) 
	{
        PIRP currentLastIrp = CONTAINING_RECORD(QueueToClean->Blink, IRP, Tail.Overlay.ListEntry);

		SpxIRPCounter(pPort, currentLastIrp, IRP_DEQUEUED);		// Decrement counter for performance stats.
        RemoveEntryList(QueueToClean->Blink);

        cancelRoutine = currentLastIrp->CancelRoutine;
        currentLastIrp->CancelIrql = cancelIrql;
        currentLastIrp->CancelRoutine = NULL;
        currentLastIrp->Cancel = TRUE;

        cancelRoutine(DeviceObject, currentLastIrp);
            
        IoAcquireCancelSpinLock(&cancelIrql);
    }

    //
    // The queue is clean.  Now go after the current if
    // it's there.
    //

    if(*CurrentOpIrp) 
	{
        cancelRoutine = (*CurrentOpIrp)->CancelRoutine;
        (*CurrentOpIrp)->Cancel = TRUE;

        //
        // If the current irp is not in a cancelable state
        // then it *will* try to enter one and the above
        // assignment will kill it.  If it already is in
        // a cancelable state then the following will kill it.
        //

        if(cancelRoutine) 
		{
            (*CurrentOpIrp)->CancelRoutine = NULL;
            (*CurrentOpIrp)->CancelIrql = cancelIrql;

            //
            // This irp is already in a cancelable state.  We simply
            // mark it as canceled and call the cancel routine for it.
            //
            cancelRoutine(DeviceObject, *CurrentOpIrp);
        } 
		else 
		{
            IoReleaseCancelSpinLock(cancelIrql);
        }

    } 
	else 
	{
        IoReleaseCancelSpinLock(cancelIrql);
    }

}


VOID
SerialGetNextIrp(IN PPORT_DEVICE_EXTENSION pPort,
				 IN PIRP *CurrentOpIrp,
				 IN PLIST_ENTRY QueueToProcess,
				 OUT PIRP *NextIrp,
				 IN BOOLEAN CompleteCurrent)
/*++

Routine Description:

    This function is used to make the head of the particular
    queue the current irp.  It also completes the what
    was the old current irp if desired.

Arguments:

    CurrentOpIrp - Pointer to a pointer to the currently active
                   irp for the particular work list.  Note that
                   this item is not actually part of the list.

    QueueToProcess - The list to pull the new item off of.

    NextIrp - The next Irp to process.  Note that CurrentOpIrp
              will be set to this value under protection of the
              cancel spin lock.  However, if *NextIrp is NULL when
              this routine returns, it is not necessaryly true the
              what is pointed to by CurrentOpIrp will also be NULL.
              The reason for this is that if the queue is empty
              when we hold the cancel spin lock, a new irp may come
              in immediately after we release the lock.

    CompleteCurrent - If TRUE then this routine will complete the
                      irp pointed to by the pointer argument
                      CurrentOpIrp.

Return Value:

    None.

--*/

{

    KIRQL oldIrql;
    PIRP oldIrp;


    IoAcquireCancelSpinLock(&oldIrql);

    oldIrp = *CurrentOpIrp;

    if(oldIrp) 
	{
        if(CompleteCurrent) 
            ASSERT(!oldIrp->CancelRoutine);
    }

    //
    // Check to see if there is a new irp to start up.
    //

    if(!IsListEmpty(QueueToProcess)) 
	{
        PLIST_ENTRY headOfList;

        headOfList = RemoveHeadList(QueueToProcess);

        *CurrentOpIrp = CONTAINING_RECORD(headOfList, IRP, Tail.Overlay.ListEntry);
		SpxIRPCounter(pPort, *CurrentOpIrp, IRP_DEQUEUED);		// Decrement counter for performance stats.

        IoSetCancelRoutine(*CurrentOpIrp, NULL);
    } 
	else 
	{
        *CurrentOpIrp = NULL;
    }

    *NextIrp = *CurrentOpIrp;
    IoReleaseCancelSpinLock(oldIrql);

    if(CompleteCurrent) 
	{
        if(oldIrp) 
		{
            SerialDump(SERIRPPATH, ("Complete Irp: %x\n", oldIrp));
			SpxIRPCounter(pPort, oldIrp, IRP_COMPLETED);	// Increment counter for performance stats.
            IoCompleteRequest(oldIrp, IO_SERIAL_INCREMENT);
        }
    }

}


VOID
SerialTryToCompleteCurrent(IN PPORT_DEVICE_EXTENSION pPort,
						   IN PKSYNCHRONIZE_ROUTINE SynchRoutine OPTIONAL,
						   IN KIRQL IrqlForRelease,
						   IN NTSTATUS StatusToUse,
						   IN PIRP *CurrentOpIrp,
						   IN PLIST_ENTRY QueueToProcess OPTIONAL,
						   IN PKTIMER IntervalTimer OPTIONAL,
						   IN PKTIMER TotalTimer OPTIONAL,
						   IN PSERIAL_START_ROUTINE Starter OPTIONAL,
						   IN PSERIAL_GET_NEXT_ROUTINE GetNextIrp OPTIONAL,
						   IN LONG RefType)

/*++

Routine Description:

    This routine attempts to kill all of the reasons there are
    references on the current read/write.  If everything can be killed
    it will complete this read/write and try to start another.

    NOTE: This routine assumes that it is called with the cancel
          spinlock held.

Arguments:

    Extension - Simply a pointer to the device extension.

    SynchRoutine - A routine that will synchronize with the isr
                   and attempt to remove the knowledge of the
                   current irp from the isr.  NOTE: This pointer
                   can be null.

    IrqlForRelease - This routine is called with the cancel spinlock held.
                     This is the irql that was current when the cancel
                     spinlock was acquired.

    StatusToUse - The irp's status field will be set to this value, if
                  this routine can complete the irp.


Return Value:

    None.

--*/

{

    //
    // We can decrement the reference to "remove" the fact
    // that the caller no longer will be accessing this irp.
    //

	// If RefType was not the ISR reference 
	if(RefType != SERIAL_REF_ISR)
	{
		SERIAL_CLEAR_REFERENCE(*CurrentOpIrp, RefType);		// Clear the reference
	}
	else 
	{
		if(SERIAL_REFERENCE_COUNT(*CurrentOpIrp) & RefType)	// If reference is for ISR and is still set. 
			SERIAL_CLEAR_REFERENCE(*CurrentOpIrp, RefType);		// Clear it.
	}

        
    if(SynchRoutine)
        KeSynchronizeExecution(pPort->Interrupt, SynchRoutine, pPort);


    //
    // Try to run down all other references to this irp.
    //

    SerialRundownIrpRefs(CurrentOpIrp, IntervalTimer, TotalTimer);
        

    //
    // See if the ref count is zero after trying to kill everybody else.
    //
    if(!SERIAL_REFERENCE_COUNT(*CurrentOpIrp)) 
	{
        PIRP newIrp;

        //
        // The ref count was zero so we should complete this request.
        // The following call will also cause the current irp to be completed.
        //
        (*CurrentOpIrp)->IoStatus.Status = StatusToUse;

        if(StatusToUse == STATUS_CANCELLED) 
            (*CurrentOpIrp)->IoStatus.Information = 0;


        if(GetNextIrp) 
		{
            IoReleaseCancelSpinLock(IrqlForRelease);
            
			GetNextIrp(pPort, CurrentOpIrp, QueueToProcess, &newIrp, TRUE);
            
			if(newIrp) 
                Starter(pPort);
        } 
		else 
		{

            PIRP oldIrp = *CurrentOpIrp;

            //
            // There was no get next routine.  We will simply complete
            // the irp.  We should make sure that we null out the
            // pointer to the pointer to this irp.
            //

            *CurrentOpIrp = NULL;

            IoReleaseCancelSpinLock(IrqlForRelease);
            SerialDump(SERIRPPATH, ("Complete Irp: %x\n", oldIrp));
			SpxIRPCounter(pPort, oldIrp, IRP_COMPLETED);	// Increment counter for performance stats.
            IoCompleteRequest(oldIrp, IO_SERIAL_INCREMENT);
        }

    } 
	else 
	{
        IoReleaseCancelSpinLock(IrqlForRelease);
    }

}


VOID
SerialRundownIrpRefs(IN PIRP *CurrentOpIrp,
					 IN PKTIMER IntervalTimer OPTIONAL,
					 IN PKTIMER TotalTimer OPTIONAL)
/*++

Routine Description:

    This routine runs through the various items that *could*
    have a reference to the current read/write.  It try's to kill
    the reason.  If it does succeed in killing the reason it
    will decrement the reference count on the irp.

    NOTE: This routine assumes that it is called with the cancel
          spin lock held.

Arguments:

    CurrentOpIrp - Pointer to a pointer to current irp for the
                   particular operation.

    IntervalTimer - Pointer to the interval timer for the operation.
                    NOTE: This could be null.

    TotalTimer - Pointer to the total timer for the operation.
                 NOTE: This could be null.

Return Value:

    None.

--*/
{

    //
    // This routine is called with the cancel spin lock held
    // so we know only one thread of execution can be in here
    // at one time.
    //

    //
    // First we see if there is still a cancel routine.  If
    // so then we can decrement the count by one.
    //

    if((*CurrentOpIrp)->CancelRoutine) 
	{
        SERIAL_CLEAR_REFERENCE(*CurrentOpIrp, SERIAL_REF_CANCEL);

        IoSetCancelRoutine(*CurrentOpIrp, NULL);
    }

    if(IntervalTimer) 
	{
        //
        // Try to cancel the operations interval timer.  If the operation
        // returns true then the timer did have a reference to the
        // irp.  Since we've canceled this timer that reference is
        // no longer valid and we can decrement the reference count.
        //
        // If the cancel returns false then this means either of two things:
        //
        // a) The timer has already fired.
        //
        // b) There never was an interval timer.
        //
        // In the case of "b" there is no need to decrement the reference
        // count since the "timer" never had a reference to it.
        //
        // In the case of "a", then the timer itself will be coming
        // along and decrement it's reference.  Note that the caller
        // of this routine might actually be the this timer, but it
        // has already decremented the reference.
        //

        if(KeCancelTimer(IntervalTimer)) 
		{
            SERIAL_CLEAR_REFERENCE(*CurrentOpIrp, SERIAL_REF_INT_TIMER);
        }

    }

    if(TotalTimer) 
	{
        //
        // Try to cancel the operations total timer.  If the operation
        // returns true then the timer did have a reference to the
        // irp.  Since we've canceled this timer that reference is
        // no longer valid and we can decrement the reference count.
        //
        // If the cancel returns false then this means either of two things:
        //
        // a) The timer has already fired.
        //
        // b) There never was an total timer.
        //
        // In the case of "b" there is no need to decrement the reference
        // count since the "timer" never had a reference to it.
        //
        // In the case of "a", then the timer itself will be coming
        // along and decrement it's reference.  Note that the caller
        // of this routine might actually be the this timer, but it
        // has already decremented the reference.
        //

        if(KeCancelTimer(TotalTimer)) 
		{
            SERIAL_CLEAR_REFERENCE(*CurrentOpIrp, SERIAL_REF_TOTAL_TIMER);
        }

    }

}


NTSTATUS
SerialStartOrQueue(IN PPORT_DEVICE_EXTENSION pPort,
				   IN PIRP Irp,
				   IN PLIST_ENTRY QueueToExamine,
				   IN PIRP *CurrentOpIrp,
				   IN PSERIAL_START_ROUTINE Starter)
/*++

Routine Description:

    This routine is used to either start or queue any requst
    that can be queued in the driver.

Arguments:

    Extension - Points to the serial device extension.

    Irp - The irp to either queue or start.  In either
          case the irp will be marked pending.

    QueueToExamine - The queue the irp will be place on if there
                     is already an operation in progress.

    CurrentOpIrp - Pointer to a pointer to the irp the is current
                   for the queue.  The pointer pointed to will be
                   set with to Irp if what CurrentOpIrp points to
                   is NULL.

    Starter - The routine to call if the queue is empty.

Return Value:

    This routine will return STATUS_PENDING if the queue is
    not empty.  Otherwise, it will return the status returned
    from the starter routine (or cancel, if the cancel bit is
    on in the irp).


--*/

{

    KIRQL oldIrql;

    IoAcquireCancelSpinLock(&oldIrql);

    //
    // If this is a write irp then take the amount of characters
    // to write and add it to the count of characters to write.
    //

    if(IoGetCurrentIrpStackLocation(Irp)->MajorFunction == IRP_MJ_WRITE)
	{
        pPort->TotalCharsQueued += IoGetCurrentIrpStackLocation(Irp)->Parameters.Write.Length;

    } else if((IoGetCurrentIrpStackLocation(Irp)->MajorFunction == IRP_MJ_DEVICE_CONTROL)
                && ((IoGetCurrentIrpStackLocation(Irp)->Parameters.DeviceIoControl.IoControlCode == IOCTL_SERIAL_IMMEDIATE_CHAR) 
                ||(IoGetCurrentIrpStackLocation(Irp) ->Parameters.DeviceIoControl.IoControlCode == IOCTL_SERIAL_XOFF_COUNTER))) 
	{
        pPort->TotalCharsQueued++;
    }

    if((IsListEmpty(QueueToExamine)) && !(*CurrentOpIrp))
	{
        //
        // There were no current operation.  Mark this one as
        // current and start it up.
        //

        *CurrentOpIrp = Irp;

        IoReleaseCancelSpinLock(oldIrql);

        return Starter(pPort);
    } 
	else 
	{
        //
        // We don't know how long the irp will be in the
        // queue.  So we need to handle cancel.
        //

        if(Irp->Cancel) 
		{
            IoReleaseCancelSpinLock(oldIrql);

            Irp->IoStatus.Status = STATUS_CANCELLED;

            SerialDump(SERIRPPATH, ("Complete Irp: %x\n", Irp));
			SpxIRPCounter(pPort, Irp, IRP_COMPLETED);	// Increment counter for performance stats.
            IoCompleteRequest(Irp,0);
            
			return STATUS_CANCELLED;

        } 
		else 
		{
            Irp->IoStatus.Status = STATUS_PENDING;
            IoMarkIrpPending(Irp);

            InsertTailList(QueueToExamine, &Irp->Tail.Overlay.ListEntry);

            IoSetCancelRoutine(Irp, SerialCancelQueued);
			
			SpxIRPCounter(pPort, Irp, IRP_QUEUED);	// Increment counter for performance stats.

            IoReleaseCancelSpinLock(oldIrql);

            return STATUS_PENDING;
        }

    }

}


VOID
SerialCancelQueued(PDEVICE_OBJECT DeviceObject, PIRP Irp)
/*++

Routine Description:

    This routine is used to cancel Irps that currently reside on
    a queue.

Arguments:

    DeviceObject - Pointer to the device object for this device

    Irp - Pointer to the IRP to be canceled.

Return Value:

    None.

--*/

{

    PPORT_DEVICE_EXTENSION pPort = DeviceObject->DeviceExtension;
    PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation(Irp);

    Irp->IoStatus.Status = STATUS_CANCELLED;
    Irp->IoStatus.Information = 0;

    RemoveEntryList(&Irp->Tail.Overlay.ListEntry);
	SpxIRPCounter(pPort, Irp, IRP_DEQUEUED);	// Decrement counter for performance stats.

    //
    // If this is a write irp then take the amount of characters
    // to write and subtract it from the count of characters to write.
    //

    if(irpSp->MajorFunction == IRP_MJ_WRITE) 
	{
        pPort->TotalCharsQueued -= irpSp->Parameters.Write.Length;
    } 
	else if(irpSp->MajorFunction == IRP_MJ_DEVICE_CONTROL) 
	{
        //
        // If it's an immediate then we need to decrement the
        // count of chars queued.  If it's a resize then we
        // need to deallocate the pool that we're passing on
        // to the "resizing" routine.
        //
        if((irpSp->Parameters.DeviceIoControl.IoControlCode == IOCTL_SERIAL_IMMEDIATE_CHAR)
			|| (irpSp->Parameters.DeviceIoControl.IoControlCode == IOCTL_SERIAL_XOFF_COUNTER))
		{
            pPort->TotalCharsQueued--;
        } 
		else if(irpSp->Parameters.DeviceIoControl.IoControlCode == IOCTL_SERIAL_SET_QUEUE_SIZE) 
		{
            //
            // We shoved the pointer to the memory into the
            // the type 3 buffer pointer which we KNOW we
            // never use.
            //

            ASSERT(irpSp->Parameters.DeviceIoControl.Type3InputBuffer);

            ExFreePool(irpSp->Parameters.DeviceIoControl.Type3InputBuffer);

            irpSp->Parameters.DeviceIoControl.Type3InputBuffer = NULL;

        }

    }

    IoReleaseCancelSpinLock(Irp->CancelIrql);

    SerialDump(SERIRPPATH, ("Complete Irp: %x\n", Irp));
	SpxIRPCounter(pPort, Irp, IRP_COMPLETED);	// Increment counter for performance stats.
    IoCompleteRequest(Irp, IO_SERIAL_INCREMENT);
}



NTSTATUS
SerialCompleteIfError(PDEVICE_OBJECT DeviceObject, PIRP Irp)
/*++

Routine Description:

    If the current irp is not an IOCTL_SERIAL_GET_COMMSTATUS request and
    there is an error and the application requested abort on errors,
    then cancel the irp.

Arguments:

    DeviceObject - Pointer to the device object for this device

    Irp - Pointer to the IRP to test.

Return Value:

    STATUS_SUCCESS or STATUS_CANCELLED.

--*/

{

    PPORT_DEVICE_EXTENSION pPort = DeviceObject->DeviceExtension;

    NTSTATUS status = STATUS_SUCCESS;

    if((pPort->HandFlow.ControlHandShake & SERIAL_ERROR_ABORT) && pPort->ErrorWord)
	{
        PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation(Irp);

        //
        // There is a current error in the driver.  No requests should
        // come through except for the GET_COMMSTATUS.
        //

        if((irpSp->MajorFunction != IRP_MJ_DEVICE_CONTROL) 
			|| (irpSp->Parameters.DeviceIoControl.IoControlCode != IOCTL_SERIAL_GET_COMMSTATUS))
		{
            status = STATUS_CANCELLED;
            Irp->IoStatus.Status = STATUS_CANCELLED;
            Irp->IoStatus.Information = 0;

            SerialDump(SERIRPPATH, ("Complete Irp: %x\n",Irp));
			SpxIRPCounter(pPort, Irp, IRP_COMPLETED);	// Increment counter for performance stats.
            IoCompleteRequest(Irp,0);
        }

    }

    return status;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\spx\speed\driver\incl\spx.h ===
//////////////////////////////////////////////////////////////////////////////////////////
//																						
//	File: SPX.H 
//
//	Contains:	Prototypes of functions to be supplied by a specific  
//				driver to integrate into NT generic PnP code.
//
//	Note:	All generic NT PnP code is prefixed by Spx_.
//			All funcions that are required to integrate into the generic 
//			code are prefixed by XXX_.
//
//
//////////////////////////////////////////////////////////////////////////////////////////
#ifndef SPX_H
#define SPX_H	


// Purpose:		Interpret resources given to card by PnP Manager.
//
// Must:		Store resource details in card extension.
NTSTATUS
XXX_CardGetResources(	
	IN PDEVICE_OBJECT pDevObject, 
	IN PCM_RESOURCE_LIST PResList,
	IN PCM_RESOURCE_LIST PTrResList
	);

// Purpose:		Initialise card.
//				Find out how many ports are attached.
// 
// Must:		Fill in NumberOfPorts field in card extension.
NTSTATUS
XXX_CardInit(IN PCARD_DEVICE_EXTENSION pCard);


// Purpose:		Start up the card.
//
// Must:		Connect up any interrupts.
NTSTATUS
XXX_CardStart(IN PCARD_DEVICE_EXTENSION pCard);

// Purpose:		Stop the card.
//
// Must:		Stop Card from interrupting.
NTSTATUS
XXX_CardStop(IN PCARD_DEVICE_EXTENSION pCard);


// Purpose:		Deinitialise the card.
//
// Must:		Disconnect any interrupts.
NTSTATUS
XXX_CardDeInit(IN PCARD_DEVICE_EXTENSION pCard);

// Purpose:		Initialise the port extension.
//
// Must:		Store DeviceID, HardwareIDs, DevDesc into the port extension.
//					
NTSTATUS
XXX_PortInit(PPORT_DEVICE_EXTENSION pPort);

// Purpose:		Start up the port.
//
// Must:		Get port ready to receive read and write commands.
NTSTATUS
XXX_PortStart(IN PPORT_DEVICE_EXTENSION pPort);


// Purpose:		Stop the port.
//
// Must:		Disconnect any resources and stop DPCs.
//				Do not delete the device object or symbolic link.
NTSTATUS
XXX_PortStop(IN PPORT_DEVICE_EXTENSION pPort);

// Purpose:		Deinitialise the port.
//
// Must:		Delete the device object & symbolic link.
NTSTATUS
XXX_PortDeInit(IN PPORT_DEVICE_EXTENSION pPort);

// Purpose:		Save the state of the card hardware.
//
// Must:		Save enough info to restore the hardware to exactly the 
//				same state when	full power resumes.
NTSTATUS
XXX_CardPowerDown(IN PCARD_DEVICE_EXTENSION pCard);

// Purpose:		Restore the state of the card hardware.
//
// Must:		Restore the hardware when full power resumes.			
NTSTATUS
XXX_CardPowerUp(IN PCARD_DEVICE_EXTENSION pCard);

// Purpose:		Save the state of the port hardware.
//
// Must:		Save enough info to restore the hardware to exactly the 
//				same state when	full power resumes.
NTSTATUS
XXX_PortPowerDown(IN PPORT_DEVICE_EXTENSION pPort);

// Purpose:		Restore the state of the port hardware.
//
// Must:		Restore the hardware when full power resumes.			
NTSTATUS
XXX_PortPowerUp(IN PPORT_DEVICE_EXTENSION pPort);

// Purpose:		Queries whether it is safe for the port to power down.
//
// Must:		Return STATUS_SUCCESS if OK to power down.			
NTSTATUS
XXX_PortQueryPowerDown(IN PPORT_DEVICE_EXTENSION pPort);

// Purpose:		Set hand shaking and flow control on a port.
VOID 
XXX_SetHandFlow(IN PPORT_DEVICE_EXTENSION pPort, IN PSERIAL_IOCTL_SYNC pS);

// Paging 
#ifdef ALLOC_PRAGMA
#pragma alloc_text (PAGE, XXX_CardGetResources)
#pragma alloc_text (PAGE, XXX_CardInit)
#pragma alloc_text (PAGE, XXX_CardDeInit)
#pragma alloc_text (PAGE, XXX_CardStart)
#pragma alloc_text (PAGE, XXX_CardStop)
#pragma alloc_text (PAGE, XXX_PortInit)
#pragma alloc_text (PAGE, XXX_PortDeInit)
#pragma alloc_text (PAGE, XXX_PortStart)
#pragma alloc_text (PAGE, XXX_PortStop)
#endif  


#endif	// End of SPX.H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\spx\speed\driver\inc\serialp.h ===
/*++

Copyright (c) 1990, 1991, 1992, 1993 Microsoft Corporation

Module Name :
	
    serialp.h

Abstract:

    Prototypes and macros that are used throughout the driver.

Author:

    Anthony V. Ercolano                 September 26, 1991

Revision History:
--*/
#if !defined(SERIALP_H)
#define SERIALP_H	

typedef NTSTATUS(*PSERIAL_START_ROUTINE) (IN PPORT_DEVICE_EXTENSION);

typedef VOID(*PSERIAL_GET_NEXT_ROUTINE)(IN PPORT_DEVICE_EXTENSION pPort,
										IN PIRP *CurrentOpIrp,
										IN PLIST_ENTRY QueueToProcess,
										OUT PIRP *NewIrp,
										IN BOOLEAN CompleteCurrent);

NTSTATUS SerialRead(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp);

NTSTATUS SerialStartRead(IN PPORT_DEVICE_EXTENSION pPort);

VOID SerialCompleteRead(IN PKDPC Dpc, 
						IN PVOID DeferredContext, 
						IN PVOID SystemContext1, 
						IN PVOID SystemContext2);

VOID SerialReadTimeout(IN PKDPC Dpc,
					   IN PVOID DeferredContext,
					   IN PVOID SystemContext1,
					   IN PVOID SystemContext2);

VOID SerialIntervalReadTimeout(IN PKDPC Dpc,
							   IN PVOID DeferredContext,
							   IN PVOID SystemContext1,
							   IN PVOID SystemContext2);

NTSTATUS SerialFlush(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp);

NTSTATUS SerialWrite(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp);

NTSTATUS SerialStartWrite(IN PPORT_DEVICE_EXTENSION pPort);

VOID SerialGetNextWrite(IN PPORT_DEVICE_EXTENSION pPort,
						IN PIRP *CurrentOpIrp,
						IN PLIST_ENTRY QueueToProcess,
						IN PIRP *NewIrp,
						IN BOOLEAN CompleteCurrent);

VOID SerialCompleteWrite(IN PKDPC Dpc,
						 IN PVOID DeferredContext,
						 IN PVOID SystemContext1,
						 IN PVOID SystemContext2);

BOOLEAN SerialProcessEmptyTransmit(IN PVOID Context);

VOID SerialWriteTimeout(IN PKDPC Dpc, 
						IN PVOID DeferredContext,
						IN PVOID SystemContext1,
						IN PVOID SystemContext2);

VOID SerialCommError(IN PKDPC Dpc,
					 IN PVOID DeferredContext,
					 IN PVOID SystemContext1,
					 IN PVOID SystemContext2);

NTSTATUS SerialCleanup(IN PDEVICE_OBJECT DeviceObject,
					   IN PIRP Irp);

NTSTATUS SerialCreateOpen(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp);

NTSTATUS SerialClose(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp);

BOOLEAN SerialSetDTR(IN PVOID Context);

BOOLEAN SerialClrDTR(IN PVOID Context);
    
BOOLEAN SerialSetRTS(IN PVOID Context);
    
BOOLEAN SerialClrRTS(IN PVOID Context);

BOOLEAN SerialSetChars(IN PVOID Context);

BOOLEAN SerialSetBaud(IN PVOID Context);
    
BOOLEAN SerialSetLineControl(IN PVOID Context);
    
    

BOOLEAN
SerialSetupNewHandFlow(
    IN PPORT_DEVICE_EXTENSION pPort,
    IN PSERIAL_HANDFLOW NewHandFlow
    );

BOOLEAN SerialSetHandFlow(IN PVOID Context);

BOOLEAN SerialTurnOnBreak(IN PVOID Context);

BOOLEAN SerialTurnOffBreak(IN PVOID Context);

BOOLEAN SerialPretendXoff(IN PVOID Context);

BOOLEAN SerialPretendXon(IN PVOID Context);

    
    

VOID
SerialHandleReducedIntBuffer(
    IN PPORT_DEVICE_EXTENSION pPort
    );

VOID
SerialProdXonXoff(
    IN PPORT_DEVICE_EXTENSION pPort,
    IN BOOLEAN SendXon
    );

NTSTATUS
SerialIoControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
SerialStartMask(
    IN PPORT_DEVICE_EXTENSION pPort
    );

VOID
SerialCancelWait(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

VOID
SerialCompleteWait(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemContext1,
    IN PVOID SystemContext2
    );

VOID
SerialStartImmediate(
    IN PPORT_DEVICE_EXTENSION pPort
    );

VOID
SerialCompleteImmediate(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemContext1,
    IN PVOID SystemContext2
    );

VOID
SerialTimeoutImmediate(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemContext1,
    IN PVOID SystemContext2
    );

VOID
SerialTimeoutXoff(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemContext1,
    IN PVOID SystemContext2
    );

VOID
SerialCompleteXoff(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemContext1,
    IN PVOID SystemContext2
    );

NTSTATUS
SerialStartPurge(
    IN PPORT_DEVICE_EXTENSION pPort
    );

BOOLEAN
SerialPurgeInterruptBuff(
    IN PVOID Context
    );

NTSTATUS
SerialQueryInformationFile(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
SerialSetInformationFile(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

VOID
SerialKillAllReadsOrWrites(
    IN PDEVICE_OBJECT DeviceObject,
    IN PLIST_ENTRY QueueToClean,
    IN PIRP *CurrentOpIrp
    );

VOID
SerialGetNextIrp(
	IN PPORT_DEVICE_EXTENSION pPort,
	IN PIRP *CurrentOpIrp,
	IN PLIST_ENTRY QueueToProcess,
	OUT PIRP *NextIrp,
	IN BOOLEAN CompleteCurrent
	);

VOID
SerialTryToCompleteCurrent(
    IN PPORT_DEVICE_EXTENSION pPort,
    IN PKSYNCHRONIZE_ROUTINE SynchRoutine OPTIONAL,
    IN KIRQL IrqlForRelease,
    IN NTSTATUS StatusToUse,
    IN PIRP *CurrentOpIrp,
    IN PLIST_ENTRY QueueToProcess,
    IN PKTIMER IntervalTimer,
    IN PKTIMER TotalTimer,
    IN PSERIAL_START_ROUTINE Starter,
    IN PSERIAL_GET_NEXT_ROUTINE GetNextIrp,
    IN LONG RefType
    );

NTSTATUS
SerialStartOrQueue(
    IN PPORT_DEVICE_EXTENSION pPort,
    IN PIRP Irp,
    IN PLIST_ENTRY QueueToExamine,
    IN PIRP *CurrentOpIrp,
    IN PSERIAL_START_ROUTINE Starter
    );

VOID
SerialCancelQueued(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp
    );

NTSTATUS
SerialCompleteIfError(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp
    );

ULONG
SerialHandleModemUpdate(
    IN PPORT_DEVICE_EXTENSION pPort,
    IN BOOLEAN DoingTX
    );

BOOLEAN
SerialISR(
    IN PKINTERRUPT InterruptObject,
    IN PVOID Context
    );

BOOLEAN
SerialDispatchISR(
    IN PKINTERRUPT InterruptObject,
    IN PVOID Context
    );

NTSTATUS
SerialGetDivisorFromBaud(
    IN ULONG ClockRate,
    IN LONG DesiredBaud,
    OUT PSHORT AppropriateDivisor
    );


VOID SerialUnload(IN PDRIVER_OBJECT DriverObject);

BOOLEAN SerialReset(IN PVOID Context);

BOOLEAN ApplyInitialPortSettings(IN PVOID Context);


BOOLEAN SerialPerhapsLowerRTS(IN PVOID Context);
    
    

VOID
SerialStartTimerLowerRTS(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemContext1,
    IN PVOID SystemContext2
    );

VOID
SerialInvokePerhapsLowerRTS(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemContext1,
    IN PVOID SystemContext2
    );


VOID SerialCleanupDevice(IN PPORT_DEVICE_EXTENSION pPort);

UCHAR SerialProcessLSR(IN PPORT_DEVICE_EXTENSION pPort);

LARGE_INTEGER SerialGetCharTime(IN PPORT_DEVICE_EXTENSION pPort);
    

BOOLEAN
SerialSharerIsr(
    IN PKINTERRUPT InterruptObject,
    IN PVOID Context
    );

BOOLEAN
SerialMarkClose(
    IN PVOID Context
    );

VOID
SerialPutChar(
    IN PPORT_DEVICE_EXTENSION pPort,
    IN UCHAR CharToPut
    );

VOID SerialGetProperties(
	IN PPORT_DEVICE_EXTENSION pPort, 
	IN PSERIAL_COMMPROP Properties
	);


BOOLEAN SerialGetStats(IN PVOID Context);

BOOLEAN SerialClearStats(IN PVOID Context);
    
    

typedef struct _SERIAL_UPDATE_CHAR 
{
    PPORT_DEVICE_EXTENSION pPort;
    ULONG CharsCopied;
    BOOLEAN Completed;
    
} SERIAL_UPDATE_CHAR,*PSERIAL_UPDATE_CHAR;

//
// The following simple structure is used to send a pointer
// the device extension and an ioctl specific pointer
// to data.
//
typedef struct _SERIAL_IOCTL_SYNC 
{
    PPORT_DEVICE_EXTENSION pPort;
    PVOID Data;

} SERIAL_IOCTL_SYNC,*PSERIAL_IOCTL_SYNC;

//
// The following three macros are used to initialize, set
// and clear references in IRPs that are used by
// this driver.  The reference is stored in the fourth
// argument of the irp, which is never used by any operation
// accepted by this driver.
//

#define SERIAL_REF_ISR				(0x00000001)
#define SERIAL_REF_CANCEL			(0x00000002)
#define SERIAL_REF_TOTAL_TIMER		(0x00000004)
#define SERIAL_REF_INT_TIMER		(0x00000008)
#define SERIAL_REF_XOFF_REF			(0x00000010)
#define SERIAL_REF_COMPLETING		(0x00000020)



#define SERIAL_INIT_REFERENCE(Irp) { \
    ASSERT(sizeof(LONG) <= sizeof(PVOID)); \
    IoGetCurrentIrpStackLocation((Irp))->Parameters.Others.Argument4 = NULL; \
    }

#define SERIAL_SET_REFERENCE(Irp,RefType) \
   do { \
       LONG _refType = (RefType); \
       PLONG _arg4 = (PVOID)&IoGetCurrentIrpStackLocation((Irp))->Parameters.Others.Argument4; \
       ASSERT(!(*_arg4 & _refType)); \
       *_arg4 |= _refType; \
   } while (0)

#define SERIAL_CLEAR_REFERENCE(Irp,RefType) \
   do { \
       LONG _refType = (RefType); \
       PLONG _arg4 = (PVOID)&IoGetCurrentIrpStackLocation((Irp))->Parameters.Others.Argument4; \
       ASSERT(*_arg4 & _refType); \
       *_arg4 &= ~_refType; \
   } while (0)

#define SERIAL_REFERENCE_COUNT(Irp) \
    ((LONG)((IoGetCurrentIrpStackLocation((Irp))->Parameters.Others.Argument4)))


#endif // End SERIALP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\spx\speed\driver\inc\spd_defs.h ===
#if !defined(SPD_DEFS_H)
#define SPD_DEFS_H


// File IDs for Event Logging (top 8 bits only).
#define SPD_PNP_C		((ULONG)0x010000)
#define SPD_W2K_C		((ULONG)0x020000)

#define PRODUCT_MAX_PORTS		20

// Port Types.
#define SPD_8PIN_RJ45			1	// FG, SG, TXD, RXD, RTS, CTS, DTR, DCD, DSR 
#define SPD_10PIN_RJ45			2	// FG, SG, TXD, RXD, RTS, CTS, DTR, DCD, DSR, RI
#define FAST_8PIN_RJ45			3	// FG, SG, TXD, RXD, RTS, CTS, DTR, DCD, DSR 
#define FAST_8PIN_XXXX			4	// FG, SG, TXD, RXD, RTS, CTS, DTR, DCD, DSR 
#define FAST_6PIN_XXXX			5	// FG, SG, TXD, RXD, RTS, CTS
#define MODEM_PORT				6	// Modem Port

// Port device object name.
#define PORT_PDO_NAME_BASE		L"\\Device\\SPEEDPort"

// Tag used for memory allocations (must be 4 bytes in reverse).
#define MEMORY_TAG				'DEPS'


#define OXPCI_IO_OFFSET			    0x0008 // I/O address offset between UARTs
#define OXPCI_INTERNAL_MEM_OFFSET	0x0020 // Memory address offset between internal UARTs
#define OXPCI_LOCAL_MEM_OFFSET		0x0400 // Memory address offset between local bus UARTs

#define SPEED_GIS_REG				0x1C	// Gloabl Interrupt Status Reg (GIS)
#define INTERNAL_UART_INT_PENDING	(ULONG)0x0000000F	// Interanl UART 0, 1, 2 or 3 has an Interrupt Pending
#define UART0_INT_PENDING			(ULONG)0x00000001	// Interanl UART 0 Interrupt Pending
#define UART1_INT_PENDING			(ULONG)0x00000002	// Interanl UART 1 Interrupt Pending
#define UART2_INT_PENDING			(ULONG)0x00000004	// Interanl UART 2 Interrupt Pending
#define UART3_INT_PENDING			(ULONG)0x00000008	// Interanl UART 3 Interrupt Pending

#define FAST_UARTS_0_TO_7_INTS_REG		0x07	// Fast UARTs 0 to 7 Interrupt Status Reg 

#define FAST_UARTS_0_TO_3_INT_PENDING	0x0F	// Fast UART 0, 1, 2 or 3 has an Interrupt Pending
#define FAST_UART0_INT_PENDING			0x01	// Fast UART 0 Interrupt Pending
#define FAST_UART1_INT_PENDING			0x02	// Fast UART 1 Interrupt Pending
#define FAST_UART2_INT_PENDING			0x04	// Fast UART 2 Interrupt Pending
#define FAST_UART3_INT_PENDING			0x08	// Fast UART 3 Interrupt Pending
#define FAST_UART4_INT_PENDING			0x10	// Fast UART 4 Interrupt Pending
#define FAST_UART5_INT_PENDING			0x20	// Fast UART 5 Interrupt Pending
#define FAST_UART6_INT_PENDING			0x40	// Fast UART 6 Interrupt Pending
#define FAST_UART7_INT_PENDING			0x80	// Fast UART 7 Interrupt Pending


#define FAST_UARTS_9_TO_16_INTS_REG		0x0F	// Fast UARTs 8 to 15 Interrupt Status Reg 
#define FAST_UART8_INT_PENDING			0x01	// Fast UART 8 Interrupt Pending
#define FAST_UART9_INT_PENDING			0x02	// Fast UART 9 Interrupt Pending
#define FAST_UART10_INT_PENDING			0x04	// Fast UART 10 Interrupt Pending
#define FAST_UART11_INT_PENDING			0x08	// Fast UART 11 Interrupt Pending
#define FAST_UART12_INT_PENDING			0x10	// Fast UART 12 Interrupt Pending
#define FAST_UART13_INT_PENDING			0x20	// Fast UART 13 Interrupt Pending
#define FAST_UART14_INT_PENDING			0x40	// Fast UART 14 Interrupt Pending
#define FAST_UART15_INT_PENDING			0x80	// Fast UART 15 Interrupt Pending


#define PLX9050_INT_CNTRL_REG_OFFSET	0x4C	// PLX 9050 Interrupt Control Reg Offset in PCI Config Regs.
#define PLX9050_CNTRL_REG_OFFSET		0x50	// PLX 9050 Control Reg Offset in PCI Config Regs.



// Clock frequencies
#define CLOCK_FREQ_1M8432Hz			1843200
#define CLOCK_FREQ_7M3728Hz			7372800
#define CLOCK_FREQ_14M7456Hz		14745600



// SPEED HardwareIDs
// -------------------

// Speed 2 and 4 local bus device (UNUSED)
#define SPD2AND4_PCI_NO_F1_HWID			L"PCI\\VEN_1415&DEV_9510&SUBSYS_000011CB"	// (F1: Unusable).

// SPEED4 Standard Performance PCI Card.
#define SPD4_PCI_PCI954_HWID			L"PCI\\VEN_1415&DEV_9501&SUBSYS_A00411CB"	// (F0: Quad 950 UART).

// SPEED4+ High Performance PCI Card.
#define SPD4P_PCI_PCI954_HWID			L"PCI\\VEN_11CB&DEV_9501&SUBSYS_A00411CB"	// (F0: Quad 950 UART).
#define SPD4P_PCI_8BIT_LOCALBUS_HWID	L"PCI\\VEN_11CB&DEV_9511&SUBSYS_A00011CB"	// (F1: 8 bit local bus).

// SPEED2 Standard Performance PCI Card.
#define SPD2_PCI_PCI954_HWID			L"PCI\\VEN_1415&DEV_9501&SUBSYS_A00211CB"	// (F0: 2 950 UARTs).

// SPEED2+ High Performance PCI Card.
#define SPD2P_PCI_PCI954_HWID			L"PCI\\VEN_11CB&DEV_9501&SUBSYS_A00211CB"	// (F0: 2 950 UARTs).
#define SPD2P_PCI_8BIT_LOCALBUS_HWID	L"PCI\\VEN_11CB&DEV_9511&SUBSYS_A00111CB"	// (F1: 8 bit local bus).


// Chase cards
#define FAST4_PCI_HWID					L"PCI\\VEN_10B5&DEV_9050&SUBSYS_003112E0"	// PCI-Fast 4 Port Adapter
#define FAST8_PCI_HWID					L"PCI\\VEN_10B5&DEV_9050&SUBSYS_002112E0"	// PCI-Fast 8 Port Adapter
#define FAST16_PCI_HWID					L"PCI\\VEN_10B5&DEV_9050&SUBSYS_001112E0"	// PCI-Fast 16 Port Adapter
#define FAST16FMC_PCI_HWID				L"PCI\\VEN_10B5&DEV_9050&SUBSYS_004112E0"	// PCI-Fast 16 FMC Adapter
#define AT_FAST4_HWID					L"AT_FAST4"									// AT-Fast	4 Port Adapter
#define AT_FAST8_HWID					L"AT_FAST8"									// AT-Fast	8 Port Adapter
#define AT_FAST16_HWID					L"AT_FAST16"								// AT-Fast	16 Port Adapter

#define RAS4_PCI_HWID					L"PCI\\VEN_10B5&DEV_9050&SUBSYS_F001124D"	// PCI-RAS 4 Multi-modem Adapter
#define RAS8_PCI_HWID					L"PCI\\VEN_10B5&DEV_9050&SUBSYS_F010124D"	// PCI-RAS 8 Multi-modem Adapter


// SPEED CardTypes
#define Speed4_Pci				1		// Speed 4 adapter
#define Speed2and4_Pci_8BitBus	2		// Speed 2 and 4 unused local bus.
#define Speed4P_Pci				3		// Speed 4+ adapter
#define Speed4P_Pci_8BitBus		4		// Speed 4+ adapter local bus

// Chase Cards
#define Fast4_Pci				5
#define Fast8_Pci				6
#define Fast16_Pci				7
#define Fast16FMC_Pci			8
#define Fast4_Isa				9
#define Fast8_Isa				10
#define Fast16_Isa				11
#define RAS4_Pci				12
#define RAS8_Pci				13

#define Speed2_Pci				14		// Speed 2 adapter
#define Speed2P_Pci				15		// Speed 2+ adapter
#define Speed2P_Pci_8BitBus		16		// Speed 2+ adapter local bus


/*****************************************************************************
*********************************** NT 4.0 PCI IDs ***************************
*****************************************************************************/
// General definitions... 

#define	OX_SEMI_VENDOR_ID		0x1415				// Oxford's VendorID  Assigned by the PCI SIG 
#define	SPX_VENDOR_ID			0x11CB				// Specialix's VendorID Assigned by the PCI SIG 

#define	OX_SEMI_SUB_VENDOR_ID	OX_SEMI_VENDOR_ID	// Same as Oxford's VendorID 
#define	SPX_SUB_VENDOR_ID		SPX_VENDOR_ID		// Same as Specialix's VendorID 

// SPEED4 Low Performance Card.
// ---------------------------------------------------
// PCI Function 0 - (Quad 16C950 UARTs).
// --------------
// VendorID				= OX_SEMI_VENDOR_ID
// DeviceID				= OX_SEMI_PCI954_DEVICE_ID
// SubSystem DeviceID	= SPD4_PCI954_SUB_SYS_ID
// SubSystem VendorID	= SPX_SUB_VENDOR_ID
//
// PCI Function 1 - (Unusable).
// --------------
// VendorID				= OX_SEMI_VENDOR_ID
// DeviceID				= OX_SEMI_NO_F1_DEVICE_ID
// SubSystem DeviceID	= Unknown ??? could be 0x0000 which is bad for MS HCTs
// SubSystem VendorID	= OX_SEMI_SUB_VENDOR_ID
//
#define OX_SEMI_PCI954_DEVICE_ID			0x9501		// OX SEMI PCI954 Bridge and integrated Quad UARTs 
#define	SPD4_PCI954_SUB_SYS_ID				0xA004		// SPX SubSystem DeviceID

#define	SPD2_PCI954_SUB_SYS_ID				0xA002		// SPX SubSystem DeviceID


// SPEED4+ High Performance Card.
// ---------------------------------------------------
// PCI Function 0 - (Quad 16C950 UARTs).
// --------------
// VendorID				= SPX_VENDOR_ID
// DeviceID				= SPD4P_PCI954_DEVICE_ID
// SubSystem DeviceID	= SPD4P_PCI954_SUB_SYS_ID
// SubSystem VendorID	= SPX_SUB_VENDOR_ID
//
// PCI Function 1 - (8 Bit Local Bus with possibly more UARTs).
// -------------- 
// VendorID				= SPX_VENDOR_ID
// DeviceID				= SPD4P_PCI954_8BIT_BUS_DEVICE_ID
// SubSystem DeviceID	= SPD4P_PCI954_8BIT_BUS_SUB_SYS_ID
// SubSystem VendorID	= SPX_SUB_VENDOR_ID
//
#define	SPD4P_PCI954_DEVICE_ID				0x9501		// SPX PCI954 Bridge and integrated Quad UARTs
#define	SPD4P_PCI954_SUB_SYS_ID				0xA004		// SPX PCI954 Bridge and integrated Quad UARTs

#define	SPD4P_8BIT_BUS_DEVICE_ID			0x9511		// 8 Bit Local Bus 
#define	SPD4P_8BIT_BUS_SUB_SYS_ID			0xA000		// 8 Bit Local Bus 


#define	SPD2P_PCI954_DEVICE_ID				0x9501		// SPX PCI954 Bridge and integrated Quad UARTs
#define	SPD2P_PCI954_SUB_SYS_ID				0xA002		// SPX PCI954 Bridge and integrated Quad UARTs

#define	SPD2P_8BIT_BUS_DEVICE_ID			0x9511		// 8 Bit Local Bus 
#define	SPD2P_8BIT_BUS_SUB_SYS_ID			0xA001		// 8 Bit Local Bus 





#define	PLX_VENDOR_ID					0x10B5			// PLX board vendor ID
#define	PLX_DEVICE_ID					0x9050			// PLX board device ID 
	
#define CHASE_SUB_VENDOR_ID				0x12E0			// Chase Research SubVendorID
#define	FAST4_SUB_SYS_ID				0x0031			// PCI-Fast 4 SubSystem DeviceID
#define	FAST8_SUB_SYS_ID				0x0021			// PCI-Fast 8 SubSystem DeviceID
#define	FAST16_SUB_SYS_ID				0x0011			// PCI-Fast 16 SubSystem DeviceID
#define	FAST16FMC_SUB_SYS_ID			0x0041			// PCI-Fast 16 FMC SubSystem DeviceID


#define MORETONBAY_SUB_VENDOR_ID		0x124D			// Moreton Bay SubVendorID
#define	RAS4_SUB_SYS_ID					0xF001			// PCI-Fast 4 SubSystem DeviceID
#define	RAS8_SUB_SYS_ID					0xF010			// PCI-Fast 4 SubSystem DeviceID



// Port Property reg keys.
#define TX_FIFO_LIMIT		L"TxFiFoLimit"
#define TX_FIFO_TRIG_LEVEL	L"TxFiFoTrigger"
#define RX_FIFO_TRIG_LEVEL	L"RxFiFoTrigger"
#define LO_FLOW_CTRL_LEVEL	L"LoFlowCtrlThreshold" 
#define HI_FLOW_CTRL_LEVEL	L"HiFlowCtrlThreshold"





// Card Properties
#define DELAY_INTERRUPT			L"DelayInterrupt"	// Can be used to delay the interrupt by 1.1ms on PCI-Fast16 and PCI-Fast16 FMC cards.
#define SWAP_RTS_FOR_DTR		L"SwapRTSForDTR"	// Can be used to Swap RTS for DTR on the PCI-Fast16 cards.
#define CLOCK_FREQ_OVERRIDE		L"ClockFreqOverride"	// Can be used to set override the card's default clock frequency. 

// Card Options
#define DELAY_INTERRUPT_OPTION		0x00000001		// Settable on PCI-Fast 16 & PCI-Fast 16 FMC (Interrupt delayed 1.1 ms)
#define SWAP_RTS_FOR_DTR_OPTION		0x00000002		// Settable on PCI-Fast 16




#endif	// End of SPD_DEFS.H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\spx\speed\driver\inc\spd_ver.h ===
/*****************************************************************************
*****************************                     ****************************
*****************************   Current Version   ****************************
*****************************                     ****************************
*****************************************************************************/
#if !defined(SPD_VER_H)
#define SPD_VER_H

/* The following definitions are used to define the driver "properties" */

#define	VER_MAJOR		01
#define	VER_MINOR		00
#define	VER_REVISION		04

#define VER_BUILD			0028
#define VER_BUILDSTR		"0029"

#define	VERSION_NUMBER		VER_MAJOR,VER_MINOR,VER_REVISION,VER_BUILD
#define VERSION_MAIN_STR	"1.0.4"
#define VERSION_NUMBER_STR	VERSION_MAIN_STR "." VER_BUILDSTR

#define COMPANY_NAME		"Perle Systems Ltd." 
#define COPYRIGHT_YEARS		"2002 "
#define COPYRIGHT_SYMBOL	" "

#define PRODUCT_NAME		"SPEED"

#define SOFTWARE_NAME		" Serial Device Driver"
#define DRIVER_FILENAME 	"SPEED.SYS"


#endif	// End of SPD_VER.H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\spx\speed\driver\inc\speedwmi.h ===
#ifndef _speedwmi_h_
#define _speedwmi_h_

// SpeedPortFifoProp - SPX_SPEED_WMI_FIFO_PROP
// Specialix Speed Port FIFO Properties
#define SPX_SPEED_WMI_FIFO_PROP_GUID \
    { 0xd81fe0a1,0x2cac,0x11d4, { 0x8d,0x09,0x00,0x08,0xc7,0xd0,0x30,0x66 } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(SpeedPortFifoProp_GUID, \
            0xd81fe0a1,0x2cac,0x11d4,0x8d,0x09,0x00,0x08,0xc7,0xd0,0x30,0x66);
#endif


typedef struct _SPX_SPEED_WMI_FIFO_PROP
{
    // Max Tx FIFO Size
    ULONG MaxTxFiFoSize;
    #define SPX_SPEED_WMI_FIFO_PROP_MaxTxFiFoSize_SIZE sizeof(ULONG)
    #define SPX_SPEED_WMI_FIFO_PROP_MaxTxFiFoSize_ID 1

    // Max Rx FIFO Size
    ULONG MaxRxFiFoSize;
    #define SPX_SPEED_WMI_FIFO_PROP_MaxRxFiFoSize_SIZE sizeof(ULONG)
    #define SPX_SPEED_WMI_FIFO_PROP_MaxRxFiFoSize_ID 2

    // Default Tx FIFO Limit
    ULONG DefaultTxFiFoLimit;
    #define SPX_SPEED_WMI_FIFO_PROP_DefaultTxFiFoLimit_SIZE sizeof(ULONG)
    #define SPX_SPEED_WMI_FIFO_PROP_DefaultTxFiFoLimit_ID 3

    // Tx FIFO Limit
    ULONG TxFiFoLimit;
    #define SPX_SPEED_WMI_FIFO_PROP_TxFiFoLimit_SIZE sizeof(ULONG)
    #define SPX_SPEED_WMI_FIFO_PROP_TxFiFoLimit_ID 4

    // Default Tx FIFO Trigger
    ULONG DefaultTxFiFoTrigger;
    #define SPX_SPEED_WMI_FIFO_PROP_DefaultTxFiFoTrigger_SIZE sizeof(ULONG)
    #define SPX_SPEED_WMI_FIFO_PROP_DefaultTxFiFoTrigger_ID 5

    // Tx FIFO Trigger
    ULONG TxFiFoTrigger;
    #define SPX_SPEED_WMI_FIFO_PROP_TxFiFoTrigger_SIZE sizeof(ULONG)
    #define SPX_SPEED_WMI_FIFO_PROP_TxFiFoTrigger_ID 6

    // Default Rx FIFO Trigger
    ULONG DefaultRxFiFoTrigger;
    #define SPX_SPEED_WMI_FIFO_PROP_DefaultRxFiFoTrigger_SIZE sizeof(ULONG)
    #define SPX_SPEED_WMI_FIFO_PROP_DefaultRxFiFoTrigger_ID 7

    // Rx FIFO Trigger
    ULONG RxFiFoTrigger;
    #define SPX_SPEED_WMI_FIFO_PROP_RxFiFoTrigger_SIZE sizeof(ULONG)
    #define SPX_SPEED_WMI_FIFO_PROP_RxFiFoTrigger_ID 8

    // Default Low Flow Control Threshold
    ULONG DefaultLoFlowCtrlThreshold;
    #define SPX_SPEED_WMI_FIFO_PROP_DefaultLoFlowCtrlThreshold_SIZE sizeof(ULONG)
    #define SPX_SPEED_WMI_FIFO_PROP_DefaultLoFlowCtrlThreshold_ID 9

    // Low Flow Control Threshold
    ULONG LoFlowCtrlThreshold;
    #define SPX_SPEED_WMI_FIFO_PROP_LoFlowCtrlThreshold_SIZE sizeof(ULONG)
    #define SPX_SPEED_WMI_FIFO_PROP_LoFlowCtrlThreshold_ID 10

    // Default High Flow Control Threshold
    ULONG DefaultHiFlowCtrlThreshold;
    #define SPX_SPEED_WMI_FIFO_PROP_DefaultHiFlowCtrlThreshold_SIZE sizeof(ULONG)
    #define SPX_SPEED_WMI_FIFO_PROP_DefaultHiFlowCtrlThreshold_ID 11

    // High Flow Control Threshold
    ULONG HiFlowCtrlThreshold;
    #define SPX_SPEED_WMI_FIFO_PROP_HiFlowCtrlThreshold_SIZE sizeof(ULONG)
    #define SPX_SPEED_WMI_FIFO_PROP_HiFlowCtrlThreshold_ID 12

} SPX_SPEED_WMI_FIFO_PROP, *PSPX_SPEED_WMI_FIFO_PROP;

#define SPX_SPEED_WMI_FIFO_PROP_SIZE (FIELD_OFFSET(SPX_SPEED_WMI_FIFO_PROP, HiFlowCtrlThreshold) + SPX_SPEED_WMI_FIFO_PROP_HiFlowCtrlThreshold_SIZE)

// FastCardProp - SPX_SPEED_WMI_FAST_CARD_PROP
// Specialix Fast Card Properties
#define SPX_SPEED_WMI_FAST_CARD_PROP_GUID \
    { 0xb2df36f1,0x570b,0x11d4, { 0x8d,0x11,0x00,0x08,0xc7,0xd0,0x30,0x66 } }

#if ! (defined(MIDL_PASS))
DEFINE_GUID(FastCardProp_GUID, \
            0xb2df36f1,0x570b,0x11d4,0x8d,0x11,0x00,0x08,0xc7,0xd0,0x30,0x66);
#endif


typedef struct _SPX_SPEED_WMI_FAST_CARD_PROP
{
    // Delay Card Interrupt
    BOOLEAN DelayCardIntrrupt;
    #define SPX_SPEED_WMI_FAST_CARD_PROP_DelayCardIntrrupt_SIZE sizeof(BOOLEAN)
    #define SPX_SPEED_WMI_FAST_CARD_PROP_DelayCardIntrrupt_ID 1

    // Swap RTS For DTR
    BOOLEAN SwapRTSForDTR;
    #define SPX_SPEED_WMI_FAST_CARD_PROP_SwapRTSForDTR_SIZE sizeof(BOOLEAN)
    #define SPX_SPEED_WMI_FAST_CARD_PROP_SwapRTSForDTR_ID 2

} SPX_SPEED_WMI_FAST_CARD_PROP, *PSPX_SPEED_WMI_FAST_CARD_PROP;

#define SPX_SPEED_WMI_FAST_CARD_PROP_SIZE (FIELD_OFFSET(SPX_SPEED_WMI_FAST_CARD_PROP, SwapRTSForDTR) + SPX_SPEED_WMI_FAST_CARD_PROP_SwapRTSForDTR_SIZE)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\spx\speed\driver\incl\spx_defs.h ===
/****************************************************************************************
*																						*
*	Header:		SPX_DEFS.H 																*
*																						*
*	Creation:	15th October 1998														*
*																						*
*	Author:		Paul Smith																*
*																						*
*	Version:	1.0.0																	*
*																						*
*	Contains:	Definitions for all the common PnP and power code.						*
*																						*
****************************************************************************************/

#if	!defined(SPX_DEFS_H)
#define SPX_DEFS_H	

static const PHYSICAL_ADDRESS PhysicalZero = {0};

#define DEVICE_OBJECT_NAME_LENGTH       128
#define SYMBOLIC_NAME_LENGTH            128

#define SERIAL_DEVICE_MAP               L"SERIALCOMM"


// This define gives the default Object directory
// that we should use to insert the symbolic links
// between the NT device name and namespace used by
// that object directory.
#define DEFAULT_DIRECTORY		L"DosDevices"

#define MAX_ERROR_LOG_INSERT	52


// File IDs for Event Logging (top 8 bits only).
#define SPX_INIT_C		((ULONG)0x01000000)
#define SPX_PNP_C		((ULONG)0x02000000)
#define SPX_POWR_C		((ULONG)0x03000000)
#define SPX_DISP_C		((ULONG)0x04000000)
#define SPX_UTILS_C		((ULONG)0x05000000)
#define SPX_IIOC_C		((ULONG)0x06000000)




// COMMON_OBJECT_DATA.PnpPowerFlags definitions... 
#define	PPF_STARTED			0x00000001		// Device has been started 
#define	PPF_STOP_PENDING	0x00000002		// Device stop is pending 
#define	PPF_REMOVE_PENDING	0x00000004		// Device remove is pending 
#define	PPF_REMOVED			0x00000008		// Device has been removed 
#define	PPF_POWERED			0x00000010		// Device has been powered up 
			
typedef enum _SPX_MEM_COMPARES 
{
	AddressesAreEqual,
	AddressesOverlap,
	AddressesAreDisjoint

}SPX_MEM_COMPARES, *PSPX_MEM_COMPARES;

// IRP Counters
#define IRP_SUBMITTED		0x00000001	
#define IRP_COMPLETED		0x00000002
#define IRP_QUEUED			0x00000003
#define IRP_DEQUEUED		0x00000004


extern UNICODE_STRING SavedRegistryPath;	// Driver Registry Path.


#endif	// End of SPX_DEFS.H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\spx\speed\driver\inc\spd_proto.h ===
//////////////////////////////////////////////////////////////////
// Prototypes and macros that are used throughout the driver. 
//////////////////////////////////////////////////////////////////
#if !defined(SPD_PROTO_H)
#define SPD_PROTO_H


VOID DriverUnload(IN PDRIVER_OBJECT pDriverObject);
NTSTATUS GetPortSettings(PDEVICE_OBJECT pDevObject);
BOOLEAN SetPortFiFoSettings(PPORT_DEVICE_EXTENSION pPort);
NTSTATUS GetCardSettings(PDEVICE_OBJECT pDevObject);


#ifdef WMI_SUPPORT
NTSTATUS SpeedCard_WmiInitializeWmilibContext(IN PWMILIB_CONTEXT WmilibContext);
NTSTATUS SpeedPort_WmiInitializeWmilibContext(IN PWMILIB_CONTEXT WmilibContext);
#endif

BOOLEAN SerialResetAndVerifyUart(PDEVICE_OBJECT pDevObj);
BOOLEAN SetCardToDelayInterrupt(PCARD_DEVICE_EXTENSION pCard);
BOOLEAN SetCardNotToDelayInterrupt(PCARD_DEVICE_EXTENSION pCard);
BOOLEAN SetCardNotToUseDTRInsteadOfRTS(PCARD_DEVICE_EXTENSION pCard);
BOOLEAN SetCardToUseDTRInsteadOfRTS(PCARD_DEVICE_EXTENSION pCard);

#endif	// End of SPD_PROTO.H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\spx\speed\driver\inc\spd_card.h ===
#if !defined(SPD_CARD_H)
#define SPD_CARD_H	




#if DBG
#define SERDIAG1              ((ULONG)0x00000001)
#define SERDIAG2              ((ULONG)0x00000002)
#define SERDIAG3              ((ULONG)0x00000004)
#define SERDIAG4              ((ULONG)0x00000008)
#define SERDIAG5              ((ULONG)0x00000010)
#define SERIRPPATH            ((ULONG)0x00000020)
#define SERWARNING            ((ULONG)0x00000100)
#define SERINFO               ((ULONG)0x00000200)

#define SERFLOW               ((ULONG)0x00000400)
#define SERERRORS             ((ULONG)0x00000800)
#define SERBUGCHECK           ((ULONG)0x00001000)

// -- OXSER Diag 3 --
// Additional debug levels
#define PCIINFO               ((ULONG)0x00002000)
#define XTLINFO               ((ULONG)0x00004000)
#define ISRINFO				  ((ULONG)0x00008000)
#define TXINFO				  ((ULONG)0x00010000)
#define RXINFO				  ((ULONG)0x00020000)
#define LSINFO				  ((ULONG)0x00040000)
#define MSINFO				  ((ULONG)0x00080000)
#define KICKINFO			  ((ULONG)0x00100000)
#define FIFOINFO			  ((ULONG)0x00200000)
#define CLOSE_STATS			  ((ULONG)0x00400000)
#define BAUDINFO			  ((ULONG)0x00800000)	

extern ULONG SpxDebugLevel;

#define SerialDump(LEVEL,STRING)											\
    do {																	\
        ULONG _level = (LEVEL);												\
		if (SpxDebugLevel & _level) {										\
            DbgPrint STRING;												\
        }																	\
        if (_level == SERBUGCHECK) {										\
            ASSERT(FALSE);													\
        }																	\
    } while (0)
#else
#define SerialDump(LEVEL,STRING) do {NOTHING;} while (0)
#endif





// For the above directory, the serial port will
// use the following name as the suffix of the serial
// ports for that directory.  It will also append
// a number onto the end of the name.  That number
// will start at 1.
#define DEFAULT_SERIAL_NAME L"COM"


// This define gives the default NT name for
// for serial ports detected by the firmware.
// This name will be appended to Device prefix
// with a number following it.  The number is
// incremented each time encounter a serial
// port detected by the firmware.  Note that
// on a system with multiple busses, this means
// that the first port on a bus is not necessarily
// \Device\Serial0.
//
#define DEFAULT_NT_SUFFIX L"Serial"



// Default xon/xoff characters.
#define SERIAL_DEF_XON		0x11
#define SERIAL_DEF_XOFF		0x13

// Reasons that recption may be held up.
#define SERIAL_RX_DTR       ((ULONG)0x01)
#define SERIAL_RX_XOFF      ((ULONG)0x02)
#define SERIAL_RX_RTS       ((ULONG)0x04)
#define SERIAL_RX_DSR       ((ULONG)0x08)

// Reasons that transmission may be held up.
#define SERIAL_TX_CTS       ((ULONG)0x01)
#define SERIAL_TX_DSR       ((ULONG)0x02)
#define SERIAL_TX_DCD       ((ULONG)0x04)
#define SERIAL_TX_XOFF      ((ULONG)0x08)
#define SERIAL_TX_BREAK     ((ULONG)0x10)


//////////////////////////////////////////////////////////////////////////////////////////
// SPEED Port Device Extenstion.
// Information specific to SPEED Ports.
//////////////////////////////////////////////////////////////////////////////////////////
typedef struct _PORT_DEVICE_EXTENSION 
{

	COMMON_PORT_DEVICE_EXTENSION;		// Common Card Device Extension 

	ULONG			SysPortNumber;		// System port number 

	// Timing variables... 
    LARGE_INTEGER		IntervalTime;			// Read interval time 
	LARGE_INTEGER		ShortIntervalAmount;	// Short tread interval time 
	LARGE_INTEGER		LongIntervalAmount;		// Long read interval time 
	LARGE_INTEGER		CutOverAmount;			// Used to determine short/long interval time 
	LARGE_INTEGER		LastReadTime;			// System time of last read 
	PLARGE_INTEGER		IntervalTimeToUse;		// Interval timing delta time delay 
	
	// Queued IRP lists... 
	LIST_ENTRY		ReadQueue;		// Head of read IRP list, protected by cancel spinlock 
	LIST_ENTRY		WriteQueue;		// Head of write IRP list, protected by cancel spinlock 
	LIST_ENTRY		MaskQueue;		// Head of set/wait mask IRP list, protected by cancel spinlock 
	LIST_ENTRY		PurgeQueue;		// Head of purge IRP list, protected by cancel spinlock 

	// Current IRPs... 
	PIRP			CurrentReadIrp;			// Pointer to current read IRP 
	PIRP			CurrentWriteIrp;		// Pointer to current write IRP 
	PIRP			CurrentMaskIrp;			// Pointer to current mask IRP 
	PIRP			CurrentPurgeIrp;		// Pointer to current purge IRP 
	PIRP			CurrentWaitIrp;			// Pointer to current wait IRP 
	PIRP			CurrentImmediateIrp;	// Pointer to current send immediate IRP 
	PIRP			CurrentXoffIrp;			// Pointer to current XOFF_COUNTER IRP 

	// Write IRP variables... 
	ULONG			WriteLength;			// Write character count in current write IRP 
	PUCHAR			WriteCurrentChar;		// Pointer to write character in current write IRP 

	// Read IRP variables... 
	PUCHAR			InterruptReadBuffer;	// Read buffer current pointer in current read IRP 
	PUCHAR			ReadBufferBase;			// Read buffer base pointer in current read IRP 
	ULONG			CharsInInterruptBuffer;	// Characters read into read buffer 
//	KSPIN_LOCK		BufferLock;				// Spinlock protecting "CharsInInterruptBuffer" 
	PUCHAR			CurrentCharSlot;		// Pointer at space to store new read data 
	PUCHAR			LastCharSlot;			// Last valid position in read buffer 
	PUCHAR			FirstReadableChar;		// First read character in read buffer 
	ULONG			BufferSize;				// Read buffer size 
	ULONG			BufferSizePt8;			// 80% read buffer size 
	ULONG			NumberNeededForRead;	// Number of characters requested in current read IRP 

	// Mask IRP variables... 
	ULONG			IsrWaitMask;			// Wait mask in current wait IRP 
	ULONG			HistoryMask;			// History of masked events 
	ULONG			*IrpMaskLocation;		// Pointer to mask location 

	// Serial port configuration...
//	ULONG				CurrentBaud;		// Current baud rate 
	ULONG				SupportedBauds;		// Bitmask defining supported baud rates 
	SERIAL_HANDFLOW		HandFlow;			// Current handshaking and flow control settings 
	UCHAR				LineControl;		// Current parity,databits,stopbits 
	SERIAL_CHARS		SpecialChars;		// Current Special error/replacement characters 
	SERIAL_TIMEOUTS		Timeouts;			// Read and write timeouts 
	UCHAR				ValidDataMask;		// Read data mask 
	UCHAR				EscapeChar;			// Escape character used with line/modem status strings 
//	BOOLEAN				InsertEscChar;		// Indicates of EscapeChar should be inserted 

	// Serial port status... 
	LONG			CountSinceXoff;			// Nun chars read since XOFF counter started 
	ULONG			CountOfTryingToLowerRTS;// Count of processes trying to lower RTS 
	BOOLEAN			TransmitImmediate;		// Indicates of transmit immediate is pending 
	BOOLEAN			EmptiedTransmit;		// Indicates transmit empty 
	UCHAR			ImmediateChar;			// Character to be transmitted immediately 
	ULONG			TXHolding;				// Reasons for transmit blocked 
	ULONG			RXHolding;				// Reasons for receive blocked 
	ULONG			ErrorWord;				// Error conditions 
	ULONG			TotalCharsQueued;		// Total number of queued characters in all write IRPs 
	LONG			CountOnLastRead;		// Number of chars read last time interval timer DPC ran 
	ULONG			ReadByIsr;				// Number of characters read during ISR 

	KSPIN_LOCK		ControlLock;			// Used to protect certain fields 

	// Deferred procedure calls... 
	KDPC		CompleteWriteDpc;			// DPC used to complete write IRPs 
	KDPC		CompleteReadDpc;			// DPC used to complete read IRPs 
	KDPC		TotalReadTimeoutDpc;		// DPC used to handle read total timeout 
	KDPC		IntervalReadTimeoutDpc;		// DPC used to handle read interval timeout 
	KDPC		TotalWriteTimeoutDpc;		// DPC used to handle write total timeout 
	KDPC		CommErrorDpc;				// DPC used to handle cancel on error 
	KDPC		CommWaitDpc;				// DPC used to handle waking IRPs waiting on an event 
	KDPC		CompleteImmediateDpc;		// DPC used to handle transmitting an immediate character 
	KDPC		TotalImmediateTimeoutDpc;	// DPC used to handle immediate char timeout 
	KDPC		XoffCountTimeoutDpc;		// DPC used to handle XOFF_COUNT timeout 
	KDPC		XoffCountCompleteDpc;		// DPC used to complete XOFF_COUNT IRP 
	KDPC		StartTimerLowerRTSDpc;		// DPC used to check for RTS lowering 
	KDPC		PerhapsLowerRTSDpc;			// DPC used to check for RTS lowering 

	// Timers... 
	KTIMER		ReadRequestTotalTimer;		// Timer used to handle total read request timeout 
	KTIMER		ReadRequestIntervalTimer;	// Timer used to handle interval read timeout 
	KTIMER		WriteRequestTotalTimer;		// Timer used to handle total write request timeout 
	KTIMER		ImmediateTotalTimer;		// Timer used to handle send immediate timeout 
	KTIMER		XoffCountTimer;				// Timer used to handle XOFF_COUNT timeout 
	KTIMER		LowerRTSTimer;				// Timer used to handle lower RTS timing 



	PUART_LIB		pUartLib;	// Uart library finctions.
	PUART_OBJECT	pUart;
	UART_CONFIG		UartConfig;
	BOOLEAN			DTR_Set;
	BOOLEAN			RTS_Set;
	SET_BUFFER_SIZES BufferSizes;

	DWORD			MaxTxFIFOSize;		// Max Tx FIFO Size.
	DWORD			MaxRxFIFOSize;		// Max Rx FIFO Size.

	DWORD			TxFIFOSize;			// Tx FIFO Size.
	DWORD			RxFIFOSize;			// Rx FIFO Size.
	DWORD			TxFIFOTrigLevel;	// Tx FIFO Trigger Level.
	DWORD			RxFIFOTrigLevel;	// Rx FIFO Trigger Level.
	DWORD			HiFlowCtrlThreshold;	// High Flow Control Threshold.
	DWORD			LoFlowCtrlThreshold;	// Low Flow Control Threshold.

	#ifdef WMI_SUPPORT
	SPX_SPEED_WMI_FIFO_PROP		SpeedWmiFifoProp;
	#endif

	BYTE			ImmediateIndex;

    // This holds the isr that should be called from our own
    // dispatching isr for "cards" that are trying to share the
    // same interrupt.

    PKSERVICE_ROUTINE TopLevelOurIsr;

    // This holds the context that should be used when we
    // call the above service routine.
    
	PVOID TopLevelOurIsrContext;

    // This links together all of the different "cards" that are
    // trying to share the same interrupt of a non-mca machine.
    
    LIST_ENTRY TopLevelSharers;

    // This circular doubly linked list links together all
    // devices that are using the same interrupt object.
    // NOTE: This does not mean that they are using the
    // same interrupt "dispatching" routine.
    
    LIST_ENTRY CommonInterruptObject;

    // For reporting resource usage, we keep around the physical
    // address we got from the registry.
    
	PHYSICAL_ADDRESS OriginalController;

    // For reporting resource usage, we keep around the physical
    // address we got from the registry.
    
    PHYSICAL_ADDRESS OriginalInterruptStatus;




    // This points to the object directory that we will place
    // a symbolic link to our device name.
    
    UNICODE_STRING ObjectDirectory;
    
    // This points to the device name for this device
    // sans device prefix.
    
    UNICODE_STRING NtNameForPort;

    // After initialization of the driver is complete, this
    // will either be NULL or point to the routine that the
    // kernel will call when an interrupt occurs.
    
    // If the pointer is null then this is part of a list
    // of ports that are sharing an interrupt and this isn't
    // the first port that we configured for this interrupt.
    
    // If the pointer is non-null then this routine has some
    // kind of structure that will "eventually" get us into
    // the real serial isr with a pointer to this device extension.
    
    // NOTE: On an MCA bus (except for multiport cards) this
    // is always a pointer to the "real" serial isr.
    
	PKSERVICE_ROUTINE OurIsr;

    // This will generally point right to this device extension.
    //
    // However, when the port that this device extension is
    // "managing" was the first port initialized on a chain
    // of ports that were trying to share an interrupt, this
    // will point to a structure that will enable dispatching
    // to any port on the chain of sharers of this interrupt.
    
    PVOID OurIsrContext;

    // The base address for the set of device registers
    // of the serial port.
    
    PUCHAR Controller;

    // The base address for interrupt status register.
    // This is only defined in the root extension.
    
    PUCHAR InterruptStatus;

    // Points to the interrupt object for used by this device.
    
    PKINTERRUPT Interrupt;




    // Pointer to the lock variable returned for this extension when
    // locking down the driver
    
    PVOID LockPtr;


	// This value holds the span (in units of bytes) of the register
    // set controlling this port.  This is constant over the life
    // of the port.

    ULONG SpanOfController;

    // This value holds the span (in units of bytes) of the interrupt
    // status register associated with this port.  This is constant
    // over the life of the port.

    ULONG SpanOfInterruptStatus;

    // Hold the clock rate input to the serial part.

    ULONG ClockRate;

    // The number of characters to push out if a fifo is present.

    ULONG TxFifoAmount;

    // Set to indicate that it is ok to share interrupts within the device.

    ULONG PermitShare;





    // Set at intialization to indicate that on the current
    // architecture we need to unmap the base register address
    // when we unload the driver.

    BOOLEAN UnMapRegisters;

	// Set at intialization to indicate that on the current
    // architecture we need to unmap the interrupt status address
    // when we unload the driver.

    BOOLEAN UnMapStatus;

    // This is only accessed at interrupt level.  It keeps track
    // of whether the holding register is empty.

    BOOLEAN HoldingEmpty;



    // This simply indicates that the port associated with this
    // extension is part of a multiport card.

    BOOLEAN PortOnAMultiportCard;

    // We keep the following values around so that we can connect
    // to the interrupt and report resources after the configuration
    // record is gone.

    ULONG Vector;
    KIRQL Irql;
    ULONG OriginalVector;
    ULONG OriginalIrql;
    KINTERRUPT_MODE InterruptMode;
    KAFFINITY ProcessorAffinity;
    ULONG AddressSpace;
    ULONG BusNumber;
    INTERFACE_TYPE InterfaceType;



    // These two booleans are used to indicate to the isr transmit
    // code that it should send the xon or xoff character.  They are
    // only accessed at open and at interrupt level.

    BOOLEAN SendXonChar;
    BOOLEAN SendXoffChar;

    // This boolean will be true if a 16550 is present *and* enabled.

    BOOLEAN FifoPresent;

  	//	-- OXSER Mod 12 --
	// The Jensen does not interest us and all references to it have been
	// removed

	// This denotes that this particular port is an on the motherboard
    // port for the Jensen hardware.  On these ports the OUT2 bit
    // which is used to enable/disable interrupts is always hight.
    // BOOLEAN Jensen;
	
    // This is the water mark that the rxfifo should be
    // set to when the fifo is turned on.  This is not the actual
    // value, but the encoded value that goes into the register.

    UCHAR RxFifoTrigger;

    // Says whether this device can share interrupts with devices
    // other than serial devices.

    BOOLEAN InterruptShareable;


} PORT_DEVICE_EXTENSION, *PPORT_DEVICE_EXTENSION;











// PORT_DEVICE_EXTENSION.CountOnLastRead definitions... 
#define		SERIAL_COMPLETE_READ_CANCEL		((LONG)-1)
#define		SERIAL_COMPLETE_READ_TOTAL		((LONG)-2)
#define		SERIAL_COMPLETE_READ_COMPLETE	((LONG)-3)


// PORT_DEVICE_EXTENSION.LineControl definitions... 
#define		SERIAL_5_DATA		((UCHAR)0x00)
#define		SERIAL_6_DATA		((UCHAR)0x01)
#define		SERIAL_7_DATA		((UCHAR)0x02)
#define		SERIAL_8_DATA		((UCHAR)0x03)
#define		SERIAL_DATA_MASK	((UCHAR)0x03)

#define		SERIAL_1_STOP		((UCHAR)0x00)
#define		SERIAL_1_5_STOP		((UCHAR)0x04) // Only valid for 5 data bits
#define		SERIAL_2_STOP		((UCHAR)0x04) // Not valid for 5 data bits
#define		SERIAL_STOP_MASK	((UCHAR)0x04)

#define		SERIAL_NONE_PARITY	((UCHAR)0x00)
#define		SERIAL_ODD_PARITY	((UCHAR)0x08)
#define		SERIAL_EVEN_PARITY	((UCHAR)0x18)
#define		SERIAL_MARK_PARITY	((UCHAR)0x28)
#define		SERIAL_SPACE_PARITY	((UCHAR)0x38)
#define		SERIAL_PARITY_MASK	((UCHAR)0x38)
#define		SERIAL_LCR_BREAK	0x40


// PORT_DEVICE_EXTENSION.SpecialChars default xon/xoff characters... 
#define		SERIAL_DEF_XON		0x11
#define		SERIAL_DEF_XOFF		0x13

// PORT_DEVICE_EXTENSION.TXHolding definitions... 
#define		SERIAL_TX_CTS		((ULONG)0x01)
#define		SERIAL_TX_DSR		((ULONG)0x02)
#define		SERIAL_TX_DCD		((ULONG)0x04)
#define		SERIAL_TX_XOFF		((ULONG)0x08)
#define		SERIAL_TX_BREAK		((ULONG)0x10)

// PORT_DEVICE_EXTENSION.RXHolding definitions...
#define		SERIAL_RX_DTR		((ULONG)0x01)
#define		SERIAL_RX_XOFF		((ULONG)0x02)
#define		SERIAL_RX_RTS		((ULONG)0x04)
#define		SERIAL_RX_DSR		((ULONG)0x08)	
#define		SERIAL_RX_FULL      ((ULONG)0x10)   // VIV: If Io8 Rx queue is full.

// PORT_DEVICE_EXTENSION.LastStatus definitions... 
#define		SERIAL_LSR_DR       0x01
#define		SERIAL_LSR_OE		0x02
#define		SERIAL_LSR_PE		0x04
#define		SERIAL_LSR_FE		0x08
#define		SERIAL_LSR_BI		0x10

// 16550 Modem Control Register definitions... 
#define		SERIAL_MCR_DTR		0x01
#define		SERIAL_MCR_RTS		0x02

// 16550 Modem Status Register definitions... 
#define		SERIAL_MSR_DCTS		0x01
#define		SERIAL_MSR_DDSR		0x02
#define		SERIAL_MSR_TERI		0x04
#define		SERIAL_MSR_DDCD		0x08
#define		SERIAL_MSR_CTS		0x10
#define		SERIAL_MSR_DSR		0x20
#define		SERIAL_MSR_RI		0x40
#define		SERIAL_MSR_DCD		0x80



// These masks define the interrupts that can be enabled or disabled.
//
// This interrupt is used to notify that there is new incomming
// data available.  The SERIAL_RDA interrupt is enabled by this bit.
#define SERIAL_IER_RDA   0x01


// This interrupt is used to notify that there is space available
// in the transmitter for another character.  The SERIAL_THR
// interrupt is enabled by this bit.
#define SERIAL_IER_THR   0x02

// This interrupt is used to notify that some sort of error occured
// with the incomming data.  The SERIAL_RLS interrupt is enabled by
// this bit.
#define SERIAL_IER_RLS   0x04

// This interrupt is used to notify that some sort of change has
// taken place in the modem control line.  The SERIAL_MS interrupt is
// enabled by this bit.
#define SERIAL_IER_MS    0x08


// These masks define the values of the interrupt identification
// register.  The low bit must be clear in the interrupt identification
// register for any of these interrupts to be valid.  The interrupts
// are defined in priority order, with the highest value being most
// important.  See above for a description of what each interrupt
// implies.
#define SERIAL_IIR_RLS      0x06
#define SERIAL_IIR_RDA      0x04
#define SERIAL_IIR_CTI      0x0c
#define SERIAL_IIR_THR      0x02
#define SERIAL_IIR_MS       0x00


// This bit mask get the value of the high two bits of the
// interrupt id register.  If this is a 16550 class chip
// these bits will be a one if the fifo's are enbled, otherwise
// they will always be zero.
#define SERIAL_IIR_FIFOS_ENABLED 0xc0

// If the low bit is logic one in the interrupt identification register
// this implies that *NO* interrupts are pending on the device.
#define SERIAL_IIR_NO_INTERRUPT_PENDING 0x01




// These masks define access to the fifo control register.

// Enabling this bit in the fifo control register will turn
// on the fifos.  If the fifos are enabled then the high two
// bits of the interrupt id register will be set to one.  Note
// that this only occurs on a 16550 class chip.  If the high
// two bits in the interrupt id register are not one then
// we know we have a lower model chip.
#define SERIAL_FCR_ENABLE     ((UCHAR)0x01)
#define SERIAL_FCR_RCVR_RESET ((UCHAR)0x02)
#define SERIAL_FCR_TXMT_RESET ((UCHAR)0x04)


// This set of values define the high water marks (when the
// interrupts trip) for the receive fifo.
#define SERIAL_1_BYTE_HIGH_WATER   ((UCHAR)0x00)
#define SERIAL_4_BYTE_HIGH_WATER   ((UCHAR)0x40)
#define SERIAL_8_BYTE_HIGH_WATER   ((UCHAR)0x80)
#define SERIAL_14_BYTE_HIGH_WATER  ((UCHAR)0xc0)



// This defines the bit used to control the definition of the "first"
// two registers for the 8250.  These registers are the input/output
// register and the interrupt enable register.  When the DLAB bit is
// enabled these registers become the least significant and most
// significant bytes of the divisor value.
#define SERIAL_LCR_DLAB     0x80


// This bit is used for general purpose output.
#define SERIAL_MCR_OUT1     0x04

// This bit is used for general purpose output.
#define SERIAL_MCR_OUT2     0x08

// This bit controls the loopback testing mode of the device.  Basically
// the outputs are connected to the inputs (and vice versa).
#define SERIAL_MCR_LOOP     0x10


// This is the transmit holding register empty indicator.  It is set
// to indicate that the hardware is ready to accept another character
// for transmission.  This bit is cleared whenever a character is
// written to the transmit holding register.
#define SERIAL_LSR_THRE     0x20


// This bit is the transmitter empty indicator.  It is set whenever the
// transmit holding buffer is empty and the transmit shift register
// (a non-software accessable register that is used to actually put
// the data out on the wire) is empty.  Basically this means that all
// data has been sent.  It is cleared whenever the transmit holding or
// the shift registers contain data.
#define SERIAL_LSR_TEMT     0x40


// This bit indicates that there is at least one error in the fifo.
// The bit will not be turned off until there are no more errors
// in the fifo.
#define SERIAL_LSR_FIFOERR  0x80


//
// This should be more than enough space to hold then
// numeric suffix of the device name.
//
#define DEVICE_NAME_DELTA 20


//
// Up to 16 Ports Per card.  However for sixteen
// port cards the interrupt status register must be
// the indexing kind rather then the bitmask kind.
//
#define SERIAL_MAX_PORTS_INDEXED      (16)
#define SERIAL_MAX_PORTS_NONINDEXED   (8)




















//////////////////////////////////////////////////////////////////////////////////////////
// SPEED Card Device Extenstion.
// Information specific to SPEED cards.
//////////////////////////////////////////////////////////////////////////////////////////
typedef struct _CARD_DEVICE_EXTENSION 
{

	COMMON_CARD_DEVICE_EXTENSION;	// Common Card Device Extension 
	
	ULONG CrystalFrequency;			// Frequency of onboard crystal

	PHYSICAL_ADDRESS	PCIConfigRegisters;
	ULONG				SpanOfPCIConfigRegisters;
	PUCHAR				LocalConfigRegisters;


	PUCHAR InterruptStatus;
    PPORT_DEVICE_EXTENSION Extensions[SERIAL_MAX_PORTS_INDEXED];
    ULONG MaskInverted;
    UCHAR UsablePortMask;
	ULONG UARTOffset;
	ULONG UARTRegStride;
 
	// First UART in the list to be serviced next by the ISR.
	PUART_OBJECT	pFirstUart;

	UART_LIB		UartLib;	// Uart library finctions.

	ULONG CardOptions;
	

} CARD_DEVICE_EXTENSION, *PCARD_DEVICE_EXTENSION;


#endif // End of SPD_CARD.H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\spx\speed\driver\incl\os.h ===
/******************************************************************************
*	
*	$Workfile: os.h $ 
*
*	$Author: Psmith $ 
*
*	$Revision: 3 $
* 
*	$Modtime: 21/07/99 9:19 $ 
*
*	Description: NT specific macros and definitions.
*
******************************************************************************/
#if !defined(OSDEFS_H)		// OSDEFS.H
#define OSDEFS_H

#include <ntddk.h>
/*
#define TRUE	1
#define FALSE	0

typedef int			BOOLEAN;
typedef void			VOID;
typedef VOID			*PVOID;

*/
typedef unsigned char	BYTE;	// 8-bits 
typedef unsigned short	WORD;	// 16-bits 
typedef unsigned long	DWORD;	// 32-bits
typedef unsigned char	UCHAR; 	// 8-bits 
typedef unsigned short	USHORT;	// 16-bits 
typedef unsigned long	ULONG;	// 32-bits

typedef BYTE	*PBYTE;
typedef WORD	*PWORD;
typedef DWORD	*PDWORD;
typedef UCHAR	*PUCHAR; 
typedef USHORT	*PUSHORT;
typedef ULONG	*PULONG; 



extern PVOID SpxAllocateMem(IN POOL_TYPE PoolType, IN ULONG NumberOfBytes);


// Macros

#define UL_ALLOC_AND_ZERO_MEM(Size)			\
    (SpxAllocateMem(NonPagedPool, Size))	

#define UL_FREE_MEM(Ptr, Size)				\
    (ExFreePool(Ptr))	

#define UL_COPY_MEM(pDest, pSrc, NumBytes)		\
    (RtlCopyMemory(pDest, pSrc, NumBytes))	



// Read single byte from I/O.
#define UL_READ_BYTE_IO(BaseAddress, OffSet)		\
	(READ_PORT_UCHAR( ((PUCHAR)BaseAddress) + OffSet) )

// Write single byte to I/O.
#define UL_WRITE_BYTE_IO(BaseAddress, OffSet, Data)	\
	(WRITE_PORT_UCHAR( ((PUCHAR)BaseAddress) + OffSet, Data) )
/*
// Read multiple bytes to I/O.
#define UL_READ_MULTIBYTES_IO(BaseAddress, OffSet, pDest, NumberOfBytes)	\
	(READ_PORT_BUFFER_UCHAR( ((PUCHAR)BaseAddress) + OffSet, pDest, NumberOfBytes) )

// Write multiple bytes to I/O.
#define UL_WRITE_MULTIBYTES_IO(BaseAddress, OffSet, pData, NumberOfBytes)	\
	(WRITE_PORT_BUFFER_UCHAR( ((PUCHAR)BaseAddress) + OffSet, pData, NumberOfBytes) )
*/

// Read single byte from Memory.
#define UL_READ_BYTE_MEM(BaseAddress, OffSet)		\
	(READ_REGISTER_UCHAR( ((PUCHAR)BaseAddress) + OffSet) )

// Write single byte to Memory.
#define UL_WRITE_BYTE_MEM(BaseAddress, OffSet, Data)	\
	(WRITE_REGISTER_UCHAR( ((PUCHAR)BaseAddress) + OffSet, Data) )
/*
// Read multiple bytes to Memory.
#define UL_READ_MULTIBYTES_MEM(BaseAddress, OffSet, pDest, NumberOfBytes)	\
	(READ_REGISTER_BUFFER_UCHAR( ((PUCHAR)BaseAddress) + OffSet, pDest, NumberOfBytes) )
	

// Write multiple bytes to Memory.
#define UL_WRITE_MULTIBYTES_MEM(BaseAddress, OffSet, pData, NumberOfBytes)	\
	(WRITE_REGISTER_BUFFER_UCHAR( ((PUCHAR)BaseAddress) + OffSet, pData, NumberOfBytes) )
*/
#endif	// End of OSDEFS.H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\spx\speed\driver\incl\spx_card.h ===
//////////////////////////////////////////////////////////////////////////////////////////
//  Card and Port device extension structures.
// 
//////////////////////////////////////////////////////////////////////////////////////////
#ifndef SPX_CARD_H
#define SPX_CARD_H	

typedef	struct _CARD_DEVICE_EXTENSION *PCARD_DEV_EXT;
typedef	struct _PORT_DEVICE_EXTENSION *PPORT_DEV_EXT;

//////////////////////////////////////////////////////////////////////////////////////////
// Common header for all the device extensions 
// Common to all the PDOs and FDOs (cards and ports).
//////////////////////////////////////////////////////////////////////////////////////////
typedef struct _COMMON_OBJECT_DATA
{
    PDEVICE_OBJECT	DeviceObject;			// A backpointer to the device object that contains this device extension.
    PDRIVER_OBJECT	DriverObject;			// Pointer to Driver Object
    BOOLEAN         IsFDO;					// A boolean to distringuish between PDO and FDO.
	PDEVICE_OBJECT	LowerDeviceObject;		// This is a pointer to the next lower device in the IRP stack.

    ULONG           DebugLevel;

	ULONG			PnpPowerFlags;			// Plug & Play / Power flags
	KSPIN_LOCK		PnpPowerFlagsLock;		// Lock for protecting the flags
	BOOLEAN         PowerQueryLock;			// Are we currently in a query power state? 
    LIST_ENTRY		StalledIrpQueue;		// List of stalled IRPs
	KSPIN_LOCK		StalledIrpLock;			// Lock for protecting stalled IRPs
	BOOLEAN			UnstallingFlag;			// Flag set if we are unstalling IRPs currently queued.

#ifndef	BUILD_SPXMINIPORT
	SYSTEM_POWER_STATE  SystemState;		// Current System Power State
    DEVICE_POWER_STATE  DeviceState;		// Current Device Power State
#endif

#ifdef WMI_SUPPORT
    WMILIB_CONTEXT		WmiLibInfo;			// WMI Information
#endif

} COMMON_OBJECT_DATA, *PCOMMON_OBJECT_DATA;


//////////////////////////////////////////////////////////////////////////////////////////
// Common Card Configuration Data.
// Information not specific to product.
//////////////////////////////////////////////////////////////////////////////////////////
typedef struct _CONFIG_DATA 
{
	PHYSICAL_ADDRESS	RawPhysAddr;		// Raw physical address of card 
    PHYSICAL_ADDRESS    PhysAddr;			// Translated Physical address of card.
	PUCHAR				Controller;			// Virtual mapped sddress of card.
    ULONG               SpanOfController;	// Size of memory used by Cord.
    INTERFACE_TYPE      InterfaceType;		// Type of card (Isa or Pci)
    ULONG               BusNumber;			// Bus number card is using.
	ULONG				SlotNumber;			// Slot number on bus.		
    ULONG               AddressSpace;		// Flag used by SX
    ULONG               OriginalVector;		// Original Vector (bus relative)
    ULONG               OriginalIrql;		// Original Irql (bus relative)
    ULONG               TrVector;			// Translated Vector (system relative).
    KIRQL               TrIrql;				// Translated Irql (system relative).
    KINTERRUPT_MODE     InterruptMode;		// Interrupt mode (LevelSensitive or Latched)
	BOOLEAN				InterruptShareable;	// Interrupt shareable flag.
    KAFFINITY           ProcessorAffinity;	// Processor affintity.
	PKSERVICE_ROUTINE	OurIsr;				// Points to interrupt service routine.
    PVOID				OurIsrContext;		// Points to card device extension.
    PKINTERRUPT			Interrupt;			// Points to the interrupt object used by the card.
    ULONG               ClockRate;			// ClockRate.
} CONFIG_DATA,*PCONFIG_DATA;


//////////////////////////////////////////////////////////////////////////////////////////
// Common Card Device Extenstion.
// Information not specific to product.
//////////////////////////////////////////////////////////////////////////////////////////
typedef struct _COMMON_CARD_DEVICE_EXTENSION 
{

	COMMON_OBJECT_DATA;								// Common Object Data 
	CONFIG_DATA;									// Card Config Data
	PDEVICE_OBJECT PDO;								// Pointer to Physical Device Object 

	UNICODE_STRING	DeviceName;						// Device name.
	ULONG			CardNumber;
	ULONG			NumberOfPorts;					// Number of ports attached to card.
	ULONG			NumPDOs;						// The PDOs currently enumerated.
	ULONG			CardType;						// Defines the type of host card.

	PDEVICE_OBJECT  AttachedPDO[PRODUCT_MAX_PORTS];	// Array of pointers to PDOs for ports attached to card.

} COMMON_CARD_DEVICE_EXTENSION, *PCOMMON_CARD_DEVICE_EXTENSION;



typedef struct _PORT_PERFORMANCE_STATS
{
    SERIALPERF_STATS;

	// IRPs with a Major Function of IRP_MJ_WRITE
	ULONG WriteIrpsSubmitted;
	ULONG WriteIrpsCompleted;
	ULONG WriteIrpsCancelled;
	ULONG WriteIrpsTimedOut;
	ULONG WriteIrpsQueued;

	// IRPs with a Major Function of IRP_MJ_READ
	ULONG ReadIrpsSubmitted;
	ULONG ReadIrpsCompleted;
	ULONG ReadIrpsCancelled;
	ULONG ReadIrpsTimedOut;
	ULONG ReadIrpsQueued;

	// IRPs with a Major Function of IRP_MJ_FLUSH_BUFFERS
	ULONG FlushIrpsSubmitted;
	ULONG FlushIrpsCompleted;
	ULONG FlushIrpsCancelled;
	ULONG FlushIrpsQueued;

	// IRPs with a Major Function of IRP_MJ_DEVICE_CONTROL
	ULONG IoctlIrpsSubmitted;
	ULONG IoctlIrpsCompleted;
	ULONG IoctlIrpsCancelled;

	// IRPs with a Major Function of IRP_MJ_INTERNAL_DEVICE_CONTROL
	ULONG InternalIoctlIrpsSubmitted;
	ULONG InternalIoctlIrpsCompleted;
	ULONG InternalIoctlIrpsCancelled;

	// IRPs with a Major Function of IRP_MJ_CREATE
	ULONG CreateIrpsSubmitted;
	ULONG CreateIrpsCompleted;
	ULONG CreateIrpsCancelled;

	// IRPs with a Major Function of IRP_MJ_CLOSE
	ULONG CloseIrpsSubmitted;
	ULONG CloseIrpsCompleted;
	ULONG CloseIrpsCancelled;

	// IRPs with a Major Function of IRP_MJ_CLEANUP
	ULONG CleanUpIrpsSubmitted;
	ULONG CleanUpIrpsCompleted;
	ULONG CleanUpIrpsCancelled;

	// IRPs with a Major Function of IRP_MJ_QUERY_INFORMATION and IRP_MJ_SET_INFORMATION 
	ULONG InfoIrpsSubmitted;
	ULONG InfoIrpsCompleted;
	ULONG InfoIrpsCancelled;

} PORT_PERFORMANCE_STATS, *PPORT_PERFORMANCE_STATS;

//////////////////////////////////////////////////////////////////////////////////////////
// Common Port Device Extenstion.
// Information not specific to product.
//////////////////////////////////////////////////////////////////////////////////////////
typedef struct _COMMON_PORT_DEVICE_EXTENSION 
{

	COMMON_OBJECT_DATA;								// Common Object Data 
	PDEVICE_OBJECT		ParentFDO;					// A back pointer to the bus FDO  (this will be the LowerDeviceObject) 
	PCARD_DEV_EXT		pParentCardExt;				// Pointer to parent card device structure
	UNICODE_STRING		DeviceName;					// Device name eg. "\Device\PortName#".
	UNICODE_STRING		DeviceClassSymbolicName;	// Device Interface Name
	UNICODE_STRING		SerialCommEntry;			// Device name in SERIALCOMM Reg key eg. "PortName#".
	ULONG				PortNumber;					// Port number.
	UNICODE_STRING		DeviceID;					// Format: bus\device (must be most specific HardwareID)
	UNICODE_STRING		InstanceID;					// Instance ID 
	BOOLEAN				UniqueInstanceID;			// TRUE if InstanceID is gloablly unique, FALSE otherwise.
    UNICODE_STRING		HardwareIDs;				// Format bus\device or *PNPXXXX - meaning root enumerated
    UNICODE_STRING		CompatibleIDs;				// Compatible IDs to the Hardware ID
    UNICODE_STRING		DevDesc;					// Text describing device
    UNICODE_STRING		DevLocation;				// Text describing device location
	UNICODE_STRING		DosName;					// Dos device name "COM#" 
	UNICODE_STRING		SymbolicLinkName;			// External Device Name eg."\DosDevices\COM#".
	BOOLEAN				CreatedSymbolicLink;		// Flag to indicate that a symbolic link has been created.
	BOOLEAN				CreatedSerialCommEntry;		// Flag to indicate that a reg entry has been created in "SERIALCOMM"
	BOOLEAN				DeviceIsOpen;				// Flag to indicate when the port is open	
	ULONG				SavedModemControl;			// DTR/RTS signal states saved during power down
    FAST_MUTEX			OpenMutex;					// Mutex on open status

	    
#ifdef WMI_SUPPORT
	SERIAL_WMI_COMM_DATA	WmiCommData;			// WMI Comm Data
    SERIAL_WMI_HW_DATA		WmiHwData;				// WMI HW Data
	SERIAL_WMI_PERF_DATA	WmiPerfData;			// WMI Performance Data
#endif

    //
    // Holds performance statistics that applications can query.
    // Reset on each open.  Only set at device level.
    //
	PORT_PERFORMANCE_STATS PerfStats;

} COMMON_PORT_DEVICE_EXTENSION, *PCOMMON_PORT_DEVICE_EXTENSION;


#endif	// End of SPX_CARD.H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\spx\speed\uartlib\os.c ===
#include "os.h"



// Read single byte from I/O.
BYTE UL_READ_BYTE_IO(PVOID BaseAddress, DWORD OffSet)		
{
	return READ_PORT_UCHAR((PUCHAR)BaseAddress + OffSet) 
}

// Write single byte to I/O.
void UL_WRITE_BYTE_IO(PVOID BaseAddress, DWORD OffSet, BYTE Data)
{
	WRITE_PORT_UCHAR((PUCHAR)BaseAddress + OffSet, Data);
}

// Read single byte from Memory.
BYTE UL_READ_BYTE_MEM(PVOID BaseAddress, DWORD OffSet)
{
	return READ_REGISTER_UCHAR((PUCHAR)BaseAddress + OffSet);
}

// Write single byte to Memory.
void UL_WRITE_BYTE_MEM(PVOID BaseAddress, DWORD OffSet, BYTE Data)
{
	WRITE_REGISTER_UCHAR((PUCHAR)BaseAddress + OffSet, Data);
}



// Read multiple bytes to I/O.
void UL_READ_MULTIBYTES_IO(PVOID BaseAddress, DWORD OffSet, PBYTE pDest, DWORD NumberOfBytes)
{
	READ_PORT_BUFFER_UCHAR((PUCHAR)BaseAddress + OffSet, pDest, NumberOfBytes);
}

// Write multiple bytes to I/O.
void UL_WRITE_MULTIBYTES_IO(PVOID BaseAddress, DWORD OffSet, PBYTE pData, DWORD NumberOfBytes)
{
	WRITE_PORT_BUFFER_UCHAR((PUCHAR)BaseAddress + OffSet, pData, NumberOfBytes);
}

// Read multiple bytes to Memory.
void UL_READ_MULTIBYTES_MEM(PVOID BaseAddress, DWORD OffSet, PBYTE pDest, DWORD NumberOfBytes)
{
	READ_REGISTER_BUFFER_UCHAR((PUCHAR)BaseAddress + OffSet, pDest, NumberOfBytes);
}

// Write multiple bytes to Memory.
void UL_WRITE_MULTIBYTES_MEM(PVOID BaseAddress, DWORD OffSet, PBYTE pData, DWORD NumberOfBytes)
{
	WRITE_REGISTER_BUFFER_UCHAR((PUCHAR)BaseAddress + OffSet, pData, NumberOfBytes);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\spx\speed\uartlib\16c65x.c ===
/******************************************************************************
*	
*	$Workfile: 16c65x.c $ 
*
*	$Author: Admin $ 
*
*	$Revision: 5 $
* 
*	$Modtime: 2/15/02 3:41p $ 
*
*	Description: Contains 16C65X UART Library functions. 
*
******************************************************************************/
#include "os.h"
#include "uartlib.h"
#include "uartprvt.h"

#if !defined(ACCESS_16C65X_IN_IO_SPACE)		
#define ACCESS_16C65X_IN_IO_SPACE		1
#endif

#include "16c65x.h"
#include "lib65x.h"


/******************************************************************************
* 650 REGISTER ACCESS CODE
******************************************************************************/

/* Performs all the necessary business to read a 650 register */
BYTE READ_FROM_16C650_REG_65X(PUART_OBJECT pUart, BYTE Register)
{
	BYTE Result;

	BYTE LastLCR = READ_LINE_CONTROL_65X(pUart);

	WRITE_LINE_CONTROL_65X(pUart, LCR_ACCESS_650);	/* Enable access to enhanced mode registers */

   	Result = READ_BYTE_REG_65X(pUart, Register);	/* Read value from Register. */

	WRITE_LINE_CONTROL_65X(pUart, LastLCR);	/* Write last LCR value to exit enhanced mode register access. */

	return Result;
}

/* Performs all the necessary business to write a 650 register */
void WRITE_TO_16C650_REG_65X(PUART_OBJECT pUart, BYTE Register, BYTE Value)
{ 
	BYTE LastLCR = READ_LINE_CONTROL_65X(pUart);

	WRITE_LINE_CONTROL_65X(pUart, LCR_ACCESS_650);	/* Enable access to enhanced mode registers */
	
	WRITE_BYTE_REG_65X(pUart, Register, Value);	/* Write Value to Register. */

	WRITE_LINE_CONTROL_65X(pUart, LastLCR);  /* Write last LCR value to exit enhanced mode register access. */
}


WORD CalculateBaudDivisor_65X(PUART_OBJECT pUart, DWORD DesiredBaud)
{
	WORD CalculatedDivisor;
	DWORD Denominator, Remainder, ActualBaudrate;
	long BaudError;
	DWORD ClockFreq = pUart->ClockFreq;
	PUART_DATA_16C65X pUartData = (PUART_DATA_16C65X)pUart->pUartData;


	if(DesiredBaud <= 0)	/* Fail if negative or zero baud rate. */
		goto Error;


	/* Special cases */
	switch(ClockFreq)
	{
	case 14745600:
		{
			switch(DesiredBaud)
			{
			case 128000:
				return 7;	/* Return 7 as the CalculatedDivisor */

			default:
				break;
			}

			break;
		}
	
	default:
		break;
	}


	Denominator = (16 * DesiredBaud);

	if(Denominator < DesiredBaud)	/* If the BaudRate was so huge that it caused the  */
		goto Error;		/* denominator calculation to wrap, don't support it. */

	/* Don't support a baud that causes the denominator to be larger than the clock. (i.e; Divisor < 1) */
	if(Denominator > ClockFreq) 
		goto Error;


	CalculatedDivisor = (WORD)(ClockFreq / Denominator);		/* divisior need for this rate */

	Remainder = ClockFreq % Denominator;				/* remainder */

	if(Remainder >= 16 * DesiredBaud) 
		CalculatedDivisor++;		/* Round up divisor */

	ActualBaudrate = ClockFreq / (16 * CalculatedDivisor);		/* actual rate to be set */

	BaudError = 100 - (ActualBaudrate * 100 / DesiredBaud);		/* % error */


	/* check if baud rate is within tolerance */
	if((BaudError <= -3L) || (BaudError >= 3L))
		goto Error;


	return CalculatedDivisor;

Error:
	return 0;
}


/******************************************************************************
* 16C650 UART LIBRARY INTERFACE CODE
******************************************************************************/


/******************************************************************************
* Init a 16C65X UART
******************************************************************************/
ULSTATUS UL_InitUart_16C65X(PINIT_UART pInitUart, PUART_OBJECT pFirstUart, PUART_OBJECT *ppUart)
{
	int Result = UL_STATUS_SUCCESS;
	*ppUart = pFirstUart;

	*ppUart = UL_CommonInitUart(pFirstUart);

	if (!(*ppUart))				/* check for mem alloc problems */
	{
		Result = UL_STATUS_INSUFFICIENT_RESOURCES;
		goto Error;		/* Memory allocation failed. */
	}

	if(!(*ppUart)->pUartData) 	/* Attach Uart Data */
	{
		if(!((*ppUart)->pUartData = (PUART_DATA_16C65X) UL_ALLOC_AND_ZERO_MEM(sizeof(UART_DATA_16C65X))))
		{
			Result = UL_STATUS_INSUFFICIENT_RESOURCES;
			goto Error;		/* Memory allocation failed. */
		}
	}
	
	(*ppUart)->UartNumber		= pInitUart->UartNumber;	/* Set the UART Number. */
	(*ppUart)->BaseAddress		= pInitUart->BaseAddress;	/* Set base address of the UART. */
	(*ppUart)->RegisterStride	= pInitUart->RegisterStride;	/* Set register stride of the UART. */
	(*ppUart)->ClockFreq		= pInitUart->ClockFreq;		/* Set clock frequency of the UART. */

	Result = UL_STATUS_SUCCESS;	/* Success */

	return Result;


/* InitUart Failed - so Clean up. */
Error:
	UL_DeInitUart_16C65X(*ppUart);	
	return Result;
}

/******************************************************************************
* DeInit a 16C65X UART
******************************************************************************/
void UL_DeInitUart_16C65X(PUART_OBJECT pUart)
{
	if(!pUart)
		return;

	if(pUart->pUartData)
	{
		UL_FREE_MEM(pUart->pUartData, sizeof(UART_DATA_16C65X));	/* Destroy the UART Data */
		pUart->pUartData = NULL;
	}

	UL_CommonDeInitUart(pUart);	/* Do Common DeInit UART */
}


/******************************************************************************
* Reset a 16C65X UART
******************************************************************************/
void UL_ResetUart_16C65X(PUART_OBJECT pUart)
{
	int i = 0;

	WRITE_INTERRUPT_ENABLE_65X(pUart, 0x0);		/* Turn off interrupts. */
	WRITE_LINE_CONTROL_65X(pUart, 0x0);			/* To ensure not 0xBF on 16C650 UART */
	
	/* Enable and Flush FIFOs */
	WRITE_FIFO_CONTROL_65X(pUart, FCR_FIFO_ENABLE);	/* Enable FIFO with default trigger levels. */
	READ_RECEIVE_BUFFER_65X(pUart);
	WRITE_FIFO_CONTROL_65X(pUart, FCR_FIFO_ENABLE | FCR_FLUSH_RX_FIFO | FCR_FLUSH_TX_FIFO);	/* Flush FIFOs */
	WRITE_FIFO_CONTROL_65X(pUart, 0x0);			/* Disable FIFOs again */
	
	WRITE_MODEM_CONTROL_65X(pUart, 0x0);		/* Clear Modem Ctrl Lines. */

	/* Reset internal UART library data and config structures */
	UL_ZERO_MEM(((PUART_DATA_16C65X)pUart->pUartData), sizeof(UART_DATA_16C65X));
	UL_ZERO_MEM(pUart->pUartConfig, sizeof(UART_CONFIG));	

	/* Enable Enahnced mode - we must always do this or we are not a 16C65x. */
	WRITE_TO_16C650_REG_65X(pUart, EFR, (BYTE)(READ_FROM_16C650_REG_65X(pUart, EFR) | EFR_ENH_MODE));

	for(i=0; i<MAX_65X_RX_FIFO_SIZE; i++)
	{
		if(!(READ_LINE_STATUS_65X(pUart) & LSR_RX_DATA)) /* if no data available */
			break;

		READ_RECEIVE_BUFFER_65X(pUart);		/* read byte of data */
	}

	
	for(i=0; i<100; i++)
	{
		/* Read Modem Status Register until clear */
		if(!(READ_MODEM_STATUS_65X(pUart) & (MSR_CTS_CHANGE | MSR_DSR_CHANGE | MSR_RI_DROPPED | MSR_DCD_CHANGE)))
			break;
	}

	for(i=0; i<MAX_65X_RX_FIFO_SIZE; i++)
	{
		/* Read Line Status Register until clear */
		if(!(READ_LINE_STATUS_65X(pUart) & (LSR_ERR_OE | LSR_ERR_PE | LSR_ERR_FE | LSR_ERR_BK | LSR_ERR_DE)))
			break;	/* Line Status now clear so finish */
			
		READ_RECEIVE_BUFFER_65X(pUart);	/* Read receive Buffer */
	}

}


/******************************************************************************
* Verify the presence of a 16C96X UART
******************************************************************************/
ULSTATUS UL_VerifyUart_16C65X(PUART_OBJECT pUart)
{
	/* Returns UL_STATUS_SUCCESS if a 16C65x device is found at the given 
	   address, otherwise UL_STATUS_UNSUCCESSFUL */

	/* A good place to perform a channel reset so we know
	   the exact state of the device from here on */
	
	UL_ResetUart_16C65X(pUart);	/* Reset Port and Turn off interrupts. */


	/* Write value to 16C65x XOFF1 Reg. */
	WRITE_TO_16C650_REG_65X(pUart, XOFF1, 0xAA);

	/* Read the Modem Status register (same offset) - should not contain the value we put in XOFF1 Reg */
	if(READ_MODEM_STATUS_65X(pUart) == 0xAA)
		goto Error;

	/* Try to read back from same XOFF1 register from 16C65x extended registers.*/
	if(READ_FROM_16C650_REG_65X(pUart, XOFF1) != 0xAA)
		goto Error;

	UL_ResetUart_16C65X(pUart);	/* Reset Port and Turn off interrupts. */

	((PUART_DATA_16C65X)((pUart)->pUartData))->Verified = TRUE;

	return UL_STATUS_SUCCESS;


Error:
	return UL_STATUS_UNSUCCESSFUL;
}


/******************************************************************************
* Configure a 16C65X UART
******************************************************************************/
ULSTATUS UL_SetConfig_16C65X(PUART_OBJECT pUart, PUART_CONFIG pNewUartConfig, DWORD ConfigMask)
{
	if(ConfigMask & UC_FRAME_CONFIG_MASK)
	{
		BYTE Frame = 0x00;

		/* Set Data Bit Length */
		switch(pNewUartConfig->FrameConfig & UC_FCFG_DATALEN_MASK)
		{
		case UC_FCFG_DATALEN_6:
			Frame |= LCR_DATALEN_6;
			break;

		case UC_FCFG_DATALEN_7:
			Frame |= LCR_DATALEN_7;
			break;

		case UC_FCFG_DATALEN_8:
			Frame |= LCR_DATALEN_8;
			break;

		case UC_FCFG_DATALEN_5:
		default:
			break;
		}

		/* Set Number of Stop Bits */
		switch(pNewUartConfig->FrameConfig & UC_FCFG_STOPBITS_MASK)
		{
		case UC_FCFG_STOPBITS_1_5:
			Frame |= LCR_STOPBITS;
			break;

		case UC_FCFG_STOPBITS_2:
			Frame |= LCR_STOPBITS;
			break;

		case UC_FCFG_STOPBITS_1:
		default:
			break;
		}
		
		/* Set Parity Type */
		switch(pNewUartConfig->FrameConfig & UC_FCFG_PARITY_MASK)
		{
		case UC_FCFG_ODD_PARITY:
			Frame |= LCR_ODD_PARITY;
			break;

		case UC_FCFG_EVEN_PARITY:
			Frame |= LCR_EVEN_PARITY;
			break;

		case UC_FCFG_MARK_PARITY:
			Frame |= LCR_MARK_PARITY;
			break;

		case UC_FCFG_SPACE_PARITY:
			Frame |= LCR_SPACE_PARITY;
			break;

		case UC_FCFG_NO_PARITY:
		default:
			break;
		}		

		/* Configure UART. */
		WRITE_LINE_CONTROL_65X(pUart, Frame);
		pUart->pUartConfig->FrameConfig = pNewUartConfig->FrameConfig;	/* Save config. */
	}


	/* Set Interrupts */
	if(ConfigMask & UC_INT_ENABLE_MASK)
	{
		BYTE IntEnable = 0x00;

		/* First check if both TX and TX Empty has been specified - we cannot have both. */
		if((pNewUartConfig->InterruptEnable & UC_IE_TX_INT) 
			&& (pNewUartConfig->InterruptEnable & UC_IE_TX_EMPTY_INT))
			return UL_STATUS_INVALID_PARAMETER;	

		if(pNewUartConfig->InterruptEnable & UC_IE_RX_INT)
			IntEnable |= IER_INT_RDA;
		
		if(pNewUartConfig->InterruptEnable & UC_IE_TX_INT) 
			IntEnable |= IER_INT_THR;
		
		if(pNewUartConfig->InterruptEnable & UC_IE_TX_EMPTY_INT)
		{
			IntEnable |= IER_INT_THR;

			if(((PUART_DATA_16C65X)((pUart)->pUartData))->FIFOEnabled)	/* If FIFO is enabled. */
			{
#ifdef PBS
				WRITE_TO_OX950_ICR(pUart, TTL, 0);		/* Set Tx FIFO Trigger Level to Zero and save it. */
#endif
				((PUART_DATA_16C65X)((pUart)->pUartData))->TxFIFOTrigLevel = (BYTE) 0;
			}
		}

		if(pNewUartConfig->InterruptEnable & UC_IE_RX_STAT_INT) 
			IntEnable |= IER_INT_RLS;


		if(pNewUartConfig->InterruptEnable & UC_IE_MODEM_STAT_INT) 
			IntEnable |= IER_INT_MS;

		WRITE_INTERRUPT_ENABLE_65X(pUart, (BYTE)(READ_INTERRUPT_ENABLE_65X(pUart) | IntEnable));
		pUart->pUartConfig->InterruptEnable = pNewUartConfig->InterruptEnable;	/* Save config. */

		/* If we are enabling some interrupts. */
		if(IntEnable)
			WRITE_MODEM_CONTROL_65X(pUart, (BYTE)(READ_MODEM_CONTROL_65X(pUart) | MCR_OUT2));	/* Enable Ints */
		else
			WRITE_MODEM_CONTROL_65X(pUart, (BYTE)(READ_MODEM_CONTROL_65X(pUart) & ~MCR_OUT2));	/* Disable Ints */

	}


	if(ConfigMask & UC_TX_BAUD_RATE_MASK)
	{
		WORD Divisor = CalculateBaudDivisor_65X(pUart, pNewUartConfig->TxBaud);

		if(Divisor > 0)
			WRITE_DIVISOR_LATCH_65X(pUart, Divisor);
		else
			return UL_STATUS_UNSUCCESSFUL;

		pUart->pUartConfig->TxBaud = pNewUartConfig->TxBaud;	/* Save config. */
		pUart->pUartConfig->RxBaud = pNewUartConfig->RxBaud;	/* Rx baudrate will always be the same as the Tx Baudrate. */
	}


	/* Configure Flow Control Settings */
	if(ConfigMask & UC_FLOW_CTRL_MASK)
	{
		/* This currently assumes FIFOs  */
		((PUART_DATA_16C65X)((pUart)->pUartData))->RTSToggle = FALSE;
		((PUART_DATA_16C65X)((pUart)->pUartData))->DSRSensitive = FALSE;

		/* Setup RTS out-of-band flow control */
		switch(pNewUartConfig->FlowControl & UC_FLWC_RTS_FLOW_MASK)
		{
		case UC_FLWC_RTS_HS:
			/* Enable automatic RTS flow control */
			WRITE_TO_16C650_REG_65X(pUart, EFR, (BYTE)(READ_FROM_16C650_REG_65X(pUart, EFR) | EFR_RTS_FC));
			WRITE_MODEM_CONTROL_65X(pUart, (BYTE)(READ_MODEM_CONTROL_65X(pUart) | MCR_SET_RTS));	/* Set RTS */
			break;

		case UC_FLWC_RTS_TOGGLE:
			((PUART_DATA_16C65X)((pUart)->pUartData))->RTSToggle = TRUE;
			WRITE_TO_16C650_REG_65X(pUart, EFR, (BYTE)(READ_FROM_16C650_REG_65X(pUart, EFR) & ~EFR_RTS_FC));
			break;

		case UC_FLWC_NO_RTS_FLOW:		
		default:
			/* Disable automatic RTS flow control */
			WRITE_TO_16C650_REG_65X(pUart, EFR, (BYTE)(READ_FROM_16C650_REG_65X(pUart, EFR) & ~EFR_RTS_FC));
			break;
		}


		/* Setup CTS out-of-band flow control */
		switch(pNewUartConfig->FlowControl & UC_FLWC_CTS_FLOW_MASK)
		{
		case UC_FLWC_CTS_HS:
			/* Enable automatic CTS flow control */
			WRITE_TO_16C650_REG_65X(pUart, EFR, (BYTE)(READ_FROM_16C650_REG_65X(pUart, EFR) | EFR_CTS_FC));
			break;

		case UC_FLWC_NO_CTS_FLOW:		
		default:
			/* Disable automatic CTS flow control */
			WRITE_TO_16C650_REG_65X(pUart, EFR, (BYTE)(READ_FROM_16C650_REG_65X(pUart, EFR) & ~EFR_CTS_FC));
			break;
		}

		/* Setup DSR out-of-band flow control */
		switch(pNewUartConfig->FlowControl & UC_FLWC_DSR_FLOW_MASK)
		{
		case UC_FLWC_DSR_HS:
			((PUART_DATA_16C65X)((pUart)->pUartData))->DSRHandshake = TRUE;
			break;

		case UC_FLWC_NO_DSR_FLOW:
		default:
			((PUART_DATA_16C65X)((pUart)->pUartData))->DSRHandshake = FALSE;
			break;
		}

		/* Setup DTR out-of-band flow control */
		switch(pNewUartConfig->FlowControl & UC_FLWC_DTR_FLOW_MASK)
		{
		case UC_FLWC_DTR_HS:
			((PUART_DATA_16C65X)((pUart)->pUartData))->DTRHandshake = TRUE;
			WRITE_MODEM_CONTROL_65X(pUart, (BYTE)(READ_MODEM_CONTROL_65X(pUart) | MCR_SET_DTR));	/* Set DTR */
			break;

		case UC_FLWC_DSR_IP_SENSITIVE:
			/* If we were doing DTR flow control clear DTR */
			if(((PUART_DATA_16C65X)((pUart)->pUartData))->DTRHandshake)
				WRITE_MODEM_CONTROL_65X(pUart, (BYTE)(READ_MODEM_CONTROL_65X(pUart) & ~MCR_SET_DTR));	/* Clear DTR */

			((PUART_DATA_16C65X)((pUart)->pUartData))->DSRSensitive = TRUE;
			break;

		case UC_FLWC_NO_DTR_FLOW:
		default:
			/* If we were doing DTR flow control clear DTR */
			if(((PUART_DATA_16C65X)((pUart)->pUartData))->DTRHandshake)
				WRITE_MODEM_CONTROL_65X(pUart, (BYTE)(READ_MODEM_CONTROL_65X(pUart) & ~MCR_SET_DTR));	/* Clear DTR */

			((PUART_DATA_16C65X)((pUart)->pUartData))->DTRHandshake = FALSE;
			break;
		}

		/* Setup Transmit XON/XOFF in-band flow control */
		/* 10.11.1999 ARG - ESIL 0928 */
		/* Modified each case functionality to set the correct bits in EFR & MCR */
		switch (pNewUartConfig->FlowControl & UC_FLWC_TX_XON_XOFF_FLOW_MASK)
		{
		case UC_FLWC_TX_XON_XOFF_FLOW:
			WRITE_TO_16C650_REG_65X(pUart, EFR, (BYTE)(READ_FROM_16C650_REG_65X(pUart, EFR) | EFR_TX_XON_XOFF_1));
			WRITE_MODEM_CONTROL_65X(pUart, (BYTE)(READ_MODEM_CONTROL_65X(pUart) & ~MCR_XON_ANY));
			break;

		case UC_FLWC_TX_XONANY_XOFF_FLOW:
			WRITE_TO_16C650_REG_65X(pUart, EFR, (BYTE)(READ_FROM_16C650_REG_65X(pUart, EFR) | EFR_TX_XON_XOFF_1));
			WRITE_MODEM_CONTROL_65X(pUart, (BYTE)(READ_MODEM_CONTROL_65X(pUart) | MCR_XON_ANY));
			break;

		case UC_FLWC_TX_NO_XON_XOFF_FLOW:
		default:
			WRITE_TO_16C650_REG_65X(pUart, EFR, (BYTE)(READ_FROM_16C650_REG_65X(pUart, EFR) & ~(EFR_TX_XON_XOFF_1 | EFR_TX_XON_XOFF_2)));
			WRITE_MODEM_CONTROL_65X(pUart, (BYTE)(READ_MODEM_CONTROL_65X(pUart) & ~MCR_XON_ANY));
			break;
		}

		/* Setup Receive XON/XOFF in-band flow control */
		/* 10.11.1999 ARG - ESIL 0928 */
		/* Remove XON-ANY case as not a UART feature */
		/* Modified remaining cases to NOT touch the MCR */
		switch(pNewUartConfig->FlowControl & UC_FLWC_RX_XON_XOFF_FLOW_MASK)
		{
		case UC_FLWC_RX_XON_XOFF_FLOW:
			WRITE_TO_16C650_REG_65X(pUart, EFR, (BYTE)(READ_FROM_16C650_REG_65X(pUart, EFR) | EFR_RX_XON_XOFF_1));
			break;

		case UC_FLWC_RX_NO_XON_XOFF_FLOW:
		default:
			WRITE_TO_16C650_REG_65X(pUart, EFR, (BYTE)(READ_FROM_16C650_REG_65X(pUart, EFR) & ~(EFR_RX_XON_XOFF_1 | EFR_RX_XON_XOFF_2)));
			break;
		}

		/* Disable/Enable Transmitter or Rerceivers */
		switch(pNewUartConfig->FlowControl & UC_FLWC_DISABLE_TXRX_MASK)
		{
		case UC_FLWC_DISABLE_TX:
			((PUART_DATA_16C65X)((pUart)->pUartData))->TxDisabled = TRUE;
			break;

		case UC_FLWC_DISABLE_RX:
			((PUART_DATA_16C65X)((pUart)->pUartData))->RxDisabled = TRUE;
			break;

		case UC_FLWC_DISABLE_TXRX:
			((PUART_DATA_16C65X)((pUart)->pUartData))->TxDisabled = TRUE;
			((PUART_DATA_16C65X)((pUart)->pUartData))->RxDisabled = TRUE;
			break;

		default:
			((PUART_DATA_16C65X)((pUart)->pUartData))->TxDisabled = FALSE;
			((PUART_DATA_16C65X)((pUart)->pUartData))->RxDisabled = FALSE;
			break;
		}

		pUart->pUartConfig->FlowControl = pNewUartConfig->FlowControl;	/* Save config. */
	}

#ifdef PBS	/* Set via Fifo Triggers */
	/* Configure threshold Settings */
	if(ConfigMask & UC_FC_THRESHOLD_SETTING_MASK)	/* ONLY USED FOR DTR/DSR Flow control on 16C65X UARTS */
	{
		/* To do flow control in hardware the thresholds must be less than the FIFO size. */
		if(pNewUartConfig->HiFlowCtrlThreshold > MAX_65X_TX_FIFO_SIZE)
			pNewUartConfig->HiFlowCtrlThreshold = DEFAULT_65X_HI_FC_TRIG_LEVEL;	/* = 75% of FIFO */

		if(pNewUartConfig->LoFlowCtrlThreshold > MAX_65X_TX_FIFO_SIZE)
			pNewUartConfig->LoFlowCtrlThreshold = DEFAULT_65X_LO_FC_TRIG_LEVEL;	/* = 25% of FIFO */


		/* Upper handshaking threshold */
		pUart->pUartConfig->HiFlowCtrlThreshold = pNewUartConfig->HiFlowCtrlThreshold;	/* Save config. */
	
		/* Lower handshaking threshold */
		pUart->pUartConfig->LoFlowCtrlThreshold = pNewUartConfig->LoFlowCtrlThreshold;	/* Save config. */
	}
#endif

	/* Configure Special Character Settings */
	if(ConfigMask & UC_SPECIAL_CHARS_MASK)
	{
		/* Set default XON & XOFF chars. */
		WRITE_TO_16C650_REG_65X(pUart, XON1, (BYTE)pNewUartConfig->XON);		
		pUart->pUartConfig->XON = pNewUartConfig->XON;		/* Save config. */
		
		WRITE_TO_16C650_REG_65X(pUart, XOFF1, (BYTE)pNewUartConfig->XOFF);
		pUart->pUartConfig->XOFF = pNewUartConfig->XOFF;	/* Save config. */

		pUart->pUartConfig->SpecialCharDetect = pNewUartConfig->SpecialCharDetect;	/* Save config. */
	}

	/* Set any special mode */
	if(ConfigMask & UC_SPECIAL_MODE_MASK)
	{
		if(pNewUartConfig->SpecialMode & UC_SM_LOOPBACK_MODE)
			WRITE_MODEM_CONTROL_65X(pUart, (BYTE)(READ_MODEM_CONTROL_65X(pUart) | MCR_LOOPBACK));
		else
			WRITE_MODEM_CONTROL_65X(pUart, (BYTE)(READ_MODEM_CONTROL_65X(pUart) & ~MCR_LOOPBACK));

		if(pNewUartConfig->SpecialMode & UC_SM_LOW_POWER_MODE)
			WRITE_INTERRUPT_ENABLE_65X(pUart, (BYTE)(READ_INTERRUPT_ENABLE_65X(pUart) | IER_SLEEP_EN));
		else
			WRITE_INTERRUPT_ENABLE_65X(pUart, (BYTE)(READ_INTERRUPT_ENABLE_65X(pUart) & ~IER_SLEEP_EN));


		if(pNewUartConfig->SpecialMode & UC_SM_TX_BREAK)
			WRITE_LINE_CONTROL_65X(pUart, (BYTE)(READ_LINE_CONTROL_65X(pUart) | LCR_TX_BREAK));
		else
		{
			/* if the break was on */ 
			if(pUart->pUartConfig->SpecialMode & UC_SM_TX_BREAK)
			{
				/* Clear the break */
				WRITE_LINE_CONTROL_65X(pUart, (BYTE)(READ_LINE_CONTROL_65X(pUart) & ~LCR_TX_BREAK));
			}
		}

		if(pNewUartConfig->SpecialMode & UC_SM_DO_NULL_STRIPPING)
			((PUART_DATA_16C65X)((pUart)->pUartData))->StripNULLs = TRUE;
		else
			((PUART_DATA_16C65X)((pUart)->pUartData))->StripNULLs = FALSE;

		pUart->pUartConfig->SpecialMode = pNewUartConfig->SpecialMode;	/* Save config. */
	}

	return UL_STATUS_SUCCESS;
}





/******************************************************************************
* Control Buffers on a 16C65X UART
******************************************************************************/
ULSTATUS UL_BufferControl_16C65X(PUART_OBJECT pUart, PVOID pBufferControl, int Operation, DWORD Flags)
{
	switch(Operation)
	{
	case UL_BC_OP_FLUSH:	/* If this is a flush operation */
		{
			if(Flags & UL_BC_BUFFER) /* flush Buffers? */
			{
				if(Flags & UL_BC_IN)
				{	
					pUart->InBuf_ipos = 0;
					pUart->InBuf_opos = 0;
					pUart->InBufBytes = 0;

					/* If Rx interrupts are or were enabled */
					if(pUart->pUartConfig->InterruptEnable & UC_IE_RX_INT) 
					{
						/* If the Rx interrupt is disabled then it must be because the buffer got full */
						if(!(READ_INTERRUPT_ENABLE_65X(pUart) & IER_INT_RDA))
						{
							/* Re-enable Rx Interrupts */
							WRITE_INTERRUPT_ENABLE_65X(pUart, (BYTE)(READ_INTERRUPT_ENABLE_65X(pUart) | IER_INT_RDA));
						}
					}
				}

				if(Flags & UL_BC_OUT)
				{
					pUart->pOutBuf = NULL;
					pUart->OutBufSize = 0;
					pUart->OutBuf_pos = 0;
				}
			}

			if(Flags & UL_BC_FIFO)	/* flush FIFOs? */
			{
				if(Flags & UL_BC_IN)
					WRITE_FIFO_CONTROL_65X(pUart, (BYTE)(READ_FIFO_CONTROL_65X(pUart) | FCR_FLUSH_RX_FIFO));
				
				if(Flags & UL_BC_OUT)
					WRITE_FIFO_CONTROL_65X(pUart, (BYTE)(READ_FIFO_CONTROL_65X(pUart) | FCR_FLUSH_TX_FIFO));
			}

			break;
		}

	case UL_BC_OP_SET:
		{
			PSET_BUFFER_SIZES pBufferSizes = (PSET_BUFFER_SIZES) pBufferControl;

			if(Flags & UL_BC_BUFFER) /* Set Buffers? */
			{
				if(Flags & UL_BC_IN)
				{	
					PBYTE tmpPtr = NULL;

					if(pBufferSizes->pINBuffer != pUart->pInBuf)	/* if there was already a buffer allocated then.. */
					{
						if(pBufferSizes->pINBuffer == NULL)	/* freeing the IN buffer */
						{
							pBufferSizes->pINBuffer = pUart->pInBuf;	/* pass back a pointer to the current in buffer */
							pUart->pInBuf = NULL;
							pUart->InBufSize = 0;
							pUart->InBuf_ipos = 0;	/* Reset buffer pointers */
							pUart->InBuf_opos = 0;
							pUart->InBufBytes = 0;
						}
						else
						{
							if(pUart->pInBuf == NULL)	/* using a new buffer */
							{
								pUart->pInBuf = pBufferSizes->pINBuffer;
								pUart->InBufSize = pBufferSizes->INBufferSize;	/* Set IN buffer size. */
								pUart->InBuf_ipos = 0;	/* Reset buffer pointers */
								pUart->InBuf_opos = 0;
								pUart->InBufBytes = 0;
							}
							else		/* exchanging for a larger buffer */
							{
								DWORD Copy1 = 0, Copy2 = 0;
								tmpPtr = pUart->pInBuf;

								/* If there is data in the buffer - copy it into the new buffer */
								if((pUart->InBufBytes) && (pUart->InBufSize <= pBufferSizes->INBufferSize))
								{
									/* Get total amount that can be read in one or two read operations. */
									if(pUart->InBuf_opos < pUart->InBuf_ipos)
									{
										Copy1 = pUart->InBuf_ipos - pUart->InBuf_opos;
										Copy2 = 0;
									}
									else
									{
										Copy1 = pUart->InBufSize - pUart->InBuf_opos;
										Copy2 = pUart->InBuf_ipos;
									}

									if(Copy1)
										UL_COPY_MEM(pBufferSizes->pINBuffer, (pUart->pInBuf + pUart->InBuf_opos), Copy1);

									if(Copy2)
										UL_COPY_MEM((pBufferSizes->pINBuffer + Copy1), (pUart->pInBuf), Copy2);
								}

								pUart->InBuf_ipos = Copy1 + Copy2;	/* Reset buffer pointers */
								pUart->InBuf_opos = 0;
								
								pUart->pInBuf = pBufferSizes->pINBuffer;
								pUart->InBufSize = pBufferSizes->INBufferSize;	/* Set IN buffer size. */
								
								/* If Rx interrupts are or were enabled */
								if(pUart->pUartConfig->InterruptEnable & UC_IE_RX_INT) 
								{
									/* If the Rx interrupt is disabled then it must be because the buffer got full */
									if(!(READ_INTERRUPT_ENABLE_65X(pUart) & IER_INT_RDA))
									{
										/* When the buffer is less than 3/4 full */
										if(pUart->InBufBytes < ((3*(pUart->InBufSize>>2)) + (pUart->InBufSize>>4)))
										{
											/* Re-enable Rx Interrupts */
											WRITE_INTERRUPT_ENABLE_65X(pUart, (BYTE)(READ_INTERRUPT_ENABLE_65X(pUart) | IER_INT_RDA));
										}
									}
								}

								pBufferSizes->pINBuffer = tmpPtr;	/* pass back a pointer to the old buffer */

							}

						}

					}


				}

				/* We cannot set an OUT buffer so we just reset the pointer */
				if(Flags & UL_BC_OUT)
				{
					pUart->pOutBuf = NULL;
					pUart->OutBufSize = 0;
					pUart->OutBuf_pos = 0;
				}
			}


			if((Flags & UL_BC_FIFO) && (Flags & (UL_BC_OUT | UL_BC_IN)))	/* on FIFOs? */
			{
				/* If a Tx interrupt has been enabled then disable it */
				if(pUart->pUartConfig->InterruptEnable & (UC_IE_TX_INT | UC_IE_TX_EMPTY_INT)) 
					WRITE_INTERRUPT_ENABLE_65X(pUart, (BYTE)(READ_INTERRUPT_ENABLE_65X(pUart) & ~IER_INT_THR));

				/* If Tx & Rx FIFO sizes are zero then disable FIFOs. */
				if((pBufferSizes->TxFIFOSize == 0) && (pBufferSizes->RxFIFOSize == 0))
				{
					/* Disable FIFOs */
					WRITE_FIFO_CONTROL_65X(pUart, (BYTE)(READ_FIFO_CONTROL_65X(pUart) & ~FCR_FIFO_ENABLE));
					((PUART_DATA_16C65X)((pUart)->pUartData))->FIFOEnabled = FALSE;
				}
				else
				{
					/* if FIFOs not enabled then enable and flush them */
					if(!((PUART_DATA_16C65X)((pUart)->pUartData))->FIFOEnabled)
					{
						WRITE_FIFO_CONTROL_65X(pUart, FCR_FIFO_ENABLE);	/* Enable FIFO with default trigger levels. */
						READ_RECEIVE_BUFFER_65X(pUart);
						WRITE_FIFO_CONTROL_65X(pUart, FCR_FIFO_ENABLE | FCR_FLUSH_RX_FIFO | FCR_FLUSH_TX_FIFO);	/* Flush FIFOs */
						((PUART_DATA_16C65X)((pUart)->pUartData))->FIFOEnabled = TRUE;
					}
				}

				/* If the UART is configured for a TX Empty Interrupt - set Tx Trig Level to 0. */
				if(pUart->pUartConfig->InterruptEnable & UC_IE_TX_EMPTY_INT)
					pBufferSizes->TxFIFOTrigLevel = 0;


				if(Flags & UL_BC_OUT)	/* Set the transmit FIFO size */
				{
					/* Check Tx FIFO size is not greater than the maximum. */
					if(pBufferSizes->TxFIFOSize > MAX_65X_TX_FIFO_SIZE) 
						return UL_STATUS_INVALID_PARAMETER;

					/* Save the Tx FIFO size. */
					((PUART_DATA_16C65X)((pUart)->pUartData))->TxFIFOSize = (BYTE) pBufferSizes->TxFIFOSize;	


					/* Tx FIFO Trigger can be 8, 16, 32 or 56 */
					switch(pBufferSizes->TxFIFOTrigLevel)
					{
					case 0:
						{
							if(pBufferSizes->TxFIFOSize != 0)		/* If Tx FIFO size is not zero */
								return UL_STATUS_INVALID_PARAMETER;
							break;
						}
					case 8:
						WRITE_FIFO_CONTROL_65X(pUart, (BYTE)((READ_FIFO_CONTROL_65X(pUart) & ~FCR_THR_TRIG_LEVEL_4) | FCR_THR_TRIG_LEVEL_1));
						break;

					case 16:
						WRITE_FIFO_CONTROL_65X(pUart, (BYTE)((READ_FIFO_CONTROL_65X(pUart) & ~FCR_THR_TRIG_LEVEL_4) | FCR_THR_TRIG_LEVEL_2));
						break;

					case 32:
						WRITE_FIFO_CONTROL_65X(pUart, (BYTE)((READ_FIFO_CONTROL_65X(pUart) & ~FCR_THR_TRIG_LEVEL_4) | FCR_THR_TRIG_LEVEL_3));
						break;

					case 56:
						WRITE_FIFO_CONTROL_65X(pUart, (BYTE)((READ_FIFO_CONTROL_65X(pUart) & ~FCR_THR_TRIG_LEVEL_4) | FCR_THR_TRIG_LEVEL_4));
						break;

					default:
						return UL_STATUS_INVALID_PARAMETER;
						break;
					}

				}

				if(Flags & UL_BC_IN)	/* Set the receive FIFO size */
				{
					/* The Rx FIFO size can only be 0 or the UART's maximum in size. */
					if((pBufferSizes->RxFIFOSize != 0) && (pBufferSizes->RxFIFOSize != MAX_65X_RX_FIFO_SIZE))
						return UL_STATUS_INVALID_PARAMETER;

					/* Save the Rx FIFO size. */
					((PUART_DATA_16C65X)((pUart)->pUartData))->RxFIFOSize = (BYTE) pBufferSizes->RxFIFOSize;
					
					/* Rx FIFO Trigger can be 8, 16, 56 or 60 */
					switch(pBufferSizes->RxFIFOTrigLevel)
					{
					case 0:
						{
							if(pBufferSizes->RxFIFOSize != 0)			/* If Rx FIFO size is not zero */
								return UL_STATUS_INVALID_PARAMETER;
							break;
						}
					case 8:
						pUart->pUartConfig->LoFlowCtrlThreshold = 0;	/* Save Lower handshaking threshold */ 
						pUart->pUartConfig->HiFlowCtrlThreshold = 16;	/* Save Upper handshaking threshold */
						WRITE_FIFO_CONTROL_65X(pUart, (BYTE)((READ_FIFO_CONTROL_65X(pUart) & ~FCR_TRIG_LEVEL_4) | FCR_TRIG_LEVEL_1));
						break;

					case 16:
						pUart->pUartConfig->LoFlowCtrlThreshold = 8;	/* Save Lower handshaking threshold */ 
						pUart->pUartConfig->HiFlowCtrlThreshold = 56;	/* Save Upper handshaking threshold */
						WRITE_FIFO_CONTROL_65X(pUart, (BYTE)((READ_FIFO_CONTROL_65X(pUart) & ~FCR_TRIG_LEVEL_4) | FCR_TRIG_LEVEL_2));
						break;

					case 56:
						pUart->pUartConfig->LoFlowCtrlThreshold = 16;	/* Save Lower handshaking threshold */ 
						pUart->pUartConfig->HiFlowCtrlThreshold = 60;	/* Save Upper handshaking threshold */
						WRITE_FIFO_CONTROL_65X(pUart, (BYTE)((READ_FIFO_CONTROL_65X(pUart) & ~FCR_TRIG_LEVEL_4) | FCR_TRIG_LEVEL_3));
						break;

					case 60:
						pUart->pUartConfig->LoFlowCtrlThreshold = 56;	/* Save Lower handshaking threshold */ 
						pUart->pUartConfig->HiFlowCtrlThreshold = 60;	/* Save Upper handshaking threshold */
						WRITE_FIFO_CONTROL_65X(pUart, (BYTE)((READ_FIFO_CONTROL_65X(pUart) & ~FCR_TRIG_LEVEL_4) | FCR_TRIG_LEVEL_4));
						break;

					default:
						return UL_STATUS_INVALID_PARAMETER;
						break;
					}


				}

				/* Save away Tx trigger level set. */
				((PUART_DATA_16C65X)((pUart)->pUartData))->TxFIFOTrigLevel = (BYTE)pBufferSizes->TxFIFOTrigLevel;

				/* Save away Rx trigger level set. */
				((PUART_DATA_16C65X)((pUart)->pUartData))->RxFIFOTrigLevel = (BYTE)pBufferSizes->RxFIFOTrigLevel;

				/* If a Tx interrupt was enabled then re-enable it */
				if(pUart->pUartConfig->InterruptEnable & (UC_IE_TX_INT | UC_IE_TX_EMPTY_INT)) 
					WRITE_INTERRUPT_ENABLE_65X(pUart, (BYTE)(READ_INTERRUPT_ENABLE_65X(pUart) | IER_INT_THR));

			}

			/* Scale up thresholds for flow ctrl being done in software */
			if(pUart->InBufSize > MAX_65X_RX_FIFO_SIZE)
			{
				((PUART_DATA_16C65X)((pUart)->pUartData))->HiFlowCtrlLevel 
					= ((pUart->InBufSize) / MAX_65X_RX_FIFO_SIZE) * (pUart->pUartConfig->HiFlowCtrlThreshold);
			
				((PUART_DATA_16C65X)((pUart)->pUartData))->LoFlowCtrlLevel 
					= ((pUart->InBufSize) / MAX_65X_RX_FIFO_SIZE) * (pUart->pUartConfig->LoFlowCtrlThreshold);
			}


			break;
		}

	case UL_BC_OP_GET:
		{
			PGET_BUFFER_STATE pBufferState = (PGET_BUFFER_STATE) pBufferControl;

			if(Flags & UL_BC_BUFFER) /* state of Buffers? */
			{
				if(Flags & UL_BC_IN)
					pBufferState->BytesInINBuffer = pUart->InBufBytes;

				if(Flags & UL_BC_OUT)
					pBufferState->BytesInOUTBuffer = pUart->OutBuf_pos;
			}

			

			if(Flags & UL_BC_FIFO) /* state of FIFOs? */
			{

				if(Flags & UL_BC_IN)
				{
					if(READ_LINE_STATUS_65X(pUart) & LSR_RX_DATA)	/* if there is a byte to receive */
						pBufferState->BytesInRxFIFO = 1;	/* at least 1 byte is ready */
					else
						pBufferState->BytesInRxFIFO = 0;	/* Nothing in Rx FIFO */
				}


				if(Flags & UL_BC_OUT)
				{
					if(READ_LINE_STATUS_65X(pUart) & LSR_TX_EMPTY)	/* if there is a byte to send */
						pBufferState->BytesInTxFIFO = 0;	/* Nothing in Tx FIFO */
					else
						pBufferState->BytesInTxFIFO = 1;	/* at least 1 byte is ready to send */
				}
			}

			break;
		}

	default:
		goto Error;
	}


	return UL_STATUS_SUCCESS;

Error:
	return UL_STATUS_INVALID_PARAMETER;
}


/******************************************************************************
* Control Modem Signals on a 16C65X UART
******************************************************************************/
ULSTATUS UL_ModemControl_16C65X(PUART_OBJECT pUart, PDWORD pModemSignals, int Operation)
{
	BYTE ModemControl = READ_MODEM_CONTROL_65X(pUart);	/* Read MCR */

	switch(Operation)
	{
	case UL_MC_OP_SET:			/* Set all signals with bits set & Clear all signals with bits not set */
		{
			if((*pModemSignals) & UL_MC_RTS)
				ModemControl |= MCR_SET_RTS;		/* Set RTS */
			else
				ModemControl &= ~MCR_SET_RTS;		/* Clear RTS */


			if((*pModemSignals) & UL_MC_DTR)
				ModemControl |= MCR_SET_DTR;		/* Set DTR */
			else
				ModemControl &= ~MCR_SET_DTR;		/* Clear DTR */

			WRITE_MODEM_CONTROL_65X(pUart, ModemControl);		/* Write to MCR */
			break;
		}

	case UL_MC_OP_BIT_SET:		/* Set all output signals with bits set in DWORD */
		{
			if((*pModemSignals) & UL_MC_RTS)
				ModemControl |= MCR_SET_RTS;		/* Set RTS */

			if((*pModemSignals) & UL_MC_DTR)
				ModemControl |= MCR_SET_DTR;		/* Set DTR */

			WRITE_MODEM_CONTROL_65X(pUart, ModemControl);		/* Write to MCR */
			break;
		}

	case UL_MC_OP_BIT_CLEAR:	/* Clear all output signals with bits set in DWORD */
		{
			if((*pModemSignals) & UL_MC_RTS)
				ModemControl &= ~MCR_SET_RTS;		/* Clear RTS */

			if((*pModemSignals) & UL_MC_DTR)
				ModemControl &= ~MCR_SET_DTR;		/* Clear DTR */

			WRITE_MODEM_CONTROL_65X(pUart, ModemControl);		/* Write to MCR */
			break;
		}

	case UL_MC_OP_STATUS:		/* Return current status of all signals */
		{
			BYTE ModemStatus = READ_MODEM_STATUS_65X(pUart);	/* Get Modem Status */
			*pModemSignals = 0;	/* Clear the DWORD */

			if(ModemControl & MCR_SET_RTS)
				*pModemSignals |= UL_MC_RTS;		/* Show RTS is set */

			if(ModemControl & MCR_SET_DTR)
				*pModemSignals |= UL_MC_DTR;		/* Show DTR is set */


			if(ModemStatus & MSR_CTS_CHANGE)
				*pModemSignals |= UL_MC_DELTA_CTS;		/* Show CTS has changed */

			if(ModemStatus & MSR_DSR_CHANGE)
				*pModemSignals |= UL_MC_DELTA_DSR;		/* Show DSR has changed */

			if(ModemStatus & MSR_RI_DROPPED)
				*pModemSignals |= UL_MC_TRAILING_RI_EDGE;	/* Show RI has changed */

			if(ModemStatus & MSR_DCD_CHANGE)
				*pModemSignals |= UL_MC_DELTA_DCD;		/* Show DCD has changed */

			
			if(ModemStatus & MSR_CTS)
				*pModemSignals |= UL_MC_CTS;			/* Show CTS is set */

			if(ModemStatus & MSR_DSR)
			{
				*pModemSignals |= UL_MC_DSR;			/* Show DSR is set */
				
				/* If DSR Handshaking enabled */
				if(((PUART_DATA_16C65X)((pUart)->pUartData))->DSRHandshake)
				{
					/* If Tx Interrupts have been enabled */
					if(pUart->pUartConfig->InterruptEnable & (UC_IE_TX_INT | UC_IE_TX_EMPTY_INT)) 
					{
						/* If the Tx interrupt is disabled then it must be because the buffer got full */
						if(!(READ_INTERRUPT_ENABLE_65X(pUart) & IER_INT_THR))
						{
							/* Now lets generate a Tx Interrupt */

							/* Disable Tx Interrupt */
							WRITE_INTERRUPT_ENABLE_65X(pUart, (BYTE)(READ_INTERRUPT_ENABLE_65X(pUart) & ~IER_INT_THR));

							/* Enable Tx Interrupt */
							WRITE_INTERRUPT_ENABLE_65X(pUart, (BYTE)(READ_INTERRUPT_ENABLE_65X(pUart) | IER_INT_THR));
						}
					}

				}
			}

			if(ModemStatus & MSR_RI)
				*pModemSignals |= UL_MC_RI;				/* Show RI is set */

			if(ModemStatus & MSR_DCD)
				*pModemSignals |= UL_MC_DCD;			/* Show DCD is set */

			break;
		}

	default:
		goto Error;
		break;
	}


	return UL_STATUS_SUCCESS;

Error:
	return UL_STATUS_INVALID_PARAMETER;	/* Invalid Operation. */
}



/******************************************************************************
* Discover which interrupts are pending on a 16C65X UART.
******************************************************************************/
DWORD UL_IntsPending_16C65X(PUART_OBJECT *ppUart)
{
	BYTE Ints = 0;
	PUART_OBJECT pStartingUart = *ppUart;
	DWORD IntsPending = 0;	/* Clear current Ints Pending. */

	while(*ppUart)
	{
		Ints = READ_INTERRUPT_ID_REG_65X(*ppUart);	/* Get the interrupts pending for the UART. */
		
		if(!(Ints & IIR_NO_INT_PENDING))	/* If an interrupt is pending */
		{
			/* Mask all the Interrupts we are interrested in. */
			Ints &= IIR_RX_STAT_MSK | IIR_RX_MSK | IIR_RXTO_MSK | IIR_TX_MSK | IIR_MODEM_MSK;
		
			switch(Ints)
			{
			/* Which type of interrupts are pending? */
			case IIR_RX_STAT_MSK:			/* Receiver Line Status Interrupt	(Level 1 - Highest) */
				IntsPending |= UL_IP_RX_STAT;
				break;

			case IIR_RX_MSK:			/* Received Data Available Interrupt	(Level 2a) */
				IntsPending |= UL_IP_RX;
				break;

			case IIR_RXTO_MSK:			/* Received Data Time Out Interrupt	(Level 2b) */
				IntsPending |= UL_IP_RXTO;
				break;

			case IIR_TX_MSK:			/* Transmitter Holding Empty Interrupt	(Level 3) */
				{
					/* If Tx Empty INT set */
					if((*ppUart)->pUartConfig->InterruptEnable & UC_IE_TX_EMPTY_INT)
					{
						if(READ_LINE_STATUS_65X(*ppUart) & LSR_TX_EMPTY)	/* If transmitter idle */
							IntsPending |= UL_IP_TX_EMPTY;	/* we have a TX Empty interrupt. */
						else
							IntsPending |= UL_IP_TX;	/* We have a TX interrupt */

					}
					else
					{
						IntsPending |= UL_IP_TX;		/* We have a TX interrupt */
					}

					break;
				}

			case IIR_MODEM_MSK:			/* Modem Status Interrupt		(Level 4).  */
				IntsPending |= UL_IP_MODEM;
				break;

			default:
				break;
			}

			if(IntsPending)		/* If we have found an interrupt we know how to service then  */
				return IntsPending;		/* Return pointer to UART. */
		}

		*ppUart = (*ppUart)->pNextUart;	/* Set pointer to point to next UART */

		if(*ppUart == pStartingUart)	/* If we have gone through all the UARTs in the list */
			*ppUart = NULL;		/* Exit loop. */
	}

	return 0;		/* If no more UARTs then finish. */
}


/******************************************************************************
* Get information on 16C65X UART
******************************************************************************/
void UL_GetUartInfo_16C65X(PUART_OBJECT pUart, PUART_INFO pUartInfo)
{
	pUartInfo->MaxTxFIFOSize = MAX_65X_TX_FIFO_SIZE;
	pUartInfo->MaxRxFIFOSize = MAX_65X_RX_FIFO_SIZE;

	pUartInfo->PowerManagement = TRUE;
	pUartInfo->IndependentRxBaud = FALSE;

	pUartInfo->UART_SubType = 0;
	pUartInfo->UART_Rev = 0;
}


/******************************************************************************
* Output data to the UART FIFO
******************************************************************************/
int UL_OutputData_16C65X(PUART_OBJECT pUart)
{
	int NumBytes = 0;
	int BytesInBuffer = pUart->OutBufSize - pUart->OutBuf_pos;
	int SpaceInUART = 0;
	int i = 0;
	int BytesInFIFO = 0;

	if((!pUart->ImmediateBytes) && (!pUart->pOutBuf))	/* If no buffer of data to send then return 0. */
		return 0;	/* There would be zero byts in the buffer */


	/* If FIFOs enabled and Tx Interrupts enabled then Tx trigger level must have been reached */ 
	if((((PUART_DATA_16C65X)((pUart)->pUartData))->FIFOEnabled) && (pUart->pUartConfig->InterruptEnable & UC_IE_TX_INT))
	{
		/* Space in UART FIFO must be at least the FIFO size - trigger level */
		SpaceInUART = ((PUART_DATA_16C65X)((pUart)->pUartData))->TxFIFOSize - ((PUART_DATA_16C65X)((pUart)->pUartData))->TxFIFOTrigLevel;
	}
	else
	{
		/* If holding register empty then room for at least 1 byte */
		if(READ_LINE_STATUS_65X(pUart) & LSR_THR_EMPTY)
			SpaceInUART = -1;	/* Set to -1 to indicate byte mode */
	}

	/* If no space then we cannot send anything */
	if(SpaceInUART == 0)
		return (BytesInBuffer);

	/* If Transmitter disabled we can't send anything */
	if(((PUART_DATA_16C65X)((pUart)->pUartData))->TxDisabled)
			return (BytesInBuffer);	/* so return number of bytes left in OUT buffer */


	/* Whilst we have some bytes to send immediatly */
	while((pUart->ImmediateBytes) && (i < UL_IM_SIZE_OF_BUFFER))
	{
		if(pUart->ImmediateBuf[i][UL_IM_SLOT_STATUS] == UL_IM_BYTE_TO_SEND)
		{
			WRITE_TRANSMIT_HOLDING_65X(pUart, pUart->ImmediateBuf[i][UL_IM_SLOT_DATA]);
			pUart->ImmediateBuf[i][UL_IM_SLOT_STATUS] = UL_IM_NO_BYTE_TO_SEND;

			pUart->ImmediateBytes--;

			if(SpaceInUART >= 0) /* if not in byte mode */
			{
				SpaceInUART--;	/* less space in FIFO now */

				if(SpaceInUART == 0)
					return (BytesInBuffer);	/* return number of bytes left in OUT buffer */
			}
			else
			{
				if(!(READ_LINE_STATUS_65X(pUart) & LSR_THR_EMPTY))
					return (BytesInBuffer);	/* return number of bytes left in OUT buffer */
			}
		}

		i++; /* Goto next immediate byte slot */
	}


	/* If we still have room for more then send some not so urgent bytes */ 
	if((SpaceInUART >= 0) && (SpaceInUART < BytesInBuffer))
		NumBytes = SpaceInUART;		/* Only send what we have space for */
	else
		NumBytes = BytesInBuffer;	/* Either in byte mode or we can send all data to FIFO */


	/* If the number of bytes to send exceeds the fifo size then limit it */
	if(NumBytes > ((PUART_DATA_16C65X)((pUart)->pUartData))->TxFIFOSize)
		NumBytes = ((PUART_DATA_16C65X)((pUart)->pUartData))->TxFIFOSize;


	if(NumBytes)
	{
		/* If we have data to send and we are doing RTS toggle then raise RTS. */
		if(((PUART_DATA_16C65X)((pUart)->pUartData))->RTSToggle)
			WRITE_MODEM_CONTROL_65X(pUart, (BYTE)(READ_MODEM_CONTROL_65X(pUart) | MCR_SET_RTS));		/* Set RTS */


		for(i = 0; i < NumBytes; i++)
		{
			/* If DSR Handshaking enabled */
			if(((PUART_DATA_16C65X)((pUart)->pUartData))->DSRHandshake)
			{
				if(!(READ_MODEM_STATUS_65X(pUart) & MSR_DSR))	/* If DSR Low */
				{
					/* Disable Tx Interrupt */
					WRITE_INTERRUPT_ENABLE_65X(pUart, (BYTE)(READ_INTERRUPT_ENABLE_65X(pUart) & ~IER_INT_THR));
					
					NumBytes = i;	/* set to the number we have sent so far */
					break;
				}
			}

			WRITE_TRANSMIT_HOLDING_65X(pUart, *(pUart->pOutBuf + pUart->OutBuf_pos + i));
			
			if(SpaceInUART < 0)	/* if in byte mode check for space */
			{
				if(!(READ_LINE_STATUS_65X(pUart) & LSR_THR_EMPTY))
				{
					NumBytes = i+1;	/* set to the number we have sent so far */
					break;
				}
			}
		}

		pUart->OutBuf_pos += NumBytes;	/* Move buffer position pointer. */

		if(NumBytes == BytesInBuffer)		/* If we sent the entire buffer then */
		{
			pUart->pOutBuf = NULL;		/* Reset Out buffer pointer as we are finished with this one. */
			pUart->OutBufSize = 0;		/* Reset Out buffer size */
			pUart->OutBuf_pos = 0;		/* Reset */

			/* If we have sent all data and we are doing RTS toggle then lower RTS. */
			if(((PUART_DATA_16C65X)((pUart)->pUartData))->RTSToggle)
				WRITE_MODEM_CONTROL_65X(pUart, (BYTE)(READ_MODEM_CONTROL_65X(pUart) & ~MCR_SET_RTS));	/* Clear RTS */
		}
	}

	return (BytesInBuffer - NumBytes);	/* return number of byte left in buffer */
}


/******************************************************************************
* Input data from the UART FIFO
******************************************************************************/
int UL_InputData_16C65X(PUART_OBJECT pUart, PDWORD pRxStatus)
{
	int BytesReceived = 0, i = 0;
	BYTE NewByte;

	*pRxStatus = 0;

	/* To prevent lock ups limit the receive routine to twice the max FIFO size */
	for(i=0; i<(2*MAX_65X_RX_FIFO_SIZE); i++)
	{
		/* if there is a byte to receive */
		if(READ_LINE_STATUS_65X(pUart) & LSR_RX_DATA)
		{
			if((pUart->InBufSize - pUart->InBufBytes) == 0)	/* If no space then we cannot receive anything more. */
			{
				/* We have data in the UART that needs to be taken out and we have no where to put it */
				*pRxStatus |= UL_RS_BUFFER_OVERRUN;	

				/* Turn off Rx interrupts until there is room in the buffer */
				WRITE_INTERRUPT_ENABLE_65X(pUart, (BYTE)(READ_INTERRUPT_ENABLE_65X(pUart) & ~IER_INT_RDA));
				return BytesReceived;	
			}


			/* Read byte */
			NewByte = READ_RECEIVE_BUFFER_65X(pUart);

			/* If Receiver is disabled */
			if(((PUART_DATA_16C65X)((pUart)->pUartData))->RxDisabled)
				continue;	

			/* If we are doing DSR sensitive then check if DSR is low. */
			if(((PUART_DATA_16C65X)((pUart)->pUartData))->DSRSensitive)
			{
				/* if DSR is low then get the data but just throw the data away and get the next byte */ 
				if(!(READ_MODEM_STATUS_65X(pUart) & MSR_DSR))
					continue;
			}

			if(((PUART_DATA_16C65X)((pUart)->pUartData))->StripNULLs)	/* If we are stripping NULLs  */
			{
				if(NewByte == 0)		/* If new byte is NULL just ignore it and get the next byte */
					continue;
			}

			if(pUart->pUartConfig->SpecialMode & UC_SM_DETECT_SPECIAL_CHAR)
			{
				if(NewByte == pUart->pUartConfig->SpecialCharDetect)
					*pRxStatus |= UL_RS_SPECIAL_CHAR_DETECTED;
			}

			*(pUart->pInBuf + pUart->InBuf_ipos) = NewByte;	/* place byte in buffer */
			
			pUart->InBuf_ipos++;	/* Increment buffer offset for next byte */
			pUart->InBufBytes++;
			BytesReceived++;

			if(pUart->InBuf_ipos >= pUart->InBufSize)
				pUart->InBuf_ipos = 0;	/* reset. */
		
			/* If DTR Handshaking enabled */
			if(((PUART_DATA_16C65X)((pUart)->pUartData))->DTRHandshake)
			{
				/* If we have reached or exceeded threshold limit */
				if(pUart->InBufBytes >= ((PUART_DATA_16C65X)((pUart)->pUartData))->HiFlowCtrlLevel)
				{
					if(READ_MODEM_CONTROL_65X(pUart) & MCR_SET_DTR)	/* If DTR set */
						WRITE_MODEM_CONTROL_65X(pUart, (BYTE)(READ_MODEM_CONTROL_65X(pUart) & ~MCR_SET_DTR));	/* Clear DTR */
				}
			}
		}
		else
		{
			if(i==0)	
			{
				/* If this is the first call to UL_InputData_16C65X and Rx Interrupts are enabled then
				 we will read the receive buffer to clear the Rx interrupt whether there is data in Rx FIFO 
				 reported by the LSR register or not to prevent any lockups */
				if((READ_INTERRUPT_ENABLE_65X(pUart) & IER_INT_RDA))
					READ_RECEIVE_BUFFER_65X(pUart);
			}

			break;
		}

	}

	return (BytesReceived);
}



/******************************************************************************
* Read from the UART Buffer
******************************************************************************/
int UL_ReadData_16C65X(PUART_OBJECT pUart, PBYTE pDest, int Size)
{
	int Read1;
	int Read2;

	if(!pUart->InBufBytes)
		return 0;	/* If there is nothing in the buffer then we can't read anything. */


	/* Get total amount that can be read in one or two read operations. */
	if(pUart->InBuf_opos < pUart->InBuf_ipos)
	{
		Read1 = pUart->InBuf_ipos - pUart->InBuf_opos;
		Read2 = 0;
	}
	else 
	{
		Read1 = pUart->InBufSize - pUart->InBuf_opos;
		Read2 = pUart->InBuf_ipos;
	}


	/* Check if size is big enough else adjust values to read as much as we can. */
	if(Read1 > Size)
	{
		Read1 = Size;
		Read2 = 0;
	}
	else
	{
		if((Read1 + Read2) > Size)
			Read2 = Size - Read1;
	}

	if(Read1)
	{
		UL_COPY_MEM(pDest, (pUart->pInBuf + pUart->InBuf_opos), Read1);
		pUart->InBuf_opos += Read1;
		pUart->InBufBytes -= Read1;
		
		if(pUart->InBuf_opos >= pUart->InBufSize)
			pUart->InBuf_opos = 0;	/* Reset. */
	}

	if(Read2)
	{
		UL_COPY_MEM((pDest + Read1), (pUart->pInBuf + pUart->InBuf_opos), Read2);
		pUart->InBuf_opos += Read2;
		pUart->InBufBytes -= Read2;
	}


	/* If Rx interrupts are or were enabled */
	if(pUart->pUartConfig->InterruptEnable & UC_IE_RX_INT) 
	{
		/* If the Rx interrupt is disabled then it must be because the buffer got full */
		if(!(READ_INTERRUPT_ENABLE_65X(pUart) & IER_INT_RDA))
		{
			/* When the buffer is less than 3/4 full */
			if(pUart->InBufBytes < ((3*(pUart->InBufSize>>2)) + (pUart->InBufSize>>4)))
			{
				/* Re-enable Rx Interrupts */
				WRITE_INTERRUPT_ENABLE_65X(pUart, (BYTE)(READ_INTERRUPT_ENABLE_65X(pUart) | IER_INT_RDA));
			}
		}
	}


	/* If DTR Handshaking enabled */
	if(((PUART_DATA_16C65X)((pUart)->pUartData))->DTRHandshake)
	{	
		/* If less than the Low flow threshoold limit */
		if(pUart->InBufBytes <= ((PUART_DATA_16C65X)((pUart)->pUartData))->LoFlowCtrlLevel)
		{
			if(!(READ_MODEM_CONTROL_65X(pUart) & MCR_SET_DTR))	/* If DTR not set */
				WRITE_MODEM_CONTROL_65X(pUart, (BYTE)(READ_MODEM_CONTROL_65X(pUart) | MCR_SET_DTR));	/* Set DTR */
		}
	}


	return (Read1 + Read2);
}


/******************************************************************************
* Write to the UART Buffer
******************************************************************************/
ULSTATUS UL_WriteData_16C65X(PUART_OBJECT pUart, PBYTE pData, int Size)
{
	if(pUart->pOutBuf != NULL)
		return UL_STATUS_UNSUCCESSFUL;

	pUart->pOutBuf = pData;
	pUart->OutBufSize = Size;
	pUart->OutBuf_pos = 0;

	/* If a Tx interrupt has been enabled and there isn't an immediate write in progress then */
	if((pUart->pUartConfig->InterruptEnable & (UC_IE_TX_INT | UC_IE_TX_EMPTY_INT)) 
		&& (pUart->ImmediateBytes == 0))
	{
		/* Now lets generate a Tx Interrupt */

		/* Disable Tx Interrupt */
		WRITE_INTERRUPT_ENABLE_65X(pUart, (BYTE)(READ_INTERRUPT_ENABLE_65X(pUart) & ~IER_INT_THR));

		/* Enable Tx Interrupt */
		WRITE_INTERRUPT_ENABLE_65X(pUart, (BYTE)(READ_INTERRUPT_ENABLE_65X(pUart) | IER_INT_THR));
	}

	return Size;
}

/******************************************************************************
* Write/Cancel immediate byte.
******************************************************************************/
ULSTATUS UL_ImmediateByte_16C65X(PUART_OBJECT pUart, PBYTE pData, int Operation)
{
	switch(Operation)
	{

	case UL_IM_OP_WRITE:	/* Write a byte */
		{
			int i = 0;

			for(i = 0; i < UL_IM_SIZE_OF_BUFFER; i++)
			{
				/* If this is a free slot then write the byte */
				if(pUart->ImmediateBuf[i][UL_IM_SLOT_STATUS] == UL_IM_NO_BYTE_TO_SEND)
				{
					pUart->ImmediateBuf[i][UL_IM_SLOT_DATA] = *pData;
					pUart->ImmediateBuf[i][UL_IM_SLOT_STATUS] = UL_IM_BYTE_TO_SEND;

					pUart->ImmediateBytes++;

					/* If a Tx interrupt has been enabled and there isn't a write in progress then */
					if((pUart->pUartConfig->InterruptEnable & (UC_IE_TX_INT | UC_IE_TX_EMPTY_INT)) 
						&& (pUart->pOutBuf == NULL))
					{
						/* Now lets generate a Tx Interrupt */

						/* Disable Tx Interrupt */
						WRITE_INTERRUPT_ENABLE_65X(pUart, (BYTE)(READ_INTERRUPT_ENABLE_65X(pUart) & ~IER_INT_THR));

						/* Enable Tx Interrupt */
						WRITE_INTERRUPT_ENABLE_65X(pUart, (BYTE)(READ_INTERRUPT_ENABLE_65X(pUart) | IER_INT_THR));
					}
					
					*pData = (BYTE) i;		/* Pass back the index so the byte can be cancelled */


					return UL_STATUS_SUCCESS;	
				}
			}
			break;
		}

	case UL_IM_OP_CANCEL:
		{
			if(pUart->ImmediateBuf[*pData][UL_IM_SLOT_STATUS] == UL_IM_BYTE_TO_SEND)
			{
				pUart->ImmediateBuf[*pData][UL_IM_SLOT_STATUS] = UL_IM_NO_BYTE_TO_SEND;
				pUart->ImmediateBytes--;
				return UL_STATUS_SUCCESS;
			}
			break;
		}

	case UL_IM_OP_STATUS:
		{
			if(pUart->ImmediateBuf[*pData][UL_IM_SLOT_STATUS] == UL_IM_BYTE_TO_SEND)
				return UL_IM_BYTE_TO_SEND;
			else
				return UL_IM_NO_BYTE_TO_SEND;

			break;
		}

	default:
		return UL_STATUS_INVALID_PARAMETER;
		break;

	}


	/* If no space then we cannot send anything immediately. */
	return UL_STATUS_UNSUCCESSFUL;
}



/******************************************************************************
* Get status of UART.
******************************************************************************/
ULSTATUS UL_GetStatus_16C65X(PUART_OBJECT pUart, PDWORD pReturnData, int Operation)
{
	BYTE AdditionalStatusReg = 0;
	int i = 0;

	*pReturnData = 0;

	switch(Operation)
	{
	case UL_GS_OP_HOLDING_REASONS:
		{
			BYTE ModemStatus = READ_MODEM_STATUS_65X(pUart);

			/* RTS out-of-band flow control */
			switch(pUart->pUartConfig->FlowControl & UC_FLWC_RTS_FLOW_MASK)
			{
			case UC_FLWC_RTS_HS:	
				break;

			case UC_FLWC_RTS_TOGGLE:
				break;

			case UC_FLWC_NO_RTS_FLOW:
			default:
				break;
			}

			/* CTS out-of-band flow control */
			switch(pUart->pUartConfig->FlowControl & UC_FLWC_CTS_FLOW_MASK)
			{
			case UC_FLWC_CTS_HS:
				if(!(ModemStatus & MSR_CTS))	/* If CTS is low we cannot transmit */
					*pReturnData |= UL_TX_WAITING_FOR_CTS;
				break;

			case UC_FLWC_NO_CTS_FLOW:		
			default:
				break;
			}
		

			/* DSR out-of-band flow control */
			switch(pUart->pUartConfig->FlowControl & UC_FLWC_DSR_FLOW_MASK)
			{
			case UC_FLWC_DSR_HS:
				if(!(ModemStatus & MSR_DSR)) 	/* If DSR is low we cannot transmit */
					*pReturnData |= UL_TX_WAITING_FOR_DSR;
				break;

			case UC_FLWC_NO_DSR_FLOW:
			default:
				break;
			}
		

			/* DTR out-of-band flow control */
			switch(pUart->pUartConfig->FlowControl & UC_FLWC_DTR_FLOW_MASK)
			{
			case UC_FLWC_DTR_HS:
				break;

			case UC_FLWC_DSR_IP_SENSITIVE:
				if(!(ModemStatus & MSR_DSR))	/* If DSR is low we cannot receive */
					*pReturnData |= UL_RX_WAITING_FOR_DSR;
				break;

			case UC_FLWC_NO_DTR_FLOW:
			default:
				break;
			}

#ifdef PBS
			if(pUart->pUartConfig->FlowControl & (UC_FLWC_TX_XON_XOFF_FLOW_MASK | UC_FLWC_RX_XON_XOFF_FLOW_MASK))
			{
				ENABLE_OX950_ASR(pUart);
				AdditionalStatusReg = READ_BYTE_REG_95X(pUart, ASR);	/* Read Additional Status Register */
				DISABLE_OX950_ASR(pUart);

				/* Transmit XON/XOFF in-band flow control */
				switch(pUart->pUartConfig->FlowControl & UC_FLWC_TX_XON_XOFF_FLOW_MASK)
				{
				case UC_FLWC_TX_XON_XOFF_FLOW:
					if(AdditionalStatusReg & ASR_TX_DISABLED)
						*pReturnData |= UL_TX_WAITING_FOR_XON;
					break;

				case UC_FLWC_TX_XONANY_XOFF_FLOW:	
					if(AdditionalStatusReg & ASR_TX_DISABLED)
						*pReturnData |= UL_TX_WAITING_FOR_XON;
					break;

				case UC_FLWC_TX_NO_XON_XOFF_FLOW:
				default:
					break;
				}
			
				/* Receive XON/XOFF in-band flow control */
				switch(pUart->pUartConfig->FlowControl & UC_FLWC_RX_XON_XOFF_FLOW_MASK)
				{
				case UC_FLWC_RX_XON_XOFF_FLOW:
					if(AdditionalStatusReg & ASR_RTX_DISABLED)
						*pReturnData |= UL_TX_WAITING_XOFF_SENT;
					break;

				case UC_FLWC_RX_NO_XON_XOFF_FLOW:
				default:
					break;
				}
			}
#endif	
		
			if(pUart->pUartConfig->SpecialMode & UC_SM_TX_BREAK)
				*pReturnData |= UL_TX_WAITING_ON_BREAK;

			break;
		}

	case UL_GS_OP_LINESTATUS:
		{
			BYTE LineStatus = READ_LINE_STATUS_65X(pUart);
	
			if(LineStatus & LSR_ERR_OE)		/* Overrun Error */
				*pReturnData |= UL_US_OVERRUN_ERROR;

			if(LineStatus & LSR_ERR_PE)		/* Parity Error */
				*pReturnData |= UL_US_PARITY_ERROR;

			if(LineStatus & LSR_ERR_FE)		/* Framing Error. */
				*pReturnData |= UL_US_FRAMING_ERROR;

			if(LineStatus & LSR_ERR_BK)		/* Break Interrupt. */
				*pReturnData |= UL_US_BREAK_ERROR;

			if(LineStatus & LSR_ERR_DE)		/* Error In Receive FIFO. */
				*pReturnData |= UL_US_DATA_ERROR;

			/* If Overrun, Parity, Framing, Break status error */
			if(LineStatus & (LSR_ERR_OE | LSR_ERR_PE | LSR_ERR_FE | LSR_ERR_BK | LSR_ERR_DE))
			{
				/* While data is in Rx buffer the exception will not get cleared, so we must empty it. */
				for(i=0; i<MAX_65X_RX_FIFO_SIZE; i++)
				{
					if(!(READ_LINE_STATUS_65X(pUart) & LSR_RX_DATA)) /* if no data available */
						break;

					READ_RECEIVE_BUFFER_65X(pUart);		/* read byte of data */
				}
			}

			break;
		}

	default:
		return UL_STATUS_INVALID_PARAMETER;
	}


	return UL_STATUS_SUCCESS;
}


/******************************************************************************
* Prints out UART registers.
******************************************************************************/
void UL_DumpUartRegs_16C65X(PUART_OBJECT pUart)
{
	UART_REGS_16C65X UartRegs;

	UartRegs.REG_RHR = READ_RECEIVE_BUFFER_65X(pUart);
	UartRegs.REG_IER = READ_INTERRUPT_ENABLE_65X(pUart);
	UartRegs.REG_FCR = READ_FIFO_CONTROL_65X(pUart);
	UartRegs.REG_IIR = READ_INTERRUPT_ID_REG_65X(pUart);
	UartRegs.REG_LCR = READ_LINE_CONTROL_65X(pUart);
	UartRegs.REG_MCR = READ_MODEM_CONTROL_65X(pUart);
	UartRegs.REG_LSR = READ_LINE_STATUS_65X(pUart);
	UartRegs.REG_MSR = READ_MODEM_STATUS_65X(pUart);
	UartRegs.REG_SPR = READ_SCRATCH_PAD_REGISTER_65X(pUart);

	UartRegs.REG_EFR = READ_FROM_16C650_REG_65X(pUart, EFR);
	UartRegs.REG_XON1 = READ_FROM_16C650_REG_65X(pUart, XON1);
	UartRegs.REG_XON2 = READ_FROM_16C650_REG_65X(pUart, XON2);
	UartRegs.REG_XOFF1 = READ_FROM_16C650_REG_65X(pUart, XOFF1);
	UartRegs.REG_XOFF2 = READ_FROM_16C650_REG_65X(pUart, XOFF2);



#ifdef SpxDbgPrint /* If a DebugPrint macro is defined then print the register contents */
	SpxDbgPrint(("16C65X UART REGISTER DUMP for UART at 0x%08lX\n", pUart->BaseAddress));
	SpxDbgPrint(("-------------------------------------------------\n"));
	SpxDbgPrint(("  RHR:			0x%02X\n", UartRegs.REG_RHR));
	SpxDbgPrint(("  IER:			0x%02X\n", UartRegs.REG_IER));
	SpxDbgPrint(("  FCR:			0x%02X\n", UartRegs.REG_FCR));
	SpxDbgPrint(("  IIR:			0x%02X\n", UartRegs.REG_IIR));
	SpxDbgPrint(("  LCR:			0x%02X\n", UartRegs.REG_LCR));
	SpxDbgPrint(("  MCR:			0x%02X\n", UartRegs.REG_MCR));
	SpxDbgPrint(("  LSR:			0x%02X\n", UartRegs.REG_LSR));
	SpxDbgPrint(("  MSR:			0x%02X\n", UartRegs.REG_MSR));
	SpxDbgPrint(("  SPR:			0x%02X\n", UartRegs.REG_SPR));

	SpxDbgPrint(("16C650 Compatible Registers...\n"));
	SpxDbgPrint(("-------------------------------------------------\n"));
	SpxDbgPrint(("  EFR:			0x%02X\n", UartRegs.REG_EFR));
	SpxDbgPrint(("  XON1:			0x%02X\n", UartRegs.REG_XON1));
	SpxDbgPrint(("  XON2:			0x%02X\n", UartRegs.REG_XON2));
	SpxDbgPrint(("  XOFF1:			0x%02X\n", UartRegs.REG_XOFF1));
	SpxDbgPrint(("  XOFF2:			0x%02X\n", UartRegs.REG_XOFF2));

#endif

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\spx\speed\driver\incl\spx_misc.h ===
/****************************************************************************************
*																						*
*	Header:		SPX_MISC.H 																*
*																						*
*	Creation:	15th October 1998														*
*																						*
*	Author:		Paul Smith																*
*																						*
*	Version:	1.0.0																	*
*																						*
*	Contains:	All Macros and function prototypes for the common PnP and power code.	*
*																						*
****************************************************************************************/

#if	!defined(SPX_MISC_H)
#define SPX_MISC_H	


// Prototypes for common PnP code.
NTSTATUS
Spx_AddDevice(IN PDRIVER_OBJECT pDriverObject, IN PDEVICE_OBJECT pPDO);

NTSTATUS
Spx_DispatchPnp(IN PDEVICE_OBJECT pDevObject, IN PIRP pIrp);

NTSTATUS
Spx_DispatchPower(IN PDEVICE_OBJECT pDevObject, IN PIRP	pIrp);

NTSTATUS 
Spx_DispatchPnpPowerComplete(IN PDEVICE_OBJECT pDevObject, IN PIRP pIrp, IN PVOID Context);

NTSTATUS 
Spx_SerialInternalIoControl(IN PDEVICE_OBJECT pDevObj, IN PIRP pIrp);

NTSTATUS
Spx_InitMultiString(BOOLEAN multi, PUNICODE_STRING MultiString, ...);

NTSTATUS 
Spx_GetRegistryKeyValue(
	IN HANDLE	Handle,
	IN PWCHAR	KeyNameString,
	IN ULONG	KeyNameStringLength,
	IN PVOID	Data,
	IN ULONG	DataLength
	);

NTSTATUS 
Spx_PutRegistryKeyValue(
	IN HANDLE Handle, 
	IN PWCHAR PKeyNameString,
	IN ULONG KeyNameStringLength, 
	IN ULONG Dtype,
    IN PVOID PData, 
	IN ULONG DataLength
	);

VOID
Spx_LogMessage(
	IN ULONG MessageSeverity,				
	IN PDRIVER_OBJECT DriverObject,
	IN PDEVICE_OBJECT DeviceObject OPTIONAL,
	IN PHYSICAL_ADDRESS P1,
	IN PHYSICAL_ADDRESS P2,
	IN ULONG SequenceNumber,
	IN UCHAR MajorFunctionCode,
	IN UCHAR RetryCount,
	IN ULONG UniqueErrorValue,
	IN NTSTATUS FinalStatus,
	IN PCHAR szTemp);

VOID
Spx_LogError(
	IN PDRIVER_OBJECT DriverObject,
	IN PDEVICE_OBJECT DeviceObject OPTIONAL,
	IN PHYSICAL_ADDRESS P1,
	IN PHYSICAL_ADDRESS P2,
	IN ULONG SequenceNumber,
	IN UCHAR MajorFunctionCode,
	IN UCHAR RetryCount,
	IN ULONG UniqueErrorValue,
	IN NTSTATUS FinalStatus,
	IN NTSTATUS SpecificIOStatus,
	IN ULONG LengthOfInsert1,
	IN PWCHAR Insert1,
	IN ULONG LengthOfInsert2,
	IN PWCHAR Insert2
	);

ULONG	SpxGetNtCardType(PDEVICE_OBJECT pNtDevObj);
NTSTATUS Spx_CreatePortInstanceID(IN PPORT_DEVICE_EXTENSION pPort);

SPX_MEM_COMPARES Spx_MemCompare(IN PHYSICAL_ADDRESS A, IN ULONG SpanOfA, IN PHYSICAL_ADDRESS B, IN ULONG SpanOfB);

NTSTATUS PLX_9050_CNTRL_REG_FIX(IN PCARD_DEVICE_EXTENSION pCard);

VOID SpxSetOrClearPnpPowerFlags(IN PCOMMON_OBJECT_DATA pDevExt, IN ULONG Value, IN BOOLEAN Set);
VOID SpxSetOrClearUnstallingFlag(IN PCOMMON_OBJECT_DATA pDevExt, IN BOOLEAN Set);

BOOLEAN 
SpxCheckPnpPowerFlags(IN PCOMMON_OBJECT_DATA pDevExt, IN ULONG ulSetFlags, IN ULONG ulClearedFlags, IN BOOLEAN bAll);


PVOID SpxAllocateMem(IN POOL_TYPE PoolType, IN ULONG NumberOfBytes);
PVOID SpxAllocateMemWithQuota(IN POOL_TYPE PoolType, IN ULONG NumberOfBytes);

#ifndef BUILD_SPXMINIPORT
void SpxFreeMem(PVOID pMem);
#endif
						   
VOID SpxIRPCounter(IN PPORT_DEVICE_EXTENSION pPort, IN PIRP pIrp, IN ULONG IrpCondition);
BOOLEAN SpxClearAllPortStats(IN PPORT_DEVICE_EXTENSION pPort);


// Filtered dispatch entry points... 
NTSTATUS Spx_Flush(IN PDEVICE_OBJECT pDevObject,IN PIRP pIrp);					// SPX_DISP.C 
NTSTATUS Spx_Write(IN PDEVICE_OBJECT pDevObject,IN PIRP pIrp);					// SPX_DISP.C 
NTSTATUS Spx_Read(IN PDEVICE_OBJECT pDevObject,IN PIRP pIrp);					// SPX_DISP.C 
NTSTATUS Spx_IoControl(IN PDEVICE_OBJECT pDevObject,IN PIRP pIrp);				// SPX_DISP.C 
NTSTATUS Spx_InternalIoControl(IN PDEVICE_OBJECT pDevObject,IN PIRP pIrp);		// SPX_DISP.C 
NTSTATUS Spx_CreateOpen(IN PDEVICE_OBJECT pDevObject,IN PIRP pIrp);				// SPX_DISP.C 
NTSTATUS Spx_Close(IN PDEVICE_OBJECT pDevObject,IN PIRP pIrp);					// SPX_DISP.C 
NTSTATUS Spx_Cleanup(IN PDEVICE_OBJECT pDevObject,IN PIRP pIrp);				// SPX_DISP.C 
NTSTATUS Spx_QueryInformationFile(IN PDEVICE_OBJECT pDevObject,IN PIRP pIrp);	// SPX_DISP.C 
NTSTATUS Spx_SetInformationFile(IN PDEVICE_OBJECT pDevObject,IN PIRP pIrp);		// SPX_DISP.C 

VOID Spx_UnstallIrps(IN PPORT_DEVICE_EXTENSION pPort);							// SPX_DISP.C 
VOID Spx_KillStalledIRPs(IN PDEVICE_OBJECT pDevObj);							// SPX_DISP.C 


// End of prototypes for common PnP code.


#ifdef WMI_SUPPORT

NTSTATUS Spx_DispatchSystemControl(IN PDEVICE_OBJECT pDevObject, IN PIRP pIrp);
NTSTATUS SpxPort_WmiInitializeWmilibContext(IN PWMILIB_CONTEXT WmilibContext);

#define UPDATE_WMI_LINE_CONTROL(WmiCommData, LineControl)						\
do																				\
{																				\
																				\
	WmiCommData.BitsPerByte			= (LineControl & SERIAL_DATA_MASK) + 5;		\
	WmiCommData.ParityCheckEnable	= (LineControl & 0x08) ? TRUE : FALSE;		\
																				\
	switch(LineControl & SERIAL_PARITY_MASK)									\
	{																			\
	case SERIAL_ODD_PARITY:														\
		WmiCommData.Parity = SERIAL_WMI_PARITY_ODD;								\
		break;																	\
																				\
	case SERIAL_EVEN_PARITY:													\
		WmiCommData.Parity = SERIAL_WMI_PARITY_EVEN;							\
		break;																	\
																				\
	case SERIAL_MARK_PARITY:													\
		WmiCommData.Parity = SERIAL_WMI_PARITY_MARK;							\
		break;																	\
																				\
	case SERIAL_SPACE_PARITY:													\
		WmiCommData.Parity = SERIAL_WMI_PARITY_SPACE;							\
		break;																	\
																				\
	case SERIAL_NONE_PARITY:													\
	default:																	\
		WmiCommData.Parity = SERIAL_WMI_PARITY_NONE;							\
		break;																	\
	}																			\
																				\
																				\
	if(LineControl & SERIAL_STOP_MASK)											\
	{																			\
		if((LineControl & SERIAL_DATA_MASK) == SERIAL_5_DATA)					\
			WmiCommData.StopBits = SERIAL_WMI_STOP_1_5;							\
		else																	\
			WmiCommData.StopBits = SERIAL_WMI_STOP_2;							\
	}																			\
	else																		\
		WmiCommData.StopBits = SERIAL_WMI_STOP_1;								\
																				\
} while (0)


#define UPDATE_WMI_XON_XOFF_CHARS(WmiCommData, SpecialChars)					\
do																				\
{																				\
	WmiCommData.XoffCharacter	= SpecialChars.XoffChar;						\
	WmiCommData.XonCharacter	= SpecialChars.XonChar;							\
																				\
} while (0)


#define UPDATE_WMI_XMIT_THRESHOLDS(WmiCommData, HandFlow)						\
do																				\
{																				\
	WmiCommData.XoffXmitThreshold	= HandFlow.XoffLimit;						\
	WmiCommData.XonXmitThreshold	= HandFlow.XonLimit;						\
																				\
} while (0)

#endif



// Macros 

// Debug Messages
#if DBG
#define SPX_TRACE_CALLS			((ULONG)0x00000001)
#define SPX_TRACE_PNP_IRPS		((ULONG)0x00000002)
#define SPX_ERRORS				((ULONG)0x00000004)
#define SPX_MISC_DBG			((ULONG)0x00000008)
#define SPX_TRACE_POWER_IRPS	((ULONG)0x00000010)
#define	SPX_TRACE_IRP_PATH		((ULONG)0x00000020)
#define	SPX_TRACE_FILTER_IRPS	((ULONG)0x00000040)
//#define SERFLOW				((ULONG)0x00000080)
//#define SERERRORS				((ULONG)0x00000100)
//#define SERBUGCHECK			((ULONG)0x00000200)

extern ULONG SpxDebugLevel;		// Global Debug Level 

#define SpxDbgMsg(LEVEL, STRING)			\
        do{									\
            if(SpxDebugLevel & (LEVEL))		\
			{								\
                DbgPrint STRING;			\
            }								\
            if((LEVEL) == SERBUGCHECK)		\
			{								\
                ASSERT(FALSE);				\
            }								\
        }while (0)
#else
#define SpxDbgMsg(LEVEL, STRING) do {NOTHING;} while (0)
#endif




#define	SetPnpPowerFlags(pDevExt,Value)		\
		SpxSetOrClearPnpPowerFlags( (PCOMMON_OBJECT_DATA)(pDevExt), (Value), TRUE);		

#define	ClearPnpPowerFlags(pDevExt,Value)	\
		SpxSetOrClearPnpPowerFlags( (PCOMMON_OBJECT_DATA)(pDevExt), (Value), FALSE);	

#define SPX_SUCCESS(Status) ((NTSTATUS)(Status) == 0)

#define	SetUnstallingFlag(pDevExt)	\
		SpxSetOrClearUnstallingFlag( (PCOMMON_OBJECT_DATA)(pDevExt), TRUE);		

#define	ClearUnstallingFlag(pDevExt)	\
		SpxSetOrClearUnstallingFlag( (PCOMMON_OBJECT_DATA)(pDevExt), FALSE);	

// End of macros.

#endif	// End of SPX_MISC_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\spx\speed\uartlib\16c95x.c ===
/******************************************************************************
*	
*	$Workfile: 16c95x.c $ 
*
*	$Author: Admin $ 
*
*	$Revision: 31 $
* 
*	$Modtime: 2/15/02 3:40p $ 
*
*	Description: Contains 16C95X UART Library functions. 
*
******************************************************************************/
#include "os.h"
#include "uartlib.h"
#include "uartprvt.h"

#if !defined(ACCESS_16C95X_IN_IO_SPACE)		
#define ACCESS_16C95X_IN_IO_SPACE		0
#endif

#include "16c95x.h"
#include "lib95x.h"


/******************************************************************************
* 650 REGISTER ACCESS CODE
******************************************************************************/

/* Performs all the necessary business to read a 650 register */
BYTE READ_FROM_16C650_REG(PUART_OBJECT pUart, BYTE Register)
{
    BYTE Result;
	BYTE LastLCR = READ_LINE_CONTROL(pUart);

	WRITE_LINE_CONTROL(pUart, LCR_ACCESS_650);	/* Enable access to enhanced mode registers */

   	Result = READ_BYTE_REG_95X(pUart, Register);	/* Read value from Register. */

	WRITE_LINE_CONTROL(pUart, LastLCR);	/* Write last LCR value to exit enhanced mode register access. */

	return Result;
}

/* Performs all the necessary business to write a 650 register */
void WRITE_TO_16C650_REG(PUART_OBJECT pUart, BYTE Register, BYTE Value)
{ 
	BYTE LastLCR = READ_LINE_CONTROL(pUart);

	WRITE_LINE_CONTROL(pUart, LCR_ACCESS_650);	/* Enable access to enhanced mode registers */
	
	WRITE_BYTE_REG_95X(pUart, Register, Value);	/* Write Value to Register. */

	WRITE_LINE_CONTROL(pUart, LastLCR);  /* Write last LCR value to exit enhanced mode register access. */
}



/******************************************************************************
* INDEX CONTROL REGISTER ACCESS CODE
******************************************************************************/



/* This writes to the ICR (Indexed Control Register Set) in the 16C950 UART. 
   NOTE: ICR set can only be accessed if last value written to LCR is not 0xBF. 

   pUart	- A pointer to UART object. 
   Register	- Offset into the ICR of the Register to be written to. 
   Value	- Value to be written to the register. */
void WRITE_TO_OX950_ICR(PUART_OBJECT pUart, BYTE Register, BYTE Value)				
{																		
	WRITE_SCRATCH_PAD_REGISTER(pUart, Register);				
																		
	WRITE_BYTE_REG_95X(pUart, ICR, Value);

	if(Register == ACR)	/* Cater for the ACR register */
		((PUART_DATA_16C95X)((pUart)->pUartData))->CurrentACR = Value;
}

/* This macro reads from the ICR (Indexed Control Register Set) in the 16C950 UART. 
   NOTE: ICR set can only be accessed if last value written to LCR is not 0xBF. 

   pUart	- A pointer to the UART object.
   Register	- Offset into the ICR of the Register to be written to. 
   pCurrentACR	- Current Value of ACR - Software MUST keep contents of ACR as reading ICR overwrites ACR.  */
BYTE READ_FROM_OX950_ICR(PUART_OBJECT pUart, BYTE Register)
{
	PUART_DATA_16C95X pUartData = (PUART_DATA_16C95X)pUart->pUartData;
	BYTE Value = 0;

	if(Register == ACR)	/* Cater for the ACR register */
		return ((PUART_DATA_16C95X)((pUart)->pUartData))->CurrentACR;

	WRITE_SCRATCH_PAD_REGISTER(pUart, ACR);	
	pUartData->CurrentACR |= ACR_ICR_READ_EN;			
	WRITE_BYTE_REG_95X(pUart, ICR, pUartData->CurrentACR);
																	
	WRITE_SCRATCH_PAD_REGISTER(pUart, Register);			
	Value =	READ_BYTE_REG_95X(pUart, ICR);					
																	
	WRITE_SCRATCH_PAD_REGISTER(pUart, ACR);					
	pUartData->CurrentACR &= ~ACR_ICR_READ_EN;							
	WRITE_BYTE_REG_95X(pUart, ICR, pUartData->CurrentACR);

	return Value;
}




/******************************************************************************
* 950 SPECIFIC REGISTER ACCESS CODE
******************************************************************************/

/* Enabling access to the ASR, RFL, TFL prevents read access to MCR, LCR, IER 
   But not with the UART library as it remebers what was written to these registers   
   and doesn't bother to access the hardware.   */
void ENABLE_OX950_ASR(PUART_OBJECT pUart)
{
	PUART_DATA_16C95X pUartData = (PUART_DATA_16C95X)pUart->pUartData;

	/* Enables access to the advanced status registers */
	/* if it is not already enabled. Stores previous state */

	if(pUartData->CurrentACR & ACR_ASR_EN)
	{
		pUartData->ASRChanged = FALSE;		/* Already enabled, just remember that */
	}
	else
	{
		/* Set the bit and remember that we had to. */
		pUartData->CurrentACR |= ACR_ASR_EN;
		WRITE_TO_OX950_ICR(pUart, ACR, pUartData->CurrentACR);
		pUartData->ASRChanged = TRUE;
	}
}



void DISABLE_OX950_ASR(PUART_OBJECT pUart)
{
	PUART_DATA_16C95X pUartData = (PUART_DATA_16C95X)pUart->pUartData;

	/* Disables access to the advanced status registers */
	/* if it is not already disabled. Stores previous state */

	if(pUartData->CurrentACR & ACR_ASR_EN)
	{
		/* Clear the bit and remember it was previously set */
		pUartData->CurrentACR &= ~ACR_ASR_EN;
		WRITE_TO_OX950_ICR(pUart, ACR, pUartData->CurrentACR);
		pUartData->ASRChanged = TRUE;
	}
	else
	{
		/* It was not enabled anyway so don't */
		/* re-enable it when re-enable is called */
		pUartData->ASRChanged = FALSE;	
	}
}



void RESTORE_OX950_ASR(PUART_OBJECT pUart)
{
	PUART_DATA_16C95X pUartData = (PUART_DATA_16C95X)pUart->pUartData;

	/* Restores the ASR bit in ACR to the value it was set to imediately prior  */
	/* to the most recent call to Enable/DisableASR. */
	if(pUartData->ASRChanged)
	{
		if(pUartData->CurrentACR & ACR_ASR_EN)
			pUartData->CurrentACR &= ~ACR_ASR_EN;
		else
			pUartData->CurrentACR |= ACR_ASR_EN;

		WRITE_TO_OX950_ICR(pUart, ACR, pUartData->CurrentACR);
	}
}

WORD CalculateBaudDivisor_95X(PUART_OBJECT pUart, DWORD DesiredBaud)
{
	WORD CalculatedDivisor;
	DWORD Denominator, Remainder, ActualBaudrate;
	long BaudError;
	DWORD ClockFreq = pUart->ClockFreq;
	PUART_DATA_16C95X pUartData = (PUART_DATA_16C95X)pUart->pUartData;


	if(DesiredBaud <= 0)	/* Fail if negative or zero baud rate. */
		goto Error;


	/* Special cases */
	switch(ClockFreq)
	{
	case 14745600:
		{
			switch(DesiredBaud)
			{
			case 128000:
				return 7;	/* Return 7 as the CalculatedDivisor */

			default:
				break;
			}

			break;
		}
	
	default:
		break;
	}


	Denominator = (16 * DesiredBaud);

	if(Denominator < DesiredBaud)	/* If the BaudRate was so huge that it caused the  */
		goto Error;		/* denominator calculation to wrap, don't support it. */

	/* Don't support a baud that causes the denominator to be larger than the clock. (i.e; Divisor < 1) */
	if(Denominator > ClockFreq) 
		goto Error;


	CalculatedDivisor = (WORD)(ClockFreq / Denominator);		/* divisior need for this rate */

	Remainder = ClockFreq % Denominator;				/* remainder */

	if(Remainder >= 16 * DesiredBaud) 
		CalculatedDivisor++;		/* Round up divisor */

	ActualBaudrate = ClockFreq / (16 * CalculatedDivisor);		/* actual rate to be set */

	BaudError = 100 - (ActualBaudrate * 100 / DesiredBaud);		/* % error */


	/* check if baud rate is within tolerance */
	if((BaudError <= -3L) || (BaudError >= 3L))
		goto Error;


	/* Fix that nasty 952 divisor latch error */
	if((pUartData->UART_Type == UART_TYPE_952) && (pUartData->UART_Rev == UART_REV_B))
	{
		/* If DLL = 0 and DLM <> 0 */
		if(((CalculatedDivisor & 0x00FF) == 0) && (CalculatedDivisor > 0x00FF))
			CalculatedDivisor++;
	}


	return CalculatedDivisor;

Error:
	return 0;
}


/******************************************************************************
* 16C950 UART LIBRARY INTERFACE CODE
******************************************************************************/


/******************************************************************************
* Init a 16C95X UART
******************************************************************************/
ULSTATUS UL_InitUart_16C95X(PINIT_UART pInitUart, PUART_OBJECT pFirstUart, PUART_OBJECT *ppUart)
{
	int Result = UL_STATUS_SUCCESS;
	*ppUart = pFirstUart;

	*ppUart = UL_CommonInitUart(pFirstUart);

	if (!(*ppUart))				/* check for mem alloc problems */
	{
		Result = UL_STATUS_INSUFFICIENT_RESOURCES;
		goto Error;		/* Memory allocation failed. */
	}

	if(!(*ppUart)->pUartData) 	/* Attach Uart Data */
	{
		if(!((*ppUart)->pUartData = (PUART_DATA_16C95X) UL_ALLOC_AND_ZERO_MEM(sizeof(UART_DATA_16C95X))))
		{
			Result = UL_STATUS_INSUFFICIENT_RESOURCES;
			goto Error;		/* Memory allocation failed. */
		}
	}
	
	(*ppUart)->UartNumber		= pInitUart->UartNumber;	/* Set the UART Number. */
	(*ppUart)->BaseAddress		= pInitUart->BaseAddress;	/* Set base address of the UART. */
	(*ppUart)->RegisterStride	= pInitUart->RegisterStride;	/* Set register stride of the UART. */
	(*ppUart)->ClockFreq		= pInitUart->ClockFreq;		/* Set clock frequency of the UART. */


	Result = UL_STATUS_SUCCESS;	/* Success */

	return Result;


/* InitUart Failed - so Clean up. */
Error:
	UL_DeInitUart_16C95X(*ppUart);	
	return Result;
}

/******************************************************************************
* DeInit a 16C95X UART
******************************************************************************/
void UL_DeInitUart_16C95X(PUART_OBJECT pUart)
{
	if(!pUart)
		return;

	if(pUart->pUartData)
	{
		UL_FREE_MEM(pUart->pUartData, sizeof(UART_DATA_16C95X));	/* Destroy the UART Data */
		pUart->pUartData = NULL;
	}

	UL_CommonDeInitUart(pUart);	/* Do Common DeInit UART */
}


/******************************************************************************
* Reset a 16C95X UART
******************************************************************************/
void UL_ResetUart_16C95X(PUART_OBJECT pUart)
{
	int i = 0;

	WRITE_INTERRUPT_ENABLE(pUart, 0x0);		/* Turn off interrupts. */
	WRITE_LINE_CONTROL(pUart, 0x0);			/* To ensure not 0xBF on 16C950 UART */
	WRITE_FIFO_CONTROL(pUart, 0x0);			/* Disable FIFO */
	WRITE_MODEM_CONTROL(pUart, 0x0);		/* Clear Modem Ctrl Lines. */
	WRITE_SCRATCH_PAD_REGISTER(pUart, 0x0);		/* Clear SPR */
	
	/* Resets Clock Select Register on 16C95X. */
	WRITE_TO_OX950_ICR(pUart, CKS, 0x0);	

	/* Soft Reset on 16C95X.	 */
	WRITE_TO_OX950_ICR(pUart, CSR, 0x0);	

	/* Reset internal UART library data and config structures */
	UL_ZERO_MEM(((PUART_DATA_16C95X)pUart->pUartData), sizeof(UART_DATA_16C95X));
	UL_ZERO_MEM(pUart->pUartConfig, sizeof(UART_CONFIG));	

	/* Reset UART Data Registers */
	((PUART_DATA_16C95X)pUart->pUartData)->CurrentACR = 0x0;
	((PUART_DATA_16C95X)pUart->pUartData)->ASRChanged = FALSE;

	/* Enable Enahnced mode - we must always do this or we are not a 16C95x. */
	WRITE_TO_16C650_REG(pUart, EFR, (BYTE)(READ_FROM_16C650_REG(pUart, EFR) | EFR_ENH_MODE));

	/* Ensure that clock prescaler is switched off */
	WRITE_MODEM_CONTROL(pUart, 0x0);		/* Clear Modem Ctrl Lines. */

	for(i=0; i<130; i++)
		READ_RECEIVE_BUFFER(pUart);
}

/******************************************************************************
* Verify the presence of a 16C95X UART
******************************************************************************/
ULSTATUS UL_VerifyUart_16C95X(PUART_OBJECT pUart)
{
	BYTE id1, id2, id3, rev;
	BYTE UART_Type = 0, UART_Rev = 0;
	DWORD UART_ID = 0;

	/* Reads the 950 ID registers and dumps the formated 
	   UART ID to the debug terminal if a 95x is detected 
	   Returns TRUE if a 95x device is found at the given 
	   address, otherwise FALSE */

	/* A good place to perform a channel reset so we know
	   the exact state of the device from here on */
	
	UL_ResetUart_16C95X(pUart);	/* Reset Port and Turn off interrupts. */

	id1 = READ_FROM_OX950_ICR(pUart, ID1);
	
	if(id1 == 0x16)
	{
		id2 = READ_FROM_OX950_ICR(pUart, ID2);
		id3 = READ_FROM_OX950_ICR(pUart, ID3);
		rev = READ_FROM_OX950_ICR(pUart, REV);

		UART_Type	= id3 & 0x0F;
		UART_Rev	= rev;
		UART_ID		= 0x16000000 + (id2 << 16) + (id3 << 8) + rev;
		
	  
		((PUART_DATA_16C95X)((pUart)->pUartData))->UART_Type = UART_Type;
		((PUART_DATA_16C95X)((pUart)->pUartData))->UART_Rev = UART_Rev;
		((PUART_DATA_16C95X)((pUart)->pUartData))->UART_ID = UART_ID;

		/* We can only support devices available at the time the driver was built */

		switch(UART_Type)
		{
		case UART_TYPE_950:
			if(UART_Rev > MAX_SUPPORTED_950_REV)
				goto Error;
			
			break;

		case UART_TYPE_952:
			if((UART_Rev < MIN_SUPPORTED_952_REV) || (UART_Rev > MAX_SUPPORTED_952_REV))
				goto Error;
			
			break;

		case UART_TYPE_954:
			if(UART_Rev > MAX_SUPPORTED_954_REV)
				goto Error;
			
			break;

		default:
			goto Error;
		}
	}
	else
		goto Error;


	((PUART_DATA_16C95X)((pUart)->pUartData))->Verified = TRUE;
	UL_ResetUart_16C95X(pUart);	/* Reset Port and Turn off interrupts. */

	return UL_STATUS_SUCCESS;


Error:
	return UL_STATUS_UNSUCCESSFUL;
}


/******************************************************************************
* Configure a 16C95X UART
******************************************************************************/
ULSTATUS UL_SetConfig_16C95X(PUART_OBJECT pUart, PUART_CONFIG pNewUartConfig, DWORD ConfigMask)
{
	if(ConfigMask & UC_FRAME_CONFIG_MASK)
	{
		BYTE Frame = 0x00;

		/* Set Data Bit Length */
		switch(pNewUartConfig->FrameConfig & UC_FCFG_DATALEN_MASK)
		{
		case UC_FCFG_DATALEN_6:
			Frame |= LCR_DATALEN_6;
			break;

		case UC_FCFG_DATALEN_7:
			Frame |= LCR_DATALEN_7;
			break;

		case UC_FCFG_DATALEN_8:
			Frame |= LCR_DATALEN_8;
			break;

		case UC_FCFG_DATALEN_5:
		default:
			break;
		}

		/* Set Number of Stop Bits */
		switch(pNewUartConfig->FrameConfig & UC_FCFG_STOPBITS_MASK)
		{
		case UC_FCFG_STOPBITS_1_5:
			Frame |= LCR_STOPBITS;
			break;

		case UC_FCFG_STOPBITS_2:
			Frame |= LCR_STOPBITS;
			break;

		case UC_FCFG_STOPBITS_1:
		default:
			break;
		}
		
		/* Set Parity Type */
		switch(pNewUartConfig->FrameConfig & UC_FCFG_PARITY_MASK)
		{
		case UC_FCFG_ODD_PARITY:
			Frame |= LCR_ODD_PARITY;
			break;

		case UC_FCFG_EVEN_PARITY:
			Frame |= LCR_EVEN_PARITY;
			break;

		case UC_FCFG_MARK_PARITY:
			Frame |= LCR_MARK_PARITY;
			break;

		case UC_FCFG_SPACE_PARITY:
			Frame |= LCR_SPACE_PARITY;
			break;

		case UC_FCFG_NO_PARITY:
		default:
			break;
		}		

		/* Configure UART. */
		WRITE_LINE_CONTROL(pUart, Frame);
		pUart->pUartConfig->FrameConfig = pNewUartConfig->FrameConfig;	/* Save config. */
	}


	/* Set Interrupts */
	if(ConfigMask & UC_INT_ENABLE_MASK)
	{
		BYTE IntEnable = 0x00;

		/* First check if both TX and TX Empty has been specified - we cannot have both. */
		if((pNewUartConfig->InterruptEnable & UC_IE_TX_INT) 
			&& (pNewUartConfig->InterruptEnable & UC_IE_TX_EMPTY_INT))
			return UL_STATUS_INVALID_PARAMETER;	

		if(pNewUartConfig->InterruptEnable & UC_IE_RX_INT)
			IntEnable |= IER_INT_RDA;
		
		if(pNewUartConfig->InterruptEnable & UC_IE_TX_INT) 
			IntEnable |= IER_INT_THR;
		
		if(pNewUartConfig->InterruptEnable & UC_IE_TX_EMPTY_INT)
		{
			IntEnable |= IER_INT_THR;

			if(((PUART_DATA_16C95X)((pUart)->pUartData))->FIFOEnabled)	/* If FIFO is enabled. */
			{
				WRITE_TO_OX950_ICR(pUart, TTL, 0);		/* Set Tx FIFO Trigger Level to Zero and save it. */
				((PUART_DATA_16C95X)((pUart)->pUartData))->TxFIFOTrigLevel = (BYTE) 0;
			}
		}

		if(pNewUartConfig->InterruptEnable & UC_IE_RX_STAT_INT) 
		{
			IntEnable |= IER_INT_RLS;

#ifdef USE_HW_TO_DETECT_CHAR
			/* If Special char detection is enabled then turn on the interrupt */
			if(pUart->pUartConfig->SpecialMode & UC_SM_DETECT_SPECIAL_CHAR)
				IntEnable |= IER_SPECIAL_CHR;
#endif
		}


		if(pNewUartConfig->InterruptEnable & UC_IE_MODEM_STAT_INT) 
			IntEnable |= IER_INT_MS;

		WRITE_INTERRUPT_ENABLE(pUart, (BYTE)(READ_INTERRUPT_ENABLE(pUart) | IntEnable));
		pUart->pUartConfig->InterruptEnable = pNewUartConfig->InterruptEnable;	/* Save config. */

		/* If we are enabling some interrupts. */
		if(IntEnable)
			WRITE_MODEM_CONTROL(pUart, (BYTE)(READ_MODEM_CONTROL(pUart) | MCR_OUT2));	/* Enable Ints */
		else
			WRITE_MODEM_CONTROL(pUart, (BYTE)(READ_MODEM_CONTROL(pUart) & ~MCR_OUT2));	/* Disable Ints */

	}


	if(ConfigMask & UC_TX_BAUD_RATE_MASK)
	{
		WORD Divisor = CalculateBaudDivisor_95X(pUart, pNewUartConfig->TxBaud);

		if(Divisor > 0)
			WRITE_DIVISOR_LATCH(pUart, Divisor);
		else
			return UL_STATUS_UNSUCCESSFUL;

		pUart->pUartConfig->TxBaud = pNewUartConfig->TxBaud;	/* Save config. */
		pUart->pUartConfig->RxBaud = pNewUartConfig->RxBaud;	/* Rx baudrate will always be the same as the Tx Baudrate. */
	}


	/* Configure Flow Control Settings */
	if(ConfigMask & UC_FLOW_CTRL_MASK)
	{
		/* This currently assumes FIFOs  */
		((PUART_DATA_16C95X)((pUart)->pUartData))->RTSToggle = FALSE;
		((PUART_DATA_16C95X)((pUart)->pUartData))->DSRSensitive = FALSE;

		/* Setup RTS out-of-band flow control */
		switch(pNewUartConfig->FlowControl & UC_FLWC_RTS_FLOW_MASK)
		{
		case UC_FLWC_RTS_HS:
			/* Enable automatic RTS flow control */
			WRITE_TO_16C650_REG(pUart, EFR, (BYTE)(READ_FROM_16C650_REG(pUart, EFR) | EFR_RTS_FC));
			WRITE_MODEM_CONTROL(pUart, (BYTE)(READ_MODEM_CONTROL(pUart) | MCR_SET_RTS));	/* Set RTS */
			break;

		case UC_FLWC_RTS_TOGGLE:
			((PUART_DATA_16C95X)((pUart)->pUartData))->RTSToggle = TRUE;
			WRITE_TO_16C650_REG(pUart, EFR, (BYTE)(READ_FROM_16C650_REG(pUart, EFR) & ~EFR_RTS_FC));
			break;

		case UC_FLWC_NO_RTS_FLOW:		
		default:
			/* Disable automatic RTS flow control */
			WRITE_TO_16C650_REG(pUart, EFR, (BYTE)(READ_FROM_16C650_REG(pUart, EFR) & ~EFR_RTS_FC));
			break;
		}


		/* Setup CTS out-of-band flow control */
		switch(pNewUartConfig->FlowControl & UC_FLWC_CTS_FLOW_MASK)
		{
		case UC_FLWC_CTS_HS:
			/* Enable automatic CTS flow control */
			WRITE_TO_16C650_REG(pUart, EFR, (BYTE)(READ_FROM_16C650_REG(pUart, EFR) | EFR_CTS_FC));
			break;

		case UC_FLWC_NO_CTS_FLOW:		
		default:
			/* Disable automatic CTS flow control */
			WRITE_TO_16C650_REG(pUart, EFR, (BYTE)(READ_FROM_16C650_REG(pUart, EFR) & ~EFR_CTS_FC));
			break;
		}

		/* Setup DSR out-of-band flow control */
		switch(pNewUartConfig->FlowControl & UC_FLWC_DSR_FLOW_MASK)
		{
		case UC_FLWC_DSR_HS:
			WRITE_TO_OX950_ICR(pUart, ACR, (BYTE)(READ_FROM_OX950_ICR(pUart, ACR) | ACR_DSR_FC));
			break;

		case UC_FLWC_NO_DSR_FLOW:
		default:
			WRITE_TO_OX950_ICR(pUart, ACR, (BYTE)(READ_FROM_OX950_ICR(pUart, ACR) & ~ACR_DSR_FC));
			break;
		}

		/* Setup DTR out-of-band flow control */
		switch(pNewUartConfig->FlowControl & UC_FLWC_DTR_FLOW_MASK)
		{
		case UC_FLWC_DTR_HS:
			WRITE_TO_OX950_ICR(pUart, ACR, (BYTE)(READ_FROM_OX950_ICR(pUart, ACR) | ACR_DTR_FC));
			WRITE_MODEM_CONTROL(pUart, (BYTE)(READ_MODEM_CONTROL(pUart) | MCR_SET_DTR));	/* Set DTR */
			break;

		case UC_FLWC_DSR_IP_SENSITIVE:
			((PUART_DATA_16C95X)((pUart)->pUartData))->DSRSensitive = TRUE;
			WRITE_TO_OX950_ICR(pUart, ACR, (BYTE)(READ_FROM_OX950_ICR(pUart, ACR) & ~ACR_DTR_FC));
			break;

		case UC_FLWC_NO_DTR_FLOW:
		default:
			WRITE_TO_OX950_ICR(pUart, ACR, (BYTE)(READ_FROM_OX950_ICR(pUart, ACR) & ~ACR_DTR_FC));
			break;
		}

		/* Setup Transmit XON/XOFF in-band flow control */
		/* 10.11.1999 ARG - ESIL 0928 */
		/* Modified each case functionality to set the correct bits in EFR & MCR */
		switch (pNewUartConfig->FlowControl & UC_FLWC_TX_XON_XOFF_FLOW_MASK)
		{
		case UC_FLWC_TX_XON_XOFF_FLOW:
			WRITE_TO_16C650_REG(pUart, EFR, (BYTE)(READ_FROM_16C650_REG(pUart, EFR) | EFR_TX_XON_XOFF_1));
			WRITE_MODEM_CONTROL(pUart, (BYTE)(READ_MODEM_CONTROL(pUart) & ~MCR_XON_ANY));
			break;

		case UC_FLWC_TX_XONANY_XOFF_FLOW:
			WRITE_TO_16C650_REG(pUart, EFR, (BYTE)(READ_FROM_16C650_REG(pUart, EFR) | EFR_TX_XON_XOFF_1));
			WRITE_MODEM_CONTROL(pUart, (BYTE)(READ_MODEM_CONTROL(pUart) | MCR_XON_ANY));
			break;

		case UC_FLWC_TX_NO_XON_XOFF_FLOW:
		default:
			WRITE_TO_16C650_REG(pUart, EFR, (BYTE)(READ_FROM_16C650_REG(pUart, EFR) & ~(EFR_TX_XON_XOFF_1 | EFR_TX_XON_XOFF_2)));
			WRITE_MODEM_CONTROL(pUart, (BYTE)(READ_MODEM_CONTROL(pUart) & ~MCR_XON_ANY));
			break;
		}

		/* Setup Receive XON/XOFF in-band flow control */
		/* 10.11.1999 ARG - ESIL 0928 */
		/* Remove XON-ANY case as not a UART feature */
		/* Modified remaining cases to NOT touch the MCR */
		switch(pNewUartConfig->FlowControl & UC_FLWC_RX_XON_XOFF_FLOW_MASK)
		{
		case UC_FLWC_RX_XON_XOFF_FLOW:
			WRITE_TO_16C650_REG(pUart, EFR, (BYTE)(READ_FROM_16C650_REG(pUart, EFR) | EFR_RX_XON_XOFF_1));
			break;

		case UC_FLWC_RX_NO_XON_XOFF_FLOW:
		default:
			WRITE_TO_16C650_REG(pUart, EFR, (BYTE)(READ_FROM_16C650_REG(pUart, EFR) & ~(EFR_RX_XON_XOFF_1 | EFR_RX_XON_XOFF_2)));
			break;
		}


		/* Disable/Enable Transmitter or Rerceivers */
		switch(pNewUartConfig->FlowControl & UC_FLWC_DISABLE_TXRX_MASK)
		{
		case UC_FLWC_DISABLE_TX:
			WRITE_TO_OX950_ICR(pUart, ACR, (BYTE)(READ_FROM_OX950_ICR(pUart, ACR) | ACR_DISABLE_TX));
			WRITE_TO_OX950_ICR(pUart, ACR, (BYTE)(READ_FROM_OX950_ICR(pUart, ACR) & ~ACR_DISABLE_RX));
			break;

		case UC_FLWC_DISABLE_RX:
			WRITE_TO_OX950_ICR(pUart, ACR, (BYTE)(READ_FROM_OX950_ICR(pUart, ACR) & ~ACR_DISABLE_TX));
			WRITE_TO_OX950_ICR(pUart, ACR, (BYTE)(READ_FROM_OX950_ICR(pUart, ACR) | ACR_DISABLE_RX));
			break;

		case UC_FLWC_DISABLE_TXRX:
			WRITE_TO_OX950_ICR(pUart, ACR, (BYTE)(READ_FROM_OX950_ICR(pUart, ACR) | ACR_DISABLE_TX));
			WRITE_TO_OX950_ICR(pUart, ACR, (BYTE)(READ_FROM_OX950_ICR(pUart, ACR) | ACR_DISABLE_RX));
			break;

		default:
			WRITE_TO_OX950_ICR(pUart, ACR, (BYTE)(READ_FROM_OX950_ICR(pUart, ACR) & ~ACR_DISABLE_RX));
			WRITE_TO_OX950_ICR(pUart, ACR, (BYTE)(READ_FROM_OX950_ICR(pUart, ACR) & ~ACR_DISABLE_TX));
			break;
		}

		pUart->pUartConfig->FlowControl = pNewUartConfig->FlowControl;	/* Save config. */
	}



	/* Configure threshold Settings */
	if(ConfigMask & UC_FC_THRESHOLD_SETTING_MASK)
	{
		/* To do flow control in hardware the thresholds must be less than the FIFO size. */
		if(pNewUartConfig->HiFlowCtrlThreshold > MAX_95X_TX_FIFO_SIZE)
			pNewUartConfig->HiFlowCtrlThreshold = DEFAULT_95X_HI_FC_TRIG_LEVEL;	/* = 75% of FIFO */

		if(pNewUartConfig->LoFlowCtrlThreshold > MAX_95X_TX_FIFO_SIZE)
			pNewUartConfig->LoFlowCtrlThreshold = DEFAULT_95X_LO_FC_TRIG_LEVEL;	/* = 25% of FIFO */

		/* Upper handshaking threshold */
		WRITE_TO_OX950_ICR(pUart, FCH, (BYTE)pNewUartConfig->HiFlowCtrlThreshold);
		pUart->pUartConfig->HiFlowCtrlThreshold = pNewUartConfig->HiFlowCtrlThreshold;	/* Save config. */
	
		/* Lower handshaking threshold */
		WRITE_TO_OX950_ICR(pUart, FCL, (BYTE)pNewUartConfig->LoFlowCtrlThreshold);
		pUart->pUartConfig->LoFlowCtrlThreshold = pNewUartConfig->LoFlowCtrlThreshold;	/* Save config. */
	}

	/* Configure Special Character Settings */
	if(ConfigMask & UC_SPECIAL_CHARS_MASK)
	{
		/* Set default XON & XOFF chars. */
		WRITE_TO_16C650_REG(pUart, XON1, (BYTE)pNewUartConfig->XON);		
		pUart->pUartConfig->XON = pNewUartConfig->XON;		/* Save config. */
		
		WRITE_TO_16C650_REG(pUart, XOFF1, (BYTE)pNewUartConfig->XOFF);
		pUart->pUartConfig->XOFF = pNewUartConfig->XOFF;	/* Save config. */

#ifdef USE_HW_TO_DETECT_CHAR
		WRITE_TO_16C650_REG(pUart, XOFF2, (BYTE)pNewUartConfig->SpecialCharDetect);
#endif
		pUart->pUartConfig->SpecialCharDetect = pNewUartConfig->SpecialCharDetect;	/* Save config. */
	}

	/* Set any special mode */
	if(ConfigMask & UC_SPECIAL_MODE_MASK)
	{
		if(pNewUartConfig->SpecialMode & UC_SM_LOOPBACK_MODE)
			WRITE_MODEM_CONTROL(pUart, (BYTE)(READ_MODEM_CONTROL(pUart) | MCR_LOOPBACK));
		else
			WRITE_MODEM_CONTROL(pUart, (BYTE)(READ_MODEM_CONTROL(pUart) & ~MCR_LOOPBACK));

		if(pNewUartConfig->SpecialMode & UC_SM_LOW_POWER_MODE)
			WRITE_INTERRUPT_ENABLE(pUart, (BYTE)(READ_INTERRUPT_ENABLE(pUart) | IER_SLEEP_EN));
		else
			WRITE_INTERRUPT_ENABLE(pUart, (BYTE)(READ_INTERRUPT_ENABLE(pUart) & ~IER_SLEEP_EN));

#ifdef USE_HW_TO_DETECT_CHAR
		if(pNewUartConfig->SpecialMode & UC_SM_DETECT_SPECIAL_CHAR)
		{
			WRITE_TO_16C650_REG(pUart, EFR, (BYTE)(READ_FROM_16C650_REG(pUart, EFR) | EFR_SPECIAL_CHR));
			
			/* If receive status interrupts are enabled then we will enable the special char interrupt */
			if(pUart->pUartConfig->InterruptEnable & UC_IE_RX_STAT_INT) 
				WRITE_INTERRUPT_ENABLE(pUart, (BYTE)(READ_INTERRUPT_ENABLE(pUart) | IER_SPECIAL_CHR));
		}
		else
		{
			WRITE_TO_16C650_REG(pUart, EFR, (BYTE)(READ_FROM_16C650_REG(pUart, EFR) & ~EFR_SPECIAL_CHR));
			
			/* If receive status interrupts are enabled then we will disable the special char interrupt */
			if(pUart->pUartConfig->InterruptEnable & UC_IE_RX_STAT_INT) 
				WRITE_INTERRUPT_ENABLE(pUart, (BYTE)(READ_INTERRUPT_ENABLE(pUart) & ~IER_SPECIAL_CHR));
		}
#endif

		if(pNewUartConfig->SpecialMode & UC_SM_TX_BREAK)
			WRITE_LINE_CONTROL(pUart, (BYTE)(READ_LINE_CONTROL(pUart) | LCR_TX_BREAK));
		else
		{
			/* if the break was on */ 
			if(pUart->pUartConfig->SpecialMode & UC_SM_TX_BREAK)
			{
				/* Clear the break */
				WRITE_LINE_CONTROL(pUart, (BYTE)(READ_LINE_CONTROL(pUart) & ~LCR_TX_BREAK));
			}
		}

		if(pNewUartConfig->SpecialMode & UC_SM_DO_NULL_STRIPPING)
			((PUART_DATA_16C95X)((pUart)->pUartData))->StripNULLs = TRUE;
		else
			((PUART_DATA_16C95X)((pUart)->pUartData))->StripNULLs = FALSE;

		pUart->pUartConfig->SpecialMode = pNewUartConfig->SpecialMode;	/* Save config. */
	}

	return UL_STATUS_SUCCESS;
}




/******************************************************************************
* Control Buffers on a 16C95X UART
******************************************************************************/
ULSTATUS UL_BufferControl_16C95X(PUART_OBJECT pUart, PVOID pBufferControl, int Operation, DWORD Flags)
{
	switch(Operation)
	{
	case UL_BC_OP_FLUSH:	/* If this is a flush operation */
		{
			if(Flags & UL_BC_BUFFER) /* flush Buffers? */
			{
				if(Flags & UL_BC_IN)
				{	
					pUart->InBuf_ipos = 0;
					pUart->InBuf_opos = 0;
					pUart->InBufBytes = 0;

					/* If Rx interrupts are or were enabled */
					if(pUart->pUartConfig->InterruptEnable & UC_IE_RX_INT) 
					{
						/* If the Rx interrupt is disabled then it must be because the buffer got full */
						if(!(READ_INTERRUPT_ENABLE(pUart) & IER_INT_RDA))
						{
							/* Re-enable Rx Interrupts */
							WRITE_INTERRUPT_ENABLE(pUart, (BYTE)(READ_INTERRUPT_ENABLE(pUart) | IER_INT_RDA));
						}
					}
				}

				if(Flags & UL_BC_OUT)
				{
					pUart->pOutBuf = NULL;
					pUart->OutBufSize = 0;
					pUart->OutBuf_pos = 0;
				}
			}

			if(Flags & UL_BC_FIFO)	/* flush FIFOs? */
			{
				if(Flags & UL_BC_IN)
					WRITE_FIFO_CONTROL(pUart, (BYTE)(READ_FIFO_CONTROL(pUart) | FCR_FLUSH_RX_FIFO));
				
				if(Flags & UL_BC_OUT)
					WRITE_FIFO_CONTROL(pUart, (BYTE)(READ_FIFO_CONTROL(pUart) | FCR_FLUSH_TX_FIFO));
			}

			break;
		}

	case UL_BC_OP_SET:
		{
			PSET_BUFFER_SIZES pBufferSizes = (PSET_BUFFER_SIZES) pBufferControl;

			if(Flags & UL_BC_BUFFER) /* Set Buffers? */
			{
				if(Flags & UL_BC_IN)
				{	
					PBYTE tmpPtr = NULL;

					if(pBufferSizes->pINBuffer != pUart->pInBuf)	/* if there was already a buffer allocated then.. */
					{
						if(pBufferSizes->pINBuffer == NULL)	/* freeing the IN buffer */
						{
							pBufferSizes->pINBuffer = pUart->pInBuf;	/* pass back a pointer to the current in buffer */
							pUart->pInBuf = NULL;
							pUart->InBufSize = 0;
							pUart->InBuf_ipos = 0;	/* Reset buffer pointers */
							pUart->InBuf_opos = 0;
							pUart->InBufBytes = 0;
						}
						else
						{
							if(pUart->pInBuf == NULL)	/* using a new buffer */
							{
								pUart->pInBuf = pBufferSizes->pINBuffer;
								pUart->InBufSize = pBufferSizes->INBufferSize;	/* Set IN buffer size. */
								pUart->InBuf_ipos = 0;	/* Reset buffer pointers */
								pUart->InBuf_opos = 0;
								pUart->InBufBytes = 0;
							}
							else		/* exchanging for a larger buffer */
							{
								DWORD Copy1 = 0, Copy2 = 0;
								tmpPtr = pUart->pInBuf;

								/* If there is data in the buffer - copy it into the new buffer */
								if((pUart->InBufBytes) && (pUart->InBufSize <= pBufferSizes->INBufferSize))
								{
									/* Get total amount that can be read in one or two read operations. */
									if(pUart->InBuf_opos < pUart->InBuf_ipos)
									{
										Copy1 = pUart->InBuf_ipos - pUart->InBuf_opos;
										Copy2 = 0;
									}
									else
									{
										Copy1 = pUart->InBufSize - pUart->InBuf_opos;
										Copy2 = pUart->InBuf_ipos;
									}

									if(Copy1)
										UL_COPY_MEM(pBufferSizes->pINBuffer, (pUart->pInBuf + pUart->InBuf_opos), Copy1);

									if(Copy2)
										UL_COPY_MEM((pBufferSizes->pINBuffer + Copy1), (pUart->pInBuf), Copy2);
								}

								pUart->InBuf_ipos = Copy1 + Copy2;	/* Reset buffer pointers */
								pUart->InBuf_opos = 0;
								
								pUart->pInBuf = pBufferSizes->pINBuffer;
								pUart->InBufSize = pBufferSizes->INBufferSize;	/* Set IN buffer size. */
								
								/* If Rx interrupts are or were enabled */
								if(pUart->pUartConfig->InterruptEnable & UC_IE_RX_INT) 
								{
									/* If the Rx interrupt is disabled then it must be because the buffer got full */
									if(!(READ_INTERRUPT_ENABLE(pUart) & IER_INT_RDA))
									{
										/* When the buffer is less than 3/4 full */
										if(pUart->InBufBytes < ((3*(pUart->InBufSize>>2)) + (pUart->InBufSize>>4)))
										{
											/* Re-enable Rx Interrupts */
											WRITE_INTERRUPT_ENABLE(pUart, (BYTE)(READ_INTERRUPT_ENABLE(pUart) | IER_INT_RDA));
										}
									}
								}

								pBufferSizes->pINBuffer = tmpPtr;	/* pass back a pointer to the old buffer */

							}

						}

					}


				}

				/* We cannot set an OUT buffer so we just reset the pointer */
				if(Flags & UL_BC_OUT)
				{
					pUart->pOutBuf = NULL;
					pUart->OutBufSize = 0;
					pUart->OutBuf_pos = 0;
				}
			}

			if((Flags & UL_BC_FIFO) && (Flags & (UL_BC_OUT | UL_BC_IN)))	/* on TX or Rx FIFOs? */
			{
				if(Flags & UL_BC_OUT)	/* Set the transmit interrupt trigger level */
				{
					/* Check Tx FIFO size is not greater than the maximum. */
					if(pBufferSizes->TxFIFOSize > MAX_95X_TX_FIFO_SIZE) 
						return UL_STATUS_INVALID_PARAMETER;

					/* If a Tx interrupt has been enabled then disable it */
					if(pUart->pUartConfig->InterruptEnable & (UC_IE_TX_INT | UC_IE_TX_EMPTY_INT)) 
						WRITE_INTERRUPT_ENABLE(pUart, (BYTE)(READ_INTERRUPT_ENABLE(pUart) & ~IER_INT_THR));

					/* Save the Tx FIFO size. */
					((PUART_DATA_16C95X)((pUart)->pUartData))->TxFIFOSize = (BYTE) pBufferSizes->TxFIFOSize;	

					/* If the UART is configured for a TX Empty Interrupt - set Tx Trig Level to 0. */
					if(pUart->pUartConfig->InterruptEnable & UC_IE_TX_EMPTY_INT)
						pBufferSizes->TxFIFOTrigLevel = 0;

					/* Setup TTL then enable 950 Trigger level */
					WRITE_TO_OX950_ICR(pUart, TTL, pBufferSizes->TxFIFOTrigLevel);

					/* Save away trigger level set. */
					((PUART_DATA_16C95X)((pUart)->pUartData))->TxFIFOTrigLevel = (BYTE)pBufferSizes->TxFIFOTrigLevel;

					/* If a Tx interrupt was enabled then re-enable it */
					if(pUart->pUartConfig->InterruptEnable & (UC_IE_TX_INT | UC_IE_TX_EMPTY_INT)) 
						WRITE_INTERRUPT_ENABLE(pUart, (BYTE)(READ_INTERRUPT_ENABLE(pUart) | IER_INT_THR));

				}

				if(Flags & UL_BC_IN)	/* Set the receive interrupt trigger level */
				{
					/* The Rx FIFO size can only be 0 or 128 in size. */
					if((pBufferSizes->RxFIFOSize != 0) && (pBufferSizes->RxFIFOSize != MAX_95X_RX_FIFO_SIZE))
						return UL_STATUS_INVALID_PARAMETER;

					/* Save the Rx FIFO size. */
					((PUART_DATA_16C95X)((pUart)->pUartData))->RxFIFOSize = (BYTE) pBufferSizes->RxFIFOSize;	

					/* Setup RTL then enable 950 Trigger level */
					WRITE_TO_OX950_ICR(pUart, RTL, pBufferSizes->RxFIFOTrigLevel);

					/* Save away trigger level set. */
					((PUART_DATA_16C95X)((pUart)->pUartData))->RxFIFOTrigLevel = (BYTE)pBufferSizes->RxFIFOTrigLevel;
				}

				/* If Tx & Rx FIFO sizes are zero then disable FIFOs. */
				if((pBufferSizes->TxFIFOSize == 0) && (pBufferSizes->RxFIFOSize == 0))
				{
					/* Disable FIFOs */
					WRITE_FIFO_CONTROL(pUart, (BYTE)(READ_FIFO_CONTROL(pUart) & ~FCR_FIFO_ENABLE));
					((PUART_DATA_16C95X)((pUart)->pUartData))->FIFOEnabled = FALSE;
				}
				else
				{
					/* Enable FIFOs */
					WRITE_FIFO_CONTROL(pUart, (BYTE)(READ_FIFO_CONTROL(pUart) | FCR_FIFO_ENABLE));
					((PUART_DATA_16C95X)((pUart)->pUartData))->FIFOEnabled = TRUE;

					/* Enable 950 trigger levels. */
					WRITE_TO_OX950_ICR(pUart, ACR, (BYTE)(READ_FROM_OX950_ICR(pUart, ACR) | ACR_TRIG_LEV_EN));
				}

			}

			break;
		}

	case UL_BC_OP_GET:
		{
			PGET_BUFFER_STATE pBufferState = (PGET_BUFFER_STATE) pBufferControl;

			if(Flags & UL_BC_BUFFER) /* state of Buffers? */
			{
				if(Flags & UL_BC_IN)
					pBufferState->BytesInINBuffer = pUart->InBufBytes;

				if(Flags & UL_BC_OUT)
					pBufferState->BytesInOUTBuffer = pUart->OutBuf_pos;
			}

			

			if(Flags & UL_BC_FIFO) /* state of FIFOs? */
			{
				ENABLE_OX950_ASR(pUart);

				if(Flags & UL_BC_IN)
					pBufferState->BytesInRxFIFO = READ_BYTE_REG_95X(pUart, RFL);

				if(Flags & UL_BC_OUT)
					pBufferState->BytesInTxFIFO = READ_BYTE_REG_95X(pUart, TFL);

				DISABLE_OX950_ASR(pUart);
			}

			break;
		}

	default:
		goto Error;
	}


	return UL_STATUS_SUCCESS;

Error:
	return UL_STATUS_INVALID_PARAMETER;
}

/******************************************************************************
* Control Modem Signals on a 16C95X UART
******************************************************************************/
ULSTATUS UL_ModemControl_16C95X(PUART_OBJECT pUart, PDWORD pModemSignals, int Operation)
{
	BYTE ModemControl = READ_MODEM_CONTROL(pUart);	/* Read MCR */

	switch(Operation)
	{
	case UL_MC_OP_SET:			/* Set all signals with bits set & Clear all signals with bits not set */
		{
			if((*pModemSignals) & UL_MC_RTS)
				ModemControl |= MCR_SET_RTS;		/* Set RTS */
			else
				ModemControl &= ~MCR_SET_RTS;		/* Clear RTS */


			if((*pModemSignals) & UL_MC_DTR)
				ModemControl |= MCR_SET_DTR;		/* Set DTR */
			else
				ModemControl &= ~MCR_SET_DTR;		/* Clear DTR */

			WRITE_MODEM_CONTROL(pUart, ModemControl);		/* Write to MCR */
			break;
		}

	case UL_MC_OP_BIT_SET:		/* Set all output signals with bits set in DWORD */
		{
			if((*pModemSignals) & UL_MC_RTS)
				ModemControl |= MCR_SET_RTS;		/* Set RTS */

			if((*pModemSignals) & UL_MC_DTR)
				ModemControl |= MCR_SET_DTR;		/* Set DTR */

			WRITE_MODEM_CONTROL(pUart, ModemControl);		/* Write to MCR */
			break;
		}

	case UL_MC_OP_BIT_CLEAR:	/* Clear all output signals with bits set in DWORD */
		{
			if((*pModemSignals) & UL_MC_RTS)
				ModemControl &= ~MCR_SET_RTS;		/* Clear RTS */

			if((*pModemSignals) & UL_MC_DTR)
				ModemControl &= ~MCR_SET_DTR;		/* Clear DTR */

			WRITE_MODEM_CONTROL(pUart, ModemControl);		/* Write to MCR */
			break;
		}

	case UL_MC_OP_STATUS:		/* Return current status of all signals */
		{
			BYTE ModemStatus = READ_MODEM_STATUS(pUart);	/* Get Modem Status */
			*pModemSignals = 0;	/* Clear the DWORD */

			if(ModemControl & MCR_SET_RTS)
				*pModemSignals |= UL_MC_RTS;		/* Show RTS is set */

			if(ModemControl & MCR_SET_DTR)
				*pModemSignals |= UL_MC_DTR;		/* Show DTR is set */


			if(ModemStatus & MSR_CTS_CHANGE)
				*pModemSignals |= UL_MC_DELTA_CTS;		/* Show CTS has changed */

			if(ModemStatus & MSR_DSR_CHANGE)
				*pModemSignals |= UL_MC_DELTA_DSR;		/* Show DSR has changed */

			if(ModemStatus & MSR_RI_DROPPED)
				*pModemSignals |= UL_MC_TRAILING_RI_EDGE;	/* Show RI has changed */

			if(ModemStatus & MSR_DCD_CHANGE)
				*pModemSignals |= UL_MC_DELTA_DCD;		/* Show DCD has changed */

			
			if(ModemStatus & MSR_CTS)
				*pModemSignals |= UL_MC_CTS;			/* Show CTS is set */

			if(ModemStatus & MSR_DSR)
				*pModemSignals |= UL_MC_DSR;			/* Show DSR is set */

			if(ModemStatus & MSR_RI)
				*pModemSignals |= UL_MC_RI;				/* Show RI is set */

			if(ModemStatus & MSR_DCD)
				*pModemSignals |= UL_MC_DCD;			/* Show DCD is set */

			break;
		}

	default:
		goto Error;
		break;
	}


	return UL_STATUS_SUCCESS;

Error:
	return UL_STATUS_INVALID_PARAMETER;	/* Invalid Operation. */
}

/******************************************************************************
* Discover which interrupts are pending on a 16C95X UART.
******************************************************************************/
DWORD UL_IntsPending_16C95X(PUART_OBJECT *ppUart)
{
	BYTE Ints = 0;
	PUART_OBJECT pStartingUart = *ppUart;
	DWORD IntsPending = 0;	/* Clear current Ints Pending. */

	while(*ppUart)
	{
		Ints = READ_INTERRUPT_ID_REG(*ppUart);	/* Get the interrupts pending for the UART. */
		
		if(!(Ints & IIR_NO_INT_PENDING))	/* If an interrupt is pending */
		{
			/* Mask all the Interrupts we are interrested in. */
			Ints &= IIR_RX_STAT_MSK | IIR_RX_MSK | IIR_RXTO_MSK | IIR_TX_MSK | IIR_MODEM_MSK | IIR_S_CHR_MSK;
		
			switch(Ints)
			{
			/* Which type of interrupts are pending? */
			case IIR_RX_STAT_MSK:			/* Receiver Line Status Interrupt	(Level 1 - Highest) */
				IntsPending |= UL_IP_RX_STAT;
				break;

			case IIR_RX_MSK:			/* Received Data Available Interrupt	(Level 2a) */
				IntsPending |= UL_IP_RX;
				break;

			case IIR_RXTO_MSK:			/* Received Data Time Out Interrupt	(Level 2b) */
				IntsPending |= UL_IP_RXTO;
				break;

			case IIR_TX_MSK:			/* Transmitter Holding Empty Interrupt	(Level 3) */
				{
					if(((PUART_DATA_16C95X)((*ppUart)->pUartData))->FIFOEnabled	/* If FIFOs are enabled */
						&& ((PUART_DATA_16C95X)((*ppUart)->pUartData))->TxFIFOTrigLevel > 0)	/* And Tx Trigger Level is >0 */
						IntsPending |= UL_IP_TX;			/* We have a TX interrupt */
					else
						IntsPending |= UL_IP_TX_EMPTY;	/* Else we have a TX Empty interrupt. */
					
					break;
				}

			case IIR_MODEM_MSK:			/* Modem Status Interrupt		(Level 4).  */
				IntsPending |= UL_IP_MODEM;
				break;

#ifdef USE_HW_TO_DETECT_CHAR
			case IIR_S_CHR_MSK:			/* Special Char Detect Interrupt	(Level 5).  */
				IntsPending |= UL_IP_RX_STAT;	/* Make it into a UL_IP_RX_STAT interrupt */
				break;
#endif
			default:
				break;
			}

			if(IntsPending)		/* If we have found an interrupt we know how to service then  */
				return IntsPending;		/* Return pointer to UART. */
		}

		*ppUart = (*ppUart)->pNextUart;	/* Set pointer to point to next UART */

		if(*ppUart == pStartingUart)	/* If we have gone through all the UARTs in the list */
			*ppUart = NULL;		/* Exit loop. */
	}

	return 0;		/* If no more UARTs then finish. */
}


/******************************************************************************
* Get information on 16C95X UART
******************************************************************************/
void UL_GetUartInfo_16C95X(PUART_OBJECT pUart, PUART_INFO pUartInfo)
{
	pUartInfo->MaxTxFIFOSize = MAX_95X_TX_FIFO_SIZE;
	pUartInfo->MaxRxFIFOSize = MAX_95X_RX_FIFO_SIZE;

	pUartInfo->PowerManagement = TRUE;
	pUartInfo->IndependentRxBaud = FALSE;

	if(!((PUART_DATA_16C95X)((pUart)->pUartData))->Verified)
		UL_VerifyUart_16C95X(pUart);

	pUartInfo->UART_SubType = ((PUART_DATA_16C95X)((pUart)->pUartData))->UART_Type;
	pUartInfo->UART_Rev = ((PUART_DATA_16C95X)((pUart)->pUartData))->UART_Rev;
}

/******************************************************************************
* Output data to the UART FIFO
******************************************************************************/
int UL_OutputData_16C95X(PUART_OBJECT pUart)
{
	int NumBytes = 0;
	int BytesInBuffer = pUart->OutBufSize - pUart->OutBuf_pos;
	int SpaceInUART = 0;
	int i = 0;
	int BytesInFIFO = 0;

	if((!pUart->ImmediateBytes) && (!pUart->pOutBuf))	/* If no buffer of data to send then return 0. */
		return 0;	/* There would be zero byts in the buffer */


	if(((PUART_DATA_16C95X)((pUart)->pUartData))->FIFOEnabled)
	{
		ENABLE_OX950_ASR(pUart);
		
		BytesInFIFO = READ_BYTE_REG_95X(pUart, TFL);	/* Get number of bytes in FIFO */

		if(BytesInFIFO < ((PUART_DATA_16C95X)((pUart)->pUartData))->TxFIFOSize)
			SpaceInUART = ((PUART_DATA_16C95X)((pUart)->pUartData))->TxFIFOSize - BytesInFIFO;	
		else
			SpaceInUART = 0;

		DISABLE_OX950_ASR(pUart);
	}
	else
		SpaceInUART = 1;	/* If no FIFO then we can only send one byte. */

	/* If no space then we cannot send anything */
	if(!SpaceInUART)
		return (BytesInBuffer);


	/* Whilst we have some bytes to send immediatly */
	while((pUart->ImmediateBytes) && (i < UL_IM_SIZE_OF_BUFFER))
	{
		if(pUart->ImmediateBuf[i][UL_IM_SLOT_STATUS] == UL_IM_BYTE_TO_SEND)
		{
			WRITE_TRANSMIT_HOLDING(pUart, pUart->ImmediateBuf[i][UL_IM_SLOT_DATA]);
			pUart->ImmediateBuf[i][UL_IM_SLOT_STATUS] = UL_IM_NO_BYTE_TO_SEND;

			SpaceInUART--;
			pUart->ImmediateBytes--;

			if(!SpaceInUART)
				return (BytesInBuffer);	/* return number of byte left in OUT buffer */
		}

		i++; /* Goto next immediate byte slot */
	}


	/* If we still have room for more then send some not so urgent bytes */ 
	if(SpaceInUART < BytesInBuffer)
		NumBytes = SpaceInUART;
	else
		NumBytes = BytesInBuffer;

	if(NumBytes)
	{
		/* If we have data to send and we are doing RTS toggle then raise RTS. */
		if(((PUART_DATA_16C95X)((pUart)->pUartData))->RTSToggle)
			WRITE_MODEM_CONTROL(pUart, (BYTE)(READ_MODEM_CONTROL(pUart) | MCR_SET_RTS));		/* Set RTS */

		for(i = 0; i < NumBytes; i++)
			WRITE_TRANSMIT_HOLDING(pUart, *(pUart->pOutBuf + pUart->OutBuf_pos + i));
	
		pUart->OutBuf_pos += NumBytes;	/* Move buffer position pointer. */

		if(NumBytes == BytesInBuffer)		/* If we sent the entire buffer then */
		{
			pUart->pOutBuf = NULL;		/* Reset Out buffer pointer as we are finished with this one. */
			pUart->OutBufSize = 0;		/* Reset Out buffer size */
			pUart->OutBuf_pos = 0;		/* Reset */

			/* If we have sent all data and we are doing RTS toggle then lower RTS. */
			if(((PUART_DATA_16C95X)((pUart)->pUartData))->RTSToggle)
				WRITE_MODEM_CONTROL(pUart, (BYTE)(READ_MODEM_CONTROL(pUart) & ~MCR_SET_RTS));	/* Clear RTS */
		}
	}

	return (BytesInBuffer - NumBytes);	/* return number of byte left in buffer */
}

/******************************************************************************
* Input data from the UART FIFO
******************************************************************************/
int UL_InputData_16C95X(PUART_OBJECT pUart, PDWORD pRxStatus)
{
	int BytesInUART = 0;
	int BytesReceived = 0;
	BYTE NewByte;

	*pRxStatus = 0;


	/* If FIFO then... */
	if(((PUART_DATA_16C95X)((pUart)->pUartData))->FIFOEnabled)
	{
		ENABLE_OX950_ASR(pUart);
		BytesInUART = READ_BYTE_REG_95X(pUart, RFL);	/* Get the amount from UART */
		DISABLE_OX950_ASR(pUart);
	}
	else
	{
		if(READ_LINE_STATUS(pUart) & LSR_RX_DATA)	/* if there is a byte to receive */
			BytesInUART = 1;	
	}

	if(BytesInUART == 0)	/* If no data in Rx FIFO or holding register */ 
	{
		/* If we are running this because we have interrupts enabled then */
		if(pUart->pUartConfig->InterruptEnable & UC_IE_RX_INT)
			READ_RECEIVE_BUFFER(pUart);		/* Clear the reason for the interrupt */

		return 0;	/* nothing to receive so return */
	}

	if((pUart->InBufSize - pUart->InBufBytes) == 0)	/* If no space then we cannot receive anything. */
	{
		/* We have data in the UART that needs to be taken out and we have no where to put it */
		*pRxStatus |= UL_RS_BUFFER_OVERRUN;	

		/* Turn off Rx interrupts until there is room in the buffer */
		WRITE_INTERRUPT_ENABLE(pUart, (BYTE)(READ_INTERRUPT_ENABLE(pUart) & ~IER_INT_RDA));
		return 0;	
	}

	/* Bytes in UART to receive */
	while(BytesInUART)
	{
			if(pUart->InBufSize - pUart->InBufBytes) /* if there is space in buffer then receive the data */ 
			{
				NewByte = READ_RECEIVE_BUFFER(pUart);

				/* If we are doing DSR sensitive then check if DSR is low. */
				if(((PUART_DATA_16C95X)((pUart)->pUartData))->DSRSensitive)
				{
					/* if DSR is low then get the data but just throw the data away */ 
					if(!(READ_MODEM_STATUS(pUart) & MSR_DSR))
					{
						BytesInUART--;
						continue;
					}	/* else if DSR is high then receive normally */
				}

				if(((PUART_DATA_16C95X)((pUart)->pUartData))->StripNULLs)	/* If we are stripping NULLs  */
				{
					if(NewByte == 0)		/* If new byte is NULL just ignore it */
					{
						BytesInUART--;
						continue;
					}	/* else receive normally */
				}

#ifndef USE_HW_TO_DETECT_CHAR
				if(pUart->pUartConfig->SpecialMode & UC_SM_DETECT_SPECIAL_CHAR)
				{
					if(NewByte == pUart->pUartConfig->SpecialCharDetect)
						*pRxStatus |= UL_RS_SPECIAL_CHAR_DETECTED;
				}
#endif

				*(pUart->pInBuf + pUart->InBuf_ipos) = NewByte;	/* place byte in buffer */
				
				pUart->InBuf_ipos++;	/* Increment buffer offset for next byte */
				pUart->InBufBytes++;
				BytesInUART--;
				BytesReceived++;

				if(pUart->InBuf_ipos >= pUart->InBufSize)
					pUart->InBuf_ipos = 0;	/* reset. */
			}
			else
			{	/* We have data in the UART that needs to be taken out and we have no where to put it */
				*pRxStatus |= UL_RS_BUFFER_OVERRUN;	
				
				/* Turn off Rx interrupts until there is room in the buffer */
				WRITE_INTERRUPT_ENABLE(pUart, (BYTE)(READ_INTERRUPT_ENABLE(pUart) & ~IER_INT_RDA));
				break;
			}
	}


	return (BytesReceived);
}


/******************************************************************************
* Read from the UART Buffer
******************************************************************************/
int UL_ReadData_16C95X(PUART_OBJECT pUart, PBYTE pDest, int Size)
{
	int Read1;
	int Read2;

	if(!pUart->InBufBytes)
		return 0;	/* If there is nothing in the buffer then we can't read anything. */


	/* Get total amount that can be read in one or two read operations. */
	if(pUart->InBuf_opos < pUart->InBuf_ipos)
	{
		Read1 = pUart->InBuf_ipos - pUart->InBuf_opos;
		Read2 = 0;
	}
	else 
	{
		Read1 = pUart->InBufSize - pUart->InBuf_opos;
		Read2 = pUart->InBuf_ipos;
	}


	/* Check if size is big enough else adjust values to read as much as we can. */
	if(Read1 > Size)
	{
		Read1 = Size;
		Read2 = 0;
	}
	else
	{
		if((Read1 + Read2) > Size)
			Read2 = Size - Read1;
	}

	if(Read1)
	{
		UL_COPY_MEM(pDest, (pUart->pInBuf + pUart->InBuf_opos), Read1);
		pUart->InBuf_opos += Read1;
		pUart->InBufBytes -= Read1;
		
		if(pUart->InBuf_opos >= pUart->InBufSize)
			pUart->InBuf_opos = 0;	/* Reset. */
	}

	if(Read2)
	{
		UL_COPY_MEM((pDest + Read1), (pUart->pInBuf + pUart->InBuf_opos), Read2);
		pUart->InBuf_opos += Read2;
		pUart->InBufBytes -= Read2;
	}


	/* If Rx interrupts are or were enabled */
	if(pUart->pUartConfig->InterruptEnable & UC_IE_RX_INT) 
	{
		/* If the Rx interrupt is disabled then it must be because the buffer got full */
		if(!(READ_INTERRUPT_ENABLE(pUart) & IER_INT_RDA))
		{
			/* When the buffer is less than 3/4 full */
			if(pUart->InBufBytes < ((3*(pUart->InBufSize>>2)) + (pUart->InBufSize>>4)))
			{
				/* Re-enable Rx Interrupts */
				WRITE_INTERRUPT_ENABLE(pUart, (BYTE)(READ_INTERRUPT_ENABLE(pUart) | IER_INT_RDA));
			}
		}
	}


	return (Read1 + Read2);
}

/******************************************************************************
* Write to the UART Buffer
******************************************************************************/
ULSTATUS UL_WriteData_16C95X(PUART_OBJECT pUart, PBYTE pData, int Size)
{
	if((pUart->pOutBuf != NULL) || (pData == NULL) || (Size == 0))
		return UL_STATUS_UNSUCCESSFUL;

	pUart->pOutBuf = pData;
	pUart->OutBufSize = Size;
	pUart->OutBuf_pos = 0;

	/* If a Tx interrupt has been enabled and there isn't an immediate write in progress then */
	if((pUart->pUartConfig->InterruptEnable & (UC_IE_TX_INT | UC_IE_TX_EMPTY_INT)) 
		&& (pUart->ImmediateBytes == 0))
	{
		/* Now lets generate a Tx Interrupt */

		/* Disable Tx Interrupt */
		WRITE_INTERRUPT_ENABLE(pUart, (BYTE)(READ_INTERRUPT_ENABLE(pUart) & ~IER_INT_THR));

		/* Enable Tx Interrupt */
		WRITE_INTERRUPT_ENABLE(pUart, (BYTE)(READ_INTERRUPT_ENABLE(pUart) | IER_INT_THR));
	}

	return Size;
}

/******************************************************************************
* Write/Cancel immediate byte.
******************************************************************************/
ULSTATUS UL_ImmediateByte_16C95X(PUART_OBJECT pUart, PBYTE pData, int Operation)
{
	switch(Operation)
	{

	case UL_IM_OP_WRITE:	/* Write a byte */
		{
			BYTE i = 0;

			for(i = 0; i < UL_IM_SIZE_OF_BUFFER; i++)
			{
				/* If this is a free slot then write the byte */
				if(pUart->ImmediateBuf[i][UL_IM_SLOT_STATUS] == UL_IM_NO_BYTE_TO_SEND)
				{
					pUart->ImmediateBuf[i][UL_IM_SLOT_DATA] = *pData;
					pUart->ImmediateBuf[i][UL_IM_SLOT_STATUS] = UL_IM_BYTE_TO_SEND;

					pUart->ImmediateBytes++;

					/* If a Tx interrupt has been enabled and there isn't a write in progress then */
					if((pUart->pUartConfig->InterruptEnable & (UC_IE_TX_INT | UC_IE_TX_EMPTY_INT)) 
						&& (pUart->pOutBuf == NULL))
					{
						/* Now lets generate a Tx Interrupt */

						/* Disable Tx Interrupt */
						WRITE_INTERRUPT_ENABLE(pUart, (BYTE)(READ_INTERRUPT_ENABLE(pUart) & ~IER_INT_THR));

						/* Enable Tx Interrupt */
						WRITE_INTERRUPT_ENABLE(pUart, (BYTE)(READ_INTERRUPT_ENABLE(pUart) | IER_INT_THR));
					}
					
					*pData = i;		/* Pass back the index so the byte can be cancelled */


					return UL_STATUS_SUCCESS;	
				}
			}
			break;
		}

	case UL_IM_OP_CANCEL:
		{
			if(pUart->ImmediateBuf[*pData][UL_IM_SLOT_STATUS] == UL_IM_BYTE_TO_SEND)
			{
				pUart->ImmediateBuf[*pData][UL_IM_SLOT_STATUS] = UL_IM_NO_BYTE_TO_SEND;
				pUart->ImmediateBytes--;
				return UL_STATUS_SUCCESS;
			}
			break;
		}

	case UL_IM_OP_STATUS:
		{
			if(pUart->ImmediateBuf[*pData][UL_IM_SLOT_STATUS] == UL_IM_BYTE_TO_SEND)
				return UL_IM_BYTE_TO_SEND;
			else
				return UL_IM_NO_BYTE_TO_SEND;

			break;
		}

	default:
		return UL_STATUS_INVALID_PARAMETER;
		break;

	}


	/* If no space then we cannot send anything immediately. */
	return UL_STATUS_UNSUCCESSFUL;
}



/******************************************************************************
* Get status of UART.
******************************************************************************/
ULSTATUS UL_GetStatus_16C95X(PUART_OBJECT pUart, PDWORD pReturnData, int Operation)
{
	BYTE AdditionalStatusReg = 0;
	*pReturnData = 0;

	switch(Operation)
	{
	case UL_GS_OP_HOLDING_REASONS:
		{
			BYTE ModemStatus = READ_MODEM_STATUS(pUart);


			/* RTS out-of-band flow control */
			switch(pUart->pUartConfig->FlowControl & UC_FLWC_RTS_FLOW_MASK)
			{
			case UC_FLWC_RTS_HS:	
				break;

			case UC_FLWC_RTS_TOGGLE:
				break;

			case UC_FLWC_NO_RTS_FLOW:
			default:
				break;
			}

			/* CTS out-of-band flow control */
			switch(pUart->pUartConfig->FlowControl & UC_FLWC_CTS_FLOW_MASK)
			{
			case UC_FLWC_CTS_HS:
				if(!(ModemStatus & MSR_CTS))	/* If CTS is low we cannot transmit */
					*pReturnData |= UL_TX_WAITING_FOR_CTS;
				break;

			case UC_FLWC_NO_CTS_FLOW:		
			default:
				break;
			}
		

			/* DSR out-of-band flow control */
			switch(pUart->pUartConfig->FlowControl & UC_FLWC_DSR_FLOW_MASK)
			{
			case UC_FLWC_DSR_HS:
				if(!(ModemStatus & MSR_DSR)) 	/* If DSR is low we cannot transmit */
					*pReturnData |= UL_TX_WAITING_FOR_DSR;
				break;

			case UC_FLWC_NO_DSR_FLOW:
			default:
				break;
			}
		

			/* DTR out-of-band flow control */
			switch(pUart->pUartConfig->FlowControl & UC_FLWC_DTR_FLOW_MASK)
			{
			case UC_FLWC_DTR_HS:
				break;

			case UC_FLWC_DSR_IP_SENSITIVE:
				if(!(ModemStatus & MSR_DSR))	/* If DSR is low we cannot receive */
					*pReturnData |= UL_RX_WAITING_FOR_DSR;
				break;

			case UC_FLWC_NO_DTR_FLOW:
			default:
				break;
			}


			if(pUart->pUartConfig->FlowControl & (UC_FLWC_TX_XON_XOFF_FLOW_MASK | UC_FLWC_RX_XON_XOFF_FLOW_MASK))
			{
				ENABLE_OX950_ASR(pUart);
				AdditionalStatusReg = READ_BYTE_REG_95X(pUart, ASR);	/* Read Additional Status Register */
				DISABLE_OX950_ASR(pUart);

				/* Transmit XON/XOFF in-band flow control */
				switch(pUart->pUartConfig->FlowControl & UC_FLWC_TX_XON_XOFF_FLOW_MASK)
				{
				case UC_FLWC_TX_XON_XOFF_FLOW:
					if(AdditionalStatusReg & ASR_TX_DISABLED)
						*pReturnData |= UL_TX_WAITING_FOR_XON;
					break;

				case UC_FLWC_TX_XONANY_XOFF_FLOW:	
					if(AdditionalStatusReg & ASR_TX_DISABLED)
						*pReturnData |= UL_TX_WAITING_FOR_XON;
					break;

				case UC_FLWC_TX_NO_XON_XOFF_FLOW:
				default:
					break;
				}
			
				/* Receive XON/XOFF in-band flow control */
				switch(pUart->pUartConfig->FlowControl & UC_FLWC_RX_XON_XOFF_FLOW_MASK)
				{
				case UC_FLWC_RX_XON_XOFF_FLOW:
					if(AdditionalStatusReg & ASR_RTX_DISABLED)
						*pReturnData |= UL_TX_WAITING_XOFF_SENT;
					break;

				case UC_FLWC_RX_NO_XON_XOFF_FLOW:
				default:
					break;
				}
			}
	
		
			if(pUart->pUartConfig->SpecialMode & UC_SM_TX_BREAK)
				*pReturnData |= UL_TX_WAITING_ON_BREAK;

			break;
		}

	case UL_GS_OP_LINESTATUS:
		{
			BYTE LineStatus = READ_LINE_STATUS(pUart);
	
			if(LineStatus & LSR_ERR_OE)		/* Overrun Error */
				*pReturnData |= UL_US_OVERRUN_ERROR;

			if(LineStatus & LSR_ERR_PE)		/* Parity Error */
				*pReturnData |= UL_US_PARITY_ERROR;

			if(LineStatus & LSR_ERR_FE)		/* Framing Error. */
				*pReturnData |= UL_US_FRAMING_ERROR;

			if(LineStatus & LSR_ERR_BK)		/* Break Interrupt. */
				*pReturnData |= UL_US_BREAK_ERROR;

			if(LineStatus & LSR_ERR_DE)		/* Error In Receive FIFO. */
				*pReturnData |= UL_US_DATA_ERROR;
		
#ifdef USE_HW_TO_DETECT_CHAR
			/* if we are looking for a special char */
			if(pUart->pUartConfig->SpecialMode & UC_SM_DETECT_SPECIAL_CHAR)
			{
				ENABLE_OX950_ASR(pUart);
				AdditionalStatusReg = READ_BYTE_REG_95X(pUart, ASR);
				DISABLE_OX950_ASR(pUart);	
				
				/* Read Additional Status Register */
				if(AdditionalStatusReg & ASR_SPECIAL_CHR) /* Special char was detected */
					*pReturnData |= UL_RS_SPECIAL_CHAR_DETECTED;
			
			}
#endif
			break;
		}

	default:
		return UL_STATUS_INVALID_PARAMETER;
	}


	return UL_STATUS_SUCCESS;
}


/******************************************************************************
* Prints out UART registers.
******************************************************************************/
void UL_DumpUartRegs_16C95X(PUART_OBJECT pUart)
{
	UART_REGS_16C95X UartRegs;

	UartRegs.REG_RHR = READ_RECEIVE_BUFFER(pUart);
	UartRegs.REG_IER = READ_INTERRUPT_ENABLE(pUart);
	UartRegs.REG_FCR = READ_FIFO_CONTROL(pUart);
	UartRegs.REG_IIR = READ_INTERRUPT_ID_REG(pUart);
	UartRegs.REG_LCR = READ_LINE_CONTROL(pUart);
	UartRegs.REG_MCR = READ_MODEM_CONTROL(pUart);
	UartRegs.REG_LSR = READ_LINE_STATUS(pUart);
	UartRegs.REG_MSR = READ_MODEM_STATUS(pUart);
	UartRegs.REG_SPR = READ_SCRATCH_PAD_REGISTER(pUart);

	UartRegs.REG_EFR = READ_FROM_16C650_REG(pUart, EFR);
	UartRegs.REG_XON1 = READ_FROM_16C650_REG(pUart, XON1);
	UartRegs.REG_XON2 = READ_FROM_16C650_REG(pUart, XON2);
	UartRegs.REG_XOFF1 = READ_FROM_16C650_REG(pUart, XOFF1);
	UartRegs.REG_XOFF2 = READ_FROM_16C650_REG(pUart, XOFF2);

	ENABLE_OX950_ASR(pUart);
	UartRegs.REG_ASR = READ_BYTE_REG_95X(pUart, ASR);
	UartRegs.REG_RFL = READ_BYTE_REG_95X(pUart, RFL);
	UartRegs.REG_TFL = READ_BYTE_REG_95X(pUart, TFL);
	DISABLE_OX950_ASR(pUart);

	UartRegs.REG_ACR = READ_FROM_OX950_ICR(pUart, ACR);
	UartRegs.REG_CPR = READ_FROM_OX950_ICR(pUart, CPR);
	UartRegs.REG_TCR = READ_FROM_OX950_ICR(pUart, TCR);
	UartRegs.REG_TTL = READ_FROM_OX950_ICR(pUart, TTL);
	UartRegs.REG_RTL = READ_FROM_OX950_ICR(pUart, RTL);
	UartRegs.REG_FCL = READ_FROM_OX950_ICR(pUart, FCL);
	UartRegs.REG_FCH = READ_FROM_OX950_ICR(pUart, FCH);
	UartRegs.REG_ID1 = READ_FROM_OX950_ICR(pUart, ID1);
	UartRegs.REG_ID2 = READ_FROM_OX950_ICR(pUart, ID2);
	UartRegs.REG_ID3 = READ_FROM_OX950_ICR(pUart, ID3);
	UartRegs.REG_REV = READ_FROM_OX950_ICR(pUart, REV);


#ifdef SpxDbgPrint /* If a DebugPrint macro is defined then print the register contents */
	SpxDbgPrint(("16C95X UART REGISTER DUMP for UART at 0x%08lX\n", pUart->BaseAddress));
	SpxDbgPrint(("-------------------------------------------------\n"));
	SpxDbgPrint(("  RHR:			0x%02X\n", UartRegs.REG_RHR));
	SpxDbgPrint(("  IER:			0x%02X\n", UartRegs.REG_IER));
	SpxDbgPrint(("  FCR:			0x%02X\n", UartRegs.REG_FCR));
	SpxDbgPrint(("  IIR:			0x%02X\n", UartRegs.REG_IIR));
	SpxDbgPrint(("  LCR:			0x%02X\n", UartRegs.REG_LCR));
	SpxDbgPrint(("  MCR:			0x%02X\n", UartRegs.REG_MCR));
	SpxDbgPrint(("  LSR:			0x%02X\n", UartRegs.REG_LSR));
	SpxDbgPrint(("  MSR:			0x%02X\n", UartRegs.REG_MSR));
	SpxDbgPrint(("  SPR:			0x%02X\n", UartRegs.REG_SPR));

	SpxDbgPrint(("16C650 Compatible Registers...\n"));
	SpxDbgPrint(("-------------------------------------------------\n"));
	SpxDbgPrint(("  EFR:			0x%02X\n", UartRegs.REG_EFR));
	SpxDbgPrint(("  XON1:			0x%02X\n", UartRegs.REG_XON1));
	SpxDbgPrint(("  XON2:			0x%02X\n", UartRegs.REG_XON2));
	SpxDbgPrint(("  XOFF1:			0x%02X\n", UartRegs.REG_XOFF1));
	SpxDbgPrint(("  XOFF2:			0x%02X\n", UartRegs.REG_XOFF2));

	SpxDbgPrint(("Additional Status Regsiters...\n"));
	SpxDbgPrint(("-------------------------------------------------\n"));
	SpxDbgPrint(("  ASR:			0x%02X\n", UartRegs.REG_ASR));
	SpxDbgPrint(("  RFL:			0x%02X\n", UartRegs.REG_RFL));
	SpxDbgPrint(("  TFL:			0x%02X\n", UartRegs.REG_TFL));


	SpxDbgPrint(("Index Control Registers...\n"));
	SpxDbgPrint(("-------------------------------------------------\n"));
	SpxDbgPrint(("  ACR:			0x%02X\n", UartRegs.REG_ACR));
	SpxDbgPrint(("  CPR:			0x%02X\n", UartRegs.REG_CPR));
	SpxDbgPrint(("  TCR:			0x%02X\n", UartRegs.REG_TCR));
	SpxDbgPrint(("  TTL:			0x%02X\n", UartRegs.REG_TTL));
	SpxDbgPrint(("  RTL:			0x%02X\n", UartRegs.REG_RTL));
	SpxDbgPrint(("  FCL:			0x%02X\n", UartRegs.REG_FCL));
	SpxDbgPrint(("  FCH:			0x%02X\n", UartRegs.REG_FCH));
	SpxDbgPrint(("  ID1:			0x%02X\n", UartRegs.REG_ID1));
	SpxDbgPrint(("  ID2:			0x%02X\n", UartRegs.REG_ID2));
	SpxDbgPrint(("  ID3:			0x%02X\n", UartRegs.REG_ID3));
	SpxDbgPrint(("  REV:			0x%02X\n", UartRegs.REG_REV)); 
#endif

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\spx\speed\uartlib\inc\private\16cx5x.h ===
/******************************************************************************
*	
*	$Workfile: 16cx5x.h $ 
*
*	$Author: Golden $ 
*
*	$Revision: 6 $
* 
*	$Modtime: 10/11/99 14:21 $ 
*
*	Description: Contains private 16Cx9x UART family definitions.
*
******************************************************************************/
#if !defined(_16CX5X_H)		/* _16CX5X.H */
#define _16CX5X_H


/******************************************************************************
* UART REGISTERS 
******************************************************************************/
#define TRANSMIT_HOLDING_REGISTER		0x00	/* Write Only. */
#define RECEIVE_BUFFER_REGISTER			0x00	/* Read Only. */
#define DIVISOR_LATCH_LSB				0x00	/* Read/Write When DLAB is Set. */
#define DIVISOR_LATCH_MSB				0x01	/* Read/Write When DLAB is Set. */
#define INTERRUPT_ENABLE_REGISTER		0x01	/* Read/Write. */
#define FIFO_CONTROL_REGISTER			0x02	/* Write Only. */
#define INTERRUPT_IDENT_REGISTER		0x02	/* Read Only. */
#define LINE_CONTROL_REGISTER			0x03	/* Read/Write.	 */
#define MODEM_CONTROL_REGISTER			0x04	/* Read/Write. */
#define LINE_STATUS_REGISTER			0x05	/* Read Only. */
#define MODEM_STATUS_REGISTER			0x06	/* Read Only. */
#define SCRATCH_PAD_REGISTER			0x07	/* Read/Write. */


/******************************************************************************
* THR: Transmittter Holding Register - WRITE ONLY 
******************************************************************************/
#define THR					TRANSMIT_HOLDING_REGISTER

/******************************************************************************
* RBR: Receive Buffer Register - READ ONLY 
******************************************************************************/
#define RBR					RECEIVE_BUFFER_REGISTER


/******************************************************************************
* IER: Interrupt Enable Register - READ/WRITE 
******************************************************************************/
#define IER					INTERRUPT_ENABLE_REGISTER
#define IER_INT_RDA			0x01	/* Bit 0: Enable Receive Data Available Interrupt (RXRDY). */
#define IER_INT_THR			0x02	/* Bit 1: Enable Transmitter Holding Register Empty Interrupt (THRE). */
#define IER_INT_RLS			0x04	/* Bit 2: Enable Receiver Line Status Interrupt (RXSTAT). */
#define IER_INT_MS			0x08	/* Bit 3: Enable Modem Status Interrupt (MODEM). */
#define IER_SLEEP_EN		0x10	/* Bit 4: Enable Sleep Mode (16750+). */

#define IER_ALTSLEEP_EN		0x20	/* Bit 5: Enable Low Power Mode (16750+). */
#define IER_SPECIAL_CHR		0x20	/* Bit 5: Enable Level 5 Interupts - Special Char Detect (16950+ Enhanced Mode) */

#define IER_INT_RTS			0x40	/* Bit 6: Enable RTS Interrupt Mask (16950+  Enhanced Mode). */
#define IER_INT_CTS			0x80	/* Bit 7: Enable CTS Interrupt Mask (16950+  Enhanced Mode). */
	

/******************************************************************************
* FCR: FIFO Control Register - WRITE ONLY
******************************************************************************/
#define FCR					FIFO_CONTROL_REGISTER
#define FCR_FIFO_ENABLE		0x01	/* Bit 0: Enable FIFOs */
#define FCR_FLUSH_RX_FIFO	0x02	/* Bit 1: Clear Receive FIFO. */
#define FCR_FLUSH_TX_FIFO	0x04	/* Bit 2: Clear Transmit FIFO. */
#define FCR_DMA_MODE		0x08	/* Bit 3: DMA Mode Select. Change RXRDY & TXRDY Pins From Mode 1 to Mode 2. */

/* 16C950 - 650 Mode only.				 */
#define FCR_THR_TRIG_LEVEL_1	0x00	/* Bits 4:5 - Set Transmit FIFO Trigger Level to 16 Bytes in 650 mode. */
#define FCR_THR_TRIG_LEVEL_2	0x10	/* Bits 4:5 - Set Transmit FIFO Trigger Level to 32 Bytes in 650 mode.  */
#define FCR_THR_TRIG_LEVEL_3	0x20	/* Bits 4:5	- Set Transmit FIFO Trigger Level to 64 Bytes in 650 mode. */
#define FCR_THR_TRIG_LEVEL_4	0x30	/* Bits 4:5 - Set Transmit FIFO Trigger Level to 112 Bytes in 650 mode. */

#define FCR_750_FIFO		0x20	/* Bit 5: Enable 64 Bit FIFO (16C750) */

#define FCR_TRIG_LEVEL_1	0x00	/* Bits 6:7 - Set Receive FIFO Trigger Level to 1 Byte on 16C550A. */
#define FCR_TRIG_LEVEL_2	0x40	/* Bits 6:7 - Set Receive FIFO Trigger Level to 4 Bytes on 16C550A. */
#define FCR_TRIG_LEVEL_3	0x80	/* Bits 6:7 - Set Receive FIFO Trigger Level to 8 Bytes on 16C550A. */
#define FCR_TRIG_LEVEL_4	0xC0	/* Bits 6:7 - Set Receive FIFO Trigger Level to 16 Bytes on 16C550A. */

/******************************************************************************
* IIR: Interrupt Identification Register. or ISR: Interrupt Status Register - READ ONLY
******************************************************************************/
#define IIR					INTERRUPT_IDENT_REGISTER
#define IIR_NO_INT_PENDING	0x01	/* Bit 0: No Interrupt Pending. */

/* Interrupt Priorities  */
#define IIR_RX_STAT_MSK		0x06	/* Bits 1:2 - Receiver Line Status Interrupt		(Level 1 - Highest).  */
#define IIR_RX_MSK			0x04	/* Bits 1:2 - Received Data Available Interrupt		(Level 2a). */
#define IIR_RXTO_MSK		0x0C	/* Bits 1:2 - Received Data Time Out Interrupt		(Level 2b). */
#define IIR_TX_MSK			0x02	/* Bits 1:2 - Transmitter Holding Empty Interrupt	(Level 3). */
#define IIR_MODEM_MSK		0x00	/* Bits 1:2 - Modem Status Interrupt				(Level 4).  */

#define IIR_TO_INT_PENDING	0x08	/* Bit 3: Time-out Interrupt Pending.  */

#define IIR_S_CHR_MSK		0x10	/* Bit 4: Special Char (16C950 - Enhanced Mode)		(Level 5)   */
#define IIR_CTS_RTS_MSK		0x20	/* Bit 4: CTS/RTS Interrupt (16C950 - Enhanced Mode)(Level 6 - Lowest)   */

#define IIR_64BYTE_FIFO		0x20	/* Bit 5: 64 Byte FIFO Enabeled (16C750).  */

#define IIR_NO_FIFO			0x00	/* Bits 6:7 - No FIFO.  */
#define IIR_FIFO_UNUSABLE	0x40	/* Bits 6:7 - FIFO Enabled But Unusable (16550 Only).  */
#define IIR_FIFO_ENABLED	0xC0	/* Bits 6:7 - FIFO Enabled And Usable.  */
#define IIR_FIFO_MASK		0xC0	/* Bits 6:7	- Bit mask, */


/******************************************************************************
* LCR: Line Control Register. - READ/WRITE 
******************************************************************************/
#define LCR					LINE_CONTROL_REGISTER
#define LCR_DATALEN_5		0x00	/* Bits 0:1 - Sets Data Word Length to 5 Bits. */
#define LCR_DATALEN_6		0x01	/* Bits 0:1 - Sets Data Word Length to 6 Bits. */
#define LCR_DATALEN_7		0x02	/* Bits 0:1 - Sets Data Word Length to 7 Bits. */
#define LCR_DATALEN_8		0x03	/* Bits 0:1 - Sets Data Word Length to 8 Bits. */
	
#define LCR_STOPBITS		0x04	/* Bit 2 - 2 Stop Bits for 6,7,8 Bit Words or 1.5 Stop Bits for 5 Bit Words.  */

#define LCR_NO_PARITY		0x00	/* Bits 3:5 - No Parity. */
#define LCR_ODD_PARITY		0x08	/* Bits 3:5 - Odd Parity. */
#define LCR_EVEN_PARITY		0x18	/* Bits 3:5 - Even Parity. */
#define LCR_MARK_PARITY		0x28	/* Bits 3:5 - High Parity - Mark (Forced to 1). */
#define LCR_SPACE_PARITY	0x38	/* Bits 3:5 - Low Parity - Space (Forced to 0). */

#define LCR_TX_BREAK		0x40	/* Bit 6 - Set Break Enable. */

#define LCR_DLAB			0x80	/* Divisor Latch Access Bit - Allows Access To Low And High Divisor Registers. */
#define LCR_ACCESS_650		0xBF	/* Access to 650 Compatiblity Registers (16C950) */


/******************************************************************************
* MCR: Modem Control Register - READ/WRITE
******************************************************************************/
#define MCR					MODEM_CONTROL_REGISTER
#define MCR_SET_DTR			0x01	/* Bit 0: Force DTR (Data Terminal Ready). */
#define MCR_SET_RTS			0x02	/* Bit 1: Force RTS (Request To Send). */
#define MCR_OUT1			0x04	/* Bit 2: Aux Output 1. */
#define MCR_OUT2			0x08	/* Bit 3: Aux Output 2. */
#define MCR_INT_EN			0x08	/* Bit 3: (16C950)  */
#define MCR_LOOPBACK		0x10	/* Bit 4: Enable Loopback Mode. */
#define MCR_750CTSRTS		0x20	/* Bit 5: Automatic Flow Control Enabled RTS/CTS (16C750) */
#define MCR_XON_ANY			0x20	/* Bit 5: Xon-Any is enabled (16C950 - Enhanced Mode) */
#define MCR_IRDA_MODE		0x40	/* Bit 6: Enable IrDA mode - requires 16x clock. (16C950 - Enhanced Mode) */
#define MCR_CPR_EN			0x80	/* Bit 7: Enable Baud Prescale (16C950 - Enhanced Mode) */


/******************************************************************************
* LSR: Line Status Register - READ ONLY
******************************************************************************/
#define LSR					LINE_STATUS_REGISTER
#define LSR_RX_DATA			0x01	/* Bit 0: Data Ready. */
#define LSR_ERR_OE			0x02	/* Bit 1: Overrun Error. */

#define LSR_ERR_PE			0x04	/* Bit 2: Parity Error. */
#define LSR_RX_BIT9			0x04	/* Bit 2: 9th Rx Data Bit (16C950 - 9 bit data mode only) */

#define LSR_ERR_FE			0x08	/* Bit 3: Framing Error. */
#define LSR_ERR_BK			0x10	/* Bit 4: Break Interrupt. */
#define LSR_THR_EMPTY		0x20	/* Bit 5: Empty Transmitter Holding Register. */
#define LSR_TX_EMPTY		0x40	/* Bit 6: Empty Data Holding Registers. */
#define LSR_ERR_DE			0x80	/* Bit 7: Error In Received FIFO. */
#define LSR_ERR_MSK			LSR_ERR_OE + LSR_ERR_PE + LSR_ERR_FE + LSR_ERR_BK + LSR_ERR_DE


/******************************************************************************
* MSR: Modem Status Register - READ ONLY 
******************************************************************************/
#define MSR					MODEM_STATUS_REGISTER
#define MSR_CTS_CHANGE		0x01	/* Bit 0: Delta Clear To Send.	 */
#define MSR_DSR_CHANGE		0x02	/* Bit 1: Delta Data Set Ready. */
#define MSR_RI_DROPPED		0x04	/* Bit 2: Trailing Edge Ring Indicator (A Change From Low To High). */
#define MSR_DCD_CHANGE		0x08	/* Bit 3: Delta Data Carrier Detect. */
#define MSR_CTS				0x10	/* Bit 4: Clear To Send (Current State of CTS). */
#define MSR_DSR				0x20	/* Bit 5: Data Set Ready (Current State of DSR). */
#define MSR_RI				0x40	/* Bit 6: Ring Indicator (Current State of RI). */
#define MSR_DCD				0x80	/* Bit 7: Data Carrier Detect (Current State of DCD). */

/******************************************************************************
* SR: Scratch Pad Register - READ/WRITE 
******************************************************************************/
#define SPR					SCRATCH_PAD_REGISTER
#define SPR_TX_BIT9			0x01	/* Bit 0: 9th Tx Data Bit (16C950 - 9 bit data mode only) */







/******************************************************************************
* Oxford Semiconductor's 16C950 UART Specific Macros 
******************************************************************************/

/******************************************************************************
* 650 COMPATIBLE REGISTERS 
* To Access these registers LCR MUST be set to 0xBF 
******************************************************************************/

#define EFR		0x02	/* Enhanced Features Register. */

/* Bits 0:1 In band transmit flow control mode. */
/* 10.11.1999 ARG - ESIL 0927 */
/* Definitions for Tx XON/XOFF bits in the EFR corrected to use bits 0:1 */
#define EFR_TX_XON_XOFF_DISABLED	0x00	/* Bits 0:1 Transmit XON/XOFF Disabled. */
#define EFR_TX_XON_XOFF_2			0x01	/* Bits 0:1 Transmit XON/XOFF Enabled using chars in XON2 and XOFF2 */
#define EFR_TX_XON_XOFF_1			0x02	/* Bits 0:1 Transmit XON/XOFF Enabled using chars in XON1 and XOFF1 */

/* Bits 2:3 In band receive flow control mode. */
/* 10.11.1999 ARG - ESIL 0927 */
/* Definitions for Rx XON/XOFF bits in the EFR corrected to use bits 2:3 */
#define EFR_RX_XON_XOFF_DISABLED	0x00	/* Bits 2:3 Receive XON/XOFF Disabled. */
#define EFR_RX_XON_XOFF_2			0x04	/* Bits 2:3 Receive XON/XOFF Enabled using chars in XON2 and XOFF2 */
#define EFR_RX_XON_XOFF_1			0x08	/* Bits 2:3 Receive XON/XOFF Enabled using chars in XON1 and XOFF1 */

								
#define EFR_ENH_MODE	0x10	/* Bit 4: Enable Enhanced Mode. */
#define EFR_SPECIAL_CHR 0x20	/* Bit 5: Enable Special Character Detect. */
#define EFR_RTS_FC		0x40	/* Bit 6: Enable Automatic RTS Flow Control. */
#define EFR_CTS_FC		0x80	/* Bit 7: Enable Automatic CTS Flow Control. */

#define XON1	0x04	/* XON Character 1 */
#define XON2	0x05	/* XON Character 2 */
#define XOFF1	0x06	/* XOFF Character 1 */
#define XOFF2	0x07	/* XOFF Character 2 */

#define SPECIAL_CHAR1	XON1	/* Special Character 1 (16C950 - 9 bit data mode only) */
#define SPECIAL_CHAR2	XON2	/* Special Character 2 (16C950 - 9 bit data mode only) */
#define SPECIAL_CHAR3	XOFF1	/* Special Character 3 (16C950 - 9 bit data mode only) */
#define SPECIAL_CHAR4	XOFF2	/* Special Character 4 (16C950 - 9 bit data mode only) */

/*****************************************************************************/
/* 950 SPECIFIC REGISTERS */

#define ASR		0x01	/* Advanced Status Register */

#define ASR_TX_DISABLED		0x01	/* Transmitter Disabled By In-Band Flow Control (XOFF). */
#define ASR_RTX_DISABLED	0x02	/* Remote Transmitter Disabled By In-Band Flow Control (XOFF).  */
#define ASR_RTS				0x04	/* Remote Transmitter Disabled By RTS Out-Of-Band Flow Ctrl. */
#define ASR_DTR				0x08	/* Remote Transmitter Disabled By DTR Out-Of-Band Flow Ctrl. */
#define ASR_SPECIAL_CHR		0x10	/* Special Character Detected in the RHR. */
#define ASR_FIFO_SEL		0x20	/* Bit reflects the unlatched state of the FIFOSEL pin. */
#define ASR_FIFO_SIZE		0x40	/* Bit not set: FIFOs are 16 Deep. Bit Set: FIFOs are 128 Deep  */
#define ASR_TX_IDLE			0x80	/* Transmitter is Idle. */

/* Receiver FIFO Fill Level Register */
#define RFL		0x03	/* Minimum characters in the Rx FIFO. */

/* Transmitter FIFO Fill Level Register */
#define TFL		0x04	/* Maximum characters in the Tx FIFO.  */

/* Indexed Control Register Set Access Register */
#define ICR					LINE_STATUS_REGISTER

/*****************************************************************************/
/*INDEXED CONTROL REGISTER SET OFFSETS */

/* Advanced Control Register */
#define ACR		0x00	/* Aditional Control Register. */

#define ACR_DISABLE_RX	0x01	/* Receiver Disable. */
#define ACR_DISABLE_TX	0x02	/* Tranmitter Disable. */

#define ACR_DSR_FC		0x04	/* Enable Automatic DSR Flow Control */
#define ACR_DTR_FC		0x08	/* Enable Automatic DTR Flow Control */
#define ACR_DSRDTR_FC	0x0C	/* Enable Automatic DSR/DTR Flow Control. */

#define ACR_DTRDFN_MSK	0x18	/*  */
#define ACR_TRIG_LEV_EN	0x20	/* Enable 16950 Enhanced Interrupt & trig. levels defined by RTH, TTL, FCL & FCH. */
#define ACR_ICR_READ_EN	0x40	/* Enables Read Accesss to the Indexed Control Registers. */
#define ACR_ASR_EN		0x80	/* Additional Status Enable: Enables ASR, TFL, RFL. */

/* Clock Prescaler Register */
#define CPR				0x01	/* Clock Prescaler Register. */
#define CPR_FRACT_MSK	0x07	/* Mask for fractional part of clock prescaler. */
#define CPR_INTEGER_MSK 0xF8	/* Mask for integer part of clock prescaler. */

#define TCR				0x02	/* Times Clock Register to operate at baud rates to 50Mbps. */
#define CKS				0x03	/* Clock Select Register. */
#define TTL				0x04	/* Transmitter Interrupt Trigger Level. */
#define RTL				0x05	/* Receiver Interrupt Trigger Level. */
#define FCL				0x06	/* Flow Control Lower Trigger Level. */
#define FCH				0x07	/* Flow Control Higher Trigger Level. */

/* Identification Registers */
#define ID1				0x08	/* 0x16 for OX16C950 */
#define ID2				0x09	/* 0xC9 for OX16C950 */
#define ID3				0x0A	/* 0x50	for OX16C950 */
#define REV				0x0B	/* UART Revision: 0x1 for integrated 16C950 in rev A of OX16PCI954. */

#define UART_TYPE_950   0x00
#define UART_TYPE_952   0x02
#define UART_TYPE_954   0x04
#define UART_TYPE_NON95x 0xF0

#define UART_REV_A		0x00
#define UART_REV_B		0x01
#define UART_REV_C		0x02
#define UART_REV_D		0x03

/* Channel Soft Reset Register */
#define CSR				0x0C	/* Channel Soft Reset Register - Write 0x0 to reset the channel. */

/* Nine-Bit Mode Register */
#define NMR				0x0D	/* Nine-Bit Mode Register */
#define NMR_9BIT_EN     0x01	/* Enable 9-Bit mode. */

#define MDM				0x0E	/* Modem Disable Mask */
#define RFC				0x0F	/* Readable FCR. - Current state of FCR Register. */
#define GDS				0x10	/* Good Data Status Register. */
#define	CTR				0xFF	/* Register for Testing purposes only - Must not use. */



/******************************************************************************/
/* Local Configuration Register Offsets */

#define LCC				0x00	/* Local Configuration and Control Regiseter */
#define MIC				0x04	/* Multi-purpose IO Configuration Register  */
#define LT1				0x08	/* Local Bus Configuration Register 1 - Local Bus Timing Parameter Register. */
#define LT2				0x0C	/* Local Bus Configuration Register 2 - Local Bus Timing Parameter Register. */
#define URL				0x10	/* UART Receiver FIFO Levels. */
#define UTL				0x14	/* UART Transmitter FIFO Levels. */
#define UIS				0x18	/* UART Interrupt Source Register. */
#define GIS				0x1C	/* Global Interrupt Status Register. */




/* Supported 950s */
#define MIN_SUPPORTED_950_REV		UART_REV_A
#define MAX_SUPPORTED_950_REV		UART_REV_B

/* Supported 952s */
#define MIN_SUPPORTED_952_REV		UART_REV_B
#define MAX_SUPPORTED_952_REV		UART_REV_B

/* Supported 954s */
#define MIN_SUPPORTED_954_REV		UART_REV_A
#define MAX_SUPPORTED_954_REV		UART_REV_A



/* Prototypes. */

/* End of prototypes. */





#endif	/* End of 16CX5X.H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\spx\speed\uartlib\uartlib.c ===
/******************************************************************************
*	
*	$Workfile: uartlib.c $ 
*
*	$Author: Psmith $ 
*
*	$Revision: 10 $
* 
*	$Modtime: 6/07/00 15:19 $ 
*
*	Description: Contains generic UART Library functions. 
*
******************************************************************************/
#include "os.h"	
#include "uartlib.h"
#include "uartprvt.h"
#include "lib65x.h"
#include "lib95x.h"

/* Prototypes */
PUART_OBJECT UL_CreateUartObject();
void UL_AddUartToList(PUART_OBJECT pUart, PUART_OBJECT pPreviousUart);
void UL_RemoveUartFromList(PUART_OBJECT pUart);
PUART_OBJECT UL_FindLastUartInList(PUART_OBJECT pUart);
/* End of Prototypes. */


/******************************************************************************
* Creates a UART object.
******************************************************************************/
PUART_OBJECT UL_CreateUartObject()
{
	PUART_OBJECT pUart = NULL;

	/* Create UART Object */	
	pUart = (PUART_OBJECT) UL_ALLOC_AND_ZERO_MEM(sizeof(UART_OBJECT));

	return pUart;
}



/******************************************************************************
* Find Last UART object in the list.
******************************************************************************/
PUART_OBJECT UL_FindLastUartInList(PUART_OBJECT pFirstUart)
{
	PUART_OBJECT pUart = pFirstUart;

	while(pUart)
	{
		/* If the next UART is not the first UART */
		if(pUart->pNextUart != pFirstUart)
			pUart = pUart->pNextUart;	/* Get the next UART */
		else
			break;	/* Break we have the last UART */
	}	

	return pUart;
}

/******************************************************************************
* Adds a new UART object to the list.
******************************************************************************/
void UL_AddUartToList(PUART_OBJECT pUart, PUART_OBJECT pPreviousUart)
{
	/* Add new UART object into Linked List. */

	if(pPreviousUart == NULL)	/* must be a new list */
	{
		pUart->pPreviousUart = pUart;
		pUart->pNextUart = pUart;
	}
	else
	{
		pUart->pPreviousUart = pPreviousUart;		/* Set pPreviousUart */
		pUart->pNextUart = pPreviousUart->pNextUart;

		pUart->pPreviousUart->pNextUart = pUart; 
		pUart->pNextUart->pPreviousUart = pUart;
	}
}

/******************************************************************************
* Removes a UART object from the list.
******************************************************************************/
void UL_RemoveUartFromList(PUART_OBJECT pUart)
{
	/* Remove UART from linked list. */
	if(pUart->pPreviousUart)
		pUart->pPreviousUart->pNextUart = pUart->pNextUart;

	if(pUart->pNextUart)
		pUart->pNextUart->pPreviousUart = pUart->pPreviousUart;

	pUart->pPreviousUart = NULL;
	pUart->pNextUart = NULL;
}


/******************************************************************************
* Common Init UART object.
******************************************************************************/
PUART_OBJECT UL_CommonInitUart(PUART_OBJECT pFirstUart)
{
	PUART_OBJECT pUart = NULL, pPreviousUart = NULL;

	if(!(pUart = UL_CreateUartObject()))
		goto Error;		/* Memory allocation failed. */

	pPreviousUart = UL_FindLastUartInList(pFirstUart);

	/* Add new UART object into Linked List. */
	UL_AddUartToList(pUart, pPreviousUart);

	if(!pUart->pUartConfig) 		/* Allocate UART Config storage */
		if(!(pUart->pUartConfig = (PUART_CONFIG) UL_ALLOC_AND_ZERO_MEM(sizeof(UART_CONFIG))))
			goto Error;		/* Memory allocation failed. */

	return pUart;

/* InitUart Failed - so Clean up. */		
Error:
	return NULL;
}

/******************************************************************************
* Common DeInit UART object function.
******************************************************************************/
void UL_CommonDeInitUart(PUART_OBJECT pUart)
{
	if(!pUart)
		return;

	UL_RemoveUartFromList(pUart);

	if(pUart->pUartConfig)
	{
		UL_FREE_MEM(pUart->pUartConfig, sizeof(UART_CONFIG));		/* Free the UART Config Struct. */
		pUart->pUartConfig = NULL;
	}

	UL_FREE_MEM(pUart, sizeof(UART_OBJECT));	/* Destroy UART Object */
}



/******************************************************************************
* Get Current Config Sturcture.
******************************************************************************/
void UL_GetConfig(PUART_OBJECT pUart, PUART_CONFIG pUartConfig)
{
	UL_COPY_MEM(pUartConfig, pUart->pUartConfig, sizeof(UART_CONFIG));
}


/******************************************************************************
* Set pAppBackPtr from UART Object
******************************************************************************/
void UL_SetAppBackPtr(PUART_OBJECT pUart, PVOID pAppBackPtr)
{
	pUart->pAppBackPtr = pAppBackPtr;
}

/******************************************************************************
* Get pAppBackPtr from UART Object
******************************************************************************/
PVOID UL_GetAppBackPtr(PUART_OBJECT pUart)
{
	return pUart->pAppBackPtr;
}



/******************************************************************************
* UL_GetUartObject
******************************************************************************/
PUART_OBJECT UL_GetUartObject(PUART_OBJECT pUart, int Operation)
{
	PUART_OBJECT RequestedUart = NULL;

	if(pUart == NULL)
		return NULL;

	switch(Operation)
	{
	case UL_OP_GET_NEXT_UART:
		{
			/* If the NextUart is the same then we are the only one in the list. */
			if(pUart->pNextUart == pUart)
				RequestedUart = NULL;
			else
				RequestedUart = pUart->pNextUart;
			break;
		}

	case UL_OP_GET_PREVIOUS_UART:
		{
			 /* If the PreviousUart is the same then we are the only one in the list. */
			if(pUart->pPreviousUart == pUart)
				RequestedUart = NULL;
			else
				RequestedUart = pUart->pPreviousUart;
			break;
		}

	default:
		break;
	}

	return RequestedUart;
}



/******************************************************************************
* UL_InitUartLibrary
******************************************************************************/
ULSTATUS UL_InitUartLibrary(PUART_LIB pUartLib, int Library)
{
	ULSTATUS ULStatus =  UL_STATUS_UNSUCCESSFUL;

	if(pUartLib != NULL)
	{
		switch(Library)
		{
		case UL_LIB_16C65X_UART:	/* UART library functions for 16C65x UART */
			{
				pUartLib->UL_InitUart_XXXX	= UL_InitUart_16C65X;
				pUartLib->UL_DeInitUart_XXXX	= UL_DeInitUart_16C65X;
				pUartLib->UL_ResetUart_XXXX	= UL_ResetUart_16C65X;
				pUartLib->UL_VerifyUart_XXXX	= UL_VerifyUart_16C65X;

				pUartLib->UL_SetConfig_XXXX	= UL_SetConfig_16C65X;
				pUartLib->UL_BufferControl_XXXX	= UL_BufferControl_16C65X;

				pUartLib->UL_ModemControl_XXXX	= UL_ModemControl_16C65X;
				pUartLib->UL_IntsPending_XXXX	= UL_IntsPending_16C65X;
				pUartLib->UL_GetUartInfo_XXXX	= UL_GetUartInfo_16C65X;

				pUartLib->UL_OutputData_XXXX	= UL_OutputData_16C65X;
				pUartLib->UL_InputData_XXXX	= UL_InputData_16C65X;

				pUartLib->UL_ReadData_XXXX	= UL_ReadData_16C65X;
				pUartLib->UL_WriteData_XXXX	= UL_WriteData_16C65X;
				pUartLib->UL_ImmediateByte_XXXX	= UL_ImmediateByte_16C65X;
				pUartLib->UL_GetStatus_XXXX	= UL_GetStatus_16C65X;
				pUartLib->UL_DumpUartRegs_XXXX	= UL_DumpUartRegs_16C65X;

				pUartLib->UL_SetAppBackPtr_XXXX = UL_SetAppBackPtr_16C65X;
				pUartLib->UL_GetAppBackPtr_XXXX = UL_GetAppBackPtr_16C65X;
				pUartLib->UL_GetConfig_XXXX	= UL_GetConfig_16C65X;
				pUartLib->UL_GetUartObject_XXXX	= UL_GetUartObject_16C65X;

				ULStatus = UL_STATUS_SUCCESS;
				break;
			}

		case UL_LIB_16C95X_UART:	/* UART library functions for 16C95x UART */
			{
				pUartLib->UL_InitUart_XXXX	= UL_InitUart_16C95X;
				pUartLib->UL_DeInitUart_XXXX	= UL_DeInitUart_16C95X;
				pUartLib->UL_ResetUart_XXXX	= UL_ResetUart_16C95X;
				pUartLib->UL_VerifyUart_XXXX	= UL_VerifyUart_16C95X;

				pUartLib->UL_SetConfig_XXXX	= UL_SetConfig_16C95X;
				pUartLib->UL_BufferControl_XXXX	= UL_BufferControl_16C95X;

				pUartLib->UL_ModemControl_XXXX	= UL_ModemControl_16C95X;
				pUartLib->UL_IntsPending_XXXX	= UL_IntsPending_16C95X;
				pUartLib->UL_GetUartInfo_XXXX	= UL_GetUartInfo_16C95X;

				pUartLib->UL_OutputData_XXXX	= UL_OutputData_16C95X;
				pUartLib->UL_InputData_XXXX	= UL_InputData_16C95X;

				pUartLib->UL_ReadData_XXXX	= UL_ReadData_16C95X;
				pUartLib->UL_WriteData_XXXX	= UL_WriteData_16C95X;
				pUartLib->UL_ImmediateByte_XXXX	= UL_ImmediateByte_16C95X;
				pUartLib->UL_GetStatus_XXXX	= UL_GetStatus_16C95X;
				pUartLib->UL_DumpUartRegs_XXXX	= UL_DumpUartRegs_16C95X;

				pUartLib->UL_SetAppBackPtr_XXXX = UL_SetAppBackPtr_16C95X;
				pUartLib->UL_GetAppBackPtr_XXXX = UL_GetAppBackPtr_16C95X;
				pUartLib->UL_GetConfig_XXXX	= UL_GetConfig_16C95X;
				pUartLib->UL_GetUartObject_XXXX	= UL_GetUartObject_16C95X;

				ULStatus = UL_STATUS_SUCCESS;
				break;
			}

		default:	/* Unknown UART */
			ULStatus = UL_STATUS_INVALID_PARAMETER;
			break;
		}
	}

	return ULStatus;
}


/******************************************************************************
* UL_DeInitUartLibrary
******************************************************************************/
void UL_DeInitUartLibrary(PUART_LIB pUartLib)
{
	ULSTATUS ULStatus =  UL_STATUS_UNSUCCESSFUL;

	if(pUartLib != NULL)
	{
		pUartLib->UL_InitUart_XXXX	= NULL;
		pUartLib->UL_DeInitUart_XXXX	= NULL;
		pUartLib->UL_ResetUart_XXXX	= NULL;
		pUartLib->UL_VerifyUart_XXXX	= NULL;

		pUartLib->UL_SetConfig_XXXX	= NULL;
		pUartLib->UL_BufferControl_XXXX	= NULL;

		pUartLib->UL_ModemControl_XXXX	= NULL;
		pUartLib->UL_IntsPending_XXXX	= NULL;
		pUartLib->UL_GetUartInfo_XXXX	= NULL;

		pUartLib->UL_OutputData_XXXX	= NULL;
		pUartLib->UL_InputData_XXXX	= NULL;

		pUartLib->UL_ReadData_XXXX	= NULL;
		pUartLib->UL_WriteData_XXXX	= NULL;
		pUartLib->UL_ImmediateByte_XXXX	= NULL;
		pUartLib->UL_GetStatus_XXXX	= NULL;
		pUartLib->UL_DumpUartRegs_XXXX	= NULL;
				
		pUartLib->UL_SetAppBackPtr_XXXX = NULL;
		pUartLib->UL_GetAppBackPtr_XXXX = NULL;
		pUartLib->UL_GetConfig_XXXX	= NULL;
		pUartLib->UL_GetUartObject_XXXX	= NULL;

	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\spx\speed\uartlib\inc\private\os.h ===
/******************************************************************************
*	
*	$Workfile: os.h $ 
*
*	$Author: Psmith $ 
*
*	$Revision: 2 $
* 
*	$Modtime: 23/09/99 10:07 $ 
*
*	Description: NT specific macros and definitions.
*
******************************************************************************/
#if !defined(OS_H)		// OS.H
#define OS_H

#include <ntddk.h>


typedef unsigned char	BYTE;	// 8-bits 
typedef unsigned short	WORD;	// 16-bits 
typedef unsigned long	DWORD;	// 32-bits
typedef unsigned char	UCHAR; 	// 8-bits 
typedef unsigned short	USHORT;	// 16-bits 
typedef unsigned long	ULONG;	// 32-bits

typedef BYTE	*PBYTE;
typedef WORD	*PWORD;
typedef DWORD	*PDWORD;
typedef UCHAR	*PUCHAR; 
typedef USHORT	*PUSHORT;
typedef ULONG	*PULONG; 


extern PVOID SpxAllocateMem(IN POOL_TYPE PoolType, IN ULONG NumberOfBytes);


// Macros
/////////////////////////////////////////////////////////////////////////////////

// DebugPrint macro.
#define SpxDbgPrint(STRING)					\
	DbgPrint STRING 

// Allocate and zero memory.
#define UL_ALLOC_AND_ZERO_MEM(NumBytes)			\
	(SpxAllocateMem(NonPagedPool, NumBytes))	

// Free memory.
#define UL_FREE_MEM(Ptr, NumBytes)				\
	(ExFreePool(Ptr))	

// Copy memory.
#define UL_COPY_MEM(pDest, pSrc, NumBytes)	\
	(RtlCopyMemory(pDest, pSrc, NumBytes))	

#define UL_ZERO_MEM(Ptr, NumBytes)	\
	RtlZeroMemory(Ptr, NumBytes);
	
// Read single byte from I/O.
#define UL_READ_BYTE_IO(BaseAddress, OffSet)		\
	(READ_PORT_UCHAR( ((PUCHAR)BaseAddress) + OffSet) )

// Write single byte to I/O.
#define UL_WRITE_BYTE_IO(BaseAddress, OffSet, Data)	\
	(WRITE_PORT_UCHAR( ((PUCHAR)BaseAddress) + OffSet, Data) )

// Read single byte from Memory.
#define UL_READ_BYTE_MEM(BaseAddress, OffSet)		\
	(READ_REGISTER_UCHAR( ((PUCHAR)BaseAddress) + OffSet) )

// Write single byte to Memory.
#define UL_WRITE_BYTE_MEM(BaseAddress, OffSet, Data)	\
	(WRITE_REGISTER_UCHAR( ((PUCHAR)BaseAddress) + OffSet, Data) )

/*
// Read multiple bytes to I/O.
#define UL_READ_MULTIBYTES_IO(BaseAddress, OffSet, pDest, NumberOfBytes)	\
	(READ_PORT_BUFFER_UCHAR( ((PUCHAR)BaseAddress) + OffSet, pDest, NumberOfBytes) )

// Write multiple bytes to I/O.
#define UL_WRITE_MULTIBYTES_IO(BaseAddress, OffSet, pData, NumberOfBytes)	\
	(WRITE_PORT_BUFFER_UCHAR( ((PUCHAR)BaseAddress) + OffSet, pData, NumberOfBytes) )

// Read multiple bytes to Memory.
#define UL_READ_MULTIBYTES_MEM(BaseAddress, OffSet, pDest, NumberOfBytes)	\
	(READ_REGISTER_BUFFER_UCHAR( ((PUCHAR)BaseAddress) + OffSet, pDest, NumberOfBytes) )

// Write multiple bytes to Memory.
#define UL_WRITE_MULTIBYTES_MEM(BaseAddress, OffSet, pData, NumberOfBytes)	\
	(WRITE_REGISTER_BUFFER_UCHAR( ((PUCHAR)BaseAddress) + OffSet, pData, NumberOfBytes) )
*/


#endif	// End of OS.H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\spx\speed\uartlib\inc\private\16c65x.h ===
/******************************************************************************
*	
*	$Workfile: 16c65x.h $ 
*
*	$Author: Psmith $ 
*
*	$Revision: 3 $
* 
*	$Modtime: 6/07/00 15:16 $ 
*
*	Description: Contains private 16C65X UART Library structures, 
*			macros & prototypes.
*
******************************************************************************/
#if !defined(_16C65X_H)		/* 16C65X.H */
#define _16C65X_H

#include "os.h"
#include "uartlib.h"
#include "uartprvt.h"
#include "16cx5x.h"

#if ACCESS_16C65X_IN_IO_SPACE
#define UL_READ_BYTE		UL_READ_BYTE_IO
#define UL_WRITE_BYTE		UL_WRITE_BYTE_IO
#else
#define UL_READ_BYTE 		UL_READ_BYTE_MEM
#define UL_WRITE_BYTE		UL_WRITE_BYTE_MEM
#endif

#define MAX_65X_TX_FIFO_SIZE	64
#define MAX_65X_RX_FIFO_SIZE	64

#define DEFAULT_65X_HI_FC_TRIG_LEVEL	60	/* = 75% of FIFO */
#define DEFAULT_65X_LO_FC_TRIG_LEVEL	16	/* = 25% of FIFO */


/* 16C95X UART Data */
typedef struct _UART_DATA_16C65X
{
	BYTE	CurrentFCR;

	BYTE	CurrentIER;
	BYTE	CurrentMCR;
	BYTE	CurrentLCR;
	
	BOOLEAN FIFOEnabled;
	BYTE	TxFIFOSize;			
	BYTE	RxFIFOSize;		
	BYTE	TxFIFOTrigLevel; 
	BYTE	RxFIFOTrigLevel; 

	DWORD	HiFlowCtrlLevel;	/* For software buffers only not FIFOs */
	DWORD	LoFlowCtrlLevel; 	/* For software buffers only not FIFOs */


	BOOLEAN RTSToggle;
	BOOLEAN DSRSensitive;
	BOOLEAN DTRHandshake;
	BOOLEAN DSRHandshake;

	BOOLEAN TxDisabled;
	BOOLEAN RxDisabled;

	BOOLEAN Verified;

	BOOLEAN StripNULLs;


} UART_DATA_16C65X, *PUART_DATA_16C65X;



/******************************************************************************
* FUNCTIONS TO READ & WRITE BYTES TO REGISTERS
******************************************************************************/
/* Reads a byte from a Register at offset RegOffset.	*/
#define READ_BYTE_REG_65X(pUart, RegOffset)				\
	(UL_READ_BYTE((pUart)->BaseAddress, (RegOffset * (pUart)->RegisterStride)))


/* Writes a byte to a Register at offset RegOffset.	*/
#define WRITE_BYTE_REG_65X(pUart, RegOffset, Data)			\
	(UL_WRITE_BYTE((pUart)->BaseAddress, (RegOffset * (pUart)->RegisterStride), Data))


/******************************************************************************
* FUNCTIONS TO ACCESS COMMON REGISTERS
******************************************************************************/
/* This writes to the THR (Transmit Holding Register).	*/
#define WRITE_TRANSMIT_HOLDING_65X(pUart, Data)	\
	WRITE_BYTE_REG_65X(pUart, TRANSMIT_HOLDING_REGISTER, Data)

/* This reads the RBR (Receive Buffer Register).	*/
#define READ_RECEIVE_BUFFER_65X(pUart)		\
	READ_BYTE_REG_65X(pUart, RECEIVE_BUFFER_REGISTER)


/* Writes a byte to the THR (Transmit Holding Register). */
#define FILL_FIFO_65X(pUart, pData, NumBytes)				\
	(UL_WRITE_MULTIBYTES((pUart)->BaseAddress, (TRANSMIT_HOLDING_REGISTER * (pUart)->RegisterStride), pData, NumBytes))

/* Reads multiple bytes from the RBR (Receive Buffer Register).	*/
#define EMPTY_FIFO_65X(pUart, pDest, NumBytes)				\
	(UL_READ_MULTIBYTES((pUart)->BaseAddress, (RECEIVE_BUFFER_REGISTER * (pUart)->RegisterStride), pDest, NumBytes))


/* This writes the IER (Interrupt Enable Register).	*/
#define WRITE_INTERRUPT_ENABLE_65X(pUart, Data)				\
(									\
	WRITE_BYTE_REG_65X(pUart, INTERRUPT_ENABLE_REGISTER, Data),	\
	((PUART_DATA_16C65X)((pUart)->pUartData))->CurrentIER = Data	\
)



/* This reads to the IER (Interrupt Enable Register).	*/
#define READ_INTERRUPT_ENABLE_65X(pUart)		\
	((PUART_DATA_16C65X)((pUart)->pUartData))->CurrentIER			
/*	READ_BYTE_REG_65X(pUart, INTERRUPT_ENABLE_REGISTER),	*/			



/* This reads to the IIR (Interrupt Identification Register).
*
*  Note that this routine potententially quites a transmitter empty interrupt.  
*  This is because one way that the transmitter empty interrupt is cleared is to
*  simply read the interrupt id register.	*/
#define READ_INTERRUPT_ID_REG_65X(pUart)		\
	READ_BYTE_REG_65X(pUart, INTERRUPT_IDENT_REGISTER)


/* This reads the LSR (Line Status Register).		*/
#define READ_LINE_STATUS_65X(pUart)	\
	READ_BYTE_REG_65X(pUart, LINE_STATUS_REGISTER)


/* This writes to the FCR (FIFO Control Register).
*
*  17.11.1999 ARG - ESIL 0920
*  When we write to the FCR we store those bits being set - but we don't want the Rx
*  and Tx FIFO flush bits to be retained - so we mask them off.
*
*/
#define WRITE_FIFO_CONTROL_65X(pUart, Data)				\
(									\
	WRITE_BYTE_REG_65X(pUart, FIFO_CONTROL_REGISTER, Data),		\
	((PUART_DATA_16C65X)((pUart)->pUartData))->CurrentFCR		\
	    = (Data & ~(FCR_FLUSH_RX_FIFO|FCR_FLUSH_TX_FIFO))		\
)

 
#define READ_FIFO_CONTROL_65X(pUart)			\
	((PUART_DATA_16C65X)((pUart)->pUartData))->CurrentFCR


/* This writes to the LCR (Line Control Register).	*/
#define WRITE_LINE_CONTROL_65X(pUart, Data)				\
(									\
	((PUART_DATA_16C65X)((pUart)->pUartData))->CurrentLCR = Data,	\
	WRITE_BYTE_REG_65X(pUart, LINE_CONTROL_REGISTER, Data)		\
)

/* This reads the LCR (Line Control Register).
*
* -- OXSER Mod 14 --
* An LCR register has been created in the UART Object's Data Structure to store the state of this
* register (updated on every LCR write) this removes the requirement for a read LCR routine to access 
* the hardware and means on the 16C95x RFL + TFL read access can be enabled at all times.	*/
#define READ_LINE_CONTROL_65X(pUart)		\
	((PUART_DATA_16C65X)((pUart)->pUartData))->CurrentLCR	
/*	READ_BYTE_REG_65X(pUart, LINE_CONTROL_REGISTER)	*/



/* This writes to the MCR (Modem Control Register).	*/
#define WRITE_MODEM_CONTROL_65X(pUart, Data)					\
(										\
	((PUART_DATA_16C65X)((pUart)->pUartData))->CurrentMCR = Data,		\
	WRITE_BYTE_REG_65X(pUart, MODEM_CONTROL_REGISTER, Data)			\
)

/* This reads the MCR (Modem Control Register).
*
* -- OXSER Mod 14 --
* An MCR register has been created in the UART Object's Data Structure to store the state of this
* register (updated on every MCR write) this removes the requirement for a read MCR routine to access
* the hardware and means on the 16C95x RFL + TFL read access can be enabled at all times.	*/
#define READ_MODEM_CONTROL_65X(pUart)	\
	((PUART_DATA_16C65X)((pUart)->pUartData))->CurrentMCR
/*	READ_BYTE_REG_65X(pUart, MODEM_CONTROL_REGISTER)	*/



/* This reads the MSR (Modem Status Register).	*/
#define READ_MODEM_STATUS_65X(pUart)		\
	READ_BYTE_REG_65X(pUart, MODEM_STATUS_REGISTER)


/* This writes to the SPR (Scratch Pad Register).	*/
#define WRITE_SCRATCH_PAD_REGISTER_65X(pUart, Data)	\
	WRITE_BYTE_REG_65X(pUart, SCRATCH_PAD_REGISTER, Data)


/* This reads the SPR (Scratch Pad Register).		*/
#define READ_SCRATCH_PAD_REGISTER_65X(pUart)	\
	READ_BYTE_REG_65X(pUart, SCRATCH_PAD_REGISTER)



/* Sets the divisor latch register.  
*  The divisor latch register is used to control the baud rate of the UART.	*/
#define WRITE_DIVISOR_LATCH_65X(pUart, DesiredDivisor)						\
(												\
	WRITE_LINE_CONTROL_65X(pUart, (BYTE)(READ_LINE_CONTROL_65X(pUart) | LCR_DLAB)),		\
												\
	WRITE_BYTE_REG_65X(pUart, DIVISOR_LATCH_LSB, (BYTE)(DesiredDivisor & 0xFF)),		\
												\
	WRITE_BYTE_REG_65X(pUart, DIVISOR_LATCH_MSB, (BYTE)((DesiredDivisor & 0xFF00) >> 8)),	\
												\
	WRITE_LINE_CONTROL_65X(pUart, (BYTE)(READ_LINE_CONTROL_65X(pUart) & ~LCR_DLAB))		\
)



/* Reads the divisor latch register.  
*  The divisor latch register is used to control the baud rate of the UART.	*/
#define READ_DIVISOR_LATCH_65X(pUart, pDivisor)							\
(												\
	WRITE_LINE_CONTROL_65X(pUart, (BYTE)(READ_LINE_CONTROL_65X(pUart) | LCR_DLAB)),		\
												\
	*pDivisor = (WORD)READ_BYTE_REG_65X(pUart, DIVISOR_LATCH_LSB),				\
												\
	*pDivisor |= (WORD)(READ_BYTE_REG_65X(pUart, DIVISOR_LATCH_MSB) << 8),			\
												\
	WRITE_LINE_CONTROL_65X(pUart, (BYTE)(READ_LINE_CONTROL_65X(pUart) & ~LCR_DLAB))		\
)



WORD CalculateBaudDivisor_65X(PUART_OBJECT pUart, DWORD DesiredBaud);


/* 16C65X UART REGISTERS */
typedef struct _UART_REGS_16C65X
{

	BYTE	REG_RHR, REG_IER, REG_FCR, REG_IIR, REG_LCR, REG_MCR, REG_LSR, REG_MSR, REG_SPR,
		REG_EFR, REG_XON1, REG_XON2, REG_XOFF1, REG_XOFF2;

} UART_REGS_16C65X, *PUART_REGS_16C65X;


#endif	/* End of 16C65X.H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\spx\speed\uartlib\inc\private\16c95x.h ===
/******************************************************************************
*	
*	$Workfile: 16c95x.h $ 
*
*	$Author: Psmith $ 
*
*	$Revision: 9 $
* 
*	$Modtime: 6/06/00 11:41 $ 
*
*	Description: Contains private 16C95X UART Library structures, 
*			macros & prototypes.
*
******************************************************************************/
#if !defined(_16C95X_H)		/* 16C95X.H */
#define _16C95X_H

#include "os.h"
#include "uartlib.h"
#include "uartprvt.h"
#include "16cx5x.h"

#if ACCESS_16C95X_IN_IO_SPACE
#define UL_READ_BYTE		UL_READ_BYTE_IO
#define UL_WRITE_BYTE		UL_WRITE_BYTE_IO
#else
#define UL_READ_BYTE 		UL_READ_BYTE_MEM
#define UL_WRITE_BYTE		UL_WRITE_BYTE_MEM
#endif

#define MAX_95X_TX_FIFO_SIZE	128
#define MAX_95X_RX_FIFO_SIZE	128

#define DEFAULT_95X_HI_FC_TRIG_LEVEL	96	/* = 75% of FIFO */
#define DEFAULT_95X_LO_FC_TRIG_LEVEL	32	/* = 25% of FIFO */


/* 16C95X UART Data */
typedef struct _UART_DATA_16C95X
{
	BYTE	CurrentFCR;

	BYTE	CurrentIER;
	BYTE	CurrentMCR;
	BYTE	CurrentLCR;
	BYTE	CurrentACR;
	BOOLEAN ASRChanged;
	
	BOOLEAN FIFOEnabled;
	BYTE	TxFIFOSize;			
	BYTE	RxFIFOSize;		
	BYTE	TxFIFOTrigLevel; 
	BYTE	RxFIFOTrigLevel; 

	BOOLEAN RTSToggle;
	BOOLEAN DSRSensitive;

	BYTE	UART_Type;
	BYTE	UART_Rev;
	DWORD	UART_ID;

	BOOLEAN Verified;

	BOOLEAN StripNULLs;

} UART_DATA_16C95X, *PUART_DATA_16C95X;



/******************************************************************************
* FUNCTIONS TO READ & WRITE BYTES TO REGISTERS
******************************************************************************/
/* Reads a byte from a Register at offset RegOffset.	*/
#define READ_BYTE_REG_95X(pUart, RegOffset)				\
	(UL_READ_BYTE((pUart)->BaseAddress, (RegOffset * (pUart)->RegisterStride)))

/* Writes a byte to a Register at offset RegOffset.	*/
#define WRITE_BYTE_REG_95X(pUart, RegOffset, Data)			\
	(UL_WRITE_BYTE((pUart)->BaseAddress, (RegOffset * (pUart)->RegisterStride), Data))


/******************************************************************************
* FUNCTIONS TO ACCESS COMMON REGISTERS
******************************************************************************/
/* This writes to the THR (Transmit Holding Register).	*/
#define WRITE_TRANSMIT_HOLDING(pUart, Data)	\
	WRITE_BYTE_REG_95X(pUart, TRANSMIT_HOLDING_REGISTER, Data)

/* This reads the RBR (Receive Buffer Register).	*/
#define READ_RECEIVE_BUFFER(pUart)		\
	READ_BYTE_REG_95X(pUart, RECEIVE_BUFFER_REGISTER)


/* Writes a byte to the THR (Transmit Holding Register). */
#define FILL_FIFO_95X(pUart, pData, NumBytes)				\
	(UL_WRITE_MULTIBYTES((pUart)->BaseAddress, (TRANSMIT_HOLDING_REGISTER * (pUart)->RegisterStride), pData, NumBytes))

/* Reads multiple bytes from the RBR (Receive Buffer Register).	*/
#define EMPTY_FIFO_95X(pUart, pDest, NumBytes)				\
	(UL_READ_MULTIBYTES((pUart)->BaseAddress, (RECEIVE_BUFFER_REGISTER * (pUart)->RegisterStride), pDest, NumBytes))



/* This writes the IER (Interrupt Enable Register).	*/
#define WRITE_INTERRUPT_ENABLE(pUart, Data)				\
(									\
	WRITE_BYTE_REG_95X(pUart, INTERRUPT_ENABLE_REGISTER, Data),	\
	((PUART_DATA_16C95X)((pUart)->pUartData))->CurrentIER = Data	\
)



/* This reads to the IER (Interrupt Enable Register).	*/
#define READ_INTERRUPT_ENABLE(pUart)		\
	((PUART_DATA_16C95X)((pUart)->pUartData))->CurrentIER			
/*	READ_BYTE_REG_95X(pUart, INTERRUPT_ENABLE_REGISTER),	*/			



/* This reads to the IIR (Interrupt Identification Register).
*
*  Note that this routine potententially quites a transmitter empty interrupt.  
*  This is because one way that the transmitter empty interrupt is cleared is to
*  simply read the interrupt id register.	*/
#define READ_INTERRUPT_ID_REG(pUart)		\
	READ_BYTE_REG_95X(pUart, INTERRUPT_IDENT_REGISTER)


/* This reads the LSR (Line Status Register).		*/
#define READ_LINE_STATUS(pUart)	\
	READ_BYTE_REG_95X(pUart, LINE_STATUS_REGISTER)


/* This writes to the FCR (FIFO Control Register).
*  -- OXSER BUGFIX 4 --
*  Incase anyone puts an OX16C950 on the local bus we will unconditionally fix its 
*  Rx FIFO Flush bug here by following all FCR writes with a read of both RBR and LSR.
*
*  17.11.1999 ARG - ESIL 0920
*  When we write to the FCR we store those bits being set - but we don't want the Rx
*  and Tx FIFI flush bits to be retained - so we mask them off.
*
*  Note : Due to the Rx FIFO flush bug fix, a byte of Rx data will be lost when we do a
*  Tx flush
*/
#define WRITE_FIFO_CONTROL(pUart, Data)					\
(									\
	WRITE_BYTE_REG_95X(pUart, FIFO_CONTROL_REGISTER, Data),		\
	((PUART_DATA_16C95X)((pUart)->pUartData))->CurrentFCR		\
	    = (Data & ~(FCR_FLUSH_RX_FIFO|FCR_FLUSH_TX_FIFO)),		\
									\
	READ_RECEIVE_BUFFER(pUart),					\
	READ_LINE_STATUS(pUart)						\
)

 
#define READ_FIFO_CONTROL(pUart)			\
	((PUART_DATA_16C95X)((pUart)->pUartData))->CurrentFCR


/* This writes to the LCR (Line Control Register).	*/
#define WRITE_LINE_CONTROL(pUart, Data)					\
(									\
	((PUART_DATA_16C95X)((pUart)->pUartData))->CurrentLCR = Data,	\
	WRITE_BYTE_REG_95X(pUart, LINE_CONTROL_REGISTER, Data)		\
)

/* This reads the LCR (Line Control Register).
*
* -- OXSER Mod 14 --
* An LCR register has been created in the UART Object's Data Structure to store the state of this
* register (updated on every LCR write) this removes the requirement for a read LCR routine to access 
* the hardware and means on the 16C95x RFL + TFL read access can be enabled at all times.	*/
#define READ_LINE_CONTROL(pUart)		\
	((PUART_DATA_16C95X)((pUart)->pUartData))->CurrentLCR	
/*	READ_BYTE_REG_95X(pUart, LINE_CONTROL_REGISTER)	*/



/* This writes to the MCR (Modem Control Register).	*/
#define WRITE_MODEM_CONTROL(pUart, Data)					\
(										\
	((PUART_DATA_16C95X)((pUart)->pUartData))->CurrentMCR = Data,		\
	WRITE_BYTE_REG_95X(pUart, MODEM_CONTROL_REGISTER, Data)			\
)

/* This reads the MCR (Modem Control Register).
*
* -- OXSER Mod 14 --
* An MCR register has been created in the UART Object's Data Structure to store the state of this
* register (updated on every MCR write) this removes the requirement for a read MCR routine to access
* the hardware and means on the 16C95x RFL + TFL read access can be enabled at all times.	*/
#define READ_MODEM_CONTROL(pUart)	\
	((PUART_DATA_16C95X)((pUart)->pUartData))->CurrentMCR
/*	READ_BYTE_REG_95X(pUart, MODEM_CONTROL_REGISTER)	*/



/* This reads the MSR (Modem Status Register).	*/
#define READ_MODEM_STATUS(pUart)		\
	READ_BYTE_REG_95X(pUart, MODEM_STATUS_REGISTER)


/* This writes to the SPR (Scratch Pad Register).	*/
#define WRITE_SCRATCH_PAD_REGISTER(pUart, Data)	\
	WRITE_BYTE_REG_95X(pUart, SCRATCH_PAD_REGISTER, Data)


/* This reads the SPR (Scratch Pad Register).		*/
#define READ_SCRATCH_PAD_REGISTER(pUart)	\
	READ_BYTE_REG_95X(pUart, SCRATCH_PAD_REGISTER)



/* Sets the divisor latch register.  
*  The divisor latch register is used to control the baud rate of the UART.	*/
#define WRITE_DIVISOR_LATCH(pUart, DesiredDivisor)						\
(												\
	WRITE_LINE_CONTROL(pUart, (BYTE)(READ_LINE_CONTROL(pUart) | LCR_DLAB)),			\
												\
	WRITE_BYTE_REG_95X(pUart, DIVISOR_LATCH_LSB, (BYTE)(DesiredDivisor & 0xFF)),		\
												\
	WRITE_BYTE_REG_95X(pUart, DIVISOR_LATCH_MSB, (BYTE)((DesiredDivisor & 0xFF00) >> 8)),	\
												\
	WRITE_LINE_CONTROL(pUart, (BYTE)(READ_LINE_CONTROL(pUart) & ~LCR_DLAB))			\
)



/* Reads the divisor latch register.  
*  The divisor latch register is used to control the baud rate of the UART.	*/
#define READ_DIVISOR_LATCH(pUart, pDivisor)							\
(												\
	WRITE_LINE_CONTROL(pUart, (BYTE)(READ_LINE_CONTROL(pUart) | LCR_DLAB)),			\
												\
	*pDivisor = (WORD)READ_BYTE_REG_95X(pUart, DIVISOR_LATCH_LSB),				\
												\
	*pDivisor |= (WORD)(READ_BYTE_REG_95X(pUart, DIVISOR_LATCH_MSB) << 8),			\
												\
	WRITE_LINE_CONTROL(pUart, (BYTE)(READ_LINE_CONTROL(pUart) & ~LCR_DLAB))			\
)



void WRITE_TO_OX950_ICR(PUART_OBJECT pUart, BYTE Register, BYTE Value);				
BYTE READ_FROM_OX950_ICR(PUART_OBJECT pUart, BYTE Register);
WORD CalculateBaudDivisor_95X(PUART_OBJECT pUart, DWORD DesiredBaud);


/* 16C95X UART REGISTERS */
typedef struct _UART_REGS_16C95X
{

	BYTE	REG_RHR, REG_IER, REG_FCR, REG_IIR, REG_LCR, REG_MCR, REG_LSR, REG_MSR, REG_SPR,
		REG_EFR, REG_XON1, REG_XON2, REG_XOFF1, REG_XOFF2,
		REG_ASR, REG_RFL, REG_TFL,
		REG_ACR, REG_CPR, REG_TCR, REG_TTL, REG_RTL, REG_FCL, REG_FCH, REG_ID1, REG_ID2, REG_ID3, REG_REV;

} UART_REGS_16C95X, *PUART_REGS_16C95X;


#endif	/* End of 16C95X.H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\spx\speed\uartlib\inc\private\uartprvt.h ===
/******************************************************************************
*	
*	$Workfile: uartprvt.h $ 
*
*	$Author: Psmith $ 
*
*	$Revision: 8 $
* 
*	$Modtime: 22/09/99 10:22 $ 
*
*	Description: Contains private UART Library definitions and prototypes.
*
******************************************************************************/
#if !defined(UARTPRVT_H)	/* UARTPRVT.H */
#define UARTPRVT_H

#include "os.h"	

#define UL_IM_SIZE_OF_BUFFER	10

#define UL_IM_SLOT_DATA		0x0
#define UL_IM_SLOT_STATUS	0x1



/* UART Object Structure */
typedef struct _UART_OBJECT
{
	PVOID		pUartData;		/* Pointer to UART Data */

	PUART_OBJECT	pNextUart;		/* Pointer to Next UART Object */
	PUART_OBJECT	pPreviousUart;		/* Pointer to Previous UART Object */

	DWORD		UartNumber;		/* UART Number.	*/
	PVOID		BaseAddress;		/* UART Base Address. */ 
	DWORD		RegisterStride;		/* UART Register Stride */
	DWORD		ClockFreq;		/* UART Clock Frequency in Hz */
	
	PBYTE		pInBuf;			/* Pointer to IN Buffer */
	DWORD		InBufSize;		/* Size of IN Buffer. */
	DWORD 		InBufBytes;		/* Number of bytes in buffer */
	DWORD		InBuf_ipos;		/* Offset into buffer to place new data into buffer. */
	DWORD		InBuf_opos;		/* Offset into buffer take data out of buffer. */

	PBYTE		pOutBuf;		/* Pointer to OUT Buffer */
	DWORD		OutBufSize;		/* Size of OUT Buffer. */
	DWORD		OutBuf_pos;		/* Offset into buffer take data out of buffer to transmit. */

	BYTE		ImmediateBuf[UL_IM_SIZE_OF_BUFFER][2];
	DWORD		ImmediateBytes;		/* Number of bytes to send */

	PUART_CONFIG	pUartConfig;		/* UART Configuration Structure. */

	PVOID		pAppBackPtr;		/* Back pointer to an application specific info. */

} UART_OBJECT;


/* Prototypes. */
PUART_OBJECT UL_CommonInitUart(PUART_OBJECT pPreviousUart);
void UL_CommonDeInitUart(PUART_OBJECT pUart);

int UL_CalcBufferAmount(int Buf_ipos, int Buf_opos, int BufSize);
int UL_CalcBufferSpace(int Buf_ipos, int Buf_opos, int BufSize);
/* End of Prototypes. */


#endif	/* End of UARTPRVT.H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\ser101\error.c ===
/*++

Copyright (c) 1991, 1992, 1993 Microsoft Corporation

Module Name:

    error.c

Abstract:

    This module contains the code that is very specific to error
    operations in the serial driver

Author:

    Anthony V. Ercolano 26-Sep-1991

Environment:

    Kernel mode

Revision History :

--*/

#include "precomp.h"


VOID
SerialCommError(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemContext1,
    IN PVOID SystemContext2
    )

/*++

Routine Description:

    This routine is invoked at dpc level to in response to
    a comm error.  All comm errors kill all read and writes

Arguments:

    Dpc - Not Used.

    DeferredContext - Really points to the device object.

    SystemContext1 - Not Used.

    SystemContext2 - Not Used.

Return Value:

    None.

--*/

{

    PSERIAL_DEVICE_EXTENSION Extension = DeferredContext;

    UNREFERENCED_PARAMETER(SystemContext1);
    UNREFERENCED_PARAMETER(SystemContext2);

    SerialDump(SERTRACECALLS, ("SERIAL: SerialCommError\n"));

    SerialKillAllReadsOrWrites(
        Extension->DeviceObject,
        &Extension->WriteQueue,
        &Extension->CurrentWriteIrp
        );

    SerialKillAllReadsOrWrites(
        Extension->DeviceObject,
        &Extension->ReadQueue,
        &Extension->CurrentReadIrp
        );


    SerialDpcEpilogue(Extension, Dpc);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\spx\speed\uartlib\inc\public\uartlib.h ===
/******************************************************************************
*	
*	$Workfile: uartlib.h $ 
*
*	$Author: Moti $ 
*
*	$Revision: 23 $
* 
*	$Modtime: 3/15/02 12:28p $ 
*
*	Description: Contains public UART Library definitions and prototypes.
*
******************************************************************************/
#if !defined(UARTLIB_H)		/* UARTLIB.H */
#define UARTLIB_H


/* UART object structure prototype */
typedef	struct _UART_OBJECT		*PUART_OBJECT;


/* UART_CONFIG.FrameConfig */
#define UC_FCFG_DATALEN_MASK		((DWORD)(0x0000000F))	/* Data Length mask for bits 0:3 */
#define UC_FCFG_DATALEN_5		((DWORD)(0x00<<0))	/* Bits 0:3 - Sets Data Word Length to 5 Bits. */
#define UC_FCFG_DATALEN_6		((DWORD)(0x01<<0))	/* Bits 0:3 - Sets Data Word Length to 6 Bits. */
#define UC_FCFG_DATALEN_7		((DWORD)(0x02<<0))	/* Bits 0:3 - Sets Data Word Length to 7 Bits. */
#define UC_FCFG_DATALEN_8		((DWORD)(0x03<<0))	/* Bits 0:3 - Sets Data Word Length to 8 Bits. */

#define UC_FCFG_STOPBITS_MASK		((DWORD)(0x000000F0))	/* Stop Bits mask for bits 4:7 */
#define UC_FCFG_STOPBITS_1		((DWORD)(0x00<<4))	/* Bits 4:7 - 1 Stop Bit. */
#define UC_FCFG_STOPBITS_1_5		((DWORD)(0x01<<4))	/* Bits 4:7 - 1.5 Stop Bits. */
#define UC_FCFG_STOPBITS_2		((DWORD)(0x02<<4))	/* Bits 4:7 - 2 Stop Bits. */
	
#define UC_FCFG_PARITY_MASK		((DWORD)(0x00000F00))	/* Parity Bits mask for bits 8:11 */
#define UC_FCFG_NO_PARITY		((DWORD)(0x00<<8))	/* Bits 8:11 - No Parity. */
#define UC_FCFG_ODD_PARITY		((DWORD)(0x01<<8))	/* Bits 8:11 - Odd Parity. */
#define UC_FCFG_EVEN_PARITY		((DWORD)(0x02<<8))	/* Bits 8:11 - Even Parity. */
#define UC_FCFG_MARK_PARITY		((DWORD)(0x03<<8))	/* Bits 8:11 - High Parity - Mark (Forced to 1). */
#define UC_FCFG_SPACE_PARITY		((DWORD)(0x04<<8))	/* Bits 8:11 - Low Parity - Space (Forced to 0). */


/* UART_CONFIG.InterruptEnable */
#define UC_IE_NO_INTS			((DWORD)(0x00))		/* No Interrupts - Interrupts Disabled. */
#define UC_IE_RX_STAT_INT		((DWORD)(0x01))		/* Bit 0 - Receive Status Interrupt. */
#define UC_IE_RX_INT			((DWORD)(0x02))		/* Bit 1 - Receive Data Available Interrupt. */
#define UC_IE_TX_INT			((DWORD)(0x04))		/* Bit 2 - Transmit Interrupt. */
#define UC_IE_TX_EMPTY_INT		((DWORD)(0x08))		/* Bit 3 - Transmit Empty Interrupt. */
#define UC_IE_MODEM_STAT_INT		((DWORD)(0x10))		/* Bit 4 - Modem Status Interrupt. */


/* UART_CONFIG.FlowControl */
#define UC_FLWC_RTS_FLOW_MASK		((DWORD)(0x0000000F))
#define UC_FLWC_NO_RTS_FLOW		((DWORD)(0x00<<0))	/* No RTS Handshaking */
#define UC_FLWC_RTS_HS			((DWORD)(0x01<<0))	/* RTS Handshaking */
#define UC_FLWC_RTS_TOGGLE		((DWORD)(0x02<<0))	/* RTS is raised when there is data to send and whilst being sent. */

#define UC_FLWC_CTS_FLOW_MASK		((DWORD)(0x000000F0))
#define UC_FLWC_NO_CTS_FLOW		((DWORD)(0x00<<4))	/* No CTS Handshaking */
#define UC_FLWC_CTS_HS			((DWORD)(0x01<<4))	/* CTS Handshaking */

#define UC_FLWC_DSR_FLOW_MASK		((DWORD)(0x00000F00))
#define UC_FLWC_NO_DSR_FLOW		((DWORD)(0x00<<8))	/* No DSR Handshaking */
#define UC_FLWC_DSR_HS			((DWORD)(0x01<<8))	/* DSR Handshaking */

#define UC_FLWC_DTR_FLOW_MASK		((DWORD)(0x0000F000))
#define UC_FLWC_NO_DTR_FLOW		((DWORD)(0x00<<12))	/* No DTR Handshaking */
#define UC_FLWC_DTR_HS			((DWORD)(0x01<<12))	/* DTR Handshaking */
#define UC_FLWC_DSR_IP_SENSITIVE	((DWORD)(0x02<<12))	/* DSR input sensitivity. */

#define UC_FLWC_TX_XON_XOFF_FLOW_MASK	((DWORD)(0x000F0000))	/* Transmit XON/XOFF flow control. */
#define UC_FLWC_TX_NO_XON_XOFF_FLOW	((DWORD)(0x00<<16))	/* No transmit XON/XOFF in-band flow control. */
#define UC_FLWC_TX_XON_XOFF_FLOW	((DWORD)(0x01<<16))	/* Transmit XON/XOFF in-band flow control. */
#define UC_FLWC_TX_XONANY_XOFF_FLOW	((DWORD)(0x02<<16))	/* Transmit XON Any/XOFF in-band flow control. */

/* 10.11.1999 ARG - ESIL 0928 */
/* Definition for Rx XON-ANY/XOFF flow control removed as not a feature of UART */
#define UC_FLWC_RX_XON_XOFF_FLOW_MASK	((DWORD)(0x00F00000))	/* Receive XON/XOFF flow control. */
#define UC_FLWC_RX_NO_XON_XOFF_FLOW	((DWORD)(0x00<<20))	/* No receive XON/XOFF in-band flow control. */
#define UC_FLWC_RX_XON_XOFF_FLOW	((DWORD)(0x01<<20))	/* Receive XON/XOFF in-band flow control. */

#define UC_FLWC_DISABLE_TXRX_MASK	((DWORD)(0xF0000000))
#define UC_FLWC_DISABLE_TX		((DWORD)(0x01<<28))	/* Disable Tx. */
#define UC_FLWC_DISABLE_RX		((DWORD)(0x02<<28))	/* Disable Rx. */
#define UC_FLWC_DISABLE_TXRX		((DWORD)(0x03<<28))	/* Disable Tx & Rx. */


/* UART_CONFIG.SpecialMode */
#define UC_SM_LOOPBACK_MODE		((DWORD)(0x01))	/* Place UART into internal loopback mode */
#define UC_SM_LOW_POWER_MODE		((DWORD)(0x02))	/* Place UART into low power mode */
#define UC_SM_TX_BREAK			((DWORD)(0x04))	/* Send break character */
#define UC_SM_DETECT_SPECIAL_CHAR	((DWORD)(0x08))	/* Detect special character */
#define UC_SM_DO_NULL_STRIPPING		((DWORD)(0x10))	/* Strip all NULLs from receive data */


/* Config Structure Masks */
#define UC_FRAME_CONFIG_MASK		((DWORD)(0x01))
#define UC_INT_ENABLE_MASK		((DWORD)(0x02))
#define UC_FLOW_CTRL_MASK		((DWORD)(0x04))
#define UC_FC_THRESHOLD_SETTING_MASK	((DWORD)(0x08))
#define UC_SPECIAL_CHARS_MASK		((DWORD)(0x10))
#define UC_TX_BAUD_RATE_MASK		((DWORD)(0x20))
#define UC_RX_BAUD_RATE_MASK		((DWORD)(0x40))
#define UC_SPECIAL_MODE_MASK		((DWORD)(0x80))
#define UC_ALL_MASK			((DWORD)(0xFFFF))


/* Configure UART Struct. */
typedef struct _UART_CONFIG
{
	/* UC_FRAME_CONFIG_MASK */
	DWORD FrameConfig;			/* Parity/Stop/Data */

	/* UC_INT_ENABLE_MASK */
	DWORD InterruptEnable;			/* Enable/Disable Interrupts */

	/* UC_FLOW_CTRL_MASK */
	DWORD FlowControl;			/* Receive & Transmit Flow Control Settings & Enable Tx & Rx. */
	
	/* UC_SPECIAL_CHARS_MASK */
	DWORD XON;				/* XON Special Character for XON/XOFF flow control. */
	DWORD XOFF;				/* XOFF Special Character for XON/XOFF flow control. */
	DWORD SpecialCharDetect;		/* Special Character to detect */
	
	/* UC_FC_THRESHOLD_SETTING_MASK */
	DWORD HiFlowCtrlThreshold;		/* High Flow control threshold level */
	DWORD LoFlowCtrlThreshold;		/* Low Flow control threshold level */

	/* UC_TX_BAUD_RATE_MASK */
	DWORD TxBaud;				/* Transmit baud rate. */

	/* UC_RX_BAUD_RATE_MASK */
	DWORD RxBaud;				/* Receive baud rate. */

	/* UC_SPECIAL_MODE_MASK */
	DWORD SpecialMode;			/* Special Mode */

} UART_CONFIG, *PUART_CONFIG;





/* Buffer Control Operations */
#define UL_BC_OP_FLUSH			0x01
#define UL_BC_OP_SET			0x02
#define UL_BC_OP_GET			0x03

#define UL_BC_FIFO			((DWORD)(0x01))
#define UL_BC_BUFFER			((DWORD)(0x02))
#define UL_BC_IN			((DWORD)(0x04))
#define UL_BC_OUT			((DWORD)(0x08))


/* Set UART Buffer Sizes Struct. */
typedef struct _SET_BUFFER_SIZES
{
	PBYTE pINBuffer;		/* Pointer to allocated IN buffer */
	DWORD INBufferSize;		/* IN buffer size */

	DWORD TxFIFOSize;		/* Tx FIFO size */
	DWORD RxFIFOSize;		/* Rx FIFO size */

	BYTE TxFIFOTrigLevel;		/* Tx FIFO interrupt trigger level. */
	BYTE RxFIFOTrigLevel;		/* Rx FIFO interrupt trigger level. */

} SET_BUFFER_SIZES, *PSET_BUFFER_SIZES;


/* Get UART Buffer State Struct. */
typedef struct _GET_BUFFER_STATE
{
	DWORD BytesInOUTBuffer;		/* Bytes in OUT buffer */
	DWORD BytesInINBuffer;		/* Bytes in IN buffer */
	DWORD BytesInTxFIFO;		/* Bytes in TX FIFO */
	DWORD BytesInRxFIFO;		/* Bytes in RX FIFO */

} GET_BUFFER_STATE, *PGET_BUFFER_STATE;



/* Modem Control Operations */
#define UL_MC_OP_SET			0x01
#define UL_MC_OP_BIT_SET		0x02
#define UL_MC_OP_BIT_CLEAR		0x03
#define UL_MC_OP_STATUS			0x04

/* Modem Control Signals */
#define UL_MC_RTS			((DWORD)0x00000001)	/* O	Read/Write */
#define UL_MC_DTR			((DWORD)0x00000002)	/* O	Read/Write */
#define UL_MC_DCD			((DWORD)0x00000004)	/* I	Read Only */
#define UL_MC_RI			((DWORD)0x00000008)	/* I	Read Only */
#define UL_MC_DSR			((DWORD)0x00000010)	/* I	Read Only */
#define UL_MC_CTS			((DWORD)0x00000020)	/* I	Read Only */

#define UL_MC_DELTA_DCD			((DWORD)0x00010000)	/* I	Read Only */
#define UL_MC_TRAILING_RI_EDGE		((DWORD)0x00020000)	/* I	Read Only */
#define UL_MC_DELTA_DSR			((DWORD)0x00040000)	/* I	Read Only */
#define UL_MC_DELTA_CTS			((DWORD)0x00080000)	/* I	Read Only */

#define UL_MC_INPUT_SIGNALS_CHANGED	(UL_MC_DELTA_DCD | UL_MC_TRAILING_RI_EDGE | UL_MC_DELTA_DSR | UL_MC_DELTA_CTS)


/* UART Information Struct. */
typedef struct _UART_INFO
{
	DWORD MaxTxFIFOSize;
	DWORD MaxRxFIFOSize;
	BOOLEAN PowerManagement;
	BOOLEAN IndependentRxBaud;

	DWORD	UART_SubType;
	DWORD	UART_Rev;

} UART_INFO, *PUART_INFO;


/* UART Interrupts Pending */
#define UL_IP_RX_STAT			((DWORD)0x1<<0)
#define UL_IP_RX			((DWORD)0x1<<1)
#define UL_IP_RXTO			((DWORD)0x1<<2)
#define UL_IP_TX			((DWORD)0x1<<3)
#define UL_IP_TX_EMPTY			((DWORD)0x1<<4)
#define UL_IP_MODEM			((DWORD)0x1<<5)



/* GetUartStatus operations */
#define UL_GS_OP_HOLDING_REASONS	0x1
#define UL_GS_OP_LINESTATUS		0x2


/* These are the reasons that the device could be holding. */
/* UART Status */
#define UL_TX_WAITING_FOR_CTS		((DWORD)0x00000001)
#define UL_TX_WAITING_FOR_DSR		((DWORD)0x00000002)
#define UL_TX_WAITING_FOR_DCD		((DWORD)0x00000004)
#define UL_TX_WAITING_FOR_XON		((DWORD)0x00000008)
#define UL_TX_WAITING_XOFF_SENT		((DWORD)0x00000010)
#define UL_TX_WAITING_ON_BREAK		((DWORD)0x00000020)
#define UL_RX_WAITING_FOR_DSR		((DWORD)0x00010000)

/* UART Status Errors */
#define UL_US_OVERRUN_ERROR		((DWORD)0x00000001)	/* Buffer Overrun Error */
#define UL_US_PARITY_ERROR		((DWORD)0x00000002)	/* Parity Error */
#define UL_US_FRAMING_ERROR		((DWORD)0x00000004)	/* Framing Error. */
#define UL_US_BREAK_ERROR		((DWORD)0x00000008)	/* Break Interrupt. */
#define UL_US_DATA_ERROR		((DWORD)0x00000010)	/* Error In Receive FIFO. */

/* Receive Status */
#define UL_RS_SPECIAL_CHAR_DETECTED	((DWORD)0x00000020)	/* Detected special char. */
#define UL_RS_BUFFER_OVERRUN		((DWORD)0x00000040)	/* IN Buffer Overrun */



/* Immediate Byte Operations */
#define UL_IM_OP_WRITE			0x1
#define UL_IM_OP_CANCEL			0x2
#define UL_IM_OP_STATUS			0x3

#define UL_IM_NO_BYTE_TO_SEND		0x0	/* Byte Does not need to be sent */
#define UL_IM_BYTE_TO_SEND		0x1	/* Byte needs to be sent */


/* Init UART Struct. */
typedef struct _INIT_UART
{
	DWORD	UartNumber;		/* UART Number.	*/
	PVOID	BaseAddress;		/* UART Base Address. */ 
	DWORD	RegisterStride;		/* UART Register Stride */
	DWORD	ClockFreq;		/* UART Clock Frequency in Hz */

} INIT_UART, *PINIT_UART;



typedef int	ULSTATUS;

/* General UART Library status codes */
#define UL_STATUS_SUCCESS				0
#define UL_STATUS_UNSUCCESSFUL				-1
#define UL_STATUS_INSUFFICIENT_RESOURCES		-2
#define UL_STATUS_INVALID_PARAMETER			-3
#define UL_STATUS_SAME_BASE_ADDRESS			-4
#define UL_STATUS_TOO_MANY_UARTS_FOR_CHIP		-5


// UL_GetUartObject Operations
#define UL_OP_GET_NEXT_UART			0x1
#define UL_OP_GET_PREVIOUS_UART			0x2




#define UL_LIB_16C65X_UART		1
#define UL_LIB_16C95X_UART		2

typedef struct _UART_LIB
{
	ULSTATUS	(*UL_InitUart_XXXX)(PINIT_UART pInitUart, PUART_OBJECT pFirstUart, PUART_OBJECT *ppUart);
	void		(*UL_DeInitUart_XXXX)(PUART_OBJECT pUart);
	void		(*UL_ResetUart_XXXX)(PUART_OBJECT pUart);
	ULSTATUS	(*UL_VerifyUart_XXXX)(PUART_OBJECT pUart);

	ULSTATUS	(*UL_SetConfig_XXXX)(PUART_OBJECT pUart, PUART_CONFIG pNewUartConfig, DWORD ConfigMask);
	ULSTATUS	(*UL_BufferControl_XXXX)(PUART_OBJECT pUart, PVOID pBufferControl, int Operation, DWORD Flags);

	ULSTATUS	(*UL_ModemControl_XXXX)(PUART_OBJECT pUart, PDWORD pModemSignals, int Operation);
	DWORD		(*UL_IntsPending_XXXX)(PUART_OBJECT *ppUart);
	void		(*UL_GetUartInfo_XXXX)(PUART_OBJECT pUart, PUART_INFO pUartInfo);

	int		(*UL_OutputData_XXXX)(PUART_OBJECT pUart);
	int		(*UL_InputData_XXXX)(PUART_OBJECT pUart, PDWORD pRxStatus);

	int		(*UL_ReadData_XXXX)(PUART_OBJECT pUart, PBYTE pDest, int Size);
	ULSTATUS	(*UL_WriteData_XXXX)(PUART_OBJECT pUart, PBYTE pData, int Size);
	ULSTATUS	(*UL_ImmediateByte_XXXX)(PUART_OBJECT pUart, PBYTE pData, int Operation);
	ULSTATUS	(*UL_GetStatus_XXXX)(PUART_OBJECT pUart, PDWORD pReturnData, int Operation);
	void		(*UL_DumpUartRegs_XXXX)(PUART_OBJECT pUart);

	void		(*UL_SetAppBackPtr_XXXX)(PUART_OBJECT pUart, PVOID pAppBackPtr);
	PVOID		(*UL_GetAppBackPtr_XXXX)(PUART_OBJECT pUart);
	void		(*UL_GetConfig_XXXX)(PUART_OBJECT pUart, PUART_CONFIG pUartConfig);
	PUART_OBJECT	(*UL_GetUartObject_XXXX)(PUART_OBJECT pUart, int Operation);


} UART_LIB, *PUART_LIB;


/* Prototypes - functions should not be called directly */	
void UL_SetAppBackPtr(PUART_OBJECT pUart, PVOID pAppBackPtr);
PVOID UL_GetAppBackPtr(PUART_OBJECT pUart);
void UL_GetConfig(PUART_OBJECT pUart, PUART_CONFIG pUartConfig);
PUART_OBJECT UL_GetUartObject(PUART_OBJECT pUart, int Operation);

ULSTATUS UL_InitUartLibrary(PUART_LIB pUartLib, int Library);
void UL_DeInitUartLibrary(PUART_LIB pUartLib);

/* End of prototypes. */


#endif	/* End of UARTLIB.H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\ser101\flush.c ===
/*++

Copyright (c) 1991, 1992, 1993 Microsoft Corporation

Module Name:

    flush.c

Abstract:

    This module contains the code that is very specific to flush
    operations in the serial driver

Author:

    Anthony V. Ercolano 26-Sep-1991

Environment:

    Kernel mode

Revision History :

--*/

#include "precomp.h"


NTSTATUS
SerialStartFlush(
    IN PSERIAL_DEVICE_EXTENSION Extension
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGESRP0,SerialFlush)
#pragma alloc_text(PAGESRP0,SerialStartFlush)
#endif


NTSTATUS
SerialFlush(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This is the dispatch routine for flush.  Flushing works by placing
    this request in the write queue.  When this request reaches the
    front of the write queue we simply complete it since this implies
    that all previous writes have completed.

Arguments:

    DeviceObject - Pointer to the device object for this device

    Irp - Pointer to the IRP for the current request

Return Value:

    Could return status success, cancelled, or pending.

--*/

{

    PSERIAL_DEVICE_EXTENSION Extension = DeviceObject->DeviceExtension;
    NTSTATUS status;
    PAGED_CODE();

    SerialDump(
        SERIRPPATH,
        ("SERIAL: Dispatch entry for: %x\n",Irp)
        );

    SerialDump(SERTRACECALLS, ("SERIAL: Entering SerialFlush\n"));

    

    Irp->IoStatus.Information = 0L;

    if ((status = SerialIRPPrologue(Irp, Extension)) == STATUS_SUCCESS) {

       if (SerialCompleteIfError(DeviceObject, Irp) != STATUS_SUCCESS) {
          SerialDump(SERTRACECALLS, ("SERIAL: Leaving SerialFlush (1)\n"));

          return STATUS_CANCELLED;

       }

       SerialDump(SERTRACECALLS, ("SERIAL: Leaving SerialFlush (2)\n"));

       return SerialStartOrQueue(Extension, Irp, &Extension->WriteQueue,
               &Extension->CurrentWriteIrp, SerialStartFlush);

    } else {
       Irp->IoStatus.Status = status;

       if (!NT_SUCCESS(status)) {
          SerialCompleteRequest(Extension, Irp, IO_NO_INCREMENT);
       }

       SerialDump(SERTRACECALLS, ("SERIAL: Leaving SerialFlush (3)\n"));
       return status;
    }
}


NTSTATUS
SerialStartFlush(
    IN PSERIAL_DEVICE_EXTENSION Extension
    )

/*++

Routine Description:

    This routine is called if there were no writes in the queue.
    The flush became the current write because there was nothing
    in the queue.  Note however that does not mean there is
    nothing in the queue now!  So, we will start off the write
    that might follow us.

Arguments:

    Extension - Points to the serial device extension

Return Value:

    This will always return STATUS_SUCCESS.

--*/

{

    PIRP NewIrp;
    PAGED_CODE();

    Extension->CurrentWriteIrp->IoStatus.Status = STATUS_SUCCESS;

    //
    // The following call will actually complete the flush.
    //

    SerialGetNextWrite(
        &Extension->CurrentWriteIrp,
        &Extension->WriteQueue,
        &NewIrp,
        TRUE,
        Extension
        );

    if (NewIrp) {

        ASSERT(NewIrp == Extension->CurrentWriteIrp);
        SerialStartWrite(Extension);

    }

    return STATUS_SUCCESS;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\ser101\immediat.c ===
/*++

Copyright (c) 1991, 1992, 1993 - 1997 Microsoft Corporation

Module Name:

    immediat.c

Abstract:

    This module contains the code that is very specific to transmit
    immediate character operations in the serial driver

Author:

    Anthony V. Ercolano 26-Sep-1991

Environment:

    Kernel mode

--*/

#include "precomp.h"

VOID
SerialGetNextImmediate(
    IN PIRP *CurrentOpIrp,
    IN PLIST_ENTRY QueueToProcess,
    IN PIRP *NewIrp,
    IN BOOLEAN CompleteCurrent,
    IN PSERIAL_DEVICE_EXTENSION Extension
    );

VOID
SerialCancelImmediate(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

BOOLEAN
SerialGiveImmediateToIsr(
    IN PVOID Context
    );

BOOLEAN
SerialGrabImmediateFromIsr(
    IN PVOID Context
    );

BOOLEAN
SerialGiveImmediateToIsr(
    IN PVOID Context
    );

BOOLEAN
SerialGrabImmediateFromIsr(
    IN PVOID Context
    );


#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGESER,SerialStartImmediate)
#pragma alloc_text(PAGESER,SerialGetNextImmediate)
#pragma alloc_text(PAGESER,SerialCancelImmediate)
#pragma alloc_text(PAGESER,SerialGiveImmediateToIsr)
#pragma alloc_text(PAGESER,SerialGrabImmediateFromIsr)
#endif


VOID
SerialStartImmediate(
    IN PSERIAL_DEVICE_EXTENSION Extension
    )

/*++

Routine Description:

    This routine will calculate the timeouts needed for the
    write.  It will then hand the irp off to the isr.  It
    will need to be careful incase the irp has been canceled.

Arguments:

    Extension - A pointer to the serial device extension.

Return Value:

    None.

--*/

{

    KIRQL OldIrql;
    LARGE_INTEGER TotalTime;
    BOOLEAN UseATimer;
    SERIAL_TIMEOUTS Timeouts;

    SERIAL_LOCKED_PAGED_CODE();


    SerialDump(SERTRACECALLS, ("SERIAL: SerialStartImmediate\n"));


    UseATimer = FALSE;
    Extension->CurrentImmediateIrp->IoStatus.Status = STATUS_PENDING;
    IoMarkIrpPending(Extension->CurrentImmediateIrp);

    //
    // Calculate the timeout value needed for the
    // request.  Note that the values stored in the
    // timeout record are in milliseconds.  Note that
    // if the timeout values are zero then we won't start
    // the timer.
    //

    KeAcquireSpinLock(
        &Extension->ControlLock,
        &OldIrql
        );

    Timeouts = Extension->Timeouts;

    KeReleaseSpinLock(
        &Extension->ControlLock,
        OldIrql
        );

    if (Timeouts.WriteTotalTimeoutConstant ||
        Timeouts.WriteTotalTimeoutMultiplier) {

        UseATimer = TRUE;

        //
        // We have some timer values to calculate.
        //

        TotalTime.QuadPart = (LONGLONG)((ULONG)Timeouts.WriteTotalTimeoutMultiplier);

        TotalTime.QuadPart += Timeouts.WriteTotalTimeoutConstant;

        TotalTime.QuadPart *= -10000;

    }

    //
    // As the irp might be going to the isr, this is a good time
    // to initialize the reference count.
    //

    SERIAL_INIT_REFERENCE(Extension->CurrentImmediateIrp);

    //
    // We need to see if this irp should be canceled.
    //

    IoAcquireCancelSpinLock(&OldIrql);
    if (Extension->CurrentImmediateIrp->Cancel) {

        PIRP OldIrp = Extension->CurrentImmediateIrp;

        Extension->CurrentImmediateIrp = NULL;
        IoReleaseCancelSpinLock(OldIrql);

        OldIrp->IoStatus.Status = STATUS_CANCELLED;
        OldIrp->IoStatus.Information = 0;

        SerialDump(
            SERIRPPATH,
            ("SERIAL: Complete Irp: %x\n",OldIrp)
            );
        SerialCompleteRequest(Extension, OldIrp, 0);

    } else {

        //
        // We give the irp to to the isr to write out.
        // We set a cancel routine that knows how to
        // grab the current write away from the isr.
        //

        IoSetCancelRoutine(
            Extension->CurrentImmediateIrp,
            SerialCancelImmediate
            );

        //
        // Since the cancel routine knows about the irp we
        // increment the reference count.
        //

        SERIAL_SET_REFERENCE(
            Extension->CurrentImmediateIrp,
            SERIAL_REF_CANCEL
            );

        if (UseATimer) {

            SerialSetTimer(
                &Extension->ImmediateTotalTimer,
                TotalTime,
                &Extension->TotalImmediateTimeoutDpc,
                Extension
                );

            //
            // Since the timer knows about the irp we increment
            // the reference count.
            //

            SERIAL_SET_REFERENCE(
                Extension->CurrentImmediateIrp,
                SERIAL_REF_TOTAL_TIMER
                );

        }

        KeSynchronizeExecution(
            Extension->Interrupt,
            SerialGiveImmediateToIsr,
            Extension
            );

        IoReleaseCancelSpinLock(OldIrql);

    }

}

VOID
SerialCompleteImmediate(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemContext1,
    IN PVOID SystemContext2
    )

{

    PSERIAL_DEVICE_EXTENSION Extension = DeferredContext;
    KIRQL OldIrql;

    UNREFERENCED_PARAMETER(SystemContext1);
    UNREFERENCED_PARAMETER(SystemContext2);


    SerialDump(SERTRACECALLS, ("SERIAL: SerialCompleteImmediate\n"));

    IoAcquireCancelSpinLock(&OldIrql);

    SerialTryToCompleteCurrent(
        Extension,
        NULL,
        OldIrql,
        STATUS_SUCCESS,
        &Extension->CurrentImmediateIrp,
        NULL,
        NULL,
        &Extension->ImmediateTotalTimer,
        NULL,
        SerialGetNextImmediate,
        SERIAL_REF_ISR
        );

    SerialDpcEpilogue(Extension, Dpc);

}

VOID
SerialTimeoutImmediate(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemContext1,
    IN PVOID SystemContext2
    )

{

    PSERIAL_DEVICE_EXTENSION Extension = DeferredContext;
    KIRQL OldIrql;

    UNREFERENCED_PARAMETER(SystemContext1);
    UNREFERENCED_PARAMETER(SystemContext2);


    SerialDump(SERTRACECALLS, ("SERIAL: SerialTimeoutImmediate\n"));

    IoAcquireCancelSpinLock(&OldIrql);

    SerialTryToCompleteCurrent(
        Extension,
        SerialGrabImmediateFromIsr,
        OldIrql,
        STATUS_TIMEOUT,
        &Extension->CurrentImmediateIrp,
        NULL,
        NULL,
        &Extension->ImmediateTotalTimer,
        NULL,
        SerialGetNextImmediate,
        SERIAL_REF_TOTAL_TIMER
        );

    SerialDpcEpilogue(Extension, Dpc);
}

VOID
SerialGetNextImmediate(
    IN PIRP *CurrentOpIrp,
    IN PLIST_ENTRY QueueToProcess,
    IN PIRP *NewIrp,
    IN BOOLEAN CompleteCurrent,
    IN PSERIAL_DEVICE_EXTENSION Extension
    )

/*++

Routine Description:

    This routine is used to complete the current immediate
    irp.  Even though the current immediate will always
    be completed and there is no queue associated with it,
    we use this routine so that we can try to satisfy
    a wait for transmit queue empty event.

Arguments:

    CurrentOpIrp - Pointer to the pointer that points to the
                   current write irp.  This should point
                   to CurrentImmediateIrp.

    QueueToProcess - Always NULL.

    NewIrp - Always NULL on exit to this routine.

    CompleteCurrent - Should always be true for this routine.


Return Value:

    None.

--*/

{

    KIRQL OldIrql;
//    PSERIAL_DEVICE_EXTENSION Extension = CONTAINING_RECORD(
//                                             CurrentOpIrp,
//                                             SERIAL_DEVICE_EXTENSION,
//                                             CurrentImmediateIrp
//                                             );
    PIRP OldIrp = *CurrentOpIrp;

    UNREFERENCED_PARAMETER(QueueToProcess);
    UNREFERENCED_PARAMETER(CompleteCurrent);
    SERIAL_LOCKED_PAGED_CODE();

    IoAcquireCancelSpinLock(&OldIrql);

    ASSERT(Extension->TotalCharsQueued >= 1);
    Extension->TotalCharsQueued--;

    *CurrentOpIrp = NULL;
    *NewIrp = NULL;
    KeSynchronizeExecution(
        Extension->Interrupt,
        SerialProcessEmptyTransmit,
        Extension
        );
    IoReleaseCancelSpinLock(OldIrql);

    SerialDump(
        SERIRPPATH,
        ("SERIAL: Complete Irp: %x\n",OldIrp)
        );
    
    SerialCompleteRequest(Extension, OldIrp, IO_SERIAL_INCREMENT);
}

VOID
SerialCancelImmediate(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is used to cancel a irp that is waiting on
    a comm event.

Arguments:

    DeviceObject - Pointer to the device object for this device

    Irp - Pointer to the IRP for the current request

Return Value:

    None.

--*/

{

    PSERIAL_DEVICE_EXTENSION Extension = DeviceObject->DeviceExtension;
    SERIAL_LOCKED_PAGED_CODE();

    SerialTryToCompleteCurrent(
        Extension,
        SerialGrabImmediateFromIsr,
        Irp->CancelIrql,
        STATUS_CANCELLED,
        &Extension->CurrentImmediateIrp,
        NULL,
        NULL,
        &Extension->ImmediateTotalTimer,
        NULL,
        SerialGetNextImmediate,
        SERIAL_REF_CANCEL
        );

}

BOOLEAN
SerialGiveImmediateToIsr(
    IN PVOID Context
    )

/*++

Routine Description:

    Try to start off the write by slipping it in behind
    a transmit immediate char, or if that isn't available
    and the transmit holding register is empty, "tickle"
    the UART into interrupting with a transmit buffer
    empty.

    NOTE: This routine is called by KeSynchronizeExecution.

    NOTE: This routine assumes that it is called with the
          cancel spin lock held.

Arguments:

    Context - Really a pointer to the device extension.

Return Value:

    This routine always returns FALSE.

--*/

{

    PSERIAL_DEVICE_EXTENSION Extension = Context;
    SERIAL_LOCKED_PAGED_CODE();

    Extension->TransmitImmediate = TRUE;
    Extension->ImmediateChar =
        *((UCHAR *)
         (Extension->CurrentImmediateIrp->AssociatedIrp.SystemBuffer));

    //
    // The isr now has a reference to the irp.
    //

    SERIAL_SET_REFERENCE(
        Extension->CurrentImmediateIrp,
        SERIAL_REF_ISR
        );

    //
    // Check first to see if a write is going on.  If
    // there is then we'll just slip in during the write.
    //

    if (!Extension->WriteLength) {

        //
        // If there is no normal write transmitting then we
        // will "re-enable" the transmit holding register empty
        // interrupt.  The 8250 family of devices will always
        // signal a transmit holding register empty interrupt
        // *ANY* time this bit is set to one.  By doing things
        // this way we can simply use the normal interrupt code
        // to start off this write.
        //
        // We've been keeping track of whether the transmit holding
        // register is empty so it we only need to do this
        // if the register is empty.
        //

        if (Extension->HoldingEmpty) {

            DISABLE_ALL_INTERRUPTS(Extension->Controller);
            ENABLE_ALL_INTERRUPTS(Extension->Controller);

        }

    }

    return FALSE;

}

BOOLEAN
SerialGrabImmediateFromIsr(
    IN PVOID Context
    )

/*++

Routine Description:


    This routine is used to grab the current irp, which could be timing
    out or canceling, from the ISR

    NOTE: This routine is being called from KeSynchronizeExecution.

    NOTE: This routine assumes that the cancel spin lock is held
          when this routine is called.

Arguments:

    Context - Really a pointer to the device extension.

Return Value:

    Always false.

--*/

{

    PSERIAL_DEVICE_EXTENSION Extension = Context;
    SERIAL_LOCKED_PAGED_CODE();

    if (Extension->TransmitImmediate) {

        Extension->TransmitImmediate = FALSE;

        //
        // Since the isr no longer references this irp, we can
        // decrement it's reference count.
        //

        SERIAL_CLEAR_REFERENCE(
            Extension->CurrentImmediateIrp,
            SERIAL_REF_ISR
            );

    }

    return FALSE;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\spx\speed\uartlib\inc\public\lib65x.h ===
/******************************************************************************
*	
*	$Workfile: lib65x.h $ 
*
*	$Author: Psmith $ 
*
*	$Revision: 1 $
* 
*	$Modtime: 6/06/00 16:06 $ 
*
*	Description: Contains function prototypes for 16C65X UART library functions. 
*
******************************************************************************/
#if !defined(_LIB65X_H)		/* LIB65X.H */
#define _LIB65X_H


ULSTATUS UL_InitUart_16C65X(PINIT_UART pInitUart, PUART_OBJECT pFirstUart, PUART_OBJECT *ppUart);
void UL_DeInitUart_16C65X(PUART_OBJECT pUart);
void UL_ResetUart_16C65X(PUART_OBJECT pUart);
ULSTATUS UL_VerifyUart_16C65X(PUART_OBJECT pUart);

ULSTATUS UL_SetConfig_16C65X(PUART_OBJECT pUart, PUART_CONFIG pNewUartConfig, DWORD ConfigMask);
ULSTATUS UL_BufferControl_16C65X(PUART_OBJECT pUart, PVOID pBufferControl, int Operation, DWORD Flags);

ULSTATUS UL_ModemControl_16C65X(PUART_OBJECT pUart, PDWORD pModemSignals, int Operation);
DWORD UL_IntsPending_16C65X(PUART_OBJECT *ppUart);
void UL_GetUartInfo_16C65X(PUART_OBJECT pUart, PUART_INFO pUartInfo);

int UL_OutputData_16C65X(PUART_OBJECT pUart);
int UL_InputData_16C65X(PUART_OBJECT pUart, PDWORD pRxStatus);

int UL_ReadData_16C65X(PUART_OBJECT pUart, PBYTE pDest, int Size);
ULSTATUS UL_WriteData_16C65X(PUART_OBJECT pUart, PBYTE pData, int Size);
ULSTATUS UL_ImmediateByte_16C65X(PUART_OBJECT pUart, PBYTE pData, int Operation);
ULSTATUS UL_GetStatus_16C65X(PUART_OBJECT pUart, PDWORD pReturnData, int Operation);
void UL_DumpUartRegs_16C65X(PUART_OBJECT pUart);

#define UL_SetAppBackPtr_16C65X		UL_SetAppBackPtr
#define UL_GetAppBackPtr_16C65X		UL_GetAppBackPtr

#define UL_GetConfig_16C65X		UL_GetConfig
#define UL_GetUartObject_16C65X		UL_GetUartObject


#endif	/* End of LIB65X.H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\ser101\initunlo.c ===
/*++

Copyright (c) 1991, 1992, 1993 - 1997 Microsoft Corporation

Module Name:

    initunlo.c

Abstract:

    This module contains the code that is very specific to initialization
    and unload operations in the serial driver

Author:

    Anthony V. Ercolano 26-Sep-1991

Environment:

    Kernel mode

--*/

#include "precomp.h"

//
// This is the actual definition of SerialDebugLevel.
// Note that it is only defined if this is a "debug"
// build.
//
#if DBG
extern ULONG SerialDebugLevel = 0;
#endif

//
// All our global variables except DebugLevel stashed in one
// little package
//
SERIAL_GLOBALS SerialGlobals;

static const PHYSICAL_ADDRESS SerialPhysicalZero = {0};

//
// We use this to query into the registry as to whether we
// should break at driver entry.
//

SERIAL_FIRMWARE_DATA    driverDefaults;

//
// This is exported from the kernel.  It is used to point
// to the address that the kernel debugger is using.
//
extern PUCHAR *KdComPortInUse;

//
// INIT - only needed during init and then can be disposed
// PAGESRP0 - always paged / never locked
// PAGESER - must be locked when a device is open, else paged
//
//
// INIT is used for DriverEntry() specific code
//
// PAGESRP0 is used for code that is not often called and has nothing
// to do with I/O performance.  An example, IRP_MJ_PNP/IRP_MN_START_DEVICE
// support functions
//
// PAGESER is used for code that needs to be locked after an open for both
// performance and IRQL reasons.
//

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT,DriverEntry)

#pragma alloc_text(PAGESRP0, SerialInitMultiPort)
#pragma alloc_text(PAGESRP0, SerialInitOneController)
#pragma alloc_text(PAGESRP0, SerialInitController)
#pragma alloc_text(PAGESRP0, SerialFindInitController)
#pragma alloc_text(PAGESRP0, SerialGetMappedAddress)
#pragma alloc_text(PAGESRP0, SerialRemoveDevObj)
#pragma alloc_text(PAGESRP0, SerialReleaseResources)
#pragma alloc_text(PAGESRP0, SerialUnload)
#pragma alloc_text(PAGESRP0, SerialMemCompare)


//
// PAGESER handled is keyed off of SerialReset, so SerialReset
// must remain in PAGESER for things to work properly
//

#pragma alloc_text(PAGESER, SerialGetDivisorFromBaud)
#pragma alloc_text(PAGESER, SerialReset)
#endif


NTSTATUS
DriverEntry(
           IN PDRIVER_OBJECT DriverObject,
           IN PUNICODE_STRING RegistryPath
           )

/*++

Routine Description:

    The entry point that the system point calls to initialize
    any driver.

    This routine will gather the configuration information,
    report resource usage, attempt to initialize all serial
    devices, connect to interrupts for ports.  If the above
    goes reasonably well it will fill in the dispatch points,
    reset the serial devices and then return to the system.

Arguments:

    DriverObject - Just what it says,  really of little use
    to the driver itself, it is something that the IO system
    cares more about.

    PathToRegistry - points to the entry for this driver
    in the current control set of the registry.

Return Value:

    Always STATUS_SUCCESS

--*/

{
   RTL_QUERY_REGISTRY_TABLE jensenTable[2] = {0};
   UNICODE_STRING jensenData;
   UNICODE_STRING jensenValue;
   BOOLEAN jensenDetected;
   PUCHAR jensenBuffer;

   //
   // Lock the paged code in their frames
   //

   PVOID lockPtr = MmLockPagableCodeSection(SerialReset);

   PAGED_CODE();


   ASSERT(SerialGlobals.PAGESER_Handle == NULL);
#if DBG
   SerialGlobals.PAGESER_Count = 0;
#endif
   SerialGlobals.PAGESER_Handle = lockPtr;

   SerialGlobals.RegistryPath.MaximumLength = RegistryPath->MaximumLength;
   SerialGlobals.RegistryPath.Length = RegistryPath->Length;
   SerialGlobals.RegistryPath.Buffer
      = ExAllocatePool(PagedPool, SerialGlobals.RegistryPath.MaximumLength);

   if (SerialGlobals.RegistryPath.Buffer == NULL) {
      MmUnlockPagableImageSection(lockPtr);
      return STATUS_INSUFFICIENT_RESOURCES;
   }

   RtlZeroMemory(SerialGlobals.RegistryPath.Buffer,
                 SerialGlobals.RegistryPath.MaximumLength);
   RtlMoveMemory(SerialGlobals.RegistryPath.Buffer,
                 RegistryPath->Buffer, RegistryPath->Length);

   //
   // Initialize all our globals
   //

   InitializeListHead(&SerialGlobals.AllDevObjs);

   //
   // Call to find out default values to use for all the devices that the 
   // driver controls, including whether or not to break on entry.
   //

   SerialGetConfigDefaults(&driverDefaults, RegistryPath);

#if DBG
   //
   // Set global debug output level
   // 
   SerialDebugLevel = driverDefaults.DebugLevel;
#endif

   //
   // Break on entry if requested via registry
   //

   if (driverDefaults.ShouldBreakOnEntry) {
      DbgBreakPoint();
   }


   //
   // Just dump out how big the extension is.
   //

   SerialDump(SERDIAG1, ("SERIAL: The number of bytes in the extension is: %d"
                         "\n", sizeof(SERIAL_DEVICE_EXTENSION)));


   //
   // Initialize the Driver Object with driver's entry points
   //

   DriverObject->DriverUnload                          = SerialUnload;
   DriverObject->DriverExtension->AddDevice            = SerialAddDevice;

   DriverObject->MajorFunction[IRP_MJ_FLUSH_BUFFERS]   = SerialFlush;
   DriverObject->MajorFunction[IRP_MJ_WRITE]           = SerialWrite;
   DriverObject->MajorFunction[IRP_MJ_READ]            = SerialRead;
   DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL]  = SerialIoControl;
   DriverObject->MajorFunction[IRP_MJ_INTERNAL_DEVICE_CONTROL]
      = SerialInternalIoControl;
   DriverObject->MajorFunction[IRP_MJ_CREATE]          = SerialCreateOpen;
   DriverObject->MajorFunction[IRP_MJ_CLOSE]           = SerialClose;
   DriverObject->MajorFunction[IRP_MJ_CLEANUP]         = SerialCleanup;
   DriverObject->MajorFunction[IRP_MJ_PNP]             = SerialPnpDispatch;
   DriverObject->MajorFunction[IRP_MJ_POWER]           = SerialPowerDispatch;

   DriverObject->MajorFunction[IRP_MJ_QUERY_INFORMATION]
      = SerialQueryInformationFile;
   DriverObject->MajorFunction[IRP_MJ_SET_INFORMATION]
      = SerialSetInformationFile;

   DriverObject->MajorFunction[IRP_MJ_SYSTEM_CONTROL]
      = SerialSystemControlDispatch;

   if (!(jensenBuffer = ExAllocatePool(
                                      PagedPool,
                                      512
                                      ))) {

      //
      // We couldn't allocate 512 bytes of paged pool.  If that's
      // so, then it's likely that the least of this machine's problems
      // is that it's a Jensen.
      //

      jensenDetected = FALSE;

   } else {

      //
      // Check to see if this is a Jensen alpha.  If it is, then
      // we'll have to change the way we enable and disable interrupts
      //

      jensenData.Length = 0;
      jensenData.MaximumLength = 512;
      jensenData.Buffer = (PWCHAR)&jensenBuffer[0];
      RtlInitUnicodeString(
                          &jensenValue,
                          L"Jensen"
                          );
      jensenTable[0].Flags = RTL_QUERY_REGISTRY_DIRECT
                             | RTL_QUERY_REGISTRY_REQUIRED;
      jensenTable[0].Name = L"Identifier";
      jensenTable[0].EntryContext = &jensenData;

      if (!NT_SUCCESS(RtlQueryRegistryValues(RTL_REGISTRY_ABSOLUTE
                                             | RTL_REGISTRY_OPTIONAL,
                                             L"\\REGISTRY\\MACHINE\\HARDWARE"
                                             L"\\DESCRIPTION\\SYSTEM",
                                             &jensenTable[0], NULL, NULL))) {

         //
         // How odd, no identifer string! We'll it's probably not a jensen.
         //

         jensenDetected = FALSE;

      } else {

         //
         // Skip past the DEC-XX Portion of the name string.
         // Be carful and make sure we have at least that much data.
         //

         if (jensenData.Length <= (sizeof(WCHAR)*6)) {

            jensenDetected = FALSE;

         } else {

            jensenData.Length -= (sizeof(WCHAR)*6);
            jensenData.MaximumLength -= (sizeof(WCHAR)*6);
            jensenData.Buffer = (PWCHAR)&jensenBuffer[sizeof(WCHAR)*6];
            jensenDetected = RtlEqualUnicodeString(
                                                  &jensenData,
                                                  &jensenValue,
                                                  FALSE
                                                  );
         }

      }

      ExFreePool(jensenBuffer);

   }

   if (jensenDetected) {

      SerialDump(
                SERDIAG1,
                ("SERIAL: Jensen Detected\n")
                );

   }

   driverDefaults.JensenDetected = jensenDetected;

#if !defined(NO_LEGACY_DRIVERS)

#define SerialDoLegacyConversion() (~0)

   //
   // Enumerate and Initialize legacy devices if necessary.  This should go away
   // and be done by setup.
   //

   if (SerialDoLegacyConversion()) {
#if DBG
      InterlockedIncrement(&SerialGlobals.PAGESER_Count);
#endif
      (void)SerialEnumerateLegacy(DriverObject, RegistryPath, &driverDefaults);
#if DBG
      InterlockedDecrement(&SerialGlobals.PAGESER_Count);
#endif
   }
#endif // NO_LEGACY_DRIVERS

   //
   // Unlock pageable text
   //
   MmUnlockPagableImageSection(lockPtr);

   return STATUS_SUCCESS;
}




BOOLEAN
SerialCleanLists(IN PVOID Context)
/*++

Routine Description:

    Removes a device object from any of the serial linked lists it may
    appear on.
    
Arguments:

    Context - Actually a PSERIAL_DEVICE_EXTENSION (for the devobj being
              removed).

Return Value:

    Always TRUE

--*/
{
   PSERIAL_DEVICE_EXTENSION pDevExt = (PSERIAL_DEVICE_EXTENSION)Context;

    //
    // If we are a multiport device, remove our entry
    //

    if (pDevExt->PortOnAMultiportCard) {
       PSERIAL_MULTIPORT_DISPATCH pDispatch
          = (PSERIAL_MULTIPORT_DISPATCH)pDevExt->OurIsrContext;

       SerialDump(SERPNPPOWER,("SERIAL: CLEAN: removing multiport isr ext\n"));

       pDispatch->Extensions[pDevExt->PortIndex - 1] = NULL;

       if (pDevExt->Indexed == FALSE) {
          pDispatch->UsablePortMask &= ~(1 << (pDevExt->PortIndex - 1));
          pDispatch->MaskInverted &= ~(pDevExt->NewMaskInverted);
       }
    }

   if (!IsListEmpty(&pDevExt->TopLevelSharers)) {

      SerialDump(SERPNPPOWER,("SERIAL: CLEAN: Device is a sharer\n"));

      //
      // If we have siblings, the first becomes the sharer
      //

      if (!IsListEmpty(&pDevExt->MultiportSiblings)) {
         PSERIAL_DEVICE_EXTENSION pNewRoot;

         SerialDump(SERPNPPOWER,("SERIAL: CLEAN: Transferring to siblings\n"));

         pNewRoot = CONTAINING_RECORD(pDevExt->MultiportSiblings.Flink,
                                      SERIAL_DEVICE_EXTENSION,
                                      MultiportSiblings);

         //
         // He should not be on there already
         //

         ASSERT(IsListEmpty(&pNewRoot->TopLevelSharers));
         InsertTailList(&pDevExt->TopLevelSharers, &pNewRoot->TopLevelSharers);
        
      }

      //
      // Remove ourselves
      //

      RemoveEntryList(&pDevExt->TopLevelSharers);
      InitializeListHead(&pDevExt->TopLevelSharers);

      //
      // Now check the master list to see if anyone is left...
      //

      if (!IsListEmpty(&pDevExt->CIsrSw->SharerList)) {
         //
         // Others are chained on this interrupt, so we don't want to
         // disconnect it.
         //

         pDevExt->Interrupt = NULL;
      }
   }

   //
   // If this is part of a multiport board and we still have
   // siblings, remove us from that list
   //

   if (!IsListEmpty(&pDevExt->MultiportSiblings)) {
      SerialDump(SERPNPPOWER,("SERIAL: CLEAN: Has multiport siblings\n"));
      RemoveEntryList(&pDevExt->MultiportSiblings);
      InitializeListHead(&pDevExt->MultiportSiblings);
   }
    

   if (!IsListEmpty(&pDevExt->CommonInterruptObject)) {

      SerialDump(SERPNPPOWER,("SERIAL: CLEAN: Common intobj member\n"));

      RemoveEntryList(&pDevExt->CommonInterruptObject);
      InitializeListHead(&pDevExt->CommonInterruptObject);

      //
      // Others are sharing this interrupt object so we detach ourselves
      // from it this way instead of disconnecting.
      // 

      pDevExt->Interrupt = NULL;
   }

   //
   // AllDevObjs should never be empty since we have a sentinal
   //

   ASSERT(!IsListEmpty(&pDevExt->AllDevObjs));

   RemoveEntryList(&pDevExt->AllDevObjs);
   InitializeListHead(&pDevExt->AllDevObjs);

   return TRUE;
}



VOID
SerialReleaseResources(IN PSERIAL_DEVICE_EXTENSION PDevExt)
/*++

Routine Description:

    Releases resources (not pool) stored in the device extension.
    
Arguments:

    PDevExt - Pointer to the device extension to release resources from.

Return Value:

    VOID

--*/
{
   PAGED_CODE();

   SerialDump(SERTRACECALLS,("SERIAL: Enter SerialReleaseResources\n"));

   //
   // Remove us from any lists we may be on
   //

   if (PDevExt->Interrupt != NULL) {
      KeSynchronizeExecution(PDevExt->Interrupt, SerialCleanLists, PDevExt);
   }

   //
   // SerialCleanLists can remove our interrupt from us...
   //

   if (PDevExt->Interrupt != NULL) {
      //
      // Stop servicing interrupts if we are the owner
      //

      SerialDump(SERPNPPOWER,
                 ("SERIAL: Release - disconnecting interrupt %08X\n",
                  PDevExt->Interrupt));

      IoDisconnectInterrupt(PDevExt->Interrupt);
      PDevExt->Interrupt = NULL;

      if (PDevExt->CIsrSw != NULL) {
         ExFreePool(PDevExt->CIsrSw);
         PDevExt->CIsrSw = NULL;
      }
   }

   if (PDevExt->PortOnAMultiportCard) {
       ULONG i;

       //
       // If we are the last device, free this memory
       //

       for (i = 0; i < SERIAL_MAX_PORTS_INDEXED; i++) {
          if (((PSERIAL_MULTIPORT_DISPATCH)PDevExt->OurIsrContext)
              ->Extensions[i] != NULL) {
             break;
          }
       }

       if (i == SERIAL_MAX_PORTS_INDEXED) {
          SerialDump(SERPNPPOWER,("SERIAL: Release - freeing multi context\n"));
          ExFreePool(PDevExt->OurIsrContext);
       }
    }


   //
   // Stop handling timers
   //

   SerialCancelTimer(&PDevExt->ReadRequestTotalTimer, PDevExt);
   SerialCancelTimer(&PDevExt->ReadRequestIntervalTimer, PDevExt);
   SerialCancelTimer(&PDevExt->WriteRequestTotalTimer, PDevExt);
   SerialCancelTimer(&PDevExt->ImmediateTotalTimer, PDevExt);
   SerialCancelTimer(&PDevExt->XoffCountTimer, PDevExt);
   SerialCancelTimer(&PDevExt->LowerRTSTimer, PDevExt);

   //
   // Stop servicing DPC's
   //

   SerialRemoveQueueDpc(&PDevExt->CompleteWriteDpc, PDevExt);
   SerialRemoveQueueDpc(&PDevExt->CompleteReadDpc, PDevExt);
   SerialRemoveQueueDpc(&PDevExt->TotalReadTimeoutDpc, PDevExt);
   SerialRemoveQueueDpc(&PDevExt->IntervalReadTimeoutDpc, PDevExt);
   SerialRemoveQueueDpc(&PDevExt->TotalWriteTimeoutDpc, PDevExt);
   SerialRemoveQueueDpc(&PDevExt->CommErrorDpc, PDevExt);
   SerialRemoveQueueDpc(&PDevExt->CompleteImmediateDpc, PDevExt);
   SerialRemoveQueueDpc(&PDevExt->TotalImmediateTimeoutDpc, PDevExt);
   SerialRemoveQueueDpc(&PDevExt->CommWaitDpc, PDevExt);
   SerialRemoveQueueDpc(&PDevExt->XoffCountTimeoutDpc, PDevExt);
   SerialRemoveQueueDpc(&PDevExt->XoffCountCompleteDpc, PDevExt);
   SerialRemoveQueueDpc(&PDevExt->StartTimerLowerRTSDpc, PDevExt);
   SerialRemoveQueueDpc(&PDevExt->PerhapsLowerRTSDpc, PDevExt);

  

   //
   // If necessary, unmap the device registers.
   //

   if (PDevExt->UnMapRegisters) {
      MmUnmapIoSpace(PDevExt->Controller, PDevExt->SpanOfController);
   }

   if (PDevExt->UnMapStatus) {
      MmUnmapIoSpace(PDevExt->InterruptStatus,
                     PDevExt->SpanOfInterruptStatus);
   }

   SerialDump(SERTRACECALLS,("SERIAL: Leave SerialReleaseResources\n"));
}



NTSTATUS
SerialPrepareRemove(IN PDEVICE_OBJECT PDevObj)
/*++

Routine Description:

    Removes a serial device object from the system.
    
Arguments:

    PDevObj - A pointer to the Device Object we want removed.

Return Value:

    Always TRUE

--*/
{
   PSERIAL_DEVICE_EXTENSION pDevExt
      = (PSERIAL_DEVICE_EXTENSION)PDevObj->DeviceExtension;
   POWER_STATE state;
   ULONG pendingIRPs;

   PAGED_CODE();

   SerialDump(SERTRACECALLS,("SERIAL: Enter SerialPrepareRemove\n"));

   //
   // Mark as not accepting requests
   //

   SerialSetAccept(pDevExt, SERIAL_PNPACCEPT_REMOVING);

   //
   // Complete all pending requests
   //

   SerialKillPendingIrps(PDevObj);

   //
   // Wait for any pending requests we raced on.
   //

   pendingIRPs = InterlockedDecrement(&pDevExt->PendingIRPCnt);
         
   if (pendingIRPs) {
      KeWaitForSingleObject(&pDevExt->PendingIRPEvent, Executive, KernelMode, 
                            FALSE, NULL);
   }

   state.DeviceState = PowerDeviceD3;

   PoSetPowerState(PDevObj, DevicePowerState, state);

   return TRUE;
}


VOID
SerialDisableInterfacesResources(IN PDEVICE_OBJECT PDevObj,
                                 BOOLEAN DisableUART)
{
   PSERIAL_DEVICE_EXTENSION pDevExt
      = (PSERIAL_DEVICE_EXTENSION)PDevObj->DeviceExtension;

#if defined(NEC_98)
   //
   // This argument use at MACRO only.
   //
   PSERIAL_DEVICE_EXTENSION Extension = pDevExt;
#else
#endif //defined(NEC_98)

   PAGED_CODE();

   SerialDump(SERTRACECALLS,("SERIAL: Enter SerialDisableInterfaces\n"));

   //
   // Only do these many things if the device has started and still
   // has resources allocated
   //

   if (pDevExt->Flags & SERIAL_FLAGS_STARTED) {
       if (!(pDevExt->Flags & SERIAL_FLAGS_STOPPED)) {

           if (DisableUART) {
              //
              // Mask off interrupts
              //

              DISABLE_ALL_INTERRUPTS(pDevExt->Controller);

           }

           SerialReleaseResources(pDevExt);
       }

      //
      // Remove us from WMI consideration
      //

      IoWMIRegistrationControl(PDevObj, WMIREG_ACTION_DEREGISTER);
   }

   //
   // Undo external names
   //

   SerialUndoExternalNaming(pDevExt);

   SerialDump(SERTRACECALLS,("SERIAL: Exit SerialDisableInterfaces\n"));
}


NTSTATUS
SerialRemoveDevObj(IN PDEVICE_OBJECT PDevObj)
/*++

Routine Description:

    Removes a serial device object from the system.
    
Arguments:

    PDevObj - A pointer to the Device Object we want removed.

Return Value:

    Always TRUE

--*/
{
   PSERIAL_DEVICE_EXTENSION pDevExt
      = (PSERIAL_DEVICE_EXTENSION)PDevObj->DeviceExtension;

   PAGED_CODE();

   SerialDump(SERTRACECALLS,("SERIAL: Enter SerialRemoveDevObj\n"));

   if (!(pDevExt->DevicePNPAccept & SERIAL_PNPACCEPT_SURPRISE_REMOVING)) {
      //
      // Disable all external interfaces and release resources
      //

      SerialDisableInterfacesResources(PDevObj, TRUE);
   }

   IoDetachDevice(pDevExt->LowerDeviceObject);

   //
   // Free memory allocated in the extension
   //

   if (pDevExt->NtNameForPort.Buffer != NULL) {
      ExFreePool(pDevExt->NtNameForPort.Buffer);
   }

   if (pDevExt->DeviceName.Buffer != NULL) {
      ExFreePool(pDevExt->DeviceName.Buffer);
   }

   if (pDevExt->SymbolicLinkName.Buffer != NULL) {
      ExFreePool(pDevExt->SymbolicLinkName.Buffer);
   }

   if (pDevExt->DosName.Buffer != NULL) {
      ExFreePool(pDevExt->DosName.Buffer);
   }

   if (pDevExt->ObjectDirectory.Buffer) {
      ExFreePool(pDevExt->ObjectDirectory.Buffer);
   }

   //
   // Delete the devobj
   //

   IoDeleteDevice(PDevObj);


   SerialDump(SERTRACECALLS,("SERIAL: Leave SerialRemoveDevObj\n"));

   return STATUS_SUCCESS;
}


VOID
SerialKillPendingIrps(PDEVICE_OBJECT PDevObj)
/*++

Routine Description:

   This routine kills any irps pending for the passed device object.
   
Arguments:

    PDevObj - Pointer to the device object whose irps must die.

Return Value:

    VOID

--*/
{
   PSERIAL_DEVICE_EXTENSION pDevExt = PDevObj->DeviceExtension;
   KIRQL oldIrql;
   
   SerialDump (SERTRACECALLS,("SERIAL: Enter SerialKillPendingIrps\n"));

   //
   // First kill all the reads and writes.
   //

    SerialKillAllReadsOrWrites(PDevObj, &pDevExt->WriteQueue,
                               &pDevExt->CurrentWriteIrp);

    SerialKillAllReadsOrWrites(PDevObj, &pDevExt->ReadQueue,
                               &pDevExt->CurrentReadIrp);

    //
    // Next get rid of purges.
    //

    SerialKillAllReadsOrWrites(PDevObj, &pDevExt->PurgeQueue,
                               &pDevExt->CurrentPurgeIrp);

    //
    // Get rid of any mask operations.
    //

    SerialKillAllReadsOrWrites(PDevObj, &pDevExt->MaskQueue,
                               &pDevExt->CurrentMaskIrp);

    //
    // Now get rid a pending wait mask irp.
    //

    IoAcquireCancelSpinLock(&oldIrql);

    if (pDevExt->CurrentWaitIrp) {

        PDRIVER_CANCEL cancelRoutine;

        cancelRoutine = pDevExt->CurrentWaitIrp->CancelRoutine;
        pDevExt->CurrentWaitIrp->Cancel = TRUE;

        if (cancelRoutine) {

            pDevExt->CurrentWaitIrp->CancelIrql = oldIrql;
            pDevExt->CurrentWaitIrp->CancelRoutine = NULL;

            cancelRoutine(PDevObj, pDevExt->CurrentWaitIrp);

        }

    } else {

        IoReleaseCancelSpinLock(oldIrql);

    }

    //
    // Cancel any pending wait-wake irps
    //

    if (pDevExt->PendingWakeIrp != NULL) {
       IoCancelIrp(pDevExt->PendingWakeIrp);
       pDevExt->PendingWakeIrp = NULL;
    }

    //
    // Finally, dump any stalled IRPS
    //

    SerialKillAllStalled(PDevObj);


    SerialDump (SERTRACECALLS,("SERIAL: Leave SerialKillPendingIrps\n"));
}


BOOLEAN
SerialSingleToMulti(PVOID Context)
/*++

Routine Description:

    This routine converts a root device set up to be a single port
    device to a multiport device while that device is running.
    
Arguments:

    Context - Actually a pointer to the device extension of the root
              device we are turning into a multiport device.
              
Return Value:

    Always TRUE

--*/
{
   PSERIAL_DEVICE_EXTENSION pDevExt = (PSERIAL_DEVICE_EXTENSION)Context;
   PSERIAL_MULTIPORT_DISPATCH pOurIsrContext;
   PSERIAL_MULTIPORT_DISPATCH pNewIsrContext
      = (PSERIAL_MULTIPORT_DISPATCH)pDevExt->NewExtension;
   PVOID isrFunc;

   SerialDump (SERTRACECALLS,("SERIAL: Enter SerialSingleToMulti\n"));

   //
   // Stomp OurIsrContext since we are going from one to many
   // thus our previous context was just pDevExt and doesn't
   // need to be released (i.e., no call to ExFreePool() is needed).
   //

   pOurIsrContext = pDevExt->OurIsrContext = pDevExt->TopLevelOurIsrContext
      = pNewIsrContext;

   //
   // We are now multiport
   //

   pDevExt->PortOnAMultiportCard = TRUE;

   //
   // Update our personal extensions slot
   //

   pOurIsrContext->Extensions[pDevExt->PortIndex - 1] = pDevExt;
   pOurIsrContext->InterruptStatus = pDevExt->InterruptStatus;


   //
   // We have to pick a new ISR and a new context.
   // As soon as this is done, the ISR will change, so we have to
   // be ready to handle things there.
   //

   if (pDevExt->Indexed == FALSE) {
      pOurIsrContext->UsablePortMask = 1 << (pDevExt->PortIndex - 1);
      pOurIsrContext->MaskInverted = pDevExt->MaskInverted;
      isrFunc = SerialBitMappedMultiportIsr;
   } else {
      isrFunc = SerialIndexedMultiportIsr;
   }

   pDevExt->OurIsr = isrFunc;
   pDevExt->TopLevelOurIsr = isrFunc;

   if (pDevExt->CIsrSw->IsrFunc != SerialSharerIsr) {
         pDevExt->CIsrSw->IsrFunc = isrFunc;
         pDevExt->CIsrSw->Context = pOurIsrContext;
   }

   SerialDump (SERTRACECALLS,("SERIAL: Leave SerialSingleToMulti\n"));
   return TRUE;
}


BOOLEAN
SerialAddToMulti(PVOID Context)
/*++

Routine Description:

    This routine adds a new port to a multiport device while that device is
    running.
    
Arguments:

    Context - Actually a pointer to the device extension of the root
              device we are adding a port to.
              
Return Value:

    Always TRUE

--*/
{
   PSERIAL_DEVICE_EXTENSION pDevExt = (PSERIAL_DEVICE_EXTENSION)Context;
   PSERIAL_MULTIPORT_DISPATCH pOurIsrContext
      = (PSERIAL_MULTIPORT_DISPATCH)pDevExt->OurIsrContext;
   PSERIAL_DEVICE_EXTENSION pNewExt
      = (PSERIAL_DEVICE_EXTENSION)pDevExt->NewExtension;


   SerialDump (SERTRACECALLS,("SERIAL: Enter SerialAddToMulti\n"));

   if (pDevExt->Indexed == FALSE) {
      pOurIsrContext->UsablePortMask |= 1 << (pDevExt->NewPortIndex - 1);
      pOurIsrContext->MaskInverted |= pDevExt->NewMaskInverted;
   }

   //
   // Add us to the linked list of common interrupt objects if we are not
   // already in it. We may be if there is another device besides our
   // multiport card.
   //

   if (IsListEmpty(&pNewExt->CommonInterruptObject)) {
      InsertTailList(&pDevExt->CommonInterruptObject,
                     &pNewExt->CommonInterruptObject);
   }

   //
   // Give us the list of contexts also
   //

   pNewExt->OurIsrContext = pOurIsrContext;


   //
   // Add us to the list of our siblings
   //
   InsertTailList(&pDevExt->MultiportSiblings, &pNewExt->MultiportSiblings);

   SerialDump(SERDIAG1, ("SERIAL: Adding to multi...\n"));
   SerialDump(SERDIAG1, ("------: old ext %x\n", pDevExt));

   //
   // Map us in so the ISR can find us.
   //

   pOurIsrContext->Extensions[pDevExt->NewPortIndex - 1]
      = pDevExt->NewExtension;

   pNewExt->TopLevelOurIsr = pDevExt->TopLevelOurIsr;
   pNewExt->TopLevelOurIsrContext = pDevExt->TopLevelOurIsrContext;

   SerialDump (SERTRACECALLS,("SERIAL: Leave SerialAddToMulti\n"));
   return TRUE;
}



NTSTATUS
SerialInitMultiPort(IN PSERIAL_DEVICE_EXTENSION PDevExt,
                    IN PCONFIG_DATA PConfigData, IN PDEVICE_OBJECT PDevObj)
/*++

Routine Description:

    This routine initializes a multiport device by adding a port to an existing
    one.
    
Arguments:

    PDevExt - pointer to the device extension of the root of the multiport
              device.
              
    PConfigData - pointer to the config data for the new port 
             
    PDevObj - pointer to the devobj for the new port
              
Return Value:

    STATUS_SUCCESS on success, appropriate error on failure.

--*/
{
   PSERIAL_DEVICE_EXTENSION pOurIsrContext
      = (PSERIAL_DEVICE_EXTENSION)PDevExt->OurIsrContext;
   PSERIAL_DEVICE_EXTENSION pNewExt
      = (PSERIAL_DEVICE_EXTENSION)PDevObj->DeviceExtension;
   NTSTATUS status;
   PSERIAL_MULTIPORT_DISPATCH pDispatch;

   PAGED_CODE();


   SerialDump (SERTRACECALLS,("SERIAL: Enter SerialInitMultiPort\n"));

   //
   // Allow him to share our CISRsw and interrupt object
   //

   pNewExt->CIsrSw = PDevExt->CIsrSw;
   pNewExt->Interrupt = PDevExt->Interrupt;

   //
   // First, see if we can initialize the one we have found
   //

   status = SerialInitOneController(PDevObj, PConfigData);

   if (!NT_SUCCESS(status)) {
      SerialDump (SERTRACECALLS,("SERIAL: Leave SerialInitMultiPort\n"));
      return status;
   }

   //
   // OK.  He's good to go.  Find the root controller.  He may
   // currently be a single, so we have to change him to multi.
   //

   if (PDevExt->PortOnAMultiportCard != TRUE) {

      pDispatch = PDevExt->NewExtension
         = ExAllocatePool(NonPagedPool, sizeof(SERIAL_MULTIPORT_DISPATCH));

      if (pDispatch == NULL) {
         // FAIL and CLEANUP
         SerialDump (SERTRACECALLS,("SERIAL: Leave SerialInitMultiPort\n"));
         return STATUS_INSUFFICIENT_RESOURCES;
      }

      RtlZeroMemory(pDispatch, sizeof(*pDispatch));
      KeSynchronizeExecution(PDevExt->Interrupt, SerialSingleToMulti, PDevExt);
   }

   //
   // Update some important fields
   //

   ((PSERIAL_DEVICE_EXTENSION)PDevObj->DeviceExtension)->PortOnAMultiportCard
      = TRUE;
   ((PSERIAL_DEVICE_EXTENSION)PDevObj->DeviceExtension)->OurIsr = NULL;


   PDevExt->NewPortIndex = PConfigData->PortIndex;
   PDevExt->NewMaskInverted = PConfigData->MaskInverted;
   PDevExt->NewExtension = PDevObj->DeviceExtension;

   //
   // Now, we can add the new guy.  He will be hooked in
   // immediately, so we need to be able to handle interrupts.
   //

   KeSynchronizeExecution(PDevExt->Interrupt, SerialAddToMulti, PDevExt);

   SerialDump (SERTRACECALLS,("SERIAL: Leave SerialInitMultiPort\n"));
   return STATUS_SUCCESS;
}



NTSTATUS
SerialInitController(IN PDEVICE_OBJECT PDevObj, IN PCONFIG_DATA PConfigData)

/*++

Routine Description:

    Really too many things to mention here.  In general initializes 
    kernel synchronization structures, allocates the typeahead buffer,
    sets up defaults, etc.

Arguments:

    PDevObj       - Device object for the device to be started

    PConfigData   - Pointer to a record for a single port.
    
Return Value:

    STATUS_SUCCCESS if everything went ok.  A !NT_SUCCESS status
    otherwise.

--*/

{

   PSERIAL_DEVICE_EXTENSION pDevExt = PDevObj->DeviceExtension;
#if defined(NEC_98)
   PSERIAL_DEVICE_EXTENSION Extension = PDevObj->DeviceExtension;
#else
#endif //defined(NEC_98)

   //
   // This will hold the string that we need to use to describe
   // the name of the device to the IO system.
   //

   UNICODE_STRING uniNameString;

   //
   // Holds the NT Status that is returned from each call to the
   // kernel and executive.
   //

   NTSTATUS status = STATUS_SUCCESS;

   //
   // Indicates that a conflict was detected for resources
   // used by this device.
   //

   BOOLEAN conflictDetected = FALSE;

   //
   // Indicates if we allocated an ISR switch
   //

   BOOLEAN allocedISRSw = FALSE;

   PAGED_CODE();


   SerialDump(
             SERDIAG1,
             ("SERIAL: Initializing for configuration record of %wZ\n",
              &pDevExt->DeviceName)
             );

   //
   // This compare is done using **untranslated** values since that is what
   // the kernel shoves in regardless of the architecture.
   //

   if ((*KdComPortInUse) == ((PUCHAR)(PConfigData->Controller.LowPart))) {
      SerialDump(SERERRORS, ("SERIAL: Kernel debugger is using port at address "
                             "%x\n"
                             "------  Serial driver will not load port\n",
                             *KdComPortInUse));

      SerialLogError(
                    PDevObj->DriverObject,
                    NULL,
                    PConfigData->TrController,
                    SerialPhysicalZero,
                    0,
                    0,
                    0,
                    3,
                    STATUS_SUCCESS,
                    SERIAL_KERNEL_DEBUGGER_ACTIVE,
                    pDevExt->DeviceName.Length+sizeof(WCHAR),
                    pDevExt->DeviceName.Buffer,
                    0,
                    NULL
                    );

      return STATUS_INSUFFICIENT_RESOURCES;
   }

      
   if (pDevExt->CIsrSw == NULL) {
      if ((pDevExt->CIsrSw
           = ExAllocatePool(NonPagedPool, sizeof(SERIAL_CISR_SW))) == NULL) {
         return STATUS_INSUFFICIENT_RESOURCES;
      }

      InitializeListHead(&pDevExt->CIsrSw->SharerList);

      allocedISRSw = TRUE;
   }

#if defined(NEC_98)
   //
   // intiallize device extension
   //
   pDevExt->DivisorLatch16550 = 0;
   pDevExt->ModemControl16550 = 0;
   pDevExt->LineControl16550 = SERIAL_8_DATA;
   pDevExt->ModeSet71051 = 0;
   pDevExt->CommandSet71051 = COMMAND_DEFAULT_SET;
   pDevExt->InterruptEnable16550 = 0;
   pDevExt->CommonBaseAddress = 0;
   pDevExt->ModeSetRegisterAddress = 0;
   pDevExt->CommandSetRegisterAddress = 0;

#else
#endif //defined(NEC_98)
   //
   // Propagate that it is a jensen.
   //

   pDevExt->Jensen = PConfigData->Jensen;


   //
   // Initialize the spinlock associated with fields read (& set)
   // by IO Control functions and the flags spinlock.
   //

   KeInitializeSpinLock(&pDevExt->ControlLock);
   KeInitializeSpinLock(&pDevExt->FlagsLock);


   //
   // Initialize the timers used to timeout operations.
   //

   KeInitializeTimer(&pDevExt->ReadRequestTotalTimer);
   KeInitializeTimer(&pDevExt->ReadRequestIntervalTimer);
   KeInitializeTimer(&pDevExt->WriteRequestTotalTimer);
   KeInitializeTimer(&pDevExt->ImmediateTotalTimer);
   KeInitializeTimer(&pDevExt->XoffCountTimer);
   KeInitializeTimer(&pDevExt->LowerRTSTimer);


   //
   // Intialialize the dpcs that will be used to complete
   // or timeout various IO operations.
   //

   KeInitializeDpc(&pDevExt->CompleteWriteDpc, SerialCompleteWrite, pDevExt);
   KeInitializeDpc(&pDevExt->CompleteReadDpc, SerialCompleteRead, pDevExt);
   KeInitializeDpc(&pDevExt->TotalReadTimeoutDpc, SerialReadTimeout, pDevExt);
   KeInitializeDpc(&pDevExt->IntervalReadTimeoutDpc, SerialIntervalReadTimeout,
                   pDevExt);
   KeInitializeDpc(&pDevExt->TotalWriteTimeoutDpc, SerialWriteTimeout, pDevExt);
   KeInitializeDpc(&pDevExt->CommErrorDpc, SerialCommError, pDevExt);
   KeInitializeDpc(&pDevExt->CompleteImmediateDpc, SerialCompleteImmediate,
                   pDevExt);
   KeInitializeDpc(&pDevExt->TotalImmediateTimeoutDpc, SerialTimeoutImmediate,
                   pDevExt);
   KeInitializeDpc(&pDevExt->CommWaitDpc, SerialCompleteWait, pDevExt);
   KeInitializeDpc(&pDevExt->XoffCountTimeoutDpc, SerialTimeoutXoff, pDevExt);
   KeInitializeDpc(&pDevExt->XoffCountCompleteDpc, SerialCompleteXoff, pDevExt);
   KeInitializeDpc(&pDevExt->StartTimerLowerRTSDpc, SerialStartTimerLowerRTS,
                   pDevExt);
   KeInitializeDpc(&pDevExt->PerhapsLowerRTSDpc, SerialInvokePerhapsLowerRTS,
                   pDevExt);
   KeInitializeDpc(&pDevExt->IsrUnlockPagesDpc, SerialUnlockPages, pDevExt);

#if 0 // DBG
   //
   // Init debug stuff
   //

   pDevExt->DpcQueued[0].Dpc = &pDevExt->CompleteWriteDpc;
   pDevExt->DpcQueued[1].Dpc = &pDevExt->CompleteReadDpc;
   pDevExt->DpcQueued[2].Dpc = &pDevExt->TotalReadTimeoutDpc;
   pDevExt->DpcQueued[3].Dpc = &pDevExt->IntervalReadTimeoutDpc;
   pDevExt->DpcQueued[4].Dpc = &pDevExt->TotalWriteTimeoutDpc;
   pDevExt->DpcQueued[5].Dpc = &pDevExt->CommErrorDpc;
   pDevExt->DpcQueued[6].Dpc = &pDevExt->CompleteImmediateDpc;
   pDevExt->DpcQueued[7].Dpc = &pDevExt->TotalImmediateTimeoutDpc;
   pDevExt->DpcQueued[8].Dpc = &pDevExt->CommWaitDpc;
   pDevExt->DpcQueued[9].Dpc = &pDevExt->XoffCountTimeoutDpc;
   pDevExt->DpcQueued[10].Dpc = &pDevExt->XoffCountCompleteDpc;
   pDevExt->DpcQueued[11].Dpc = &pDevExt->StartTimerLowerRTSDpc;
   pDevExt->DpcQueued[12].Dpc = &pDevExt->PerhapsLowerRTSDpc;
   pDevExt->DpcQueued[13].Dpc = &pDevExt->IsrUnlockPagesDpc;

#endif

   if (!((PConfigData->ClockRate == 1843200) ||
         (PConfigData->ClockRate == 3072000) ||
         (PConfigData->ClockRate == 4233600) ||
         (PConfigData->ClockRate == 8000000))) {

      SerialLogError(
                    PDevObj->DriverObject,
                    PDevObj,
                    PConfigData->TrController,
                    SerialPhysicalZero,
                    0,
                    0,
                    0,
                    6,
                    STATUS_SUCCESS,
                    SERIAL_UNSUPPORTED_CLOCK_RATE,
                    pDevExt->DeviceName.Length+sizeof(WCHAR),
                    pDevExt->DeviceName.Buffer,
                    0,
                    NULL
                    );

      SerialDump(
                SERERRORS,
                ("SERIAL: Invalid clock rate specified for %wZ\n",
                 &pDevExt->DeviceName)
                );

      status = STATUS_SERIAL_NO_DEVICE_INITED;
      goto ExtensionCleanup;

   }


   //
   // Save the value of clock input to the part.  We use this to calculate
   // the divisor latch value.  The value is in Hertz.
   //

   pDevExt->ClockRate = PConfigData->ClockRate;


  


   //
   // Map the memory for the control registers for the serial device
   // into virtual memory.
   //
   pDevExt->Controller =
      SerialGetMappedAddress(PConfigData->InterfaceType,
                             PConfigData->BusNumber,
                             PConfigData->TrController,
                             PConfigData->SpanOfController, 
                             (BOOLEAN)PConfigData->AddressSpace,
                             &pDevExt->UnMapRegisters);

   if (!pDevExt->Controller) {

      SerialLogError(
                    PDevObj->DriverObject,
                    pDevExt->DeviceObject,
                    PConfigData->TrController,
                    SerialPhysicalZero,
                    0,
                    0,
                    0,
                    7,
                    STATUS_SUCCESS,
                    SERIAL_REGISTERS_NOT_MAPPED,
                    pDevExt->DeviceName.Length+sizeof(WCHAR),
                    pDevExt->DeviceName.Buffer,
                    0,
                    NULL
                    );

      SerialDump(
                SERERRORS,
                ("SERIAL: Could not map memory for device registers for %wZ\n",
                 &pDevExt->DeviceName)
                );

      pDevExt->UnMapRegisters = FALSE;
      status = STATUS_NONE_MAPPED;
      goto ExtensionCleanup;

   }

   pDevExt->AddressSpace          = PConfigData->AddressSpace;
   pDevExt->OriginalController    = PConfigData->Controller;
   pDevExt->SpanOfController      = PConfigData->SpanOfController;


   //
   // if we have an interrupt status then map it.
   //

   pDevExt->InterruptStatus =
      (PUCHAR)PConfigData->TrInterruptStatus.QuadPart;

   if (pDevExt->InterruptStatus) {

      pDevExt->InterruptStatus
         = SerialGetMappedAddress(PConfigData->InterfaceType,
                                  PConfigData->BusNumber,                                                           
                                  PConfigData->TrInterruptStatus,
                                  PConfigData->SpanOfInterruptStatus,
                                  (BOOLEAN)PConfigData->AddressSpace,
                                  &pDevExt->UnMapStatus);


      if (!pDevExt->InterruptStatus) {

         SerialLogError(
                       PDevObj->DriverObject,
                       PDevObj,
                       PConfigData->TrController,
                       SerialPhysicalZero,
                       0,
                       0,
                       0,
                       8,
                       STATUS_SUCCESS,
                       SERIAL_REGISTERS_NOT_MAPPED,
                       pDevExt->DeviceName.Length+sizeof(WCHAR),
                       pDevExt->DeviceName.Buffer,
                       0,
                       NULL
                       );

         SerialDump(SERERRORS, ("SERIAL: Could not map memory for interrupt "
                                "status for %wZ\n",
                                &pDevExt->DeviceName));

         //
         // Manually unmap the other register here if necessary
         //

         if (pDevExt->UnMapRegisters) {
            MmUnmapIoSpace((PVOID)PConfigData->TrController.QuadPart,
                           PConfigData->SpanOfController);
         }

         pDevExt->UnMapRegisters = FALSE;
         pDevExt->UnMapStatus = FALSE;
         status = STATUS_NONE_MAPPED;
         goto ExtensionCleanup;

      }

      pDevExt->OriginalInterruptStatus = PConfigData->InterruptStatus;
      pDevExt->SpanOfInterruptStatus = PConfigData->SpanOfInterruptStatus;
 

   }


   //
   // Shareable interrupt?
   //

   if ((BOOLEAN)PConfigData->PermitSystemWideShare) {
      pDevExt->InterruptShareable = TRUE;
   }

   //
   // Save off the interface type and the bus number.
   //

   pDevExt->InterfaceType = PConfigData->InterfaceType;
   pDevExt->BusNumber     = PConfigData->BusNumber;

   pDevExt->PortIndex = PConfigData->PortIndex;
   pDevExt->Indexed = (BOOLEAN)PConfigData->Indexed;
   pDevExt->MaskInverted = PConfigData->MaskInverted;

   //
   // Get the translated interrupt vector, level, and affinity
   //

   pDevExt->OriginalIrql      = PConfigData->OriginalIrql;
   pDevExt->OriginalVector    = PConfigData->OriginalVector;


   //
   // PnP uses the passed translated values rather than calling
   // HalGetInterruptVector()
   //

   pDevExt->Vector = PConfigData->TrVector;
   pDevExt->Irql = (UCHAR)PConfigData->TrIrql;

   //
   // Set up the Isr.
   //

   pDevExt->OurIsr        = SerialISR;
   pDevExt->OurIsrContext = pDevExt;


   //
   // If the user said to permit sharing within the device, propagate this
   // through.
   //

   pDevExt->PermitShare = PConfigData->PermitShare;


   //
   // Before we test whether the port exists (which will enable the FIFO)
   // convert the rx trigger value to what should be used in the register.
   //
   // If a bogus value was given - crank them down to 1.
   //

   switch (PConfigData->RxFIFO) {

   case 1:

      pDevExt->RxFifoTrigger = SERIAL_1_BYTE_HIGH_WATER;
      break;

   case 4:

      pDevExt->RxFifoTrigger = SERIAL_4_BYTE_HIGH_WATER;
      break;

   case 8:

      pDevExt->RxFifoTrigger = SERIAL_8_BYTE_HIGH_WATER;
      break;

   case 14:

      pDevExt->RxFifoTrigger = SERIAL_14_BYTE_HIGH_WATER;
      break;

   default:

      pDevExt->RxFifoTrigger = SERIAL_1_BYTE_HIGH_WATER;
      break;

   }


   if ((PConfigData->TxFIFO > 16) ||
       (PConfigData->TxFIFO < 1)) {

      pDevExt->TxFifoAmount = 1;

   } else {

      pDevExt->TxFifoAmount = PConfigData->TxFIFO;

   }


   if (!SerialDoesPortExist(
                           pDevExt,
                           &pDevExt->DeviceName,
                           PConfigData->ForceFifoEnable,
                           PConfigData->LogFifo
                           )) {

      //
      // We couldn't verify that there was actually a
      // port. No need to log an error as the port exist
      // code will log exactly why.
      //

      SerialDump(
                SERERRORS,
                ("SERIAL: Does Port exist test failed for %wZ\n",
                 &pDevExt->DeviceName)
                );

      status = STATUS_NO_SUCH_DEVICE;
      goto ExtensionCleanup;

   }


   //
   // If the user requested that we disable the port, then
   // do it now.  Log the fact that the port has been disabled.
   //

   if (PConfigData->DisablePort) {

      SerialDump(
                SERERRORS,
                ("SERIAL: disabled port %wZ as requested in configuration\n",
                 &pDevExt->DeviceName)
                );

      status = STATUS_NO_SUCH_DEVICE;

      SerialLogError(
                    PDevObj->DriverObject,
                    PDevObj,
                    PConfigData->Controller,
                    SerialPhysicalZero,
                    0,
                    0,
                    0,
                    57,
                    STATUS_SUCCESS,
                    SERIAL_DISABLED_PORT,
                    pDevExt->DeviceName.Length+sizeof(WCHAR),
                    pDevExt->DeviceName.Buffer,
                    0,
                    NULL
                    );

      goto ExtensionCleanup;

   }



   //
   // Set up the default device control fields.
   // Note that if the values are changed after
   // the file is open, they do NOT revert back
   // to the old value at file close.
   //

   pDevExt->SpecialChars.XonChar      = SERIAL_DEF_XON;
   pDevExt->SpecialChars.XoffChar     = SERIAL_DEF_XOFF;
   pDevExt->HandFlow.ControlHandShake = SERIAL_DTR_CONTROL;
   pDevExt->HandFlow.FlowReplace      = SERIAL_RTS_CONTROL;


   //
   // Default Line control protocol. 7E1
   //
   // Seven data bits.
   // Even parity.
   // 1 Stop bits.
   //

   pDevExt->LineControl = SERIAL_7_DATA |
                               SERIAL_EVEN_PARITY |
                               SERIAL_NONE_PARITY;

   pDevExt->ValidDataMask = 0x7f;
   pDevExt->CurrentBaud   = 1200;


   //
   // We set up the default xon/xoff limits.
   //
   // This may be a bogus value.  It looks like the BufferSize
   // is not set up until the device is actually opened.
   //

   pDevExt->HandFlow.XoffLimit    = pDevExt->BufferSize >> 3;
   pDevExt->HandFlow.XonLimit     = pDevExt->BufferSize >> 1;

   pDevExt->BufferSizePt8 = ((3*(pDevExt->BufferSize>>2))+
                                  (pDevExt->BufferSize>>4));

   SerialDump(
             SERDIAG1,
             ("SERIAL: The default interrupt read buffer size is: %d\n"
              "------  The XoffLimit is                         : %d\n"
              "------  The XonLimit is                          : %d\n"
              "------  The pt 8 size is                         : %d\n",
              pDevExt->BufferSize,
              pDevExt->HandFlow.XoffLimit,
              pDevExt->HandFlow.XonLimit,
              pDevExt->BufferSizePt8)
             );


   //
   // Go through all the "named" baud rates to find out which ones
   // can be supported with this port.
   //

   pDevExt->SupportedBauds = SERIAL_BAUD_USER;

   {

      SHORT junk;

      if (!NT_ERROR(SerialGetDivisorFromBaud(
                                            pDevExt->ClockRate,
                                            (LONG)75,
                                            &junk
                                            ))) {

         pDevExt->SupportedBauds |= SERIAL_BAUD_075;

      }

      if (!NT_ERROR(SerialGetDivisorFromBaud(
                                            pDevExt->ClockRate,
                                            (LONG)110,
                                            &junk
                                            ))) {

         pDevExt->SupportedBauds |= SERIAL_BAUD_110;

      }

      if (!NT_ERROR(SerialGetDivisorFromBaud(
                                            pDevExt->ClockRate,
                                            (LONG)135,
                                            &junk
                                            ))) {

         pDevExt->SupportedBauds |= SERIAL_BAUD_134_5;

      }

      if (!NT_ERROR(SerialGetDivisorFromBaud(
                                            pDevExt->ClockRate,
                                            (LONG)150,
                                            &junk
                                            ))) {

         pDevExt->SupportedBauds |= SERIAL_BAUD_150;

      }

      if (!NT_ERROR(SerialGetDivisorFromBaud(
                                            pDevExt->ClockRate,
                                            (LONG)300,
                                            &junk
                                            ))) {

         pDevExt->SupportedBauds |= SERIAL_BAUD_300;

      }

      if (!NT_ERROR(SerialGetDivisorFromBaud(
                                            pDevExt->ClockRate,
                                            (LONG)600,
                                            &junk
                                            ))) {

         pDevExt->SupportedBauds |= SERIAL_BAUD_600;

      }

      if (!NT_ERROR(SerialGetDivisorFromBaud(
                                            pDevExt->ClockRate,
                                            (LONG)1200,
                                            &junk
                                            ))) {

         pDevExt->SupportedBauds |= SERIAL_BAUD_1200;

      }

      if (!NT_ERROR(SerialGetDivisorFromBaud(
                                            pDevExt->ClockRate,
                                            (LONG)1800,
                                            &junk
                                            ))) {

         pDevExt->SupportedBauds |= SERIAL_BAUD_1800;

      }

      if (!NT_ERROR(SerialGetDivisorFromBaud(
                                            pDevExt->ClockRate,
                                            (LONG)2400,
                                            &junk
                                            ))) {

         pDevExt->SupportedBauds |= SERIAL_BAUD_2400;

      }

      if (!NT_ERROR(SerialGetDivisorFromBaud(
                                            pDevExt->ClockRate,
                                            (LONG)4800,
                                            &junk
                                            ))) {

         pDevExt->SupportedBauds |= SERIAL_BAUD_4800;

      }

      if (!NT_ERROR(SerialGetDivisorFromBaud(
                                            pDevExt->ClockRate,
                                            (LONG)7200,
                                            &junk
                                            ))) {

         pDevExt->SupportedBauds |= SERIAL_BAUD_7200;

      }

      if (!NT_ERROR(SerialGetDivisorFromBaud(
                                            pDevExt->ClockRate,
                                            (LONG)9600,
                                            &junk
                                            ))) {

         pDevExt->SupportedBauds |= SERIAL_BAUD_9600;

      }

      if (!NT_ERROR(SerialGetDivisorFromBaud(
                                            pDevExt->ClockRate,
                                            (LONG)14400,
                                            &junk
                                            ))) {

         pDevExt->SupportedBauds |= SERIAL_BAUD_14400;

      }

      if (!NT_ERROR(SerialGetDivisorFromBaud(
                                            pDevExt->ClockRate,
                                            (LONG)19200,
                                            &junk
                                            ))) {

         pDevExt->SupportedBauds |= SERIAL_BAUD_19200;

      }

      if (!NT_ERROR(SerialGetDivisorFromBaud(
                                            pDevExt->ClockRate,
                                            (LONG)38400,
                                            &junk
                                            ))) {

         pDevExt->SupportedBauds |= SERIAL_BAUD_38400;

      }

      if (!NT_ERROR(SerialGetDivisorFromBaud(
                                            pDevExt->ClockRate,
                                            (LONG)56000,
                                            &junk
                                            ))) {

         pDevExt->SupportedBauds |= SERIAL_BAUD_56K;

      }
      if (!NT_ERROR(SerialGetDivisorFromBaud(
                                            pDevExt->ClockRate,
                                            (LONG)57600,
                                            &junk
                                            ))) {

         pDevExt->SupportedBauds |= SERIAL_BAUD_57600;

      }
      if (!NT_ERROR(SerialGetDivisorFromBaud(
                                            pDevExt->ClockRate,
                                            (LONG)115200,
                                            &junk
                                            ))) {

         pDevExt->SupportedBauds |= SERIAL_BAUD_115200;

      }

      if (!NT_ERROR(SerialGetDivisorFromBaud(
                                            pDevExt->ClockRate,
                                            (LONG)128000,
                                            &junk
                                            ))) {

         pDevExt->SupportedBauds |= SERIAL_BAUD_128K;

      }

   }


   //
   // Mark this device as not being opened by anyone.  We keep a
   // variable around so that spurious interrupts are easily
   // dismissed by the ISR.
   //

   pDevExt->DeviceIsOpened = FALSE;

   //
   // Store values into the extension for interval timing.
   //

   //
   // If the interval timer is less than a second then come
   // in with a short "polling" loop.
   //
   // For large (> then 2 seconds) use a 1 second poller.
   //

   pDevExt->ShortIntervalAmount.QuadPart  = -1;
   pDevExt->LongIntervalAmount.QuadPart   = -10000000;
   pDevExt->CutOverAmount.QuadPart        = 200000000;


   //
   // Common error path cleanup.  If the status is
   // bad, get rid of the device extension, device object
   // and any memory associated with it.
   //

ExtensionCleanup: ;
   if (!NT_SUCCESS(status)) {
      if (allocedISRSw) {
         ExFreePool(pDevExt->CIsrSw);
         pDevExt->CIsrSw = NULL;
      }

      if (pDevExt->UnMapRegisters) {
         MmUnmapIoSpace(pDevExt->Controller, pDevExt->SpanOfController);
      }

      if (pDevExt->UnMapStatus) {
         MmUnmapIoSpace(pDevExt->InterruptStatus,
                        pDevExt->SpanOfInterruptStatus);
      }

   }

   return status;

}



NTSTATUS
SerialInitOneController(IN PDEVICE_OBJECT PDevObj, IN PCONFIG_DATA PConfigData)
/*++

Routine Description:

    This routine will call the real port initialization code.  It sets
    up the ISR and Context correctly for a one port device.

Arguments:

    All args are simply passed along.

Return Value:

    Status returned from the controller initialization routine.

--*/

{

   NTSTATUS status;
   PSERIAL_DEVICE_EXTENSION pDevExt;

   PAGED_CODE();

   status = SerialInitController(PDevObj, PConfigData);

   if (NT_SUCCESS(status)) {

      pDevExt = PDevObj->DeviceExtension;

      //
      // We successfully initialized the single controller.
      // Stick the isr routine and the parameter for it
      // back into the extension.
      //

      pDevExt->OurIsr = SerialISR;
      pDevExt->OurIsrContext = pDevExt;
      pDevExt->TopLevelOurIsr = SerialISR;
      pDevExt->TopLevelOurIsrContext = pDevExt;

   }

   return status;

}


BOOLEAN
SerialDoesPortExist(
                   IN PSERIAL_DEVICE_EXTENSION Extension,
                   IN PUNICODE_STRING InsertString,
                   IN ULONG ForceFifo,
                   IN ULONG LogFifo
                   )

/*++

Routine Description:

    This routine examines several of what might be the serial device
    registers.  It ensures that the bits that should be zero are zero.

    In addition, this routine will determine if the device supports
    fifo's.  If it does it will enable the fifo's and turn on a boolean
    in the extension that indicates the fifo's presence.

    NOTE: If there is indeed a serial port at the address specified
          it will absolutely have interrupts inhibited upon return
          from this routine.

    NOTE: Since this routine should be called fairly early in
          the device driver initialization, the only element
          that needs to be filled in is the base register address.

    NOTE: These tests all assume that this code is the only
          code that is looking at these ports or this memory.

          This is a not to unreasonable assumption even on
          multiprocessor systems.

Arguments:

    Extension - A pointer to a serial device extension.
    InsertString - String to place in an error log entry.
    ForceFifo - !0 forces the fifo to be left on if found.
    LogFifo - !0 forces a log message if fifo found.

Return Value:

    Will return true if the port really exists, otherwise it
    will return false.

--*/

{


   UCHAR regContents;
   BOOLEAN returnValue = TRUE;
   UCHAR oldIERContents;
   UCHAR oldLCRContents;
   USHORT value1;
   USHORT value2;
   KIRQL oldIrql;

   PAGED_CODE();

#if defined (NEC_98)
{
   //
   // For the 101 board, we will found the just fit port.
   // The 101 board is multifunction port, therefore need it.
   //   Ch2 = 0x0yb0 as start port address
   //   Ch3 = 0x0yb2 as start port address
   //
   #define    PortOffsetCh3         0x02
   #define    ModeOffsetCh2         0x03
   #define    ModeOffsetCh3         0x0b
   #define    ModeOffsetCh3_nonPnP  0x09  // non PnP

   ULONG IrqLevelCh2[] = {3,5,6,9};    //irq of 101 borad at Ch2
   ULONG IrqLevelCh3[] = {3,10,12,13}; //irq of 101 borad at CH3
   ULONG i;
   PUCHAR Port  = 0;

   Extension->CommonBaseAddress         = NULL;
   Extension->ModeSetRegisterAddress    = NULL;
   Extension->CommandSetRegisterAddress = NULL;

   Port = (PUCHAR)(Extension->Controller);
   if ((READ_PORT_UCHAR((PUCHAR)Port)) == 0xff){
       returnValue = FALSE;
       return returnValue;
   }

   SerialDump(
             SERDIAG1,
             ("SERIAL: IRQL is : %x\n",Extension->OriginalIrql)
             );

   i = (ULONG)((UCHAR)(Extension->Controller));
   if (i & 0x02) {
       //
       // When Ch3 of non PnP mode, entry of  I/O start address is an even number by the NTDETECT.COM.
       //
       Extension->ModeSetRegisterAddress    = ((Extension->Controller) + ModeOffsetCh3_nonPnP);
       Extension->CommandSetRegisterAddress = ((Extension->Controller) + ModeOffsetCh3_nonPnP);
       Extension->CommonBaseAddress = Extension->Controller;
   }

   if (Extension->CommonBaseAddress == NULL) {
       //
       // Read irq sense at Ch2.
       //
       for (i = 0; i < 4; i++) {
           if (Extension->OriginalIrql == IrqLevelCh2[i]) {
               // There is Ch2 exist.
               Extension->CommonBaseAddress         = Extension->Controller;
               Extension->ModeSetRegisterAddress    = ((Extension->Controller) + ModeOffsetCh2);
               Extension->CommandSetRegisterAddress = ((Extension->Controller) + ModeOffsetCh2);
           }
       }
       if (Extension->CommonBaseAddress == NULL) {
           for (i = 0; i < 4; i++) {
               //
               // Read irq sense at Ch3.
               //
               if (Extension->OriginalIrql == IrqLevelCh3[i]) {
                   // There is Ch3 exist.
                   Extension->ModeSetRegisterAddress    = ((Extension->Controller) + ModeOffsetCh3);
                   Extension->CommandSetRegisterAddress = ((Extension->Controller) + ModeOffsetCh3);
                   Extension->Controller = Extension->CommonBaseAddress = ((Extension->Controller) + PortOffsetCh3);
               }
           }
       }
   }
   if (Extension->CommonBaseAddress == NULL) {
       //
       // There is not found port.
       //
       SerialDump(
                 SERDIAG1,
                 ("SERIAL: There is not found port for 101\n")
                 );

       returnValue = FALSE;
       return returnValue;
   }
   SerialDump(
             SERDIAG1,
             ("SERIAL: Found the common Base address: %x ModeReg: %x CommandReg: %x\n",
              Extension->CommonBaseAddress,
              Extension->ModeSetRegisterAddress,
              Extension->CommandSetRegisterAddress)
             );
}
#else
#endif

   //
   // Save of the line control.
   //

   oldLCRContents = READ_LINE_CONTROL(Extension->Controller);

   //
   // Make sure that we are *aren't* accessing the divsior latch.
   //

   WRITE_LINE_CONTROL(
                     Extension->Controller,
                     (UCHAR)(oldLCRContents & ~SERIAL_LCR_DLAB)
                     );

#if defined (NEC_98)
   oldIERContents = READ_INTERRUPT_ENABLE(Extension->Controller);
#else
   oldIERContents = READ_INTERRUPT_ENABLE(Extension->Controller);
#endif
   //
   // Go up to power level for a very short time to prevent
   // any interrupts from this device from coming in.
   //

   KeRaiseIrql(
              POWER_LEVEL,
              &oldIrql
              );

   WRITE_INTERRUPT_ENABLE(
                         Extension->Controller,
                         0x0f
                         );

#if defined (NEC_98)
   value1 = READ_INTERRUPT_ENABLE(Extension->Controller);
#else
   value1 = READ_INTERRUPT_ENABLE(Extension->Controller);
#endif
   value1 = value1 << 8;
   value1 |= READ_RECEIVE_BUFFER(Extension->Controller);

   READ_DIVISOR_LATCH(
                     Extension->Controller,
                     &value2
                     );

   WRITE_LINE_CONTROL(
                     Extension->Controller,
                     oldLCRContents
                     );

   //
   // Put the ier back to where it was before.  If we are on a
   // level sensitive port this should prevent the interrupts
   // from coming in.  If we are on a latched, we don't care
   // cause the interrupts generated will just get dropped.
   //

   WRITE_INTERRUPT_ENABLE(
                         Extension->Controller,
                         oldIERContents
                         );

   KeLowerIrql(oldIrql);

   if (value1 == value2) {

      SerialLogError(
                    Extension->DeviceObject->DriverObject,
                    Extension->DeviceObject,
                    Extension->OriginalController,
                    SerialPhysicalZero,
                    0,
                    0,
                    0,
                    62,
                    STATUS_SUCCESS,
                    SERIAL_DLAB_INVALID,
                    InsertString->Length+sizeof(WCHAR),
                    InsertString->Buffer,
                    0,
                    NULL
                    );
      returnValue = FALSE;
      goto AllDone;

   }

   AllDone: ;


   //
   // If we think that there is a serial device then we determine
   // if a fifo is present.
   //

   if (returnValue) {

      //
      // Well, we think it's a serial device.  Absolutely
      // positively, prevent interrupts from occuring.
      //
      // We disable all the interrupt enable bits, and
      // push down all the lines in the modem control
      // We only needed to push down OUT2 which in
      // PC's must also be enabled to get an interrupt.
      //

      DISABLE_ALL_INTERRUPTS(Extension->Controller);

      if (Extension->Jensen) {

         WRITE_MODEM_CONTROL(
                            Extension->Controller,
                            (UCHAR)SERIAL_MCR_OUT2
                            );

      } else {

         WRITE_MODEM_CONTROL(
                            Extension->Controller,
                            (UCHAR)0
                            );

      }

      //
      // See if this is a 16550.  We do this by writing to
      // what would be the fifo control register with a bit
      // pattern that tells the device to enable fifo's.
      // We then read the iterrupt Id register to see if the
      // bit pattern is present that identifies the 16550.
      //

      WRITE_FIFO_CONTROL(
                        Extension->Controller,
                        SERIAL_FCR_ENABLE
                        );

      regContents = READ_INTERRUPT_ID_REG(Extension->Controller);

      if (regContents & SERIAL_IIR_FIFOS_ENABLED) {

         //
         // Save off that the device supports fifos.
         //

         Extension->FifoPresent = TRUE;

         //
         // There is a fine new "super" IO chip out there that
         // will get stuck with a line status interrupt if you
         // attempt to clear the fifo and enable it at the same
         // time if data is present.  The best workaround seems
         // to be that you should turn off the fifo read a single
         // byte, and then re-enable the fifo.
         //

         WRITE_FIFO_CONTROL(
                           Extension->Controller,
                           (UCHAR)0
                           );

         READ_RECEIVE_BUFFER(Extension->Controller);

         //
         // There are fifos on this card.  Set the value of the
         // receive fifo to interrupt when 4 characters are present.
         //

         WRITE_FIFO_CONTROL(Extension->Controller,
                            (UCHAR)(SERIAL_FCR_ENABLE
                                    | Extension->RxFifoTrigger
                                    | SERIAL_FCR_RCVR_RESET
                                    | SERIAL_FCR_TXMT_RESET));

      }

      //
      // The !Extension->FifoPresent is included in the test so that
      // broken chips like the WinBond will still work after we test
      // for the fifo.
      //

      if (!ForceFifo || !Extension->FifoPresent) {

         Extension->FifoPresent = FALSE;
         WRITE_FIFO_CONTROL(
                           Extension->Controller,
                           (UCHAR)0
                           );

      }

      if (Extension->FifoPresent) {

         if (LogFifo) {

            SerialLogError(
                          Extension->DeviceObject->DriverObject,
                          Extension->DeviceObject,
                          Extension->OriginalController,
                          SerialPhysicalZero,
                          0,
                          0,
                          0,
                          15,
                          STATUS_SUCCESS,
                          SERIAL_FIFO_PRESENT,
                          InsertString->Length+sizeof(WCHAR),
                          InsertString->Buffer,
                          0,
                          NULL
                          );

         }

         SerialDump(
                   SERDIAG1,
                   ("SERIAL: Fifo's detected at port address: %x\n",
                    Extension->Controller)
                   );

      }

      //
      // In case we are dealing with a bitmasked multiportcard,
      // that has the mask register enabled, enable the
      // interrupts.
      //

      if (Extension->InterruptStatus) {
         if (Extension->Indexed) {
            WRITE_PORT_UCHAR(Extension->InterruptStatus, (UCHAR)0xFF);
         } else {
            //
            // Either we are standalone or already mapped
            //

            if (Extension->OurIsrContext == Extension) {
               //
               // This is a standalone
               //

               WRITE_PORT_UCHAR(Extension->InterruptStatus,
                                (UCHAR)(1 << (Extension->PortIndex - 1)));
            } else {
               //
               // One of many
               //

               WRITE_PORT_UCHAR(Extension->InterruptStatus,
                                (UCHAR)((PSERIAL_MULTIPORT_DISPATCH)Extension->
                                        OurIsrContext)->UsablePortMask);
            }
         }
      }

   }

   return returnValue;

}


BOOLEAN
SerialReset(
           IN PVOID Context
           )

/*++

Routine Description:

    This places the hardware in a standard configuration.

    NOTE: This assumes that it is called at interrupt level.


Arguments:

    Context - The device extension for serial device
    being managed.

Return Value:

    Always FALSE.

--*/

{

   PSERIAL_DEVICE_EXTENSION extension = Context;
#if defined(NEC_98)
   //
   // This argument use at MACRO only.
   //
   PSERIAL_DEVICE_EXTENSION Extension = Context;
#else
#endif //defined(NEC_98)
   UCHAR regContents;
   UCHAR oldModemControl;
   ULONG i;
   SERIAL_LOCKED_PAGED_CODE();

   //
   // Adjust the out2 bit.
   // This will also prevent any interrupts from occuring.
   //

   oldModemControl = READ_MODEM_CONTROL(extension->Controller);

   if (extension->Jensen) {

      WRITE_MODEM_CONTROL(
                         extension->Controller,
                         (UCHAR)(oldModemControl | SERIAL_MCR_OUT2)
                         );

   } else {


      WRITE_MODEM_CONTROL(
                         extension->Controller,
                         (UCHAR)(oldModemControl & ~SERIAL_MCR_OUT2)
                         );

   }

   //
   // Reset the fifo's if there are any.
   //

   if (extension->FifoPresent) {


      //
      // There is a fine new "super" IO chip out there that
      // will get stuck with a line status interrupt if you
      // attempt to clear the fifo and enable it at the same
      // time if data is present.  The best workaround seems
      // to be that you should turn off the fifo read a single
      // byte, and then re-enable the fifo.
      //

      WRITE_FIFO_CONTROL(
                        extension->Controller,
                        (UCHAR)0
                        );

      READ_RECEIVE_BUFFER(extension->Controller);

      WRITE_FIFO_CONTROL(
                        extension->Controller,
                        (UCHAR)(SERIAL_FCR_ENABLE | extension->RxFifoTrigger |
                                SERIAL_FCR_RCVR_RESET | SERIAL_FCR_TXMT_RESET)
                        );

   }

   //
   // Make sure that the line control set up correct.
   //
   // 1) Make sure that the Divisor latch select is set
   //    up to select the transmit and receive register.
   //
   // 2) Make sure that we aren't in a break state.
   //

   regContents = READ_LINE_CONTROL(extension->Controller);
   regContents &= ~(SERIAL_LCR_DLAB | SERIAL_LCR_BREAK);

   WRITE_LINE_CONTROL(
                     extension->Controller,
                     regContents
                     );

   //
   // Read the receive buffer until the line status is
   // clear.  (Actually give up after a 5 reads.)
   //

   for (i = 0;
       i < 5;
       i++
       ) {

      if (IsNotNEC_98) {
         READ_RECEIVE_BUFFER(extension->Controller);
         if (!(READ_LINE_STATUS(extension->Controller) & 1)) {

            break;

         }
      } else {
          //  
          // I get incorrect data when read enpty buffer.
          // But do not read no data! for PC98!
          // 
          if (!(READ_LINE_STATUS(extension->Controller) & 1)) {

             break;

          }
          READ_RECEIVE_BUFFER(extension->Controller);
      }

   }

   //
   // Read the modem status until the low 4 bits are
   // clear.  (Actually give up after a 5 reads.)
   //

   for (i = 0;
       i < 1000;
       i++
       ) {

      if (!(READ_MODEM_STATUS(extension->Controller) & 0x0f)) {

         break;

      }

   }

   //
   // Now we set the line control, modem control, and the
   // baud to what they should be.
   //

   SerialSetLineControl(extension);

   SerialSetupNewHandFlow(
                         extension,
                         &extension->HandFlow
                         );

   SerialHandleModemUpdate(
                          extension,
                          FALSE
                          );

   {
      SHORT  appropriateDivisor;
      SERIAL_IOCTL_SYNC s;

      SerialGetDivisorFromBaud(
                              extension->ClockRate,
                              extension->CurrentBaud,
                              &appropriateDivisor
                              );
      s.Extension = extension;
      s.Data = (PVOID)appropriateDivisor;
      SerialSetBaud(&s);
   }

   //
   // Enable which interrupts we want to receive.
   //
   // NOTE NOTE: This does not actually let interrupts
   // occur.  We must still raise the OUT2 bit in the
   // modem control register.  We will do that on open.
   //

   ENABLE_ALL_INTERRUPTS(extension->Controller);

   //
   // Read the interrupt id register until the low bit is
   // set.  (Actually give up after a 5 reads.)
   //

   for (i = 0;
       i < 5;
       i++
       ) {

      if (READ_INTERRUPT_ID_REG(extension->Controller) & 0x01) {

         break;

      }

   }

   //
   // Now we know that nothing could be transmitting at this point
   // so we set the HoldingEmpty indicator.
   //

   extension->HoldingEmpty = TRUE;

   return FALSE;
}


NTSTATUS
SerialGetDivisorFromBaud(
                        IN ULONG ClockRate,
                        IN LONG DesiredBaud,
                        OUT PSHORT AppropriateDivisor
                        )

/*++

Routine Description:

    This routine will determine a divisor based on an unvalidated
    baud rate.

Arguments:

    ClockRate - The clock input to the controller.

    DesiredBaud - The baud rate for whose divisor we seek.

    AppropriateDivisor - Given that the DesiredBaud is valid, the
    LONG pointed to by this parameter will be set to the appropriate
    value.  NOTE: The long is undefined if the DesiredBaud is not
    supported.

Return Value:

    This function will return STATUS_SUCCESS if the baud is supported.
    If the value is not supported it will return a status such that
    NT_ERROR(Status) == FALSE.

--*/

{

   NTSTATUS status = STATUS_SUCCESS;
   SHORT calculatedDivisor;
   ULONG denominator;
   ULONG remainder;

   //
   // Allow up to a 1 percent error
   //

   ULONG maxRemain18 = 18432;
   ULONG maxRemain30 = 30720;
   ULONG maxRemain42 = 42336;
   ULONG maxRemain80 = 80000;
   ULONG maxRemain;

   SERIAL_LOCKED_PAGED_CODE();

   //
   // Reject any non-positive bauds.
   //

   denominator = DesiredBaud*(ULONG)16;

   if (DesiredBaud <= 0) {

      *AppropriateDivisor = -1;

   } else if ((LONG)denominator < DesiredBaud) {

      //
      // If the desired baud was so huge that it cause the denominator
      // calculation to wrap, don't support it.
      //

      *AppropriateDivisor = -1;

   } else {

      if (ClockRate == 1843200) {
         maxRemain = maxRemain18;
      } else if (ClockRate == 3072000) {
         maxRemain = maxRemain30;
      } else if (ClockRate == 4233600) {
         maxRemain = maxRemain42;
      } else {
         maxRemain = maxRemain80;
      }

      calculatedDivisor = (SHORT)(ClockRate / denominator);
      remainder = ClockRate % denominator;

      //
      // Round up.
      //

      if (((remainder*2) > ClockRate) && (DesiredBaud != 110)) {

         calculatedDivisor++;
      }


      //
      // Only let the remainder calculations effect us if
      // the baud rate is > 9600.
      //

      if (DesiredBaud >= 9600) {

         //
         // If the remainder is less than the maximum remainder (wrt
         // the ClockRate) or the remainder + the maximum remainder is
         // greater than or equal to the ClockRate then assume that the
         // baud is ok.
         //

         if ((remainder >= maxRemain) && ((remainder+maxRemain) < ClockRate)) {
            calculatedDivisor = -1;
         }

      }

      //
      // Don't support a baud that causes the denominator to
      // be larger than the clock.
      //

      if (denominator > ClockRate) {

         calculatedDivisor = -1;

      }

      //
      // Ok, Now do some special casing so that things can actually continue
      // working on all platforms.
      //

      if (ClockRate == 1843200) {

         if (DesiredBaud == 56000) {
            calculatedDivisor = 2;
         }

      } else if (ClockRate == 3072000) {

         if (DesiredBaud == 14400) {
            calculatedDivisor = 13;
         }

      } else if (ClockRate == 4233600) {

         if (DesiredBaud == 9600) {
            calculatedDivisor = 28;
         } else if (DesiredBaud == 14400) {
            calculatedDivisor = 18;
         } else if (DesiredBaud == 19200) {
            calculatedDivisor = 14;
         } else if (DesiredBaud == 38400) {
            calculatedDivisor = 7;
         } else if (DesiredBaud == 56000) {
            calculatedDivisor = 5;
         }

      } else if (ClockRate == 8000000) {

         if (DesiredBaud == 14400) {
            calculatedDivisor = 35;
         } else if (DesiredBaud == 56000) {
            calculatedDivisor = 9;
         }

      }

      *AppropriateDivisor = calculatedDivisor;

#if defined(NEC_98)
      //
      // This code check the baud that NEC98 support.
      //
      if (*AppropriateDivisor != -1) {
         if (DesiredBaud <= 50) {
            *AppropriateDivisor = -1;
         } else if (DesiredBaud >= 9600) {
            switch (DesiredBaud) {
               case 9600:
               case 19200:
               case 38400:
               case 57600:
               case 115200:
                  break;
               default:
                  *AppropriateDivisor = -1;
            }
         } else {
            if (153600L % DesiredBaud) {
               if (DesiredBaud != 110) {
                  *AppropriateDivisor = -1;
               }
            }
         }
      }
#else
#endif //defined(NEC_98)
   }


   if (*AppropriateDivisor == -1) {

      status = STATUS_INVALID_PARAMETER;

   }

   return status;

}


VOID
SerialUnload(
            IN PDRIVER_OBJECT DriverObject
            )

/*++

Routine Description:

    This routine is defunct since all device objects are removed before
    the driver is unloaded.

Arguments:

    DriverObject - Pointer to the driver object controling all of the
                   devices.

Return Value:

    None.

--*/

{
   PVOID lockPtr;

   PAGED_CODE();

   lockPtr = MmLockPagableCodeSection(SerialUnload);

   //
   // Unnecessary since our BSS is going away, but do it anyhow to be safe
   //

   SerialGlobals.PAGESER_Handle = NULL;

   if (SerialGlobals.RegistryPath.Buffer != NULL) {
      ExFreePool(SerialGlobals.RegistryPath.Buffer);
      SerialGlobals.RegistryPath.Buffer = NULL;
   }

   SerialDump(
             SERDIAG3,
             ("SERIAL: In SerialUnload\n")
             );

   MmUnlockPagableImageSection(lockPtr);

}





PVOID
SerialGetMappedAddress(
                      IN INTERFACE_TYPE BusType,
                      IN ULONG BusNumber,
                      PHYSICAL_ADDRESS IoAddress,
                      ULONG NumberOfBytes,
                      ULONG AddressSpace,
                      PBOOLEAN MappedAddress
                      )

/*++

Routine Description:

    This routine maps an IO address to system address space.

Arguments:

    BusType - what type of bus - eisa, mca, isa
    IoBusNumber - which IO bus (for machines with multiple buses).
    IoAddress - base device address to be mapped.
    NumberOfBytes - number of bytes for which address is valid.
    AddressSpace - Denotes whether the address is in io space or memory.
    MappedAddress - indicates whether the address was mapped.
                    This only has meaning if the address returned
                    is non-null.

Return Value:

    Mapped address

--*/

{
   PHYSICAL_ADDRESS cardAddress;
   PVOID address;

   PAGED_CODE();

   //
   // Map the device base address into the virtual address space
   // if the address is in memory space.
   //

   if (!AddressSpace) {

      address = MmMapIoSpace(
                            IoAddress,
                            NumberOfBytes,
                            FALSE
                            );

      *MappedAddress = (BOOLEAN)((address)?(TRUE):(FALSE));


   } else {

      address = (PVOID)IoAddress.LowPart;
      *MappedAddress = FALSE;

   }

   return address;

}


SERIAL_MEM_COMPARES
SerialMemCompare(
                IN PHYSICAL_ADDRESS A,
                IN ULONG SpanOfA,
                IN PHYSICAL_ADDRESS B,
                IN ULONG SpanOfB
                )

/*++

Routine Description:

    Compare two phsical address.

Arguments:

    A - One half of the comparison.

    SpanOfA - In units of bytes, the span of A.

    B - One half of the comparison.

    SpanOfB - In units of bytes, the span of B.


Return Value:

    The result of the comparison.

--*/

{

   LARGE_INTEGER a;
   LARGE_INTEGER b;

   LARGE_INTEGER lower;
   ULONG lowerSpan;
   LARGE_INTEGER higher;

   PAGED_CODE();

   a = A;
   b = B;

   if (a.QuadPart == b.QuadPart) {

      return AddressesAreEqual;

   }

   if (a.QuadPart > b.QuadPart) {

      higher = a;
      lower = b;
      lowerSpan = SpanOfB;

   } else {

      higher = b;
      lower = a;
      lowerSpan = SpanOfA;

   }

   if ((higher.QuadPart - lower.QuadPart) >= lowerSpan) {

      return AddressesAreDisjoint;

   }

   return AddressesOverlap;

}



BOOLEAN
SerialBecomeSharer(PVOID Context)
/*++

Routine Description:

    This routine will take a device extension for a serial port and
    allow it to share interrupts with other serial ports.

Arguments:

    Context - The device extension of the port who is to start sharing
    interrupts.

Return Value:

    Always TRUE.

--*/
{
   PSERIAL_DEVICE_EXTENSION pDevExt = (PSERIAL_DEVICE_EXTENSION)Context;
   PSERIAL_DEVICE_EXTENSION pNewExt
      = (PSERIAL_DEVICE_EXTENSION)pDevExt->NewExtension;
   PSERIAL_CISR_SW pCIsrSw = pDevExt->CIsrSw;

   //
   // See if we need to configure the pre-existing node to become
   // a sharer.
   //

   if (IsListEmpty(&pCIsrSw->SharerList)) {
      pCIsrSw->IsrFunc = SerialSharerIsr;
      pCIsrSw->Context = &pCIsrSw->SharerList;
      InsertTailList(&pCIsrSw->SharerList, &pDevExt->TopLevelSharers);
   }

   //
   // They share an interrupt object and a context
   //

   pNewExt->Interrupt = pDevExt->Interrupt;
   pNewExt->CIsrSw = pDevExt->CIsrSw;

   //
   // Add to list of sharers
   //

   InsertTailList(&pCIsrSw->SharerList, &pNewExt->TopLevelSharers);

   //
   // Add to list of those who share this interrupt object --
   // we may already be on if this port is part of a multiport board
   //

   if (IsListEmpty(&pNewExt->CommonInterruptObject)) {
      InsertTailList(&pDevExt->CommonInterruptObject,
                     &pNewExt->CommonInterruptObject);
   }


   return TRUE;
}



NTSTATUS
SerialFindInitController(IN PDEVICE_OBJECT PDevObj, IN PCONFIG_DATA PConfig)
/*++

Routine Description:

    This function discovers what type of controller is responsible for
    the given port and initializes the controller and port.

Arguments:

    PDevObj - Pointer to the devobj for the port we are about to init.

    PConfig - Pointer to configuration data for the port we are about to init.

Return Value:

    STATUS_SUCCESS on success, appropriate error value on failure.

--*/

{

   PSERIAL_DEVICE_EXTENSION pDevExt = PDevObj->DeviceExtension;
   PDEVICE_OBJECT pDeviceObject;
   PSERIAL_DEVICE_EXTENSION pExtension;
   PHYSICAL_ADDRESS serialPhysicalMax;
   SERIAL_LIST_DATA listAddition;
   BOOLEAN didInit = FALSE;
   PLIST_ENTRY pCurDevObj;
   NTSTATUS status;

   PAGED_CODE();


   SerialDump(SERTRACECALLS, ("SERIAL: entering SerialFindInitController\n"));

   serialPhysicalMax.LowPart = (ULONG)~0;
   serialPhysicalMax.HighPart = ~0;

   SerialDump(SERDIAG1, ("SERIAL: Attempting to init %wZ\n"
                         "------- PortAddress is %x\n"
                         "------- Interrupt Status is %x\n"
                         "------- BusNumber is %d\n"
                         "------- BusType is %d\n"
                         "------- AddressSpace is %d\n"
                         "------- Interrupt Mode is %d\n",
                         &pDevExt->DeviceName,
                         PConfig->Controller.LowPart,
                         PConfig->InterruptStatus.LowPart,
                         PConfig->BusNumber,
                         PConfig->InterfaceType,
                         PConfig->AddressSpace,
                         PConfig->InterruptMode)
             );

   //
   // We don't support any boards whose memory wraps around
   // the physical address space.
   //

   if (SerialMemCompare(
                       PConfig->Controller,
                       PConfig->SpanOfController,
                       serialPhysicalMax,
                       (ULONG)0
                       ) != AddressesAreDisjoint) {

      SerialLogError(
                    PDevObj->DriverObject,
                    NULL,
                    PConfig->Controller,
                    SerialPhysicalZero,
                    0,
                    0,
                    0,
                    43,
                    STATUS_SUCCESS,
                    SERIAL_DEVICE_TOO_HIGH,
                    pDevExt->SymbolicLinkName.Length+sizeof(WCHAR),
                    pDevExt->SymbolicLinkName.Buffer,
                    0,
                    NULL
                    );

      SerialDump(
                SERERRORS,
                ("SERIAL: Error in config record for %wZ\n"
                 "------  registers wrap around physical memory\n",
                 &pDevExt->DeviceName)
                );

      return STATUS_NO_SUCH_DEVICE;

   }


   if (SerialMemCompare(
                       PConfig->InterruptStatus,
                       PConfig->SpanOfInterruptStatus,
                       serialPhysicalMax,
                       (ULONG)0
                       ) != AddressesAreDisjoint) {

      SerialLogError(
                    PDevObj->DriverObject,
                    NULL,
                    PConfig->Controller,
                    SerialPhysicalZero,
                    0,
                    0,
                    0,
                    44,
                    STATUS_SUCCESS,
                    SERIAL_STATUS_TOO_HIGH,
                    pDevExt->SymbolicLinkName.Length+sizeof(WCHAR),
                    pDevExt->SymbolicLinkName.Buffer,
                    0,
                    NULL
                    );

      SerialDump(
                SERERRORS,
                ("SERIAL: Error in config record for %wZ\n"
                 "------  status raps around physical memory\n",
                 &pDevExt->DeviceName)
                );

      return STATUS_NO_SUCH_DEVICE;
   }


   //
   // Make sure that the interrupt status address doesn't
   // overlap the controller registers
   //

   if (SerialMemCompare(
                       PConfig->InterruptStatus,
                       PConfig->SpanOfInterruptStatus,
                       SerialPhysicalZero,
                       (ULONG)0
                       ) != AddressesAreEqual) {

      if (SerialMemCompare(
                          PConfig->InterruptStatus,
                          PConfig->SpanOfInterruptStatus,
                          PConfig->Controller,
                          PConfig->SpanOfController
                          ) != AddressesAreDisjoint) {

         SerialLogError(
                       PDevObj->DriverObject,
                       NULL,
                       PConfig->Controller,
                       PConfig->InterruptStatus,
                       0,
                       0,
                       0,
                       45,
                       STATUS_SUCCESS,
                       SERIAL_STATUS_CONTROL_CONFLICT,
                       pDevExt->SymbolicLinkName.Length+sizeof(WCHAR),
                       pDevExt->SymbolicLinkName.Buffer,
                       0,
                       NULL
                       );

         SerialDump(
                   SERERRORS,
                   ("SERIAL: Error in config record for %wZ\n"
                    "------- Interrupt status overlaps regular registers\n",
                    &pDevExt->DeviceName)
                   );

         return STATUS_NO_SUCH_DEVICE;
      }
   }


#if defined(NEC_98)
#else
   //
   // Loop through all of the driver's device objects making
   // sure that this new record doesn't overlap with any of them.
   //

   if (!IsListEmpty(&SerialGlobals.AllDevObjs)) {
      pCurDevObj = SerialGlobals.AllDevObjs.Flink;
      pExtension = CONTAINING_RECORD(pCurDevObj, SERIAL_DEVICE_EXTENSION,
                                     AllDevObjs);
   } else {
      pCurDevObj = NULL;
      pExtension = NULL;
   }


   while (pCurDevObj != NULL
          && pCurDevObj != &SerialGlobals.AllDevObjs) {
      //
      // We only care about this list if the elements are on the
      // same bus as this new entry.
      //

      if ((pExtension->InterfaceType  == PConfig->InterfaceType) &&
          (pExtension->AddressSpace   == PConfig->AddressSpace)  &&
          (pExtension->BusNumber      == PConfig->BusNumber)) {

         SerialDump(
                   SERDIAG1,
                   ("SERIAL: Comparing it to %wZ\n"
                    "------- already in the device list\n"
                    "------- PortAddress is %x\n"
                    "------- Interrupt Status is %x\n"
                    "------- BusNumber is %d\n"
                    "------- BusType is %d\n"
                    "------- AddressSpace is %d\n",
                    &pExtension->DeviceName,
                    pExtension->OriginalController.LowPart,
                    pExtension->OriginalInterruptStatus.LowPart,
                    pExtension->BusNumber,
                    pExtension->InterfaceType,
                    pExtension->AddressSpace
                   )
                   );

         //
         // Check to see if the controller addresses are not equal.  
         //

         if (SerialMemCompare(
                             PConfig->Controller,
                             PConfig->SpanOfController,
                             pExtension->OriginalController,
                             pExtension->SpanOfController
                             ) != AddressesAreDisjoint) {

            //
            // We don't want to log an error if the addresses
            // are the same and the name is the same and
            // the new item is from the firmware.
            //

            SerialDump(
                      SERERRORS,
                      ("SERIAL: Error in config record for %wZ\n"
                       "------- Register address overlaps with\n"
                       "------- previous serial device\n",
                       &pDevExt->DeviceName)
                      );

            return STATUS_NO_SUCH_DEVICE;
         }


         //
         // If we have an interrupt status, make sure that
         // it doesn't overlap with the old controllers
         // registers.
         //

         if (SerialMemCompare(
                             PConfig->InterruptStatus,
                             PConfig->SpanOfInterruptStatus,
                             SerialPhysicalZero,
                             (ULONG)0
                             ) != AddressesAreEqual) {

            //
            // Check it against the existing device's controller address
            //

            if (SerialMemCompare(
                                PConfig->InterruptStatus,
                                PConfig->SpanOfInterruptStatus,
                                pExtension->OriginalController,
                                pExtension->SpanOfController
                                ) != AddressesAreDisjoint) {

               SerialLogError(
                             PDevObj->DriverObject,
                             NULL,
                             PConfig->Controller,
                             pExtension->OriginalController,
                             0,
                             0,
                             0,
                             47,
                             STATUS_SUCCESS,
                             SERIAL_STATUS_OVERLAP,
                             pDevExt->SymbolicLinkName.Length+sizeof(WCHAR),
                             pDevExt->SymbolicLinkName.Buffer,
                             pExtension->SymbolicLinkName.Length+sizeof(WCHAR),
                             pExtension->SymbolicLinkName.Buffer
                             );

               SerialDump(
                         SERERRORS,
                         ("SERIAL: Error in config record for %wZ\n"
                          "------- status address overlaps with\n"
                          "------- previous serial device registers\n",
                          &pDevExt->DeviceName)
                         );

               return STATUS_NO_SUCH_DEVICE;
            }

            //
            // If the old configuration record has an interrupt
            // status, the addresses should not overlap.
            //

            if (SerialMemCompare(
                                PConfig->InterruptStatus,
                                PConfig->SpanOfInterruptStatus,
                                SerialPhysicalZero,
                                (ULONG)0
                                ) != AddressesAreEqual) {

               if (SerialMemCompare(
                                   PConfig->InterruptStatus,
                                   PConfig->SpanOfInterruptStatus,
                                   pExtension->OriginalInterruptStatus,
                                   pExtension->SpanOfInterruptStatus
                                   ) == AddressesOverlap) {

                  SerialLogError(
                                PDevObj->DriverObject,
                                NULL,
                                PConfig->Controller,
                                pExtension->OriginalController,
                                0,
                                0,
                                0,
                                48,
                                STATUS_SUCCESS,
                                SERIAL_STATUS_STATUS_OVERLAP,
                                pDevExt->SymbolicLinkName.Length+sizeof(WCHAR),
                                pDevExt->SymbolicLinkName.Buffer,
                                pExtension->SymbolicLinkName.Length
                                + sizeof(WCHAR),
                                pExtension->SymbolicLinkName.Buffer
                                );

                  SerialDump(
                            SERERRORS,
                            ("SERIAL: Error in config record for %wZ\n"
                             "------- status address overlaps with\n"
                             "------- previous serial status register\n",
                             &pDevExt->DeviceName)
                            );

                  return STATUS_NO_SUCH_DEVICE;
               }
            }
         }       // if ((pExtension->InterfaceType  == pDevExt->InterfaceType) &&


         //
         // If the old configuration record has a status
         // address make sure that it doesn't overlap with
         // the new controllers address.  (Interrupt status
         // overlap is take care of above.
         //

         if (SerialMemCompare(
                             pExtension->OriginalInterruptStatus,
                             pExtension->SpanOfInterruptStatus,
                             SerialPhysicalZero,
                             (ULONG)0
                             ) != AddressesAreEqual) {

            if (SerialMemCompare(
                                PConfig->Controller,
                                PConfig->SpanOfController,
                                pExtension->OriginalInterruptStatus,
                                pExtension->SpanOfInterruptStatus
                                ) == AddressesOverlap) {

               SerialLogError(
                             PDevObj->DriverObject,
                             NULL,
                             PConfig->Controller,
                             pExtension->OriginalController,
                             0,
                             0,
                             0,
                             49,
                             STATUS_SUCCESS,
                             SERIAL_CONTROL_STATUS_OVERLAP,
                             pDevExt->SymbolicLinkName.Length
                             + sizeof(WCHAR),
                             pDevExt->SymbolicLinkName.Buffer,
                             pExtension->SymbolicLinkName.Length+sizeof(WCHAR),
                             pExtension->SymbolicLinkName.Buffer
                             );

               SerialDump(
                         SERERRORS,
                         ("SERIAL: Error in config record for %wZ\n"
                          "------- register address overlaps with\n"
                          "------- previous serial status register\n",
                          &pDevExt->DeviceName)
                         );

               return STATUS_NO_SUCH_DEVICE;
            }
         }
      }

      pCurDevObj = pCurDevObj->Flink;

      if (pCurDevObj != NULL) {
         pExtension = CONTAINING_RECORD(pCurDevObj, SERIAL_DEVICE_EXTENSION,
                                        AllDevObjs);
      }
   }   // while (pCurDevObj != NULL && pCurDevObj != &SerialGlobals.AllDevObjs)



   //
   // Now, we will check if this is a port on a multiport card.
   // The conditions are same ISR set and same IRQL/Vector
   //

   //
   // Loop through all previously attached devices
   //

   if (!IsListEmpty(&SerialGlobals.AllDevObjs)) {
      pCurDevObj = SerialGlobals.AllDevObjs.Flink;
      pExtension = CONTAINING_RECORD(pCurDevObj, SERIAL_DEVICE_EXTENSION,
                                     AllDevObjs);
   } else {
      pCurDevObj = NULL;
      pExtension = NULL;
   }


   //
   // If there is an interrupt status then we
   // loop through the config list again to look
   // for a config record with the same interrupt
   // status (on the same bus).
   //

   if ((SerialMemCompare(
                        PConfig->InterruptStatus,
                        PConfig->SpanOfInterruptStatus,
                        SerialPhysicalZero,
                        (ULONG)0
                        ) != AddressesAreEqual) &&
       (pCurDevObj != NULL)) {

      ASSERT(pExtension != NULL);

      //
      // We have an interrupt status.  Loop through all
      // previous records, look for an existing interrupt status
      // the same as the current interrupt status.
      //
      do {

         //
         // We only care about this list if the elements are on the
         // same bus as this new entry.  (Their interrupts must therefore
         // also be the on the same bus.  We will check that momentarily).
         //
         // We don't check here for the dissimilar interrupts since that
         // could cause us to miss the error of having the same interrupt
         // status but different interrupts - which is bizzare.
         //

         if ((pExtension->InterfaceType == PConfig->InterfaceType) &&
             (pExtension->AddressSpace == PConfig->AddressSpace) &&
             (pExtension->BusNumber == PConfig->BusNumber)) {

            //
            // If the interrupt status is the same, then same card.
            //

            if (SerialMemCompare(
                                pExtension->OriginalInterruptStatus,
                                pExtension->SpanOfInterruptStatus,
                                PConfig->InterruptStatus,
                                PConfig->SpanOfInterruptStatus
                                ) == AddressesAreEqual) {

               //
               // Same card.  Now make sure that they
               // are using the same interrupt parameters.
               //

               if ((PConfig->OriginalIrql != pExtension->OriginalIrql) ||
                   (PConfig->OriginalVector != pExtension->OriginalVector)) {

                  //
                  // We won't put this into the configuration
                  // list.
                  //
                  SerialLogError(
                                PDevObj->DriverObject,
                                NULL,
                                PConfig->Controller,
                                pExtension->OriginalController,
                                0,
                                0,
                                0,
                                50,
                                STATUS_SUCCESS,
                                SERIAL_MULTI_INTERRUPT_CONFLICT,
                                pDevExt->SymbolicLinkName.Length+sizeof(WCHAR),
                                pDevExt->SymbolicLinkName.Buffer,
                                pExtension->SymbolicLinkName.Length
                                + sizeof(WCHAR),
                                pExtension->SymbolicLinkName.Buffer
                                );

                  SerialDump(
                            SERERRORS,
                            ("SERIAL: Configuration error for %wZ\n"
                             "------- Same multiport - different interrupts\n",
                             &pDevExt->DeviceName)
                            );
                  return STATUS_NO_SUCH_DEVICE;

               }

               //
               // We should never get this far on a restart since we don't
               // support stop on ISA multiport devices!
               //

               ASSERT(pDevExt->PNPState == SERIAL_PNP_ADDED);

               //
               //
               // Initialize the device as part of a multiport board
               //

               SerialDump(SERDIAG1, ("SERIAL: Aha! It is a multiport node\n"));
               SerialDump(SERDIAG1, ("------: Matched to %x\n", pExtension));

               status = SerialInitMultiPort(pExtension, PConfig, PDevObj);

               //
               // A port can be one of three things:
               //    A standalone
               //    A non-root on a multiport
               //    A root on a multiport
               //
               // It can only share an interrupt if it is a root
               // or if it is a standalone.  Since this was a non-root
               // we don't need to check if it shares an interrupt
               // and we can return.
               //
               return status;
            }
         }

         //
         // No match, check some more
         //

         pCurDevObj = pCurDevObj->Flink;
         if (pCurDevObj != NULL) {
            pExtension = CONTAINING_RECORD(pCurDevObj,SERIAL_DEVICE_EXTENSION,
                                           AllDevObjs);
         }

      } while (pCurDevObj != NULL && pCurDevObj != &SerialGlobals.AllDevObjs);
   }
#endif //(NEC_98)


   SerialDump(SERDIAG1, ("SERIAL: Aha! It is a standalone node or first multi"
                         "\n"));
   status = SerialInitOneController(PDevObj, PConfig);

   if (!NT_SUCCESS(status)) {
      return status;
   }

   //
   // The device is initialized.  Now we need to check if 
   // this device shares an interrupt with anyone.
   //


   //
   // Loop through all previously attached devices
   //

   if (!IsListEmpty(&SerialGlobals.AllDevObjs)) {
      pCurDevObj = SerialGlobals.AllDevObjs.Flink;
      pExtension = CONTAINING_RECORD(pCurDevObj, SERIAL_DEVICE_EXTENSION,
                                     AllDevObjs);
   } else {
      pCurDevObj = NULL;
      pExtension = NULL;
   }

   //
   // Go through the list again looking for previous devices
   // with the same interrupt.  The first one found will either be a root
   // or standalone.  Order of insertion is important here!
   //

   if (!PConfig->Jensen && (pCurDevObj != NULL)) {
      do {

         //
         // We only care about interrupts that are on
         // the same bus.
         //

         if ((pExtension->InterfaceType == PConfig->InterfaceType) &&
             (pExtension->BusNumber == PConfig->BusNumber)) {

            if ((pExtension->OriginalIrql == PConfig->OriginalIrql) &&
                (pExtension->OriginalVector == PConfig->OriginalVector)) {
                pExtension->NewExtension = pDevExt;

                //
                // We will share another's CIsrSw so we can free the one
                // allocated for us during init
                //

                ExFreePool(pDevExt->CIsrSw);

                SerialDump(SERDIAG1, ("Becoming sharer: %08X %08X %08X\n",
                                      pExtension, pExtension->OriginalIrql,
                                      &pExtension->CIsrSw->SharerList));

                KeSynchronizeExecution(pExtension->Interrupt,
                                       SerialBecomeSharer, pExtension);

               return STATUS_SUCCESS;

            }

         }

         //
         // No match, check some more
         //

         pCurDevObj = pCurDevObj->Flink;

         if (pCurDevObj != NULL) {
            pExtension = CONTAINING_RECORD(pCurDevObj, SERIAL_DEVICE_EXTENSION,
                                           AllDevObjs);
         }
      } while (pCurDevObj != NULL
               && pCurDevObj != &SerialGlobals.AllDevObjs);
   }

   return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\mps\spx\speed\uartlib\inc\public\lib95x.h ===
/******************************************************************************
*	
*	$Workfile: lib95x.h $ 
*
*	$Author: Psmith $ 
*
*	$Revision: 11 $
* 
*	$Modtime: 6/06/00 16:12 $ 
*
*	Description: Contains function prototypes for 16C95X UART library functions. 
*
******************************************************************************/
#if !defined(_LIB95X_H)		/* LIB95X.H */
#define _LIB95X_H


ULSTATUS UL_InitUart_16C95X(PINIT_UART pInitUart, PUART_OBJECT pFirstUart, PUART_OBJECT *ppUart);
void UL_DeInitUart_16C95X(PUART_OBJECT pUart);
void UL_ResetUart_16C95X(PUART_OBJECT pUart);
ULSTATUS UL_VerifyUart_16C95X(PUART_OBJECT pUart);

ULSTATUS UL_SetConfig_16C95X(PUART_OBJECT pUart, PUART_CONFIG pNewUartConfig, DWORD ConfigMask);
ULSTATUS UL_BufferControl_16C95X(PUART_OBJECT pUart, PVOID pBufferControl, int Operation, DWORD Flags);

ULSTATUS UL_ModemControl_16C95X(PUART_OBJECT pUart, PDWORD pModemSignals, int Operation);
DWORD UL_IntsPending_16C95X(PUART_OBJECT *ppUart);
void UL_GetUartInfo_16C95X(PUART_OBJECT pUart, PUART_INFO pUartInfo);

int UL_OutputData_16C95X(PUART_OBJECT pUart);
int UL_InputData_16C95X(PUART_OBJECT pUart, PDWORD pRxStatus);

int UL_ReadData_16C95X(PUART_OBJECT pUart, PBYTE pDest, int Size);
ULSTATUS UL_WriteData_16C95X(PUART_OBJECT pUart, PBYTE pData, int Size);
ULSTATUS UL_ImmediateByte_16C95X(PUART_OBJECT pUart, PBYTE pData, int Operation);
ULSTATUS UL_GetStatus_16C95X(PUART_OBJECT pUart, PDWORD pReturnData, int Operation);
void UL_DumpUartRegs_16C95X(PUART_OBJECT pUart);

#define UL_SetAppBackPtr_16C95X		UL_SetAppBackPtr
#define UL_GetAppBackPtr_16C95X		UL_GetAppBackPtr

#define UL_GetConfig_16C95X		UL_GetConfig
#define UL_GetUartObject_16C95X		UL_GetUartObject

#endif	/* End of LIB95X.H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\ser101\modmflow.c ===
/*++

Copyright (c) 1991, 1992, 1993 Microsoft Corporation

Module Name:

    modmflow.c

Abstract:

    This module contains *MOST* of the code used to manipulate
    the modem control and status registers.  The vast majority
    of the remainder of flow control is concentrated in the
    Interrupt service routine.  A very small amount resides
    in the read code that pull characters out of the interrupt
    buffer.

Author:

    Anthony V. Ercolano 26-Sep-1991

Environment:

    Kernel mode

Revision History :

--*/

#include "precomp.h"

BOOLEAN
SerialDecrementRTSCounter(
    IN PVOID Context
    );

#ifdef ALLOC_PRAGMA
#if 0
#pragma alloc_text(PAGESER,SerialHandleReducedIntBuffer)
#pragma alloc_text(PAGESER,SerialProdXonXoff)
#pragma alloc_text(PAGESER,SerialHandleModemUpdate)
#pragma alloc_text(PAGESER,SerialPerhapsLowerRTS)
#pragma alloc_text(PAGESER,SerialStartTimerLowerRTS)
#pragma alloc_text(PAGESER,SerialInvokePerhapsLowerRTS)
#pragma alloc_text(PAGESER,SerialSetDTR)
//#pragma alloc_text(PAGESER,SerialClrDTR)
#pragma alloc_text(PAGESER,SerialSetRTS)
//#pragma alloc_text(PAGESER,SerialClrRTS)
//#pragma alloc_text(PAGESER,SerialSetupNewHandFlow)
#pragma alloc_text(PAGESER,SerialSetHandFlow)
#pragma alloc_text(PAGESER,SerialTurnOnBreak)
#pragma alloc_text(PAGESER,SerialTurnOffBreak)
#pragma alloc_text(PAGESER,SerialPretendXoff)
#pragma alloc_text(PAGESER,SerialPretendXon)
#pragma alloc_text(PAGESER,SerialDecrementRTSCounter)
#endif
#endif

BOOLEAN
SerialSetDTR(
    IN PVOID Context
    )

/*++

Routine Description:

    This routine which is only called at interrupt level is used
    to set the DTR in the modem control register.

Arguments:

    Context - Really a pointer to the device extension.

Return Value:

    This routine always returns FALSE.

--*/

{

    PSERIAL_DEVICE_EXTENSION Extension = Context;
    UCHAR ModemControl;

    ModemControl = READ_MODEM_CONTROL(Extension->Controller);

    ModemControl |= SERIAL_MCR_DTR;

    SerialDump(
        SERFLOW,
        ("SERIAL: Setting DTR for %x\n",
         Extension->Controller)
        );
    WRITE_MODEM_CONTROL(
        Extension->Controller,
        ModemControl
        );

    return FALSE;

}

BOOLEAN
SerialClrDTR(
    IN PVOID Context
    )

/*++

Routine Description:

    This routine which is only called at interrupt level is used
    to clear the DTR in the modem control register.

Arguments:

    Context - Really a pointer to the device extension.

Return Value:

    This routine always returns FALSE.

--*/

{

    PSERIAL_DEVICE_EXTENSION Extension = Context;
    UCHAR ModemControl;

    ModemControl = READ_MODEM_CONTROL(Extension->Controller);

    ModemControl &= ~SERIAL_MCR_DTR;

    SerialDump(
        SERFLOW,
        ("SERIAL: Clearing DTR for %x\n",
         Extension->Controller)
        );
    WRITE_MODEM_CONTROL(
        Extension->Controller,
        ModemControl
        );

    return FALSE;

}

BOOLEAN
SerialSetRTS(
    IN PVOID Context
    )

/*++

Routine Description:

    This routine which is only called at interrupt level is used
    to set the RTS in the modem control register.

Arguments:

    Context - Really a pointer to the device extension.

Return Value:

    This routine always returns FALSE.

--*/

{

    PSERIAL_DEVICE_EXTENSION Extension = Context;
    UCHAR ModemControl;

    ModemControl = READ_MODEM_CONTROL(Extension->Controller);

    ModemControl |= SERIAL_MCR_RTS;

    SerialDump(
        SERFLOW,
        ("SERIAL: Setting Rts for %x\n",
         Extension->Controller)
        );
    WRITE_MODEM_CONTROL(
        Extension->Controller,
        ModemControl
        );

    return FALSE;

}

BOOLEAN
SerialClrRTS(
    IN PVOID Context
    )

/*++

Routine Description:

    This routine which is only called at interrupt level is used
    to clear the RTS in the modem control register.

Arguments:

    Context - Really a pointer to the device extension.

Return Value:

    This routine always returns FALSE.

--*/

{

    PSERIAL_DEVICE_EXTENSION Extension = Context;
    UCHAR ModemControl;

    ModemControl = READ_MODEM_CONTROL(Extension->Controller);

    ModemControl &= ~SERIAL_MCR_RTS;

    SerialDump(
        SERFLOW,
        ("SERIAL: Clearing Rts for %x\n",
         Extension->Controller)
        );
    WRITE_MODEM_CONTROL(
        Extension->Controller,
        ModemControl
        );

    return FALSE;

}

BOOLEAN
SerialSetupNewHandFlow(
    IN PSERIAL_DEVICE_EXTENSION Extension,
    IN PSERIAL_HANDFLOW NewHandFlow
    )

/*++

Routine Description:

    This routine adjusts the flow control based on new
    control flow.

Arguments:

    Extension - A pointer to the serial device extension.

    NewHandFlow - A pointer to a serial handflow structure
                  that is to become the new setup for flow
                  control.

Return Value:

    This routine always returns FALSE.

--*/

{

    SERIAL_HANDFLOW New = *NewHandFlow;

    //
    // If the Extension->DeviceIsOpened is FALSE that means
    // we are entering this routine in response to an open request.
    // If that is so, then we always proceed with the work regardless
    // of whether things have changed.
    //

    //
    // First we take care of the DTR flow control.  We only
    // do work if something has changed.
    //

    if ((!Extension->DeviceIsOpened) ||
        ((Extension->HandFlow.ControlHandShake & SERIAL_DTR_MASK) !=
         (New.ControlHandShake & SERIAL_DTR_MASK))) {

        SerialDump(
            SERFLOW,
            ("SERIAL: Processing DTR flow for %x\n",
             Extension->Controller)
            );

        if (New.ControlHandShake & SERIAL_DTR_MASK) {

            //
            // Well we might want to set DTR.
            //
            // Before we do, we need to check whether we are doing
            // dtr flow control.  If we are then we need to check
            // if then number of characters in the interrupt buffer
            // exceeds the XoffLimit.  If it does then we don't
            // enable DTR AND we set the RXHolding to record that
            // we are holding because of the dtr.
            //

            if ((New.ControlHandShake & SERIAL_DTR_MASK)
                == SERIAL_DTR_HANDSHAKE) {

                if ((Extension->BufferSize - New.XoffLimit) >
                    Extension->CharsInInterruptBuffer) {

                    //
                    // However if we are already holding we don't want
                    // to turn it back on unless we exceed the Xon
                    // limit.
                    //

                    if (Extension->RXHolding & SERIAL_RX_DTR) {

                        //
                        // We can assume that its DTR line is already low.
                        //

                        if (Extension->CharsInInterruptBuffer >
                            (ULONG)New.XonLimit) {

                            SerialDump(
                                SERFLOW,
                                ("SERIAL: Removing DTR block on reception for %x\n",
                                 Extension->Controller)
                                );
                            Extension->RXHolding &= ~SERIAL_RX_DTR;
                            SerialSetDTR(Extension);

                        }

                    } else {

                        SerialSetDTR(Extension);

                    }

                } else {

                    SerialDump(
                        SERFLOW,
                        ("SERIAL: Setting DTR block on reception for %x\n",
                         Extension->Controller)
                        );
                    Extension->RXHolding |= SERIAL_RX_DTR;
                    SerialClrDTR(Extension);

                }

            } else {

                //
                // Note that if we aren't currently doing dtr flow control then
                // we MIGHT have been.  So even if we aren't currently doing
                // DTR flow control, we should still check if RX is holding
                // because of DTR.  If it is, then we should clear the holding
                // of this bit.
                //

                if (Extension->RXHolding & SERIAL_RX_DTR) {

                    SerialDump(
                        SERFLOW,
                        ("SERIAL: Removing dtr block of reception for %x\n",
                        Extension->Controller)
                        );
                    Extension->RXHolding &= ~SERIAL_RX_DTR;

                }

                SerialSetDTR(Extension);

            }

        } else {

            //
            // The end result here will be that DTR is cleared.
            //
            // We first need to check whether reception is being held
            // up because of previous DTR flow control.  If it is then
            // we should clear that reason in the RXHolding mask.
            //

            if (Extension->RXHolding & SERIAL_RX_DTR) {

                SerialDump(
                    SERFLOW,
                    ("SERIAL: removing dtr block of reception for %x\n",
                    Extension->Controller)
                    );
                Extension->RXHolding &= ~SERIAL_RX_DTR;

            }

            SerialClrDTR(Extension);

        }

    }

    //
    // Time to take care of the RTS Flow control.
    //
    // First we only do work if something has changed.
    //

    if ((!Extension->DeviceIsOpened) ||
        ((Extension->HandFlow.FlowReplace & SERIAL_RTS_MASK) !=
         (New.FlowReplace & SERIAL_RTS_MASK))) {

        SerialDump(
            SERFLOW,
            ("SERIAL: Processing RTS flow\n",
             Extension->Controller)
            );

        if ((New.FlowReplace & SERIAL_RTS_MASK) ==
            SERIAL_RTS_HANDSHAKE) {

            //
            // Well we might want to set RTS.
            //
            // Before we do, we need to check whether we are doing
            // rts flow control.  If we are then we need to check
            // if then number of characters in the interrupt buffer
            // exceeds the XoffLimit.  If it does then we don't
            // enable RTS AND we set the RXHolding to record that
            // we are holding because of the rts.
            //

            if ((Extension->BufferSize - New.XoffLimit) >
                Extension->CharsInInterruptBuffer) {

                //
                // However if we are already holding we don't want
                // to turn it back on unless we exceed the Xon
                // limit.
                //

                if (Extension->RXHolding & SERIAL_RX_RTS) {

                    //
                    // We can assume that its RTS line is already low.
                    //

                    if (Extension->CharsInInterruptBuffer >
                        (ULONG)New.XonLimit) {

                       SerialDump(
                           SERFLOW,
                           ("SERIAL: Removing rts block of reception for %x\n",
                           Extension->Controller)
                           );
                        Extension->RXHolding &= ~SERIAL_RX_RTS;
                        SerialSetRTS(Extension);

                    }

                } else {

                    SerialSetRTS(Extension);

                }

            } else {

                SerialDump(
                    SERFLOW,
                    ("SERIAL: Setting rts block of reception for %x\n",
                    Extension->Controller)
                    );
                Extension->RXHolding |= SERIAL_RX_RTS;
                SerialClrRTS(Extension);

            }

        } else if ((New.FlowReplace & SERIAL_RTS_MASK) ==
                   SERIAL_RTS_CONTROL) {

            //
            // Note that if we aren't currently doing rts flow control then
            // we MIGHT have been.  So even if we aren't currently doing
            // RTS flow control, we should still check if RX is holding
            // because of RTS.  If it is, then we should clear the holding
            // of this bit.
            //

            if (Extension->RXHolding & SERIAL_RX_RTS) {

                SerialDump(
                    SERFLOW,
                    ("SERIAL: Clearing rts block of reception for %x\n",
                    Extension->Controller)
                    );
                Extension->RXHolding &= ~SERIAL_RX_RTS;

            }

            SerialSetRTS(Extension);

        } else if ((New.FlowReplace & SERIAL_RTS_MASK) ==
                   SERIAL_TRANSMIT_TOGGLE) {

            //
            // We first need to check whether reception is being held
            // up because of previous RTS flow control.  If it is then
            // we should clear that reason in the RXHolding mask.
            //

            if (Extension->RXHolding & SERIAL_RX_RTS) {

                SerialDump(
                    SERFLOW,
                    ("SERIAL: TOGGLE Clearing rts block of reception for %x\n",
                    Extension->Controller)
                    );
                Extension->RXHolding &= ~SERIAL_RX_RTS;

            }

            //
            // We have to place the rts value into the Extension
            // now so that the code that tests whether the
            // rts line should be lowered will find that we
            // are "still" doing transmit toggling.  The code
            // for lowering can be invoked later by a timer so
            // it has to test whether it still needs to do its
            // work.
            //

            Extension->HandFlow.FlowReplace &= ~SERIAL_RTS_MASK;
            Extension->HandFlow.FlowReplace |= SERIAL_TRANSMIT_TOGGLE;

            //
            // The order of the tests is very important below.
            //
            // If there is a break then we should turn on the RTS.
            //
            // If there isn't a break but there are characters in
            // the hardware, then turn on the RTS.
            //
            // If there are writes pending that aren't being held
            // up, then turn on the RTS.
            //

            if ((Extension->TXHolding & SERIAL_TX_BREAK) ||
                ((SerialProcessLSR(Extension) & (SERIAL_LSR_THRE |
                                                 SERIAL_LSR_TEMT)) !=
                                                (SERIAL_LSR_THRE |
                                                 SERIAL_LSR_TEMT)) ||
                (Extension->CurrentWriteIrp || Extension->TransmitImmediate ||
                 (!IsListEmpty(&Extension->WriteQueue)) &&
                 (!Extension->TXHolding))) {

                SerialSetRTS(Extension);

            } else {

                //
                // This routine will check to see if it is time
                // to lower the RTS because of transmit toggle
                // being on.  If it is ok to lower it, it will,
                // if it isn't ok, it will schedule things so
                // that it will get lowered later.
                //

                Extension->CountOfTryingToLowerRTS++;
                SerialPerhapsLowerRTS(Extension);

            }

        } else {

            //
            // The end result here will be that RTS is cleared.
            //
            // We first need to check whether reception is being held
            // up because of previous RTS flow control.  If it is then
            // we should clear that reason in the RXHolding mask.
            //

            if (Extension->RXHolding & SERIAL_RX_RTS) {

                SerialDump(
                    SERFLOW,
                    ("SERIAL: Clearing rts block of reception for %x\n",
                    Extension->Controller)
                    );
                Extension->RXHolding &= ~SERIAL_RX_RTS;

            }

            SerialClrRTS(Extension);

        }

    }

    //
    // We now take care of automatic receive flow control.
    // We only do work if things have changed.
    //

    if ((!Extension->DeviceIsOpened) ||
        ((Extension->HandFlow.FlowReplace & SERIAL_AUTO_RECEIVE) !=
         (New.FlowReplace & SERIAL_AUTO_RECEIVE))) {

        if (New.FlowReplace & SERIAL_AUTO_RECEIVE) {

            //
            // We wouldn't be here if it had been on before.
            //
            // We should check to see whether we exceed the turn
            // off limits.
            //
            // Note that since we are following the OS/2 flow
            // control rules we will never send an xon if
            // when enabling xon/xoff flow control we discover that
            // we could receive characters but we are held up do
            // to a previous Xoff.
            //

            if ((Extension->BufferSize - New.XoffLimit) <=
                Extension->CharsInInterruptBuffer) {

                //
                // Cause the Xoff to be sent.
                //

                Extension->RXHolding |= SERIAL_RX_XOFF;

                SerialProdXonXoff(
                    Extension,
                    FALSE
                    );

            }

        } else {

            //
            // The app has disabled automatic receive flow control.
            //
            // If transmission was being held up because of
            // an automatic receive Xoff, then we should
            // cause an Xon to be sent.
            //

            if (Extension->RXHolding & SERIAL_RX_XOFF) {

                Extension->RXHolding &= ~SERIAL_RX_XOFF;

                //
                // Cause the Xon to be sent.
                //

                SerialProdXonXoff(
                    Extension,
                    TRUE
                    );

            }

        }

    }

    //
    // We now take care of automatic transmit flow control.
    // We only do work if things have changed.
    //

    if ((!Extension->DeviceIsOpened) ||
        ((Extension->HandFlow.FlowReplace & SERIAL_AUTO_TRANSMIT) !=
         (New.FlowReplace & SERIAL_AUTO_TRANSMIT))) {

        if (New.FlowReplace & SERIAL_AUTO_TRANSMIT) {

            //
            // We wouldn't be here if it had been on before.
            //
            // BUG BUG ??? There is some belief that if autotransmit
            // was just enabled, I should go look in what we
            // already received, and if we find the xoff character
            // then we should stop transmitting.  I think this
            // is an application bug.  For now we just care about
            // what we see in the future.
            //

            ;

        } else {

            //
            // The app has disabled automatic transmit flow control.
            //
            // If transmission was being held up because of
            // an automatic transmit Xoff, then we should
            // cause an Xon to be sent.
            //

            if (Extension->TXHolding & SERIAL_TX_XOFF) {

                Extension->TXHolding &= ~SERIAL_TX_XOFF;

                //
                // Cause the Xon to be sent.
                //

                SerialProdXonXoff(
                    Extension,
                    TRUE
                    );

            }

        }

    }

    //
    // At this point we can simply make sure that entire
    // handflow structure in the extension is updated.
    //

    Extension->HandFlow = New;

    return FALSE;

}

BOOLEAN
SerialSetHandFlow(
    IN PVOID Context
    )

/*++

Routine Description:

    This routine is used to set the handshake and control
    flow in the device extension.

Arguments:

    Context - Pointer to a structure that contains a pointer to
              the device extension and a pointer to a handflow
              structure..

Return Value:

    This routine always returns FALSE.

--*/

{

    PSERIAL_IOCTL_SYNC S = Context;
    PSERIAL_DEVICE_EXTENSION Extension = S->Extension;
    PSERIAL_HANDFLOW HandFlow = S->Data;

    SerialSetupNewHandFlow(
        Extension,
        HandFlow
        );

    SerialHandleModemUpdate(
        Extension,
        FALSE
        );

    return FALSE;

}

BOOLEAN
SerialTurnOnBreak(
    IN PVOID Context
    )

/*++

Routine Description:

    This routine will turn on break in the hardware and
    record the fact the break is on, in the extension variable
    that holds reasons that transmission is stopped.

Arguments:

    Context - Really a pointer to the device extension.

Return Value:

    This routine always returns FALSE.

--*/

{

    PSERIAL_DEVICE_EXTENSION Extension = Context;

    UCHAR OldLineControl;

    if ((Extension->HandFlow.FlowReplace & SERIAL_RTS_MASK) ==
        SERIAL_TRANSMIT_TOGGLE) {

        SerialSetRTS(Extension);

    }

    OldLineControl = READ_LINE_CONTROL(Extension->Controller);

    OldLineControl |= SERIAL_LCR_BREAK;

    WRITE_LINE_CONTROL(
        Extension->Controller,
        OldLineControl
        );

    Extension->TXHolding |= SERIAL_TX_BREAK;

    return FALSE;

}

BOOLEAN
SerialTurnOffBreak(
    IN PVOID Context
    )

/*++

Routine Description:

    This routine will turn off break in the hardware and
    record the fact the break is off, in the extension variable
    that holds reasons that transmission is stopped.

Arguments:

    Context - Really a pointer to the device extension.

Return Value:

    This routine always returns FALSE.

--*/

{

    PSERIAL_DEVICE_EXTENSION Extension = Context;

    UCHAR OldLineControl;

    if (Extension->TXHolding & SERIAL_TX_BREAK) {

        //
        // We actually have a good reason for testing if transmission
        // is holding instead of blindly clearing the bit.
        //
        // If transmission actually was holding and the result of
        // clearing the bit is that we should restart transmission
        // then we will poke the interrupt enable bit, which will
        // cause an actual interrupt and transmission will then
        // restart on its own.
        //
        // If transmission wasn't holding and we poked the bit
        // then we would interrupt before a character actually made
        // it out and we could end up over writing a character in
        // the transmission hardware.

        OldLineControl = READ_LINE_CONTROL(Extension->Controller);

        OldLineControl &= ~SERIAL_LCR_BREAK;

        WRITE_LINE_CONTROL(
            Extension->Controller,
            OldLineControl
            );

        Extension->TXHolding &= ~SERIAL_TX_BREAK;

        if (!Extension->TXHolding &&
            (Extension->TransmitImmediate ||
             Extension->WriteLength) &&
             Extension->HoldingEmpty) {

            DISABLE_ALL_INTERRUPTS(Extension->Controller);
            ENABLE_ALL_INTERRUPTS(Extension->Controller);

        } else {

            //
            // The following routine will lower the rts if we
            // are doing transmit toggleing and there is no
            // reason to keep it up.
            //

            Extension->CountOfTryingToLowerRTS++;
            SerialPerhapsLowerRTS(Extension);

        }

    }

    return FALSE;

}

BOOLEAN
SerialPretendXoff(
    IN PVOID Context
    )

/*++

Routine Description:

    This routine is used to process the Ioctl that request the
    driver to act as if an Xoff was received.  Even if the
    driver does not have automatic Xoff/Xon flowcontrol - This
    still will stop the transmission.  This is the OS/2 behavior
    and is not well specified for Windows.  Therefore we adopt
    the OS/2 behavior.

    Note: If the driver does not have automatic Xoff/Xon enabled
    then the only way to restart transmission is for the
    application to request we "act" as if we saw the xon.

Arguments:

    Context - Really a pointer to the device extension.

Return Value:

    This routine always returns FALSE.

--*/

{

    PSERIAL_DEVICE_EXTENSION Extension = Context;

    Extension->TXHolding |= SERIAL_TX_XOFF;

    if ((Extension->HandFlow.FlowReplace & SERIAL_RTS_MASK) ==
        SERIAL_TRANSMIT_TOGGLE) {

        SerialInsertQueueDpc(
            &Extension->StartTimerLowerRTSDpc,
            NULL,
            NULL,
            Extension
            )?Extension->CountOfTryingToLowerRTS++:0;

    }

    return FALSE;

}

BOOLEAN
SerialPretendXon(
    IN PVOID Context
    )

/*++

Routine Description:

    This routine is used to process the Ioctl that request the
    driver to act as if an Xon was received.

    Note: If the driver does not have automatic Xoff/Xon enabled
    then the only way to restart transmission is for the
    application to request we "act" as if we saw the xon.

Arguments:

    Context - Really a pointer to the device extension.

Return Value:

    This routine always returns FALSE.

--*/

{

    PSERIAL_DEVICE_EXTENSION Extension = Context;

    if (Extension->TXHolding) {

        //
        // We actually have a good reason for testing if transmission
        // is holding instead of blindly clearing the bit.
        //
        // If transmission actually was holding and the result of
        // clearing the bit is that we should restart transmission
        // then we will poke the interrupt enable bit, which will
        // cause an actual interrupt and transmission will then
        // restart on its own.
        //
        // If transmission wasn't holding and we poked the bit
        // then we would interrupt before a character actually made
        // it out and we could end up over writing a character in
        // the transmission hardware.

        Extension->TXHolding &= ~SERIAL_TX_XOFF;

        if (!Extension->TXHolding &&
            (Extension->TransmitImmediate ||
             Extension->WriteLength) &&
             Extension->HoldingEmpty) {

            DISABLE_ALL_INTERRUPTS(Extension->Controller);
            ENABLE_ALL_INTERRUPTS(Extension->Controller);

        }

    }

    return FALSE;

}

VOID
SerialHandleReducedIntBuffer(
    IN PSERIAL_DEVICE_EXTENSION Extension
    )

/*++

Routine Description:

    This routine is called to handle a reduction in the number
    of characters in the interrupt (typeahead) buffer.  It
    will check the current output flow control and re-enable transmission
    as needed.

    NOTE: This routine assumes that it is working at interrupt level.

Arguments:

    Extension - A pointer to the device extension.

Return Value:

    None.

--*/

{


    //
    // If we are doing receive side flow control and we are
    // currently "holding" then because we've emptied out
    // some characters from the interrupt buffer we need to
    // see if we can "re-enable" reception.
    //

    if (Extension->RXHolding) {

        if (Extension->CharsInInterruptBuffer <=
            (ULONG)Extension->HandFlow.XonLimit) {

            if (Extension->RXHolding & SERIAL_RX_DTR) {

                Extension->RXHolding &= ~SERIAL_RX_DTR;
                SerialSetDTR(Extension);

            }

            if (Extension->RXHolding & SERIAL_RX_RTS) {

                Extension->RXHolding &= ~SERIAL_RX_RTS;
                SerialSetRTS(Extension);

            }

            if (Extension->RXHolding & SERIAL_RX_XOFF) {

                //
                // Prod the transmit code to send xon.
                //

                SerialProdXonXoff(
                    Extension,
                    TRUE
                    );

            }

        }

    }

}

VOID
SerialProdXonXoff(
    IN PSERIAL_DEVICE_EXTENSION Extension,
    IN BOOLEAN SendXon
    )

/*++

Routine Description:

    This routine will set up the SendXxxxChar variables if
    necessary and determine if we are going to be interrupting
    because of current transmission state.  It will cause an
    interrupt to occur if neccessary, to send the xon/xoff char.

    NOTE: This routine assumes that it is called at interrupt
          level.

Arguments:

    Extension - A pointer to the serial device extension.

    SendXon - If a character is to be send, this indicates whether
              it should be an Xon or an Xoff.

Return Value:

    None.

--*/

{

    //
    // We assume that if the prodding is called more than
    // once that the last prod has set things up appropriately.
    //
    // We could get called before the character is sent out
    // because the send of the character was blocked because
    // of hardware flow control (or break).
    //

    if (!Extension->SendXonChar && !Extension->SendXoffChar
        && Extension->HoldingEmpty) {

        DISABLE_ALL_INTERRUPTS(Extension->Controller);
        ENABLE_ALL_INTERRUPTS(Extension->Controller);

    }

    if (SendXon) {

        Extension->SendXonChar = TRUE;
        Extension->SendXoffChar = FALSE;

    } else {

        Extension->SendXonChar = FALSE;
        Extension->SendXoffChar = TRUE;

    }

}

ULONG
SerialHandleModemUpdate(
    IN PSERIAL_DEVICE_EXTENSION Extension,
    IN BOOLEAN DoingTX
    )

/*++

Routine Description:

    This routine will be to check on the modem status, and
    handle any appropriate event notification as well as
    any flow control appropriate to modem status lines.

    NOTE: This routine assumes that it is called at interrupt
          level.

Arguments:

    Extension - A pointer to the serial device extension.

    DoingTX - This boolean is used to indicate that this call
              came from the transmit processing code.  If this
              is true then there is no need to cause a new interrupt
              since the code will be trying to send the next
              character as soon as this call finishes.

Return Value:

    This returns the old value of the modem status register
    (extended into a ULONG).

--*/

{

    //
    // We keep this local so that after we are done
    // examining the modem status and we've updated
    // the transmission holding value, we know whether
    // we've changed from needing to hold up transmission
    // to transmission being able to proceed.
    //
    ULONG OldTXHolding = Extension->TXHolding;

    //
    // Holds the value in the mode status register.
    //
    UCHAR ModemStatus;

    ModemStatus =
        READ_MODEM_STATUS(Extension->Controller);

    //
    // If we are placeing the modem status into the data stream
    // on every change, we should do it now.
    //

    if (Extension->EscapeChar) {

        if (ModemStatus & (SERIAL_MSR_DCTS |
                           SERIAL_MSR_DDSR |
                           SERIAL_MSR_TERI |
                           SERIAL_MSR_DDCD)) {

            SerialPutChar(
                Extension,
                Extension->EscapeChar
                );
            SerialPutChar(
                Extension,
                SERIAL_LSRMST_MST
                );
            SerialPutChar(
                Extension,
                ModemStatus
                );

        }

    }


    //
    // Take care of input flow control based on sensitivity
    // to the DSR.  This is done so that the application won't
    // see spurious data generated by odd devices.
    //
    // Basically, if we are doing dsr sensitivity then the
    // driver should only accept data when the dsr bit is
    // set.
    //

    if (Extension->HandFlow.ControlHandShake & SERIAL_DSR_SENSITIVITY) {

        if (ModemStatus & SERIAL_MSR_DSR) {

            //
            // The line is high.  Simply make sure that
            // RXHolding does't have the DSR bit.
            //

            Extension->RXHolding &= ~SERIAL_RX_DSR;

        } else {

            Extension->RXHolding |= SERIAL_RX_DSR;

        }

    } else {

        //
        // We don't have sensitivity due to DSR.  Make sure we
        // arn't holding. (We might have been, but the app just
        // asked that we don't hold for this reason any more.)
        //

        Extension->RXHolding &= ~SERIAL_RX_DSR;

    }

    //
    // Check to see if we have a wait
    // pending on the modem status events.  If we
    // do then we schedule a dpc to satisfy
    // that wait.
    //

    if (Extension->IsrWaitMask) {

        if ((Extension->IsrWaitMask & SERIAL_EV_CTS) &&
            (ModemStatus & SERIAL_MSR_DCTS)) {

            Extension->HistoryMask |= SERIAL_EV_CTS;

        }

        if ((Extension->IsrWaitMask & SERIAL_EV_DSR) &&
            (ModemStatus & SERIAL_MSR_DDSR)) {

            Extension->HistoryMask |= SERIAL_EV_DSR;

        }

        if ((Extension->IsrWaitMask & SERIAL_EV_RING) &&
            (ModemStatus & SERIAL_MSR_TERI)) {

            Extension->HistoryMask |= SERIAL_EV_RING;

        }

        if ((Extension->IsrWaitMask & SERIAL_EV_RLSD) &&
            (ModemStatus & SERIAL_MSR_DDCD)) {

            Extension->HistoryMask |= SERIAL_EV_RLSD;

        }

        if (Extension->IrpMaskLocation &&
            Extension->HistoryMask) {

            *Extension->IrpMaskLocation =
             Extension->HistoryMask;
            Extension->IrpMaskLocation = NULL;
            Extension->HistoryMask = 0;

            Extension->CurrentWaitIrp->
                IoStatus.Information = sizeof(ULONG);
            SerialInsertQueueDpc(
                &Extension->CommWaitDpc,
                NULL,
                NULL,
                Extension
                );

        }

    }

    //
    // If the app has modem line flow control then
    // we check to see if we have to hold up transmission.
    //

    if (Extension->HandFlow.ControlHandShake &
        SERIAL_OUT_HANDSHAKEMASK) {

        if (Extension->HandFlow.ControlHandShake &
            SERIAL_CTS_HANDSHAKE) {

            if (ModemStatus & SERIAL_MSR_CTS) {

                Extension->TXHolding &= ~SERIAL_TX_CTS;

            } else {

                Extension->TXHolding |= SERIAL_TX_CTS;

            }

        } else {

            Extension->TXHolding &= ~SERIAL_TX_CTS;

        }

        if (Extension->HandFlow.ControlHandShake &
            SERIAL_DSR_HANDSHAKE) {

            if (ModemStatus & SERIAL_MSR_DSR) {

                Extension->TXHolding &= ~SERIAL_TX_DSR;

            } else {

                Extension->TXHolding |= SERIAL_TX_DSR;

            }

        } else {

            Extension->TXHolding &= ~SERIAL_TX_DSR;

        }

        if (Extension->HandFlow.ControlHandShake &
            SERIAL_DCD_HANDSHAKE) {

            if (ModemStatus & SERIAL_MSR_DCD) {

                Extension->TXHolding &= ~SERIAL_TX_DCD;

            } else {

                Extension->TXHolding |= SERIAL_TX_DCD;

            }

        } else {

            Extension->TXHolding &= ~SERIAL_TX_DCD;

        }

        //
        // If we hadn't been holding, and now we are then
        // queue off a dpc that will lower the RTS line
        // if we are doing transmit toggling.
        //

        if (!OldTXHolding && Extension->TXHolding  &&
            ((Extension->HandFlow.FlowReplace & SERIAL_RTS_MASK) ==
              SERIAL_TRANSMIT_TOGGLE)) {

            SerialInsertQueueDpc(
                &Extension->StartTimerLowerRTSDpc,
                NULL,
                NULL,
                Extension
                )?Extension->CountOfTryingToLowerRTS++:0;

        }

        //
        // We've done any adjusting that needed to be
        // done to the holding mask given updates
        // to the modem status.  If the Holding mask
        // is clear (and it wasn't clear to start)
        // and we have "write" work to do set things
        // up so that the transmission code gets invoked.
        //

        if (!DoingTX && OldTXHolding && !Extension->TXHolding) {

            if (!Extension->TXHolding &&
                (Extension->TransmitImmediate ||
                 Extension->WriteLength) &&
                 Extension->HoldingEmpty) {

                DISABLE_ALL_INTERRUPTS(Extension->Controller);
                ENABLE_ALL_INTERRUPTS(Extension->Controller);

            }

        }

    } else {

        //
        // We need to check if transmission is holding
        // up because of modem status lines.  What
        // could have occured is that for some strange
        // reason, the app has asked that we no longer
        // stop doing output flow control based on
        // the modem status lines.  If however, we
        // *had* been held up because of the status lines
        // then we need to clear up those reasons.
        //

        if (Extension->TXHolding & (SERIAL_TX_DCD |
                                    SERIAL_TX_DSR |
                                    SERIAL_TX_CTS)) {

            Extension->TXHolding &= ~(SERIAL_TX_DCD |
                                      SERIAL_TX_DSR |
                                      SERIAL_TX_CTS);


            if (!DoingTX && OldTXHolding && !Extension->TXHolding) {

                if (!Extension->TXHolding &&
                    (Extension->TransmitImmediate ||
                     Extension->WriteLength) &&
                     Extension->HoldingEmpty) {

                    DISABLE_ALL_INTERRUPTS(Extension->Controller);
                    ENABLE_ALL_INTERRUPTS(Extension->Controller);

                }

            }

        }

    }

    return ((ULONG)ModemStatus);
}

BOOLEAN
SerialPerhapsLowerRTS(
    IN PVOID Context
    )

/*++

Routine Description:

    This routine checks that the software reasons for lowering
    the RTS lines are present.  If so, it will then cause the
    line status register to be read (and any needed processing
    implied by the status register to be done), and if the
    shift register is empty it will lower the line.  If the
    shift register isn't empty, this routine will queue off
    a dpc that will start a timer, that will basically call
    us back to try again.

    NOTE: This routine assumes that it is called at interrupt
          level.

Arguments:

    Context - Really a pointer to the device extension.

Return Value:

    Always FALSE.

--*/

{

    PSERIAL_DEVICE_EXTENSION Extension = Context;


    //
    // We first need to test if we are actually still doing
    // transmit toggle flow control.  If we aren't then
    // we have no reason to try be here.
    //

    if ((Extension->HandFlow.FlowReplace & SERIAL_RTS_MASK) ==
        SERIAL_TRANSMIT_TOGGLE) {

        //
        // The order of the tests is very important below.
        //
        // If there is a break then we should leave on the RTS,
        // because when the break is turned off, it will submit
        // the code to shut down the RTS.
        //
        // If there are writes pending that aren't being held
        // up, then leave on the RTS, because the end of the write
        // code will cause this code to be reinvoked.  If the writes
        // are being held up, its ok to lower the RTS because the
        // upon trying to write the first character after transmission
        // is restarted, we will raise the RTS line.
        //

        if ((Extension->TXHolding & SERIAL_TX_BREAK) ||
            (Extension->CurrentWriteIrp || Extension->TransmitImmediate ||
             (!IsListEmpty(&Extension->WriteQueue)) &&
             (!Extension->TXHolding))) {

            NOTHING;

        } else {

            //
            // Looks good so far.  Call the line status check and processing
            // code, it will return the "current" line status value.  If
            // the holding and shift register are clear, lower the RTS line,
            // if they aren't clear, queue of a dpc that will cause a timer
            // to reinvoke us later.  We do this code here because no one
            // but this routine cares about the characters in the hardware,
            // so no routine by this routine will bother invoking to test
            // if the hardware is empty.
            //

            if ((SerialProcessLSR(Extension) &
                 (SERIAL_LSR_THRE | SERIAL_LSR_TEMT)) !=
                 (SERIAL_LSR_THRE | SERIAL_LSR_TEMT)) {

                //
                // Well it's not empty, try again later.
                //

                SerialInsertQueueDpc(
                    &Extension->StartTimerLowerRTSDpc,
                    NULL,
                    NULL,
                    Extension
                    )?Extension->CountOfTryingToLowerRTS++:0;


            } else {

                //
                // Nothing in the hardware, Lower the RTS.
                //

                SerialClrRTS(Extension);


            }

        }

    }

    //
    // We decement the counter to indicate that we've reached
    // the end of the execution path that is trying to push
    // down the RTS line.
    //

    Extension->CountOfTryingToLowerRTS--;

    return FALSE;
}

VOID
SerialStartTimerLowerRTS(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemContext1,
    IN PVOID SystemContext2
    )

/*++

Routine Description:

    This routine starts a timer that when it expires will start
    a dpc that will check if it can lower the rts line because
    there are no characters in the hardware.

Arguments:

    Dpc - Not Used.

    DeferredContext - Really points to the device extension.

    SystemContext1 - Not Used.

    SystemContext2 - Not Used.

Return Value:

    None.

--*/

{

    PSERIAL_DEVICE_EXTENSION Extension = DeferredContext;
    LARGE_INTEGER CharTime;
    KIRQL OldIrql;

    UNREFERENCED_PARAMETER(Dpc);
    UNREFERENCED_PARAMETER(SystemContext1);
    UNREFERENCED_PARAMETER(SystemContext2);


    SerialDump(SERTRACECALLS, ("SERIAL: SerialStartTimerLowerRTS\n"));


    //
    // Take out the lock to prevent the line control
    // from changing out from under us while we calculate
    // a character time.
    //

    KeAcquireSpinLock(
        &Extension->ControlLock,
        &OldIrql
        );

    CharTime = SerialGetCharTime(Extension);

    KeReleaseSpinLock(
        &Extension->ControlLock,
        OldIrql
        );

    CharTime.QuadPart = -CharTime.QuadPart;

    if (SerialSetTimer(
            &Extension->LowerRTSTimer,
            CharTime,
            &Extension->PerhapsLowerRTSDpc,
            Extension
            )) {

        //
        // The timer was already in the timer queue.  This implies
        // that one path of execution that was trying to lower
        // the RTS has "died".  Synchronize with the ISR so that
        // we can lower the count.
        //

        KeSynchronizeExecution(
            Extension->Interrupt,
            SerialDecrementRTSCounter,
            Extension
            );

    }

    SerialDpcEpilogue(Extension, Dpc);

}

VOID
SerialInvokePerhapsLowerRTS(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemContext1,
    IN PVOID SystemContext2
    )

/*++

Routine Description:

    This dpc routine exists solely to call the code that
    tests if the rts line should be lowered when TRANSMIT
    TOGGLE flow control is being used.

Arguments:

    Dpc - Not Used.

    DeferredContext - Really points to the device extension.

    SystemContext1 - Not Used.

    SystemContext2 - Not Used.

Return Value:

    None.

--*/

{

    PSERIAL_DEVICE_EXTENSION Extension = DeferredContext;

    UNREFERENCED_PARAMETER(Dpc);
    UNREFERENCED_PARAMETER(SystemContext1);
    UNREFERENCED_PARAMETER(SystemContext2);

    KeSynchronizeExecution(
        Extension->Interrupt,
        SerialPerhapsLowerRTS,
        Extension
        );

    SerialDpcEpilogue(Extension, Dpc);
}

BOOLEAN
SerialDecrementRTSCounter(
    IN PVOID Context
    )

/*++

Routine Description:

    This routine checks that the software reasons for lowering
    the RTS lines are present.  If so, it will then cause the
    line status register to be read (and any needed processing
    implied by the status register to be done), and if the
    shift register is empty it will lower the line.  If the
    shift register isn't empty, this routine will queue off
    a dpc that will start a timer, that will basically call
    us back to try again.

    NOTE: This routine assumes that it is called at interrupt
          level.

Arguments:

    Context - Really a pointer to the device extension.

Return Value:

    Always FALSE.

--*/

{

    PSERIAL_DEVICE_EXTENSION Extension = Context;

    Extension->CountOfTryingToLowerRTS--;

    return FALSE;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\ser101\isr.c ===
/*++

Copyright (c) 1991, 1992, 1993 - 1997 Microsoft Corporation

Module Name:

    isr.c

Abstract:

    This module contains the interrupt service routine for the
    serial driver.

Author:

    Anthony V. Ercolano 26-Sep-1991

Environment:

    Kernel mode

--*/

#include "precomp.h"


#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGESER,SerialPutChar)
#pragma alloc_text(PAGESER,SerialProcessLSR)
#endif


BOOLEAN
SerialCIsrSw(IN PKINTERRUPT InterruptObject, IN PVOID Context)
/*++

Routine Description:

    All Serial interrupts get vectored through here and switched.
    This is necessary so that previously single port serial boards
    can be switched to multiport without having to disconnect
    the interrupt object etc.

Arguments:

    InterruptObject - Points to the interrupt object declared for this
    device.  We merely pass this parameter along.

    Context - Actually a PSERIAL_CISR_SW; a switch structure for
    serial ISR's that contains the real function and context to use.

Return Value:

    This function will return TRUE if a serial port using this
    interrupt was the source of this interrupt, FALSE otherwise.

--*/
{
   PSERIAL_CISR_SW csw = (PSERIAL_CISR_SW)Context;

   return (*(csw->IsrFunc))(InterruptObject, csw->Context);
}



BOOLEAN
SerialSharerIsr(
    IN PKINTERRUPT InterruptObject,
    IN PVOID Context
    )

/*++

Routine Description:

    This is the isr that the system will call if there are any
    serial devices sharing the same interrupt and they aren't
    all confined to one multiport card.  This routine traverses
    a linked list structure that contains a pointer to a more
    refined isr and context that will indicate whether one of
    the ports on this interrupt actually was interrupting.

Arguments:

    InterruptObject - Points to the interrupt object declared for this
    device.  We *do not* use this parameter.

    Context - Pointer to a linked list of contextes and isrs.
    device.

Return Value:

    This function will return TRUE if a serial port using this
    interrupt was the source of this interrupt, FALSE otherwise.

--*/

{

    BOOLEAN servicedAnInterrupt = FALSE;
    BOOLEAN thisPassServiced;
    PLIST_ENTRY interruptEntry = ((PLIST_ENTRY)Context)->Flink;
    PLIST_ENTRY firstInterruptEntry = Context;

    if (IsListEmpty(firstInterruptEntry)) {
       return FALSE;
    }

    do {

        thisPassServiced = FALSE;
        do {

            PSERIAL_DEVICE_EXTENSION extension = CONTAINING_RECORD(
                                                     interruptEntry,
                                                     SERIAL_DEVICE_EXTENSION,
                                                     TopLevelSharers
                                                     );

            thisPassServiced |= extension->TopLevelOurIsr(
                                    InterruptObject,
                                    extension->TopLevelOurIsrContext
                                    );

            servicedAnInterrupt |= thisPassServiced;
            interruptEntry = interruptEntry->Flink;

        } while (interruptEntry != firstInterruptEntry);

    } while (thisPassServiced);

    return servicedAnInterrupt;

}

BOOLEAN
SerialIndexedMultiportIsr(
    IN PKINTERRUPT InterruptObject,
    IN PVOID Context
    )

/*++

Routine Description:

    This routine is used to figure out if a port on a multiport
    card is the source of an interrupt.  If so, this routine
    uses a dispatch structure to actually call the normal isr
    to process the interrupt.

    NOTE: This routine is peculiar to Digiboard interrupt status registers.

Arguments:

    InterruptObject - Points to the interrupt object declared for this
    device.  We *do not* use this parameter.

    Context - Points to a dispatch structure that contains the
    device extension of each port on this multiport card.

Return Value:


    This function will return TRUE if a serial port using this
    interrupt was the source of this interrupt, FALSE otherwise.

--*/

{

    BOOLEAN servicedAnInterrupt = FALSE;
    BOOLEAN thisStatusReadServiced;
    PSERIAL_MULTIPORT_DISPATCH dispatch = Context;
    ULONG whichPort;
    UCHAR statusRegister;

    do {

        thisStatusReadServiced = FALSE;
        statusRegister = READ_PORT_UCHAR(
                             dispatch->InterruptStatus
                             );

        whichPort = statusRegister & 0x07;

        //
        // We test against 0xff, which signals that no port
        // is interruping. The reason 0xff (rather than 0)
        // is that that would indicate the 0th (first) port
        // or the 0th daisy chained card.
        //

        if (statusRegister != 0xff) {

            if (dispatch->Extensions[whichPort]) {

                thisStatusReadServiced = SerialISR(
                                             InterruptObject,
                                              dispatch->Extensions[whichPort]
                                              );

                servicedAnInterrupt |= thisStatusReadServiced;

            }

        }

    } while (thisStatusReadServiced);

    return servicedAnInterrupt;

}

BOOLEAN
SerialBitMappedMultiportIsr(
    IN PKINTERRUPT InterruptObject,
    IN PVOID Context
    )

/*++

Routine Description:

    This routine is used to figure out if a port on a multiport
    card is the source of an interrupt.  If so, this routine
    uses a dispatch structure to actually call the normal isr
    to process the interrupt.

    NOTE: This routine is peculiar to status registers that use
    a bitmask to denote the interrupting port.

Arguments:

    InterruptObject - Points to the interrupt object declared for this
    device.  We *do not* use this parameter.

    Context - Points to a dispatch structure that contains the
    device extension of each port on this multiport card.

Return Value:


    This function will return TRUE if a serial port using this
    interrupt was the source of this interrupt, FALSE otherwise.

--*/

{

    BOOLEAN servicedAnInterrupt = FALSE;
    PSERIAL_MULTIPORT_DISPATCH dispatch = Context;
    ULONG whichPort;
    UCHAR statusRegister;

    do {

        statusRegister = READ_PORT_UCHAR(
                             dispatch->InterruptStatus
                             );
        if (dispatch->MaskInverted) {
            statusRegister = ~statusRegister;
        }
        statusRegister &= dispatch->UsablePortMask;

        if (statusRegister) {

            if (statusRegister & 0x0f) {

                if (statusRegister & 0x03) {

                    if (statusRegister & 1) {

                        whichPort = 0;

                    } else {

                        whichPort = 1;

                    }

                } else {

                    if (statusRegister & 0x04) {

                        whichPort = 2;

                    } else {

                        whichPort = 3;

                    }

                }

            } else {

                if (statusRegister & 0x30) {

                    if (statusRegister & 0x10) {

                        whichPort = 4;

                    } else {

                        whichPort = 5;

                    }

                } else {

                    if (statusRegister & 0x40) {

                        whichPort = 6;

                    } else {

                        whichPort = 7;

                    }

                }

            }

            if (dispatch->Extensions[whichPort]) {

                if (SerialISR(
                        InterruptObject,
                        dispatch->Extensions[whichPort]
                        )) {

                    servicedAnInterrupt = TRUE;

                }

            }

        }

    } while (statusRegister);

    return servicedAnInterrupt;

}

BOOLEAN
SerialISR(
    IN PKINTERRUPT InterruptObject,
    IN PVOID Context
    )

/*++

Routine Description:

    This is the interrupt service routine for the serial port driver.
    It will determine whether the serial port is the source of this
    interrupt.  If it is, then this routine will do the minimum of
    processing to quiet the interrupt.  It will store any information
    necessary for later processing.

Arguments:

    InterruptObject - Points to the interrupt object declared for this
    device.  We *do not* use this parameter.

    Context - This is really a pointer to the device extension for this
    device.

Return Value:

    This function will return TRUE if the serial port is the source
    of this interrupt, FALSE otherwise.

--*/

{

    //
    // Holds the information specific to handling this device.
    //
    PSERIAL_DEVICE_EXTENSION Extension = Context;

    //
    // Holds the contents of the interrupt identification record.
    // A low bit of zero in this register indicates that there is
    // an interrupt pending on this device.
    //
    UCHAR InterruptIdReg;

    //
    // Will hold whether we've serviced any interrupt causes in this
    // routine.
    //
    BOOLEAN ServicedAnInterrupt;

    UCHAR tempLSR;

    UNREFERENCED_PARAMETER(InterruptObject);

    //
    // Make sure we have an interrupt pending.  If we do then
    // we need to make sure that the device is open.  If the
    // device isn't open or powered down then quiet the device.  Note that
    // if the device isn't opened when we enter this routine
    // it can't open while we're in it.
    //

    InterruptIdReg = READ_INTERRUPT_ID_REG(Extension->Controller);

    //
    // Apply lock so if close happens concurrently we don't miss the DPC
    // queueing
    //

    InterlockedIncrement(&Extension->DpcCount);

    if ((InterruptIdReg & SERIAL_IIR_NO_INTERRUPT_PENDING)) {

        ServicedAnInterrupt = FALSE;

    } else if (!Extension->DeviceIsOpened
               || (Extension->PowerState != PowerDeviceD0)) {
       

        //
        // We got an interrupt with the device being closed or when the
        // device is supposed to be powered down.  This
        // is not unlikely with a serial device.  We just quietly
        // keep servicing the causes until it calms down.
        //

        ServicedAnInterrupt = TRUE;
        do {

            InterruptIdReg &= (~SERIAL_IIR_FIFOS_ENABLED);
            switch (InterruptIdReg) {

                case SERIAL_IIR_RLS: {

                    READ_LINE_STATUS(Extension->Controller);
                    break;

                }

                case SERIAL_IIR_RDA:
                case SERIAL_IIR_CTI: {


                    READ_RECEIVE_BUFFER(Extension->Controller);
                    break;

                }

                case SERIAL_IIR_THR: {

                    //
                    // Alread clear from reading the iir.
                    //
                    // We want to keep close track of whether
                    // the holding register is empty.
                    //

                    Extension->HoldingEmpty = TRUE;
                    break;

                }

                case SERIAL_IIR_MS: {

                    READ_MODEM_STATUS(Extension->Controller);
                    break;

                }

                default: {

                    ASSERT(FALSE);
                    break;

                }

            }

        } while (!((InterruptIdReg =
                    READ_INTERRUPT_ID_REG(Extension->Controller))
                    & SERIAL_IIR_NO_INTERRUPT_PENDING));
    } else {

        ServicedAnInterrupt = TRUE;
        do {

            //
            // We only care about bits that can denote an interrupt.
            //

            InterruptIdReg &= SERIAL_IIR_RLS | SERIAL_IIR_RDA |
                              SERIAL_IIR_CTI | SERIAL_IIR_THR |
                              SERIAL_IIR_MS;

            //
            // We have an interrupt.  We look for interrupt causes
            // in priority order.  The presence of a higher interrupt
            // will mask out causes of a lower priority.  When we service
            // and quiet a higher priority interrupt we then need to check
            // the interrupt causes to see if a new interrupt cause is
            // present.
            //

            switch (InterruptIdReg) {

                case SERIAL_IIR_RLS: {

                    SerialProcessLSR(Extension);

                    break;

                }

                case SERIAL_IIR_RDA:
                case SERIAL_IIR_CTI:

                {

                    //
                    // Reading the receive buffer will quiet this interrupt.
                    //
                    // It may also reveal a new interrupt cause.
                    //
                    UCHAR ReceivedChar;

                    do {

                        ReceivedChar =
                            READ_RECEIVE_BUFFER(Extension->Controller);
                        Extension->PerfStats.ReceivedCount++;
                        Extension->WmiPerfData.ReceivedCount++;

                        ReceivedChar &= Extension->ValidDataMask;

                        if (!ReceivedChar &&
                            (Extension->HandFlow.FlowReplace &
                             SERIAL_NULL_STRIPPING)) {

                            //
                            // If what we got is a null character
                            // and we're doing null stripping, then
                            // we simply act as if we didn't see it.
                            //

                            goto ReceiveDoLineStatus;

                        }

                        if ((Extension->HandFlow.FlowReplace &
                             SERIAL_AUTO_TRANSMIT) &&
                            ((ReceivedChar ==
                              Extension->SpecialChars.XonChar) ||
                             (ReceivedChar ==
                              Extension->SpecialChars.XoffChar))) {

                            //
                            // No matter what happens this character
                            // will never get seen by the app.
                            //

                            if (ReceivedChar ==
                                Extension->SpecialChars.XoffChar) {

                                Extension->TXHolding |= SERIAL_TX_XOFF;

                                if ((Extension->HandFlow.FlowReplace &
                                     SERIAL_RTS_MASK) ==
                                     SERIAL_TRANSMIT_TOGGLE) {

                                    SerialInsertQueueDpc(
                                        &Extension->StartTimerLowerRTSDpc,
                                        NULL,
                                        NULL,
                                        Extension
                                        )?Extension->CountOfTryingToLowerRTS++:0;

                                }


                            } else {

                                if (Extension->TXHolding & SERIAL_TX_XOFF) {

                                    //
                                    // We got the xon char **AND*** we
                                    // were being held up on transmission
                                    // by xoff.  Clear that we are holding
                                    // due to xoff.  Transmission will
                                    // automatically restart because of
                                    // the code outside the main loop that
                                    // catches problems chips like the
                                    // SMC and the Winbond.
                                    //

                                    Extension->TXHolding &= ~SERIAL_TX_XOFF;

                                }

                            }

                            goto ReceiveDoLineStatus;

                        }

                        //
                        // Check to see if we should note
                        // the receive character or special
                        // character event.
                        //

                        if (Extension->IsrWaitMask) {

                            if (Extension->IsrWaitMask &
                                SERIAL_EV_RXCHAR) {

                                Extension->HistoryMask |= SERIAL_EV_RXCHAR;

                            }

                            if ((Extension->IsrWaitMask &
                                 SERIAL_EV_RXFLAG) &&
                                (Extension->SpecialChars.EventChar ==
                                 ReceivedChar)) {

                                Extension->HistoryMask |= SERIAL_EV_RXFLAG;

                            }

                            if (Extension->IrpMaskLocation &&
                                Extension->HistoryMask) {

                                *Extension->IrpMaskLocation =
                                 Extension->HistoryMask;
                                Extension->IrpMaskLocation = NULL;
                                Extension->HistoryMask = 0;

                                Extension->CurrentWaitIrp->
                                    IoStatus.Information = sizeof(ULONG);
                                SerialInsertQueueDpc(
                                    &Extension->CommWaitDpc,
                                    NULL,
                                    NULL,
                                    Extension
                                    );

                            }

                        }

                        SerialPutChar(
                            Extension,
                            ReceivedChar
                            );

                        //
                        // If we're doing line status and modem
                        // status insertion then we need to insert
                        // a zero following the character we just
                        // placed into the buffer to mark that this
                        // was reception of what we are using to
                        // escape.
                        //

                        if (Extension->EscapeChar &&
                            (Extension->EscapeChar ==
                             ReceivedChar)) {

                            SerialPutChar(
                                Extension,
                                SERIAL_LSRMST_ESCAPE
                                );

                        }


ReceiveDoLineStatus:    ;

                        if (!((tempLSR = SerialProcessLSR(Extension)) &
                              SERIAL_LSR_DR)) {

                            //
                            // No more characters, get out of the
                            // loop.
                            //

                            break;

                        }

                        if ((tempLSR & ~(SERIAL_LSR_THRE | SERIAL_LSR_TEMT |
                                         SERIAL_LSR_DR)) &&
                            Extension->EscapeChar) {

                           //
                           // An error was indicated and inserted into the
                           // stream, get out of the loop.
                           //

                           break;
                        }

                    } while (TRUE);

                    break;

                }

                case SERIAL_IIR_THR: {

doTrasmitStuff:;
                    Extension->HoldingEmpty = TRUE;

                    if (Extension->WriteLength ||
                        Extension->TransmitImmediate ||
                        Extension->SendXoffChar ||
                        Extension->SendXonChar) {

                        //
                        // Even though all of the characters being
                        // sent haven't all been sent, this variable
                        // will be checked when the transmit queue is
                        // empty.  If it is still true and there is a
                        // wait on the transmit queue being empty then
                        // we know we finished transmitting all characters
                        // following the initiation of the wait since
                        // the code that initiates the wait will set
                        // this variable to false.
                        //
                        // One reason it could be false is that
                        // the writes were cancelled before they
                        // actually started, or that the writes
                        // failed due to timeouts.  This variable
                        // basically says a character was written
                        // by the isr at some point following the
                        // initiation of the wait.
                        //

                        Extension->EmptiedTransmit = TRUE;

                        //
                        // If we have output flow control based on
                        // the modem status lines, then we have to do
                        // all the modem work before we output each
                        // character. (Otherwise we might miss a
                        // status line change.)
                        //

                        if (Extension->HandFlow.ControlHandShake &
                            SERIAL_OUT_HANDSHAKEMASK) {

                            SerialHandleModemUpdate(
                                Extension,
                                TRUE
                                );

                        }

                        //
                        // We can only send the xon character if
                        // the only reason we are holding is because
                        // of the xoff.  (Hardware flow control or
                        // sending break preclude putting a new character
                        // on the wire.)
                        //

                        if (Extension->SendXonChar &&
                            !(Extension->TXHolding & ~SERIAL_TX_XOFF)) {

                            if ((Extension->HandFlow.FlowReplace &
                                 SERIAL_RTS_MASK) ==
                                 SERIAL_TRANSMIT_TOGGLE) {

                                //
                                // We have to raise if we're sending
                                // this character.
                                //

                                SerialSetRTS(Extension);

                                Extension->PerfStats.TransmittedCount++;
                                Extension->WmiPerfData.TransmittedCount++;
                                WRITE_TRANSMIT_HOLDING(
                                    Extension->Controller,
                                    Extension->SpecialChars.XonChar
                                    );

                                SerialInsertQueueDpc(
                                    &Extension->StartTimerLowerRTSDpc,
                                    NULL,
                                    NULL,
                                    Extension
                                    )?Extension->CountOfTryingToLowerRTS++:0;


                            } else {

                                Extension->PerfStats.TransmittedCount++;
                                Extension->WmiPerfData.TransmittedCount++;
                                WRITE_TRANSMIT_HOLDING(
                                    Extension->Controller,
                                    Extension->SpecialChars.XonChar
                                    );

                            }


                            Extension->SendXonChar = FALSE;
                            Extension->HoldingEmpty = FALSE;

                            //
                            // If we send an xon, by definition we
                            // can't be holding by Xoff.
                            //

                            Extension->TXHolding &= ~SERIAL_TX_XOFF;

                            //
                            // If we are sending an xon char then
                            // by definition we can't be "holding"
                            // up reception by Xoff.
                            //

                            Extension->RXHolding &= ~SERIAL_RX_XOFF;

                        } else if (Extension->SendXoffChar &&
                              !Extension->TXHolding) {

                            if ((Extension->HandFlow.FlowReplace &
                                 SERIAL_RTS_MASK) ==
                                 SERIAL_TRANSMIT_TOGGLE) {

                                //
                                // We have to raise if we're sending
                                // this character.
                                //

                                SerialSetRTS(Extension);

                                Extension->PerfStats.TransmittedCount++;
                                Extension->WmiPerfData.TransmittedCount++;
                                WRITE_TRANSMIT_HOLDING(
                                    Extension->Controller,
                                    Extension->SpecialChars.XoffChar
                                    );

                                SerialInsertQueueDpc(
                                    &Extension->StartTimerLowerRTSDpc,
                                    NULL,
                                    NULL,
                                    Extension
                                    )?Extension->CountOfTryingToLowerRTS++:0;

                            } else {

                                Extension->PerfStats.TransmittedCount++;
                                Extension->WmiPerfData.TransmittedCount++;
                                WRITE_TRANSMIT_HOLDING(
                                    Extension->Controller,
                                    Extension->SpecialChars.XoffChar
                                    );

                            }

                            //
                            // We can't be sending an Xoff character
                            // if the transmission is already held
                            // up because of Xoff.  Therefore, if we
                            // are holding then we can't send the char.
                            //

                            //
                            // If the application has set xoff continue
                            // mode then we don't actually stop sending
                            // characters if we send an xoff to the other
                            // side.
                            //

                            if (!(Extension->HandFlow.FlowReplace &
                                  SERIAL_XOFF_CONTINUE)) {

                                Extension->TXHolding |= SERIAL_TX_XOFF;

                                if ((Extension->HandFlow.FlowReplace &
                                     SERIAL_RTS_MASK) ==
                                     SERIAL_TRANSMIT_TOGGLE) {

                                    SerialInsertQueueDpc(
                                        &Extension->StartTimerLowerRTSDpc,
                                        NULL,
                                        NULL,
                                        Extension
                                        )?Extension->CountOfTryingToLowerRTS++:0;

                                }

                            }

                            Extension->SendXoffChar = FALSE;
                            Extension->HoldingEmpty = FALSE;

                        //
                        // Even if transmission is being held
                        // up, we should still transmit an immediate
                        // character if all that is holding us
                        // up is xon/xoff (OS/2 rules).
                        //

                        } else if (Extension->TransmitImmediate &&
                            (!Extension->TXHolding ||
                             (Extension->TXHolding == SERIAL_TX_XOFF)
                            )) {

                            Extension->TransmitImmediate = FALSE;

                            if ((Extension->HandFlow.FlowReplace &
                                 SERIAL_RTS_MASK) ==
                                 SERIAL_TRANSMIT_TOGGLE) {

                                //
                                // We have to raise if we're sending
                                // this character.
                                //

                                SerialSetRTS(Extension);

                                Extension->PerfStats.TransmittedCount++;
                                Extension->WmiPerfData.TransmittedCount++;
                                WRITE_TRANSMIT_HOLDING(
                                    Extension->Controller,
                                    Extension->ImmediateChar
                                    );

                                SerialInsertQueueDpc(
                                    &Extension->StartTimerLowerRTSDpc,
                                    NULL,
                                    NULL,
                                    Extension
                                    )?Extension->CountOfTryingToLowerRTS++:0;

                            } else {

                                Extension->PerfStats.TransmittedCount++;
                                Extension->WmiPerfData.TransmittedCount++;
                                WRITE_TRANSMIT_HOLDING(
                                    Extension->Controller,
                                    Extension->ImmediateChar
                                    );

                            }

                            Extension->HoldingEmpty = FALSE;

                            SerialInsertQueueDpc(
                                &Extension->CompleteImmediateDpc,
                                NULL,
                                NULL,
                                Extension
                                );

                        } else if (!Extension->TXHolding) {

                            ULONG amountToWrite;

                            if (Extension->FifoPresent) {

                                amountToWrite = (Extension->TxFifoAmount <
                                                 Extension->WriteLength)?
                                                Extension->TxFifoAmount:
                                                Extension->WriteLength;

                            } else {

                                amountToWrite = 1;

                            }
                            if ((Extension->HandFlow.FlowReplace &
                                 SERIAL_RTS_MASK) ==
                                 SERIAL_TRANSMIT_TOGGLE) {

                                //
                                // We have to raise if we're sending
                                // this character.
                                //

                                SerialSetRTS(Extension);

                                if (amountToWrite == 1) {

                                    Extension->PerfStats.TransmittedCount++;
                                    Extension->WmiPerfData.TransmittedCount++;
                                    WRITE_TRANSMIT_HOLDING(
                                        Extension->Controller,
                                        *(Extension->WriteCurrentChar)
                                        );

                                } else {

                                    Extension->PerfStats.TransmittedCount +=
                                        amountToWrite;
                                    Extension->WmiPerfData.TransmittedCount +=
                                       amountToWrite;
                                    WRITE_TRANSMIT_FIFO_HOLDING(
                                        Extension->Controller,
                                        Extension->WriteCurrentChar,
                                        amountToWrite
                                        );

                                }

                                SerialInsertQueueDpc(
                                    &Extension->StartTimerLowerRTSDpc,
                                    NULL,
                                    NULL,
                                    Extension
                                    )?Extension->CountOfTryingToLowerRTS++:0;

                            } else {

                                if (amountToWrite == 1) {

                                    Extension->PerfStats.TransmittedCount++;
                                    Extension->WmiPerfData.TransmittedCount++;
                                    WRITE_TRANSMIT_HOLDING(
                                        Extension->Controller,
                                        *(Extension->WriteCurrentChar)
                                        );

                                } else {

                                    Extension->PerfStats.TransmittedCount +=
                                        amountToWrite;
                                    Extension->WmiPerfData.TransmittedCount +=
                                        amountToWrite;
                                    WRITE_TRANSMIT_FIFO_HOLDING(
                                        Extension->Controller,
                                        Extension->WriteCurrentChar,
                                        amountToWrite
                                        );

                                }

                            }

                            Extension->HoldingEmpty = FALSE;
                            Extension->WriteCurrentChar += amountToWrite;
                            Extension->WriteLength -= amountToWrite;

                            if (!Extension->WriteLength) {

                                PIO_STACK_LOCATION IrpSp;
                                //
                                // No More characters left.  This
                                // write is complete.  Take care
                                // when updating the information field,
                                // we could have an xoff counter masquerading
                                // as a write irp.
                                //

                                IrpSp = IoGetCurrentIrpStackLocation(
                                            Extension->CurrentWriteIrp
                                            );

                                Extension->CurrentWriteIrp->
                                    IoStatus.Information =
                                    (IrpSp->MajorFunction == IRP_MJ_WRITE)?
                                        (IrpSp->Parameters.Write.Length):
                                        (1);

                                SerialInsertQueueDpc(
                                    &Extension->CompleteWriteDpc,
                                    NULL,
                                    NULL,
                                    Extension
                                    );

                            }

                        }

                    }

                    break;

                }

                case SERIAL_IIR_MS: {

                    SerialHandleModemUpdate(
                        Extension,
                        FALSE
                        );

                    break;

                }

            }

        } while (!((InterruptIdReg =
                    READ_INTERRUPT_ID_REG(Extension->Controller))
                    & SERIAL_IIR_NO_INTERRUPT_PENDING));

        //
        // Besides catching the WINBOND and SMC chip problems this
        // will also cause transmission to restart incase of an xon
        // char being received.  Don't remove.
        //

        if (SerialProcessLSR(Extension) & SERIAL_LSR_THRE) {

            if (!Extension->TXHolding &&
                (Extension->WriteLength ||
                 Extension->TransmitImmediate)) {

                goto doTrasmitStuff;

            }

        }

    }

    //
    // This will "unlock" the close and cause the event
    // to fire if we didn't queue any DPC's
    //

    {
       LONG pendingCnt;

       //
       // Increment once more.  This is just a quick test to see if we
       // have a chance of causing the event to fire... we don't want
       // to run a DPC on every ISR if we don't have to....
       //

retryDPCFiring:;

       InterlockedIncrement(&Extension->DpcCount);

       //
       // Decrement and see if the lock above looks like the only one left.
       //

       pendingCnt = InterlockedDecrement(&Extension->DpcCount);

       if (pendingCnt == 1) {
          KeInsertQueueDpc(&Extension->IsrUnlockPagesDpc, NULL, NULL);
       } else {
          if (InterlockedDecrement(&Extension->DpcCount) == 0) {
             //
             // We missed it.  Retry...
             //

             InterlockedIncrement(&Extension->DpcCount);
             goto retryDPCFiring;
          }
       }
    }

    return ServicedAnInterrupt;

}

VOID
SerialPutChar(
    IN PSERIAL_DEVICE_EXTENSION Extension,
    IN UCHAR CharToPut
    )

/*++

Routine Description:

    This routine, which only runs at device level, takes care of
    placing a character into the typeahead (receive) buffer.

Arguments:

    Extension - The serial device extension.

Return Value:

    None.

--*/

{
   SERIAL_LOCKED_PAGED_CODE();

    //
    // If we have dsr sensitivity enabled then
    // we need to check the modem status register
    // to see if it has changed.
    //

    if (Extension->HandFlow.ControlHandShake &
        SERIAL_DSR_SENSITIVITY) {

        SerialHandleModemUpdate(
            Extension,
            FALSE
            );

        if (Extension->RXHolding & SERIAL_RX_DSR) {

            //
            // We simply act as if we haven't
            // seen the character if we have dsr
            // sensitivity and the dsr line is low.
            //

            return;

        }

    }

    //
    // If the xoff counter is non-zero then decrement it.
    // If the counter then goes to zero, complete that irp.
    //

    if (Extension->CountSinceXoff) {

        Extension->CountSinceXoff--;

        if (!Extension->CountSinceXoff) {

            Extension->CurrentXoffIrp->IoStatus.Status = STATUS_SUCCESS;
            Extension->CurrentXoffIrp->IoStatus.Information = 0;
            SerialInsertQueueDpc(
                &Extension->XoffCountCompleteDpc,
                NULL,
                NULL,
                Extension
                );

        }

    }

    //
    // Check to see if we are copying into the
    // users buffer or into the interrupt buffer.
    //
    // If we are copying into the user buffer
    // then we know there is always room for one more.
    // (We know this because if there wasn't room
    // then that read would have completed and we
    // would be using the interrupt buffer.)
    //
    // If we are copying into the interrupt buffer
    // then we will need to check if we have enough
    // room.
    //

    if (Extension->ReadBufferBase !=
        Extension->InterruptReadBuffer) {

        //
        // Increment the following value so
        // that the interval timer (if one exists
        // for this read) can know that a character
        // has been read.
        //

        Extension->ReadByIsr++;

        //
        // We are in the user buffer.  Place the
        // character into the buffer.  See if the
        // read is complete.
        //

        *Extension->CurrentCharSlot = CharToPut;

        if (Extension->CurrentCharSlot ==
            Extension->LastCharSlot) {

            //
            // We've filled up the users buffer.
            // Switch back to the interrupt buffer
            // and send off a DPC to Complete the read.
            //
            // It is inherent that when we were using
            // a user buffer that the interrupt buffer
            // was empty.
            //

            Extension->ReadBufferBase =
                Extension->InterruptReadBuffer;
            Extension->CurrentCharSlot =
                Extension->InterruptReadBuffer;
            Extension->FirstReadableChar =
                Extension->InterruptReadBuffer;
            Extension->LastCharSlot =
                Extension->InterruptReadBuffer +
                (Extension->BufferSize - 1);
            Extension->CharsInInterruptBuffer = 0;

            Extension->CurrentReadIrp->IoStatus.Information =
                IoGetCurrentIrpStackLocation(
                    Extension->CurrentReadIrp
                    )->Parameters.Read.Length;

            SerialInsertQueueDpc(
                &Extension->CompleteReadDpc,
                NULL,
                NULL,
                Extension
                );

        } else {

            //
            // Not done with the users read.
            //

            Extension->CurrentCharSlot++;

        }

    } else {

        //
        // We need to see if we reached our flow
        // control threshold.  If we have then
        // we turn on whatever flow control the
        // owner has specified.  If no flow
        // control was specified, well..., we keep
        // trying to receive characters and hope that
        // we have enough room.  Note that no matter
        // what flow control protocol we are using, it
        // will not prevent us from reading whatever
        // characters are available.
        //

        if ((Extension->HandFlow.ControlHandShake
             & SERIAL_DTR_MASK) ==
            SERIAL_DTR_HANDSHAKE) {

            //
            // If we are already doing a
            // dtr hold then we don't have
            // to do anything else.
            //

            if (!(Extension->RXHolding &
                  SERIAL_RX_DTR)) {

                if ((Extension->BufferSize -
                     Extension->HandFlow.XoffLimit)
                    <= (Extension->CharsInInterruptBuffer+1)) {

                    Extension->RXHolding |= SERIAL_RX_DTR;

                    SerialClrDTR(Extension);

                }

            }

        }

        if ((Extension->HandFlow.FlowReplace
             & SERIAL_RTS_MASK) ==
            SERIAL_RTS_HANDSHAKE) {

            //
            // If we are already doing a
            // rts hold then we don't have
            // to do anything else.
            //

            if (!(Extension->RXHolding &
                  SERIAL_RX_RTS)) {

                if ((Extension->BufferSize -
                     Extension->HandFlow.XoffLimit)
                    <= (Extension->CharsInInterruptBuffer+1)) {

                    Extension->RXHolding |= SERIAL_RX_RTS;

                    SerialClrRTS(Extension);

                }

            }

        }

        if (Extension->HandFlow.FlowReplace &
            SERIAL_AUTO_RECEIVE) {

            //
            // If we are already doing a
            // xoff hold then we don't have
            // to do anything else.
            //

            if (!(Extension->RXHolding &
                  SERIAL_RX_XOFF)) {

                if ((Extension->BufferSize -
                     Extension->HandFlow.XoffLimit)
                    <= (Extension->CharsInInterruptBuffer+1)) {

                    Extension->RXHolding |= SERIAL_RX_XOFF;

                    //
                    // If necessary cause an
                    // off to be sent.
                    //

                    SerialProdXonXoff(
                        Extension,
                        FALSE
                        );

                }

            }

        }

        if (Extension->CharsInInterruptBuffer <
            Extension->BufferSize) {

            *Extension->CurrentCharSlot = CharToPut;
            Extension->CharsInInterruptBuffer++;

            //
            // If we've become 80% full on this character
            // and this is an interesting event, note it.
            //

            if (Extension->CharsInInterruptBuffer ==
                Extension->BufferSizePt8) {

                if (Extension->IsrWaitMask &
                    SERIAL_EV_RX80FULL) {

                    Extension->HistoryMask |= SERIAL_EV_RX80FULL;

                    if (Extension->IrpMaskLocation) {

                        *Extension->IrpMaskLocation =
                         Extension->HistoryMask;
                        Extension->IrpMaskLocation = NULL;
                        Extension->HistoryMask = 0;

                        Extension->CurrentWaitIrp->
                            IoStatus.Information = sizeof(ULONG);
                        SerialInsertQueueDpc(
                            &Extension->CommWaitDpc,
                            NULL,
                            NULL,
                            Extension
                            );

                    }

                }

            }

            //
            // Point to the next available space
            // for a received character.  Make sure
            // that we wrap around to the beginning
            // of the buffer if this last character
            // received was placed at the last slot
            // in the buffer.
            //

            if (Extension->CurrentCharSlot ==
                Extension->LastCharSlot) {

                Extension->CurrentCharSlot =
                    Extension->InterruptReadBuffer;

            } else {

                Extension->CurrentCharSlot++;

            }

        } else {

            //
            // We have a new character but no room for it.
            //

            Extension->PerfStats.BufferOverrunErrorCount++;
            Extension->WmiPerfData.BufferOverrunErrorCount++;
            Extension->ErrorWord |= SERIAL_ERROR_QUEUEOVERRUN;

            if (Extension->HandFlow.FlowReplace &
                SERIAL_ERROR_CHAR) {

                //
                // Place the error character into the last
                // valid place for a character.  Be careful!,
                // that place might not be the previous location!
                //

                if (Extension->CurrentCharSlot ==
                    Extension->InterruptReadBuffer) {

                    *(Extension->InterruptReadBuffer+
                      (Extension->BufferSize-1)) =
                      Extension->SpecialChars.ErrorChar;

                } else {

                    *(Extension->CurrentCharSlot-1) =
                     Extension->SpecialChars.ErrorChar;

                }

            }

            //
            // If the application has requested it, abort all reads
            // and writes on an error.
            //

            if (Extension->HandFlow.ControlHandShake &
                SERIAL_ERROR_ABORT) {

                SerialInsertQueueDpc(
                    &Extension->CommErrorDpc,
                    NULL,
                    NULL,
                    Extension
                    );

            }

        }

    }

}

UCHAR
SerialProcessLSR(
    IN PSERIAL_DEVICE_EXTENSION Extension
    )

/*++

Routine Description:

    This routine, which only runs at device level, reads the
    ISR and totally processes everything that might have
    changed.

Arguments:

    Extension - The serial device extension.

Return Value:

    The value of the line status register.

--*/

{

    UCHAR LineStatus = READ_LINE_STATUS(Extension->Controller);

    SERIAL_LOCKED_PAGED_CODE();
    Extension->HoldingEmpty = !!(LineStatus & SERIAL_LSR_THRE);

    //
    // If the line status register is just the fact that
    // the trasmit registers are empty or a character is
    // received then we want to reread the interrupt
    // identification register so that we just pick up that.
    //

    if (LineStatus & ~(SERIAL_LSR_THRE | SERIAL_LSR_TEMT
                       | SERIAL_LSR_DR)) {

        //
        // We have some sort of data problem in the receive.
        // For any of these errors we may abort all current
        // reads and writes.
        //
        //
        // If we are inserting the value of the line status
        // into the data stream then we should put the escape
        // character in now.
        //

        if (Extension->EscapeChar) {

            SerialPutChar(
                Extension,
                Extension->EscapeChar
                );

            SerialPutChar(
                Extension,
                (UCHAR)((LineStatus & SERIAL_LSR_DR)?
                    (SERIAL_LSRMST_LSR_DATA):(SERIAL_LSRMST_LSR_NODATA))
                );

            SerialPutChar(
                Extension,
                LineStatus
                );

            if (LineStatus & SERIAL_LSR_DR) {

                Extension->PerfStats.ReceivedCount++;
                Extension->WmiPerfData.ReceivedCount++;
                SerialPutChar(
                    Extension,
                    READ_RECEIVE_BUFFER(Extension->Controller)
                    );

            }

        }

        if (LineStatus & SERIAL_LSR_OE) {

            Extension->PerfStats.SerialOverrunErrorCount++;
            Extension->WmiPerfData.SerialOverrunErrorCount++;
            Extension->ErrorWord |= SERIAL_ERROR_OVERRUN;

            if (Extension->HandFlow.FlowReplace &
                SERIAL_ERROR_CHAR) {

                SerialPutChar(
                    Extension,
                    Extension->SpecialChars.ErrorChar
                    );

                if (LineStatus & SERIAL_LSR_DR) {

                    Extension->PerfStats.ReceivedCount++;
                    Extension->WmiPerfData.ReceivedCount++;
                    READ_RECEIVE_BUFFER(Extension->Controller);

                }

            } else {

                if (LineStatus & SERIAL_LSR_DR) {

                    Extension->PerfStats.ReceivedCount++;
                    Extension->WmiPerfData.ReceivedCount++;
                    SerialPutChar(
                        Extension,
                        READ_RECEIVE_BUFFER(
                            Extension->Controller
                            )
                        );

                }

            }

        }

        if (LineStatus & SERIAL_LSR_BI) {

            Extension->ErrorWord |= SERIAL_ERROR_BREAK;

            if (Extension->HandFlow.FlowReplace &
                SERIAL_BREAK_CHAR) {

                SerialPutChar(
                    Extension,
                    Extension->SpecialChars.BreakChar
                    );

            }

        } else {

            //
            // Framing errors only count if they
            // occur exclusive of a break being
            // received.
            //

            if (LineStatus & SERIAL_LSR_PE) {

                Extension->PerfStats.ParityErrorCount++;
                Extension->WmiPerfData.ParityErrorCount++;
                Extension->ErrorWord |= SERIAL_ERROR_PARITY;

                if (Extension->HandFlow.FlowReplace &
                    SERIAL_ERROR_CHAR) {

                    SerialPutChar(
                        Extension,
                        Extension->SpecialChars.ErrorChar
                        );

                    if (LineStatus & SERIAL_LSR_DR) {

                        Extension->PerfStats.ReceivedCount++;
                        Extension->WmiPerfData.ReceivedCount++;
                        READ_RECEIVE_BUFFER(Extension->Controller);

                    }

                }

            }

            if (LineStatus & SERIAL_LSR_FE) {

                Extension->PerfStats.FrameErrorCount++;
                Extension->WmiPerfData.FrameErrorCount++;
                Extension->ErrorWord |= SERIAL_ERROR_FRAMING;

                if (Extension->HandFlow.FlowReplace &
                    SERIAL_ERROR_CHAR) {

                    SerialPutChar(
                        Extension,
                        Extension->SpecialChars.ErrorChar
                        );
                    if (LineStatus & SERIAL_LSR_DR) {

                        Extension->PerfStats.ReceivedCount++;
                        Extension->WmiPerfData.ReceivedCount++;
                        READ_RECEIVE_BUFFER(Extension->Controller);

                    }

                }

            }

        }

        //
        // If the application has requested it,
        // abort all the reads and writes
        // on an error.
        //

        if (Extension->HandFlow.ControlHandShake &
            SERIAL_ERROR_ABORT) {

            SerialInsertQueueDpc(
                &Extension->CommErrorDpc,
                NULL,
                NULL,
                Extension
                );

        }

        //
        // Check to see if we have a wait
        // pending on the comm error events.  If we
        // do then we schedule a dpc to satisfy
        // that wait.
        //

        if (Extension->IsrWaitMask) {

            if ((Extension->IsrWaitMask & SERIAL_EV_ERR) &&
                (LineStatus & (SERIAL_LSR_OE |
                               SERIAL_LSR_PE |
                               SERIAL_LSR_FE))) {

                Extension->HistoryMask |= SERIAL_EV_ERR;

            }

            if ((Extension->IsrWaitMask & SERIAL_EV_BREAK) &&
                (LineStatus & SERIAL_LSR_BI)) {

                Extension->HistoryMask |= SERIAL_EV_BREAK;

            }

            if (Extension->IrpMaskLocation &&
                Extension->HistoryMask) {

                *Extension->IrpMaskLocation =
                 Extension->HistoryMask;
                Extension->IrpMaskLocation = NULL;
                Extension->HistoryMask = 0;

                Extension->CurrentWaitIrp->IoStatus.Information =
                    sizeof(ULONG);
                SerialInsertQueueDpc(
                    &Extension->CommWaitDpc,
                    NULL,
                    NULL,
                    Extension
                    );

            }

        }

        if (LineStatus & SERIAL_LSR_THRE) {

            //
            // There is a hardware bug in some versions
            // of the 16450 and 550.  If THRE interrupt
            // is pending, but a higher interrupt comes
            // in it will only return the higher and
            // *forget* about the THRE.
            //
            // A suitable workaround - whenever we
            // are *all* done reading line status
            // of the device we check to see if the
            // transmit holding register is empty.  If it is
            // AND we are currently transmitting data
            // enable the interrupts which should cause
            // an interrupt indication which we quiet
            // when we read the interrupt id register.
            //

            if (Extension->WriteLength |
                Extension->TransmitImmediate) {

                DISABLE_ALL_INTERRUPTS(
                    Extension->Controller
                    );
                ENABLE_ALL_INTERRUPTS(
                    Extension->Controller
                    );

            }

        }

    }

    return LineStatus;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\ser101\ioctl.c ===
/*++

Copyright (c) 1991, 1992, 1993 Microsoft Corporation

Module Name:

    ioctl.c

Abstract:

    This module contains the ioctl dispatcher as well as a couple
    of routines that are generally just called in response to
    ioctl calls.

Author:

    Anthony V. Ercolano 26-Sep-1991

Environment:

    Kernel mode

--*/

#include "precomp.h"

BOOLEAN
SerialGetModemUpdate(
    IN PVOID Context
    );

BOOLEAN
SerialGetCommStatus(
    IN PVOID Context
    );

VOID
SerialGetProperties(
    IN PSERIAL_DEVICE_EXTENSION Extension,
    IN PSERIAL_COMMPROP Properties
    );

BOOLEAN
SerialSetEscapeChar(
    IN PVOID Context
    );

#ifdef ALLOC_PRAGMA
//
// Locked during PnP operations and while open
//

#pragma alloc_text(PAGESER,SerialSetBaud)
#pragma alloc_text(PAGESER,SerialSetLineControl)
#pragma alloc_text(PAGESER,SerialIoControl)
#pragma alloc_text(PAGESER,SerialSetChars)
#pragma alloc_text(PAGESER,SerialGetModemUpdate)
#pragma alloc_text(PAGESER,SerialGetCommStatus)
#pragma alloc_text(PAGESER,SerialGetProperties)
#pragma alloc_text(PAGESER,SerialSetEscapeChar)
#pragma alloc_text(PAGESER,SerialGetStats)
#pragma alloc_text(PAGESER,SerialClearStats)
#pragma alloc_text(PAGESER, SerialSetMCRContents)
#pragma alloc_text(PAGESER, SerialGetMCRContents)
#pragma alloc_text(PAGESER, SerialSetFCRContents)
#pragma alloc_text(PAGESER, SerialInternalIoControl)
#endif


BOOLEAN
SerialGetStats(
    IN PVOID Context
    )

/*++

Routine Description:

    In sync with the interrpt service routine (which sets the perf stats)
    return the perf stats to the caller.


Arguments:

    Context - Pointer to a the irp.

Return Value:

    This routine always returns FALSE.

--*/

{

    PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation((PIRP)Context);
    PSERIAL_DEVICE_EXTENSION extension = irpSp->DeviceObject->DeviceExtension;
    PSERIALPERF_STATS sp = ((PIRP)Context)->AssociatedIrp.SystemBuffer;

    SERIAL_LOCKED_PAGED_CODE();

    *sp = extension->PerfStats;
    return FALSE;

}

BOOLEAN
SerialClearStats(
    IN PVOID Context
    )

/*++

Routine Description:

    In sync with the interrpt service routine (which sets the perf stats)
    clear the perf stats.


Arguments:

    Context - Pointer to a the extension.

Return Value:

    This routine always returns FALSE.

--*/

{
   SERIAL_LOCKED_PAGED_CODE();

    RtlZeroMemory(
        &((PSERIAL_DEVICE_EXTENSION)Context)->PerfStats,
        sizeof(SERIALPERF_STATS)
        );

    RtlZeroMemory(&((PSERIAL_DEVICE_EXTENSION)Context)->WmiPerfData,
                 sizeof(SERIAL_WMI_PERF_DATA));
    return FALSE;

}


BOOLEAN
SerialSetChars(
    IN PVOID Context
    )

/*++

Routine Description:

    This routine is used to set the special characters for the
    driver.

Arguments:

    Context - Pointer to a structure that contains a pointer to
              the device extension and a pointer to a special characters
              structure.

Return Value:

    This routine always returns FALSE.

--*/

{

    ((PSERIAL_IOCTL_SYNC)Context)->Extension->SpecialChars =
        *((PSERIAL_CHARS)(((PSERIAL_IOCTL_SYNC)Context)->Data));

    SERIAL_LOCKED_PAGED_CODE();

    return FALSE;

}

BOOLEAN
SerialSetBaud(
    IN PVOID Context
    )

/*++

Routine Description:

    This routine is used to set the baud rate of the device.

Arguments:

    Context - Pointer to a structure that contains a pointer to
              the device extension and what should be the current
              baud rate.

Return Value:

    This routine always returns FALSE.

--*/

{

    PSERIAL_DEVICE_EXTENSION Extension = ((PSERIAL_IOCTL_SYNC)Context)->Extension;
    USHORT Appropriate = PtrToUshort(((PSERIAL_IOCTL_SYNC)Context)->Data);

    SERIAL_LOCKED_PAGED_CODE();


    WRITE_DIVISOR_LATCH(
        Extension->Controller,
        Appropriate
        );

    return FALSE;

}

BOOLEAN
SerialSetLineControl(
    IN PVOID Context
    )

/*++

Routine Description:

    This routine is used to set the buad rate of the device.

Arguments:

    Context - Pointer to the device extension.

Return Value:

    This routine always returns FALSE.

--*/

{

    PSERIAL_DEVICE_EXTENSION Extension = Context;

    SERIAL_LOCKED_PAGED_CODE();

    WRITE_LINE_CONTROL(
        Extension->Controller,
        Extension->LineControl
        );

    return FALSE;

}

BOOLEAN
SerialGetModemUpdate(
    IN PVOID Context
    )

/*++

Routine Description:

    This routine is simply used to call the interrupt level routine
    that handles modem status update.

Arguments:

    Context - Pointer to a structure that contains a pointer to
              the device extension and a pointer to a ulong.

Return Value:

    This routine always returns FALSE.

--*/

{

    PSERIAL_DEVICE_EXTENSION Extension = ((PSERIAL_IOCTL_SYNC)Context)->Extension;
    ULONG *Result = (ULONG *)(((PSERIAL_IOCTL_SYNC)Context)->Data);

    SERIAL_LOCKED_PAGED_CODE();


    *Result = SerialHandleModemUpdate(
                  Extension,
                  FALSE
                  );

    return FALSE;

}


BOOLEAN
SerialSetMCRContents(IN PVOID Context)
/*++

Routine Description:

    This routine is simply used to set the contents of the MCR

Arguments:

    Context - Pointer to a structure that contains a pointer to
              the device extension and a pointer to a ulong.

Return Value:

    This routine always returns FALSE.

--*/
{
   PSERIAL_DEVICE_EXTENSION Extension = ((PSERIAL_IOCTL_SYNC)Context)->Extension;
   ULONG *Result = (ULONG *)(((PSERIAL_IOCTL_SYNC)Context)->Data);

   SERIAL_LOCKED_PAGED_CODE();

   //
   // This is severe casting abuse!!!
   //

    WRITE_MODEM_CONTROL(Extension->Controller, (UCHAR)PtrToUlong(Result));
    return FALSE;
}



BOOLEAN
SerialGetMCRContents(IN PVOID Context)

/*++

Routine Description:

    This routine is simply used to get the contents of the MCR

Arguments:

    Context - Pointer to a structure that contains a pointer to
              the device extension and a pointer to a ulong.

Return Value:

    This routine always returns FALSE.

--*/

{

    PSERIAL_DEVICE_EXTENSION Extension = ((PSERIAL_IOCTL_SYNC)Context)->Extension;
    ULONG *Result = (ULONG *)(((PSERIAL_IOCTL_SYNC)Context)->Data);

    SERIAL_LOCKED_PAGED_CODE();

    *Result = READ_MODEM_CONTROL(Extension->Controller);
    return FALSE;

}



BOOLEAN
SerialSetFCRContents(IN PVOID Context)
/*++

Routine Description:

    This routine is simply used to set the contents of the FCR

Arguments:

    Context - Pointer to a structure that contains a pointer to
              the device extension and a pointer to a ulong.

Return Value:

    This routine always returns FALSE.

--*/
{
   PSERIAL_DEVICE_EXTENSION Extension = ((PSERIAL_IOCTL_SYNC)Context)->Extension;
   ULONG *Result = (ULONG *)(((PSERIAL_IOCTL_SYNC)Context)->Data);

   SERIAL_LOCKED_PAGED_CODE();

   //
   // This is severe casting abuse!!!
   //

    WRITE_FIFO_CONTROL(Extension->Controller, (UCHAR)PtrToUlong(Result));
    return FALSE;
}


BOOLEAN
SerialGetCommStatus(
    IN PVOID Context
    )

/*++

Routine Description:

    This is used to get the current state of the serial driver.

Arguments:

    Context - Pointer to a structure that contains a pointer to
              the device extension and a pointer to a serial status
              record.

Return Value:

    This routine always returns FALSE.

--*/

{

    PSERIAL_DEVICE_EXTENSION Extension = ((PSERIAL_IOCTL_SYNC)Context)->Extension;
    PSERIAL_STATUS Stat = ((PSERIAL_IOCTL_SYNC)Context)->Data;

    SERIAL_LOCKED_PAGED_CODE();


    Stat->Errors = Extension->ErrorWord;
    Extension->ErrorWord = 0;

    //
    // BUG BUG We need to do something about eof (binary mode).
    //
    Stat->EofReceived = FALSE;

    Stat->AmountInInQueue = Extension->CharsInInterruptBuffer;

    Stat->AmountInOutQueue = Extension->TotalCharsQueued;

    if (Extension->WriteLength) {

        //
        // By definition if we have a writelength the we have
        // a current write irp.
        //

        ASSERT(Extension->CurrentWriteIrp);
        ASSERT(Stat->AmountInOutQueue >= Extension->WriteLength);

        Stat->AmountInOutQueue -=
            IoGetCurrentIrpStackLocation(Extension->CurrentWriteIrp)
            ->Parameters.Write.Length - (Extension->WriteLength);

    }

    Stat->WaitForImmediate = Extension->TransmitImmediate;

    Stat->HoldReasons = 0;
    if (Extension->TXHolding) {

        if (Extension->TXHolding & SERIAL_TX_CTS) {

            Stat->HoldReasons |= SERIAL_TX_WAITING_FOR_CTS;

        }

        if (Extension->TXHolding & SERIAL_TX_DSR) {

            Stat->HoldReasons |= SERIAL_TX_WAITING_FOR_DSR;

        }

        if (Extension->TXHolding & SERIAL_TX_DCD) {

            Stat->HoldReasons |= SERIAL_TX_WAITING_FOR_DCD;

        }

        if (Extension->TXHolding & SERIAL_TX_XOFF) {

            Stat->HoldReasons |= SERIAL_TX_WAITING_FOR_XON;

        }

        if (Extension->TXHolding & SERIAL_TX_BREAK) {

            Stat->HoldReasons |= SERIAL_TX_WAITING_ON_BREAK;

        }

    }

    if (Extension->RXHolding & SERIAL_RX_DSR) {

        Stat->HoldReasons |= SERIAL_RX_WAITING_FOR_DSR;

    }

    if (Extension->RXHolding & SERIAL_RX_XOFF) {

        Stat->HoldReasons |= SERIAL_TX_WAITING_XOFF_SENT;

    }

    return FALSE;

}

BOOLEAN
SerialSetEscapeChar(
    IN PVOID Context
    )

/*++

Routine Description:

    This is used to set the character that will be used to escape
    line status and modem status information when the application
    has set up that line status and modem status should be passed
    back in the data stream.

Arguments:

    Context - Pointer to the irp that is specify the escape character.
              Implicitly - An escape character of 0 means no escaping
              will occur.

Return Value:

    This routine always returns FALSE.

--*/

{
   PSERIAL_DEVICE_EXTENSION extension =
      IoGetCurrentIrpStackLocation((PIRP)Context)
         ->DeviceObject->DeviceExtension;


    extension->EscapeChar =
        *(PUCHAR)((PIRP)Context)->AssociatedIrp.SystemBuffer;

   return FALSE;

}


NTSTATUS
SerialIoControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine provides the initial processing for all of the
    Ioctrls for the serial device.

Arguments:

    DeviceObject - Pointer to the device object for this device

    Irp - Pointer to the IRP for the current request

Return Value:

    The function value is the final status of the call

--*/

{
    //
    // The status that gets returned to the caller and
    // set in the Irp.
    //
    NTSTATUS Status;

    //
    // The current stack location.  This contains all of the
    // information we need to process this particular request.
    //
    PIO_STACK_LOCATION IrpSp;

    //
    // Just what it says.  This is the serial specific device
    // extension of the device object create for the serial driver.
    //
    PSERIAL_DEVICE_EXTENSION Extension = DeviceObject->DeviceExtension;

    //
    // A temporary to hold the old IRQL so that it can be
    // restored once we complete/validate this request.
    //
    KIRQL OldIrql;

    NTSTATUS prologueStatus;

    SERIAL_LOCKED_PAGED_CODE();

    //
    // We expect to be open so all our pages are locked down.  This is, after
    // all, an IO operation, so the device should be open first.
    //

    if (Extension->DeviceIsOpened != TRUE) {
       Irp->IoStatus.Status = STATUS_INVALID_DEVICE_REQUEST;
       IoCompleteRequest(Irp, IO_NO_INCREMENT);
       return STATUS_INVALID_DEVICE_REQUEST;
    }


    if ((prologueStatus = SerialIRPPrologue(Irp, Extension))
        != STATUS_SUCCESS) {
       Irp->IoStatus.Status = prologueStatus;
       SerialCompleteRequest(Extension, Irp, IO_NO_INCREMENT);
       return prologueStatus;
    }

    SerialDump(
        SERIRPPATH,
        ("SERIAL: Dispatch entry for: %x\n",Irp)
        );
    if (SerialCompleteIfError(
            DeviceObject,
            Irp
            ) != STATUS_SUCCESS) {

        return STATUS_CANCELLED;

    }
    IrpSp = IoGetCurrentIrpStackLocation(Irp);
    Irp->IoStatus.Information = 0L;
    Status = STATUS_SUCCESS;
    switch (IrpSp->Parameters.DeviceIoControl.IoControlCode) {

        case IOCTL_SERIAL_SET_BAUD_RATE : {

            ULONG BaudRate;
            //
            // Will hold the value of the appropriate divisor for
            // the requested baud rate.  If the baudrate is invalid
            // (because the device won't support that baud rate) then
            // this value is undefined.
            //
            // Note: in one sense the concept of a valid baud rate
            // is cloudy.  We could allow the user to request any
            // baud rate.  We could then calculate the divisor needed
            // for that baud rate.  As long as the divisor wasn't less
            // than one we would be "ok".  (The percentage difference
            // between the "true" divisor and the "rounded" value given
            // to the hardware might make it unusable, but... )  It would
            // really be up to the user to "Know" whether the baud rate
            // is suitable.  So much for theory, *We* only support a given
            // set of baud rates.
            //
            SHORT AppropriateDivisor;

            if (IrpSp->Parameters.DeviceIoControl.InputBufferLength <
                sizeof(SERIAL_BAUD_RATE)) {

                Status = STATUS_BUFFER_TOO_SMALL;
                break;

            } else {

                BaudRate = ((PSERIAL_BAUD_RATE)(Irp->AssociatedIrp.SystemBuffer))->BaudRate;

            }

            //
            // Get the baud rate from the irp.  We pass it
            // to a routine which will set the correct divisor.
            //

            Status = SerialGetDivisorFromBaud(
                         Extension->ClockRate,
                         BaudRate,
                         &AppropriateDivisor
                         );

            //
            // Make sure we are at power D0
            //

            if (NT_SUCCESS(Status)) {
               if (Extension->PowerState != PowerDeviceD0) {
                  Status = SerialGotoPowerState(Extension->Pdo, Extension,
                                                PowerDeviceD0);
                  if (!NT_SUCCESS(Status)) {
                     break;
                  }
               }
            }

            KeAcquireSpinLock(
                &Extension->ControlLock,
                &OldIrql
                );

            if (NT_SUCCESS(Status)) {

                SERIAL_IOCTL_SYNC S;


                Extension->CurrentBaud = BaudRate;
                Extension->WmiCommData.BaudRate = BaudRate;

                S.Extension = Extension;
                S.Data = (PVOID)AppropriateDivisor;
                KeSynchronizeExecution(
                    Extension->Interrupt,
                    SerialSetBaud,
                    &S
                    );

            }

            KeReleaseSpinLock(
                &Extension->ControlLock,
                OldIrql
                );

            break;
        }
        case IOCTL_SERIAL_GET_BAUD_RATE: {

            PSERIAL_BAUD_RATE Br = (PSERIAL_BAUD_RATE)Irp->AssociatedIrp.SystemBuffer;
            if (IrpSp->Parameters.DeviceIoControl.OutputBufferLength <
                sizeof(SERIAL_BAUD_RATE)) {

                Status = STATUS_BUFFER_TOO_SMALL;
                break;

            }

            KeAcquireSpinLock(
                &Extension->ControlLock,
                &OldIrql
                );

            Br->BaudRate = Extension->CurrentBaud;

            KeReleaseSpinLock(
                &Extension->ControlLock,
                OldIrql
                );

            Irp->IoStatus.Information = sizeof(SERIAL_BAUD_RATE);

            break;

        }

        case IOCTL_SERIAL_GET_MODEM_CONTROL: {
           SERIAL_IOCTL_SYNC S;

            if (IrpSp->Parameters.DeviceIoControl.OutputBufferLength <
                sizeof(ULONG)) {

                Status = STATUS_BUFFER_TOO_SMALL;
                break;

            }

            Irp->IoStatus.Information = sizeof(ULONG);

            S.Extension = Extension;
            S.Data = Irp->AssociatedIrp.SystemBuffer;

            KeAcquireSpinLock(
                &Extension->ControlLock,
                &OldIrql
                );

            KeSynchronizeExecution(
                Extension->Interrupt,
                SerialGetMCRContents,
                &S
                );

            KeReleaseSpinLock(
                &Extension->ControlLock,
                OldIrql
                );

            break;
        }
        case IOCTL_SERIAL_SET_MODEM_CONTROL: {
           SERIAL_IOCTL_SYNC S;

            if (IrpSp->Parameters.DeviceIoControl.InputBufferLength <
                sizeof(ULONG)) {

                Status = STATUS_BUFFER_TOO_SMALL;
                break;

            }

            S.Extension = Extension;
            S.Data = Irp->AssociatedIrp.SystemBuffer;

            //
            // Make sure we are at power D0
            //

            if (Extension->PowerState != PowerDeviceD0) {
               Status = SerialGotoPowerState(Extension->Pdo, Extension,
                                             PowerDeviceD0);
               if (!NT_SUCCESS(Status)) {
                  break;
               }
            }

            KeAcquireSpinLock(
                &Extension->ControlLock,
                &OldIrql
                );

            KeSynchronizeExecution(
                Extension->Interrupt,
                SerialSetMCRContents,
                &S
                );

            KeReleaseSpinLock(
                &Extension->ControlLock,
                OldIrql
                );

            break;
        }
        case IOCTL_SERIAL_SET_FIFO_CONTROL: {
           SERIAL_IOCTL_SYNC S;

            if (IrpSp->Parameters.DeviceIoControl.InputBufferLength <
                sizeof(ULONG)) {

                Status = STATUS_BUFFER_TOO_SMALL;
                break;

            }

            S.Extension = Extension;
            S.Data = Irp->AssociatedIrp.SystemBuffer;

            //
            // Make sure we are at power D0
            //

            if (Extension->PowerState != PowerDeviceD0) {
               Status = SerialGotoPowerState(Extension->Pdo, Extension,
                                             PowerDeviceD0);
               if (!NT_SUCCESS(Status)) {
                  break;
               }
            }

            KeAcquireSpinLock(
                &Extension->ControlLock,
                &OldIrql
                );

            KeSynchronizeExecution(
                Extension->Interrupt,
                SerialSetFCRContents,
                &S
                );

            KeReleaseSpinLock(
                &Extension->ControlLock,
                OldIrql
                );

            break;
        }
        case IOCTL_SERIAL_SET_LINE_CONTROL: {

            //
            // Points to the line control record in the Irp.
            //
            PSERIAL_LINE_CONTROL Lc =
                ((PSERIAL_LINE_CONTROL)(Irp->AssociatedIrp.SystemBuffer));

            UCHAR LData;
            UCHAR LStop;
            UCHAR LParity;
            UCHAR Mask = 0xff;

            if (IrpSp->Parameters.DeviceIoControl.InputBufferLength <
                sizeof(SERIAL_LINE_CONTROL)) {

                Status = STATUS_BUFFER_TOO_SMALL;
                break;

            }

            //
            // Make sure we are at power D0
            //

            if (Extension->PowerState != PowerDeviceD0) {
               Status = SerialGotoPowerState(Extension->Pdo, Extension,
                                             PowerDeviceD0);
               if (!NT_SUCCESS(Status)) {
                  break;
               }
            }

            switch (Lc->WordLength) {
                case 5: {

                    LData = SERIAL_5_DATA;
                    Mask = 0x1f;
                    break;

                }
                case 6: {

                    LData = SERIAL_6_DATA;
                    Mask = 0x3f;
                    break;

                }
                case 7: {

                    LData = SERIAL_7_DATA;
                    Mask = 0x7f;
                    break;

                }
                case 8: {

                    LData = SERIAL_8_DATA;
                    break;

                }
                default: {

                    Status = STATUS_INVALID_PARAMETER;
                    goto DoneWithIoctl;

                }

            }

            Extension->WmiCommData.BitsPerByte = Lc->WordLength;

            switch (Lc->Parity) {

                case NO_PARITY: {
                    Extension->WmiCommData.Parity = SERIAL_WMI_PARITY_NONE;
                    LParity = SERIAL_NONE_PARITY;
                    break;

                }
                case EVEN_PARITY: {
                    Extension->WmiCommData.Parity = SERIAL_WMI_PARITY_EVEN;
                    LParity = SERIAL_EVEN_PARITY;
                    break;

                }
                case ODD_PARITY: {
                    Extension->WmiCommData.Parity = SERIAL_WMI_PARITY_ODD;
                    LParity = SERIAL_ODD_PARITY;
                    break;

                }
#if defined(NEC_98)
                //
                // COM1 of PC-9800 series is not support MarkParity and SpaceParity.
                //
#else
                case SPACE_PARITY: {
                    Extension->WmiCommData.Parity = SERIAL_WMI_PARITY_SPACE;
                    LParity = SERIAL_SPACE_PARITY;
                    break;

                }
                case MARK_PARITY: {
                    Extension->WmiCommData.Parity = SERIAL_WMI_PARITY_MARK;
                    LParity = SERIAL_MARK_PARITY;
                    break;

                }
#endif //defined(NEC_98)
                default: {

                    Status = STATUS_INVALID_PARAMETER;
                    goto DoneWithIoctl;
                    break;
                }

            }

            switch (Lc->StopBits) {

                case STOP_BIT_1: {
                    Extension->WmiCommData.StopBits = SERIAL_WMI_STOP_1;
                    LStop = SERIAL_1_STOP;
                    break;
                }
                case STOP_BITS_1_5: {

                    if (LData != SERIAL_5_DATA) {

                        Status = STATUS_INVALID_PARAMETER;
                        goto DoneWithIoctl;
                    }
                    Extension->WmiCommData.StopBits = SERIAL_WMI_STOP_1_5;
                    LStop = SERIAL_1_5_STOP;
                    break;

                }
                case STOP_BITS_2: {

                    if (LData == SERIAL_5_DATA) {

                        Status = STATUS_INVALID_PARAMETER;
                        goto DoneWithIoctl;
                    }
                    Extension->WmiCommData.StopBits = SERIAL_WMI_STOP_2;
                    LStop = SERIAL_2_STOP;
                    break;

                }
                default: {

                    Status = STATUS_INVALID_PARAMETER;
                    goto DoneWithIoctl;
                }

            }

            KeAcquireSpinLock(
                &Extension->ControlLock,
                &OldIrql
                );

            Extension->LineControl =
                (UCHAR)((Extension->LineControl & SERIAL_LCR_BREAK) |
                        (LData | LParity | LStop));
            Extension->ValidDataMask = Mask;

            KeSynchronizeExecution(
                Extension->Interrupt,
                SerialSetLineControl,
                Extension
                );

            KeReleaseSpinLock(
                &Extension->ControlLock,
                OldIrql
                );

            break;
        }
        case IOCTL_SERIAL_GET_LINE_CONTROL: {

            PSERIAL_LINE_CONTROL Lc = (PSERIAL_LINE_CONTROL)Irp->AssociatedIrp.SystemBuffer;

            if (IrpSp->Parameters.DeviceIoControl.OutputBufferLength <
                sizeof(SERIAL_LINE_CONTROL)) {

                Status = STATUS_BUFFER_TOO_SMALL;
                break;

            }

            KeAcquireSpinLock(
                &Extension->ControlLock,
                &OldIrql
                );

            if ((Extension->LineControl & SERIAL_DATA_MASK) == SERIAL_5_DATA) {
                Lc->WordLength = 5;
            } else if ((Extension->LineControl & SERIAL_DATA_MASK)
                        == SERIAL_6_DATA) {
                Lc->WordLength = 6;
            } else if ((Extension->LineControl & SERIAL_DATA_MASK)
                        == SERIAL_7_DATA) {
                Lc->WordLength = 7;
            } else if ((Extension->LineControl & SERIAL_DATA_MASK)
                        == SERIAL_8_DATA) {
                Lc->WordLength = 8;
            }

            if ((Extension->LineControl & SERIAL_PARITY_MASK)
                    == SERIAL_NONE_PARITY) {
                Lc->Parity = NO_PARITY;
            } else if ((Extension->LineControl & SERIAL_PARITY_MASK)
                    == SERIAL_ODD_PARITY) {
                Lc->Parity = ODD_PARITY;
            } else if ((Extension->LineControl & SERIAL_PARITY_MASK)
                    == SERIAL_EVEN_PARITY) {
                Lc->Parity = EVEN_PARITY;
            } else if ((Extension->LineControl & SERIAL_PARITY_MASK)
                    == SERIAL_MARK_PARITY) {
                Lc->Parity = MARK_PARITY;
            } else if ((Extension->LineControl & SERIAL_PARITY_MASK)
                    == SERIAL_SPACE_PARITY) {
                Lc->Parity = SPACE_PARITY;
            }

            if (Extension->LineControl & SERIAL_2_STOP) {
                if (Lc->WordLength == 5) {
                    Lc->StopBits = STOP_BITS_1_5;
                } else {
                    Lc->StopBits = STOP_BITS_2;
                }
            } else {
                Lc->StopBits = STOP_BIT_1;
            }

            Irp->IoStatus.Information = sizeof(SERIAL_LINE_CONTROL);

            KeReleaseSpinLock(
                &Extension->ControlLock,
                OldIrql
                );

            break;
        }
        case IOCTL_SERIAL_SET_TIMEOUTS: {

            PSERIAL_TIMEOUTS NewTimeouts =
                ((PSERIAL_TIMEOUTS)(Irp->AssociatedIrp.SystemBuffer));


            if (IrpSp->Parameters.DeviceIoControl.InputBufferLength <
                sizeof(SERIAL_TIMEOUTS)) {

                Status = STATUS_BUFFER_TOO_SMALL;
                break;

            }

            if ((NewTimeouts->ReadIntervalTimeout == MAXULONG) &&
                (NewTimeouts->ReadTotalTimeoutMultiplier == MAXULONG) &&
                (NewTimeouts->ReadTotalTimeoutConstant == MAXULONG)) {

                Status = STATUS_INVALID_PARAMETER;
                break;

            }

            KeAcquireSpinLock(
                &Extension->ControlLock,
                &OldIrql
                );

            Extension->Timeouts.ReadIntervalTimeout =
                NewTimeouts->ReadIntervalTimeout;

            Extension->Timeouts.ReadTotalTimeoutMultiplier =
                NewTimeouts->ReadTotalTimeoutMultiplier;

            Extension->Timeouts.ReadTotalTimeoutConstant =
                NewTimeouts->ReadTotalTimeoutConstant;

            Extension->Timeouts.WriteTotalTimeoutMultiplier =
                NewTimeouts->WriteTotalTimeoutMultiplier;

            Extension->Timeouts.WriteTotalTimeoutConstant =
                NewTimeouts->WriteTotalTimeoutConstant;

            KeReleaseSpinLock(
                &Extension->ControlLock,
                OldIrql
                );

            break;
        }
        case IOCTL_SERIAL_GET_TIMEOUTS: {

            if (IrpSp->Parameters.DeviceIoControl.OutputBufferLength <
                sizeof(SERIAL_TIMEOUTS)) {

                Status = STATUS_BUFFER_TOO_SMALL;
                break;

            }

            KeAcquireSpinLock(
                &Extension->ControlLock,
                &OldIrql
                );

            *((PSERIAL_TIMEOUTS)Irp->AssociatedIrp.SystemBuffer) = Extension->Timeouts;
            Irp->IoStatus.Information = sizeof(SERIAL_TIMEOUTS);

            KeReleaseSpinLock(
                &Extension->ControlLock,
                OldIrql
                );

            break;
        }
        case IOCTL_SERIAL_SET_CHARS: {

            SERIAL_IOCTL_SYNC S;
            PSERIAL_CHARS NewChars =
                ((PSERIAL_CHARS)(Irp->AssociatedIrp.SystemBuffer));


            if (IrpSp->Parameters.DeviceIoControl.InputBufferLength <
                sizeof(SERIAL_CHARS)) {

                Status = STATUS_BUFFER_TOO_SMALL;
                break;

            }

            //
            // The only thing that can be wrong with the chars
            // is that the xon and xoff characters are the
            // same.
            //
#if 0
            if (NewChars->XonChar == NewChars->XoffChar) {

                Status = STATUS_INVALID_PARAMETER;
                break;

            }
#endif

            //
            // We acquire the control lock so that only
            // one request can GET or SET the characters
            // at a time.  The sets could be synchronized
            // by the interrupt spinlock, but that wouldn't
            // prevent multiple gets at the same time.
            //

            S.Extension = Extension;
            S.Data = NewChars;

            KeAcquireSpinLock(
                &Extension->ControlLock,
                &OldIrql
                );

            //
            // Under the protection of the lock, make sure that
            // the xon and xoff characters aren't the same as
            // the escape character.
            //

            if (Extension->EscapeChar) {

                if ((Extension->EscapeChar == NewChars->XonChar) ||
                    (Extension->EscapeChar == NewChars->XoffChar)) {

                    Status = STATUS_INVALID_PARAMETER;
                    KeReleaseSpinLock(
                        &Extension->ControlLock,
                        OldIrql
                        );
                    break;

                }

            }

            Extension->WmiCommData.XonCharacter = NewChars->XonChar;
            Extension->WmiCommData.XoffCharacter = NewChars->XoffChar;

            KeSynchronizeExecution(
                Extension->Interrupt,
                SerialSetChars,
                &S
                );

            KeReleaseSpinLock(
                &Extension->ControlLock,
                OldIrql
                );

            break;

        }
        case IOCTL_SERIAL_GET_CHARS: {

            if (IrpSp->Parameters.DeviceIoControl.OutputBufferLength <
                sizeof(SERIAL_CHARS)) {

                Status = STATUS_BUFFER_TOO_SMALL;
                break;

            }

            KeAcquireSpinLock(
                &Extension->ControlLock,
                &OldIrql
                );

            *((PSERIAL_CHARS)Irp->AssociatedIrp.SystemBuffer) = Extension->SpecialChars;
            Irp->IoStatus.Information = sizeof(SERIAL_CHARS);

            KeReleaseSpinLock(
                &Extension->ControlLock,
                OldIrql
                );

            break;
        }
        case IOCTL_SERIAL_SET_DTR:
        case IOCTL_SERIAL_CLR_DTR: {

           //
           // Make sure we are at power D0
           //

           if (Extension->PowerState != PowerDeviceD0) {
              Status = SerialGotoPowerState(Extension->Pdo, Extension,
                                            PowerDeviceD0);
              if (!NT_SUCCESS(Status)) {
                     break;
              }
           }

            //
            // We acquire the lock so that we can check whether
            // automatic dtr flow control is enabled.  If it is
            // then we return an error since the app is not allowed
            // to touch this if it is automatic.
            //

            KeAcquireSpinLock(
                &Extension->ControlLock,
                &OldIrql
                );

            if ((Extension->HandFlow.ControlHandShake & SERIAL_DTR_MASK)
                == SERIAL_DTR_HANDSHAKE) {

                Status = STATUS_INVALID_PARAMETER;

            } else {

                KeSynchronizeExecution(
                    Extension->Interrupt,
                    ((IrpSp->Parameters.DeviceIoControl.IoControlCode ==
                     IOCTL_SERIAL_SET_DTR)?
                     (SerialSetDTR):(SerialClrDTR)),
                    Extension
                    );

            }

            KeReleaseSpinLock(
                &Extension->ControlLock,
                OldIrql
                );

            break;
        }
        case IOCTL_SERIAL_RESET_DEVICE: {

            break;
        }
        case IOCTL_SERIAL_SET_RTS:
        case IOCTL_SERIAL_CLR_RTS: {
           //
           // Make sure we are at power D0
           //

           if (Extension->PowerState != PowerDeviceD0) {
              Status = SerialGotoPowerState(Extension->Pdo, Extension,
                                            PowerDeviceD0);
              if (!NT_SUCCESS(Status)) {
                 break;
              }
           }

            //
            // We acquire the lock so that we can check whether
            // automatic rts flow control or transmit toggleing
            // is enabled.  If it is then we return an error since
            // the app is not allowed to touch this if it is automatic
            // or toggling.
            //

            KeAcquireSpinLock(
                &Extension->ControlLock,
                &OldIrql
                );

            if (((Extension->HandFlow.FlowReplace & SERIAL_RTS_MASK)
                 == SERIAL_RTS_HANDSHAKE) ||
                ((Extension->HandFlow.FlowReplace & SERIAL_RTS_MASK)
                 == SERIAL_TRANSMIT_TOGGLE)) {

                Status = STATUS_INVALID_PARAMETER;

            } else {

                KeSynchronizeExecution(
                    Extension->Interrupt,
                    ((IrpSp->Parameters.DeviceIoControl.IoControlCode ==
                     IOCTL_SERIAL_SET_RTS)?
                     (SerialSetRTS):(SerialClrRTS)),
                    Extension
                    );

            }

            KeReleaseSpinLock(
                &Extension->ControlLock,
                OldIrql
                );

            break;

        }
        case IOCTL_SERIAL_SET_XOFF: {

            KeSynchronizeExecution(
                Extension->Interrupt,
                SerialPretendXoff,
                Extension
                );

            break;

        }
        case IOCTL_SERIAL_SET_XON: {

            KeSynchronizeExecution(
                Extension->Interrupt,
                SerialPretendXon,
                Extension
                );

            break;

        }
        case IOCTL_SERIAL_SET_BREAK_ON: {
           //
           // Make sure we are at power D0
           //

           if (Extension->PowerState != PowerDeviceD0) {
              Status = SerialGotoPowerState(Extension->Pdo, Extension,
                                            PowerDeviceD0);
              if (!NT_SUCCESS(Status)) {
                 break;
              }
           }

            KeSynchronizeExecution(
                Extension->Interrupt,
                SerialTurnOnBreak,
                Extension
                );

            break;
        }
        case IOCTL_SERIAL_SET_BREAK_OFF: {
           //
           // Make sure we are at power D0
           //

           if (Extension->PowerState != PowerDeviceD0) {
              Status = SerialGotoPowerState(Extension->Pdo, Extension,
                                            PowerDeviceD0);
              if (!NT_SUCCESS(Status)) {
                 break;
              }
           }

            KeSynchronizeExecution(
                Extension->Interrupt,
                SerialTurnOffBreak,
                Extension
                );

            break;
        }
        case IOCTL_SERIAL_SET_QUEUE_SIZE: {

            //
            // Type ahead buffer is fixed, so we just validate
            // the the users request is not bigger that our
            // own internal buffer size.
            //

            PSERIAL_QUEUE_SIZE Rs =
                ((PSERIAL_QUEUE_SIZE)(Irp->AssociatedIrp.SystemBuffer));

            if (IrpSp->Parameters.DeviceIoControl.InputBufferLength <
                sizeof(SERIAL_QUEUE_SIZE)) {

                Status = STATUS_BUFFER_TOO_SMALL;
                break;

            }

            //
            // We have to allocate the memory for the new
            // buffer while we're still in the context of the
            // caller.  We don't even try to protect this
            // with a lock because the value could be stale
            // as soon as we release the lock - The only time
            // we will know for sure is when we actually try
            // to do the resize.
            //

            if (Rs->InSize <= Extension->BufferSize) {

                Status = STATUS_SUCCESS;
                break;

            }

            try {

                IrpSp->Parameters.DeviceIoControl.Type3InputBuffer =
                    ExAllocatePoolWithQuota(
                        NonPagedPool,
                        Rs->InSize
                        );

            } except (EXCEPTION_EXECUTE_HANDLER) {

                IrpSp->Parameters.DeviceIoControl.Type3InputBuffer = NULL;
                Status = GetExceptionCode();

            }

            if (!IrpSp->Parameters.DeviceIoControl.Type3InputBuffer) {

                break;

            }

            //
            // Well the data passed was big enough.  Do the request.
            //
            // There are two reason we place it in the read queue:
            //
            // 1) We want to serialize these resize requests so that
            //    they don't contend with each other.
            //
            // 2) We want to serialize these requests with reads since
            //    we don't want reads and resizes contending over the
            //    read buffer.
            //

            return SerialStartOrQueue(
                       Extension,
                       Irp,
                       &Extension->ReadQueue,
                       &Extension->CurrentReadIrp,
                       SerialStartRead
                       );

            break;

        }
        case IOCTL_SERIAL_GET_WAIT_MASK: {

            if (IrpSp->Parameters.DeviceIoControl.OutputBufferLength <
                sizeof(ULONG)) {

                Status = STATUS_BUFFER_TOO_SMALL;
                break;

            }

            //
            // Simple scalar read.  No reason to acquire a lock.
            //

            Irp->IoStatus.Information = sizeof(ULONG);

            *((ULONG *)Irp->AssociatedIrp.SystemBuffer) = Extension->IsrWaitMask;

            break;

        }
        case IOCTL_SERIAL_SET_WAIT_MASK: {

            ULONG NewMask;

            SerialDump(
                SERDIAG3 | SERIRPPATH,
                ("SERIAL: In Ioctl processing for set mask\n")
                );
            if (IrpSp->Parameters.DeviceIoControl.InputBufferLength <
                sizeof(ULONG)) {

                SerialDump(
                    SERDIAG3,
                    ("SERIAL: Invalid size fo the buffer %d\n",
                     IrpSp->Parameters.DeviceIoControl.InputBufferLength)
                    );
                Status = STATUS_BUFFER_TOO_SMALL;
                break;

            } else {

                NewMask = *((ULONG *)Irp->AssociatedIrp.SystemBuffer);

            }

            //
            // Make sure that the mask only contains valid
            // waitable events.
            //

            if (NewMask & ~(SERIAL_EV_RXCHAR   |
                            SERIAL_EV_RXFLAG   |
                            SERIAL_EV_TXEMPTY  |
                            SERIAL_EV_CTS      |
                            SERIAL_EV_DSR      |
                            SERIAL_EV_RLSD     |
                            SERIAL_EV_BREAK    |
                            SERIAL_EV_ERR      |
                            SERIAL_EV_RING     |
                            SERIAL_EV_PERR     |
                            SERIAL_EV_RX80FULL |
                            SERIAL_EV_EVENT1   |
                            SERIAL_EV_EVENT2)) {

                SerialDump(
                    SERDIAG3,
                    ("SERIAL: Unknown mask %x\n",NewMask)
                    );
                Status = STATUS_INVALID_PARAMETER;
                break;

            }

            //
            // Either start this irp or put it on the
            // queue.
            //

            SerialDump(
                SERDIAG3 | SERIRPPATH,
                ("SERIAL: Starting or queuing set mask irp %x\n",Irp)
                );
            return SerialStartOrQueue(
                       Extension,
                       Irp,
                       &Extension->MaskQueue,
                       &Extension->CurrentMaskIrp,
                       SerialStartMask
                       );

        }
        case IOCTL_SERIAL_WAIT_ON_MASK: {

            SerialDump(
                SERDIAG3 | SERIRPPATH,
                ("SERIAL: In Ioctl processing for wait mask\n")
                );
            if (IrpSp->Parameters.DeviceIoControl.OutputBufferLength <
                sizeof(ULONG)) {

                SerialDump(
                    SERDIAG3,
                    ("SERIAL: Invalid size for the buffer %d\n",
                     IrpSp->Parameters.DeviceIoControl.OutputBufferLength)
                    );
                Status = STATUS_BUFFER_TOO_SMALL;
                break;

            }

            //
            // Either start this irp or put it on the
            // queue.
            //

            SerialDump(
                SERDIAG3 | SERIRPPATH,
                ("SERIAL: Starting or queuing wait mask irp %x\n",Irp)
                );
            return SerialStartOrQueue(
                       Extension,
                       Irp,
                       &Extension->MaskQueue,
                       &Extension->CurrentMaskIrp,
                       SerialStartMask
                       );

        }
        case IOCTL_SERIAL_IMMEDIATE_CHAR: {

            KIRQL OldIrql;

            if (IrpSp->Parameters.DeviceIoControl.InputBufferLength <
                sizeof(UCHAR)) {

                Status = STATUS_BUFFER_TOO_SMALL;
                break;

            }

            IoAcquireCancelSpinLock(&OldIrql);
            if (Extension->CurrentImmediateIrp) {

                Status = STATUS_INVALID_PARAMETER;
                IoReleaseCancelSpinLock(OldIrql);

            } else {

                //
                // We can queue the char.  We need to set
                // a cancel routine because flow control could
                // keep the char from transmitting.  Make sure
                // that the irp hasn't already been canceled.
                //

                if (Irp->Cancel) {

                    IoReleaseCancelSpinLock(OldIrql);
                    Status = STATUS_CANCELLED;

                } else {

                    Extension->CurrentImmediateIrp = Irp;
                    Extension->TotalCharsQueued++;
                    IoReleaseCancelSpinLock(OldIrql);
                    SerialStartImmediate(Extension);

                    return STATUS_PENDING;

                }

            }

            break;

        }
        case IOCTL_SERIAL_PURGE: {

            ULONG Mask;

            if (IrpSp->Parameters.DeviceIoControl.InputBufferLength <
                sizeof(ULONG)) {

                Status = STATUS_BUFFER_TOO_SMALL;
                break;

            }
            //
            // Check to make sure that the mask only has
            // 0 or the other appropriate values.
            //

            Mask = *((ULONG *)(Irp->AssociatedIrp.SystemBuffer));

            if ((!Mask) || (Mask & (~(SERIAL_PURGE_TXABORT |
                                      SERIAL_PURGE_RXABORT |
                                      SERIAL_PURGE_TXCLEAR |
                                      SERIAL_PURGE_RXCLEAR
                                     )
                                   )
                           )) {

                Status = STATUS_INVALID_PARAMETER;
                break;

            }

            //
            // Either start this irp or put it on the
            // queue.
            //

            return SerialStartOrQueue(
                       Extension,
                       Irp,
                       &Extension->PurgeQueue,
                       &Extension->CurrentPurgeIrp,
                       SerialStartPurge
                       );

        }
        case IOCTL_SERIAL_GET_HANDFLOW: {

            if (IrpSp->Parameters.DeviceIoControl.OutputBufferLength <
                sizeof(SERIAL_HANDFLOW)) {

                Status = STATUS_BUFFER_TOO_SMALL;
                break;

            }

            Irp->IoStatus.Information = sizeof(SERIAL_HANDFLOW);

            KeAcquireSpinLock(
                &Extension->ControlLock,
                &OldIrql
                );

            *((PSERIAL_HANDFLOW)Irp->AssociatedIrp.SystemBuffer) =
                Extension->HandFlow;

            KeReleaseSpinLock(
                &Extension->ControlLock,
                OldIrql
                );

            break;

        }
        case IOCTL_SERIAL_SET_HANDFLOW: {

            SERIAL_IOCTL_SYNC S;
            PSERIAL_HANDFLOW HandFlow = Irp->AssociatedIrp.SystemBuffer;

            //
            // Make sure that the hand shake and control is the
            // right size.
            //

            if (IrpSp->Parameters.DeviceIoControl.InputBufferLength <
                sizeof(SERIAL_HANDFLOW)) {

                Status = STATUS_BUFFER_TOO_SMALL;
                break;

            }

            //
            // Make sure that there are no invalid bits set in
            // the control and handshake.
            //

            if (HandFlow->ControlHandShake & SERIAL_CONTROL_INVALID) {

                Status = STATUS_INVALID_PARAMETER;
                break;

            }

            if (HandFlow->FlowReplace & SERIAL_FLOW_INVALID) {

                Status = STATUS_INVALID_PARAMETER;
                break;

            }

            //
            // Make sure that the app hasn't set an invlid DTR mode.
            //

            if ((HandFlow->ControlHandShake & SERIAL_DTR_MASK) ==
                SERIAL_DTR_MASK) {

                Status = STATUS_INVALID_PARAMETER;
                break;

            }

            //
            // Make sure that haven't set totally invalid xon/xoff
            // limits.
            //

            if ((HandFlow->XonLimit < 0) ||
                ((ULONG)HandFlow->XonLimit > Extension->BufferSize)) {

                Status = STATUS_INVALID_PARAMETER;
                break;

            }

            if ((HandFlow->XoffLimit < 0) ||
                ((ULONG)HandFlow->XoffLimit > Extension->BufferSize)) {

                Status = STATUS_INVALID_PARAMETER;
                break;

            }

            S.Extension = Extension;
            S.Data = HandFlow;

            KeAcquireSpinLock(
                &Extension->ControlLock,
                &OldIrql
                );

            //
            // Under the protection of the lock, make sure that
            // we aren't turning on error replacement when we
            // are doing line status/modem status insertion.
            //

            if (Extension->EscapeChar) {

                if (HandFlow->FlowReplace & SERIAL_ERROR_CHAR) {

                    Status = STATUS_INVALID_PARAMETER;
                    KeReleaseSpinLock(
                        &Extension->ControlLock,
                        OldIrql
                        );
                    break;

                }

            }

            KeSynchronizeExecution(
                Extension->Interrupt,
                SerialSetHandFlow,
                &S
                );

            KeReleaseSpinLock(
                &Extension->ControlLock,
                OldIrql
                );

            break;

        }
        case IOCTL_SERIAL_GET_MODEMSTATUS: {

            SERIAL_IOCTL_SYNC S;

            if (IrpSp->Parameters.DeviceIoControl.OutputBufferLength <
                sizeof(ULONG)) {

                Status = STATUS_BUFFER_TOO_SMALL;
                break;

            }

            Irp->IoStatus.Information = sizeof(ULONG);

            S.Extension = Extension;
            S.Data = Irp->AssociatedIrp.SystemBuffer;

            KeAcquireSpinLock(
                &Extension->ControlLock,
                &OldIrql
                );

            KeSynchronizeExecution(
                Extension->Interrupt,
                SerialGetModemUpdate,
                &S
                );

            KeReleaseSpinLock(
                &Extension->ControlLock,
                OldIrql
                );

            break;

        }
        case IOCTL_SERIAL_GET_DTRRTS: {

            ULONG ModemControl;
            if (IrpSp->Parameters.DeviceIoControl.OutputBufferLength <
                sizeof(ULONG)) {

                Status = STATUS_BUFFER_TOO_SMALL;
                break;

            }

            Irp->IoStatus.Information = sizeof(ULONG);
            Irp->IoStatus.Status = STATUS_SUCCESS;

            //
            // Reading this hardware has no effect on the device.
            //

            ModemControl = READ_MODEM_CONTROL(Extension->Controller);

            ModemControl &= SERIAL_DTR_STATE | SERIAL_RTS_STATE;

            *(PULONG)Irp->AssociatedIrp.SystemBuffer = ModemControl;

            break;

        }
        case IOCTL_SERIAL_GET_COMMSTATUS: {

            SERIAL_IOCTL_SYNC S;

            if (IrpSp->Parameters.DeviceIoControl.OutputBufferLength <
                sizeof(SERIAL_STATUS)) {

                Status = STATUS_BUFFER_TOO_SMALL;
                break;

            }

            Irp->IoStatus.Information = sizeof(SERIAL_STATUS);

            S.Extension = Extension;
            S.Data =  Irp->AssociatedIrp.SystemBuffer;

            //
            // Acquire the cancel spin lock so nothing much
            // changes while were getting the state.
            //

            IoAcquireCancelSpinLock(&OldIrql);

            KeSynchronizeExecution(
                Extension->Interrupt,
                SerialGetCommStatus,
                &S
                );

            IoReleaseCancelSpinLock(OldIrql);

            break;

        }
        case IOCTL_SERIAL_GET_PROPERTIES: {


            if (IrpSp->Parameters.DeviceIoControl.OutputBufferLength <
                sizeof(SERIAL_COMMPROP)) {

                Status = STATUS_BUFFER_TOO_SMALL;
                break;

            }

            //
            // No synchronization is required since this information
            // is "static".
            //

            SerialGetProperties(
                Extension,
                Irp->AssociatedIrp.SystemBuffer
                );

            Irp->IoStatus.Information = sizeof(SERIAL_COMMPROP);
            Irp->IoStatus.Status = STATUS_SUCCESS;

            break;
        }
        case IOCTL_SERIAL_XOFF_COUNTER: {

            PSERIAL_XOFF_COUNTER Xc = Irp->AssociatedIrp.SystemBuffer;

            if (IrpSp->Parameters.DeviceIoControl.InputBufferLength <
                sizeof(SERIAL_XOFF_COUNTER)) {

                Status = STATUS_BUFFER_TOO_SMALL;
                break;

            }

            if (Xc->Counter <= 0) {

                Status = STATUS_INVALID_PARAMETER;
                break;

            }

            //
            // There is no output, so make that clear now
            //

            Irp->IoStatus.Information = 0;

            //
            // So far so good.  Put the irp onto the write queue.
            //

            return SerialStartOrQueue(
                       Extension,
                       Irp,
                       &Extension->WriteQueue,
                       &Extension->CurrentWriteIrp,
                       SerialStartWrite
                       );

        }
        case IOCTL_SERIAL_LSRMST_INSERT: {

            PUCHAR escapeChar = Irp->AssociatedIrp.SystemBuffer;
            SERIAL_IOCTL_SYNC S;

            //
            // Make sure we get a byte.
            //

            if (IrpSp->Parameters.DeviceIoControl.InputBufferLength <
                sizeof(UCHAR)) {

                Status = STATUS_BUFFER_TOO_SMALL;
                break;

            }

            KeAcquireSpinLock(
                &Extension->ControlLock,
                &OldIrql
                );

            if (*escapeChar) {

                //
                // We've got some escape work to do.  We will make sure that
                // the character is not the same as the Xon or Xoff character,
                // or that we are already doing error replacement.
                //

                if ((*escapeChar == Extension->SpecialChars.XoffChar) ||
                    (*escapeChar == Extension->SpecialChars.XonChar) ||
                    (Extension->HandFlow.FlowReplace & SERIAL_ERROR_CHAR)) {

                    Status = STATUS_INVALID_PARAMETER;

                    KeReleaseSpinLock(
                        &Extension->ControlLock,
                        OldIrql
                        );
                    break;

                }

            }

            S.Extension = Extension;
            S.Data = Irp->AssociatedIrp.SystemBuffer;

            KeSynchronizeExecution(
                Extension->Interrupt,
                SerialSetEscapeChar,
                Irp
                );

            KeReleaseSpinLock(
                &Extension->ControlLock,
                OldIrql
                );

            break;

        }
        case IOCTL_SERIAL_CONFIG_SIZE: {

            if (IrpSp->Parameters.DeviceIoControl.OutputBufferLength <
                sizeof(ULONG)) {

                Status = STATUS_BUFFER_TOO_SMALL;
                break;

            }

            Irp->IoStatus.Information = sizeof(ULONG);
            Irp->IoStatus.Status = STATUS_SUCCESS;

            *(PULONG)Irp->AssociatedIrp.SystemBuffer = 0;

            break;
        }
        case IOCTL_SERIAL_GET_STATS: {

            if (IrpSp->Parameters.DeviceIoControl.OutputBufferLength <
                sizeof(SERIALPERF_STATS)) {

                Status = STATUS_BUFFER_TOO_SMALL;
                break;

            }
            Irp->IoStatus.Information = sizeof(SERIALPERF_STATS);
            Irp->IoStatus.Status = STATUS_SUCCESS;

            KeSynchronizeExecution(
                Extension->Interrupt,
                SerialGetStats,
                Irp
                );

            break;
        }
        case IOCTL_SERIAL_CLEAR_STATS: {

            KeSynchronizeExecution(
                Extension->Interrupt,
                SerialClearStats,
                Extension
                );
            break;
        }
        default: {

            Status = STATUS_INVALID_PARAMETER;
            break;
        }
    }

DoneWithIoctl:;

    Irp->IoStatus.Status = Status;

    SerialDump(
        SERIRPPATH,
        ("SERIAL: Complete Irp: %x\n",Irp)
        );

    SerialCompleteRequest(Extension, Irp, 0);

    return Status;

}

VOID
SerialGetProperties(
    IN PSERIAL_DEVICE_EXTENSION Extension,
    IN PSERIAL_COMMPROP Properties
    )

/*++

Routine Description:

    This function returns the capabilities of this particular
    serial device.

Arguments:

    Extension - The serial device extension.

    Properties - The structure used to return the properties

Return Value:

    None.

--*/

{
   SERIAL_LOCKED_PAGED_CODE();

    RtlZeroMemory(
        Properties,
        sizeof(SERIAL_COMMPROP)
        );

    Properties->PacketLength = sizeof(SERIAL_COMMPROP);
    Properties->PacketVersion = 2;
    Properties->ServiceMask = SERIAL_SP_SERIALCOMM;
    Properties->MaxTxQueue = 0;
    Properties->MaxRxQueue = 0;

    Properties->MaxBaud = SERIAL_BAUD_USER;
    Properties->SettableBaud = Extension->SupportedBauds;

    Properties->ProvSubType = SERIAL_SP_RS232;
    Properties->ProvCapabilities = SERIAL_PCF_DTRDSR |
                                   SERIAL_PCF_RTSCTS |
                                   SERIAL_PCF_CD     |
                                   SERIAL_PCF_PARITY_CHECK |
                                   SERIAL_PCF_XONXOFF |
                                   SERIAL_PCF_SETXCHAR |
                                   SERIAL_PCF_TOTALTIMEOUTS |
                                   SERIAL_PCF_INTTIMEOUTS;
    Properties->SettableParams = SERIAL_SP_PARITY |
                                 SERIAL_SP_BAUD |
                                 SERIAL_SP_DATABITS |
                                 SERIAL_SP_STOPBITS |
                                 SERIAL_SP_HANDSHAKING |
                                 SERIAL_SP_PARITY_CHECK |
                                 SERIAL_SP_CARRIER_DETECT;


    Properties->SettableData = SERIAL_DATABITS_5 |
                               SERIAL_DATABITS_6 |
                               SERIAL_DATABITS_7 |
                               SERIAL_DATABITS_8;
#if defined(NEC_98)
    //
    // COM1 of PC-9800 series is not support MarkParity and SpaceParity.
    //
    Properties->SettableStopParity = SERIAL_STOPBITS_10 |
                                     SERIAL_STOPBITS_15 |
                                     SERIAL_STOPBITS_20 |
                                     SERIAL_PARITY_NONE |
                                     SERIAL_PARITY_ODD  |
                                     SERIAL_PARITY_EVEN;
#else
    Properties->SettableStopParity = SERIAL_STOPBITS_10 |
                                     SERIAL_STOPBITS_15 |
                                     SERIAL_STOPBITS_20 |
                                     SERIAL_PARITY_NONE |
                                     SERIAL_PARITY_ODD  |
                                     SERIAL_PARITY_EVEN |
                                     SERIAL_PARITY_MARK |
                                     SERIAL_PARITY_SPACE;
#endif //defined(NEC_98)
    Properties->CurrentTxQueue = 0;
    Properties->CurrentRxQueue = Extension->BufferSize;

}


NTSTATUS
SerialInternalIoControl(IN PDEVICE_OBJECT PDevObj, IN PIRP PIrp)

/*++

Routine Description:

    This routine provides the initial processing for all of the
    internal Ioctrls for the serial device.

Arguments:

    PDevObj - Pointer to the device object for this device

    PIrp - Pointer to the IRP for the current request

Return Value:

    The function value is the final status of the call

--*/

{
    //
    // The status that gets returned to the caller and
    // set in the Irp.
    //
    NTSTATUS status;

    //
    // The current stack location.  This contains all of the
    // information we need to process this particular request.
    //
    PIO_STACK_LOCATION pIrpStack;

    //
    // Just what it says.  This is the serial specific device
    // extension of the device object create for the serial driver.
    //
    PSERIAL_DEVICE_EXTENSION pDevExt = PDevObj->DeviceExtension;

#if defined(NEC_98)
    //
    // This argument use at MACRO only.
    //
    PSERIAL_DEVICE_EXTENSION Extension = pDevExt;
#else
#endif //defined(NEC_98)
    //
    // A temporary to hold the old IRQL so that it can be
    // restored once we complete/validate this request.
    //
    KIRQL OldIrql;

    NTSTATUS prologueStatus;

    SERIAL_LOCKED_PAGED_CODE();


    if ((prologueStatus = SerialIRPPrologue(PIrp, pDevExt))
        != STATUS_SUCCESS) {
       SerialCompleteRequest(pDevExt, PIrp, IO_NO_INCREMENT);
       return prologueStatus;
    }

    SerialDump(SERIRPPATH, ("SERIAL: Dispatch entry for: %x\n", PIrp));

    if (SerialCompleteIfError(PDevObj, PIrp) != STATUS_SUCCESS) {
        return STATUS_CANCELLED;
    }

    pIrpStack = IoGetCurrentIrpStackLocation(PIrp);
    PIrp->IoStatus.Information = 0L;
    status = STATUS_SUCCESS;

    switch (pIrpStack->Parameters.DeviceIoControl.IoControlCode) {

    //
    // Send a wait-wake IRP
    //

    case IOCTL_SERIAL_INTERNAL_DO_WAIT_WAKE:
       pDevExt->SendWaitWake = TRUE;
       status = STATUS_SUCCESS;
       break;

    case IOCTL_SERIAL_INTERNAL_CANCEL_WAIT_WAKE:
       pDevExt->SendWaitWake = FALSE;

       if (pDevExt->PendingWakeIrp != NULL) {
          IoCancelIrp(pDevExt->PendingWakeIrp);
       }

       status = STATUS_SUCCESS;
       break;


    //
    // Put the serial port in a "filter-driver" appropriate state
    //
    // WARNING: This code assumes it is being called by a trusted kernel
    // entity and no checking is done on the validity of the settings
    // passed to IOCTL_SERIAL_INTERNAL_RESTORE_SETTINGS
    //
    // If validity checking is desired, the regular ioctl's should be used
    //

    case IOCTL_SERIAL_INTERNAL_BASIC_SETTINGS:
    case IOCTL_SERIAL_INTERNAL_RESTORE_SETTINGS: {
       SERIAL_BASIC_SETTINGS basic;
       PSERIAL_BASIC_SETTINGS pBasic;
       SHORT AppropriateDivisor;
       SERIAL_IOCTL_SYNC S;

       if (pIrpStack->Parameters.DeviceIoControl.IoControlCode
           == IOCTL_SERIAL_INTERNAL_BASIC_SETTINGS) {


          //
          // Check the buffer size
          //

          if (pIrpStack->Parameters.DeviceIoControl.OutputBufferLength <
              sizeof(SERIAL_BASIC_SETTINGS)) {
             status = STATUS_BUFFER_TOO_SMALL;
             break;
          }

          //
          // Everything is 0 -- timeouts and flow control and fifos.  If
          // We add additional features, this zero memory method
          // may not work.
          //

          RtlZeroMemory(&basic, sizeof(SERIAL_BASIC_SETTINGS));

          basic.TxFifo = 1;
          basic.RxFifo = SERIAL_1_BYTE_HIGH_WATER;

          PIrp->IoStatus.Information = sizeof(SERIAL_BASIC_SETTINGS);
          pBasic = (PSERIAL_BASIC_SETTINGS)PIrp->AssociatedIrp.SystemBuffer;

          //
          // Save off the old settings
          //

          RtlCopyMemory(&pBasic->Timeouts, &pDevExt->Timeouts,
                        sizeof(SERIAL_TIMEOUTS));

          RtlCopyMemory(&pBasic->HandFlow, &pDevExt->HandFlow,
                        sizeof(SERIAL_HANDFLOW));

          pBasic->RxFifo = pDevExt->RxFifoTrigger;
          pBasic->TxFifo = pDevExt->TxFifoAmount;

          //
          // Point to our new settings
          //

          pBasic = &basic;
       } else { // restoring settings
          if (pIrpStack->Parameters.DeviceIoControl.InputBufferLength
              < sizeof(SERIAL_BASIC_SETTINGS)) {
             status = STATUS_BUFFER_TOO_SMALL;
             break;
          }

          pBasic = (PSERIAL_BASIC_SETTINGS)PIrp->AssociatedIrp.SystemBuffer;
       }

       KeAcquireSpinLock(&pDevExt->ControlLock, &OldIrql);

       //
       // Set the timeouts
       //

       RtlCopyMemory(&pDevExt->Timeouts, &pBasic->Timeouts,
                     sizeof(SERIAL_TIMEOUTS));

       //
       // Set flowcontrol
       //

       S.Extension = pDevExt;
       S.Data = &pBasic->HandFlow;
       KeSynchronizeExecution(pDevExt->Interrupt, SerialSetHandFlow, &S);


       if (pDevExt->FifoPresent) {
          pDevExt->TxFifoAmount = pBasic->TxFifo;
          pDevExt->RxFifoTrigger = (UCHAR)pBasic->RxFifo;

          WRITE_FIFO_CONTROL(pDevExt->Controller, (UCHAR)0);
          READ_RECEIVE_BUFFER(pDevExt->Controller);
          WRITE_FIFO_CONTROL(pDevExt->Controller,
                             (UCHAR)(SERIAL_FCR_ENABLE | pDevExt->RxFifoTrigger
                                     | SERIAL_FCR_RCVR_RESET
                                     | SERIAL_FCR_TXMT_RESET));
       } else {
          pDevExt->TxFifoAmount = pDevExt->RxFifoTrigger = 0;
          WRITE_FIFO_CONTROL(pDevExt->Controller, (UCHAR)0);
       }


       KeReleaseSpinLock(&pDevExt->ControlLock, OldIrql);


       break;
    }

    default:
       status = STATUS_INVALID_PARAMETER;
       break;

    }

    PIrp->IoStatus.Status = status;

    SerialDump(SERIRPPATH, ("SERIAL: Complete Irp: %x\n", PIrp));
    SerialCompleteRequest(pDevExt, PIrp, 0);

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\ser101\precomp.h ===
#include <stddef.h>
#include "ntddk.h"
#include "ntddser.h"
#include <wmilib.h>
#include <wmidata.h>
#include "serial.h"
#include "serialp.h"
#include "serlog.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\ser101\pnp.c ===
/*++

Copyright (c) 1991, 1992, 1993 - 1997 Microsoft Corporation

Module Name:

    pnp.c

Abstract:

    This module contains the code that handles the plug and play
    IRPs for the serial driver.

Environment:

    Kernel mode

Revision History :


--*/

#include "precomp.h"

#define ALLF    0xffffffff

static const PHYSICAL_ADDRESS SerialPhysicalZero = {0};



#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGESRP0, SerialCreateDevObj)
#pragma alloc_text(PAGESRP0, SerialAddDevice)
#pragma alloc_text(PAGESRP0, SerialPnpDispatch)
#pragma alloc_text(PAGESRP0, SerialStartDevice)
#pragma alloc_text(PAGESRP0, SerialFinishStartDevice)
#pragma alloc_text(PAGESRP0, SerialGetPortInfo)
#pragma alloc_text(PAGESRP0, SerialDoExternalNaming)
#pragma alloc_text(PAGESRP0, SerialReportMaxBaudRate)
#pragma alloc_text(PAGESRP0, SerialControllerCallBack)
#pragma alloc_text(PAGESRP0, SerialItemCallBack)
#pragma alloc_text(PAGESRP0, SerialUndoExternalNaming)
#endif // ALLOC_PRAGMA

//
// Instantiate the GUID
//

#if !defined(FAR)
#define FAR
#endif // !defined(FAR)

#include <initguid.h>

DEFINE_GUID(GUID_CLASS_COMPORT, 0x86e0d1e0L, 0x8089, 0x11d0, 0x9c, 0xe4, 0x08,
            0x00, 0x3e, 0x30, 0x1f, 0x73);


#if DBG

UCHAR *SerSystemCapString[] = {
   "PowerSystemUnspecified",
   "PowerSystemWorking",
   "PowerSystemSleeping1",
   "PowerSystemSleeping2",
   "PowerSystemSleeping3",
   "PowerSystemHibernate",
   "PowerSystemShutdown",
   "PowerSystemMaximum"
};

UCHAR *SerDeviceCapString[] = {
   "PowerDeviceUnspecified",
   "PowerDeviceD0",
   "PowerDeviceD1",
   "PowerDeviceD2",
   "PowerDeviceD3",
   "PowerDeviceMaximum"
};

#endif // DBG


NTSTATUS
SerialSyncCompletion(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp,
                     IN PKEVENT SerialSyncEvent)
{
   KeSetEvent(SerialSyncEvent, IO_NO_INCREMENT, FALSE);
   return STATUS_MORE_PROCESSING_REQUIRED;
}


NTSTATUS
SerialCreateDevObj(IN PDRIVER_OBJECT DriverObject,
                   OUT PDEVICE_OBJECT *NewDeviceObject)

/*++

Routine Description:

    This routine will create and initialize a functional device object to
    be attached to a Serial controller PDO.

Arguments:

    DriverObject - a pointer to the driver object this is created under
    NewDeviceObject - a location to store the pointer to the new device object

Return Value:

    STATUS_SUCCESS if everything was successful
    reason for failure otherwise

--*/

{
   UNICODE_STRING deviceObjName;
   PDEVICE_OBJECT deviceObject = NULL;
   PSERIAL_DEVICE_EXTENSION pDevExt;
   NTSTATUS status = STATUS_SUCCESS;
   static ULONG currentInstance = 0;
   UNICODE_STRING instanceStr;
   WCHAR instanceNumberBuffer[20];


   PAGED_CODE();

   SerialDump (SERTRACECALLS,("SERIAL: Enter SerialCreateDevObj\n"));

   //
   // Zero out allocated memory pointers so we know if they must be freed
   //

   RtlZeroMemory(&deviceObjName, sizeof(UNICODE_STRING));

   deviceObjName.MaximumLength = DEVICE_OBJECT_NAME_LENGTH * sizeof(WCHAR);
   deviceObjName.Buffer = ExAllocatePool(PagedPool, deviceObjName.MaximumLength
                                     + sizeof(WCHAR));


   if (deviceObjName.Buffer == NULL) {
      SerialLogError(DriverObject, NULL, SerialPhysicalZero, SerialPhysicalZero,
                     0, 0, 0, 19, STATUS_SUCCESS, SERIAL_INSUFFICIENT_RESOURCES,
                     0, NULL, 0, NULL);
      SerialDump(SERERRORS, ("SERIAL: Couldn't allocate memory for device name"
                             "\n"));

      return STATUS_INSUFFICIENT_RESOURCES;

   }

   RtlZeroMemory(deviceObjName.Buffer, deviceObjName.MaximumLength
                 + sizeof(WCHAR));

#if defined(NEC_98)
   RtlAppendUnicodeToString(&deviceObjName, L"\\Device\\Ser101");
#else
   RtlAppendUnicodeToString(&deviceObjName, L"\\Device\\Serial");
#endif //defined(NEC_98)

   RtlInitUnicodeString(&instanceStr, NULL);

   instanceStr.MaximumLength = sizeof(instanceNumberBuffer);
   instanceStr.Buffer = instanceNumberBuffer;

   RtlIntegerToUnicodeString(currentInstance++, 10, &instanceStr);

   RtlAppendUnicodeStringToString(&deviceObjName, &instanceStr);


   //
   // Create the device object
   //

   status = IoCreateDevice(DriverObject, sizeof(SERIAL_DEVICE_EXTENSION),
                           &deviceObjName, FILE_DEVICE_SERIAL_PORT,
                           FILE_DEVICE_SECURE_OPEN, TRUE, &deviceObject);


   if (!NT_SUCCESS(status)) {
      SerialDump(SERERRORS, ("SerialAddDevice: Create device failed - %x \n",
                             status));
      goto SerialCreateDevObjError;
   }

   ASSERT(deviceObject != NULL);


   //
   // The device object has a pointer to an area of non-paged
   // pool allocated for this device.  This will be the device
   // extension. Zero it out.
   //

   pDevExt = deviceObject->DeviceExtension;
   RtlZeroMemory(pDevExt, sizeof(SERIAL_DEVICE_EXTENSION));

   //
   // Initialize the count of IRP's pending
   //

   pDevExt->PendingIRPCnt = 1;


   //
   // Initialize the count of DPC's pending
   //

   pDevExt->DpcCount = 1;

   //
   // Allocate Pool and save the nt device name in the device extension.
   //

   pDevExt->DeviceName.Buffer =
      ExAllocatePool(PagedPool, deviceObjName.Length + sizeof(WCHAR));

   if (!pDevExt->DeviceName.Buffer) {

      SerialLogError(
                    DriverObject,
                    NULL,
                    SerialPhysicalZero,
                    SerialPhysicalZero,
                    0,
                    0,
                    0,
                    19,
                    STATUS_SUCCESS,
                    SERIAL_INSUFFICIENT_RESOURCES,
                    0,
                    NULL,
                    0,
                    NULL
                    );
      SerialDump(
                SERERRORS,
                ("SERIAL: Couldn't allocate memory for DeviceName\n"));

      status = STATUS_INSUFFICIENT_RESOURCES;
      goto SerialCreateDevObjError;
   }

   pDevExt->DeviceName.MaximumLength = deviceObjName.Length
      + sizeof(WCHAR);

   //
   // Zero fill it.
   //

   RtlZeroMemory(pDevExt->DeviceName.Buffer,
                 pDevExt->DeviceName.MaximumLength);

   RtlAppendUnicodeStringToString(&pDevExt->DeviceName, &deviceObjName);

   pDevExt->NtNameForPort.Buffer = ExAllocatePool(PagedPool,
                                                  deviceObjName.MaximumLength);

   if (pDevExt->NtNameForPort.Buffer == NULL) {
      SerialDump(SERERRORS, ("SerialAddDevice: Cannot allocate memory for "
                             "NtName\n"));
      status = STATUS_INSUFFICIENT_RESOURCES;
      goto SerialCreateDevObjError;
   }

   pDevExt->NtNameForPort.MaximumLength = deviceObjName.MaximumLength;
   RtlAppendUnicodeStringToString(&pDevExt->NtNameForPort,
                                  &deviceObjName);



   //
   // Set up the device extension.
   //

   pDevExt->DeviceIsOpened = FALSE;
   pDevExt->DeviceObject   = deviceObject;
   pDevExt->DriverObject   = DriverObject;
   pDevExt->DeviceObject   = deviceObject;
   pDevExt->PowerState     = PowerDeviceD0;

   pDevExt->TxFifoAmount           = driverDefaults.TxFIFODefault;
   pDevExt->CreatedSymbolicLink    = TRUE;
   pDevExt->OwnsPowerPolicy = TRUE;

   InitializeListHead(&pDevExt->CommonInterruptObject);
   InitializeListHead(&pDevExt->TopLevelSharers);
   InitializeListHead(&pDevExt->MultiportSiblings);
   InitializeListHead(&pDevExt->AllDevObjs);
   InitializeListHead(&pDevExt->ReadQueue);
   InitializeListHead(&pDevExt->WriteQueue);
   InitializeListHead(&pDevExt->MaskQueue);
   InitializeListHead(&pDevExt->PurgeQueue);
   InitializeListHead(&pDevExt->StalledIrpQueue);

   ExInitializeFastMutex(&pDevExt->OpenMutex);
   ExInitializeFastMutex(&pDevExt->CloseMutex);

   KeInitializeEvent(&pDevExt->PendingIRPEvent, SynchronizationEvent, FALSE);
   KeInitializeEvent(&pDevExt->PendingDpcEvent, SynchronizationEvent, FALSE);
   KeInitializeEvent(&pDevExt->PowerD0Event, SynchronizationEvent, FALSE);


   deviceObject->Flags &= ~DO_DEVICE_INITIALIZING;

   *NewDeviceObject = deviceObject;

   ExFreePool(deviceObjName.Buffer);

   SerialDump (SERTRACECALLS,("SERIAL: Leave SerialCreateDevObj\n") );
   return STATUS_SUCCESS;


   SerialCreateDevObjError:

   SerialDump (SERERRORS,("SERIAL: SerialCreateDevObj Error, Cleaning up\n") );

   //
   // Free the allocated strings for the NT and symbolic names if they exist.
   //

   if (deviceObjName.Buffer != NULL) {
      ExFreePool(deviceObjName.Buffer);
   }

   if (deviceObject) {

      if (pDevExt->NtNameForPort.Buffer != NULL) {
         ExFreePool(pDevExt->NtNameForPort.Buffer);
      }

      if (pDevExt->DeviceName.Buffer != NULL) {
         ExFreePool(pDevExt->DeviceName.Buffer);
      }

      IoDeleteDevice(deviceObject);
   }

   *NewDeviceObject = NULL;

   SerialDump (SERTRACECALLS,("SERIAL: Leave SerialCreateDevObj\n") );
   return status;
}


NTSTATUS
SerialAddDevice(IN PDRIVER_OBJECT DriverObject, IN PDEVICE_OBJECT PPdo)

/*++

Routine Description:

    This routine creates a functional device object for com ports in the
    system and attaches them to the physical device objects for the ports


Arguments:

    DriverObject - a pointer to the object for this driver

    PPdo - a pointer to the PDO in the stack we need to attach to

Return Value:

    status from device creation and initialization

--*/

{
   PDEVICE_OBJECT pNewDevObj = NULL;
   PDEVICE_OBJECT pLowerDevObj = NULL;
   NTSTATUS status;
   PSERIAL_DEVICE_EXTENSION pDevExt;

   PAGED_CODE();

   SerialDump(SERTRACECALLS, ("SERIAL: Enter SerialAddDevice with PPdo "
                              "0x%x\n", PPdo));

   if (PPdo == NULL) {
      //
      // Return no more devices
      //

      SerialDump(SERERRORS, ("SerialAddDevice: Enumeration request, returning"
                             " NO_MORE_ENTRIES\n"));

      return (STATUS_NO_MORE_ENTRIES);
   }



   //
   // create and initialize the new device object
   //

   status = SerialCreateDevObj(DriverObject, &pNewDevObj);

   if (!NT_SUCCESS(status)) {

      SerialDump(SERERRORS,
                 ("SerialAddDevice - error creating new devobj [%#08lx]\n",
                  status));
      return status;
   }


   //
   // Layer our DO on top of the lower device object
   // The return value is a pointer to the device object to which the
   // DO is actually attached.
   //

   pLowerDevObj = IoAttachDeviceToDeviceStack(pNewDevObj, PPdo);


   //
   // No status. Do the best we can.
   //
   ASSERT(pLowerDevObj != NULL);


   pDevExt = pNewDevObj->DeviceExtension;
   pDevExt->LowerDeviceObject = pLowerDevObj;
   pDevExt->Pdo = PPdo;



   //
   // Specify that this driver only supports buffered IO.  This basically
   // means that the IO system copies the users data to and from
   // system supplied buffers.
   //
   // Also specify that we are power pagable.
   //

   pNewDevObj->Flags |= DO_BUFFERED_IO | DO_POWER_PAGABLE;

   SerialDump(SERTRACECALLS, ("SERIAL: Leave SerialAddDevice\n"));

   return status;
}


NTSTATUS
SerialPnpDispatch(IN PDEVICE_OBJECT PDevObj, IN PIRP PIrp)

/*++

Routine Description:

    This is a dispatch routine for the IRPs that come to the driver with the
    IRP_MJ_PNP major code (plug-and-play IRPs).

Arguments:

    PDevObj - Pointer to the device object for this device

    PIrp - Pointer to the IRP for the current request

Return Value:

    The function value is the final status of the call


--*/

{
   PSERIAL_DEVICE_EXTENSION pDevExt = PDevObj->DeviceExtension;
   PDEVICE_OBJECT pLowerDevObj = pDevExt->LowerDeviceObject;
   PIO_STACK_LOCATION pIrpStack = IoGetCurrentIrpStackLocation(PIrp);
   NTSTATUS status;
   PDEVICE_CAPABILITIES pDevCaps;

   PAGED_CODE();

   if ((status = SerialIRPPrologue(PIrp, pDevExt)) != STATUS_SUCCESS) {
      SerialCompleteRequest(pDevExt, PIrp, IO_NO_INCREMENT);
      return status;
   }

   switch (pIrpStack->MinorFunction) {
   case IRP_MN_QUERY_CAPABILITIES: {
      PKEVENT pQueryCapsEvent;
      SYSTEM_POWER_STATE cap;

      SerialDump(SERPNPPOWER, ("SERIAL: Got IRP_MN_QUERY_DEVICE_CAPABILITIES "
                               "IRP\n"));

      pQueryCapsEvent = ExAllocatePool(NonPagedPool, sizeof(KEVENT));

      if (pQueryCapsEvent == NULL) {
         PIrp->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;
         SerialCompleteRequest(pDevExt, PIrp, IO_NO_INCREMENT);
         return STATUS_INSUFFICIENT_RESOURCES;
      }

      KeInitializeEvent(pQueryCapsEvent, SynchronizationEvent, FALSE);

      IoCopyCurrentIrpStackLocationToNext(PIrp);
      IoSetCompletionRoutine(PIrp, SerialSyncCompletion, pQueryCapsEvent,
                             TRUE, TRUE, TRUE);

      status = IoCallDriver(pLowerDevObj, PIrp);


      //
      // Wait for lower drivers to be done with the Irp
      //

      if (status == STATUS_PENDING) {
         KeWaitForSingleObject(pQueryCapsEvent, Executive, KernelMode, FALSE,
                               NULL);
      }

      ExFreePool(pQueryCapsEvent);

      status = PIrp->IoStatus.Status;

      if (pIrpStack->Parameters.DeviceCapabilities.Capabilities == NULL) {
         goto errQueryCaps;
      }

      //
      // Save off their power capabilities
      //

      SerialDump(SERPNPPOWER, ("SERIAL: Mapping power capabilities\n"));

      pIrpStack = IoGetCurrentIrpStackLocation(PIrp);

      pDevCaps = pIrpStack->Parameters.DeviceCapabilities.Capabilities;

      for (cap = PowerSystemSleeping1; cap < PowerSystemMaximum;
           cap++) {
         SerialDump(SERPNPPOWER, ("  SERIAL: %d: %s <--> %s\n",
                                  cap, SerSystemCapString[cap],
                                  SerDeviceCapString[pDevCaps->DeviceState[cap]]
                                  ));

         pDevExt->DeviceStateMap[cap] = pDevCaps->DeviceState[cap];
      }

      pDevExt->DeviceStateMap[PowerSystemUnspecified]
         = PowerDeviceUnspecified;

      pDevExt->DeviceStateMap[PowerSystemWorking]
        = PowerDeviceD0;

      pDevExt->SystemWake = pDevCaps->SystemWake;
      pDevExt->DeviceWake = pDevCaps->DeviceWake;

      errQueryCaps:;

      SerialCompleteRequest(pDevExt, PIrp, IO_NO_INCREMENT);
      return status;
   }

   case IRP_MN_QUERY_DEVICE_RELATIONS:
      //
      // We just pass this down -- serenum enumerates our bus for us.
      //

      SerialDump (SERPNPPOWER, ("SERIAL: Got IRP_MN_QUERY_DEVICE_RELATIONS "
                                "Irp\n"));

      switch (pIrpStack->Parameters.QueryDeviceRelations.Type) {
      case BusRelations:
         SerialDump(SERPNPPOWER, ("------- BusRelations Query\n"));
         break;

      case EjectionRelations:
         SerialDump(SERPNPPOWER, ("------- EjectionRelations Query\n"));
         break;

      case PowerRelations:
         SerialDump(SERPNPPOWER, ("------- PowerRelations Query\n"));
         break;

      case RemovalRelations:
         SerialDump(SERPNPPOWER, ("------- RemovalRelations Query\n"));
         break;

      case TargetDeviceRelation:
         SerialDump(SERPNPPOWER, ("------- TargetDeviceRelation Query\n"));
         break;

      default:
         SerialDump(SERPNPPOWER, ("------- Unknown Query\n"));
         break;
      }

      IoSkipCurrentIrpStackLocation(PIrp);
      status = SerialIoCallDriver(pDevExt, pLowerDevObj, PIrp);
      return status;


   case IRP_MN_QUERY_INTERFACE:
      SerialDump (SERPNPPOWER, ("SERIAL: Got IRP_MN_QUERY_INTERFACE Irp\n"));
      break;


   case IRP_MN_QUERY_RESOURCE_REQUIREMENTS:
      SerialDump (SERPNPPOWER, ("SERIAL: Got "
                                "IRP_MN_QUERY_RESOURCE_REQUIREMENTS Irp\n"));
      break;


   case IRP_MN_START_DEVICE: {
      PVOID startLockPtr;

      SerialDump (SERPNPPOWER, ("SERIAL: Got IRP_MN_START_DEVICE Irp\n"));

      //
      // SerialStartDevice will pass this Irp to the next driver,
      // and process it as completion so just complete it here.
      //

      SerialLockPagableSectionByHandle(SerialGlobals.PAGESER_Handle);

      //
      // We used to make sure the stack was powered up, but now it
      // is supposed to be done implicitly by start_device.
      // If that wasn't the case we would just make this call:
      //
      //   status = SerialGotoPowerState(PDevObj, pDevExt, PowerDeviceD0);
      //

      pDevExt->PowerState     = PowerDeviceD0;

      status = SerialStartDevice(PDevObj, PIrp);

      (void)SerialGotoPowerState(PDevObj, pDevExt, PowerDeviceD3);

      SerialUnlockPagableImageSection(SerialGlobals.PAGESER_Handle);


      PIrp->IoStatus.Status = status;

      SerialCompleteRequest(pDevExt, PIrp, IO_NO_INCREMENT);
      return status;
   }


   case IRP_MN_READ_CONFIG:
      SerialDump (SERPNPPOWER, ("SERIAL: Got IRP_MN_READ_CONFIG Irp\n"));
      break;


   case IRP_MN_WRITE_CONFIG:
      SerialDump (SERPNPPOWER, ("SERIAL: Got IRP_MN_WRITE_CONFIG Irp\n"));
      break;


   case IRP_MN_EJECT:
      SerialDump (SERPNPPOWER, ("SERIAL: Got IRP_MN_EJECT Irp\n"));
      break;


   case IRP_MN_SET_LOCK:
      SerialDump (SERPNPPOWER, ("SERIAL: Got IRP_MN_SET_LOCK Irp\n"));
      break;


   case IRP_MN_QUERY_ID: {
         UNICODE_STRING pIdBuf;
         PWCHAR pPnpIdStr;
         ULONG pnpIdStrLen;
         ULONG isMulti = 0;
         HANDLE pnpKey;

         SerialDump(SERPNPPOWER, ("SERIAL: Got IRP_MN_QUERY_ID Irp\n"));

         if (pIrpStack->Parameters.QueryId.IdType != BusQueryHardwareIDs
             && pIrpStack->Parameters.QueryId.IdType != BusQueryCompatibleIDs) {
            IoSkipCurrentIrpStackLocation(PIrp);
            return SerialIoCallDriver(pDevExt, pLowerDevObj, PIrp);
         }

         if (pIrpStack->Parameters.QueryId.IdType == BusQueryCompatibleIDs) {
            PIrp->IoStatus.Status = STATUS_SUCCESS;
            IoSkipCurrentIrpStackLocation(PIrp);
            return SerialIoCallDriver(pDevExt, pLowerDevObj, PIrp);
         }

         status = IoOpenDeviceRegistryKey(pDevExt->Pdo, PLUGPLAY_REGKEY_DEVICE,
                                          STANDARD_RIGHTS_WRITE, &pnpKey);

         if (!NT_SUCCESS(status)) {
            PIrp->IoStatus.Status = status;

            SerialCompleteRequest(pDevExt, PIrp, IO_NO_INCREMENT);
            return status;

         }

         status = SerialGetRegistryKeyValue (pnpKey, L"MultiportDevice",
                                             sizeof(L"MultiportDevice"),
                                             &isMulti,
                                             sizeof (ULONG));

         ZwClose(pnpKey);

         if (!NT_SUCCESS(status)) {
            PIrp->IoStatus.Status = status;
            SerialCompleteRequest(pDevExt, PIrp, IO_NO_INCREMENT);
            return status;
         }

         pPnpIdStr = isMulti ? SERIAL_PNP_MULTI_ID_STR : SERIAL_PNP_ID_STR;
         pnpIdStrLen = isMulti ? sizeof(SERIAL_PNP_MULTI_ID_STR)
            : sizeof(SERIAL_PNP_ID_STR);

         if (PIrp->IoStatus.Information != 0) {
            ULONG curStrLen;
            ULONG allocLen = 0;
            PWSTR curStr = (PWSTR)PIrp->IoStatus.Information;

            //
            // We have to walk the strings to count the amount of space to
            // reallocate
            //

            while ((curStrLen = wcslen(curStr)) != 0) {
               allocLen += curStrLen * sizeof(WCHAR) + sizeof(UNICODE_NULL);
               curStr += curStrLen + 1;
            }

            allocLen += sizeof(UNICODE_NULL);

            pIdBuf.Buffer = ExAllocatePool(PagedPool, allocLen
                                           + pnpIdStrLen
                                           + sizeof(WCHAR));

            if (pIdBuf.Buffer == NULL) {
               //
               // Clean up after other drivers since we are
               // sending the irp back up.
               //

               ExFreePool((PWSTR)PIrp->IoStatus.Information);


               PIrp->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;
               PIrp->IoStatus.Information = 0;
               SerialCompleteRequest(pDevExt, PIrp, IO_NO_INCREMENT);
               return STATUS_INSUFFICIENT_RESOURCES;
            }

            pIdBuf.MaximumLength = (USHORT)(allocLen + pnpIdStrLen);
            pIdBuf.Length = (USHORT)allocLen - sizeof(UNICODE_NULL);

            RtlZeroMemory(pIdBuf.Buffer, pIdBuf.MaximumLength + sizeof(WCHAR));
            RtlCopyMemory(pIdBuf.Buffer, (PWSTR)PIrp->IoStatus.Information,
                          allocLen);
            RtlAppendUnicodeToString(&pIdBuf, pPnpIdStr);

            //
            // Free what the previous driver allocated
            //

            ExFreePool((PWSTR)PIrp->IoStatus.Information);


         } else {

            SerialDump(SERPNPPOWER, ("SERIAL: ID is sole ID\n"));

            pIdBuf.Buffer = ExAllocatePool(PagedPool, pnpIdStrLen
                                           + sizeof(WCHAR) * 2);

            if (pIdBuf.Buffer == NULL) {
               PIrp->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;
               PIrp->IoStatus.Information = 0;
               SerialCompleteRequest(pDevExt, PIrp, IO_NO_INCREMENT);
               return STATUS_INSUFFICIENT_RESOURCES;
            }

            pIdBuf.MaximumLength  = (USHORT)pnpIdStrLen;
            pIdBuf.Length = 0;

            RtlZeroMemory(pIdBuf.Buffer, pIdBuf.MaximumLength + sizeof(WCHAR)
                          * 2);

            RtlAppendUnicodeToString(&pIdBuf, pPnpIdStr);
         }

         PIrp->IoStatus.Information = (ULONG_PTR)pIdBuf.Buffer;
         PIrp->IoStatus.Status = STATUS_SUCCESS;

         IoCopyCurrentIrpStackLocationToNext(PIrp);
         return SerialIoCallDriver(pDevExt, pLowerDevObj, PIrp);
      }

      case IRP_MN_FILTER_RESOURCE_REQUIREMENTS: {
         HANDLE pnpKey;
         PKEVENT pResFiltEvent;
         ULONG isMulti = 0;
         PIO_RESOURCE_REQUIREMENTS_LIST pReqList;
         PIO_RESOURCE_LIST pResList;
         PIO_RESOURCE_DESCRIPTOR pResDesc;
         ULONG i, j;
         ULONG reqCnt;
         ULONG gotISR;
         ULONG gotInt;
         ULONG listNum;

         SerialDump(SERPNPPOWER, ("SERIAL: Got "
                                  "IRP_MN_FILTER_RESOURCE_REQUIREMENTS Irp\n"));
         SerialDump(SERPNPPOWER, ("------- for device %x\n", pLowerDevObj));


         pResFiltEvent = ExAllocatePool(NonPagedPool, sizeof(KEVENT));

         if (pResFiltEvent == NULL) {
            PIrp->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;
            SerialCompleteRequest(pDevExt, PIrp, IO_NO_INCREMENT);
            return STATUS_INSUFFICIENT_RESOURCES;
         }

         KeInitializeEvent(pResFiltEvent, SynchronizationEvent, FALSE);

         IoCopyCurrentIrpStackLocationToNext(PIrp);
         IoSetCompletionRoutine(PIrp, SerialSyncCompletion, pResFiltEvent,
                                TRUE, TRUE, TRUE);

         status = IoCallDriver(pLowerDevObj, PIrp);


         //
         // Wait for lower drivers to be done with the Irp
         //

         if (status == STATUS_PENDING) {
            KeWaitForSingleObject (pResFiltEvent, Executive, KernelMode, FALSE,
                                   NULL);
         }

         ExFreePool(pResFiltEvent);

         if (PIrp->IoStatus.Information == 0) {
            if (pIrpStack->Parameters.FilterResourceRequirements
                .IoResourceRequirementList == 0) {
               SerialDump(SERPNPPOWER, ("------- Can't filter NULL resources!"
                                        "\n"));
               status = PIrp->IoStatus.Status;
               SerialCompleteRequest(pDevExt, PIrp, IO_NO_INCREMENT);
               return status;
            }

            PIrp->IoStatus.Information = (ULONG_PTR)pIrpStack->Parameters
                                        .FilterResourceRequirements
                                        .IoResourceRequirementList;

         }

         status = IoOpenDeviceRegistryKey(pDevExt->Pdo, PLUGPLAY_REGKEY_DEVICE,
                                          STANDARD_RIGHTS_WRITE, &pnpKey);

         if (!NT_SUCCESS(status)) {
            PIrp->IoStatus.Status = status;

            SerialCompleteRequest(pDevExt, PIrp, IO_NO_INCREMENT);
            return status;

         }

         //
         // No matter what we add our filter if we can and return success.
         //

         status = SerialGetRegistryKeyValue (pnpKey, L"MultiportDevice",
                                             sizeof(L"MultiportDevice"),
                                             &isMulti,
                                             sizeof (ULONG));

         ZwClose(pnpKey);


         //
         // Force ISR ports in IO_RES_REQ_LIST to shared status
         // Force interrupts to shared status
         //

         //
         // We will only process the first list -- multiport boards
         // should not have alternative resources
         //

         pReqList = (PIO_RESOURCE_REQUIREMENTS_LIST)PIrp->IoStatus.Information;
         pResList = &pReqList->List[0];

         SerialDump(SERPNPPOWER, ("------- List has %x lists "
                                  "(including alternatives)\n",
                                  pReqList->AlternativeLists));

         for (listNum = 0; listNum < (pReqList->AlternativeLists);
              listNum++) {
#if defined(NEC_98)
            for (j = 0; (j < pResList->Count); j++) {
               pResDesc = &pResList->Descriptors[j];

               if (isMulti && pResDesc->Type == CmResourceTypePort) {
                  pResDesc->ShareDisposition = CmResourceShareShared;
                  SerialDump(SERPNPPOWER, ("------- Sharing I/O port for "
                                           "device %x\n", pLowerDevObj));
               }
            }
#else
            gotISR = 0;
            gotInt = 0;

            SerialDump(SERPNPPOWER, ("------- List has %x resources in it\n",
                                  pResList->Count));

            for (j = 0; (j < pResList->Count); j++) {
               pResDesc = &pResList->Descriptors[j];

               switch (pResDesc->Type) {
               case CmResourceTypePort:
                  if (isMulti
                      && (pResDesc->u.Port.Length == SERIAL_STATUS_LENGTH)
                      && !gotISR) {
                     gotISR = 1;
                     pResDesc->ShareDisposition = CmResourceShareShared;
                     SerialDump(SERPNPPOWER, ("------- Sharing I/O port for "
                                              "device %x\n", pLowerDevObj));
                  }
                  break;

               case CmResourceTypeInterrupt:
                  if (!gotInt) {
                     gotInt = 1;
                     if (pResDesc->ShareDisposition != CmResourceShareShared) {
                        pResDesc->ShareDisposition = CmResourceShareShared;
                        SerialDump(SERPNPPOWER, ("------- Sharing interrupt "
                                                 "for device %x\n",
                                                 pLowerDevObj));
                     } else {
                        pDevExt->InterruptShareable = TRUE;
                        SerialDump(SERPNPPOWER, ("------- Globally sharing "
                                                 " interrupt for device %x\n",
                                                 pLowerDevObj));
                     }
                  }
                  break;

               default:
                  break;
               }

               //
               // If we found what we need, we can break out of the loop
               //

               if ((isMulti && gotInt && gotISR) || (!isMulti && gotInt)) {
                  break;
               }
            }

            pResList = (PIO_RESOURCE_LIST)((PUCHAR)pResList
                                           + sizeof(IO_RESOURCE_LIST)
                                           + sizeof(IO_RESOURCE_DESCRIPTOR)
                                           * (pResList->Count - 1));
#endif
         }



         PIrp->IoStatus.Status = STATUS_SUCCESS;
         SerialCompleteRequest(pDevExt, PIrp, IO_NO_INCREMENT);
         return STATUS_SUCCESS;
      }

   case IRP_MN_QUERY_PNP_DEVICE_STATE:
      {
         if (pDevExt->Flags & SERIAL_FLAGS_BROKENHW) {
            (PNP_DEVICE_STATE)PIrp->IoStatus.Information |= PNP_DEVICE_FAILED;

            PIrp->IoStatus.Status = STATUS_SUCCESS;
         }

         IoCopyCurrentIrpStackLocationToNext(PIrp);
         return SerialIoCallDriver(pDevExt, pLowerDevObj, PIrp);
      }

   case IRP_MN_STOP_DEVICE:
      {
         ULONG pendingIRPs;
         KIRQL oldIrql;

         SerialDump(SERPNPPOWER, ("SERIAL: Got IRP_MN_STOP_DEVICE Irp\n"));
         SerialDump(SERPNPPOWER, ("------- for device %x\n", pLowerDevObj));



         ASSERT(!pDevExt->PortOnAMultiportCard);


         SerialSetFlags(pDevExt, SERIAL_FLAGS_STOPPED);
         SerialSetAccept(pDevExt,SERIAL_PNPACCEPT_STOPPED);
         SerialClearAccept(pDevExt, SERIAL_PNPACCEPT_STOPPING);

         pDevExt->PNPState = SERIAL_PNP_STOPPING;

         //
         // From this point on all non-PNP IRP's will be queued
         //

         //
         // Decrement for entry here
         //

         InterlockedDecrement(&pDevExt->PendingIRPCnt);

         //
         // Decrement for stopping
         //

         pendingIRPs = InterlockedDecrement(&pDevExt->PendingIRPCnt);

         if (pendingIRPs) {
            KeWaitForSingleObject(&pDevExt->PendingIRPEvent, Executive,
                                  KernelMode, FALSE, NULL);
         }

         //
         // Re-increment the count for later
         //

         InterlockedIncrement(&pDevExt->PendingIRPCnt);

         //
         // We need to free resources...basically this is a remove
         // without the detach from the stack.
         //

         if (pDevExt->Flags & SERIAL_FLAGS_STARTED) {
            SerialReleaseResources(pDevExt);
         }

         //
         // Pass the irp down
         //

         PIrp->IoStatus.Status = STATUS_SUCCESS;
         IoSkipCurrentIrpStackLocation(PIrp);

         return IoCallDriver(pLowerDevObj, PIrp);
      }

   case IRP_MN_QUERY_STOP_DEVICE:
      {
         KIRQL oldIrql;

         SerialDump(SERPNPPOWER, ("SERIAL: Got IRP_MN_QUERY_STOP_DEVICE Irp\n")
                    );
         SerialDump(SERPNPPOWER, ("------- for device %x\n", pLowerDevObj));

         //
         // See if we should succeed a stop query
         //


         if (pDevExt->PortOnAMultiportCard) {
            PIrp->IoStatus.Status = STATUS_NOT_SUPPORTED;
            SerialDump(SERPNPPOWER, ("------- failing; multiport node\n"));
            SerialCompleteRequest(pDevExt, PIrp, IO_NO_INCREMENT);
            return STATUS_NOT_SUPPORTED;
         }

         //
         // If the device hasn't started yet, we ignore this request
         // and just pass it down.
         //

         if (pDevExt->PNPState != SERIAL_PNP_STARTED) {
            IoSkipCurrentIrpStackLocation(PIrp);
            return SerialIoCallDriver(pDevExt, pLowerDevObj, PIrp);
         }

         //
         // Lock around the open status
         //

         ExAcquireFastMutex(&pDevExt->OpenMutex);

         if (pDevExt->DeviceIsOpened) {
            ExReleaseFastMutex(&pDevExt->OpenMutex);
            PIrp->IoStatus.Status = STATUS_DEVICE_BUSY;
            SerialDump(SERPNPPOWER, ("------- failing; device open\n"));
            SerialCompleteRequest(pDevExt, PIrp, IO_NO_INCREMENT);
            return STATUS_DEVICE_BUSY;
         }

         pDevExt->PNPState = SERIAL_PNP_QSTOP;

         SerialSetAccept(pDevExt, SERIAL_PNPACCEPT_STOPPING);
         //
         // Unlock around the open status
         //

         ExReleaseFastMutex(&pDevExt->OpenMutex);

         PIrp->IoStatus.Status = STATUS_SUCCESS;
         IoCopyCurrentIrpStackLocationToNext(PIrp);
         return SerialIoCallDriver(pDevExt, pLowerDevObj, PIrp);
      }

   case IRP_MN_CANCEL_STOP_DEVICE:
      SerialDump(SERPNPPOWER, ("SERIAL: Got "
                               "IRP_MN_CANCEL_STOP_DEVICE Irp\n"));
      SerialDump(SERPNPPOWER, ("------- for device %x\n", pLowerDevObj));

      if (pDevExt->PNPState == SERIAL_PNP_QSTOP) {
         //
         // Restore the device state
         //

         pDevExt->PNPState = SERIAL_PNP_STARTED;
         SerialClearAccept(pDevExt, SERIAL_PNPACCEPT_STOPPING);
      }

      PIrp->IoStatus.Status = STATUS_SUCCESS;
      IoCopyCurrentIrpStackLocationToNext(PIrp);
      return SerialIoCallDriver(pDevExt, pLowerDevObj, PIrp);

   case IRP_MN_CANCEL_REMOVE_DEVICE:

      SerialDump(SERPNPPOWER, ("SERIAL: Got "
                               "IRP_MN_CANCEL_REMOVE_DEVICE Irp\n"));
      SerialDump(SERPNPPOWER, ("------- for device %x\n", pLowerDevObj));

      //
      // Restore the device state
      //

      pDevExt->PNPState = SERIAL_PNP_STARTED;
      SerialClearAccept(pDevExt, SERIAL_PNPACCEPT_REMOVING);

      PIrp->IoStatus.Status = STATUS_SUCCESS;
      IoCopyCurrentIrpStackLocationToNext(PIrp);
      return SerialIoCallDriver(pDevExt, pLowerDevObj, PIrp);

   case IRP_MN_QUERY_REMOVE_DEVICE:
      {
         KIRQL oldIrql;
         SerialDump(SERPNPPOWER, ("SERIAL: Got "
                                  "IRP_MN_QUERY_REMOVE_DEVICE Irp\n"));
         SerialDump(SERPNPPOWER, ("------- for device %x\n", pLowerDevObj));

         ExAcquireFastMutex(&pDevExt->OpenMutex);

         //
         // See if we should succeed a remove query
         //

         if (pDevExt->DeviceIsOpened) {
            ExReleaseFastMutex(&pDevExt->OpenMutex);
            PIrp->IoStatus.Status = STATUS_DEVICE_BUSY;
            SerialDump(SERPNPPOWER, ("------- failing; device open\n"));
            SerialCompleteRequest(pDevExt, PIrp, IO_NO_INCREMENT);
            return STATUS_DEVICE_BUSY;
         }

         pDevExt->PNPState = SERIAL_PNP_QREMOVE;
         SerialSetAccept(pDevExt, SERIAL_PNPACCEPT_REMOVING);
         ExReleaseFastMutex(&pDevExt->OpenMutex);

         PIrp->IoStatus.Status = STATUS_SUCCESS;
         IoCopyCurrentIrpStackLocationToNext(PIrp);
         return SerialIoCallDriver(pDevExt, pLowerDevObj, PIrp);
      }

   case IRP_MN_SURPRISE_REMOVAL:
      {
         ULONG pendingIRPs;
         KIRQL oldIrql;

         SerialDump(SERPNPPOWER, ("SERIAL: Got IRP_MN_SURPRISE_REMOVAL Irp\n"));
         SerialDump(SERPNPPOWER, ("------- for device %x\n", pLowerDevObj));

         //
         // Prevent any new I/O to the device
         //

         SerialSetAccept(pDevExt, SERIAL_PNPACCEPT_SURPRISE_REMOVING);

         //
         // Dismiss all pending requests
         //

         SerialKillPendingIrps(PDevObj);

         //
         // Wait for any pending requests we raced on.
         //

         //
         // Decrement once for ourselves
         //

         InterlockedDecrement(&pDevExt->PendingIRPCnt);

         //
         // Decrement for the remove
         //

         pendingIRPs = InterlockedDecrement(&pDevExt->PendingIRPCnt);

         if (pendingIRPs) {
            KeWaitForSingleObject(&pDevExt->PendingIRPEvent, Executive,
                                  KernelMode, FALSE, NULL);
         }

         //
         // Reset for subsequent remove
         //

         InterlockedIncrement(&pDevExt->PendingIRPCnt);

         //
         // Remove any external interfaces and release resources
         //

         SerialDisableInterfacesResources(PDevObj, FALSE);

         PIrp->IoStatus.Status = STATUS_SUCCESS;
         IoSkipCurrentIrpStackLocation(PIrp);

         return SerialIoCallDriver(pDevExt, pLowerDevObj, PIrp);
      }

   case IRP_MN_REMOVE_DEVICE:

      {
         ULONG pendingIRPs;
         KIRQL oldIrql;

         SerialDump(SERPNPPOWER, ("SERIAL: Got IRP_MN_REMOVE_DEVICE Irp\n"));
         SerialDump(SERPNPPOWER, ("------- for device %x\n", pLowerDevObj));

         //
         // If we get this, we have to remove
         //

         //
         // Mark as not accepting requests
         //

         SerialSetAccept(pDevExt, SERIAL_PNPACCEPT_REMOVING);

         //
         // Complete all pending requests
         //

         SerialKillPendingIrps(PDevObj);

         //
         // Decrement for this Irp itself
         //

         InterlockedDecrement(&pDevExt->PendingIRPCnt);

         //
         // Wait for any pending requests we raced on -- this decrement
         // is for our "placeholder".
         //

         pendingIRPs = InterlockedDecrement(&pDevExt->PendingIRPCnt);

         if (pendingIRPs) {
            KeWaitForSingleObject(&pDevExt->PendingIRPEvent, Executive,
                                  KernelMode, FALSE, NULL);
         }

         //
         // Remove us
         //

         SerialRemoveDevObj(PDevObj);


         //
         // Pass the irp down
         //

         PIrp->IoStatus.Status = STATUS_SUCCESS;

         IoCopyCurrentIrpStackLocationToNext(PIrp);

         //
         // We do decrement here because we incremented on entry here.
         //

         IoCallDriver(pLowerDevObj, PIrp);


         return STATUS_SUCCESS;
      }

   default:
      break;



   }   // switch (pIrpStack->MinorFunction)

   //
   // Pass to driver beneath us
   //

   IoSkipCurrentIrpStackLocation(PIrp);
   status = SerialIoCallDriver(pDevExt, pLowerDevObj, PIrp);
   return status;
}



UINT32
SerialReportMaxBaudRate(ULONG Bauds)
/*++

Routine Description:

    This routine returns the max baud rate given a selection of rates

Arguments:

   Bauds  -  Bit-encoded list of supported bauds


  Return Value:

   The max baud rate listed in Bauds

--*/
{
   PAGED_CODE();

   if (Bauds & SERIAL_BAUD_128K) {
      return (128U * 1024U);
   }

   if (Bauds & SERIAL_BAUD_115200) {
      return 115200U;
   }

   if (Bauds & SERIAL_BAUD_56K) {
      return (56U * 1024U);
   }

   if (Bauds & SERIAL_BAUD_57600) {
      return 57600U;
   }

   if (Bauds & SERIAL_BAUD_38400) {
      return 38400U;
   }

   if (Bauds & SERIAL_BAUD_19200) {
      return 19200U;
   }

   if (Bauds & SERIAL_BAUD_14400) {
      return 14400U;
   }

   if (Bauds & SERIAL_BAUD_9600) {
      return 9600U;
   }

   if (Bauds & SERIAL_BAUD_7200) {
      return 7200U;
   }

   if (Bauds & SERIAL_BAUD_4800) {
      return 4800U;
   }

   if (Bauds & SERIAL_BAUD_2400) {
      return 2400U;
   }

   if (Bauds & SERIAL_BAUD_1800) {
      return 1800U;
   }

   if (Bauds & SERIAL_BAUD_1200) {
      return 1200U;
   }

   if (Bauds & SERIAL_BAUD_600) {
      return 600U;
   }

   if (Bauds & SERIAL_BAUD_300) {
      return 300U;
   }

   if (Bauds & SERIAL_BAUD_150) {
      return 150U;
   }

   if (Bauds & SERIAL_BAUD_134_5) {
      return 135U; // Close enough
   }

   if (Bauds & SERIAL_BAUD_110) {
      return 110U;
   }

   if (Bauds & SERIAL_BAUD_075) {
      return 75U;
   }

   //
   // We're in bad shape
   //

   return 0;
}



NTSTATUS
SerialFinishStartDevice(IN PDEVICE_OBJECT PDevObj,
                        IN PCM_RESOURCE_LIST PResList,
                        IN PCM_RESOURCE_LIST PTrResList,
                        PSERIAL_USER_DATA PUserData)
/*++

Routine Description:

    This routine does serial-specific procedures to start a device.  It
    does this either for a legacy device detected by its registry entries,
    or for a PnP device after the start IRP has been sent down the stack.


Arguments:

   PDevObj    -  Pointer to the devobj that is starting

   PResList   -  Pointer to the untranslated resources needed by this device

   PTrResList -  Pointer to the translated resources needed by this device

   PUserData  -  Pointer to the user-specified resources/attributes


  Return Value:

    STATUS_SUCCESS on success, something else appropriate on failure


--*/

{
   PSERIAL_DEVICE_EXTENSION pDevExt = PDevObj->DeviceExtension;
#if defined(NEC_98)
   //
   // This argument use at MACRO only.
   //
   PSERIAL_DEVICE_EXTENSION Extension = PDevObj->DeviceExtension;
#else
#endif //defined(NEC_98)
   NTSTATUS status;
   PCONFIG_DATA pConfig;
   HANDLE pnpKey;
   ULONG one = 1;
   BOOLEAN allocedUserData = FALSE;

   PAGED_CODE();

   //
   // See if this is a restart, and if so don't reallocate the world
   //

   if ((pDevExt->Flags & SERIAL_FLAGS_STOPPED)
       && (pDevExt->Flags & SERIAL_FLAGS_STARTED)) {
      SerialClearFlags(pDevExt, SERIAL_FLAGS_STOPPED);

      pDevExt->PNPState = SERIAL_PNP_RESTARTING;

      //
      // Re-init resource-related things in the extension
      //

      pDevExt->TopLevelOurIsr = NULL;
      pDevExt->TopLevelOurIsrContext = NULL;

      pDevExt->OriginalController = SerialPhysicalZero;
      pDevExt->OriginalInterruptStatus = SerialPhysicalZero;

      pDevExt->OurIsr = NULL;
      pDevExt->OurIsrContext = NULL;

      pDevExt->Controller = NULL;
      pDevExt->InterruptStatus = NULL;
      pDevExt->Interrupt = NULL;

      pDevExt->SpanOfController = 0;
      pDevExt->SpanOfInterruptStatus = 0;

      pDevExt->Vector = 0;
      pDevExt->Irql = 0;
      pDevExt->OriginalVector = 0;
      pDevExt->OriginalIrql = 0;
      pDevExt->AddressSpace = 0;
      pDevExt->BusNumber = 0;
      pDevExt->InterfaceType = 0;

      pDevExt->CIsrSw = NULL;

      ASSERT(PUserData == NULL);

      PUserData = ExAllocatePool(PagedPool, sizeof(SERIAL_USER_DATA));

      if (PUserData == NULL) {
         return STATUS_INSUFFICIENT_RESOURCES;
      }

      allocedUserData = TRUE;

      RtlZeroMemory(PUserData, sizeof(SERIAL_USER_DATA));

      PUserData->DisablePort = FALSE;
      PUserData->UserClockRate = pDevExt->ClockRate;
      PUserData->TxFIFO = pDevExt->TxFifoAmount;
      PUserData->PermitShareDefault = pDevExt->PermitShare;


      //
      // Map betweeen trigger and amount
      //

      switch (pDevExt->RxFifoTrigger) {
      case SERIAL_1_BYTE_HIGH_WATER:
         PUserData->RxFIFO = 1;
         break;

      case SERIAL_4_BYTE_HIGH_WATER:
         PUserData->RxFIFO = 4;
         break;

      case SERIAL_8_BYTE_HIGH_WATER:
         PUserData->RxFIFO = 8;
         break;

      case SERIAL_14_BYTE_HIGH_WATER:
         PUserData->RxFIFO = 14;
         break;

      default:
         PUserData->RxFIFO = 1;
      }
   } else {
      //
      // Mark as serenumerable -- toss status because we can
      // still start without this key.
      //

      status = IoOpenDeviceRegistryKey(pDevExt->Pdo,
                                       PLUGPLAY_REGKEY_DEVICE,
                                       STANDARD_RIGHTS_WRITE, &pnpKey);

      if (NT_SUCCESS(status)) {
         ULONG powerPolicy = 0;

         //
         // Find out if we own power policy
         //

         SerialGetRegistryKeyValue(pnpKey, L"SerialRelinquishPowerPolicy",
                                   sizeof(L"SerialRelinquishPowerPolicy"),
                                   &powerPolicy, sizeof(ULONG));

         pDevExt->OwnsPowerPolicy = powerPolicy ? FALSE : TRUE;


         ZwClose(pnpKey);
      }
   }

   //
   // Allocate the config record.
   //

   pConfig = ExAllocatePool (PagedPool, sizeof(CONFIG_DATA));

   if (pConfig == NULL) {

      SerialLogError(pDevExt->DriverObject, NULL, SerialPhysicalZero,
                     SerialPhysicalZero, 0, 0, 0, 37, STATUS_SUCCESS,
                     SERIAL_INSUFFICIENT_RESOURCES, 0, NULL, 0, NULL);

      SerialDump(SERERRORS, ("SERIAL: Couldn't allocate memory for the\n"
                             "------  user configuration record\n"));

      status = STATUS_INSUFFICIENT_RESOURCES;
      goto SerialFinishStartDeviceError;
   }

   RtlZeroMemory(pConfig, sizeof(CONFIG_DATA));


   //
   // Get the configuration info for the device.
   //

   status = SerialGetPortInfo(PDevObj, PResList, PTrResList, pConfig,
                              PUserData);

   if (!NT_SUCCESS(status)) {
      goto SerialFinishStartDeviceError;
   }


   //
   // See if we are in the proper power state.
   //



   if (pDevExt->PowerState != PowerDeviceD0) {

      status = SerialGotoPowerState(pDevExt->Pdo, pDevExt, PowerDeviceD0);

      if (!NT_SUCCESS(status)) {
         goto SerialFinishStartDeviceError;
      }
   }

   //
   // Find and initialize the controller
   //

   status = SerialFindInitController(PDevObj, pConfig);

   if (!NT_SUCCESS(status)) {
      goto SerialFinishStartDeviceError;
   }


   //
   // The hardware that is set up to NOT interrupt, connect an interrupt.
   //

   //
   // If a device doesn't already have an interrupt and it has an isr then
   // we attempt to connect to the interrupt if it is not shareing with other
   // serial devices.  If we fail to connect to an  interrupt we will delete
   // this device.
   //

   if (pDevExt != NULL) {
      SerialDump(SERDIAG5, ("SERIAL: pDevExt: Interrupt %x\n"
                            "-------               OurIsr %x\n",
                            pDevExt->Interrupt, pDevExt->OurIsr));
   } else {
      SerialDump(SERERRORS, ("SERIAL: SerialFinishStartDevice got NULL "
                           "pDevExt\n"));
   }

   if ((!pDevExt->Interrupt) && (pDevExt->OurIsr)) {

      SerialDump(
                SERDIAG5,
                ("SERIAL: About to connect to interrupt for port %wZ\n"
                 "------- address of extension is %x\n",
                 &pDevExt->DeviceName, pDevExt)
                );

      SerialDump(SERDIAG5, ("SERIAL: IoConnectInterrupt Args:\n"
                                "------- Interrupt           %x\n"
                                "------- OurIsr              %x\n"
                                "------- OurIsrContext       %x\n"
                                "------- NULL\n"
                                "------- Vector              %x\n"
                                "------- Irql                %x\n"
                                "------- InterruptMode       %x\n"
                                "------- InterruptShareable  %x\n"
                                "------- ProcessorAffinity   %x\n"
                                "------- FALSE\n",
                                &pDevExt->Interrupt,
                                SerialCIsrSw,
                                pDevExt->CIsrSw,
                                pDevExt->Vector,
                                pDevExt->Irql,
                                pConfig->InterruptMode,
                                pDevExt->InterruptShareable,
                                pConfig->Affinity
                               ));

      //
      // Do a just in time construction of the ISR switch.
      //

      pDevExt->CIsrSw->IsrFunc = pDevExt->OurIsr;
      pDevExt->CIsrSw->Context = pDevExt->OurIsrContext;

      status = IoConnectInterrupt(&pDevExt->Interrupt, SerialCIsrSw,
                                  pDevExt->CIsrSw, NULL,
                                  pDevExt->Vector, pDevExt->Irql,
                                  pDevExt->Irql,
                                  pConfig->InterruptMode,
                                  pDevExt->InterruptShareable,
                                  pConfig->Affinity, FALSE);

      if (!NT_SUCCESS(status)) {

         //
         // Hmmm, how'd that happen?  Somebody either
         // didn't report their resources, or they
         // sneaked in since the last time I looked.
         //
         // Oh well,  delete this device.
         //

         SerialDump(SERERRORS, ("SERIAL: Couldn't connect to interrupt for "
                                "%wZ\n", &pDevExt->DeviceName));

         SerialDump(SERERRORS, ("SERIAL: IoConnectInterrupt Args:\n"
                                "------- Interrupt           %x\n"
                                "------- OurIsr              %x\n"
                                "------- OurIsrContext       %x\n"
                                "------- NULL\n"
                                "------- Vector              %x\n"
                                "------- Irql                %x\n"
                                "------- InterruptMode       %x\n"
                                "------- InterruptShareable  %x\n"
                                "------- ProcessorAffinity   %x\n"
                                "------- FALSE\n",
                                &pDevExt->Interrupt,
                                SerialCIsrSw,
                                pDevExt->CIsrSw,
                                pDevExt->Vector,
                                pDevExt->Irql,
                                pConfig->InterruptMode,
                                pDevExt->InterruptShareable,
                                pConfig->Affinity
                               ));



         SerialLogError(PDevObj->DriverObject, PDevObj,
                        pDevExt->OriginalController,
                        SerialPhysicalZero, 0, 0, 0, 1, status,
                        SERIAL_UNREPORTED_IRQL_CONFLICT,
                        pDevExt->DeviceName.Length + sizeof(WCHAR),
                        pDevExt->DeviceName.Buffer, 0, NULL);

         status = SERIAL_UNREPORTED_IRQL_CONFLICT;
         goto SerialFinishStartDeviceError;

      }
   }

   SerialDump(SERDIAG5, ("Connected interrupt %08X\n", pDevExt->Interrupt));


   //
   // Add the PDevObj to the master list
   //

   InsertTailList(&SerialGlobals.AllDevObjs, &pDevExt->AllDevObjs);


   //
   // Reset the device.
   //


   //
   // While the device isn't open, disable all interrupts.
   //

   DISABLE_ALL_INTERRUPTS (pDevExt->Controller);


   if (pDevExt->Jensen) {

      WRITE_MODEM_CONTROL(
                         pDevExt->Controller,
                         (UCHAR)SERIAL_MCR_OUT2
                         );

   } else {

      WRITE_MODEM_CONTROL(
                         pDevExt->Controller,
                         (UCHAR)0
                         );

   }

   //
   // This should set up everything as it should be when
   // a device is to be opened.  We do need to lower the
   // modem lines, and disable the recalcitrant fifo
   // so that it will show up if the user boots to dos.
   //

   KeSynchronizeExecution(
                         pDevExt->Interrupt,
                         SerialReset,
                         pDevExt
                         );

   KeSynchronizeExecution( //Disables the fifo.
                           pDevExt->Interrupt,
                           SerialMarkClose,
                           pDevExt
                         );

   KeSynchronizeExecution(
                         pDevExt->Interrupt,
                         SerialClrRTS,
                         pDevExt
                         );

   KeSynchronizeExecution(
                         pDevExt->Interrupt,
                         SerialClrDTR,
                         pDevExt
                         );

   if (pDevExt->PNPState == SERIAL_PNP_ADDED ) {
      //
      // Do the external naming now that the device is accessible.
      //

      status = SerialDoExternalNaming(pDevExt, pDevExt->DeviceObject->
                                      DriverObject);


      if (!NT_SUCCESS(status)) {
         SerialDump (SERERRORS,("SERIAL: External Naming Failed - Status %x\n",
                                status));

         //
         // Allow the device to start anyhow
         //

         status = STATUS_SUCCESS;
      }
   } else {
      SerialDump(SERPNPPOWER, ("Not doing external naming -- state is %x\n",
                               pDevExt->PNPState));
   }

SerialFinishStartDeviceError:;

   if (!NT_SUCCESS (status)) {

      SerialDump(SERDIAG1,("SERIAL: Cleaning up failed start\n"));

      //
      // Resources created by this routine will be cleaned up by the remove
      //

      if (pDevExt->PNPState == SERIAL_PNP_RESTARTING) {
         //
         // Kill all that lives and breathes -- we'll clean up the
         // rest on the impending remove
         //

         SerialKillPendingIrps(PDevObj);

         //
         // In fact, pretend we're removing so we don't take any
         // more irps
         //

         SerialSetAccept(pDevExt, SERIAL_PNPACCEPT_REMOVING);
         SerialClearFlags(pDevExt, SERIAL_FLAGS_STARTED);
      }
   } else { // SUCCESS

      //
      // Fill in WMI hardware data
      //

      pDevExt->WmiHwData.IrqNumber = pDevExt->Irql;
      pDevExt->WmiHwData.IrqLevel = pDevExt->Irql;
      pDevExt->WmiHwData.IrqVector = pDevExt->Vector;
      pDevExt->WmiHwData.IrqAffinityMask = pConfig->Affinity;
      pDevExt->WmiHwData.InterruptType = pConfig->InterruptMode == Latched
         ? SERIAL_WMI_INTTYPE_LATCHED : SERIAL_WMI_INTTYPE_LEVEL;
      pDevExt->WmiHwData.BaseIOAddress = (ULONG_PTR)pDevExt->Controller;

      //
      // Fill in WMI device state data (as defaults)
      //

      pDevExt->WmiCommData.BaudRate = pDevExt->CurrentBaud;
      pDevExt->WmiCommData.BitsPerByte = (pDevExt->LineControl & 0x03) + 5;
      pDevExt->WmiCommData.ParityCheckEnable = (pDevExt->LineControl & 0x08)
         ? TRUE : FALSE;

      switch (pDevExt->LineControl & SERIAL_PARITY_MASK) {
      case SERIAL_NONE_PARITY:
         pDevExt->WmiCommData.Parity = SERIAL_WMI_PARITY_NONE;
         break;

      case SERIAL_ODD_PARITY:
         pDevExt->WmiCommData.Parity = SERIAL_WMI_PARITY_ODD;
         break;

      case SERIAL_EVEN_PARITY:
         pDevExt->WmiCommData.Parity = SERIAL_WMI_PARITY_EVEN;
         break;

#if defined(NEC_98)
      //
      // COM1 of PC-9800 series is not support MarkParity and SpaceParity.
      //
#else
      case SERIAL_MARK_PARITY:
         pDevExt->WmiCommData.Parity = SERIAL_WMI_PARITY_MARK;
         break;

      case SERIAL_SPACE_PARITY:
         pDevExt->WmiCommData.Parity = SERIAL_WMI_PARITY_SPACE;
         break;
#endif //defined(NEC_98)

      default:
         ASSERTMSG(0, "SERIAL: Illegal Parity setting for WMI");
         pDevExt->WmiCommData.Parity = SERIAL_WMI_PARITY_NONE;
         break;
      }

      pDevExt->WmiCommData.StopBits = pDevExt->LineControl & SERIAL_STOP_MASK
         ? (pDevExt->WmiCommData.BitsPerByte == 5 ? SERIAL_WMI_STOP_1_5
            : SERIAL_WMI_STOP_2) : SERIAL_WMI_STOP_1;
      pDevExt->WmiCommData.XoffCharacter = pDevExt->SpecialChars.XoffChar;
      pDevExt->WmiCommData.XoffXmitThreshold = pDevExt->HandFlow.XoffLimit;
      pDevExt->WmiCommData.XonCharacter = pDevExt->SpecialChars.XonChar;
      pDevExt->WmiCommData.XonXmitThreshold = pDevExt->HandFlow.XonLimit;
      pDevExt->WmiCommData.MaximumBaudRate
         = SerialReportMaxBaudRate(pDevExt->SupportedBauds);
      pDevExt->WmiCommData.MaximumOutputBufferSize = (UINT32)((ULONG)-1);
      pDevExt->WmiCommData.MaximumInputBufferSize = (UINT32)((ULONG)-1);
      pDevExt->WmiCommData.Support16BitMode = FALSE;
      pDevExt->WmiCommData.SupportDTRDSR = TRUE;
      pDevExt->WmiCommData.SupportIntervalTimeouts = TRUE;
      pDevExt->WmiCommData.SupportParityCheck = TRUE;
      pDevExt->WmiCommData.SupportRTSCTS = TRUE;
      pDevExt->WmiCommData.SupportXonXoff = TRUE;
      pDevExt->WmiCommData.SettableBaudRate = TRUE;
      pDevExt->WmiCommData.SettableDataBits = TRUE;
      pDevExt->WmiCommData.SettableFlowControl = TRUE;
      pDevExt->WmiCommData.SettableParity = TRUE;
      pDevExt->WmiCommData.SettableParityCheck = TRUE;
      pDevExt->WmiCommData.SettableStopBits = TRUE;
      pDevExt->WmiCommData.IsBusy = FALSE;

      //
      // Fill in wmi perf data (all zero's)
      //

      RtlZeroMemory(&pDevExt->WmiPerfData, sizeof(pDevExt->WmiPerfData));


      if (pDevExt->PNPState == SERIAL_PNP_ADDED) {
         PULONG countSoFar = &IoGetConfigurationInformation()->SerialCount;
         (*countSoFar)++;

         //
         // Register for WMI
         //

         pDevExt->WmiLibInfo.GuidCount = sizeof(SerialWmiGuidList) /
                                              sizeof(WMIGUIDREGINFO);
         pDevExt->WmiLibInfo.GuidList = SerialWmiGuidList;
         ASSERT (pDevExt->WmiLibInfo.GuidCount == SERIAL_WMI_GUID_LIST_SIZE);

         pDevExt->WmiLibInfo.QueryWmiRegInfo = SerialQueryWmiRegInfo;
         pDevExt->WmiLibInfo.QueryWmiDataBlock = SerialQueryWmiDataBlock;
         pDevExt->WmiLibInfo.SetWmiDataBlock = SerialSetWmiDataBlock;
         pDevExt->WmiLibInfo.SetWmiDataItem = SerialSetWmiDataItem;
         pDevExt->WmiLibInfo.ExecuteWmiMethod = NULL;
         pDevExt->WmiLibInfo.WmiFunctionControl = NULL;

         IoWMIRegistrationControl(PDevObj, WMIREG_ACTION_REGISTER);

      }

      if (pDevExt->PNPState == SERIAL_PNP_RESTARTING) {
         //
         // Release the stalled IRP's
         //

         SerialUnstallIrps(pDevExt);
      }

      pDevExt->PNPState = SERIAL_PNP_STARTED;
      SerialClearAccept(pDevExt, ~SERIAL_PNPACCEPT_OK);
      SerialSetFlags(pDevExt, SERIAL_FLAGS_STARTED);

   }

   if (pConfig) {
      ExFreePool (pConfig);
   }

   if ((PUserData != NULL) && allocedUserData) {
      ExFreePool(PUserData);
   }

   SerialDump (SERTRACECALLS, ("SERIAL: leaving SerialFinishStartDevice\n"));

   return status;
}



NTSTATUS
SerialStartDevice(IN PDEVICE_OBJECT PDevObj, IN PIRP PIrp)

/*++

Routine Description:

    This routine first passes the start device Irp down the stack then
    it picks up the resources for the device, ititializes, puts it on any
    appropriate lists (i.e shared interrupt or interrupt status) and
    connects the interrupt.

Arguments:

    PDevObj - Pointer to the device object for this device

    PIrp - Pointer to the IRP for the current request

Return Value:

    Return status


--*/

{
   PIO_STACK_LOCATION pIrpStack = IoGetCurrentIrpStackLocation(PIrp);
   NTSTATUS status = STATUS_NOT_IMPLEMENTED;
   PSERIAL_DEVICE_EXTENSION pDevExt = PDevObj->DeviceExtension;
   PDEVICE_OBJECT pLowerDevObj = pDevExt->LowerDeviceObject;

   PAGED_CODE();

   SerialDump (SERTRACECALLS, ("SERIAL: entering SerialStartDevice\n"));


   //
   // Pass this down to the next device object
   //

   KeInitializeEvent(&pDevExt->SerialStartEvent, SynchronizationEvent,
                     FALSE);

   IoCopyCurrentIrpStackLocationToNext(PIrp);
   IoSetCompletionRoutine(PIrp, SerialSyncCompletion,
                          &pDevExt->SerialStartEvent, TRUE, TRUE, TRUE);

   status = IoCallDriver(pLowerDevObj, PIrp);


   //
   // Wait for lower drivers to be done with the Irp
   //

   if (status == STATUS_PENDING) {
      KeWaitForSingleObject (&pDevExt->SerialStartEvent, Executive, KernelMode,
                             FALSE, NULL);

      status = PIrp->IoStatus.Status;
   }

   if (!NT_SUCCESS(status)) {
      SerialDump (SERERRORS, ("SERIAL: error with IoCallDriver %x\n", status));
      return status;
   }


   //
   // Do the serial specific items to start the device
   //

   status = SerialFinishStartDevice(PDevObj, pIrpStack->Parameters.StartDevice
                                    .AllocatedResources,
                                    pIrpStack->Parameters.StartDevice
                                    .AllocatedResourcesTranslated, NULL);
   return status;
}



NTSTATUS
SerialItemCallBack(
                  IN PVOID Context,
                  IN PUNICODE_STRING PathName,
                  IN INTERFACE_TYPE BusType,
                  IN ULONG BusNumber,
                  IN PKEY_VALUE_FULL_INFORMATION *BusInformation,
                  IN CONFIGURATION_TYPE ControllerType,
                  IN ULONG ControllerNumber,
                  IN PKEY_VALUE_FULL_INFORMATION *ControllerInformation,
                  IN CONFIGURATION_TYPE PeripheralType,
                  IN ULONG PeripheralNumber,
                  IN PKEY_VALUE_FULL_INFORMATION *PeripheralInformation
                  )

/*++

Routine Description:

    This routine is called to check if a particular item
    is present in the registry.

Arguments:

    Context - Pointer to a boolean.

    PathName - unicode registry path.  Not Used.

    BusType - Internal, Isa, ...

    BusNumber - Which bus if we are on a multibus system.

    BusInformation - Configuration information about the bus. Not Used.

    ControllerType - Controller type.

    ControllerNumber - Which controller if there is more than one
                       controller in the system.

    ControllerInformation - Array of pointers to the three pieces of
                            registry information.

    PeripheralType - Should be a peripheral.

    PeripheralNumber - Which peripheral - not used..

    PeripheralInformation - Configuration information. Not Used.

Return Value:

    STATUS_SUCCESS

--*/

{
   PAGED_CODE();

   *((BOOLEAN *)Context) = TRUE;
   return STATUS_SUCCESS;
}


NTSTATUS
SerialControllerCallBack(
                  IN PVOID Context,
                  IN PUNICODE_STRING PathName,
                  IN INTERFACE_TYPE BusType,
                  IN ULONG BusNumber,
                  IN PKEY_VALUE_FULL_INFORMATION *BusInformation,
                  IN CONFIGURATION_TYPE ControllerType,
                  IN ULONG ControllerNumber,
                  IN PKEY_VALUE_FULL_INFORMATION *ControllerInformation,
                  IN CONFIGURATION_TYPE PeripheralType,
                  IN ULONG PeripheralNumber,
                  IN PKEY_VALUE_FULL_INFORMATION *PeripheralInformation
                  )

/*++

Routine Description:

    This routine is called to check if a particular item
    is present in the registry.

Arguments:

    Context - Pointer to a boolean.

    PathName - unicode registry path.  Not Used.

    BusType - Internal, Isa, ...

    BusNumber - Which bus if we are on a multibus system.

    BusInformation - Configuration information about the bus. Not Used.

    ControllerType - Controller type.

    ControllerNumber - Which controller if there is more than one
                       controller in the system.

    ControllerInformation - Array of pointers to the three pieces of
                            registry information.

    PeripheralType - Should be a peripheral.

    PeripheralNumber - Which peripheral - not used..

    PeripheralInformation - Configuration information. Not Used.

Return Value:

    STATUS_SUCCESS

--*/

{
   PCM_FULL_RESOURCE_DESCRIPTOR controllerData;
   PSERIAL_PTR_CTX pContext = (PSERIAL_PTR_CTX)Context;
   ULONG i;

   PAGED_CODE();

   if (ControllerInformation[IoQueryDeviceConfigurationData]->DataLength == 0) {
      pContext->isPointer = FALSE;
      return STATUS_SUCCESS;
   }

   controllerData =
      (PCM_FULL_RESOURCE_DESCRIPTOR)
      (((PUCHAR)ControllerInformation[IoQueryDeviceConfigurationData])
        + ControllerInformation[IoQueryDeviceConfigurationData]->DataOffset);

   //
   // See if this is the exact port we are testing
   //
   for (i = 0; i < controllerData->PartialResourceList.Count; i++) {

      PCM_PARTIAL_RESOURCE_DESCRIPTOR partial
         = &controllerData->PartialResourceList.PartialDescriptors[i];

      switch (partial->Type) {
      case CmResourceTypePort:
         if (partial->u.Port.Start.QuadPart == pContext->Port.QuadPart) {
            //
            // Pointer on same controller. Bail out.
            //
            pContext->isPointer = SERIAL_FOUNDPOINTER_PORT;
            return STATUS_SUCCESS;
         }

      case CmResourceTypeInterrupt:
         if (partial->u.Interrupt.Vector == pContext->Vector) {
            //
            // Pointer sharing this interrupt.  Bail out.
            //
            pContext->isPointer = SERIAL_FOUNDPOINTER_VECTOR;
            return STATUS_SUCCESS;
         }

      default:
         break;
      }
   }

   pContext->isPointer = FALSE;
   return STATUS_SUCCESS;
}



NTSTATUS
SerialGetPortInfo(IN PDEVICE_OBJECT PDevObj, IN PCM_RESOURCE_LIST PResList,
                  IN PCM_RESOURCE_LIST PTrResList, OUT PCONFIG_DATA PConfig,
                  IN PSERIAL_USER_DATA PUserData)

/*++

Routine Description:

    This routine will get the configuration information and put
    it and the translated values into CONFIG_DATA structures.
    It first sets up with  defaults and then queries the registry
    to see if the user has overridden these defaults; if this is a legacy
    multiport card, it uses the info in PUserData instead of groping the
    registry again.

Arguments:

    PDevObj - Pointer to the device object.

    PResList - Pointer to the untranslated resources requested.

    PTrResList - Pointer to the translated resources requested.

    PConfig - Pointer to configuration info

    PUserData - Pointer to data discovered in the registry for
    legacy devices.

Return Value:

    STATUS_SUCCESS if consistant configuration was found - otherwise.
    returns STATUS_SERIAL_NO_DEVICE_INITED.

--*/

{
   PSERIAL_DEVICE_EXTENSION pDevExt = PDevObj->DeviceExtension;
   PDEVICE_OBJECT pLowerDevObj = pDevExt->LowerDeviceObject;
   NTSTATUS status = STATUS_NOT_IMPLEMENTED;
   CONFIGURATION_TYPE pointer = PointerPeripheral;
   CONFIGURATION_TYPE controllerType  = SerialController;

   HANDLE keyHandle;
   ULONG count;
   ULONG i;
   INTERFACE_TYPE interfaceType;

   PCM_PARTIAL_RESOURCE_LIST pPartialResourceList, pPartialTrResourceList;
   PCM_PARTIAL_RESOURCE_DESCRIPTOR pPartialResourceDesc, pPartialTrResourceDesc;

   PCM_FULL_RESOURCE_DESCRIPTOR pFullResourceDesc = NULL,
      pFullTrResourceDesc = NULL;

   ULONG defaultInterruptMode;
   ULONG defaultAddressSpace;
   ULONG defaultInterfaceType;
   ULONG defaultClockRate;
   ULONG zero = 0;
   SERIAL_PTR_CTX foundPointerCtx;
   ULONG isMulti = 0;
   ULONG gotInt = 0;
   ULONG gotISR = 0;
   ULONG gotIO = 0;
   ULONG ioResIndex = 0;
   ULONG curIoIndex = 0;

   PAGED_CODE();

   SerialDump(SERTRACECALLS, ("SERIAL: entering SerialGetPortInfo\n"));

   SerialDump(SERPNPPOWER, ("SERIAL: resource pointer is %x\n", PResList));
   SerialDump(SERPNPPOWER, ("SERIAL: TR resource pointer is %x\n", PTrResList));


   if ((PResList == NULL) || (PTrResList == NULL)) {
      //
      // This shouldn't happen in theory
      //

       ASSERT(PResList != NULL);
       ASSERT(PTrResList != NULL);

      //
      // This status is as appropriate as I can think of
      //
      return STATUS_INSUFFICIENT_RESOURCES;
   }

   //
   // Each resource list should have only one set of resources
   //

   ASSERT(PResList->Count == 1);
   ASSERT(PTrResList->Count == 1);

   //
   // See if this is a multiport device.  This way we allow other
   // pseudo-serial devices with extra resources to specify another range
   // of I/O ports.  If this is not a multiport, we only look at the first
   // range.  If it is a multiport, we look at the first two ranges.
   //

   status = IoOpenDeviceRegistryKey(pDevExt->Pdo, PLUGPLAY_REGKEY_DEVICE,
                                    STANDARD_RIGHTS_WRITE, &keyHandle);

   if (!NT_SUCCESS(status)) {
      return status;
   }

   status = SerialGetRegistryKeyValue(keyHandle, L"MultiportDevice",
                                      sizeof(L"MultiportDevice"), &isMulti,
                                      sizeof (ULONG));

   if (!NT_SUCCESS(status)) {
      isMulti = 0;
   }

   status = SerialGetRegistryKeyValue(keyHandle, L"SerialIoResourcesIndex",
                                      sizeof(L"SerialIoResourcesIndex"),
                                      &ioResIndex, sizeof(ULONG));

   if (!NT_SUCCESS(status)) {
      ioResIndex = 0;
   }

   ZwClose(keyHandle);


   pFullResourceDesc   = &PResList->List[0];
   pFullTrResourceDesc = &PTrResList->List[0];

   //
   // Ok, if we have a full resource descriptor.  Let's take it apart.
   //

   if (pFullResourceDesc) {
      pPartialResourceList    = &pFullResourceDesc->PartialResourceList;
      pPartialResourceDesc    = pPartialResourceList->PartialDescriptors;
      count                   = pPartialResourceList->Count;

      //
      // Pull out the stuff that is in the full descriptor.
      //

      PConfig->InterfaceType  = pFullResourceDesc->InterfaceType;
      PConfig->BusNumber      = pFullResourceDesc->BusNumber;

      //
      // Now run through the partial resource descriptors looking for the port,
      // interrupt, and clock rate.
      //

      PConfig->ClockRate = 1843200;
      PConfig->InterruptStatus = SerialPhysicalZero;
      PConfig->SpanOfInterruptStatus = SERIAL_STATUS_LENGTH;

      for (i = 0;     i < count;     i++, pPartialResourceDesc++) {

         switch (pPartialResourceDesc->Type) {
         case CmResourceTypePort: {

#if defined(NEC_98)
               //
               // NEC98 can't decide by length.
               //
               if (gotIO == 0) {  // This is the serial register set
                     gotIO = 1;
                     PConfig->Controller = pPartialResourceDesc->u.Port.Start;
                     PConfig->SpanOfController   = SERIAL_REGISTER_SPAN;
                     PConfig->AddressSpace       = pPartialResourceDesc->Flags;
               }
#else
               if (pPartialResourceDesc->u.Port.Length
                   == SERIAL_STATUS_LENGTH && (gotISR == 0)) { // This is an ISR
                  if (isMulti) {
                     gotISR = 1;
                     PConfig->InterruptStatus
                        = pPartialResourceDesc->u.Port.Start;
                     PConfig->SpanOfInterruptStatus
                        = pPartialResourceDesc->u.Port.Length;
                     PConfig->AddressSpace = pPartialResourceDesc->Flags;
                  }
               } else {
                  if (gotIO == 0) { // This is the serial register set
                     if (curIoIndex == ioResIndex) {
                        gotIO = 1;
                        PConfig->Controller
                           = pPartialResourceDesc->u.Port.Start;
                        PConfig->SpanOfController = SERIAL_REGISTER_SPAN;
                        PConfig->AddressSpace = pPartialResourceDesc->Flags;
                     } else {
                        curIoIndex++;
                     }
                  }
               }
#endif //defined(NEC_98)
               break;
         }

         case CmResourceTypeInterrupt: {
            if (gotInt == 0) {
               gotInt = 1;
               PConfig->OriginalIrql = pPartialResourceDesc->u.Interrupt.Level;
               PConfig->OriginalVector
                  = pPartialResourceDesc->u.Interrupt.Vector;
               PConfig->Affinity = pPartialResourceDesc->u.Interrupt.Affinity;

               if (pPartialResourceDesc->Flags
                   & CM_RESOURCE_INTERRUPT_LATCHED) {
                  PConfig->InterruptMode  = Latched;
               } else {
                  PConfig->InterruptMode  = LevelSensitive;
               }
            }
            break;
         }

         case CmResourceTypeDeviceSpecific: {
               PCM_SERIAL_DEVICE_DATA sDeviceData;

               sDeviceData = (PCM_SERIAL_DEVICE_DATA)(pPartialResourceDesc + 1);
               PConfig->ClockRate  = sDeviceData->BaudClock;
               break;
            }


         default: {
               break;
            }
         }   // switch (pPartialResourceDesc->Type)
      }       // for (i = 0;     i < count;     i++, pPartialResourceDesc++)
   }           // if (pFullResourceDesc)


   //
   // Do the same for the translated resources
   //

   gotInt = 0;
   gotISR = 0;
   gotIO = 0;
   curIoIndex = 0;

   if (pFullTrResourceDesc) {
      pPartialTrResourceList = &pFullTrResourceDesc->PartialResourceList;
      pPartialTrResourceDesc = pPartialTrResourceList->PartialDescriptors;
      count = pPartialTrResourceList->Count;

      //
      // Reload PConfig with the translated values for later use
      //

      PConfig->InterfaceType  = pFullTrResourceDesc->InterfaceType;
      PConfig->BusNumber      = pFullTrResourceDesc->BusNumber;

      PConfig->TrInterruptStatus = SerialPhysicalZero;

      for (i = 0;     i < count;     i++, pPartialTrResourceDesc++) {

         switch (pPartialTrResourceDesc->Type) {
         case CmResourceTypePort: {
#if defined(NEC_98)
            //
            // NEC98 can't decide by length.
            //
            if (gotIO == 0) {  // This is the serial register set
               gotIO = 1;
               PConfig->TrController = pPartialTrResourceDesc->u.Port.Start;
               PConfig->AddressSpace = pPartialTrResourceDesc->Flags;
            }
#else
            if (pPartialTrResourceDesc->u.Port.Length
                == SERIAL_STATUS_LENGTH && (gotISR == 0)) { // This is an ISR
               if (isMulti) {
                  gotISR = 1;
                  PConfig->TrInterruptStatus = pPartialTrResourceDesc
                     ->u.Port.Start;
               }
            } else { // This is the serial register set
               if (gotIO == 0) {
                  if (curIoIndex == ioResIndex) {
                     gotIO = 1;
                     PConfig->TrController
                        = pPartialTrResourceDesc->u.Port.Start;
                     PConfig->AddressSpace
                        = pPartialTrResourceDesc->Flags;
                  } else {
                     curIoIndex++;
                  }
               }
            }
#endif //defined(NEC_98)
            break;
         }

         case CmResourceTypeInterrupt: {
            if (gotInt == 0) {
               gotInt = 1;
               PConfig->TrVector = pPartialTrResourceDesc->u.Interrupt.Vector;
               PConfig->TrIrql = pPartialTrResourceDesc->u.Interrupt.Level;
               PConfig->Affinity = pPartialTrResourceDesc->u.Interrupt.Affinity;
            }
            break;
         }

         default: {
               break;
         }
         }   // switch (pPartialTrResourceDesc->Type)
      }       // for (i = 0;     i < count;     i++, pPartialTrResourceDesc++)
   }           // if (pFullTrResourceDesc)


   //
   // Initialize a config data structure with default values for those that
   // may not already be initialized.
   //

   PConfig->PortIndex = 0;
   PConfig->DisablePort = 0;
   PConfig->PermitSystemWideShare = FALSE;
   PConfig->MaskInverted = 0;
   PConfig->Indexed = 0;
   PConfig->ForceFifoEnable = driverDefaults.ForceFifoEnableDefault;
   PConfig->RxFIFO = driverDefaults.RxFIFODefault;
   PConfig->TxFIFO = driverDefaults.TxFIFODefault;
   PConfig->PermitShare = driverDefaults.PermitShareDefault;
   PConfig->LogFifo = driverDefaults.LogFifoDefault;
   PConfig->Jensen = driverDefaults.JensenDetected;

   //
   // Query the registry to look for the first bus on
   // the system (that isn't the internal bus - we assume
   // that the firmware code knows about those ports).  We
   // will use that as the default bus if no bustype or bus
   // number is specified in the "user" configuration records.
   //

   defaultInterfaceType            = (ULONG)Isa;
   defaultClockRate                = 1843200;


   for (interfaceType = 0;
       interfaceType < MaximumInterfaceType;
       interfaceType++
       ) {

      ULONG   busZero     = 0;
      BOOLEAN foundOne    = FALSE;


      if (interfaceType != Internal) {

         IoQueryDeviceDescription(
                                 &interfaceType,
                                 &busZero,
                                 NULL,
                                 NULL,
                                 NULL,
                                 NULL,
                                 SerialItemCallBack,
                                 &foundOne
                                 );

         if (foundOne) {
            defaultInterfaceType = (ULONG)interfaceType;

            if (defaultInterfaceType == MicroChannel) {

               defaultInterruptMode = CM_RESOURCE_INTERRUPT_LEVEL_SENSITIVE;
            }
            break;
         }
      }   // if (interfaceType != Internal)
   }       // for (interfaceType = 0


   //
   // Get any user data associated with the port now and override the
   // values passed in if applicable.  If this a legacy device, this
   // is where we may actually get the parameters.
   //

   //
   // Open the "Device Parameters" section of registry for this device object.
   // If PUserData is NULL, this is PnP enumerated and we need to check,
   // otherwise we are doing a legacy device and have the info already.
   //


   if (PUserData == NULL) {
      status = IoOpenDeviceRegistryKey (pDevExt->Pdo,
                                        PLUGPLAY_REGKEY_DEVICE,
                                        STANDARD_RIGHTS_READ,
                                        &keyHandle);

      if (!NT_SUCCESS(status)) {

         SerialDump(SERERRORS, ("SERIAL: IoOpenDeviceRegistryKey failed - %x "
                                "\n", status));
         goto PortInfoCleanUp;

      } else {
         status = SerialGetRegistryKeyValue (keyHandle,
                                             L"DisablePort",
                                             sizeof(L"DisablePort"),
                                             &PConfig->DisablePort,
                                             sizeof (ULONG));

         status = SerialGetRegistryKeyValue (keyHandle,
                                             L"ForceFifoEnable",
                                             sizeof(L"ForceFifoEnable"),
                                             &PConfig->ForceFifoEnable,
                                             sizeof (ULONG));

         status = SerialGetRegistryKeyValue (keyHandle,
                                             L"RxFIFO",
                                             sizeof(L"RxFIFO"),
                                             &PConfig->RxFIFO,
                                             sizeof (ULONG));

         status = SerialGetRegistryKeyValue (keyHandle,
                                             L"TxFIFO",
                                             sizeof(L"TxFIFO"),
                                             &PConfig->TxFIFO,
                                             sizeof (ULONG));

         status = SerialGetRegistryKeyValue (keyHandle,
                                             L"MaskInverted",
                                             sizeof(L"MaskInverted"),
                                             &PConfig->MaskInverted,
                                             sizeof (ULONG));

         status = SerialGetRegistryKeyValue (keyHandle,
                                             L"Share System Interrupt",
                                             sizeof(L"Share System Interrupt"),
                                             &PConfig->PermitShare,
                                             sizeof (ULONG));

         status = SerialGetRegistryKeyValue (keyHandle,
                                             L"PortIndex",
                                             sizeof(L"PortIndex"),
                                             &PConfig->PortIndex,
                                             sizeof (ULONG));

         status = SerialGetRegistryKeyValue(keyHandle, L"Indexed",
                                            sizeof(L"Indexed"),
                                            &PConfig->Indexed,
                                            sizeof(ULONG));

         status = SerialGetRegistryKeyValue (keyHandle,
                                             L"ClockRate",
                                             sizeof(L"ClockRate"),
                                             &PConfig->ClockRate,
                                             sizeof (ULONG));

         if (!NT_SUCCESS(status)) {
            PConfig->ClockRate = defaultClockRate;
         }

         ZwClose (keyHandle);
      }
   } else {
      //
      // This was a legacy device, either use a driver default or copy over
      // the user-specified values.
      //
      ULONG badValue = (ULONG)-1;

      PConfig->DisablePort = (PUserData->DisablePort == badValue)
         ? 0
         : PUserData->DisablePort;
      PConfig->ForceFifoEnable = (PUserData->ForceFIFOEnable == badValue)
         ? PUserData->ForceFIFOEnableDefault
         : PUserData->ForceFIFOEnable;
      PConfig->RxFIFO = (PUserData->RxFIFO == badValue)
         ? PUserData->RxFIFODefault
         : PUserData->RxFIFO;
      PConfig->Indexed = (PUserData->UserIndexed == badValue)
         ? 0
         : PUserData->UserIndexed;
      PConfig->TxFIFO = (PUserData->TxFIFO == badValue)
         ? PUserData->TxFIFODefault
         : PUserData->TxFIFO;
      PConfig->MaskInverted = (PUserData->MaskInverted == badValue)
         ? 0
         : PUserData->MaskInverted;
      PConfig->ClockRate = (PUserData->UserClockRate == badValue)
         ? defaultClockRate
         : PUserData->UserClockRate;
      PConfig->PermitShare = PUserData->PermitShareDefault;
      PConfig->PortIndex = PUserData->UserPortIndex;
   }

   //
   // Do some error checking on the configuration info we have.
   //
   // Make sure that the interrupt is non zero (which we defaulted
   // it to).
   //
   // Make sure that the portaddress is non zero (which we defaulted
   // it to).
   //
   // Make sure that the DosDevices is not NULL (which we defaulted
   // it to).
   //
   // We need to make sure that if an interrupt status
   // was specified, that a port index was also specfied,
   // and if so that the port index is <= maximum ports
   // on a board.
   //
   // We should also validate that the bus type and number
   // are correct.
   //
   // We will also validate that the interrupt mode makes
   // sense for the bus.
   //

   if (!PConfig->Controller.LowPart) {

      //
      // Ehhhh! Lose Game.
      //

      SerialLogError(
                    PDevObj->DriverObject,
                    NULL,
                    PConfig->Controller,
                    SerialPhysicalZero,
                    0,
                    0,
                    0,
                    58,
                    STATUS_SUCCESS,
                    SERIAL_INVALID_USER_CONFIG,
                    0,
                    NULL,
                    sizeof(L"PortAddress") + sizeof(WCHAR),
                    L"PortAddress"
                    );

      SerialDump (SERERRORS,
                  ("SERIAL: Bogus port address %x\n",
                   PConfig->Controller.LowPart));

      status = SERIAL_INVALID_USER_CONFIG;
      goto PortInfoCleanUp;
   }


   if (!PConfig->OriginalVector) {

      //
      // Ehhhh! Lose Game.
      //

      SerialLogError(
                    pDevExt->DriverObject,
                    NULL,
                    PConfig->Controller,
                    SerialPhysicalZero,
                    0,
                    0,
                    0,
                    59,
                    STATUS_SUCCESS,
                    SERIAL_INVALID_USER_CONFIG,
                    pDevExt->DeviceName.Length,
                    pDevExt->DeviceName.Buffer,
                    sizeof (L"Interrupt"),
                    L"Interrupt"
                    );

      SerialDump (SERERRORS,("SERIAL: Bogus vector %x\n",
                             PConfig->OriginalVector));

      status = SERIAL_INVALID_USER_CONFIG;
      goto PortInfoCleanUp;
   }


   if (PConfig->InterruptStatus.LowPart != 0) {

      if (PConfig->PortIndex == MAXULONG) {

         //
         // Ehhhh! Lose Game.
         //

         SerialLogError(
                       pDevExt->DriverObject,
                       NULL,
                       PConfig->Controller,
                       SerialPhysicalZero,
                       0,
                       0,
                       0,
                       30,
                       STATUS_SUCCESS,
                       SERIAL_INVALID_PORT_INDEX,
                       0,
                       NULL,
                       0,
                       NULL
                       );

         SerialDump (SERERRORS,
                     ("SERIAL: Bogus port index %x\n", PConfig->PortIndex));

         status = SERIAL_INVALID_PORT_INDEX;
         goto PortInfoCleanUp;

      } else if (!PConfig->PortIndex) {

         //
         // So sorry, you must have a non-zero port index.
         //

         SerialLogError(
                       pDevExt->DriverObject,
                       NULL,
                       PConfig->Controller,
                       SerialPhysicalZero,
                       0,
                       0,
                       0,
                       31,
                       STATUS_SUCCESS,
                       SERIAL_INVALID_PORT_INDEX,
                       0,
                       NULL,
                       0,
                       NULL
                       );

         SerialDump(
                   SERERRORS,
                   ("SERIAL: Port index must be > 0 for any\n"
                    "------- port on a multiport card: %x\n",
                    PConfig->PortIndex)
                   );

         status = SERIAL_INVALID_PORT_INDEX;
         goto PortInfoCleanUp;

      } else {

         if (PConfig->Indexed) {

            if (PConfig->PortIndex > SERIAL_MAX_PORTS_INDEXED) {

               SerialLogError(
                             pDevExt->DriverObject,
                             NULL,
                             PConfig->Controller,
                             SerialPhysicalZero,
                             0,
                             0,
                             0,
                             32,
                             STATUS_SUCCESS,
                             SERIAL_PORT_INDEX_TOO_HIGH,
                             0,
                             NULL,
                             0,
                             NULL
                             );

               SerialDump (SERERRORS,
                           ("SERIAL: port index to large %x\n",
                            PConfig->PortIndex));

               status = SERIAL_PORT_INDEX_TOO_HIGH;
               goto PortInfoCleanUp;
            }

         } else {

            if (PConfig->PortIndex > SERIAL_MAX_PORTS_NONINDEXED) {

               SerialLogError(
                             pDevExt->DriverObject,
                             NULL,
                             PConfig->Controller,
                             SerialPhysicalZero,
                             0,
                             0,
                             0,
                             33,
                             STATUS_SUCCESS,
                             SERIAL_PORT_INDEX_TOO_HIGH,
                             0,
                             NULL,
                             0,
                             NULL
                             );

               SerialDump (SERERRORS,
                           ("SERIAL: port index to large %x\n",
                            PConfig->PortIndex));

               status = SERIAL_PORT_INDEX_TOO_HIGH;
               goto PortInfoCleanUp;
            }

         }

      }   // else  (if !PConfig->PortIndex)

   }       // if (PConfig->InterruptStatus != 0)


   //
   // We don't want to cause the hal to have a bad day,
   // so let's check the interface type and bus number.
   //
   // We only need to check the registry if they aren't
   // equal to the defaults.
   //

   if (PConfig->BusNumber != 0) {

      BOOLEAN foundIt;

      if (PConfig->InterfaceType >= MaximumInterfaceType) {

         //
         // Ehhhh! Lose Game.
         //

         SerialLogError(
                       pDevExt->DriverObject,
                       NULL,
                       PConfig->Controller,
                       SerialPhysicalZero,
                       0,
                       0,
                       0,
                       34,
                       STATUS_SUCCESS,
                       SERIAL_UNKNOWN_BUS,
                       0,
                       NULL,
                       0,
                       NULL
                       );

         SerialDump (SERERRORS,
                     ("SERIAL: Invalid Bus type %x\n", PConfig->BusNumber));

         status = SERIAL_UNKNOWN_BUS;
         goto PortInfoCleanUp;
      }

      IoQueryDeviceDescription(
                              (INTERFACE_TYPE *)&PConfig->InterfaceType,
                              &zero,
                              NULL,
                              NULL,
                              NULL,
                              NULL,
                              SerialItemCallBack,
                              &foundIt
                              );

      if (!foundIt) {

         SerialLogError(
                       pDevExt->DriverObject,
                       NULL,
                       PConfig->Controller,
                       SerialPhysicalZero,
                       0,
                       0,
                       0,
                       35,
                       STATUS_SUCCESS,
                       SERIAL_BUS_NOT_PRESENT,
                       0,
                       NULL,
                       0,
                       NULL
                       );
         SerialDump(
                   SERERRORS,
                   ("SERIAL: There aren't that many of those\n"
                    "------- busses on this system,%x\n",
                    PConfig->BusNumber)
                   );

         status = SERIAL_BUS_NOT_PRESENT;
         goto PortInfoCleanUp;

      }

   }   // if (PConfig->BusNumber != 0)


   if ((PConfig->InterfaceType == MicroChannel) &&
       (PConfig->InterruptMode == CM_RESOURCE_INTERRUPT_LATCHED)) {

      SerialLogError(
                    pDevExt->DriverObject,
                    NULL,
                    PConfig->Controller,
                    SerialPhysicalZero,
                    0,
                    0,
                    0,
                    36,
                    STATUS_SUCCESS,
                    SERIAL_BUS_INTERRUPT_CONFLICT,
                    0,
                    NULL,
                    0,
                    NULL
                    );
      SerialDump(
                SERERRORS,
                ("SERIAL: Latched interrupts and MicroChannel\n"
                 "------- busses don't mix\n")
                );

      status = SERIAL_BUS_INTERRUPT_CONFLICT;
      goto PortInfoCleanUp;
   }


   status = STATUS_SUCCESS;

   //
   // Dump out the port configuration.
   //

   SerialDump(SERDIAG1, ("SERIAL: Com Port address: %x\n",
                          PConfig->Controller.LowPart));

   SerialDump(SERDIAG1, ("SERIAL: Com Interrupt Status: %x\n",
                         PConfig->InterruptStatus));

   SerialDump(SERDIAG1, ("SERIAL: Com Port Index: %x\n",
                         PConfig->PortIndex));

   SerialDump(SERDIAG1, ("SERIAL: Com Port ClockRate: %x\n",
                         PConfig->ClockRate));

   SerialDump(SERDIAG1, ("SERIAL: Com Port BusNumber: %x\n",
                         PConfig->BusNumber));

   SerialDump(SERDIAG1, ("SERIAL: Com AddressSpace: %x\n",
                         PConfig->AddressSpace));

   SerialDump(SERDIAG1, ("SERIAL: Com InterruptMode: %x\n",
                         PConfig->InterruptMode));

   SerialDump(SERDIAG1, ("SERIAL: Com InterfaceType: %x\n",
                         PConfig->InterfaceType));

   SerialDump(SERDIAG1, ("SERIAL: Com OriginalVector: %x\n",
                         PConfig->OriginalVector));

   SerialDump(SERDIAG1, ("SERIAL: Com OriginalIrql: %x\n",
                         PConfig->OriginalIrql));

   SerialDump(SERDIAG1, ("SERIAL: Com Indexed: %x\n",
                         PConfig->Indexed));

   PortInfoCleanUp:;

   return status;
}



NTSTATUS
SerialDoExternalNaming(IN PSERIAL_DEVICE_EXTENSION PDevExt,
                       IN PDRIVER_OBJECT PDrvObj)

/*++

Routine Description:

    This routine will be used to create a symbolic link
    to the driver name in the given object directory.

    It will also create an entry in the device map for
    this device - IF we could create the symbolic link.

Arguments:

    Extension - Pointer to the device extension.

Return Value:

    None.

--*/

{
   NTSTATUS status = STATUS_SUCCESS;
   HANDLE keyHandle;
   WCHAR *pRegName = NULL;
   UNICODE_STRING linkName;
   PDEVICE_OBJECT pLowerDevObj, pDevObj;
   ULONG bufLen;


   PAGED_CODE();

   pDevObj = PDevExt->DeviceObject;
   pLowerDevObj = PDevExt->LowerDeviceObject;

   status = IoOpenDeviceRegistryKey(PDevExt->Pdo, PLUGPLAY_REGKEY_DEVICE,
                                    STANDARD_RIGHTS_READ, &keyHandle);

   //
   // Check to see if we are allowed to do external naming; if not,
   // then we just return success
   //


   if (status != STATUS_SUCCESS) {
      return status;
   }


   SerialGetRegistryKeyValue(keyHandle, L"SerialSkipExternalNaming",
                             sizeof(L"SerialSkipExternalNaming"),
                             &PDevExt->SkipNaming, sizeof(ULONG));

   if (PDevExt->SkipNaming) {
      ZwClose(keyHandle);
      return STATUS_SUCCESS;
   }

   RtlZeroMemory(&linkName, sizeof(UNICODE_STRING));

   linkName.MaximumLength = SYMBOLIC_NAME_LENGTH*sizeof(WCHAR);
   linkName.Buffer = ExAllocatePool(PagedPool, linkName.MaximumLength
                                    + sizeof(WCHAR));

   if (linkName.Buffer == NULL) {
      SerialLogError(PDrvObj, pDevObj, SerialPhysicalZero, SerialPhysicalZero,
                     0, 0, 0, 19, STATUS_SUCCESS, SERIAL_INSUFFICIENT_RESOURCES,
                     0, NULL, 0, NULL);
      SerialDump(SERERRORS, ("SERIAL: Couldn't allocate memory for device name"
                             "\n"));

      status = STATUS_INSUFFICIENT_RESOURCES;
      ZwClose(keyHandle);
      goto SerialDoExternalNamingError;

   }

   RtlZeroMemory(linkName.Buffer, linkName.MaximumLength + sizeof(WCHAR));


   pRegName = ExAllocatePool(PagedPool, SYMBOLIC_NAME_LENGTH * sizeof(WCHAR)
                            + sizeof(WCHAR));

   if (pRegName == NULL) {
      SerialLogError(PDrvObj, pDevObj, SerialPhysicalZero, SerialPhysicalZero,
                     0, 0, 0, 19, STATUS_SUCCESS, SERIAL_INSUFFICIENT_RESOURCES,
                     0, NULL, 0, NULL);
      SerialDump(SERERRORS, ("SERIAL: Couldn't allocate memory for buffer"
                             "\n"));

      status = STATUS_INSUFFICIENT_RESOURCES;
      ZwClose(keyHandle);
      goto SerialDoExternalNamingError;

   }

   //
   // Fetch PortName which contains the suggested REG_SZ symbolic name.
   //

   status = SerialGetRegistryKeyValue(keyHandle, L"PortName",
                                      sizeof(L"PortName"), pRegName,
                                      SYMBOLIC_NAME_LENGTH * sizeof(WCHAR));

   if (!NT_SUCCESS(status)) {

      //
      // This is for PCMCIA which currently puts the name under Identifier.
      //

      status = SerialGetRegistryKeyValue(keyHandle, L"Identifier",
                                         sizeof(L"Identifier"),
                                         pRegName, SYMBOLIC_NAME_LENGTH
                                         * sizeof(WCHAR));

      if (!NT_SUCCESS(status)) {

         //
         // Hmm.  Either we have to pick a name or bail...
         //
         // ...we will bail.
         //

         SerialDump(SERERRORS, ("SERIAL: Getting PortName/Identifier failed - "
                                "%x\n", status));
         ZwClose (keyHandle);
         goto SerialDoExternalNamingError;
      }

   }

   ZwClose (keyHandle);

   bufLen = wcslen(pRegName) * sizeof(WCHAR) + sizeof(UNICODE_NULL);

   PDevExt->WmiIdentifier.Buffer = ExAllocatePool(PagedPool, bufLen);

   if (PDevExt->WmiIdentifier.Buffer == NULL) {
      SerialLogError(PDrvObj, pDevObj, SerialPhysicalZero, SerialPhysicalZero,
                    0, 0, 0, 19, STATUS_SUCCESS, SERIAL_INSUFFICIENT_RESOURCES,
                    0, NULL, 0, NULL);
      SerialDump(SERERRORS,
                 ("SERIAL: Couldn't allocate memory for WMI name\n"));

      status = STATUS_INSUFFICIENT_RESOURCES;
      goto SerialDoExternalNamingError;
   }

   RtlZeroMemory(PDevExt->WmiIdentifier.Buffer, bufLen);

   PDevExt->WmiIdentifier.Length = 0;
   PDevExt->WmiIdentifier.MaximumLength = (USHORT)bufLen - sizeof(WCHAR);
   RtlAppendUnicodeToString(&PDevExt->WmiIdentifier, pRegName);


   //
   // Create the "\\DosDevices\\<symbolicName>" string
   //
   RtlAppendUnicodeToString(&linkName, L"\\");
   RtlAppendUnicodeToString(&linkName, DEFAULT_DIRECTORY);
   RtlAppendUnicodeToString(&linkName, L"\\");
   RtlAppendUnicodeToString(&linkName, pRegName);

   //
   // Allocate Pool and save the symbolic link name in the device extension.
   //
   PDevExt->SymbolicLinkName.MaximumLength = linkName.Length + sizeof(WCHAR);
   PDevExt->SymbolicLinkName.Buffer
      = ExAllocatePool(PagedPool, PDevExt->SymbolicLinkName.MaximumLength);

   if (!PDevExt->SymbolicLinkName.Buffer) {

      SerialLogError(PDrvObj, pDevObj, SerialPhysicalZero, SerialPhysicalZero,
                    0, 0, 0, 19, STATUS_SUCCESS, SERIAL_INSUFFICIENT_RESOURCES,
                    0, NULL, 0, NULL);
      SerialDump(SERERRORS,
                 ("SERIAL: Couldn't allocate memory for symbolic link name\n"));

      status = STATUS_INSUFFICIENT_RESOURCES;
      goto SerialDoExternalNamingError;
   }



   //
   // Zero fill it.
   //

   RtlZeroMemory(PDevExt->SymbolicLinkName.Buffer,
                 PDevExt->SymbolicLinkName.MaximumLength);

   RtlAppendUnicodeStringToString(&PDevExt->SymbolicLinkName,
                                  &linkName);

   PDevExt->DosName.Buffer = ExAllocatePool(PagedPool, 64 + sizeof(WCHAR));

   if (!PDevExt->DosName.Buffer) {

      SerialLogError(PDrvObj, pDevObj, SerialPhysicalZero, SerialPhysicalZero,
                    0, 0, 0, 19, STATUS_SUCCESS, SERIAL_INSUFFICIENT_RESOURCES,
                    0, NULL, 0, NULL);
      SerialDump(SERERRORS,
                 ("SERIAL: Couldn't allocate memory for Dos name\n"));

      status =  STATUS_INSUFFICIENT_RESOURCES;
      goto SerialDoExternalNamingError;
   }


   PDevExt->DosName.MaximumLength = 64 + sizeof(WCHAR);

   //
   // Zero fill it.
   //

   PDevExt->DosName.Length = 0;

   RtlZeroMemory(PDevExt->DosName.Buffer,
                 PDevExt->DosName.MaximumLength);

   RtlAppendUnicodeToString(&PDevExt->DosName, pRegName);
   RtlZeroMemory(((PUCHAR)(&PDevExt->DosName.Buffer[0]))
                 + PDevExt->DosName.Length, sizeof(WCHAR));

   SerialDump(SERDIAG1, ("SERIAL: DosName is %wZ\n",
                         &PDevExt->DosName));

   //


   status = IoCreateSymbolicLink (&PDevExt->SymbolicLinkName,
                                  &PDevExt->DeviceName);

   if (!NT_SUCCESS(status)) {

      //
      // Oh well, couldn't create the symbolic link.  No point
      // in trying to create the device map entry.
      //

      SerialLogError(PDrvObj, pDevObj, SerialPhysicalZero, SerialPhysicalZero,
                     0, 0, 0, 52, status, SERIAL_NO_SYMLINK_CREATED,
                     PDevExt->DeviceName.Length + sizeof(WCHAR),
                     PDevExt->DeviceName.Buffer, 0, NULL);

      SerialDump(
                SERERRORS,
                ("SERIAL: Couldn't create the symbolic link\n"
                 "------- for port %wZ\n",
                 &PDevExt->DeviceName)
                );

      goto SerialDoExternalNamingError;

   }

   PDevExt->CreatedSymbolicLink = TRUE;

   status = RtlWriteRegistryValue(RTL_REGISTRY_DEVICEMAP, L"SERIALCOMM",
                                   PDevExt->DeviceName.Buffer, REG_SZ,
                                   PDevExt->DosName.Buffer,
                                   PDevExt->DosName.Length + sizeof(WCHAR));

   if (!NT_SUCCESS(status)) {

      SerialLogError(PDrvObj, pDevObj, SerialPhysicalZero, SerialPhysicalZero,
                     0, 0, 0, 53, status, SERIAL_NO_DEVICE_MAP_CREATED,
                     PDevExt->DeviceName.Length + sizeof(WCHAR),
                     PDevExt->DeviceName.Buffer, 0, NULL);

      SerialDump(SERERRORS, ("SERIAL: Couldn't create the device map entry\n"
                             "------- for port %wZ\n", &PDevExt->DeviceName));

      goto SerialDoExternalNamingError;
   }

   PDevExt->CreatedSerialCommEntry = TRUE;

   //
   // Make the device visible via a device association as well.
   // The reference string is the eight digit device index
   //

   status = IoRegisterDeviceInterface(PDevExt->Pdo, (LPGUID)&GUID_CLASS_COMPORT,
                                      NULL, &PDevExt->DeviceClassSymbolicName);

   if (!NT_SUCCESS(status)) {
      SerialDump(SERERRORS, ("SERIAL: Couldn't register class association\n"
                             "------- for port %wZ\n",
                                 &PDevExt->DeviceName));

      PDevExt->DeviceClassSymbolicName.Buffer = NULL;
      goto SerialDoExternalNamingError;
   }


   //
   // Now set the symbolic link for the association
   //

   status = IoSetDeviceInterfaceState(&PDevExt->DeviceClassSymbolicName,
                                         TRUE);

   if (!NT_SUCCESS(status)) {
      SerialDump(SERERRORS, ("SERIAL: Couldn't set class association\n"
                             "------- for port %wZ\n",
                             &PDevExt->DeviceName));
   }

   SerialDoExternalNamingError:;

   //
   // Clean up error conditions
   //

   if (!NT_SUCCESS(status)) {
      if (PDevExt->DosName.Buffer != NULL) {
         ExFreePool(PDevExt->DosName.Buffer);
         PDevExt->DosName.Buffer = NULL;
      }

      if (PDevExt->CreatedSymbolicLink ==  TRUE) {
         IoDeleteSymbolicLink(&PDevExt->SymbolicLinkName);
         PDevExt->CreatedSymbolicLink = FALSE;
      }

      if (PDevExt->SymbolicLinkName.Buffer != NULL) {
         ExFreePool(PDevExt->SymbolicLinkName.Buffer);
         PDevExt->SymbolicLinkName.Buffer = NULL;
      }

      if (PDevExt->DeviceName.Buffer != NULL) {
         RtlDeleteRegistryValue(RTL_REGISTRY_DEVICEMAP, SERIAL_DEVICE_MAP,
                                PDevExt->DeviceName.Buffer);
      }

      if (PDevExt->DeviceClassSymbolicName.Buffer) {
         IoSetDeviceInterfaceState (&PDevExt->DeviceClassSymbolicName, FALSE);
      }

      if (PDevExt->WmiIdentifier.Buffer != NULL) {
         ExFreePool(PDevExt->WmiIdentifier.Buffer);
         PDevExt->WmiIdentifier.Buffer = NULL;
      }
   }

   //
   // Always clean up our temp buffers.
   //

   if (linkName.Buffer != NULL) {
      ExFreePool(linkName.Buffer);
   }

   if (pRegName != NULL) {
      ExFreePool(pRegName);
   }

   return status;
}





VOID
SerialUndoExternalNaming(IN PSERIAL_DEVICE_EXTENSION Extension)

/*++

Routine Description:

    This routine will be used to delete a symbolic link
    to the driver name in the given object directory.

    It will also delete an entry in the device map for
    this device if the symbolic link had been created.

Arguments:

    Extension - Pointer to the device extension.

Return Value:

    None.

--*/

{

   NTSTATUS status;

   PAGED_CODE();

   SerialDump(
             SERDIAG3,
             ("SERIAL: In SerialUndoExternalNaming for\n"
              "------- extension: %x of port %wZ\n",
              Extension,&Extension->DeviceName)
             );

   //
   // Maybe there is nothing for us to do
   //

   if (Extension->SkipNaming) {
      return;
   }

   //
   // We're cleaning up here.  One reason we're cleaning up
   // is that we couldn't allocate space for the directory
   // name or the symbolic link.
   //

   if (Extension->SymbolicLinkName.Buffer &&
       Extension->CreatedSymbolicLink) {

            if (Extension->DeviceClassSymbolicName.Buffer) {
               status = IoSetDeviceInterfaceState (&Extension->
                                                   DeviceClassSymbolicName,
                                                   FALSE);

               //
               // IoRegisterDeviceClassInterface() allocated this string for us,
               // and we no longer need it.
               //

               ExFreePool( Extension->DeviceClassSymbolicName.Buffer );
            }


      IoDeleteSymbolicLink (&Extension->SymbolicLinkName);

   }

   if (Extension->WmiIdentifier.Buffer) {
      ExFreePool(Extension->WmiIdentifier.Buffer);
      Extension->WmiIdentifier.MaximumLength
         = Extension->WmiIdentifier.Length = 0;
      Extension->WmiIdentifier.Buffer = NULL;
   }

   //
   // We're cleaning up here.  One reason we're cleaning up
   // is that we couldn't allocate space for the NtNameOfPort.
   //

   if ((Extension->DeviceName.Buffer != NULL)
        && Extension->CreatedSerialCommEntry) {

      status = RtlDeleteRegistryValue(RTL_REGISTRY_DEVICEMAP, SERIAL_DEVICE_MAP,
                                     Extension->DeviceName.Buffer);

      if (!NT_SUCCESS(status)) {

         SerialLogError(
                       Extension->DeviceObject->DriverObject,
                       Extension->DeviceObject,
                       Extension->OriginalController,
                       SerialPhysicalZero,
                       0,
                       0,
                       0,
                       55,
                       status,
                       SERIAL_NO_DEVICE_MAP_DELETED,
                       Extension->DeviceName.Length+sizeof(WCHAR),
                       Extension->DeviceName.Buffer,
                       0,
                       NULL
                       );
         SerialDump(
                   SERERRORS,
                   ("SERIAL: Couldn't delete value entry %wZ\n",
                    &Extension->DeviceName)
                   );

      }
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\ser101\legacy.c ===
/*++

Copyright (c) 1991, 1992, 1993 Microsoft Corporation

Module Name:

    Legacy.c

Abstract:

    This module contains the code that does the legacy configuration and
    initialization of the comm ports.  As the driver gets more PnP 
    functionality and the PnP manager appears, most of this module should
    go away.

Environment:

    Kernel mode

--*/

#include "precomp.h"

#if !defined(NO_LEGACY_DRIVERS)

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT,SerialEnumerateLegacy)
#pragma alloc_text(INIT,SerialMigrateLegacyRegistry)
#pragma alloc_text(INIT,SerialBuildResourceList)
#pragma alloc_text(INIT,SerialTranslateResourceList)
#pragma alloc_text(INIT,SerialBuildRequirementsList)
#pragma alloc_text(INIT,SerialIsUserDataValid)
#endif // ALLOC_PRAGMA

static const PHYSICAL_ADDRESS SerialPhysicalZero = {0};



NTSTATUS
SerialTranslateResourceList(IN PDRIVER_OBJECT DriverObject,
                            IN PKEY_BASIC_INFORMATION UserSubKey,
                            OUT PCM_RESOURCE_LIST PTrResourceList,
                            IN PCM_RESOURCE_LIST PResourceList,
                            IN ULONG PartialCount,
                            IN PSERIAL_USER_DATA PUserData)
/*++

Routine Description:

    This routine will create a resource list of translated resources
    based on PResourceList.


    This is pageable INIT because it is only called from SerialEnumerateLegacy
    which is also pageable INIT.


Arguments:
    DriverObject - Only used for logging.
    
    UserSubKey - Only used for logging.

    PPResourceList - Pointer to a PCM_RESOURCE_LIST that we are creating.
    
    PResourceList - PCM_RESOURCE_LIST that we are translating.
    
    ParitalCount - Number of Partial Resource lists in PResourceList.
    
    PUserData - Data retrieved as defaults or from the registry.
    

Return Value:

    STATUS_SUCCESS on success, apropriate error value otherwise.

--*/
{
   KIRQL outIrql;
   KAFFINITY outAffinity = (KAFFINITY)-1;
   ULONG outAddrSpace;
   PHYSICAL_ADDRESS outPhysAddr;
   NTSTATUS status = STATUS_SUCCESS;

   PAGED_CODE();

   SerialDump(SERTRACECALLS, ("SERIAL: Enter SerialTranslateResourceList\n"));

   outIrql = (KIRQL)(PUserData->UserLevel ? PUserData->UserLevel
      : PUserData->UserVector);

   //
   // Copy the list over to the translated buffer and fixup and translate
   // what we need.
   //
   RtlCopyMemory(PTrResourceList, PResourceList, sizeof(CM_RESOURCE_LIST)
                 + sizeof(CM_PARTIAL_RESOURCE_DESCRIPTOR) * 2);

   outAddrSpace = PTrResourceList->List[0].PartialResourceList
                  .PartialDescriptors[0].Flags;
   outPhysAddr = PTrResourceList->List[0].PartialResourceList
                 .PartialDescriptors[0].u.Port.Start;


   if (HalTranslateBusAddress(PUserData->UserInterfaceType,
                              PUserData->UserBusNumber, PUserData->UserPort,
                              &outAddrSpace, &outPhysAddr)
       == 0) {
      SerialLogError(DriverObject, NULL, PUserData->UserPort,
                     SerialPhysicalZero, 0, 0, 0, 60, STATUS_SUCCESS,
                     SERIAL_NO_TRANSLATE_PORT, UserSubKey->NameLength
                     + sizeof(WCHAR), &UserSubKey->Name[0], 0, NULL);

      SerialDump(SERERRORS, ("SERIAL: Port map failed attempt was \n"
                             "------- Interface:  %x\n"
                             "------- Bus Number: %x\n"
                             "------- userPort:  %x\n"
                             "------- AddrSpace:  %x\n"
                             "------- PhysAddr:   %x\n",
                             PUserData->UserInterfaceType,
                             PUserData->UserBusNumber,
                             PUserData->UserPort,
                             PTrResourceList->List[0].
                             PartialResourceList.PartialDescriptors[0]
                             .Flags,
                             PTrResourceList->List[0].
                             PartialResourceList.PartialDescriptors[0]
                             .u.Port.Start.QuadPart));

      status = STATUS_NONE_MAPPED;
      goto SerialTranslateError;
   }

   PTrResourceList->List[0].PartialResourceList.PartialDescriptors[0].Flags
      = (USHORT)outAddrSpace;
   PTrResourceList->List[0].PartialResourceList.PartialDescriptors[0]
      .u.Port.Start = outPhysAddr;

   if ((PTrResourceList->List[0].PartialResourceList
        .PartialDescriptors[1].u.Interrupt.Vector
        = HalGetInterruptVector(PUserData->UserInterfaceType,
                                PUserData->UserBusNumber, PUserData->UserLevel
                                ? PUserData->UserLevel
                                : PUserData->UserVector,
                                PUserData->UserVector, &outIrql,
                                &outAffinity)) == 0) {

      SerialLogError(DriverObject, NULL, PUserData->UserPort,
                     SerialPhysicalZero, 0, 0, 0, 61, STATUS_SUCCESS,
                     SERIAL_NO_GET_INTERRUPT, UserSubKey->NameLength
                     + sizeof(WCHAR), &UserSubKey->Name[0], 0, NULL);

      status = STATUS_NONE_MAPPED;
      goto SerialTranslateError;
   }

   PTrResourceList->List[0].PartialResourceList
      .PartialDescriptors[1].u.Interrupt.Level = outIrql;

   PTrResourceList->List[0].PartialResourceList
      .PartialDescriptors[1].u.Interrupt.Affinity = outAffinity;

   outAddrSpace = PTrResourceList->List[0].PartialResourceList
                  .PartialDescriptors[2].Flags;
   outPhysAddr = PTrResourceList->List[0].PartialResourceList
                 .PartialDescriptors[2].u.Port.Start;


   if (PartialCount == 3) {
      if (HalTranslateBusAddress(PUserData->UserInterfaceType,
                                 PUserData->UserBusNumber,
                                 PUserData->UserInterruptStatus,
                                 &outAddrSpace, &outPhysAddr) == 0) {

         SerialLogError(DriverObject, NULL, PUserData->UserPort,
                        SerialPhysicalZero, 0, 0, 0, 62, STATUS_SUCCESS,
                        SERIAL_NO_TRANSLATE_ISR, UserSubKey->NameLength
                        + sizeof(WCHAR), &UserSubKey->Name[0], 0, NULL);


         SerialDump(SERERRORS, ("SERIAL: ISR map failed attempt was \n"
                                "------- Interface:  %x\n"
                                "------- Bus Number: %x\n"
                                "------- IntStatus:  %x\n"
                                "------- AddrSpace:  %x\n"
                                "------- PhysAddr:   %x\n",
                                PUserData->UserInterfaceType,
                                PUserData->UserBusNumber,
                                PUserData->UserInterruptStatus,
                                PTrResourceList->List[0].
                                PartialResourceList.PartialDescriptors[2]
                                .Flags,
                                PTrResourceList->List[0].
                                PartialResourceList.PartialDescriptors[2]
                                .u.Port.Start.QuadPart));

        status = STATUS_NONE_MAPPED;
        goto SerialTranslateError;
      }

      SerialDump(SERDIAG1, ("SERIAL: ISR map was %x\n", outPhysAddr.QuadPart));

      PTrResourceList->List[0].PartialResourceList.
         PartialDescriptors[2].Flags = (USHORT)outAddrSpace;
      PTrResourceList->List[0].PartialResourceList.PartialDescriptors[2]
         .u.Port.Start = outPhysAddr;
   }

   SerialTranslateError:;

   SerialDump(SERTRACECALLS, ("SERIAL: Enter SerialTranslateResourceList\n"));

   return status;
}


NTSTATUS
SerialBuildRequirementsList(OUT PIO_RESOURCE_REQUIREMENTS_LIST PRequiredList,
                            IN ULONG PartialCount,
                            IN PSERIAL_USER_DATA PUserData)
/*++

Routine Description:

    This routine will build an IO_RESOURCE_REQUIREMENTS_LIST based on
    the defaults and user-supplied registry info.


    This is pageable INIT because it is only called from SerialEnumerateLegacy
    which is also pageable INIT.


Arguments:

    DriverObject - Used only for logging.
    
    PRequiredList - PIO_RESOURCE_REQUIREMENTS_LIST we are building.
    
    PartialCount - Number of partial descriptors needed in PPRequiredList.
    
    PUserData - Default and user-supplied values from the registry.
    

Return Value:

    STATUS_SUCCESS on success, apropriate error value otherwise.

--*/
{
   PIO_RESOURCE_LIST reqResList;
   PIO_RESOURCE_DESCRIPTOR reqResDesc;
   NTSTATUS status = STATUS_SUCCESS;

   PAGED_CODE();

   SerialDump(SERTRACECALLS, ("SERIAL: Enter SerialBuildRequirementsList\n"));


   // Build requirements list
   //

   RtlZeroMemory(PRequiredList, sizeof(IO_RESOURCE_REQUIREMENTS_LIST)
                 + sizeof(IO_RESOURCE_DESCRIPTOR) * 2);

   PRequiredList->ListSize = sizeof(IO_RESOURCE_REQUIREMENTS_LIST)
      + sizeof(IO_RESOURCE_DESCRIPTOR) * (PartialCount - 1);
   PRequiredList->InterfaceType = PUserData->UserInterfaceType;
   PRequiredList->BusNumber = PUserData->UserBusNumber;
   PRequiredList->SlotNumber = 0;
   PRequiredList->AlternativeLists = 1;

   reqResList = &PRequiredList->List[0];

   reqResList->Version = 1;
   reqResList->Revision = 1;
   reqResList->Count = PartialCount;

   reqResDesc = &reqResList->Descriptors[0];


   //
   // Port Information
   //

   reqResDesc->Flags = (USHORT)PUserData->UserAddressSpace;
   reqResDesc->Type = CmResourceTypePort;
   reqResDesc->ShareDisposition = CmResourceShareDriverExclusive;
   reqResDesc->u.Port.Length = SERIAL_REGISTER_SPAN;
   reqResDesc->u.Port.Alignment= 1;
   reqResDesc->u.Port.MinimumAddress = PUserData->UserPort;
   reqResDesc->u.Port.MaximumAddress.QuadPart
      = PUserData->UserPort.QuadPart + SERIAL_REGISTER_SPAN - 1;


   reqResDesc++;


   //
   // Interrupt information
   //

   if (PUserData->UserInterruptMode == Latched) {
      reqResDesc->Flags = CM_RESOURCE_INTERRUPT_LATCHED;
   } else {
      reqResDesc->Flags = CM_RESOURCE_INTERRUPT_LEVEL_SENSITIVE;
   }

   //
   // We have to globally share resources even though this is a **BAD**
   // thing.  We must do it for multiport cards.  DO NOT replicate
   // this in other drivers.
   //

   reqResDesc->ShareDisposition = CmResourceShareShared;

   reqResDesc->Type = CmResourceTypeInterrupt;
   reqResDesc->u.Interrupt.MinimumVector = PUserData->UserVector;
   reqResDesc->u.Interrupt.MaximumVector = PUserData->UserVector;

   //
   // ISR register information (if needed)
   //
   if (PartialCount == 3) {

      reqResDesc++;

      reqResDesc->Type = CmResourceTypePort;

      //
      // We have to globally share resources even though this is a **BAD**
      // thing.  We must do it for multiport cards.  DO NOT replicate
      // this in other drivers.
      //

      reqResDesc->ShareDisposition = CmResourceShareShared;

      reqResDesc->Flags = (USHORT)PUserData->UserAddressSpace;
      reqResDesc->u.Port.Length = 1;
      reqResDesc->u.Port.Alignment= 1;
      reqResDesc->u.Port.MinimumAddress = PUserData->UserInterruptStatus;
      reqResDesc->u.Port.MaximumAddress = PUserData->UserInterruptStatus;
   }

   SerialDump(SERTRACECALLS, ("SERIAL: Leave SerialBuildRequirementsList\n"));

   return status;
}



NTSTATUS
SerialBuildResourceList(OUT PCM_RESOURCE_LIST PResourceList,
                        OUT PULONG PPartialCount,
                        IN PSERIAL_USER_DATA PUserData)
/*++

Routine Description:

    This routine will build a resource list based on the information
    supplied by the registry.


    This is pageable INIT because it is only called from SerialEnumerateLegacy
    which is also pageable INIT.


Arguments:

    PResourceList - Pointer to PCM_RESOURCE_LIST we are building.
    
    PPartialCount - Number of Partial Resource Lists we required.
    
    PUserData - Pointer to user-supplied and default info from registry.
    

Return Value:

    STATUS_SUCCESS on success, apropriate error value otherwise.

--*/
{
   ULONG countOfPartials;
   PCM_PARTIAL_RESOURCE_DESCRIPTOR pPartial;
   NTSTATUS status = STATUS_SUCCESS;

   PAGED_CODE();

   SerialDump(SERTRACECALLS, ("SERIAL: Enter SerialBuildResourceList\n"));
   SerialDump(SERDIAG1, ("SERIAL: Building cmreslist in %x\n", PResourceList));

   *PPartialCount = 0;

   //
   // If we have a separate ISR register requirement, we then have 3
   // partials instead of 2.
   //
   countOfPartials = (PUserData->UserInterruptStatus.LowPart != 0) ? 3 : 2;
   

   RtlZeroMemory(PResourceList, sizeof(CM_RESOURCE_LIST)
                 + sizeof(CM_PARTIAL_RESOURCE_DESCRIPTOR) * 2);

   PResourceList->Count = 1;

   PResourceList->List[0].InterfaceType = PUserData->UserInterfaceType;
   PResourceList->List[0].BusNumber = PUserData->UserBusNumber;
   PResourceList->List[0].PartialResourceList.Count = countOfPartials;

   pPartial
      = &PResourceList->List[0].PartialResourceList.PartialDescriptors[0];


   //
   // Port information
   //

   pPartial->Type = CmResourceTypePort;
   pPartial->ShareDisposition = CmResourceShareDeviceExclusive;
   pPartial->Flags = (USHORT)PUserData->UserAddressSpace;
   pPartial->u.Port.Start = PUserData->UserPort;
   pPartial->u.Port.Length = SERIAL_REGISTER_SPAN;


   pPartial++;


   //
   // Interrupt information
   //

   pPartial->Type = CmResourceTypeInterrupt;

      //
      // We have to globally share resources even though this is a **BAD**
      // thing.  We must do it for multiport cards.  DO NOT replicate
      // this in other drivers.
      //

      pPartial->ShareDisposition = CmResourceShareShared;

   if (PUserData->UserInterruptMode == Latched) {
      pPartial->Flags = CM_RESOURCE_INTERRUPT_LATCHED;
   } else {
      pPartial->Flags = CM_RESOURCE_INTERRUPT_LEVEL_SENSITIVE;
   }

   pPartial->u.Interrupt.Vector = PUserData->UserVector;

   if (PUserData->UserLevel == 0) {
      pPartial->u.Interrupt.Level = PUserData->UserVector;
   } else {
      pPartial->u.Interrupt.Level = PUserData->UserLevel;
   }


   //
   // ISR register information (if needed)
   //

   if (countOfPartials == 3) {

      pPartial++;

      pPartial->Type = CmResourceTypePort;

      //
      // We have to globally share resources even though this is a **BAD**
      // thing.  We must do it for multiport cards.  DO NOT replicate
      // this in other drivers.
      //

      pPartial->ShareDisposition = CmResourceShareShared;      

      pPartial->Flags = (USHORT)PUserData->UserAddressSpace;
      pPartial->u.Port.Start = PUserData->UserInterruptStatus;
      pPartial->u.Port.Length = SERIAL_STATUS_LENGTH;
   }

   *PPartialCount = countOfPartials;

   SerialDump(SERTRACECALLS, ("SERIAL: Leave SerialBuildResourceList\n"));

   return status;
}


NTSTATUS
SerialMigrateLegacyRegistry(IN PDEVICE_OBJECT PPdo,
                            IN PSERIAL_USER_DATA PUserData, BOOLEAN IsMulti)
/*++

Routine Description:

    This routine will copy information stored in the registry for a legacy
    device over to the PnP Device Parameters section.


    This is pageable INIT because it is only called from SerialEnumerateLegacy
    which is also pageable INIT.


Arguments:

    PPdo - Pointer to the Device Object we are migrating.
    
    PUserData - Pointer to user supplied values.
    

Return Value:

    STATUS_SUCCESS on success, apropriate error value otherwise.

--*/
{
   NTSTATUS status;
   HANDLE pnpKey;
   UNICODE_STRING pnpNameBuf;
   ULONG isMultiport = 1;
   ULONG one = 1;

   PAGED_CODE();

   SerialDump(SERTRACECALLS, ("SERIAL: Enter SerialMigrateLegacyRegistry\n"));

   status = IoOpenDeviceRegistryKey(PPdo, PLUGPLAY_REGKEY_DEVICE,
                                    STANDARD_RIGHTS_WRITE, &pnpKey);

   if (!NT_SUCCESS(status)) {
      SerialDump(SERTRACECALLS, ("SERIAL: Leave (1) SerialMigrateLegacyRegistry"
                                 "\n"));
      return status;
   }

   //
   // Allocate a buffer to copy the port name over.
   //

   pnpNameBuf.MaximumLength = sizeof(WCHAR) * 256;
   pnpNameBuf.Length = 0;
   pnpNameBuf.Buffer = ExAllocatePool(PagedPool, sizeof(WCHAR) * 257);

   if (pnpNameBuf.Buffer == NULL) {
      SerialLogError(PPdo->DriverObject, NULL, PUserData->UserPort,
                     SerialPhysicalZero, 0, 0, 0, 63, STATUS_SUCCESS,
                     SERIAL_INSUFFICIENT_RESOURCES, 0, NULL, 0, NULL);

      SerialDump(SERERRORS, ("SERIAL: Couldn't allocate buffer for the PnP "
                             "link\n"));
      status = STATUS_INSUFFICIENT_RESOURCES;
      goto MigrateLegacyExit;

   }

   RtlZeroMemory(pnpNameBuf.Buffer, pnpNameBuf.MaximumLength + sizeof(WCHAR));


   //
   // Add the port name -- ALWAYS
   //

   RtlAppendUnicodeStringToString(&pnpNameBuf, &PUserData->UserSymbolicLink);
   RtlZeroMemory(((PUCHAR)(&pnpNameBuf.Buffer[0])) + pnpNameBuf.Length,
                 sizeof(WCHAR));

   status = SerialPutRegistryKeyValue(pnpKey, L"PortName", sizeof(L"PortName"),
                                      REG_SZ, pnpNameBuf.Buffer,
                                      pnpNameBuf.Length + sizeof(WCHAR));

   ExFreePool(pnpNameBuf.Buffer);

   if (!NT_SUCCESS(status)) {
      SerialDump(SERERRORS, ("SERIAL: Couldn't migrate PortName\n"));
      goto MigrateLegacyExit;
   }

   //
   // If it was part of a multiport card, save that info as well
   //

   if (IsMulti) {
      status = SerialPutRegistryKeyValue(pnpKey, L"MultiportDevice",
                                         sizeof(L"MultiportDevice"), REG_DWORD,
                                         &isMultiport, sizeof(ULONG));

      if (!NT_SUCCESS(status)) {
         SerialDump(SERERRORS, ("SERIAL: Couldn't mark multiport\n"));
         goto MigrateLegacyExit;
      }
   }

  


   //
   // If a port index was specified, save it
   //

   if (PUserData->UserPortIndex != 0) {
      status = SerialPutRegistryKeyValue(pnpKey, L"PortIndex",
                                         sizeof(L"PortIndex"), REG_DWORD,
                                         &PUserData->UserPortIndex,
                                         sizeof(ULONG));

      if (!NT_SUCCESS(status)) {
         SerialDump(SERERRORS, ("SERIAL: Couldn't migrate PortIndex\n"));
         goto MigrateLegacyExit;
      }
   }


   //
   // If not default clock rate, save it
   //

   if (PUserData->UserClockRate != SERIAL_BAD_VALUE) {
      status = SerialPutRegistryKeyValue(pnpKey, L"ClockRate",
                                         sizeof(L"ClockRate"), REG_DWORD,
                                         &PUserData->UserClockRate,
                                         sizeof(ULONG));

      if (!NT_SUCCESS(status)) {
         SerialDump(SERERRORS, ("SERIAL: Couldn't migrate ClockRate\n"));
         goto MigrateLegacyExit;
      }
   }


   //
   // If there is a user index, save it.
   //

   if (PUserData->UserIndexed != SERIAL_BAD_VALUE) {
      status = SerialPutRegistryKeyValue(pnpKey, L"Indexed", sizeof(L"Indexed"),
                                         REG_DWORD, &PUserData->UserIndexed,
                                         sizeof(ULONG));

      if (!NT_SUCCESS(status)) {
         SerialDump(SERERRORS, ("SERIAL: Couldn't migrate Indexed\n"));
         goto MigrateLegacyExit;
      }
   }


   //
   // If the port was disabled, save that.
   //

   if (PUserData->DisablePort != SERIAL_BAD_VALUE) {
      status = SerialPutRegistryKeyValue(pnpKey, L"DisablePort",
                                         sizeof(L"DisablePort"), REG_DWORD,
                                         &PUserData->DisablePort,
                                         sizeof(ULONG));
      if (!NT_SUCCESS(status)) {
         SerialDump(SERERRORS, ("SERIAL: Couldn't migrate DisablePort\n"));
         goto MigrateLegacyExit;
      }
   }


   //
   // If Fifo's were forced enabled, save that.
   //
   if (PUserData->ForceFIFOEnable != SERIAL_BAD_VALUE) {
      status = SerialPutRegistryKeyValue(pnpKey, L"ForceFifoEnable",
                                         sizeof(L"ForceFifoEnable"), REG_DWORD,
                                         &PUserData->ForceFIFOEnable,
                                         sizeof(ULONG));

      if (!NT_SUCCESS(status)) {
         SerialDump(SERERRORS, ("SERIAL: Couldn't migrate ForceFifoEnable\n"));
         goto MigrateLegacyExit;
      }
   }


   //
   // If RxFIFO had an override, save that.
   //

   if (PUserData->RxFIFO != SERIAL_BAD_VALUE) {
      status = SerialPutRegistryKeyValue(pnpKey, L"RxFIFO", sizeof(L"RxFIFO"),
                                         REG_DWORD, &PUserData->RxFIFO,
                                         sizeof(ULONG));

      if (!NT_SUCCESS(status)) {
         SerialDump(SERERRORS, ("SERIAL: Couldn't migrate RxFIFO\n"));
         goto MigrateLegacyExit;
      }
   }


   //
   // If TxFIFO had an override, save that.
   //

   if (PUserData->TxFIFO != SERIAL_BAD_VALUE) {
      status = SerialPutRegistryKeyValue(pnpKey, L"TxFIFO", sizeof(L"TxFIFO"),
                                         REG_DWORD, &PUserData->TxFIFO,
                                         sizeof(ULONG));

      if (!NT_SUCCESS(status)) {
         SerialDump(SERERRORS, ("SERIAL: Couldn't migrate TxFIFO\n"));
         goto MigrateLegacyExit;
      }
   }


   //
   // If MaskInverted had an override, save that.
   //

   if (PUserData->MaskInverted != SERIAL_BAD_VALUE) {
      status = SerialPutRegistryKeyValue(pnpKey, L"MaskInverted",
                                         sizeof(L"MaskInverted"), REG_DWORD,
                                         &PUserData->MaskInverted,
                                         sizeof(ULONG));
      if (!NT_SUCCESS(status)) {
         SerialDump(SERERRORS, ("SERIAL: Couldn't migrate MaskInverted\n"));
         goto MigrateLegacyExit;
      }
   }


   MigrateLegacyExit:;

   ZwClose(pnpKey);

   SerialDump(SERTRACECALLS, ("SERIAL: Leave (2) SerialMigrateLegacyRegistry"
                              "\n"));

   return status;
}




BOOLEAN
SerialIsUserDataValid(IN PDRIVER_OBJECT DriverObject,
                      IN PKEY_BASIC_INFORMATION UserSubKey,
                      IN PRTL_QUERY_REGISTRY_TABLE Parameters,
                      IN ULONG DefaultInterfaceType,
                      IN PSERIAL_USER_DATA PUserData)
/*++

Routine Description:

    This routine will do some basic sanity checking on the data
    found in the registry.


    This is pageable INIT because it is only called from SerialEnumerateLegacy
    which is also pageable INIT.


Arguments:

    DriverObject - Used only for logging.
    
    UserSubKey -  Used only for logging.
    
    Parameters - Used only for logging.
    
    DefaultInterfaceType - Default bus type we found.
    
    PUserData - Pointer to the values found in the registry we need to validate.
    

Return Value:

    TRUE if data appears valid, FALSE otherwise.

--*/
{
   ULONG zero = 0;
   BOOLEAN rval = TRUE;

   PAGED_CODE();


   SerialDump(SERTRACECALLS, ("SERIAL: Enter SerialIsUserDataValid\n"));

   //
   // Make sure that the interrupt is non zero (which we defaulted
   // it to).
   //
   // Make sure that the portaddress is non zero (which we defaulted
   // it to).
   //
   // Make sure that the DosDevices is not NULL (which we defaulted
   // it to).
   //
   // We need to make sure that if an interrupt status
   // was specified, that a port index was also specfied,
   // and if so that the port index is <= maximum ports
   // on a board.
   //
   // We should also validate that the bus type and number
   // are correct.
   //
   // We will also validate that the interrupt mode makes
   // sense for the bus.
   //

   if (!PUserData->UserPort.LowPart) {

      //
      // Ehhhh! Lose Game.
      //

      SerialLogError(
                    DriverObject,
                    NULL,
                    PUserData->UserPort,
                    SerialPhysicalZero,
                    0,
                    0,
                    0,
                    64,
                    STATUS_SUCCESS,
                    SERIAL_INVALID_USER_CONFIG,
                    UserSubKey->NameLength+sizeof(WCHAR),
                    &UserSubKey->Name[0],
                    (wcslen(Parameters[1].Name)*sizeof(WCHAR))
                    + sizeof(WCHAR),
                    Parameters[1].Name
                    );
      SerialDump(
                SERERRORS,
                ("SERIAL: Bogus port address %ws\n",
                 Parameters[1].Name)
                );
      rval = FALSE;
      goto SerialIsUserDataValidError;
   }

   if (!PUserData->UserVector) {

      //
      // Ehhhh! Lose Game.
      //

      SerialLogError(
                    DriverObject,
                    NULL,
                    PUserData->UserPort,
                    SerialPhysicalZero,
                    0,
                    0,
                    0,
                    65,
                    STATUS_SUCCESS,
                    SERIAL_INVALID_USER_CONFIG,
                    UserSubKey->NameLength+sizeof(WCHAR),
                    &UserSubKey->Name[0],
                    (wcslen(Parameters[2].Name)*sizeof(WCHAR))
                    + sizeof(WCHAR),
                    Parameters[2].Name
                    );
      SerialDump(
                SERERRORS,
                ("SERIAL: Bogus vector %ws\n",
                 Parameters[2].Name)
                );

      rval = FALSE;
      goto SerialIsUserDataValidError;
   }

   if (!PUserData->UserSymbolicLink.Length) {

      //
      // Ehhhh! Lose Game.
      //

      SerialLogError(DriverObject, NULL, PUserData->UserPort,
                     SerialPhysicalZero, 0, 0, 0, 66, STATUS_SUCCESS,
                     SERIAL_INVALID_USER_CONFIG,
                     UserSubKey->NameLength + sizeof(WCHAR),
                     &UserSubKey->Name[0],
                     (wcslen(Parameters[3].Name) * sizeof(WCHAR))
                     + sizeof(WCHAR),
                     Parameters[3].Name);

      SerialDump(
                SERERRORS,
                ("SERIAL: bogus value for %ws\n",
                 Parameters[3].Name)
                );

      rval = FALSE;
      goto SerialIsUserDataValidError;
   }

   if (PUserData->UserInterruptStatus.LowPart != 0) {

      if (PUserData->UserPortIndex == MAXULONG) {

         //
         // Ehhhh! Lose Game.
         //

         SerialLogError(
                       DriverObject,
                       NULL,
                       PUserData->UserPort,
                       SerialPhysicalZero,
                       0,
                       0,
                       0,
                       67,
                       STATUS_SUCCESS,
                       SERIAL_INVALID_PORT_INDEX,
                       PUserData->UserSymbolicLink.Length+sizeof(WCHAR),
                       PUserData->UserSymbolicLink.Buffer,
                       0,
                       NULL
                       );
         SerialDump(
                   SERERRORS,
                   ("SERIAL: Bogus port index %ws\n",
                    Parameters[0].Name)
                   );

         rval = FALSE;
         goto SerialIsUserDataValidError;

      } else if (!PUserData->UserPortIndex) {

         //
         // So sorry, you must have a non-zero port index.
         //

         SerialLogError(
                       DriverObject,
                       NULL,
                       PUserData->UserPort,
                       SerialPhysicalZero,
                       0,
                       0,
                       0,
                       68,
                       STATUS_SUCCESS,
                       SERIAL_INVALID_PORT_INDEX,
                       PUserData->UserSymbolicLink.Length+sizeof(WCHAR),
                       PUserData->UserSymbolicLink.Buffer,
                       0,
                       NULL
                       );
         SerialDump(
                   SERERRORS,
                   ("SERIAL: Port index must be > 0 for any\n"
                    "------- port on a multiport card: %ws\n",
                    Parameters[0].Name)
                   );

         rval = FALSE;
         goto SerialIsUserDataValidError;

      } else {

         if (PUserData->UserIndexed) {

            if (PUserData->UserPortIndex > SERIAL_MAX_PORTS_INDEXED) {

               SerialLogError(
                             DriverObject,
                             NULL,
                             PUserData->UserPort,
                             SerialPhysicalZero,
                             0,
                             0,
                             0,
                             69,
                             STATUS_SUCCESS,
                             SERIAL_PORT_INDEX_TOO_HIGH,
                             PUserData->UserSymbolicLink.Length+sizeof(WCHAR),
                             PUserData->UserSymbolicLink.Buffer,
                             0,
                             NULL
                             );
               SerialDump(
                         SERERRORS,
                         ("SERIAL: port index to large %ws\n",
                          Parameters[0].Name)
                         );

               rval = FALSE;
               goto SerialIsUserDataValidError;
            }

         } else {

            if (PUserData->UserPortIndex > SERIAL_MAX_PORTS_NONINDEXED) {

               SerialLogError(
                             DriverObject,
                             NULL,
                             PUserData->UserPort,
                             SerialPhysicalZero,
                             0,
                             0,
                             0,
                             70,
                             STATUS_SUCCESS,
                             SERIAL_PORT_INDEX_TOO_HIGH,
                             PUserData->UserSymbolicLink.Length+sizeof(WCHAR),
                             PUserData->UserSymbolicLink.Buffer,
                             0,
                             NULL
                             );
               SerialDump(
                         SERERRORS,
                         ("SERIAL: port index to large %ws\n",
                          Parameters[0].Name)
                         );

               rval = FALSE;
               goto SerialIsUserDataValidError;
            }

         }

      }

   }

   //
   // We don't want to cause the hal to have a bad day,
   // so let's check the interface type and bus number.
   //
   // We only need to check the registry if they aren't
   // equal to the defaults.
   //

   if ((PUserData->UserBusNumber != 0) ||
       (PUserData->UserInterfaceType != DefaultInterfaceType)) {

      BOOLEAN foundIt;
      if (PUserData->UserInterfaceType >= MaximumInterfaceType) {

         //
         // Ehhhh! Lose Game.
         //

         SerialLogError(
                       DriverObject,
                       NULL,
                       PUserData->UserPort,
                       SerialPhysicalZero,
                       0,
                       0,
                       0,
                       71,
                       STATUS_SUCCESS,
                       SERIAL_UNKNOWN_BUS,
                       PUserData->UserSymbolicLink.Length+sizeof(WCHAR),
                       PUserData->UserSymbolicLink.Buffer,
                       0,
                       NULL
                       );
         SerialDump(
                   SERERRORS,
                   ("SERIAL: Invalid Bus type %ws\n",
                    Parameters[0].Name)
                   );

         rval = FALSE;
         goto SerialIsUserDataValidError;
      }

      IoQueryDeviceDescription(
                              (INTERFACE_TYPE *)&PUserData->UserInterfaceType,
                              &zero,
                              NULL,
                              NULL,
                              NULL,
                              NULL,
                              SerialItemCallBack,
                              &foundIt
                              );

      if (!foundIt) {

         SerialLogError(
                       DriverObject,
                       NULL,
                       PUserData->UserPort,
                       SerialPhysicalZero,
                       0,
                       0,
                       0,
                       72,
                       STATUS_SUCCESS,
                       SERIAL_BUS_NOT_PRESENT,
                       PUserData->UserSymbolicLink.Length+sizeof(WCHAR),
                       PUserData->UserSymbolicLink.Buffer,
                       0,
                       NULL
                       );
         SerialDump(
                   SERERRORS,
                   ("SERIAL: There aren't that many of those\n"
                    "------- busses on this system,%ws\n",
                    Parameters[0].Name)
                   );

         rval = FALSE;
         goto SerialIsUserDataValidError;
      }

   }

   if ((PUserData->UserInterfaceType == MicroChannel) &&
       (PUserData->UserInterruptMode == CM_RESOURCE_INTERRUPT_LATCHED)) {

      SerialLogError(
                    DriverObject,
                    NULL,
                    PUserData->UserPort,
                    SerialPhysicalZero,
                    0,
                    0,
                    0,
                    73,
                    STATUS_SUCCESS,
                    SERIAL_BUS_INTERRUPT_CONFLICT,
                    PUserData->UserSymbolicLink.Length+sizeof(WCHAR),
                    PUserData->UserSymbolicLink.Buffer,
                    0,
                    NULL
                    );
      SerialDump(
                SERERRORS,
                ("SERIAL: Latched interrupts and MicroChannel\n"
                 "------- busses don't mix,%ws\n",
                 Parameters[0].Name)
                );

      rval = FALSE;
      goto SerialIsUserDataValidError;
   }

   SerialDump(
             SERDIAG1,
             ("SERIAL: 'user registry info - userPort: %x\n",
              PUserData->UserPort.LowPart)
             );
   SerialDump(
             SERDIAG1,
             ("SERIAL: 'user registry info - userInterruptStatus: %x\n",
              PUserData->UserInterruptStatus.LowPart)
             );
   SerialDump(
             SERDIAG1,
             ("SERIAL: 'user registry info - userPortIndex: %d\n",
              PUserData->UserPortIndex)
             );
   SerialDump(
             SERDIAG1,
             ("SERIAL: 'user registry info - userClockRate: %d\n",
              PUserData->UserClockRate)
             );
   SerialDump(
             SERDIAG1,
             ("SERIAL: 'user registry info - userBusNumber: %d\n",
              PUserData->UserBusNumber)
             );
   SerialDump(
             SERDIAG1,
             ("SERIAL: 'user registry info - userAddressSpace: %d\n",
              PUserData->UserAddressSpace)
             );
   SerialDump(
             SERDIAG1,
             ("SERIAL: 'user registry info - userInterruptMode: %d\n",
              PUserData->UserInterruptMode)
             );
   SerialDump(
             SERDIAG1,
             ("SERIAL: 'user registry info - userInterfaceType: %d\n",
              PUserData->UserInterfaceType)
             );
   SerialDump(
             SERDIAG1,
             ("SERIAL: 'user registry info - userVector: %d\n",
              PUserData->UserVector)
             );
   SerialDump(
             SERDIAG1,
             ("SERIAL: 'user registry info - userLevel: %d\n",
              PUserData->UserLevel)
             );
   SerialDump(
             SERDIAG1,
             ("SERIAL: 'user registry info - userIndexed: %d\n",
              PUserData->UserIndexed)
             );


   SerialDump(SERTRACECALLS, ("SERIAL: Leave SerialIsUserDataValid\n"));

   SerialIsUserDataValidError:

   return rval;

}


NTSTATUS
SerialEnumerateLegacy(IN PDRIVER_OBJECT DriverObject,
                      IN PUNICODE_STRING RegistryPath,
                      IN PSERIAL_FIRMWARE_DATA DriverDefaultsPtr)

/*++

Routine Description:

    This routine will enumerate and initialize all legacy serial ports that
    have just been scribbled into the registry.  These are usually non-
    intelligent multiport boards, but can be any type of "standard" serial
    port.


    This is pageable INIT because it is only called from DriverEntry.


Arguments:

    DriverObject - Used only for logging errors.

    RegistryPath - Path to this drivers service node in
                   the current control set.

    DriverDefaultsPtr - Pointer to structure of driver-wide defaults.

Return Value:

    STATUS_SUCCESS if consistant configuration was found - otherwise.
    returns STATUS_SERIAL_NO_DEVICE_INITED.

--*/

{

   SERIAL_FIRMWARE_DATA firmware;

   PRTL_QUERY_REGISTRY_TABLE parameters = NULL;

   INTERFACE_TYPE interfaceType;
   ULONG defaultInterfaceType;

   PULONG countSoFar = &IoGetConfigurationInformation()->SerialCount;


   //
   // Default values for user data.
   //
   ULONG maxUlong = MAXULONG;
   ULONG zero = 0;
   ULONG nonzero = 1;
   ULONG badValue = (ULONG)-1;

   ULONG defaultInterruptMode;
   ULONG defaultAddressSpace = CM_RESOURCE_PORT_IO;

   //
   // Where user data from the registry will be placed.
   //
   SERIAL_USER_DATA userData;
   ULONG legacyDiscovered;

   UNICODE_STRING PnPID;
   UNICODE_STRING legacyKeys;

   UNICODE_STRING parametersPath;
   OBJECT_ATTRIBUTES parametersAttributes;
   HANDLE parametersKey;
   HANDLE pnpKey;
   PKEY_BASIC_INFORMATION userSubKey = NULL;
   ULONG i;

   PCM_RESOURCE_LIST resourceList = NULL;
   PCM_RESOURCE_LIST trResourceList = NULL;
   PIO_RESOURCE_REQUIREMENTS_LIST pRequiredList = NULL;
   ULONG countOfPartials;
   PDEVICE_OBJECT newPdo;
   ULONG brokenStatus;

   PAGED_CODE();

   SerialDump(SERTRACECALLS, ("SERIAL: Enter SerialEnumerateLegacy\n"));

   PnPID.Buffer = NULL;
   legacyKeys.Buffer = NULL;
   userData.UserSymbolicLink.Buffer = NULL;
   parametersPath.Buffer = NULL;

   userData.ForceFIFOEnableDefault = DriverDefaultsPtr->ForceFifoEnableDefault;
   userData.PermitShareDefault = DriverDefaultsPtr->PermitShareDefault;
   userData.LogFIFODefault = DriverDefaultsPtr->LogFifoDefault;
   userData.DefaultPermitSystemWideShare = FALSE;
   userData.RxFIFODefault = DriverDefaultsPtr->RxFIFODefault;
   userData.TxFIFODefault = DriverDefaultsPtr->TxFIFODefault;

   

   //
   // Start of normal configuration and detection.
   //

   //
   // Query the registry one more time.  This time we
   // look for the first bus on the system (that isn't
   // the internal bus - we assume that the firmware
   // code knows about those ports).  We will use that
   // as the default bus if no bustype or bus number
   // is specified in the "user" configuration records.
   //

   defaultInterfaceType = (ULONG)Isa;
   defaultInterruptMode = CM_RESOURCE_INTERRUPT_LATCHED;

   for (
       interfaceType = 0;
       interfaceType < MaximumInterfaceType;
       interfaceType++
       ) {

      ULONG busZero = 0;
      BOOLEAN foundOne = FALSE;

      if (interfaceType != Internal) {

         IoQueryDeviceDescription(
                                 &interfaceType,
                                 &busZero,
                                 NULL,
                                 NULL,
                                 NULL,
                                 NULL,
                                 SerialItemCallBack,
                                 &foundOne
                                 );

         if (foundOne) {

            defaultInterfaceType = (ULONG)interfaceType;
            if (defaultInterfaceType == MicroChannel) {

               defaultInterruptMode = CM_RESOURCE_INTERRUPT_LEVEL_SENSITIVE;

               //
               // Microchannel machines can permit the interrupt to be
               // shared system wide.
               //

               userData.DefaultPermitSystemWideShare = TRUE;

            }

            break;

         }

      }

   }

   //
   // Gonna get the user data now.  Allocate the
   // structures that we will be using throughout
   // the search for user data.  We will deallocate
   // them before we leave this routine.
   //

   userData.UserSymbolicLink.Buffer = NULL;
   parametersPath.Buffer = NULL;

   //
   // Allocate the rtl query table.  This should have an entry for each value
   // we retrieve from the registry as well as a terminating zero entry as
   // well the first "goto subkey" entry.
   //

   parameters = ExAllocatePool(
                              PagedPool,
                              sizeof(RTL_QUERY_REGISTRY_TABLE)*22
                              );

   if (!parameters) {

      SerialLogError(
                    DriverObject,
                    NULL,
                    SerialPhysicalZero,
                    SerialPhysicalZero,
                    0,
                    0,
                    0,
                    74,
                    STATUS_SUCCESS,
                    SERIAL_INSUFFICIENT_RESOURCES,
                    0,
                    NULL,
                    0,
                    NULL
                    );
      SerialDump(
                SERERRORS,
                ("SERIAL: Couldn't allocate table for rtl query\n"
                 "------  to parameters for %wZ",
                 RegistryPath)
                );

      goto LegacyInitLeave;

   }

   RtlZeroMemory(
                parameters,
                sizeof(RTL_QUERY_REGISTRY_TABLE)*22
                );

   //
   // Allocate the place where the user's symbolic link name
   // for the port will go.
   //

   //
   // We will initially allocate space for 257 wchars.
   // we will then set the maximum size to 256
   // This way the rtl routine could return a 256
   // WCHAR wide string with no null terminator.
   // We'll remember that the buffer is one WCHAR
   // longer then it says it is so that we can always
   // have a NULL terminator at the end.
   //

   RtlInitUnicodeString(&userData.UserSymbolicLink, NULL);
   userData.UserSymbolicLink.MaximumLength = sizeof(WCHAR) * 256;
   userData.UserSymbolicLink.Buffer = ExAllocatePool(PagedPool, sizeof(WCHAR)
                                                     * 257);

   if (!userData.UserSymbolicLink.Buffer) {

      SerialLogError(
                    DriverObject,
                    NULL,
                    SerialPhysicalZero,
                    SerialPhysicalZero,
                    0,
                    0,
                    0,
                    75,
                    STATUS_SUCCESS,
                    SERIAL_INSUFFICIENT_RESOURCES,
                    0,
                    NULL,
                    0,
                    NULL
                    );
      SerialDump(
                SERERRORS,
                ("SERIAL: Couldn't allocate buffer for the symbolic link\n"
                 "------  for parameters items in %wZ",
                 RegistryPath)
                );

      goto LegacyInitLeave;

   }





   //
   // We will initially allocate space for 257 wchars.
   // we will then set the maximum size to 256
   // This way the rtl routine could return a 256
   // WCHAR wide string with no null terminator.
   // We'll remember that the buffer is one WCHAR
   // longer then it says it is so that we can always
   // have a NULL terminator at the end.
   //

   RtlInitUnicodeString(&PnPID, NULL);
   PnPID.MaximumLength = sizeof(WCHAR) * 256;
   PnPID.Buffer = ExAllocatePool(PagedPool, sizeof(WCHAR) * 257);

   if (PnPID.Buffer == 0) {

      SerialLogError(
                    DriverObject,
                    NULL,
                    SerialPhysicalZero,
                    SerialPhysicalZero,
                    0,
                    0,
                    0,
                    76,
                    STATUS_SUCCESS,
                    SERIAL_INSUFFICIENT_RESOURCES,
                    0,
                    NULL,
                    0,
                    NULL
                    );
      SerialDump(
                SERERRORS,
                ("SERIAL: Couldn't allocate buffer for the PnP ID\n"
                 "------  for parameters items in %wZ",
                 RegistryPath)
                );

      goto LegacyInitLeave;

   }


   // Initialize the legacy key buffer
   RtlInitUnicodeString(&legacyKeys, NULL);
   legacyKeys.MaximumLength = sizeof(WCHAR) * 256;
   legacyKeys.Buffer = ExAllocatePool(PagedPool, sizeof(WCHAR) * 257);

   if (!legacyKeys.Buffer) {

      SerialLogError(
                    DriverObject,
                    NULL,
                    SerialPhysicalZero,
                    SerialPhysicalZero,
                    0,
                    0,
                    0,
                    77,
                    STATUS_SUCCESS,
                    SERIAL_INSUFFICIENT_RESOURCES,
                    0,
                    NULL,
                    0,
                    NULL
                    );

      SerialDump(SERERRORS, ("SERIAL: Couldn't allocate buffer for the legacy"
                             " keys\n"));

      goto LegacyInitLeave;

   }

   resourceList = ExAllocatePool(PagedPool, sizeof(CM_RESOURCE_LIST)
                                 + sizeof(CM_PARTIAL_RESOURCE_DESCRIPTOR) * 2);

   if (resourceList == NULL) {
      SerialLogError(
                    DriverObject,
                    NULL,
                    userData.UserPort,
                    SerialPhysicalZero,
                    0,
                    0,
                    0,
                    78,
                    STATUS_SUCCESS,
                    SERIAL_INSUFFICIENT_RESOURCES,
                    0,
                    NULL,
                    0,
                    NULL
                    );
      goto LegacyInitLeave;
   }

   trResourceList = ExAllocatePool(PagedPool, sizeof(CM_RESOURCE_LIST)
                                   + sizeof(CM_PARTIAL_RESOURCE_DESCRIPTOR)
                                   * 2);

   if (trResourceList == NULL) {
      SerialLogError(
                    DriverObject,
                    NULL,
                    userData.UserPort,
                    SerialPhysicalZero,
                    0,
                    0,
                    0,
                    79,
                    STATUS_SUCCESS,
                    SERIAL_INSUFFICIENT_RESOURCES,
                    0,
                    NULL,
                    0,
                    NULL
                    );
      goto LegacyInitLeave;
   }


   pRequiredList
      = ExAllocatePool(PagedPool, sizeof(IO_RESOURCE_REQUIREMENTS_LIST)
                       + sizeof(IO_RESOURCE_DESCRIPTOR) * 2);

   if (pRequiredList == NULL) {
      SerialLogError(
                    DriverObject,
                    NULL,
                    userData.UserPort,
                    SerialPhysicalZero,
                    0,
                    0,
                    0,
                    80,
                    STATUS_SUCCESS,
                    SERIAL_INSUFFICIENT_RESOURCES,
                    0,
                    NULL,
                    0,
                    NULL
                    );

      goto LegacyInitLeave;
   }


   //
   // Form a path to our drivers Parameters subkey.
   //

   RtlInitUnicodeString(
                       &parametersPath,
                       NULL
                       );

   parametersPath.MaximumLength = RegistryPath->Length +
                                  sizeof(L"\\") +
                                  sizeof(L"Parameters");

   parametersPath.Buffer = ExAllocatePool(
                                         PagedPool,
                                         parametersPath.MaximumLength
                                         );

   if (!parametersPath.Buffer) {

      SerialLogError(
                    DriverObject,
                    NULL,
                    SerialPhysicalZero,
                    SerialPhysicalZero,
                    0,
                    0,
                    0,
                    81,
                    STATUS_SUCCESS,
                    SERIAL_INSUFFICIENT_RESOURCES,
                    0,
                    NULL,
                    0,
                    NULL
                    );
      SerialDump(
                SERERRORS,
                ("SERIAL: Couldn't allocate string for path\n"
                 "------  to parameters for %wZ",
                 RegistryPath)
                );

      goto LegacyInitLeave;

   }

   //
   // Form the parameters path.
   //

   RtlZeroMemory(
                parametersPath.Buffer,
                parametersPath.MaximumLength
                );
   RtlAppendUnicodeStringToString(
                                 &parametersPath,
                                 RegistryPath
                                 );
   RtlAppendUnicodeToString(
                           &parametersPath,
                           L"\\"
                           );
   RtlAppendUnicodeToString(
                           &parametersPath,
                           L"Parameters"
                           );

   //
   // Form the start of the legacy keys string
   //
   RtlZeroMemory(legacyKeys.Buffer, legacyKeys.MaximumLength);
   RtlAppendUnicodeStringToString(&legacyKeys, &parametersPath);


   userSubKey = ExAllocatePool(
                              PagedPool,
                              sizeof(KEY_BASIC_INFORMATION)+(sizeof(WCHAR)*256)
                              );

   if (!userSubKey) {

      SerialLogError(
                    DriverObject,
                    NULL,
                    SerialPhysicalZero,
                    SerialPhysicalZero,
                    0,
                    0,
                    0,
                    82,
                    STATUS_SUCCESS,
                    SERIAL_INSUFFICIENT_RESOURCES,
                    0,
                    NULL,
                    0,
                    NULL
                    );
      SerialDump(
                SERERRORS,
                ("SERIAL: Couldn't allocate memory basic information\n"
                 "------  structure to enumerate subkeys for %wZ",
                 &parametersPath)
                );

      goto LegacyInitLeave;

   }

   //
   // Open the key given by our registry path & Parameters.
   //

   InitializeObjectAttributes(
                             &parametersAttributes,
                             &parametersPath,
                             OBJ_CASE_INSENSITIVE,
                             NULL,
                             NULL
                             );

   if (!NT_SUCCESS(ZwOpenKey(
                            &parametersKey,
                            MAXIMUM_ALLOWED,
                            &parametersAttributes
                            ))) {

      SerialLogError(
                    DriverObject,
                    NULL,
                    SerialPhysicalZero,
                    SerialPhysicalZero,
                    0,
                    0,
                    0,
                    83,
                    STATUS_SUCCESS,
                    SERIAL_NO_PARAMETERS_INFO,
                    0,
                    NULL,
                    0,
                    NULL
                    );
      SerialDump(
                SERERRORS,
                ("SERIAL: Couldn't open the drivers Parameters key %wZ\n",
                 RegistryPath)
                );
      goto LegacyInitLeave;

   }



   parameters[0].Flags = RTL_QUERY_REGISTRY_SUBKEY;

   parameters[1].Flags = RTL_QUERY_REGISTRY_DIRECT;
   parameters[1].Name = L"PortAddress";
   parameters[1].EntryContext = &userData.UserPort.LowPart;
   parameters[1].DefaultType = REG_DWORD;
   parameters[1].DefaultData = &zero;
   parameters[1].DefaultLength = sizeof(ULONG);

   parameters[2].Flags = RTL_QUERY_REGISTRY_DIRECT;
   parameters[2].Name = L"Interrupt";
   parameters[2].EntryContext = &userData.UserVector;
   parameters[2].DefaultType = REG_DWORD;
   parameters[2].DefaultData = &zero;
   parameters[2].DefaultLength = sizeof(ULONG);

   parameters[3].Flags = RTL_QUERY_REGISTRY_DIRECT;
   parameters[3].Name = DEFAULT_DIRECTORY;
   parameters[3].EntryContext = &userData.UserSymbolicLink;
   parameters[3].DefaultType = REG_SZ;
   parameters[3].DefaultData = L"";
   parameters[3].DefaultLength = 0;

   parameters[4].Flags = RTL_QUERY_REGISTRY_DIRECT;
   parameters[4].Name = L"InterruptStatus";
   parameters[4].EntryContext = &userData.UserInterruptStatus.LowPart;
   parameters[4].DefaultType = REG_DWORD;
   parameters[4].DefaultData = &zero;
   parameters[4].DefaultLength = sizeof(ULONG);

   parameters[5].Flags = RTL_QUERY_REGISTRY_DIRECT;
   parameters[5].Name = L"PortIndex";
   parameters[5].EntryContext = &userData.UserPortIndex;
   parameters[5].DefaultType = REG_DWORD;
   parameters[5].DefaultData = &zero;
   parameters[5].DefaultLength = sizeof(ULONG);

   parameters[6].Flags = RTL_QUERY_REGISTRY_DIRECT;
   parameters[6].Name = L"BusNumber";
   parameters[6].EntryContext = &userData.UserBusNumber;
   parameters[6].DefaultType = REG_DWORD;
   parameters[6].DefaultData = &zero;
   parameters[6].DefaultLength = sizeof(ULONG);

   parameters[7].Flags = RTL_QUERY_REGISTRY_DIRECT;
   parameters[7].Name = L"BusType";
   parameters[7].EntryContext = &userData.UserInterfaceType;
   parameters[7].DefaultType = REG_DWORD;
   parameters[7].DefaultData = &defaultInterfaceType;
   parameters[7].DefaultLength = sizeof(ULONG);

   parameters[8].Flags = RTL_QUERY_REGISTRY_DIRECT;
   parameters[8].Name = L"ClockRate";
   parameters[8].EntryContext = &userData.UserClockRate;
   parameters[8].DefaultType = REG_DWORD;
   parameters[8].DefaultData = &badValue;
   parameters[8].DefaultLength = sizeof(ULONG);

   parameters[9].Flags = RTL_QUERY_REGISTRY_DIRECT;
   parameters[9].Name = L"Indexed";
   parameters[9].EntryContext = &userData.UserIndexed;
   parameters[9].DefaultType = REG_DWORD;
   parameters[9].DefaultData = &badValue;
   parameters[9].DefaultLength = sizeof(ULONG);

   parameters[10].Flags = RTL_QUERY_REGISTRY_DIRECT;
   parameters[10].Name = L"InterruptMode";
   parameters[10].EntryContext = &userData.UserInterruptMode;
   parameters[10].DefaultType = REG_DWORD;
   parameters[10].DefaultData = &defaultInterruptMode;
   parameters[10].DefaultLength = sizeof(ULONG);

   parameters[11].Flags = RTL_QUERY_REGISTRY_DIRECT;
   parameters[11].Name = L"AddressSpace";
   parameters[11].EntryContext = &userData.UserAddressSpace;
   parameters[11].DefaultType = REG_DWORD;
   parameters[11].DefaultData = &defaultAddressSpace;
   parameters[11].DefaultLength = sizeof(ULONG);

   parameters[12].Flags = RTL_QUERY_REGISTRY_DIRECT;
   parameters[12].Name = L"InterruptLevel";
   parameters[12].EntryContext = &userData.UserLevel;
   parameters[12].DefaultType = REG_DWORD;
   parameters[12].DefaultData = &zero;
   parameters[12].DefaultLength = sizeof(ULONG);

   parameters[13].Flags = RTL_QUERY_REGISTRY_DIRECT;
   parameters[13].Name = L"DisablePort";
   parameters[13].EntryContext = &userData.DisablePort;
   parameters[13].DefaultType = REG_DWORD;
   parameters[13].DefaultData = &badValue;
   parameters[13].DefaultLength = sizeof(ULONG);

   parameters[14].Flags = RTL_QUERY_REGISTRY_DIRECT;
   parameters[14].Name = L"ForceFifoEnable";
   parameters[14].EntryContext = &userData.ForceFIFOEnable;
   parameters[14].DefaultType = REG_DWORD;
   parameters[14].DefaultData = &badValue;
   parameters[14].DefaultLength = sizeof(ULONG);

   parameters[15].Flags = RTL_QUERY_REGISTRY_DIRECT;
   parameters[15].Name = L"RxFIFO";
   parameters[15].EntryContext = &userData.RxFIFO;
   parameters[15].DefaultType = REG_DWORD;
   parameters[15].DefaultData = &badValue;
   parameters[15].DefaultLength = sizeof(ULONG);

   parameters[16].Flags = RTL_QUERY_REGISTRY_DIRECT;
   parameters[16].Name = L"TxFIFO";
   parameters[16].EntryContext = &userData.TxFIFO;
   parameters[16].DefaultType = REG_DWORD;
   parameters[16].DefaultData = &badValue;
   parameters[16].DefaultLength = sizeof(ULONG);

   parameters[17].Flags = RTL_QUERY_REGISTRY_DIRECT;
   parameters[17].Name = L"MaskInverted";
   parameters[17].EntryContext = &userData.MaskInverted;
   parameters[17].DefaultType = REG_DWORD;
   parameters[17].DefaultData = &zero;
   parameters[17].DefaultLength = sizeof(ULONG);

   parameters[18].Flags = RTL_QUERY_REGISTRY_DIRECT;
   parameters[18].Name = L"PnPDeviceID";
   parameters[18].EntryContext = &PnPID;
   parameters[18].DefaultType = REG_SZ;
   parameters[18].DefaultData = L"";
   parameters[18].DefaultLength = 0;

   parameters[19].Flags = RTL_QUERY_REGISTRY_DIRECT;
   parameters[19].Name = L"LegacyDiscovered";
   parameters[19].EntryContext = &legacyDiscovered;
   parameters[19].DefaultType = REG_DWORD;
   parameters[19].DefaultData = &zero;
   parameters[19].DefaultLength = sizeof(ULONG);

   //
   // This is for a buggy Digi serial.ini that worked with pre-NT5.0
   // by accident.  DO NOT USE "Interrupt Status" in the future; its
   // use is deprecated.  Use the correct "InterruptStatus"
   //

   parameters[20].Flags = RTL_QUERY_REGISTRY_DIRECT;
   parameters[20].Name = L"Interrupt Status";
   parameters[20].EntryContext = &brokenStatus;
   parameters[20].DefaultType = REG_DWORD;
   parameters[20].DefaultData = &zero;
   parameters[20].DefaultLength = sizeof(ULONG);


   i = 0;

   while (TRUE) {

      NTSTATUS status;
      ULONG actuallyReturned;
      PDEVICE_OBJECT newDevObj = NULL;
      PSERIAL_DEVICE_EXTENSION deviceExtension;
      PDEVICE_OBJECT lowerDevice;

      //
      // We lie about the length of the buffer, so that we can
      // MAKE SURE that the name it returns can be padded with
      // a NULL.
      //

      status = ZwEnumerateKey(
                             parametersKey,
                             i,
                             KeyBasicInformation,
                             userSubKey,
                             sizeof(KEY_BASIC_INFORMATION)+(sizeof(WCHAR)*255),
                             &actuallyReturned
                             );


      if (status == STATUS_NO_MORE_ENTRIES) {

         break;
      }

      if (status == STATUS_BUFFER_OVERFLOW) {

         SerialLogError(
                       DriverObject,
                       NULL,
                       SerialPhysicalZero,
                       SerialPhysicalZero,
                       0,
                       0,
                       0,
                       84,
                       STATUS_SUCCESS,
                       SERIAL_UNABLE_TO_ACCESS_CONFIG,
                       0,
                       NULL,
                       0,
                       NULL
                       );
         SerialDump(
                   SERERRORS,
                   ("SERIAL: Overflowed the enumerate buffer\n"
                    "------- for subkey #%d of %wZ\n",
                    i,parametersPath)
                   );
         i++;
         continue;

      }

      if (!NT_SUCCESS(status)) {

         SerialLogError(
                       DriverObject,
                       NULL,
                       SerialPhysicalZero,
                       SerialPhysicalZero,
                       0,
                       0,
                       0,
                       85,
                       STATUS_SUCCESS,
                       SERIAL_UNABLE_TO_ACCESS_CONFIG,
                       0,
                       NULL,
                       0,
                       NULL
                       );
         SerialDump(
                   SERERRORS,
                   ("SERIAL: Bad status returned: %x \n"
                    "------- on enumeration for subkey # %d of %wZ\n",
                    status,i,parametersPath)
                   );
         i++;
         continue;

      }

      //
      // Pad the name returned with a null.
      //

      RtlZeroMemory(
                   ((PUCHAR)(&userSubKey->Name[0]))+userSubKey->NameLength,
                   sizeof(WCHAR)
                   );

      parameters[0].Name = &userSubKey->Name[0];

      //
      // Make sure that the physical addresses start
      // out clean.
      //

      RtlZeroMemory(&userData.UserPort, sizeof(userData.UserPort));
      RtlZeroMemory(&userData.UserInterruptStatus,
                    sizeof(userData.UserInterruptStatus));

      //
      // Make sure the symbolic link buffer starts clean
      //

      RtlZeroMemory(userData.UserSymbolicLink.Buffer, 
                    userData.UserSymbolicLink.MaximumLength);
      userData.UserSymbolicLink.Length = 0;


      status = RtlQueryRegistryValues(
                                     RTL_REGISTRY_ABSOLUTE,
                                     parametersPath.Buffer,
                                     parameters,
                                     NULL,
                                     NULL
                                     );
      if (!NT_SUCCESS(status)) {
         SerialLogError(
                       DriverObject,
                       NULL,
                       SerialPhysicalZero,
                       SerialPhysicalZero,
                       0,
                       0,
                       0,
                       86,
                       STATUS_SUCCESS,
                       SERIAL_INVALID_USER_CONFIG,
                       userSubKey->NameLength+sizeof(WCHAR),
                       &userSubKey->Name[0],
                       0,
                       NULL
                       );
         SerialDump(
                   SERERRORS,
                   ("SERIAL: Bad status returned: %x \n"
                    "------- for the value entries of\n"
                    "-------  %ws\n",
                    status,parameters[0].Name)
                   );

         i++;
         continue;
      }


      //
      // Well! Some supposedly valid information was found!
      //
      // We'll see about that.
      //

      //
      // If this is PnP, skip it -- it will be found by an enumerator
      //

      if (PnPID.Length != 0) {
         i++;
         continue;
      }

      //
      // If this was found on a previous boot, skip it -- PnP will send
      // us an add_device()/start_device() for it.
      //

      if (legacyDiscovered != 0) {
         i++;
         continue;
      }

      //
      // Let's just jam the WCHAR null at the end of the
      // user symbolic link.  Remember that we left room for
      // one when we allocated it's buffer.
      //

      RtlZeroMemory(((PUCHAR)(&userData.UserSymbolicLink.Buffer[0]))
                    + userData.UserSymbolicLink.Length, sizeof(WCHAR));

      //
      // See if this has a busted serial.ini and convert it over.
      //

      if (brokenStatus != 0) {
            userData.UserInterruptStatus.LowPart = brokenStatus;
      }

      //
      // Call a function to validate the data.
      //

      if (SerialIsUserDataValid(DriverObject, userSubKey, parameters,
                                defaultInterfaceType, &userData) == FALSE) {
         i++;
         continue;
      }


      //
      // Well ok, I guess we can take the data.
      // There be other tests later on to make
      // sure it doesn't have any other kinds
      // of conflicts.
      //

      //
      // Report this device to the PnP Manager and create the device object
      // Also update the registry entry for this device so we don't enumerate
      // it next time.
      //

      //
      // Build resource lists
      //

      status = SerialBuildResourceList(resourceList, &countOfPartials,
                                       &userData);

      if (!NT_SUCCESS(status)) {
         i++;
         continue;
      }

      ASSERT(countOfPartials >= 2);

      status = SerialTranslateResourceList(DriverObject, userSubKey,
                                           trResourceList, resourceList,
                                           countOfPartials, &userData);

      if (!NT_SUCCESS(status)) {
         i++;
         continue;
      }

      status = SerialBuildRequirementsList(pRequiredList, countOfPartials,
                                           &userData);

      if (!NT_SUCCESS(status)) {
         i++;
         continue;
      }

      newPdo = NULL;

      //
      // We want **untranslated** resources passed to this call
      // since it calls IoReportResourceUsage() for us.
      //

      status = IoReportDetectedDevice(
                   DriverObject,
                   InterfaceTypeUndefined,
                   -1,
                   -1,
                   resourceList,
                   pRequiredList,
                   FALSE,
                   &newPdo
               );

      //
      // If we fail, we can keep going but we need to see this device next
      // time, so we won't write its discovery into the registry.
      //

      if (!NT_SUCCESS(status)) {
         if (status == STATUS_INSUFFICIENT_RESOURCES) {
            SerialLogError(DriverObject, NULL, userData.UserPort,
                           SerialPhysicalZero, 0, 0, 0, 89, status,
                           SERIAL_NO_DEVICE_REPORT_RES, userSubKey->NameLength
                           + sizeof(WCHAR), &userSubKey->Name[0], 0,
                           NULL);
         } else {
            SerialLogError(DriverObject, NULL, userData.UserPort,
                           SerialPhysicalZero, 0, 0, 0, 87, status,
                           SERIAL_NO_DEVICE_REPORT, userSubKey->NameLength
                           + sizeof(WCHAR), &userSubKey->Name[0], 0, NULL);
         }

         SerialDump(SERERRORS, ("SERIAL: Could not report legacy device - %x\n",
                                status));
         i++;
         continue;
      }


      //
      // Scribble our name in PnP land
      //

      status = SerialMigrateLegacyRegistry(newPdo, &userData,
                                           (BOOLEAN)(countOfPartials == 3
                                                     ? TRUE : FALSE));

      if (!NT_SUCCESS(status)) {
         //
         // For now leave pdo floating until there is a cleanup
         // for IoReportDetectedDevice()
         //
         i++;
         continue;
      }

      //
      // Now, we call our add device and start device for this PDO
      //

      status = SerialCreateDevObj(DriverObject, &newDevObj);

      if (!NT_SUCCESS(status)) {
         //
         // For now leave pdo floating until there is a cleanup
         // for IoReportDetectedDevice()
         //
         i++;
         continue;
      }

      lowerDevice = IoAttachDeviceToDeviceStack(newDevObj, newPdo);
      deviceExtension = newDevObj->DeviceExtension;
      deviceExtension->LowerDeviceObject = lowerDevice;
      deviceExtension->Pdo = newPdo;
      newDevObj->Flags |= DO_POWER_PAGABLE | DO_BUFFERED_IO;

      //
      // Try to start the device...
      //

      SerialLockPagableSectionByHandle(SerialGlobals.PAGESER_Handle);


      status = SerialFinishStartDevice(newDevObj, resourceList, trResourceList,
                                       &userData);

      SerialUnlockPagableImageSection(SerialGlobals.PAGESER_Handle);


      //
      // If the port is disabled, SerialFinishStartDevice returns
      // an error, but we should still mark legacydiscovered and
      // leave the registry migrated.
      //

      if (!NT_SUCCESS(status)) {
         //
         // For now leave pdo floating until there is a cleanup
         // for IoReportDetectedDevice()
         //

         SerialRemoveDevObj(newDevObj);

         i++;
         continue;
      }

      //
      // Fix up the path to the entry we are currently working on
      //

      RtlAppendUnicodeToString(&legacyKeys, L"\\");
      RtlAppendUnicodeToString(&legacyKeys, &userSubKey->Name[0]);

      status = RtlWriteRegistryValue(RTL_REGISTRY_ABSOLUTE,
                                     legacyKeys.Buffer,
                                     L"LegacyDiscovered", REG_DWORD,
                                     &nonzero, sizeof(nonzero));

      //
      // Clean up our path buffer
      //

      RtlZeroMemory(legacyKeys.Buffer, legacyKeys.MaximumLength);
      legacyKeys.Length = 0;
      RtlAppendUnicodeStringToString(&legacyKeys, &parametersPath);

      //
      // Failure is non-fatal; it just means that the device will be
      // re-enumerated next time, and a collision will occur.
      //

      if (!NT_SUCCESS(status)) {
         SerialLogError(DriverObject, NULL, userData.UserPort,
                        SerialPhysicalZero, 0, 0, 0, 88, STATUS_SUCCESS,
                        SERIAL_REGISTRY_WRITE_FAILED, 0, NULL, 0, NULL);

         SerialDump(SERERRORS, ("SERIAL: Couldn't write registry value"
                                "for LegacyDiscovered in %wZ\n",
                                legacyKeys));
      }

      i++;
      (*countSoFar)++;

   } // while(TRUE)

   ZwClose(parametersKey);

   LegacyInitLeave:;

   if (userSubKey != NULL) {
      ExFreePool(userSubKey);
   }

   if (PnPID.Buffer != NULL) {
      ExFreePool(PnPID.Buffer);
   }

   if (legacyKeys.Buffer != NULL) {
      ExFreePool(legacyKeys.Buffer); 
   }

   if (userData.UserSymbolicLink.Buffer != NULL) {
      ExFreePool(userData.UserSymbolicLink.Buffer);
   }

   if (parametersPath.Buffer != NULL) {
      ExFreePool(parametersPath.Buffer);
   }

   if (parameters != NULL) {
      ExFreePool(parameters);
   }

   if (resourceList != NULL) {
      ExFreePool(resourceList);
   }

   if (trResourceList != NULL) {
      ExFreePool(trResourceList);
   }

   if (pRequiredList != NULL) {
      ExFreePool(pRequiredList);
   }


   SerialDump(SERTRACECALLS, ("SERIAL: Leave SerialEnumerateLegacy\n"));

   return STATUS_SUCCESS;
}
#endif // NO_LEGACY_DRIVERS
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\ser101\openclos.c ===
/*++

Copyright (c) 1991, 1992, 1993 - 1997 Microsoft Corporation

Module Name:

    openclos.c

Abstract:

    This module contains the code that is very specific to
    opening, closing, and cleaning up in the serial driver.

Author:

    Anthony V. Ercolano 26-Sep-1991

Environment:

    Kernel mode

--*/

#include "precomp.h"


BOOLEAN
SerialMarkOpen(
    IN PVOID Context
    );

BOOLEAN
SerialCheckOpen(
    IN PVOID Context
    );

BOOLEAN
SerialNullSynch(
    IN PVOID Context
    );

NTSTATUS
SerialCreateOpen(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );


#ifdef ALLOC_PRAGMA

//
// Paged for open and PnP transactions
//

#pragma alloc_text(PAGESER,SerialGetCharTime)
#pragma alloc_text(PAGESER,SerialCleanup)
#pragma alloc_text(PAGESER,SerialClose)
#pragma alloc_text(PAGESER, SerialCheckOpen)
#pragma alloc_text(PAGESER, SerialMarkOpen)

//
// Always paged
//

#pragma alloc_text(PAGESRP0,SerialCreateOpen)
#pragma alloc_text(PAGESRP0, SerialDrainUART)
#endif // ALLOC_PRAGMA

typedef struct _SERIAL_CHECK_OPEN {
    PSERIAL_DEVICE_EXTENSION Extension;
    NTSTATUS *StatusOfOpen;
    } SERIAL_CHECK_OPEN,*PSERIAL_CHECK_OPEN;

//
// Just a bogus little routine to make sure that we
// can synch with the ISR.
//

BOOLEAN
SerialNullSynch(
    IN PVOID Context
    ) {

    UNREFERENCED_PARAMETER(Context);
    return FALSE;
}

NTSTATUS
SerialCreateOpen(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    We connect up to the interrupt for the create/open and initialize
    the structures needed to maintain an open for a device.

Arguments:

    DeviceObject - Pointer to the device object for this device

    Irp - Pointer to the IRP for the current request

Return Value:

    The function value is the final status of the call

--*/

{

    PSERIAL_DEVICE_EXTENSION extension = DeviceObject->DeviceExtension;
    SERIAL_CHECK_OPEN checkOpen;
    NTSTATUS localStatus;

    PAGED_CODE();

    if (extension->PNPState != SERIAL_PNP_STARTED) {
       Irp->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;
       IoCompleteRequest(Irp, IO_NO_INCREMENT);
       return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Lock out changes to PnP state until we have our open state decided
    //

    ExAcquireFastMutex(&extension->OpenMutex);

    if ((localStatus = SerialIRPPrologue(Irp, extension)) != STATUS_SUCCESS) {
       ExReleaseFastMutex(&extension->OpenMutex);
       SerialCompleteRequest(extension, Irp, IO_NO_INCREMENT);
       return localStatus;
    }

    if (InterlockedIncrement(&extension->OpenCount) != 1) {
       ExReleaseFastMutex(&extension->OpenMutex);
       InterlockedDecrement(&extension->OpenCount);
       Irp->IoStatus.Status = STATUS_ACCESS_DENIED;
       SerialCompleteRequest(extension, Irp, IO_NO_INCREMENT);
       return STATUS_ACCESS_DENIED;
    }

    SerialDump(
        SERIRPPATH,
        ("SERIAL: Dispatch entry for: %x\n",Irp)
        );
    SerialDump(
        SERDIAG3,
        ("SERIAL: In SerialCreateOpen\n")
        );

    //
    // Before we do anything, let's make sure they aren't trying
    // to create a directory. what's a driver to do!?
    //

    if (IoGetCurrentIrpStackLocation(Irp)->Parameters.Create.Options &
        FILE_DIRECTORY_FILE) {
        ExReleaseFastMutex(&extension->OpenMutex);

        Irp->IoStatus.Status = STATUS_NOT_A_DIRECTORY;
        Irp->IoStatus.Information = 0;

        SerialDump(
            SERIRPPATH,
            ("SERIAL: Complete Irp: %x\n",Irp)
            );



        InterlockedDecrement(&extension->OpenCount);
        SerialCompleteRequest(extension, Irp, IO_NO_INCREMENT);

        return STATUS_NOT_A_DIRECTORY;

    }

    //
    // Create a buffer for the RX data when no reads are outstanding.
    //

    extension->InterruptReadBuffer = NULL;
    extension->BufferSize = 0;

    switch (MmQuerySystemSize()) {

        case MmLargeSystem: {

            extension->BufferSize = 4096;
            extension->InterruptReadBuffer = ExAllocatePool(
                                                 NonPagedPool,
                                                 extension->BufferSize
                                                 );

            if (extension->InterruptReadBuffer) {

                break;

            }

        }

        case MmMediumSystem: {

            extension->BufferSize = 1024;
            extension->InterruptReadBuffer = ExAllocatePool(
                                                 NonPagedPool,
                                                 extension->BufferSize
                                                 );

            if (extension->InterruptReadBuffer) {

                break;

            }

        }

        case MmSmallSystem: {

            extension->BufferSize = 128;
            extension->InterruptReadBuffer = ExAllocatePool(
                                                 NonPagedPool,
                                                 extension->BufferSize
                                                 );

        }

    }

    if (!extension->InterruptReadBuffer) {
       ExReleaseFastMutex(&extension->OpenMutex);

        extension->BufferSize = 0;
        Irp->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;
        Irp->IoStatus.Information = 0;

        SerialDump(
            SERIRPPATH,
            ("SERIAL: Complete Irp: %x\n",Irp)
            );

        InterlockedDecrement(&extension->OpenCount);
        SerialCompleteRequest(extension, Irp, IO_NO_INCREMENT);

        return STATUS_INSUFFICIENT_RESOURCES;

    }

    //
    // Ok, it looks like we really are going to open.  Lock down the
    // driver.
    //
    SerialLockPagableSectionByHandle(SerialGlobals.PAGESER_Handle);

    //
    // Power up the stack
    //

    (void)SerialGotoPowerState(DeviceObject, extension, PowerDeviceD0);

    //
    // Not currently waiting for wake up
    //

    extension->SendWaitWake = FALSE;

    //
    // On a new open we "flush" the read queue by initializing the
    // count of characters.
    //

    extension->CharsInInterruptBuffer = 0;
    extension->LastCharSlot = extension->InterruptReadBuffer +
                              (extension->BufferSize - 1);

    extension->ReadBufferBase = extension->InterruptReadBuffer;
    extension->CurrentCharSlot = extension->InterruptReadBuffer;
    extension->FirstReadableChar = extension->InterruptReadBuffer;

    extension->TotalCharsQueued = 0;

    //
    // We set up the default xon/xoff limits.
    //

    extension->HandFlow.XoffLimit = extension->BufferSize >> 3;
    extension->HandFlow.XonLimit = extension->BufferSize >> 1;

    extension->WmiCommData.XoffXmitThreshold = extension->HandFlow.XoffLimit;
    extension->WmiCommData.XonXmitThreshold = extension->HandFlow.XonLimit;

    extension->BufferSizePt8 = ((3*(extension->BufferSize>>2))+
                                   (extension->BufferSize>>4));

    //
    // Mark the device as busy for WMI
    //

    extension->WmiCommData.IsBusy = TRUE;

    extension->IrpMaskLocation = NULL;
    extension->HistoryMask = 0;
    extension->IsrWaitMask = 0;

    extension->SendXonChar = FALSE;
    extension->SendXoffChar = FALSE;

#if !DBG
    //
    // Clear out the statistics.
    //

    KeSynchronizeExecution(
        extension->Interrupt,
        SerialClearStats,
        extension
        );
#endif

    //
    // The escape char replacement must be reset upon every open.
    //

    extension->EscapeChar = 0;

    if (!extension->PermitShare) {

        if (!extension->InterruptShareable) {

            checkOpen.Extension = extension;
            checkOpen.StatusOfOpen = &Irp->IoStatus.Status;

            KeSynchronizeExecution(
                extension->Interrupt,
                SerialCheckOpen,
                &checkOpen
                );

        } else {

            KeSynchronizeExecution(
                extension->Interrupt,
                SerialMarkOpen,
                extension
                );

            Irp->IoStatus.Status = STATUS_SUCCESS;

        }

    } else {

        //
        // Synchronize with the ISR and let it know that the device
        // has been successfully opened.
        //

        KeSynchronizeExecution(
            extension->Interrupt,
            SerialMarkOpen,
            extension
            );

        Irp->IoStatus.Status = STATUS_SUCCESS;

    }

    //
    // We have been marked open, so now the PnP state can change
    //

    ExReleaseFastMutex(&extension->OpenMutex);

    localStatus = Irp->IoStatus.Status;
    Irp->IoStatus.Information=0L;

    SerialDump(
        SERIRPPATH,
        ("SERIAL: Complete Irp: %x\n",Irp)
        );

    if (!NT_SUCCESS(localStatus)) {
       if (extension->InterruptReadBuffer != NULL) {
          ExFreePool(extension->InterruptReadBuffer);
          extension->InterruptReadBuffer = NULL;
       }

       InterlockedDecrement(&extension->OpenCount);
    }

    SerialCompleteRequest(extension, Irp, IO_NO_INCREMENT);

    return localStatus;

}

VOID
SerialDrainUART(IN PSERIAL_DEVICE_EXTENSION PDevExt,
                IN PLARGE_INTEGER PDrainTime)
{
   PAGED_CODE();

   //
   // Wait until all characters have been emptied out of the hardware.
   //

   while ((READ_LINE_STATUS(PDevExt->Controller) &
           (SERIAL_LSR_THRE | SERIAL_LSR_TEMT))
           != (SERIAL_LSR_THRE | SERIAL_LSR_TEMT)) {

        KeDelayExecutionThread(KernelMode, FALSE, PDrainTime);
    }
}


NTSTATUS
SerialClose(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    We simply disconnect the interrupt for now.

Arguments:

    DeviceObject - Pointer to the device object for this device

    Irp - Pointer to the IRP for the current request

Return Value:

    The function value is the final status of the call

--*/

{

    //
    // This "timer value" is used to wait 10 character times
    // after the hardware is empty before we actually "run down"
    // all of the flow control/break junk.
    //
    LARGE_INTEGER tenCharDelay;

    //
    // Holds a character time.
    //
    LARGE_INTEGER charTime;

    //
    // Just what it says.  This is the serial specific device
    // extension of the device object create for the serial driver.
    //
    PSERIAL_DEVICE_EXTENSION extension = DeviceObject->DeviceExtension;

    NTSTATUS status;

    //
    // Number of opens still active
    //

    LONG openCount;

    //
    // Number of DPC's still pending
    //

    ULONG pendingDPCs;

    ULONG flushCount;

    //
    // Grab a mutex
    //

    ExAcquireFastMutex(&extension->CloseMutex);


    //
    // We succeed a close on a removing device
    //

    if ((status = SerialIRPPrologue(Irp, extension)) != STATUS_SUCCESS) {
       SerialDump(SERERRORS, ("SERIAL: Close prologue failed for: %x\n",Irp));
       if (status == STATUS_DELETE_PENDING) {
             extension->BufferSize = 0;
             ExFreePool(extension->InterruptReadBuffer);
             extension->InterruptReadBuffer = NULL;
             status = Irp->IoStatus.Status = STATUS_SUCCESS;
       }

       SerialCompleteRequest(extension, Irp, IO_NO_INCREMENT);
       openCount = InterlockedDecrement(&extension->OpenCount);
       ASSERT(openCount == 0);
       ExReleaseFastMutex(&extension->CloseMutex);
       return status;
    }

    ASSERT(extension->OpenCount == 1);

    if (extension->OpenCount != 1) {
       SerialDump(SERERRORS, ("SERIAL: Close open count bad for: 0x%x\n",Irp));
       SerialDump(SERERRORS, ("------: Count: %x  Addr: 0x%x\n",
                              extension->OpenCount, &extension->OpenCount));
       ExReleaseFastMutex(&extension->CloseMutex);
       Irp->IoStatus.Status = STATUS_INVALID_DEVICE_REQUEST;
       SerialCompleteRequest(extension, Irp, IO_NO_INCREMENT);
       return STATUS_INVALID_DEVICE_REQUEST;
    }

    SerialDump(
        SERIRPPATH,
        ("SERIAL: Dispatch entry for: %x\n",Irp)
        );
    SerialDump(
        SERDIAG3,
        ("SERIAL: In SerialClose\n")
        );

    charTime.QuadPart = -SerialGetCharTime(extension).QuadPart;

    //
    // Do this now so that if the isr gets called it won't do anything
    // to cause more chars to get sent.  We want to run down the hardware.
    //

    extension->DeviceIsOpened = FALSE;

    //
    // Synchronize with the isr to turn off break if it
    // is already on.
    //

    KeSynchronizeExecution(
        extension->Interrupt,
        SerialTurnOffBreak,
        extension
        );

    //
    // Wait a reasonable amount of time (20 * fifodepth) until all characters
    // have been emptied out of the hardware.
    //

#if defined(NEC_98)
    //
    // all characters not have been emptied out of the hardware.
    //
#else
    for (flushCount = (20 * 16); flushCount != 0; flushCount--) {
       if ((READ_LINE_STATUS(extension->Controller) &
            (SERIAL_LSR_THRE | SERIAL_LSR_TEMT)) !=
           (SERIAL_LSR_THRE | SERIAL_LSR_TEMT)) {

          KeDelayExecutionThread(KernelMode, FALSE, &charTime);
      } else {
         break;
      }
    }

    if (flushCount == 0) {
       SerialMarkHardwareBroken(extension);
    }
#endif //defined(NEC_98)

    //
    // Synchronize with the ISR to let it know that interrupts are
    // no longer important.
    //

    KeSynchronizeExecution(
        extension->Interrupt,
        SerialMarkClose,
        extension
        );


    //
    // If the driver has automatically transmitted an Xoff in
    // the context of automatic receive flow control then we
    // should transmit an Xon.
    //

    if (extension->RXHolding & SERIAL_RX_XOFF) {

        //
        // Loop until the holding register is empty.
        //

        while (!(READ_LINE_STATUS(extension->Controller) &
                 SERIAL_LSR_THRE)) {

            KeDelayExecutionThread(
                KernelMode,
                FALSE,
                &charTime
                );

        }

        WRITE_TRANSMIT_HOLDING(
            extension->Controller,
            extension->SpecialChars.XonChar
            );

        //
        // Wait a reasonable amount of time for the characters
        // to be emptied out of the hardware.
        //

         for (flushCount = (20 * 16); flushCount != 0; flushCount--) {
            if ((READ_LINE_STATUS(extension->Controller) &
                 (SERIAL_LSR_THRE | SERIAL_LSR_TEMT)) !=
                (SERIAL_LSR_THRE | SERIAL_LSR_TEMT)) {

               KeDelayExecutionThread(KernelMode, FALSE, &charTime);
            } else {
               break;
            }
         }

         if (flushCount == 0) {
            SerialMarkHardwareBroken(extension);
         }
    }


    //
    // The hardware is empty.  Delay 10 character times before
    // shut down all the flow control.
    //

    tenCharDelay.QuadPart = charTime.QuadPart * 10;

    KeDelayExecutionThread(
        KernelMode,
        TRUE,
        &tenCharDelay
        );

    SerialClrDTR(extension);

    //
    // We have to be very careful how we clear the RTS line.
    // Transmit toggling might have been on at some point.
    //
    // We know that there is nothing left that could start
    // out the "polling"  execution path.  We need to
    // check the counter that indicates that the execution
    // path is active.  If it is then we loop delaying one
    // character time.  After each delay we check to see if
    // the counter has gone to zero.  When it has we know that
    // the execution path should be just about finished.  We
    // make sure that we still aren't in the routine that
    // synchronized execution with the ISR by synchronizing
    // ourselve with the ISR.
    //

    if (extension->CountOfTryingToLowerRTS) {

        do {

            KeDelayExecutionThread(
                KernelMode,
                FALSE,
                &charTime
                );

        } while (extension->CountOfTryingToLowerRTS);

        KeSynchronizeExecution(
            extension->Interrupt,
            SerialNullSynch,
            NULL
            );

        //
        // The execution path should no longer exist that
        // is trying to push down the RTS.  Well just
        // make sure it's down by falling through to
        // code that forces it down.
        //

    }

    SerialClrRTS(extension);

    //
    // Clean out the holding reasons (since we are closed).
    //

    extension->RXHolding = 0;
    extension->TXHolding = 0;

    //
    // Mark device as not busy for WMI
    //

    extension->WmiCommData.IsBusy = FALSE;

    //
    // All is done.  The port has been disabled from interrupting
    // so there is no point in keeping the memory around.
    //

    extension->BufferSize = 0;
    if (extension->InterruptReadBuffer != NULL) {
       ExFreePool(extension->InterruptReadBuffer);
    }
    extension->InterruptReadBuffer = NULL;

    //
    // Stop waiting for wakeup
    //

    extension->SendWaitWake = FALSE;

    if (extension->PendingWakeIrp != NULL) {
       IoCancelIrp(extension->PendingWakeIrp);
    }

    //
    // Power down our device stack
    //

    (void)SerialGotoPowerState(DeviceObject, extension, PowerDeviceD3);

    Irp->IoStatus.Status = STATUS_SUCCESS;
    Irp->IoStatus.Information=0L;

    SerialDump(
        SERIRPPATH,
        ("SERIAL: Complete Irp: %x\n",Irp)
        );
    SerialCompleteRequest(extension, Irp, IO_NO_INCREMENT);

    //
    // Unlock the pages.  If this is the last reference to the section
    // then the driver code will be flushed out.
    //

    //
    // First, we have to let the DPC's drain.  No more should be queued
    // since we aren't taking interrupts now....
    //

    pendingDPCs = InterlockedDecrement(&extension->DpcCount);

    if (pendingDPCs) {
       SerialDump(SERDIAG1, ("SERIAL: Drainging DPC's: %x\n",Irp));
       KeWaitForSingleObject(&extension->PendingDpcEvent, Executive,
                             KernelMode, FALSE, NULL);
    }


    SerialDump(SERDIAG1, ("SERIAL: DPC's drained: %x\n",Irp));



    //
    // Pages must be locked to release the mutex, so don't unlock
    // them until after we release the mutex
    //

    ExReleaseFastMutex(&extension->CloseMutex);

    //
    // Reset for next open
    //

    InterlockedIncrement(&extension->DpcCount);

    openCount = InterlockedDecrement(&extension->OpenCount);

    ASSERT(openCount == 0);
    SerialUnlockPagableImageSection(SerialGlobals.PAGESER_Handle);

    return STATUS_SUCCESS;

}


BOOLEAN
SerialCheckOpen(
    IN PVOID Context
    )

/*++

Routine Description:

    This routine will traverse the circular doubly linked list
    of devices that are using the same interrupt object.  It will look
    for other devices that are open.  If it doesn't find any
    it will indicate that it is ok to open this device.

    If it finds another device open we have two cases:

        1) The device we are trying to open is on a multiport card.

           If the already open device is part of a multiport device
           this code will indicate it is ok to open.  We do this on the
           theory that the multiport devices are daisy chained
           and the cards can correctly arbitrate the interrupt
           line.  Note this assumption could be wrong.  Somebody
           could put two non-daisychained multiports on the
           same interrupt.  However, only a total clod would do
           such a thing, and in my opinion deserves everthing they
           get.

        2) The device we are trying to open is not on a multiport card.

            We indicate that it is not ok to open.

Arguments:

    Context - This is a structure that contains a pointer to the
              extension of the device we are trying to open, and
              a pointer to an NTSTATUS that will indicate whether
              the device was opened or not.

Return Value:

    This routine always returns FALSE.

--*/

{

    PSERIAL_DEVICE_EXTENSION extensionToOpen =
        ((PSERIAL_CHECK_OPEN)Context)->Extension;
    NTSTATUS *status = ((PSERIAL_CHECK_OPEN)Context)->StatusOfOpen;
    PLIST_ENTRY firstEntry = &extensionToOpen->CommonInterruptObject;
    PLIST_ENTRY currentEntry = firstEntry;
    PSERIAL_DEVICE_EXTENSION currentExtension;

    do {

        currentExtension = CONTAINING_RECORD(
                               currentEntry,
                               SERIAL_DEVICE_EXTENSION,
                               CommonInterruptObject
                               );

        if (currentExtension->DeviceIsOpened) {

            break;

        }

        currentEntry = currentExtension->CommonInterruptObject.Flink;

    } while (currentEntry != firstEntry);

    if (currentEntry == firstEntry) {

        //
        // We searched the whole list and found no other opens
        // mark the status as successful and call the regular
        // opening routine.
        //

        *status = STATUS_SUCCESS;
        SerialMarkOpen(extensionToOpen);

    } else {

        if (!extensionToOpen->PortOnAMultiportCard) {

            *status = STATUS_SHARED_IRQ_BUSY;

        } else {

            if (!currentExtension->PortOnAMultiportCard) {

                *status = STATUS_SHARED_IRQ_BUSY;

            } else {

                *status = STATUS_SUCCESS;
                SerialMarkOpen(extensionToOpen);

            }

        }

    }

    return FALSE;

}

BOOLEAN
SerialMarkOpen(
    IN PVOID Context
    )

/*++

Routine Description:

    This routine merely sets a boolean to true to mark the fact that
    somebody opened the device and its worthwhile to pay attention
    to interrupts.

Arguments:

    Context - Really a pointer to the device extension.

Return Value:

    This routine always returns FALSE.

--*/

{

    PSERIAL_DEVICE_EXTENSION extension = Context;
#if defined(NEC_98)
   //
   // This argument use at MACRO only.
   //
    PSERIAL_DEVICE_EXTENSION Extension = Context;
#else
#endif //defined(NEC_98)

    SerialReset(extension);

    //
    // Prepare for the opening by re-enabling interrupts.
    //
    // We do this my modifying the OUT2 line in the modem control.
    // In PC's this bit is "anded" with the interrupt line.
    //
    // For the Jensen, we will ALWAYS leave the line high.  That's
    // the way the hardware engineers want it.
    //

    WRITE_MODEM_CONTROL(
        extension->Controller,
        (UCHAR)(READ_MODEM_CONTROL(extension->Controller) | SERIAL_MCR_OUT2)
        );

    extension->DeviceIsOpened = TRUE;
    extension->ErrorWord = 0;

    return FALSE;

}


VOID
SerialDisableUART(IN PVOID Context)

/*++

Routine Description:

    This routine disables the UART and puts it in a "safe" state when
    not in use (like a close or powerdown).

Arguments:

    Context - Really a pointer to the device extension.

Return Value:

    This routine always returns FALSE.

--*/

{
   PSERIAL_DEVICE_EXTENSION extension = Context;
#if defined(NEC_98)
   //
   // This argument use at MACRO only.
   //
   PSERIAL_DEVICE_EXTENSION Extension = Context;
#else
#endif //defined(NEC_98)

   //
   // Prepare for the closing by stopping interrupts.
   //
   // We do this by adjusting the OUT2 line in the modem control.
   // In PC's this bit is "anded" with the interrupt line.
   //
   // The line should stay high on the Jensen because that's the
   // way the hardware engineers did it.
   //

   if (!extension->Jensen) {
      WRITE_MODEM_CONTROL(extension->Controller,
                          (UCHAR)(READ_MODEM_CONTROL(extension->Controller)
                                  & ~SERIAL_MCR_OUT2));
   }

   if (extension->FifoPresent) {
      WRITE_FIFO_CONTROL(extension->Controller, (UCHAR)0);
    }
}


BOOLEAN
SerialMarkClose(
    IN PVOID Context
    )

/*++

Routine Description:

    This routine merely sets a boolean to false to mark the fact that
    somebody closed the device and it's no longer worthwhile to pay attention
    to interrupts.  It also disables the UART.

Arguments:

    Context - Really a pointer to the device extension.

Return Value:

    This routine always returns FALSE.

--*/

{

    PSERIAL_DEVICE_EXTENSION extension = Context;

    SerialDisableUART(Context);
    extension->DeviceIsOpened = FALSE;

    return FALSE;

}


NTSTATUS
SerialCleanup(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This function is used to kill all longstanding IO operations.

Arguments:

    DeviceObject - Pointer to the device object for this device

    Irp - Pointer to the IRP for the current request

Return Value:

    The function value is the final status of the call

--*/

{

    PSERIAL_DEVICE_EXTENSION extension = DeviceObject->DeviceExtension;
    NTSTATUS status;


    PAGED_CODE();

    //
    // We succeed a cleanup on a removing device
    //

    if ((status = SerialIRPPrologue(Irp, extension)) != STATUS_SUCCESS) {
       if (status == STATUS_DELETE_PENDING) {
          status = Irp->IoStatus.Status = STATUS_SUCCESS;
       }
       SerialCompleteRequest(extension, Irp, IO_NO_INCREMENT);
       return status;
    }

    SerialDump(
        SERIRPPATH,
        ("SERIAL: Dispatch entry for: %x\n",Irp)
        );

    SerialKillPendingIrps(DeviceObject);

    Irp->IoStatus.Status = STATUS_SUCCESS;
    Irp->IoStatus.Information=0L;

    SerialDump(
        SERIRPPATH,
        ("SERIAL: Complete Irp: %x\n",Irp)
        );
    SerialCompleteRequest(extension, Irp, IO_NO_INCREMENT);

    return STATUS_SUCCESS;

}

LARGE_INTEGER
SerialGetCharTime(
    IN PSERIAL_DEVICE_EXTENSION Extension
    )

/*++

Routine Description:

    This function will return the number of 100 nanosecond intervals
    there are in one character time (based on the present form
    of flow control.

Arguments:

    Extension - Just what it says.

Return Value:

    100 nanosecond intervals in a character time.

--*/

{

    ULONG dataSize;
    ULONG paritySize;
    ULONG stopSize;
    ULONG charTime;
    ULONG bitTime;
    LARGE_INTEGER tmp;


    if ((Extension->LineControl & SERIAL_DATA_MASK) == SERIAL_5_DATA) {
        dataSize = 5;
    } else if ((Extension->LineControl & SERIAL_DATA_MASK)
                == SERIAL_6_DATA) {
        dataSize = 6;
    } else if ((Extension->LineControl & SERIAL_DATA_MASK)
                == SERIAL_7_DATA) {
        dataSize = 7;
    } else if ((Extension->LineControl & SERIAL_DATA_MASK)
                == SERIAL_8_DATA) {
        dataSize = 8;
    }

    paritySize = 1;
    if ((Extension->LineControl & SERIAL_PARITY_MASK)
            == SERIAL_NONE_PARITY) {

        paritySize = 0;

    }

    if (Extension->LineControl & SERIAL_2_STOP) {

        //
        // Even if it is 1.5, for sanities sake were going
        // to say 2.
        //

        stopSize = 2;

    } else {

        stopSize = 1;

    }

    //
    // First we calculate the number of 100 nanosecond intervals
    // are in a single bit time (Approximately).
    //

    bitTime = (10000000+(Extension->CurrentBaud-1))/Extension->CurrentBaud;
    charTime = bitTime + ((dataSize+paritySize+stopSize)*bitTime);

    tmp.QuadPart = charTime;
    return tmp;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\ser101\power.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    power.c

Abstract:

    This module contains the code that handles the power IRPs for the serial
    driver.


Environment:

    Kernel mode

Revision History :


--*/

#include "precomp.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGESRP0, SerialGotoPowerState)
#pragma alloc_text(PAGESRP0, SerialPowerDispatch)
#pragma alloc_text(PAGESRP0, SerialSetPowerD0)
#pragma alloc_text(PAGESRP0, SerialSetPowerD3)
#pragma alloc_text(PAGESRP0, SerialSaveDeviceState)
#pragma alloc_text(PAGESRP0, SerialRestoreDeviceState)
#pragma alloc_text(PAGESRP0, SerialSendWaitWake)
#endif // ALLOC_PRAGMA


NTSTATUS
SerialSystemPowerCompletion(IN PDEVICE_OBJECT PDevObj, UCHAR MinorFunction,
                            IN POWER_STATE PowerState, IN PVOID Context,
                            PIO_STATUS_BLOCK IoStatus)
/*++

Routine Description:

    This routine is the completion routine for PoRequestPowerIrp calls
    in this module.

Arguments:

    PDevObj - Pointer to the device object the irp is completing for

    MinorFunction - IRP_MN_XXXX value requested

    PowerState - Power state request was made of

    Context - Event to set or NULL if no setting required

    IoStatus - Status block from request

Return Value:

    VOID


--*/
{
   if (Context != NULL) {
      KeSetEvent((PKEVENT)Context, IO_NO_INCREMENT, 0);
   }

   return STATUS_SUCCESS;
}



VOID
SerialSaveDeviceState(IN PSERIAL_DEVICE_EXTENSION PDevExt)
/*++

Routine Description:

    This routine saves the device state of the UART

Arguments:

    PDevExt - Pointer to the device extension for the devobj to save the state
              for.

Return Value:

    VOID


--*/
{
   PSERIAL_DEVICE_STATE pDevState = &PDevExt->DeviceState;
#if defined(NEC_98)
   //
   // This argument use at MACRO only.
   //
   PSERIAL_DEVICE_EXTENSION Extension = PDevExt;
#else
#endif //defined(NEC_98)
   PAGED_CODE();

   SerialDump(SERTRACECALLS, ("SERIAL: Entering SerialSaveDeviceState\n"));

   //
   // Read necessary registers direct
   //

#if defined(NEC_98)
   pDevState->IER = READ_INTERRUPT_ENABLE(Extension->Controller);
#else
   pDevState->IER = READ_INTERRUPT_ENABLE(PDevExt->Controller);
#endif //defined(NEC_98)
   pDevState->MCR = READ_MODEM_CONTROL(PDevExt->Controller);
   pDevState->LCR = READ_LINE_CONTROL(PDevExt->Controller);


   SerialDump(SERTRACECALLS, ("SERIAL: Leaving SerialSaveDeviceState\n"));
}


VOID
SerialRestoreDeviceState(IN PSERIAL_DEVICE_EXTENSION PDevExt)
/*++

Routine Description:

    This routine restores the device state of the UART

Arguments:

    PDevExt - Pointer to the device extension for the devobj to restore the
    state for.

Return Value:

    VOID


--*/
{
   PSERIAL_DEVICE_STATE pDevState = &PDevExt->DeviceState;
   SHORT divisor;
   SERIAL_IOCTL_SYNC S;
#if defined(NEC_98)
   //
   // This argument use at MACRO only.
   //
   PSERIAL_DEVICE_EXTENSION Extension = PDevExt;
#else
#endif //defined(NEC_98)

   PAGED_CODE();

   SerialDump(SERTRACECALLS, ("SERIAL: Enter SerialRestoreDeviceState\n"));
   SerialDump(SERTRACECALLS, ("------  PDevExt: %x\n", PDevExt));

   //
   // Disable interrupts both via OUT2 and IER
   //

   WRITE_MODEM_CONTROL(PDevExt->Controller, 0);
   DISABLE_ALL_INTERRUPTS(PDevExt->Controller);

   //
   // Set the baud rate
   //

   SerialGetDivisorFromBaud(PDevExt->ClockRate, PDevExt->CurrentBaud, &divisor);
   S.Extension = PDevExt;
   S.Data = (PVOID)divisor;
   SerialSetBaud(&S);

   //
   // Reset / Re-enable the FIFO's
   //

   if (PDevExt->FifoPresent) {
      WRITE_FIFO_CONTROL(PDevExt->Controller, (UCHAR)0);
      READ_RECEIVE_BUFFER(PDevExt->Controller);
      WRITE_FIFO_CONTROL(PDevExt->Controller,
                         (UCHAR)(SERIAL_FCR_ENABLE | PDevExt->RxFifoTrigger
                                 | SERIAL_FCR_RCVR_RESET
                                 | SERIAL_FCR_TXMT_RESET));
   } else {
      WRITE_FIFO_CONTROL(PDevExt->Controller, (UCHAR)0);
   }

   //
   // In case we are dealing with a bitmasked multiportcard,
   // that has the mask register enabled, enable the
   // interrupts.
   //

   if (PDevExt->InterruptStatus) {
      if (PDevExt->Indexed) {
            WRITE_PORT_UCHAR(PDevExt->InterruptStatus, (UCHAR)0xFF);
      } else {
         //
         // Either we are standalone or already mapped
         //

         if (PDevExt->OurIsrContext == PDevExt) {
            //
            // This is a standalone
            //

            WRITE_PORT_UCHAR(PDevExt->InterruptStatus,
                             (UCHAR)(1 << (PDevExt->PortIndex - 1)));
         } else {
            //
            // One of many
            //

            WRITE_PORT_UCHAR(PDevExt->InterruptStatus,
                             (UCHAR)((PSERIAL_MULTIPORT_DISPATCH)PDevExt->
                                     OurIsrContext)->UsablePortMask);
         }
      }
   }

   //
   // Restore a couple more registers
   //

#if defined(NEC_98)
   WRITE_INTERRUPT_ENABLE(Extension->Controller, pDevState->IER);
#else
   WRITE_INTERRUPT_ENABLE(PDevExt->Controller, pDevState->IER);
#endif //defined(NEC_98)
   WRITE_LINE_CONTROL(PDevExt->Controller, pDevState->LCR);

   //
   // Clear out any stale interrupts
   //

   READ_INTERRUPT_ID_REG(PDevExt->Controller);
   READ_LINE_STATUS(PDevExt->Controller);
   READ_MODEM_STATUS(PDevExt->Controller);


   if (PDevExt->DeviceState.Reopen == TRUE) {
      SerialDump(SERPNPPOWER, ("SERIAL: Reopening device\n"));

      PDevExt->DeviceIsOpened = TRUE;
      PDevExt->DeviceState.Reopen = FALSE;

      //
      // This enables interrupts on the device!
      //

      WRITE_MODEM_CONTROL(PDevExt->Controller,
                          (UCHAR)(pDevState->MCR | SERIAL_MCR_OUT2));

      //
      // Refire the state machine
      //

      DISABLE_ALL_INTERRUPTS(PDevExt->Controller);
      ENABLE_ALL_INTERRUPTS(PDevExt->Controller);
   }

}


NTSTATUS
SerialPowerDispatch(IN PDEVICE_OBJECT PDevObj, IN PIRP PIrp)

/*++

Routine Description:

    This is a dispatch routine for the IRPs that come to the driver with the
    IRP_MJ_POWER major code (power IRPs).

Arguments:

    PDevObj - Pointer to the device object for this device

    PIrp - Pointer to the IRP for the current request

Return Value:

    The function value is the final status of the call


--*/

{

   PSERIAL_DEVICE_EXTENSION pDevExt = PDevObj->DeviceExtension;
   PIO_STACK_LOCATION pIrpStack = IoGetCurrentIrpStackLocation(PIrp);
   NTSTATUS status;
   PDEVICE_OBJECT pLowerDevObj = pDevExt->LowerDeviceObject;
   PDEVICE_OBJECT pPdo = pDevExt->Pdo;
   BOOLEAN acceptingIRPs;

   PAGED_CODE();

   if ((status = SerialIRPPrologue(PIrp, pDevExt)) != STATUS_SUCCESS) {
      PoStartNextPowerIrp(PIrp);
      SerialCompleteRequest(pDevExt, PIrp, IO_NO_INCREMENT);
      return status;
   }

   status = STATUS_SUCCESS;

   switch (pIrpStack->MinorFunction) {

   case IRP_MN_WAIT_WAKE:
      SerialDump(SERPNPPOWER, ("SERIAL: Got IRP_MN_WAIT_WAKE Irp\n"));
      break;


   case IRP_MN_POWER_SEQUENCE:
      SerialDump(SERPNPPOWER, ("SERIAL: Got IRP_MN_POWER_SEQUENCE Irp\n"));
      break;


   case IRP_MN_SET_POWER:
      SerialDump(SERPNPPOWER, ("SERIAL: Got IRP_MN_SET_POWER Irp\n"));

      //
      // Perform different ops if it was system or device
      //

      switch (pIrpStack->Parameters.Power.Type) {
      case SystemPowerState: {
            POWER_STATE powerState;

            //
            // They asked for a system power state change
            //

            SerialDump(SERPNPPOWER, ("------: SystemPowerState\n"));

            //
            // We will only service this if we are policy owner -- we
            // don't need to lock on this value since we only service
            // one power request at a time.
            //

            if (pDevExt->OwnsPowerPolicy != TRUE) {
               status = STATUS_SUCCESS;
               goto PowerExit;
            }


            switch (pIrpStack->Parameters.Power.State.SystemState) {
            case PowerSystemUnspecified:
               powerState.DeviceState = PowerDeviceUnspecified;
               break;

            case PowerSystemWorking:
               powerState.DeviceState = PowerDeviceD0;
               break;

            case PowerSystemSleeping1:
            case PowerSystemSleeping2:
            case PowerSystemSleeping3:
            case PowerSystemHibernate:
            case PowerSystemShutdown:
            case PowerSystemMaximum:
               powerState.DeviceState = PowerDeviceD3;
               break;

            default:
               status = STATUS_SUCCESS;
               goto PowerExit;
               break;
            }


            PoSetPowerState(PDevObj, pIrpStack->Parameters.Power.Type,
                            pIrpStack->Parameters.Power.State);

            //
            // Send IRP to change device state if we should change
            //

            //
            // We only power up the stack if the device is open.  This is based
            // on our policy of keeping the device powered down unless it is
            // open.
            //

            if (((powerState.DeviceState < pDevExt->PowerState)
                 && pDevExt->OpenCount)) {
               PoRequestPowerIrp(pPdo, IRP_MN_SET_POWER, powerState, NULL, NULL,
                                 NULL);
            }else {
               //
               // If powering down, we can't go past wake state
               // if wait-wake pending
               //

               if (powerState.DeviceState >= pDevExt->PowerState) {

                  //
                  // Power down -- ensure there is no wake-wait pending OR
                  // we can do down to that level and still wake the machine
                  //

                  if ((pDevExt->PendingWakeIrp == NULL && !pDevExt->SendWaitWake)
                      || powerState.DeviceState <= pDevExt->DeviceWake) {
                     PoRequestPowerIrp(pPdo, IRP_MN_SET_POWER, powerState, NULL,
                                       NULL, NULL);
                  }
               }
            }


            status = STATUS_SUCCESS;
            goto PowerExit;
         }

      case DevicePowerState:
         SerialDump(SERPNPPOWER, ("------: DevicePowerState\n"));
         break;

      default:
         SerialDump(SERPNPPOWER, ("------: UNKNOWN PowerState\n"));
         status = STATUS_SUCCESS;
         goto PowerExit;
      }


      //
      // If we are already in the requested state, just pass the IRP down
      //

      if (pDevExt->PowerState
          == pIrpStack->Parameters.Power.State.DeviceState) {
         SerialDump(SERPNPPOWER, ("SERIAL: Already in requested power state\n")
                    );
         status = STATUS_SUCCESS;
         break;
      }


      switch (pIrpStack->Parameters.Power.State.DeviceState) {

      case PowerDeviceD0:
         SerialDump(SERPNPPOWER, ("SERIAL: Going to power state D0\n"));
         return SerialSetPowerD0(PDevObj, PIrp);

      case PowerDeviceD1:
      case PowerDeviceD2:
      case PowerDeviceD3:
         SerialDump(SERPNPPOWER, ("SERIAL: Going to power state D3\n"));
         return SerialSetPowerD3(PDevObj, PIrp);

      default:
         break;
      }
      break;



   case IRP_MN_QUERY_POWER:

      SerialDump (SERPNPPOWER, ("SERIAL: Got IRP_MN_QUERY_POWER Irp\n"));

      //
      // Check if we have a wait-wake pending and if so,
      // ensure we don't power down too far.
      //

      if (pDevExt->PendingWakeIrp != NULL || pDevExt->SendWaitWake) {
         if (pIrpStack->Parameters.Power.Type == DevicePowerState
             && pIrpStack->Parameters.Power.State.DeviceState
             > pDevExt->DeviceWake) {
            status = PIrp->IoStatus.Status = STATUS_INVALID_DEVICE_STATE;
            PoStartNextPowerIrp(PIrp);
            SerialCompleteRequest(pDevExt, PIrp, IO_NO_INCREMENT);
            return status;
         }
      }

      //
      // If no wait-wake, always successful
      //

      PIrp->IoStatus.Status = STATUS_SUCCESS;
      status = STATUS_SUCCESS;
      PoStartNextPowerIrp(PIrp);
      IoSkipCurrentIrpStackLocation(PIrp);
      return SerialPoCallDriver(pDevExt, pLowerDevObj, PIrp);

   }   // switch (pIrpStack->MinorFunction)


   PowerExit:;

   PoStartNextPowerIrp(PIrp);


   //
   // Pass to the lower driver
   //
   IoSkipCurrentIrpStackLocation(PIrp);
   status = SerialPoCallDriver(pDevExt, pLowerDevObj, PIrp);

   return status;
}





NTSTATUS
SerialSetPowerD0(IN PDEVICE_OBJECT PDevObj, IN PIRP PIrp)

/*++

Routine Description:

    This routine Decides if we need to pass the power Irp down the stack
    or not.  It then either sets up a completion handler to finish the
    initialization or calls the completion handler directly.

Arguments:

    PDevObj - Pointer to the devobj we are changing power state on

    PIrp - Pointer to the IRP for the current request

Return Value:

    Return status of either PoCallDriver of the call to the initialization
    routine.


--*/

{
   PSERIAL_DEVICE_EXTENSION pDevExt = PDevObj->DeviceExtension;
   PIO_STACK_LOCATION pIrpStack = IoGetCurrentIrpStackLocation(PIrp);
   NTSTATUS status;

   PAGED_CODE();

   SerialDump(SERTRACECALLS, ("SERIAL: In SerialSetPowerD0\n"));
   SerialDump(SERPNPPOWER, ("SERIAL: SetPowerD0 has IRP %x\n", PIrp));

   ASSERT(pDevExt->LowerDeviceObject);

   //
   // Set up completion to init device when it is on
   //

   KeClearEvent(&pDevExt->PowerD0Event);


   IoCopyCurrentIrpStackLocationToNext(PIrp);
   IoSetCompletionRoutine(PIrp, SerialSyncCompletion, &pDevExt->PowerD0Event,
                          TRUE, TRUE, TRUE);

   SerialDump(SERPNPPOWER, ("SERIAL: Calling next driver\n"));

   status = PoCallDriver(pDevExt->LowerDeviceObject, PIrp);

   if (status == STATUS_PENDING) {
      SerialDump(SERPNPPOWER, ("SERIAL: Waiting for next driver\n"));
      KeWaitForSingleObject (&pDevExt->PowerD0Event, Executive, KernelMode,
                             FALSE, NULL);
   } else {
      if (!NT_SUCCESS(status)) {
         PIrp->IoStatus.Status = status;
         PoStartNextPowerIrp(PIrp);
         SerialCompleteRequest(pDevExt, PIrp, IO_NO_INCREMENT);
         return status;
      }
   }

   if (!NT_SUCCESS(PIrp->IoStatus.Status)) {
      status = PIrp->IoStatus.Status;
      PoStartNextPowerIrp(PIrp);
      SerialCompleteRequest(pDevExt, PIrp, IO_NO_INCREMENT);
      return status;
   }

   //
   // Restore the device
   //

   pDevExt->PowerState = PowerDeviceD0;


   //
   // Theoretically we could change states in the middle of processing
   // the restore which would result in a bad PKINTERRUPT being used
   // in SerialRestoreDeviceState().
   //

   if (pDevExt->PNPState == SERIAL_PNP_STARTED) {
      SerialRestoreDeviceState(pDevExt);
   }

   //
   // Now that we are powered up, call PoSetPowerState
   //

   PoSetPowerState(PDevObj, pIrpStack->Parameters.Power.Type,
                   pIrpStack->Parameters.Power.State);

   PoStartNextPowerIrp(PIrp);
   SerialCompleteRequest(pDevExt, PIrp, IO_NO_INCREMENT);


   SerialDump(SERTRACECALLS, ("SERIAL: Leaving SerialSetPowerD0\n"));
   return status;
}


NTSTATUS
SerialGotoPowerState(IN PDEVICE_OBJECT PDevObj,
                     IN PSERIAL_DEVICE_EXTENSION PDevExt,
                     IN DEVICE_POWER_STATE DevPowerState)
/*++

Routine Description:

    This routine causes the driver to request the stack go to a particular
    power state.

Arguments:

    PDevObj - Pointer to the device object for this device

    PDevExt - Pointer to the device extension we are working from

    DevPowerState - the power state we wish to go to

Return Value:

    The function value is the final status of the call


--*/
{
   KEVENT gotoPowEvent;
   NTSTATUS status;
   POWER_STATE powerState;

   PAGED_CODE();

   SerialDump(SERTRACECALLS, ("SERIAL: In SerialGotoPowerState\n"));

   powerState.DeviceState = DevPowerState;

   KeInitializeEvent(&gotoPowEvent, SynchronizationEvent, FALSE);

   status = PoRequestPowerIrp(PDevObj, IRP_MN_SET_POWER, powerState,
                              SerialSystemPowerCompletion, &gotoPowEvent,
                              NULL);

   if (status == STATUS_PENDING) {
      KeWaitForSingleObject(&gotoPowEvent, Executive, KernelMode, FALSE, NULL);
      status = STATUS_SUCCESS;
   }

#if DBG
   if (!NT_SUCCESS(status)) {
      SerialDump(SERPNPPOWER, ("SERIAL: SerialGotoPowerState FAILED\n"));
   }
#endif

   SerialDump(SERTRACECALLS, ("SERIAL: Leaving SerialGotoPowerState\n"));

   return status;
}




NTSTATUS
SerialSetPowerD3(IN PDEVICE_OBJECT PDevObj, IN PIRP PIrp)
/*++

Routine Description:

    This routine handles the SET_POWER minor function.

Arguments:

    PDevObj - Pointer to the device object for this device

    PIrp - Pointer to the IRP for the current request

Return Value:

    The function value is the final status of the call


--*/
{
   NTSTATUS status = STATUS_SUCCESS;
   PSERIAL_DEVICE_EXTENSION pDevExt = PDevObj->DeviceExtension;
   PIO_STACK_LOCATION pIrpStack = IoGetCurrentIrpStackLocation(PIrp);

   PAGED_CODE();

   SerialDump(SERDIAG3, ("SERIAL: In SerialSetPowerD3\n"));

   //
   // Send the wait wake now, just in time
   //


   if (pDevExt->SendWaitWake) {
      SerialSendWaitWake(pDevExt);
   }
   //
   // Before we power down, call PoSetPowerState
   //

   PoSetPowerState(PDevObj, pIrpStack->Parameters.Power.Type,
                   pIrpStack->Parameters.Power.State);

   //
   // If the device is not closed, disable interrupts and allow the fifo's
   // to flush.
   //

   if (pDevExt->DeviceIsOpened == TRUE) {
      LARGE_INTEGER charTime;

      pDevExt->DeviceIsOpened = FALSE;
      pDevExt->DeviceState.Reopen = TRUE;

      charTime.QuadPart = -SerialGetCharTime(pDevExt).QuadPart;

      //
      // Shut down the chip
      //

      SerialDisableUART(pDevExt);

      //
      // Drain the device
      //

      SerialDrainUART(pDevExt, &charTime);

      //
      // Save the device state
      //

      SerialSaveDeviceState(pDevExt);
   }

   //
   // If the device is not open, we don't need to save the state;
   // we can just reset the device on power-up
   //


   PIrp->IoStatus.Status = STATUS_SUCCESS;

   pDevExt->PowerState = PowerDeviceD3;

   //
   // For what we are doing, we don't need a completion routine
   // since we don't race on the power requests.
   //

   PIrp->IoStatus.Status = STATUS_SUCCESS;

   PoStartNextPowerIrp(PIrp);
   IoSkipCurrentIrpStackLocation(PIrp);

   return SerialPoCallDriver(pDevExt, pDevExt->LowerDeviceObject, PIrp);
}


NTSTATUS
SerialSendWaitWake(PSERIAL_DEVICE_EXTENSION PDevExt)
/*++

Routine Description:

    This routine causes a waitwake IRP to be sent

Arguments:

    PDevExt - Pointer to the device extension for this device

Return Value:

    STATUS_INVALID_DEVICE_STATE if one is already pending, else result
    of call to PoRequestPowerIrp.


--*/
{
   NTSTATUS status;
   PIRP pIrp;
   POWER_STATE powerState;

   PAGED_CODE();

   //
   // Make sure one isn't pending already -- serial will only handle one at
   // a time.
   //

   if (PDevExt->PendingWakeIrp != NULL) {
      return STATUS_INVALID_DEVICE_STATE;
   }

   //
   // Make sure we are capable of waking the machine
   //

   if (PDevExt->SystemWake <= PowerSystemWorking) {
      return STATUS_INVALID_DEVICE_STATE;
   }

   if (PDevExt->DeviceWake == PowerDeviceUnspecified) {
      return STATUS_INVALID_DEVICE_STATE;
   }

   //
   // Send IRP to request wait wake and add a pending irp flag
   //
   //

   InterlockedIncrement(&PDevExt->PendingIRPCnt);

   powerState.SystemState = PDevExt->SystemWake;

   status = PoRequestPowerIrp(PDevExt->Pdo, IRP_MN_WAIT_WAKE,
                              powerState, SerialWakeCompletion, PDevExt, &pIrp);

   if (status == STATUS_PENDING) {
      status = STATUS_SUCCESS;
      PDevExt->PendingWakeIrp = pIrp;
   } else if (!NT_SUCCESS(status)) {
      SerialIRPEpilogue(PDevExt);
   }

   return status;
}

NTSTATUS
SerialWakeCompletion(IN PDEVICE_OBJECT PDevObj, IN UCHAR MinorFunction,
                     IN POWER_STATE PowerState, IN PVOID Context,
                     IN PIO_STATUS_BLOCK IoStatus)
/*++

Routine Description:

    This routine handles completion of the waitwake IRP.

Arguments:

    PDevObj - Pointer to the device object for this device

    MinorFunction - Minor function previously supplied to PoRequestPowerIrp

    PowerState - PowerState previously supplied to PoRequestPowerIrp

    Context - a pointer to the device extension

    IoStatus - current/final status of the waitwake IRP

Return Value:

    The function value is the final status of attempting to process the
    waitwake.


--*/
{
   NTSTATUS status;
   PSERIAL_DEVICE_EXTENSION pDevExt = (PSERIAL_DEVICE_EXTENSION)Context;
   POWER_STATE powerState;

   status = IoStatus->Status;

   if (NT_SUCCESS(status)) {
      //
      // A wakeup has occurred -- powerup our stack
      //

      powerState.DeviceState = PowerDeviceD0;

      PoRequestPowerIrp(pDevExt->Pdo, IRP_MN_SET_POWER, powerState, NULL,
                        NULL, NULL);

   }

   pDevExt->PendingWakeIrp = NULL;
   SerialIRPEpilogue(pDevExt);

   return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\ser101\qsfile.c ===
/*++

Copyright (c) 1991, 1992, 1993 - 1997 Microsoft Corporation

Module Name:

    qsfile.c

Abstract:

    This module contains the code that is very specific to query/set file
    operations in the serial driver.

Author:

    Anthony V. Ercolano 26-Sep-1991

Environment:

    Kernel mode

--*/

#include "precomp.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGESRP0,SerialQueryInformationFile)
#pragma alloc_text(PAGESRP0,SerialSetInformationFile)
#endif


NTSTATUS
SerialQueryInformationFile(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is used to query the end of file information on
    the opened serial port.  Any other file information request
    is retured with an invalid parameter.

    This routine always returns an end of file of 0.

Arguments:

    DeviceObject - Pointer to the device object for this device

    Irp - Pointer to the IRP for the current request

Return Value:

    The function value is the final status of the call

--*/

{
    //
    // The status that gets returned to the caller and
    // set in the Irp.
    //
    NTSTATUS Status;

    //
    // The current stack location.  This contains all of the
    // information we need to process this particular request.
    //
    PIO_STACK_LOCATION IrpSp;

    NTSTATUS status;

    UNREFERENCED_PARAMETER(DeviceObject);

    PAGED_CODE();

    if ((status = SerialIRPPrologue(Irp,
                                    (PSERIAL_DEVICE_EXTENSION)DeviceObject->
                                    DeviceExtension)) != STATUS_SUCCESS) {
      SerialCompleteRequest((PSERIAL_DEVICE_EXTENSION)DeviceObject->
                            DeviceExtension, Irp, IO_NO_INCREMENT);
      return status;
   }

    SerialDump(
        SERIRPPATH,
        ("SERIAL: Dispatch entry for: %x\n",Irp)
        );
    if (SerialCompleteIfError(
            DeviceObject,
            Irp
            ) != STATUS_SUCCESS) {

        return STATUS_CANCELLED;

    }
    IrpSp = IoGetCurrentIrpStackLocation(Irp);
    Irp->IoStatus.Information = 0L;
    Status = STATUS_SUCCESS;
    if (IrpSp->Parameters.QueryFile.FileInformationClass ==
        FileStandardInformation) {

        PFILE_STANDARD_INFORMATION Buf = Irp->AssociatedIrp.SystemBuffer;

        Buf->AllocationSize.QuadPart = 0;
        Buf->EndOfFile = Buf->AllocationSize;
        Buf->NumberOfLinks = 0;
        Buf->DeletePending = FALSE;
        Buf->Directory = FALSE;
        Irp->IoStatus.Information = sizeof(FILE_STANDARD_INFORMATION);

    } else if (IrpSp->Parameters.QueryFile.FileInformationClass ==
               FilePositionInformation) {

        ((PFILE_POSITION_INFORMATION)Irp->AssociatedIrp.SystemBuffer)->
            CurrentByteOffset.QuadPart = 0;
        Irp->IoStatus.Information = sizeof(FILE_POSITION_INFORMATION);

    } else {
        Status = STATUS_INVALID_PARAMETER;
        Irp->IoStatus.Status = STATUS_INVALID_PARAMETER;
    }

    SerialDump(
        SERIRPPATH,
        ("SERIAL: Complete Irp: %x\n",Irp)
        );
    SerialCompleteRequest((PSERIAL_DEVICE_EXTENSION)DeviceObject->
                          DeviceExtension, Irp, 0);
    return Status;

}

NTSTATUS
SerialSetInformationFile(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is used to set the end of file information on
    the opened parallel port.  Any other file information request
    is retured with an invalid parameter.

    This routine always ignores the actual end of file since
    the query information code always returns an end of file of 0.

Arguments:

    DeviceObject - Pointer to the device object for this device

    Irp - Pointer to the IRP for the current request

Return Value:

The function value is the final status of the call

--*/

{
    //
    // The status that gets returned to the caller and
    // set in the Irp.
    //
    NTSTATUS Status;

    UNREFERENCED_PARAMETER(DeviceObject);

    PAGED_CODE();

    if ((Status = SerialIRPPrologue(Irp,
                                    (PSERIAL_DEVICE_EXTENSION)DeviceObject->
                                    DeviceExtension)) != STATUS_SUCCESS) {
      SerialCompleteRequest((PSERIAL_DEVICE_EXTENSION)DeviceObject->
                            DeviceExtension, Irp, IO_NO_INCREMENT);
      return Status;
   }

    SerialDump(
        SERIRPPATH,
        ("SERIAL: Dispatch entry for: %x\n",Irp)
        );
    if (SerialCompleteIfError(
            DeviceObject,
            Irp
            ) != STATUS_SUCCESS) {

        return STATUS_CANCELLED;

    }
    Irp->IoStatus.Information = 0L;
    if ((IoGetCurrentIrpStackLocation(Irp)->
            Parameters.SetFile.FileInformationClass ==
         FileEndOfFileInformation) ||
        (IoGetCurrentIrpStackLocation(Irp)->
            Parameters.SetFile.FileInformationClass ==
         FileAllocationInformation)) {

        Status = STATUS_SUCCESS;

    } else {

        Status = STATUS_INVALID_PARAMETER;

    }

    Irp->IoStatus.Status = Status;

    SerialDump(
        SERIRPPATH,
        ("SERIAL: Complete Irp: %x\n",Irp)
        );
    SerialCompleteRequest((PSERIAL_DEVICE_EXTENSION)DeviceObject->
                          DeviceExtension, Irp, 0);

    return Status;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\ser101\registry.c ===
/*++

Copyright (c) 1991, 1992, 1993 Microsoft Corporation

Module Name:

    registry.c

Abstract:

    This module contains the code that is used to get values from the
    registry and to manipulate entries in the registry.

Author:

    Anthony V. Ercolano 26-Sep-1991

Environment:

    Kernel mode

Revision History :

--*/

#include "precomp.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT,SerialGetConfigDefaults)

#pragma alloc_text(PAGESRP0,SerialGetRegistryKeyValue)
#pragma alloc_text(PAGESRP0,SerialPutRegistryKeyValue)
#endif // ALLOC_PRAGMA


NTSTATUS
SerialGetConfigDefaults(
    IN PSERIAL_FIRMWARE_DATA    DriverDefaultsPtr,
    IN PUNICODE_STRING          RegistryPath
    )

/*++

Routine Description:

    This routine reads the default configuration data from the
    registry for the serial driver.

    It also builds fields in the registry for several configuration
    options if they don't exist.

Arguments:

    DriverDefaultsPtr - Pointer to a structure that will contain
                        the default configuration values.

    RegistryPath - points to the entry for this driver in the
                   current control set of the registry.

Return Value:

    STATUS_SUCCESS if we got the defaults, otherwise we failed.
    The only way to fail this call is if the  STATUS_INSUFFICIENT_RESOURCES.

--*/

{

    NTSTATUS Status = STATUS_SUCCESS;    // return value

    //
    // We use this to query into the registry for defaults
    //

    RTL_QUERY_REGISTRY_TABLE paramTable[8];
    
    PWCHAR  path;
    ULONG   zero            = 0;
    ULONG   DbgDefault      = 0;//SER_DBG_DEFAULT;
    ULONG   notThereDefault = SERIAL_UNINITIALIZED_DEFAULT;

    PAGED_CODE();

    //
    // Since the registry path parameter is a "counted" UNICODE string, it
    // might not be zero terminated.  For a very short time allocate memory
    // to hold the registry path zero terminated so that we can use it to
    // delve into the registry.
    //
    // NOTE NOTE!!!! This is not an architected way of breaking into
    // a driver.  It happens to work for this driver because the author
    // likes to do things this way.
    //

    path = ExAllocatePool (PagedPool, RegistryPath->Length+sizeof(WCHAR));
    
    if (!path) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        return (Status);
    }
    
    RtlZeroMemory (DriverDefaultsPtr, sizeof(SERIAL_FIRMWARE_DATA));
    RtlZeroMemory (&paramTable[0], sizeof(paramTable));
    RtlZeroMemory (path, RegistryPath->Length+sizeof(WCHAR));
    RtlMoveMemory (path, RegistryPath->Buffer, RegistryPath->Length);

    paramTable[0].Flags         = RTL_QUERY_REGISTRY_DIRECT;
    paramTable[0].Name          = L"BreakOnEntry";
    paramTable[0].EntryContext  = &DriverDefaultsPtr->ShouldBreakOnEntry;
    paramTable[0].DefaultType   = REG_DWORD;
    paramTable[0].DefaultData   = &zero;
    paramTable[0].DefaultLength = sizeof(ULONG);
    
    paramTable[1].Flags         = RTL_QUERY_REGISTRY_DIRECT;
    paramTable[1].Name          = L"DebugLevel";
    paramTable[1].EntryContext  = &DriverDefaultsPtr->DebugLevel;
    paramTable[1].DefaultType   = REG_DWORD;
    paramTable[1].DefaultData   = &DbgDefault;
    paramTable[1].DefaultLength = sizeof(ULONG);
    
    paramTable[2].Flags         = RTL_QUERY_REGISTRY_DIRECT;
    paramTable[2].Name          = L"ForceFifoEnable";
    paramTable[2].EntryContext  = &DriverDefaultsPtr->ForceFifoEnableDefault;
    paramTable[2].DefaultType   = REG_DWORD;
    paramTable[2].DefaultData   = &notThereDefault;
    paramTable[2].DefaultLength = sizeof(ULONG);
    
    paramTable[3].Flags         = RTL_QUERY_REGISTRY_DIRECT;
    paramTable[3].Name          = L"RxFIFO";
    paramTable[3].EntryContext  = &DriverDefaultsPtr->RxFIFODefault;
    paramTable[3].DefaultType   = REG_DWORD;
    paramTable[3].DefaultData   = &notThereDefault;
    paramTable[3].DefaultLength = sizeof(ULONG);
    
    paramTable[4].Flags         = RTL_QUERY_REGISTRY_DIRECT;
    paramTable[4].Name          = L"TxFIFO";
    paramTable[4].EntryContext  = &DriverDefaultsPtr->TxFIFODefault;
    paramTable[4].DefaultType   = REG_DWORD;
    paramTable[4].DefaultData   = &notThereDefault;
    paramTable[4].DefaultLength = sizeof(ULONG);
    
    paramTable[5].Flags         = RTL_QUERY_REGISTRY_DIRECT;
    paramTable[5].Name          = L"PermitShare";
    paramTable[5].EntryContext  = &DriverDefaultsPtr->PermitShareDefault;
    paramTable[5].DefaultType   = REG_DWORD;
    paramTable[5].DefaultData   = &notThereDefault;
    paramTable[5].DefaultLength = sizeof(ULONG);
    
    paramTable[6].Flags         = RTL_QUERY_REGISTRY_DIRECT;
    paramTable[6].Name          = L"LogFifo";
    paramTable[6].EntryContext  = &DriverDefaultsPtr->LogFifoDefault;
    paramTable[6].DefaultType   = REG_DWORD;
    paramTable[6].DefaultData   = &notThereDefault;
    paramTable[6].DefaultLength = sizeof(ULONG);

    Status = RtlQueryRegistryValues( RTL_REGISTRY_ABSOLUTE | RTL_REGISTRY_OPTIONAL,
                                     path,
                                     &paramTable[0],
                                     NULL,
                                     NULL);
       
    if (!NT_SUCCESS(Status)) {
            DriverDefaultsPtr->ShouldBreakOnEntry   = 0;
            DriverDefaultsPtr->DebugLevel           = 0;
    }

    //
    // Check to see if there was a forcefifo or an rxfifo size.
    // If there isn't then write out values so that they could
    // be adjusted later.
    //

    if (DriverDefaultsPtr->ForceFifoEnableDefault == notThereDefault) {

        DriverDefaultsPtr->ForceFifoEnableDefault = SERIAL_FORCE_FIFO_DEFAULT;
        RtlWriteRegistryValue(
            RTL_REGISTRY_ABSOLUTE,
            path,
            L"ForceFifoEnable",
            REG_DWORD,
            &DriverDefaultsPtr->ForceFifoEnableDefault,
            sizeof(ULONG)
            );

    }

    if (DriverDefaultsPtr->RxFIFODefault == notThereDefault) {
        DriverDefaultsPtr->RxFIFODefault = SERIAL_RX_FIFO_DEFAULT;
        RtlWriteRegistryValue(
            RTL_REGISTRY_ABSOLUTE,
            path,
            L"RxFIFO",
            REG_DWORD,
            &DriverDefaultsPtr->RxFIFODefault,
            sizeof(ULONG)
            );
    }

    if (DriverDefaultsPtr->TxFIFODefault == notThereDefault) {

        DriverDefaultsPtr->TxFIFODefault = SERIAL_TX_FIFO_DEFAULT;
        RtlWriteRegistryValue(
            RTL_REGISTRY_ABSOLUTE,
            path,
            L"TxFIFO",
            REG_DWORD,
            &DriverDefaultsPtr->TxFIFODefault,
            sizeof(ULONG)
            );
    }


    if (DriverDefaultsPtr->PermitShareDefault == notThereDefault) {

        DriverDefaultsPtr->PermitShareDefault = SERIAL_PERMIT_SHARE_DEFAULT;
        //
        // Only share if the user actual changes switch.
        //

        RtlWriteRegistryValue(
            RTL_REGISTRY_ABSOLUTE,
            path,
            L"PermitShare",
            REG_DWORD,
            &DriverDefaultsPtr->PermitShareDefault,
            sizeof(ULONG)
            );

    }


    if (DriverDefaultsPtr->LogFifoDefault == notThereDefault) {

        //
        // Wasn't there.  After this load don't log
        // the message anymore.  However this first
        // time log the message.
        //

        DriverDefaultsPtr->LogFifoDefault = SERIAL_LOG_FIFO_DEFAULT;

        RtlWriteRegistryValue(
            RTL_REGISTRY_ABSOLUTE,
            path,
            L"LogFifo",
            REG_DWORD,
            &DriverDefaultsPtr->LogFifoDefault,
            sizeof(ULONG)
            );

        DriverDefaultsPtr->LogFifoDefault = 1;

    }

    //
    // We don't need that path anymore.
    //

    if (path) {
        ExFreePool(path);
    }

    //
    //  Set the defaults for other values
    //
    DriverDefaultsPtr->PermitSystemWideShare = FALSE;

    return (Status);
}


NTSTATUS 
SerialGetRegistryKeyValue (
                          IN HANDLE Handle,
                          IN PWCHAR KeyNameString,
                          IN ULONG KeyNameStringLength,
                          IN PVOID Data,
                          IN ULONG DataLength
                          )
/*++

Routine Description:

    Reads a registry key value from an already opened registry key.
    
Arguments:

    Handle              Handle to the opened registry key
    
    KeyNameString       ANSI string to the desired key

    KeyNameStringLength Length of the KeyNameString

    Data                Buffer to place the key value in

    DataLength          Length of the data buffer

Return Value:

    STATUS_SUCCESS if all works, otherwise status of system call that
    went wrong.

--*/
{
   UNICODE_STRING              keyName;
   ULONG                       length;
   PKEY_VALUE_FULL_INFORMATION fullInfo;

   NTSTATUS                    ntStatus = STATUS_INSUFFICIENT_RESOURCES;

   PAGED_CODE();

   SerialDump(SERTRACECALLS, ("SERIAL: Enter SerialGetRegistryKeyValue\n"));


   RtlInitUnicodeString (&keyName, KeyNameString);

   length = sizeof(KEY_VALUE_FULL_INFORMATION) + KeyNameStringLength
      + DataLength;
   fullInfo = ExAllocatePool(PagedPool, length); 

   if (fullInfo) {
      ntStatus = ZwQueryValueKey (Handle,
                                  &keyName,
                                  KeyValueFullInformation,
                                  fullInfo,
                                  length,
                                  &length);

      if (NT_SUCCESS(ntStatus)) {
         //
         // If there is enough room in the data buffer, copy the output
         //

         if (DataLength >= fullInfo->DataLength) {
            RtlCopyMemory (Data, 
                           ((PUCHAR) fullInfo) + fullInfo->DataOffset, 
                           fullInfo->DataLength);
         }
      }

      ExFreePool(fullInfo);
   }

   return ntStatus;
}



NTSTATUS 
SerialPutRegistryKeyValue(IN HANDLE Handle, IN PWCHAR PKeyNameString,
			  IN ULONG KeyNameStringLength, IN ULONG Dtype,
                          IN PVOID PData, IN ULONG DataLength)
/*++

Routine Description:

    Writes a registry key value to an already opened registry key.
    
Arguments:

    Handle              Handle to the opened registry key
    
    PKeyNameString      ANSI string to the desired key

    KeyNameStringLength Length of the KeyNameString
    
    Dtype		REG_XYZ value type

    PData               Buffer to place the key value in

    DataLength          Length of the data buffer

Return Value:

    STATUS_SUCCESS if all works, otherwise status of system call that
    went wrong.

--*/
{
   NTSTATUS status;
   UNICODE_STRING keyname;

   PAGED_CODE();

   SerialDump(SERTRACECALLS,("SERIAL: Enter SerialPutRegistryKeyValue\n"));

   RtlInitUnicodeString(&keyname, NULL);
   keyname.MaximumLength = (USHORT)(KeyNameStringLength + sizeof(WCHAR));
   keyname.Buffer = ExAllocatePool(PagedPool, keyname.MaximumLength);

   if (keyname.Buffer == NULL) {
      return STATUS_INSUFFICIENT_RESOURCES;
   }

   RtlAppendUnicodeToString(&keyname, PKeyNameString);

   status = ZwSetValueKey(Handle, &keyname, 0, Dtype, PData, DataLength);

   ExFreePool(keyname.Buffer);
   
   return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\ser101\serial.h ===
/*++

Copyright (c) 1990, 1991, 1992, 1993 - 1997 Microsoft Corporation

Module Name :

    serial.h

Abstract:

    Type definitions and data for the serial port driver

Author:

    Anthony V. Ercolano                 April 8, 1991

--*/

#ifdef POOL_TAGGING
#undef ExAllocatePool
#undef ExAllocatePoolWithQuota
#define ExAllocatePool(a,b) ExAllocatePoolWithTag(a,b,'XMOC')
#define ExAllocatePoolWithQuota(a,b) ExAllocatePoolWithQuotaTag(a,b,'XMOC')
#endif


//
// The following definition is used to include/exclude changes made for power
// support in the driver.  If non-zero the support is included.  If zero the
// support is excluded.
//

#define POWER_SUPPORT   1

//
// The following is used to tell the serial driver to perform legacy detection
// and initialization until PnP functionality can be fully implemented.
//
// #define FAKE_IT         1

#define RM_PNP_CODE


#if DBG
#define SERDIAG1              ((ULONG)0x00000001)
#define SERDIAG2              ((ULONG)0x00000002)
#define SERDIAG3              ((ULONG)0x00000004)
#define SERDIAG4              ((ULONG)0x00000008)
#define SERDIAG5              ((ULONG)0x00000010)
#define SERIRPPATH            ((ULONG)0x00000020)
#define SERINITCODE           ((ULONG)0x00000040)
#define SERTRACECALLS         ((ULONG)0x00000040)
#define SERPNPPOWER           ((ULONG)0x00000100)
#define SERFLOW               ((ULONG)0x20000000)
#define SERERRORS             ((ULONG)0x40000000)
#define SERBUGCHECK           ((ULONG)0x80000000)
#define SERDBGALL             ((ULONG)0xFFFFFFFF)

#define SER_DBG_DEFAULT       SERDBGALL


extern ULONG SerialDebugLevel;
#if defined(NEC_98)
//
// DbgPrint header changed from SERIAL to SER101
//
#define SerialDump(LEVEL,STRING) \
            do { \
                ULONG _level = (LEVEL); \
                if (SerialDebugLevel & _level) { \
                    DbgPrint ("SER101: "); \
                    DbgPrint STRING; \
                } \
                if (_level == SERBUGCHECK) { \
                    ASSERT(FALSE); \
                } \
            } while (0)
#else
#define SerialDump(LEVEL,STRING) \
        do { \
            ULONG _level = (LEVEL); \
            if (SerialDebugLevel & _level) { \
                DbgPrint STRING; \
            } \
            if (_level == SERBUGCHECK) { \
                ASSERT(FALSE); \
            } \
        } while (0)
#endif //defined(NEC_98)
#else
#define SerialDump(LEVEL,STRING) do {NOTHING;} while (0)
#endif


//
// Some default driver values.  We will check the registry for
// them first.
//
#define SERIAL_UNINITIALIZED_DEFAULT    1234567
#define SERIAL_FORCE_FIFO_DEFAULT       1
#define SERIAL_RX_FIFO_DEFAULT          8
#define SERIAL_TX_FIFO_DEFAULT          14
#define SERIAL_PERMIT_SHARE_DEFAULT     0
#define SERIAL_LOG_FIFO_DEFAULT         0


//
// This define gives the default Object directory
// that we should use to insert the symbolic links
// between the NT device name and namespace used by
// that object directory.
#define DEFAULT_DIRECTORY L"DosDevices"

//
// For the above directory, the serial port will
// use the following name as the suffix of the serial
// ports for that directory.  It will also append
// a number onto the end of the name.  That number
// will start at 1.
#define DEFAULT_SERIAL_NAME L"COM"
//
//
// This define gives the default NT name for
// for serial ports detected by the firmware.
// This name will be appended to Device prefix
// with a number following it.  The number is
// incremented each time encounter a serial
// port detected by the firmware.  Note that
// on a system with multiple busses, this means
// that the first port on a bus is not necessarily
// \Device\Serial0.
//
#if defined(NEC_98)
#define DEFAULT_NT_SUFFIX L"Ser101"
#else
#define DEFAULT_NT_SUFFIX L"Serial"
#endif //defined(NEC_98)

#if defined(NEC_98)
//
// Out of offsets from the base register address of the
// various registers for the 71051.
//
#define SYSTEM_PORT_C         0x35
#define TIMER_MODE_REGISTER   0x77
#define TIMER_COUNT_REGISTER  0x75
#define COMMAND_SET           0x32
#define MODE_SET              0x32
#define IO_DELAY_REGISTER     0x5f
#define CONFIG_INDEX_REGISTER 0x411
#define CONFIG_DATA_REGISTER  0x413
#define TRANSFER_CLOCK_ENABLE_ADDRESS (UCHAR)0x83
#else
#endif //defined(NEC_98)
//
// This value - which could be redefined at compile
// time, define the stride between registers
//
#if !defined(SERIAL_REGISTER_STRIDE)
#define SERIAL_REGISTER_STRIDE 1
#endif

//
// Offsets from the base register address of the
// various registers for the 8250 family of UARTS.
//
#define RECEIVE_BUFFER_REGISTER    ((ULONG)((0x00)*SERIAL_REGISTER_STRIDE))
#define TRANSMIT_HOLDING_REGISTER  ((ULONG)((0x00)*SERIAL_REGISTER_STRIDE))
#if defined(NEC_98)
#define INTERRUPT_ENABLE_REGISTER  ((ULONG)((0x08)*SERIAL_REGISTER_STRIDE))
#define INTERRUPT_IDENT_REGISTER   ((ULONG)((0x06)*SERIAL_REGISTER_STRIDE))
#define FIFO_CONTROL_REGISTER      ((ULONG)((0x08)*SERIAL_REGISTER_STRIDE))
#define LINE_CONTROL_REGISTER      ((ULONG)((0x03)*SERIAL_REGISTER_STRIDE))
#define MODEM_CONTROL_REGISTER     ((ULONG)((0x04)*SERIAL_REGISTER_STRIDE))
#define LINE_STATUS_REGISTER       ((ULONG)((0x02)*SERIAL_REGISTER_STRIDE))
#define MODEM_STATUS_REGISTER      ((ULONG)((0x04)*SERIAL_REGISTER_STRIDE))
#define DIVISOR_LATCH_LSB          ((ULONG)((0x00)*SERIAL_REGISTER_STRIDE))
#define DIVISOR_LATCH_MSB          ((ULONG)((0x01)*SERIAL_REGISTER_STRIDE))
#define VFAST_BAUDCLK_REGISTER     ((ULONG)((0x0a)*SERIAL_REGISTER_STRIDE))
#define SERIAL_REGISTER_SPAN       ((ULONG)(10*SERIAL_REGISTER_STRIDE))
#else
#define INTERRUPT_ENABLE_REGISTER  ((ULONG)((0x01)*SERIAL_REGISTER_STRIDE))
#define INTERRUPT_IDENT_REGISTER   ((ULONG)((0x02)*SERIAL_REGISTER_STRIDE))
#define FIFO_CONTROL_REGISTER      ((ULONG)((0x02)*SERIAL_REGISTER_STRIDE))
#define LINE_CONTROL_REGISTER      ((ULONG)((0x03)*SERIAL_REGISTER_STRIDE))
#define MODEM_CONTROL_REGISTER     ((ULONG)((0x04)*SERIAL_REGISTER_STRIDE))
#define LINE_STATUS_REGISTER       ((ULONG)((0x05)*SERIAL_REGISTER_STRIDE))
#define MODEM_STATUS_REGISTER      ((ULONG)((0x06)*SERIAL_REGISTER_STRIDE))
#define DIVISOR_LATCH_LSB          ((ULONG)((0x00)*SERIAL_REGISTER_STRIDE))
#define DIVISOR_LATCH_MSB          ((ULONG)((0x01)*SERIAL_REGISTER_STRIDE))
#define SERIAL_REGISTER_SPAN       ((ULONG)(7*SERIAL_REGISTER_STRIDE))
#endif //defined(NEC_98)

//
// If we have an interrupt status register this is its assumed
// length.
//
#define SERIAL_STATUS_LENGTH       ((ULONG)(1*SERIAL_REGISTER_STRIDE))

#if defined(NEC_98)
//
// Offset from the base register address of the 
// INDEX registers for the PC-9801-101(on the 8251 family controler)
//

#define INDEX_REGISTER_OFFSET                ((ULONG)((0x04)*SERIAL_REGISTER_STRIDE))
#define INDEX_DATA_REGISTER_OFFSET           ((ULONG)((0x05)*SERIAL_REGISTER_STRIDE))

//
// 1stCCU Transfer Clock Enable Port
//
#define TXC_PERMIT   ((UCHAR)0x00)
#define TXC_PROHIBIT ((UCHAR)0x01)

//
// V.Fast mode buad rate clock for 101
//
#define VFAST_BAUD_0075   ((SHORT)0x03)
#define VFAST_BAUD_0150   ((SHORT)0x04)
#define VFAST_BAUD_0300   ((SHORT)0x05)
#define VFAST_BAUD_0600   ((SHORT)0x06)
#define VFAST_BAUD_1200   ((SHORT)0x07)
#define VFAST_BAUD_2400   ((SHORT)0x08)
#define VFAST_BAUD_4800   ((SHORT)0x09)
#define VFAST_BAUD_9600   ((SHORT)0x0a)
#define VFAST_BAUD_14400  ((SHORT)0x0b)
#define VFAST_BAUD_19200  ((SHORT)0x0c)
#define VFAST_BAUD_38400  ((SHORT)0x0d)
#define VFAST_BAUD_57600  ((SHORT)0x0e)
#define VFAST_BAUD_115200 ((SHORT)0x0f)

//
// Communication mode default(ASYNC)

//
#define COMMUNICATION_MODE  0x00

//
// default control word to Timer Mode register
//
#define TIMER_DEFAULT_CONTROL ((UCHAR)0xb6)

//
// default out data to command set register
//
#define COMMAND_DEFAULT_SET ((UCHAR)0x15)
#define COMMAND_ERROR_RESET ((UCHAR)0x40)

//
// default baud rate mode(x16) to Mode Set register
//
#define BAUDRATE_DEFAULT_MODE ((UCHAR)0x02)

//
// default out data to Io Delay register
//
#define IO_DELAY_DATA ((UCHAR)0x00)

//
// Fifo mode enable
//
#define DISABLE_FIFO_MODE ((UCHAR)0x00)
#define SUPPORT_FIFO_MODE ((UCHAR)0x40)
#define SUPPORT_FIFO_MASK ((UCHAR)0x60)

//
// Interrupt enable bit
//
#define MODEM_STATUS_INTERRUPT  ((UCHAR)0x10)
#define LINE_STATUS_INTERRUPT   ((UCHAR)0x08)
#define TRANSMIT_FIFO_INTERRUPT ((UCHAR)0x04)
#define RECEIVE_FIFO_INTERRUPT  ((UCHAR)0x01)

//
// These defines are used to set the line control register.
//
#define SER71051_PARITY_MASK  ((UCHAR)0x18)
#define SER71051_1_STOP       ((UCHAR)0x40)
#define SER71051_1_5_STOP     ((UCHAR)0x80)
#define SER71051_2_STOP       ((UCHAR)0xc0)

// This defines the bit used to control whether the device is sending
// a break.  When this bit is set the device is sending a space (logic 0).
//
#define SER71051_SEND_BREAK    0x08
#else
#endif //defined(NEC_98)
//
// Bitmask definitions for accessing the 8250 device registers.
//

//
// These bits define the number of data bits trasmitted in
// the Serial Data Unit (SDU - Start,data, parity, and stop bits)
//
#define SERIAL_DATA_LENGTH_5 0x00
#define SERIAL_DATA_LENGTH_6 0x01
#define SERIAL_DATA_LENGTH_7 0x02
#define SERIAL_DATA_LENGTH_8 0x03


//
// These masks define the interrupts that can be enabled or disabled.
//
//
// This interrupt is used to notify that there is new incomming
// data available.  The SERIAL_RDA interrupt is enabled by this bit.
//
#define SERIAL_IER_RDA   0x01

//
// This interrupt is used to notify that there is space available
// in the transmitter for another character.  The SERIAL_THR
// interrupt is enabled by this bit.
//
#define SERIAL_IER_THR   0x02

//
// This interrupt is used to notify that some sort of error occured
// with the incomming data.  The SERIAL_RLS interrupt is enabled by
// this bit.
#define SERIAL_IER_RLS   0x04

//
// This interrupt is used to notify that some sort of change has
// taken place in the modem control line.  The SERIAL_MS interrupt is
// enabled by this bit.
//
#define SERIAL_IER_MS    0x08


//
// These masks define the values of the interrupt identification
// register.  The low bit must be clear in the interrupt identification
// register for any of these interrupts to be valid.  The interrupts
// are defined in priority order, with the highest value being most
// important.  See above for a description of what each interrupt
// implies.
//
#define SERIAL_IIR_RLS      0x06
#define SERIAL_IIR_RDA      0x04
#define SERIAL_IIR_CTI      0x0c
#define SERIAL_IIR_THR      0x02
#define SERIAL_IIR_MS       0x00

//
// This bit mask get the value of the high two bits of the
// interrupt id register.  If this is a 16550 class chip
// these bits will be a one if the fifo's are enbled, otherwise
// they will always be zero.
//
#define SERIAL_IIR_FIFOS_ENABLED 0xc0

//
// If the low bit is logic one in the interrupt identification register
// this implies that *NO* interrupts are pending on the device.
//
#define SERIAL_IIR_NO_INTERRUPT_PENDING 0x01



//
// These masks define access to the fifo control register.
//

//
// Enabling this bit in the fifo control register will turn
// on the fifos.  If the fifos are enabled then the high two
// bits of the interrupt id register will be set to one.  Note
// that this only occurs on a 16550 class chip.  If the high
// two bits in the interrupt id register are not one then
// we know we have a lower model chip.
//
//
#define SERIAL_FCR_ENABLE     ((UCHAR)0x01)
#define SERIAL_FCR_RCVR_RESET ((UCHAR)0x02)
#define SERIAL_FCR_TXMT_RESET ((UCHAR)0x04)

//
// This set of values define the high water marks (when the
// interrupts trip) for the receive fifo.
//
#define SERIAL_1_BYTE_HIGH_WATER   ((UCHAR)0x00)
#define SERIAL_4_BYTE_HIGH_WATER   ((UCHAR)0x40)
#define SERIAL_8_BYTE_HIGH_WATER   ((UCHAR)0x80)
#define SERIAL_14_BYTE_HIGH_WATER  ((UCHAR)0xc0)

//
// These masks define access to the line control register.
//

//
// This defines the bit used to control the definition of the "first"
// two registers for the 8250.  These registers are the input/output
// register and the interrupt enable register.  When the DLAB bit is
// enabled these registers become the least significant and most
// significant bytes of the divisor value.
//
#define SERIAL_LCR_DLAB     0x80

//
// This defines the bit used to control whether the device is sending
// a break.  When this bit is set the device is sending a space (logic 0).
//
// Most protocols will assume that this is a hangup.
//
#define SERIAL_LCR_BREAK    0x40

//
// These defines are used to set the line control register.
//
#define SERIAL_5_DATA       ((UCHAR)0x00)
#define SERIAL_6_DATA       ((UCHAR)0x01)
#define SERIAL_7_DATA       ((UCHAR)0x02)
#define SERIAL_8_DATA       ((UCHAR)0x03)
#define SERIAL_DATA_MASK    ((UCHAR)0x03)

#define SERIAL_1_STOP       ((UCHAR)0x00)
#define SERIAL_1_5_STOP     ((UCHAR)0x04) // Only valid for 5 data bits
#define SERIAL_2_STOP       ((UCHAR)0x04) // Not valid for 5 data bits
#define SERIAL_STOP_MASK    ((UCHAR)0x04)

#define SERIAL_NONE_PARITY  ((UCHAR)0x00)
#define SERIAL_ODD_PARITY   ((UCHAR)0x08)
#define SERIAL_EVEN_PARITY  ((UCHAR)0x18)
#define SERIAL_MARK_PARITY  ((UCHAR)0x28)
#define SERIAL_SPACE_PARITY ((UCHAR)0x38)
#define SERIAL_PARITY_MASK  ((UCHAR)0x38)

//
// These masks define access the modem control register.
//

//
// This bit controls the data terminal ready (DTR) line.  When
// this bit is set the line goes to logic 0 (which is then inverted
// by normal hardware).  This is normally used to indicate that
// the device is available to be used.  Some odd hardware
// protocols (like the kernel debugger) use this for handshaking
// purposes.
//
#define SERIAL_MCR_DTR      0x01

//
// This bit controls the ready to send (RTS) line.  When this bit
// is set the line goes to logic 0 (which is then inverted by the normal
// hardware).  This is used for hardware handshaking.  It indicates that
// the hardware is ready to send data and it is waiting for the
// receiving end to set clear to send (CTS).
//
#define SERIAL_MCR_RTS      0x02

//
// This bit is used for general purpose output.
//
#define SERIAL_MCR_OUT1     0x04

//
// This bit is used for general purpose output.
//
#define SERIAL_MCR_OUT2     0x08

//
// This bit controls the loopback testing mode of the device.  Basically
// the outputs are connected to the inputs (and vice versa).
//
#define SERIAL_MCR_LOOP     0x10


//
// These masks define access to the line status register.  The line
// status register contains information about the status of data
// transfer.  The first five bits deal with receive data and the
// last two bits deal with transmission.  An interrupt is generated
// whenever bits 1 through 4 in this register are set.
//

//
// This bit is the data ready indicator.  It is set to indicate that
// a complete character has been received.  This bit is cleared whenever
// the receive buffer register has been read.
//
#define SERIAL_LSR_DR       0x01

//
// This is the overrun indicator.  It is set to indicate that the receive
// buffer register was not read befor a new character was transferred
// into the buffer.  This bit is cleared when this register is read.
//
#define SERIAL_LSR_OE       0x02

//
// This is the parity error indicator.  It is set whenever the hardware
// detects that the incoming serial data unit does not have the correct
// parity as defined by the parity select in the line control register.
// This bit is cleared by reading this register.
//
#define SERIAL_LSR_PE       0x04

//
// This is the framing error indicator.  It is set whenever the hardware
// detects that the incoming serial data unit does not have a valid
// stop bit.  This bit is cleared by reading this register.
//
#define SERIAL_LSR_FE       0x08

//
// This is the break interrupt indicator.  It is set whenever the data
// line is held to logic 0 for more than the amount of time it takes
// to send one serial data unit.  This bit is cleared whenever the
// this register is read.
//
#define SERIAL_LSR_BI       0x10

//
// This is the transmit holding register empty indicator.  It is set
// to indicate that the hardware is ready to accept another character
// for transmission.  This bit is cleared whenever a character is
// written to the transmit holding register.
//
#define SERIAL_LSR_THRE     0x20

//
// This bit is the transmitter empty indicator.  It is set whenever the
// transmit holding buffer is empty and the transmit shift register
// (a non-software accessable register that is used to actually put
// the data out on the wire) is empty.  Basically this means that all
// data has been sent.  It is cleared whenever the transmit holding or
// the shift registers contain data.
//
#define SERIAL_LSR_TEMT     0x40

//
// This bit indicates that there is at least one error in the fifo.
// The bit will not be turned off until there are no more errors
// in the fifo.
//
#define SERIAL_LSR_FIFOERR  0x80


//
// These masks are used to access the modem status register.
// Whenever one of the first four bits in the modem status
// register changes state a modem status interrupt is generated.
//

//
// This bit is the delta clear to send.  It is used to indicate
// that the clear to send bit (in this register) has *changed*
// since this register was last read by the CPU.
//
#define SERIAL_MSR_DCTS     0x01

//
// This bit is the delta data set ready.  It is used to indicate
// that the data set ready bit (in this register) has *changed*
// since this register was last read by the CPU.
//
#define SERIAL_MSR_DDSR     0x02

//
// This is the trailing edge ring indicator.  It is used to indicate
// that the ring indicator input has changed from a low to high state.
//
#define SERIAL_MSR_TERI     0x04

//
// This bit is the delta data carrier detect.  It is used to indicate
// that the data carrier bit (in this register) has *changed*
// since this register was last read by the CPU.
//
#define SERIAL_MSR_DDCD     0x08

//
// This bit contains the (complemented) state of the clear to send
// (CTS) line.
//
#define SERIAL_MSR_CTS      0x10

//
// This bit contains the (complemented) state of the data set ready
// (DSR) line.
//
#define SERIAL_MSR_DSR      0x20

//
// This bit contains the (complemented) state of the ring indicator
// (RI) line.
//
#define SERIAL_MSR_RI       0x40

//
// This bit contains the (complemented) state of the data carrier detect
// (DCD) line.
//
#define SERIAL_MSR_DCD      0x80

//
// This should be more than enough space to hold then
// numeric suffix of the device name.
//
#define DEVICE_NAME_DELTA 20


//
// Up to 16 Ports Per card.  However for sixteen
// port cards the interrupt status register must me
// the indexing kind rather then the bitmask kind.
//
//
#define SERIAL_MAX_PORTS_INDEXED (16)
#define SERIAL_MAX_PORTS_NONINDEXED (8)

typedef struct _CONFIG_DATA {
    PHYSICAL_ADDRESS    Controller;
    PHYSICAL_ADDRESS    TrController;
    PHYSICAL_ADDRESS    InterruptStatus;
    PHYSICAL_ADDRESS    TrInterruptStatus;
    ULONG               SpanOfController;
    ULONG               SpanOfInterruptStatus;
    ULONG               PortIndex;
    ULONG               ClockRate;
    ULONG               BusNumber;
    ULONG               AddressSpace;
    ULONG               DisablePort;
    ULONG               ForceFifoEnable;
    ULONG               RxFIFO;
    ULONG               TxFIFO;
    ULONG               PermitShare;
    ULONG               PermitSystemWideShare;
    ULONG               LogFifo;
    ULONG               MaskInverted;
    KINTERRUPT_MODE     InterruptMode;
    INTERFACE_TYPE      InterfaceType;
    ULONG               OriginalVector;
    ULONG               OriginalIrql;
    ULONG               TrVector;
    ULONG               TrIrql;
    ULONG               Affinity;
    ULONG               Indexed;
    BOOLEAN             Jensen;
    } CONFIG_DATA,*PCONFIG_DATA;

//
// Serial ISR switch structure
//

typedef struct _SERIAL_CISR_SW {
   BOOLEAN (*IsrFunc)(PKINTERRUPT, PVOID);
   PVOID Context;
   LIST_ENTRY SharerList;
} SERIAL_CISR_SW, *PSERIAL_CISR_SW;


//
// This structure contains configuration data, much of which
// is read from the registry.
//
typedef struct _SERIAL_FIRMWARE_DATA {
    PDRIVER_OBJECT  DriverObject;
    ULONG           ControllersFound;
    ULONG           ForceFifoEnableDefault;
    ULONG           DebugLevel;
    ULONG           ShouldBreakOnEntry;
    ULONG           RxFIFODefault;
    ULONG           TxFIFODefault;
    ULONG           PermitShareDefault;
    ULONG           PermitSystemWideShare;
    ULONG           LogFifoDefault;
    UNICODE_STRING  Directory;
    UNICODE_STRING  NtNameSuffix;
    UNICODE_STRING  DirectorySymbolicName;
    LIST_ENTRY      ConfigList;
    BOOLEAN         JensenDetected;
} SERIAL_FIRMWARE_DATA,*PSERIAL_FIRMWARE_DATA;

//
// Default xon/xoff characters.
//
#define SERIAL_DEF_XON 0x11
#define SERIAL_DEF_XOFF 0x13

//
// Reasons that recption may be held up.
//
#define SERIAL_RX_DTR       ((ULONG)0x01)
#define SERIAL_RX_XOFF      ((ULONG)0x02)
#define SERIAL_RX_RTS       ((ULONG)0x04)
#define SERIAL_RX_DSR       ((ULONG)0x08)

//
// Reasons that transmission may be held up.
//
#define SERIAL_TX_CTS       ((ULONG)0x01)
#define SERIAL_TX_DSR       ((ULONG)0x02)
#define SERIAL_TX_DCD       ((ULONG)0x04)
#define SERIAL_TX_XOFF      ((ULONG)0x08)
#define SERIAL_TX_BREAK     ((ULONG)0x10)

//
// These values are used by the routines that can be used
// to complete a read (other than interval timeout) to indicate
// to the interval timeout that it should complete.
//
#define SERIAL_COMPLETE_READ_CANCEL ((LONG)-1)
#define SERIAL_COMPLETE_READ_TOTAL ((LONG)-2)
#define SERIAL_COMPLETE_READ_COMPLETE ((LONG)-3)

//
// These are default values that shouldn't appear in the registry
//
#define SERIAL_BAD_VALUE ((ULONG)-1)


typedef struct _SERIAL_DEVICE_STATE {
   //
   // TRUE if we need to set the state to open
   // on a powerup
   //

   BOOLEAN Reopen;

   //
   // Hardware registers
   //

   UCHAR IER;
   // FCR is known by other values
   UCHAR LCR;
   UCHAR MCR;
   // LSR is never written
   // MSR is never written
   // SCR is either scratch or interrupt status


} SERIAL_DEVICE_STATE, *PSERIAL_DEVICE_STATE;


#if DBG
#define SerialLockPagableSectionByHandle(_secHandle) \
{ \
    MmLockPagableSectionByHandle((_secHandle)); \
    InterlockedIncrement(&SerialGlobals.PAGESER_Count); \
}

#define SerialUnlockPagableImageSection(_secHandle) \
{ \
   InterlockedDecrement(&SerialGlobals.PAGESER_Count); \
   MmUnlockPagableImageSection(_secHandle); \
}


#define SERIAL_LOCKED_PAGED_CODE() \
    if ((KeGetCurrentIrql() > APC_LEVEL)  \
    && (SerialGlobals.PAGESER_Count == 0)) { \
    KdPrint(("SERIAL: Pageable code called at IRQL %d without lock \n", \
             KeGetCurrentIrql())); \
        ASSERT(FALSE); \
        }

#else
#define SerialLockPagableSectionByHandle(_secHandle) \
{ \
    MmLockPagableSectionByHandle((_secHandle)); \
}

#define SerialUnlockPagableImageSection(_secHandle) \
{ \
   MmUnlockPagableImageSection(_secHandle); \
}

#define SERIAL_LOCKED_PAGED_CODE()
#endif // DBG



#define SerialRemoveQueueDpc(_dpc, _pExt) \
{ \
  if (KeRemoveQueueDpc((_dpc))) { \
     InterlockedDecrement(&(_pExt)->DpcCount); \
  } \
}


typedef struct _SERIAL_DEVICE_EXTENSION {

    //
    // This holds the isr that should be called from our own
    // dispatching isr for "cards" that are trying to share the
    // same interrupt.
    //
    PKSERVICE_ROUTINE TopLevelOurIsr;

    //
    // This holds the context that should be used when we
    // call the above service routine.
    //
    PVOID TopLevelOurIsrContext;

    //
    // This links together all of the different "cards" that are
    // trying to share the same interrupt of a non-mca machine.
    //
    LIST_ENTRY TopLevelSharers;

    //
    // This circular doubly linked list links together all
    // devices that are using the same interrupt object.
    // NOTE: This does not mean that they are using the
    // same interrupt "dispatching" routine.
    //
    LIST_ENTRY CommonInterruptObject;

    //
    // This is to link together ports on the same multiport card
    //

    LIST_ENTRY MultiportSiblings;

    //
    // This links together all devobjs that this driver owns.
    // It is needed to search when starting a new device.
    //
    LIST_ENTRY AllDevObjs;

    //
    // For reporting resource usage, we keep around the physical
    // address we got from the registry.
    //
    PHYSICAL_ADDRESS OriginalController;

    //
    // For reporting resource usage, we keep around the physical
    // address we got from the registry.
    //
    PHYSICAL_ADDRESS OriginalInterruptStatus;

    //
    // This value is set by the read code to hold the time value
    // used for read interval timing.  We keep it in the extension
    // so that the interval timer dpc routine determine if the
    // interval time has passed for the IO.
    //
    LARGE_INTEGER IntervalTime;

    //
    // These two values hold the "constant" time that we should use
    // to delay for the read interval time.
    //
    LARGE_INTEGER ShortIntervalAmount;
    LARGE_INTEGER LongIntervalAmount;

    //
    // This holds the value that we use to determine if we should use
    // the long interval delay or the short interval delay.
    //
    LARGE_INTEGER CutOverAmount;

    //
    // This holds the system time when we last time we had
    // checked that we had actually read characters.  Used
    // for interval timing.
    //
    LARGE_INTEGER LastReadTime;

    //
    // We keep a pointer around to our device name for dumps
    // and for creating "external" symbolic links to this
    // device.
    //
    UNICODE_STRING DeviceName;

    //
    // This points to the object directory that we will place
    // a symbolic link to our device name.
    //
    UNICODE_STRING ObjectDirectory;

    //
    // This points to the device name for this device
    // sans device prefix.
    //
    UNICODE_STRING NtNameForPort;

    //
    // This points to the symbolic link name that will be
    // linked to the actual nt device name.
    //
    UNICODE_STRING SymbolicLinkName;

    //
    // This points to the pure "COMx" name
    //
    UNICODE_STRING DosName;

    //
    // This points the the delta time that we should use to
    // delay for interval timing.
    //
    PLARGE_INTEGER IntervalTimeToUse;

    //
    // Points to the device object that contains
    // this device extension.
    //
    PDEVICE_OBJECT DeviceObject;

    //
    // After initialization of the driver is complete, this
    // will either be NULL or point to the routine that the
    // kernel will call when an interrupt occurs.
    //
    // If the pointer is null then this is part of a list
    // of ports that are sharing an interrupt and this isn't
    // the first port that we configured for this interrupt.
    //
    // If the pointer is non-null then this routine has some
    // kind of structure that will "eventually" get us into
    // the real serial isr with a pointer to this device extension.
    //
    // NOTE: On an MCA bus (except for multiport cards) this
    // is always a pointer to the "real" serial isr.
    PKSERVICE_ROUTINE OurIsr;

    //
    // This will generally point right to this device extension.
    //
    // However, when the port that this device extension is
    // "managing" was the first port initialized on a chain
    // of ports that were trying to share an interrupt, this
    // will point to a structure that will enable dispatching
    // to any port on the chain of sharers of this interrupt.
    //
    PVOID OurIsrContext;

    //
    // The base address for the set of device registers
    // of the serial port.
    //
    PUCHAR Controller;

    //
    // The base address for interrupt status register.
    // This is only defined in the root extension.
    //
    PUCHAR InterruptStatus;

    //
    // Points to the interrupt object for used by this device.
    //
    PKINTERRUPT Interrupt;

    //
    // This list head is used to contain the time ordered list
    // of read requests.  Access to this list is protected by
    // the global cancel spinlock.
    //
    LIST_ENTRY ReadQueue;

    //
    // This list head is used to contain the time ordered list
    // of write requests.  Access to this list is protected by
    // the global cancel spinlock.
    //
    LIST_ENTRY WriteQueue;

    //
    // This list head is used to contain the time ordered list
    // of set and wait mask requests.  Access to this list is protected by
    // the global cancel spinlock.
    //
    LIST_ENTRY MaskQueue;

    //
    // Holds the serialized list of purge requests.
    //
    LIST_ENTRY PurgeQueue;

    //
    // This points to the irp that is currently being processed
    // for the read queue.  This field is initialized by the open to
    // NULL.
    //
    // This value is only set at dispatch level.  It may be
    // read at interrupt level.
    //
    PIRP CurrentReadIrp;

    //
    // This points to the irp that is currently being processed
    // for the write queue.
    //
    // This value is only set at dispatch level.  It may be
    // read at interrupt level.
    //
    PIRP CurrentWriteIrp;

    //
    // Points to the irp that is currently being processed to
    // affect the wait mask operations.
    //
    PIRP CurrentMaskIrp;

    //
    // Points to the irp that is currently being processed to
    // purge the read/write queues and buffers.
    //
    PIRP CurrentPurgeIrp;

    //
    // Points to the current irp that is waiting on a comm event.
    //
    PIRP CurrentWaitIrp;

    //
    // Points to the irp that is being used to send an immediate
    // character.
    //
    PIRP CurrentImmediateIrp;

    //
    // Points to the irp that is being used to count the number
    // of characters received after an xoff (as currently defined
    // by the IOCTL_SERIAL_XOFF_COUNTER ioctl) is sent.
    //
    PIRP CurrentXoffIrp;

    //
    // Holds the number of bytes remaining in the current write
    // irp.
    //
    // This location is only accessed while at interrupt level.
    //
    ULONG WriteLength;

    //
    // Holds a pointer to the current character to be sent in
    // the current write.
    //
    // This location is only accessed while at interrupt level.
    //
    PUCHAR WriteCurrentChar;

    //
    // This is a buffer for the read processing.
    //
    // The buffer works as a ring.  When the character is read from
    // the device it will be place at the end of the ring.
    //
    // Characters are only placed in this buffer at interrupt level
    // although character may be read at any level. The pointers
    // that manage this buffer may not be updated except at interrupt
    // level.
    //
    PUCHAR InterruptReadBuffer;

    //
    // This is a pointer to the first character of the buffer into
    // which the interrupt service routine is copying characters.
    //
    PUCHAR ReadBufferBase;

    //
    // This is a count of the number of characters in the interrupt
    // buffer.  This value is set and read at interrupt level.  Note
    // that this value is only *incremented* at interrupt level so
    // it is safe to read it at any level.  When characters are
    // copied out of the read buffer, this count is decremented by
    // a routine that synchronizes with the ISR.
    //
    ULONG CharsInInterruptBuffer;

    //
    // Points to the first available position for a newly received
    // character.  This variable is only accessed at interrupt level and
    // buffer initialization code.
    //
    PUCHAR CurrentCharSlot;

    //
    // This variable is used to contain the last available position
    // in the read buffer.  It is updated at open and at interrupt
    // level when switching between the users buffer and the interrupt
    // buffer.
    //
    PUCHAR LastCharSlot;

    //
    // This marks the first character that is available to satisfy
    // a read request.  Note that while this always points to valid
    // memory, it may not point to a character that can be sent to
    // the user.  This can occur when the buffer is empty.
    //
    PUCHAR FirstReadableChar;

    //
    // Pointer to the lock variable returned for this extension when
    // locking down the driver
    //
    PVOID LockPtr;


    //
    // This variable holds the size of whatever buffer we are currently
    // using.
    //
    ULONG BufferSize;

    //
    // This variable holds .8 of BufferSize. We don't want to recalculate
    // this real often - It's needed when so that an application can be
    // "notified" that the buffer is getting full.
    //
    ULONG BufferSizePt8;

    //
    // This value holds the number of characters desired for a
    // particular read.  It is initially set by read length in the
    // IRP.  It is decremented each time more characters are placed
    // into the "users" buffer buy the code that reads characters
    // out of the typeahead buffer into the users buffer.  If the
    // typeahead buffer is exhausted by the read, and the reads buffer
    // is given to the isr to fill, this value is becomes meaningless.
    //
    ULONG NumberNeededForRead;

    //
    // This mask will hold the bitmask sent down via the set mask
    // ioctl.  It is used by the interrupt service routine to determine
    // if the occurence of "events" (in the serial drivers understanding
    // of the concept of an event) should be noted.
    //
    ULONG IsrWaitMask;

    //
    // This mask will always be a subset of the IsrWaitMask.  While
    // at device level, if an event occurs that is "marked" as interesting
    // in the IsrWaitMask, the driver will turn on that bit in this
    // history mask.  The driver will then look to see if there is a
    // request waiting for an event to occur.  If there is one, it
    // will copy the value of the history mask into the wait irp, zero
    // the history mask, and complete the wait irp.  If there is no
    // waiting request, the driver will be satisfied with just recording
    // that the event occured.  If a wait request should be queued,
    // the driver will look to see if the history mask is non-zero.  If
    // it is non-zero, the driver will copy the history mask into the
    // irp, zero the history mask, and then complete the irp.
    //
    ULONG HistoryMask;

    //
    // This is a pointer to the where the history mask should be
    // placed when completing a wait.  It is only accessed at
    // device level.
    //
    // We have a pointer here to assist us to synchronize completing a wait.
    // If this is non-zero, then we have wait outstanding, and the isr still
    // knows about it.  We make this pointer null so that the isr won't
    // attempt to complete the wait.
    //
    // We still keep a pointer around to the wait irp, since the actual
    // pointer to the wait irp will be used for the "common" irp completion
    // path.
    //
    ULONG *IrpMaskLocation;

    //
    // This mask holds all of the reason that transmission
    // is not proceeding.  Normal transmission can not occur
    // if this is non-zero.
    //
    // This is only written from interrupt level.
    // This could be (but is not) read at any level.
    //
    ULONG TXHolding;

    //
    // This mask holds all of the reason that reception
    // is not proceeding.  Normal reception can not occur
    // if this is non-zero.
    //
    // This is only written from interrupt level.
    // This could be (but is not) read at any level.
    //
    ULONG RXHolding;

    //
    // This holds the reasons that the driver thinks it is in
    // an error state.
    //
    // This is only written from interrupt level.
    // This could be (but is not) read at any level.
    //
    ULONG ErrorWord;

    //
    // This keeps a total of the number of characters that
    // are in all of the "write" irps that the driver knows
    // about.  It is only accessed with the cancel spinlock
    // held.
    //
    ULONG TotalCharsQueued;

    //
    // This holds a count of the number of characters read
    // the last time the interval timer dpc fired.  It
    // is a long (rather than a ulong) since the other read
    // completion routines use negative values to indicate
    // to the interval timer that it should complete the read
    // if the interval timer DPC was lurking in some DPC queue when
    // some other way to complete occurs.
    //
    LONG CountOnLastRead;

    //
    // This is a count of the number of characters read by the
    // isr routine.  It is *ONLY* written at isr level.  We can
    // read it at dispatch level.
    //
    ULONG ReadByIsr;

    //
    // This holds the current baud rate for the device.
    //
    ULONG CurrentBaud;

    //
    // This is the number of characters read since the XoffCounter
    // was started.  This variable is only accessed at device level.
    // If it is greater than zero, it implies that there is an
    // XoffCounter ioctl in the queue.
    //
    LONG CountSinceXoff;

    //
    // This ulong is incremented each time something trys to start
    // the execution path that tries to lower the RTS line when
    // doing transmit toggling.  If it "bumps" into another path
    // (indicated by a false return value from queueing a dpc
    // and a TRUE return value tring to start a timer) it will
    // decrement the count.  These increments and decrements
    // are all done at device level.  Note that in the case
    // of a bump while trying to start the timer, we have to
    // go up to device level to do the decrement.
    //
    ULONG CountOfTryingToLowerRTS;

    //
    // This ULONG is used to keep track of the "named" (in ntddser.h)
    // baud rates that this particular device supports.
    //
    ULONG SupportedBauds;

    //
    // This value holds the span (in units of bytes) of the register
    // set controlling this port.  This is constant over the life
    // of the port.
    //
    ULONG SpanOfController;

    //
    // This value holds the span (in units of bytes) of the interrupt
    // status register associated with this port.  This is constant
    // over the life of the port.
    //
    ULONG SpanOfInterruptStatus;

    //
    // Hold the clock rate input to the serial part.
    //
    ULONG ClockRate;

    //
    // The number of characters to push out if a fifo is present.
    //
    ULONG TxFifoAmount;

    //
    // Set to indicate that it is ok to share interrupts within the device.
    //
    ULONG PermitShare;

    //
    // Holds the timeout controls for the device.  This value
    // is set by the Ioctl processing.
    //
    // It should only be accessed under protection of the control
    // lock since more than one request can be in the control dispatch
    // routine at one time.
    //
    SERIAL_TIMEOUTS Timeouts;

    //
    // This holds the various characters that are used
    // for replacement on errors and also for flow control.
    //
    // They are only set at interrupt level.
    //
    SERIAL_CHARS SpecialChars;

    //
    // This structure holds the handshake and control flow
    // settings for the serial driver.
    //
    // It is only set at interrupt level.  It can be
    // be read at any level with the control lock held.
    //
    SERIAL_HANDFLOW HandFlow;


    //
    // Holds performance statistics that applications can query.
    // Reset on each open.  Only set at device level.
    //
    SERIALPERF_STATS PerfStats;

    //
    // This holds what we beleive to be the current value of
    // the line control register.
    //
    // It should only be accessed under protection of the control
    // lock since more than one request can be in the control dispatch
    // routine at one time.
    //
    UCHAR LineControl;

    //
    // We keep track of whether the somebody has the device currently
    // opened with a simple boolean.  We need to know this so that
    // spurious interrupts from the device (especially during initialization)
    // will be ignored.  This value is only accessed in the ISR and
    // is only set via synchronization routines.  We may be able
    // to get rid of this boolean when the code is more fleshed out.
    //
    BOOLEAN DeviceIsOpened;

    //
    // Set at intialization to indicate that on the current
    // architecture we need to unmap the base register address
    // when we unload the driver.
    //
    BOOLEAN UnMapRegisters;

    //
    // Set at intialization to indicate that on the current
    // architecture we need to unmap the interrupt status address
    // when we unload the driver.
    //
    BOOLEAN UnMapStatus;

    //
    // This is only accessed at interrupt level.  It keeps track
    // of whether the holding register is empty.
    //
    BOOLEAN HoldingEmpty;

    //
    // This variable is only accessed at interrupt level.  It
    // indicates that we want to transmit a character immediately.
    // That is - in front of any characters that could be transmitting
    // from a normal write.
    //
    BOOLEAN TransmitImmediate;

    //
    // This variable is only accessed at interrupt level.  Whenever
    // a wait is initiated this variable is set to false.
    // Whenever any kind of character is written it is set to true.
    // Whenever the write queue is found to be empty the code that
    // is processing that completing irp will synchonize with the interrupt.
    // If this synchronization code finds that the variable is true and that
    // there is a wait on the transmit queue being empty then it is
    // certain that the queue was emptied and that it has happened since
    // the wait was initiated.
    //
    BOOLEAN EmptiedTransmit;

    //
    // This simply indicates that the port associated with this
    // extension is part of a multiport card.
    //
    BOOLEAN PortOnAMultiportCard;


    //
    // We keep the following values around so that we can connect
    // to the interrupt and report resources after the configuration
    // record is gone.
    //

    //
    // Translated vector
    //

    ULONG Vector;

    //
    // Translated Irql
    //

    KIRQL Irql;


    //
    // Untranslated vector
    //

    ULONG OriginalVector;


    //
    // Untranslated irql
    //

    ULONG OriginalIrql;


    //
    // Address space
    //

    ULONG AddressSpace;


    //
    // Bus number
    //

    ULONG BusNumber;


    //
    // Interface type
    //

    INTERFACE_TYPE InterfaceType;


    //
    // Port index no for multiport devices
    //

    ULONG PortIndex;


    //
    // Indexed flag for multiport devices
    //

    BOOLEAN Indexed;

    //
    // Mask inverted mask for multiport devices
    //

    ULONG MaskInverted;

    //
    // Needed to add new devices to multiport boards
    //

    ULONG NewPortIndex;
    ULONG NewMaskInverted;
    PVOID NewExtension;

    //
    // We hold the character that should be transmitted immediately.
    //
    // Note that we can't use this to determine whether there is
    // a character to send because the character to send could be
    // zero.
    //
    UCHAR ImmediateChar;

    //
    // This holds the mask that will be used to mask off unwanted
    // data bits of the received data (valid data bits can be 5,6,7,8)
    // The mask will normally be 0xff.  This is set while the control
    // lock is held since it wouldn't have adverse effects on the
    // isr if it is changed in the middle of reading characters.
    // (What it would do to the app is another question - but then
    // the app asked the driver to do it.)
    //
    UCHAR ValidDataMask;

    //
    // The application can turn on a mode,via the
    // IOCTL_SERIAL_LSRMST_INSERT ioctl, that will cause the
    // serial driver to insert the line status or the modem
    // status into the RX stream.  The parameter with the ioctl
    // is a pointer to a UCHAR.  If the value of the UCHAR is
    // zero, then no insertion will ever take place.  If the
    // value of the UCHAR is non-zero (and not equal to the
    // xon/xoff characters), then the serial driver will insert.
    //
    UCHAR EscapeChar;

    //
    // These two booleans are used to indicate to the isr transmit
    // code that it should send the xon or xoff character.  They are
    // only accessed at open and at interrupt level.
    //
    BOOLEAN SendXonChar;
    BOOLEAN SendXoffChar;

    //
    // This boolean will be true if a 16550 is present *and* enabled.
    //
    BOOLEAN FifoPresent;

    //
    // This denotes that this particular port is an on the motherboard
    // port for the Jensen hardware.  On these ports the OUT2 bit
    // which is used to enable/disable interrupts is always hight.
    //
    BOOLEAN Jensen;

    //
    // This is the water mark that the rxfifo should be
    // set to when the fifo is turned on.  This is not the actual
    // value, but the encoded value that goes into the register.
    //
    UCHAR RxFifoTrigger;

    //
    // Says whether this device can share interrupts with devices
    // other than serial devices.
    //
    BOOLEAN InterruptShareable;

    //
    // Records whether we actually created the symbolic link name
    // at driver load time.  If we didn't create it, we won't try
    // to destroy it when we unload.
    //
    BOOLEAN CreatedSymbolicLink;

    //
    // Records whether we actually created an entry in SERIALCOMM
    // at driver load time.  If we didn't create it, we won't try
    // to destroy it when the device is removed.
    //
    BOOLEAN CreatedSerialCommEntry;

    //
    // We place all of the kernel and Io subsystem "opaque" structures
    // at the end of the extension.  We don't care about their contents.
    //

    //
    // This lock will be used to protect various fields in
    // the extension that are set (& read) in the extension
    // by the io controls.
    //
    KSPIN_LOCK ControlLock;

    //
    // This lock will be used to protect the accept / reject state
    // transitions and flags of the driver  It must be acquired
    // before a cancel lock
    //
    
    KSPIN_LOCK FlagsLock;

    //
    // This points to a DPC used to complete read requests.
    //
    KDPC CompleteWriteDpc;

    //
    // This points to a DPC used to complete read requests.
    //
    KDPC CompleteReadDpc;

    //
    // This dpc is fired off if the timer for the total timeout
    // for the read expires.  It will execute a dpc routine that
    // will cause the current read to complete.
    //
    //
    KDPC TotalReadTimeoutDpc;

    //
    // This dpc is fired off if the timer for the interval timeout
    // expires.  If no more characters have been read then the
    // dpc routine will cause the read to complete.  However, if
    // more characters have been read then the dpc routine will
    // resubmit the timer.
    //
    KDPC IntervalReadTimeoutDpc;

    //
    // This dpc is fired off if the timer for the total timeout
    // for the write expires.  It will execute a dpc routine that
    // will cause the current write to complete.
    //
    //
    KDPC TotalWriteTimeoutDpc;

    //
    // This dpc is fired off if a comm error occurs.  It will
    // execute a dpc routine that will cancel all pending reads
    // and writes.
    //
    KDPC CommErrorDpc;

    //
    // This dpc is fired off if an event occurs and there was
    // a irp waiting on that event.  A dpc routine will execute
    // that completes the irp.
    //
    KDPC CommWaitDpc;

    //
    // This dpc is fired off when the transmit immediate char
    // character is given to the hardware.  It will simply complete
    // the irp.
    //
    KDPC CompleteImmediateDpc;

    //
    // This dpc is fired off if the transmit immediate char
    // character times out.  The dpc routine will "grab" the
    // irp from the isr and time it out.
    //
    KDPC TotalImmediateTimeoutDpc;

    //
    // This dpc is fired off if the timer used to "timeout" counting
    // the number of characters received after the Xoff ioctl is started
    // expired.
    //
    KDPC XoffCountTimeoutDpc;

    //
    // This dpc is fired off if the xoff counter actually runs down
    // to zero.
    //
    KDPC XoffCountCompleteDpc;

    //
    // This dpc is fired off only from device level to start off
    // a timer that will queue a dpc to check if the RTS line
    // should be lowered when we are doing transmit toggling.
    //
    KDPC StartTimerLowerRTSDpc;

    //
    // This dpc is fired off when a timer expires (after one
    // character time), so that code can be invoked that will
    // check to see if we should lower the RTS line when
    // doing transmit toggling.
    //
    KDPC PerhapsLowerRTSDpc;

    //
    // This DPC is fired to set an event stating that all other
    // DPC's have been finish for this device extension so that
    // paged code may be unlocked.
    //

    KDPC IsrUnlockPagesDpc;

    //
    // This is the kernal timer structure used to handle
    // total read request timing.
    //
    KTIMER ReadRequestTotalTimer;

    //
    // This is the kernal timer structure used to handle
    // interval read request timing.
    //
    KTIMER ReadRequestIntervalTimer;

    //
    // This is the kernal timer structure used to handle
    // total time request timing.
    //
    KTIMER WriteRequestTotalTimer;

    //
    // This is the kernal timer structure used to handle
    // total time request timing.
    //
    KTIMER ImmediateTotalTimer;

    //
    // This timer is used to timeout the xoff counter
    // io.
    //
    KTIMER XoffCountTimer;

    //
    // This timer is used to invoke a dpc one character time
    // after the timer is set.  That dpc will be used to check
    // whether we should lower the RTS line if we are doing
    // transmit toggling.
    //
    KTIMER LowerRTSTimer;

    //
    // This is a pointer to the next lower device in the IRP stack.
    //

    PDEVICE_OBJECT LowerDeviceObject;

    //
    // This is where keep track of the power state the device is in.
    //

    DEVICE_POWER_STATE PowerState;

    //
    // Pointer to the driver object
    //

    PDRIVER_OBJECT DriverObject;


    //
    // Event used to do some synchronization with the devices underneath me
    // (namely ACPI)
    //

    KEVENT SerialSyncEvent;


    //
    // String where we keep the symbolic link that is returned to us when we
    // register our device under the COMM class with the Plug and Play manager.
    //

    UNICODE_STRING DeviceClassSymbolicName;


    //
    // Serial ISR switch structure
    //

    PSERIAL_CISR_SW CIsrSw;

    //
    // Count of pending IRP's
    //

    ULONG PendingIRPCnt;

    //
    // Accepting requests?
    //

    ULONG DevicePNPAccept;

    //
    // No IRP's pending event
    //

    KEVENT PendingIRPEvent;

    //
    // PNP State
    //

    ULONG PNPState;

    //
    // Misc Flags
    //

    ULONG Flags;

    //
    // Open count
    //

    LONG OpenCount;

    //
    // Start sync event
    //

    KEVENT SerialStartEvent;

    //
    // Current state during powerdown
    //

    SERIAL_DEVICE_STATE DeviceState;

    //
    // Device stack capabilites
    //

    DEVICE_POWER_STATE DeviceStateMap[PowerSystemMaximum];

    //
    // Event to signal transition to D0 completion
    //

    KEVENT PowerD0Event;

    //
    // List of stalled IRP's
    //

    LIST_ENTRY StalledIrpQueue;

    //
    // Mutex on open status
    //

    FAST_MUTEX OpenMutex;

    //
    // Mutex on close
    //

    FAST_MUTEX CloseMutex;

    //
    // TRUE if we own power policy
    //

    BOOLEAN OwnsPowerPolicy;

    //
    // SystemWake from devcaps
    //

    SYSTEM_POWER_STATE SystemWake;

    //
    // DeviceWake from devcaps
    //

    DEVICE_POWER_STATE DeviceWake;

    //
    // Our PDO
    //

    PDEVICE_OBJECT Pdo;

    //
    // Should we enable wakeup
    //

    BOOLEAN SendWaitWake;

    //
    // Pending wait wake IRP
    //

    PIRP PendingWakeIrp;

    //
    // WMI Information
    //

    WMILIB_CONTEXT WmiLibInfo;

    //
    // Name to use as WMI identifier
    //

    UNICODE_STRING WmiIdentifier;

    //
    // WMI Comm Data
    //

    SERIAL_WMI_COMM_DATA WmiCommData;

    //
    // WMI HW Data
    //

    SERIAL_WMI_HW_DATA WmiHwData;

    //
    // WMI Performance Data
    //

    SERIAL_WMI_PERF_DATA WmiPerfData;

    //
    // Pending DPC count
    //

    ULONG DpcCount;

    //
    // Pending DPC event
    //

    KEVENT PendingDpcEvent;

    //
    // Should we expose external interfaces?
    //

    ULONG SkipNaming;


#if defined(NEC_98)
    //
    // write data to divisor latch register (for 16550)
    //

    SHORT DivisorLatch16550;

    //
    // write data to modem control register (for 16550)
    //

    UCHAR ModemControl16550;

    //
    // write data to line control register (for 16550)
    //

    UCHAR LineControl16550;

    //
    // out data to mode set register (for 71051)
    //

    UCHAR ModeSet71051;

    //
    // out data to command set register (for 71051)
    //

    UCHAR CommandSet71051;

    //
    // out data to Interrupt enable register for 101
    //    bit0 = Recive Data Available
    //    bit1 = Transmit Holding Register Empty
    //

    UCHAR InterruptEnable16550;

    //
    // Common base address for 101
    //     CH2 = 0x0yB0
    //     CH3 = 0x0yB2
    //

    PUCHAR CommonBaseAddress;

    //
    // CCU Mode set register address for 101
    //     CH2 = 0x0yB3
    //     CH3 = 0x0yBB

    PUCHAR ModeSetRegisterAddress;

    //
    // CCU Command set register address for 101
    //     CH2 = 0x0yB3
    //     CH3 = 0x0yBB

    PUCHAR CommandSetRegisterAddress;

#else
#endif //defined(NEC_98)
    } SERIAL_DEVICE_EXTENSION,*PSERIAL_DEVICE_EXTENSION;

#define SERIAL_PNPACCEPT_OK                 0x0L
#define SERIAL_PNPACCEPT_REMOVING           0x1L
#define SERIAL_PNPACCEPT_STOPPING           0x2L
#define SERIAL_PNPACCEPT_STOPPED            0x4L
#define SERIAL_PNPACCEPT_SURPRISE_REMOVING  0x8L

#define SERIAL_PNP_ADDED                    0x0L
#define SERIAL_PNP_STARTED                  0x1L
#define SERIAL_PNP_QSTOP                    0x2L
#define SERIAL_PNP_STOPPING                 0x3L
#define SERIAL_PNP_QREMOVE                  0x4L
#define SERIAL_PNP_REMOVING                 0x5L
#define SERIAL_PNP_RESTARTING               0x6L

#define SERIAL_FLAGS_CLEAR                  0x0L
#define SERIAL_FLAGS_STARTED                0x1L
#define SERIAL_FLAGS_STOPPED                0x2L
#define SERIAL_FLAGS_BROKENHW               0x4L 






//
// When dealing with a multi-port device (that is possibly
// daisy chained with other multi-port device), the interrupt
// service routine will actually be a routine that determines
// which port on which board is actually causing the interrupt.
//
// The following structure is used so that only one device
// extension will actually need to connect to the interrupt.
// The following structure which is passed to the interrupt
// service routine contains the addresses of all of the
// interrupt status registers (there will be multiple
// status registers when multi-port cards are chained).  It
// will contain the addresses of all the extensions whose
// devices are being serviced by this interrupt.
//

typedef struct _SERIAL_MULTIPORT_DISPATCH {
    PUCHAR InterruptStatus;
    PSERIAL_DEVICE_EXTENSION Extensions[SERIAL_MAX_PORTS_INDEXED];
    ULONG MaskInverted;
    UCHAR UsablePortMask;
    } SERIAL_MULTIPORT_DISPATCH,*PSERIAL_MULTIPORT_DISPATCH;
#if defined(NEC_98)
//
// The value of INDEX for the access of various registers.
// For the PC-9801-101
//
#define INDEX_FOR_DATA_REGISTER              ((ULONG)((0x00)*SERIAL_REGISTER_STRIDE))
#define INDEX_FOR_INTERRUPT_ENABLE_REGISTER  ((ULONG)((0x04)*SERIAL_REGISTER_STRIDE))
#define INDEX_FOR_INTERRUPT_IDENT_REGISTER   ((ULONG)((0x03)*SERIAL_REGISTER_STRIDE))
#define INDEX_FOR_FIFO_CONTROL_REGISTER      ((ULONG)((0x04)*SERIAL_REGISTER_STRIDE))
#define INDEX_FOR_LINE_CONTROL_REGISTER      ((ULONG)((0x06)*SERIAL_REGISTER_STRIDE))
#define INDEX_FOR_LINE_STATUS_REGISTER       ((ULONG)((0x01)*SERIAL_REGISTER_STRIDE))
#define INDEX_FOR_MODEM_STATUS_REGISTER      ((ULONG)((0x02)*SERIAL_REGISTER_STRIDE))
#define INDEX_FOR_VFAST_BAUDCLK_REGISTER     ((ULONG)((0x05)*SERIAL_REGISTER_STRIDE))


//
// The inline process is access for the various registers on the PC-9801-101
//

#define WRITE_IO_DELAY(Counter)                                         \
do                                                                      \
{                                                                       \
    ULONG i;                                                            \
                                                                        \
    for (i = 0; (i <= Counter) && (Counter >= 1); i++) {                \
        WRITE_PORT_UCHAR((PUCHAR)IO_DELAY_REGISTER, IO_DELAY_DATA);     \
    }                                                                   \
} while (0)

_inline
UCHAR
ReadDataRegister(
    IN PUCHAR BaseAddress
    )
{
    WRITE_PORT_UCHAR((BaseAddress)+INDEX_REGISTER_OFFSET,INDEX_FOR_DATA_REGISTER);
    WRITE_IO_DELAY(1);
    return (READ_PORT_UCHAR((BaseAddress)+INDEX_DATA_REGISTER_OFFSET));
}
_inline
VOID
WriteDataRegister(
    IN PUCHAR BaseAddress,
    IN UCHAR  Value
    )
{
    WRITE_PORT_UCHAR((BaseAddress)+INDEX_REGISTER_OFFSET,INDEX_FOR_DATA_REGISTER);
    WRITE_PORT_UCHAR((BaseAddress)+INDEX_DATA_REGISTER_OFFSET, Value);
}

_inline
UCHAR
ReadInterruptEnableRegister(
    IN PUCHAR BaseAddress
    )
{
    WRITE_PORT_UCHAR((BaseAddress)+INDEX_REGISTER_OFFSET,INDEX_FOR_INTERRUPT_ENABLE_REGISTER);
    WRITE_IO_DELAY(1);
    return (READ_PORT_UCHAR((BaseAddress)+INDEX_DATA_REGISTER_OFFSET));
}

_inline
VOID
WriteInterruptEnableRegister(
    IN PUCHAR BaseAddress,
    IN UCHAR  Value
    )
{
    WRITE_PORT_UCHAR((BaseAddress)+INDEX_REGISTER_OFFSET,INDEX_FOR_INTERRUPT_ENABLE_REGISTER);
    WRITE_PORT_UCHAR((BaseAddress)+INDEX_DATA_REGISTER_OFFSET, Value);
}

_inline
UCHAR
ReadInterruptIdentRegister(
    IN PUCHAR BaseAddress
    )
{
    WRITE_PORT_UCHAR((BaseAddress)+INDEX_REGISTER_OFFSET,INDEX_FOR_INTERRUPT_IDENT_REGISTER);
    WRITE_IO_DELAY(1);
    return (READ_PORT_UCHAR((BaseAddress)+INDEX_DATA_REGISTER_OFFSET));
}

_inline
VOID
WriteInterruptIdentRegister(
    IN PUCHAR BaseAddress,
    IN UCHAR  Value
    )
{
    WRITE_PORT_UCHAR((BaseAddress)+INDEX_REGISTER_OFFSET,INDEX_FOR_INTERRUPT_IDENT_REGISTER);
    WRITE_PORT_UCHAR((BaseAddress)+INDEX_DATA_REGISTER_OFFSET, Value);
}

_inline
UCHAR
ReadFifoControlRegister(
    IN PUCHAR BaseAddress
    )
{
    WRITE_PORT_UCHAR((BaseAddress)+INDEX_REGISTER_OFFSET,INDEX_FOR_FIFO_CONTROL_REGISTER);
    WRITE_IO_DELAY(1);
    return (READ_PORT_UCHAR((BaseAddress)+INDEX_DATA_REGISTER_OFFSET));
}

_inline
VOID
WriteFifoControlRegister(
    IN PUCHAR BaseAddress,
    IN UCHAR  Value
    )
{
    WRITE_PORT_UCHAR((BaseAddress)+INDEX_REGISTER_OFFSET,INDEX_FOR_FIFO_CONTROL_REGISTER);
    WRITE_PORT_UCHAR((BaseAddress)+INDEX_DATA_REGISTER_OFFSET, Value);
}

_inline
UCHAR
ReadLineControlRegister(
    IN PUCHAR BaseAddress
    )
{
    WRITE_PORT_UCHAR((BaseAddress)+INDEX_REGISTER_OFFSET,INDEX_FOR_LINE_CONTROL_REGISTER);
    WRITE_IO_DELAY(1);
    return (READ_PORT_UCHAR((BaseAddress)+INDEX_DATA_REGISTER_OFFSET));
}

_inline
VOID
WriteLineControlRegister(
    IN PUCHAR BaseAddress,
    IN UCHAR  Value
    )
{
    WRITE_PORT_UCHAR((BaseAddress)+INDEX_REGISTER_OFFSET,INDEX_FOR_LINE_CONTROL_REGISTER);
    WRITE_PORT_UCHAR((BaseAddress)+INDEX_DATA_REGISTER_OFFSET, Value);
}

_inline
UCHAR
ReadLineStatusRegister(
    IN PUCHAR BaseAddress
    )
{
    WRITE_PORT_UCHAR((BaseAddress)+INDEX_REGISTER_OFFSET,INDEX_FOR_LINE_STATUS_REGISTER);
    WRITE_IO_DELAY(1);
    return (READ_PORT_UCHAR((BaseAddress)+INDEX_DATA_REGISTER_OFFSET));
}

_inline
UCHAR
ReadModemStatusRegister(
    IN PUCHAR BaseAddress
    )
{
    WRITE_PORT_UCHAR((BaseAddress)+INDEX_REGISTER_OFFSET,INDEX_FOR_MODEM_STATUS_REGISTER);
    WRITE_IO_DELAY(1);
    return (READ_PORT_UCHAR((BaseAddress)+INDEX_DATA_REGISTER_OFFSET));
}

_inline
UCHAR
ReadVFASTBaudclkRegister(
    IN PUCHAR BaseAddress
    )
{
    WRITE_PORT_UCHAR((BaseAddress)+INDEX_REGISTER_OFFSET,INDEX_FOR_VFAST_BAUDCLK_REGISTER);
    WRITE_IO_DELAY(1);
    return (READ_PORT_UCHAR((BaseAddress)+INDEX_DATA_REGISTER_OFFSET));
}

_inline
VOID
WriteVFASTBaudclkRegister(
    IN PUCHAR BaseAddress,
    IN UCHAR  Value
    )
{
    WRITE_PORT_UCHAR((BaseAddress)+INDEX_REGISTER_OFFSET,INDEX_FOR_VFAST_BAUDCLK_REGISTER);
    WRITE_PORT_UCHAR((BaseAddress)+INDEX_DATA_REGISTER_OFFSET, Value);
}


_inline
UCHAR
SerialGetInterruptEnable(
    IN PUCHAR BaseAddress,
    IN PSERIAL_DEVICE_EXTENSION Extension
    )
{
    UCHAR InterruptEnable = 0;
    UCHAR FifoControl;

    FifoControl = ReadInterruptEnableRegister(BaseAddress);

    //
    // D3: Modem Status                    D4:INTERRUPT_ENABLE_REG
    // D2: Receiver Line Status            D3:INTERRUPT_ENABLE_REG
    // D1: Transmit Holding Register Empty D1:
    // D0: Received Data Available         D0:
    //

    InterruptEnable |= (FifoControl & (MODEM_STATUS_INTERRUPT | LINE_STATUS_INTERRUPT)) >> 1;
    InterruptEnable |= (Extension->InterruptEnable16550);

    return(InterruptEnable);
}



_inline
UCHAR
SerialGetLineStatus(
    IN PUCHAR BaseAddress
    )
{
    UCHAR LineStatus = 0;
    UCHAR FifoStatus;

    FifoStatus = ReadLineStatusRegister(BaseAddress);

    //
    // D7: Error in Receive FIFO              D7:LINE_STATUS_REG
    // D6: Transmitter shift Register empty   D0:LINE_STATUS_REG
    // D5: Transmitter holding Register empty D1:LINE_STATUS_REG
    // D4: Break interrupt                    D6:LINE_STATUS_REG
    // D3: Framing error                      D5:LINE_STATUS_REG
    // D2: Parity error                       D3:LINE_STATUS_REG
    // D1: Overrun error                      D4:LINE_STATUS_REG
    // D0: Receive Data Ready                 D2:LINE_STATUS_REG
    //

    LineStatus |= (FifoStatus & 0x80);       // Error in Receive FIFO
    LineStatus |= (FifoStatus & 0x01) << 6;  // Transmitter shift Register empty
    LineStatus |= (FifoStatus & 0x02) << 4;  // Transmitter holding Register empty
    LineStatus |= (FifoStatus & 0x40) >> 2;  // Break interrupt
    LineStatus |= (FifoStatus & 0x20) >> 2;  // Framing error
    LineStatus |= (FifoStatus & 0x08) >> 1;  // Parity error
    LineStatus |= (FifoStatus & 0x10) >> 3;  // Overrun error
    LineStatus |= (FifoStatus & 0x04) >> 2;  // Receive Data Ready

    return(LineStatus);
}



/* #define WRITE_PORT_UCHAR(BaseAddress, Value)    */  \
/* do                                              */  \
/* {                                               */  \
/*     WRITE_PORT_UCHAR(BaseAddress, Value);       */  \
/*     WRITE_PORT_UCHAR(                           */  \
/*         (PUCHAR)IO_DELAY_REGISTER,              */  \
/*         IO_DELAY_DATA                           */  \
/*         );                                      */  \
/* } while (0) */


#define READ_DIVISOR_LATCH(BaseAddress,PDesiredDivisor)           \
do                                                                \
{                                                                 \
    *PDesiredDivisor = Extension->DivisorLatch16550;              \
} while (0)

#define READ_INTERRUPT_ENABLE(BaseAddress)                                   \
    (SerialGetInterruptEnable(BaseAddress,Extension))

#define WRITE_INTERRUPT_ENABLE(BaseAddress,Values)                           \
do                                                                           \
{                                                                            \
    UCHAR FifoControl = 0;                                                   \
    UCHAR FifoInterruptControl = 0;                                          \
    UCHAR OutValues = 0;                                                     \
    FifoControl = ReadInterruptEnableRegister(BaseAddress);                  \
    if (Values & SERIAL_IER_MS) {                                            \
        FifoControl |= MODEM_STATUS_INTERRUPT;                               \
    } else {                                                                 \
        FifoControl &= ~MODEM_STATUS_INTERRUPT;                              \
    }                                                                        \
    if (Values & SERIAL_IER_RLS) {                                           \
        FifoControl |= LINE_STATUS_INTERRUPT;                                \
    } else {                                                                 \
        FifoControl &= ~LINE_STATUS_INTERRUPT;                               \
    }                                                                        \
    WriteInterruptEnableRegister(BaseAddress, FifoControl);                  \
    FifoInterruptControl = (Values & (SERIAL_IER_THR | SERIAL_IER_RDA));     \
    OutValues = (Values & (SERIAL_IER_THR | SERIAL_IER_RDA));                \
    if (OutValues & SERIAL_IER_THR) {                                        \
        OutValues |= 0x04;                                                   \
    } else {                                                                 \
        OutValues &= ~0x04;                                                  \
    }                                                                        \
    WRITE_PORT_UCHAR(BaseAddress, OutValues);                                \
    Extension->InterruptEnable16550 = FifoInterruptControl;                  \
} while (0)


#define DISABLE_ALL_INTERRUPTS(BaseAddress)       \
do                                                \
{                                                 \
    WRITE_INTERRUPT_ENABLE(BaseAddress,0);        \
} while (0)

#define ENABLE_ALL_INTERRUPTS(BaseAddress)        \
do                                                \
{                                                 \
                                                  \
    WRITE_INTERRUPT_ENABLE(                       \
        (BaseAddress),                            \
        (UCHAR)(SERIAL_IER_RDA | SERIAL_IER_THR | \
                SERIAL_IER_RLS | SERIAL_IER_MS)   \
        );                                        \
                                                  \
} while (0)


#define READ_INTERRUPT_ID_REG(BaseAddress)                                                            \
    (((ReadInterruptIdentRegister(BaseAddress)) & 0x0f) | SERIAL_IIR_FIFOS_ENABLED)

#define READ_MODEM_CONTROL(BaseAddress)                          \
    (Extension->ModemControl16550)

#define READ_MODEM_STATUS(BaseAddress)                          \
    (ReadModemStatusRegister(BaseAddress))

#define READ_RECEIVE_BUFFER(BaseAddress)                        \
    (ReadDataRegister(BaseAddress))

#define READ_LINE_STATUS(BaseAddress)                           \
    (SerialGetLineStatus(BaseAddress))

#define READ_LINE_CONTROL(BaseAddress)                         \
    (Extension->LineControl16550)

#define WRITE_TRANSMIT_HOLDING(BaseAddress,TransmitChar)       \
do                                                             \
{                                                              \
    WriteDataRegister(                                         \
        BaseAddress,                                           \
        (TransmitChar)                                         \
        );                                                     \
} while (0)


#define WRITE_TRANSMIT_FIFO_HOLDING(BaseAddress,TransmitChars,TxN)  \
do                                                                  \
{                                                                   \
    PUCHAR TransmitBuffer = TransmitChars;                          \
    ULONG i;                                                        \
    for (i = 0; i < TxN; i++, TransmitBuffer++) {                   \
        WriteDataRegister(                                          \
             BaseAddress,                                           \
             (UCHAR)(*TransmitBuffer)                               \
        );                                                          \
    }                                                               \
} while (0)



#define ENTER_LEGACY_MODE(BaseAddress, InterruptEnable, FifoControl)     \
do                                                                       \
{                                                                        \
    *InterruptEnable = READ_INTERRUPT_ENABLE(BaseAddress);               \
    DISABLE_ALL_INTERRUPTS(BaseAddress);                                 \
    *FifoControl = ReadFifoControlRegister(BaseAddress);                 \
    WriteFifoControlRegister(BaseAddress, DISABLE_FIFO_MODE);            \
    WRITE_IO_DELAY(3);                                                   \
} while (0)

#define EXIT_LEGACY_MODE(BaseAddress, InterruptEnable, FifoControl)    \
do                                                       \
{                                                        \
    WriteFifoControlRegister(                            \
        (BaseAddress),                                   \
        (UCHAR)(*FifoControl)                            \
        );                                               \
    WRITE_INTERRUPT_ENABLE(                              \
        (BaseAddress),                                   \
        (UCHAR)(*InterruptEnable),                       \
        );                                               \
} while (0)

#define RESET_71051(ModeSet)                                                              \
do                                                                                        \
{                                                                                         \
    WRITE_PORT_UCHAR((PUCHAR)Extension->CommandSetRegisterAddress, (UCHAR)0);             \
    WRITE_IO_DELAY(1);                                                                    \
    WRITE_PORT_UCHAR((PUCHAR)Extension->CommandSetRegisterAddress, (UCHAR)0);             \
    WRITE_IO_DELAY(1);                                                                    \
    WRITE_PORT_UCHAR((PUCHAR)Extension->CommandSetRegisterAddress, (UCHAR)0);             \
    WRITE_IO_DELAY(1);                                                                    \
    WRITE_PORT_UCHAR((PUCHAR)Extension->CommandSetRegisterAddress, COMMAND_ERROR_RESET);  \
    WRITE_IO_DELAY(2);                                                                    \
    WRITE_PORT_UCHAR(                                                                     \
        (PUCHAR)Extension->ModeSetRegisterAddress,                                        \
        (ModeSet)                                                                         \
        );                                                                                \
    WRITE_IO_DELAY(1);                                                                    \
    WRITE_PORT_UCHAR(                                                                     \
        (PUCHAR)Extension->CommandSetRegisterAddress,                                     \
        (UCHAR)Extension->CommandSet71051                                                 \
        );                                                                                \
    WRITE_IO_DELAY(1);                                                                    \
} while (0)



#define WRITE_DIVISOR_LATCH(BaseAddress,DesiredDivisor)               \
do                                                                    \
{                                                                     \
    SHORT Divisor = DesiredDivisor;                                   \
    ULONG denominator;                                                \
    LONG DesiredBaud;                                                 \
    Extension->DivisorLatch16550 = Divisor;                           \
    denominator = 1843200 / Divisor;                                  \
    DesiredBaud = denominator / (ULONG)16;                            \
        /* RS syncronize clock TXC prohibit */                        \
        /* 98 mode -> V.Fast mode, and Baud rate set */               \
    switch (DesiredBaud) {                                            \
        case   0075: Divisor = VFAST_BAUD_0075;                       \
                     break;                                           \
        case   0150: Divisor = VFAST_BAUD_0150;                       \
                     break;                                           \
        case   0300: Divisor = VFAST_BAUD_0300;                       \
                     break;                                           \
        case   0600: Divisor = VFAST_BAUD_0600;                       \
                     break;                                           \
        case   1200: Divisor = VFAST_BAUD_1200;                       \
                     break;                                           \
        case   2400: Divisor = VFAST_BAUD_2400;                       \
                     break;                                           \
        case   4800: Divisor = VFAST_BAUD_4800;                       \
                     break;                                           \
        case   9600: Divisor = VFAST_BAUD_9600;                       \
                     break;                                           \
        case  14400: Divisor = VFAST_BAUD_14400;                      \
                     break;                                           \
        case  19200: Divisor = VFAST_BAUD_19200;                      \
                     break;                                           \
        case  38400: Divisor = VFAST_BAUD_38400;                      \
                     break;                                           \
        case  57600: Divisor = VFAST_BAUD_57600;                      \
                     break;                                           \
        case 115200: Divisor = VFAST_BAUD_115200;                     \
    }                                                                 \
    WriteVFASTBaudclkRegister(BaseAddress,                            \
        (UCHAR)(Divisor | COMMUNICATION_MODE)                         \
        );                                                            \
} while (0)




#define WRITE_LINE_CONTROL(BaseAddress,NewLineControl)                    \
do                                                                        \
{                                                                         \
    UCHAR InterruptControl = 0;                                           \
    UCHAR FifoControl = 0;                                                \
    UCHAR OutLineControl = BAUDRATE_DEFAULT_MODE;                         \
    ENTER_LEGACY_MODE(BaseAddress, &InterruptControl, &FifoControl);      \
    /* character length */                                                \
    OutLineControl |= (NewLineControl & SERIAL_DATA_MASK) << 2;           \
    /* parity enable and parity mode */                                   \
    OutLineControl |= (NewLineControl & SER71051_PARITY_MASK) << 1;       \
    /* stop bit */                                                        \
    if (NewLineControl & SERIAL_STOP_MASK) {                              \
        if (NewLineControl & SERIAL_DATA_MASK) {                          \
            OutLineControl |= SER71051_1_5_STOP;                          \
        } else {                                                          \
            OutLineControl |= SER71051_2_STOP;                            \
        }                                                                 \
    } else {                                                              \
        OutLineControl |= SER71051_1_STOP;                                \
    }                                                                     \
    Extension->ModeSet71051 = OutLineControl;                             \
    RESET_71051(OutLineControl);                                          \
    /* break character */                                                 \
    if (NewLineControl & SERIAL_LCR_BREAK) {                              \
        if (!(Extension->LineControl16550 & SERIAL_LCR_BREAK)) {          \
            Extension->CommandSet71051 |= SER71051_SEND_BREAK;            \
            WRITE_PORT_UCHAR(                                             \
                (PUCHAR)Extension->CommandSetRegisterAddress,             \
                (UCHAR)Extension->CommandSet71051                         \
                );                                                        \
        }                                                                 \
    } else {                                                              \
        if (Extension->LineControl16550 & SERIAL_LCR_BREAK) {             \
            Extension->CommandSet71051 &= ~SER71051_SEND_BREAK;           \
            WRITE_PORT_UCHAR(                                             \
                (PUCHAR)Extension->CommandSetRegisterAddress,             \
                (UCHAR)Extension->CommandSet71051                         \
                );                                                        \
        }                                                                 \
    }                                                                     \
    Extension->LineControl16550 = NewLineControl;                         \
    EXIT_LEGACY_MODE(BaseAddress, &InterruptControl, &FifoControl);       \
} while (0)

#define WRITE_FIFO_CONTROL(BaseAddress,ControlValue)                      \
do                                                                        \
{                                                                         \
    UCHAR InterruptControl = 0;                                           \
    UCHAR FifoControl = 0;                                                \
    UCHAR OutValue = ControlValue;                                        \
    ENTER_LEGACY_MODE(BaseAddress, &InterruptControl, &FifoControl);      \
    OutValue &= ~(MODEM_STATUS_INTERRUPT | LINE_STATUS_INTERRUPT);        \
    WriteFifoControlRegister(                                             \
        (BaseAddress),                                                    \
        (OutValue)                                                        \
        );                                                                \
    FifoControl = ReadFifoControlRegister(BaseAddress);                   \
    /* always Fifo mode on PC98 */                                        \
    FifoControl |= SERIAL_FCR_ENABLE;                                     \
    EXIT_LEGACY_MODE(BaseAddress, &InterruptControl, &FifoControl);       \
} while (0)

#define WRITE_MODEM_CONTROL(BaseAddress,ModemControl)                    \
do                                                                       \
{                                                                        \
    UCHAR InterruptControl = 0;                                          \
    UCHAR FifoControl = 0;                                               \
    /* command default:ER, RXE, TxE -> ON */                             \
    UCHAR CommandSet = COMMAND_DEFAULT_SET;                              \
    Extension->ModemControl16550 = ModemControl;                         \
    ENTER_LEGACY_MODE(BaseAddress, &InterruptControl, &FifoControl);     \
    CommandSet |= (ModemControl & SERIAL_MCR_DTR) << 1;                  \
    CommandSet |= (ModemControl & SERIAL_MCR_RTS) << 4;                  \
    Extension->CommandSet71051 = CommandSet;                             \
    WRITE_PORT_UCHAR(                                                    \
        (PUCHAR)Extension->CommandSetRegisterAddress,                    \
        (CommandSet)                                                     \
        );                                                               \
    EXIT_LEGACY_MODE(BaseAddress, &InterruptControl, &FifoControl);      \
} while (0)
#else


//
// Sets the divisor latch register.  The divisor latch register
// is used to control the baud rate of the 8250.
//
// As with all of these routines it is assumed that it is called
// at a safe point to access the hardware registers.  In addition
// it also assumes that the data is correct.
//
// Arguments:
//
// BaseAddress - A pointer to the address from which the hardware
//               device registers are located.
//
// DesiredDivisor - The value to which the divisor latch register should
//                  be set.
//
#define WRITE_DIVISOR_LATCH(BaseAddress,DesiredDivisor)           \
do                                                                \
{                                                                 \
    PUCHAR Address = BaseAddress;                                 \
    SHORT Divisor = DesiredDivisor;                               \
    UCHAR LineControl;                                            \
    LineControl = READ_PORT_UCHAR(Address+LINE_CONTROL_REGISTER); \
    WRITE_PORT_UCHAR(                                             \
        Address+LINE_CONTROL_REGISTER,                            \
        (UCHAR)(LineControl | SERIAL_LCR_DLAB)                    \
        );                                                        \
    WRITE_PORT_UCHAR(                                             \
        Address+DIVISOR_LATCH_LSB,                                \
        (UCHAR)(Divisor & 0xff)                                   \
        );                                                        \
    WRITE_PORT_UCHAR(                                             \
        Address+DIVISOR_LATCH_MSB,                                \
        (UCHAR)((Divisor & 0xff00) >> 8)                          \
        );                                                        \
    WRITE_PORT_UCHAR(                                             \
        Address+LINE_CONTROL_REGISTER,                            \
        LineControl                                               \
        );                                                        \
} while (0)

//
// Reads the divisor latch register.  The divisor latch register
// is used to control the baud rate of the 8250.
//
// As with all of these routines it is assumed that it is called
// at a safe point to access the hardware registers.  In addition
// it also assumes that the data is correct.
//
// Arguments:
//
// BaseAddress - A pointer to the address from which the hardware
//               device registers are located.
//
// DesiredDivisor - A pointer to the 2 byte word which will contain
//                  the value of the divisor.
//
#define READ_DIVISOR_LATCH(BaseAddress,PDesiredDivisor)           \
do                                                                \
{                                                                 \
    PUCHAR Address = BaseAddress;                                 \
    PSHORT PDivisor = PDesiredDivisor;                            \
    UCHAR LineControl;                                            \
    UCHAR Lsb;                                                    \
    UCHAR Msb;                                                    \
    LineControl = READ_PORT_UCHAR(Address+LINE_CONTROL_REGISTER); \
    WRITE_PORT_UCHAR(                                             \
        Address+LINE_CONTROL_REGISTER,                            \
        (UCHAR)(LineControl | SERIAL_LCR_DLAB)                    \
        );                                                        \
    Lsb = READ_PORT_UCHAR(Address+DIVISOR_LATCH_LSB);             \
    Msb = READ_PORT_UCHAR(Address+DIVISOR_LATCH_MSB);             \
    *PDivisor = Lsb;                                              \
    *PDivisor = *PDivisor | (((USHORT)Msb) << 8);                 \
    WRITE_PORT_UCHAR(                                             \
        Address+LINE_CONTROL_REGISTER,                            \
        LineControl                                               \
        );                                                        \
} while (0)

//
// This macro reads the interrupt enable register.
//
// Arguments:
//
// BaseAddress - A pointer to the address from which the hardware
//               device registers are located.
//
#define READ_INTERRUPT_ENABLE(BaseAddress)                     \
    (READ_PORT_UCHAR((BaseAddress)+INTERRUPT_ENABLE_REGISTER))

//
// This macro writes the interrupt enable register.
//
// Arguments:
//
// BaseAddress - A pointer to the address from which the hardware
//               device registers are located.
//
// Values - The values to write to the interrupt enable register.
//
#define WRITE_INTERRUPT_ENABLE(BaseAddress,Values)                \
do                                                                \
{                                                                 \
    WRITE_PORT_UCHAR(                                             \
        BaseAddress+INTERRUPT_ENABLE_REGISTER,                    \
        Values                                                    \
        );                                                        \
} while (0)

//
// This macro disables all interrupts on the hardware.
//
// Arguments:
//
// BaseAddress - A pointer to the address from which the hardware
//               device registers are located.
//
//
#define DISABLE_ALL_INTERRUPTS(BaseAddress)       \
do                                                \
{                                                 \
    WRITE_INTERRUPT_ENABLE(BaseAddress,0);        \
} while (0)

//
// This macro enables all interrupts on the hardware.
//
// Arguments:
//
// BaseAddress - A pointer to the address from which the hardware
//               device registers are located.
//
//
#define ENABLE_ALL_INTERRUPTS(BaseAddress)        \
do                                                \
{                                                 \
                                                  \
    WRITE_INTERRUPT_ENABLE(                       \
        (BaseAddress),                            \
        (UCHAR)(SERIAL_IER_RDA | SERIAL_IER_THR | \
                SERIAL_IER_RLS | SERIAL_IER_MS)   \
        );                                        \
                                                  \
} while (0)

//
// This macro reads the interrupt identification register
//
// Arguments:
//
// BaseAddress - A pointer to the address from which the hardware
//               device registers are located.
//
// Note that this routine potententially quites a transmitter
// empty interrupt.  This is because one way that the transmitter
// empty interrupt is cleared is to simply read the interrupt id
// register.
//
//
#define READ_INTERRUPT_ID_REG(BaseAddress)                          \
    (READ_PORT_UCHAR((BaseAddress)+INTERRUPT_IDENT_REGISTER))

//
// This macro reads the modem control register
//
// Arguments:
//
// BaseAddress - A pointer to the address from which the hardware
//               device registers are located.
//
//
#define READ_MODEM_CONTROL(BaseAddress)                          \
    (READ_PORT_UCHAR((BaseAddress)+MODEM_CONTROL_REGISTER))

//
// This macro reads the modem status register
//
// Arguments:
//
// BaseAddress - A pointer to the address from which the hardware
//               device registers are located.
//
//
#define READ_MODEM_STATUS(BaseAddress)                          \
    (READ_PORT_UCHAR((BaseAddress)+MODEM_STATUS_REGISTER))

//
// This macro reads a value out of the receive buffer
//
// Arguments:
//
// BaseAddress - A pointer to the address from which the hardware
//               device registers are located.
//
//
#define READ_RECEIVE_BUFFER(BaseAddress)                          \
    (READ_PORT_UCHAR((BaseAddress)+RECEIVE_BUFFER_REGISTER))

//
// This macro reads the line status register
//
// Arguments:
//
// BaseAddress - A pointer to the address from which the hardware
//               device registers are located.
//
//
#define READ_LINE_STATUS(BaseAddress)                          \
    (READ_PORT_UCHAR((BaseAddress)+LINE_STATUS_REGISTER))

//
// This macro writes the line control register
//
// Arguments:
//
// BaseAddress - A pointer to the address from which the hardware
//               device registers are located.
//
//
#define WRITE_LINE_CONTROL(BaseAddress,NewLineControl)           \
do                                                               \
{                                                                \
    WRITE_PORT_UCHAR(                                            \
        (BaseAddress)+LINE_CONTROL_REGISTER,                     \
        (NewLineControl)                                         \
        );                                                       \
} while (0)

//
// This macro reads the line control register
//
// Arguments:
//
// BaseAddress - A pointer to the address from which the hardware
//               device registers are located.
//
//
#define READ_LINE_CONTROL(BaseAddress)           \
    (READ_PORT_UCHAR((BaseAddress)+LINE_CONTROL_REGISTER))


//
// This macro writes to the transmit register
//
// Arguments:
//
// BaseAddress - A pointer to the address from which the hardware
//               device registers are located.
//
// TransmitChar - The character to send down the wire.
//
//
#define WRITE_TRANSMIT_HOLDING(BaseAddress,TransmitChar)       \
do                                                             \
{                                                              \
    WRITE_PORT_UCHAR(                                          \
        (BaseAddress)+TRANSMIT_HOLDING_REGISTER,               \
        (TransmitChar)                                         \
        );                                                     \
} while (0)

//
// This macro writes to the transmit FIFO register
//
// Arguments:
//
// BaseAddress - A pointer to the address from which the hardware
//               device registers are located.
//
// TransmitChars - Pointer to the characters to send down the wire.
//
// TxN - number of charactes to send.
//
//
#define WRITE_TRANSMIT_FIFO_HOLDING(BaseAddress,TransmitChars,TxN)  \
do                                                             \
{                                                              \
    WRITE_PORT_BUFFER_UCHAR(                                   \
        (BaseAddress)+TRANSMIT_HOLDING_REGISTER,               \
        (TransmitChars),                                       \
        (TxN)                                                  \
        );                                                     \
} while (0)

//
// This macro writes to the control register
//
// Arguments:
//
// BaseAddress - A pointer to the address from which the hardware
//               device registers are located.
//
// ControlValue - The value to set the fifo control register too.
//
//
#define WRITE_FIFO_CONTROL(BaseAddress,ControlValue)           \
do                                                             \
{                                                              \
    WRITE_PORT_UCHAR(                                          \
        (BaseAddress)+FIFO_CONTROL_REGISTER,                   \
        (ControlValue)                                         \
        );                                                     \
} while (0)

//
// This macro writes to the modem control register
//
// Arguments:
//
// BaseAddress - A pointer to the address from which the hardware
//               device registers are located.
//
// ModemControl - The control bits to send to the modem control.
//
//
#define WRITE_MODEM_CONTROL(BaseAddress,ModemControl)          \
do                                                             \
{                                                              \
    WRITE_PORT_UCHAR(                                          \
        (BaseAddress)+MODEM_CONTROL_REGISTER,                  \
        (ModemControl)                                         \
        );                                                     \
} while (0)
#endif //defined(NEC_98)

//
// We use this to query into the registry as to whether we
// should break at driver entry.
//

extern SERIAL_FIRMWARE_DATA    driverDefaults;


//
// This is exported from the kernel.  It is used to point
// to the address that the kernel debugger is using.
//

extern PUCHAR *KdComPortInUse;


typedef enum _SERIAL_MEM_COMPARES {
    AddressesAreEqual,
    AddressesOverlap,
    AddressesAreDisjoint
    } SERIAL_MEM_COMPARES,*PSERIAL_MEM_COMPARES;


typedef struct _SERIAL_LIST_DATA {
   PLIST_ENTRY destList;
   PLIST_ENTRY newElement;
} SERIAL_LIST_DATA, *PSERIAL_LIST_DATA;

typedef struct _SERIAL_GLOBALS {
   LIST_ENTRY AllDevObjs;
   PVOID PAGESER_Handle;
   UNICODE_STRING RegistryPath;
#if DBG
   ULONG PAGESER_Count;
#endif // DBG
} SERIAL_GLOBALS, *PSERIAL_GLOBALS;

extern SERIAL_GLOBALS SerialGlobals;

typedef struct _SERIAL_USER_DATA {
   PHYSICAL_ADDRESS UserPort;
   PHYSICAL_ADDRESS UserInterruptStatus;
   ULONG UserVector;
   UNICODE_STRING UserSymbolicLink;
   ULONG UserPortIndex;
   ULONG UserBusNumber;
   ULONG UserInterfaceType;
   ULONG UserClockRate;
   ULONG UserIndexed;
   ULONG UserInterruptMode;
   ULONG UserAddressSpace;
   ULONG UserLevel;
   ULONG DefaultPermitSystemWideShare;
   ULONG DisablePort;
   ULONG RxFIFO;
   ULONG RxFIFODefault;
   ULONG TxFIFO;
   ULONG TxFIFODefault;
   ULONG ForceFIFOEnable;
   ULONG ForceFIFOEnableDefault;
   ULONG PermitShareDefault;
   ULONG LogFIFODefault;
   ULONG MaskInverted;
} SERIAL_USER_DATA, *PSERIAL_USER_DATA;

typedef struct _SERIAL_PTR_CTX {
   ULONG isPointer;
   PHYSICAL_ADDRESS Port;
   ULONG Vector;
} SERIAL_PTR_CTX, *PSERIAL_PTR_CTX;

#define DEVICE_OBJECT_NAME_LENGTH       128
#define SYMBOLIC_NAME_LENGTH            128
#define SERIAL_PNP_ID_STR               L"*PNP0501"
#define SERIAL_PNP_MULTI_ID_STR         L"*PNP0502"
#define SERIAL_DEVICE_MAP               L"SERIALCOMM"

//
// Return values for mouse detection callback
//

#define SERIAL_FOUNDPOINTER_PORT   1
#define SERIAL_FOUNDPOINTER_VECTOR 2

#define SerialCompleteRequest(PDevExt, PIrp, PriBoost) \
   { \
      IoCompleteRequest((PIrp), (PriBoost)); \
      SerialIRPEpilogue((PDevExt)); \
   }

#define SERIAL_WMI_GUID_LIST_SIZE 5

extern WMIGUIDREGINFO SerialWmiGuidList[SERIAL_WMI_GUID_LIST_SIZE];
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\ser101\read.c ===
/*++

Copyright (c) 1991, 1992, 1993 - 1997 Microsoft Corporation

Module Name:

    read.c

Abstract:

    This module contains the code that is very specific to read
    operations in the serial driver

Author:

    Anthony V. Ercolano 26-Sep-1991

Environment:

    Kernel mode

--*/

#include "precomp.h"


VOID
SerialCancelCurrentRead(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp
    );

BOOLEAN
SerialGrabReadFromIsr(
    IN PVOID Context
    );

BOOLEAN
SerialUpdateReadByIsr(
    IN PVOID Context
    );

ULONG
SerialGetCharsFromIntBuffer(
    PSERIAL_DEVICE_EXTENSION Extension
    );

BOOLEAN
SerialUpdateInterruptBuffer(
    IN PVOID Context
    );

BOOLEAN
SerialUpdateAndSwitchToUser(
    IN PVOID Context
    );

NTSTATUS
SerialResizeBuffer(
    IN PSERIAL_DEVICE_EXTENSION Extension
    );

ULONG
SerialMoveToNewIntBuffer(
    PSERIAL_DEVICE_EXTENSION Extension,
    PUCHAR NewBuffer
    );

BOOLEAN
SerialUpdateAndSwitchToNew(
    IN PVOID Context
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGESER,SerialRead)
#pragma alloc_text(PAGESER,SerialStartRead)
#pragma alloc_text(PAGESER,SerialCancelCurrentRead)
#pragma alloc_text(PAGESER,SerialGrabReadFromIsr)
#pragma alloc_text(PAGESER,SerialUpdateReadByIsr)
#pragma alloc_text(PAGESER,SerialGetCharsFromIntBuffer)
#pragma alloc_text(PAGESER,SerialUpdateInterruptBuffer)
#pragma alloc_text(PAGESER,SerialUpdateAndSwitchToUser)
#pragma alloc_text(PAGESER,SerialResizeBuffer)
#pragma alloc_text(PAGESER,SerialMoveToNewIntBuffer)
#pragma alloc_text(PAGESER,SerialUpdateAndSwitchToNew)
#endif


NTSTATUS
SerialRead(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This is the dispatch routine for reading.  It validates the parameters
    for the read request and if all is ok then it places the request
    on the work queue.

Arguments:

    DeviceObject - Pointer to the device object for this device

    Irp - Pointer to the IRP for the current request

Return Value:

    If the io is zero length then it will return STATUS_SUCCESS,
    otherwise this routine will return the status returned by
    the actual start read routine.

--*/

{

    PSERIAL_DEVICE_EXTENSION extension = DeviceObject->DeviceExtension;
    BOOLEAN acceptingIRPs;
    NTSTATUS status;

    SERIAL_LOCKED_PAGED_CODE();

    SerialDump(SERTRACECALLS, ("SERIAL: Entering SerialRead\n"));

    if ((status = SerialIRPPrologue(Irp, extension)) != STATUS_SUCCESS) {
      SerialCompleteRequest(extension, Irp, IO_NO_INCREMENT);
      SerialDump(SERTRACECALLS, ("SERIAL: Leaving SerialRead (1)\n"));
      return status;
    }

    SerialDump(
        SERIRPPATH,
        ("SERIAL: Dispatch entry for: %x\n",Irp)
        );
    if (SerialCompleteIfError(
            DeviceObject,
            Irp
            ) != STATUS_SUCCESS) {


       SerialDump(SERTRACECALLS, ("SERIAL: Leaving SerialRead (2)\n"));

        return STATUS_CANCELLED;

    }

    Irp->IoStatus.Information = 0L;

    //
    // Quick check for a zero length read.  If it is zero length
    // then we are already done!
    //

    if (IoGetCurrentIrpStackLocation(Irp)->Parameters.Read.Length) {

        //
        // Well it looks like we actually have to do some
        // work.  Put the read on the queue so that we can
        // process it when our previous reads are done.
        //


       SerialDump(SERTRACECALLS, ("SERIAL: Leaving SerialRead (3)\n"));
        return SerialStartOrQueue(
                   extension,
                   Irp,
                   &extension->ReadQueue,
                   &extension->CurrentReadIrp,
                   SerialStartRead
                   );

    } else {

        Irp->IoStatus.Status = STATUS_SUCCESS;
        SerialDump(
            SERIRPPATH,
            ("SERIAL: Complete Irp: %x\n",Irp)
            );
        SerialCompleteRequest(extension, Irp, 0);


        SerialDump(SERTRACECALLS, ("SERIAL: Leaving SerialRead (4)\n"));

        return STATUS_SUCCESS;

    }

}

NTSTATUS
SerialStartRead(
    IN PSERIAL_DEVICE_EXTENSION Extension
    )

/*++

Routine Description:

    This routine is used to start off any read.  It initializes
    the Iostatus fields of the irp.  It will set up any timers
    that are used to control the read.  It will attempt to complete
    the read from data already in the interrupt buffer.  If the
    read can be completed quickly it will start off another if
    necessary.

Arguments:

    Extension - Simply a pointer to the serial device extension.

Return Value:

    This routine will return the status of the first read
    irp.  This is useful in that if we have a read that can
    complete right away (AND there had been nothing in the
    queue before it) the read could return SUCCESS and the
    application won't have to do a wait.

--*/

{

    SERIAL_UPDATE_CHAR updateChar;

    PIRP newIrp;
    KIRQL oldIrql;
    KIRQL controlIrql;

    BOOLEAN returnWithWhatsPresent;
    BOOLEAN os2ssreturn;
    BOOLEAN crunchDownToOne;
    BOOLEAN useTotalTimer;
    BOOLEAN useIntervalTimer;

    ULONG multiplierVal;
    ULONG constantVal;

    LARGE_INTEGER totalTime;

    SERIAL_TIMEOUTS timeoutsForIrp;

    BOOLEAN setFirstStatus = FALSE;
    NTSTATUS firstStatus;

    SERIAL_LOCKED_PAGED_CODE();


    SerialDump(SERTRACECALLS, ("SERIAL: SerialStartRead\n"));

    updateChar.Extension = Extension;

    do {

        //
        // Check to see if this is a resize request.  If it is
        // then go to a routine that specializes in that.
        //

        if (IoGetCurrentIrpStackLocation(Extension->CurrentReadIrp)
            ->MajorFunction != IRP_MJ_READ) {

            NTSTATUS localStatus = SerialResizeBuffer(Extension);

            if (!setFirstStatus) {

                firstStatus = localStatus;
                setFirstStatus = TRUE;

            }

        } else {

            Extension->NumberNeededForRead =
                IoGetCurrentIrpStackLocation(Extension->CurrentReadIrp)
                    ->Parameters.Read.Length;

            //
            // Calculate the timeout value needed for the
            // request.  Note that the values stored in the
            // timeout record are in milliseconds.
            //

            useTotalTimer = FALSE;
            returnWithWhatsPresent = FALSE;
            os2ssreturn = FALSE;
            crunchDownToOne = FALSE;
            useIntervalTimer = FALSE;

            //
            //
            // CIMEXCIMEX -- this is a lie
            //
            // Always initialize the timer objects so that the
            // completion code can tell when it attempts to
            // cancel the timers whether the timers had ever
            // been Set.
            //
            // CIMEXCIMEX -- this is the truth
            //
            // What we want to do is just make sure the timers are
            // cancelled to the best of our ability and move on with
            // life.
            //

            SerialCancelTimer(&Extension->ReadRequestTotalTimer, Extension);
            SerialCancelTimer(&Extension->ReadRequestIntervalTimer, Extension);


//            KeInitializeTimer(&Extension->ReadRequestTotalTimer);
//            KeInitializeTimer(&Extension->ReadRequestIntervalTimer);

            //
            // We get the *current* timeout values to use for timing
            // this read.
            //

            KeAcquireSpinLock(
                &Extension->ControlLock,
                &controlIrql
                );

            timeoutsForIrp = Extension->Timeouts;

            KeReleaseSpinLock(
                &Extension->ControlLock,
                controlIrql
                );

            //
            // Calculate the interval timeout for the read.
            //

            if (timeoutsForIrp.ReadIntervalTimeout &&
                (timeoutsForIrp.ReadIntervalTimeout !=
                 MAXULONG)) {

                useIntervalTimer = TRUE;

                Extension->IntervalTime.QuadPart =
                    UInt32x32To64(
                        timeoutsForIrp.ReadIntervalTimeout,
                        10000
                        );


                if (Extension->IntervalTime.QuadPart >=
                    Extension->CutOverAmount.QuadPart) {

                    Extension->IntervalTimeToUse =
                        &Extension->LongIntervalAmount;

                } else {

                    Extension->IntervalTimeToUse =
                        &Extension->ShortIntervalAmount;

                }

            }

            if (timeoutsForIrp.ReadIntervalTimeout == MAXULONG) {

                //
                // We need to do special return quickly stuff here.
                //
                // 1) If both constant and multiplier are
                //    0 then we return immediately with whatever
                //    we've got, even if it was zero.
                //
                // 2) If constant and multiplier are not MAXULONG
                //    then return immediately if any characters
                //    are present, but if nothing is there, then
                //    use the timeouts as specified.
                //
                // 3) If multiplier is MAXULONG then do as in
                //    "2" but return when the first character
                //    arrives.
                //

                if (!timeoutsForIrp.ReadTotalTimeoutConstant &&
                    !timeoutsForIrp.ReadTotalTimeoutMultiplier) {

                    returnWithWhatsPresent = TRUE;

                } else if ((timeoutsForIrp.ReadTotalTimeoutConstant != MAXULONG)
                            &&
                           (timeoutsForIrp.ReadTotalTimeoutMultiplier
                            != MAXULONG)) {

                    useTotalTimer = TRUE;
                    os2ssreturn = TRUE;
                    multiplierVal = timeoutsForIrp.ReadTotalTimeoutMultiplier;
                    constantVal = timeoutsForIrp.ReadTotalTimeoutConstant;

                } else if ((timeoutsForIrp.ReadTotalTimeoutConstant != MAXULONG)
                            &&
                           (timeoutsForIrp.ReadTotalTimeoutMultiplier
                            == MAXULONG)) {

                    useTotalTimer = TRUE;
                    os2ssreturn = TRUE;
                    crunchDownToOne = TRUE;
                    multiplierVal = 0;
                    constantVal = timeoutsForIrp.ReadTotalTimeoutConstant;

                }

            } else {

                //
                // If both the multiplier and the constant are
                // zero then don't do any total timeout processing.
                //

                if (timeoutsForIrp.ReadTotalTimeoutMultiplier ||
                    timeoutsForIrp.ReadTotalTimeoutConstant) {

                    //
                    // We have some timer values to calculate.
                    //

                    useTotalTimer = TRUE;
                    multiplierVal = timeoutsForIrp.ReadTotalTimeoutMultiplier;
                    constantVal = timeoutsForIrp.ReadTotalTimeoutConstant;

                }

            }

            if (useTotalTimer) {

                totalTime.QuadPart = ((LONGLONG)(UInt32x32To64(
                                          Extension->NumberNeededForRead,
                                          multiplierVal
                                          )
                                          + constantVal))
                                      * -10000;

            }


            //
            // We do this copy in the hope of getting most (if not
            // all) of the characters out of the interrupt buffer.
            //
            // Note that we need to protect this operation with a
            // spinlock since we don't want a purge to hose us.
            //

            KeAcquireSpinLock(
                &Extension->ControlLock,
                &controlIrql
                );

            updateChar.CharsCopied = SerialGetCharsFromIntBuffer(Extension);

            //
            // See if we have any cause to return immediately.
            //

            if (returnWithWhatsPresent || (!Extension->NumberNeededForRead) ||
                (os2ssreturn &&
                 Extension->CurrentReadIrp->IoStatus.Information)) {

                //
                // We got all we needed for this read.
                // Update the number of characters in the
                // interrupt read buffer.
                //

                KeSynchronizeExecution(
                    Extension->Interrupt,
                    SerialUpdateInterruptBuffer,
                    &updateChar
                    );

                KeReleaseSpinLock(
                    &Extension->ControlLock,
                    controlIrql
                    );

                Extension->CurrentReadIrp->IoStatus.Status = STATUS_SUCCESS;
                if (!setFirstStatus) {

                    firstStatus = STATUS_SUCCESS;
                    setFirstStatus = TRUE;

                }

            } else {

                //
                // The irp might go under control of the isr.  It
                // won't hurt to initialize the reference count
                // right now.
                //

                SERIAL_INIT_REFERENCE(Extension->CurrentReadIrp);

                IoAcquireCancelSpinLock(&oldIrql);

                //
                // We need to see if this irp should be canceled.
                //

                if (Extension->CurrentReadIrp->Cancel) {

                    IoReleaseCancelSpinLock(oldIrql);
                    KeReleaseSpinLock(
                        &Extension->ControlLock,
                        controlIrql
                        );
                    Extension->CurrentReadIrp->IoStatus.Status =
                        STATUS_CANCELLED;
                    Extension->CurrentReadIrp->IoStatus.Information = 0;

                    if (!setFirstStatus) {

                        firstStatus = STATUS_CANCELLED;
                        setFirstStatus = TRUE;

                    }

                } else {

                    //
                    // If we are supposed to crunch the read down to
                    // one character, then update the read length
                    // in the irp and truncate the number needed for
                    // read down to one. Note that if we are doing
                    // this crunching, then the information must be
                    // zero (or we would have completed above) and
                    // the number needed for the read must still be
                    // equal to the read length.
                    //

                    if (crunchDownToOne) {

                        ASSERT(
                            (!Extension->CurrentReadIrp->IoStatus.Information)
                            &&
                            (Extension->NumberNeededForRead ==
                                IoGetCurrentIrpStackLocation(
                                    Extension->CurrentReadIrp
                                    )->Parameters.Read.Length)
                            );

                        Extension->NumberNeededForRead = 1;
                        IoGetCurrentIrpStackLocation(
                            Extension->CurrentReadIrp
                            )->Parameters.Read.Length = 1;

                    }

                    //
                    // We still need to get more characters for this read.
                    // synchronize with the isr so that we can update the
                    // number of characters and if necessary it will have the
                    // isr switch to copying into the users buffer.
                    //

                    KeSynchronizeExecution(
                        Extension->Interrupt,
                        SerialUpdateAndSwitchToUser,
                        &updateChar
                        );

                    if (!updateChar.Completed) {

                        //
                        // The irp still isn't complete.  The
                        // completion routines will end up reinvoking
                        // this routine.  So we simply leave.
                        //
                        // First thought we should start off the total
                        // timer for the read and increment the reference
                        // count that the total timer has on the current
                        // irp.  Note that this is safe, because even if
                        // the io has been satisfied by the isr it can't
                        // complete yet because we still own the cancel
                        // spinlock.
                        //

                        if (useTotalTimer) {

                            SERIAL_SET_REFERENCE(
                                Extension->CurrentReadIrp,
                                SERIAL_REF_TOTAL_TIMER
                                );

                            SerialSetTimer(
                                &Extension->ReadRequestTotalTimer,
                                totalTime,
                                &Extension->TotalReadTimeoutDpc,
                                Extension
                                );

                        }

                        if (useIntervalTimer) {

                            SERIAL_SET_REFERENCE(
                                Extension->CurrentReadIrp,
                                SERIAL_REF_INT_TIMER
                                );

                            KeQuerySystemTime(
                                &Extension->LastReadTime
                                );
                            SerialSetTimer(
                                &Extension->ReadRequestIntervalTimer,
                                *Extension->IntervalTimeToUse,
                                &Extension->IntervalReadTimeoutDpc,
                                Extension
                                );

                        }

                        IoMarkIrpPending(Extension->CurrentReadIrp);
                        IoReleaseCancelSpinLock(oldIrql);
                        KeReleaseSpinLock(
                            &Extension->ControlLock,
                            controlIrql
                            );
                        if (!setFirstStatus) {

                            firstStatus = STATUS_PENDING;

                        }
                        return firstStatus;

                    } else {

                        IoReleaseCancelSpinLock(oldIrql);
                        KeReleaseSpinLock(
                            &Extension->ControlLock,
                            controlIrql
                            );
                        Extension->CurrentReadIrp->IoStatus.Status =
                            STATUS_SUCCESS;

                        if (!setFirstStatus) {

                            firstStatus = STATUS_SUCCESS;
                            setFirstStatus = TRUE;

                        }

                    }

                }

            }

        }

        //
        // Well the operation is complete.
        //

        SerialGetNextIrp(
            &Extension->CurrentReadIrp,
            &Extension->ReadQueue,
            &newIrp,
            TRUE,
            Extension
            );

    } while (newIrp);

    return firstStatus;

}

VOID
SerialCompleteRead(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemContext1,
    IN PVOID SystemContext2
    )

/*++

Routine Description:

    This routine is merely used to complete any read that
    ended up being used by the Isr.  It assumes that the
    status and the information fields of the irp are already
    correctly filled in.

Arguments:

    Dpc - Not Used.

    DeferredContext - Really points to the device extension.

    SystemContext1 - Not Used.

    SystemContext2 - Not Used.

Return Value:

    None.

--*/

{

    PSERIAL_DEVICE_EXTENSION extension = DeferredContext;
    KIRQL oldIrql;

    UNREFERENCED_PARAMETER(SystemContext1);
    UNREFERENCED_PARAMETER(SystemContext2);


    SerialDump(SERTRACECALLS, ("SERIAL: SerialCompleteRead\n"));


    IoAcquireCancelSpinLock(&oldIrql);

    //
    // We set this to indicate to the interval timer
    // that the read has completed.
    //
    // Recall that the interval timer dpc can be lurking in some
    // DPC queue.
    //

    extension->CountOnLastRead = SERIAL_COMPLETE_READ_COMPLETE;

    SerialTryToCompleteCurrent(
        extension,
        NULL,
        oldIrql,
        STATUS_SUCCESS,
        &extension->CurrentReadIrp,
        &extension->ReadQueue,
        &extension->ReadRequestIntervalTimer,
        &extension->ReadRequestTotalTimer,
        SerialStartRead,
        SerialGetNextIrp,
        SERIAL_REF_ISR
        );

    SerialDpcEpilogue(extension, Dpc);
}

VOID
SerialCancelCurrentRead(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp
    )

/*++

Routine Description:

    This routine is used to cancel the current read.

Arguments:

    DeviceObject - Pointer to the device object for this device

    Irp - Pointer to the IRP to be canceled.

Return Value:

    None.

--*/

{

    PSERIAL_DEVICE_EXTENSION extension = DeviceObject->DeviceExtension;
    SERIAL_LOCKED_PAGED_CODE();

    //
    // We set this to indicate to the interval timer
    // that the read has encountered a cancel.
    //
    // Recall that the interval timer dpc can be lurking in some
    // DPC queue.
    //

    extension->CountOnLastRead = SERIAL_COMPLETE_READ_CANCEL;

    SerialTryToCompleteCurrent(
        extension,
        SerialGrabReadFromIsr,
        Irp->CancelIrql,
        STATUS_CANCELLED,
        &extension->CurrentReadIrp,
        &extension->ReadQueue,
        &extension->ReadRequestIntervalTimer,
        &extension->ReadRequestTotalTimer,
        SerialStartRead,
        SerialGetNextIrp,
        SERIAL_REF_CANCEL
        );

}

BOOLEAN
SerialGrabReadFromIsr(
    IN PVOID Context
    )

/*++

Routine Description:

    This routine is used to grab (if possible) the irp from the
    isr.  If it finds that the isr still owns the irp it grabs
    the ipr away (updating the number of characters copied into the
    users buffer).  If it grabs it away it also decrements the
    reference count on the irp since it no longer belongs to the
    isr (and the dpc that would complete it).

    NOTE: This routine assumes that if the current buffer that the
          ISR is copying characters into is the interrupt buffer then
          the dpc has already been queued.

    NOTE: This routine is being called from KeSynchronizeExecution.

    NOTE: This routine assumes that it is called with the cancel spin
          lock held.

Arguments:

    Context - Really a pointer to the device extension.

Return Value:

    Always false.

--*/

{

    PSERIAL_DEVICE_EXTENSION extension = Context;
    SERIAL_LOCKED_PAGED_CODE();

    if (extension->ReadBufferBase !=
        extension->InterruptReadBuffer) {

        //
        // We need to set the information to the number of characters
        // that the read wanted minus the number of characters that
        // didn't get read into the interrupt buffer.
        //

        extension->CurrentReadIrp->IoStatus.Information =
            IoGetCurrentIrpStackLocation(
                extension->CurrentReadIrp
                )->Parameters.Read.Length -
            ((extension->LastCharSlot - extension->CurrentCharSlot) + 1);

        //
        // Switch back to the interrupt buffer.
        //

        extension->ReadBufferBase = extension->InterruptReadBuffer;
        extension->CurrentCharSlot = extension->InterruptReadBuffer;
        extension->FirstReadableChar = extension->InterruptReadBuffer;
        extension->LastCharSlot = extension->InterruptReadBuffer +
                                      (extension->BufferSize - 1);
        extension->CharsInInterruptBuffer = 0;

        SERIAL_CLEAR_REFERENCE(
            extension->CurrentReadIrp,
            SERIAL_REF_ISR
            );

    }

    return FALSE;

}

VOID
SerialReadTimeout(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemContext1,
    IN PVOID SystemContext2
    )

/*++

Routine Description:

    This routine is used to complete a read because its total
    timer has expired.

Arguments:

    Dpc - Not Used.

    DeferredContext - Really points to the device extension.

    SystemContext1 - Not Used.

    SystemContext2 - Not Used.

Return Value:

    None.

--*/

{

    PSERIAL_DEVICE_EXTENSION extension = DeferredContext;
    KIRQL oldIrql;

    UNREFERENCED_PARAMETER(SystemContext1);
    UNREFERENCED_PARAMETER(SystemContext2);


    SerialDump(SERTRACECALLS, ("SERIAL: SerialReadTimeout\n"));

    IoAcquireCancelSpinLock(&oldIrql);

    //
    // We set this to indicate to the interval timer
    // that the read has completed due to total timeout.
    //
    // Recall that the interval timer dpc can be lurking in some
    // DPC queue.
    //

    extension->CountOnLastRead = SERIAL_COMPLETE_READ_TOTAL;

    SerialTryToCompleteCurrent(
        extension,
        SerialGrabReadFromIsr,
        oldIrql,
        STATUS_TIMEOUT,
        &extension->CurrentReadIrp,
        &extension->ReadQueue,
        &extension->ReadRequestIntervalTimer,
        &extension->ReadRequestTotalTimer,
        SerialStartRead,
        SerialGetNextIrp,
        SERIAL_REF_TOTAL_TIMER
        );

    SerialDpcEpilogue(extension, Dpc);

}

BOOLEAN
SerialUpdateReadByIsr(
    IN PVOID Context
    )

/*++

Routine Description:

    This routine is used to update the count of characters read
    by the isr since the last interval timer experation.

    NOTE: This routine is being called from KeSynchronizeExecution.

    NOTE: This routine assumes that it is called with the cancel spin
          lock held.

Arguments:

    Context - Really a pointer to the device extension.

Return Value:

    Always false.

--*/

{

    PSERIAL_DEVICE_EXTENSION extension = Context;
    SERIAL_LOCKED_PAGED_CODE();

    extension->CountOnLastRead = extension->ReadByIsr;
    extension->ReadByIsr = 0;

    return FALSE;

}

VOID
SerialIntervalReadTimeout(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemContext1,
    IN PVOID SystemContext2
    )

/*++

Routine Description:

    This routine is used timeout the request if the time between
    characters exceed the interval time.  A global is kept in
    the device extension that records the count of characters read
    the last the last time this routine was invoked (This dpc
    will resubmit the timer if the count has changed).  If the
    count has not changed then this routine will attempt to complete
    the irp.  Note the special case of the last count being zero.
    The timer isn't really in effect until the first character is
    read.

Arguments:

    Dpc - Not Used.

    DeferredContext - Really points to the device extension.

    SystemContext1 - Not Used.

    SystemContext2 - Not Used.

Return Value:

    None.

--*/

{

    PSERIAL_DEVICE_EXTENSION extension = DeferredContext;
    KIRQL oldIrql;

    UNREFERENCED_PARAMETER(SystemContext1);
    UNREFERENCED_PARAMETER(SystemContext2);

    IoAcquireCancelSpinLock(&oldIrql);

    SerialDump(SERTRACECALLS, ("SERIAL: SerialIntervalReadTimeout\n"));

    if (extension->CountOnLastRead == SERIAL_COMPLETE_READ_TOTAL) {

        //
        // This value is only set by the total
        // timer to indicate that it has fired.
        // If so, then we should simply try to complete.
        //

        SerialTryToCompleteCurrent(
            extension,
            SerialGrabReadFromIsr,
            oldIrql,
            STATUS_TIMEOUT,
            &extension->CurrentReadIrp,
            &extension->ReadQueue,
            &extension->ReadRequestIntervalTimer,
            &extension->ReadRequestTotalTimer,
            SerialStartRead,
            SerialGetNextIrp,
            SERIAL_REF_INT_TIMER
            );

    } else if (extension->CountOnLastRead == SERIAL_COMPLETE_READ_COMPLETE) {

        //
        // This value is only set by the regular
        // completion routine.
        //
        // If so, then we should simply try to complete.
        //

        SerialTryToCompleteCurrent(
            extension,
            SerialGrabReadFromIsr,
            oldIrql,
            STATUS_SUCCESS,
            &extension->CurrentReadIrp,
            &extension->ReadQueue,
            &extension->ReadRequestIntervalTimer,
            &extension->ReadRequestTotalTimer,
            SerialStartRead,
            SerialGetNextIrp,
            SERIAL_REF_INT_TIMER
            );

    } else if (extension->CountOnLastRead == SERIAL_COMPLETE_READ_CANCEL) {

        //
        // This value is only set by the cancel
        // read routine.
        //
        // If so, then we should simply try to complete.
        //

        SerialTryToCompleteCurrent(
            extension,
            SerialGrabReadFromIsr,
            oldIrql,
            STATUS_CANCELLED,
            &extension->CurrentReadIrp,
            &extension->ReadQueue,
            &extension->ReadRequestIntervalTimer,
            &extension->ReadRequestTotalTimer,
            SerialStartRead,
            SerialGetNextIrp,
            SERIAL_REF_INT_TIMER
            );

    } else if (extension->CountOnLastRead || extension->ReadByIsr) {

        //
        // Something has happened since we last came here.  We
        // check to see if the ISR has read in any more characters.
        // If it did then we should update the isr's read count
        // and resubmit the timer.
        //

        if (extension->ReadByIsr) {

            KeSynchronizeExecution(
                extension->Interrupt,
                SerialUpdateReadByIsr,
                extension
                );

            //
            // Save off the "last" time something was read.
            // As we come back to this routine we will compare
            // the current time to the "last" time.  If the
            // difference is ever larger then the interval
            // requested by the user, then time out the request.
            //

            KeQuerySystemTime(
                &extension->LastReadTime
                );

            SerialSetTimer(
                &extension->ReadRequestIntervalTimer,
                *extension->IntervalTimeToUse,
                &extension->IntervalReadTimeoutDpc,
                extension
                );

            IoReleaseCancelSpinLock(oldIrql);

        } else {

            //
            // Take the difference between the current time
            // and the last time we had characters and
            // see if it is greater then the interval time.
            // if it is, then time out the request.  Otherwise
            // go away again for a while.
            //

            //
            // No characters read in the interval time.  Kill
            // this read.
            //

            LARGE_INTEGER currentTime;

            KeQuerySystemTime(
                &currentTime
                );

            if ((currentTime.QuadPart - extension->LastReadTime.QuadPart) >=
                extension->IntervalTime.QuadPart) {

                SerialTryToCompleteCurrent(
                    extension,
                    SerialGrabReadFromIsr,
                    oldIrql,
                    STATUS_TIMEOUT,
                    &extension->CurrentReadIrp,
                    &extension->ReadQueue,
                    &extension->ReadRequestIntervalTimer,
                    &extension->ReadRequestTotalTimer,
                    SerialStartRead,
                    SerialGetNextIrp,
                    SERIAL_REF_INT_TIMER
                    );

            } else {

                SerialSetTimer(
                    &extension->ReadRequestIntervalTimer,
                    *extension->IntervalTimeToUse,
                    &extension->IntervalReadTimeoutDpc,
                    extension
                    );
                IoReleaseCancelSpinLock(oldIrql);

            }


        }

    } else {

        //
        // Timer doesn't really start until the first character.
        // So we should simply resubmit ourselves.
        //

        SerialSetTimer(
            &extension->ReadRequestIntervalTimer,
            *extension->IntervalTimeToUse,
            &extension->IntervalReadTimeoutDpc,
            extension
            );

        IoReleaseCancelSpinLock(oldIrql);

    }

    SerialDpcEpilogue(extension, Dpc);

}

ULONG
SerialGetCharsFromIntBuffer(
    PSERIAL_DEVICE_EXTENSION Extension
    )

/*++

Routine Description:

    This routine is used to copy any characters out of the interrupt
    buffer into the users buffer.  It will be reading values that
    are updated with the ISR but this is safe since this value is
    only decremented by synchronization routines.  This routine will
    return the number of characters copied so some other routine
    can call a synchronization routine to update what is seen at
    interrupt level.

Arguments:

    Extension - A pointer to the device extension.

Return Value:

    The number of characters that were copied into the user
    buffer.

--*/

{

    //
    // This value will be the number of characters that this
    // routine returns.  It will be the minimum of the number
    // of characters currently in the buffer or the number of
    // characters required for the read.
    //
    ULONG numberOfCharsToGet;

    //
    // This holds the number of characters between the first
    // readable character and - the last character we will read or
    // the real physical end of the buffer (not the last readable
    // character).
    //
    ULONG firstTryNumberToGet;

    SERIAL_LOCKED_PAGED_CODE();


    //
    // The minimum of the number of characters we need and
    // the number of characters available
    //

    numberOfCharsToGet = Extension->CharsInInterruptBuffer;

    if (numberOfCharsToGet > Extension->NumberNeededForRead) {

        numberOfCharsToGet = Extension->NumberNeededForRead;

    }

    if (numberOfCharsToGet) {

        //
        // This will hold the number of characters between the
        // first available character and the end of the buffer.
        // Note that the buffer could wrap around but for the
        // purposes of the first copy we don't care about that.
        //

        firstTryNumberToGet = (ULONG)(Extension->LastCharSlot -
                               Extension->FirstReadableChar) + 1;

        if (firstTryNumberToGet > numberOfCharsToGet) {

            //
            // The characters don't wrap. Actually they may wrap but
            // we don't care for the purposes of this read since the
            // characters we need are available before the wrap.
            //

            RtlMoveMemory(
                ((PUCHAR)(Extension->CurrentReadIrp->AssociatedIrp.SystemBuffer))
                    + (IoGetCurrentIrpStackLocation(
                           Extension->CurrentReadIrp
                           )->Parameters.Read.Length
                       - Extension->NumberNeededForRead
                      ),
                Extension->FirstReadableChar,
                numberOfCharsToGet
                );

            Extension->NumberNeededForRead -= numberOfCharsToGet;

            //
            // We now will move the pointer to the first character after
            // what we just copied into the users buffer.
            //
            // We need to check if the stream of readable characters
            // is wrapping around to the beginning of the buffer.
            //
            // Note that we may have just taken the last characters
            // at the end of the buffer.
            //

            if ((Extension->FirstReadableChar + (numberOfCharsToGet - 1)) ==
                Extension->LastCharSlot) {

                Extension->FirstReadableChar = Extension->InterruptReadBuffer;

            } else {

                Extension->FirstReadableChar += numberOfCharsToGet;

            }

        } else {

            //
            // The characters do wrap.  Get up until the end of the buffer.
            //

            RtlMoveMemory(
                ((PUCHAR)(Extension->CurrentReadIrp->AssociatedIrp.SystemBuffer))
                    + (IoGetCurrentIrpStackLocation(
                           Extension->CurrentReadIrp
                           )->Parameters.Read.Length
                       - Extension->NumberNeededForRead
                      ),
                Extension->FirstReadableChar,
                firstTryNumberToGet
                );

            Extension->NumberNeededForRead -= firstTryNumberToGet;

            //
            // Now get the rest of the characters from the beginning of the
            // buffer.
            //

            RtlMoveMemory(
                ((PUCHAR)(Extension->CurrentReadIrp->AssociatedIrp.SystemBuffer))
                    + (IoGetCurrentIrpStackLocation(
                           Extension->CurrentReadIrp
                           )->Parameters.Read.Length
                       - Extension->NumberNeededForRead
                      ),
                Extension->InterruptReadBuffer,
                numberOfCharsToGet - firstTryNumberToGet
                );

            Extension->FirstReadableChar = Extension->InterruptReadBuffer +
                                           (numberOfCharsToGet -
                                            firstTryNumberToGet);

            Extension->NumberNeededForRead -= (numberOfCharsToGet -
                                               firstTryNumberToGet);

        }

    }

    Extension->CurrentReadIrp->IoStatus.Information += numberOfCharsToGet;
    return numberOfCharsToGet;

}

BOOLEAN
SerialUpdateInterruptBuffer(
    IN PVOID Context
    )

/*++

Routine Description:

    This routine is used to update the number of characters that
    remain in the interrupt buffer.  We need to use this routine
    since the count could be updated during the update by execution
    of the ISR.

    NOTE: This is called by KeSynchronizeExecution.

Arguments:

    Context - Points to a structure that contains a pointer to the
              device extension and count of the number of characters
              that we previously copied into the users buffer.  The
              structure actually has a third field that we don't
              use in this routine.

Return Value:

    Always FALSE.

--*/

{

    PSERIAL_UPDATE_CHAR update = Context;
    PSERIAL_DEVICE_EXTENSION extension = update->Extension;

    SERIAL_LOCKED_PAGED_CODE();

    ASSERT(extension->CharsInInterruptBuffer >= update->CharsCopied);
    extension->CharsInInterruptBuffer -= update->CharsCopied;

    //
    // Deal with flow control if necessary.
    //

    SerialHandleReducedIntBuffer(extension);


    return FALSE;

}

BOOLEAN
SerialUpdateAndSwitchToUser(
    IN PVOID Context
    )

/*++

Routine Description:

    This routine gets the (hopefully) few characters that
    remain in the interrupt buffer after the first time we tried
    to get them out.  If we still don't have enough characters
    to satisfy the read it will then we set things up so that the
    ISR uses the user buffer copy into.

    This routine is also used to update a count that is maintained
    by the ISR to keep track of the number of characters in its buffer.

    NOTE: This is called by KeSynchronizeExecution.

Arguments:

    Context - Points to a structure that contains a pointer to the
              device extension, a count of the number of characters
              that we previously copied into the users buffer, and
              a boolean that we will set that defines whether we
              switched the ISR to copy into the users buffer.

Return Value:

    Always FALSE.

--*/

{

    PSERIAL_UPDATE_CHAR updateChar = Context;
    PSERIAL_DEVICE_EXTENSION extension = updateChar->Extension;

    SERIAL_LOCKED_PAGED_CODE();

    SerialUpdateInterruptBuffer(Context);

    //
    // There are more characters to get to satisfy this read.
    // Copy any characters that have arrived since we got
    // the last batch.
    //

    updateChar->CharsCopied = SerialGetCharsFromIntBuffer(extension);

    SerialUpdateInterruptBuffer(Context);

    //
    // No more new characters will be "received" until we exit
    // this routine.  We again check to make sure that we
    // haven't satisfied this read, and if we haven't we set things
    // up so that the ISR copies into the user buffer.
    //

    if (extension->NumberNeededForRead) {

        //
        // We shouldn't be switching unless there are no
        // characters left.
        //

        ASSERT(!extension->CharsInInterruptBuffer);

        //
        // We use the following to values to do inteval timing.
        //
        // CountOnLastRead is mostly used to simply prevent
        // the interval timer from timing out before any characters
        // are read. (Interval timing should only be effective
        // after the first character is read.)
        //
        // After the first time the interval timer fires and
        // characters have be read we will simply update with
        // the value of ReadByIsr and then set ReadByIsr to zero.
        // (We do that in a synchronization routine.
        //
        // If the interval timer dpc routine ever encounters
        // ReadByIsr == 0 when CountOnLastRead is non-zero it
        // will timeout the read.
        //
        // (Note that we have a special case of CountOnLastRead
        // < 0.  This is done by the read completion routines other
        // than the total timeout dpc to indicate that the total
        // timeout has expired.)
        //

        extension->CountOnLastRead =
            (LONG)extension->CurrentReadIrp->IoStatus.Information;

        extension->ReadByIsr = 0;

        //
        // By compareing the read buffer base address to the
        // the base address of the interrupt buffer the ISR
        // can determine whether we are using the interrupt
        // buffer or the user buffer.
        //

        extension->ReadBufferBase =
            extension->CurrentReadIrp->AssociatedIrp.SystemBuffer;

        //
        // The current char slot is after the last copied in
        // character.  We know there is always room since we
        // we wouldn't have gotten here if there wasn't.
        //

        extension->CurrentCharSlot = extension->ReadBufferBase +
            extension->CurrentReadIrp->IoStatus.Information;

        //
        // The last position that a character can go is on the
        // last byte of user buffer.  While the actual allocated
        // buffer space may be bigger, we know that there is at
        // least as much as the read length.
        //

        extension->LastCharSlot = extension->ReadBufferBase +
                                      (IoGetCurrentIrpStackLocation(
                                          extension->CurrentReadIrp
                                          )->Parameters.Read.Length
                                       - 1);

        //
        // Mark the irp as being in a cancelable state.
        //

        IoSetCancelRoutine(
            extension->CurrentReadIrp,
            SerialCancelCurrentRead
            );

        //
        // Increment the reference count twice.
        //
        // Once for the Isr owning the irp and once
        // because the cancel routine has a reference
        // to it.
        //

        SERIAL_SET_REFERENCE(
            extension->CurrentReadIrp,
            SERIAL_REF_ISR
            );
        SERIAL_SET_REFERENCE(
            extension->CurrentReadIrp,
            SERIAL_REF_CANCEL
            );

        updateChar->Completed = FALSE;

    } else {

        updateChar->Completed = TRUE;

    }

    return FALSE;

}
//
// We use this structure only to communicate to the synchronization
// routine when we are switching to the resized buffer.
//
typedef struct _SERIAL_RESIZE_PARAMS {
    PSERIAL_DEVICE_EXTENSION Extension;
    PUCHAR OldBuffer;
    PUCHAR NewBuffer;
    ULONG NewBufferSize;
    ULONG NumberMoved;
    } SERIAL_RESIZE_PARAMS,*PSERIAL_RESIZE_PARAMS;

NTSTATUS
SerialResizeBuffer(
    IN PSERIAL_DEVICE_EXTENSION Extension
    )

/*++

Routine Description:

    This routine will process the resize buffer request.
    If size requested for the RX buffer is smaller than
    the current buffer then we will simply return
    STATUS_SUCCESS.  (We don't want to make buffers smaller.
    If we did that then we all of a sudden have "overrun"
    problems to deal with as well as flow control to deal
    with - very painful.)  We ignore the TX buffer size
    request since we don't use a TX buffer.

Arguments:

    Extension - Pointer to the device extension for the port.

Return Value:

    STATUS_SUCCESS if everything worked out ok.
    STATUS_INSUFFICIENT_RESOURCES if we couldn't allocate the
    memory for the buffer.

--*/

{

    PSERIAL_QUEUE_SIZE rs = Extension->CurrentReadIrp->AssociatedIrp
                                                       .SystemBuffer;
    PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation(
                                   Extension->CurrentReadIrp
                                   );
    PVOID newBuffer = irpSp->Parameters.DeviceIoControl.Type3InputBuffer;

    SERIAL_LOCKED_PAGED_CODE();

    irpSp->Parameters.DeviceIoControl.Type3InputBuffer = NULL;
    Extension->CurrentReadIrp->IoStatus.Information = 0L;
    Extension->CurrentReadIrp->IoStatus.Status = STATUS_SUCCESS;

    if (rs->InSize <= Extension->BufferSize) {

        //
        // Nothing to do.  We don't make buffers smaller.  Just
        // agree with the user.  We must deallocate the memory
        // that was already allocated in the ioctl dispatch routine.
        //

        ExFreePool(newBuffer);

    } else {

        SERIAL_RESIZE_PARAMS rp;
        KIRQL controlIrql;

        //
        // Hmmm, looks like we actually have to go
        // through with this.  We need to move all the
        // data that is in the current buffer into this
        // new buffer.  We'll do this in two steps.
        //
        // First we go up to dispatch level and try to
        // move as much as we can without stopping the
        // ISR from running.  We go up to dispatch level
        // by acquiring the control lock.  We do it at
        // dispatch using the control lock so that:
        //
        //    1) We can't be context switched in the middle
        //       of the move.  Our pointers into the buffer
        //       could be *VERY* stale by the time we got back.
        //
        //    2) We use the control lock since we don't want
        //       some pesky purge irp to come along while
        //       we are trying to move.
        //
        // After the move, but while we still hold the control
        // lock, we synch with the ISR and get those last
        // (hopefully) few characters that have come in since
        // we started the copy.  We switch all of our pointers,
        // counters, and such to point to this new buffer.  NOTE:
        // we need to be careful.  If the buffer we were using
        // was not the default one created when we initialized
        // the device (i.e. it was created via a previous IRP of
        // this type), we should deallocate it.
        //

        rp.Extension = Extension;
        rp.OldBuffer = Extension->InterruptReadBuffer;
        rp.NewBuffer = newBuffer;
        rp.NewBufferSize = rs->InSize;

        KeAcquireSpinLock(
            &Extension->ControlLock,
            &controlIrql
            );

        rp.NumberMoved = SerialMoveToNewIntBuffer(
                             Extension,
                             newBuffer
                             );

        KeSynchronizeExecution(
            Extension->Interrupt,
            SerialUpdateAndSwitchToNew,
            &rp
            );

        KeReleaseSpinLock(
            &Extension->ControlLock,
            controlIrql
            );

        //
        // Free up the memory that the old buffer consumed.
        //

        ExFreePool(rp.OldBuffer);

    }

    return STATUS_SUCCESS;

}

ULONG
SerialMoveToNewIntBuffer(
    PSERIAL_DEVICE_EXTENSION Extension,
    PUCHAR NewBuffer
    )

/*++

Routine Description:

    This routine is used to copy any characters out of the interrupt
    buffer into the "new" buffer.  It will be reading values that
    are updated with the ISR but this is safe since this value is
    only decremented by synchronization routines.  This routine will
    return the number of characters copied so some other routine
    can call a synchronization routine to update what is seen at
    interrupt level.

Arguments:

    Extension - A pointer to the device extension.
    NewBuffer - Where the characters are to be move to.

Return Value:

    The number of characters that were copied into the user
    buffer.

--*/

{

    ULONG numberOfCharsMoved = Extension->CharsInInterruptBuffer;
    SERIAL_LOCKED_PAGED_CODE();

    if (numberOfCharsMoved) {

        //
        // This holds the number of characters between the first
        // readable character and the last character we will read or
        // the real physical end of the buffer (not the last readable
        // character).
        //
        ULONG firstTryNumberToGet = (ULONG)(Extension->LastCharSlot -
                                     Extension->FirstReadableChar) + 1;

        if (firstTryNumberToGet >= numberOfCharsMoved) {

            //
            // The characters don't wrap.
            //

            RtlMoveMemory(
                NewBuffer,
                Extension->FirstReadableChar,
                numberOfCharsMoved
                );

            if ((Extension->FirstReadableChar+(numberOfCharsMoved-1)) ==
                Extension->LastCharSlot) {

                Extension->FirstReadableChar = Extension->InterruptReadBuffer;

            } else {

                Extension->FirstReadableChar += numberOfCharsMoved;

            }

        } else {

            //
            // The characters do wrap.  Get up until the end of the buffer.
            //

            RtlMoveMemory(
                NewBuffer,
                Extension->FirstReadableChar,
                firstTryNumberToGet
                );

            //
            // Now get the rest of the characters from the beginning of the
            // buffer.
            //

            RtlMoveMemory(
                NewBuffer+firstTryNumberToGet,
                Extension->InterruptReadBuffer,
                numberOfCharsMoved - firstTryNumberToGet
                );

            Extension->FirstReadableChar = Extension->InterruptReadBuffer +
                                   numberOfCharsMoved - firstTryNumberToGet;

        }

    }

    return numberOfCharsMoved;

}

BOOLEAN
SerialUpdateAndSwitchToNew(
    IN PVOID Context
    )

/*++

Routine Description:

    This routine gets the (hopefully) few characters that
    remain in the interrupt buffer after the first time we tried
    to get them out.

    NOTE: This is called by KeSynchronizeExecution.

Arguments:

    Context - Points to a structure that contains a pointer to the
              device extension, a pointer to the buffer we are moving
              to, and a count of the number of characters
              that we previously copied into the new buffer, and the
              actual size of the new buffer.

Return Value:

    Always FALSE.

--*/

{

    PSERIAL_RESIZE_PARAMS params = Context;
    PSERIAL_DEVICE_EXTENSION extension = params->Extension;
    ULONG tempCharsInInterruptBuffer = extension->CharsInInterruptBuffer;

    SERIAL_LOCKED_PAGED_CODE();

    ASSERT(extension->CharsInInterruptBuffer >= params->NumberMoved);

    //
    // We temporarily reduce the chars in interrupt buffer to
    // "fool" the move routine.  We will restore it after the
    // move.
    //

    extension->CharsInInterruptBuffer -= params->NumberMoved;

    if (extension->CharsInInterruptBuffer) {

        SerialMoveToNewIntBuffer(
            extension,
            params->NewBuffer + params->NumberMoved
            );

    }

    extension->CharsInInterruptBuffer = tempCharsInInterruptBuffer;


    extension->LastCharSlot = params->NewBuffer + (params->NewBufferSize - 1);
    extension->FirstReadableChar = params->NewBuffer;
    extension->ReadBufferBase = params->NewBuffer;
    extension->InterruptReadBuffer = params->NewBuffer;
    extension->BufferSize = params->NewBufferSize;

    //
    // We *KNOW* that the new interrupt buffer is larger than the
    // old buffer.  We don't need to worry about it being full.
    //

    extension->CurrentCharSlot = extension->InterruptReadBuffer +
                                 extension->CharsInInterruptBuffer;

    //
    // We set up the default xon/xoff limits.
    //

    extension->HandFlow.XoffLimit = extension->BufferSize >> 3;
    extension->HandFlow.XonLimit = extension->BufferSize >> 1;

    extension->WmiCommData.XoffXmitThreshold = extension->HandFlow.XoffLimit;
    extension->WmiCommData.XonXmitThreshold = extension->HandFlow.XonLimit;

    extension->BufferSizePt8 = ((3*(extension->BufferSize>>2))+
                                   (extension->BufferSize>>4));

    //
    // Since we (essentially) reduced the percentage of the interrupt
    // buffer being full, we need to handle any flow control.
    //

    SerialHandleReducedIntBuffer(extension);

    return FALSE;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\ser101\sources.inc ===
!IF 0

Copyright (c) 1989  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Steve Wood (stevewo) 12-Apr-1990

NOTE:   Commented description of this file is in $(BASEDIR)\bak\bin\sources.tpl

!ENDIF

MAJORCOMP=ntos
MINORCOMP=dd



DDKROOT=$(_NTDRIVE)$(_NTROOT)

TARGETNAME=ser101
TARGETPATH=obj

TARGETTYPE=DRIVER
DRIVERTYPE=NTPNP

TARGETLIBS= $(SDK_LIB_PATH)\wmilib.lib

USE_MAPSYM=1

INCLUDES=$(DDKROOT)\private\ntos\inc;..\

SOURCES=..\error.c    \
        ..\flush.c    \
        ..\immediat.c \
        ..\initunlo.c \
        ..\ioctl.c    \
        ..\isr.c      \
        ..\modmflow.c \
        ..\openclos.c \
        ..\purge.c    \
        ..\qsfile.c   \
        ..\read.c     \
        ..\serial.rc  \
        ..\utils.c    \
        ..\waitmask.c \
        ..\write.c    \
        ..\pnp.c \
        ..\registry.c \
        ..\legacy.c   \
	..\wmi.c      \
	..\power.c    \
	..\serlog.mc

PRECOMPILED_INCLUDE=..\precomp.h
PRECOMPILED_PCH=precomp.pch
PRECOMPILED_OBJ=precomp.obj
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\ser101\purge.c ===
/*++

Copyright (c) 1991, 1992, 1993 Microsoft Corporation

Module Name:

    purge.c

Abstract:

    This module contains the code that is very specific to purge
    operations in the serial driver

Author:

    Anthony V. Ercolano 26-Sep-1991

Environment:

    Kernel mode

Revision History :

--*/

#include "precomp.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGESER,SerialStartPurge)
#pragma alloc_text(PAGESER,SerialPurgeInterruptBuff)
#endif


NTSTATUS
SerialStartPurge(
    IN PSERIAL_DEVICE_EXTENSION Extension
    )

/*++

Routine Description:

    Depending on the mask in the current irp, purge the interrupt
    buffer, the read queue, or the write queue, or all of the above.

Arguments:

    Extension - Pointer to the device extension.

Return Value:

    Will return STATUS_SUCCESS always.  This is reasonable
    since the DPC completion code that calls this routine doesn't
    care and the purge request always goes through to completion
    once it's started.

--*/

{

    PIRP NewIrp;

    SERIAL_LOCKED_PAGED_CODE();

    do {

        ULONG Mask;

        Mask = *((ULONG *)
                 (Extension->CurrentPurgeIrp->AssociatedIrp.SystemBuffer));

        if (Mask & SERIAL_PURGE_TXABORT) {

            SerialKillAllReadsOrWrites(
                Extension->DeviceObject,
                &Extension->WriteQueue,
                &Extension->CurrentWriteIrp
                );

            SerialKillAllReadsOrWrites(
                Extension->DeviceObject,
                &Extension->WriteQueue,
                &Extension->CurrentXoffIrp
                );

        }

        if (Mask & SERIAL_PURGE_RXABORT) {

            SerialKillAllReadsOrWrites(
                Extension->DeviceObject,
                &Extension->ReadQueue,
                &Extension->CurrentReadIrp
                );

        }

        if (Mask & SERIAL_PURGE_RXCLEAR) {

            KIRQL OldIrql;

            //
            // Clean out the interrupt buffer.
            //
            // Note that we do this under protection of the
            // the drivers control lock so that we don't hose
            // the pointers if there is currently a read that
            // is reading out of the buffer.
            //

            KeAcquireSpinLock(
                &Extension->ControlLock,
                &OldIrql
                );

            KeSynchronizeExecution(
                Extension->Interrupt,
                SerialPurgeInterruptBuff,
                Extension
                );

            KeReleaseSpinLock(
                &Extension->ControlLock,
                OldIrql
                );

        }

        Extension->CurrentPurgeIrp->IoStatus.Status = STATUS_SUCCESS;
        Extension->CurrentPurgeIrp->IoStatus.Information = 0;

        SerialGetNextIrp(
            &Extension->CurrentPurgeIrp,
            &Extension->PurgeQueue,
            &NewIrp,
            TRUE,
            Extension
            );

    } while (NewIrp);

    return STATUS_SUCCESS;

}

BOOLEAN
SerialPurgeInterruptBuff(
    IN PVOID Context
    )

/*++

Routine Description:

    This routine simply resets the interrupt (typeahead) buffer.

    NOTE: This routine is being called from KeSynchronizeExecution.

Arguments:

    Context - Really a pointer to the device extension.

Return Value:

    Always false.

--*/

{

    PSERIAL_DEVICE_EXTENSION Extension = Context;
    SERIAL_LOCKED_PAGED_CODE();

    //
    // The typeahead buffer is by definition empty if there
    // currently is a read owned by the isr.
    //


    if (Extension->ReadBufferBase == Extension->InterruptReadBuffer) {

        Extension->CurrentCharSlot = Extension->InterruptReadBuffer;
        Extension->FirstReadableChar = Extension->InterruptReadBuffer;
        Extension->LastCharSlot = Extension->InterruptReadBuffer +
                                      (Extension->BufferSize - 1);
        Extension->CharsInInterruptBuffer = 0;

        SerialHandleReducedIntBuffer(Extension);

    }

    return FALSE;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\ser101\serialp.h ===
/*++

Copyright (c) 1990, 1991, 1992, 1993 - 1997 Microsoft Corporation

Module Name :

    serialp.h

Abstract:

    Prototypes and macros that are used throughout the driver.

Author:

    Anthony V. Ercolano                 September 26, 1991

--*/


typedef
NTSTATUS
(*PSERIAL_START_ROUTINE) (
    IN PSERIAL_DEVICE_EXTENSION
    );

typedef
VOID
(*PSERIAL_GET_NEXT_ROUTINE) (
    IN PIRP *CurrentOpIrp,
    IN PLIST_ENTRY QueueToProcess,
    OUT PIRP *NewIrp,
    IN BOOLEAN CompleteCurrent,
    PSERIAL_DEVICE_EXTENSION Extension
    );

NTSTATUS
SerialRead(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
SerialStartRead(
    IN PSERIAL_DEVICE_EXTENSION Extension
    );

VOID
SerialCompleteRead(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemContext1,
    IN PVOID SystemContext2
    );

VOID
SerialReadTimeout(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemContext1,
    IN PVOID SystemContext2
    );

NTSTATUS
DriverEntry(
           IN PDRIVER_OBJECT DriverObject,
           IN PUNICODE_STRING RegistryPath
           );

VOID
SerialIntervalReadTimeout(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemContext1,
    IN PVOID SystemContext2
    );

NTSTATUS
SerialFlush(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
SerialWrite(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
SerialStartWrite(
    IN PSERIAL_DEVICE_EXTENSION Extension
    );

VOID
SerialGetNextWrite(
    IN PIRP *CurrentOpIrp,
    IN PLIST_ENTRY QueueToProcess,
    IN PIRP *NewIrp,
    IN BOOLEAN CompleteCurrent,
    IN PSERIAL_DEVICE_EXTENSION Extension
    );

VOID
SerialCompleteWrite(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemContext1,
    IN PVOID SystemContext2
    );

BOOLEAN
SerialProcessEmptyTransmit(
    IN PVOID Context
    );

VOID
SerialWriteTimeout(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemContext1,
    IN PVOID SystemContext2
    );

VOID
SerialCommError(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemContext1,
    IN PVOID SystemContext2
    );

NTSTATUS
SerialCleanup(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
SerialInitOneController(IN PDEVICE_OBJECT PDevObj, IN PCONFIG_DATA PConfigData);

NTSTATUS
SerialCreateOpen(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
SerialClose(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

BOOLEAN
SerialSetDTR(
    IN PVOID Context
    );

BOOLEAN
SerialClrDTR(
    IN PVOID Context
    );

BOOLEAN
SerialSetRTS(
    IN PVOID Context
    );

BOOLEAN
SerialClrRTS(
    IN PVOID Context
    );

BOOLEAN
SerialSetChars(
    IN PVOID Context
    );

BOOLEAN
SerialSetBaud(
    IN PVOID Context
    );

BOOLEAN
SerialSetLineControl(
    IN PVOID Context
    );

BOOLEAN
SerialSetupNewHandFlow(
    IN PSERIAL_DEVICE_EXTENSION Extension,
    IN PSERIAL_HANDFLOW NewHandFlow
    );

BOOLEAN
SerialSetHandFlow(
    IN PVOID Context
    );

BOOLEAN
SerialTurnOnBreak(
    IN PVOID Context
    );

BOOLEAN
SerialTurnOffBreak(
    IN PVOID Context
    );

BOOLEAN
SerialPretendXoff(
    IN PVOID Context
    );

BOOLEAN
SerialPretendXon(
    IN PVOID Context
    );

VOID
SerialHandleReducedIntBuffer(
    IN PSERIAL_DEVICE_EXTENSION Extension
    );

VOID
SerialProdXonXoff(
    IN PSERIAL_DEVICE_EXTENSION Extension,
    IN BOOLEAN SendXon
    );

NTSTATUS
SerialIoControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
SerialStartMask(
    IN PSERIAL_DEVICE_EXTENSION Extension
    );

VOID
SerialCancelWait(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

VOID
SerialCompleteWait(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemContext1,
    IN PVOID SystemContext2
    );

VOID
SerialStartImmediate(
    IN PSERIAL_DEVICE_EXTENSION Extension
    );

VOID
SerialCompleteImmediate(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemContext1,
    IN PVOID SystemContext2
    );

VOID
SerialTimeoutImmediate(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemContext1,
    IN PVOID SystemContext2
    );

VOID
SerialTimeoutXoff(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemContext1,
    IN PVOID SystemContext2
    );

VOID
SerialCompleteXoff(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemContext1,
    IN PVOID SystemContext2
    );

NTSTATUS
SerialStartPurge(
    IN PSERIAL_DEVICE_EXTENSION Extension
    );

BOOLEAN
SerialPurgeInterruptBuff(
    IN PVOID Context
    );

NTSTATUS
SerialQueryInformationFile(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
SerialSetInformationFile(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

VOID
SerialKillAllReadsOrWrites(
    IN PDEVICE_OBJECT DeviceObject,
    IN PLIST_ENTRY QueueToClean,
    IN PIRP *CurrentOpIrp
    );

VOID
SerialGetNextIrp(
    IN PIRP *CurrentOpIrp,
    IN PLIST_ENTRY QueueToProcess,
    OUT PIRP *NextIrp,
    IN BOOLEAN CompleteCurrent,
    IN PSERIAL_DEVICE_EXTENSION extension
    );

VOID
SerialGetNextIrpLocked(IN PIRP *CurrentOpIrp, IN PLIST_ENTRY QueueToProcess,
                       OUT PIRP *NextIrp, IN BOOLEAN CompleteCurrent,
                       IN PSERIAL_DEVICE_EXTENSION extension, IN KIRQL OldIrql);

VOID
SerialTryToCompleteCurrent(
    IN PSERIAL_DEVICE_EXTENSION Extension,
    IN PKSYNCHRONIZE_ROUTINE SynchRoutine OPTIONAL,
    IN KIRQL IrqlForRelease,
    IN NTSTATUS StatusToUse,
    IN PIRP *CurrentOpIrp,
    IN PLIST_ENTRY QueueToProcess,
    IN PKTIMER IntervalTimer,
    IN PKTIMER TotalTimer,
    IN PSERIAL_START_ROUTINE Starter,
    IN PSERIAL_GET_NEXT_ROUTINE GetNextIrp,
    IN LONG RefType
    );

NTSTATUS
SerialStartOrQueue(
    IN PSERIAL_DEVICE_EXTENSION Extension,
    IN PIRP Irp,
    IN PLIST_ENTRY QueueToExamine,
    IN PIRP *CurrentOpIrp,
    IN PSERIAL_START_ROUTINE Starter
    );

VOID
SerialCancelQueued(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp
    );

NTSTATUS
SerialCompleteIfError(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp
    );

ULONG
SerialHandleModemUpdate(
    IN PSERIAL_DEVICE_EXTENSION Extension,
    IN BOOLEAN DoingTX
    );

BOOLEAN
SerialISR(
    IN PKINTERRUPT InterruptObject,
    IN PVOID Context
    );

NTSTATUS
SerialGetDivisorFromBaud(
    IN ULONG ClockRate,
    IN LONG DesiredBaud,
    OUT PSHORT AppropriateDivisor
    );

VOID
SerialUnload(
    IN PDRIVER_OBJECT DriverObject
    );

BOOLEAN
SerialReset(
    IN PVOID Context
    );

BOOLEAN
SerialPerhapsLowerRTS(
    IN PVOID Context
    );

VOID
SerialStartTimerLowerRTS(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemContext1,
    IN PVOID SystemContext2
    );

VOID
SerialInvokePerhapsLowerRTS(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemContext1,
    IN PVOID SystemContext2
    );

VOID
SerialCleanupDevice(
    IN PSERIAL_DEVICE_EXTENSION Extension
    );

UCHAR
SerialProcessLSR(
    IN PSERIAL_DEVICE_EXTENSION Extension
    );

LARGE_INTEGER
SerialGetCharTime(
    IN PSERIAL_DEVICE_EXTENSION Extension
    );

BOOLEAN
SerialSharerIsr(
    IN PKINTERRUPT InterruptObject,
    IN PVOID Context
    );

BOOLEAN
SerialMarkClose(
    IN PVOID Context
    );

BOOLEAN
SerialIndexedMultiportIsr(
    IN PKINTERRUPT InterruptObject,
    IN PVOID Context
    );

BOOLEAN
SerialBitMappedMultiportIsr(
    IN PKINTERRUPT InterruptObject,
    IN PVOID Context
    );

VOID
SerialPutChar(
    IN PSERIAL_DEVICE_EXTENSION Extension,
    IN UCHAR CharToPut
    );

BOOLEAN
SerialGetStats(
    IN PVOID Context
    );

BOOLEAN
SerialClearStats(
    IN PVOID Context
    );

NTSTATUS
SerialCloseComplete(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

NTSTATUS
SerialPnpDispatch(IN PDEVICE_OBJECT PDevObj, IN PIRP PIrp);

NTSTATUS
SerialPowerDispatch(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
SerialSetPowerD0(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
SerialSetPowerD3(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
SerialOpenClose(
   IN PDEVICE_OBJECT DeviceObject,
   IN PIRP Irp
   );

NTSTATUS
SerialGetConfigDefaults(
    IN PSERIAL_FIRMWARE_DATA DriverDefaultsPtr,
    IN PUNICODE_STRING RegistryPath
    );

VOID
SerialGetProperties(
    IN PSERIAL_DEVICE_EXTENSION Extension,
    IN PSERIAL_COMMPROP Properties
    );

NTSTATUS
SerialEnumerateLegacy(IN PDRIVER_OBJECT DriverObject,
                      IN PUNICODE_STRING RegistryPath,
                      IN PSERIAL_FIRMWARE_DATA DriverDefaultsPtr);

NTSTATUS
SerialMigrateLegacyRegistry(IN PDEVICE_OBJECT PPdo,
                            IN PSERIAL_USER_DATA PUserData,
                            IN BOOLEAN IsMulti);

NTSTATUS
SerialBuildResourceList(OUT PCM_RESOURCE_LIST PResourceList,
                        OUT PULONG PPartialCount,
                        IN PSERIAL_USER_DATA PUserData);

NTSTATUS
SerialTranslateResourceList(IN PDRIVER_OBJECT DriverObject,
                            IN PKEY_BASIC_INFORMATION UserSubKey,
                            OUT PCM_RESOURCE_LIST PTrResourceList,
                            IN PCM_RESOURCE_LIST PResourceList,
                            IN ULONG PartialCount,
                            IN PSERIAL_USER_DATA PUserData);

NTSTATUS
SerialBuildRequirementsList(OUT PIO_RESOURCE_REQUIREMENTS_LIST PRequiredList,
                            IN ULONG PartialCount,
                            IN PSERIAL_USER_DATA PUserData);

BOOLEAN
SerialIsUserDataValid(IN PDRIVER_OBJECT DriverObject,
                      IN PKEY_BASIC_INFORMATION UserSubKey,
                      IN PRTL_QUERY_REGISTRY_TABLE Parameters,
                      IN ULONG DefaultInterfaceType,
                      IN PSERIAL_USER_DATA PUserData);

NTSTATUS
SerialControllerCallBack(
                  IN PVOID Context,
                  IN PUNICODE_STRING PathName,
                  IN INTERFACE_TYPE BusType,
                  IN ULONG BusNumber,
                  IN PKEY_VALUE_FULL_INFORMATION *BusInformation,
                  IN CONFIGURATION_TYPE ControllerType,
                  IN ULONG ControllerNumber,
                  IN PKEY_VALUE_FULL_INFORMATION *ControllerInformation,
                  IN CONFIGURATION_TYPE PeripheralType,
                  IN ULONG PeripheralNumber,
                  IN PKEY_VALUE_FULL_INFORMATION *PeripheralInformation
                  );

VOID
SerialLogError(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT DeviceObject OPTIONAL,
    IN PHYSICAL_ADDRESS P1,
    IN PHYSICAL_ADDRESS P2,
    IN ULONG SequenceNumber,
    IN UCHAR MajorFunctionCode,
    IN UCHAR RetryCount,
    IN ULONG UniqueErrorValue,
    IN NTSTATUS FinalStatus,
    IN NTSTATUS SpecificIOStatus,
    IN ULONG LengthOfInsert1,
    IN PWCHAR Insert1,
    IN ULONG LengthOfInsert2,
    IN PWCHAR Insert2
    );

NTSTATUS
SerialAddDevice(IN PDRIVER_OBJECT DriverObject, IN PDEVICE_OBJECT PLowerDevObj);

NTSTATUS
SerialCreateDevObj(IN PDRIVER_OBJECT DriverObject,
                   OUT PDEVICE_OBJECT *NewDeviceObject);

NTSTATUS
SerialStartDevice(IN PDEVICE_OBJECT PDevObj, IN PIRP PIrp);

NTSTATUS
SerialGetRegistryKeyValue (IN HANDLE Handle, IN PWCHAR KeyNameString,
                           IN ULONG KeyNameStringLength, IN PVOID Data,
                           IN ULONG DataLength);

NTSTATUS
SerialPnpDispatch(IN PDEVICE_OBJECT PDevObj, IN PIRP PIrp);

NTSTATUS
SerialGetPortInfo(IN PDEVICE_OBJECT PDevObj, IN PCM_RESOURCE_LIST PResList,
                 IN PCM_RESOURCE_LIST PTrResList, OUT PCONFIG_DATA PConfig,
                 IN PSERIAL_USER_DATA PUserData);

NTSTATUS
SerialFinishStartDevice(IN PDEVICE_OBJECT PDevObj,
                        IN PCM_RESOURCE_LIST PResList,
                        IN PCM_RESOURCE_LIST PTrResList,
                        IN PSERIAL_USER_DATA PUserData);

NTSTATUS
SerialPutRegistryKeyValue (
                          IN HANDLE Handle,
                          IN PWCHAR KeyNameString,
                          IN ULONG KeyNameStringLength,
                          IN ULONG Dtype,
                          IN PVOID Data,
                          IN ULONG DataLength
                          );

NTSTATUS
SerialInitController(IN PDEVICE_OBJECT PDevObj, IN PCONFIG_DATA PConfigData);

NTSTATUS
SerialInitMultiPort(IN PSERIAL_DEVICE_EXTENSION PDevExt,
                    IN PCONFIG_DATA PConfigData, IN PDEVICE_OBJECT PDevObj);

NTSTATUS
SerialFindInitController(IN PDEVICE_OBJECT PDevObj, IN PCONFIG_DATA PConfig);


BOOLEAN
SerialCIsrSw(IN PKINTERRUPT InterruptObject, IN PVOID Context);

NTSTATUS
SerialDoExternalNaming(IN PSERIAL_DEVICE_EXTENSION PDevExt,
                       IN PDRIVER_OBJECT PDrvObj);

PVOID
SerialGetMappedAddress(
    IN INTERFACE_TYPE BusType,
    IN ULONG BusNumber,
    PHYSICAL_ADDRESS IoAddress,
    ULONG NumberOfBytes,
    ULONG AddressSpace,
    PBOOLEAN MappedAddress
    );

NTSTATUS
SerialItemCallBack(
    IN PVOID Context,
    IN PUNICODE_STRING PathName,
    IN INTERFACE_TYPE BusType,
    IN ULONG BusNumber,
    IN PKEY_VALUE_FULL_INFORMATION *BusInformation,
    IN CONFIGURATION_TYPE ControllerType,
    IN ULONG ControllerNumber,
    IN PKEY_VALUE_FULL_INFORMATION *ControllerInformation,
    IN CONFIGURATION_TYPE PeripheralType,
    IN ULONG PeripheralNumber,
    IN PKEY_VALUE_FULL_INFORMATION *PeripheralInformation
    );

BOOLEAN
SerialDoesPortExist(
    IN PSERIAL_DEVICE_EXTENSION Extension,
    PUNICODE_STRING InsertString,
    IN ULONG ForceFifo,
    IN ULONG LogFifo
    );

SERIAL_MEM_COMPARES
SerialMemCompare(
    IN PHYSICAL_ADDRESS A,
    IN ULONG SpanOfA,
    IN PHYSICAL_ADDRESS B,
    IN ULONG SpanOfB
    );

VOID
SerialUndoExternalNaming(
    IN PSERIAL_DEVICE_EXTENSION Extension
    );


NTSTATUS
SerialIRPPrologue(IN PIRP PIrp, IN PSERIAL_DEVICE_EXTENSION PDevExt);

VOID
SerialIRPEpilogue(IN PSERIAL_DEVICE_EXTENSION PDevExt);

NTSTATUS
SerialIoCallDriver(PSERIAL_DEVICE_EXTENSION PDevExt, PDEVICE_OBJECT PDevObj,
                   PIRP PIrp);

NTSTATUS
SerialPoCallDriver(PSERIAL_DEVICE_EXTENSION PDevExt, PDEVICE_OBJECT PDevObj,
                   PIRP PIrp);

NTSTATUS
SerialRemoveDevObj(IN PDEVICE_OBJECT PDevObj);

VOID
SerialReleaseResources(IN PSERIAL_DEVICE_EXTENSION PDevExt);

VOID
SerialKillPendingIrps(PDEVICE_OBJECT DeviceObject);

VOID
SerialDisableUART(IN PVOID Context);

VOID
SerialDrainUART(IN PSERIAL_DEVICE_EXTENSION PDevExt,
                IN PLARGE_INTEGER PDrainTime);

NTSTATUS
SerialSystemControlDispatch(IN PDEVICE_OBJECT PDevObj, IN PIRP PIrp);

NTSTATUS
SerialSetWmiDataItem(IN PDEVICE_OBJECT PDevObj, IN PIRP PIrp,
                     IN ULONG GuidIndex, IN ULONG InstanceIndex,
                     IN ULONG DataItemId,
                     IN ULONG BufferSize, IN PUCHAR PBuffer);

NTSTATUS
SerialSetWmiDataBlock(IN PDEVICE_OBJECT PDevObj, IN PIRP PIrp,
                      IN ULONG GuidIndex, IN ULONG InstanceIndex,
                      IN ULONG BufferSize,
                      IN PUCHAR PBuffer);

NTSTATUS
SerialQueryWmiDataBlock(IN PDEVICE_OBJECT PDevObj, IN PIRP PIrp,
                        IN ULONG GuidIndex,
                        IN ULONG InstanceIndex,
                        IN ULONG InstanceCount,
                        IN OUT PULONG InstanceLengthArray,
                        IN ULONG OutBufferSize,
                        OUT PUCHAR PBuffer);

NTSTATUS
SerialQueryWmiRegInfo(IN PDEVICE_OBJECT PDevObj, OUT PULONG PRegFlags,
                      OUT PUNICODE_STRING PInstanceName,
                      OUT PUNICODE_STRING *PRegistryPath,
                      OUT PUNICODE_STRING MofResourceName,
                      OUT PDEVICE_OBJECT *Pdo);

VOID
SerialRestoreDeviceState(IN PSERIAL_DEVICE_EXTENSION PDevExt);

VOID
SerialSaveDeviceState(IN PSERIAL_DEVICE_EXTENSION PDevExt);

NTSTATUS
SerialSyncCompletion(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp,
                     IN PKEVENT SerialSyncEvent);

NTSTATUS
SerialGotoPowerState(IN PDEVICE_OBJECT PDevObj,
                     IN PSERIAL_DEVICE_EXTENSION PDevExt,
                     IN DEVICE_POWER_STATE DevPowerState);

NTSTATUS
SerialFilterIrps(IN PIRP PIrp, IN PSERIAL_DEVICE_EXTENSION PDevExt);

VOID
SerialKillAllStalled(IN PDEVICE_OBJECT PDevObj);

VOID
SerialUnstallIrps(IN PSERIAL_DEVICE_EXTENSION PDevExt);

NTSTATUS
SerialInternalIoControl(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp);

NTSTATUS
SerialSendWaitWake(PSERIAL_DEVICE_EXTENSION PDevExt);

NTSTATUS
SerialWakeCompletion(IN PDEVICE_OBJECT PDevObj, IN UCHAR MinorFunction,
                     IN POWER_STATE PowerState, IN PVOID Context,
                     IN PIO_STATUS_BLOCK IoStatus);

UINT32
SerialReportMaxBaudRate(ULONG Bauds);

BOOLEAN
SerialSetMCRContents(IN PVOID Context);

BOOLEAN
SerialGetMCRContents(IN PVOID Context);

BOOLEAN
SerialSetFCRContents(IN PVOID Context);

NTSTATUS
SerialTossWMIRequest(IN PDEVICE_OBJECT PDevObj, IN PIRP PIrp,
                     IN ULONG GuidIndex);

VOID
SerialDpcEpilogue(IN PSERIAL_DEVICE_EXTENSION PDevExt, IN PKDPC PDpc);

BOOLEAN
SerialInsertQueueDpc(IN PRKDPC Dpc, IN PVOID Sarg1, IN PVOID Sarg2,
                     IN PSERIAL_DEVICE_EXTENSION PDevExt);

BOOLEAN
SerialSetTimer(IN PKTIMER Timer, IN LARGE_INTEGER DueTime,
               IN PKDPC Dpc OPTIONAL, IN PSERIAL_DEVICE_EXTENSION PDevExt);

BOOLEAN
SerialCancelTimer(IN PKTIMER Timer, IN PSERIAL_DEVICE_EXTENSION PDevExt);

VOID
SerialUnlockPages(IN PKDPC PDpc, IN PVOID PDeferredContext,
                  IN PVOID PSysContext1, IN PVOID PSysContext2);

VOID
SerialMarkHardwareBroken(IN PSERIAL_DEVICE_EXTENSION PDevExt);

VOID
SerialDisableInterfacesResources(IN PDEVICE_OBJECT PDevObj,
                                 IN BOOLEAN DisableUART);

VOID
SerialSetDeviceFlags(IN PSERIAL_DEVICE_EXTENSION PDevExt, OUT PULONG PFlags,
                     IN ULONG Value, IN BOOLEAN Set);


typedef struct _SERIAL_UPDATE_CHAR {
    PSERIAL_DEVICE_EXTENSION Extension;
    ULONG CharsCopied;
    BOOLEAN Completed;
    } SERIAL_UPDATE_CHAR,*PSERIAL_UPDATE_CHAR;

//
// The following simple structure is used to send a pointer
// the device extension and an ioctl specific pointer
// to data.
//
typedef struct _SERIAL_IOCTL_SYNC {
    PSERIAL_DEVICE_EXTENSION Extension;
    PVOID Data;
    } SERIAL_IOCTL_SYNC,*PSERIAL_IOCTL_SYNC;

#define SerialSetFlags(PDevExt, Value) \
   SerialSetDeviceFlags((PDevExt), &(PDevExt)->Flags, (Value), TRUE)
#define SerialClearFlags(PDevExt, Value) \
   SerialSetDeviceFlags((PDevExt), &(PDevExt)->Flags, (Value), FALSE)
#define SerialSetAccept(PDevExt, Value) \
   SerialSetDeviceFlags((PDevExt), &(PDevExt)->DevicePNPAccept, (Value), TRUE)
#define SerialClearAccept(PDevExt, Value) \
   SerialSetDeviceFlags((PDevExt), &(PDevExt)->DevicePNPAccept, (Value), FALSE)




//
// The following three macros are used to initialize, set
// and clear references in IRPs that are used by
// this driver.  The reference is stored in the fourth
// argument of the irp, which is never used by any operation
// accepted by this driver.
//

#define SERIAL_REF_ISR         (0x00000001)
#define SERIAL_REF_CANCEL      (0x00000002)
#define SERIAL_REF_TOTAL_TIMER (0x00000004)
#define SERIAL_REF_INT_TIMER   (0x00000008)
#define SERIAL_REF_XOFF_REF    (0x00000010)


#define SERIAL_INIT_REFERENCE(Irp) { \
    ASSERT(sizeof(ULONG_PTR) <= sizeof(PVOID)); \
    IoGetCurrentIrpStackLocation((Irp))->Parameters.Others.Argument4 = NULL; \
    }

#define SERIAL_SET_REFERENCE(Irp,RefType) \
   do { \
       LONG _refType = (RefType); \
       PULONG_PTR _arg4 = (PVOID)&IoGetCurrentIrpStackLocation((Irp))->Parameters.Others.Argument4; \
       ASSERT(!(*_arg4 & _refType)); \
       *_arg4 |= _refType; \
   } while (0)

#define SERIAL_CLEAR_REFERENCE(Irp,RefType) \
   do { \
       LONG _refType = (RefType); \
       PULONG_PTR _arg4 = (PVOID)&IoGetCurrentIrpStackLocation((Irp))->Parameters.Others.Argument4; \
       ASSERT(*_arg4 & _refType); \
       *_arg4 &= ~_refType; \
   } while (0)

#define SERIAL_REFERENCE_COUNT(Irp) \
    ((ULONG_PTR)((IoGetCurrentIrpStackLocation((Irp))->Parameters.Others.Argument4)))
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\ser71051\error.c ===
/*++

Copyright (c) 1991, 1992, 1993 Microsoft Corporation

Module Name:

    error.c

Abstract:

    This module contains the code that is very specific to error
    operations in the serial driver

Author:

    Anthony V. Ercolano 26-Sep-1991

Environment:

    Kernel mode

Revision History :

--*/

#include "precomp.h"


VOID
SerialCommError(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemContext1,
    IN PVOID SystemContext2
    )

/*++

Routine Description:

    This routine is invoked at dpc level to in response to
    a comm error.  All comm errors kill all read and writes

Arguments:

    Dpc - Not Used.

    DeferredContext - Really points to the device object.

    SystemContext1 - Not Used.

    SystemContext2 - Not Used.

Return Value:

    None.

--*/

{

    PSERIAL_DEVICE_EXTENSION Extension = DeferredContext;

    UNREFERENCED_PARAMETER(SystemContext1);
    UNREFERENCED_PARAMETER(SystemContext2);

    SerialDump(SERTRACECALLS, ("SERIAL: SerialCommError\n"));

    SerialKillAllReadsOrWrites(
        Extension->DeviceObject,
        &Extension->WriteQueue,
        &Extension->CurrentWriteIrp
        );

    SerialKillAllReadsOrWrites(
        Extension->DeviceObject,
        &Extension->ReadQueue,
        &Extension->CurrentReadIrp
        );


    SerialDpcEpilogue(Extension, Dpc);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\ser71051\flush.c ===
/*++

Copyright (c) 1991, 1992, 1993 Microsoft Corporation

Module Name:

    flush.c

Abstract:

    This module contains the code that is very specific to flush
    operations in the serial driver

Author:

    Anthony V. Ercolano 26-Sep-1991

Environment:

    Kernel mode

Revision History :

--*/

#include "precomp.h"


NTSTATUS
SerialStartFlush(
    IN PSERIAL_DEVICE_EXTENSION Extension
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGESRP0,SerialFlush)
#pragma alloc_text(PAGESRP0,SerialStartFlush)
#endif


NTSTATUS
SerialFlush(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This is the dispatch routine for flush.  Flushing works by placing
    this request in the write queue.  When this request reaches the
    front of the write queue we simply complete it since this implies
    that all previous writes have completed.

Arguments:

    DeviceObject - Pointer to the device object for this device

    Irp - Pointer to the IRP for the current request

Return Value:

    Could return status success, cancelled, or pending.

--*/

{

    PSERIAL_DEVICE_EXTENSION Extension = DeviceObject->DeviceExtension;
    NTSTATUS status;
    PAGED_CODE();

    SerialDump(
        SERIRPPATH,
        ("SERIAL: Dispatch entry for: %x\n",Irp)
        );

    SerialDump(SERTRACECALLS, ("SERIAL: Entering SerialFlush\n"));

    

    Irp->IoStatus.Information = 0L;

    if ((status = SerialIRPPrologue(Irp, Extension)) == STATUS_SUCCESS) {

       if (SerialCompleteIfError(DeviceObject, Irp) != STATUS_SUCCESS) {
          SerialDump(SERTRACECALLS, ("SERIAL: Leaving SerialFlush (1)\n"));

          return STATUS_CANCELLED;

       }

       SerialDump(SERTRACECALLS, ("SERIAL: Leaving SerialFlush (2)\n"));

       return SerialStartOrQueue(Extension, Irp, &Extension->WriteQueue,
               &Extension->CurrentWriteIrp, SerialStartFlush);

    } else {
       Irp->IoStatus.Status = status;

       if (!NT_SUCCESS(status)) {
          SerialCompleteRequest(Extension, Irp, IO_NO_INCREMENT);
       }

       SerialDump(SERTRACECALLS, ("SERIAL: Leaving SerialFlush (3)\n"));
       return status;
    }
}


NTSTATUS
SerialStartFlush(
    IN PSERIAL_DEVICE_EXTENSION Extension
    )

/*++

Routine Description:

    This routine is called if there were no writes in the queue.
    The flush became the current write because there was nothing
    in the queue.  Note however that does not mean there is
    nothing in the queue now!  So, we will start off the write
    that might follow us.

Arguments:

    Extension - Points to the serial device extension

Return Value:

    This will always return STATUS_SUCCESS.

--*/

{

    PIRP NewIrp;
    PAGED_CODE();

    Extension->CurrentWriteIrp->IoStatus.Status = STATUS_SUCCESS;

    //
    // The following call will actually complete the flush.
    //

    SerialGetNextWrite(
        &Extension->CurrentWriteIrp,
        &Extension->WriteQueue,
        &NewIrp,
        TRUE,
        Extension
        );

    if (NewIrp) {

        ASSERT(NewIrp == Extension->CurrentWriteIrp);
        SerialStartWrite(Extension);

    }

    return STATUS_SUCCESS;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\ser101\utils.c ===
/*++

Copyright (c) 1991, 1992, 1993 - 1997 Microsoft Corporation

Module Name:

    utils.c

Abstract:

    This module contains code that perform queueing and completion
    manipulation on requests.  Also module generic functions such
    as error logging.

Author:

    Anthony V. Ercolano 26-Sep-1991

Environment:

    Kernel mode

--*/

#include "precomp.h"

VOID
SerialRundownIrpRefs(
    IN PIRP *CurrentOpIrp,
    IN PKTIMER IntervalTimer,
    IN PKTIMER TotalTimer,
    IN PSERIAL_DEVICE_EXTENSION PDevExt
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGESER,SerialGetNextIrp)
#pragma alloc_text(PAGESER, SerialGetNextIrpLocked)
#pragma alloc_text(PAGESER,SerialTryToCompleteCurrent)
#pragma alloc_text(PAGESER,SerialStartOrQueue)
#pragma alloc_text(PAGESER,SerialCancelQueued)
#pragma alloc_text(PAGESER,SerialCompleteIfError)
#pragma alloc_text(PAGESER,SerialRundownIrpRefs)

#pragma alloc_text(PAGESRP0, SerialLogError)
#pragma alloc_text(PAGESRP0, SerialMarkHardwareBroken)
#endif

static const PHYSICAL_ADDRESS SerialPhysicalZero = {0};


VOID
SerialKillAllReadsOrWrites(
    IN PDEVICE_OBJECT DeviceObject,
    IN PLIST_ENTRY QueueToClean,
    IN PIRP *CurrentOpIrp
    )

/*++

Routine Description:

    This function is used to cancel all queued and the current irps
    for reads or for writes.

Arguments:

    DeviceObject - A pointer to the serial device object.

    QueueToClean - A pointer to the queue which we're going to clean out.

    CurrentOpIrp - Pointer to a pointer to the current irp.

Return Value:

    None.

--*/

{

    KIRQL cancelIrql;
    PDRIVER_CANCEL cancelRoutine;

    //
    // We acquire the cancel spin lock.  This will prevent the
    // irps from moving around.
    //

    IoAcquireCancelSpinLock(&cancelIrql);

    //
    // Clean the list from back to front.
    //

    while (!IsListEmpty(QueueToClean)) {

        PIRP currentLastIrp = CONTAINING_RECORD(
                                  QueueToClean->Blink,
                                  IRP,
                                  Tail.Overlay.ListEntry
                                  );

        RemoveEntryList(QueueToClean->Blink);

        cancelRoutine = currentLastIrp->CancelRoutine;
        currentLastIrp->CancelIrql = cancelIrql;
        currentLastIrp->CancelRoutine = NULL;
        currentLastIrp->Cancel = TRUE;

        cancelRoutine(
            DeviceObject,
            currentLastIrp
            );

        IoAcquireCancelSpinLock(&cancelIrql);

    }

    //
    // The queue is clean.  Now go after the current if
    // it's there.
    //

    if (*CurrentOpIrp) {


        cancelRoutine = (*CurrentOpIrp)->CancelRoutine;
        (*CurrentOpIrp)->Cancel = TRUE;

        //
        // If the current irp is not in a cancelable state
        // then it *will* try to enter one and the above
        // assignment will kill it.  If it already is in
        // a cancelable state then the following will kill it.
        //

        if (cancelRoutine) {

            (*CurrentOpIrp)->CancelRoutine = NULL;
            (*CurrentOpIrp)->CancelIrql = cancelIrql;

            //
            // This irp is already in a cancelable state.  We simply
            // mark it as canceled and call the cancel routine for
            // it.
            //

            cancelRoutine(
                DeviceObject,
                *CurrentOpIrp
                );

        } else {

            IoReleaseCancelSpinLock(cancelIrql);

        }

    } else {

        IoReleaseCancelSpinLock(cancelIrql);

    }

}

VOID
SerialGetNextIrp(
    IN PIRP *CurrentOpIrp,
    IN PLIST_ENTRY QueueToProcess,
    OUT PIRP *NextIrp,
    IN BOOLEAN CompleteCurrent,
    IN PSERIAL_DEVICE_EXTENSION extension
    )

/*++

Routine Description:

    This function is used to make the head of the particular
    queue the current irp.  It also completes the what
    was the old current irp if desired.

Arguments:

    CurrentOpIrp - Pointer to a pointer to the currently active
                   irp for the particular work list.  Note that
                   this item is not actually part of the list.

    QueueToProcess - The list to pull the new item off of.

    NextIrp - The next Irp to process.  Note that CurrentOpIrp
              will be set to this value under protection of the
              cancel spin lock.  However, if *NextIrp is NULL when
              this routine returns, it is not necessaryly true the
              what is pointed to by CurrentOpIrp will also be NULL.
              The reason for this is that if the queue is empty
              when we hold the cancel spin lock, a new irp may come
              in immediately after we release the lock.

    CompleteCurrent - If TRUE then this routine will complete the
                      irp pointed to by the pointer argument
                      CurrentOpIrp.

Return Value:

    None.

--*/

{

    KIRQL oldIrql;
    SERIAL_LOCKED_PAGED_CODE();


    IoAcquireCancelSpinLock(&oldIrql);
    SerialGetNextIrpLocked(CurrentOpIrp, QueueToProcess, NextIrp,
                           CompleteCurrent, extension, oldIrql);
}

VOID
SerialGetNextIrpLocked(
    IN PIRP *CurrentOpIrp,
    IN PLIST_ENTRY QueueToProcess,
    OUT PIRP *NextIrp,
    IN BOOLEAN CompleteCurrent,
    IN PSERIAL_DEVICE_EXTENSION extension,
    IN KIRQL OldIrql
    )

/*++

Routine Description:

    This function is used to make the head of the particular
    queue the current irp.  It also completes the what
    was the old current irp if desired.  The difference between
    this and SerialGetNextIrp() is that for this we assume the caller
    holds the cancel spinlock and we should release it when we're done.

Arguments:

    CurrentOpIrp - Pointer to a pointer to the currently active
                   irp for the particular work list.  Note that
                   this item is not actually part of the list.

    QueueToProcess - The list to pull the new item off of.

    NextIrp - The next Irp to process.  Note that CurrentOpIrp
              will be set to this value under protection of the
              cancel spin lock.  However, if *NextIrp is NULL when
              this routine returns, it is not necessaryly true the
              what is pointed to by CurrentOpIrp will also be NULL.
              The reason for this is that if the queue is empty
              when we hold the cancel spin lock, a new irp may come
              in immediately after we release the lock.

    CompleteCurrent - If TRUE then this routine will complete the
                      irp pointed to by the pointer argument
                      CurrentOpIrp.

    OldIrql - IRQL which the cancel spinlock was acquired at and what we
              should restore it to.

Return Value:

    None.

--*/

{

    PIRP oldIrp;

    SERIAL_LOCKED_PAGED_CODE();


    oldIrp = *CurrentOpIrp;

#if DBG
    if (oldIrp) {

        if (CompleteCurrent) {

            ASSERT(!oldIrp->CancelRoutine);

        }

    }
#endif

    //
    // Check to see if there is a new irp to start up.
    //

    if (!IsListEmpty(QueueToProcess)) {

        PLIST_ENTRY headOfList;

        headOfList = RemoveHeadList(QueueToProcess);

        *CurrentOpIrp = CONTAINING_RECORD(
                            headOfList,
                            IRP,
                            Tail.Overlay.ListEntry
                            );

        IoSetCancelRoutine(
            *CurrentOpIrp,
            NULL
            );

    } else {

        *CurrentOpIrp = NULL;

    }

    *NextIrp = *CurrentOpIrp;
    IoReleaseCancelSpinLock(OldIrql);

    if (CompleteCurrent) {

        if (oldIrp) {

            SerialDump(
                SERIRPPATH,
                ("SERIAL: Complete Irp: %x\n",oldIrp)
                );

            SerialCompleteRequest(extension, oldIrp, IO_SERIAL_INCREMENT);
        }
    }
}



VOID
SerialTryToCompleteCurrent(
    IN PSERIAL_DEVICE_EXTENSION Extension,
    IN PKSYNCHRONIZE_ROUTINE SynchRoutine OPTIONAL,
    IN KIRQL IrqlForRelease,
    IN NTSTATUS StatusToUse,
    IN PIRP *CurrentOpIrp,
    IN PLIST_ENTRY QueueToProcess OPTIONAL,
    IN PKTIMER IntervalTimer OPTIONAL,
    IN PKTIMER TotalTimer OPTIONAL,
    IN PSERIAL_START_ROUTINE Starter OPTIONAL,
    IN PSERIAL_GET_NEXT_ROUTINE GetNextIrp OPTIONAL,
    IN LONG RefType
    )

/*++

Routine Description:

    This routine attempts to kill all of the reasons there are
    references on the current read/write.  If everything can be killed
    it will complete this read/write and try to start another.

    NOTE: This routine assumes that it is called with the cancel
          spinlock held.

Arguments:

    Extension - Simply a pointer to the device extension.

    SynchRoutine - A routine that will synchronize with the isr
                   and attempt to remove the knowledge of the
                   current irp from the isr.  NOTE: This pointer
                   can be null.

    IrqlForRelease - This routine is called with the cancel spinlock held.
                     This is the irql that was current when the cancel
                     spinlock was acquired.

    StatusToUse - The irp's status field will be set to this value, if
                  this routine can complete the irp.


Return Value:

    None.

--*/

{

   SERIAL_LOCKED_PAGED_CODE();

    //
    // We can decrement the reference to "remove" the fact
    // that the caller no longer will be accessing this irp.
    //

    SERIAL_CLEAR_REFERENCE(
        *CurrentOpIrp,
        RefType
        );

    if (SynchRoutine) {

        KeSynchronizeExecution(
            Extension->Interrupt,
            SynchRoutine,
            Extension
            );

    }

    //
    // Try to run down all other references to this irp.
    //

    SerialRundownIrpRefs(
        CurrentOpIrp,
        IntervalTimer,
        TotalTimer,
        Extension
        );

    //
    // See if the ref count is zero after trying to kill everybody else.
    //

    if (!SERIAL_REFERENCE_COUNT(*CurrentOpIrp)) {

        PIRP newIrp;


        //
        // The ref count was zero so we should complete this
        // request.
        //
        // The following call will also cause the current irp to be
        // completed.
        //

        (*CurrentOpIrp)->IoStatus.Status = StatusToUse;

        if (StatusToUse == STATUS_CANCELLED) {

            (*CurrentOpIrp)->IoStatus.Information = 0;

        }

        if (GetNextIrp) {

            IoReleaseCancelSpinLock(IrqlForRelease);
            GetNextIrp(
                CurrentOpIrp,
                QueueToProcess,
                &newIrp,
                TRUE,
                Extension
                );

            if (newIrp) {

                Starter(Extension);

            }

        } else {

            PIRP oldIrp = *CurrentOpIrp;

            //
            // There was no get next routine.  We will simply complete
            // the irp.  We should make sure that we null out the
            // pointer to the pointer to this irp.
            //

            *CurrentOpIrp = NULL;

            IoReleaseCancelSpinLock(IrqlForRelease);
            SerialDump(
                SERIRPPATH,
                ("SERIAL: Complete Irp: %x\n",oldIrp)
                );
            SerialCompleteRequest(Extension, oldIrp, IO_SERIAL_INCREMENT);
        }

    } else {

        IoReleaseCancelSpinLock(IrqlForRelease);

    }

}

VOID
SerialRundownIrpRefs(IN PIRP *CurrentOpIrp, IN PKTIMER IntervalTimer OPTIONAL,
                     IN PKTIMER TotalTimer OPTIONAL,
                     IN PSERIAL_DEVICE_EXTENSION PDevExt)

/*++

Routine Description:

    This routine runs through the various items that *could*
    have a reference to the current read/write.  It try's to kill
    the reason.  If it does succeed in killing the reason it
    will decrement the reference count on the irp.

    NOTE: This routine assumes that it is called with the cancel
          spin lock held.

Arguments:

    CurrentOpIrp - Pointer to a pointer to current irp for the
                   particular operation.

    IntervalTimer - Pointer to the interval timer for the operation.
                    NOTE: This could be null.

    TotalTimer - Pointer to the total timer for the operation.
                 NOTE: This could be null.

    PDevExt - Pointer to device extension

Return Value:

    None.

--*/


{

   SERIAL_LOCKED_PAGED_CODE();

    //
    // This routine is called with the cancel spin lock held
    // so we know only one thread of execution can be in here
    // at one time.
    //

    //
    // First we see if there is still a cancel routine.  If
    // so then we can decrement the count by one.
    //

    if ((*CurrentOpIrp)->CancelRoutine) {

        SERIAL_CLEAR_REFERENCE(
            *CurrentOpIrp,
            SERIAL_REF_CANCEL
            );

        IoSetCancelRoutine(
            *CurrentOpIrp,
            NULL
            );

    }

    if (IntervalTimer) {

        //
        // Try to cancel the operations interval timer.  If the operation
        // returns true then the timer did have a reference to the
        // irp.  Since we've canceled this timer that reference is
        // no longer valid and we can decrement the reference count.
        //
        // If the cancel returns false then this means either of two things:
        //
        // a) The timer has already fired.
        //
        // b) There never was an interval timer.
        //
        // In the case of "b" there is no need to decrement the reference
        // count since the "timer" never had a reference to it.
        //
        // In the case of "a", then the timer itself will be coming
        // along and decrement it's reference.  Note that the caller
        // of this routine might actually be the this timer, but it
        // has already decremented the reference.
        //

        if (SerialCancelTimer(IntervalTimer, PDevExt)) {

            SERIAL_CLEAR_REFERENCE(
                *CurrentOpIrp,
                SERIAL_REF_INT_TIMER
                );

        }

    }

    if (TotalTimer) {

        //
        // Try to cancel the operations total timer.  If the operation
        // returns true then the timer did have a reference to the
        // irp.  Since we've canceled this timer that reference is
        // no longer valid and we can decrement the reference count.
        //
        // If the cancel returns false then this means either of two things:
        //
        // a) The timer has already fired.
        //
        // b) There never was an total timer.
        //
        // In the case of "b" there is no need to decrement the reference
        // count since the "timer" never had a reference to it.
        //
        // In the case of "a", then the timer itself will be coming
        // along and decrement it's reference.  Note that the caller
        // of this routine might actually be the this timer, but it
        // has already decremented the reference.
        //

        if (SerialCancelTimer(TotalTimer, PDevExt)) {

            SERIAL_CLEAR_REFERENCE(
                *CurrentOpIrp,
                SERIAL_REF_TOTAL_TIMER
                );
        }

    }

}

NTSTATUS
SerialStartOrQueue(
    IN PSERIAL_DEVICE_EXTENSION Extension,
    IN PIRP Irp,
    IN PLIST_ENTRY QueueToExamine,
    IN PIRP *CurrentOpIrp,
    IN PSERIAL_START_ROUTINE Starter
    )

/*++

Routine Description:

    This routine is used to either start or queue any requst
    that can be queued in the driver.

Arguments:

    Extension - Points to the serial device extension.

    Irp - The irp to either queue or start.  In either
          case the irp will be marked pending.

    QueueToExamine - The queue the irp will be place on if there
                     is already an operation in progress.

    CurrentOpIrp - Pointer to a pointer to the irp the is current
                   for the queue.  The pointer pointed to will be
                   set with to Irp if what CurrentOpIrp points to
                   is NULL.

    Starter - The routine to call if the queue is empty.

Return Value:

    This routine will return STATUS_PENDING if the queue is
    not empty.  Otherwise, it will return the status returned
    from the starter routine (or cancel, if the cancel bit is
    on in the irp).


--*/

{

    KIRQL oldIrql;

    SERIAL_LOCKED_PAGED_CODE();

    IoAcquireCancelSpinLock(&oldIrql);

    //
    // If this is a write irp then take the amount of characters
    // to write and add it to the count of characters to write.
    //

    if (IoGetCurrentIrpStackLocation(Irp)->MajorFunction
        == IRP_MJ_WRITE) {

        Extension->TotalCharsQueued +=
            IoGetCurrentIrpStackLocation(Irp)
            ->Parameters.Write.Length;

    } else if ((IoGetCurrentIrpStackLocation(Irp)->MajorFunction
                == IRP_MJ_DEVICE_CONTROL) &&
               ((IoGetCurrentIrpStackLocation(Irp)
                 ->Parameters.DeviceIoControl.IoControlCode ==
                 IOCTL_SERIAL_IMMEDIATE_CHAR) ||
                (IoGetCurrentIrpStackLocation(Irp)
                 ->Parameters.DeviceIoControl.IoControlCode ==
                 IOCTL_SERIAL_XOFF_COUNTER))) {

        Extension->TotalCharsQueued++;

    }

    if ((IsListEmpty(QueueToExamine)) &&
        !(*CurrentOpIrp)) {

        //
        // There were no current operation.  Mark this one as
        // current and start it up.
        //

        *CurrentOpIrp = Irp;

        IoReleaseCancelSpinLock(oldIrql);

        return Starter(Extension);

    } else {

        //
        // We don't know how long the irp will be in the
        // queue.  So we need to handle cancel.
        //

        if (Irp->Cancel) {
           PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation(Irp);

            IoReleaseCancelSpinLock(oldIrql);

            if (irpSp->Parameters.DeviceIoControl.IoControlCode ==
                   IOCTL_SERIAL_SET_QUEUE_SIZE) {
               //
               // We shoved the pointer to the memory into the
               // the type 3 buffer pointer which we KNOW we
               // never use.
               //

               ASSERT(irpSp->Parameters.DeviceIoControl.Type3InputBuffer);

               ExFreePool(irpSp->Parameters.DeviceIoControl.Type3InputBuffer);

               irpSp->Parameters.DeviceIoControl.Type3InputBuffer = NULL;
            }

            Irp->IoStatus.Status = STATUS_CANCELLED;

            SerialDump(
                SERIRPPATH,
                ("SERIAL: Complete Irp: %x\n",Irp)
                );
            SerialCompleteRequest(Extension, Irp, 0);

            return STATUS_CANCELLED;

        } else {


            Irp->IoStatus.Status = STATUS_PENDING;
            IoMarkIrpPending(Irp);

            InsertTailList(
                QueueToExamine,
                &Irp->Tail.Overlay.ListEntry
                );

            IoSetCancelRoutine(
                Irp,
                SerialCancelQueued
                );

            IoReleaseCancelSpinLock(oldIrql);

            return STATUS_PENDING;

        }

    }

}

VOID
SerialCancelQueued(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp
    )

/*++

Routine Description:

    This routine is used to cancel Irps that currently reside on
    a queue.

Arguments:

    DeviceObject - Pointer to the device object for this device

    Irp - Pointer to the IRP to be canceled.

Return Value:

    None.

--*/

{

    PSERIAL_DEVICE_EXTENSION extension = DeviceObject->DeviceExtension;
    PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation(Irp);

    SERIAL_LOCKED_PAGED_CODE();

    Irp->IoStatus.Status = STATUS_CANCELLED;
    Irp->IoStatus.Information = 0;

    RemoveEntryList(&Irp->Tail.Overlay.ListEntry);

    //
    // If this is a write irp then take the amount of characters
    // to write and subtract it from the count of characters to write.
    //

    if (irpSp->MajorFunction == IRP_MJ_WRITE) {

        extension->TotalCharsQueued -= irpSp->Parameters.Write.Length;

    } else if (irpSp->MajorFunction == IRP_MJ_DEVICE_CONTROL) {

        //
        // If it's an immediate then we need to decrement the
        // count of chars queued.  If it's a resize then we
        // need to deallocate the pool that we're passing on
        // to the "resizing" routine.
        //

        if ((irpSp->Parameters.DeviceIoControl.IoControlCode ==
             IOCTL_SERIAL_IMMEDIATE_CHAR) ||
            (irpSp->Parameters.DeviceIoControl.IoControlCode ==
             IOCTL_SERIAL_XOFF_COUNTER)) {

            extension->TotalCharsQueued--;

        } else if (irpSp->Parameters.DeviceIoControl.IoControlCode ==
                   IOCTL_SERIAL_SET_QUEUE_SIZE) {

            //
            // We shoved the pointer to the memory into the
            // the type 3 buffer pointer which we KNOW we
            // never use.
            //

            ASSERT(irpSp->Parameters.DeviceIoControl.Type3InputBuffer);

            ExFreePool(irpSp->Parameters.DeviceIoControl.Type3InputBuffer);

            irpSp->Parameters.DeviceIoControl.Type3InputBuffer = NULL;

        }

    }

    IoReleaseCancelSpinLock(Irp->CancelIrql);

    SerialDump(
        SERIRPPATH,
        ("SERIAL: Complete Irp: %x\n",Irp)
        );
    SerialCompleteRequest(extension, Irp, IO_SERIAL_INCREMENT);
}

NTSTATUS
SerialCompleteIfError(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp
    )

/*++

Routine Description:

    If the current irp is not an IOCTL_SERIAL_GET_COMMSTATUS request and
    there is an error and the application requested abort on errors,
    then cancel the irp.

Arguments:

    DeviceObject - Pointer to the device object for this device

    Irp - Pointer to the IRP to test.

Return Value:

    STATUS_SUCCESS or STATUS_CANCELLED.

--*/

{

    PSERIAL_DEVICE_EXTENSION extension = DeviceObject->DeviceExtension;

    NTSTATUS status = STATUS_SUCCESS;

    SERIAL_LOCKED_PAGED_CODE();

    if ((extension->HandFlow.ControlHandShake &
         SERIAL_ERROR_ABORT) && extension->ErrorWord) {

        PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation(Irp);

        //
        // There is a current error in the driver.  No requests should
        // come through except for the GET_COMMSTATUS.
        //

        if ((irpSp->MajorFunction != IRP_MJ_DEVICE_CONTROL) ||
            (irpSp->Parameters.DeviceIoControl.IoControlCode !=
             IOCTL_SERIAL_GET_COMMSTATUS)) {

            status = STATUS_CANCELLED;
            Irp->IoStatus.Status = STATUS_CANCELLED;
            Irp->IoStatus.Information = 0;

            SerialDump(
                SERIRPPATH,
                ("SERIAL: Complete Irp: %x\n",Irp)
                );
            SerialCompleteRequest(extension, Irp, 0);
        }

    }

    return status;

}

VOID
SerialFilterCancelQueued(IN PDEVICE_OBJECT PDevObj, IN PIRP PIrp)
/*++

Routine Description:

    This routine will be used cancel irps on the stalled queue.

Arguments:

    PDevObj - Pointer to the device object.

    PIrp - Pointer to the Irp to cancel

Return Value:

    None.

--*/
{
   PSERIAL_DEVICE_EXTENSION pDevExt = PDevObj->DeviceExtension;
   PIO_STACK_LOCATION pIrpSp = IoGetCurrentIrpStackLocation(PIrp);

   PIrp->IoStatus.Status = STATUS_CANCELLED;
   PIrp->IoStatus.Information = 0;

   RemoveEntryList(&PIrp->Tail.Overlay.ListEntry);

   IoReleaseCancelSpinLock(PIrp->CancelIrql);
}

VOID
SerialKillAllStalled(IN PDEVICE_OBJECT PDevObj)
{
   KIRQL cancelIrql;
   PDRIVER_CANCEL cancelRoutine;
   PSERIAL_DEVICE_EXTENSION pDevExt = PDevObj->DeviceExtension;

   IoAcquireCancelSpinLock(&cancelIrql);

   while (!IsListEmpty(&pDevExt->StalledIrpQueue)) {

      PIRP currentLastIrp = CONTAINING_RECORD(pDevExt->StalledIrpQueue.Blink,
                                              IRP, Tail.Overlay.ListEntry);

      RemoveEntryList(pDevExt->StalledIrpQueue.Blink);

      cancelRoutine = currentLastIrp->CancelRoutine;
      currentLastIrp->CancelIrql = cancelIrql;
      currentLastIrp->CancelRoutine = NULL;
      currentLastIrp->Cancel = TRUE;

      cancelRoutine(PDevObj, currentLastIrp);

      IoAcquireCancelSpinLock(&cancelIrql);
   }

   IoReleaseCancelSpinLock(cancelIrql);
}

NTSTATUS
SerialFilterIrps(IN PIRP PIrp, IN PSERIAL_DEVICE_EXTENSION PDevExt)
/*++

Routine Description:

    This routine will be used to approve irps for processing.
    If an irp is approved, success will be returned.  If not,
    the irp will be queued or rejected outright.  The IoStatus struct
    and return value will appropriately reflect the actions taken.

Arguments:

    PIrp - Pointer to the Irp to cancel

    PDevExt - Pointer to the device extension

Return Value:

    None.

--*/
{
   PIO_STACK_LOCATION pIrpStack;
   KIRQL oldIrqlFlags;

   pIrpStack = IoGetCurrentIrpStackLocation(PIrp);

   KeAcquireSpinLock(&PDevExt->FlagsLock, &oldIrqlFlags);

   if ((PDevExt->DevicePNPAccept == SERIAL_PNPACCEPT_OK)
       && ((PDevExt->Flags & SERIAL_FLAGS_BROKENHW) == 0)) {
      KeReleaseSpinLock(&PDevExt->FlagsLock, oldIrqlFlags);
      return STATUS_SUCCESS;
   }

   if ((PDevExt->DevicePNPAccept & SERIAL_PNPACCEPT_REMOVING)
       || (PDevExt->Flags & SERIAL_FLAGS_BROKENHW)
       || (PDevExt->DevicePNPAccept & SERIAL_PNPACCEPT_SURPRISE_REMOVING)) {

      KeReleaseSpinLock(&PDevExt->FlagsLock, oldIrqlFlags);

      //
      // Accept all PNP IRP's -- we assume PNP can synchronize itself
      //

      if (pIrpStack->MajorFunction == IRP_MJ_PNP) {
         return STATUS_SUCCESS;
      }

      PIrp->IoStatus.Status = STATUS_DELETE_PENDING;
      return STATUS_DELETE_PENDING;
   }

   if (PDevExt->DevicePNPAccept & SERIAL_PNPACCEPT_STOPPING) {
       KIRQL oldIrql;

       KeReleaseSpinLock(&PDevExt->FlagsLock, oldIrqlFlags);


      //
      // Accept all PNP IRP's -- we assume PNP can synchronize itself
      //

      if (pIrpStack->MajorFunction == IRP_MJ_PNP) {
         return STATUS_SUCCESS;
      }

      IoAcquireCancelSpinLock(&oldIrql);

      if (PIrp->Cancel) {
         IoReleaseCancelSpinLock(oldIrql);
         PIrp->IoStatus.Status = STATUS_CANCELLED;
         return STATUS_CANCELLED;
      } else {
         //
         // Mark the Irp as pending
         //

         PIrp->IoStatus.Status = STATUS_PENDING;
         IoMarkIrpPending(PIrp);

         //
         // Queue up the IRP
         //

         InsertTailList(&PDevExt->StalledIrpQueue,
                        &PIrp->Tail.Overlay.ListEntry);

         IoSetCancelRoutine(PIrp, SerialFilterCancelQueued);
         IoReleaseCancelSpinLock(oldIrql);
         return STATUS_PENDING;
      }
   }

   KeReleaseSpinLock(&PDevExt->FlagsLock, oldIrqlFlags);

   return STATUS_SUCCESS;
}


VOID
SerialUnstallIrps(IN PSERIAL_DEVICE_EXTENSION PDevExt)
/*++

Routine Description:

    This routine will be used to restart irps temporarily stalled on
    the stall queue due to a stop or some such nonsense.

Arguments:

    PDevExt - Pointer to the device extension

Return Value:

    None.

--*/
{
   PLIST_ENTRY pIrpLink;
   PIRP pIrp;
   PIO_STACK_LOCATION pIrpStack;
   PDEVICE_OBJECT pDevObj;
   PDRIVER_OBJECT pDrvObj;
   KIRQL oldIrql;

   SerialDump(SERTRACECALLS, ("SERIAL: Entering SerialUnstallIrps\n"));
   IoAcquireCancelSpinLock(&oldIrql);

   pIrpLink = PDevExt->StalledIrpQueue.Flink;

   while (pIrpLink != &PDevExt->StalledIrpQueue) {
      pIrp = CONTAINING_RECORD(pIrpLink, IRP, Tail.Overlay.ListEntry);
      RemoveEntryList(&pIrp->Tail.Overlay.ListEntry);

      pIrpStack = IoGetCurrentIrpStackLocation(pIrp);
      pDevObj = pIrpStack->DeviceObject;
      pDrvObj = pDevObj->DriverObject;
      IoSetCancelRoutine(pIrp, NULL);
      IoReleaseCancelSpinLock(oldIrql);

      SerialDump(SERPNPPOWER, ("SERIAL: Unstalling Irp 0x%x with 0x%x\n",
                               pIrp, pIrpStack->MajorFunction));

      pDrvObj->MajorFunction[pIrpStack->MajorFunction](pDevObj, pIrp);

      IoAcquireCancelSpinLock(&oldIrql);
      pIrpLink = PDevExt->StalledIrpQueue.Flink;
   }

   IoReleaseCancelSpinLock(oldIrql);

   SerialDump(SERTRACECALLS, ("SERIAL: Leaving SerialUnstallIrps\n"));
}


NTSTATUS
SerialIRPPrologue(IN PIRP PIrp, IN PSERIAL_DEVICE_EXTENSION PDevExt)
/*++

Routine Description:

   This function must be called at any IRP dispatch entry point.  It,
   with SerialIRPEpilogue(), keeps track of all pending IRP's for the given
   PDevObj.

Arguments:

   PDevObj - Pointer to the device object we are tracking pending IRP's for.

Return Value:

    Tentative status of the Irp.

--*/
{
   InterlockedIncrement(&PDevExt->PendingIRPCnt);

   return SerialFilterIrps(PIrp, PDevExt);
}



VOID
SerialIRPEpilogue(IN PSERIAL_DEVICE_EXTENSION PDevExt)
/*++

Routine Description:

   This function must be called at any IRP dispatch entry point.  It,
   with SerialIRPPrologue(), keeps track of all pending IRP's for the given
   PDevObj.

Arguments:

   PDevObj - Pointer to the device object we are tracking pending IRP's for.

Return Value:

   None.

--*/
{
   LONG pendingCnt;

   pendingCnt = InterlockedDecrement(&PDevExt->PendingIRPCnt);

   ASSERT(pendingCnt >= 0);

   if (pendingCnt == 0) {
      KeSetEvent(&PDevExt->PendingIRPEvent, IO_NO_INCREMENT, FALSE);
   }
}


BOOLEAN
SerialInsertQueueDpc(IN PRKDPC PDpc, IN PVOID Sarg1, IN PVOID Sarg2,
                     IN PSERIAL_DEVICE_EXTENSION PDevExt)
/*++

Routine Description:

   This function must be called to queue DPC's for the serial driver.

Arguments:

   PDpc thru Sarg2  - Standard args to KeInsertQueueDpc()

   PDevExt - Pointer to the device extension for the device that needs to
             queue a DPC

Return Value:

   Kicks up return value from KeInsertQueueDpc()

--*/
{
   BOOLEAN queued;

   InterlockedIncrement(&PDevExt->DpcCount);

   queued = KeInsertQueueDpc(PDpc, Sarg1, Sarg2);

   if (!queued) {
      ULONG pendingCnt;

      pendingCnt = InterlockedDecrement(&PDevExt->DpcCount);

      if (pendingCnt == 0) {
         KeSetEvent(&PDevExt->PendingIRPEvent, IO_NO_INCREMENT, FALSE);
      }
   }

#if 0 // DBG
   if (queued) {
      int i;

      for (i = 0; i < MAX_DPC_QUEUE; i++) {
                     if (PDevExt->DpcQueued[i].Dpc == PDpc) {
                        PDevExt->DpcQueued[i].QueuedCount++;
                        break;
                     }
      }

      ASSERT(i < MAX_DPC_QUEUE);
   }
#endif

   return queued;
}


BOOLEAN
SerialSetTimer(IN PKTIMER Timer, IN LARGE_INTEGER DueTime,
               IN PKDPC Dpc OPTIONAL, IN PSERIAL_DEVICE_EXTENSION PDevExt)
/*++

Routine Description:

   This function must be called to set timers for the serial driver.

Arguments:

   Timer - pointer to timer dispatcher object

   DueTime - time at which the timer should expire

   Dpc - option Dpc

   PDevExt - Pointer to the device extension for the device that needs to
             set a timer

Return Value:

   Kicks up return value from KeSetTimer()

--*/
{
   BOOLEAN set;

   InterlockedIncrement(&PDevExt->DpcCount);

   set = KeSetTimer(Timer, DueTime, Dpc);

   if (set) {
      InterlockedDecrement(&PDevExt->DpcCount);
   }

#if 0 // DBG
   if (set) {
      int i;

      for (i = 0; i < MAX_DPC_QUEUE; i++) {
                     if (PDevExt->DpcQueued[i].Dpc == Dpc) {
                        PDevExt->DpcQueued[i].QueuedCount++;
                        break;
                     }
      }

      ASSERT(i < MAX_DPC_QUEUE);
   }
#endif

   return set;
}


BOOLEAN
SerialCancelTimer(IN PKTIMER Timer, IN PSERIAL_DEVICE_EXTENSION PDevExt)
/*++

Routine Description:

   This function must be called to cancel timers for the serial driver.

Arguments:

   Timer - pointer to timer dispatcher object

   PDevExt - Pointer to the device extension for the device that needs to
             set a timer

Return Value:

   True if timer was cancelled

--*/
{
   BOOLEAN cancelled;

   cancelled = KeCancelTimer(Timer);

   if (cancelled) {
      SerialDpcEpilogue(PDevExt, Timer->Dpc);
   }

   return cancelled;
}


VOID
SerialDpcEpilogue(IN PSERIAL_DEVICE_EXTENSION PDevExt, PKDPC PDpc)
/*++

Routine Description:

   This function must be called at the end of every dpc function.

Arguments:

   PDevObj - Pointer to the device object we are tracking dpc's for.

Return Value:

   None.

--*/
{
   LONG pendingCnt;
#if 1 // !DBG
   UNREFERENCED_PARAMETER(PDpc);
#endif

   pendingCnt = InterlockedDecrement(&PDevExt->DpcCount);

   ASSERT(pendingCnt >= 0);

#if 0 //DBG
{
      int i;

      for (i = 0; i < MAX_DPC_QUEUE; i++) {
                     if (PDevExt->DpcQueued[i].Dpc == PDpc) {
                        PDevExt->DpcQueued[i].FlushCount++;

                        ASSERT(PDevExt->DpcQueued[i].QueuedCount >=
                               PDevExt->DpcQueued[i].FlushCount);
                        break;
                     }
      }

      ASSERT(i < MAX_DPC_QUEUE);
   }
#endif

   if (pendingCnt == 0) {
      KeSetEvent(&PDevExt->PendingDpcEvent, IO_NO_INCREMENT, FALSE);
   }
}



VOID
SerialUnlockPages(IN PKDPC PDpc, IN PVOID PDeferredContext,
                  IN PVOID PSysContext1, IN PVOID PSysContext2)
/*++

Routine Description:

   This function is a DPC routine queue from the ISR if he released the
   last lock on pending DPC's.

Arguments:

   PDpdc, PSysContext1, PSysContext2 -- not used

   PDeferredContext -- Really the device extension

Return Value:

   None.

--*/
{
   PSERIAL_DEVICE_EXTENSION pDevExt
      = (PSERIAL_DEVICE_EXTENSION)PDeferredContext;

   UNREFERENCED_PARAMETER(PDpc);
   UNREFERENCED_PARAMETER(PSysContext1);
   UNREFERENCED_PARAMETER(PSysContext2);

   KeSetEvent(&pDevExt->PendingDpcEvent, IO_NO_INCREMENT, FALSE);
}


NTSTATUS
SerialIoCallDriver(PSERIAL_DEVICE_EXTENSION PDevExt, PDEVICE_OBJECT PDevObj,
                   PIRP PIrp)
/*++

Routine Description:

   This function must be called instead of IoCallDriver.  It automatically
   updates Irp tracking for PDevObj.

Arguments:
   PDevExt - Device extension attached to PDevObj

   PDevObj - Pointer to the device object we are tracking pending IRP's for.

   PIrp - Pointer to the Irp we are passing to the next driver.

Return Value:

   None.

--*/
{
   NTSTATUS status;

   status = IoCallDriver(PDevObj, PIrp);
   SerialIRPEpilogue(PDevExt);
   return status;
}



NTSTATUS
SerialPoCallDriver(PSERIAL_DEVICE_EXTENSION PDevExt, PDEVICE_OBJECT PDevObj,
                   PIRP PIrp)
/*++

Routine Description:

   This function must be called instead of PoCallDriver.  It automatically
   updates Irp tracking for PDevObj.

Arguments:
   PDevExt - Device extension attached to PDevObj

   PDevObj - Pointer to the device object we are tracking pending IRP's for.

   PIrp - Pointer to the Irp we are passing to the next driver.

Return Value:

   None.

--*/
{
   NTSTATUS status;

   status = PoCallDriver(PDevObj, PIrp);
   SerialIRPEpilogue(PDevExt);
   return status;
}


VOID
SerialLogError(
              IN PDRIVER_OBJECT DriverObject,
              IN PDEVICE_OBJECT DeviceObject OPTIONAL,
              IN PHYSICAL_ADDRESS P1,
              IN PHYSICAL_ADDRESS P2,
              IN ULONG SequenceNumber,
              IN UCHAR MajorFunctionCode,
              IN UCHAR RetryCount,
              IN ULONG UniqueErrorValue,
              IN NTSTATUS FinalStatus,
              IN NTSTATUS SpecificIOStatus,
              IN ULONG LengthOfInsert1,
              IN PWCHAR Insert1,
              IN ULONG LengthOfInsert2,
              IN PWCHAR Insert2
              )

/*++

Routine Description:

    This routine allocates an error log entry, copies the supplied data
    to it, and requests that it be written to the error log file.

Arguments:

    DriverObject - A pointer to the driver object for the device.

    DeviceObject - A pointer to the device object associated with the
    device that had the error, early in initialization, one may not
    yet exist.

    P1,P2 - If phyical addresses for the controller ports involved
    with the error are available, put them through as dump data.

    SequenceNumber - A ulong value that is unique to an IRP over the
    life of the irp in this driver - 0 generally means an error not
    associated with an irp.

    MajorFunctionCode - If there is an error associated with the irp,
    this is the major function code of that irp.

    RetryCount - The number of times a particular operation has been
    retried.

    UniqueErrorValue - A unique long word that identifies the particular
    call to this function.

    FinalStatus - The final status given to the irp that was associated
    with this error.  If this log entry is being made during one of
    the retries this value will be STATUS_SUCCESS.

    SpecificIOStatus - The IO status for a particular error.

    LengthOfInsert1 - The length in bytes (including the terminating NULL)
                      of the first insertion string.

    Insert1 - The first insertion string.

    LengthOfInsert2 - The length in bytes (including the terminating NULL)
                      of the second insertion string.  NOTE, there must
                      be a first insertion string for their to be
                      a second insertion string.

    Insert2 - The second insertion string.

Return Value:

    None.

--*/

{
   PIO_ERROR_LOG_PACKET errorLogEntry;

   PVOID objectToUse;
   SHORT dumpToAllocate = 0;
   PUCHAR ptrToFirstInsert;
   PUCHAR ptrToSecondInsert;

   PAGED_CODE();

   if (Insert1 == NULL) {
      LengthOfInsert1 = 0;
   }

   if (Insert2 == NULL) {
      LengthOfInsert2 = 0;
   }


   if (ARGUMENT_PRESENT(DeviceObject)) {

      objectToUse = DeviceObject;

   } else {

      objectToUse = DriverObject;

   }

   if (SerialMemCompare(
                       P1,
                       (ULONG)1,
                       SerialPhysicalZero,
                       (ULONG)1
                       ) != AddressesAreEqual) {

      dumpToAllocate = (SHORT)sizeof(PHYSICAL_ADDRESS);

   }

   if (SerialMemCompare(
                       P2,
                       (ULONG)1,
                       SerialPhysicalZero,
                       (ULONG)1
                       ) != AddressesAreEqual) {

      dumpToAllocate += (SHORT)sizeof(PHYSICAL_ADDRESS);

   }

   errorLogEntry = IoAllocateErrorLogEntry(
                                          objectToUse,
                                          (UCHAR)(sizeof(IO_ERROR_LOG_PACKET) +
                                                  dumpToAllocate
                                                  + LengthOfInsert1 +
                                                  LengthOfInsert2)
                                          );

   if ( errorLogEntry != NULL ) {

      errorLogEntry->ErrorCode = SpecificIOStatus;
      errorLogEntry->SequenceNumber = SequenceNumber;
      errorLogEntry->MajorFunctionCode = MajorFunctionCode;
      errorLogEntry->RetryCount = RetryCount;
      errorLogEntry->UniqueErrorValue = UniqueErrorValue;
      errorLogEntry->FinalStatus = FinalStatus;
      errorLogEntry->DumpDataSize = dumpToAllocate;

      if (dumpToAllocate) {

         RtlCopyMemory(
                      &errorLogEntry->DumpData[0],
                      &P1,
                      sizeof(PHYSICAL_ADDRESS)
                      );

         if (dumpToAllocate > sizeof(PHYSICAL_ADDRESS)) {

            RtlCopyMemory(
                         ((PUCHAR)&errorLogEntry->DumpData[0])
                         +sizeof(PHYSICAL_ADDRESS),
                         &P2,
                         sizeof(PHYSICAL_ADDRESS)
                         );

            ptrToFirstInsert =
            ((PUCHAR)&errorLogEntry->DumpData[0])+(2*sizeof(PHYSICAL_ADDRESS));

         } else {

            ptrToFirstInsert =
            ((PUCHAR)&errorLogEntry->DumpData[0])+sizeof(PHYSICAL_ADDRESS);


         }

      } else {

         ptrToFirstInsert = (PUCHAR)&errorLogEntry->DumpData[0];

      }

      ptrToSecondInsert = ptrToFirstInsert + LengthOfInsert1;

      if (LengthOfInsert1) {

         errorLogEntry->NumberOfStrings = 1;
         errorLogEntry->StringOffset = (USHORT)(ptrToFirstInsert -
                                                (PUCHAR)errorLogEntry);
         RtlCopyMemory(
                      ptrToFirstInsert,
                      Insert1,
                      LengthOfInsert1
                      );

         if (LengthOfInsert2) {

            errorLogEntry->NumberOfStrings = 2;
            RtlCopyMemory(
                         ptrToSecondInsert,
                         Insert2,
                         LengthOfInsert2
                         );

         }

      }

      IoWriteErrorLogEntry(errorLogEntry);

   }

}

VOID
SerialMarkHardwareBroken(IN PSERIAL_DEVICE_EXTENSION PDevExt)
/*++

Routine Description:

   Marks a UART as broken.  This causes the driver stack to stop accepting
   requests and eventually be removed.

Arguments:
   PDevExt - Device extension attached to PDevObj

Return Value:

   None.

--*/
{
   PAGED_CODE();

   //
   // Mark as damaged goods
   //

   SerialSetFlags(PDevExt, SERIAL_FLAGS_BROKENHW);

   //
   // Write a log entry
   //

   SerialLogError(PDevExt->DriverObject, NULL, SerialPhysicalZero,
                  SerialPhysicalZero, 0, 0, 0, 88, STATUS_SUCCESS,
                  SERIAL_HARDWARE_FAILURE, PDevExt->DeviceName.Length
                  + sizeof(WCHAR), PDevExt->DeviceName.Buffer, 0, NULL);

   //
   // Invalidate the device
   //

   IoInvalidateDeviceState(PDevExt->Pdo);
}

VOID
SerialSetDeviceFlags(IN PSERIAL_DEVICE_EXTENSION PDevExt, OUT PULONG PFlags,
                     IN ULONG Value, IN BOOLEAN Set)
/*++

Routine Description:

   Sets flags in a value protected by the flags spinlock.  This is used
   to set values that would stop IRP's from being accepted.

Arguments:
   PDevExt - Device extension attached to PDevObj

   PFlags - Pointer to the flags variable that needs changing

   Value - Value to modify flags variable with

   Set - TRUE if |= , FALSE if &=

Return Value:

   None.

--*/
{
   KIRQL oldIrql;

   KeAcquireSpinLock(&PDevExt->FlagsLock, &oldIrql);

   if (Set) {
      *PFlags |= Value;
   } else {
      *PFlags &= ~Value;
   }

   KeReleaseSpinLock(&PDevExt->FlagsLock, oldIrql);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\ser101\wmi.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    wmi.c

Abstract:

    This module contains the code that handles the wmi IRPs for the
    serial driver.

Environment:

    Kernel mode

Revision History :
--*/

#include "precomp.h"
#include <wmistr.h>

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGESRP0, SerialSystemControlDispatch)
#pragma alloc_text(PAGESRP0, SerialTossWMIRequest)
#pragma alloc_text(PAGESRP0, SerialSetWmiDataItem)
#pragma alloc_text(PAGESRP0, SerialSetWmiDataBlock)
#pragma alloc_text(PAGESRP0, SerialQueryWmiDataBlock)
#pragma alloc_text(PAGESRP0, SerialQueryWmiRegInfo)
#endif


NTSTATUS
SerialSystemControlDispatch(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp)
{
    SYSCTL_IRP_DISPOSITION disposition;
    NTSTATUS status;
    PSERIAL_DEVICE_EXTENSION pDevExt
      = (PSERIAL_DEVICE_EXTENSION)DeviceObject->DeviceExtension;

    PAGED_CODE();

    status = WmiSystemControl(   &pDevExt->WmiLibInfo,
                                 DeviceObject, 
                                 Irp,
                                 &disposition);
    switch(disposition)
    {
        case IrpProcessed:
        {
            //
            // This irp has been processed and may be completed or pending.
            break;
        }
        
        case IrpNotCompleted:
        {
            //
            // This irp has not been completed, but has been fully processed.
            // we will complete it now
            IoCompleteRequest(Irp, IO_NO_INCREMENT);                
            break;
        }
        
        case IrpForward:
        case IrpNotWmi:
        {
            //
            // This irp is either not a WMI irp or is a WMI irp targetted
            // at a device lower in the stack.
            IoSkipCurrentIrpStackLocation(Irp);
            status = IoCallDriver(pDevExt->LowerDeviceObject, Irp);
            break;
        }
                                    
        default:
        {
            //
            // We really should never get here, but if we do just forward....
            ASSERT(FALSE);
            IoSkipCurrentIrpStackLocation(Irp);
            status = IoCallDriver(pDevExt->LowerDeviceObject, Irp);
            break;
        }        
    }
    
    return(status);

}


#define WMI_SERIAL_PORT_NAME_INFORMATION 0
#define WMI_SERIAL_PORT_COMM_INFORMATION 1
#define WMI_SERIAL_PORT_HW_INFORMATION   2
#define WMI_SERIAL_PORT_PERF_INFORMATION 3
#define WMI_SERIAL_PORT_PROPERTIES       4

GUID SerialPortNameGuid = SERIAL_PORT_WMI_NAME_GUID;
GUID SerialPortCommGuid = SERIAL_PORT_WMI_COMM_GUID;
GUID SerialPortHWGuid = SERIAL_PORT_WMI_HW_GUID;
GUID SerailPortPerfGuid = SERIAL_PORT_WMI_PERF_GUID;
GUID SerialPortPropertiesGuid = SERIAL_PORT_WMI_PROPERTIES_GUID;

WMIGUIDREGINFO SerialWmiGuidList[SERIAL_WMI_GUID_LIST_SIZE] =
{
    { &SerialPortNameGuid, 1, 0 },
    { &SerialPortCommGuid, 1, 0 },
    { &SerialPortHWGuid, 1, 0 },
    { &SerailPortPerfGuid, 1, 0 },
    { &SerialPortPropertiesGuid, 1, 0}
};

//
// WMI System Call back functions
//



NTSTATUS
SerialTossWMIRequest(IN PDEVICE_OBJECT PDevObj, IN PIRP PIrp,
                     IN ULONG GuidIndex)
{
   PSERIAL_DEVICE_EXTENSION pDevExt;
   NTSTATUS status;

   PAGED_CODE();

   pDevExt = (PSERIAL_DEVICE_EXTENSION)PDevObj->DeviceExtension;

   switch (GuidIndex) {

   case WMI_SERIAL_PORT_NAME_INFORMATION:
   case WMI_SERIAL_PORT_COMM_INFORMATION:
   case WMI_SERIAL_PORT_HW_INFORMATION:
   case WMI_SERIAL_PORT_PERF_INFORMATION:
   case WMI_SERIAL_PORT_PROPERTIES:
      status = STATUS_INVALID_DEVICE_REQUEST;
      break;

   default:
      status = STATUS_WMI_GUID_NOT_FOUND;
      break;
   }

   status = WmiCompleteRequest(PDevObj, PIrp,
                                 status, 0, IO_NO_INCREMENT);

   return status;
}


NTSTATUS
SerialSetWmiDataItem(IN PDEVICE_OBJECT PDevObj, IN PIRP PIrp,
                     IN ULONG GuidIndex, IN ULONG InstanceIndex,
                     IN ULONG DataItemId,
                     IN ULONG BufferSize, IN PUCHAR PBuffer)
/*++

Routine Description:

    This routine is a callback into the driver to set for the contents of
    a data block. When the driver has finished filling the data block it
    must call ClassWmiCompleteRequest to complete the irp. The driver can
    return STATUS_PENDING if the irp cannot be completed immediately.

Arguments:

    PDevObj is the device whose data block is being queried

    PIrp is the Irp that makes this request

    GuidIndex is the index into the list of guids provided when the
        device registered

    InstanceIndex is the index that denotes which instance of the data block
        is being queried.
            
    DataItemId has the id of the data item being set

    BufferSize has the size of the data item passed

    PBuffer has the new values for the data item


Return Value:

    status

--*/
{
   PAGED_CODE();

   //
   // Toss this request -- we don't support anything for it
   //

   return SerialTossWMIRequest(PDevObj, PIrp, GuidIndex);
}


NTSTATUS
SerialSetWmiDataBlock(IN PDEVICE_OBJECT PDevObj, IN PIRP PIrp,
                      IN ULONG GuidIndex, IN ULONG InstanceIndex,
                      IN ULONG BufferSize,
                      IN PUCHAR PBuffer)
/*++

Routine Description:

    This routine is a callback into the driver to set the contents of
    a data block. When the driver has finished filling the data block it
    must call ClassWmiCompleteRequest to complete the irp. The driver can
    return STATUS_PENDING if the irp cannot be completed immediately.

Arguments:

    PDevObj is the device whose data block is being queried

    PIrp is the Irp that makes this request

    GuidIndex is the index into the list of guids provided when the
        device registered

    InstanceIndex is the index that denotes which instance of the data block
        is being queried.
            
    BufferSize has the size of the data block passed

    PBuffer has the new values for the data block


Return Value:

    status

--*/
{
   PAGED_CODE();

   //
   // Toss this request -- we don't support anything for it
   //

   return SerialTossWMIRequest(PDevObj, PIrp, GuidIndex);
}


NTSTATUS
SerialQueryWmiDataBlock(IN PDEVICE_OBJECT PDevObj, IN PIRP PIrp,
                        IN ULONG GuidIndex, 
                        IN ULONG InstanceIndex,
                        IN ULONG InstanceCount,
                        IN OUT PULONG InstanceLengthArray,
                        IN ULONG OutBufferSize,
                        OUT PUCHAR PBuffer)
/*++

Routine Description:

    This routine is a callback into the driver to query for the contents of
    a data block. When the driver has finished filling the data block it
    must call ClassWmiCompleteRequest to complete the irp. The driver can
    return STATUS_PENDING if the irp cannot be completed immediately.

Arguments:

    PDevObj is the device whose data block is being queried

    PIrp is the Irp that makes this request

    GuidIndex is the index into the list of guids provided when the
        device registered

    InstanceIndex is the index that denotes which instance of the data block
        is being queried.
            
    InstanceCount is the number of instnaces expected to be returned for
        the data block.
            
    InstanceLengthArray is a pointer to an array of ULONG that returns the 
        lengths of each instance of the data block. If this is NULL then
        there was not enough space in the output buffer to fufill the request
        so the irp should be completed with the buffer needed.        
            
    BufferAvail on has the maximum size available to write the data
        block.

    PBuffer on return is filled with the returned data block


Return Value:

    status

--*/
{
    NTSTATUS status;
    ULONG size = 0;
    PSERIAL_DEVICE_EXTENSION pDevExt
       = (PSERIAL_DEVICE_EXTENSION)PDevObj->DeviceExtension;

    PAGED_CODE();

    switch (GuidIndex) {
    case WMI_SERIAL_PORT_NAME_INFORMATION:
       size = pDevExt->WmiIdentifier.Length;

       if (OutBufferSize < (size + sizeof(USHORT))) {
            size += sizeof(USHORT);
            status = STATUS_BUFFER_TOO_SMALL;
            break;
        }

       if (pDevExt->WmiIdentifier.Buffer == NULL) {
           status = STATUS_INSUFFICIENT_RESOURCES;
           break;
        }

        //
        // First, copy the string over containing our identifier
        //

        *(USHORT *)PBuffer = (USHORT)size;
        (UCHAR *)PBuffer += sizeof(USHORT);

        RtlCopyMemory(PBuffer, pDevExt->WmiIdentifier.Buffer, size);

        //
        // Increment total size to include the WORD containing our len
        //

        size += sizeof(USHORT);
        *InstanceLengthArray = size;
                
        status = STATUS_SUCCESS;

        break;

    case WMI_SERIAL_PORT_COMM_INFORMATION: 
       size = sizeof(SERIAL_WMI_COMM_DATA);

       if (OutBufferSize < size) {
          status = STATUS_BUFFER_TOO_SMALL;
          break;
        }

        *InstanceLengthArray = size;
        *(PSERIAL_WMI_COMM_DATA)PBuffer = pDevExt->WmiCommData;

        status = STATUS_SUCCESS;

        break;

    case WMI_SERIAL_PORT_HW_INFORMATION:
       size = sizeof(SERIAL_WMI_HW_DATA);

       if (OutBufferSize < size) {
          status = STATUS_BUFFER_TOO_SMALL;
          break;
       }

       *InstanceLengthArray = size;
       *(PSERIAL_WMI_HW_DATA)PBuffer = pDevExt->WmiHwData;

       status = STATUS_SUCCESS;

       break;

    case WMI_SERIAL_PORT_PERF_INFORMATION: 
      size = sizeof(SERIAL_WMI_PERF_DATA);

      if (OutBufferSize < size) {
         status = STATUS_BUFFER_TOO_SMALL;
         break;
      }

      *InstanceLengthArray = size;
      *(PSERIAL_WMI_PERF_DATA)PBuffer = pDevExt->WmiPerfData;

      status = STATUS_SUCCESS;

      break;

    case WMI_SERIAL_PORT_PROPERTIES: 
      size = sizeof(SERIAL_COMMPROP) + sizeof(ULONG);

      if (OutBufferSize < size) {
         status = STATUS_BUFFER_TOO_SMALL;
         break;
      }

      *InstanceLengthArray = size;
      SerialGetProperties(
                pDevExt,
                (PSERIAL_COMMPROP)PBuffer
                );
	
      *((PULONG)(((PSERIAL_COMMPROP)PBuffer)->ProvChar)) = 0;

      status = STATUS_SUCCESS;

      break;

    default:
        status = STATUS_WMI_GUID_NOT_FOUND;
        break;
    }

    status = WmiCompleteRequest( PDevObj, PIrp,
                                  status, size, IO_NO_INCREMENT);

    return status;
}


NTSTATUS
SerialQueryWmiRegInfo(IN PDEVICE_OBJECT PDevObj, OUT PULONG PRegFlags,
                      OUT PUNICODE_STRING PInstanceName,
                      OUT PUNICODE_STRING *PRegistryPath,
                      OUT PUNICODE_STRING MofResourceName,
                      OUT PDEVICE_OBJECT *Pdo)
                                                  
/*++

Routine Description:

    This routine is a callback into the driver to retrieve information about
    the guids being registered. 
            
    Implementations of this routine may be in paged memory

Arguments:

    DeviceObject is the device whose registration information is needed

    *RegFlags returns with a set of flags that describe all of the guids being
        registered for this device. If the device wants enable and disable
        collection callbacks before receiving queries for the registered
        guids then it should return the WMIREG_FLAG_EXPENSIVE flag. Also the
        returned flags may specify WMIREG_FLAG_INSTANCE_PDO in which case
        the instance name is determined from the PDO associated with the
        device object. Note that the PDO must have an associated devnode. If
        WMIREG_FLAG_INSTANCE_PDO is not set then Name must return a unique
        name for the device. These flags are ORed into the flags specified
        by the GUIDREGINFO for each guid.               

    InstanceName returns with the instance name for the guids if
        WMIREG_FLAG_INSTANCE_PDO is not set in the returned *RegFlags. The
        caller will call ExFreePool with the buffer returned.

    *RegistryPath returns with the registry path of the driver. This is 
        required
                
    *MofResourceName returns with the name of the MOF resource attached to
        the binary file. If the driver does not have a mof resource attached
        then this can be returned as NULL.
                
    *Pdo returns with the device object for the PDO associated with this
        device if the WMIREG_FLAG_INSTANCE_PDO flag is retured in 
        *RegFlags.

Return Value:

    status

--*/
{
   PSERIAL_DEVICE_EXTENSION pDevExt
       = (PSERIAL_DEVICE_EXTENSION)PDevObj->DeviceExtension;
   
   PAGED_CODE();

   *PRegFlags = WMIREG_FLAG_INSTANCE_PDO;
   *PRegistryPath = &SerialGlobals.RegistryPath;
   *Pdo = pDevExt->Pdo;

   return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\ser71051\comtstd.c ===
#include <windows.h>
#include <stdio.h>

#define NUM     128

DWORD main(int argc, char *argv[], char *envp[])
{
CHAR chBuffer[128];
CHAR RdBuffer[128];
DWORD UseBaud = 9600;
WORD i;
HANDLE hCommPort;
DCB    dcb;
BOOL   bRc;
DWORD  dwNumWritten,dwNumRead,dwErrors;

envp;

if (argc > 1)
    {
    sscanf(argv[1],"%d",&UseBaud);
    }


printf("\n\n *** COMM TEST START ***\n\n");

printf("Opening the comm port for read write\n");

hCommPort = CreateFile(
                       "COM1",
                       GENERIC_READ|GENERIC_WRITE,
                       0, // exclusive
                       NULL, // sec attr
                       OPEN_EXISTING,
                       0,             // no attributes
                       NULL);         // no template

if (hCommPort == (HANDLE)-1)
    {
    printf("FAIL: OpenComm failed rc: %lx\n",hCommPort);
    return -1;
    }


printf("Opening the comm port for read write: SUCCESS hCommPort=%lx\n",hCommPort);

printf("Setting the line characteristics 9600,8,N,1 on comm \n");

dcb.DCBlength   = sizeof(DCB);
// dcb.DCBversion  = 0x0002; BUG BUG in spec not in header


if (!GetCommState(hCommPort,&dcb))
    {
    printf("FAIL: Couldn't get the dcb: %d\n",GetLastError());
    return FALSE;
    }

dcb.BaudRate = UseBaud;

dcb.ByteSize = 8;
dcb.Parity   = NOPARITY;
dcb.StopBits = ONESTOPBIT;

bRc = SetCommState(hCommPort,&dcb);

if (!bRc)
    {
    printf("FAIL: cannot set the comm state rc:%lx\n",bRc);
    return -1;
    }

printf("Setting the line characteristics 9600,8,N,1 on comm: SUCCESS\n");


printf("Filling the buffer with the known chars \n");

for (i=0; i< NUM; i++)
    {
    //chBuffer[i] = 'a';
    chBuffer[i] = (CHAR)i;

    }

printf("Filling the buffer with the known chars : SUCCESS\n");

printf("Dumping the buffer before sending it to comm\n");

for (i=0; i< NUM; i++)
    {
    //printf("%c",RdBuffer[i]);
    printf(" %d ",chBuffer[i]);

    }

printf("\nDumping the buffer before sending it to comm SUCCESS\n");



printf("Filling the Rdbuffer with the known chars (0xFF) to makeit dirty\n");

for (i=0; i< NUM; i++)
    {
    RdBuffer[i] = 0xFF;
    }

printf("Filling the Rdbuffer with the known chars (0xFF): SUCCESS\n");

printf("Writting this buffer to the comm port\n");

bRc = WriteFile( hCommPort,
                 chBuffer,
                 NUM,
                &dwNumWritten,
                 NULL);

if (!bRc)
        {
        printf("FAIL: cannot Write To the comm port:%lx\n",bRc);
        return -1;
        }

printf("Writting this buffer to the comm port: SUCCESS rc:%lx, byteswritten:%lx\n",
                                                     bRc,dwNumWritten);


printf("Reading this buffer from the comm port\n");

bRc = ReadFile( hCommPort,
                RdBuffer,
                NUM,
               &dwNumRead,
                NULL);

if (!bRc)
        {
        printf("FAIL: cannot Read From the comm port:%lx\n",bRc);
        return -1;
        }

printf("Reading this buffer from the comm port: SUCCESS rc:%lx, bytesread:%lx\n",
                                                     bRc,dwNumRead);


printf("Dumping the Rdbuffer with the comm data\n");

for (i=0; i< NUM; i++)
    {
    //printf("%c",RdBuffer[i]);
    printf(" %d ",RdBuffer[i]);

    }

printf("\nDumping the Rdbuffer with the comm data: SUCCESS\n");


printf("Closing the comm port\n");


bRc = ClearCommError(hCommPort,&dwErrors,NULL);

printf("ClearCommError: rc= %lx and dwErrors=%lx\n",bRc,dwErrors);


bRc = CloseHandle(hCommPort);

if (!bRc)
    {
        printf("FAIL: cannot close the comm port:%lx\n",bRc);
        return -1;
    }


printf("\n\n*** COMM TEST OVER*** \n\n");
return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\ser71051\comtst2.c ===
#include <windows.h>
#include <stdio.h>

//#define COM_DEB     1

#define   NUM         128
#define   print       printf
#define   SETTINGS1       "COM1",9600,8,NOPARITY,ONESTOPBIT
#define   SETTINGS15       "COM1",9600,8,NOPARITY,ONE5STOPBITS
#define   SETTINGS2       "COM1",4800,8,NOPARITY,ONESTOPBIT
#define   SETTINGS3       "COM1",2400,8,NOPARITY,ONESTOPBIT
#define   SETTINGS4       "COM1",1200,8,NOPARITY,ONESTOPBIT


BOOL DoComIo(LPSTR lpCom,DWORD Baud,BYTE Size,BYTE Parity,BYTE Stop);
DWORD main(int argc, char *argv[], char *envp[])
{
BOOL bRc;

UNREFERENCED_PARAMETER(argc);
UNREFERENCED_PARAMETER(argv);
UNREFERENCED_PARAMETER(envp);
print("\n\n *** Doing COM TEST with [port=%s Baud=%d,Size=%d,Parity=%d,Stop=%d]***\n\n",
        SETTINGS1);
bRc = DoComIo(SETTINGS1);
if (!bRc) {
            print("\n\nCOM TEST FAILED********************************\n\n");
          }


print("\n\n *** Doing COM TEST with [port=%s Baud=%d,Size=%d,Parity=%d,Stop=%d]***\n\n",
        SETTINGS15);
bRc = DoComIo(SETTINGS15);
if (!bRc) {
            print("\n\nCOM TEST FAILED********************************\n\n");
          }

print("\n\n *** Doing COM TEST with [port=%s Baud=%d,Size=%d,Parity=%d,Stop=%d]***\n\n",
        SETTINGS2);
bRc = DoComIo(SETTINGS2);
if (!bRc) {
            print("\n\nCOM TEST FAILED********************************\n\n");
          }

print("\n\n *** Doing COM TEST with [port=%s Baud=%d,Size=%d,Parity=%d,Stop=%d]***\n\n",
        SETTINGS3);
bRc = DoComIo(SETTINGS3);
if (!bRc) {
            print("\n\nCOM TEST FAILED********************************\n\n");
          }

print("\n\n *** Doing COM TEST with [port=%s Baud=%d,Size=%d,Parity=%d,Stop=%d]***\n\n",
        SETTINGS4);
bRc = DoComIo(SETTINGS4);
if (!bRc) {
            print("\n\nCOM TEST FAILED********************************\n\n");
          }

return 0;
}


BOOL DoComIo(LPSTR lpCom,DWORD Baud,BYTE Size,BYTE Parity,BYTE Stop)
{

CHAR WrBuffer[NUM];
CHAR RdBuffer[NUM];
DWORD i;
HANDLE hCommPort;
DCB    dcb;
BOOL   bRc;
DWORD  dwNumWritten,dwNumRead,dwErrors;

print("\n\n *** COMM TEST START [port=%s,Baud=%d,Size=%d,Parity=%d,Stop=%d]***\n\n",
         lpCom,Baud,Size,Parity,Stop);

print("Opening the comm port for read write\n");

hCommPort = CreateFile(
                       lpCom,
                       GENERIC_READ|GENERIC_WRITE,
                       0, // exclusive
                       NULL, // sec attr
                       OPEN_EXISTING,
                       0,             // no attributes
                       NULL);         // no template

if (hCommPort == (HANDLE)-1)
    {
    print("FAIL: OpenComm failed rc: %lx\n",hCommPort);
    return FALSE;
    }


print("Opening the comm port for read write: SUCCESS hCommPort=%lx\n",hCommPort);

print("Setting the line characteristics on comm \n");

if(!GetCommState(
        hCommPort,
        &dcb
        )) {
    printf("Could not get the state of the comm port: %d\n",GetLastError());
    return FALSE;
}
dcb.DCBlength   = sizeof(DCB);
// dcb.DCBversion  = 0x0002;

dcb.BaudRate = Baud;
dcb.ByteSize = Size;
dcb.Parity   = Parity;
dcb.StopBits = Stop;

//dcb.RlsTimeout = 10000;   10sec
//dcb.CtsTimeout = 10000;   10sec
//dcb.DsrTimeout = 10000;   10sec

dcb.fBinary = 1;         // binary data xmit
dcb.fParity = 0;         // dont bother about parity
dcb.fOutxCtsFlow= 0;     // no cts flow control
dcb.fOutxDsrFlow= 0;     // no dsr flow control
dcb.fDtrControl = DTR_CONTROL_DISABLE;      // dont bother about dtr
dcb.fRtsControl = RTS_CONTROL_DISABLE;      // dont bother about dtr
dcb.fOutX =0;            //  disable xoff handling
dcb.fInX  =0;            //  disable xon handling
dcb.fErrorChar = 0;         // forget about parity char
dcb.fNull =  0;          // forget about the null striping
//dcb.fChEvt = 0;           forget about event char

bRc = SetCommState(hCommPort,&dcb);

if (!bRc)
    {
    print("FAIL: cannot set the comm state rc:%lx\n",bRc);
    bRc = CloseHandle(hCommPort);
          if (!bRc)
          {
           print("FAIL: cannot close the comm port:%lx\n",bRc);
          }
    return FALSE;
    }

print("Setting the line characteristics on comm: SUCCESS\n");


print("Filling the buffer with the known chars \n");

for (i=0; i< NUM; i++)
    {
    //WrBuffer[i] = 'a';
    WrBuffer[i] = (CHAR)i;

    }

print("Filling the buffer with the known chars : SUCCESS\n");


#ifdef COM_DEB
print("Dumping the buffer before sending it to comm\n");

for (i=0; i< NUM; i++)
    {
    //print("%c",RdBuffer[i]);
    print(" %d ",WrBuffer[i]);

    }

print("\nDumping the buffer before sending it to comm SUCCESS\n");
#endif

print("Filling the Rdbuffer with the known chars (0xFF) to makeit dirty\n");

for (i=0; i< NUM; i++)
    {
    RdBuffer[i] = (CHAR)'0xFF';
    }

print("Filling the Rdbuffer with the known chars (0xFF): SUCCESS\n");

print("Writting this buffer to the comm port\n");

bRc = WriteFile( hCommPort,
                 WrBuffer,
                 NUM,
                &dwNumWritten,
                 NULL);

if (!bRc)
        {
        print("FAIL: cannot Write To the comm port:%lx\n",bRc);
        bRc = CloseHandle(hCommPort);
          if (!bRc)
          {
           print("FAIL: cannot close the comm port:%lx\n",bRc);
          }
        return FALSE;
        }

print("Writting this buffer to the comm port: SUCCESS rc:%lx, byteswritten:%lx\n",
                                                     bRc,dwNumWritten);


print("Reading this buffer from the comm port\n");

bRc = ReadFile( hCommPort,
                RdBuffer,
                NUM,
               &dwNumRead,
                NULL);

if (!bRc)
        {
        print("FAIL: cannot Read From the comm port:%lx\n",bRc);
        bRc = CloseHandle(hCommPort);
          if (!bRc)
          {
           print("FAIL: cannot close the comm port:%lx\n",bRc);
          }
        return FALSE;
        }

print("Reading this buffer from the comm port: SUCCESS rc:%lx, bytesread:%lx\n",
                                                     bRc,dwNumRead);


#ifdef COM_DEB
print("Dumping the Rdbuffer with the comm data\n");

for (i=0; i< NUM; i++)
    {
    //print("%c",RdBuffer[i]);
    print(" %d ",RdBuffer[i]);

    }

print("\nDumping the Rdbuffer with the comm data: SUCCESS\n");
#endif

print("Comparing the rd and wr buffers\n");

for (i=0; i< NUM; i++)
    {
    if (RdBuffer[i] != WrBuffer[i])
        {
        print("FAIL: BufferMisMatch: RdBuffer[%d]=%lx,WrBuffer[%d]=%lx\n",
                      i,RdBuffer[i],i,WrBuffer[i]);
        bRc = CloseHandle(hCommPort);
          if (!bRc)
          {
           print("FAIL: cannot close the comm port:%lx\n",bRc);
          }
        return FALSE;
        }
    }

print("Comparing the rd and wr buffers: SUCCESS\n");


bRc = ClearCommError(hCommPort,&dwErrors,NULL);
print("ClearCommError: rc= %lx and dwErrors=%lx\n",bRc,dwErrors);

//bRc = PurgeComm(hCommPort,0);
print("BYPASS PurgeComm BUG (%lx,0) rc = %lx\n",hCommPort,bRc);


print("Closing the comm port\n");
bRc = CloseHandle(hCommPort);

if (!bRc)
    {
        print("FAIL: cannot close the comm port:%lx\n",bRc);
        return FALSE;
    }


print("\n\n*** COMM TEST OVER*** \n\n");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\ser71051\comtst.c ===
#include <windows.h>
#include <stdio.h>

#define NUM     128

DWORD main(int argc, char *argv[], char *envp[])
{
CHAR chBuffer[128];
CHAR RdBuffer[128];
DWORD UseBaud = 9600;
WORD i;
HANDLE hCommPort;
DCB    dcb;
BOOL   bRc;
DWORD  dwNumWritten,dwNumRead,dwErrors;

envp;

if (argc > 1)
    {
    sscanf(argv[1],"%d",&UseBaud);
    }


printf("\n\n *** COMM TEST START ***\n\n");

printf("Opening the comm port for read write\n");

hCommPort = CreateFile(
                       "COM1",
                       GENERIC_READ|GENERIC_WRITE,
                       0, // exclusive
                       NULL, // sec attr
                       OPEN_EXISTING,
                       0,             // no attributes
                       NULL);         // no template

if (hCommPort == (HANDLE)-1)
    {
    printf("FAIL: OpenComm failed rc: %lx\n",hCommPort);
    return -1;
    }


printf("Opening the comm port for read write: SUCCESS hCommPort=%lx\n",hCommPort);

printf("Setting the line characteristics 9600,8,N,1 on comm \n");

dcb.DCBlength   = sizeof(DCB);
// dcb.DCBversion  = 0x0002; BUG BUG in spec not in header


if (!GetCommState(hCommPort,&dcb))
    {
    printf("FAIL: Couldn't get the dcb: %d\n",GetLastError());
    return FALSE;
    }

dcb.BaudRate = UseBaud;

dcb.ByteSize = 8;
dcb.Parity   = NOPARITY;
dcb.StopBits = ONESTOPBIT;

bRc = SetCommState(hCommPort,&dcb);

if (!bRc)
    {
    printf("FAIL: cannot set the comm state rc:%lx\n",bRc);
    return -1;
    }

printf("Setting the line characteristics 9600,8,N,1 on comm: SUCCESS\n");


printf("Filling the buffer with the known chars \n");

for (i=0; i< NUM; i++)
    {
    //chBuffer[i] = 'a';
    chBuffer[i] = (CHAR)i;

    }

printf("Filling the buffer with the known chars : SUCCESS\n");

printf("Dumping the buffer before sending it to comm\n");

for (i=0; i< NUM; i++)
    {
    //printf("%c",RdBuffer[i]);
    printf(" %d ",chBuffer[i]);

    }

printf("\nDumping the buffer before sending it to comm SUCCESS\n");



printf("Filling the Rdbuffer with the known chars (0xFF) to makeit dirty\n");

for (i=0; i< NUM; i++)
    {
    RdBuffer[i] = 0xFF;
    }

printf("Filling the Rdbuffer with the known chars (0xFF): SUCCESS\n");

printf("Writting this buffer to the comm port\n");

bRc = WriteFile( hCommPort,
                 chBuffer,
                 NUM,
                &dwNumWritten,
                 NULL);

if (!bRc)
        {
        printf("FAIL: cannot Write To the comm port:%lx\n",bRc);
        return -1;
        }

printf("Writting this buffer to the comm port: SUCCESS rc:%lx, byteswritten:%lx\n",
                                                     bRc,dwNumWritten);


printf("Reading this buffer from the comm port\n");

bRc = ReadFile( hCommPort,
                RdBuffer,
                NUM,
               &dwNumRead,
                NULL);

if (!bRc)
        {
        printf("FAIL: cannot Read From the comm port:%lx\n",bRc);
        return -1;
        }

printf("Reading this buffer from the comm port: SUCCESS rc:%lx, bytesread:%lx\n",
                                                     bRc,dwNumRead);


printf("Dumping the Rdbuffer with the comm data\n");

for (i=0; i< NUM; i++)
    {
    //printf("%c",RdBuffer[i]);
    printf(" %d ",RdBuffer[i]);

    }

printf("\nDumping the Rdbuffer with the comm data: SUCCESS\n");


printf("Closing the comm port\n");


bRc = ClearCommError(hCommPort,&dwErrors,NULL);

printf("ClearCommError: rc= %lx and dwErrors=%lx\n",bRc,dwErrors);


bRc = CloseHandle(hCommPort);

if (!bRc)
    {
        printf("FAIL: cannot close the comm port:%lx\n",bRc);
        return -1;
    }


printf("\n\n*** COMM TEST OVER*** \n\n");
return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\ser101\waitmask.c ===
/*++

Copyright (c) 1991, 1992, 1993 Microsoft Corporation

Module Name:

    waitmask.c

Abstract:

    This module contains the code that is very specific to get/set/wait
    on event mask operations in the serial driver

Author:

    Anthony V. Ercolano 26-Sep-1991

Environment:

    Kernel mode

Revision History :

--*/

#include "precomp.h"


BOOLEAN
SerialGrabWaitFromIsr(
    IN PVOID Context
    );

BOOLEAN
SerialGiveWaitToIsr(
    IN PVOID Context
    );

BOOLEAN
SerialFinishOldWait(
    IN PVOID Context
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGESER,SerialStartMask)
#pragma alloc_text(PAGESER,SerialCancelWait)
#pragma alloc_text(PAGESER,SerialGrabWaitFromIsr)
#pragma alloc_text(PAGESER,SerialGiveWaitToIsr)
#pragma alloc_text(PAGESER,SerialFinishOldWait)
#endif


NTSTATUS
SerialStartMask(
    IN PSERIAL_DEVICE_EXTENSION Extension
    )

/*++

Routine Description:

    This routine is used to process the set mask and wait
    mask ioctls.  Calls to this routine are serialized by
    placing irps in the list under the protection of the
    cancel spin lock.

Arguments:

    Extension - A pointer to the serial device extension.

Return Value:

    Will return pending for everything put the first
    request that we actually process.  Even in that
    case it will return pending unless it can complete
    it right away.


--*/

{

    //
    // The current stack location.  This contains much of the
    // information we need to process this particular request.
    //
    PIO_STACK_LOCATION IrpSp;

    PIRP NewIrp;

    BOOLEAN SetFirstStatus = FALSE;
    NTSTATUS FirstStatus;

    SERIAL_LOCKED_PAGED_CODE();

    SerialDump(
        SERDIAG3,
        ("SERIAL: In SerialStartMask\n")
        );

    ASSERT(Extension->CurrentMaskIrp);

    do {

        SerialDump(
            SERDIAG4,
            ("SERIAL: STARMASK - CurrentMaskIrp: %x\n",Extension->CurrentMaskIrp)
            );
        IrpSp = IoGetCurrentIrpStackLocation(Extension->CurrentMaskIrp);

        ASSERT((IrpSp->Parameters.DeviceIoControl.IoControlCode ==
                IOCTL_SERIAL_WAIT_ON_MASK) ||
               (IrpSp->Parameters.DeviceIoControl.IoControlCode ==
                IOCTL_SERIAL_SET_WAIT_MASK));

        if (IrpSp->Parameters.DeviceIoControl.IoControlCode ==
            IOCTL_SERIAL_SET_WAIT_MASK) {

            SerialDump(
                SERDIAG4,
                ("SERIAL - %x is a SETMASK irp\n",Extension->CurrentMaskIrp)
                );

            //
            // Complete the old wait if there is one.
            //

            KeSynchronizeExecution(
                Extension->Interrupt,
                SerialFinishOldWait,
                Extension
                );

            //
            // Any current waits should be on its way to completion
            // at this point.  There certainly shouldn't be any
            // irp mask location.
            //

            ASSERT(!Extension->IrpMaskLocation);

            Extension->CurrentMaskIrp->IoStatus.Status = STATUS_SUCCESS;

            if (!SetFirstStatus) {

                SerialDump(
                    SERDIAG4,
                    ("SERIAL: %x was the first irp processed by this\n"
                     "------- invocation of startmask\n",Extension->CurrentMaskIrp)
                    );
                FirstStatus = STATUS_SUCCESS;
                SetFirstStatus = TRUE;

            }

            //
            // The following call will also cause the current
            // call to be completed.
            //

            SerialGetNextIrp(
                &Extension->CurrentMaskIrp,
                &Extension->MaskQueue,
                &NewIrp,
                TRUE,
                Extension
                );
            SerialDump(
                SERDIAG4,
                ("SERIAL: Perhaps another mask irp was found in the queue\n"
                 "------- %x/%x <- values should be the same\n",
                 Extension->CurrentMaskIrp,NewIrp)
                );


        } else {

            //
            // First make sure that we have a non-zero mask.
            // If the app queues a wait on a zero mask it can't
            // be statisfied so it makes no sense to start it.
            //

            if ((!Extension->IsrWaitMask) || (Extension->CurrentWaitIrp)) {

                SerialDump(
                    SERDIAG4,
                    ("SERIAL: WaitIrp is invalid\n"
                     "------- IsrWaitMask: %x\n"
                     "------- CurrentWaitIrp: %x\n",
                     Extension->IsrWaitMask,
                     Extension->CurrentWaitIrp)
                    );

                Extension->CurrentMaskIrp->IoStatus.Status = STATUS_INVALID_PARAMETER;

                if (!SetFirstStatus) {

                    SerialDump(
                        SERDIAG4,
                        ("SERIAL: %x was the first irp processed by this\n"
                         "------- invocation of startmask\n",Extension->CurrentMaskIrp)
                        );
                    FirstStatus = STATUS_INVALID_PARAMETER;
                    SetFirstStatus = TRUE;

                }

                SerialGetNextIrp(
                    &Extension->CurrentMaskIrp,
                    &Extension->MaskQueue,
                    &NewIrp,
                    TRUE,
                    Extension
                    );
                SerialDump(
                    SERDIAG4,
                    ("SERIAL: Perhaps another mask irp was found in the queue\n"
                     "------- %x/%x <- values should be the same\n",
                     Extension->CurrentMaskIrp,NewIrp)
                    );

            } else {

                KIRQL OldIrql;

                //
                // Make the current mask irp the current wait irp and
                // get a new current mask irp.  Note that when we get
                // the new current mask irp we DO NOT complete the
                // old current mask irp (which is now the current wait
                // irp.
                //
                // Then under the protection of the cancel spin lock
                // we check to see if the current wait irp needs to
                // be canceled
                //

                IoAcquireCancelSpinLock(&OldIrql);

                if (Extension->CurrentMaskIrp->Cancel) {

                    SerialDump(
                        SERDIAG4,
                        ("SERIAL: %x irp was already marked as cancelled\n",
                         Extension->CurrentMaskIrp)
                        );
                    IoReleaseCancelSpinLock(OldIrql);
                    Extension->CurrentMaskIrp->IoStatus.Status = STATUS_CANCELLED;

                    if (!SetFirstStatus) {

                        SerialDump(
                            SERDIAG4,
                            ("SERIAL: %x was the first irp processed by this\n"
                             "------- invocation of startmask\n",Extension->CurrentMaskIrp)
                            );
                        FirstStatus = STATUS_CANCELLED;
                        SetFirstStatus = TRUE;

                    }

                    SerialGetNextIrp(
                        &Extension->CurrentMaskIrp,
                        &Extension->MaskQueue,
                        &NewIrp,
                        TRUE,
                        Extension
                        );
                    SerialDump(
                        SERDIAG4,
                        ("SERIAL: Perhaps another mask irp was found in the queue\n"
                         "------- %x/%x <- values should be the same\n",
                         Extension->CurrentMaskIrp,NewIrp)
                        );

                } else {

                    SerialDump(
                        SERDIAG4,
                        ("SERIAL: %x will become the current wait irp\n",
                         Extension->CurrentMaskIrp)
                        );
                    if (!SetFirstStatus) {

                        SerialDump(
                            SERDIAG4,
                            ("SERIAL: %x was the first irp processed by this\n"
                             "------- invocation of startmask\n",Extension->CurrentMaskIrp)
                            );
                        FirstStatus = STATUS_PENDING;
                        SetFirstStatus = TRUE;

                        //
                        // If we haven't already set a first status
                        // then there is a chance that this packet
                        // was never on the queue.  We should mark
                        // it as pending.
                        //

                        IoMarkIrpPending(Extension->CurrentMaskIrp);

                    }

                    //
                    // There should never be a mask location when
                    // there isn't a current wait irp.  At this point
                    // there shouldn't be a current wait irp also.
                    //

                    ASSERT(!Extension->IrpMaskLocation);
                    ASSERT(!Extension->CurrentWaitIrp);

                    Extension->CurrentWaitIrp = Extension->CurrentMaskIrp;
                    SERIAL_INIT_REFERENCE(Extension->CurrentWaitIrp);
                    IoSetCancelRoutine(
                        Extension->CurrentWaitIrp,
                        SerialCancelWait
                        );

                    //
                    // Since the cancel routine has a reference to
                    // the irp we need to update the reference
                    // count.
                    //

                    SERIAL_SET_REFERENCE(
                        Extension->CurrentWaitIrp,
                        SERIAL_REF_CANCEL
                        );

                    KeSynchronizeExecution(
                        Extension->Interrupt,
                        SerialGiveWaitToIsr,
                        Extension
                        );

                    //
                    // Since it isn't really the mask irp anymore,
                    // null out that pointer.
                    //

                    Extension->CurrentMaskIrp = NULL;

                    //
                    // This will release the cancel spinlock for us
                    //

                    SerialGetNextIrpLocked(
                        &Extension->CurrentMaskIrp,
                        &Extension->MaskQueue,
                        &NewIrp,
                        FALSE,
                        Extension,
                        OldIrql
                        );
                    SerialDump(
                        SERDIAG4,
                        ("SERIAL: Perhaps another mask irp was found in the queue\n"
                         "------- %x/%x <- values should be the same\n",
                         Extension->CurrentMaskIrp,NewIrp)
                        );

                }

            }

        }

    } while (NewIrp);

    return FirstStatus;

}

BOOLEAN
SerialGrabWaitFromIsr(
    IN PVOID Context
    )

/*++

Routine Description:

    This routine will check to see if the ISR still knows about
    a wait irp by checking to see if the IrpMaskLocation is non-null.
    If it is then it will zero the Irpmasklocation (which in effect
    grabs the irp away from the isr).  This routine is only called
    buy the cancel code for the wait.

    NOTE: This is called by KeSynchronizeExecution.

Arguments:

    Context - A pointer to the device extension

Return Value:

    Always FALSE.

--*/

{

    PSERIAL_DEVICE_EXTENSION Extension = Context;
    SERIAL_LOCKED_PAGED_CODE();

    SerialDump(
        SERDIAG3,
        ("SERIAL: In SerialGrabWaitFromIsr\n")
        );

    if (Extension->IrpMaskLocation) {

        SerialDump(
            SERDIAG4,
            ("SERIAL: The isr still owns the irp %x, mask location is %x\n"
             "------- and system buffer is %x\n",
             Extension->CurrentWaitIrp,Extension->IrpMaskLocation,
             Extension->CurrentWaitIrp->AssociatedIrp.SystemBuffer)
            );

        //
        // The isr still "owns" the irp.
        //

        *Extension->IrpMaskLocation = 0;
        Extension->IrpMaskLocation = NULL;

        Extension->CurrentWaitIrp->IoStatus.Information = sizeof(ULONG);

        //
        // Since the isr no longer references the irp we need to
        // decrement the reference count.
        //

        SERIAL_CLEAR_REFERENCE(
            Extension->CurrentWaitIrp,
            SERIAL_REF_ISR
            );

    }

    return FALSE;
}

BOOLEAN
SerialGiveWaitToIsr(
    IN PVOID Context
    )

/*++

Routine Description:

    This routine simply sets a variable in the device extension
    so that the isr knows that we have a wait irp.

    NOTE: This is called by KeSynchronizeExecution.

    NOTE: This routine assumes that it is called with the
          cancel spinlock held.

Arguments:

    Context - Simply a pointer to the device extension.

Return Value:

    Always FALSE.

--*/

{

    PSERIAL_DEVICE_EXTENSION Extension = Context;
    SERIAL_LOCKED_PAGED_CODE();

    SerialDump(
        SERDIAG3,
        ("SERIAL: In SerialGiveWaitToIsr\n")
        );
    //
    // There certainly shouldn't be a current mask location at
    // this point since we have a new current wait irp.
    //

    ASSERT(!Extension->IrpMaskLocation);

    //
    // The isr may or may not actually reference this irp.  It
    // won't if the wait can be satisfied immediately.  However,
    // since it will then go through the normal completion sequence,
    // we need to have an incremented reference count anyway.
    //

    SERIAL_SET_REFERENCE(
        Extension->CurrentWaitIrp,
        SERIAL_REF_ISR
        );

    if (!Extension->HistoryMask) {

        SerialDump(
            SERDIAG4,
            ("SERIAL: No events occured prior to the wait call\n")
            );

        //
        // Although this wait might not be for empty transmit
        // queue, it doesn't hurt anything to set it to false.
        //

        Extension->EmptiedTransmit = FALSE;

        //
        // Record where the "completion mask" should be set.
        //

        Extension->IrpMaskLocation =
            Extension->CurrentWaitIrp->AssociatedIrp.SystemBuffer;
        SerialDump(
            SERDIAG4,
            ("SERIAL: The isr owns the irp %x, mask location is %x\n"
             "------- and system buffer is %x\n",
             Extension->CurrentWaitIrp,Extension->IrpMaskLocation,
             Extension->CurrentWaitIrp->AssociatedIrp.SystemBuffer)
            );

    } else {

        SerialDump(
            SERDIAG4,
            ("SERIAL: %x occurred prior to the wait - starting the\n"
             "------- completion code for %x\n",
             Extension->HistoryMask,Extension->CurrentWaitIrp)
            );
        *((ULONG *)Extension->CurrentWaitIrp->AssociatedIrp.SystemBuffer) =
            Extension->HistoryMask;
        Extension->HistoryMask = 0;
        Extension->CurrentWaitIrp->IoStatus.Information = sizeof(ULONG);
        Extension->CurrentWaitIrp->IoStatus.Status = STATUS_SUCCESS;

        SerialInsertQueueDpc(
            &Extension->CommWaitDpc,
            NULL,
            NULL,
            Extension
            );

    }

    return FALSE;
}

BOOLEAN
SerialFinishOldWait(
    IN PVOID Context
    )

/*++

Routine Description:

    This routine will check to see if the ISR still knows about
    a wait irp by checking to see if the Irpmasklocation is non-null.
    If it is then it will zero the Irpmasklocation (which in effect
    grabs the irp away from the isr).  This routine is only called
    buy the cancel code for the wait.

    NOTE: This is called by KeSynchronizeExecution.

Arguments:

    Context - A pointer to the device extension

Return Value:

    Always FALSE.

--*/

{

    PSERIAL_DEVICE_EXTENSION Extension = Context;
    SERIAL_LOCKED_PAGED_CODE();

    SerialDump(
        SERDIAG3,
        ("SERIAL: In SerialFinishOldWait\n")
        );
    if (Extension->IrpMaskLocation) {

        SerialDump(
            SERDIAG4,
            ("SERIAL: The isr still owns the irp %x, mask location is %x\n"
             "------- and system buffer is %x\n",
             Extension->CurrentWaitIrp,Extension->IrpMaskLocation,
             Extension->CurrentWaitIrp->AssociatedIrp.SystemBuffer)
            );
        //
        // The isr still "owns" the irp.
        //

        *Extension->IrpMaskLocation = 0;
        Extension->IrpMaskLocation = NULL;

        Extension->CurrentWaitIrp->IoStatus.Information = sizeof(ULONG);

        //
        // We don't decrement the reference since the completion routine
        // will do that.
        //

        SerialInsertQueueDpc(
            &Extension->CommWaitDpc,
            NULL,
            NULL,
            Extension
            );

    }

    //
    // Don't wipe out any historical data we are still interested in.
    //

    Extension->HistoryMask &= *((ULONG *)Extension->CurrentMaskIrp->
                                            AssociatedIrp.SystemBuffer);

    Extension->IsrWaitMask = *((ULONG *)Extension->CurrentMaskIrp->
                                            AssociatedIrp.SystemBuffer);
    SerialDump(
        SERDIAG4,
        ("SERIAL: Set mask location of %x, in irp %x, with system buffer of %x\n",
         Extension->IrpMaskLocation,
         Extension->CurrentMaskIrp,Extension->CurrentMaskIrp->AssociatedIrp.SystemBuffer)
        );
    return FALSE;
}

VOID
SerialCancelWait(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is used to cancel a irp that is waiting on
    a comm event.

Arguments:

    DeviceObject - Pointer to the device object for this device

    Irp - Pointer to the IRP for the current request

Return Value:

    None.

--*/

{

    PSERIAL_DEVICE_EXTENSION Extension = DeviceObject->DeviceExtension;
    SERIAL_LOCKED_PAGED_CODE();

    SerialDump(
        SERDIAG3,
        ("SERIAL: In SerialCancelWait\n")
        );

    SerialDump(
        SERDIAG4,
        ("SERIAL: Canceling wait for irp %x\n",Extension->CurrentWaitIrp)
        );
    SerialTryToCompleteCurrent(
        Extension,
        SerialGrabWaitFromIsr,
        Irp->CancelIrql,
        STATUS_CANCELLED,
        &Extension->CurrentWaitIrp,
        NULL,
        NULL,
        NULL,
        NULL,
        NULL,
        SERIAL_REF_CANCEL
        );

}

VOID
SerialCompleteWait(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemContext1,
    IN PVOID SystemContext2
    )

{

    PSERIAL_DEVICE_EXTENSION Extension = DeferredContext;
    KIRQL OldIrql;


    SerialDump(SERTRACECALLS, ("SERIAL: SerialCompleteWait\n"));

    SerialDump(
        SERDIAG3,
        ("SERIAL: In SerialCompleteWait\n")
        );
    UNREFERENCED_PARAMETER(SystemContext1);
    UNREFERENCED_PARAMETER(SystemContext2);

    IoAcquireCancelSpinLock(&OldIrql);

    SerialDump(
        SERDIAG4,
        ("SERIAL: Completing wait for irp %x\n",Extension->CurrentWaitIrp)
        );
    SerialTryToCompleteCurrent(
        Extension,
        NULL,
        OldIrql,
        STATUS_SUCCESS,
        &Extension->CurrentWaitIrp,
        NULL,
        NULL,
        NULL,
        NULL,
        NULL,
        SERIAL_REF_ISR
        );

    SerialDpcEpilogue(Extension, Dpc);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\ser101\write.c ===
/*++

Copyright (c) 1991, 1992, 1993 - 1997 Microsoft Corporation

Module Name:

    write.c

Abstract:

    This module contains the code that is very specific to write
    operations in the serial driver

Author:

    Anthony V. Ercolano 26-Sep-1991

Environment:

    Kernel mode

--*/

#include "precomp.h"


BOOLEAN
SerialGiveWriteToIsr(
    IN PVOID Context
    );

VOID
SerialCancelCurrentWrite(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp
    );

BOOLEAN
SerialGrabWriteFromIsr(
    IN PVOID Context
    );

BOOLEAN
SerialGrabXoffFromIsr(
    IN PVOID Context
    );

VOID
SerialCancelCurrentXoff(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp
    );

BOOLEAN
SerialGiveXoffToIsr(
    IN PVOID Context
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGESER,SerialProcessEmptyTransmit)
#pragma alloc_text(PAGESER,SerialWrite)
#pragma alloc_text(PAGESER,SerialStartWrite)
#pragma alloc_text(PAGESER,SerialGetNextWrite)
#pragma alloc_text(PAGESER,SerialGiveWriteToIsr)
#pragma alloc_text(PAGESER,SerialCancelCurrentWrite)
#pragma alloc_text(PAGESER,SerialGrabWriteFromIsr)
#pragma alloc_text(PAGESER,SerialGrabXoffFromIsr)
#pragma alloc_text(PAGESER,SerialCancelCurrentXoff)
#pragma alloc_text(PAGESER,SerialGiveXoffToIsr)
#endif


NTSTATUS
SerialWrite(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This is the dispatch routine for write.  It validates the parameters
    for the write request and if all is ok then it places the request
    on the work queue.

Arguments:

    DeviceObject - Pointer to the device object for this device

    Irp - Pointer to the IRP for the current request

Return Value:

    If the io is zero length then it will return STATUS_SUCCESS,
    otherwise this routine will return STATUS_PENDING.

--*/

{

    PSERIAL_DEVICE_EXTENSION Extension = DeviceObject->DeviceExtension;
    NTSTATUS status;

    SERIAL_LOCKED_PAGED_CODE();

    SerialDump(SERTRACECALLS, ("Entering SerialWrite\n"));

    if ((status = SerialIRPPrologue(Irp, Extension)) != STATUS_SUCCESS) {
      SerialCompleteRequest(Extension, Irp, IO_NO_INCREMENT);
      SerialDump(SERTRACECALLS, ("Leaving SerialWrite (1)\n"));
      return status;
   }

    SerialDump(
        SERIRPPATH,
        ("SERIAL: Dispatch entry for: %x\n",Irp)
        );
    if (SerialCompleteIfError(
            DeviceObject,
            Irp
            ) != STATUS_SUCCESS) {

       SerialDump(SERTRACECALLS, ("Leaving SerialWrite (2)\n"));

        return STATUS_CANCELLED;

    }

    Irp->IoStatus.Information = 0L;

    //
    // Quick check for a zero length write.  If it is zero length
    // then we are already done!
    //

    if (IoGetCurrentIrpStackLocation(Irp)->Parameters.Write.Length) {

        //
        // Well it looks like we actually have to do some
        // work.  Put the write on the queue so that we can
        // process it when our previous writes are done.
        //


       SerialDump(SERTRACECALLS, ("Leaving SerialWrite (3)\n"));

        return SerialStartOrQueue(
                   Extension,
                   Irp,
                   &Extension->WriteQueue,
                   &Extension->CurrentWriteIrp,
                   SerialStartWrite
                   );

    } else {

        Irp->IoStatus.Status = STATUS_SUCCESS;
        SerialDump(
            SERIRPPATH,
            ("SERIAL: Complete Irp: %x\n",Irp)
            );
        SerialCompleteRequest(Extension, Irp, 0);

        SerialDump(SERTRACECALLS, ("Leaving SerialWrite (4)\n"));
        return STATUS_SUCCESS;

    }

}

NTSTATUS
SerialStartWrite(
    IN PSERIAL_DEVICE_EXTENSION Extension
    )

/*++

Routine Description:

    This routine is used to start off any write.  It initializes
    the Iostatus fields of the irp.  It will set up any timers
    that are used to control the write.

Arguments:

    Extension - Points to the serial device extension

Return Value:

    This routine will return STATUS_PENDING for all writes
    other than those that we find are cancelled.

--*/

{

    PIRP NewIrp;
    KIRQL OldIrql;
    LARGE_INTEGER TotalTime;
    BOOLEAN UseATimer;
    SERIAL_TIMEOUTS Timeouts;
    BOOLEAN SetFirstStatus = FALSE;
    NTSTATUS FirstStatus;

    SERIAL_LOCKED_PAGED_CODE();

    SerialDump(SERTRACECALLS, ("SERIAL: SerialStartWrite\n"));

    do {

        //
        // If there is an xoff counter then complete it.
        //

        IoAcquireCancelSpinLock(&OldIrql);

        //
        // We see if there is a actually an Xoff counter irp.
        //
        // If there is, we put the write irp back on the head
        // of the write list.  We then kill the xoff counter.
        // The xoff counter killing code will actually make the
        // xoff counter back into the current write irp, and
        // in the course of completing the xoff (which is now
        // the current write) we will restart this irp.
        //

        if (Extension->CurrentXoffIrp) {

            if (SERIAL_REFERENCE_COUNT(Extension->CurrentXoffIrp)) {

                //
                // The reference count is non-zero.  This implies that
                // the xoff irp has not made it through the completion
                // path yet.  We will increment the reference count
                // and attempt to complete it ourseleves.
                //

                SERIAL_SET_REFERENCE(
                    Extension->CurrentXoffIrp,
                    SERIAL_REF_XOFF_REF
                    );

                //
                // The following call will actually release the
                // cancel spin lock.
                //

                SerialTryToCompleteCurrent(
                    Extension,
                    SerialGrabXoffFromIsr,
                    OldIrql,
                    STATUS_SERIAL_MORE_WRITES,
                    &Extension->CurrentXoffIrp,
                    NULL,
                    NULL,
                    &Extension->XoffCountTimer,
                    NULL,
                    NULL,
                    SERIAL_REF_XOFF_REF
                    );

            } else {

                //
                // The irp is well on its way to being finished.
                // We can let the regular completion code do the
                // work.  Just release the spin lock.
                //

                IoReleaseCancelSpinLock(OldIrql);

            }

        } else {

            IoReleaseCancelSpinLock(OldIrql);

        }

        UseATimer = FALSE;

        //
        // Calculate the timeout value needed for the
        // request.  Note that the values stored in the
        // timeout record are in milliseconds.  Note that
        // if the timeout values are zero then we won't start
        // the timer.
        //

        KeAcquireSpinLock(
            &Extension->ControlLock,
            &OldIrql
            );

        Timeouts = Extension->Timeouts;

        KeReleaseSpinLock(
            &Extension->ControlLock,
            OldIrql
            );

        if (Timeouts.WriteTotalTimeoutConstant ||
            Timeouts.WriteTotalTimeoutMultiplier) {

            PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation(
                                           Extension->CurrentWriteIrp
                                           );
            UseATimer = TRUE;

            //
            // We have some timer values to calculate.
            //
            // Take care, we might have an xoff counter masquerading
            // as a write.
            //

            TotalTime.QuadPart =
                ((LONGLONG)((UInt32x32To64(
                                 (IrpSp->MajorFunction == IRP_MJ_WRITE)?
                                     (IrpSp->Parameters.Write.Length):
                                     (1),
                                 Timeouts.WriteTotalTimeoutMultiplier
                                 )
                                 + Timeouts.WriteTotalTimeoutConstant)))
                * -10000;

        }

        //
        // The irp may be going to the isr shortly.  Now
        // is a good time to initialize its reference counts.
        //

        SERIAL_INIT_REFERENCE(Extension->CurrentWriteIrp);

        //
        // We need to see if this irp should be canceled.
        //

        IoAcquireCancelSpinLock(&OldIrql);
        if (Extension->CurrentWriteIrp->Cancel) {

            IoReleaseCancelSpinLock(OldIrql);
            Extension->CurrentWriteIrp->IoStatus.Status = STATUS_CANCELLED;

            if (!SetFirstStatus) {

                FirstStatus = STATUS_CANCELLED;
                SetFirstStatus = TRUE;

            }

        } else {

            if (!SetFirstStatus) {

                //
                // If we haven't set our first status, then
                // this is the only irp that could have possibly
                // not been on the queue.  (It could have been
                // on the queue if this routine is being invoked
                // from the completion routine.)  Since this
                // irp might never have been on the queue we
                // should mark it as pending.
                //

                IoMarkIrpPending(Extension->CurrentWriteIrp);
                SetFirstStatus = TRUE;
                FirstStatus = STATUS_PENDING;

            }

            //
            // We give the irp to to the isr to write out.
            // We set a cancel routine that knows how to
            // grab the current write away from the isr.
            //
            // Since the cancel routine has an implicit reference
            // to this irp up the reference count.
            //

            IoSetCancelRoutine(
                Extension->CurrentWriteIrp,
                SerialCancelCurrentWrite
                );

            SERIAL_SET_REFERENCE(
                Extension->CurrentWriteIrp,
                SERIAL_REF_CANCEL
                );

            if (UseATimer) {

                SerialSetTimer(
                    &Extension->WriteRequestTotalTimer,
                    TotalTime,
                    &Extension->TotalWriteTimeoutDpc,
                    Extension
                    );

                //
                // This timer now has a reference to the irp.
                //

                SERIAL_SET_REFERENCE(
                    Extension->CurrentWriteIrp,
                    SERIAL_REF_TOTAL_TIMER
                    );
            }

            KeSynchronizeExecution(
                Extension->Interrupt,
                SerialGiveWriteToIsr,
                Extension
                );

            IoReleaseCancelSpinLock(OldIrql);
            break;

        }

        //
        // Well the write was canceled before we could start it up.
        // Try to get another.
        //

        SerialGetNextWrite(
            &Extension->CurrentWriteIrp,
            &Extension->WriteQueue,
            &NewIrp,
            TRUE,
            Extension
            );

    } while (NewIrp);

    return FirstStatus;

}

VOID
SerialGetNextWrite(
    IN PIRP *CurrentOpIrp,
    IN PLIST_ENTRY QueueToProcess,
    IN PIRP *NewIrp,
    IN BOOLEAN CompleteCurrent,
    PSERIAL_DEVICE_EXTENSION Extension
    )

/*++

Routine Description:

    This routine completes the old write as well as getting
    a pointer to the next write.

    The reason that we have have pointers to the current write
    queue as well as the current write irp is so that this
    routine may be used in the common completion code for
    read and write.

Arguments:

    CurrentOpIrp - Pointer to the pointer that points to the
                   current write irp.

    QueueToProcess - Pointer to the write queue.

    NewIrp - A pointer to a pointer to the irp that will be the
             current irp.  Note that this could end up pointing
             to a null pointer.  This does NOT necessaryly mean
             that there is no current write.  What could occur
             is that while the cancel lock is held the write
             queue ended up being empty, but as soon as we release
             the cancel spin lock a new irp came in from
             SerialStartWrite.

    CompleteCurrent - Flag indicates whether the CurrentOpIrp should
                      be completed.

Return Value:

    None.

--*/

{

//    PSERIAL_DEVICE_EXTENSION Extension = CONTAINING_RECORD(
//                                             QueueToProcess,
 //                                            SERIAL_DEVICE_EXTENSION,
 //                                            WriteQueue
//                                             );

   SERIAL_LOCKED_PAGED_CODE();

   SerialDump(SERTRACECALLS, ("SERIAL: SerialGetNextWrite\n"));


    do {


        //
        // We could be completing a flush.
        //

        if (IoGetCurrentIrpStackLocation(*CurrentOpIrp)->MajorFunction
            == IRP_MJ_WRITE) {

            KIRQL OldIrql;

            ASSERT(Extension->TotalCharsQueued >=
                   (IoGetCurrentIrpStackLocation(*CurrentOpIrp)
                    ->Parameters.Write.Length));

            IoAcquireCancelSpinLock(&OldIrql);
            Extension->TotalCharsQueued -=
                IoGetCurrentIrpStackLocation(*CurrentOpIrp)
                ->Parameters.Write.Length;
            IoReleaseCancelSpinLock(OldIrql);

        } else if (IoGetCurrentIrpStackLocation(*CurrentOpIrp)->MajorFunction
                   == IRP_MJ_DEVICE_CONTROL) {

            KIRQL OldIrql;
            PIRP Irp;
            PSERIAL_XOFF_COUNTER Xc;

            IoAcquireCancelSpinLock(&OldIrql);

            Irp = *CurrentOpIrp;
            Xc = Irp->AssociatedIrp.SystemBuffer;

            //
            // We should never have a xoff counter when we
            // get to this point.
            //

            ASSERT(!Extension->CurrentXoffIrp);

            //
            // We absolutely shouldn't have a cancel routine
            // at this point.
            //

            ASSERT(!Irp->CancelRoutine);

            //
            // This could only be a xoff counter masquerading as
            // a write irp.
            //

            Extension->TotalCharsQueued--;

            //
            // Check to see of the xoff irp has been set with success.
            // This means that the write completed normally.  If that
            // is the case, and it hasn't been set to cancel in the
            // meanwhile, then go on and make it the CurrentXoffIrp.
            //

            if (Irp->IoStatus.Status != STATUS_SUCCESS) {

                //
                // Oh well, we can just finish it off.
                //
                NOTHING;

            } else if (Irp->Cancel) {

                Irp->IoStatus.Status = STATUS_CANCELLED;

            } else {

                //
                // Give it a new cancel routine, and increment the
                // reference count because the cancel routine has
                // a reference to it.
                //

                IoSetCancelRoutine(
                    Irp,
                    SerialCancelCurrentXoff
                    );

                SERIAL_SET_REFERENCE(
                    Irp,
                    SERIAL_REF_CANCEL
                    );

                //
                // We don't want to complete the current irp now.  This
                // will now get completed by the Xoff counter code.
                //

                CompleteCurrent = FALSE;

                //
                // Give the counter to the isr.
                //

                Extension->CurrentXoffIrp = Irp;
                KeSynchronizeExecution(
                    Extension->Interrupt,
                    SerialGiveXoffToIsr,
                    Extension
                    );

                //
                // Start the timer for the counter and increment
                // the reference count since the timer has a
                // reference to the irp.
                //

                if (Xc->Timeout) {

                    LARGE_INTEGER delta;

                    delta.QuadPart = -((LONGLONG)UInt32x32To64(
                                                     1000,
                                                     Xc->Timeout
                                                     ));

                    SerialSetTimer(
                        &Extension->XoffCountTimer,
                        delta,
                        &Extension->XoffCountTimeoutDpc,
                        Extension

                        );

                    SERIAL_SET_REFERENCE(
                        Irp,
                        SERIAL_REF_TOTAL_TIMER
                        );

                }

            }

            IoReleaseCancelSpinLock(OldIrql);

        }

        //
        // Note that the following call will (probably) also cause
        // the current irp to be completed.
        //

        SerialGetNextIrp(
            CurrentOpIrp,
            QueueToProcess,
            NewIrp,
            CompleteCurrent,
            Extension
            );

        if (!*NewIrp) {

            KIRQL OldIrql;

            IoAcquireCancelSpinLock(&OldIrql);
            KeSynchronizeExecution(
                Extension->Interrupt,
                SerialProcessEmptyTransmit,
                Extension
                );
            IoReleaseCancelSpinLock(OldIrql);

            break;

        } else if (IoGetCurrentIrpStackLocation(*NewIrp)->MajorFunction
                   == IRP_MJ_FLUSH_BUFFERS) {

            //
            // If we encounter a flush request we just want to get
            // the next irp and complete the flush.
            //
            // Note that if NewIrp is non-null then it is also
            // equal to CurrentWriteIrp.
            //


            ASSERT((*NewIrp) == (*CurrentOpIrp));
            (*NewIrp)->IoStatus.Status = STATUS_SUCCESS;

        } else {

            break;

        }

    } while (TRUE);

}

VOID
SerialCompleteWrite(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemContext1,
    IN PVOID SystemContext2
    )

/*++

Routine Description:

    This routine is merely used to complete any write.  It
    assumes that the status and the information fields of
    the irp are already correctly filled in.

Arguments:

    Dpc - Not Used.

    DeferredContext - Really points to the device extension.

    SystemContext1 - Not Used.

    SystemContext2 - Not Used.

Return Value:

    None.

--*/

{

    PSERIAL_DEVICE_EXTENSION Extension = DeferredContext;
    KIRQL OldIrql;

    UNREFERENCED_PARAMETER(SystemContext1);
    UNREFERENCED_PARAMETER(SystemContext2);

    SerialDump(SERTRACECALLS, ("SERIAL: SerialCompleteWrite\n"));

    IoAcquireCancelSpinLock(&OldIrql);

    SerialTryToCompleteCurrent(
        Extension,
        NULL,
        OldIrql,
        STATUS_SUCCESS,
        &Extension->CurrentWriteIrp,
        &Extension->WriteQueue,
        NULL,
        &Extension->WriteRequestTotalTimer,
        SerialStartWrite,
        SerialGetNextWrite,
        SERIAL_REF_ISR
        );

    SerialDpcEpilogue(Extension, Dpc);

}

BOOLEAN
SerialProcessEmptyTransmit(
    IN PVOID Context
    )

/*++

Routine Description:

    This routine is used to determine if conditions are appropriate
    to satisfy a wait for transmit empty event, and if so to complete
    the irp that is waiting for that event.  It also call the code
    that checks to see if we should lower the RTS line if we are
    doing transmit toggling.

    NOTE: This routine is called by KeSynchronizeExecution.

    NOTE: This routine assumes that it is called with the cancel
          spinlock held.

Arguments:

    Context - Really a pointer to the device extension.

Return Value:

    This routine always returns FALSE.

--*/

{

    PSERIAL_DEVICE_EXTENSION Extension = Context;
    SERIAL_LOCKED_PAGED_CODE();

    if (Extension->IsrWaitMask && (Extension->IsrWaitMask & SERIAL_EV_TXEMPTY) &&
        Extension->EmptiedTransmit && (!Extension->TransmitImmediate) &&
        (!Extension->CurrentWriteIrp) && IsListEmpty(&Extension->WriteQueue)) {

        Extension->HistoryMask |= SERIAL_EV_TXEMPTY;
        if (Extension->IrpMaskLocation) {

            *Extension->IrpMaskLocation = Extension->HistoryMask;
            Extension->IrpMaskLocation = NULL;
            Extension->HistoryMask = 0;

            Extension->CurrentWaitIrp->IoStatus.Information = sizeof(ULONG);
            SerialInsertQueueDpc(
                &Extension->CommWaitDpc,
                NULL,
                NULL,
                Extension
                );

        }

        Extension->CountOfTryingToLowerRTS++;
        SerialPerhapsLowerRTS(Extension);

    }

    return FALSE;

}

BOOLEAN
SerialGiveWriteToIsr(
    IN PVOID Context
    )

/*++

Routine Description:

    Try to start off the write by slipping it in behind
    a transmit immediate char, or if that isn't available
    and the transmit holding register is empty, "tickle"
    the UART into interrupting with a transmit buffer
    empty.

    NOTE: This routine is called by KeSynchronizeExecution.

    NOTE: This routine assumes that it is called with the
          cancel spin lock held.

Arguments:

    Context - Really a pointer to the device extension.

Return Value:

    This routine always returns FALSE.

--*/

{

    PSERIAL_DEVICE_EXTENSION Extension = Context;

    //
    // The current stack location.  This contains all of the
    // information we need to process this particular request.
    //
    PIO_STACK_LOCATION IrpSp;

    SERIAL_LOCKED_PAGED_CODE();

    IrpSp = IoGetCurrentIrpStackLocation(Extension->CurrentWriteIrp);

    //
    // We might have a xoff counter request masquerading as a
    // write.  The length of these requests will always be one
    // and we can get a pointer to the actual character from
    // the data supplied by the user.
    //

    if (IrpSp->MajorFunction == IRP_MJ_WRITE) {

        Extension->WriteLength = IrpSp->Parameters.Write.Length;
        Extension->WriteCurrentChar =
            Extension->CurrentWriteIrp->AssociatedIrp.SystemBuffer;

    } else {

        Extension->WriteLength = 1;
        Extension->WriteCurrentChar =
            ((PUCHAR)Extension->CurrentWriteIrp->AssociatedIrp.SystemBuffer) +
            FIELD_OFFSET(
                SERIAL_XOFF_COUNTER,
                XoffChar
                );

    }

    //
    // The isr now has a reference to the irp.
    //

    SERIAL_SET_REFERENCE(
        Extension->CurrentWriteIrp,
        SERIAL_REF_ISR
        );

    //
    // Check first to see if an immediate char is transmitting.
    // If it is then we'll just slip in behind it when its
    // done.
    //

    if (!Extension->TransmitImmediate) {

        //
        // If there is no immediate char transmitting then we
        // will "re-enable" the transmit holding register empty
        // interrupt.  The 8250 family of devices will always
        // signal a transmit holding register empty interrupt
        // *ANY* time this bit is set to one.  By doing things
        // this way we can simply use the normal interrupt code
        // to start off this write.
        //
        // We've been keeping track of whether the transmit holding
        // register is empty so it we only need to do this
        // if the register is empty.
        //

        if (Extension->HoldingEmpty) {

            DISABLE_ALL_INTERRUPTS(Extension->Controller);
            ENABLE_ALL_INTERRUPTS(Extension->Controller);

        }

    }

    //
    // The rts line may already be up from previous writes,
    // however, it won't take much additional time to turn
    // on the RTS line if we are doing transmit toggling.
    //

    if ((Extension->HandFlow.FlowReplace & SERIAL_RTS_MASK) ==
        SERIAL_TRANSMIT_TOGGLE) {

        SerialSetRTS(Extension);

    }

    return FALSE;

}

VOID
SerialCancelCurrentWrite(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp
    )

/*++

Routine Description:

    This routine is used to cancel the current write.

Arguments:

    DeviceObject - Pointer to the device object for this device

    Irp - Pointer to the IRP to be canceled.

Return Value:

    None.

--*/

{

    PSERIAL_DEVICE_EXTENSION Extension = DeviceObject->DeviceExtension;
    SERIAL_LOCKED_PAGED_CODE();

    SerialTryToCompleteCurrent(
        Extension,
        SerialGrabWriteFromIsr,
        Irp->CancelIrql,
        STATUS_CANCELLED,
        &Extension->CurrentWriteIrp,
        &Extension->WriteQueue,
        NULL,
        &Extension->WriteRequestTotalTimer,
        SerialStartWrite,
        SerialGetNextWrite,
        SERIAL_REF_CANCEL
        );

}

VOID
SerialWriteTimeout(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemContext1,
    IN PVOID SystemContext2
    )

/*++

Routine Description:

    This routine will try to timeout the current write.

Arguments:

    Dpc - Not Used.

    DeferredContext - Really points to the device extension.

    SystemContext1 - Not Used.

    SystemContext2 - Not Used.

Return Value:

    None.

--*/

{

    PSERIAL_DEVICE_EXTENSION Extension = DeferredContext;
    KIRQL OldIrql;

    UNREFERENCED_PARAMETER(SystemContext1);
    UNREFERENCED_PARAMETER(SystemContext2);

SerialDump(SERTRACECALLS, ("SERIAL: SerialWriteTimeout\n"));

    IoAcquireCancelSpinLock(&OldIrql);

    SerialTryToCompleteCurrent(
        Extension,
        SerialGrabWriteFromIsr,
        OldIrql,
        STATUS_TIMEOUT,
        &Extension->CurrentWriteIrp,
        &Extension->WriteQueue,
        NULL,
        &Extension->WriteRequestTotalTimer,
        SerialStartWrite,
        SerialGetNextWrite,
        SERIAL_REF_TOTAL_TIMER
        );

    SerialDpcEpilogue(Extension, Dpc);
}

BOOLEAN
SerialGrabWriteFromIsr(
    IN PVOID Context
    )

/*++

Routine Description:


    This routine is used to grab the current irp, which could be timing
    out or canceling, from the ISR

    NOTE: This routine is being called from KeSynchronizeExecution.

    NOTE: This routine assumes that the cancel spin lock is held
          when this routine is called.

Arguments:

    Context - Really a pointer to the device extension.

Return Value:

    Always false.

--*/

{

    PSERIAL_DEVICE_EXTENSION Extension = Context;
    SERIAL_LOCKED_PAGED_CODE();

    //
    // Check if the write length is non-zero.  If it is non-zero
    // then the ISR still owns the irp. We calculate the the number
    // of characters written and update the information field of the
    // irp with the characters written.  We then clear the write length
    // the isr sees.
    //

    if (Extension->WriteLength) {

        //
        // We could have an xoff counter masquerading as a
        // write irp.  If so, don't update the write length.
        //

        if (IoGetCurrentIrpStackLocation(Extension->CurrentWriteIrp)
            ->MajorFunction == IRP_MJ_WRITE) {

            Extension->CurrentWriteIrp->IoStatus.Information =
                IoGetCurrentIrpStackLocation(
                    Extension->CurrentWriteIrp
                    )->Parameters.Write.Length -
                Extension->WriteLength;

        } else {

            Extension->CurrentWriteIrp->IoStatus.Information = 0;

        }

        //
        // Since the isr no longer references this irp, we can
        // decrement it's reference count.
        //

        SERIAL_CLEAR_REFERENCE(
            Extension->CurrentWriteIrp,
            SERIAL_REF_ISR
            );

        Extension->WriteLength = 0;

    }

    return FALSE;

}

BOOLEAN
SerialGrabXoffFromIsr(
    IN PVOID Context
    )

/*++

Routine Description:

    This routine is used to grab an xoff counter irp from the
    isr when it is no longer masquerading as a write irp.  This
    routine is called by the cancel and timeout code for the
    xoff counter ioctl.


    NOTE: This routine is being called from KeSynchronizeExecution.

    NOTE: This routine assumes that the cancel spin lock is held
          when this routine is called.

Arguments:

    Context - Really a pointer to the device extension.

Return Value:

    Always false.

--*/

{

    PSERIAL_DEVICE_EXTENSION Extension = Context;
    SERIAL_LOCKED_PAGED_CODE();

    if (Extension->CountSinceXoff) {

        //
        // This is only non-zero when there actually is a Xoff ioctl
        // counting down.
        //

        Extension->CountSinceXoff = 0;

        //
        // We decrement the count since the isr no longer owns
        // the irp.
        //

        SERIAL_CLEAR_REFERENCE(
            Extension->CurrentXoffIrp,
            SERIAL_REF_ISR
            );

    }

    return FALSE;

}

VOID
SerialCompleteXoff(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemContext1,
    IN PVOID SystemContext2
    )

/*++

Routine Description:

    This routine is merely used to truely complete an xoff counter irp.  It
    assumes that the status and the information fields of the irp are
    already correctly filled in.

Arguments:

    Dpc - Not Used.

    DeferredContext - Really points to the device extension.

    SystemContext1 - Not Used.

    SystemContext2 - Not Used.

Return Value:

    None.

--*/

{

    PSERIAL_DEVICE_EXTENSION Extension = DeferredContext;
    KIRQL OldIrql;

    UNREFERENCED_PARAMETER(SystemContext1);
    UNREFERENCED_PARAMETER(SystemContext2);

    SerialDump(SERTRACECALLS, ("SERIAL: SerialCompleteXoff\n"));

    IoAcquireCancelSpinLock(&OldIrql);

    SerialTryToCompleteCurrent(
        Extension,
        NULL,
        OldIrql,
        STATUS_SUCCESS,
        &Extension->CurrentXoffIrp,
        NULL,
        NULL,
        &Extension->XoffCountTimer,
        NULL,
        NULL,
        SERIAL_REF_ISR
        );

    SerialDpcEpilogue(Extension, Dpc);

}

VOID
SerialTimeoutXoff(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemContext1,
    IN PVOID SystemContext2
    )

/*++

Routine Description:

    This routine is merely used to truely complete an xoff counter irp,
    if its timer has run out.

Arguments:

    Dpc - Not Used.

    DeferredContext - Really points to the device extension.

    SystemContext1 - Not Used.

    SystemContext2 - Not Used.

Return Value:

    None.

--*/

{

    PSERIAL_DEVICE_EXTENSION Extension = DeferredContext;
    KIRQL OldIrql;

    UNREFERENCED_PARAMETER(SystemContext1);
    UNREFERENCED_PARAMETER(SystemContext2);

    SerialDump(SERTRACECALLS, ("SERIAL: SerialTimeoutXoff\n"));

    IoAcquireCancelSpinLock(&OldIrql);

    SerialTryToCompleteCurrent(
        Extension,
        SerialGrabXoffFromIsr,
        OldIrql,
        STATUS_SERIAL_COUNTER_TIMEOUT,
        &Extension->CurrentXoffIrp,
        NULL,
        NULL,
        NULL,
        NULL,
        NULL,
        SERIAL_REF_TOTAL_TIMER
        );

    SerialDpcEpilogue(Extension, Dpc);

}

VOID
SerialCancelCurrentXoff(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp
    )

/*++

Routine Description:

    This routine is used to cancel the current write.

Arguments:

    DeviceObject - Pointer to the device object for this device

    Irp - Pointer to the IRP to be canceled.

Return Value:

    None.

--*/

{

    PSERIAL_DEVICE_EXTENSION Extension = DeviceObject->DeviceExtension;
    SERIAL_LOCKED_PAGED_CODE();

    SerialTryToCompleteCurrent(
        Extension,
        SerialGrabXoffFromIsr,
        Irp->CancelIrql,
        STATUS_CANCELLED,
        &Extension->CurrentXoffIrp,
        NULL,
        NULL,
        &Extension->XoffCountTimer,
        NULL,
        NULL,
        SERIAL_REF_CANCEL
        );

}

BOOLEAN
SerialGiveXoffToIsr(
    IN PVOID Context
    )

/*++

Routine Description:


    This routine starts off the xoff counter.  It merely
    has to set the xoff count and increment the reference
    count to denote that the isr has a reference to the irp.

    NOTE: This routine is called by KeSynchronizeExecution.

    NOTE: This routine assumes that it is called with the
          cancel spin lock held.

Arguments:

    Context - Really a pointer to the device extension.

Return Value:

    This routine always returns FALSE.

--*/

{

    PSERIAL_DEVICE_EXTENSION Extension = Context;

    //
    // The current stack location.  This contains all of the
    // information we need to process this particular request.
    //

    PSERIAL_XOFF_COUNTER Xc =
        Extension->CurrentXoffIrp->AssociatedIrp.SystemBuffer;

    SERIAL_LOCKED_PAGED_CODE();

    ASSERT(Extension->CurrentXoffIrp);
    Extension->CountSinceXoff = Xc->Counter;

    //
    // The isr now has a reference to the irp.
    //

    SERIAL_SET_REFERENCE(
        Extension->CurrentXoffIrp,
        SERIAL_REF_ISR
        );

    return FALSE;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\serial\ser71051\initunlo.c ===
/*++

Copyright (c) 1991, 1992, 1993 - 1997 Microsoft Corporation

Module Name:

    initunlo.c

Abstract:

    This module contains the code that is very specific to initialization
    and unload operations in the serial driver

Author:

    Anthony V. Ercolano 26-Sep-1991

Environment:

    Kernel mode

--*/

#include "precomp.h"

//
// This is the actual definition of SerialDebugLevel.
// Note that it is only defined if this is a "debug"
// build.
//
#if DBG
extern ULONG SerialDebugLevel = 0;
#endif

//
// All our global variables except DebugLevel stashed in one
// little package
//
SERIAL_GLOBALS SerialGlobals;

static const PHYSICAL_ADDRESS SerialPhysicalZero = {0};

//
// We use this to query into the registry as to whether we
// should break at driver entry.
//

SERIAL_FIRMWARE_DATA    driverDefaults;

//
// This is exported from the kernel.  It is used to point
// to the address that the kernel debugger is using.
//
extern PUCHAR *KdComPortInUse;

//
// INIT - only needed during init and then can be disposed
// PAGESRP0 - always paged / never locked
// PAGESER - must be locked when a device is open, else paged
//
//
// INIT is used for DriverEntry() specific code
//
// PAGESRP0 is used for code that is not often called and has nothing
// to do with I/O performance.  An example, IRP_MJ_PNP/IRP_MN_START_DEVICE
// support functions
//
// PAGESER is used for code that needs to be locked after an open for both
// performance and IRQL reasons.
//

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT,DriverEntry)

#pragma alloc_text(PAGESRP0, SerialInitMultiPort)
#pragma alloc_text(PAGESRP0, SerialInitOneController)
#pragma alloc_text(PAGESRP0, SerialInitController)
#pragma alloc_text(PAGESRP0, SerialFindInitController)
#pragma alloc_text(PAGESRP0, SerialGetMappedAddress)
#pragma alloc_text(PAGESRP0, SerialRemoveDevObj)
#pragma alloc_text(PAGESRP0, SerialReleaseResources)
#pragma alloc_text(PAGESRP0, SerialUnload)
#pragma alloc_text(PAGESRP0, SerialMemCompare)


//
// PAGESER handled is keyed off of SerialReset, so SerialReset
// must remain in PAGESER for things to work properly
//

#pragma alloc_text(PAGESER, SerialGetDivisorFromBaud)
#pragma alloc_text(PAGESER, SerialReset)
#endif


NTSTATUS
DriverEntry(
           IN PDRIVER_OBJECT DriverObject,
           IN PUNICODE_STRING RegistryPath
           )

/*++

Routine Description:

    The entry point that the system point calls to initialize
    any driver.

    This routine will gather the configuration information,
    report resource usage, attempt to initialize all serial
    devices, connect to interrupts for ports.  If the above
    goes reasonably well it will fill in the dispatch points,
    reset the serial devices and then return to the system.

Arguments:

    DriverObject - Just what it says,  really of little use
    to the driver itself, it is something that the IO system
    cares more about.

    PathToRegistry - points to the entry for this driver
    in the current control set of the registry.

Return Value:

    Always STATUS_SUCCESS

--*/

{
   RTL_QUERY_REGISTRY_TABLE jensenTable[2] = {0};
   UNICODE_STRING jensenData;
   UNICODE_STRING jensenValue;
   BOOLEAN jensenDetected;
   PUCHAR jensenBuffer;

   //
   // Lock the paged code in their frames
   //

   PVOID lockPtr = MmLockPagableCodeSection(SerialReset);

   PAGED_CODE();


   ASSERT(SerialGlobals.PAGESER_Handle == NULL);
#if DBG
   SerialGlobals.PAGESER_Count = 0;
#endif
   SerialGlobals.PAGESER_Handle = lockPtr;

   SerialGlobals.RegistryPath.MaximumLength = RegistryPath->MaximumLength;
   SerialGlobals.RegistryPath.Length = RegistryPath->Length;
   SerialGlobals.RegistryPath.Buffer
      = ExAllocatePool(PagedPool, SerialGlobals.RegistryPath.MaximumLength);

   if (SerialGlobals.RegistryPath.Buffer == NULL) {
      MmUnlockPagableImageSection(lockPtr);
      return STATUS_INSUFFICIENT_RESOURCES;
   }

   RtlZeroMemory(SerialGlobals.RegistryPath.Buffer,
                 SerialGlobals.RegistryPath.MaximumLength);
   RtlMoveMemory(SerialGlobals.RegistryPath.Buffer,
                 RegistryPath->Buffer, RegistryPath->Length);

   //
   // Initialize all our globals
   //

   InitializeListHead(&SerialGlobals.AllDevObjs);

   //
   // Call to find out default values to use for all the devices that the
   // driver controls, including whether or not to break on entry.
   //

   SerialGetConfigDefaults(&driverDefaults, RegistryPath);

#if DBG
   //
   // Set global debug output level
   //
   SerialDebugLevel = driverDefaults.DebugLevel;
#endif

   //
   // Break on entry if requested via registry
   //

   if (driverDefaults.ShouldBreakOnEntry) {
      DbgBreakPoint();
   }


   //
   // Just dump out how big the extension is.
   //

   SerialDump(SERDIAG1, ("SERIAL: The number of bytes in the extension is: %d"
                         "\n", sizeof(SERIAL_DEVICE_EXTENSION)));


   //
   // Initialize the Driver Object with driver's entry points
   //

   DriverObject->DriverUnload                          = SerialUnload;
   DriverObject->DriverExtension->AddDevice            = SerialAddDevice;

   DriverObject->MajorFunction[IRP_MJ_FLUSH_BUFFERS]   = SerialFlush;
   DriverObject->MajorFunction[IRP_MJ_WRITE]           = SerialWrite;
   DriverObject->MajorFunction[IRP_MJ_READ]            = SerialRead;
   DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL]  = SerialIoControl;
   DriverObject->MajorFunction[IRP_MJ_INTERNAL_DEVICE_CONTROL]
      = SerialInternalIoControl;
   DriverObject->MajorFunction[IRP_MJ_CREATE]          = SerialCreateOpen;
   DriverObject->MajorFunction[IRP_MJ_CLOSE]           = SerialClose;
   DriverObject->MajorFunction[IRP_MJ_CLEANUP]         = SerialCleanup;
   DriverObject->MajorFunction[IRP_MJ_PNP]             = SerialPnpDispatch;
   DriverObject->MajorFunction[IRP_MJ_POWER]           = SerialPowerDispatch;

   DriverObject->MajorFunction[IRP_MJ_QUERY_INFORMATION]
      = SerialQueryInformationFile;
   DriverObject->MajorFunction[IRP_MJ_SET_INFORMATION]
      = SerialSetInformationFile;

   DriverObject->MajorFunction[IRP_MJ_SYSTEM_CONTROL]
      = SerialSystemControlDispatch;

   if (!(jensenBuffer = ExAllocatePool(
                                      PagedPool,
                                      512
                                      ))) {

      //
      // We couldn't allocate 512 bytes of paged pool.  If that's
      // so, then it's likely that the least of this machine's problems
      // is that it's a Jensen.
      //

      jensenDetected = FALSE;

   } else {

      //
      // Check to see if this is a Jensen alpha.  If it is, then
      // we'll have to change the way we enable and disable interrupts
      //

      jensenData.Length = 0;
      jensenData.MaximumLength = 512;
      jensenData.Buffer = (PWCHAR)&jensenBuffer[0];
      RtlInitUnicodeString(
                          &jensenValue,
                          L"Jensen"
                          );
      jensenTable[0].Flags = RTL_QUERY_REGISTRY_DIRECT
                             | RTL_QUERY_REGISTRY_REQUIRED;
      jensenTable[0].Name = L"Identifier";
      jensenTable[0].EntryContext = &jensenData;

      if (!NT_SUCCESS(RtlQueryRegistryValues(RTL_REGISTRY_ABSOLUTE
                                             | RTL_REGISTRY_OPTIONAL,
                                             L"\\REGISTRY\\MACHINE\\HARDWARE"
                                             L"\\DESCRIPTION\\SYSTEM",
                                             &jensenTable[0], NULL, NULL))) {

         //
         // How odd, no identifer string! We'll it's probably not a jensen.
         //

         jensenDetected = FALSE;

      } else {

         //
         // Skip past the DEC-XX Portion of the name string.
         // Be carful and make sure we have at least that much data.
         //

         if (jensenData.Length <= (sizeof(WCHAR)*6)) {

            jensenDetected = FALSE;

         } else {

            jensenData.Length -= (sizeof(WCHAR)*6);
            jensenData.MaximumLength -= (sizeof(WCHAR)*6);
            jensenData.Buffer = (PWCHAR)&jensenBuffer[sizeof(WCHAR)*6];
            jensenDetected = RtlEqualUnicodeString(
                                                  &jensenData,
                                                  &jensenValue,
                                                  FALSE
                                                  );
         }

      }

      ExFreePool(jensenBuffer);

   }

   if (jensenDetected) {

      SerialDump(
                SERDIAG1,
                ("SERIAL: Jensen Detected\n")
                );

   }

   driverDefaults.JensenDetected = jensenDetected;

#if defined(NO_LEGACY_DRIVERS)
#define SerialDoLegacyConversion() (0)
#else
#define SerialDoLegacyConversion() (~0)
#endif // NO_LEGACY_DRIVERS

   //
   // Enumerate and Initialize legacy devices if necessary.  This should go away
   // and be done by setup.
   //

   if (SerialDoLegacyConversion()) {
#if DBG
      InterlockedIncrement(&SerialGlobals.PAGESER_Count);
#endif
      (void)SerialEnumerateLegacy(DriverObject, RegistryPath, &driverDefaults);
#if DBG
      InterlockedDecrement(&SerialGlobals.PAGESER_Count);
#endif
   }

   //
   // Unlock pageable text
   //
   MmUnlockPagableImageSection(lockPtr);

   return STATUS_SUCCESS;
}




BOOLEAN
SerialCleanLists(IN PVOID Context)
/*++

Routine Description:

    Removes a device object from any of the serial linked lists it may
    appear on.

Arguments:

    Context - Actually a PSERIAL_DEVICE_EXTENSION (for the devobj being
              removed).

Return Value:

    Always TRUE

--*/
{
   PSERIAL_DEVICE_EXTENSION pDevExt = (PSERIAL_DEVICE_EXTENSION)Context;

    //
    // If we are a multiport device, remove our entry
    //

    if (pDevExt->PortOnAMultiportCard) {
       PSERIAL_MULTIPORT_DISPATCH pDispatch
          = (PSERIAL_MULTIPORT_DISPATCH)pDevExt->OurIsrContext;

       SerialDump(SERPNPPOWER,("SERIAL: CLEAN: removing multiport isr ext\n"));

       pDispatch->Extensions[pDevExt->PortIndex - 1] = NULL;

       if (pDevExt->Indexed == FALSE) {
          pDispatch->UsablePortMask &= ~(1 << (pDevExt->PortIndex - 1));
          pDispatch->MaskInverted &= ~(pDevExt->NewMaskInverted);
       }
    }

   if (!IsListEmpty(&pDevExt->TopLevelSharers)) {

      SerialDump(SERPNPPOWER,("SERIAL: CLEAN: Device is a sharer\n"));

      //
      // If we have siblings, the first becomes the sharer
      //

      if (!IsListEmpty(&pDevExt->MultiportSiblings)) {
         PSERIAL_DEVICE_EXTENSION pNewRoot;

         SerialDump(SERPNPPOWER,("SERIAL: CLEAN: Transferring to siblings\n"));

         pNewRoot = CONTAINING_RECORD(pDevExt->MultiportSiblings.Flink,
                                      SERIAL_DEVICE_EXTENSION,
                                      MultiportSiblings);

         //
         // He should not be on there already
         //

         ASSERT(IsListEmpty(&pNewRoot->TopLevelSharers));
         InsertTailList(&pDevExt->TopLevelSharers, &pNewRoot->TopLevelSharers);

      }

      //
      // Remove ourselves
      //

      RemoveEntryList(&pDevExt->TopLevelSharers);
      InitializeListHead(&pDevExt->TopLevelSharers);

      //
      // Now check the master list to see if anyone is left...
      //

      if (!IsListEmpty(&pDevExt->CIsrSw->SharerList)) {
         //
         // Others are chained on this interrupt, so we don't want to
         // disconnect it.
         //

         pDevExt->Interrupt = NULL;
      }
   }

   //
   // If this is part of a multiport board and we still have
   // siblings, remove us from that list
   //

   if (!IsListEmpty(&pDevExt->MultiportSiblings)) {
      SerialDump(SERPNPPOWER,("SERIAL: CLEAN: Has multiport siblings\n"));
      RemoveEntryList(&pDevExt->MultiportSiblings);
      InitializeListHead(&pDevExt->MultiportSiblings);
   }


   if (!IsListEmpty(&pDevExt->CommonInterruptObject)) {

      SerialDump(SERPNPPOWER,("SERIAL: CLEAN: Common intobj member\n"));

      RemoveEntryList(&pDevExt->CommonInterruptObject);
      InitializeListHead(&pDevExt->CommonInterruptObject);

      //
      // Others are sharing this interrupt object so we detach ourselves
      // from it this way instead of disconnecting.
      //

      pDevExt->Interrupt = NULL;
   }

   //
   // AllDevObjs should never be empty since we have a sentinal
   //

   ASSERT(!IsListEmpty(&pDevExt->AllDevObjs));

   RemoveEntryList(&pDevExt->AllDevObjs);
   InitializeListHead(&pDevExt->AllDevObjs);

   return TRUE;
}



VOID
SerialReleaseResources(IN PSERIAL_DEVICE_EXTENSION PDevExt)
/*++

Routine Description:

    Releases resources (not pool) stored in the device extension.

Arguments:

    PDevExt - Pointer to the device extension to release resources from.

Return Value:

    VOID

--*/
{
   PAGED_CODE();

   SerialDump(SERTRACECALLS,("SERIAL: Enter SerialReleaseResources\n"));

   //
   // Remove us from any lists we may be on
   //

   KeSynchronizeExecution(PDevExt->Interrupt, SerialCleanLists, PDevExt);

   //
   // Stop servicing interrupts if we are the owner
   //

   if (PDevExt->Interrupt != NULL) {
      SerialDump(SERPNPPOWER,("SERIAL: Release - disconnecting interrupt %08X\n",
                              PDevExt->Interrupt));

      IoDisconnectInterrupt(PDevExt->Interrupt);
      PDevExt->Interrupt = NULL;
   }

   if (PDevExt->PortOnAMultiportCard) {
       ULONG i;

       //
       // If we are the last device, free this memory
       //

       for (i = 0; i < SERIAL_MAX_PORTS_INDEXED; i++) {
          if (((PSERIAL_MULTIPORT_DISPATCH)PDevExt->OurIsrContext)
              ->Extensions[i] != NULL) {
             break;
          }
       }

       if (i == SERIAL_MAX_PORTS_INDEXED) {
          SerialDump(SERPNPPOWER,("SERIAL: Release - freeing multi context\n"));
          ExFreePool(PDevExt->OurIsrContext);
       }
    }


   //
   // Stop handling timers
   //

   SerialCancelTimer(&PDevExt->ReadRequestTotalTimer, PDevExt);
   SerialCancelTimer(&PDevExt->ReadRequestIntervalTimer, PDevExt);
   SerialCancelTimer(&PDevExt->WriteRequestTotalTimer, PDevExt);
   SerialCancelTimer(&PDevExt->ImmediateTotalTimer, PDevExt);
   SerialCancelTimer(&PDevExt->XoffCountTimer, PDevExt);
   SerialCancelTimer(&PDevExt->LowerRTSTimer, PDevExt);

   //
   // Stop servicing DPC's
   //

   SerialRemoveQueueDpc(&PDevExt->CompleteWriteDpc, PDevExt);
   SerialRemoveQueueDpc(&PDevExt->CompleteReadDpc, PDevExt);
   SerialRemoveQueueDpc(&PDevExt->TotalReadTimeoutDpc, PDevExt);
   SerialRemoveQueueDpc(&PDevExt->IntervalReadTimeoutDpc, PDevExt);
   SerialRemoveQueueDpc(&PDevExt->TotalWriteTimeoutDpc, PDevExt);
   SerialRemoveQueueDpc(&PDevExt->CommErrorDpc, PDevExt);
   SerialRemoveQueueDpc(&PDevExt->CompleteImmediateDpc, PDevExt);
   SerialRemoveQueueDpc(&PDevExt->TotalImmediateTimeoutDpc, PDevExt);
   SerialRemoveQueueDpc(&PDevExt->CommWaitDpc, PDevExt);
   SerialRemoveQueueDpc(&PDevExt->XoffCountTimeoutDpc, PDevExt);
   SerialRemoveQueueDpc(&PDevExt->XoffCountCompleteDpc, PDevExt);
   SerialRemoveQueueDpc(&PDevExt->StartTimerLowerRTSDpc, PDevExt);
   SerialRemoveQueueDpc(&PDevExt->PerhapsLowerRTSDpc, PDevExt);



   //
   // If necessary, unmap the device registers.
   //

   if (PDevExt->UnMapRegisters) {
      MmUnmapIoSpace(PDevExt->Controller, PDevExt->SpanOfController);
   }

   if (PDevExt->UnMapStatus) {
      MmUnmapIoSpace(PDevExt->InterruptStatus,
                     PDevExt->SpanOfInterruptStatus);
   }

   SerialDump(SERTRACECALLS,("SERIAL: Leave SerialReleaseResources\n"));
}



NTSTATUS
SerialPrepareRemove(IN PDEVICE_OBJECT PDevObj)
/*++

Routine Description:

    Removes a serial device object from the system.

Arguments:

    PDevObj - A pointer to the Device Object we want removed.

Return Value:

    Always TRUE

--*/
{
   PSERIAL_DEVICE_EXTENSION pDevExt
      = (PSERIAL_DEVICE_EXTENSION)PDevObj->DeviceExtension;
   POWER_STATE state;
   ULONG pendingIRPs;

   PAGED_CODE();

   SerialDump(SERTRACECALLS,("SERIAL: Enter SerialPrepareRemove\n"));

   //
   // Mark as not accepting requests
   //

   SerialSetAccept(pDevExt, SERIAL_PNPACCEPT_REMOVING);

   //
   // Complete all pending requests
   //

   SerialKillPendingIrps(PDevObj);

   //
   // Wait for any pending requests we raced on.
   //

   pendingIRPs = InterlockedDecrement(&pDevExt->PendingIRPCnt);

   if (pendingIRPs) {
      KeWaitForSingleObject(&pDevExt->PendingIRPEvent, Executive, KernelMode,
                            FALSE, NULL);
   }

   state.DeviceState = PowerDeviceD3;

   PoSetPowerState(PDevObj, DevicePowerState, state);

   return TRUE;
}


VOID
SerialDisableInterfacesResources(IN PDEVICE_OBJECT PDevObj,
                                 BOOLEAN DisableUART)
{
   PSERIAL_DEVICE_EXTENSION pDevExt
      = (PSERIAL_DEVICE_EXTENSION)PDevObj->DeviceExtension;

   PAGED_CODE();

   SerialDump(SERTRACECALLS,("SERIAL: Enter SerialDisableInterfaces\n"));

   //
   // Only do these many things if the device has started and still
   // has resources allocated
   //

   if (pDevExt->Flags & SERIAL_FLAGS_STARTED) {
       if (!(pDevExt->Flags & SERIAL_FLAGS_STOPPED)) {

          if (DisableUART) {
             //
             // Mask off interrupts
             //

             DISABLE_ALL_INTERRUPTS(pDevExt->Controller);
          }

          SerialReleaseResources(pDevExt);
       }

      //
      // Remove us from WMI consideration
      //

      IoWMIRegistrationControl(PDevObj, WMIREG_ACTION_DEREGISTER);
   }

   //
   // Undo external names
   //

   SerialUndoExternalNaming(pDevExt);

   SerialDump(SERTRACECALLS,("SERIAL: Exit SerialDisableInterfaces\n"));
}


NTSTATUS
SerialRemoveDevObj(IN PDEVICE_OBJECT PDevObj)
/*++

Routine Description:

    Removes a serial device object from the system.

Arguments:

    PDevObj - A pointer to the Device Object we want removed.

Return Value:

    Always TRUE

--*/
{
   PSERIAL_DEVICE_EXTENSION pDevExt
      = (PSERIAL_DEVICE_EXTENSION)PDevObj->DeviceExtension;

   PAGED_CODE();

   SerialDump(SERTRACECALLS,("SERIAL: Enter SerialRemoveDevObj\n"));

   if (!(pDevExt->DevicePNPAccept & SERIAL_PNPACCEPT_SURPRISE_REMOVING)) {
      //
      // Disable all external interfaces and release resources
      //

      SerialDisableInterfacesResources(PDevObj, TRUE);
   }

   IoDetachDevice(pDevExt->LowerDeviceObject);

   //
   // Free memory allocated in the extension
   //

   if (pDevExt->NtNameForPort.Buffer != NULL) {
      ExFreePool(pDevExt->NtNameForPort.Buffer);
   }

   if (pDevExt->DeviceName.Buffer != NULL) {
      ExFreePool(pDevExt->DeviceName.Buffer);
   }

   if (pDevExt->SymbolicLinkName.Buffer != NULL) {
      ExFreePool(pDevExt->SymbolicLinkName.Buffer);
   }

   if (pDevExt->DosName.Buffer != NULL) {
      ExFreePool(pDevExt->DosName.Buffer);
   }

   if (pDevExt->ObjectDirectory.Buffer) {
      ExFreePool(pDevExt->ObjectDirectory.Buffer);
   }

   //
   // Delete the devobj
   //

   IoDeleteDevice(PDevObj);


   SerialDump(SERTRACECALLS,("SERIAL: Leave SerialRemoveDevObj\n"));

   return STATUS_SUCCESS;
}


VOID
SerialKillPendingIrps(PDEVICE_OBJECT PDevObj)
/*++

Routine Description:

   This routine kills any irps pending for the passed device object.

Arguments:

    PDevObj - Pointer to the device object whose irps must die.

Return Value:

    VOID

--*/
{
   PSERIAL_DEVICE_EXTENSION pDevExt = PDevObj->DeviceExtension;
   KIRQL oldIrql;

   SerialDump (SERTRACECALLS,("SERIAL: Enter SerialKillPendingIrps\n"));

   //
   // First kill all the reads and writes.
   //

    SerialKillAllReadsOrWrites(PDevObj, &pDevExt->WriteQueue,
                               &pDevExt->CurrentWriteIrp);

    SerialKillAllReadsOrWrites(PDevObj, &pDevExt->ReadQueue,
                               &pDevExt->CurrentReadIrp);

    //
    // Next get rid of purges.
    //

    SerialKillAllReadsOrWrites(PDevObj, &pDevExt->PurgeQueue,
                               &pDevExt->CurrentPurgeIrp);

    //
    // Get rid of any mask operations.
    //

    SerialKillAllReadsOrWrites(PDevObj, &pDevExt->MaskQueue,
                               &pDevExt->CurrentMaskIrp);

    //
    // Now get rid a pending wait mask irp.
    //

    IoAcquireCancelSpinLock(&oldIrql);

    if (pDevExt->CurrentWaitIrp) {

        PDRIVER_CANCEL cancelRoutine;

        cancelRoutine = pDevExt->CurrentWaitIrp->CancelRoutine;
        pDevExt->CurrentWaitIrp->Cancel = TRUE;

        if (cancelRoutine) {

            pDevExt->CurrentWaitIrp->CancelIrql = oldIrql;
            pDevExt->CurrentWaitIrp->CancelRoutine = NULL;

            cancelRoutine(PDevObj, pDevExt->CurrentWaitIrp);

        }

    } else {

        IoReleaseCancelSpinLock(oldIrql);

    }

    //
    // Cancel any pending wait-wake irps
    //

    if (pDevExt->PendingWakeIrp != NULL) {
       IoCancelIrp(pDevExt->PendingWakeIrp);
       pDevExt->PendingWakeIrp = NULL;
    }

    //
    // Finally, dump any stalled IRPS
    //

    SerialKillAllStalled(PDevObj);


    SerialDump (SERTRACECALLS,("SERIAL: Leave SerialKillPendingIrps\n"));
}


BOOLEAN
SerialSingleToMulti(PVOID Context)
/*++

Routine Description:

    This routine converts a root device set up to be a single port
    device to a multiport device while that device is running.

Arguments:

    Context - Actually a pointer to the device extension of the root
              device we are turning into a multiport device.

Return Value:

    Always TRUE

--*/
{
   PSERIAL_DEVICE_EXTENSION pDevExt = (PSERIAL_DEVICE_EXTENSION)Context;
   PSERIAL_MULTIPORT_DISPATCH pOurIsrContext;
   PSERIAL_MULTIPORT_DISPATCH pNewIsrContext
      = (PSERIAL_MULTIPORT_DISPATCH)pDevExt->NewExtension;
   PVOID isrFunc;

   SerialDump (SERTRACECALLS,("SERIAL: Enter SerialSingleToMulti\n"));

   //
   // Stomp OurIsrContext since we are going from one to many
   // thus our previous context was just pDevExt and doesn't
   // need to be released (i.e., no call to ExFreePool() is needed).
   //

   pOurIsrContext = pDevExt->OurIsrContext = pDevExt->TopLevelOurIsrContext
      = pNewIsrContext;

   //
   // We are now multiport
   //

   pDevExt->PortOnAMultiportCard = TRUE;

   //
   // Update our personal extensions slot
   //

   pOurIsrContext->Extensions[pDevExt->PortIndex - 1] = pDevExt;
   pOurIsrContext->InterruptStatus = pDevExt->InterruptStatus;


   //
   // We have to pick a new ISR and a new context.
   // As soon as this is done, the ISR will change, so we have to
   // be ready to handle things there.
   //

   if (pDevExt->Indexed == FALSE) {
      pOurIsrContext->UsablePortMask = 1 << (pDevExt->PortIndex - 1);
      pOurIsrContext->MaskInverted = pDevExt->MaskInverted;
      isrFunc = SerialBitMappedMultiportIsr;
   } else {
      isrFunc = SerialIndexedMultiportIsr;
   }

   pDevExt->OurIsr = isrFunc;
   pDevExt->TopLevelOurIsr = isrFunc;

   if (pDevExt->CIsrSw->IsrFunc != SerialSharerIsr) {
         pDevExt->CIsrSw->IsrFunc = isrFunc;
         pDevExt->CIsrSw->Context = pOurIsrContext;
   }

   SerialDump (SERTRACECALLS,("SERIAL: Leave SerialSingleToMulti\n"));
   return TRUE;
}


BOOLEAN
SerialAddToMulti(PVOID Context)
/*++

Routine Description:

    This routine adds a new port to a multiport device while that device is
    running.

Arguments:

    Context - Actually a pointer to the device extension of the root
              device we are adding a port to.

Return Value:

    Always TRUE

--*/
{
   PSERIAL_DEVICE_EXTENSION pDevExt = (PSERIAL_DEVICE_EXTENSION)Context;
   PSERIAL_MULTIPORT_DISPATCH pOurIsrContext
      = (PSERIAL_MULTIPORT_DISPATCH)pDevExt->OurIsrContext;
   PSERIAL_DEVICE_EXTENSION pNewExt
      = (PSERIAL_DEVICE_EXTENSION)pDevExt->NewExtension;


   SerialDump (SERTRACECALLS,("SERIAL: Enter SerialAddToMulti\n"));

   if (pDevExt->Indexed == FALSE) {
      pOurIsrContext->UsablePortMask |= 1 << (pDevExt->NewPortIndex - 1);
      pOurIsrContext->MaskInverted |= pDevExt->NewMaskInverted;
   }

   //
   // Add us to the linked list of common interrupt objects if we are not
   // already in it. We may be if there is another device besides our
   // multiport card.
   //

   if (IsListEmpty(&pNewExt->CommonInterruptObject)) {
      InsertTailList(&pDevExt->CommonInterruptObject,
                     &pNewExt->CommonInterruptObject);
   }

   //
   // Give us the list of contexts also
   //

   pNewExt->OurIsrContext = pOurIsrContext;


   //
   // Add us to the list of our siblings
   //
   InsertTailList(&pDevExt->MultiportSiblings, &pNewExt->MultiportSiblings);

   SerialDump(SERDIAG1, ("SERIAL: Adding to multi...\n"));
   SerialDump(SERDIAG1, ("------: old ext %x\n", pDevExt));

   //
   // Map us in so the ISR can find us.
   //

   pOurIsrContext->Extensions[pDevExt->NewPortIndex - 1]
      = pDevExt->NewExtension;

   pNewExt->TopLevelOurIsr = pDevExt->TopLevelOurIsr;
   pNewExt->TopLevelOurIsrContext = pDevExt->TopLevelOurIsrContext;

   SerialDump (SERTRACECALLS,("SERIAL: Leave SerialAddToMulti\n"));
   return TRUE;
}



NTSTATUS
SerialInitMultiPort(IN PSERIAL_DEVICE_EXTENSION PDevExt,
                    IN PCONFIG_DATA PConfigData, IN PDEVICE_OBJECT PDevObj)
/*++

Routine Description:

    This routine initializes a multiport device by adding a port to an existing
    one.

Arguments:

    PDevExt - pointer to the device extension of the root of the multiport
              device.

    PConfigData - pointer to the config data for the new port

    PDevObj - pointer to the devobj for the new port

Return Value:

    STATUS_SUCCESS on success, appropriate error on failure.

--*/
{
   PSERIAL_DEVICE_EXTENSION pOurIsrContext
      = (PSERIAL_DEVICE_EXTENSION)PDevExt->OurIsrContext;
   PSERIAL_DEVICE_EXTENSION pNewExt
      = (PSERIAL_DEVICE_EXTENSION)PDevObj->DeviceExtension;
   NTSTATUS status;
   PSERIAL_MULTIPORT_DISPATCH pDispatch;

   PAGED_CODE();


   SerialDump (SERTRACECALLS,("SERIAL: Enter SerialInitMultiPort\n"));

   //
   // Allow him to share our CISRsw and interrupt object
   //

   pNewExt->CIsrSw = PDevExt->CIsrSw;
   pNewExt->Interrupt = PDevExt->Interrupt;

   //
   // First, see if we can initialize the one we have found
   //

   status = SerialInitOneController(PDevObj, PConfigData);

   if (!NT_SUCCESS(status)) {
      SerialDump (SERTRACECALLS,("SERIAL: Leave SerialInitMultiPort\n"));
      return status;
   }

   //
   // OK.  He's good to go.  Find the root controller.  He may
   // currently be a single, so we have to change him to multi.
   //

   if (PDevExt->PortOnAMultiportCard != TRUE) {

      pDispatch = PDevExt->NewExtension
         = ExAllocatePool(NonPagedPool, sizeof(SERIAL_MULTIPORT_DISPATCH));

      if (pDispatch == NULL) {
         // FAIL and CLEANUP
         SerialDump (SERTRACECALLS,("SERIAL: Leave SerialInitMultiPort\n"));
         return STATUS_INSUFFICIENT_RESOURCES;
      }

      RtlZeroMemory(pDispatch, sizeof(*pDispatch));
      KeSynchronizeExecution(PDevExt->Interrupt, SerialSingleToMulti, PDevExt);
   }

   //
   // Update some important fields
   //

   ((PSERIAL_DEVICE_EXTENSION)PDevObj->DeviceExtension)->PortOnAMultiportCard
      = TRUE;
   ((PSERIAL_DEVICE_EXTENSION)PDevObj->DeviceExtension)->OurIsr = NULL;


   PDevExt->NewPortIndex = PConfigData->PortIndex;
   PDevExt->NewMaskInverted = PConfigData->MaskInverted;
   PDevExt->NewExtension = PDevObj->DeviceExtension;

   //
   // Now, we can add the new guy.  He will be hooked in
   // immediately, so we need to be able to handle interrupts.
   //

   KeSynchronizeExecution(PDevExt->Interrupt, SerialAddToMulti, PDevExt);

   SerialDump (SERTRACECALLS,("SERIAL: Leave SerialInitMultiPort\n"));
   return STATUS_SUCCESS;
}



NTSTATUS
SerialInitController(IN PDEVICE_OBJECT PDevObj, IN PCONFIG_DATA PConfigData)

/*++

Routine Description:

    Really too many things to mention here.  In general initializes
    kernel synchronization structures, allocates the typeahead buffer,
    sets up defaults, etc.

Arguments:

    PDevObj       - Device object for the device to be started

    PConfigData   - Pointer to a record for a single port.

Return Value:

    STATUS_SUCCCESS if everything went ok.  A !NT_SUCCESS status
    otherwise.

--*/

{

   PSERIAL_DEVICE_EXTENSION pDevExt = PDevObj->DeviceExtension;
#if defined(NEC_98)
   PSERIAL_DEVICE_EXTENSION Extension = PDevObj->DeviceExtension;
#else
#endif //defined(NEC_98)

   //
   // This will hold the string that we need to use to describe
   // the name of the device to the IO system.
   //

   UNICODE_STRING uniNameString;

   //
   // Holds the NT Status that is returned from each call to the
   // kernel and executive.
   //

   NTSTATUS status = STATUS_SUCCESS;

   //
   // Indicates that a conflict was detected for resources
   // used by this device.
   //

   BOOLEAN conflictDetected = FALSE;

   //
   // Indicates if we allocated an ISR switch
   //

   BOOLEAN allocedISRSw = FALSE;

   PAGED_CODE();


   SerialDump(
             SERDIAG1,
             ("SERIAL: Initializing for configuration record of %wZ\n",
              &pDevExt->DeviceName)
             );

   //
   // This compare is done using **untranslated** values since that is what
   // the kernel shoves in regardless of the architecture.
   //

   if ((*KdComPortInUse) == ((PUCHAR)(PConfigData->Controller.LowPart))) {
      SerialDump(SERERRORS, ("SERIAL: Kernel debugger is using port at address "
                             "%x\n"
                             "------  Serial driver will not load port\n",
                             *KdComPortInUse));

      SerialLogError(
                    PDevObj->DriverObject,
                    NULL,
                    PConfigData->TrController,
                    SerialPhysicalZero,
                    0,
                    0,
                    0,
                    3,
                    STATUS_SUCCESS,
                    SERIAL_KERNEL_DEBUGGER_ACTIVE,
                    pDevExt->DeviceName.Length+sizeof(WCHAR),
                    pDevExt->DeviceName.Buffer,
                    0,
                    NULL
                    );

      return STATUS_INSUFFICIENT_RESOURCES;
   }


   if (pDevExt->CIsrSw == NULL) {
      if ((pDevExt->CIsrSw
           = ExAllocatePool(NonPagedPool, sizeof(SERIAL_CISR_SW))) == NULL) {
         return STATUS_INSUFFICIENT_RESOURCES;
      }

      InitializeListHead(&pDevExt->CIsrSw->SharerList);

      allocedISRSw = TRUE;
   }

#if defined(NEC_98)
   //
   // intiallize device extension
   //
   pDevExt->DivisorLatch16550 = 0;
   pDevExt->ModemControl16550 = 0;
   pDevExt->LineControl16550 = SERIAL_8_DATA;
   pDevExt->ModeSet71051 = 0;
   pDevExt->CommandSet71051 = COMMAND_DEFAULT_SET;
#else
#endif //defined(NEC_98)
   //
   // Propagate that it is a jensen.
   //

   pDevExt->Jensen = PConfigData->Jensen;


   //
   // Initialize the spinlock associated with fields read (& set)
   // by IO Control functions and the flags spinlock.
   //

   KeInitializeSpinLock(&pDevExt->ControlLock);
   KeInitializeSpinLock(&pDevExt->FlagsLock);


   //
   // Initialize the timers used to timeout operations.
   //

   KeInitializeTimer(&pDevExt->ReadRequestTotalTimer);
   KeInitializeTimer(&pDevExt->ReadRequestIntervalTimer);
   KeInitializeTimer(&pDevExt->WriteRequestTotalTimer);
   KeInitializeTimer(&pDevExt->ImmediateTotalTimer);
   KeInitializeTimer(&pDevExt->XoffCountTimer);
   KeInitializeTimer(&pDevExt->LowerRTSTimer);


   //
   // Intialialize the dpcs that will be used to complete
   // or timeout various IO operations.
   //

   KeInitializeDpc(&pDevExt->CompleteWriteDpc, SerialCompleteWrite, pDevExt);
   KeInitializeDpc(&pDevExt->CompleteReadDpc, SerialCompleteRead, pDevExt);
   KeInitializeDpc(&pDevExt->TotalReadTimeoutDpc, SerialReadTimeout, pDevExt);
   KeInitializeDpc(&pDevExt->IntervalReadTimeoutDpc, SerialIntervalReadTimeout,
                   pDevExt);
   KeInitializeDpc(&pDevExt->TotalWriteTimeoutDpc, SerialWriteTimeout, pDevExt);
   KeInitializeDpc(&pDevExt->CommErrorDpc, SerialCommError, pDevExt);
   KeInitializeDpc(&pDevExt->CompleteImmediateDpc, SerialCompleteImmediate,
                   pDevExt);
   KeInitializeDpc(&pDevExt->TotalImmediateTimeoutDpc, SerialTimeoutImmediate,
                   pDevExt);
   KeInitializeDpc(&pDevExt->CommWaitDpc, SerialCompleteWait, pDevExt);
   KeInitializeDpc(&pDevExt->XoffCountTimeoutDpc, SerialTimeoutXoff, pDevExt);
   KeInitializeDpc(&pDevExt->XoffCountCompleteDpc, SerialCompleteXoff, pDevExt);
   KeInitializeDpc(&pDevExt->StartTimerLowerRTSDpc, SerialStartTimerLowerRTS,
                   pDevExt);
   KeInitializeDpc(&pDevExt->PerhapsLowerRTSDpc, SerialInvokePerhapsLowerRTS,
                   pDevExt);
   KeInitializeDpc(&pDevExt->IsrUnlockPagesDpc, SerialUnlockPages, pDevExt);

#if 0 // DBG
   //
   // Init debug stuff
   //

   pDevExt->DpcQueued[0].Dpc = &pDevExt->CompleteWriteDpc;
   pDevExt->DpcQueued[1].Dpc = &pDevExt->CompleteReadDpc;
   pDevExt->DpcQueued[2].Dpc = &pDevExt->TotalReadTimeoutDpc;
   pDevExt->DpcQueued[3].Dpc = &pDevExt->IntervalReadTimeoutDpc;
   pDevExt->DpcQueued[4].Dpc = &pDevExt->TotalWriteTimeoutDpc;
   pDevExt->DpcQueued[5].Dpc = &pDevExt->CommErrorDpc;
   pDevExt->DpcQueued[6].Dpc = &pDevExt->CompleteImmediateDpc;
   pDevExt->DpcQueued[7].Dpc = &pDevExt->TotalImmediateTimeoutDpc;
   pDevExt->DpcQueued[8].Dpc = &pDevExt->CommWaitDpc;
   pDevExt->DpcQueued[9].Dpc = &pDevExt->XoffCountTimeoutDpc;
   pDevExt->DpcQueued[10].Dpc = &pDevExt->XoffCountCompleteDpc;
   pDevExt->DpcQueued[11].Dpc = &pDevExt->StartTimerLowerRTSDpc;
   pDevExt->DpcQueued[12].Dpc = &pDevExt->PerhapsLowerRTSDpc;
   pDevExt->DpcQueued[13].Dpc = &pDevExt->IsrUnlockPagesDpc;

#endif

   if (!((PConfigData->ClockRate == 1843200) ||
         (PConfigData->ClockRate == 3072000) ||
         (PConfigData->ClockRate == 4233600) ||
         (PConfigData->ClockRate == 8000000))) {

      SerialLogError(
                    PDevObj->DriverObject,
                    PDevObj,
                    PConfigData->TrController,
                    SerialPhysicalZero,
                    0,
                    0,
                    0,
                    6,
                    STATUS_SUCCESS,
                    SERIAL_UNSUPPORTED_CLOCK_RATE,
                    pDevExt->DeviceName.Length+sizeof(WCHAR),
                    pDevExt->DeviceName.Buffer,
                    0,
                    NULL
                    );

      SerialDump(
                SERERRORS,
                ("SERIAL: Invalid clock rate specified for %wZ\n",
                 &pDevExt->DeviceName)
                );

      status = STATUS_SERIAL_NO_DEVICE_INITED;
      goto ExtensionCleanup;

   }


   //
   // Save the value of clock input to the part.  We use this to calculate
   // the divisor latch value.  The value is in Hertz.
   //

   pDevExt->ClockRate = PConfigData->ClockRate;





   //
   // Map the memory for the control registers for the serial device
   // into virtual memory.
   //
   pDevExt->Controller =
      SerialGetMappedAddress(PConfigData->InterfaceType,
                             PConfigData->BusNumber,
                             PConfigData->TrController,
                             PConfigData->SpanOfController,
                             (BOOLEAN)PConfigData->AddressSpace,
                             &pDevExt->UnMapRegisters);

   if (!pDevExt->Controller) {

      SerialLogError(
                    PDevObj->DriverObject,
                    pDevExt->DeviceObject,
                    PConfigData->TrController,
                    SerialPhysicalZero,
                    0,
                    0,
                    0,
                    7,
                    STATUS_SUCCESS,
                    SERIAL_REGISTERS_NOT_MAPPED,
                    pDevExt->DeviceName.Length+sizeof(WCHAR),
                    pDevExt->DeviceName.Buffer,
                    0,
                    NULL
                    );

      SerialDump(
                SERERRORS,
                ("SERIAL: Could not map memory for device registers for %wZ\n",
                 &pDevExt->DeviceName)
                );

      pDevExt->UnMapRegisters = FALSE;
      status = STATUS_NONE_MAPPED;
      goto ExtensionCleanup;

   }

   pDevExt->AddressSpace          = PConfigData->AddressSpace;
   pDevExt->OriginalController    = PConfigData->Controller;
   pDevExt->SpanOfController      = PConfigData->SpanOfController;


   //
   // if we have an interrupt status then map it.
   //

   pDevExt->InterruptStatus =
      (PUCHAR)PConfigData->TrInterruptStatus.QuadPart;

   if (pDevExt->InterruptStatus) {

      pDevExt->InterruptStatus
         = SerialGetMappedAddress(PConfigData->InterfaceType,
                                  PConfigData->BusNumber,
                                  PConfigData->TrInterruptStatus,
                                  PConfigData->SpanOfInterruptStatus,
                                  (BOOLEAN)PConfigData->AddressSpace,
                                  &pDevExt->UnMapStatus);


      if (!pDevExt->InterruptStatus) {

         SerialLogError(
                       PDevObj->DriverObject,
                       PDevObj,
                       PConfigData->TrController,
                       SerialPhysicalZero,
                       0,
                       0,
                       0,
                       8,
                       STATUS_SUCCESS,
                       SERIAL_REGISTERS_NOT_MAPPED,
                       pDevExt->DeviceName.Length+sizeof(WCHAR),
                       pDevExt->DeviceName.Buffer,
                       0,
                       NULL
                       );

         SerialDump(SERERRORS, ("SERIAL: Could not map memory for interrupt "
                                "status for %wZ\n",
                                &pDevExt->DeviceName));

         //
         // Manually unmap the other register here if necessary
         //

         if (pDevExt->UnMapRegisters) {
            MmUnmapIoSpace((PVOID)PConfigData->TrController.QuadPart,
                           PConfigData->SpanOfController);
         }

         pDevExt->UnMapRegisters = FALSE;
         pDevExt->UnMapStatus = FALSE;
         status = STATUS_NONE_MAPPED;
         goto ExtensionCleanup;

      }

      pDevExt->OriginalInterruptStatus = PConfigData->InterruptStatus;
      pDevExt->SpanOfInterruptStatus = PConfigData->SpanOfInterruptStatus;


   }


   //
   // Shareable interrupt?
   //

   if ((BOOLEAN)PConfigData->PermitSystemWideShare) {
      pDevExt->InterruptShareable = TRUE;
   }

   //
   // Save off the interface type and the bus number.
   //

   pDevExt->InterfaceType = PConfigData->InterfaceType;
   pDevExt->BusNumber     = PConfigData->BusNumber;

   pDevExt->PortIndex = PConfigData->PortIndex;
   pDevExt->Indexed = (BOOLEAN)PConfigData->Indexed;
   pDevExt->MaskInverted = PConfigData->MaskInverted;

   //
   // Get the translated interrupt vector, level, and affinity
   //

   pDevExt->OriginalIrql      = PConfigData->OriginalIrql;
   pDevExt->OriginalVector    = PConfigData->OriginalVector;


   //
   // PnP uses the passed translated values rather than calling
   // HalGetInterruptVector()
   //

   pDevExt->Vector = PConfigData->TrVector;
   pDevExt->Irql = (UCHAR)PConfigData->TrIrql;

   //
   // Set up the Isr.
   //

   pDevExt->OurIsr        = SerialISR;
   pDevExt->OurIsrContext = pDevExt;


   //
   // If the user said to permit sharing within the device, propagate this
   // through.
   //

   pDevExt->PermitShare = PConfigData->PermitShare;


   //
   // Before we test whether the port exists (which will enable the FIFO)
   // convert the rx trigger value to what should be used in the register.
   //
   // If a bogus value was given - crank them down to 1.
   //

   switch (PConfigData->RxFIFO) {

   case 1:

      pDevExt->RxFifoTrigger = SERIAL_1_BYTE_HIGH_WATER;
      break;

   case 4:

      pDevExt->RxFifoTrigger = SERIAL_4_BYTE_HIGH_WATER;
      break;

   case 8:

      pDevExt->RxFifoTrigger = SERIAL_8_BYTE_HIGH_WATER;
      break;

   case 14:

      pDevExt->RxFifoTrigger = SERIAL_14_BYTE_HIGH_WATER;
      break;

   default:

      pDevExt->RxFifoTrigger = SERIAL_1_BYTE_HIGH_WATER;
      break;

   }


   if ((PConfigData->TxFIFO > 16) ||
       (PConfigData->TxFIFO < 1)) {

      pDevExt->TxFifoAmount = 1;

   } else {

      pDevExt->TxFifoAmount = PConfigData->TxFIFO;

   }


   if (!SerialDoesPortExist(
                           pDevExt,
                           &pDevExt->DeviceName,
                           PConfigData->ForceFifoEnable,
                           PConfigData->LogFifo
                           )) {

      //
      // We couldn't verify that there was actually a
      // port. No need to log an error as the port exist
      // code will log exactly why.
      //

      SerialDump(
                SERERRORS,
                ("SERIAL: Does Port exist test failed for %wZ\n",
                 &pDevExt->DeviceName)
                );

      status = STATUS_NO_SUCH_DEVICE;
      goto ExtensionCleanup;

   }


   //
   // If the user requested that we disable the port, then
   // do it now.  Log the fact that the port has been disabled.
   //

   if (PConfigData->DisablePort) {

      SerialDump(
                SERERRORS,
                ("SERIAL: disabled port %wZ as requested in configuration\n",
                 &pDevExt->DeviceName)
                );

      status = STATUS_NO_SUCH_DEVICE;

      SerialLogError(
                    PDevObj->DriverObject,
                    PDevObj,
                    PConfigData->Controller,
                    SerialPhysicalZero,
                    0,
                    0,
                    0,
                    57,
                    STATUS_SUCCESS,
                    SERIAL_DISABLED_PORT,
                    pDevExt->DeviceName.Length+sizeof(WCHAR),
                    pDevExt->DeviceName.Buffer,
                    0,
                    NULL
                    );

      goto ExtensionCleanup;

   }



   //
   // Set up the default device control fields.
   // Note that if the values are changed after
   // the file is open, they do NOT revert back
   // to the old value at file close.
   //

   pDevExt->SpecialChars.XonChar      = SERIAL_DEF_XON;
   pDevExt->SpecialChars.XoffChar     = SERIAL_DEF_XOFF;
   pDevExt->HandFlow.ControlHandShake = SERIAL_DTR_CONTROL;
   pDevExt->HandFlow.FlowReplace      = SERIAL_RTS_CONTROL;


   //
   // Default Line control protocol. 7E1
   //
   // Seven data bits.
   // Even parity.
   // 1 Stop bits.
   //

   pDevExt->LineControl = SERIAL_7_DATA |
                               SERIAL_EVEN_PARITY |
                               SERIAL_NONE_PARITY;

   pDevExt->ValidDataMask = 0x7f;
   pDevExt->CurrentBaud   = 1200;


   //
   // We set up the default xon/xoff limits.
   //
   // This may be a bogus value.  It looks like the BufferSize
   // is not set up until the device is actually opened.
   //

   pDevExt->HandFlow.XoffLimit    = pDevExt->BufferSize >> 3;
   pDevExt->HandFlow.XonLimit     = pDevExt->BufferSize >> 1;

   pDevExt->BufferSizePt8 = ((3*(pDevExt->BufferSize>>2))+
                                  (pDevExt->BufferSize>>4));

   SerialDump(
             SERDIAG1,
             ("SERIAL: The default interrupt read buffer size is: %d\n"
              "------  The XoffLimit is                         : %d\n"
              "------  The XonLimit is                          : %d\n"
              "------  The pt 8 size is                         : %d\n",
              pDevExt->BufferSize,
              pDevExt->HandFlow.XoffLimit,
              pDevExt->HandFlow.XonLimit,
              pDevExt->BufferSizePt8)
             );


   //
   // Go through all the "named" baud rates to find out which ones
   // can be supported with this port.
   //

   pDevExt->SupportedBauds = SERIAL_BAUD_USER;

   {

      SHORT junk;

      if (!NT_ERROR(SerialGetDivisorFromBaud(
                                            pDevExt->ClockRate,
                                            (LONG)75,
                                            &junk
                                            ))) {

         pDevExt->SupportedBauds |= SERIAL_BAUD_075;

      }

      if (!NT_ERROR(SerialGetDivisorFromBaud(
                                            pDevExt->ClockRate,
                                            (LONG)110,
                                            &junk
                                            ))) {

         pDevExt->SupportedBauds |= SERIAL_BAUD_110;

      }

      if (!NT_ERROR(SerialGetDivisorFromBaud(
                                            pDevExt->ClockRate,
                                            (LONG)135,
                                            &junk
                                            ))) {

         pDevExt->SupportedBauds |= SERIAL_BAUD_134_5;

      }

      if (!NT_ERROR(SerialGetDivisorFromBaud(
                                            pDevExt->ClockRate,
                                            (LONG)150,
                                            &junk
                                            ))) {

         pDevExt->SupportedBauds |= SERIAL_BAUD_150;

      }

      if (!NT_ERROR(SerialGetDivisorFromBaud(
                                            pDevExt->ClockRate,
                                            (LONG)300,
                                            &junk
                                            ))) {

         pDevExt->SupportedBauds |= SERIAL_BAUD_300;

      }

      if (!NT_ERROR(SerialGetDivisorFromBaud(
                                            pDevExt->ClockRate,
                                            (LONG)600,
                                            &junk
                                            ))) {

         pDevExt->SupportedBauds |= SERIAL_BAUD_600;

      }

      if (!NT_ERROR(SerialGetDivisorFromBaud(
                                            pDevExt->ClockRate,
                                            (LONG)1200,
                                            &junk
                                            ))) {

         pDevExt->SupportedBauds |= SERIAL_BAUD_1200;

      }

      if (!NT_ERROR(SerialGetDivisorFromBaud(
                                            pDevExt->ClockRate,
                                            (LONG)1800,
                                            &junk
                                            ))) {

         pDevExt->SupportedBauds |= SERIAL_BAUD_1800;

      }

      if (!NT_ERROR(SerialGetDivisorFromBaud(
                                            pDevExt->ClockRate,
                                            (LONG)2400,
                                            &junk
                                            ))) {

         pDevExt->SupportedBauds |= SERIAL_BAUD_2400;

      }

      if (!NT_ERROR(SerialGetDivisorFromBaud(
                                            pDevExt->ClockRate,
                                            (LONG)4800,
                                            &junk
                                            ))) {

         pDevExt->SupportedBauds |= SERIAL_BAUD_4800;

      }

      if (!NT_ERROR(SerialGetDivisorFromBaud(
                                            pDevExt->ClockRate,
                                            (LONG)7200,
                                            &junk
                                            ))) {

         pDevExt->SupportedBauds |= SERIAL_BAUD_7200;

      }

      if (!NT_ERROR(SerialGetDivisorFromBaud(
                                            pDevExt->ClockRate,
                                            (LONG)9600,
                                            &junk
                                            ))) {

         pDevExt->SupportedBauds |= SERIAL_BAUD_9600;

      }

      if (!NT_ERROR(SerialGetDivisorFromBaud(
                                            pDevExt->ClockRate,
                                            (LONG)14400,
                                            &junk
                                            ))) {

         pDevExt->SupportedBauds |= SERIAL_BAUD_14400;

      }

      if (!NT_ERROR(SerialGetDivisorFromBaud(
                                            pDevExt->ClockRate,
                                            (LONG)19200,
                                            &junk
                                            ))) {

         pDevExt->SupportedBauds |= SERIAL_BAUD_19200;

      }

      if (!NT_ERROR(SerialGetDivisorFromBaud(
                                            pDevExt->ClockRate,
                                            (LONG)38400,
                                            &junk
                                            ))) {

         pDevExt->SupportedBauds |= SERIAL_BAUD_38400;

      }

      if (!NT_ERROR(SerialGetDivisorFromBaud(
                                            pDevExt->ClockRate,
                                            (LONG)56000,
                                            &junk
                                            ))) {

         pDevExt->SupportedBauds |= SERIAL_BAUD_56K;

      }
      if (!NT_ERROR(SerialGetDivisorFromBaud(
                                            pDevExt->ClockRate,
                                            (LONG)57600,
                                            &junk
                                            ))) {

         pDevExt->SupportedBauds |= SERIAL_BAUD_57600;

      }
      if (!NT_ERROR(SerialGetDivisorFromBaud(
                                            pDevExt->ClockRate,
                                            (LONG)115200,
                                            &junk
                                            ))) {

         pDevExt->SupportedBauds |= SERIAL_BAUD_115200;

      }

      if (!NT_ERROR(SerialGetDivisorFromBaud(
                                            pDevExt->ClockRate,
                                            (LONG)128000,
                                            &junk
                                            ))) {

         pDevExt->SupportedBauds |= SERIAL_BAUD_128K;

      }

   }


   //
   // Mark this device as not being opened by anyone.  We keep a
   // variable around so that spurious interrupts are easily
   // dismissed by the ISR.
   //

   pDevExt->DeviceIsOpened = FALSE;

   //
   // Store values into the extension for interval timing.
   //

   //
   // If the interval timer is less than a second then come
   // in with a short "polling" loop.
   //
   // For large (> then 2 seconds) use a 1 second poller.
   //

   pDevExt->ShortIntervalAmount.QuadPart  = -1;
   pDevExt->LongIntervalAmount.QuadPart   = -10000000;
   pDevExt->CutOverAmount.QuadPart        = 200000000;


   //
   // Common error path cleanup.  If the status is
   // bad, get rid of the device extension, device object
   // and any memory associated with it.
   //

ExtensionCleanup: ;
   if (!NT_SUCCESS(status)) {
      if (allocedISRSw) {
         ExFreePool(pDevExt->CIsrSw);
         pDevExt->CIsrSw = NULL;
      }

      if (pDevExt->UnMapRegisters) {
         MmUnmapIoSpace(pDevExt->Controller, pDevExt->SpanOfController);
      }

      if (pDevExt->UnMapStatus) {
         MmUnmapIoSpace(pDevExt->InterruptStatus,
                        pDevExt->SpanOfInterruptStatus);
      }

   }

   return status;

}



NTSTATUS
SerialInitOneController(IN PDEVICE_OBJECT PDevObj, IN PCONFIG_DATA PConfigData)
/*++

Routine Description:

    This routine will call the real port initialization code.  It sets
    up the ISR and Context correctly for a one port device.

Arguments:

    All args are simply passed along.

Return Value:

    Status returned from the controller initialization routine.

--*/

{

   NTSTATUS status;
   PSERIAL_DEVICE_EXTENSION pDevExt;

   PAGED_CODE();

   status = SerialInitController(PDevObj, PConfigData);

   if (NT_SUCCESS(status)) {

      pDevExt = PDevObj->DeviceExtension;

      //
      // We successfully initialized the single controller.
      // Stick the isr routine and the parameter for it
      // back into the extension.
      //

      pDevExt->OurIsr = SerialISR;
      pDevExt->OurIsrContext = pDevExt;
      pDevExt->TopLevelOurIsr = SerialISR;
      pDevExt->TopLevelOurIsrContext = pDevExt;

   }

   return status;

}


BOOLEAN
SerialDoesPortExist(
                   IN PSERIAL_DEVICE_EXTENSION Extension,
                   IN PUNICODE_STRING InsertString,
                   IN ULONG ForceFifo,
                   IN ULONG LogFifo
                   )

/*++

Routine Description:

    This routine examines several of what might be the serial device
    registers.  It ensures that the bits that should be zero are zero.

    In addition, this routine will determine if the device supports
    fifo's.  If it does it will enable the fifo's and turn on a boolean
    in the extension that indicates the fifo's presence.

    NOTE: If there is indeed a serial port at the address specified
          it will absolutely have interrupts inhibited upon return
          from this routine.

    NOTE: Since this routine should be called fairly early in
          the device driver initialization, the only element
          that needs to be filled in is the base register address.

    NOTE: These tests all assume that this code is the only
          code that is looking at these ports or this memory.

          This is a not to unreasonable assumption even on
          multiprocessor systems.

Arguments:

    Extension - A pointer to a serial device extension.
    InsertString - String to place in an error log entry.
    ForceFifo - !0 forces the fifo to be left on if found.
    LogFifo - !0 forces a log message if fifo found.

Return Value:

    Will return true if the port really exists, otherwise it
    will return false.

--*/

{


   UCHAR regContents;
   BOOLEAN returnValue = TRUE;
   UCHAR oldIERContents;
   UCHAR oldLCRContents;
   USHORT value1;
   USHORT value2;
   KIRQL oldIrql;

   //
   // Save of the line control.
   //

   oldLCRContents = READ_LINE_CONTROL(Extension->Controller);

   //
   // Make sure that we are *aren't* accessing the divsior latch.
   //

   WRITE_LINE_CONTROL(
                     Extension->Controller,
                     (UCHAR)(oldLCRContents & ~SERIAL_LCR_DLAB)
                     );

   oldIERContents = READ_INTERRUPT_ENABLE(Extension->Controller);

   //
   // Go up to power level for a very short time to prevent
   // any interrupts from this device from coming in.
   //

   KeRaiseIrql(
              POWER_LEVEL,
              &oldIrql
              );

   WRITE_INTERRUPT_ENABLE(
                         Extension->Controller,
                         0x0f
                         );

   value1 = READ_INTERRUPT_ENABLE(Extension->Controller);
   value1 = value1 << 8;
   value1 |= READ_RECEIVE_BUFFER(Extension->Controller);

   READ_DIVISOR_LATCH(
                     Extension->Controller,
                     &value2
                     );

   WRITE_LINE_CONTROL(
                     Extension->Controller,
                     oldLCRContents
                     );

   //
   // Put the ier back to where it was before.  If we are on a
   // level sensitive port this should prevent the interrupts
   // from coming in.  If we are on a latched, we don't care
   // cause the interrupts generated will just get dropped.
   //

   WRITE_INTERRUPT_ENABLE(
                         Extension->Controller,
                         oldIERContents
                         );

   KeLowerIrql(oldIrql);

   if (value1 == value2) {

      SerialLogError(
                    Extension->DeviceObject->DriverObject,
                    Extension->DeviceObject,
                    Extension->OriginalController,
                    SerialPhysicalZero,
                    0,
                    0,
                    0,
                    62,
                    STATUS_SUCCESS,
                    SERIAL_DLAB_INVALID,
                    InsertString->Length+sizeof(WCHAR),
                    InsertString->Buffer,
                    0,
                    NULL
                    );
      returnValue = FALSE;
      goto AllDone;

   }

   AllDone: ;


   //
   // If we think that there is a serial device then we determine
   // if a fifo is present.
   //

   if (returnValue) {

      //
      // Well, we think it's a serial device.  Absolutely
      // positively, prevent interrupts from occuring.
      //
      // We disable all the interrupt enable bits, and
      // push down all the lines in the modem control
      // We only needed to push down OUT2 which in
      // PC's must also be enabled to get an interrupt.
      //

      DISABLE_ALL_INTERRUPTS(Extension->Controller);

      if (Extension->Jensen) {

         WRITE_MODEM_CONTROL(
                            Extension->Controller,
                            (UCHAR)SERIAL_MCR_OUT2
                            );

      } else {

         WRITE_MODEM_CONTROL(
                            Extension->Controller,
                            (UCHAR)0
                            );

      }

      //
      // See if this is a 16550.  We do this by writing to
      // what would be the fifo control register with a bit
      // pattern that tells the device to enable fifo's.
      // We then read the iterrupt Id register to see if the
      // bit pattern is present that identifies the 16550.
      //

      WRITE_FIFO_CONTROL(
                        Extension->Controller,
                        SERIAL_FCR_ENABLE
                        );

      regContents = READ_INTERRUPT_ID_REG(Extension->Controller);

      if (regContents & SERIAL_IIR_FIFOS_ENABLED) {

         //
         // Save off that the device supports fifos.
         //

         Extension->FifoPresent = TRUE;

         //
         // There is a fine new "super" IO chip out there that
         // will get stuck with a line status interrupt if you
         // attempt to clear the fifo and enable it at the same
         // time if data is present.  The best workaround seems
         // to be that you should turn off the fifo read a single
         // byte, and then re-enable the fifo.
         //

         WRITE_FIFO_CONTROL(
                           Extension->Controller,
                           (UCHAR)0
                           );

         READ_RECEIVE_BUFFER(Extension->Controller);

         //
         // There are fifos on this card.  Set the value of the
         // receive fifo to interrupt when 4 characters are present.
         //

         WRITE_FIFO_CONTROL(Extension->Controller,
                            (UCHAR)(SERIAL_FCR_ENABLE
                                    | Extension->RxFifoTrigger
                                    | SERIAL_FCR_RCVR_RESET
                                    | SERIAL_FCR_TXMT_RESET));

      }

      //
      // The !Extension->FifoPresent is included in the test so that
      // broken chips like the WinBond will still work after we test
      // for the fifo.
      //

      if (!ForceFifo || !Extension->FifoPresent) {

         Extension->FifoPresent = FALSE;
         WRITE_FIFO_CONTROL(
                           Extension->Controller,
                           (UCHAR)0
                           );

      }

      if (Extension->FifoPresent) {

         if (LogFifo) {

            SerialLogError(
                          Extension->DeviceObject->DriverObject,
                          Extension->DeviceObject,
                          Extension->OriginalController,
                          SerialPhysicalZero,
                          0,
                          0,
                          0,
                          15,
                          STATUS_SUCCESS,
                          SERIAL_FIFO_PRESENT,
                          InsertString->Length+sizeof(WCHAR),
                          InsertString->Buffer,
                          0,
                          NULL
                          );

         }

         SerialDump(
                   SERDIAG1,
                   ("SERIAL: Fifo's detected at port address: %x\n",
                    Extension->Controller)
                   );

      }

      //
      // In case we are dealing with a bitmasked multiportcard,
      // that has the mask register enabled, enable the
      // interrupts.
      //

      if (Extension->InterruptStatus) {
         if (Extension->Indexed) {
            WRITE_PORT_UCHAR(Extension->InterruptStatus, (UCHAR)0xFF);
         } else {
            //
            // Either we are standalone or already mapped
            //

            if (Extension->OurIsrContext == Extension) {
               //
               // This is a standalone
               //

               WRITE_PORT_UCHAR(Extension->InterruptStatus,
                                (UCHAR)(1 << (Extension->PortIndex - 1)));
            } else {
               //
               // One of many
               //

               WRITE_PORT_UCHAR(Extension->InterruptStatus,
                                (UCHAR)((PSERIAL_MULTIPORT_DISPATCH)Extension->
                                        OurIsrContext)->UsablePortMask);
            }
         }
      }

   }

   return returnValue;

}


BOOLEAN
SerialReset(
           IN PVOID Context
           )

/*++

Routine Description:

    This places the hardware in a standard configuration.

    NOTE: This assumes that it is called at interrupt level.


Arguments:

    Context - The device extension for serial device
    being managed.

Return Value:

    Always FALSE.

--*/

{

   PSERIAL_DEVICE_EXTENSION extension = Context;
#if defined(NEC_98)
   //
   // This argument use at MACRO only.
   //
   PSERIAL_DEVICE_EXTENSION Extension = Context;
#else
#endif //defined(NEC_98)
   UCHAR regContents;
   UCHAR oldModemControl;
   ULONG i;
   SERIAL_LOCKED_PAGED_CODE();

   //
   // Adjust the out2 bit.
   // This will also prevent any interrupts from occuring.
   //

   oldModemControl = READ_MODEM_CONTROL(extension->Controller);

   if (extension->Jensen) {

      WRITE_MODEM_CONTROL(
                         extension->Controller,
                         (UCHAR)(oldModemControl | SERIAL_MCR_OUT2)
                         );

   } else {


      WRITE_MODEM_CONTROL(
                         extension->Controller,
                         (UCHAR)(oldModemControl & ~SERIAL_MCR_OUT2)
                         );

   }

   //
   // Reset the fifo's if there are any.
   //

   if (extension->FifoPresent) {


      //
      // There is a fine new "super" IO chip out there that
      // will get stuck with a line status interrupt if you
      // attempt to clear the fifo and enable it at the same
      // time if data is present.  The best workaround seems
      // to be that you should turn off the fifo read a single
      // byte, and then re-enable the fifo.
      //

      WRITE_FIFO_CONTROL(
                        extension->Controller,
                        (UCHAR)0
                        );

      READ_RECEIVE_BUFFER(extension->Controller);

      WRITE_FIFO_CONTROL(
                        extension->Controller,
                        (UCHAR)(SERIAL_FCR_ENABLE | extension->RxFifoTrigger |
                                SERIAL_FCR_RCVR_RESET | SERIAL_FCR_TXMT_RESET)
                        );

   }

   //
   // Make sure that the line control set up correct.
   //
   // 1) Make sure that the Divisor latch select is set
   //    up to select the transmit and receive register.
   //
   // 2) Make sure that we aren't in a break state.
   //

   regContents = READ_LINE_CONTROL(extension->Controller);
   regContents &= ~(SERIAL_LCR_DLAB | SERIAL_LCR_BREAK);

   WRITE_LINE_CONTROL(
                     extension->Controller,
                     regContents
                     );

   //
   // Read the receive buffer until the line status is
   // clear.  (Actually give up after a 5 reads.)
   //

   for (i = 0;
       i < 5;
       i++
       ) {

      if (IsNotNEC_98) {
         READ_RECEIVE_BUFFER(extension->Controller);
         if (!(READ_LINE_STATUS(extension->Controller) & 1)) {

            break;

         }
      } else {
          //
          // I get incorrect data when read enpty buffer.
          // But do not read no data! for PC98!
          //
          if (!(READ_LINE_STATUS(extension->Controller) & 1)) {

             break;

          }
          READ_RECEIVE_BUFFER(extension->Controller);
      }

   }

   //
   // Read the modem status until the low 4 bits are
   // clear.  (Actually give up after a 5 reads.)
   //

   for (i = 0;
       i < 1000;
       i++
       ) {

      if (!(READ_MODEM_STATUS(extension->Controller) & 0x0f)) {

         break;

      }

   }

   //
   // Now we set the line control, modem control, and the
   // baud to what they should be.
   //

   SerialSetLineControl(extension);

   SerialSetupNewHandFlow(
                         extension,
                         &extension->HandFlow
                         );

   SerialHandleModemUpdate(
                          extension,
                          FALSE
                          );

   {
      SHORT  appropriateDivisor;
      SERIAL_IOCTL_SYNC s;

      SerialGetDivisorFromBaud(
                              extension->ClockRate,
                              extension->CurrentBaud,
                              &appropriateDivisor
                              );
      s.Extension = extension;
      s.Data = (PVOID)appropriateDivisor;
      SerialSetBaud(&s);
   }

   //
   // Enable which interrupts we want to receive.
   //
   // NOTE NOTE: This does not actually let interrupts
   // occur.  We must still raise the OUT2 bit in the
   // modem control register.  We will do that on open.
   //

   ENABLE_ALL_INTERRUPTS(extension->Controller);

   //
   // Read the interrupt id register until the low bit is
   // set.  (Actually give up after a 5 reads.)
   //

   for (i = 0;
       i < 5;
       i++
       ) {

      if (READ_INTERRUPT_ID_REG(extension->Controller) & 0x01) {

         break;

      }

   }

   //
   // Now we know that nothing could be transmitting at this point
   // so we set the HoldingEmpty indicator.
   //

   extension->HoldingEmpty = TRUE;

   return FALSE;
}


NTSTATUS
SerialGetDivisorFromBaud(
                        IN ULONG ClockRate,
                        IN LONG DesiredBaud,
                        OUT PSHORT AppropriateDivisor
                        )

/*++

Routine Description:

    This routine will determine a divisor based on an unvalidated
    baud rate.

Arguments:

    ClockRate - The clock input to the controller.

    DesiredBaud - The baud rate for whose divisor we seek.

    AppropriateDivisor - Given that the DesiredBaud is valid, the
    LONG pointed to by this parameter will be set to the appropriate
    value.  NOTE: The long is undefined if the DesiredBaud is not
    supported.

Return Value:

    This function will return STATUS_SUCCESS if the baud is supported.
    If the value is not supported it will return a status such that
    NT_ERROR(Status) == FALSE.

--*/

{

   NTSTATUS status = STATUS_SUCCESS;
   SHORT calculatedDivisor;
   ULONG denominator;
   ULONG remainder;

   //
   // Allow up to a 1 percent error
   //

   ULONG maxRemain18 = 18432;
   ULONG maxRemain30 = 30720;
   ULONG maxRemain42 = 42336;
   ULONG maxRemain80 = 80000;
   ULONG maxRemain;

   SERIAL_LOCKED_PAGED_CODE();

   //
   // Reject any non-positive bauds.
   //

   denominator = DesiredBaud*(ULONG)16;

   if (DesiredBaud <= 0) {

      *AppropriateDivisor = -1;

   } else if ((LONG)denominator < DesiredBaud) {

      //
      // If the desired baud was so huge that it cause the denominator
      // calculation to wrap, don't support it.
      //

      *AppropriateDivisor = -1;

   } else {

      if (ClockRate == 1843200) {
         maxRemain = maxRemain18;
      } else if (ClockRate == 3072000) {
         maxRemain = maxRemain30;
      } else if (ClockRate == 4233600) {
         maxRemain = maxRemain42;
      } else {
         maxRemain = maxRemain80;
      }

      calculatedDivisor = (SHORT)(ClockRate / denominator);
      remainder = ClockRate % denominator;

      //
      // Round up.
      //

      if (((remainder*2) > ClockRate) && (DesiredBaud != 110)) {

         calculatedDivisor++;
      }


      //
      // Only let the remainder calculations effect us if
      // the baud rate is > 9600.
      //

      if (DesiredBaud >= 9600) {

         //
         // If the remainder is less than the maximum remainder (wrt
         // the ClockRate) or the remainder + the maximum remainder is
         // greater than or equal to the ClockRate then assume that the
         // baud is ok.
         //

         if ((remainder >= maxRemain) && ((remainder+maxRemain) < ClockRate)) {
            calculatedDivisor = -1;
         }

      }

      //
      // Don't support a baud that causes the denominator to
      // be larger than the clock.
      //

      if (denominator > ClockRate) {

         calculatedDivisor = -1;

      }

      //
      // Ok, Now do some special casing so that things can actually continue
      // working on all platforms.
      //

      if (ClockRate == 1843200) {

         if (DesiredBaud == 56000) {
            calculatedDivisor = 2;
         }

      } else if (ClockRate == 3072000) {

         if (DesiredBaud == 14400) {
            calculatedDivisor = 13;
         }

      } else if (ClockRate == 4233600) {

         if (DesiredBaud == 9600) {
            calculatedDivisor = 28;
         } else if (DesiredBaud == 14400) {
            calculatedDivisor = 18;
         } else if (DesiredBaud == 19200) {
            calculatedDivisor = 14;
         } else if (DesiredBaud == 38400) {
            calculatedDivisor = 7;
         } else if (DesiredBaud == 56000) {
            calculatedDivisor = 5;
         }

      } else if (ClockRate == 8000000) {

         if (DesiredBaud == 14400) {
            calculatedDivisor = 35;
         } else if (DesiredBaud == 56000) {
            calculatedDivisor = 9;
         }

      }

      *AppropriateDivisor = calculatedDivisor;

#if defined(NEC_98)
      //
      // This code check the baud that NEC98 support.
      //
      if (*AppropriateDivisor != -1) {
         if (DesiredBaud <= 50) {
            *AppropriateDivisor = -1;
         } else if (DesiredBaud >= 9600) {
            switch (DesiredBaud) {
               case 9600:
               case 19200:
               case 38400:
               case 57600:
               case 115200:
                  break;
               default:
                  *AppropriateDivisor = -1;
            }
         } else {
            if (153600L % DesiredBaud) {
               if (DesiredBaud != 110) {
                  *AppropriateDivisor = -1;
               }
            }
         }
      }
#else
#endif //defined(NEC_98)
   }


   if (*AppropriateDivisor == -1) {

      status = STATUS_INVALID_PARAMETER;

   }

   return status;

}


VOID
SerialUnload(
            IN PDRIVER_OBJECT DriverObject
            )

/*++

Routine Description:

    This routine is defunct since all device objects are removed before
    the driver is unloaded.

Arguments:

    DriverObject - Pointer to the driver object controling all of the
                   devices.

Return Value:

    None.

--*/

{
   PVOID lockPtr;

   PAGED_CODE();

   lockPtr = MmLockPagableCodeSection(SerialUnload);

   //
   // Unnecessary since our BSS is going away, but do it anyhow to be safe
   //

   SerialGlobals.PAGESER_Handle = NULL;

   SerialDump(
             SERDIAG3,
             ("SERIAL: In SerialUnload\n")
             );

   MmUnlockPagableImageSection(lockPtr);

}





PVOID
SerialGetMappedAddress(
                      IN INTERFACE_TYPE BusType,
                      IN ULONG BusNumber,
                      PHYSICAL_ADDRESS IoAddress,
                      ULONG NumberOfBytes,
                      ULONG AddressSpace,
                      PBOOLEAN MappedAddress
                      )

/*++

Routine Description:

    This routine maps an IO address to system address space.

Arguments:

    BusType - what type of bus - eisa, mca, isa
    IoBusNumber - which IO bus (for machines with multiple buses).
    IoAddress - base device address to be mapped.
    NumberOfBytes - number of bytes for which address is valid.
    AddressSpace - Denotes whether the address is in io space or memory.
    MappedAddress - indicates whether the address was mapped.
                    This only has meaning if the address returned
                    is non-null.

Return Value:

    Mapped address

--*/

{
   PHYSICAL_ADDRESS cardAddress;
   PVOID address;

   PAGED_CODE();

   //
   // Map the device base address into the virtual address space
   // if the address is in memory space.
   //

   if (!AddressSpace) {

      address = MmMapIoSpace(
                            IoAddress,
                            NumberOfBytes,
                            FALSE
                            );

      *MappedAddress = (BOOLEAN)((address)?(TRUE):(FALSE));


   } else {

      address = (PVOID)IoAddress.LowPart;
      *MappedAddress = FALSE;

   }

   return address;

}


SERIAL_MEM_COMPARES
SerialMemCompare(
                IN PHYSICAL_ADDRESS A,
                IN ULONG SpanOfA,
                IN PHYSICAL_ADDRESS B,
                IN ULONG SpanOfB
                )

/*++

Routine Description:

    Compare two phsical address.

Arguments:

    A - One half of the comparison.

    SpanOfA - In units of bytes, the span of A.

    B - One half of the comparison.

    SpanOfB - In units of bytes, the span of B.


Return Value:

    The result of the comparison.

--*/

{

   LARGE_INTEGER a;
   LARGE_INTEGER b;

   LARGE_INTEGER lower;
   ULONG lowerSpan;
   LARGE_INTEGER higher;

   PAGED_CODE();

   a = A;
   b = B;

   if (a.QuadPart == b.QuadPart) {

      return AddressesAreEqual;

   }

   if (a.QuadPart > b.QuadPart) {

      higher = a;
      lower = b;
      lowerSpan = SpanOfB;

   } else {

      higher = b;
      lower = a;
      lowerSpan = SpanOfA;

   }

   if ((higher.QuadPart - lower.QuadPart) >= lowerSpan) {

      return AddressesAreDisjoint;

   }

   return AddressesOverlap;

}



BOOLEAN
SerialBecomeSharer(PVOID Context)
/*++

Routine Description:

    This routine will take a device extension for a serial port and
    allow it to share interrupts with other serial ports.

Arguments:

    Context - The device extension of the port who is to start sharing
    interrupts.

Return Value:

    Always TRUE.

--*/
{
   PSERIAL_DEVICE_EXTENSION pDevExt = (PSERIAL_DEVICE_EXTENSION)Context;
   PSERIAL_DEVICE_EXTENSION pNewExt
      = (PSERIAL_DEVICE_EXTENSION)pDevExt->NewExtension;
   PSERIAL_CISR_SW pCIsrSw = pDevExt->CIsrSw;

   //
   // See if we need to configure the pre-existing node to become
   // a sharer.
   //

   if (IsListEmpty(&pCIsrSw->SharerList)) {
      pCIsrSw->IsrFunc = SerialSharerIsr;
      pCIsrSw->Context = &pCIsrSw->SharerList;
      InsertTailList(&pCIsrSw->SharerList, &pDevExt->TopLevelSharers);
   }

   //
   // They share an interrupt object and a context
   //

   pNewExt->Interrupt = pDevExt->Interrupt;
   pNewExt->CIsrSw = pDevExt->CIsrSw;

   //
   // Add to list of sharers
   //

   InsertTailList(&pCIsrSw->SharerList, &pNewExt->TopLevelSharers);

   //
   // Add to list of those who share this interrupt object --
   // we may already be on if this port is part of a multiport board
   //

   if (IsListEmpty(&pNewExt->CommonInterruptObject)) {
      InsertTailList(&pDevExt->CommonInterruptObject,
                     &pNewExt->CommonInterruptObject);
   }


   return TRUE;
}



NTSTATUS
SerialFindInitController(IN PDEVICE_OBJECT PDevObj, IN PCONFIG_DATA PConfig)
/*++

Routine Description:

    This function discovers what type of controller is responsible for
    the given port and initializes the controller and port.

Arguments:

    PDevObj - Pointer to the devobj for the port we are about to init.

    PConfig - Pointer to configuration data for the port we are about to init.

Return Value:

    STATUS_SUCCESS on success, appropriate error value on failure.

--*/

{

   PSERIAL_DEVICE_EXTENSION pDevExt = PDevObj->DeviceExtension;
   PDEVICE_OBJECT pDeviceObject;
   PSERIAL_DEVICE_EXTENSION pExtension;
   PHYSICAL_ADDRESS serialPhysicalMax;
   SERIAL_LIST_DATA listAddition;
   BOOLEAN didInit = FALSE;
   PLIST_ENTRY pCurDevObj;
   NTSTATUS status;

   PAGED_CODE();


   SerialDump(SERTRACECALLS, ("SERIAL: entering SerialFindInitController\n"));

   serialPhysicalMax.LowPart = (ULONG)~0;
   serialPhysicalMax.HighPart = ~0;

   SerialDump(SERDIAG1, ("SERIAL: Attempting to init %wZ\n"
                         "------- PortAddress is %x\n"
                         "------- Interrupt Status is %x\n"
                         "------- BusNumber is %d\n"
                         "------- BusType is %d\n"
                         "------- AddressSpace is %d\n"
                         "------- Interrupt Mode is %d\n",
                         &pDevExt->DeviceName,
                         PConfig->Controller.LowPart,
                         PConfig->InterruptStatus.LowPart,
                         PConfig->BusNumber,
                         PConfig->InterfaceType,
                         PConfig->AddressSpace,
                         PConfig->InterruptMode)
             );

   //
   // We don't support any boards whose memory wraps around
   // the physical address space.
   //

   if (SerialMemCompare(
                       PConfig->Controller,
                       PConfig->SpanOfController,
                       serialPhysicalMax,
                       (ULONG)0
                       ) != AddressesAreDisjoint) {

      SerialLogError(
                    PDevObj->DriverObject,
                    NULL,
                    PConfig->Controller,
                    SerialPhysicalZero,
                    0,
                    0,
                    0,
                    43,
                    STATUS_SUCCESS,
                    SERIAL_DEVICE_TOO_HIGH,
                    pDevExt->SymbolicLinkName.Length+sizeof(WCHAR),
                    pDevExt->SymbolicLinkName.Buffer,
                    0,
                    NULL
                    );

      SerialDump(
                SERERRORS,
                ("SERIAL: Error in config record for %wZ\n"
                 "------  registers wrap around physical memory\n",
                 &pDevExt->DeviceName)
                );

      return STATUS_NO_SUCH_DEVICE;

   }


   if (SerialMemCompare(
                       PConfig->InterruptStatus,
                       PConfig->SpanOfInterruptStatus,
                       serialPhysicalMax,
                       (ULONG)0
                       ) != AddressesAreDisjoint) {

      SerialLogError(
                    PDevObj->DriverObject,
                    NULL,
                    PConfig->Controller,
                    SerialPhysicalZero,
                    0,
                    0,
                    0,
                    44,
                    STATUS_SUCCESS,
                    SERIAL_STATUS_TOO_HIGH,
                    pDevExt->SymbolicLinkName.Length+sizeof(WCHAR),
                    pDevExt->SymbolicLinkName.Buffer,
                    0,
                    NULL
                    );

      SerialDump(
                SERERRORS,
                ("SERIAL: Error in config record for %wZ\n"
                 "------  status raps around physical memory\n",
                 &pDevExt->DeviceName)
                );

      return STATUS_NO_SUCH_DEVICE;
   }


   //
   // Make sure that the interrupt status address doesn't
   // overlap the controller registers
   //

   if (SerialMemCompare(
                       PConfig->InterruptStatus,
                       PConfig->SpanOfInterruptStatus,
                       SerialPhysicalZero,
                       (ULONG)0
                       ) != AddressesAreEqual) {

      if (SerialMemCompare(
                          PConfig->InterruptStatus,
                          PConfig->SpanOfInterruptStatus,
                          PConfig->Controller,
                          PConfig->SpanOfController
                          ) != AddressesAreDisjoint) {

         SerialLogError(
                       PDevObj->DriverObject,
                       NULL,
                       PConfig->Controller,
                       PConfig->InterruptStatus,
                       0,
                       0,
                       0,
                       45,
                       STATUS_SUCCESS,
                       SERIAL_STATUS_CONTROL_CONFLICT,
                       pDevExt->SymbolicLinkName.Length+sizeof(WCHAR),
                       pDevExt->SymbolicLinkName.Buffer,
                       0,
                       NULL
                       );

         SerialDump(
                   SERERRORS,
                   ("SERIAL: Error in config record for %wZ\n"
                    "------- Interrupt status overlaps regular registers\n",
                    &pDevExt->DeviceName)
                   );

         return STATUS_NO_SUCH_DEVICE;
      }
   }


   //
   // Loop through all of the driver's device objects making
   // sure that this new record doesn't overlap with any of them.
   //

   if (!IsListEmpty(&SerialGlobals.AllDevObjs)) {
      pCurDevObj = SerialGlobals.AllDevObjs.Flink;
      pExtension = CONTAINING_RECORD(pCurDevObj, SERIAL_DEVICE_EXTENSION,
                                     AllDevObjs);
   } else {
      pCurDevObj = NULL;
      pExtension = NULL;
   }


   while (pCurDevObj != NULL
          && pCurDevObj != &SerialGlobals.AllDevObjs) {
      //
      // We only care about this list if the elements are on the
      // same bus as this new entry.
      //

      if ((pExtension->InterfaceType  == PConfig->InterfaceType) &&
          (pExtension->AddressSpace   == PConfig->AddressSpace)  &&
          (pExtension->BusNumber      == PConfig->BusNumber)) {

         SerialDump(
                   SERDIAG1,
                   ("SERIAL: Comparing it to %wZ\n"
                    "------- already in the device list\n"
                    "------- PortAddress is %x\n"
                    "------- Interrupt Status is %x\n"
                    "------- BusNumber is %d\n"
                    "------- BusType is %d\n"
                    "------- AddressSpace is %d\n",
                    &pExtension->DeviceName,
                    pExtension->OriginalController.LowPart,
                    pExtension->OriginalInterruptStatus.LowPart,
                    pExtension->BusNumber,
                    pExtension->InterfaceType,
                    pExtension->AddressSpace
                   )
                   );

         //
         // Check to see if the controller addresses are not equal.
         //

         if (SerialMemCompare(
                             PConfig->Controller,
                             PConfig->SpanOfController,
                             pExtension->OriginalController,
                             pExtension->SpanOfController
                             ) != AddressesAreDisjoint) {

            //
            // We don't want to log an error if the addresses
            // are the same and the name is the same and
            // the new item is from the firmware.
            //

            SerialDump(
                      SERERRORS,
                      ("SERIAL: Error in config record for %wZ\n"
                       "------- Register address overlaps with\n"
                       "------- previous serial device\n",
                       &pDevExt->DeviceName)
                      );

            return STATUS_NO_SUCH_DEVICE;
         }


         //
         // If we have an interrupt status, make sure that
         // it doesn't overlap with the old controllers
         // registers.
         //

         if (SerialMemCompare(
                             PConfig->InterruptStatus,
                             PConfig->SpanOfInterruptStatus,
                             SerialPhysicalZero,
                             (ULONG)0
                             ) != AddressesAreEqual) {

            //
            // Check it against the existing device's controller address
            //

            if (SerialMemCompare(
                                PConfig->InterruptStatus,
                                PConfig->SpanOfInterruptStatus,
                                pExtension->OriginalController,
                                pExtension->SpanOfController
                                ) != AddressesAreDisjoint) {

               SerialLogError(
                             PDevObj->DriverObject,
                             NULL,
                             PConfig->Controller,
                             pExtension->OriginalController,
                             0,
                             0,
                             0,
                             47,
                             STATUS_SUCCESS,
                             SERIAL_STATUS_OVERLAP,
                             pDevExt->SymbolicLinkName.Length+sizeof(WCHAR),
                             pDevExt->SymbolicLinkName.Buffer,
                             pExtension->SymbolicLinkName.Length+sizeof(WCHAR),
                             pExtension->SymbolicLinkName.Buffer
                             );

               SerialDump(
                         SERERRORS,
                         ("SERIAL: Error in config record for %wZ\n"
                          "------- status address overlaps with\n"
                          "------- previous serial device registers\n",
                          &pDevExt->DeviceName)
                         );

               return STATUS_NO_SUCH_DEVICE;
            }

            //
            // If the old configuration record has an interrupt
            // status, the addresses should not overlap.
            //

            if (SerialMemCompare(
                                PConfig->InterruptStatus,
                                PConfig->SpanOfInterruptStatus,
                                SerialPhysicalZero,
                                (ULONG)0
                                ) != AddressesAreEqual) {

               if (SerialMemCompare(
                                   PConfig->InterruptStatus,
                                   PConfig->SpanOfInterruptStatus,
                                   pExtension->OriginalInterruptStatus,
                                   pExtension->SpanOfInterruptStatus
                                   ) == AddressesOverlap) {

                  SerialLogError(
                                PDevObj->DriverObject,
                                NULL,
                                PConfig->Controller,
                                pExtension->OriginalController,
                                0,
                                0,
                                0,
                                48,
                                STATUS_SUCCESS,
                                SERIAL_STATUS_STATUS_OVERLAP,
                                pDevExt->SymbolicLinkName.Length+sizeof(WCHAR),
                                pDevExt->SymbolicLinkName.Buffer,
                                pExtension->SymbolicLinkName.Length
                                + sizeof(WCHAR),
                                pExtension->SymbolicLinkName.Buffer
                                );

                  SerialDump(
                            SERERRORS,
                            ("SERIAL: Error in config record for %wZ\n"
                             "------- status address overlaps with\n"
                             "------- previous serial status register\n",
                             &pDevExt->DeviceName)
                            );

                  return STATUS_NO_SUCH_DEVICE;
               }
            }
         }       // if ((pExtension->InterfaceType  == pDevExt->InterfaceType) &&


         //
         // If the old configuration record has a status
         // address make sure that it doesn't overlap with
         // the new controllers address.  (Interrupt status
         // overlap is take care of above.
         //

         if (SerialMemCompare(
                             pExtension->OriginalInterruptStatus,
                             pExtension->SpanOfInterruptStatus,
                             SerialPhysicalZero,
                             (ULONG)0
                             ) != AddressesAreEqual) {

            if (SerialMemCompare(
                                PConfig->Controller,
                                PConfig->SpanOfController,
                                pExtension->OriginalInterruptStatus,
                                pExtension->SpanOfInterruptStatus
                                ) == AddressesOverlap) {

               SerialLogError(
                             PDevObj->DriverObject,
                             NULL,
                             PConfig->Controller,
                             pExtension->OriginalController,
                             0,
                             0,
                             0,
                             49,
                             STATUS_SUCCESS,
                             SERIAL_CONTROL_STATUS_OVERLAP,
                             pDevExt->SymbolicLinkName.Length
                             + sizeof(WCHAR),
                             pDevExt->SymbolicLinkName.Buffer,
                             pExtension->SymbolicLinkName.Length+sizeof(WCHAR),
                             pExtension->SymbolicLinkName.Buffer
                             );

               SerialDump(
                         SERERRORS,
                         ("SERIAL: Error in config record for %wZ\n"
                          "------- register address overlaps with\n"
                          "------- previous serial status register\n",
                          &pDevExt->DeviceName)
                         );

               return STATUS_NO_SUCH_DEVICE;
            }
         }
      }

      pCurDevObj = pCurDevObj->Flink;

      if (pCurDevObj != NULL) {
         pExtension = CONTAINING_RECORD(pCurDevObj, SERIAL_DEVICE_EXTENSION,
                                        AllDevObjs);
      }
   }   // while (pCurDevObj != NULL && pCurDevObj != &SerialGlobals.AllDevObjs)



   //
   // Now, we will check if this is a port on a multiport card.
   // The conditions are same ISR set and same IRQL/Vector
   //

   //
   // Loop through all previously attached devices
   //

   if (!IsListEmpty(&SerialGlobals.AllDevObjs)) {
      pCurDevObj = SerialGlobals.AllDevObjs.Flink;
      pExtension = CONTAINING_RECORD(pCurDevObj, SERIAL_DEVICE_EXTENSION,
                                     AllDevObjs);
   } else {
      pCurDevObj = NULL;
      pExtension = NULL;
   }


   //
   // If there is an interrupt status then we
   // loop through the config list again to look
   // for a config record with the same interrupt
   // status (on the same bus).
   //

   if ((SerialMemCompare(
                        PConfig->InterruptStatus,
                        PConfig->SpanOfInterruptStatus,
                        SerialPhysicalZero,
                        (ULONG)0
                        ) != AddressesAreEqual) &&
       (pCurDevObj != NULL)) {

      ASSERT(pExtension != NULL);

      //
      // We have an interrupt status.  Loop through all
      // previous records, look for an existing interrupt status
      // the same as the current interrupt status.
      //
      do {

         //
         // We only care about this list if the elements are on the
         // same bus as this new entry.  (Their interrupts must therefore
         // also be the on the same bus.  We will check that momentarily).
         //
         // We don't check here for the dissimilar interrupts since that
         // could cause us to miss the error of having the same interrupt
         // status but different interrupts - which is bizzare.
         //

         if ((pExtension->InterfaceType == PConfig->InterfaceType) &&
             (pExtension->AddressSpace == PConfig->AddressSpace) &&
             (pExtension->BusNumber == PConfig->BusNumber)) {

            //
            // If the interrupt status is the same, then same card.
            //

            if (SerialMemCompare(
                                pExtension->OriginalInterruptStatus,
                                pExtension->SpanOfInterruptStatus,
                                PConfig->InterruptStatus,
                                PConfig->SpanOfInterruptStatus
                                ) == AddressesAreEqual) {

               //
               // Same card.  Now make sure that they
               // are using the same interrupt parameters.
               //

               if ((PConfig->OriginalIrql != pExtension->OriginalIrql) ||
                   (PConfig->OriginalVector != pExtension->OriginalVector)) {

                  //
                  // We won't put this into the configuration
                  // list.
                  //
                  SerialLogError(
                                PDevObj->DriverObject,
                                NULL,
                                PConfig->Controller,
                                pExtension->OriginalController,
                                0,
                                0,
                                0,
                                50,
                                STATUS_SUCCESS,
                                SERIAL_MULTI_INTERRUPT_CONFLICT,
                                pDevExt->SymbolicLinkName.Length+sizeof(WCHAR),
                                pDevExt->SymbolicLinkName.Buffer,
                                pExtension->SymbolicLinkName.Length
                                + sizeof(WCHAR),
                                pExtension->SymbolicLinkName.Buffer
                                );

                  SerialDump(
                            SERERRORS,
                            ("SERIAL: Configuration error for %wZ\n"
                             "------- Same multiport - different interrupts\n",
                             &pDevExt->DeviceName)
                            );
                  return STATUS_NO_SUCH_DEVICE;

               }

               //
               // We should never get this far on a restart since we don't
               // support stop on ISA multiport devices!
               //

               ASSERT(pDevExt->PNPState == SERIAL_PNP_ADDED);

               //
               //
               // Initialize the device as part of a multiport board
               //

               SerialDump(SERDIAG1, ("SERIAL: Aha! It is a multiport node\n"));
               SerialDump(SERDIAG1, ("------: Matched to %x\n", pExtension));

               status = SerialInitMultiPort(pExtension, PConfig, PDevObj);

               //
               // A port can be one of three things:
               //    A standalone
               //    A non-root on a multiport
               //    A root on a multiport
               //
               // It can only share an interrupt if it is a root
               // or if it is a standalone.  Since this was a non-root
               // we don't need to check if it shares an interrupt
               // and we can return.
               //
               return status;
            }
         }

         //
         // No match, check some more
         //

         pCurDevObj = pCurDevObj->Flink;
         if (pCurDevObj != NULL) {
            pExtension = CONTAINING_RECORD(pCurDevObj,SERIAL_DEVICE_EXTENSION,
                                           AllDevObjs);
         }

      } while (pCurDevObj != NULL && pCurDevObj != &SerialGlobals.AllDevObjs);
   }


   SerialDump(SERDIAG1, ("SERIAL: Aha! It is a standalone node or first multi"
                         "\n"));
   status = SerialInitOneController(PDevObj, PConfig);

   if (!NT_SUCCESS(status)) {
      return status;
   }

   //
   // The device is initialized.  Now we need to check if
   // this device shares an interrupt with anyone.
   //


   //
   // Loop through all previously attached devices
   //

   if (!IsListEmpty(&SerialGlobals.AllDevObjs)) {
      pCurDevObj = SerialGlobals.AllDevObjs.Flink;
      pExtension = CONTAINING_RECORD(pCurDevObj, SERIAL_DEVICE_EXTENSION,
                                     AllDevObjs);
   } else {
      pCurDevObj = NULL;
      pExtension = NULL;
   }

   //
   // Go through the list again looking for previous devices
   // with the same interrupt.  The first one found will either be a root
   // or standalone.  Order of insertion is important here!
   //

   if (!PConfig->Jensen && (pCurDevObj != NULL)) {
      do {

         //
         // We only care about interrupts that are on
         // the same bus.
         //

         if ((pExtension->InterfaceType == PConfig->InterfaceType) &&
             (pExtension->BusNumber == PConfig->BusNumber)) {

            if ((pExtension->OriginalIrql == PConfig->OriginalIrql) &&
                (pExtension->OriginalVector == PConfig->OriginalVector)) {
                pExtension->NewExtension = pDevExt;

                //
                // We will share another's CIsrSw so we can free the one
                // allocated for us during init
                //

                ExFreePool(pDevExt->CIsrSw);

                SerialDump(SERDIAG1, ("Becoming sharer: %08X %08X %08X\n",
                                      pExtension, pExtension->OriginalIrql,
                                      &pExtension->CIsrSw->SharerList));

                KeSynchronizeExecution(pExtension->Interrupt,
                                       SerialBecomeSharer, pExtension);

               return STATUS_SUCCESS;

            }

         }

         //
         // No match, check some more
         //

         pCurDevObj = pCurDevObj->Flink;

         if (pCurDevObj != NULL) {
            pExtension = CONTAINING_RECORD(pCurDevObj, SERIAL_DEVICE_EXTENSION,
                                           AllDevObjs);
         }
      } while (pCurDevObj != NULL
               && pCurDevObj != 