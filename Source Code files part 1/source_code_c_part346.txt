{
    PHW_DEVICE_EXTENSION pHwDevExt = (PHW_DEVICE_EXTENSION)pKsDevice->Context;
    PAVC_COMMAND_IRB pAvcIrb;
    NTSTATUS ntStatus;
    PUCHAR pOperands;

    pAvcIrb = (PAVC_COMMAND_IRB)
		ExAllocateFromNPagedLookasideList(&pHwDevExt->AvcCommandLookasideList);
    if ( NULL == pAvcIrb ) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    RtlZeroMemory(pAvcIrb, sizeof(AVC_COMMAND_IRB));

    pOperands = pAvcIrb->Operands;

    // Set up command in AvcIrb.
    pAvcIrb->CommandType   = ucCtype;
    pAvcIrb->Opcode        = AVC_AUDIO_FB_COMMAND;
    pAvcIrb->OperandLength = pFBSpecificDataSize;

    _DbgPrintF( DEBUGLVL_VERBOSE, ("[AudioFunctionBlockCommand] ucCtype: %x\n",ucCtype));

    RtlCopyMemory(&pOperands[0], pFBSpecificData, pFBSpecificDataSize);

    ntStatus = AvcSubmitIrbSync( pKsDevice, pAvcIrb );
    if ( NT_SUCCESS(ntStatus) ) {
        RtlCopyMemory(pFBSpecificData, &pOperands[0], pFBSpecificDataSize);
    }
#if DBG
    else {
        _DbgPrintF( DEBUGLVL_ERROR, ("[AudioFunctionBlockCommand]Error pAvcIrb: %x\n",pAvcIrb));
    }
#endif

    ExFreeToNPagedLookasideList(&pHwDevExt->AvcCommandLookasideList, pAvcIrb);

    return ntStatus;
}

NTSTATUS
AudioSet61883IsochParameters(
    IN PKSDEVICE pKsDevice )
{
    UNIT_ISOCH_PARAMS UnitIsochParams;

    UnitIsochParams.RX_NumPackets     = 50;
    UnitIsochParams.RX_NumDescriptors = 3;
    UnitIsochParams.TX_NumPackets     = 50;
    UnitIsochParams.TX_NumDescriptors = 3;

    return Av61883GetSetUnitInfo( pKsDevice,
                                  Av61883_SetUnitInfo,
                                  SET_UNIT_INFO_ISOCH_PARAMS,
                                  &UnitIsochParams );
}

NTSTATUS
AudioSetSampleRateOnPlug(
    PKSPIN pKsPin,
    ULONG ulSampleRate )
{
    PPIN_CONTEXT pPinContext = pKsPin->Context;
    PHW_DEVICE_EXTENSION pHwDevExt = pPinContext->pHwDevExt;
    PAVC_UNIT_INFORMATION pUnitInfo = pHwDevExt->pAvcUnitInformation;
    PDEVICE_GROUP_INFO pGrpInfo = pPinContext->pDevGrpInfo;
    BOOLEAN bSettable = FALSE;
    NTSTATUS ntStatus = STATUS_SUCCESS;
    UCHAR ucFDF;

    // Determine if the sample rate is settable. If not return success and assume the device
    // will do the sync up with the data.
    if ( pKsPin->DataFlow == KSPIN_DATAFLOW_IN ) {
        bSettable = pUnitInfo->fAvcCapabilities[AVC_CAP_INPUT_PLUG_FMT].fCommand;
    }
    else {
        bSettable = pUnitInfo->fAvcCapabilities[AVC_CAP_OUTPUT_PLUG_FMT].fCommand;
    }

    if ( bSettable ) {
        UCHAR ucFMT = FMT_AUDIO_MUSIC;

        // Figure out the correct FDF value
        switch( ulSampleRate ) {
            case 32000: ucFDF = SFC_32000Hz; break;
            case 44100: ucFDF = SFC_44100Hz; break;
            case 48000: ucFDF = SFC_48000Hz; break;
            case 96000: ucFDF = SFC_96000Hz; break;
        }

        // If this is a grouped device set on all devices

        if ( pGrpInfo ) {
            ULONG i;
            for ( i=0; ((i<pGrpInfo->ulDeviceCount) && NT_SUCCESS(ntStatus)); i++) {
                ntStatus = 
                    AvcPlugSignalFormat( pGrpInfo->pHwDevExts[i]->pKsDevice,
                                         pKsPin->DataFlow,
                                         pPinContext->pPinGroupInfo[i].ulPlugNumber,
                                         AVC_CTYPE_CONTROL,
                                         &ucFMT,
                                         &ucFDF );
            }
        }
        else {
            ntStatus = 
                AvcPlugSignalFormat( pHwDevExt->pKsDevice,
                                     pKsPin->DataFlow,
                                     pPinContext->ulSerialPlugNumber,
                                     AVC_CTYPE_CONTROL,
                                     &ucFMT,
                                     &ucFDF );
            
        }
    }

    return ntStatus;
}


NTSTATUS
AvcSubunitInitialize(
    IN PKSDEVICE pKsDevice )
{
    PHW_DEVICE_EXTENSION pHwDevExt = (PHW_DEVICE_EXTENSION)pKsDevice->Context;
    PAVC_UNIT_INFORMATION pUnitInfo = pHwDevExt->pAvcUnitInformation;
    PAUDIO_SUBUNIT_INFORMATION pAudioSubunitInfo;
    AVC_BOOLEAN bPowerState;
    ULONG ulPlugNumber;
    ULONG ulSubunitId;
    NTSTATUS ntStatus;
    ULONG i, j;

    // Allocate space for the Audio Subunit info 
    pAudioSubunitInfo = AllocMem( NonPagedPool, sizeof(AUDIO_SUBUNIT_INFORMATION) );
    if ( !pAudioSubunitInfo ) return STATUS_INSUFFICIENT_RESOURCES;

    pHwDevExt->pAvcSubunitInformation = pAudioSubunitInfo;

    RtlZeroMemory( pAudioSubunitInfo, sizeof(AUDIO_SUBUNIT_INFORMATION) );

    KsAddItemToObjectBag(pKsDevice->Bag, pAudioSubunitInfo, FreeMem);

    // Determine if PLUG INFO is available on the Subunit
    ntStatus = AvcGetPlugInfo( pKsDevice, FALSE, (PUCHAR)&pAudioSubunitInfo->PlugInfo);
    if ( NT_SUCCESS(ntStatus) ) {
        pAudioSubunitInfo->fAvcCapabilities[AVC_CAP_PLUG_INFO].fStatus = TRUE;
    }
//    else if ( STATUS_NOT_IMPLEMENTED != ntStatus ) {
//        return ntStatus;
//    }

    // Determine if Subunit POWER Status and possibly control available.
    ntStatus = AvcPower( pKsDevice, FALSE, AVC_CTYPE_STATUS, &bPowerState );
    if ( NT_SUCCESS(ntStatus) ) {
        pAudioSubunitInfo->fAvcCapabilities[AVC_CAP_POWER].fStatus = TRUE;
//        ntStatus = AvcPower( pKsDevice, FALSE, AVC_CTYPE_CONTROL, &bPowerState );
        ntStatus = AvcGeneralInquiry( pKsDevice, TRUE, AVC_POWER );
        if ( NT_SUCCESS(ntStatus) ) {
            pAudioSubunitInfo->fAvcCapabilities[AVC_CAP_POWER].fCommand = TRUE;
        }
    }
//    else if ( STATUS_NOT_IMPLEMENTED != ntStatus ) {
//        return ntStatus;
//    }

    // Determine if Audio Subunit has been implemented. (If so, save descriptor)
    ntStatus = AvcGetSubunitIdentifierDesc( pKsDevice, (PUCHAR *)&pAudioSubunitInfo->pSubunitIdDesc );
    if ( NT_SUCCESS(ntStatus) ) {
        pAudioSubunitInfo->fAvcCapabilities[AVC_CAP_SUBUNIT_IDENTIFIER_DESC].fStatus = TRUE;
    }
    else { // if ( STATUS_NOT_IMPLEMENTED != ntStatus ) {
        // Currently we require the Subunit Id Descriptor
        return ntStatus;
    }

#ifdef TOPO_FAKE
    // If the Audio Subunit doesn't exist, make one up.
    if (!(pAudioSubunitInfo->fAvcCapabilities[AVC_CAP_SUBUNIT_IDENTIFIER_DESC].fStatus)) {
        ntStatus = BuildFakeSubunitDescriptor( pKsDevice );
        if ( !NT_SUCCESS(ntStatus) ) {
            // Didn't find a descriptor and couldn't fake one. Give up.
            return ntStatus;
        }
    }
#endif

    // Parse Audio Subunit Descriptor (real or fake)
    ntStatus = ParseAudioSubunitDescriptor( pKsDevice );

    if ( NT_SUCCESS(ntStatus) ) {
        ntStatus = AudioPinCreate( pKsDevice );
        if ( !NT_SUCCESS(ntStatus) ) {
            return ntStatus;
        }
    }

    // Get the subunit Id from the first plug/pin. All should be the same.
    // ISSUE-2001/01/10-dsisolak Could be an extended Id
    ulSubunitId = (pAudioSubunitInfo->pPinDescriptors[0].AvcPreconnectInfo.ConnectInfo.SubunitAddress[0])&0x7; 
    // Determine if this device is CCM controled (for each destination plug)
    for ( i=0,ulPlugNumber = 0; i<pAudioSubunitInfo->ulDevicePinCount; i++ ) {
        PFW_PIN_DESCRIPTOR pPinDesc = &pAudioSubunitInfo->pPinDescriptors[i];
        if ( pPinDesc->fStreamingPin &&
           ( KSPIN_DATAFLOW_IN == pPinDesc->AvcPinDescriptor.PinDescriptor.DataFlow )) {
           ULONG ulSubunitPlugNumber = (ULONG)pPinDesc->AvcPreconnectInfo.ConnectInfo.SubunitPlugNumber;

            ntStatus = CCMCheckSupport( pKsDevice, 
                                        ulSubunitId, 
                                        ulSubunitPlugNumber );
            if ( NT_SUCCESS(ntStatus) ) {
                pUnitInfo->fAvcCapabilities[AVC_CAP_CCM].fCommand = TRUE;
                pUnitInfo->fAvcCapabilities[AVC_CAP_CCM].fStatus  = TRUE;
                pAudioSubunitInfo->fAvcCapabilities[AVC_CAP_CCM].fCommand = TRUE;
                pAudioSubunitInfo->fAvcCapabilities[AVC_CAP_CCM].fStatus  = TRUE;
            }
            else if (STATUS_NOT_IMPLEMENTED == ntStatus) {
                ntStatus = STATUS_SUCCESS;
            }
        }
    }

    
    ntStatus = AudioSet61883IsochParameters( pKsDevice );
    if ( !NT_SUCCESS(ntStatus) ) {
        _DbgPrintF( DEBUGLVL_ERROR, ("Cannot SetIsoch Parameters: %x\n",ntStatus));
    }

    // If the device is powered off, turn it on.
    if ( pUnitInfo->fAvcCapabilities[AVC_CAP_POWER].fCommand ) {
        ASSERT(pUnitInfo->fAvcCapabilities[AVC_CAP_POWER].fStatus);
        ntStatus = AvcPower( pKsDevice, TRUE, AVC_CTYPE_STATUS, &bPowerState );
        if ( NT_SUCCESS(ntStatus) && ( bPowerState == AVC_OFF )) {
            bPowerState = AVC_ON;
            ntStatus = AvcPower( pKsDevice, TRUE, AVC_CTYPE_CONTROL, &bPowerState );
            if ( !NT_SUCCESS(ntStatus) ) {
                _DbgPrintF( DEBUGLVL_ERROR, ("Cannot Turn On Power: %x\n",ntStatus));
            }
        }
        if ( NT_SUCCESS(ntStatus) ) 
            pUnitInfo->bPowerState = bPowerState;
        else
            pUnitInfo->bPowerState = AVC_ON; // ASSUME that no idiot made a device you can't turn on.
    }

    // Need to power up subunit???
    if ( pAudioSubunitInfo->fAvcCapabilities[AVC_CAP_POWER].fCommand ) {
        ASSERT(pAudioSubunitInfo->fAvcCapabilities[AVC_CAP_POWER].fStatus);
        ntStatus = AvcPower( pKsDevice, FALSE, AVC_CTYPE_STATUS, &bPowerState );
        if ( NT_SUCCESS(ntStatus) && ( bPowerState == AVC_OFF )) {
            bPowerState = AVC_ON;
            ntStatus = AvcPower( pKsDevice, FALSE, AVC_CTYPE_CONTROL, &bPowerState );
#if DBG            
            if ( !NT_SUCCESS(ntStatus) ) {
                _DbgPrintF( DEBUGLVL_ERROR, ("Cannot Turn On Power: %x\n",ntStatus));
            }
#endif
        }
    }

    return ntStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\drivers\avcaudio\am824.c ===
#include "Common.h"

#define IEC958_PREAMBLE_CODE_B    0x30000000
#define IEC958_PREAMBLE_CODE_W1   0x20000000
#define IEC958_PREAMBLE_CODE_M    0x10000000
#define IEC958_PREAMBLE_CODE_W    0x00000000

#define IEC958_CHANNEL_STATUS     0x04000000

#define IEC958_BLOCK_SIZE        192

UCHAR                    
EvenParityLookupTable[] = { 
        0, 8, 8, 0, 8, 0, 0, 8,
        8, 0, 0, 8, 0, 8, 8, 0,
        8, 0, 0, 8, 0, 8, 8, 0,
        0, 8, 8, 0, 8, 0, 0, 8,
        8, 0, 0, 8, 0, 8, 8, 0,
        0, 8, 8, 0, 8, 0, 0, 8,
        0, 8, 8, 0, 8, 0, 0, 8,
        8, 0, 0, 8, 0, 8, 8, 0,
        8, 0, 0, 8, 0, 8, 8, 0,
        0, 8, 8, 0, 8, 0, 0, 8,
        0, 8, 8, 0, 8, 0, 0, 8,
        8, 0, 0, 8, 0, 8, 8, 0,
        0, 8, 8, 0, 8, 0, 0, 8,
        8, 0, 0, 8, 0, 8, 8, 0,
        8, 0, 0, 8, 0, 8, 8, 0,
        0, 8, 8, 0, 8, 0, 0, 8,
        8, 0, 0, 8, 0, 8, 8, 0,
        0, 8, 8, 0, 8, 0, 0, 8,
        0, 8, 8, 0, 8, 0, 0, 8,
        8, 0, 0, 8, 0, 8, 8, 0,
        0, 8, 8, 0, 8, 0, 0, 8,
        8, 0, 0, 8, 0, 8, 8, 0,
        8, 0, 0, 8, 0, 8, 8, 0,
        0, 8, 8, 0, 8, 0, 0, 8,
        0, 8, 8, 0, 8, 0, 0, 8,
        8, 0, 0, 8, 0, 8, 8, 0,
        8, 0, 0, 8, 0, 8, 8, 0,
        0, 8, 8, 0, 8, 0, 0, 8,
        8, 0, 0, 8, 0, 8, 8, 0,
        0, 8, 8, 0, 8, 0, 0, 8,
        0, 8, 8, 0, 8, 0, 0, 8,
        8, 0, 0, 8, 0, 8, 8, 0 
};

void
AM824IEC958FromPCM( 
    PPIN_CONTEXT pPinContext,
    PKSSTREAM_POINTER_OFFSET pKsStreamPtrOffsetIn,
    ULONG ulNumChannels,
    ULONG ulSampleRate )
{
    ULONG ulNumSamples = (pKsStreamPtrOffsetIn->Remaining>>2) / ulNumChannels;
    ULONG ulPreambleCode;
    ULONG i, j;
	union {
		PUCHAR pData;
		PULONG pulData;
	} u;

    u.pData = pKsStreamPtrOffsetIn->Data;

    for (i=0; i<ulNumSamples; i++) {

        pPinContext->ulSampleCount %= IEC958_BLOCK_SIZE;

        ulPreambleCode = ( pPinContext->ulSampleCount == 0 ) ? IEC958_PREAMBLE_CODE_B :
                                                               IEC958_PREAMBLE_CODE_M ;

        for (j=0; j<ulNumChannels; j++, u.pulData++) {
            ULONG ulDataValue;

            switch ( pPinContext->ulSampleCount ) {
                case 2: // No Copy Protect
                    *u.pulData = bswap(((*u.pulData)>>8) | ulPreambleCode | IEC958_CHANNEL_STATUS);
                    break;
                case 24: 
                    if ( ulSampleRate == 32000 ) {
                        *u.pulData = bswap(((*u.pulData)>>8) | ulPreambleCode | IEC958_CHANNEL_STATUS);
                    }
                    else {
                        *u.pulData = bswap(((*u.pulData)>>8) | ulPreambleCode);
                    }
                    break;
                case 25: 
                    if (( ulSampleRate == 32000 ) || ( ulSampleRate == 48000 ) ){
                        *u.pulData = bswap(((*u.pulData)>>8) | ulPreambleCode | IEC958_CHANNEL_STATUS);
                    }
                    else {
                        *u.pulData = bswap(((*u.pulData)>>8) | ulPreambleCode);
                    }
                    break;
                default:
                    *u.pulData = bswap(((*u.pulData)>>8) | ulPreambleCode);
                    break;
            }

            // parity check
            ulDataValue = (ULONG)((u.pData[0] & 0xF) ^ u.pData[1] ^ u.pData[2] ^ u.pData[3]);
            u.pData[0] |= EvenParityLookupTable[ulDataValue];
//            ulPreambleCode &= IEC958_PREAMBLE_CODE_W1;
            ulPreambleCode = 0;

//            DbgLog("AM824",j,pPinContext->ulSampleCount,*u.pulData, 0);
        }

        pPinContext->ulSampleCount++;
    }
}

#define AM824_RAW_24BIT 0x40
#define AM824_RAW_20BIT 0x41
#define AM824_RAW_16BIT 0x42

void
AM824RawFromPCM( 
    PPIN_CONTEXT pPinContext,
    PKSSTREAM_POINTER_OFFSET pKsStreamPtrOffsetIn,
    ULONG ulNumBits )
{
    ULONG ulNumSamples = (pKsStreamPtrOffsetIn->Remaining>>2);
    ULONG ulHeader = 0;
    PULONG pulData;
    ULONG i;

    pulData = (PULONG)pKsStreamPtrOffsetIn->Data;

    switch (ulNumBits) {
        case 16: ulHeader = AM824_RAW_16BIT; break;
        case 20: ulHeader = AM824_RAW_20BIT; break;
        case 24: ulHeader = AM824_RAW_24BIT; break;

        default:
            break;
    }

    for (i=0; i<ulNumSamples; i++, pulData++) {
        *pulData = bswap((*pulData)>>8) | ulHeader;
    }
}

void
AM824ToPCM( PPIN_CONTEXT pPinContext )
{
    PAV_CLIENT_REQUEST_LIST_ENTRY pAVListEntry;
    PKSSTREAM_POINTER_OFFSET pKsStreamPtrOffsetOut;
    PKSSTREAM_POINTER pKsStreamPtr;
    ULONG ulNumWords;
    PULONG pulData;
    ULONG i;
    KIRQL irql;

    DbgLog("824ToPc", pPinContext, 0, 0, 0);

    KeAcquireSpinLock(&pPinContext->PinSpinLock, &irql);
    while ( !IsListEmpty(&pPinContext->CompletedRequestList ) ) {
        pAVListEntry = 
            (PAV_CLIENT_REQUEST_LIST_ENTRY)RemoveHeadList(&pPinContext->CompletedRequestList);
        KeReleaseSpinLock(&pPinContext->PinSpinLock, irql);

        pKsStreamPtr = pAVListEntry->pKsStreamPtr;
        pKsStreamPtrOffsetOut = pKsStreamPtr->Offset;
        ulNumWords = pKsStreamPtrOffsetOut->Remaining>>2;
        pulData    = (PULONG)pKsStreamPtrOffsetOut->Data;

        DbgLog("824ToP1", pKsStreamPtr, ulNumWords, pulData, 0);

        for (i=0; i<ulNumWords; i++, pulData++) {
            *pulData = (bswap(*pulData))<<8;
        }

        KsStreamPointerAdvanceOffsetsAndUnlock( pKsStreamPtr,
                                                0,
                                                pKsStreamPtrOffsetOut->Count,
                                                TRUE );

        // Need to free the Clone
        KsStreamPointerDelete(pKsStreamPtr);

        ExFreeToNPagedLookasideList( &pPinContext->CipRequestLookasideList, 
                                     &pAVListEntry->List );

        KeAcquireSpinLock(&pPinContext->PinSpinLock, &irql);
    }

    pPinContext->fWorkItemInProgress = FALSE;
    KeReleaseSpinLock(&pPinContext->PinSpinLock, irql);

}

ULONG ulMaxSecondCount = 0;

ULONG
AM824FrameCallback( 
    IN PCIP_NOTIFY_INFO pNotifyInfo )
{
    PAV_CLIENT_REQUEST_LIST_ENTRY pAVListEntry = 
        (PAV_CLIENT_REQUEST_LIST_ENTRY)pNotifyInfo->Context;
    PPIN_CONTEXT pPinContext = (PPIN_CONTEXT)pAVListEntry->pKsPin->Context;
    KIRQL irql;

    KeAcquireSpinLock(&pPinContext->PinSpinLock, &irql);

    // Get the cycle time and data offset from the returned CIP Frame. Use them
    // later to calculate current position information.
    pPinContext->KsAudioPosition.PlayOffset += pPinContext->ulLastBufferSize;

    pPinContext->ulLastBufferSize = pAVListEntry->pKsStreamPtr->Offset->Count;

    pPinContext->InitialCycleTime = pAVListEntry->Av61883Request.AttachFrame.Frame->Timestamp;

    DbgLog("824CbCT", pPinContext->InitialCycleTime.CL_SecondCount, 
                      pPinContext->InitialCycleTime.CL_CycleCount, 
                      pPinContext->InitialCycleTime.CL_CycleOffset, 
                      0 );

    if ( pPinContext->InitialCycleTime.CL_SecondCount > ulMaxSecondCount )
        ulMaxSecondCount = pPinContext->InitialCycleTime.CL_SecondCount;

    if ( !pPinContext->fStreamStarted ) {
        pPinContext->fStreamStarted = TRUE;
    }

    RemoveEntryList(&pAVListEntry->List);
    if (((++pPinContext->ulUsedBuffers) + pPinContext->ulCancelledBuffers) == pPinContext->ulAttachCount) {
        _DbgPrintF(DEBUGLVL_VERBOSE, ("*******STARVED!!!!!*******\n"));    
        pPinContext->fStreamStarted = FALSE;
        pPinContext->KsAudioPosition.PlayOffset += pPinContext->ulLastBufferSize;
        DbgLog("824CBkS", pAVListEntry->pKsStreamPtr, pAVListEntry, 0, 0);
        KeSetEvent( &pPinContext->PinStarvationEvent, 0, FALSE );
    }
    
    KeReleaseSpinLock(&pPinContext->PinSpinLock, irql);

    DbgLog("824FCBk", pAVListEntry->pKsStreamPtr, pAVListEntry, 0, 0);

    if ( pAVListEntry->pKsPin->DataFlow == KSPIN_DATAFLOW_IN ) {
        
        // Delete the stream pointer to release the buffer.
        KsStreamPointerDelete( pAVListEntry->pKsStreamPtr );
        ExFreeToNPagedLookasideList( &pPinContext->CipRequestLookasideList, 
                                     &pAVListEntry->List );
    }
    else {
        KeAcquireSpinLock(&pPinContext->PinSpinLock, &irql);
        if ( !pPinContext->fWorkItemInProgress ) {
            pPinContext->fWorkItemInProgress = TRUE;
            KeReleaseSpinLock(&pPinContext->PinSpinLock, irql);

            InsertTailList(&pPinContext->CompletedRequestList, &pAVListEntry->List);

            // Initialize worker for data reformat
            ExInitializeWorkItem( &pPinContext->PinWorkItem,
                                  AM824ToPCM,
                                  pPinContext );
            ExQueueWorkItem( &pPinContext->PinWorkItem, CriticalWorkQueue );
        }
        else {
            InsertTailList(&pPinContext->CompletedRequestList, &pAVListEntry->List);

            KeReleaseSpinLock(&pPinContext->PinSpinLock, irql);
        }
    }

	return 0;
}

NTSTATUS
AM824AttachCallback(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP pIrp,
    IN PAV_CLIENT_REQUEST_LIST_ENTRY pAVListEntry )
{
    PPIN_CONTEXT pPinContext = (PPIN_CONTEXT)pAVListEntry->pKsPin->Context;

    if ( !NT_SUCCESS(pIrp->IoStatus.Status) ) {

        // Add wasted data offset to position
        pPinContext->KsAudioPosition.PlayOffset += pAVListEntry->pKsStreamPtr->Offset->Count;

        // Set error status code in stream pointer.
        KsStreamPointerSetStatusCode (pAVListEntry->pKsStreamPtr, pIrp->IoStatus.Status);

        // Delete the stream pointer to release the buffer.
        KsStreamPointerDelete( pAVListEntry->pKsStreamPtr );

        ExFreeToNPagedLookasideList( &pPinContext->CipRequestLookasideList, 
                                     &pAVListEntry->List );
    }

    // Free the Irp used to attach the buffer.
    IoFreeIrp(pIrp);
    
	return STATUS_MORE_PROCESSING_REQUIRED;
}

NTSTATUS
AM824CreateCipRequest( 
    PKSPIN pKsPin,
    PKSSTREAM_POINTER pKsStreamPtr )
{
    PPIN_CONTEXT pPinContext = (PPIN_CONTEXT)pKsPin->Context;
    PKSSTREAM_POINTER_OFFSET pKsStreamPtrOffsetIn = pKsStreamPtr->Offset;
    PWAVEFORMATPCMEX pWavFormatPCMEx = (PWAVEFORMATPCMEX)(pKsPin->ConnectionFormat+1);
    ULONG ulNumChannels = pWavFormatPCMEx->Format.nChannels;
    ULONG ulSampleRate  = pWavFormatPCMEx->Format.nSamplesPerSec;
    PAV_CLIENT_REQUEST_LIST_ENTRY pAVListEntry;
    PCIP_ATTACH_FRAME pCipAttachFrame;
    PCIP_FRAME pCipFrame;
    PIO_STACK_LOCATION pNextIrpStack;
    PIRP pIrp;

    // Get a request entry from our lookaside
    pAVListEntry = (PAV_CLIENT_REQUEST_LIST_ENTRY)
        ExAllocateFromNPagedLookasideList(&pPinContext->CipRequestLookasideList);
    if ( NULL == pAVListEntry ) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(pAVListEntry, sizeof(AV_CLIENT_REQUEST_LIST_ENTRY) + sizeof(CIP_FRAME));

    pAVListEntry->pKsPin       = pKsPin;
    pAVListEntry->pKsStreamPtr = pKsStreamPtr;
    
    pCipFrame = (PCIP_FRAME)(pAVListEntry + 1);
    pCipAttachFrame = &pAVListEntry->Av61883Request.AttachFrame;

    INIT_61883_HEADER(&pAVListEntry->Av61883Request, Av61883_AttachFrame);
    pCipAttachFrame->hConnect     = pPinContext->hConnection;
    pCipAttachFrame->SourceLength = ulNumChannels*sizeof(ULONG); // Block Size
    pCipAttachFrame->FrameLength  = pKsStreamPtrOffsetIn->Count;
    pCipAttachFrame->Frame        = pCipFrame;

    pCipFrame->Flags         = CIP_AUDIO_STYLE_SYT;
    pCipFrame->Packet        = pKsStreamPtrOffsetIn->Data;
    pCipFrame->pfnNotify     = AM824FrameCallback;
    pCipFrame->NotifyContext = pAVListEntry;

    // Assume that the data format gives us data for each channel in 32 bits 
    // per channel format regardless of the data bit width. This can be 
    // enforced with the proper data intersection code.

    // If Rendering reformat data before attaching
    if (pKsPin->DataFlow == KSPIN_DATAFLOW_IN) {
        // ISSUE-2001/01/10-dsisolak Assuming IEC958 for now. 
        switch (pPinContext->pFwAudioDataRange->ulTransportType) {
            case MLAN_AM824_IEC958:
                DbgLog("AMtoIEC", pPinContext, pKsStreamPtrOffsetIn, 0, 0);
                ASSERT( ulSampleRate <= 48000 );
                AM824IEC958FromPCM( pPinContext, 
                                    pKsStreamPtrOffsetIn, 
                                    ulNumChannels,
                                    ulSampleRate );
                break;

            case MLAN_AM824_RAW:
                AM824RawFromPCM( pPinContext, pKsStreamPtrOffsetIn, 
                                 pWavFormatPCMEx->Samples.wValidBitsPerSample );
                break;

            case MLAN_24BIT_PACKED:
                TRAP;
                break;
        }
    }

    // Prepare an IRP to make this request
    pIrp = IoAllocateIrp(pPinContext->pPhysicalDeviceObject->StackSize, FALSE);
    if (NULL == pIrp) return STATUS_INSUFFICIENT_RESOURCES;

    pNextIrpStack = IoGetNextIrpStackLocation(pIrp);
    pNextIrpStack->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
    pNextIrpStack->Parameters.DeviceIoControl.IoControlCode = IOCTL_61883_CLASS;
    pNextIrpStack->Parameters.Others.Argument1 = &pAVListEntry->Av61883Request;

    IoSetCompletionRoutine( pIrp, AM824AttachCallback,((PVOID)pAVListEntry), 
                            TRUE, TRUE, TRUE );

    ExInterlockedInsertHeadList( &pPinContext->OutstandingRequestList, 
                                 &pAVListEntry->List,
                                 &pPinContext->PinSpinLock );

    InterlockedIncrement( &pPinContext->ulAttachCount );

    return IoCallDriver( pPinContext->pPhysicalDeviceObject, pIrp );

}

NTSTATUS
AM824ProcessData( PKSPIN pKsPin )
{
    PKSFILTER pKsFilter = KsPinGetParentFilter( pKsPin );
	PKSDEVICE pKsDevice = (PKSDEVICE)pKsFilter->Context;
    PPIN_CONTEXT pPinContext = (PPIN_CONTEXT)pKsPin->Context;
    PKSSTREAM_POINTER pKsStreamPtr, pKsCloneStreamPtr;
    NTSTATUS ntStatus;

    if ( pPinContext->pCmpRegister ) {
        if ( !pPinContext->pCmpRegister->AvPcr.oPCR.PPCCounter ) {
            _DbgPrintF( DEBUGLVL_VERBOSE, ("ERROR: LostConnection %x\n", 
                                         pPinContext->pCmpRegister->AvPcr.ulongData));
            return STATUS_DEVICE_NOT_READY;
        }
    }

    // Get the next stream pointer from the queue
    pKsStreamPtr = KsPinGetLeadingEdgeStreamPointer( pKsPin, KSSTREAM_POINTER_STATE_LOCKED );

    if ( pKsStreamPtr ) {

        if ( pKsStreamPtr->StreamHeader->OptionsFlags & KSSTREAM_HEADER_OPTIONSF_TYPECHANGED) {
            // Need to change data formats if possible???.
            KsStreamPointerSetStatusCode (pKsStreamPtr, STATUS_NOT_SUPPORTED);
            KsStreamPointerUnlock( pKsStreamPtr, TRUE );

            return STATUS_SUCCESS;
        }
        else if ( pKsStreamPtr->StreamHeader->OptionsFlags & KSSTREAM_HEADER_OPTIONSF_ENDOFSTREAM ) {
            if ( !pKsStreamPtr->Offset->Data ) {
                KsStreamPointerUnlock( pKsStreamPtr, TRUE );
                return STATUS_SUCCESS;
            }
        }

        // Update the Write Offset.
        pPinContext->KsAudioPosition.WriteOffset += pKsStreamPtr->Offset->Count;

        // Clone Stream pointer to keep queue moving.
        ntStatus = KsStreamPointerClone( pKsStreamPtr, 
		                                 NULL, 0, 
			    						 &pKsCloneStreamPtr ); 
	    if ( NT_SUCCESS(ntStatus) ) {

            ntStatus = AM824CreateCipRequest( pKsPin, pKsCloneStreamPtr );
            if ( !NT_SUCCESS(ntStatus) ) {
                _DbgPrintF( DEBUGLVL_ERROR, ("ERROR: AM824CreateCipRequest falied: %x", ntStatus ));
            }

            if ( !pPinContext->fIsTalking ) {
                if ((pKsPin->DataFlow == KSPIN_DATAFLOW_IN) && NT_SUCCESS(ntStatus)) {

                    _DbgPrintF(DEBUGLVL_VERBOSE, ("Start Talking...\n"));
                    ntStatus = 
                        Av61883StartTalkingOrListening( pKsDevice,
                                                        pPinContext->hConnection,
                                                        Av61883_Talk );
                    if (NT_SUCCESS(ntStatus)) {
                        pPinContext->fIsTalking = TRUE;
                    }
                }
            }

            // Unlock the stream pointer. This will really only unlock after last clone is deleted.
            KsStreamPointerUnlock( pKsStreamPtr, TRUE );

        }

        if ( ntStatus == STATUS_PENDING ) ntStatus = STATUS_SUCCESS;
    }
    else {
        TRAP;
        return STATUS_DEVICE_DATA_ERROR;
    }

    return ntStatus;

}

NTSTATUS
AM824CancelCallback(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP pIrp,
    IN PAV_CLIENT_REQUEST_LIST_ENTRY pAVListEntry )
{
    PPIN_CONTEXT pPinContext = (PPIN_CONTEXT)pAVListEntry->pKsPin->Context;
    KIRQL irql;

    if ( NT_SUCCESS(pIrp->IoStatus.Status) ) {

        KsStreamPointerDelete( pAVListEntry->pKsStreamPtr );

        KeAcquireSpinLock(&pPinContext->PinSpinLock, &irql);
        if (((++pPinContext->ulCancelledBuffers) + pPinContext->ulUsedBuffers ) == pPinContext->ulAttachCount) {
            _DbgPrintF(DEBUGLVL_VERBOSE, ("*******Cancel STARVED!!!!!*******\n"));    
            KeSetEvent( &pPinContext->PinStarvationEvent, 0, FALSE );
        }
        KeReleaseSpinLock(&pPinContext->PinSpinLock, irql);

        DbgLog("824CCBk", pAVListEntry->pKsStreamPtr, pAVListEntry, 0, 0);


        ExFreeToNPagedLookasideList( &pPinContext->CipRequestLookasideList, 
                                     &pAVListEntry->List );
    }

    // Free the Irp used to cancel the buffer.
    IoFreeIrp(pIrp);

    return STATUS_MORE_PROCESSING_REQUIRED;
}

NTSTATUS
AM824CancelRequest( 
    PAV_CLIENT_REQUEST_LIST_ENTRY pAVListEntry )
{
    PPIN_CONTEXT pPinContext = pAVListEntry->pKsPin->Context;
    PCIP_CANCEL_FRAME pCipCancelFrame = &pAVListEntry->Av61883Request.CancelFrame;
    PCIP_FRAME pCipFrame = pAVListEntry->Av61883Request.AttachFrame.Frame;
    PIO_STACK_LOCATION pNextIrpStack;
    PIRP pIrp;

    INIT_61883_HEADER(&pAVListEntry->Av61883Request, Av61883_CancelFrame);
    pCipCancelFrame->hConnect = pPinContext->hConnection;
    pCipCancelFrame->Frame    = pCipFrame;

    pIrp = IoAllocateIrp(pPinContext->pPhysicalDeviceObject->StackSize, FALSE);
    if (NULL == pIrp) return STATUS_INSUFFICIENT_RESOURCES;

    pNextIrpStack = IoGetNextIrpStackLocation(pIrp);
    pNextIrpStack->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
    pNextIrpStack->Parameters.DeviceIoControl.IoControlCode = IOCTL_61883_CLASS;
    pNextIrpStack->Parameters.Others.Argument1 = &pAVListEntry->Av61883Request;

    IoSetCompletionRoutine( pIrp, AM824CancelCallback,((PVOID)pAVListEntry), 
                            TRUE, TRUE, TRUE );

    return IoCallDriver( pPinContext->pPhysicalDeviceObject, pIrp );
}

NTSTATUS
AM824AudioPosition(
    PKSPIN pKsPin,
    PKSAUDIO_POSITION pPosition )
{
    PWAVEFORMATEX pWavFmtEx = (PWAVEFORMATEX)(pKsPin->ConnectionFormat + 1);
    PPIN_CONTEXT pPinContext = pKsPin->Context;
    ULONGLONG ulAvgBytesPerSec = pWavFmtEx->nAvgBytesPerSec;
    ULONGLONG ullPlayOffset;
    CYCLE_TIME InitCycleTime, CycleTime;
    NTSTATUS ntStatus;
    ULONGLONG ulSeconds;
    ULONGLONG ulCycles;
    KIRQL kIrql;

    // Get the cycle time of last completed data request.
    KeAcquireSpinLock( &pPinContext->PinSpinLock, &kIrql );
    InitCycleTime = pPinContext->InitialCycleTime;
    ullPlayOffset = pPinContext->KsAudioPosition.PlayOffset;
    KeReleaseSpinLock( &pPinContext->PinSpinLock, kIrql );

    // Get the current cycle time.
    ntStatus = Bus1394GetCycleTime( pPinContext->pPhysicalDeviceObject, &CycleTime );

    // Calculate the difference in time from the start time to current and
    // translate that into cycles.

    if ( NT_SUCCESS(ntStatus) ) {
        DbgLog("AM824P1", InitCycleTime.CL_SecondCount, 
                          InitCycleTime.CL_CycleCount,
                          CycleTime.CL_SecondCount,
                          CycleTime.CL_CycleCount );

        CycleTime.CL_SecondCount &= 0x7;

        if ( Bus1394CycleTimeCompare( InitCycleTime, CycleTime ) < 1 ) {
            CYCLE_TIME TmpCycleTime1 = { 0, 8000, 7 };

            // We crossed 0, counter rolled over.
            TmpCycleTime1 = Bus1394CycleTimeDiff( TmpCycleTime1, InitCycleTime );

            ulSeconds = (ULONGLONG)(TmpCycleTime1.CL_SecondCount + CycleTime.CL_SecondCount);
            ulCycles =  (ULONGLONG)(TmpCycleTime1.CL_CycleCount  + CycleTime.CL_CycleCount);

        }
        else {
            CycleTime = Bus1394CycleTimeDiff( CycleTime, InitCycleTime );

            ulSeconds = (ULONGLONG)CycleTime.CL_SecondCount;
            ulCycles  = (ULONGLONG)CycleTime.CL_CycleCount;

        }

//        if ( ulSeconds ) TRAP;

        if ( ulSeconds >= 6 ) { 
            // if the time has elapsed this much assume an error and use the current play offset
            ulSeconds = ulCycles = 0;
        }

        // Calculate the amount of data sent per cycle on average.and multiply by number
        // of cycles elapsed since start.
        pPosition->PlayOffset = ullPlayOffset +
                                ulSeconds * ulAvgBytesPerSec + 
                               ((ulCycles * ulAvgBytesPerSec) / 8000 );

        DbgLog("AM824P2", ulSeconds, ulCycles, pPosition->WriteOffset, pPosition->PlayOffset);
    }

    return ntStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\drivers\avcaudio\avc.c ===
#include "Common.h"

NTSTATUS
AvcCheckResponse( 
    NTSTATUS ntStatus,
    UCHAR ucResponseCode )
{
    if ( STATUS_SUCCESS == ntStatus ) {
        switch(ucResponseCode) {
            case AVC_RESPONSE_NOTIMPL:
                ntStatus = STATUS_NOT_IMPLEMENTED;
                break;
            case AVC_RESPONSE_ACCEPTED:
            case AVC_RESPONSE_STABLE:
                ntStatus = STATUS_SUCCESS;
                break;
            case AVC_RESPONSE_REJECTED:
                ntStatus = STATUS_INVALID_PARAMETER;
                break;
            case AVC_RESPONSE_IN_TRANSITION:
            case AVC_RESPONSE_CHANGED:
            case AVC_RESPONSE_INTERIM:
                ntStatus = STATUS_SUCCESS;
                break;
            default:
                ntStatus = STATUS_SUCCESS;
                break;
        }
    }
    else if ( STATUS_TIMEOUT == ntStatus ) {
        ntStatus = STATUS_DEVICE_DATA_ERROR;
    }

    return ntStatus;
}


NTSTATUS
AvcSubmitIrbSync(
    IN PKSDEVICE pKsDevice,
    PAVC_COMMAND_IRB pAvcIrb )
{
    PKEVENT pKsEvent;
    PIO_STATUS_BLOCK pIoStatus;
    PIO_STACK_LOCATION nextStack;
    NTSTATUS ntStatus, status;
    PIRP pIrp;

    // Get event and status pointers
    pKsEvent  = (PKEVENT)(pAvcIrb + 1);
    pIoStatus = (PIO_STATUS_BLOCK)(pKsEvent+1);

#if 0
    pAvcIrb->TimeoutFlag = TRUE;
    pAvcIrb->RetryFlag   = TRUE;
    pAvcIrb->Retries     = 100;
    pAvcIrb->Timeout.QuadPart = 0xFFFFFFFF;
#endif

    // issue a synchronous request
    KeInitializeEvent(pKsEvent, NotificationEvent, FALSE);

    pAvcIrb->Function = AVC_FUNCTION_COMMAND;

    pIrp = IoBuildDeviceIoControlRequest(
                IOCTL_AVC_CLASS,
                pKsDevice->NextDeviceObject,
                NULL,
                0,
                NULL,
                0,
                TRUE,
                pKsEvent,
                pIoStatus );

    if ( !pIrp ) {
        FreeMem(pKsEvent);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    nextStack = IoGetNextIrpStackLocation(pIrp);
    ASSERT(nextStack != NULL);

    nextStack->Parameters.Others.Argument1 = pAvcIrb;

    // Call the 61883 class driver to perform the operation.  If the returned status
    // is PENDING, wait for the request to complete.
    ntStatus = IoCallDriver( pKsDevice->NextDeviceObject, pIrp );

    if (ntStatus == STATUS_PENDING) {

        // ISSUE-2001/02/06-dsisolak Need to timeout wait
        status = KeWaitForSingleObject( pKsEvent, Executive, KernelMode, FALSE, NULL );

    }

    ntStatus = AvcCheckResponse( pIoStatus->Status, pAvcIrb->ResponseCode );

    return ntStatus;
}

NTSTATUS
AvcSubmitMultifuncIrbSync(
    PKSDEVICE pKsDevice,
    PAVC_MULTIFUNC_IRB pAvcIrb,
    AVC_FUNCTION AvcFunc )
{
    IN PDEVICE_OBJECT pPhysicalDeviceObject = pKsDevice->NextDeviceObject;
    PKEVENT pKsEvent;
    PIO_STATUS_BLOCK pIoStatus;
    PIO_STACK_LOCATION nextStack;
    NTSTATUS ntStatus, status;
    PIRP pIrp;

    // Get event and status pointers
    pKsEvent  = (PKEVENT)(pAvcIrb + 1);
    pIoStatus = (PIO_STATUS_BLOCK)(pKsEvent+1);

    // issue a synchronous request
    KeInitializeEvent(pKsEvent, NotificationEvent, FALSE);

    pAvcIrb->Function = AvcFunc;

    pIrp = IoBuildDeviceIoControlRequest(
                IOCTL_AVC_CLASS,
                pPhysicalDeviceObject,
                NULL,
                0,
                NULL,
                0,
                TRUE,
                pKsEvent,
                pIoStatus );

    if ( !pIrp ) {
        FreeMem(pKsEvent);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    nextStack = IoGetNextIrpStackLocation(pIrp);
    ASSERT(nextStack != NULL);

    nextStack->Parameters.Others.Argument1 = pAvcIrb;

    // Call the Avc class driver to perform the operation.  If the returned status
    // is PENDING, wait for the request to complete.
    ntStatus = IoCallDriver( pPhysicalDeviceObject, pIrp );

    if (ntStatus == STATUS_PENDING) {

        status = KeWaitForSingleObject( pKsEvent, Suspended, KernelMode, FALSE, NULL );

        ntStatus = pIoStatus->Status;
    }


    return ntStatus;
}

NTSTATUS
AvcOpenDescriptorCommand(
    PKSDEVICE pKsDevice,
    AVC_DESCRIPTOR_TYPE AvcDescType,
    PUCHAR pAvcDescTypeSpecRef,
    ULONG ulTypeSpecRefLen,
    UCHAR ucSubFunction,
    BOOLEAN fUnitCommand )
{
    PHW_DEVICE_EXTENSION pHwDevExt = (PHW_DEVICE_EXTENSION)pKsDevice->Context;
    PAVC_COMMAND_IRB pAvcIrb;
    PUCHAR pOperands;
    ULONG i;
    NTSTATUS ntStatus;
    UCHAR ucUnitAddress = 0xFF;

    _DbgPrintF( DEBUGLVL_VERBOSE, ("[AvcOpenCloseDescriptor] ucSubFunction = %x\n",ucSubFunction));

    pAvcIrb = (PAVC_COMMAND_IRB)
		ExAllocateFromNPagedLookasideList(&pHwDevExt->AvcCommandLookasideList);
    if ( NULL == pAvcIrb ) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    RtlZeroMemory(pAvcIrb, sizeof(AVC_COMMAND_IRB));

    if ( fUnitCommand ) {
        pAvcIrb->SubunitAddrFlag = TRUE;
        pAvcIrb->SubunitAddr     = &ucUnitAddress;
    }

    pOperands = pAvcIrb->Operands;

    // Set up Open Control command in AvcIrb.
    pAvcIrb->CommandType   = AVC_CTYPE_CONTROL;
    pAvcIrb->Opcode        = AVC_OPEN_DESCRIPTOR;
    pAvcIrb->OperandLength = 3 + ulTypeSpecRefLen;

    pOperands[0] = (UCHAR)AvcDescType;

    for ( i=1; i<(ulTypeSpecRefLen+1); i++ ) {
        pOperands[i] = pAvcDescTypeSpecRef[i-1];
    }
    pOperands[i++] = ucSubFunction; //AVC_SUBFUNC_READ_OPEN;
    pOperands[i] = 0x00;
    
    ntStatus = AvcSubmitIrbSync( pKsDevice, pAvcIrb );

    ExFreeToNPagedLookasideList(&pHwDevExt->AvcCommandLookasideList, pAvcIrb);

    return ntStatus;
}

NTSTATUS
AvcReadDescriptor(
    PKSDEVICE pKsDevice,
    AVC_DESCRIPTOR_TYPE AvcDescType,
    PUCHAR pAvcDescTypeSpecRef,
    ULONG ulTypeSpecRefLen,
    ULONG ulDataLength,
    ULONG ulOffsetAddress,
    PULONG pDescriptorLength,
    PUCHAR pDescriptor,
    BOOLEAN fUnitCommand )
{
    PHW_DEVICE_EXTENSION pHwDevExt = (PHW_DEVICE_EXTENSION)pKsDevice->Context;
    PAVC_COMMAND_IRB pAvcIrb;
    PUCHAR pOperands;
    NTSTATUS ntStatus;
    ULONG ulDataLenOffset;
    UCHAR ucUnitAddress = 0xFF;
    ULONG i=0;

    _DbgPrintF( DEBUGLVL_VERBOSE, ("[AvcReadDescriptor]\n"));

    pAvcIrb = (PAVC_COMMAND_IRB)
		ExAllocateFromNPagedLookasideList(&pHwDevExt->AvcCommandLookasideList);
    if ( NULL == pAvcIrb ) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    
    RtlZeroMemory(pAvcIrb, sizeof(AVC_COMMAND_IRB));

    if ( fUnitCommand ) {
        pAvcIrb->SubunitAddrFlag = TRUE;
        pAvcIrb->SubunitAddr     = &ucUnitAddress;
    }

    pOperands = pAvcIrb->Operands;

    // Set up Read Control command in AvcIrb.
    pAvcIrb->CommandType   = AVC_CTYPE_CONTROL;
    pAvcIrb->Opcode        = AVC_READ_DESCRIPTOR;
    pAvcIrb->OperandLength = 7 + ulTypeSpecRefLen;

    pOperands[0] = AvcDescType; // AVC_DESCTYPE_UNIT_IDENTIFIER;
    for ( i=1; i<(ulTypeSpecRefLen+1); i++ ) {
        pOperands[i] = pAvcDescTypeSpecRef[i-1];
    }

    pOperands[i] = 0xFF;

    i += 2; // Space for read result and reserved fields
    ulDataLenOffset = i;
    pOperands[i++] = ((PUCHAR)&ulDataLength)[2];
    pOperands[i++] = ((PUCHAR)&ulDataLength)[1];
    pOperands[i++] = ((PUCHAR)&ulOffsetAddress)[2];
    pOperands[i++] = ((PUCHAR)&ulOffsetAddress)[1];

    ntStatus = AvcSubmitIrbSync( pKsDevice, pAvcIrb );
    if ( NT_SUCCESS(ntStatus) ) {
        // ISSUE-2001/01/10-dsisolak Need to check read status
        *pDescriptorLength = ((ULONG)pOperands[ulDataLenOffset]<<8) |
                              (ULONG)pOperands[ulDataLenOffset+1];
        if ( pDescriptor ) {
            RtlCopyMemory( pDescriptor,
                           &pOperands[ulDataLenOffset+4],
                           *pDescriptorLength );
        }
    }

    ExFreeToNPagedLookasideList(&pHwDevExt->AvcCommandLookasideList, pAvcIrb);

    return ntStatus;
}

NTSTATUS
AvcGetSubunitIdentifierDesc(
    PKSDEVICE pKsDevice,
    PUCHAR *ppSuDescriptor )
{
    PUCHAR pDescriptor;
    ULONG ulDescLen;
    NTSTATUS ntStatus;

    _DbgPrintF( DEBUGLVL_VERBOSE, ("[AvcGetSubunitIdentifierDesc]\n"));

    // Open the Subunit Identifier Descriptor
    ntStatus = AvcOpenDescriptorCommand( pKsDevice, 
                                         AVC_DESCTYPE_SUBUNIT_IDENTIFIER, 
                                         NULL,
                                         0,
                                         (UCHAR)AVC_SUBFUNC_READ_OPEN,
                                         FALSE );
    if ( NT_SUCCESS(ntStatus) ) {
        ntStatus = AvcReadDescriptor( pKsDevice,
                                      AVC_DESCTYPE_SUBUNIT_IDENTIFIER, 
                                      NULL,
                                      0,
                                      0,
                                      0, 
                                      &ulDescLen,
                                      NULL,
                                      FALSE );

    }

    if ( !NT_SUCCESS(ntStatus) ) return ntStatus;

    // Save the Subunit Identifier Desc.
    pDescriptor = AllocMem( NonPagedPool, ulDescLen+2 );
    if ( NULL == pDescriptor ) {
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    }
    else {
        KsAddItemToObjectBag(pKsDevice->Bag, pDescriptor, FreeMem);
        ntStatus = AvcReadDescriptor( pKsDevice,
                                      AVC_DESCTYPE_SUBUNIT_IDENTIFIER, 
                                      NULL,
                                      0,
                                      0,
                                      0, 
                                      &ulDescLen,
                                      pDescriptor,
                                      FALSE );
       if ( NT_SUCCESS(ntStatus) ) {
           *ppSuDescriptor = pDescriptor;
           _DbgPrintF( DEBUGLVL_VERBOSE, ("Subunit Descriptor: %x\n", pDescriptor ));
       }
    }


    return ntStatus;
}


NTSTATUS
AvcPlugSignalFormat(
    PKSDEVICE pKsDevice,
    KSPIN_DATAFLOW KsDataFlow,
    ULONG ulSerialPlug,
    UCHAR ucCmdType,
    PUCHAR pFMT,
    PUCHAR pFDF )
{
    PHW_DEVICE_EXTENSION pHwDevExt = (PHW_DEVICE_EXTENSION)pKsDevice->Context;
    PAVC_COMMAND_IRB pAvcIrb;
    UCHAR ucSubunitAddress;
    PUCHAR pOperands;
    ULONG ulDescLen;
    NTSTATUS ntStatus;


    pAvcIrb = (PAVC_COMMAND_IRB)
		ExAllocateFromNPagedLookasideList(&pHwDevExt->AvcCommandLookasideList);
    if ( NULL == pAvcIrb ) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    RtlZeroMemory(pAvcIrb, sizeof(AVC_COMMAND_IRB));

    pOperands = pAvcIrb->Operands;

    // Set up command in AvcIrb.
    ucSubunitAddress = 0xFF;
    pAvcIrb->SubunitAddrFlag = TRUE;
    pAvcIrb->SubunitAddr = &ucSubunitAddress;
    pAvcIrb->CommandType   = ucCmdType;
    pAvcIrb->Opcode        = (KSPIN_DATAFLOW_IN == KsDataFlow) ? 
                                               AVC_INPUT_PLUG_SIGNAL_FORMAT  :
                                               AVC_OUTPUT_PLUG_SIGNAL_FORMAT ;
    pAvcIrb->OperandLength = 5;

    _DbgPrintF( DEBUGLVL_VERBOSE, ("[AvcSetPlugSignalFormat] %s %s\n",
                                      (pAvcIrb->Opcode == AVC_INPUT_PLUG_SIGNAL_FORMAT) ?
                                                   "INPUT_PLUG_FORMAT " :
                                                   "OUTPUT_PLUG_FORMAT",
                                      (ucCmdType == AVC_CTYPE_CONTROL) ? 
                                                   "AVC_CTYPE_CONTROL" :
                                                   "AVC_CTYPE_STATUS"));
    ASSERT(ulSerialPlug<=30);

    pOperands[0] = (UCHAR)ulSerialPlug;

    switch ( ucCmdType ) {
        case AVC_CTYPE_CONTROL:
        case AVC_CTYPE_SPEC_INQ:
            pOperands[1] = *pFMT | (UCHAR)(2<<6);
            pOperands[2] = *pFDF;
            pOperands[3] = 0;
            pOperands[4] = 0;
            break;

        case AVC_CTYPE_STATUS:
            *(PULONG)(&pOperands[1]) = 0xffffffff;
            break;

        default:
            TRAP;  // Should never happen.
            break;
    }

    ntStatus = AvcSubmitIrbSync( pKsDevice, pAvcIrb );
    if ( NT_SUCCESS(ntStatus) && ( ucCmdType == AVC_CTYPE_STATUS )) {
        *pFMT = pOperands[1] & 0x3f;
        *pFDF = pOperands[2];
    }

    ExFreeToNPagedLookasideList(&pHwDevExt->AvcCommandLookasideList, pAvcIrb);

    return ntStatus;
}

NTSTATUS
AvcGetPlugInfo(
    PKSDEVICE pKsDevice,
    ULONG fUnitFlag,
    PUCHAR pPlugCounts )
{
    PHW_DEVICE_EXTENSION pHwDevExt = (PHW_DEVICE_EXTENSION)pKsDevice->Context;
    PAVC_COMMAND_IRB pAvcIrb;
    PUCHAR pOperands;
    UCHAR ucSubunitAddress;
    ULONG ulDescLen;
    NTSTATUS ntStatus;

    _DbgPrintF( DEBUGLVL_VERBOSE, ("[AvcGetPlugInfo]\n"));
//    TRAP;

    pAvcIrb = (PAVC_COMMAND_IRB)
		ExAllocateFromNPagedLookasideList(&pHwDevExt->AvcCommandLookasideList);
    if ( NULL == pAvcIrb ) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    RtlZeroMemory(pAvcIrb, sizeof(AVC_COMMAND_IRB));

    pOperands = pAvcIrb->Operands;

    // If this is a unit command set the appropriate address
    if (fUnitFlag) {
        ucSubunitAddress = 0xFF;
        pAvcIrb->SubunitAddrFlag = TRUE;
        pAvcIrb->SubunitAddr = &ucSubunitAddress;
    }

    // Set up Open Control command in AvcIrb.
    pAvcIrb->CommandType   = AVC_CTYPE_STATUS;
    pAvcIrb->Opcode        = AVC_PLUG_INFO;
    pAvcIrb->OperandLength = 5;

    *(PULONG)(&pOperands[1]) = 0xFFFFFFFF;

    ntStatus = AvcSubmitIrbSync( pKsDevice, pAvcIrb );
    if ( NT_SUCCESS(ntStatus) ) {
        ULONG i;
        for (i=1;i<5;i++)
            pPlugCounts[i-1] = pOperands[i];
    }

    ExFreeToNPagedLookasideList(&pHwDevExt->AvcCommandLookasideList, pAvcIrb);

    return ntStatus;
}

NTSTATUS
AvcConnectDisconnect(
    PKSDEVICE pKsDevice,
    ULONG ulFunction,
    AvcCommandType ulCommandType,
    PAVC_CONNECTION pAvcConnection )
{
    PHW_DEVICE_EXTENSION pHwDevExt = (PHW_DEVICE_EXTENSION)pKsDevice->Context;
    PAVC_COMMAND_IRB pAvcIrb;
    PUCHAR pOperands;
    UCHAR ucSubunitAddress;
    NTSTATUS ntStatus;

    _DbgPrintF( DEBUGLVL_VERBOSE, ("[AvcConnectDisconnect]\n"));

    pAvcIrb = (PAVC_COMMAND_IRB)
		ExAllocateFromNPagedLookasideList(&pHwDevExt->AvcCommandLookasideList);
    if ( NULL == pAvcIrb ) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    RtlZeroMemory(pAvcIrb, sizeof(AVC_COMMAND_IRB));

    pOperands = pAvcIrb->Operands;

    // This is a unit command. Set the appropriate address
    ucSubunitAddress = 0xFF;
    pAvcIrb->SubunitAddrFlag = TRUE;
    pAvcIrb->SubunitAddr = &ucSubunitAddress;

    // Set up Open Control command in AvcIrb.
    pAvcIrb->CommandType   = (UCHAR)ulCommandType;
    pAvcIrb->Opcode        = (UCHAR)ulFunction;
    pAvcIrb->OperandLength = 5;

    *((PAVC_CONNECTION)&pOperands[0]) = *pAvcConnection;

    ntStatus = AvcSubmitIrbSync( pKsDevice, pAvcIrb );
    if ( NT_SUCCESS( ntStatus ) ) {
        *pAvcConnection = *((PAVC_CONNECTION)&pOperands[0]) ;
    }

    ExFreeToNPagedLookasideList(&pHwDevExt->AvcCommandLookasideList, pAvcIrb);

    return ntStatus;

}

NTSTATUS
AvcConnectDisconnectAV(
    PKSDEVICE pKsDevice,
    ULONG ulFunction,
    AvcCommandType ulCommandType,
    PAVC_AV_CONNECTION pAvConnection )
{
    PHW_DEVICE_EXTENSION pHwDevExt = (PHW_DEVICE_EXTENSION)pKsDevice->Context;
    PAVC_COMMAND_IRB pAvcIrb;
    PUCHAR pOperands;
    UCHAR ucSubunitAddress;
    NTSTATUS ntStatus;

    _DbgPrintF( DEBUGLVL_VERBOSE, ("[AvcConnectDisconnectAV]\n"));

    pAvcIrb = (PAVC_COMMAND_IRB)
		ExAllocateFromNPagedLookasideList(&pHwDevExt->AvcCommandLookasideList);
    if ( NULL == pAvcIrb ) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    RtlZeroMemory(pAvcIrb, sizeof(AVC_COMMAND_IRB));

    pOperands = pAvcIrb->Operands;

    // This is a unit command. Set the appropriate address
    ucSubunitAddress = 0xFF;
    pAvcIrb->SubunitAddrFlag = TRUE;
    pAvcIrb->SubunitAddr = &ucSubunitAddress;

    // Set up Open Control command in AvcIrb.
    pAvcIrb->CommandType   = (UCHAR)ulCommandType;
    pAvcIrb->Opcode        = (UCHAR)ulFunction;
    pAvcIrb->OperandLength = 5;

    *((PAVC_AV_CONNECTION)&pOperands[0]) = *pAvConnection;

    ntStatus = AvcSubmitIrbSync( pKsDevice, pAvcIrb );
    if ( NT_SUCCESS(ntStatus) ) {
        RtlCopyMemory( pAvConnection,
                       &pOperands[0],
                       5 );
    }

    ExFreeToNPagedLookasideList(&pHwDevExt->AvcCommandLookasideList, pAvcIrb);

    return ntStatus;

}

NTSTATUS
AvcConnections(
    PKSDEVICE pKsDevice,
    PULONG pNumConnections,
    PVOID pConnections )
{
    PHW_DEVICE_EXTENSION pHwDevExt = (PHW_DEVICE_EXTENSION)pKsDevice->Context;
    PAVC_COMMAND_IRB pAvcIrb;
    PUCHAR pOperands;
    UCHAR ucSubunitAddress;
    ULONG ulDescLen;
    NTSTATUS ntStatus;

    _DbgPrintF( DEBUGLVL_VERBOSE, ("[AvcConnections]\n"));
//    TRAP;

    pAvcIrb = (PAVC_COMMAND_IRB)
		ExAllocateFromNPagedLookasideList(&pHwDevExt->AvcCommandLookasideList);
    if ( NULL == pAvcIrb ) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    RtlZeroMemory(pAvcIrb, sizeof(AVC_COMMAND_IRB));

    pOperands = pAvcIrb->Operands;

    // This is a unit command. Set the appropriate address
    ucSubunitAddress = 0xFF;
    pAvcIrb->SubunitAddrFlag = TRUE;
    pAvcIrb->SubunitAddr = &ucSubunitAddress;

    // Set up Open Control command in AvcIrb.
    pAvcIrb->CommandType   = AVC_CTYPE_STATUS;
    pAvcIrb->Opcode        = AVC_CONNECTIONS_STATUS;
    pAvcIrb->OperandLength = 1;

    pOperands[0] = 0xFF;

    ntStatus = AvcSubmitIrbSync( pKsDevice, pAvcIrb );
    if ( NT_SUCCESS(ntStatus) ) {
        ULONG i;
        *pNumConnections = (ULONG)pOperands[0];
        if (pConnections) {
            RtlCopyMemory( pConnections,
                           &pOperands[1],
                           *pNumConnections * 5 );
#if DBG
            for ( i=0; i<*pNumConnections; i++ ) {
                PAVC_CONNECTION pAvcConnections = (PAVC_CONNECTION)pConnections;

                _DbgPrintF( DEBUGLVL_VERBOSE, ("Connection %d: Locked: %d Permanent: %d\n",i,
                                                    pAvcConnections[i].fLock, pAvcConnections[i].fPermanent ));
                _DbgPrintF( DEBUGLVL_VERBOSE, ("    Source: SubunitID: %x, SubunitType: %x, Plug#: %x\n",
                                                    pAvcConnections[i].SourcePlug.SubunitId,
                                                    pAvcConnections[i].SourcePlug.SubunitType,
                                                    pAvcConnections[i].SourcePlug.ucPlugNumber ));
                _DbgPrintF( DEBUGLVL_VERBOSE, ("    Dest:   SubunitID: %x, SubunitType: %x, Plug#: %x\n",
                                                    pAvcConnections[i].DestinationPlug.SubunitId,
                                                    pAvcConnections[i].DestinationPlug.SubunitType,
                                                    pAvcConnections[i].DestinationPlug.ucPlugNumber ));
            }
#endif
        }
    }

    ExFreeToNPagedLookasideList(&pHwDevExt->AvcCommandLookasideList, pAvcIrb);

    return ntStatus;

}

NTSTATUS
AvcPower(
    PKSDEVICE pKsDevice,
    ULONG fUnitFlag,
    AvcCommandType ulCommandType,
    PAVC_BOOLEAN pPowerState )
{
    PHW_DEVICE_EXTENSION pHwDevExt = (PHW_DEVICE_EXTENSION)pKsDevice->Context;
    PAVC_COMMAND_IRB pAvcIrb;
    PUCHAR pOperands;
    UCHAR ucSubunitAddress;
    NTSTATUS ntStatus;

    _DbgPrintF( DEBUGLVL_VERBOSE, ("[AvcPower]\n"));
//    TRAP;

    pAvcIrb = (PAVC_COMMAND_IRB)
		ExAllocateFromNPagedLookasideList(&pHwDevExt->AvcCommandLookasideList);
    if ( NULL == pAvcIrb ) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    RtlZeroMemory(pAvcIrb, sizeof(AVC_COMMAND_IRB));

    pOperands = pAvcIrb->Operands;

    // This is a unit command. Set the appropriate address
    if ( fUnitFlag ) {
        ucSubunitAddress = 0xFF;
        pAvcIrb->SubunitAddrFlag = TRUE;
        pAvcIrb->SubunitAddr = &ucSubunitAddress;
    }

    // Set up Open Control command in AvcIrb.
    pAvcIrb->CommandType   = (UCHAR)ulCommandType;
    pAvcIrb->Opcode        = AVC_POWER;
    pAvcIrb->OperandLength = 1;

    pOperands[0] = (ulCommandType == AVC_CTYPE_STATUS) ? 0x7f : (UCHAR)*pPowerState;

    ntStatus = AvcSubmitIrbSync( pKsDevice, pAvcIrb );
    if ( NT_SUCCESS( ntStatus ) ) {
        *pPowerState = (AVC_BOOLEAN)pOperands[0];
    }

    ExFreeToNPagedLookasideList(&pHwDevExt->AvcCommandLookasideList, pAvcIrb);

    return ntStatus;

}

NTSTATUS
AvcVendorDependent(
    PKSDEVICE pKsDevice,
    ULONG fUnitFlag,
    ULONG ulCommandType,
    ULONG ulVendorId,
    ULONG ulDataLength,
    PVOID pData )
{
    PHW_DEVICE_EXTENSION pHwDevExt = (PHW_DEVICE_EXTENSION)pKsDevice->Context;
    PAVC_COMMAND_IRB pAvcIrb;
    PUCHAR pOperands;
    UCHAR ucSubunitAddress;
    ULONG ulDescLen;
    NTSTATUS ntStatus;

    _DbgPrintF( DEBUGLVL_VERBOSE, ("[AvcVendorDependent]\n"));
    TRAP;

    pAvcIrb = (PAVC_COMMAND_IRB)
		ExAllocateFromNPagedLookasideList(&pHwDevExt->AvcCommandLookasideList);
    if ( NULL == pAvcIrb ) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    RtlZeroMemory(pAvcIrb, sizeof(AVC_COMMAND_IRB));

    pOperands = pAvcIrb->Operands;

    // This is a unit command. Set the appropriate address
    if ( fUnitFlag ) {
        ucSubunitAddress = 0xFF;
        pAvcIrb->SubunitAddrFlag = TRUE;
        pAvcIrb->SubunitAddr = &ucSubunitAddress;
    }

    // Set up Open Control command in AvcIrb.
    pAvcIrb->CommandType   = (UCHAR)ulCommandType;
    pAvcIrb->Opcode        = AVC_VENDOR_DEPENDENT;
    pAvcIrb->OperandLength = 3 + ulDataLength;

    pOperands[0] = ((PUCHAR)&ulVendorId)[2];
    pOperands[1] = ((PUCHAR)&ulVendorId)[1];
    pOperands[2] = ((PUCHAR)&ulVendorId)[0];

    RtlCopyMemory( &pOperands[3], pData, ulDataLength );

    ntStatus = AvcSubmitIrbSync( pKsDevice, pAvcIrb );
    if ( NT_SUCCESS(ntStatus) ) {
        // Check if the response is successful.
        RtlCopyMemory( pData, pOperands, ulDataLength );
    }

    ExFreeToNPagedLookasideList(&pHwDevExt->AvcCommandLookasideList, pAvcIrb);

    return ntStatus;

}

NTSTATUS
AvcGeneralInquiry(
    PKSDEVICE pKsDevice,
    BOOLEAN fUnitFlag,
    UCHAR ucOpcode )
{
    PHW_DEVICE_EXTENSION pHwDevExt = (PHW_DEVICE_EXTENSION)pKsDevice->Context;
    PAVC_COMMAND_IRB pAvcIrb;
    UCHAR ucSubunitAddress;
    NTSTATUS ntStatus;


    pAvcIrb = (PAVC_COMMAND_IRB)
		ExAllocateFromNPagedLookasideList(&pHwDevExt->AvcCommandLookasideList);
    if ( NULL == pAvcIrb ) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    RtlZeroMemory(pAvcIrb, sizeof(AVC_COMMAND_IRB));

    // This is a unit command. Set the appropriate address
    if ( fUnitFlag ) {
        ucSubunitAddress = 0xFF;
        pAvcIrb->SubunitAddrFlag = TRUE;
        pAvcIrb->SubunitAddr = &ucSubunitAddress;
    }

    // Set up Open Control command in AvcIrb.
    pAvcIrb->CommandType   = (UCHAR)AVC_CTYPE_GEN_INQ;
    pAvcIrb->Opcode        = ucOpcode;
    pAvcIrb->OperandLength = 0;

    ntStatus = AvcSubmitIrbSync( pKsDevice, pAvcIrb );

    _DbgPrintF( DEBUGLVL_VERBOSE, ("[AvcGeneralInquiry] Command: %x Response: %x\n", 
                                 ucOpcode, pAvcIrb->ResponseCode ));

    ExFreeToNPagedLookasideList(&pHwDevExt->AvcCommandLookasideList, pAvcIrb);

    return ntStatus;

}

NTSTATUS
AvcGetPinCount( 
    PKSDEVICE pKsDevice,
    PULONG pNumberOfPins )
{
    PHW_DEVICE_EXTENSION pHwDevExt = (PHW_DEVICE_EXTENSION)pKsDevice->Context;
    PAVC_MULTIFUNC_IRB pAvcIrb;
    NTSTATUS ntStatus;

    _DbgPrintF( DEBUGLVL_VERBOSE, ("[AvcGetPinCount]\n"));
//    TRAP;

    pAvcIrb = (PAVC_MULTIFUNC_IRB)
		ExAllocateFromNPagedLookasideList(&pHwDevExt->AvcMultifuncCmdLookasideList);
    if ( NULL == pAvcIrb ) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(pAvcIrb, sizeof(AVC_MULTIFUNC_IRB));

    ntStatus = AvcSubmitMultifuncIrbSync( pKsDevice, pAvcIrb, 
                                          AVC_FUNCTION_GET_PIN_COUNT );
    if ( NT_SUCCESS(ntStatus) ) {
        *pNumberOfPins = pAvcIrb->PinCount.PinCount;
    }

    ExFreeToNPagedLookasideList(&pHwDevExt->AvcMultifuncCmdLookasideList, pAvcIrb);

    return ntStatus;

}

NTSTATUS
AvcGetPinDescriptor(
    PKSDEVICE pKsDevice,
    ULONG ulPinId,
    PAVC_PIN_DESCRIPTOR pAvcPinDesc )
{
    PHW_DEVICE_EXTENSION pHwDevExt = (PHW_DEVICE_EXTENSION)pKsDevice->Context;
    PAVC_MULTIFUNC_IRB pAvcIrb;
    NTSTATUS ntStatus;

    _DbgPrintF( DEBUGLVL_VERBOSE, ("[AvcGetPinDescriptor]\n"));
//    TRAP;

    pAvcIrb = (PAVC_MULTIFUNC_IRB)
		ExAllocateFromNPagedLookasideList(&pHwDevExt->AvcMultifuncCmdLookasideList);
    if ( NULL == pAvcIrb ) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    RtlZeroMemory(pAvcIrb, sizeof(AVC_MULTIFUNC_IRB));

    pAvcIrb->PinDescriptor.PinId = ulPinId;

    ntStatus = AvcSubmitMultifuncIrbSync( pKsDevice, pAvcIrb, 
                                          AVC_FUNCTION_GET_PIN_DESCRIPTOR );
    if ( NT_SUCCESS(ntStatus) ) {
        *pAvcPinDesc = pAvcIrb->PinDescriptor;
    }

    ExFreeToNPagedLookasideList(&pHwDevExt->AvcMultifuncCmdLookasideList, pAvcIrb);

    return ntStatus;

}

NTSTATUS
AvcGetPinConnectInfo(
    PKSDEVICE pKsDevice,
    ULONG ulPinId,
    PAVC_PRECONNECT_INFO pAvcPreconnectInfo )
{
    PHW_DEVICE_EXTENSION pHwDevExt = (PHW_DEVICE_EXTENSION)pKsDevice->Context;
    PAVC_MULTIFUNC_IRB pAvcIrb;
    NTSTATUS ntStatus;

    _DbgPrintF( DEBUGLVL_VERBOSE, ("[AvcGetPinConnectInfo]\n"));
//    TRAP;

    pAvcIrb = (PAVC_MULTIFUNC_IRB)
		ExAllocateFromNPagedLookasideList(&pHwDevExt->AvcMultifuncCmdLookasideList);
    if ( NULL == pAvcIrb ) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    RtlZeroMemory(pAvcIrb, sizeof(AVC_MULTIFUNC_IRB));

    pAvcIrb->PinDescriptor.PinId = ulPinId;

    ntStatus = AvcSubmitMultifuncIrbSync( pKsDevice, pAvcIrb, 
                                          AVC_FUNCTION_GET_CONNECTINFO );
    if ( NT_SUCCESS(ntStatus) ) {
        *pAvcPreconnectInfo = pAvcIrb->PreConnectInfo;
    }

    ExFreeToNPagedLookasideList(&pHwDevExt->AvcMultifuncCmdLookasideList, pAvcIrb);

    return ntStatus;
}

NTSTATUS
AvcSetPinConnectInfo(
    PKSDEVICE pKsDevice,
    ULONG ulPinId,
    HANDLE hPlug,
    ULONG ulUnitPlugId,
    ULONG usSubunitAddress,
    PAVC_SETCONNECT_INFO pAvcSetconnectInfo )
{
    PHW_DEVICE_EXTENSION pHwDevExt = (PHW_DEVICE_EXTENSION)pKsDevice->Context;
    PAVC_MULTIFUNC_IRB pAvcIrb;
    NTSTATUS ntStatus;

    _DbgPrintF( DEBUGLVL_VERBOSE, ("[AvcSetPinConnectInfo]\n"));
//    TRAP;

    pAvcIrb = (PAVC_MULTIFUNC_IRB)
		ExAllocateFromNPagedLookasideList(&pHwDevExt->AvcMultifuncCmdLookasideList);
    if ( NULL == pAvcIrb ) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    RtlZeroMemory(pAvcIrb, sizeof(AVC_MULTIFUNC_IRB));

    pAvcIrb->SetConnectInfo.PinId = ulPinId;
    pAvcIrb->SetConnectInfo.ConnectInfo.SubunitAddress[0] = (UCHAR)usSubunitAddress;
    pAvcIrb->SetConnectInfo.ConnectInfo.hPlug = hPlug;
    pAvcIrb->SetConnectInfo.ConnectInfo.UnitPlugNumber = ulUnitPlugId;
    ntStatus = AvcSubmitMultifuncIrbSync( pKsDevice, pAvcIrb, 
                                          AVC_FUNCTION_SET_CONNECTINFO );
    if ( NT_SUCCESS(ntStatus) ) {
        *pAvcSetconnectInfo = pAvcIrb->SetConnectInfo;
    }

    ExFreeToNPagedLookasideList(&pHwDevExt->AvcMultifuncCmdLookasideList, pAvcIrb);

    return ntStatus;
}

NTSTATUS
AvcAcquireReleaseClear( 
    PKSDEVICE pKsDevice,
    ULONG ulPinId,
    AVC_FUNCTION AvcFunction )
{
    PHW_DEVICE_EXTENSION pHwDevExt = (PHW_DEVICE_EXTENSION)pKsDevice->Context;
    PAVC_MULTIFUNC_IRB pAvcIrb;
    NTSTATUS ntStatus;

    _DbgPrintF( DEBUGLVL_VERBOSE, ("[AvcAcquireReleaseClear]\n"));
//    TRAP;

    pAvcIrb = (PAVC_MULTIFUNC_IRB)
		ExAllocateFromNPagedLookasideList(&pHwDevExt->AvcMultifuncCmdLookasideList);
    if ( NULL == pAvcIrb ) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    RtlZeroMemory(pAvcIrb, sizeof(AVC_MULTIFUNC_IRB));

    pAvcIrb->PinId.PinId = ulPinId;

    ntStatus = AvcSubmitMultifuncIrbSync( pKsDevice, pAvcIrb, 
                                          AvcFunction );

    ExFreeToNPagedLookasideList(&pHwDevExt->AvcMultifuncCmdLookasideList, pAvcIrb);

    return ntStatus;
}

NTSTATUS
AvcUnitInfoInitialize(  
    IN PKSDEVICE pKsDevice )
{
    PHW_DEVICE_EXTENSION pHwDevExt = (PHW_DEVICE_EXTENSION)pKsDevice->Context;
    PAVC_UNIT_INFORMATION pUnitInfo;
    ULONG ulNumConnections;
    NTSTATUS ntStatus;
    ULONG i;

    pUnitInfo = AllocMem( NonPagedPool, sizeof(AVC_UNIT_INFORMATION) );
    if ( !pUnitInfo ) return STATUS_INSUFFICIENT_RESOURCES;

    pHwDevExt->pAvcUnitInformation = pUnitInfo;

    // Bag pUnitInfo for easy cleanup.
    KsAddItemToObjectBag(pKsDevice->Bag, pUnitInfo, FreeMem);

    RtlZeroMemory( pUnitInfo, sizeof(AVC_UNIT_INFORMATION) );

    // First get CMP Plug info (I know this is not really AV/C 
    // but the info is necessary for calculations below)

    // Get the Local Node Address for later use
    ntStatus = 
        Bus1394GetNodeAddress( pKsDevice->NextDeviceObject,
                               USE_LOCAL_NODE,
                               &pHwDevExt->NodeAddress );

    // Get the "device capabilities" (Plug Control Register info)
    if ( NT_SUCCESS(ntStatus) ) {
        ntStatus = Av61883GetSetUnitInfo( pKsDevice,
                                          Av61883_GetUnitInfo,
                                          GET_UNIT_INFO_CAPABILITIES,
                                          &pUnitInfo->CmpUnitCaps );
    }

    // Get the 61883 Config ROM info
    if ( NT_SUCCESS(ntStatus) ) {
        _DbgPrintF( DEBUGLVL_VERBOSE, ("NumOutputPlugs: %d NumInputPlugs %d\n",
                                      pUnitInfo->CmpUnitCaps.NumOutputPlugs,
                                      pUnitInfo->CmpUnitCaps.NumInputPlugs ));

        ntStatus = Av61883GetSetUnitInfo( pKsDevice,
                                          Av61883_GetUnitInfo,
                                          GET_UNIT_INFO_IDS,
                                          &pUnitInfo->IEC61883UnitIds );

        _DbgPrintF( DEBUGLVL_VERBOSE, ("VendorID: %x ModelID %x\n",
                                      pUnitInfo->IEC61883UnitIds.VendorID,
                                      pUnitInfo->IEC61883UnitIds.ModelID ));
    }

    ntStatus = AvcGetPlugInfo( pKsDevice, TRUE, (PUCHAR)&pUnitInfo->PlugInfo );
    if ( NT_SUCCESS(ntStatus) ) {
        pUnitInfo->fAvcCapabilities[AVC_CAP_PLUG_INFO].fStatus = TRUE;
        _DbgPrintF( DEBUGLVL_VERBOSE, ("Serial In: %d Serial Out: %d Ext In: %d Ext Out: %d\n",
                                      pUnitInfo->PlugInfo.ucSerialBusInputPlugCnt,
                                      pUnitInfo->PlugInfo.ucSerialBusOutputPlugCnt,
                                      pUnitInfo->PlugInfo.ucExternalInputPlugCnt,
                                      pUnitInfo->PlugInfo.ucExternalOutputPlugCnt ));
    }
    else if ( STATUS_NOT_IMPLEMENTED != ntStatus ) {
        TRAP;
        return ntStatus;
    }

    ntStatus = AvcConnections( pKsDevice, &ulNumConnections, NULL );
    if ( NT_SUCCESS(ntStatus) ) {
        pUnitInfo->ulNumConnections = ulNumConnections;
        pUnitInfo->pConnections = AllocMem(PagedPool, ulNumConnections * sizeof(AVC_CONNECTION) );
        if ( !pUnitInfo->pConnections ) {
            return STATUS_INSUFFICIENT_RESOURCES;
        }
        // Bag for easy cleanup.
        KsAddItemToObjectBag(pKsDevice->Bag, pUnitInfo->pConnections, FreeMem);

        ntStatus = AvcConnections( pKsDevice, &ulNumConnections, pUnitInfo->pConnections );
    }
    else if ( STATUS_NOT_IMPLEMENTED != ntStatus ) {
        TRAP;
        return ntStatus;
    }

    ntStatus = AvcPower( pKsDevice, TRUE, AVC_CTYPE_STATUS, &pUnitInfo->bPowerState );
    if ( NT_SUCCESS(ntStatus) ) {
        pUnitInfo->fAvcCapabilities[AVC_CAP_POWER].fStatus = TRUE;
//        ntStatus = AvcPower( pKsDevice, TRUE, AVC_CTYPE_CONTROL, &pUnitInfo->bPowerState );
        ntStatus = AvcGeneralInquiry( pKsDevice, TRUE, AVC_POWER );
        if ( NT_SUCCESS(ntStatus) ) {
            pUnitInfo->fAvcCapabilities[AVC_CAP_POWER].fCommand = TRUE;
        }
    }
    else if ( STATUS_NOT_IMPLEMENTED != ntStatus ) {
        TRAP;
        return ntStatus;
    }

    // Determine if the data format on the plug is discoverable and can change.
    for ( i=0; i<pUnitInfo->CmpUnitCaps.NumInputPlugs; i++) {
        UCHAR ucFDF;
        UCHAR ucFMT;
        ntStatus = AvcPlugSignalFormat( pKsDevice, 
                                        KSPIN_DATAFLOW_IN, 
                                        i, 
                                        AVC_CTYPE_STATUS,
                                        &ucFMT,
                                        &ucFDF );

        if ( NT_SUCCESS(ntStatus) || (STATUS_NOT_IMPLEMENTED == ntStatus)) {
            if (NT_SUCCESS(ntStatus)) {
                pUnitInfo->fAvcCapabilities[AVC_CAP_INPUT_PLUG_FMT].fStatus = TRUE;
            }

            ntStatus = AvcGeneralInquiry( pKsDevice, TRUE, AVC_INPUT_PLUG_SIGNAL_FORMAT );
            if ( NT_SUCCESS(ntStatus) ) {
                pUnitInfo->fAvcCapabilities[AVC_CAP_INPUT_PLUG_FMT].fCommand = TRUE;
            }
            else if ( STATUS_NOT_IMPLEMENTED != ntStatus ) {
                return ntStatus;
            }
        }
        else {
            return ntStatus;
        }
    }

    for ( i=0; i<pUnitInfo->CmpUnitCaps.NumOutputPlugs; i++) {
        UCHAR ucFDF;
        UCHAR ucFMT;
        ntStatus = AvcPlugSignalFormat( pKsDevice, 
                                        KSPIN_DATAFLOW_OUT, 
                                        i, 
                                        AVC_CTYPE_STATUS, 
                                        &ucFMT,
                                        &ucFDF );

        if ( NT_SUCCESS(ntStatus) || (STATUS_NOT_IMPLEMENTED == ntStatus)) {
            if (NT_SUCCESS(ntStatus)) {
                pUnitInfo->fAvcCapabilities[AVC_CAP_OUTPUT_PLUG_FMT].fStatus = TRUE;
            }

            ntStatus = AvcGeneralInquiry( pKsDevice, TRUE, AVC_OUTPUT_PLUG_SIGNAL_FORMAT );
            if ( NT_SUCCESS(ntStatus) ) {
                pUnitInfo->fAvcCapabilities[AVC_CAP_OUTPUT_PLUG_FMT].fCommand = TRUE;
            }
            else if ( STATUS_NOT_IMPLEMENTED != ntStatus ) {
                return ntStatus;
            }
        }
    }

    if ( STATUS_NOT_IMPLEMENTED == ntStatus ) {
        ntStatus = STATUS_SUCCESS;
    }

    return ntStatus;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\drivers\avcaudio\busproto.h ===
#ifndef ___BUSDEV_PROTO_H___
#define ___BUSDEV_PROTO_H___

// Filter.c
NTSTATUS
FilterCreateFilterFactory(
    PKSDEVICE pKsDevice,
    BOOLEAN fEnableInterfaces
    );

NTSTATUS
FilterDestroyFilterFactory(
    PKSDEVICE pKsDevice 
    );

// Pin.c
NTSTATUS
PinBuildDescriptors( 
    PKSDEVICE pKsDevice, 
    PKSPIN_DESCRIPTOR_EX *ppPinDescEx, 
    PULONG pNumPins,
    PULONG pPinDecSize 
    );

NTSTATUS
PinSurpriseRemove(
    PKSPIN pKsPin 
    );

// ParseDsc.c
PAUDIO_SUBUNIT_DEPENDENT_INFO 
ParseFindAudioSubunitDependentInfo(
    PSUBUNIT_IDENTIFIER_DESCRIPTOR pSubunitIdDesc 
    );

PCONFIGURATION_DEPENDENT_INFO
ParseFindFirstAudioConfiguration(
    PSUBUNIT_IDENTIFIER_DESCRIPTOR pSubunitIdDesc 
    );

PFUNCTION_BLOCKS_INFO
ParseFindFunctionBlocksInfo(
    PCONFIGURATION_DEPENDENT_INFO pConfigDepInfo 
    );

VOID
ParseFunctionBlock( 
    PFUNCTION_BLOCK_DEPENDENT_INFO pFBDepInfo,
    PFUNCTION_BLOCK pFunctionBlock 
    );

NTSTATUS
ParseAudioSubunitDescriptor( 
    PKSDEVICE pKsDevice 
    );

VOID
CountTopologyComponents(
    PHW_DEVICE_EXTENSION pHwDevExt,
    PULONG pNumCategories,
    PULONG pNumNodes,
    PULONG pNumConnections,
    PULONG pbmCategories 
    );

ULONG
CountDeviceBridgePins( 
    PKSDEVICE pKsDevice
    );

ULONG
CountFormatsForPin( 
    PKSDEVICE pKsDevice, 
    ULONG ulPinNumber
    );

void
GetPinDataRanges( 
    PKSDEVICE pKsDevice, 
    ULONG ulPinNumber, 
    PKSDATARANGE_AUDIO *ppAudioDataRanges,
    PFWAUDIO_DATARANGE pAudioDataRange 
    );

VOID
GetCategoryForBridgePin(
    PKSDEVICE pKsDevice, 
    ULONG ulBridgePinNumber,
    GUID* pTTypeGUID 
    );

BOOLEAN
IsSampleRateInRange(
    PFWAUDIO_DATARANGE pFWAudioRange,
    ULONG ulSampleRate 
    );

PFWAUDIO_DATARANGE
GetDataRangeForFormat(
    PKSDATAFORMAT pFormat,
    PFWAUDIO_DATARANGE pFwDataRange,
    ULONG ulDataRangeCnt 
    );

ULONG
FindSourceForSrcPlug( 
    PHW_DEVICE_EXTENSION pHwDevExt, 
    ULONG ulPinId 
    );

USHORT
usBitSwapper(
    USHORT usInVal );


// Property.c
NTSTATUS
CreateFeatureFBlockRequest( 
    PKSDEVICE pKsDevice,
    PTOPOLOGY_NODE_INFO pNodeInfo,
    ULONG ulChannel,
    PVOID pData,
    ULONG ulByteCount,
    USHORT usRequestType 
    );

NTSTATUS
InitializeDbLevelCache(
    PKSDEVICE pKsDevice,
    PTOPOLOGY_NODE_INFO pNodeInfo,
    PDB_LEVEL_CACHE pDbCache,
    ULONG ulDataBitCount 
    );

NTSTATUS
InitializeGeqLevelCache(
    PKSDEVICE pKsDevice, 
    PTOPOLOGY_NODE_INFO pNodeInfo, 
    PGEQ_CTRL_CACHE pGeqCache
    );

VOID
BuildNodePropertySet(
    PTOPOLOGY_NODE_INFO pNodeInfo
    );

VOID
BuildFilterPropertySet(
    PKSFILTER_DESCRIPTOR pFilterDesc,
    PKSPROPERTY_ITEM pDevPropItems,
    PKSPROPERTY_SET pDevPropSet,
    PULONG pNumItems,
    PULONG pNumSets 
    );

VOID
BuildPinPropertySet( 
    PHW_DEVICE_EXTENSION pHwDevExt,
    PKSPROPERTY_ITEM pStrmPropItems,
    PKSPROPERTY_SET pStrmPropSet,
    PULONG pNumItems,
    PULONG pNumSets 
    );

// Topology.c
NTSTATUS
BuildFilterTopology( 
    PKSDEVICE pKsDevice 
    );


// AM824.c
NTSTATUS
AM824ProcessData( 
    PKSPIN pKsPin 
    );

NTSTATUS
AM824CancelRequest( 
    PAV_CLIENT_REQUEST_LIST_ENTRY pAVListEntry 
    );

NTSTATUS
AM824AudioPosition(
    PKSPIN pKsPin,
    PKSAUDIO_POSITION pPosition
    );

#ifdef TOPO_FAKE
// TopoFake.c
NTSTATUS
BuildFakeUnitDescriptor( 
    PKSDEVICE pKsDevice 
    );
#endif

NTSTATUS
BuildFakeSubunitDescriptor( 
    PKSDEVICE pKsDevice 
    );

// Intrsect.c
ULONG
GetIntersectFormatSize( 
    PFWAUDIO_DATARANGE pAudioDataRange 
    );

ULONG
ConvertDatarangeToFormat(
    PFWAUDIO_DATARANGE pAudioDataRange,
    PKSDATAFORMAT pFormat 
    );

PFWAUDIO_DATARANGE
FindDataIntersection(
    PKSDATARANGE_AUDIO pKsAudioRange,
    PFWAUDIO_DATARANGE *ppFWAudioRanges,
    ULONG ulAudioRangeCount 
    );

// CCM.c
NTSTATUS
CCMSetSignalSource( 
    PKSDEVICE pKsDevice,
    AVC_PLUG_DEFINITION SignalSource,
    AVC_PLUG_DEFINITION SignalDestination 
    );

// Registry.c
NTSTATUS
RegistryReadMultiDeviceConfig(
    PKSDEVICE pKsDevice,
    PBOOLEAN pfMultiDevice,
    GUID *pSpkrGrpGUID,
    PULONG pChannelConfig 
    );

// Grouping.c
NTSTATUS
GroupingDeviceGroupSetup (
    PKSDEVICE pKsDevice 
    );

PHW_DEVICE_EXTENSION
GroupingFindChannelExtension(
    PKSDEVICE pKsDevice,
    PULONG pChannelIndx 
    );

// Timer.c
NTSTATUS
TimerInitialize(
    PKSDEVICE pKsDevice 
    );

NTSTATUS
TimerStop( 
    PHW_DEVICE_EXTENSION pHwDevExt
    );

// HwEvent.c
NTSTATUS
HwEventAddHandler(
    IN PIRP pIrp,
    IN PKSEVENTDATA pEventData,
    IN PKSEVENT_ENTRY pEventEntry 
    );

VOID
HwEventRemoveHandler(
    IN PFILE_OBJECT FileObject,
    IN PKSEVENT_ENTRY pEventEntry 
    );

NTSTATUS
HwEventSupportHandler(
    IN PIRP Irp,
    IN PKSEVENT pKsEvent,
    IN OUT PVOID Data 
    );

#endif // ___BUSDEV_PROTO_H___
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\drivers\avcaudio\ccm.c ===
#include "Common.h"

#define CCM_CMD_SIGNAL_SOURCE 0x1A
#define CCM_CMD_INPUT_SELECT  0x1B
#define CCM_CMD_OUTPUT_PRESET 0x1C


NTSTATUS
CCMSignalSource( 
    PKSDEVICE pKsDevice,
    AvcCommandType ulCommandType,
    PCCM_SIGNAL_SOURCE pInCCMSignalSource )
{
    PHW_DEVICE_EXTENSION pHwDevExt = (PHW_DEVICE_EXTENSION)pKsDevice->Context;
    PAVC_COMMAND_IRB pAvcIrb;
    PCCM_SIGNAL_SOURCE pCCMSignalSource;
    UCHAR ucSubunitAddress;
    NTSTATUS ntStatus;

    pAvcIrb = (PAVC_COMMAND_IRB)
		ExAllocateFromNPagedLookasideList(&pHwDevExt->AvcCommandLookasideList);
    if ( NULL == pAvcIrb ) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    RtlZeroMemory(pAvcIrb, sizeof(AVC_COMMAND_IRB));

    pCCMSignalSource = (PCCM_SIGNAL_SOURCE)&pAvcIrb->Operands;

    // This is a unit command, set the appropriate address
    ucSubunitAddress = 0xFF;
    pAvcIrb->SubunitAddrFlag = TRUE;
    pAvcIrb->SubunitAddr = &ucSubunitAddress;

    // Set up Open Control command in AvcIrb.
    pAvcIrb->CommandType   = ulCommandType;
    pAvcIrb->Opcode        = CCM_CMD_SIGNAL_SOURCE;
    pAvcIrb->OperandLength = 5;

    if ( AVC_CTYPE_CONTROL == ulCommandType ) {
        pCCMSignalSource->ucStatus = 0x0F;
        pCCMSignalSource->SignalSource = pInCCMSignalSource->SignalSource;
    }
    else {
        pCCMSignalSource->ucStatus = 0xFF;
        *((PUSHORT)&pCCMSignalSource->SignalSource) = 0xFEFF;
    }

    pCCMSignalSource->SignalDestination = pInCCMSignalSource->SignalDestination;

    _DbgPrintF( DEBUGLVL_VERBOSE, ("[CCMSignalSource] %s pAvcIrb: %x\n",
                                   ( AVC_CTYPE_CONTROL == ulCommandType ) ?
                                               "AVC_CTYPE_CONTROL" : "AVC_CTYPE_STATUS",
                                   pAvcIrb ));

    ntStatus = AvcSubmitIrbSync( pKsDevice, pAvcIrb );
    if ( NT_SUCCESS(ntStatus) ) {
        RtlCopyMemory( pInCCMSignalSource,
                       pCCMSignalSource,
                       sizeof(CCM_SIGNAL_SOURCE) );
    }

    ExFreeToNPagedLookasideList(&pHwDevExt->AvcCommandLookasideList, pAvcIrb);

    return ntStatus;
}

NTSTATUS
CCMInputSelectControl (
    PKSDEVICE pKsDevice,
    ULONG ulSubFunction,
    USHORT usNodeId,
    UCHAR ucOutputPlug,
    PAVC_PLUG_DEFINITION pSignalDestination )
{
    
    PHW_DEVICE_EXTENSION pHwDevExt = (PHW_DEVICE_EXTENSION)pKsDevice->Context;
    PAVC_COMMAND_IRB pAvcIrb;
    PCCM_INPUT_SELECT pCcmInputSelect;
    UCHAR ucSubunitAddress;
    NTSTATUS ntStatus;

    pAvcIrb = (PAVC_COMMAND_IRB)
		ExAllocateFromNPagedLookasideList(&pHwDevExt->AvcCommandLookasideList);
    if ( NULL == pAvcIrb ) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    RtlZeroMemory(pAvcIrb, sizeof(AVC_COMMAND_IRB));

    pCcmInputSelect = (PCCM_INPUT_SELECT)&pAvcIrb->Operands;

    // This is a unit command, set the appropriate address
    ucSubunitAddress = 0xFF;
    pAvcIrb->SubunitAddrFlag = TRUE;
    pAvcIrb->SubunitAddr = &ucSubunitAddress;

    // Set up Open Control command in AvcIrb.
    pAvcIrb->CommandType   = AVC_CTYPE_CONTROL;
    pAvcIrb->Opcode        = CCM_CMD_INPUT_SELECT;
    pAvcIrb->OperandLength = 9;

    // Fill In Input Select request
    pCcmInputSelect->ucSubFunction     = (UCHAR)ulSubFunction;
    pCcmInputSelect->bfResultStatus    = 0xf;
    pCcmInputSelect->usNodeId          = bswapw(usNodeId);
    pCcmInputSelect->ucInputPlug       = 0xFF;
    pCcmInputSelect->ucOutputPlug      = ucOutputPlug;
    pCcmInputSelect->SignalDestination = *pSignalDestination;

    ntStatus = AvcSubmitIrbSync( pKsDevice, pAvcIrb );
#if DBG
        if ( !NT_SUCCESS(ntStatus) ) {
            _DbgPrintF( DEBUGLVL_VERBOSE, ("[CCMInputSelectControl] Failed pAvcIrb: %x\n",pAvcIrb ));
        }
#endif

    ExFreeToNPagedLookasideList(&pHwDevExt->AvcCommandLookasideList, pAvcIrb);

    return ntStatus;

 }

NTSTATUS
CCMInputSelectStatus (
    PKSDEVICE pKsDevice,
    UCHAR ucInputPlug,
    PCCM_INPUT_SELECT pInCcmInputSelect )
{
    PHW_DEVICE_EXTENSION pHwDevExt = (PHW_DEVICE_EXTENSION)pKsDevice->Context;
    PCCM_INPUT_SELECT pCcmInputSelect;
    PAVC_COMMAND_IRB pAvcIrb;
    UCHAR ucSubunitAddress;
    NTSTATUS ntStatus;

    pAvcIrb = (PAVC_COMMAND_IRB)
		ExAllocateFromNPagedLookasideList(&pHwDevExt->AvcCommandLookasideList);
    if ( NULL == pAvcIrb ) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    RtlZeroMemory(pAvcIrb, sizeof(AVC_COMMAND_IRB));

    pCcmInputSelect = (PCCM_INPUT_SELECT)&pAvcIrb->Operands;

    // This is a unit command, set the appropriate address
    ucSubunitAddress = 0xFF;
    pAvcIrb->SubunitAddrFlag = TRUE;
    pAvcIrb->SubunitAddr = &ucSubunitAddress;

    // Set up Open Control command in AvcIrb.
    pAvcIrb->CommandType   = AVC_CTYPE_STATUS;
    pAvcIrb->Opcode        = CCM_CMD_INPUT_SELECT;
    pAvcIrb->OperandLength = 9;

    // Fill In Input Select request
    ((PULONG)pCcmInputSelect)[0] = 0xFFFFFFFF;
    ((PULONG)pCcmInputSelect)[1] = 0xFFFFFFFF;
    pCcmInputSelect->ucInputPlug = ucInputPlug;
    pAvcIrb->Operands[6] = 0xFF;
    pAvcIrb->Operands[7] = 0xFE;

    ntStatus = AvcSubmitIrbSync( pKsDevice, pAvcIrb );
    if ( NT_SUCCESS(ntStatus) ) {
        *pInCcmInputSelect = *pCcmInputSelect;
    }

    _DbgPrintF( DEBUGLVL_VERBOSE, ("[CCMInputSelectStatus] pAvcIrb: %x\n",pAvcIrb ));

    ExFreeToNPagedLookasideList(&pHwDevExt->AvcCommandLookasideList, pAvcIrb);

    return ntStatus;

 }

NTSTATUS
CCMCheckSupport(
    PKSDEVICE pKsDevice,
    ULONG ulSubunitId,
    ULONG ulPlugNumber )
{
    CCM_SIGNAL_SOURCE CcmSignalSource;
    NTSTATUS ntStatus;

    CcmSignalSource.SignalDestination.SubunitType  = AVC_SUBUNITTYPE_AUDIO;
    CcmSignalSource.SignalDestination.SubunitId    = (UCHAR)ulSubunitId;
    CcmSignalSource.SignalDestination.ucPlugNumber = (UCHAR)ulPlugNumber;

    ntStatus = CCMSignalSource( pKsDevice, 
                                AVC_CTYPE_STATUS,
                                &CcmSignalSource );

    _DbgPrintF( DEBUGLVL_VERBOSE, ("[CCMCheckSupport]:CcmSignalSource: %x ntStatus: %x\n",
                                   &CcmSignalSource, ntStatus ));
    return ntStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\drivers\avcaudio\audio.h ===
#ifndef ___FWAUDIO_AUDIO_H___
#define ___FWAUDIO_AUDIO_H___

// FDF identifier
#define FMT_AUDIO_MUSIC 0x10

// 15 predefined and Master channel
#define MAX_DEFINED_CHANNELS 16 

// Values for the EVT field of the CIP FDF
#define EVT_AM824       0
#define EVT_24x4PACK    1
#define EVT_32BIT_FLOAT 2
#define EVT_32or64BIT   3

// Values for the SFC field of the CIP FDF
#define SFC_32000Hz     0
#define SFC_44100Hz     1
#define SFC_48000Hz     2
#define SFC_96000Hz     4

#define MAX_SFC_COUNT   4

extern UCHAR ucFDFs[MAX_SFC_COUNT];

// Values for th FN field of the CIP (Fraction Number)
#define FN_NOT_DIVIDED  0
#define FN_DIVIDED_BY_2 1
#define FN_DIVIDED_BY_4 2
#define FN_DIVIDED_BY_8 3

// Chanel Cluster Flags
#define CHANNEL_CLUSTER_SAME_AS_MASTER        0
#define CHANNEL_CLUSTER_SAME_AS_UPSTREAM      1
#define CHANNEL_CLUSTER_GENERIC_MULTISPEAKER  2

// Function Block Types
// Function Block Types
enum {
    FB_SELECTOR = 0x80,
    FB_FEATURE,
    FB_PROCESSING,
    FB_CODEC
} FUNCTION_BLOCK_TYPE;

#define MAX_FUNCTION_BLOCK_TYPES 4

// Function Block Avc Command
#define AVC_AUDIO_FB_COMMAND 0xB8

// Subunit Plug types
#define SUBUNIT_DESTINATION_PLUG_TYPE   0xF0
#define SUBUNIT_SOURCE_PLUG_TYPE        0xF1

#define MAX_FUNCTION_BLOCK_TYPES 4

// Function Block Control Attributes
#define FB_CTRL_ATTRIB_RESOLUTION  0x01
#define FB_CTRL_ATTRIB_MINIMUM     0x02
#define FB_CTRL_ATTRIB_MAXIMUM     0x03
#define FB_CTRL_ATTRIB_DEFAULT     0x04
#define FB_CTRL_ATTRIB_DURATION    0x08
#define FB_CTRL_ATTRIB_CURRENT     0x10
#define FB_CTRL_ATTRIB_MOVE        0x18
#define FB_CTRL_ATTRIB_DELTA       0x19

// Function Block Control Command Types
#define FB_CTRL_TYPE_CONTROL       AVC_CTYPE_CONTROL<<8
#define FB_CTRL_TYPE_STATUS        AVC_CTYPE_STATUS<<8
#define FB_CTRL_TYPE_NOTIFY        AVC_CTYPE_NOTIFY<<8
#define FB_CTRL_TYPE_MASK          0xFF00

#define FB_GET_CUR                 (FB_CTRL_TYPE_STATUS | FB_CTRL_ATTRIB_CURRENT)
#define FB_GET_MIN                 (FB_CTRL_TYPE_STATUS | FB_CTRL_ATTRIB_MINIMUM)
#define FB_GET_MAX                 (FB_CTRL_TYPE_STATUS | FB_CTRL_ATTRIB_MAXIMUM)
#define FB_GET_RES                 (FB_CTRL_TYPE_STATUS | FB_CTRL_ATTRIB_RESOLUTION)
#define FB_SET_CUR                 (FB_CTRL_TYPE_CONTROL | FB_CTRL_ATTRIB_CURRENT)

// Terminal type masks
#define STREAMING_TERMINAL  0x0101
#define INPUT_MASK          0x0200
#define OUTPUT_MASK         0x0300
#define BIDIRECTIONAL_MASK  0x0400
#define TELEPHONY_MASK      0x0500
#define EXTERNAL_MASK       0x0600
#define EMBEDDED_MASK       0x0700

#define DATA_FORMAT_TYPE_MASK        0xF000

// Terminal Data Types
#define AUDIO_DATA_TYPE_TIME_BASED   0x0000
#define AUDIO_DATA_TYPE_PCM          0x0001
#define AUDIO_DATA_TYPE_PCM8         0x0002
#define AUDIO_DATA_TYPE_IEEE_FLOAT   0x0003

#define AUDIO_DATA_TYPE_COMPRESSED   0x1000
#define AUDIO_DATA_TYPE_AC3          0x1001
#define AUDIO_DATA_TYPE_MPEG         0x1002
#define AUDIO_DATA_TYPE_DTS          0x1003

// MLan Data Transport Types
#define MLAN_AM824_IEC958 0
#define MLAN_AM824_RAW    1
#define MLAN_24BIT_PACKED 2

// Map KSNODE_TYPE GUIDs to Indexes
#define NODE_TYPE_NONE          0
#define NODE_TYPE_DAC           1
#define NODE_TYPE_ADC           2
#define NODE_TYPE_SRC           3
#define NODE_TYPE_SUPERMIX      4
#define NODE_TYPE_MUX           5
#define NODE_TYPE_SUM           6
#define NODE_TYPE_MUTE          7
#define NODE_TYPE_VOLUME        8
#define NODE_TYPE_BASS          9
#define NODE_TYPE_MID           10
#define NODE_TYPE_TREBLE        11
#define NODE_TYPE_BASS_BOOST    12
#define NODE_TYPE_EQUALIZER     13
#define NODE_TYPE_AGC           14
#define NODE_TYPE_DELAY         15
#define NODE_TYPE_LOUDNESS      16
#define NODE_TYPE_PROLOGIC      17
#define NODE_TYPE_STEREO_WIDE   18
#define NODE_TYPE_REVERB        19
#define NODE_TYPE_CHORUS        20
#define NODE_TYPE_DEV_SPEC      21
#define NODE_TYPE_TONE          22


#define MapFuncsToNodeTypes( a ) \
{\
    a[KSPROPERTY_AUDIO_LATENCY]               = NODE_TYPE_NONE; \
    a[KSPROPERTY_AUDIO_COPY_PROTECTION]       = NODE_TYPE_NONE; \
    a[KSPROPERTY_AUDIO_CHANNEL_CONFIG]        = NODE_TYPE_NONE; \
    a[KSPROPERTY_AUDIO_VOLUMELEVEL]           = NODE_TYPE_VOLUME; \
    a[KSPROPERTY_AUDIO_POSITION]              = NODE_TYPE_NONE; \
    a[KSPROPERTY_AUDIO_DYNAMIC_RANGE]         = NODE_TYPE_NONE; \
    a[KSPROPERTY_AUDIO_QUALITY]               = NODE_TYPE_NONE; \
    a[KSPROPERTY_AUDIO_SAMPLING_RATE]         = NODE_TYPE_SRC; \
    a[KSPROPERTY_AUDIO_DYNAMIC_SAMPLING_RATE] = NODE_TYPE_SRC; \
    a[KSPROPERTY_AUDIO_MIX_LEVEL_TABLE]       = NODE_TYPE_SUPERMIX; \
    a[KSPROPERTY_AUDIO_MIX_LEVEL_CAPS]        = NODE_TYPE_SUPERMIX; \
    a[KSPROPERTY_AUDIO_MUX_SOURCE]            = NODE_TYPE_MUX; \
    a[KSPROPERTY_AUDIO_MUTE]                  = NODE_TYPE_MUTE; \
    a[KSPROPERTY_AUDIO_BASS]                  = NODE_TYPE_BASS; \
    a[KSPROPERTY_AUDIO_MID]                   = NODE_TYPE_MID; \
    a[KSPROPERTY_AUDIO_TREBLE]                = NODE_TYPE_TREBLE; \
    a[KSPROPERTY_AUDIO_BASS_BOOST]            = NODE_TYPE_BASS_BOOST; \
    a[KSPROPERTY_AUDIO_EQ_LEVEL]              = NODE_TYPE_EQUALIZER; \
    a[KSPROPERTY_AUDIO_NUM_EQ_BANDS]          = NODE_TYPE_EQUALIZER; \
    a[KSPROPERTY_AUDIO_EQ_BANDS]              = NODE_TYPE_EQUALIZER; \
    a[KSPROPERTY_AUDIO_AGC]                   = NODE_TYPE_AGC; \
    a[KSPROPERTY_AUDIO_DELAY]                 = NODE_TYPE_DELAY; \
    a[KSPROPERTY_AUDIO_LOUDNESS]              = NODE_TYPE_LOUDNESS; \
    a[KSPROPERTY_AUDIO_WIDE_MODE]             = NODE_TYPE_STEREO_WIDE; \
    a[KSPROPERTY_AUDIO_WIDENESS]              = NODE_TYPE_STEREO_WIDE; \
    a[KSPROPERTY_AUDIO_REVERB_LEVEL]          = NODE_TYPE_REVERB; \
    a[KSPROPERTY_AUDIO_CHORUS_LEVEL]          = NODE_TYPE_CHORUS; \
    a[KSPROPERTY_AUDIO_DEV_SPECIFIC]          = NODE_TYPE_DEV_SPEC; \
    a[KSPROPERTY_AUDIO_DEMUX_DEST]            = NODE_TYPE_NONE; \
    a[KSPROPERTY_AUDIO_STEREO_ENHANCE]        = NODE_TYPE_NONE; \
    a[KSPROPERTY_AUDIO_MANUFACTURE_GUID]      = NODE_TYPE_NONE; \
    a[KSPROPERTY_AUDIO_PRODUCT_GUID]          = NODE_TYPE_NONE; \
    a[KSPROPERTY_AUDIO_CPU_RESOURCES]         = NODE_TYPE_NONE; \
    a[KSPROPERTY_AUDIO_STEREO_SPEAKER_GEOMETRY] = NODE_TYPE_NONE; \
    a[KSPROPERTY_AUDIO_SURROUND_ENCODE]       = NODE_TYPE_NONE; \
    a[KSPROPERTY_AUDIO_3D_INTERFACE]          = NODE_TYPE_NONE; \
}

// Feature Unit Control Selectors
#define MUTE_CONTROL                0x01
#define VOLUME_CONTROL              0x02
#define LR_BALANCE_CONTROL          0x03
#define FR_BALANCE_CONTROL          0x04
#define BASS_CONTROL                0x05
#define MID_CONTROL                 0x06
#define TREBLE_CONTROL              0x07
#define GRAPHIC_EQUALIZER_CONTROL   0x08
#define AUTOMATIC_GAIN_CONTROL      0x09
#define DELAY_CONTROL               0x0A
#define BASS_BOOST_CONTROL          0x0B
#define LOUDNESS_CONTROL            0x0C

// Controls for error checking only
#define DEV_SPECIFIC_CONTROL    0x1001

// Feature Unit Flags
#define MUTE_FLAG               0x8000
#define VOLUME_FLAG             0x4000
#define LR_BALANCE_FLAG         0x2000
#define FR_BALANCE_FLAG         0x1000
#define BASS_FLAG               0x0800
#define MID_FLAG                0x0400
#define TREBLE_FLAG             0x0200
#define GRAPHIC_EQUALIZER_FLAG  0x0100
#define AUTOMATIC_GAIN_FLAG     0x0080
#define DELAY_FLAG              0x0040
#define BASS_BOOST_FLAG         0x0020
#define LOUDNESS_FLAG           0x0010

#define MUTE_CONTROL_FLAG               0x0080
#define VOLUME_CONTROL_FLAG             0x0040
#define LR_BALANCE_CONTROL_FLAG         0x0020
#define FR_BALANCE_CONTROL_FLAG         0x0010
#define BASS_CONTROL_FLAG               0x0008
#define MID_CONTROL_FLAG                0x0004
#define TREBLE_CONTROL_FLAG             0x0002
#define GRAPHIC_EQUALIZER_CONTROL_FLAG  0x0001
#define AUTOMATIC_GAIN_CONTROL_FLAG     0x8000
#define DELAY_CONTROL_FLAG              0x4000
#define BASS_BOOST_CONTROL_FLAG         0x2000
#define LOUDNESS_CONTROL_FLAG           0x1000

// Process Function Block Process types
#define MIXER_PROCESS               0x01
#define GENERIC_PROCESS             0x02
#define UP_DOWN_MIXER               0x03
#define DOLBY_PRO_LOGIC             0x04
#define STEREO_EXTENDER             0x05
#define REVERBERATION               0x06
#define CHORUS                      0x07
#define DYNAMIC_RANGE_COMPRESSION   0x08

// Process Function Block Process Controls
#define ENABLE_CONTROL              0x01
#define MODE_CONTROL                0x02
#define MIXER_CONTROL 				0x03
#define SPACIOUSNESS_CONTROL        0x03
#define REVERBTYPE_CONTROL          0x03
#define REVERBLEVEL_CONTROL         0x04
#define REVERBTIME_CONTROL          0x05
#define REVERBEARLYTIME_CONTROL     0x06
#define REVERBDELAY_CONTROL         0x07
#define CHORUSRATE_CONTROL          0x03
#define CHORUSDEPTH_CONTROL         0x04
#define COMPRESSION_RATIO_CONTROL   0x03
#define MAXAMPL_CONTROL             0x04
#define THRESHOLD_CONTROL           0x05
#define ATTACKTIME_CONTROL          0x06
#define RELEASETIME_CONTROL         0x07
#define GUID_CONTROL                0x03



#define ABSOLUTE_NODE_FLAG  0x80000000L
#define NODE_MASK           0x7fffffffL

#define MAX_APP_FRAMES_PER_ATTACH 80  // 10 ms of data
#define MAX_ATTACHED_FRAMES       8   // total 80 ms submitted

enum {
    CA_RESOLUTION = 1,
    CA_MINIMUM    = 2,
    CA_MAXIMUM    = 3,
    CA_DEFAULT    = 4,
    CA_DURATION = 0x08,
    CA_CURRENT  = 0x10,
    CA_MOVE     = 0x18,
    CA_DELTA    = 0x19
} FB_CONTROL_ATTRIBUTE;

#define GET_NODE_INFO_FROM_FILTER(pKsFilter,ulNodeID) \
        &((PTOPOLOGY_NODE_INFO)(pKsFilter)->Descriptor->NodeDescriptors)[(ulNodeID)]

//#define SA_HACK

#ifdef SA_HACK
#define SA_VENDOR_ID 0x509e
#define SA_MODEL_ID  0x534120
#endif
//================================================================

#pragma pack( push, descriptor_structs, 1)

typedef struct {
	UCHAR Rsvd1;
	UCHAR ucControlSpecInfoSize;
	UCHAR Rsvd2;
    UCHAR ucControlSize;
    UCHAR ucGeneralTag;
    UCHAR bmaControls[];
} FEATURE_FUNCTION_BLOCK, *PFEATURE_FUNCTION_BLOCK;

typedef struct {
    UCHAR ucPlaceholder;
} CODEC_FUNCTION_BLOCK, *PCODEC_FUNCTION_BLOCK;

typedef struct {
    UCHAR ucPlaceholder;
} PROCESS_FUNCTION_BLOCK, *PPROCESS_FUNCTION_BLOCK;

typedef struct {
    union {
        UCHAR ucFunctionBlockType;
        UCHAR ucSubunitPlugType;
    };
    union {
        UCHAR ucFunctionBlockID;
        UCHAR ucSubunitPlugNumber;
    };
} SOURCE_ID, *PSOURCE_ID;

typedef struct {
    USHORT usLength;
    USHORT usInfoFieldsLength;
    UCHAR  ucVersion;
    UCHAR  ucNumberOfConfigurations;
} AUDIO_SUBUNIT_DEPENDENT_INFO, *PAUDIO_SUBUNIT_DEPENDENT_INFO;

typedef struct {
    USHORT usLength;
    USHORT usID;
    USHORT usMasterClusterStructureLength;
    UCHAR  ucNumberOfChannels;
    UCHAR  ucChannelConfigType;
    USHORT usPredefinedChannelConfig;
    USHORT usChannelNameIndex[];
} CONFIGURATION_DEPENDENT_INFO, *PCONFIGURATION_DEPENDENT_INFO;

typedef struct {
    UCHAR ucNumLinks;
    SOURCE_ID pSourceID[];
} SOURCE_PLUG_LINK_INFO, *PSOURCE_PLUG_LINK_INFO;

typedef struct {
    USHORT usLength;
    UCHAR  ucType;
    UCHAR  ucID;
    USHORT usNameIndex;
    UCHAR  ucNumberOfInputPlugs;
} FUNCTION_BLOCK_DEPENDENT_INFO, *PFUNCTION_BLOCK_DEPENDENT_INFO;

typedef struct {
    UCHAR ucNumBlocks;
    FUNCTION_BLOCK_DEPENDENT_INFO FBDepInfo[];
} FUNCTION_BLOCKS_INFO, *PFUNCTION_BLOCKS_INFO;

typedef struct {
    USHORT usLength;
    UCHAR  ucNumberOfChannels;
    UCHAR  ucChannelConfigType;
    USHORT usPredefinedChannelConfig;
    USHORT usNonPredefinedChannelConfig;
} FBLOCK_CHANNEL_CLUSTER, *PFBLOCK_CHANNEL_CLUSTER;

typedef struct {
    UCHAR ucControlAttribute;
    UCHAR ucControlType;
} FBLOCK_REQUEST_TYPE, *PFBLOCK_REQUEST_TYPE;

typedef struct {
    SOURCE_ID FBlockId;
    UCHAR ucControlAttribute;
} FBLOCK_COMMAND_COMMON, *PFBLOCK_COMMAND_COMMON;

typedef struct {
    FBLOCK_COMMAND_COMMON Common;
    UCHAR ucSelectorLength;
    UCHAR ucChannelNumber;
    UCHAR ucControlSelector;
    UCHAR ucControlDataLength;
} FEATURE_FBLOCK_COMMAND, *PFEATURE_FBLOCK_COMMAND;

/*
typedef struct {
    FEATURE_FBLOCK_COMMAND FeatureCmd;
    UCHAR ucValueHigh;
    UCHAR ucValueLow;
} DBLEVEL_FEATURE_REQUEST, *PDBLEVEL_FEATURE_REQUEST;
*/
#pragma pack( pop, descriptor_structs )

typedef struct {
    ULONG ulTransportType;
    ULONG ulBitsPerChannel;
    ULONG ulSampleRateType;
    ULONG pSampleRate[MAX_SFC_COUNT];
} PCM_FORMAT, *PPCM_FORMAT;

typedef struct {
    ULONG ulNumberOfChannels;
    ULONG ulPredefinedChannelConfig;
    ULONG ulNonPredefinedChannelConfig;
} CHANNEL_CLUSTER, *PCHANNEL_CLUSTER;

typedef struct {
    PFUNCTION_BLOCK_DEPENDENT_INFO pBase;
    ULONG ulType;
    ULONG ulBlockId;
    ULONG ulNumInputPlugs;
    PSOURCE_ID pSourceId;
    ULONG ulFunctionTypeInfoLength;
    PVOID pFunctionTypeInfo;
    PFBLOCK_CHANNEL_CLUSTER pChannelCluster;
} FUNCTION_BLOCK, *PFUNCTION_BLOCK;

typedef struct {
    PCONFIGURATION_DEPENDENT_INFO pBase;
    ULONG ulNumberOfSourcePlugs;
    PSOURCE_ID pSourceId;
    ULONG ulNumberOfFunctionBlocks;
    PFUNCTION_BLOCK pFunctionBlocks;
    CHANNEL_CLUSTER ChannelCluster;
} AUDIO_CONFIGURATION, *PAUDIO_CONFIGURATION;

typedef struct {
    ULONG ulTerminalPinType;
    KSPIN_DATAFLOW KsPinDataFlow;
    ULONG ulFormatType;
    ULONG ulFormatCount;
} TERMINAL_PIN_INFO, *PTERMINAL_PIN_INFO;

typedef struct {
    ULONG ulPinId;
    ULONG fStreamingPin;
    ULONG fFakePin;
    ULONG bmFormats;
    ULONG bmTransports;
    SOURCE_ID SourceId;
    AVC_PIN_DESCRIPTOR  AvcPinDescriptor;
    AVC_PRECONNECT_INFO AvcPreconnectInfo;
    AVC_SETCONNECT_INFO AvcSetConnectInfo;
} FW_PIN_DESCRIPTOR, *PFW_PIN_DESCRIPTOR;

// Cached Values for DB Level Controls
typedef struct {
    ULONG ulChannelNumber;
    ULONG ulChannelIndex;
    LONG lLastValueSet;
    KSPROPERTY_STEPPING_LONG Range;
} DB_LEVEL_CACHE, *PDB_LEVEL_CACHE;

// Structure to Cache channel based Boolean control values
typedef struct {
    ULONG ulChannelNumber;
    ULONG ulChannelIndex;
    BOOL fLastValueSet;
} BOOLEAN_CTRL_CACHE, *PBOOLEAN_CTRL_CACHE;

// Structure to Cache channel based GEQ control values
typedef struct {
    ULONG ulBand;
    ULONG ulCurrentLevel;
    KSPROPERTY_STEPPING_LONG Range;
} GEQ_RANGE, *PGEQ_RANGE;

typedef struct {
    ULONG ulChannelNumber;
    ULONG ulChannelIndex;
    ULONG ulNumBands;
    ULONG ulNumExtraBands;
    ULONG ulBandBitmap;
    ULONG ulExtraBandBitmap;
    PGEQ_RANGE pRanges;
} GEQ_CTRL_CACHE, *PGEQ_CTRL_CACHE;

// Cached Values for Processing Unit Node ranges
typedef struct {
    ULONG ulControlBit;
    ULONG ulControlSelector;
    LONG lLastValueSet;
    KSPROPERTY_STEPPING_LONG Range;
} PROCESS_CTRL_RANGE, *PPROCESS_CTRL_RANGE;

// Cached Values for Processing Unit Node controls
typedef struct {
    BOOL fEnableBit;
    BOOL fEnabled;
    ULONG bmControlBitMap;
} PROCESS_CTRL_CACHE, *PPROCESS_CTRL_CACHE;

typedef struct _TOPOLOGY_NODE_INFO
TOPOLOGY_NODE_INFO, *PTOPOLOGY_NODE_INFO;

typedef
NTSTATUS
(*NODE_CACHE_UPDATE_RTN)(
    PKSDEVICE pKsDevice,
    PTOPOLOGY_NODE_INFO pNodeInfo,
    PBOOLEAN pChanged );

#define MASTER_FIX

// Information about each Topology node
typedef struct _TOPOLOGY_NODE_INFO {
    KSNODE_DESCRIPTOR KsNodeDesc;         // 4  Long Words
    KSAUTOMATION_TABLE KsAutomationTable; // 10 Long Words
    ULONG ulBlockId;
    union {
        PFUNCTION_BLOCK pFunctionBlk;
        ULONG ulPinId;
    };
    ULONG ulNodeType;
    ULONG ulControlType;
    ULONG ulChannelConfig;
    ULONG ulChannels;
    ULONG ulCacheValid;
    ULONG ulNumCachedValues;
    PVOID pCachedValues;

#ifdef MASTER_FIX
    BOOLEAN fMasterChannel;
#endif

    BOOLEAN fEventable;
    ULONG ulEventsEnabled;
    NODE_CACHE_UPDATE_RTN pCacheUpdateRtn;
};

// DataRange Structures to associate Interfaces with Datarange
typedef struct _FWAUDIO_DATARANGE {

    KSDATARANGE_AUDIO KsDataRangeAudio;

	ULONG ulDataType;

	ULONG ulValidDataBits;

	ULONG ulTransportType;

	ULONG ulMaxSampleRate;

	ULONG ulNumChannels;

	ULONG ulChannelConfig;

	ULONG ulSlotSize;

	PFW_PIN_DESCRIPTOR pFwPinDescriptor;

} FWAUDIO_DATARANGE, *PFWAUDIO_DATARANGE;

typedef struct {
    LIST_ENTRY List;
    PKSPIN pKsPin;
    PKSSTREAM_POINTER pKsStreamPtr;
    AV_61883_REQUEST Av61883Request;
} AV_CLIENT_REQUEST_LIST_ENTRY, *PAV_CLIENT_REQUEST_LIST_ENTRY;

#define MAX_GROUP_DEVICE_COUNT 32

typedef struct {
    GUID DeviceGroupGUID;
    ULONG ulChannelConfig;
    ULONG ulDeviceChannelCfg;
    ULONG ulDeviceCount;
    PSUBUNIT_IDENTIFIER_DESCRIPTOR pBackupSubunitIdDesc;
    PAUDIO_CONFIGURATION pBackupAudioConfiguration;
    PHW_DEVICE_EXTENSION pHwDevExts[MAX_GROUP_DEVICE_COUNT];
} DEVICE_GROUP_INFO, *PDEVICE_GROUP_INFO;

typedef struct {
    PVOID hConnection;
    ULONG ulPlugNumber;
} PIN_GROUP_INFO, *PPIN_GROUP_INFO;

// Context for each opened pin
typedef struct _PIN_CONTEXT {

    ULONG ulAttachCount;
    ULONG ulUsedBuffers;
    ULONG ulCancelledBuffers;

    PVOID hConnection;

    PDEVICE_GROUP_INFO pDevGrpInfo;
    PPIN_GROUP_INFO pPinGroupInfo;

    ULONG ulSerialPlugNumber;

    PVOID pHwDevExt;

    PDEVICE_OBJECT pPhysicalDeviceObject;

    PFWAUDIO_DATARANGE pFwAudioDataRange;

    PCMP_REGISTER pCmpRegister;

    ULONG DrmContentId;

    union {
        ULONG fIsTalking;
        ULONG fIsListening;
        ULONG fIsStreaming;
    };

    ULONG ulSampleCount;

    LIST_ENTRY OutstandingRequestList;
    
	KSAUDIO_POSITION KsAudioPosition;
    ULONG ulLastBufferSize;
	CYCLE_TIME InitialCycleTime;
	BOOLEAN fStreamStarted;

    KSPIN_LOCK PinSpinLock;

    KEVENT PinStarvationEvent;

    NPAGED_LOOKASIDE_LIST CipRequestLookasideList;

    ULONG fWorkItemInProgress;
    WORK_QUEUE_ITEM PinWorkItem;
    LIST_ENTRY CompletedRequestList;

    ULONG fReconnect;
    CCM_SIGNAL_SOURCE CcmSignalSource;
    CCM_INPUT_SELECT CcmInputSelect;    

} PIN_CONTEXT, *PPIN_CONTEXT;


typedef struct {

    ULONG ulDevicePinCount;
    PFW_PIN_DESCRIPTOR pPinDescriptors;

    PSUBUNIT_IDENTIFIER_DESCRIPTOR pSubunitIdDesc;

    PAUDIO_CONFIGURATION pAudioConfigurations;

    PDEVICE_GROUP_INFO pDeviceGroupInfo;

    AVC_PLUG_INFORMATION PlugInfo;

    AVC_COMMAND_CAPS fAvcCapabilities[AVC_CAP_MAX];

} AUDIO_SUBUNIT_INFORMATION, *PAUDIO_SUBUNIT_INFORMATION;

//===================================================================

NTSTATUS
AudioFunctionBlockCommand(
    PKSDEVICE pKsDevice,
    UCHAR     ucCtype,
    PVOID     pFBSpecificData,
    ULONG     pFBSpecificDataSize 
    );

NTSTATUS
AudioSetSampleRateOnPlug(
    PKSPIN    pKsPin,
    ULONG     ulSampleRate 
    );


#endif //___FWAUDIO_AUDIO_H___
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\drivers\avcaudio\avccmd.h ===
#ifndef ___FWAUDVD_AVCCMD_H___
#define ___FWAUDVD_AVCCMD_H___

// AV/C Commands
#define AVC_VENDOR_DEPENDENT          0x00
#define AVC_PLUG_RESERVE              0x01
#define AVC_PLUG_INFO                 0x02
#define AVC_OPEN_DESCRIPTOR           0x08
#define AVC_READ_DESCRIPTOR           0x09
#define AVC_WRITE_DESCRIPTOR          0x0A
#define AVC_SEARCH_DESCRIPTOR         0x0B
#define AVC_OBJECT_NUM_SELECT         0x0D
#define AVC_DIGITAL_OUTPUT            0x10
#define AVC_DIGITAL_INPUT             0x11
#define AVC_CHANNEL_USAGE             0x12
#define AVC_OUTPUT_PLUG_SIGNAL_FORMAT 0x18
#define AVC_INPUT_PLUG_SIGNAL_FORMAT  0x19
#define AVC_CONNECT_AV                0x20
#define AVC_DISCONNECT_AV             0x21
#define AVC_CONNECTIONS_STATUS        0x22
#define AVC_CONNECT                   0x24
#define AVC_DISCONNECT                0x25
#define AVC_UNIT_INFO                 0x30
#define AVC_SUBUNIT_INFO              0x31
#define AVC_POWER                     0xB2

#define UNIT_SUBUNIT_ADDRESS 0xFF
#define UNIT_SUBUNIT_ID      0x07

#define MAX_AVC_COMMAND_SIZE 512

// AV/C Descriptor operand subfunctions
#define AVC_SUBFUNC_CLOSE      0
#define AVC_SUBFUNC_READ_OPEN  1
#define AVC_SUBFUNC_WRITE_OPEN 3

// AV/C Descriptor Types
typedef enum {
    AVC_DESCTYPE_UNIT_IDENTIFIER    = 0xFF,
    AVC_DESCTYPE_SUBUNIT_IDENTIFIER = 0x00,
    AVC_DESCTYPE_OBJLIST_BY_ID      = 0x10,
    AVC_DESCTYPE_OBJLIST_BY_TYPE    = 0x11,
    AVC_DESCTYPE_OBJENTRY_BY_POS    = 0x20,
    AVC_DESCTYPE_OBJENTRY_BY_ID     = 0x21
} AVC_DESCRIPTOR_TYPE, *PAVC_DESCRIPTOR_TYPE;

typedef enum {
    AVC_ON  = 0x70,
    AVC_OFF = 0x60
} AVC_BOOLEAN, *PAVC_BOOLEAN;

// AVC definitions
#define IS_AVC_EXTERNAL_PLUG(a)  ((((UCHAR)a >  0x7f) && ((UCHAR)a < 0x9f)) || ((UCHAR)a == 0xff))
#define IS_AVC_SERIALBUS_PLUG(a) ((((UCHAR)a >= 0x00) && ((UCHAR)a < 0x1f)) || ((UCHAR)a == 0x7f))

// AV/C Capabilities Flags
enum {
    AVC_CAP_CONNECTIONS,
    AVC_CAP_CONNECT,
    AVC_CAP_PLUG_INFO,
    AVC_CAP_INPUT_PLUG_FMT,
    AVC_CAP_OUTPUT_PLUG_FMT,
    AVC_CAP_SUBUNIT_IDENTIFIER_DESC,
    AVC_CAP_CCM,
    AVC_CAP_POWER,
    AVC_CAP_MAX
} AVC_CAP_COMMANDS;

//===============================================================================

#pragma pack( push, avc_structs, 1)

typedef struct {
    UCHAR ucDescriptorLengthHi;
    UCHAR ucDescriptorLengthLo;
    UCHAR ucGenerationID;
    UCHAR ucSizeOfListID;
    UCHAR ucSizeOfObjectID;
    UCHAR ucSizeOfObjectPosition;
    UCHAR ucNumberOfRootObjectListsHi;
    UCHAR ucNumberOfRootObjectListsLo;
} SUBUNIT_INFO_DESCRIPTOR, *PSUBUNIT_IDENTIFIER_DESCRIPTOR;

typedef struct {
    UCHAR SubunitId:3;
    UCHAR SubunitType:5;
    UCHAR ucPlugNumber;
} AVC_PLUG_DEFINITION, *PAVC_PLUG_DEFINITION;

typedef struct {
    UCHAR fPermanent:1;
    UCHAR fLock:1;
    UCHAR Rsrvd:6;
    AVC_PLUG_DEFINITION SourcePlug;
    AVC_PLUG_DEFINITION DestinationPlug;
} AVC_CONNECTION, *PAVC_CONNECTION;

typedef struct {
    UCHAR AudioDstType:2;
    UCHAR VideoDstType:2;
    UCHAR AudioSrcType:2;
    UCHAR VideoSrcType:2;
    UCHAR ucVideoSource;
    UCHAR ucAudioSource;
    UCHAR ucVideoDestination;
    UCHAR ucAudioDestination;
} AVC_AV_CONNECTION, *PAVC_AV_CONNECTION;

typedef struct {
    union {
        UCHAR ucDestinationPlugCnt;
        UCHAR ucSerialBusInputPlugCnt;
    };
    union {
        UCHAR ucSourcePlugCnt;
        UCHAR ucSerialBusOutputPlugCnt;
    };
    UCHAR ucExternalInputPlugCnt;
    UCHAR ucExternalOutputPlugCnt;
} AVC_PLUG_INFORMATION, *PAVC_PLUG_INFORMATION;

#pragma pack( pop, avc_structs )

typedef struct {
    BOOLEAN fCommand;
    BOOLEAN fStatus;
    BOOLEAN fNotify;
} AVC_COMMAND_CAPS, *PAVC_COMMAND_CAPS;

typedef struct {
    AVC_COMMAND_CAPS fAvcCapabilities[AVC_CAP_MAX];

    GET_UNIT_CAPABILITIES CmpUnitCaps;
    GET_UNIT_IDS IEC61883UnitIds;

    ULONG ulNumConnections;
    PAVC_CONNECTION pConnections;

    AVC_BOOLEAN bPowerState;

    AVC_PLUG_INFORMATION PlugInfo;

    NODE_ADDRESS NodeAddress;

} AVC_UNIT_INFORMATION, *PAVC_UNIT_INFORMATION;

typedef struct __SUBUNIT_PLUG {
    AVC_PLUG_DEFINITION AvcPlug;

    CMP_PLUG_TYPE PlugType;

    PVOID pConnectedUnitPlug;

    PVOID pContext;

} SUBUNIT_PLUG, *PSUBUNIT_PLUG;


//===============================================================================

// AVC.c Prototypes
NTSTATUS
AvcSubmitIrbSync(
    IN PKSDEVICE pKsDevice,
    PAVC_COMMAND_IRB pAvcIrb 
    );

NTSTATUS
AvcConnections(
    PKSDEVICE pKsDevice,
    PULONG pNumConnections,
    PVOID pConnections 
    );

NTSTATUS
AvcGeneralInquiry(
    PKSDEVICE pKsDevice,
    BOOLEAN fUnitFlag,
    UCHAR ucOpcode 
    );

NTSTATUS
AvcPower(
    PKSDEVICE pKsDevice,
    ULONG fUnitFlag,
    AvcCommandType ulCommandType,
    PAVC_BOOLEAN pPowerState
    );

NTSTATUS
AvcGetSubunitIdentifierDesc(
    PKSDEVICE pKsDevice,
    PUCHAR *ppSuDescriptor
    );

NTSTATUS
AvcCheckResponse( 
    NTSTATUS ntStatus,
    UCHAR ucResponseCode
    );

NTSTATUS
AvcGetPlugInfo(
    PKSDEVICE pKsDevice,
    ULONG fUnitFlag,
    PUCHAR pPlugCounts
    );

NTSTATUS
AvcConnectDisconnect(
    PKSDEVICE pKsDevice,
    ULONG ulFunction,
    AvcCommandType ulCommandType,
    PAVC_CONNECTION pAvcConnection
    );

NTSTATUS
AvcConnectDisconnectAV(
    PKSDEVICE pKsDevice,
    ULONG ulFunction,
    AvcCommandType ulCommandType,
    PAVC_AV_CONNECTION pAvConnection 
    );

NTSTATUS
AvcPlugSignalFormat(
    PKSDEVICE pKsDevice,
    KSPIN_DATAFLOW KsDataFlow,
    ULONG ulSerialPlug,
    UCHAR ucCmdType,
    PUCHAR pFMT,
    PUCHAR pFDF 
    );

NTSTATUS
AvcVendorDependent(
    PKSDEVICE pKsDevice,
    ULONG fUnitFlag,
    ULONG ulCommandType,
    ULONG ulVendorId,
    ULONG ulDataLength,
    PVOID pData 
    );

NTSTATUS
AvcGetPinCount( 
    PKSDEVICE pKsDevice,
    PULONG pNumberOfPins 
    );

NTSTATUS
AvcGetPinDescriptor(
    PKSDEVICE pKsDevice,
    ULONG ulPinId,
    PAVC_PIN_DESCRIPTOR pAvcPinDesc 
    );

NTSTATUS
AvcGetPinConnectInfo(
    PKSDEVICE pKsDevice,
    ULONG ulPinId,
    PAVC_PRECONNECT_INFO pAvcPreconnectInfo 
    );

NTSTATUS
AvcSetPinConnectInfo(
    PKSDEVICE pKsDevice,
    ULONG ulPinId,
    HANDLE hPlug,
    ULONG ulUnitPlugId,
    ULONG usSubunitAddress,
    PAVC_SETCONNECT_INFO pAvcSetconnectInfo
    );

NTSTATUS
AvcAcquireReleaseClear( 
    PKSDEVICE pKsDevice,
    ULONG ulPinId,
    AVC_FUNCTION AvcFunction
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\drivers\avcaudio\ccm.h ===
#ifndef ___AVC_CCM_H___
#define ___AVC_CCM_H___

#define MAX_IPCR 0x1E

typedef enum {
    INPUT_SELECT_SUBFN_CONNECT,
    INPUT_SELECT_SUBFN_PATHCHANGE,
    INPUT_SELECT_SUBFN_SELECT,
    INPUT_SELECT_SUBFN_DISCONNECT
} INPUT_SELECT_SUBFUNCTION;

#pragma pack( push, ccm_structs, 1)

#define bfResultStatus bfControlStatus

typedef struct {
    UCHAR ucStatus;
    AVC_PLUG_DEFINITION SignalSource;
    AVC_PLUG_DEFINITION SignalDestination;
} CCM_SIGNAL_SOURCE, *PCCM_SIGNAL_SOURCE;

typedef struct {
    UCHAR ucSubFunction;
    UCHAR bfControlStatus:4,
          bfStatus       :4;
    USHORT usNodeId;
    UCHAR ucOutputPlug;
    UCHAR ucInputPlug;
    AVC_PLUG_DEFINITION SignalDestination;
    UCHAR Rsvd;
} CCM_INPUT_SELECT, *PCCM_INPUT_SELECT;

#pragma pack( pop, ccm_structs )

NTSTATUS
CCMSignalSource( 
    PKSDEVICE pKsDevice,
    AvcCommandType ulCommandType,
    PCCM_SIGNAL_SOURCE pInCCMSignalSource 
    );

NTSTATUS
CCMCheckSupport(
    PKSDEVICE pKsDevice,
    ULONG ulSubunitId,
    ULONG ulPlugNumber 
    );

NTSTATUS
CCMInputSelectControl (
    PKSDEVICE pKsDevice,
    ULONG ulSubFunction,
    USHORT usNodeId,
    UCHAR ucOutputPlug,
    PAVC_PLUG_DEFINITION pSignalDestination 
    );

NTSTATUS
CCMInputSelectStatus (
    PKSDEVICE pKsDevice,
    UCHAR ucInputPlug,
    PCCM_INPUT_SELECT pInCcmInputSelect 
    );

#endif // ___AVC_CCM_H___
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\drivers\avcaudio\common.h ===
#ifndef __COMMON_H__
#define __COMMON_H__

#define PSEUDO_HID

// #define TOPO_FAKE

#define SUM_HACK

#include "stdarg.h"
#include "stdio.h"

#include "wdm.h"
#include "windef.h"

#define NOBITMAP
#include "mmsystem.h"
#include "mmreg.h"
#undef NOBITMAP

#include "ks.h"
#include "ksmedia.h"
#include "wdmguid.h"

#include "1394.h"
#include "61883.h"
#include "Avc.h"

#include <initguid.h>

#include "Device.h"

#include "AvcAudId.h"
#include "AvcCmd.h"
#include "61883Cmd.h"

#include "CCM.h"
#include "Audio.h"

#include "Debug.h"

#include "BusProto.h"

#include <unknown.h>
#include <drmk.h>

#define INIT_CODE       code_seg("INIT", "CODE")
#define INIT_DATA       data_seg("INIT", "DATA")
#define LOCKED_CODE     code_seg(".text", "CODE")
#define LOCKED_DATA     data_seg(".data", "DATA")
#define LOCKED_BSS      bss_seg(".data", "DATA")
#define PAGEABLE_CODE   code_seg("PAGE", "CODE")
#define PAGEABLE_DATA   data_seg("PAGEDATA", "DATA")
#define PAGEABLE_BSS    bss_seg("PAGEDATA", "DATA")

#define MAX_ULONG 0xFFFFFFFF

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\drivers\avcaudio\debug.h ===
#ifndef __DEBUG_H
#define __DEBUG_H

#define TRAP KdBreakPoint()

#define DBGMEMMAP 0

#if (DBG)
#define STR_MODULENAME "'1394 Audio: "
#endif

#if DBG && DBGMEMMAP

typedef struct {
    ULONG TotalBytes;
    ULONG ulAllocations;
    KSPIN_LOCK SpinLock;
    LIST_ENTRY List;
} MEM_TRACKER, *PMEM_TRACKER;

extern PMEM_TRACKER LogMemMap;

VOID
InitializeMemoryList( VOID );

PVOID
USBAudioAllocateTrack(
    IN POOL_TYPE PoolType,
    IN SIZE_T NumberOfBytes
    );

PVOID
USBAudioAllocateTrackTag(
    IN POOL_TYPE PoolType,
    IN SIZE_T NumberOfBytes,
    IN ULONG ulTag
    );

VOID
USBAudioDeallocateTrack(
    PVOID pMem
    );

#define AllocMem USBAudioAllocateTrack
#define AllocMemTag USBAudioAllocateTrackTag
#define FreeMem USBAudioDeallocateTrack

#else

#define AllocMem ExAllocatePool
#define AllocMemTag ExAllocatePoolWithTag
#define FreeMem ExFreePool

#endif

#if DBG
VOID
DumpUnitDescriptor( PUCHAR pAddr );

VOID
DumpAllUnitDescriptors( 
    PUCHAR BeginAddr, PUCHAR EndAddr );

VOID
DumpDescriptor( PVOID pDescriptor );

VOID
DumpAllDescriptors(
    PVOID pConfigurationDescriptor 
    );

#define DumpDesc DumpDescriptor
#define DumpAllDesc DumpAllDescriptors
#define DumpAllUnits DumpAllUnitDescriptors
#define DumpUnitDesc DumpUnitDescriptor

#else

#define DumpDesc(a)
#define DumpAllDesc(a)
#define DumpAllUnits(a,b)
#define DumpUnitDesc(a)

#endif

#if DBG

#define DEBUGLVL_BLAB    4
#define DEBUGLVL_VERBOSE 3
#define DEBUGLVL_TERSE   2
#define DEBUGLVL_ERROR   1

#if !defined(DEBUG_LEVEL)
#define DEBUG_LEVEL DEBUGLVL_TERSE
#endif

extern ULONG DriverDebugLevel;

#define _DbgPrintF(lvl, strings) \
{ \
    if ((lvl) <= DriverDebugLevel) {\
        DbgPrint(STR_MODULENAME);\
        DbgPrint##strings;\
        if ((lvl) == DEBUGLVL_ERROR) {\
             TRAP;\
        } \
    } \
}

#else

#define _DbgPrintF(lvl, strings)

#endif

#include "dbglog.h"

//------------------------------- End of File --------------------------------
#endif // #ifndef __DEBUG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\drivers\avcaudio\debug.c ===
#include "common.h"

#if DBG
ULONG DriverDebugLevel = DEBUGLVL_TERSE;
#endif

#if DBG && DEBUG_LOG

LONG LogRefCnt = 0L;

PDBG_BUFFER LogPtr = NULL;
KSPIN_LOCK LogSpinLock;

#define DBG_LOG_DEPTH  1024

VOID
DbugLogInitialization(void)
{
    if (InterlockedIncrement(&LogRefCnt) == 1) {

        // First one here, so go ahead and initialize

        LogPtr = AllocMem( NonPagedPool, sizeof( DBG_BUFFER ));
        if ( !LogPtr ) {
            _DbgPrintF( DEBUGLVL_VERBOSE, ("Could NOT Allocate debug buffer ptr\n"));
            return;
        }
        LogPtr->pLog = AllocMem( NonPagedPool, sizeof(DBG_LOG_ENTRY)*DBG_LOG_DEPTH );
        if ( !LogPtr->pLog ) {
            FreeMem( LogPtr );
            LogPtr = NULL;
            _DbgPrintF( DEBUGLVL_VERBOSE, ("Could NOT Allocate debug buffer\n"));
            return;
        }

        strcpy(LogPtr->LGFlag, "DBG_BUFFER");

        LogPtr->pLogHead = LogPtr->pLog;
        LogPtr->pLogTail = LogPtr->pLogHead + DBG_LOG_DEPTH - 1;
        LogPtr->EntryCount = 0;

        KeInitializeSpinLock(&LogSpinLock);
    }
}

VOID
DbugLogUnInitialization(void)
{
    if (InterlockedDecrement(&LogRefCnt) == 0) {

        // Last one out, free the buffer

        if (LogPtr) {
            FreeMem( LogPtr->pLog );
            FreeMem( LogPtr );
            LogPtr = NULL;
        }
    }
}

VOID
DbugLogEntry( 
    IN CHAR *Name,
    IN ULONG Info1,
    IN ULONG Info2,
    IN ULONG Info3,
    IN ULONG Info4
    )
/*++

Routine Description:

    Adds an Entry to log.

Arguments:

Return Value:

    None.

--*/
{
    KIRQL irql;

    if (LogPtr == NULL)
        return;

    KeAcquireSpinLock( &LogSpinLock, &irql );
    if (LogPtr->pLogHead > LogPtr->pLog)
        LogPtr->pLogHead -= 1;    // Decrement to next entry
    else
        LogPtr->pLogHead = LogPtr->pLogTail;

    if (strlen(Name) > 7)
        strcpy(LogPtr->pLogHead->le_name, "*strER*");
    else
        strcpy(LogPtr->pLogHead->le_name, Name);
//    LogPtr->pLogHead->Irql = irql;
    KeQuerySystemTime( &LogPtr->pLogHead->SysTime );
    LogPtr->pLogHead->le_info1 = Info1;
    LogPtr->pLogHead->le_info2 = Info2;
    LogPtr->pLogHead->le_info3 = Info3;
    LogPtr->pLogHead->le_info4 = Info4;

    LogPtr->EntryCount++;

    KeReleaseSpinLock( &LogSpinLock, irql );

    return;
}

#endif

#if DBG && DBGMEMMAP

#pragma LOCKED_DATA
PMEM_TRACKER LogMemMap;
#pragma PAGEABLE_DATA

VOID
InitializeMemoryList( VOID )
{
   LogMemMap = ExAllocatePool( NonPagedPool, sizeof( MEM_TRACKER ) );
   if ( !LogMemMap ) {
       _DbgPrintF(DEBUGLVL_VERBOSE, ("MEMORY TRACKER ALLOCATION FAILED!!!"));
       TRAP;
   }
   LogMemMap->TotalBytes = 0;
   LogMemMap->ulAllocations = 0;
   InitializeListHead( &LogMemMap->List );
   KeInitializeSpinLock( &LogMemMap->SpinLock );
   _DbgPrintF(DEBUGLVL_VERBOSE, ("'Initialize MEMORY TRACKER LogMemMap: %x\n",
               LogMemMap));
}

PVOID pCaller = NULL;

PVOID
USBAudioAllocateTrack(
    POOL_TYPE PoolType,
    SIZE_T NumberOfBytes
    )
{
    PVOID pMem;
    KIRQL irql;
    ULONG TotalReqSize = NumberOfBytes + sizeof(ULONG) + sizeof(PVOID*) + sizeof(LIST_ENTRY);

    if ( !(pMem = ExAllocatePool( NonPagedPool, TotalReqSize ) ) ) {
        TRAP;
        return pMem;
    }
    
    RtlZeroMemory( pMem, TotalReqSize );

    KeAcquireSpinLock( &LogMemMap->SpinLock, &irql );
    InsertHeadList( &LogMemMap->List, (PLIST_ENTRY)pMem );
    LogMemMap->TotalBytes += NumberOfBytes;
    LogMemMap->ulAllocations++;
    KeReleaseSpinLock( &LogMemMap->SpinLock, irql );

    pMem = (PLIST_ENTRY)pMem + 1;

    _asm push eax;
    _asm mov eax, [ebp+4];
    _asm mov DWORD PTR pCaller, eax;
    _asm pop eax;

    *(PVOID*)pMem = pCaller;

    pMem = (PUCHAR)pMem + sizeof(PVOID*);

    *(PULONG)pMem = NumberOfBytes;

    pMem = (PULONG)pMem + 1;

    return pMem;
}

PVOID
USBAudioAllocateTrackTag(
    POOL_TYPE PoolType,
    SIZE_T NumberOfBytes,
    ULONG ulTag )
{
     return USBAudioAllocateTrack( PoolType, NumberOfBytes );
}

VOID
USBAudioDeallocateTrack(
    PVOID pMem )
{
    PULONG pNumberOfBytes = (PULONG)pMem - 1;
    PVOID *pCallingRtn = (PVOID *)(pNumberOfBytes - 1);
    PLIST_ENTRY ple = (PLIST_ENTRY)pCallingRtn - 1;
    KIRQL irql;

  	if ( LogMemMap->ulAllocations == 1 ) TRAP;

    KeAcquireSpinLock( &LogMemMap->SpinLock, &irql );
    RemoveEntryList(ple);
    LogMemMap->TotalBytes -= *pNumberOfBytes;
    LogMemMap->ulAllocations--;
    KeReleaseSpinLock( &LogMemMap->SpinLock, irql );

    ExFreePool(ple);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\drivers\avcaudio\device.h ===
#ifndef ___FW_DEVICE_H___
#define ___FW_DEVICE_H___

#define FWAUDIO_POOLTAG 'UAWF'

//========================================================================

typedef struct {
    ULONG ulCount;
    LIST_ENTRY List;
} UNIT_PLUG_SET, *PUNIT_PLUG_SET;

typedef struct {
    ULONG ulVirtualSubunitCount;
    LIST_ENTRY DeviceExtensionList;
    LIST_ENTRY VirtualDeviceExtensionList;
    LIST_ENTRY DeviceInterfaceSymlinkList;
    LIST_ENTRY UnitPlugConnections;
    UNIT_PLUG_SET UnitSerialBusPlugs[2];
    UNIT_PLUG_SET UnitExternalPlugs[2];
    ULONG ulUnitPlugConnectionCount;
    KSPIN_LOCK AvcGlobalInfoSpinlock;
    KMUTEX AvcPlugMonitorMutex;
} AVC_SUBUNIT_GLOBAL_INFO, *PAVC_SUBUNIT_GLOBAL_INFO;

extern AVC_SUBUNIT_GLOBAL_INFO AvcSubunitGlobalInfo;

typedef struct _HW_DEVICE_EXTENSION HW_DEVICE_EXTENSION, *PHW_DEVICE_EXTENSION;

// Hardware device extension
typedef struct _HW_DEVICE_EXTENSION {

    LIST_ENTRY List;

    PKSDEVICE pKsDevice;

    ULONG ulFilterCount;

    BOOLEAN fVirtualSubunitFlag;

    BOOLEAN fPlugMonitor;

    BOOLEAN fStopped;

    BOOLEAN fRemoved;

    BOOLEAN fSurpriseRemoved;

    NODE_ADDRESS NodeAddress;
    ULONG ulGenerationCount;

    PVOID pAvcUnitInformation;

    PVOID pAvcSubunitInformation;

#ifdef PSEUDO_HID
    KSPIN_LOCK TimerSpinLock;
    KDPC TimerDPC;
    KTIMER kTimer;
    KEVENT kTimerWIEvent;
    WORK_QUEUE_ITEM TimerWorkItem;
    BOOLEAN bTimerWorkItemQueued;
#endif

    WORK_QUEUE_ITEM BusResetWorkItem;

    BOOLEAN bFilterContextCreated;
    PKSFILTERFACTORY pKsFilterFactory;
    KSFILTER_DESCRIPTOR KsFilterDescriptor;

    NPAGED_LOOKASIDE_LIST Av61883CmdLookasideList;

    NPAGED_LOOKASIDE_LIST AvcCommandLookasideList;

    NPAGED_LOOKASIDE_LIST AvcMultifuncCmdLookasideList;

};

#endif // ___FW_DEVICE_H___
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\drivers\avcaudio\device.c ===
#include "Common.h"

#define DEFAULT_PLUG_COUNT	2

AVC_SUBUNIT_GLOBAL_INFO AvcSubunitGlobalInfo;

#ifdef VIRTUAL_DEVICE
NTSTATUS
VAvcInitializeDevice(
    PKSDEVICE pKsDevice );

NTSTATUS
RegistryReadVirtualDeviceEntry(
    PKSDEVICE pKsDevice,
    PBOOLEAN pfVirtualDevice );
#endif

NTSTATUS
AvcUnitInfoInitialize(  
    IN PKSDEVICE pKsDevice );

void
iPCRAccessCallback (
    IN PCMP_NOTIFY_INFO pNotifyInfo );

void
oPCRAccessCallback (
    IN PCMP_NOTIFY_INFO pNotifyInfo );

NTSTATUS
AvcSubunitInitialize( 
    PKSDEVICE pKsDevice );

NTSTATUS
DeviceCreate(
    IN PKSDEVICE pKsDevice )
{
    PHW_DEVICE_EXTENSION pHwDevExt;
    NTSTATUS ntStatus = STATUS_SUCCESS;
    BOOLEAN fVirtualSubunitFlag;

    _DbgPrintF(DEBUGLVL_TERSE,("[DeviceCreate]\n"));

    PAGED_CODE();

    ASSERT(pKsDevice);

#if DBG && DBGMEMMAP
    InitializeMemoryList();
#endif

    // Initialize Debug log
    DbgLogInit();
    DbgLog("TEST",1,2,3,4);


#ifdef VIRTUAL_DEVICE
    // Determine if this is an actual device or a virtual device.
    ntStatus = RegistryReadVirtualDeviceEntry( pKsDevice, &fVirtualSubunitFlag );
    if ( !NT_SUCCESS(ntStatus) ) return ntStatus;    
#endif

    // Create the Hardware Device Extension
    pHwDevExt = AllocMem(NonPagedPool, sizeof(HW_DEVICE_EXTENSION) );
    if ( !pHwDevExt ) return STATUS_INSUFFICIENT_RESOURCES;

    KsAddItemToObjectBag(pKsDevice->Bag, pHwDevExt, FreeMem);

    RtlZeroMemory(pHwDevExt, sizeof(HW_DEVICE_EXTENSION));

    pKsDevice->Context = pHwDevExt;

    pHwDevExt->pKsDevice = pKsDevice;


    // Create the 61883 command lookaside
    ExInitializeNPagedLookasideList(
        &pHwDevExt->Av61883CmdLookasideList,
        AllocMemTag,
        FreeMem,
        0,
        sizeof(AV_61883_REQUEST) + sizeof(KSEVENT) + sizeof(IO_STATUS_BLOCK),
        'UAWF',
        30);

    // Initialize AV/C Request packet lookaside lists
    ExInitializeNPagedLookasideList(
        &pHwDevExt->AvcCommandLookasideList,
        AllocMemTag,
        FreeMem,
        0,
        sizeof(AVC_COMMAND_IRB) + sizeof(KSEVENT) + sizeof(IO_STATUS_BLOCK),
        'UAWF',
        30);

    ExInitializeNPagedLookasideList(
        &pHwDevExt->AvcMultifuncCmdLookasideList,
        AllocMemTag,
        FreeMem,
        0,
        sizeof(AVC_MULTIFUNC_IRB) + sizeof(KSEVENT) + sizeof(IO_STATUS_BLOCK),
        'UAWF',
        30);

    InitializeListHead( &pHwDevExt->List );

    return ntStatus;
}

NTSTATUS
AddToDeviceExtensionList(
    IN PKSDEVICE pKsDevice
    )
{
    PHW_DEVICE_EXTENSION pHwDevExt = pKsDevice->Context;
    BOOLEAN fFirstDevice = FALSE;
    NTSTATUS ntStatus = STATUS_SUCCESS;
    KIRQL kIrql;

    ntStatus = 
        KeWaitForMutexObject(&AvcSubunitGlobalInfo.AvcPlugMonitorMutex,
                             Executive,
                             KernelMode,
                             FALSE,
                             NULL);

    KeAcquireSpinLock( &AvcSubunitGlobalInfo.AvcGlobalInfoSpinlock, &kIrql );

    // The device can only be added once, make sure we haven't already done this
    if (IsListEmpty( &pHwDevExt->List )) {

        // Check if this will be the first device on the global list
        if (IsListEmpty( &AvcSubunitGlobalInfo.DeviceExtensionList )) {
            fFirstDevice = TRUE;
        }

        InsertTailList( &AvcSubunitGlobalInfo.DeviceExtensionList, &pHwDevExt->List );
    }

    KeReleaseSpinLock( &AvcSubunitGlobalInfo.AvcGlobalInfoSpinlock, kIrql );

    // If not done already, create initial Unit plugs
    if ( fFirstDevice ) {
        ntStatus = Av61883CreateVirtualSerialPlugs( pKsDevice, 
                                                    DEFAULT_PLUG_COUNT, 
                                                    DEFAULT_PLUG_COUNT );
        if ( NT_SUCCESS(ntStatus) ) {
            ntStatus = Av61883CreateVirtualExternalPlugs( pKsDevice,
                                                          DEFAULT_PLUG_COUNT, 
                                                          DEFAULT_PLUG_COUNT );
        }
    }

    KeReleaseMutex(&AvcSubunitGlobalInfo.AvcPlugMonitorMutex, FALSE);

    return ntStatus;
}

void
RemoveFromDeviceExtensionList(
    IN PKSDEVICE pKsDevice
    )
{
    PHW_DEVICE_EXTENSION pHwDevExt = pKsDevice->Context;
    BOOLEAN fLastDevice = FALSE;
    KIRQL kIrql;
    NTSTATUS ntStatus;

    ntStatus = 
        KeWaitForMutexObject(&AvcSubunitGlobalInfo.AvcPlugMonitorMutex,
                             Executive,
                             KernelMode,
                             FALSE,
                             NULL);

    // Remove the device extension from the global list
    KeAcquireSpinLock( &AvcSubunitGlobalInfo.AvcGlobalInfoSpinlock, &kIrql );

    // The device can only be removed once, make sure we haven't already done this
    if ( !IsListEmpty( &pHwDevExt->List ) ) {

        RemoveEntryList( &pHwDevExt->List );
        InitializeListHead( &pHwDevExt->List );

        // Check if this was the last device on the global list
        if (IsListEmpty( &AvcSubunitGlobalInfo.DeviceExtensionList )) {
            fLastDevice = TRUE;
        }
    }

    KeReleaseSpinLock( &AvcSubunitGlobalInfo.AvcGlobalInfoSpinlock, kIrql );

    // If the last one here, need to destroy created CMP registers
    if ( fLastDevice ) {
        Av61883RemoveVirtualSerialPlugs( pKsDevice );
        Av61883RemoveVirtualExternalPlugs( pKsDevice );
    }
    else {
        if ( !pHwDevExt->fSurpriseRemoved && pHwDevExt->fPlugMonitor ) {
            PHW_DEVICE_EXTENSION pNextHwDevExt = NULL;

            Av61883CMPPlugMonitor( pKsDevice, FALSE );
            pHwDevExt->fPlugMonitor = FALSE;

            // Get the next device on the global list and give it this burden
            // (note that the only routines that change the global list also
            // hold AvcPlugMonitorMutex, so no need to grab the spin lock)
            pNextHwDevExt = (PHW_DEVICE_EXTENSION)AvcSubunitGlobalInfo.DeviceExtensionList.Flink;

            if ( NT_SUCCESS(Av61883CMPPlugMonitor( pNextHwDevExt->pKsDevice, TRUE )) ) {
                pNextHwDevExt->fPlugMonitor = TRUE;
            }
        }
    }

    KeReleaseMutex(&AvcSubunitGlobalInfo.AvcPlugMonitorMutex, FALSE);

    return;
}

NTSTATUS
DeviceStart(
    IN PKSDEVICE pKsDevice,
    IN PIRP Irp,
    IN PCM_RESOURCE_LIST TranslatedResources,
    IN PCM_RESOURCE_LIST UntranslatedResources )
{
    PHW_DEVICE_EXTENSION pHwDevExt = pKsDevice->Context;
    BOOLEAN fVirtualSubunitFlag = FALSE;
    ULONG ulDiagLevel = DIAGLEVEL_NONE;
    NTSTATUS ntStatus = STATUS_SUCCESS;

    _DbgPrintF(DEBUGLVL_TERSE,("[DeviceStart]\n"));

    PAGED_CODE();

    ASSERT(pKsDevice);
    ASSERT(Irp);

    // If returning after a STOP, then just restart the timer DPC
    if (pHwDevExt->fStopped) {
#ifdef PSEUDO_HID
        ntStatus = TimerInitialize( pKsDevice );
#endif
        pHwDevExt->fStopped = FALSE;

        return ntStatus;
    }

    // Make it so that 61883 will not try to assign a broadcast address
    // to a plug when disconnected.
    ntStatus = Av61883GetSetUnitInfo( pKsDevice,
                                      Av61883_SetUnitInfo,
                                      SET_UNIT_INFO_DIAG_LEVEL,
                                      &ulDiagLevel );

    // Go on if this fails. It SHOULD not matter.

#if DBG
    if ( !NT_SUCCESS(ntStatus) ) {
        TRAP;
    }
#endif

    ntStatus = AddToDeviceExtensionList(pKsDevice);
    if ( NT_SUCCESS(ntStatus) ) {

#ifdef VIRTUAL_DEVICE
        if ( fVirtualSubunitFlag ) {
            ntStatus = VAvcInitializeDevice( pKsDevice );
        }
        else
#endif
        {
            ntStatus = AvcUnitInfoInitialize ( pKsDevice );
            if ( NT_SUCCESS(ntStatus) ) {
                ntStatus = AvcSubunitInitialize( pKsDevice );

                if (NT_SUCCESS(ntStatus)) {
                    ntStatus = FilterCreateFilterFactory( pKsDevice, FALSE );
                    if (NT_SUCCESS(ntStatus)) {
                        ntStatus = Av61883RegisterForBusResetNotify( pKsDevice,
                                                                    REGISTER_BUS_RESET_NOTIFY );
#ifdef PSEUDO_HID
                        if (NT_SUCCESS(ntStatus)) {
                            ntStatus = TimerInitialize( pKsDevice );
                        }
#endif
                    }
                }
            }
        }
    }

    return ntStatus;
}

NTSTATUS
DevicePostStart (
    IN PKSDEVICE Device )
{
    _DbgPrintF(DEBUGLVL_VERBOSE,("[DevicePostStart]\n"));

    PAGED_CODE();

    ASSERT(Device);

    return STATUS_SUCCESS;
}

NTSTATUS
DeviceQueryStop(
    IN PKSDEVICE Device,
    IN PIRP Irp
    )
{
    _DbgPrintF(DEBUGLVL_TERSE,("[DeviceQueryStop]\n"));

    PAGED_CODE();

    ASSERT(Device);
    ASSERT(Irp);

    return STATUS_SUCCESS;
}

void
DeviceCancelStop(
    IN PKSDEVICE Device,
    IN PIRP Irp
    )
{
    _DbgPrintF(DEBUGLVL_TERSE,("[DeviceCancelStop]\n"));

    PAGED_CODE();

    ASSERT(Device);
    ASSERT(Irp);
}

void
DeviceStop(
    IN PKSDEVICE pKsDevice,
    IN PIRP pIrp
    )
{
    PHW_DEVICE_EXTENSION pHwDevExt = pKsDevice->Context;
    _DbgPrintF(DEBUGLVL_TERSE,("[DeviceStop]\n"));

    PAGED_CODE();

    ASSERT(pKsDevice);
    ASSERT(pIrp);

    if ( !pHwDevExt->fStopped ) {
#ifdef PSEUDO_HID
        TimerStop( pHwDevExt );
#endif
        pHwDevExt->fStopped = TRUE;
    }

}

NTSTATUS
DeviceQueryRemove(
    IN PKSDEVICE Device,
    IN PIRP Irp
    )
{
    _DbgPrintF(DEBUGLVL_TERSE,("[PnpQueryRemove]\n"));

    PAGED_CODE();

    ASSERT(Device);
    ASSERT(Irp);

    return STATUS_SUCCESS;
}

void
DeviceCancelRemove(
    IN PKSDEVICE Device,
    IN PIRP Irp
    )
{
    _DbgPrintF(DEBUGLVL_TERSE,("[DeviceCancelRemove]\n"));

    PAGED_CODE();

    ASSERT(Device);
    ASSERT(Irp);
}

void
DeviceRemove(
    IN PKSDEVICE pKsDevice,
    IN PIRP Irp )
{
    PHW_DEVICE_EXTENSION pHwDevExt = pKsDevice->Context;
    KIRQL kIrql;
    NTSTATUS ntStatus;
    ULONG j;

    _DbgPrintF(DEBUGLVL_TERSE,("[DeviceRemove]\n"));

    PAGED_CODE();

    ASSERT(pKsDevice);
    ASSERT(Irp);

    // Only do this once
    if ( pHwDevExt->fRemoved ) return;
    pHwDevExt->fRemoved = TRUE;

    if ( !pHwDevExt->fStopped ) {

#ifdef PSEUDO_HID
        TimerStop( pHwDevExt );
#endif
        // Do not set fStopped to TRUE here... this is a REMOVE not a STOP
    }

    Av61883RegisterForBusResetNotify( pKsDevice, DEREGISTER_BUS_RESET_NOTIFY );

    RemoveFromDeviceExtensionList( pKsDevice );

    ExDeleteNPagedLookasideList ( &pHwDevExt->Av61883CmdLookasideList );
    ExDeleteNPagedLookasideList ( &pHwDevExt->AvcCommandLookasideList );
    ExDeleteNPagedLookasideList ( &pHwDevExt->AvcMultifuncCmdLookasideList );

    // Need to free up debug log resources
    DbgLogUnInit();

}

NTSTATUS
DeviceQueryCapabilities(
    IN PKSDEVICE Device,
    IN PIRP Irp,
    IN OUT PDEVICE_CAPABILITIES pCapabilities )
{
    _DbgPrintF(DEBUGLVL_VERBOSE,("[DeviceQueryCapabilities]\n"));

    PAGED_CODE();

    ASSERT(Device);
    ASSERT(Irp);

    pCapabilities->Size              = sizeof(DEVICE_CAPABILITIES);
    pCapabilities->Version           = 1;  // the version documented here is version 1
    pCapabilities->LockSupported     = FALSE;
    pCapabilities->EjectSupported    = FALSE; // Ejectable in S0
    pCapabilities->Removable         = TRUE;
    pCapabilities->DockDevice        = FALSE;
    pCapabilities->UniqueID          = FALSE;
    pCapabilities->SilentInstall     = TRUE;
    pCapabilities->RawDeviceOK       = FALSE;
    pCapabilities->SurpriseRemovalOK = TRUE;
    pCapabilities->HardwareDisabled  = FALSE;

    pCapabilities->DeviceWake        = PowerDeviceUnspecified;
    pCapabilities->D1Latency         = 0;
    pCapabilities->D2Latency         = 0;
    pCapabilities->D3Latency         = 20000; // 2 Seconds (in 100 usec units)

    return STATUS_SUCCESS;
}

void
DeviceSurpriseRemoval(
    IN PKSDEVICE pKsDevice,
    IN PIRP pIrp )
{
    PKSFILTERFACTORY pKsFilterFactory;
    PKSFILTER pKsFilter;
    PKSPIN pKsPin;
    ULONG i;
    NTSTATUS ntStatus;

    _DbgPrintF(DEBUGLVL_TERSE,("[DeviceSurpriseRemoval]\n"));

    PAGED_CODE();

    ASSERT(pKsDevice);
    ASSERT(pIrp);

    // For each filter, Check for open pins. If found Close them.
    pKsFilterFactory = KsDeviceGetFirstChildFilterFactory( pKsDevice );

    while (pKsFilterFactory) {
        // Find each open filter for this filter factory
        pKsFilter = KsFilterFactoryGetFirstChildFilter( pKsFilterFactory );

        while (pKsFilter) {

            KsFilterAcquireControl( pKsFilter );

            // Find each open pin for this open filter
            for ( i = 0; i < pKsFilter->Descriptor->PinDescriptorsCount; i++) {

                pKsPin = KsFilterGetFirstChildPin( pKsFilter, i );

                while (pKsPin) {

                    PinSurpriseRemove( pKsPin );

                    // Get the next pin
                    pKsPin = KsPinGetNextSiblingPin( pKsPin );
                }
            }

            KsFilterReleaseControl( pKsFilter );

            // Get the next Filter
            pKsFilter = KsFilterGetNextSiblingFilter( pKsFilter );
        }
        // Get the next Filter Factory
        pKsFilterFactory = KsFilterFactoryGetNextSiblingFilterFactory( pKsFilterFactory );
    }

    ((PHW_DEVICE_EXTENSION)pKsDevice->Context)->fSurpriseRemoved = TRUE;
}

NTSTATUS
DeviceQueryPowerState (
    IN PKSDEVICE Device,
    IN PIRP Irp,
    IN DEVICE_POWER_STATE DeviceTo,
    IN DEVICE_POWER_STATE DeviceFrom,
    IN SYSTEM_POWER_STATE SystemTo,
    IN SYSTEM_POWER_STATE SystemFrom,
    IN POWER_ACTION Action
)
{

    _DbgPrintF(DEBUGLVL_VERBOSE,("[DeviceQueryPowerState]\n"));

    PAGED_CODE();

    ASSERT(Device);
    ASSERT(Irp);

    return STATUS_SUCCESS;
}

void
DeviceSetPowerState(
    IN PKSDEVICE Device,
    IN PIRP Irp,
    IN DEVICE_POWER_STATE To,
    IN DEVICE_POWER_STATE From
    )
{
    _DbgPrintF(DEBUGLVL_TERSE,("[DeviceSetPowerState]\n"));

    PAGED_CODE();

    ASSERT(Device);
    ASSERT(Irp);
}

const
KSDEVICE_DISPATCH
KsDeviceDispatchTable =
{
    DeviceCreate,
    DeviceStart,
    NULL, // DevicePostStart,
    DeviceQueryStop,
    DeviceCancelStop,
    DeviceStop,
    DeviceQueryRemove,
    DeviceCancelRemove,
    DeviceRemove,
    DeviceQueryCapabilities,
    DeviceSurpriseRemoval,
    DeviceQueryPowerState,
    DeviceSetPowerState
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\drivers\avcaudio\drivrent.c ===
#include "common.h"

#ifdef TIME_BOMB
#include "..\..\timebomb\timebomb.c"
#endif

extern const
KSDEVICE_DISPATCH
KsDeviceDispatchTable;

const
KSDEVICE_DESCRIPTOR
KsDeviceDescriptor =
{
    &KsDeviceDispatchTable,
    0,
    NULL
};

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPathName )
{
    ULONG i;
    _DbgPrintF(DEBUGLVL_TERSE,("[DriverEntry]\n"));

#ifdef TIME_BOMB
    if (HasEvaluationTimeExpired()) {
        return STATUS_EVALUATION_EXPIRATION;
    }
    #endif

    // Initialize Global Information
    AvcSubunitGlobalInfo.ulVirtualSubunitCount = 0;

    for ( i=CMP_PlugOut; i<=CMP_PlugIn; i++ ) {
        AvcSubunitGlobalInfo.UnitSerialBusPlugs[i].ulCount = 0;
        AvcSubunitGlobalInfo.UnitExternalPlugs[i].ulCount = 0;
        InitializeListHead(&AvcSubunitGlobalInfo.UnitSerialBusPlugs[i].List);
        InitializeListHead(&AvcSubunitGlobalInfo.UnitExternalPlugs[i].List);
    }

    InitializeListHead(&AvcSubunitGlobalInfo.UnitPlugConnections);
    InitializeListHead(&AvcSubunitGlobalInfo.DeviceExtensionList);
    InitializeListHead(&AvcSubunitGlobalInfo.VirtualDeviceExtensionList);
    InitializeListHead(&AvcSubunitGlobalInfo.DeviceInterfaceSymlinkList);

    KeInitializeSpinLock(&AvcSubunitGlobalInfo.AvcGlobalInfoSpinlock);
    KeInitializeMutex(&AvcSubunitGlobalInfo.AvcPlugMonitorMutex, PASSIVE_LEVEL);

    return
        KsInitializeDriver(
            DriverObject,
            RegistryPathName,
            &KsDeviceDescriptor);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\drivers\avcaudio\dbglog.h ===
#ifndef __DBGLOG_H
#define __DBGLOG_H

#define DEBUG_LOG 1

#if DBG && DEBUG_LOG
// structure and calls to save data in debug buffer

typedef struct _DBG_LOG_ENTRY {
    CHAR     le_name[8];      // Identifying string
    LARGE_INTEGER SysTime;    // System Time
//    ULONG    Irql;            // Current Irql
    ULONG    le_info1;        // entry specific info
    ULONG    le_info2;        // entry specific info
    ULONG    le_info3;        // entry specific info
    ULONG    le_info4;        // entry specific info
} DBG_LOG_ENTRY, *PDBG_LOG_ENTRY;

typedef struct _DBG_BUFFER {
    UCHAR LGFlag[16];
    ULONG EntryCount;
    PDBG_LOG_ENTRY pLogHead;
    PDBG_LOG_ENTRY pLogTail;
    PDBG_LOG_ENTRY pLog;
} DBG_BUFFER, *PDBG_BUFFER;

VOID
DbugLogEntry( 
    IN CHAR *Name,
    IN ULONG Info1,
    IN ULONG Info2,
    IN ULONG Info3,
    IN ULONG Info4
    );

VOID
DbugLogInitialization(void);

VOID
DbugLogUnInitialization(void);

#define DbgLogInit() DbugLogInitialization()
#define DbgLogUnInit() DbugLogUnInitialization()
#define DbgLog(a,b,c,d,e) DbugLogEntry(a,(ULONG)(ULONG_PTR)b,(ULONG)(ULONG_PTR)c,(ULONG)(ULONG_PTR)d,(ULONG)(ULONG_PTR)e)

#else
#define DbgLogInit()
#define DbgLogUnInit()
#define DbgLog(a,b,c,d,e)
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\drivers\avcaudio\filter.c ===
#include "Common.h"

#ifdef PSEUDO_HID
extern const KSEVENT_SET HwEventSetTable[];
#endif

NTSTATUS
FilterCreate(
    IN OUT PKSFILTER pKsFilter,
    IN PIRP Irp )
{
    PKSFILTERFACTORY pKsFilterFactory = KsFilterGetParentFilterFactory( pKsFilter );
    NTSTATUS ntStatus = STATUS_SUCCESS;

//    _DbgPrintF(DEBUGLVL_VERBOSE,("[FilterCreate]\n"));

    PAGED_CODE();

    ASSERT(pKsFilter);
    ASSERT(Irp);

    if ( pKsFilterFactory ) {
        // Get device extension for filter context
        PKSDEVICE pKsDevice = (PVOID)KsFilterFactoryGetParentDevice( pKsFilterFactory );
 
        if ( pKsDevice ) {

            InterlockedIncrement(&((PHW_DEVICE_EXTENSION)pKsDevice->Context)->ulFilterCount);

            pKsFilter->Context = (PVOID)KsFilterFactoryGetParentDevice( pKsFilterFactory );
        }
    }
    else {
        ntStatus = STATUS_INVALID_PARAMETER;
    }
    
	return ntStatus;
}

NTSTATUS
FilterClose(
    IN OUT PKSFILTER pKsFilter,
    IN PIRP Irp )
{
    PKSFILTERFACTORY pKsFilterFactory = KsFilterGetParentFilterFactory( pKsFilter );
    NTSTATUS ntStatus = STATUS_SUCCESS;

//    _DbgPrintF(DEBUGLVL_VERBOSE,("[FilterCreate]\n"));

    PAGED_CODE();

    ASSERT(pKsFilter);
    ASSERT(Irp);

    if ( pKsFilterFactory ) {
        // Get device extension for filter context
        PKSDEVICE pKsDevice = (PVOID)KsFilterFactoryGetParentDevice( pKsFilterFactory );
 
        if ( pKsDevice )
            InterlockedDecrement(&((PHW_DEVICE_EXTENSION)pKsDevice->Context)->ulFilterCount);
    }

    return ntStatus;
}

const
KSFILTER_DISPATCH
KsFilterDispatch =
{
    FilterCreate,
    FilterClose,
    NULL,
    NULL
};

NTSTATUS
FilterCreateKsFilterContext( 
    PKSDEVICE pKsDevice,
    PBOOLEAN  pGrouping )
{
    PHW_DEVICE_EXTENSION pHwDevExt = (PHW_DEVICE_EXTENSION)pKsDevice->Context;
    PKSFILTER_DESCRIPTOR pKsFilterDescriptor = &pHwDevExt->KsFilterDescriptor;
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PKSAUTOMATION_TABLE pKsAutomationTable;
    PKSPROPERTY_ITEM pDevPropItems;
    PKSPROPERTY_SET pDevPropSet;
    ULONG ulNumPropItems = 1;
    ULONG ulNumPropSets = 1;

    PAGED_CODE();

    // Check if device is part of a group. If so take care of it. If not, continue.
    ntStatus = GroupingDeviceGroupSetup( pKsDevice );
    if ( ntStatus == STATUS_DEVICE_BUSY ) {
        *pGrouping = TRUE;
        return ntStatus;
    }

    RtlZeroMemory( pKsFilterDescriptor, sizeof(KSFILTER_DESCRIPTOR) );

    // Fill in static values of KsFilterDescriptor
    pKsFilterDescriptor->Dispatch      = &KsFilterDispatch;
    pKsFilterDescriptor->ReferenceGuid = &KSNAME_Filter;
    pKsFilterDescriptor->Version       = KSFILTER_DESCRIPTOR_VERSION;
    pKsFilterDescriptor->Flags         = 0;

    // Build the descriptors for the device pins
    ntStatus = PinBuildDescriptors( pKsDevice, 
                                    (PKSPIN_DESCRIPTOR_EX *)&pKsFilterDescriptor->PinDescriptors, 
                                    &pKsFilterDescriptor->PinDescriptorsCount,
                                    &pKsFilterDescriptor->PinDescriptorSize );
    if ( !NT_SUCCESS(ntStatus) ) {
        return ntStatus;
    }

    // Build the Topology for the device filter
    ntStatus = BuildFilterTopology( pKsDevice );
    if ( !NT_SUCCESS(ntStatus) ) {
        return ntStatus;
    }

    // Build the Filter Property Sets
    BuildFilterPropertySet( pKsFilterDescriptor,
                            NULL,
                            NULL,
                            &ulNumPropItems,
                            &ulNumPropSets );

    pKsAutomationTable = 
		(PKSAUTOMATION_TABLE)AllocMem( NonPagedPool, 
		                               sizeof(KSAUTOMATION_TABLE) +
                                       (ulNumPropItems * sizeof(KSPROPERTY_ITEM)) +
                                       (ulNumPropSets  * sizeof(KSPROPERTY_SET)));

    if (!pKsAutomationTable ) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    // Bag the context for easy cleanup.
    KsAddItemToObjectBag(pKsDevice->Bag, pKsAutomationTable, FreeMem);

    RtlZeroMemory(pKsAutomationTable, sizeof(KSAUTOMATION_TABLE));

    pDevPropItems = (PKSPROPERTY_ITEM)(pKsAutomationTable + 1);
    pDevPropSet   = (PKSPROPERTY_SET)(pDevPropItems + ulNumPropItems);

    BuildFilterPropertySet( pKsFilterDescriptor,
                            pDevPropItems,
                            pDevPropSet,
                            &ulNumPropItems,
                            &ulNumPropSets );

    pKsFilterDescriptor->AutomationTable = (const KSAUTOMATION_TABLE *)pKsAutomationTable;
    pKsAutomationTable->PropertySetsCount = ulNumPropSets;
    pKsAutomationTable->PropertyItemSize  = sizeof(KSPROPERTY_ITEM);
    pKsAutomationTable->PropertySets      = (const KSPROPERTY_SET *)pDevPropSet;

#ifdef PSEUDO_HID
    pKsAutomationTable->EventSetsCount    = 1;
    pKsAutomationTable->EventItemSize     = sizeof(KSEVENT_ITEM);
    pKsAutomationTable->EventSets         = HwEventSetTable;
#endif

    pHwDevExt->bFilterContextCreated = TRUE;

    return STATUS_SUCCESS;

}

NTSTATUS
FilterCreateFilterFactory(
    PKSDEVICE pKsDevice,
    BOOLEAN fEnableInterfaces )
{
    PHW_DEVICE_EXTENSION pHwDevExt = (PHW_DEVICE_EXTENSION)pKsDevice->Context;
    PKSFILTER_DESCRIPTOR pKsFilterDescriptor = &pHwDevExt->KsFilterDescriptor;
    BOOLEAN fGrouping = FALSE;
    NTSTATUS ntStatus = STATUS_SUCCESS;

    if ( !pHwDevExt->bFilterContextCreated ) {
        ntStatus = FilterCreateKsFilterContext( pKsDevice, &fGrouping );
    }

    if ( NT_SUCCESS(ntStatus) ) {
        ntStatus = KsCreateFilterFactory( pKsDevice->FunctionalDeviceObject,
                                          pKsFilterDescriptor,
                                          L"GLOBAL",
                                          NULL,
                                          0,
                                          NULL, // Sleep Callback
                                          NULL, // Wake Callback
                                          &pHwDevExt->pKsFilterFactory );

        if ( NT_SUCCESS(ntStatus) && fEnableInterfaces ) {
            ntStatus = KsFilterFactorySetDeviceClassesState (pHwDevExt->pKsFilterFactory, TRUE);
        }
    }
    else if ( fGrouping && ( ntStatus == STATUS_DEVICE_BUSY ) ) {
        ntStatus = STATUS_SUCCESS;
    }

    return ntStatus;    
}

NTSTATUS
FilterDestroyFilterFactory(
    PKSDEVICE pKsDevice )
{
    PHW_DEVICE_EXTENSION pHwDevExt = (PHW_DEVICE_EXTENSION)pKsDevice->Context;
    NTSTATUS ntStatus = KsDeleteFilterFactory(pHwDevExt->pKsFilterFactory);

    _DbgPrintF( DEBUGLVL_VERBOSE, ("FilterDestroyFilterFactory: %x\n", ntStatus) );

    return ntStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\drivers\avcaudio\grouping.c ===
#include <Common.h>

ULONG 
GroupingMergeFeatureFBlock(
    PFUNCTION_BLOCK pFunctionBlock,
    PFUNCTION_BLOCK_DEPENDENT_INFO pFBDepInfo,
    ULONG ulChannelCount )
{
    ULONG ulFBIndx = sizeof(FUNCTION_BLOCK_DEPENDENT_INFO);
    PFEATURE_FUNCTION_BLOCK pFeatureFB;
    PFBLOCK_CHANNEL_CLUSTER pChannelCluster;
    PUCHAR pcFBDepInfo = (PUCHAR)pFBDepInfo;
    PUSHORT pFBDepLen, pLen;
    ULONG ulAddedBytes;
    ULONG i;

    // First copy over the old Block
    RtlCopyMemory( pFBDepInfo,
                   pFunctionBlock->pBase,
                   (ULONG)bswapw(pFunctionBlock->pBase->usLength) );

    // First find the Channel Cluster
    ulFBIndx += ((ULONG)pFBDepInfo->ucNumberOfInputPlugs * sizeof(SOURCE_ID));

    pChannelCluster = (PFBLOCK_CHANNEL_CLUSTER)&pcFBDepInfo[ulFBIndx];

    // Update the channel count in the Feature Function block
    pChannelCluster->ucNumberOfChannels = (UCHAR)ulChannelCount;

    // For now we can only merge if the channel config matches the master
    ASSERT( pChannelCluster->ucChannelConfigType < 2 );

    ulFBIndx += ((ULONG)bswapw(pChannelCluster->usLength) + sizeof(USHORT));

    pFBDepLen = (PUSHORT)&pcFBDepInfo[ulFBIndx];

    ulFBIndx += sizeof(USHORT);

    pFeatureFB = (PFEATURE_FUNCTION_BLOCK)&pcFBDepInfo[ulFBIndx];

    ulAddedBytes = pFeatureFB->ucControlSize * (ulChannelCount-1);

    for (i=2; i<=ulChannelCount; i++) {
        ULONG j;
        for (j=0; j<pFeatureFB->ucControlSize; j++)
            pFeatureFB->bmaControls[(i*pFeatureFB->ucControlSize)+j] = 
                        pFeatureFB->bmaControls[pFeatureFB->ucControlSize+j];
    }

    pLen = (PUSHORT)((PUCHAR)pChannelCluster + (ULONG)bswapw(pChannelCluster->usLength) + sizeof(USHORT));

    _DbgPrintF( DEBUGLVL_TERSE, ("pLen: %x, *pLen: %x\n",pLen,*pLen));
    *pLen = bswapw( bswapw(*pLen) + (USHORT)ulAddedBytes );
    
    pFeatureFB->ucControlSpecInfoSize += (UCHAR)ulAddedBytes;
    pFBDepInfo->usLength = bswapw( bswapw(pFBDepInfo->usLength) + (USHORT)ulAddedBytes );

    return ulAddedBytes;
}

ULONG 
GroupingMergeFBlock(
    PFUNCTION_BLOCK pFunctionBlock,
    PFUNCTION_BLOCK_DEPENDENT_INFO pFBDepInfo,
    ULONG ulChannelCount )
{
    ULONG ulFBIndx = sizeof(FUNCTION_BLOCK_DEPENDENT_INFO);
    PFBLOCK_CHANNEL_CLUSTER pChannelCluster;
    PUCHAR pcFBDepInfo = (PUCHAR)pFBDepInfo;
    PUSHORT pFBDepLen;

    // First copy over the old Block
    RtlCopyMemory( pFBDepInfo,
                   pFunctionBlock->pBase,
                   (ULONG)bswapw(pFunctionBlock->pBase->usLength) );

    // First find the Channel Cluster
    ulFBIndx += ((ULONG)pFBDepInfo->ucNumberOfInputPlugs * sizeof(SOURCE_ID));

    pChannelCluster = (PFBLOCK_CHANNEL_CLUSTER)&pcFBDepInfo[ulFBIndx];

    // For now we can only merge if the channel config matches the master
    ASSERT( pChannelCluster->ucChannelConfigType < 2 );

    ulFBIndx += ((ULONG)bswapw(pFunctionBlock->pChannelCluster->usLength) + sizeof(USHORT));

    pFBDepLen = (PUSHORT)&pcFBDepInfo[ulFBIndx];

    return 0;
}


NTSTATUS
GroupingMergeDevices(
    PKSDEVICE pKsDevice,
    ULONG ulDeviceCount )
{
    PHW_DEVICE_EXTENSION pHwDevExt = pKsDevice->Context;
    PAUDIO_SUBUNIT_INFORMATION pAudioSubunitInfo = pHwDevExt->pAvcSubunitInformation;
    PDEVICE_GROUP_INFO pGrpInfo = pAudioSubunitInfo->pDeviceGroupInfo;
    NTSTATUS ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    ULONG ulChannelCount = 0;
    ULONG ulAddedBytes = 0;
    ULONG ulTemp = pGrpInfo->ulChannelConfig;

    PAVC_UNIT_INFORMATION pUnitInfo = pHwDevExt->pAvcUnitInformation;

#ifdef SA_HACK
    if (( pUnitInfo->IEC61883UnitIds.VendorID == SA_VENDOR_ID ) &&
        ( pUnitInfo->IEC61883UnitIds.ModelID  == SA_MODEL_ID  )) {
        pUnitInfo->IEC61883UnitIds.ModelID++; // Do this to avoid reswapping
    }
#endif

    // Store total count of devices in current device extension. Backup device info.
    pGrpInfo->ulDeviceCount = ulDeviceCount;
    pGrpInfo->pBackupSubunitIdDesc = pAudioSubunitInfo->pSubunitIdDesc;
    pGrpInfo->pBackupAudioConfiguration = pAudioSubunitInfo->pAudioConfigurations;

    // Count the number of channels in the group channel config.
    while ( ulTemp ) {
        ulChannelCount++;
        ulTemp = (ulTemp & (ulTemp-1));
    }

    // Merge the descriptors. For now this will be just a combining of the 
    // controls in any feature function block, an update of the Master channel cluster, 
    // and an update (if necessary) of the individual channel cluster structures.
    pAudioSubunitInfo->pSubunitIdDesc = AllocMem( PagedPool, MAX_AVC_OPERAND_BYTES );
    if ( pAudioSubunitInfo->pSubunitIdDesc ) {
        PSUBUNIT_IDENTIFIER_DESCRIPTOR pSubunitIdDesc = pAudioSubunitInfo->pSubunitIdDesc;
        PAUDIO_SUBUNIT_DEPENDENT_INFO pAudioSUDepInfo;
        PCONFIGURATION_DEPENDENT_INFO pConfigDepInfo;
        PFUNCTION_BLOCK_DEPENDENT_INFO pFBDepInfo; 
        PFUNCTION_BLOCKS_INFO pFBlocksInfo;
        PFUNCTION_BLOCK pFunctionBlock;
        PUSHORT pLen;
        ULONG i;
        ULONG ulIdSize = (ULONG)((pGrpInfo->pBackupSubunitIdDesc->ucDescriptorLengthHi<<8) |
                                  pGrpInfo->pBackupSubunitIdDesc->ucDescriptorLengthLo     );

        // Copy the original first to get a starting point.
        RtlCopyMemory( pSubunitIdDesc,
                       pGrpInfo->pBackupSubunitIdDesc,
                       ulIdSize );

        pAudioSUDepInfo = ParseFindAudioSubunitDependentInfo( pSubunitIdDesc );

        // ISSUE-2001/01/10-dsisolak Assume only one configuration
        pConfigDepInfo  = ParseFindFirstAudioConfiguration( pSubunitIdDesc );

        // Find the Master channel Cluster and adjust
        pConfigDepInfo->ucNumberOfChannels = (UCHAR)ulChannelCount;
        pConfigDepInfo->usPredefinedChannelConfig = bswapw(usBitSwapper((USHORT)pGrpInfo->ulChannelConfig));

        // Now go through function blocks and update channel configs and controls for all channels
        pFBlocksInfo = ParseFindFunctionBlocksInfo( pConfigDepInfo );
        pFBDepInfo   = pFBlocksInfo->FBDepInfo;
        pFunctionBlock = pAudioSubunitInfo->pAudioConfigurations->pFunctionBlocks;
        for ( i=0; i<(ULONG)pFBlocksInfo->ucNumBlocks; i++ ) {
            PUCHAR pcFBDepInfo = (PUCHAR)pFBDepInfo;

            switch (pFunctionBlock->ulType) {
                case FB_FEATURE:
                    ulAddedBytes += GroupingMergeFeatureFBlock( pFunctionBlock++, 
                                                                pFBDepInfo,
                                                                ulChannelCount );
                    break;
                default:
                    ulAddedBytes += GroupingMergeFBlock( pFunctionBlock++, 
                                                         pFBDepInfo,
                                                         ulChannelCount );
                    break;
            }

            pFBDepInfo = (PFUNCTION_BLOCK_DEPENDENT_INFO)
                (pcFBDepInfo + ((ULONG)bswapw(pFBDepInfo->usLength)) + 2);

        }

        // Update descriptor size fields
        pLen = (PUSHORT)pSubunitIdDesc;
        _DbgPrintF( DEBUGLVL_TERSE, ("pLen: %x, *pLen: %x\n",pLen,*pLen));
        *pLen = bswapw( bswapw(*pLen) + (USHORT)ulAddedBytes );

        pLen = &pAudioSUDepInfo->usLength;
        _DbgPrintF( DEBUGLVL_TERSE, ("pLen: %x, *pLen: %x\n",pLen,*pLen));
        *pLen = bswapw( bswapw(*pLen) + (USHORT)ulAddedBytes );

        pLen = &pAudioSUDepInfo->usInfoFieldsLength;
        _DbgPrintF( DEBUGLVL_TERSE, ("pLen: %x, *pLen: %x\n",pLen,*pLen));
        *pLen = bswapw( bswapw(*pLen) + (USHORT)ulAddedBytes );

        pLen = &pConfigDepInfo->usLength;
        _DbgPrintF( DEBUGLVL_TERSE, ("pLen: %x, *pLen: %x\n",pLen,*pLen));
        *pLen = bswapw( bswapw(*pLen) + (USHORT)ulAddedBytes );

        // Reparse descriptor for combined device.
        ntStatus = ParseAudioSubunitDescriptor( pKsDevice );

    }

    return ntStatus;
}

NTSTATUS
GroupingDeviceGroupSetup (
    PKSDEVICE pKsDevice )
{
    PHW_DEVICE_EXTENSION pHwDevExt = pKsDevice->Context;
    PAUDIO_SUBUNIT_INFORMATION pAudioSubunitInfo = pHwDevExt->pAvcSubunitInformation;

    PDEVICE_GROUP_INFO pGrpInfo;

    BOOLEAN fDeviceGrouped = FALSE;
    GUID    DeviceGroupGUID;
    ULONG   ulChannelConfig;
    ULONG   ulMergedChannelCfg = 0;
    ULONG   ulDeviceCount = 0;

    NTSTATUS ntStatus;
    KIRQL kIrql;

    ntStatus = RegistryReadMultiDeviceConfig( pKsDevice,
                                             &fDeviceGrouped,
                                             &DeviceGroupGUID,
                                             &ulChannelConfig );

    _DbgPrintF( DEBUGLVL_TERSE, ("pAudioSubunitInfo: %x fDeviceGrouped: %x ulChannelConfig: %x ntStatus: %x\n",
                                  pAudioSubunitInfo, fDeviceGrouped, ulChannelConfig, ntStatus ) );

    if ( (NT_SUCCESS(ntStatus) && fDeviceGrouped) ) {
        pGrpInfo = 
            pAudioSubunitInfo->pDeviceGroupInfo = 
                AllocMem( NonPagedPool, sizeof(DEVICE_GROUP_INFO) );
        if ( !pAudioSubunitInfo->pDeviceGroupInfo ) return STATUS_INSUFFICIENT_RESOURCES;
        KsAddItemToObjectBag(pKsDevice->Bag, pGrpInfo, FreeMem);

        _DbgPrintF( DEBUGLVL_TERSE, ("pAudioSubunitInfo->pDeviceGroupInfo: %x \n",
                                      pAudioSubunitInfo->pDeviceGroupInfo ) );

        pGrpInfo->DeviceGroupGUID    = DeviceGroupGUID;
        pGrpInfo->ulChannelConfig    = ulChannelConfig;
        pGrpInfo->ulDeviceChannelCfg = 
            pAudioSubunitInfo->pAudioConfigurations->ChannelCluster.ulPredefinedChannelConfig;
//        pGrpInfo->pHwDevExts[ulDeviceCount++] = pHwDevExt;
//        ulMergedChannelCfg = pGrpInfo->ulDeviceChannelCfg;
    }
    else {
        // Device not grouped. Treat as a separate device.
        return STATUS_SUCCESS;
    }

    // Get the Channel position(s) of this device and the associated devices.
    // If they merge to form the required channel config, create a filter factory.
    KeAcquireSpinLock( &AvcSubunitGlobalInfo.AvcGlobalInfoSpinlock, &kIrql );

    pHwDevExt = (PHW_DEVICE_EXTENSION)AvcSubunitGlobalInfo.DeviceExtensionList.Flink;

    while ( pHwDevExt != (PHW_DEVICE_EXTENSION)&AvcSubunitGlobalInfo.DeviceExtensionList ) {
        pAudioSubunitInfo = pHwDevExt->pAvcSubunitInformation;

        if ( !pAudioSubunitInfo ) break;
        _DbgPrintF( DEBUGLVL_TERSE, ("pAudioSubunitInfo: %x pDeviceGroupInfo: %x\n",
                    pAudioSubunitInfo, pAudioSubunitInfo->pDeviceGroupInfo ) );
        if ( pAudioSubunitInfo->pDeviceGroupInfo ) {
            if ( IsEqualGUID( &DeviceGroupGUID, &pAudioSubunitInfo->pDeviceGroupInfo->DeviceGroupGUID ) ) {
                pGrpInfo->pHwDevExts[ulDeviceCount++] = pHwDevExt;

                // Get the Channel config from this device and merge it
                ulMergedChannelCfg |= pAudioSubunitInfo->pDeviceGroupInfo->ulDeviceChannelCfg;

                _DbgPrintF( DEBUGLVL_TERSE, ("ulMergedChannelCfg: %x ulChannelConfig: %x\n",
                                              ulMergedChannelCfg, ulChannelConfig ));
            }
        }

        pHwDevExt = (PHW_DEVICE_EXTENSION)pHwDevExt->List.Flink;
    }

    _DbgPrintF( DEBUGLVL_TERSE, ("Final: ulMergedChannelCfg: %x ulChannelConfig: %x\n",
                                  ulMergedChannelCfg, ulChannelConfig ));

    KeReleaseSpinLock( &AvcSubunitGlobalInfo.AvcGlobalInfoSpinlock, kIrql );

    if ( ulMergedChannelCfg == ulChannelConfig ) {
        ntStatus = GroupingMergeDevices( pKsDevice, ulDeviceCount );
    }
    else
        ntStatus = STATUS_DEVICE_BUSY;
    
    return ntStatus;
}

PHW_DEVICE_EXTENSION
GroupingFindChannelExtension(
    PKSDEVICE pKsDevice,
    PULONG pChannelIndex )
{
    PHW_DEVICE_EXTENSION pHwDevExt = pKsDevice->Context;
    PAUDIO_SUBUNIT_INFORMATION pAudioSubunitInfo = pHwDevExt->pAvcSubunitInformation;
    PDEVICE_GROUP_INFO pGrpInfo = pAudioSubunitInfo->pDeviceGroupInfo;
    PHW_DEVICE_EXTENSION pHwDevExtRet = NULL; 
    ULONG i, j, k;

    for (i=0; ((i<pGrpInfo->ulDeviceCount) && !pHwDevExtRet); i++) {
        ULONG ulDevChCfg;
        pHwDevExt = pGrpInfo->pHwDevExts[i];
        ulDevChCfg = ((PAUDIO_SUBUNIT_INFORMATION)pHwDevExt->pAvcSubunitInformation)->pDeviceGroupInfo->ulDeviceChannelCfg;
        if ( ulDevChCfg & (1<<*pChannelIndex) ) {
            pHwDevExtRet = pHwDevExt;
            // Determine the index on the device
            for (j=0, k=0; j<*pChannelIndex; j++) {
                if ( ulDevChCfg & (1<<j) ) k++;
            }

            *pChannelIndex = k;
        }
    }

    

    return pHwDevExtRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\drivers\avcaudio\hwevent.h ===
#ifndef ___AVCAUDIO_HARDWARE_EVENT_H___
#define ___AVCAUDIO_HARDWARE_EVENT_H___

#ifdef PSEUDO_HID
// EVENT Set for node hardware events.
static DEFINE_KSEVENT_TABLE(HwEventItem) {
    DEFINE_KSEVENT_ITEM( KSEVENT_CONTROL_CHANGE,
                         sizeof(KSEVENTDATA),
                         sizeof(ULONG) + sizeof(PTOPOLOGY_NODE_INFO),
                         HwEventAddHandler,
                         HwEventRemoveHandler,
                         HwEventSupportHandler )
};

DEFINE_KSEVENT_SET_TABLE( HwEventSetTable ) {
    DEFINE_KSEVENT_SET( &KSEVENTSETID_AudioControlChange,
                        1,
                        HwEventItem )
};
#endif

#endif //___AVCAUDIO_HARDWARE_EVENT_H___
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\drivers\avcaudio\hwevent.c ===
#include "Common.h"

typedef struct {
    KSEVENT_ENTRY KsEventEntry;
    ULONG ulNodeId;
    PTOPOLOGY_NODE_INFO pNodeInfo;
} HW_KSEVENT_ENTRY, *PHW_KSEVENT_ENTRY;

NTSTATUS
HwEventAddHandler(
    IN PIRP pIrp,
    IN PKSEVENTDATA pEventData,
    IN PKSEVENT_ENTRY pEventEntry )
{
    PKSFILTER pKsFilter = KsGetFilterFromIrp(pIrp);
    PTOPOLOGY_NODE_INFO pNodeInfo;
    NTSTATUS ntStatus = STATUS_INVALID_PARAMETER;
    PHW_KSEVENT_ENTRY pHwKsEventEntry = (PHW_KSEVENT_ENTRY)pEventEntry;

    if ( pKsFilter ) { 
    
        pHwKsEventEntry->ulNodeId = KsGetNodeIdFromIrp( pIrp );

        pNodeInfo = GET_NODE_INFO_FROM_FILTER(pKsFilter, pHwKsEventEntry->ulNodeId);
        pHwKsEventEntry->pNodeInfo = pNodeInfo;

        pNodeInfo->ulEventsEnabled++;

        _DbgPrintF( DEBUGLVL_VERBOSE, ("Events Enabled for node: %d Filter: %x NodeInfo: %x\n",
                                      pHwKsEventEntry->ulNodeId, pKsFilter, pNodeInfo) );

        ntStatus = KsDefaultAddEventHandler( pIrp, pEventData, pEventEntry );
    }

    return ntStatus;
}

VOID
HwEventRemoveHandler(
    IN PFILE_OBJECT FileObject,
    IN PKSEVENT_ENTRY pEventEntry )
{
    PHW_KSEVENT_ENTRY pHwKsEventEntry = (PHW_KSEVENT_ENTRY)pEventEntry;

    RemoveEntryList(&pEventEntry->ListEntry);

    pHwKsEventEntry->pNodeInfo->ulEventsEnabled--;

    _DbgPrintF( DEBUGLVL_VERBOSE, ("Events Disabled for node: %d NodeInfo: %x\n",
                                  pHwKsEventEntry->ulNodeId, pHwKsEventEntry->pNodeInfo ) );
}

NTSTATUS
HwEventSupportHandler(
    IN PIRP pIrp,
    IN PKSEVENT pKsEvent,
    IN OUT PVOID Data )
{
    PKSE_NODE pKsNodeEvent = (PKSE_NODE)pKsEvent;
    PKSFILTER pKsFilter = KsGetFilterFromIrp(pIrp);
    PTOPOLOGY_NODE_INFO pNodeInfo;
    NTSTATUS ntStatus = STATUS_UNSUCCESSFUL;

    _DbgPrintF( DEBUGLVL_VERBOSE, ("[HwEventSupportHandler]: pKsFilter: %x \n", pKsFilter) );

    if ( !pKsFilter ) return STATUS_INVALID_PARAMETER;
    pNodeInfo = GET_NODE_INFO_FROM_FILTER(pKsFilter, pKsNodeEvent->NodeId);

    _DbgPrintF( DEBUGLVL_VERBOSE, ("[HwEventSupportHandler]: NodeId: %x pKsFilter: %x pNodeInfo: %x\n",
                                  pKsNodeEvent->NodeId, pKsFilter, pNodeInfo) );

    if ( pNodeInfo->fEventable ) ntStatus = STATUS_SUCCESS;

    return ntStatus;

}

BOOLEAN
HwEventGenerateOnNodeCallback(
    IN PVOID Context,
    IN PKSEVENT_ENTRY pEventEntry )
{
    PHW_KSEVENT_ENTRY pHwKsEventEntry = (PHW_KSEVENT_ENTRY)pEventEntry;
    
    return ( *(PULONG)Context == pHwKsEventEntry->ulNodeId );
}

VOID
HwEventGenerateOnNode(
    PKSDEVICE pKsDevice,
    PULONG pNodeId )
{
    PKSFILTERFACTORY pKsFilterFactory;
    PKSFILTER pKsFilter;

    KsAcquireDevice( pKsDevice );

    pKsFilterFactory = KsDeviceGetFirstChildFilterFactory( pKsDevice );

    while (pKsFilterFactory) {

        // Find each open filter for this filter factory
        pKsFilter = KsFilterFactoryGetFirstChildFilter( pKsFilterFactory );

        while (pKsFilter) {

            KsFilterGenerateEvents( pKsFilter,
                                    &KSEVENTSETID_AudioControlChange,
                                    KSEVENT_CONTROL_CHANGE,
                                    0,
                                    NULL,
                                    HwEventGenerateOnNodeCallback,
                                    pNodeId );


            pKsFilter = KsFilterGetNextSiblingFilter( pKsFilter );

        }

        // Get the next Filter Factory
        pKsFilterFactory = KsFilterFactoryGetNextSiblingFilterFactory( pKsFilterFactory );
    }

    KsReleaseDevice( pKsDevice );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\drivers\avcaudio\nameguid.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       nameguid.h
//
//--------------------------------------------------------------------------


#define STATIC_USBNODENAME_BassBoost \
    0x1A71EBE0L, 0x959E, 0x11D1, 0xB4, 0x48, 0x00, 0xA0, 0xC9, 0x25, 0x5A, 0xC1

#define STATIC_USBNODENAME_StereoExtender \
    0xFD4F0300L, 0x9632, 0x11D1, 0xB4, 0x48, 0x00, 0xA0, 0xC9, 0x25, 0x5A, 0xC1
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\drivers\avcaudio\pin.c ===
#include "Common.h"


NTSTATUS
PinValidateDataFormat( 
    PKSPIN pKsPin, 
    PFWAUDIO_DATARANGE pFWAudioRange )
{
    PKSDATARANGE_AUDIO pKsDataRangeAudio = &pFWAudioRange->KsDataRangeAudio;
    PKSDATAFORMAT pFormat = pKsPin->ConnectionFormat;
    NTSTATUS ntStatus = STATUS_NO_MATCH;
    union {
        PWAVEFORMATEX    pWavFmtEx;
        PWAVEFORMATPCMEX pWavFmtPCMEx;
    } u;

    u.pWavFmtEx = (PWAVEFORMATEX)(pFormat + 1);

    if ( IS_VALID_WAVEFORMATEX_GUID(&pKsDataRangeAudio->DataRange.SubFormat) ) {
        if ( pKsDataRangeAudio->MaximumChannels == u.pWavFmtEx->nChannels ) {
            if ( pKsDataRangeAudio->MaximumBitsPerSample == (ULONG)u.pWavFmtEx->wBitsPerSample ) {
                if ( IsSampleRateInRange( pFWAudioRange, u.pWavFmtEx->nSamplesPerSec ) ){
                    if ( u.pWavFmtEx->wFormatTag == WAVE_FORMAT_EXTENSIBLE ) {
                        if ((u.pWavFmtPCMEx->Samples.wValidBitsPerSample == pFWAudioRange->ulValidDataBits ) &&
                            (u.pWavFmtPCMEx->dwChannelMask == pFWAudioRange->ulChannelConfig))
                                ntStatus = STATUS_SUCCESS;
                    }
                    else if ((u.pWavFmtEx->nChannels <= 2) && (u.pWavFmtEx->wBitsPerSample <= 16)) {
                        ntStatus = STATUS_SUCCESS;
                    }
                }
            }
        }
    }

    return ntStatus;
    
}

#define FS_32000_INDEX 0
#define FS_44100_INDEX 1
#define FS_48000_INDEX 2
#define FS_96000_INDEX 3
#define FS_MAX_INDEX   4

KS_FRAMING_RANGE                      // 10ms    20ms    Step (Must Multiply by # Channels)
AllocatorFramingTable[FS_MAX_INDEX] = {{ 320*4,  640*4,  32*4},   //Fs 32000 32bit data
                                       { 441*4,  882*4, 441*4},   //Fs 44100 32bit data
                                       { 480*4,  960*4,  48*4},   //Fs 48000 32bit data
                                       { 960*4, 1920*4,  96*4}    //Fs 96000 32bit data
};

#if DBG

NTSTATUS
ReportPlugValue(
    PKSDEVICE pKsDevice,
    ULONG ulPlugNum,
    KSPIN_DATAFLOW KsPinDataflow,
    PULONG pValue )
{
    PHW_DEVICE_EXTENSION pHwDevExt = pKsDevice->Context;
    ULONG ulValue;
    NTSTATUS ntStatus1 = STATUS_SUCCESS;

    // Get the current value of the remote plug.
    if ( NT_SUCCESS( ntStatus1 ) ) {
        ntStatus1 = Bus1394QuadletRead( pKsDevice->NextDeviceObject,
                                        (KsPinDataflow == KSPIN_DATAFLOW_IN) ? 0xf0000984+ulPlugNum :
                                                                               0xf0000904+ulPlugNum,
                                        pHwDevExt->ulGenerationCount,
                                        pValue );
        if ( !NT_SUCCESS(ntStatus1) ) {
            _DbgPrintF( DEBUGLVL_VERBOSE, ( "[PinCreateConnection] Could not read PCR Value: %x\n",ntStatus1));
        }
        else {
            *pValue = bswap(*pValue);
        }
    }
    else {
        _DbgPrintF( DEBUGLVL_VERBOSE, ( "[PinCreateConnection] Could not Get Gen Count: %x\n",ntStatus1));
    }

    return ntStatus1;

}

#endif

NTSTATUS
PinDisconnectPlugs(
    PKSPIN pKsPin )
{
    PPIN_CONTEXT pPinContext = (PPIN_CONTEXT)pKsPin->Context;
    PDEVICE_GROUP_INFO pGrpInfo = pPinContext->pDevGrpInfo;

    NTSTATUS ntStatus = STATUS_SUCCESS;

    // Disconnect plug(s) to release channel
    if ( pGrpInfo ) {
        ULONG i=0;
        for (i=0; i<pGrpInfo->ulDeviceCount; i++) {
            ntStatus = Av61883DisconnectCmpPlugs( pGrpInfo->pHwDevExts[i]->pKsDevice,
                                                  pPinContext->pPinGroupInfo[i].hConnection );
#if DBG
            if ( !NT_SUCCESS(ntStatus) ) {
                TRAP;
            }
#endif
        }
    }
    else if ( pPinContext->hConnection )
        ntStatus = Av61883DisconnectCmpPlugs( (PKSDEVICE)(KsPinGetParentFilter( pKsPin )->Context),
                                              pPinContext->hConnection );

    if ( pPinContext->pCmpRegister ) {
        Av61883ReleaseVirtualPlug(pPinContext->pCmpRegister);
    }

    ExDeleteNPagedLookasideList(&pPinContext->CipRequestLookasideList);

    return ntStatus;

}

NTSTATUS
PinCreateCCMConnection( 
    PKSPIN pKsPin )
{
    PKSFILTER pKsFilter = KsPinGetParentFilter( pKsPin );
    PPIN_CONTEXT pPinContext = pKsPin->Context;
	PCMP_REGISTER pCmpRegister = pPinContext->pCmpRegister;
    NTSTATUS ntStatus = STATUS_SUCCESS;
	PKSDEVICE pKsDevice;
	USHORT usNodeAddress;
    KIRQL kIrql;
    UCHAR ucSubunitId;
    UCHAR ucPlugNumber;

    if ( !pKsFilter ) return STATUS_INVALID_PARAMETER;

    pKsDevice = (PKSDEVICE)pKsFilter->Context;
    ucPlugNumber = (UCHAR)pPinContext->pFwAudioDataRange->pFwPinDescriptor->AvcPreconnectInfo.ConnectInfo.SubunitPlugNumber;
    ucSubunitId  = pPinContext->pFwAudioDataRange->pFwPinDescriptor->AvcPreconnectInfo.ConnectInfo.SubunitAddress[0] & 7;
    usNodeAddress = *(PUSHORT)&((PHW_DEVICE_EXTENSION)pKsDevice->Context)->NodeAddress;

    // Determine what the device's audio subunit plug is connected to before disconnecting it
    // so we can reconnect when the stream is completed.
    {
     PCCM_SIGNAL_SOURCE pCcmSignalSource = &pPinContext->CcmSignalSource;

     pCcmSignalSource->SignalDestination.SubunitType  = AVC_SUBUNITTYPE_AUDIO;
     pCcmSignalSource->SignalDestination.SubunitId    = ucSubunitId;
     pCcmSignalSource->SignalDestination.ucPlugNumber = ucPlugNumber;

     ntStatus = CCMSignalSource( pKsDevice, 
                                 AVC_CTYPE_STATUS,
                                 pCcmSignalSource );

     if ( NT_SUCCESS(ntStatus) ) {
         _DbgPrintF( DEBUGLVL_VERBOSE, ("[PinCreateCCMConnection]:CcmSignalSource: %x ntStatus: %x\n",
                                        pCcmSignalSource, ntStatus ));

         // Figure out if the Audio subunit is connected to the serial plug. If so, find out
         // if the source of the serial plug is the PC or not.
         if (( pCcmSignalSource->SignalSource.SubunitType  == AVC_SUBUNITTYPE_UNIT ) && 
             ( pCcmSignalSource->SignalSource.SubunitId    == UNIT_SUBUNIT_ID      ) &&
             ( pCcmSignalSource->SignalSource.ucPlugNumber <= MAX_IPCR )) {
             PCCM_INPUT_SELECT pCcmInputSelect = &pPinContext->CcmInputSelect;

             ntStatus = CCMInputSelectStatus ( pKsDevice,
                                               pCcmSignalSource->SignalSource.ucPlugNumber,
                                               pCcmInputSelect );
             if ( bswapw(pCcmInputSelect->usNodeId) != usNodeAddress ) {
                 // We need to save the reconnect info.
                 pPinContext->fReconnect = 2;
//                 TRAP;
             }
         }
         else {
             pPinContext->fReconnect = 1;
         }
     }
    }

    if ( !NT_SUCCESS(ntStatus) ) {
//        TRAP;
        ntStatus = STATUS_SUCCESS;
    }

    // First check if connection is already made
    _DbgPrintF( DEBUGLVL_VERBOSE, ("[PinCreateCCMConnection]: oPcr: %x\n", pCmpRegister->AvPcr.ulongData));
    if ( !pCmpRegister->AvPcr.oPCR.PPCCounter ) {
        CCM_SIGNAL_SOURCE CcmSignalSource;
        LARGE_INTEGER EvtTimeout;

        _DbgPrintF( DEBUGLVL_VERBOSE, ("Using CCM to make connection...\n"));
    
        KeAcquireSpinLock( &pPinContext->PinSpinLock, &kIrql );
        KeResetEvent( &pCmpRegister->kEventConnected );
        KeReleaseSpinLock( &pPinContext->PinSpinLock, kIrql );

        CcmSignalSource.SignalDestination.SubunitType  = AVC_SUBUNITTYPE_AUDIO;
        CcmSignalSource.SignalDestination.SubunitId    = ucSubunitId;
        CcmSignalSource.SignalDestination.ucPlugNumber = ucPlugNumber;

        ntStatus = CCMInputSelectControl ( pKsDevice,
                                           INPUT_SELECT_SUBFN_CONNECT,
                                           usNodeAddress, 
                                           (UCHAR)pCmpRegister->ulPlugNumber,
                                           &CcmSignalSource.SignalDestination );

        if ( !NT_SUCCESS(ntStatus) ) {
            _DbgPrintF(DEBUGLVL_VERBOSE,("[PinCreate] Failed 4 %x\n",ntStatus));
            return ntStatus;
        }

        // Specify a timeout of 1 second
        EvtTimeout.QuadPart = -10000 * 1000;
        // Wait for event to be signalled
        ntStatus = KeWaitForSingleObject( &pCmpRegister->kEventConnected,
                                          Executive,
                                          KernelMode,
                                          FALSE,
                                          &EvtTimeout );
        if ( ntStatus == STATUS_TIMEOUT ) {
            _DbgPrintF( DEBUGLVL_VERBOSE, ("ERROR: CCM Connection Timed out\n"));
            ntStatus = STATUS_DEVICE_NOT_READY;
        }
    }

    if ( NT_SUCCESS(ntStatus) ) {
        ntStatus = Av61883ConnectCmpPlugs( pKsDevice,
                                           0,
                                           NULL,
                                           pCmpRegister->hPlug,
                                           pKsPin->DataFlow,
                                           pKsPin->ConnectionFormat,
                                           &pPinContext->hConnection );
    }

    return ntStatus;
}

NTSTATUS
PinCreateConnection(
    PKSPIN pKsPin,
    PKSDEVICE pKsDevice,
    PAVC_UNIT_INFORMATION pAvcUnitInformation,
    PFW_PIN_DESCRIPTOR pFwPinDescriptor,
    PVOID *hConnection,
    PULONG pPlugNumber )
{

    PPIN_CONTEXT pPinContext = pKsPin->Context;
    ULONG ulNumPlugs;
    CMP_PLUG_TYPE CmpPlugType;
    ULONG ulPlugNum;
    HANDLE hPlug = NULL;
    NTSTATUS ntStatus = STATUS_SUCCESS;

    CmpPlugType = ( pKsPin->DataFlow == KSPIN_DATAFLOW_IN ) ? CMP_PlugIn : CMP_PlugOut;

    if ( pFwPinDescriptor->AvcPreconnectInfo.ConnectInfo.Flags & KSPIN_FLAG_AVC_FIXEDPCR ) {
        ulPlugNum = pFwPinDescriptor->AvcPreconnectInfo.ConnectInfo.UnitPlugNumber;
        ntStatus = 
            Av61883GetPlugHandle( pKsDevice, ulPlugNum, CmpPlugType, &hPlug );
    }
    else {
        // Need to choose a Plug Number if not permanently attached to pin..
        ulNumPlugs = ( pKsPin->DataFlow == KSPIN_DATAFLOW_IN ) ?
                     pAvcUnitInformation->CmpUnitCaps.NumInputPlugs  :
                     pAvcUnitInformation->CmpUnitCaps.NumOutputPlugs ;
        for (ulPlugNum=0; ulPlugNum<ulNumPlugs; ulPlugNum++) {
            ntStatus = 
                Av61883GetPlugHandle( pKsDevice, ulPlugNum, CmpPlugType, &hPlug );
            if ( NT_SUCCESS(ntStatus) ) {
                break;
            }
        }
    }

    if ( !NT_SUCCESS(ntStatus) ) {
        _DbgPrintF(DEBUGLVL_ERROR, ("[PinCreateConnection]ERROR: Could not allocate a device plug\n"));
        return ntStatus;
    }

    // Make AV/C connection
    ntStatus = AvcSetPinConnectInfo( pKsDevice, 
                                     pFwPinDescriptor->ulPinId, 
                                     hPlug,
                                     ulPlugNum,
                                     UNIT_SUBUNIT_ADDRESS,
                                     &pFwPinDescriptor->AvcSetConnectInfo );

    if ( !NT_SUCCESS(ntStatus) ) {
        _DbgPrintF(DEBUGLVL_ERROR,("[PinCreateConnection] Failed AvcSetPinConnectInfo %x\n",ntStatus));
        return ntStatus;
    }

    ntStatus = AvcAcquireReleaseClear( pKsDevice, 
                                       pFwPinDescriptor->ulPinId, 
                                       AVC_FUNCTION_ACQUIRE );
    if ( !NT_SUCCESS(ntStatus) ) {
        _DbgPrintF(DEBUGLVL_ERROR,("[PinCreateConnection] Failed AvcAcquireReleaseClear %x\n",ntStatus));
        return ntStatus;
    }

#if 0
    {
     ULONG ulValue;
     ReportPlugValue( pKsDevice, ulPlugNum, pKsPin->DataFlow, &ulValue );
     _DbgPrintF( DEBUGLVL_VERBOSE, ( "[PinCreateConnection] Before PCR Value: %x\n",ulValue ));
    }
#endif

    // Connect Plug to host.
    if ( pKsPin->DataFlow == KSPIN_DATAFLOW_IN ) {
        ntStatus = Av61883ConnectCmpPlugs( pKsDevice,
                                           0,
                                           hPlug,
                                           pPinContext->pCmpRegister->hPlug,
                                           pKsPin->DataFlow,
                                           pKsPin->ConnectionFormat,
                                           hConnection );
    }
    else {
        ntStatus = Av61883ConnectCmpPlugs( pKsDevice,
                                           0,
                                           pPinContext->pCmpRegister->hPlug,
                                           hPlug,
                                           pKsPin->DataFlow,
                                           pKsPin->ConnectionFormat,
                                           hConnection );
    }

    if ( !NT_SUCCESS(ntStatus) ) {
        _DbgPrintF(DEBUGLVL_ERROR,("[PinCreateConnection] Failed Av61883ConnectCmpPlugs %x\n",ntStatus));
        return ntStatus;
    }

    *pPlugNumber = ulPlugNum;

#if 0
    {
     ULONG ulValue;
     ReportPlugValue( pKsDevice, ulPlugNum, pKsPin->DataFlow, &ulValue );
     _DbgPrintF( DEBUGLVL_TERSE, ( "[PinCreateConnection] After PCR Value: %x\n",ulValue ));
    }
#endif

    return ntStatus;
}


NTSTATUS
PinCreateGroupConnection(
    PKSPIN pKsPin,
    PKSDEVICE pKsDevice,
    PAVC_UNIT_INFORMATION pAvcUnitInformation,
    PFW_PIN_DESCRIPTOR pFwPinDescriptor )
{
    PPIN_CONTEXT pPinContext = pKsPin->Context;
    PDEVICE_GROUP_INFO pGrpInfo = pPinContext->pDevGrpInfo;
    PHW_DEVICE_EXTENSION pHwDevExt;

    NTSTATUS ntStatus = STATUS_SUCCESS;
    ULONG i;

    // For each device in the group make the necessary plug connection.
    for (i=0; i<pGrpInfo->ulDeviceCount && NT_SUCCESS(ntStatus); i++) {
        ULONG ulPlugNumber;
        pHwDevExt = pGrpInfo->pHwDevExts[i];
        pPinContext->pPinGroupInfo[i].hConnection = NULL;
        ntStatus = PinCreateConnection( pKsPin,
                                        pHwDevExt->pKsDevice,
                                        pAvcUnitInformation,
                                        pFwPinDescriptor,
                                        &pPinContext->pPinGroupInfo[i].hConnection,
                                        &pPinContext->pPinGroupInfo[i].ulPlugNumber );
        _DbgPrintF( DEBUGLVL_VERBOSE, ("Group Pin %d Plug Number: %d\n", i, 
                                     pPinContext->pPinGroupInfo[i].ulPlugNumber ));
    }

    if ( NT_SUCCESS(ntStatus) ) {
        pPinContext->hConnection = pPinContext->pPinGroupInfo[0].hConnection;
    }
    else {
        ULONG j;
        NTSTATUS ntStatus1;
        for (j=0; j<i; j++) {
            ntStatus1 = Av61883DisconnectCmpPlugs( pGrpInfo->pHwDevExts[j]->pKsDevice,
                                                   pPinContext->pPinGroupInfo[i].hConnection );
            pPinContext->pPinGroupInfo[i].hConnection = NULL;
        }
    }

    return ntStatus;
}


NTSTATUS
PinCreate(
    IN OUT PKSPIN pKsPin,
    IN PIRP pIrp )
{
    PKSFILTER pKsFilter = KsPinGetParentFilter( pKsPin );
	PKSDEVICE pKsDevice;
	PHW_DEVICE_EXTENSION pHwDevExt;
	PAVC_UNIT_INFORMATION pAvcUnitInformation;
	PAUDIO_SUBUNIT_INFORMATION pAudioSubunitInfo;
    PKSALLOCATOR_FRAMING_EX pKsAllocatorFramingEx;
    PFW_PIN_DESCRIPTOR pFwPinDescriptor;
    PCMP_REGISTER pCmpRegister;
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PPIN_CONTEXT pPinContext;

    PAGED_CODE();

    // Initialize locals
    if ( !pKsFilter ) return STATUS_INVALID_PARAMETER;
    pKsDevice = pKsFilter->Context;
    pHwDevExt = (PHW_DEVICE_EXTENSION)pKsDevice->Context;
    pAvcUnitInformation = pHwDevExt->pAvcUnitInformation;
    pAudioSubunitInfo = pHwDevExt->pAvcSubunitInformation;

    // Allocate the Context for the Pin and initialize it
    pPinContext = pKsPin->Context = AllocMem(NonPagedPool, sizeof(PIN_CONTEXT));
    if (!pPinContext) {
        _DbgPrintF(DEBUGLVL_ERROR,("[PinCreate] Failed 1 %x\n",STATUS_INSUFFICIENT_RESOURCES));
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    // Bag the context for easy cleanup.
    KsAddItemToObjectBag(pKsPin->Bag, pPinContext, FreeMem);

    RtlZeroMemory( pPinContext, sizeof(PIN_CONTEXT) );

    _DbgPrintF(DEBUGLVL_VERBOSE,("[PinCreate] pin %d Context: %x\n",pKsPin->Id, pPinContext));

    // Save the Hardware extension in the Pin Context
    pPinContext->pHwDevExt             = (PHW_DEVICE_EXTENSION)pKsDevice->Context;
    pPinContext->pPhysicalDeviceObject = pKsDevice->NextDeviceObject;

    // Find the Streaming Terminal to match the data format of the Pin.
    pPinContext->pFwAudioDataRange = 
        GetDataRangeForFormat( pKsPin->ConnectionFormat,
                               (PFWAUDIO_DATARANGE)pKsPin->Descriptor->PinDescriptor.DataRanges[0],
                               pKsPin->Descriptor->PinDescriptor.DataRangesCount );
    if ( !pPinContext->pFwAudioDataRange ) {
        _DbgPrintF(DEBUGLVL_ERROR,("[PinCreate] Failed 2 %x\n",STATUS_INVALID_DEVICE_REQUEST));
        return STATUS_INVALID_DEVICE_REQUEST;
    }

    pFwPinDescriptor = pPinContext->pFwAudioDataRange->pFwPinDescriptor;

    // Initialize Pin SpinLock
    KeInitializeSpinLock(&pPinContext->PinSpinLock);

    // Clear StreamStarted flag. This is used to calculate audio position.
//    pPinContext->fStreamStartedFlag = FALSE;

    // Set initial Outstanding and Completed Request Lists
    InitializeListHead(&pPinContext->OutstandingRequestList);
    InitializeListHead(&pPinContext->CompletedRequestList);

    // Initialize Pin Starvation Event
    KeInitializeEvent( &pPinContext->PinStarvationEvent, SynchronizationEvent, FALSE );

    // Do Hardware Initialization and make CMP connections
    if ( pAudioSubunitInfo->pDeviceGroupInfo ) {
        pPinContext->pDevGrpInfo = pAudioSubunitInfo->pDeviceGroupInfo;
    }

    // Make the connection from PC Unit Serial bus output plug to subunit destination plug
    ntStatus = Av61883ReserveVirtualPlug( &pCmpRegister, 0, 
                                          ( pKsPin->DataFlow == KSPIN_DATAFLOW_IN ) ? CMP_PlugOut :
                                                                                      CMP_PlugIn );
    if ( !NT_SUCCESS(ntStatus) ) return ntStatus;

    pPinContext->pCmpRegister = pCmpRegister;

    if (( pAudioSubunitInfo->fAvcCapabilities[AVC_CAP_CCM].fCommand ) && 
        ( pKsPin->DataFlow == KSPIN_DATAFLOW_IN )) {
        ntStatus = PinCreateCCMConnection( pKsPin );
    }
    
    else if ( pAudioSubunitInfo->pDeviceGroupInfo ) {
        pPinContext->pPinGroupInfo = AllocMem( PagedPool, sizeof(PIN_GROUP_INFO)*
                                                          pAudioSubunitInfo->pDeviceGroupInfo->ulDeviceCount );
        if ( !pPinContext->pPinGroupInfo ) {
            Av61883ReleaseVirtualPlug( pCmpRegister );
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        KsAddItemToObjectBag(pKsPin->Bag, pPinContext->pPinGroupInfo, FreeMem);

        // NOTE: Grouped devices cannot be CCM.
        ntStatus = PinCreateGroupConnection( pKsPin,
                                             pKsDevice,
                                             pAvcUnitInformation, 
                                             pFwPinDescriptor );
    }

    else {
        ntStatus = PinCreateConnection( pKsPin,
                                        pKsDevice,
                                        pAvcUnitInformation, 
                                        pFwPinDescriptor,
                                        &pPinContext->hConnection,
                                        &pPinContext->ulSerialPlugNumber );
    }

    if ( !NT_SUCCESS(ntStatus) ) {
        _DbgPrintF(DEBUGLVL_VERBOSE,("[PinCreate] Connection Failed %x\n",ntStatus));
        // Release acquired local plug
        Av61883ReleaseVirtualPlug( pCmpRegister );
        return ntStatus;
    }


    // Initialize Lookaside list for CIP request structures
    ExInitializeNPagedLookasideList(
        &pPinContext->CipRequestLookasideList,
        AllocMemTag,
        FreeMem,
        0,
        sizeof(AV_CLIENT_REQUEST_LIST_ENTRY) + sizeof(CIP_FRAME),
        'UAWF',
        30);

    {
        PWAVEFORMATEXTENSIBLE pWavFmt = (PWAVEFORMATEXTENSIBLE)(pKsPin->ConnectionFormat+1);
        ULONG ulNumChannels = (ULONG)pWavFmt->Format.nChannels;
        ULONG ulIndex = ( pWavFmt->Format.nSamplesPerSec == 32000 ) ? FS_32000_INDEX :
                        ( pWavFmt->Format.nSamplesPerSec == 44100 ) ? FS_44100_INDEX :
                        ( pWavFmt->Format.nSamplesPerSec == 48000 ) ? FS_48000_INDEX :
                                                                      FS_96000_INDEX;

        ntStatus = AudioSetSampleRateOnPlug( pKsPin, pWavFmt->Format.nSamplesPerSec );

        // Setup approriate allocator framing for the interface selected.
        KsEdit( pKsPin, &pKsPin->Descriptor, FWAUDIO_POOLTAG );
        KsEdit( pKsPin, &pKsPin->Descriptor->AllocatorFraming, FWAUDIO_POOLTAG );

        // Set up allocator such that roughly 32 ms of data gets sent in a buffer.
        pKsAllocatorFramingEx = (PKSALLOCATOR_FRAMING_EX)pKsPin->Descriptor->AllocatorFraming;
        pKsAllocatorFramingEx->FramingItem[0].FramingRange.Range.MinFrameSize = AllocatorFramingTable[ulIndex].MinFrameSize * ulNumChannels;
        pKsAllocatorFramingEx->FramingItem[0].FramingRange.Range.MaxFrameSize = AllocatorFramingTable[ulIndex].MaxFrameSize * ulNumChannels;
        pKsAllocatorFramingEx->FramingItem[0].FramingRange.Range.Stepping     = AllocatorFramingTable[ulIndex].Stepping     * ulNumChannels;
    }

    return ntStatus;
}

VOID
PinWaitForStarvation(PKSPIN pKsPin)
{
    PPIN_CONTEXT pPinContext = (PPIN_CONTEXT)pKsPin->Context;
    KIRQL irql;

    KeAcquireSpinLock(&pPinContext->PinSpinLock, &irql);
    if ((pPinContext->ulCancelledBuffers + pPinContext->ulUsedBuffers ) != pPinContext->ulAttachCount) {
        _DbgPrintF(DEBUGLVL_VERBOSE,("[PinWaitForStarvation] pin %d Context: %x List: %x\n",
                                    pKsPin->Id, pPinContext, &pPinContext->OutstandingRequestList));
        KeResetEvent( &pPinContext->PinStarvationEvent );
        KeReleaseSpinLock(&pPinContext->PinSpinLock, irql);
        KeWaitForSingleObject( &pPinContext->PinStarvationEvent,
                               Executive,
                               KernelMode,
                               FALSE,
                               NULL );
        _DbgPrintF(DEBUGLVL_VERBOSE,("[PinWaitForStarvation] Wait Complete\n"));
        
    }
    else
        KeReleaseSpinLock(&pPinContext->PinSpinLock, irql);
}

NTSTATUS
PinClose(
    IN PKSPIN pKsPin,
    IN PIRP pIrp )
{
    PPIN_CONTEXT pPinContext = (PPIN_CONTEXT)pKsPin->Context;
    PKSFILTER pKsFilter = KsPinGetParentFilter( pKsPin );
    PKSDEVICE pKsDevice;

    NTSTATUS ntStatus = STATUS_SUCCESS;

    PAGED_CODE();

    ASSERT(pKsPin);
    ASSERT(pIrp);

    if ( !pKsFilter ) return STATUS_INVALID_PARAMETER;
    pKsDevice = pKsFilter->Context;

    _DbgPrintF(DEBUGLVL_VERBOSE,("[PinClose] pin %d Context: %x\n",pKsPin->Id, pPinContext));

#if DBG
    if ( pPinContext->ulAttachCount != (pPinContext->ulUsedBuffers + pPinContext->ulCancelledBuffers)) {
        _DbgPrintF(DEBUGLVL_VERBOSE,("[PinClose] ulAttachCount %d ulUsedBuffers: %d ulCancelledBuffers %d\n",
                         pPinContext->ulAttachCount, 
                         pPinContext->ulUsedBuffers,
                         pPinContext->ulCancelledBuffers ));
    }
#endif

    if ( !((PHW_DEVICE_EXTENSION)pKsDevice->Context)->fSurpriseRemoved ) {

        // Disconnect plugs.
        ntStatus = PinDisconnectPlugs( pKsPin );

        if ( NT_SUCCESS(ntStatus) ) {
            // Need to reconnect if CCM and PC was not the source of the audio before the stream started
            if ( pPinContext->fReconnect ) {
                _DbgPrintF(DEBUGLVL_VERBOSE,("[PinClose] Reconnect: %x\n",pPinContext->fReconnect));
                if ( pPinContext->fReconnect == 1 ) {
                    // Reconnect to subunit plug within device or external plug
                    ntStatus = CCMSignalSource( pKsDevice, 
                                                AVC_CTYPE_CONTROL,
                                                &pPinContext->CcmSignalSource );
                }
                else if ( pPinContext->fReconnect == 2 ) {
                    // Reconnect to serial bus device
                    ntStatus = CCMInputSelectControl ( pKsDevice,
                                                       INPUT_SELECT_SUBFN_CONNECT,
                                                       bswapw(pPinContext->CcmInputSelect.usNodeId), 
                                                       pPinContext->CcmInputSelect.ucOutputPlug,
                                                       &pPinContext->CcmInputSelect.SignalDestination );

                }
            }
        }

        ExDeleteNPagedLookasideList( &pPinContext->CipRequestLookasideList );
    }

    return ntStatus;
}

NTSTATUS
PinCancelOutstandingRequests(
    IN PKSPIN pKsPin )
{
    PAV_CLIENT_REQUEST_LIST_ENTRY pAVListEntry;
    PPIN_CONTEXT pPinContext = (PPIN_CONTEXT)pKsPin->Context;
    KIRQL kIrql;

    KeAcquireSpinLock( &pPinContext->PinSpinLock, &kIrql );
    while ( !IsListEmpty(&pPinContext->OutstandingRequestList) ) {
        pAVListEntry = (PAV_CLIENT_REQUEST_LIST_ENTRY)
            RemoveHeadList( &pPinContext->OutstandingRequestList );
        KeReleaseSpinLock( &pPinContext->PinSpinLock, kIrql );

        _DbgPrintF( DEBUGLVL_VERBOSE, ("Canceling Request: %x\n",pAVListEntry) );
        
        AM824CancelRequest(pAVListEntry);

        KeAcquireSpinLock( &pPinContext->PinSpinLock, &kIrql );
    }
    KeReleaseSpinLock( &pPinContext->PinSpinLock, kIrql );

    return STATUS_SUCCESS;
}

NTSTATUS
PinSetDeviceState(
    IN PKSPIN pKsPin,
    IN KSSTATE ToState,
    IN KSSTATE FromState )
{
    PPIN_CONTEXT pPinContext = (PPIN_CONTEXT)pKsPin->Context;
    PHW_DEVICE_EXTENSION pHwDevExt = pPinContext->pHwDevExt;

    NTSTATUS ntStatus = STATUS_SUCCESS;

    PAGED_CODE();

    ASSERT(pKsPin);

    _DbgPrintF(DEBUGLVL_VERBOSE,("[PinSetDeviceState] pin %d Context: %x From: %d To: %d\n",
                                pKsPin->Id, pPinContext, FromState, ToState));

    switch( ToState ) {
        case KSSTATE_STOP:
            DbgLog( "KSSTOP", pPinContext->fIsStreaming,  pPinContext->ulAttachCount,
                              pPinContext->ulUsedBuffers, pPinContext->ulCancelledBuffers );
            if (pPinContext->fIsStreaming && !pHwDevExt->fSurpriseRemoved) {
                if ( pKsPin->DataFlow == KSPIN_DATAFLOW_IN ) {
                    // Wait for Pin Starvation 
                    PinWaitForStarvation( pKsPin );
                }
    
                ntStatus = Av61883StopTalkOrListen( (PKSDEVICE)(KsPinGetParentFilter( pKsPin )->Context),
                                                    pPinContext->hConnection );

                if ( !NT_SUCCESS(ntStatus) ) TRAP;

                // If capturing, Cancel all outstanding requests.
                if ( pKsPin->DataFlow == KSPIN_DATAFLOW_OUT ) {
                    PinCancelOutstandingRequests( pKsPin );

                    // Wait for Pin Starvation
                    PinWaitForStarvation( pKsPin );
                }

                pPinContext->fIsStreaming = FALSE;
            }
            _DbgPrintF(DEBUGLVL_VERBOSE,("[PinSetDeviceState] STOP\n"));

            break;

        case KSSTATE_ACQUIRE:
            DbgLog( "KSACQIR", pPinContext->fIsStreaming,  pPinContext->ulAttachCount,
                               pPinContext->ulUsedBuffers, pPinContext->ulCancelledBuffers );
            _DbgPrintF(DEBUGLVL_VERBOSE,("[PinSetDeviceState] ACQUIRE\n"));
            break;

        case KSSTATE_PAUSE:
            DbgLog( "KSPAUSE", pPinContext->fIsStreaming,  pPinContext->ulAttachCount,
                               pPinContext->ulUsedBuffers, pPinContext->ulCancelledBuffers );
            _DbgPrintF(DEBUGLVL_VERBOSE,("[PinSetDeviceState] PAUSE\n"));

            
            break;

        case KSSTATE_RUN: 
   
            DbgLog( "KSRUN",   pPinContext->fIsStreaming,  pPinContext->ulAttachCount,
                               pPinContext->ulUsedBuffers, pPinContext->ulCancelledBuffers );
            _DbgPrintF(DEBUGLVL_VERBOSE,("[PinSetDeviceState] RUN\n"));

            if ( pKsPin->DataFlow == KSPIN_DATAFLOW_OUT ) {

                _DbgPrintF(DEBUGLVL_VERBOSE,("[PinSetDeviceState] Start Listening\n"));
                ntStatus = 
                    Av61883StartTalkingOrListening( (PKSDEVICE)(KsPinGetParentFilter( pKsPin )->Context),
                                                    pPinContext->hConnection,
                                                    Av61883_Listen );
                if ( NT_SUCCESS(ntStatus) )
                    pPinContext->fIsListening = TRUE;
            }
    }

#if DBG
    if ( !NT_SUCCESS(ntStatus) ) {
        _DbgPrintF(DEBUGLVL_VERBOSE,("[PinSetDeviceState] ERROR: ntStatus: %x\n", ntStatus));
    }
#endif

    return ntStatus;
}


NTSTATUS
PinSetDataFormat(
    IN PKSPIN pKsPin,
    IN PKSDATAFORMAT OldFormat OPTIONAL,
    IN PKSMULTIPLE_ITEM OldAttributeList OPTIONAL,
    IN const KSDATARANGE* DataRange,
    IN const KSATTRIBUTE_LIST* AttributeRange OPTIONAL )
{

    NTSTATUS ntStatus = STATUS_NO_MATCH;

    PAGED_CODE();

    ASSERT(pKsPin);

    _DbgPrintF(DEBUGLVL_VERBOSE,("[PinSetDataFormat] pin %d\n",pKsPin->Id));

    // If the old format is not NULL then the pin has already been created.
    if ( OldFormat ) {
        PPIN_CONTEXT pPinContext = (PPIN_CONTEXT)pKsPin->Context;
        ULONG ulFormatType = pPinContext->pFwAudioDataRange->ulDataType & DATA_FORMAT_TYPE_MASK;

        // If the pin has already been created make sure no other interface is used
        if ((PFWAUDIO_DATARANGE)DataRange == pPinContext->pFwAudioDataRange) {
            ntStatus = PinValidateDataFormat(  pKsPin, 
				                               (PFWAUDIO_DATARANGE)DataRange );
        }

        if ( NT_SUCCESS(ntStatus) && (ulFormatType == AUDIO_DATA_TYPE_TIME_BASED)) {
            ULONG ulSampleRate =
                ((PKSDATAFORMAT_WAVEFORMATEX)pKsPin->ConnectionFormat)->WaveFormatEx.nSamplesPerSec;
            ntStatus = AudioSetSampleRateOnPlug( pKsPin, ulSampleRate );
        }
    }
    // Otherwise simply check if this is a valid format
    else
        ntStatus = PinValidateDataFormat(  pKsPin, 
		                                   (PFWAUDIO_DATARANGE)DataRange );

    _DbgPrintF(DEBUGLVL_VERBOSE,("Exit [PinSetDataFormat] status: %x\n",ntStatus));

    return ntStatus;
}

NTSTATUS
PinProcess(
    IN PKSPIN pKsPin )
{
    PPIN_CONTEXT pPinContext = (PPIN_CONTEXT)pKsPin->Context;
    NTSTATUS ntStatus = STATUS_NOT_SUPPORTED;

    DbgLog("PinProc", pKsPin, pPinContext, 0, 0);

    switch( pPinContext->pFwAudioDataRange->ulTransportType ) {
        case MLAN_AM824_IEC958:
            ntStatus = AM824ProcessData( pKsPin );
            break;
        case MLAN_AM824_RAW:
        case MLAN_24BIT_PACKED:
        default:
            ntStatus = STATUS_NOT_IMPLEMENTED;
    }

    return ntStatus;
}

NTSTATUS
PinConnect(
    IN PKSPIN pKsPin
    )
{
    _DbgPrintF(DEBUGLVL_VERBOSE,("[PinConnect] pin %d\n",pKsPin->Id));
    return STATUS_SUCCESS;
}

void
PinDisconnect(
    IN PKSPIN pKsPin
    )
{
    NTSTATUS ntStatus;

    _DbgPrintF(DEBUGLVL_VERBOSE,("[PinDisconnect] pin %d\n",pKsPin->Id));
    if ( pKsPin->DataFlow == KSPIN_DATAFLOW_IN ) {
//        ntStatus = RenderStreamClose( pKsPin );
    }
    else {
//        ntStatus = CaptureStreamClose( pKsPin );
    }
}

NTSTATUS
PinDataIntersectHandler(
    IN PVOID Context,
    IN PIRP pIrp,
    IN PKSP_PIN pKsPinProperty,
    IN PKSDATARANGE DataRange,
    IN PKSDATARANGE MatchingDataRange,
    IN ULONG DataBufferSize,
    OUT PVOID pData OPTIONAL,
    OUT PULONG pDataSize )
{
    PKSFILTER pKsFilter = KsGetFilterFromIrp(pIrp);
    ULONG ulPinId = pKsPinProperty->PinId;
    PKSPIN_DESCRIPTOR_EX pKsPinDescriptorEx;
    PFWAUDIO_DATARANGE pFwAudioRange;
    NTSTATUS ntStatus = STATUS_NO_MATCH;

    if ( !pKsFilter ) {
        return STATUS_INVALID_PARAMETER;
    }

    pKsPinDescriptorEx = 
        (PKSPIN_DESCRIPTOR_EX)&pKsFilter->Descriptor->PinDescriptors[ulPinId];

    pFwAudioRange = 
        FindDataIntersection((PKSDATARANGE_AUDIO)DataRange,
                             (PFWAUDIO_DATARANGE *)pKsPinDescriptorEx->PinDescriptor.DataRanges,
                             pKsPinDescriptorEx->PinDescriptor.DataRangesCount);

    if ( pFwAudioRange ) {

        *pDataSize = GetIntersectFormatSize( pFwAudioRange );

        if ( !DataBufferSize ) {
            ntStatus = STATUS_BUFFER_OVERFLOW;
        }
        else if ( *pDataSize > DataBufferSize ) {
            ntStatus = STATUS_INVALID_DEVICE_REQUEST;
        }
        else if ( *pDataSize <= DataBufferSize ) {
            ConvertDatarangeToFormat( pFwAudioRange,
                                      (PKSDATAFORMAT)pData );
            ntStatus = STATUS_SUCCESS;
        }
    }

    return ntStatus;
}

void
PinReset(
    IN PKSPIN pKsPin
    )
{
}

NTSTATUS
PinSurpriseRemove(
    PKSPIN pKsPin )
{
    PPIN_CONTEXT pPinContext = pKsPin->Context;
    NTSTATUS ntStatus;

    _DbgPrintF(DEBUGLVL_VERBOSE,("[PinSurpriseRemove] pin %d\n",pKsPin->Id));

    // Stop the talk/listen if streaming.
    if ( pPinContext->fIsStreaming ) {
        ntStatus = Av61883StopTalkOrListen( (PKSDEVICE)(KsPinGetParentFilter( pKsPin )->Context),
                                            pPinContext->hConnection );
        if ( !NT_SUCCESS(ntStatus) ) {
            TRAP;
        }
    }

    // Cancel all submitted data requests if any. Wait for them to return.
    ntStatus = PinCancelOutstandingRequests( pKsPin );
    if ( NT_SUCCESS(ntStatus) ) {
        PinWaitForStarvation( pKsPin );
    }

    // Disconnect plugs.
    ntStatus = PinDisconnectPlugs( pKsPin );

    return ntStatus;
}

/*
struct _KSPIN_DISPATCH {
    PFNKSPINIRP Create;
    PFNKSPINIRP Close;
    PFNKSPIN Process;
    PFNKSPINVOID Reset;
    PFNKSPINSETDATAFORMAT SetDataFormat;
    PFNKSPINSETDEVICESTATE SetDeviceState;
    PFNKSPIN Connect;
    PFNKSPINVOID Disconnect;
    const KSCLOCK_DISPATCH* Clock;
    const KSALLOCATOR_DISPATCH* Allocator;
};
*/

const
KSPIN_DISPATCH
PinDispatch =
{
    PinCreate,
    PinClose,
    PinProcess,
    PinReset,
    PinSetDataFormat,
    PinSetDeviceState,
    PinConnect,
    PinDisconnect,
    NULL,
    NULL
};

const
KSDATAFORMAT BridgePinDataFormat[] = 
{
    sizeof(KSDATAFORMAT),
    0,
    0,
    0,
    {STATIC_KSDATAFORMAT_TYPE_AUDIO},
    {STATIC_KSDATAFORMAT_SUBTYPE_ANALOG},
    {STATIC_KSDATAFORMAT_SPECIFIER_NONE}
};

DEFINE_KSPIN_INTERFACE_TABLE(PinInterface) {
   {
    STATICGUIDOF(KSINTERFACESETID_Standard),
    KSINTERFACE_STANDARD_STREAMING,
    0
   }
};

DEFINE_KSPIN_MEDIUM_TABLE(PinMedium) {
    {
     STATICGUIDOF(KSMEDIUMSETID_Standard),
     KSMEDIUM_TYPE_ANYINSTANCE,
     0
    }
};

const
PKSDATAFORMAT pBridgePinFormats = (PKSDATAFORMAT)BridgePinDataFormat;

DECLARE_SIMPLE_FRAMING_EX(
    AllocatorFraming,
    STATIC_KSMEMORY_TYPE_KERNEL_NONPAGED,
    KSALLOCATOR_REQUIREMENTF_SYSTEM_MEMORY |
    KSALLOCATOR_REQUIREMENTF_PREFERENCES_ONLY,
    8,
    sizeof(ULONG) - 1,
    0, 
    0
);

NTSTATUS
PinBuildDescriptors( 
    PKSDEVICE pKsDevice, 
    PKSPIN_DESCRIPTOR_EX *ppPinDescEx, 
    PULONG pNumPins,
    PULONG pPinDecSize )
{
    PHW_DEVICE_EXTENSION pHwDevExt = (PHW_DEVICE_EXTENSION)pKsDevice->Context;
    PAUDIO_SUBUNIT_INFORMATION pAudioSubunitInfo = pHwDevExt->pAvcSubunitInformation;
    
    PKSPIN_DESCRIPTOR_EX pPinDescEx;
    PKSAUTOMATION_TABLE pKsAutomationTable;
    PKSALLOCATOR_FRAMING_EX pKsAllocatorFramingEx;
    ULONG ulNumPins, i, j = 0;
    ULONG ulNumBridgePins;
    ULONG ulNumStreamPins;
    PKSPROPERTY_ITEM pStrmPropItems;
    PKSPROPERTY_SET pStrmPropSet;
    ULONG ulNumPropertyItems = 1;
    ULONG ulNumPropertySets = 1;
    GUID *pTTypeGUID;
    ULONG ulFormatCount = 0;
    PKSDATARANGE_AUDIO *ppAudioDataRanges;
    PFWAUDIO_DATARANGE pAudioDataRange;

    // Determine the number of Pins in the Filter ( Should = # Plug Registers )
    // ISSUE-2001/01/10-dsisolak: For now assume only 1 configuration
    ulNumPins       = pAudioSubunitInfo->ulDevicePinCount;
    ulNumBridgePins = CountDeviceBridgePins( pKsDevice );
    ulNumStreamPins = ulNumPins - ulNumBridgePins;

    _DbgPrintF( DEBUGLVL_VERBOSE, ("[PinBuildDescriptors] ulNumPins: %d ulNumBridgePins: %d\n",
                                    ulNumPins, ulNumBridgePins ));

    // Determine the number of Properties and Property Sets for the Pin.
    BuildPinPropertySet( pHwDevExt,
                         NULL,
                         NULL,
                         &ulNumPropertyItems,
                         &ulNumPropertySets );

    // Count the total number of data ranges in the device.
    for ( i=0; i<ulNumStreamPins; i++ ) {
        ulFormatCount += CountFormatsForPin( pKsDevice, i );
    }

    // Allocate all the space we need to describe the Pins in the device.
    *pPinDecSize = sizeof(KSPIN_DESCRIPTOR_EX);
    *pNumPins = ulNumPins;
    pPinDescEx = *ppPinDescEx =
       (PKSPIN_DESCRIPTOR_EX)AllocMem(NonPagedPool, 
	                                    (ulNumPins * 
                                         ( sizeof(KSPIN_DESCRIPTOR_EX) +
                                           sizeof(KSAUTOMATION_TABLE)  +
                                           sizeof(KSALLOCATOR_FRAMING_EX) )) +
                                        (ulFormatCount *
                                         (  sizeof(PKSDATARANGE_AUDIO)  +
                                            sizeof(FWAUDIO_DATARANGE) )) +
                                        (ulNumPropertySets*sizeof(KSPROPERTY_SET)) +
                                        (ulNumPropertyItems*sizeof(KSPROPERTY_ITEM)) +
                                        (ulNumBridgePins*sizeof(GUID)) );
    if ( !pPinDescEx )
        return STATUS_INSUFFICIENT_RESOURCES;

    KsAddItemToObjectBag(pKsDevice->Bag, pPinDescEx, FreeMem);

    // Zero out all descriptors to start
    RtlZeroMemory(pPinDescEx, ulNumPins*sizeof(KSPIN_DESCRIPTOR_EX));

    // Set the pointer for the Automation Tables
    pKsAutomationTable = (PKSAUTOMATION_TABLE)(pPinDescEx + ulNumPins);
    RtlZeroMemory(pKsAutomationTable, ulNumPins * sizeof(KSAUTOMATION_TABLE));

    // Set pointers to Property Sets for Streaming Pins
    pStrmPropSet   = (PKSPROPERTY_SET)(pKsAutomationTable+ulNumPins);
    pStrmPropItems = (PKSPROPERTY_ITEM)(pStrmPropSet + ulNumPropertySets);

    // Set pointer to Terminal Type GUIDS
    pTTypeGUID = (GUID *)(pStrmPropItems + ulNumPropertyItems);

    // Set Pointers for DataRange pointers and DataRanges for streaming Pins
    ppAudioDataRanges = (PKSDATARANGE_AUDIO *)(pTTypeGUID + ulNumBridgePins);
    pAudioDataRange   = (PFWAUDIO_DATARANGE)(ppAudioDataRanges + ulFormatCount);

    // Set pointer to Allocator Framing structures for Streaming Pins
    pKsAllocatorFramingEx = (PKSALLOCATOR_FRAMING_EX)(pAudioDataRange + ulFormatCount);

    BuildPinPropertySet( pHwDevExt,
                         pStrmPropItems,
                         pStrmPropSet,
                         &ulNumPropertyItems,
                         &ulNumPropertySets );

    // For each pin generated by AVC.sys fill in the Descriptor for it.
    for ( i=0; i<ulNumPins; i++ ) {
        PFW_PIN_DESCRIPTOR pFwPinDesc = &pAudioSubunitInfo->pPinDescriptors[i];
        PAVCPRECONNECTINFO pPreConnInfo = &pFwPinDesc->AvcPreconnectInfo.ConnectInfo;
        ULONG ulFormatsForPin;

        // If the pin is a streaming pin, fill in the descriptor accordingly
        // (Whatever is not already filled in by AVC.sys)

        if ( pFwPinDesc->fStreamingPin ) {
            pPinDescEx[i].Dispatch = &PinDispatch;
            pPinDescEx[i].AutomationTable = &pKsAutomationTable[i];

            pKsAutomationTable[i].PropertySetsCount = ulNumPropertySets;
            pKsAutomationTable[i].PropertyItemSize  = sizeof(KSPROPERTY_ITEM);
            pKsAutomationTable[i].PropertySets      = pStrmPropSet;

            pPinDescEx[i].PinDescriptor = pFwPinDesc->AvcPinDescriptor.PinDescriptor;

            ulFormatsForPin = CountFormatsForPin( pKsDevice, i );

            pPinDescEx[i].PinDescriptor.DataRangesCount = ulFormatsForPin;
        
            pPinDescEx[i].PinDescriptor.DataRanges = (const PKSDATARANGE *)ppAudioDataRanges;

            GetPinDataRanges( pKsDevice, i, ppAudioDataRanges, pAudioDataRange );

            ppAudioDataRanges += ulFormatsForPin;
            pAudioDataRange   += ulFormatsForPin;

            if ( pPinDescEx[i].PinDescriptor.DataFlow == KSPIN_DATAFLOW_IN ) {
                pPinDescEx[i].PinDescriptor.Category = (GUID*) &KSCATEGORY_AUDIO;
                pPinDescEx[i].Flags = KSPIN_FLAG_RENDERER;
            }
            else {
                pPinDescEx[i].PinDescriptor.Category = (GUID*) &PINNAME_CAPTURE;
                pPinDescEx[i].Flags = KSPIN_FLAG_CRITICAL_PROCESSING | KSPIN_FLAG_PROCESS_IN_RUN_STATE_ONLY;
            }

            pPinDescEx[i].InstancesPossible  = 1;
            pPinDescEx[i].InstancesNecessary = 0;

            pPinDescEx[i].IntersectHandler = PinDataIntersectHandler;

            // Set up Allocator Framing
            pPinDescEx[i].AllocatorFraming = &AllocatorFraming;

        }
        else {
            PKSPIN_DESCRIPTOR pKsPinDesc = &pFwPinDesc->AvcPinDescriptor.PinDescriptor;

            pPinDescEx[i].Dispatch = NULL;
            pPinDescEx[i].AutomationTable = NULL;

            _DbgPrintF( DEBUGLVL_VERBOSE, ("Non-Streaming Pin: %x\n", pFwPinDesc));

            if ( pFwPinDesc->fFakePin ) {

                pFwPinDesc->AvcPinDescriptor.PinId = i;
                
                pKsPinDesc->InterfacesCount = 1;
                pKsPinDesc->Interfaces = PinInterface;
                pKsPinDesc->MediumsCount = 1;
                pKsPinDesc->Mediums = PinMedium;
                pKsPinDesc->DataFlow = KSPIN_DATAFLOW_OUT;
            }

            pKsPinDesc->Communication = KSPIN_COMMUNICATION_BRIDGE;

            pPinDescEx[i].PinDescriptor = pFwPinDesc->AvcPinDescriptor.PinDescriptor;

            pPinDescEx[i].PinDescriptor.DataRangesCount = 1;
            pPinDescEx[i].PinDescriptor.DataRanges = &pBridgePinFormats;
            pPinDescEx[i].PinDescriptor.Category = &pTTypeGUID[j];

            GetCategoryForBridgePin( pKsDevice, i, &pTTypeGUID[j++] );

            pPinDescEx[i].InstancesPossible  = 0;
            pPinDescEx[i].InstancesNecessary = 0;

        }
    }

    _DbgPrintF( DEBUGLVL_VERBOSE, ("[PinBuildDescriptors] ppAudioDataRanges: %x\n", ppAudioDataRanges ));

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\drivers\avcaudio\property.c ===
#include "Common.h"

#include "Property.h"

#define MAXPINNAME      256

#define DB_SCALE_16BIT 0x100
#define DB_SCALE_8BIT  0x4000

#define MAX_EQ_BANDS       30
#define MAX_EXTRA_EQ_BANDS 32

#define NEGATIVE_INFINITY 0xFFFF8000

#define MASTER_CHANNEL 0xffffffff

// extern ULONG MapPropertyToNode[KSPROPERTY_AUDIO_3D_INTERFACE+1];

NTSTATUS
GetPinName( PIRP pIrp, PKSP_PIN pKsPropPin, PVOID pData )
{
    PKSFILTER pKsFilter = KsGetFilterFromIrp(pIrp);
    PKSDEVICE pKsDevice;
    ULONG BufferLength;
    PWCHAR StringBuffer;
    ULONG StringLength;
    ULONG ulPinIndex;
    NTSTATUS Status;

    if ( !pKsFilter ) return STATUS_INVALID_PARAMETER;

    pKsDevice = (PKSDEVICE)pKsFilter->Context;

    _DbgPrintF(DEBUGLVL_VERBOSE,("[GetPinName] pKsPropPin->PinId %x\n",
                                 pKsPropPin->PinId));

    BufferLength = IoGetCurrentIrpStackLocation(pIrp)->Parameters.DeviceIoControl.OutputBufferLength;

    // Get the Friendly name for this device and append a subscript if there
    // is more than one pin on this device.

    StringBuffer = AllocMem(NonPagedPool, MAXPINNAME);
    if (!StringBuffer) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    Status = IoGetDeviceProperty(
        pKsDevice->PhysicalDeviceObject,
        DevicePropertyDeviceDescription,
        MAXPINNAME,
        StringBuffer,
        &StringLength);

    if(!NT_SUCCESS(Status)) {
        _DbgPrintF(DEBUGLVL_VERBOSE,("[GetPinName] IoGetDeviceProperty failed(%x)\n", Status));
        FreeMem(StringBuffer);
        return Status;
    }

    //  Compute actual length adding the pin subscript
    if (!BufferLength) {
        _DbgPrintF(DEBUGLVL_VERBOSE,("[GetPinName] StringLength: %x\n",StringLength));
        pIrp->IoStatus.Information = StringLength;
        Status = STATUS_BUFFER_OVERFLOW;
    }
    else if (BufferLength < StringLength) {
        Status = STATUS_BUFFER_TOO_SMALL;
    }
    else {
        BufferLength = BufferLength / sizeof(WCHAR);
        wcsncpy(pData, StringBuffer, min(BufferLength,MAXPINNAME));
        StringLength = (wcslen(pData) + 1) * sizeof(WCHAR);
        _DbgPrintF(DEBUGLVL_VERBOSE,("[GetPinName] String: %ls\n",pData));
        ASSERT(StringLength <= BufferLength * sizeof(WCHAR));
        pIrp->IoStatus.Information = StringLength;
        Status = STATUS_SUCCESS;
    }

    FreeMem(StringBuffer);

    return Status;
}

NTSTATUS DrmAudioStream_SetContentId (
    IN PIRP                          pIrp,
    IN PKSP_DRMAUDIOSTREAM_CONTENTID pProperty,
    IN PKSDRMAUDIOSTREAM_CONTENTID   pData )
{
    PKSFILTER pKsFilter = KsGetFilterFromIrp(pIrp);
    PKSPIN pKsPin = KsGetPinFromIrp(pIrp);
    PPIN_CONTEXT pPinContext;
    PKSDEVICE pKsDevice;
    DRMRIGHTS DrmRights;
    ULONG ContentId;
    NTSTATUS ntStatus = STATUS_SUCCESS;

    if ( !(pKsPin && pKsFilter) ) return STATUS_INVALID_PARAMETER;
    pPinContext = pKsPin->Context;
    pKsDevice = (PKSDEVICE)pKsFilter->Context;

    KsPinAcquireProcessingMutex(pKsPin);

    // Extract content ID and rights
    ContentId = pData->ContentId;
    DrmRights = pData->DrmRights;

    // If device has digital outputs and rights require them disabled,
    //  then we fail since we have no way to disable the digital outputs.
    if ( DrmRights.DigitalOutputDisable ) {
        _DbgPrintF(DEBUGLVL_VERBOSE,("[DrmAudioStream_SetContentId] Content has digital disabled\n"));
        ntStatus = STATUS_NOT_IMPLEMENTED;
    }

    if (NT_SUCCESS(ntStatus)) {

        ASSERT(pProperty->DrmForwardContentToDeviceObject);

        // Forward content to common class driver PDO
        ntStatus = pProperty->DrmForwardContentToDeviceObject( ContentId,
                                                               pKsDevice->NextDeviceObject,
                                                               pPinContext->hConnection );
        if ( NT_SUCCESS(ntStatus) ) {
            //  Store this in the pin context because we need to reforward if the pipe handle
            //  changes due to a power state change.
            pPinContext->DrmContentId = ContentId;
        }
    }

    KsPinReleaseProcessingMutex(pKsPin);

    return ntStatus;
}


NTSTATUS
CreateFeatureFBlockRequest( 
    PKSDEVICE pKsDevice,
    PTOPOLOGY_NODE_INFO pNodeInfo,
    ULONG ulChannelIndx,
    PVOID pData,
    ULONG ulByteCount,
    USHORT usRequestType )
{
    PHW_DEVICE_EXTENSION pHwDevExt = pKsDevice->Context;
    PAUDIO_SUBUNIT_INFORMATION pAudioSubunitInfo = pHwDevExt->pAvcSubunitInformation;
    PDEVICE_GROUP_INFO pGrpInfo = pAudioSubunitInfo->pDeviceGroupInfo;

    PFBLOCK_REQUEST_TYPE pFBReqType = (PFBLOCK_REQUEST_TYPE)&usRequestType;
    PSOURCE_ID pSourceId = (PSOURCE_ID)&pNodeInfo->ulBlockId;
    PUCHAR pcData = (PUCHAR)pData;
    ULONG i=0;
    NTSTATUS ntStatus = STATUS_INVALID_PARAMETER;

   	PFEATURE_FBLOCK_COMMAND pFeatureFBCmd = AllocMem( NonPagedPool, 
   		                                              sizeof(FEATURE_FBLOCK_COMMAND)+ulByteCount);

    if ( !pFeatureFBCmd ) return STATUS_INSUFFICIENT_RESOURCES;
    
    pFeatureFBCmd->Common.FBlockId = *pSourceId;
    pFeatureFBCmd->Common.ucControlAttribute = pFBReqType->ucControlAttribute;

    pFeatureFBCmd->ucControlSelector   = (UCHAR)pNodeInfo->ulControlType;
    pFeatureFBCmd->ucSelectorLength    = 2;
    pFeatureFBCmd->ucChannelNumber     = (UCHAR)ulChannelIndx;
    pFeatureFBCmd->ucControlDataLength = (UCHAR)ulByteCount;

    RtlCopyMemory((PUCHAR)(pFeatureFBCmd + 1), pData, ulByteCount);

//    DbLvlReq.ucValueHigh  = (ulByteCount & 1) ? pcData[0] : pcData[1];
//    DbLvlReq.ucValueLow   = pcData[0];

    // Check for device grouping and act accordingly
    if ( pGrpInfo ) {
        // If this is a Master Channel.

#ifdef MASTER_FIX
        if ( pNodeInfo->fMasterChannel )
#else
        if ( ulChannelIndx == 0 )
#endif
        {
            ASSERT( ulChannelIndx == 0 );
            if (pFBReqType->ucControlType == AVC_CTYPE_CONTROL) {
                // Loop through each device in the group and send the same value.
                i=0;
                do {
                    ntStatus = AudioFunctionBlockCommand( pGrpInfo->pHwDevExts[i++]->pKsDevice,
                                                          pFBReqType->ucControlType,
                                                          pFeatureFBCmd,
                                                          sizeof(FEATURE_FBLOCK_COMMAND) + ulByteCount );    
                } while ( NT_SUCCESS(ntStatus) && (i<pGrpInfo->ulDeviceCount) );
            }
            else {
                ntStatus = AudioFunctionBlockCommand( pKsDevice,
                                                      pFBReqType->ucControlType,
                                                      pFeatureFBCmd,
                                                      sizeof(FEATURE_FBLOCK_COMMAND) + ulByteCount );    
            }
        }
        else {
            // Find the correct extension for the channel.
            PHW_DEVICE_EXTENSION pChHwDevExt = GroupingFindChannelExtension( pKsDevice, &ulChannelIndx );

            if ( pChHwDevExt ) {
                pFeatureFBCmd->ucChannelNumber = (UCHAR)ulChannelIndx;
                ntStatus = 
                       AudioFunctionBlockCommand( pChHwDevExt->pKsDevice,
                                                  pFBReqType->ucControlType,
                                                  pFeatureFBCmd,
                                                  sizeof(FEATURE_FBLOCK_COMMAND) + ulByteCount );    
            }
        }
    }
    else {
        ntStatus = AudioFunctionBlockCommand( pKsDevice,
                                              pFBReqType->ucControlType,
                                              pFeatureFBCmd,
                                              sizeof(FEATURE_FBLOCK_COMMAND) + ulByteCount );    
    }

    if ( NT_SUCCESS(ntStatus) )
        RtlCopyMemory(pData, (PUCHAR)(pFeatureFBCmd + 1), ulByteCount);

    FreeMem(pFeatureFBCmd);

    return ntStatus;
}

NTSTATUS
UpdateDbLevelControlCache(
    PKSDEVICE pKsDevice,
    PTOPOLOGY_NODE_INFO pNodeInfo,
    PBOOLEAN pfChanged )
{
    PDB_LEVEL_CACHE pDbCache = (PDB_LEVEL_CACHE)pNodeInfo->pCachedValues;
    NTSTATUS ntStatus = STATUS_SUCCESS;
    ULONG ulByteCount;
    LONG lData;
    ULONG i;

    if ( pNodeInfo->ulControlType != VOLUME_CONTROL ) {
        ulByteCount = 1;
        lData = 0x7F;
    } 
    else {
        ulByteCount = 2;
        lData = 0xFF7F;
    }

    *pfChanged = FALSE;

    for ( i=0; i<pNodeInfo->ulNumCachedValues; i++ ) {
        ntStatus = CreateFeatureFBlockRequest(  pKsDevice, 
                                                pNodeInfo,
                                                pDbCache[i].ulChannelIndex,
                                                &lData,
                                                ulByteCount, 
                                                (USHORT)FB_GET_CUR );
        if ( NT_SUCCESS(ntStatus) ) {
            LONG lDelta = pDbCache[i].Range.SteppingDelta;
            LONG lCurrentCacheValue = pDbCache[i].lLastValueSet;

			lData = bswap(lData)>>16;

            // Determine if this value is within range of what is cached. If so
            // no update is necessary. If not, update the cache and set changed flag.
            if ( ulByteCount == 2 ) {
                lData = (LONG)((SHORT)lData) * DB_SCALE_16BIT;
            }
            else {
                lData = (LONG)((CHAR)lData) * DB_SCALE_8BIT;
            }
            if (( lData <= lCurrentCacheValue-lDelta ) ||
                ( lData >= lCurrentCacheValue+lDelta )) {
                // Update the Cache and set the changed flag
                _DbgPrintF( DEBUGLVL_VERBOSE, ("Control Level Change %x to %x\n", 
                                                lCurrentCacheValue, lData ));
                pDbCache[i].lLastValueSet = lData;
                *pfChanged = TRUE;
            }
        }
        else {
            *pfChanged = FALSE;
        }
    }

#if DBG
	DbgLog( "DbCheUp", lData, *pfChanged, pDbCache, 0 ); 
//    if ( *pfChanged && (lData == 0) ) TRAP;
#endif

    return ntStatus;
}

NTSTATUS
UpdateBooleanControlCache(
    PKSDEVICE pKsDevice,
    PTOPOLOGY_NODE_INFO pNodeInfo,
    PBOOLEAN pfChanged )
{
    PBOOLEAN_CTRL_CACHE pBoolCache = (PBOOLEAN_CTRL_CACHE)pNodeInfo->pCachedValues;
    ULONG ulAvcBoolean = 0xFF;
    NTSTATUS ntStatus = STATUS_SUCCESS;
    ULONG i;

    *pfChanged = FALSE;

    for ( i=0; i<pNodeInfo->ulNumCachedValues; i++ ) {
        ntStatus = CreateFeatureFBlockRequest(  pKsDevice, 
                                                pNodeInfo,
                                                pBoolCache[i].ulChannelIndex,
                                                &ulAvcBoolean,
                                                1, 
                                                FB_GET_CUR );
        if ( NT_SUCCESS(ntStatus) ) {
            ulAvcBoolean = ( ulAvcBoolean == AVC_ON ) ? TRUE : FALSE;
            if ( pBoolCache->fLastValueSet != ulAvcBoolean ) {
                pBoolCache->fLastValueSet = ulAvcBoolean;
                *pfChanged = TRUE;
            }
        }
        else {
            *pfChanged = FALSE;
        }
    }

    return ntStatus;
}

NTSTATUS
GetSetDBLevel(
    PKSDEVICE pKsDevice,
    PTOPOLOGY_NODE_INFO pNodeInfo,
    PLONG plData,
    ULONG ulChannel,
    ULONG ulDataBitCount,
    USHORT usRequestType )
{
    PDB_LEVEL_CACHE pDbCache = (PDB_LEVEL_CACHE)pNodeInfo->pCachedValues;
    NTSTATUS ntStatus = STATUS_INVALID_DEVICE_REQUEST;
    LONG lScaleFactor;
    LONG lData;
    PUCHAR pcData = (PUCHAR)&lData;

    _DbgPrintF( DEBUGLVL_VERBOSE, ("[GetSetDBLevel] ulChannel: %x lData: %x\n",ulChannel, *plData) );

    // Determine if this request is beyond # of channels available
    if (( ulChannel >= pNodeInfo->ulChannels ) ||
    	 !(pNodeInfo->ulCacheValid & (1<<ulChannel) ) ){
        return ntStatus;
    }

    // Find the Cache for the requested channel
    pDbCache += ulChannel;

    ASSERT((ulDataBitCount == 8) || (ulDataBitCount == 16));

    lScaleFactor = ( ulDataBitCount == 8 ) ? DB_SCALE_8BIT : DB_SCALE_16BIT;

    DbgLog( "GsDbLvl", usRequestType, plData, ulDataBitCount, ulChannel );

    switch( (ULONG)((usRequestType>>8) & 0xF) ) {
        case AVC_CTYPE_STATUS:
			DbgLog( "GsDbLv2", ((usRequestType>>8) & 0xF), plData, ulDataBitCount, ulChannel );
            *plData = pDbCache->lLastValueSet;
            ntStatus = STATUS_SUCCESS;
            break;
        case AVC_CTYPE_CONTROL:
			DbgLog( "GsDbLv3", ((usRequestType>>8) & 0xF), plData, ulDataBitCount, ulChannel );
			
            if ( *plData == pDbCache->lLastValueSet ) {
                ntStatus = STATUS_SUCCESS;
            }
            else {
                if ( *plData < pDbCache->Range.Bounds.SignedMinimum ) {
                    if ( ulDataBitCount == 16 )
                        lData = NEGATIVE_INFINITY; // Detect volume control to silence
                    else
                        lData = pDbCache->Range.Bounds.SignedMinimum / lScaleFactor;
                }
                else if ( *plData > pDbCache->Range.Bounds.SignedMaximum ) {
                    lData = pDbCache->Range.Bounds.SignedMaximum / lScaleFactor;
                }
                else  {
                    lData = *plData / lScaleFactor;
                }

                _DbgPrintF( DEBUGLVL_VERBOSE, ("[GetSetDBLevel] ulChannelIndex: %x lData: %x\n",
                                                pDbCache->ulChannelIndex, lData) );

                lData = bswap(lData)>>16;
                ntStatus = 
                     CreateFeatureFBlockRequest(  pKsDevice, 
                                                  pNodeInfo,
                                                  pDbCache->ulChannelIndex,
                                                  &lData,
                                                  ulDataBitCount>>3, 
                                                  usRequestType );

                if ( NT_SUCCESS(ntStatus) ) {
                    pDbCache->lLastValueSet = *plData;
                }
            }
            break;
        default:
            ntStatus  = STATUS_INVALID_DEVICE_REQUEST;
			TRAP;
            break;
    }

#if DBG
    if (!NT_SUCCESS(ntStatus) ) TRAP;
#endif

    return ntStatus;
}

NTSTATUS
GetDbLevelRange(
    PKSDEVICE pKsDevice,
    PTOPOLOGY_NODE_INFO pNodeInfo,
    ULONG ulChannel,
    ULONG ulDataBitCount,
    PKSPROPERTY_STEPPING_LONG pRange )
{
    NTSTATUS ntStatus = STATUS_INVALID_DEVICE_REQUEST;
    LONG lData;
    USHORT usRequestType;

    ASSERT((ulDataBitCount == 8) || (ulDataBitCount == 16));

    for ( usRequestType=FB_GET_RES; usRequestType<=FB_GET_MAX; usRequestType++ ) {

        lData = (ulDataBitCount == 16) ? 0xFF7F : 0x7F;

        ntStatus = 
             CreateFeatureFBlockRequest( pKsDevice,
                                         pNodeInfo,
                                         ulChannel,
                                         &lData,
                                         ulDataBitCount>>3,
                                         usRequestType );

        if ( !NT_SUCCESS(ntStatus) ) {
            _DbgPrintF(DEBUGLVL_VERBOSE,("'GetDbLevelRange ERROR: %x\n",ntStatus));
            break;
        }
        else {
            if ( ulDataBitCount == 8 ) {
                lData = (LONG)((CHAR)lData) * DB_SCALE_8BIT;
            }
            else {
                lData = (LONG)((SHORT)(bswap(lData)>>16)) * DB_SCALE_16BIT;
            }

            switch( usRequestType & 0xff ) {
                case FB_CTRL_ATTRIB_MINIMUM:
                    pRange->Bounds.SignedMinimum = lData;
                    break;
                case FB_CTRL_ATTRIB_MAXIMUM:
                    pRange->Bounds.SignedMaximum = lData;
                    break;
                case FB_CTRL_ATTRIB_RESOLUTION:
                    pRange->SteppingDelta = lData;
                    break;
            }
        }

        DbgLog("DBRnge", ntStatus, pRange, usRequestType, pNodeInfo );
    }

    return ntStatus;
}

NTSTATUS
InitializeDbLevelCache(
    PKSDEVICE pKsDevice,
    PTOPOLOGY_NODE_INFO pNodeInfo,
    PDB_LEVEL_CACHE pDbCache,
    ULONG ulDataBitCount )
{
    NTSTATUS ntStatus;
    LONG lScaleFactor;
    LONG lData, lSwapData;

    ASSERT((ulDataBitCount == 8) || (ulDataBitCount == 16));

    if ( ulDataBitCount == 8 ) {
        lScaleFactor = DB_SCALE_8BIT;
        lData = 0x7F;
    } 
    else {
        lScaleFactor = DB_SCALE_16BIT;
        lData = 0xFF7F;
    }

    ntStatus = GetDbLevelRange( pKsDevice,
                                pNodeInfo,
                                pDbCache->ulChannelIndex,
                                ulDataBitCount,
                                &pDbCache->Range );

    if ( NT_SUCCESS(ntStatus) ) {
        ntStatus = CreateFeatureFBlockRequest( pKsDevice,
                                         pNodeInfo,
                                         pDbCache->ulChannelIndex,
                                         &lData,
                                         ulDataBitCount>>3,
                                         (USHORT)FB_GET_CUR );

        if ( NT_SUCCESS(ntStatus) ) {
        	lData = bswap(lData)>>16;
            if ( pNodeInfo->ulControlType == VOLUME_CONTROL ) {
                _DbgPrintF( DEBUGLVL_VERBOSE, ("Current Volume Level: %x\n", lData));
                pDbCache->lLastValueSet = (LONG)((SHORT)lData) * lScaleFactor;
                _DbgPrintF(DEBUGLVL_VERBOSE,("InitDbCache: pDbCache->lLastValueSet=%d\n",pDbCache->lLastValueSet));
                if ( (pDbCache->lLastValueSet >= pDbCache->Range.Bounds.SignedMaximum) ||
                     (pDbCache->lLastValueSet <= pDbCache->Range.Bounds.SignedMinimum) ) {
                    lData = ( pDbCache->Range.Bounds.SignedMinimum +
                             ( pDbCache->Range.Bounds.SignedMaximum - pDbCache->Range.Bounds.SignedMinimum) / 2 )
                            / lScaleFactor;
                   _DbgPrintF(DEBUGLVL_VERBOSE,("InitDbCache: volume at max (%d) or min (%d), setting to average %d\n",
                                               pDbCache->Range.Bounds.SignedMaximum,
                                               pDbCache->Range.Bounds.SignedMinimum,
                                               lData));
                }

                lSwapData = bswap(lData)>>16;
                ntStatus = 
                     CreateFeatureFBlockRequest( pKsDevice,
                                                 pNodeInfo,
                                                 pDbCache->ulChannelIndex,
                                                 &lSwapData,
                                                 ulDataBitCount>>3,
                                                 (USHORT)FB_SET_CUR );
                if ( NT_SUCCESS(ntStatus) ) {
                    pDbCache->lLastValueSet = (LONG)((SHORT)lData) * lScaleFactor;
                    _DbgPrintF(DEBUGLVL_VERBOSE,("InitDbCache: setting lastvalue to %d\n",pDbCache->lLastValueSet));
                }
                else {
                    _DbgPrintF(DEBUGLVL_VERBOSE,("InitDbCache: error setting volume %d\n",lData));
                }
            }
            else {
                pDbCache->lLastValueSet = (LONG)((CHAR)lData) * lScaleFactor;
            }
        }
    }

    return ntStatus;

}

NTSTATUS 
GetSetSampleRate( PIRP pIrp, PKSPROPERTY pKsProperty, PVOID pData )
{
    return STATUS_NOT_IMPLEMENTED;
}

NTSTATUS 
GetSetVolumeLevel( PIRP pIrp, PKSPROPERTY pKsProperty, PVOID pData )
{
    PKSNODEPROPERTY_AUDIO_CHANNEL pNAC = (PKSNODEPROPERTY_AUDIO_CHANNEL)pKsProperty;
    PKSFILTER pKsFilter = KsGetFilterFromIrp(pIrp);
    PTOPOLOGY_NODE_INFO pNodeInfo;
    USHORT usRequestType = (pKsProperty->Flags & KSPROPERTY_TYPE_GET) ? 
                           FB_CTRL_ATTRIB_CURRENT | FB_CTRL_TYPE_STATUS: 
                           FB_CTRL_ATTRIB_CURRENT | FB_CTRL_TYPE_CONTROL;
    NTSTATUS ntStatus;

    if ( !pKsFilter ) return STATUS_INVALID_PARAMETER;
    pNodeInfo = GET_NODE_INFO_FROM_FILTER(pKsFilter,pNAC->NodeProperty.NodeId);

//    _DbgPrintF(DEBUGLVL_VERBOSE,("[GetSetVolumeLevel] pNodeInfo %x\n",pNodeInfo));

    ntStatus = GetSetDBLevel( (PKSDEVICE)pKsFilter->Context,
                              pNodeInfo,
                              pData,
                              pNAC->Channel,
                              16,
                              usRequestType );

    if ( NT_SUCCESS(ntStatus) ) {
        pIrp->IoStatus.Information = sizeof(ULONG);
    }

    return ntStatus;
}

NTSTATUS 
GetSetToneLevel( PIRP pIrp, PKSPROPERTY pKsProperty, PVOID pData )
{
    PKSNODEPROPERTY_AUDIO_CHANNEL pNAC = (PKSNODEPROPERTY_AUDIO_CHANNEL)pKsProperty;
    PKSFILTER pKsFilter = KsGetFilterFromIrp(pIrp);
    PTOPOLOGY_NODE_INFO pNodeInfo;
    NTSTATUS ntStatus;
    
    USHORT usRequestType = (pKsProperty->Flags & KSPROPERTY_TYPE_GET) ? 
                           FB_CTRL_ATTRIB_CURRENT | FB_CTRL_TYPE_STATUS: 
                           FB_CTRL_ATTRIB_CURRENT | FB_CTRL_TYPE_CONTROL;

    if ( !pKsFilter ) return STATUS_INVALID_PARAMETER;
    pNodeInfo = GET_NODE_INFO_FROM_FILTER(pKsFilter,pNAC->NodeProperty.NodeId);

    ntStatus = GetSetDBLevel( (PKSDEVICE)pKsFilter->Context,
                              pNodeInfo,
                              pData,
                              pNAC->Channel,
                              8,
                              usRequestType );

    if ( NT_SUCCESS(ntStatus) ) {
        pIrp->IoStatus.Information = sizeof(ULONG);
    }

    return ntStatus;
}

NTSTATUS 
GetSetCopyProtection( PIRP pIrp, PKSPROPERTY pKsProperty, PVOID pData )
{
    return STATUS_NOT_IMPLEMENTED;
}

NTSTATUS 
GetSetMixLevels( PIRP pIrp, PKSPROPERTY pKsProperty, PVOID pData )
{
    return STATUS_NOT_IMPLEMENTED;
}

NTSTATUS 
GetMuxSource( PIRP pIrp, PKSPROPERTY pKsProperty, PVOID pData )
{
    return STATUS_NOT_IMPLEMENTED;
}

NTSTATUS 
SetMuxSource( PIRP pIrp, PKSPROPERTY pKsProperty, PVOID pData )
{
    return STATUS_NOT_IMPLEMENTED;
}

NTSTATUS
GetSetChannelConfig( PIRP pIrp, PKSPROPERTY pKsProperty, PVOID pData )
{
    return STATUS_NOT_IMPLEMENTED;
}

NTSTATUS 
GetSetBoolean( PIRP pIrp, PKSPROPERTY pKsProperty, PVOID pValue )
{
    PKSNODEPROPERTY_AUDIO_CHANNEL pNAC = (PKSNODEPROPERTY_AUDIO_CHANNEL)pKsProperty;
    PKSFILTER pKsFilter = KsGetFilterFromIrp(pIrp);
    PTOPOLOGY_NODE_INFO pNodeInfo;
    ULONG ulChannel = pNAC->Channel;
    PBOOLEAN_CTRL_CACHE pBoolCache;
    NTSTATUS ntStatus = STATUS_INVALID_DEVICE_REQUEST;

    USHORT usRequestType = (pKsProperty->Flags & KSPROPERTY_TYPE_GET) ?
                           FB_CTRL_ATTRIB_CURRENT | FB_CTRL_TYPE_STATUS:
                           FB_CTRL_ATTRIB_CURRENT | FB_CTRL_TYPE_CONTROL;


    if ( !pKsFilter ) return STATUS_INVALID_PARAMETER;
    pNodeInfo = GET_NODE_INFO_FROM_FILTER(pKsFilter,pNAC->NodeProperty.NodeId);
    pBoolCache = (PBOOLEAN_CTRL_CACHE)pNodeInfo->pCachedValues;

    // Determine if this is a request for the Master channel or beyond # of channels available
    if ( ulChannel >= pNodeInfo->ulChannels ) {
        return ntStatus;
    }

    // Find the Cache for the requested channel
    pBoolCache += ulChannel;
    DbgLog("GSBool", &pNodeInfo, ulChannel, pBoolCache, 0 );

    if ( pNodeInfo->ulCacheValid & (1<<ulChannel)  ) {
        if ((usRequestType>>8) == AVC_CTYPE_STATUS) {
            *(PBOOL)pValue = pBoolCache->fLastValueSet;
            ntStatus = STATUS_SUCCESS;
        }
        else if ( pBoolCache->fLastValueSet == *(PBOOL)pValue ){
            ntStatus = STATUS_SUCCESS;
        }
        else {
            UCHAR ucValue = (UCHAR)((*(PBOOL)pValue) ? AVC_ON : AVC_OFF);
            ntStatus = CreateFeatureFBlockRequest( pKsFilter->Context,
                                                   pNodeInfo,
                                                   pBoolCache->ulChannelIndex,
                                                   &ucValue,
                                                   1, 
                                                   usRequestType );
        }
    }
    else { 
        UCHAR ucValue;

        if ( (usRequestType>>8) == AVC_CTYPE_STATUS ) ucValue = 0xFF;
        else ucValue = (UCHAR)((*(PBOOL)pValue) ? AVC_ON : AVC_OFF);

        ntStatus = CreateFeatureFBlockRequest( pKsFilter->Context,
                                               pNodeInfo,
                                               pBoolCache->ulChannelIndex,
                                               &ucValue,
                                               1, 
                                               usRequestType );

        if ( NT_SUCCESS(ntStatus) && ( (usRequestType>>8) == AVC_CTYPE_STATUS )) {
            *(PBOOL)pValue = ((ucValue & 0xff) == AVC_ON) ? TRUE : FALSE;
            pNodeInfo->ulCacheValid |= (1<<ulChannel) ;
        }
    }

    if ( NT_SUCCESS(ntStatus)) {
        pBoolCache->fLastValueSet = *(PBOOL)pValue;
        pIrp->IoStatus.Information = sizeof(BOOL);
    }

#if DBG
    else {
        _DbgPrintF(DEBUGLVL_VERBOSE,("[GetSetBoolean] failed pNodeInfo %x Status: %x\n",
                                      pNodeInfo, ntStatus ));

    }
#endif

    return ntStatus;
}

// NOTE: The second one is really 31.5 Hz - how should we handle it?
ULONG ulBandFreqs[] =
        {   25,   32,   40,   50,   63,   80,   100,   125,   160,   200,
           250,  315,  400,  500,  630,  800,  1000,  1250,  1600,  2000,
          2500, 3150, 4000, 5000, 6300, 8000, 10000, 12500, 16000, 20000 };

// NOTE: The sixth one is really 44.5 Hz - how should we handle it?
ULONG ulExtraBandFreqs[] =
        {   18,   20,   
            22,   28,   35,   45,   56,   70,   89,   110,   140,   180, 
           220,  280,  355,  445,  560,  710,  890,  1100,  1400,  1800, 
          2200, 2800, 3550, 4450, 5600, 7100, 8900, 11000, 14000, 18000 };

typedef struct {
	ULONG ulBandsPresent;
	ULONG ulExtraBandsPresent;
	CHAR  cGain[MAX_EQ_BANDS+MAX_EXTRA_EQ_BANDS];
} GEQ_REQUEST_DATA, *PGEQ_REQUEST_DATA;

NTSTATUS
GetEqualizerValues(
    PKSDEVICE pKsDevice,
    PTOPOLOGY_NODE_INFO pNodeInfo,
    ULONG  ulChannelIndx,
    USHORT usCommand,
    PLONG  pEqLevels,
    PULONG pEqBands,
    PULONG pNumEqBands,
    PULONG pNumExtraEqBands )
{
    GEQ_REQUEST_DATA GeqRequest;
    ULONG bmBandsPresent;
    NTSTATUS ntStatus;

    ASSERT( pNumEqBands && pNumExtraEqBands );

    ntStatus = CreateFeatureFBlockRequest( pKsDevice,
    	                                   pNodeInfo,
    	                                   ulChannelIndx,
    	                                   &GeqRequest,
    	                                   sizeof(GEQ_REQUEST_DATA),
    	                                   usCommand );

    if ( NT_SUCCESS(ntStatus) ) {
        ULONG ulBandCnt = 0;
        ULONG ulBandIndx = 0;
        ULONG i;

        for (i=0; i<2; i++) {

            bmBandsPresent = (i==0)? bswap(GeqRequest.ulBandsPresent) :
        	                     bswap(GeqRequest.ulExtraBandsPresent) ;

            while (bmBandsPresent) {
                if (bmBandsPresent & 1) {
                    // Put the data into our structure
                    if (pEqLevels)
                        pEqLevels[ulBandCnt] = (LONG)GeqRequest.cGain[ulBandCnt] * DB_SCALE_8BIT;
                    else if (pEqBands)
                        pEqBands[ulBandCnt] = ulBandFreqs[ulBandIndx];

                    ulBandCnt++;
                }
                bmBandsPresent >>= 1;
                ulBandIndx++;
            }

            if ( i==0 ) *pNumEqBands      = ulBandCnt;
            else         *pNumExtraEqBands = ulBandCnt - *pNumEqBands;

        }

    }

    return ntStatus;
}

NTSTATUS
SetEqualizerValues(
    PKSDEVICE pKsDevice,
    PTOPOLOGY_NODE_INFO pNodeInfo,
    ULONG  ulChannelIndx,
    PULONG pNumBands,
    PLONG  pEqLevels )
{
    GEQ_REQUEST_DATA GeqRequest;
    ULONG bmBandsPresent, ulBandCnt;
    NTSTATUS ntStatus;

    ntStatus = CreateFeatureFBlockRequest( pKsDevice,
    	                                   pNodeInfo,
    	                                   ulChannelIndx,
    	                                   &GeqRequest,
    	                                   sizeof(GEQ_REQUEST_DATA),
    	                                   (USHORT)FB_GET_CUR );

    if ( NT_SUCCESS(ntStatus) ) {
        ULONG i;

        for (i=0; i<2; i++) {
            bmBandsPresent = (i==0)? bswap(GeqRequest.ulBandsPresent) :
        	                     bswap(GeqRequest.ulExtraBandsPresent) ;
            ulBandCnt = 0;
            while (bmBandsPresent) {
                if (bmBandsPresent & 1) {
                    GeqRequest.cGain[ulBandCnt] = (UCHAR) (pEqLevels[ulBandCnt] / DB_SCALE_8BIT);
                    ulBandCnt++;
                }
                bmBandsPresent >>= 1;
            }
        }
        ntStatus = CreateFeatureFBlockRequest( pKsDevice,
    	                                       pNodeInfo,
          	                                   ulChannelIndx,
    	                                       &GeqRequest,
    	                                       sizeof(GEQ_REQUEST_DATA),
    	                                       (USHORT)FB_SET_CUR );

        if ( NT_SUCCESS(ntStatus) ) *pNumBands = ulBandCnt;

   	}
    
    return ntStatus;

}

NTSTATUS
InitializeGeqLevelCache(
    PKSDEVICE pKsDevice,
    PTOPOLOGY_NODE_INFO pNodeInfo,
    PGEQ_CTRL_CACHE pGeqCache )
{
    PGEQ_RANGE pGeqRange = NULL;
    PULONG pEqLevels, pBands;
    ULONG ulNumBands;
    ULONG ulNumExtraBands;
    ULONG i;
    NTSTATUS ntStatus = STATUS_SUCCESS;

    pEqLevels = AllocMem( PagedPool, 
                          2*sizeof(ULONG)*(MAX_EQ_BANDS+MAX_EXTRA_EQ_BANDS) );
    if ( !pEqLevels ) ntStatus = STATUS_INSUFFICIENT_RESOURCES;

    pBands = pEqLevels + (MAX_EQ_BANDS+MAX_EXTRA_EQ_BANDS);

    if ( NT_SUCCESS(ntStatus) ) {
        ntStatus = GetEqualizerValues( pKsDevice, 
        	                           pNodeInfo, 
    	                               pGeqCache->ulChannelIndex, 
    	                               FB_GET_CUR, 
    	                               pEqLevels, 
    	                               pBands, 
    	                               &ulNumBands,
    	                               &ulNumExtraBands );
        if ( NT_SUCCESS(ntStatus) ) {
        	pGeqRange = AllocMem( PagedPool, 
        		                  sizeof(GEQ_RANGE)*(ulNumBands+ulNumExtraBands) );
        	if ( pGeqRange ) {
        		pGeqCache->pRanges = pGeqRange;
        		for ( i=0; i<(ulNumBands+ulNumExtraBands); i++) {
        			pGeqRange[i].ulCurrentLevel = pEqLevels[i];
        			pGeqRange[i].ulBand         = pBands[i];
        		}
        		for ( i=FB_GET_RES; ((i<=FB_GET_MAX) && NT_SUCCESS(ntStatus)); i++) {
                    ntStatus = GetEqualizerValues( pKsDevice, 
        	                                       pNodeInfo, 
        	                                       pGeqCache->ulChannelIndex, 
        	                                       (USHORT)i, 
        	                                       pEqLevels, 
        	                                       NULL, 
        	                                       &ulNumBands,
        	                                       &ulNumExtraBands );
                    if ( NT_SUCCESS(ntStatus) ) {
                        ULONG j;
                        for ( j=0; j<(ulNumBands+ulNumExtraBands); j++ ) {
                        	switch( i ) {
                        		case FB_GET_RES:
                        			pGeqRange[i].Range.SteppingDelta = pEqLevels[i];
                        			break;
                        		case FB_GET_MIN:
                        			pGeqRange[i].Range.Bounds.SignedMinimum = pEqLevels[i];
                        			break;
                        		case FB_GET_MAX:
                        			pGeqRange[i].Range.Bounds.SignedMaximum = pEqLevels[i];
                        			break;
                        	}
                        }
                    }
                    else 
                    	FreeMem(pGeqRange);
        		}
        		if ( NT_SUCCESS(ntStatus) ) {
        			pNodeInfo->ulCacheValid |= 1<<(pGeqCache->ulChannelNumber);
        		}
        	}
        	else
        		ntStatus = STATUS_INSUFFICIENT_RESOURCES;
        	
    	}

        FreeMem( pEqLevels );

    }
    
    return ntStatus;
}

NTSTATUS 
GetSetEqualizerLevels( PIRP pIrp, PKSPROPERTY pKsProperty, PVOID pData )
{
    PKSNODEPROPERTY_AUDIO_CHANNEL pNAC = (PKSNODEPROPERTY_AUDIO_CHANNEL)pKsProperty;
    PKSFILTER pKsFilter;
    PTOPOLOGY_NODE_INFO pNodeInfo;
    NTSTATUS ntStatus = STATUS_INVALID_DEVICE_REQUEST;
    ULONG ulNumBands, ulNumExBands;
    PGEQ_CTRL_CACHE pGeqCache;
    ULONG i;

    pKsFilter = KsGetFilterFromIrp(pIrp);
    if (!pKsFilter) {
        return STATUS_INVALID_PARAMETER;
    }

    pNodeInfo = GET_NODE_INFO_FROM_FILTER(pKsFilter,pNAC->NodeProperty.NodeId);

    // Determine if this request is beyond # of channels available
    if (( (ULONG)pNAC->Channel >= pNodeInfo->ulChannels ) ||
    	 !(pNodeInfo->ulCacheValid & (1<<(pNAC->Channel)) ) ){
        return ntStatus;
    }

    // Find the Cache for the requested channel
    pGeqCache = (PGEQ_CTRL_CACHE)pNodeInfo->pCachedValues + pNAC->Channel;

    if ( pKsProperty->Flags & KSPROPERTY_TYPE_GET ) {
    	ulNumBands = pGeqCache->ulNumBands + pGeqCache->ulNumExtraBands;
        for (i=0; i<ulNumBands; i++) {
        	((PULONG)pData)[i] = pGeqCache->pRanges[i].ulCurrentLevel;
        }

        pIrp->IoStatus.Information = ulNumBands * sizeof(LONG);
        ntStatus = STATUS_SUCCESS;
    }
    else if ( pKsProperty->Flags & KSPROPERTY_TYPE_SET ) {
        ntStatus = SetEqualizerValues( pKsFilter->Context,
                                       pNodeInfo,
    	                               pGeqCache->ulChannelIndex,
                                       &ulNumBands,
                                       pData );
        if ( NT_SUCCESS(ntStatus) ) {
            pIrp->IoStatus.Information = ulNumBands * sizeof(LONG);
            for (i=0; i<ulNumBands; i++) {
            	pGeqCache->pRanges[i].ulCurrentLevel = ((PULONG)pData)[i];
            }
        }
    }

    return ntStatus;
}

NTSTATUS 
GetNumEqualizerBands( PIRP pIrp, PKSPROPERTY pKsProperty, PVOID pValue )
{
    PKSNODEPROPERTY_AUDIO_CHANNEL pNAC = (PKSNODEPROPERTY_AUDIO_CHANNEL)pKsProperty;
    PKSFILTER pKsFilter;
    PTOPOLOGY_NODE_INFO pNodeInfo;
    NTSTATUS ntStatus = STATUS_INVALID_DEVICE_REQUEST;
    ULONG ulNumBands, ulNumExBands;
    PGEQ_CTRL_CACHE pGeqCache;

    pKsFilter = KsGetFilterFromIrp(pIrp);
    if (!pKsFilter) return STATUS_INVALID_PARAMETER;

    pNodeInfo = GET_NODE_INFO_FROM_FILTER(pKsFilter,pNAC->NodeProperty.NodeId);

    // Determine if this request is beyond # of channels available
    if (( (ULONG)pNAC->Channel < pNodeInfo->ulChannels ) &&
    	 (pNodeInfo->ulCacheValid & (1<<(pNAC->Channel)) ) ){

        // Find the Cache for the requested channel
        pGeqCache = (PGEQ_CTRL_CACHE)pNodeInfo->pCachedValues + pNAC->Channel;

    	*(PULONG)pValue = pGeqCache->ulNumBands + pGeqCache->ulNumExtraBands;

        pIrp->IoStatus.Information = sizeof(ULONG);

        ntStatus = STATUS_SUCCESS;
    }

    return ntStatus;
}

NTSTATUS 
GetEqualizerBands( PIRP pIrp, PKSPROPERTY pKsProperty, PVOID pData )
{
    PKSNODEPROPERTY_AUDIO_CHANNEL pNAC = (PKSNODEPROPERTY_AUDIO_CHANNEL)pKsProperty;
    PKSFILTER pKsFilter;
    PTOPOLOGY_NODE_INFO pNodeInfo;
    NTSTATUS ntStatus = STATUS_INVALID_DEVICE_REQUEST;
    ULONG ulNumBands, ulNumExBands;
    PGEQ_CTRL_CACHE pGeqCache;
    ULONG i;

    pKsFilter = KsGetFilterFromIrp(pIrp);
    if (!pKsFilter) return STATUS_INVALID_PARAMETER;

    pNodeInfo = GET_NODE_INFO_FROM_FILTER(pKsFilter,pNAC->NodeProperty.NodeId);

    // Determine if this request is beyond # of channels available
    if (( (ULONG)pNAC->Channel < pNodeInfo->ulChannels ) &&
    	 (pNodeInfo->ulCacheValid & (1<<(pNAC->Channel)) ) ){

        // Find the Cache for the requested channel
        pGeqCache = (PGEQ_CTRL_CACHE)pNodeInfo->pCachedValues + pNAC->Channel;
        ulNumBands = pGeqCache->ulNumBands + pGeqCache->ulNumExtraBands;

        for (i=0; i<ulNumBands; i++) {
        	((PULONG)pData)[i] = pGeqCache->pRanges[i].ulBand;
        }

        pIrp->IoStatus.Information = sizeof(ULONG) * ulNumBands;

        ntStatus = STATUS_SUCCESS;
    }

    return ntStatus;
}

NTSTATUS 
GetSetAudioControlLevel( PIRP pIrp, PKSPROPERTY pKsProperty, PVOID pData )
{
    return STATUS_NOT_IMPLEMENTED;
}

NTSTATUS 
GetSetDeviceSpecific( PIRP pIrp, PKSPROPERTY pKsProperty, PVOID pData )
{
    PKSNODEPROPERTY_AUDIO_DEV_SPECIFIC pPropDevSpec = 
        (PKSNODEPROPERTY_AUDIO_DEV_SPECIFIC)pKsProperty;
    PKSFILTER pKsFilter = KsGetFilterFromIrp(pIrp);
    NTSTATUS ntStatus;

    ULONG ulCommandType = (pKsProperty->Flags & KSPROPERTY_TYPE_GET) ? AVC_CTYPE_STATUS  :
                                                                       AVC_CTYPE_CONTROL ; 

    // Simple passthrough to send vendor dependent commands through
    ntStatus = AvcVendorDependent( pKsFilter->Context,
                                   pPropDevSpec->DeviceInfo, 
                                   ulCommandType,
                                   pPropDevSpec->DevSpecificId,
                                   pPropDevSpec->Length,
                                   pData );
    return ntStatus;
}

NTSTATUS 
GetAudioLatency( PIRP pIrp, PKSPROPERTY pKsProperty, PVOID pData )
{
    return STATUS_NOT_IMPLEMENTED;
}

NTSTATUS 
GetChannelConfiguration( PIRP pIrp, PKSPROPERTY pKsProperty, PVOID pData )
{
    return STATUS_NOT_IMPLEMENTED;
}

NTSTATUS 
GetAudioPosition( PIRP pIrp, PKSPROPERTY pKsProperty, PVOID pData )
{
    PKSPIN pKsPin = KsGetPinFromIrp(pIrp);
    PKSAUDIO_POSITION pPosition = pData;
    PPIN_CONTEXT pPinContext;
    NTSTATUS ntStatus = STATUS_SUCCESS;

    if ( !pKsPin ) return STATUS_INVALID_PARAMETER;
    pPinContext = pKsPin->Context;

    ASSERT(pKsProperty->Flags & KSPROPERTY_TYPE_GET);

    if ( ((PHW_DEVICE_EXTENSION)pPinContext->pHwDevExt)->fSurpriseRemoved ) {
        return STATUS_DEVICE_DOES_NOT_EXIST;
    }

    pPosition->WriteOffset = pPinContext->KsAudioPosition.WriteOffset;

    if ( !pPinContext->fStreamStarted ) {
        pPosition->PlayOffset = pPinContext->KsAudioPosition.PlayOffset;
    }
    else {
        // Assume AM824 for now
        ntStatus = AM824AudioPosition( pKsPin, pPosition );
    }

    DbgLog("GetPos", pPinContext, &pPinContext->KsAudioPosition,
                     pPosition->WriteOffset, pPosition->PlayOffset);

    return ntStatus;
}


NTSTATUS
GetBasicSupportBoolean( PIRP pIrp, PKSPROPERTY pKsProperty, PVOID pData )
{
    PKSNODEPROPERTY pNodeProperty  = (PKSNODEPROPERTY)pKsProperty;
    PKSFILTER pKsFilter;
    PTOPOLOGY_NODE_INFO pNodeInfo;
    PIO_STACK_LOCATION pIrpStack   = IoGetCurrentIrpStackLocation( pIrp );
    PKSPROPERTY_DESCRIPTION pPropDesc = pData;
    NTSTATUS ntStatus = STATUS_INVALID_DEVICE_REQUEST; //Assume failure, hope for better
    ULONG ulOutputBufferLength = pIrpStack->Parameters.DeviceIoControl.OutputBufferLength;

#ifdef DEBUG
    if ( ulOutputBufferLength != sizeof(ULONG) ) {
        ULONG ulInputBufferLength;

        ulInputBufferLength = pIrpStack->Parameters.DeviceIoControl.InputBufferLength;
        ASSERT(ulInputBufferLength >= sizeof( KSNODEPROPERTY ));
    }
#endif

    pKsFilter = KsGetFilterFromIrp(pIrp);
    if (!pKsFilter) {
        return STATUS_INVALID_PARAMETER;
    }
    pNodeInfo = GET_NODE_INFO_FROM_FILTER(pKsFilter,pNodeProperty->NodeId);

    _DbgPrintF(DEBUGLVL_VERBOSE,("[GetBasicSupportBoolean] pNodeInfo %x NodeId %x\n",
                                 pNodeInfo,
                                 pNodeProperty->NodeId));

    if ( ulOutputBufferLength == sizeof(ULONG) ) {
        PULONG pAccessFlags = pData;
        *pAccessFlags = KSPROPERTY_TYPE_BASICSUPPORT |
                        KSPROPERTY_TYPE_GET |
                        KSPROPERTY_TYPE_SET;
        ntStatus = STATUS_SUCCESS;
    }
    else if ( ulOutputBufferLength >= sizeof( KSPROPERTY_DESCRIPTION )) {
        ULONG ulNumChannels = pNodeInfo->ulChannels;

        _DbgPrintF(DEBUGLVL_VERBOSE,("[GetBasicSupportBoolean] ulChannelConfig %x ulNumChannels %x\n",
                                     pNodeInfo->ulChannelConfig,
                                     ulNumChannels));

        pPropDesc->AccessFlags = KSPROPERTY_TYPE_BASICSUPPORT |
                                 KSPROPERTY_TYPE_GET |
                                 KSPROPERTY_TYPE_SET;
        pPropDesc->DescriptionSize   = sizeof(KSPROPERTY_DESCRIPTION) +
                                       sizeof(KSPROPERTY_MEMBERSHEADER);
        pPropDesc->PropTypeSet.Set   = KSPROPTYPESETID_General;
        pPropDesc->PropTypeSet.Id    = VT_BOOL;
        pPropDesc->PropTypeSet.Flags = 0;
        pPropDesc->MembersListCount  = 1;
        pPropDesc->Reserved          = 0;

        pIrp->IoStatus.Information = sizeof( KSPROPERTY_DESCRIPTION );
        ntStatus = STATUS_SUCCESS;

        if ( ulOutputBufferLength > sizeof(KSPROPERTY_DESCRIPTION)){

            PKSPROPERTY_MEMBERSHEADER pMembers = (PKSPROPERTY_MEMBERSHEADER)(pPropDesc + 1);

            pMembers->MembersFlags = 0;
            pMembers->MembersSize  = 0;
            pMembers->MembersCount = ulNumChannels;
            pMembers->Flags        = KSPROPERTY_MEMBER_FLAG_BASICSUPPORT_MULTICHANNEL;
            // If there is a Master channel, make this node UNIFORM
            if (pNodeInfo->fMasterChannel) {
                pMembers->Flags |= KSPROPERTY_MEMBER_FLAG_BASICSUPPORT_UNIFORM;
            }
            pIrp->IoStatus.Information = pPropDesc->DescriptionSize;
        }
    }

    return ntStatus;
}

NTSTATUS 
GetBasicSupport( PIRP pIrp, PKSPROPERTY pKsProperty, PVOID pData )
{
    PKSNODEPROPERTY pNodeProperty  = (PKSNODEPROPERTY)pKsProperty;
    PKSFILTER pKsFilter = KsGetFilterFromIrp(pIrp);
    PIO_STACK_LOCATION pIrpStack = IoGetCurrentIrpStackLocation( pIrp );
    ULONG ulOutputBufferLength = pIrpStack->Parameters.DeviceIoControl.OutputBufferLength;
    PKSPROPERTY_DESCRIPTION pPropDesc = pData;
    NTSTATUS ntStatus = STATUS_INVALID_DEVICE_REQUEST; //Assume failure, hope for better
    ULONG ulTotalSize;
    PTOPOLOGY_NODE_INFO pNodeInfo;
    ULONG ulNumChannels;
    ULONG ulNumBands = 1;

    if ( !pKsFilter ) return STATUS_INVALID_PARAMETER;
    pNodeInfo = GET_NODE_INFO_FROM_FILTER(pKsFilter,pNodeProperty->NodeId);
    ulNumChannels = pNodeInfo->ulChannels;

    if ( pNodeProperty->Property.Id == KSPROPERTY_AUDIO_EQ_LEVEL ) {
    	PGEQ_CTRL_CACHE pGeqCache = pNodeInfo->pCachedValues;
    	ulNumBands = pGeqCache->ulNumBands + pGeqCache->ulNumExtraBands;
    }
    
    ulTotalSize = sizeof(KSPROPERTY_DESCRIPTION)   +
                  sizeof(KSPROPERTY_MEMBERSHEADER) +
                  (sizeof(KSPROPERTY_STEPPING_LONG) * ulNumChannels * ulNumBands);

    _DbgPrintF(DEBUGLVL_VERBOSE,("[GetBasicSupport] pNodeInfo %x NodeId %x \n",pNodeInfo,pNodeProperty->NodeId));

    if ( !ulOutputBufferLength ) {
    	pIrp->IoStatus.Information = ulTotalSize;
        ntStatus = STATUS_SUCCESS;
    }
    else {
    	if ( ulOutputBufferLength >= sizeof(ULONG) ) {
            ntStatus = STATUS_SUCCESS;

            pIrp->IoStatus.Information = sizeof(ULONG);
            pPropDesc->AccessFlags = KSPROPERTY_TYPE_BASICSUPPORT |
                                     KSPROPERTY_TYPE_GET |
                                     KSPROPERTY_TYPE_SET;

            if ( ulOutputBufferLength >= sizeof( KSPROPERTY_DESCRIPTION ) ) {
               	pPropDesc->DescriptionSize   = ulTotalSize;
                pPropDesc->PropTypeSet.Set   = KSPROPTYPESETID_General;
                pPropDesc->PropTypeSet.Id    = VT_I4;
                pPropDesc->PropTypeSet.Flags = 0;
                pPropDesc->MembersListCount  = 0;
                pPropDesc->Reserved          = 0;

                pIrp->IoStatus.Information = sizeof( KSPROPERTY_DESCRIPTION );

                if ( ulOutputBufferLength >= ulTotalSize ) {
                    PKSPROPERTY_MEMBERSHEADER pMembers = (PKSPROPERTY_MEMBERSHEADER)(pPropDesc + 1);
                    PKSPROPERTY_STEPPING_LONG pRange   = (PKSPROPERTY_STEPPING_LONG)(pMembers + 1);

                    pIrp->IoStatus.Information = ulTotalSize;

                    pPropDesc->MembersListCount = 1;

                    pMembers->MembersFlags = KSPROPERTY_MEMBER_STEPPEDRANGES;
                    pMembers->MembersCount = ulNumChannels;
                    pMembers->Flags        = (ulNumChannels > 2) ? KSPROPERTY_MEMBER_FLAG_BASICSUPPORT_MULTICHANNEL : 0;

                    // If there is a Master channel, make this node UNIFORM
                    if ( pNodeInfo->fMasterChannel ) {
                        pMembers->Flags |= KSPROPERTY_MEMBER_FLAG_BASICSUPPORT_UNIFORM;
                    }

                    switch ( pNodeProperty->Property.Id ) {
                        case KSPROPERTY_AUDIO_VOLUMELEVEL:
                        case KSPROPERTY_AUDIO_BASS:
                        case KSPROPERTY_AUDIO_MID:
                        case KSPROPERTY_AUDIO_TREBLE:
                        	{
                             PDB_LEVEL_CACHE pDbCache = pNodeInfo->pCachedValues;
                             ULONG i;

                             pMembers->MembersSize = sizeof(KSPROPERTY_STEPPING_LONG);

                             for (i=0; i<ulNumChannels; i++) {
                                 if (pNodeInfo->ulCacheValid & (1<<i)) {
                                     RtlCopyMemory(&pRange[i],&pDbCache[i].Range, sizeof(KSPROPERTY_STEPPING_LONG));
                                 }
                                 else {
                         	         TRAP; // Shouldn't have a filter w/o valid cache values
                                 }
                             }
                        	}
                            break;
                            
                        case KSPROPERTY_AUDIO_EQ_LEVEL:
                        	{
                        	 PGEQ_CTRL_CACHE pGeqCache = pNodeInfo->pCachedValues;
                             ULONG i, j;

                             pMembers->MembersSize = ulNumBands * sizeof(KSPROPERTY_STEPPING_LONG);

                             for (i=0; i<ulNumChannels; i++) {
                                 if (pNodeInfo->ulCacheValid & (1<<i)) {
                                     for ( j=0; j<ulNumBands; j++) {
                                         RtlCopyMemory( &pRange[(i*ulNumBands)+j],
                                         	            &pGeqCache[i].pRanges[j].Range, 
                                         	            sizeof(KSPROPERTY_STEPPING_LONG) );
                                     }
                                 }
                                 else {
                         	         TRAP; // Shouldn't have a filter w/o valid cache values
                                 }
                             }
                        	}
                            break;

                        default:
                        	TRAP;
                        	break;
                    }
                }
            }
        }
    }

    return ntStatus;
}

NTSTATUS
GetSetTopologyNodeEnable( PIRP pIrp, PKSPROPERTY pKsProperty, PVOID pData )
{
    return STATUS_NOT_IMPLEMENTED;
}

VOID
BuildNodePropertySet(
    PTOPOLOGY_NODE_INFO pNodeInfo )
{
    ULONG ulNodeType = pNodeInfo->ulNodeType;
    PKSPROPERTY_SET pPropSet = (PKSPROPERTY_SET)&NodePropertySetTable[ulNodeType];

    if ( pPropSet->PropertiesCount ) {
        pNodeInfo->KsAutomationTable.PropertySetsCount = 1;
        pNodeInfo->KsAutomationTable.PropertyItemSize  = sizeof(KSPROPERTY_ITEM);
        pNodeInfo->KsAutomationTable.PropertySets      = pPropSet;
    }
}

VOID
BuildFilterPropertySet(
    PKSFILTER_DESCRIPTOR pFilterDesc,
    PKSPROPERTY_ITEM pDevPropItems,
    PKSPROPERTY_SET pDevPropSet,
    PULONG pNumItems,
    PULONG pNumSets )
{
    ULONG ulNumPinPropItems = 1;
    ULONG ulNumAudioPropItems = 1;
//    ULONG ulNumAudioPropItems = 0;
    PKSPROPERTY_ITEM pPinProps  = pDevPropItems;
    PKSPROPERTY_ITEM pAudioProp = pDevPropItems + ulNumPinPropItems;

    ASSERT(pNumSets);

    *pNumSets = ulNumPinPropItems + ulNumAudioPropItems; // There always is an Pin property set and a vendor dependent property

    if ( pDevPropItems ) {
        RtlCopyMemory(pDevPropItems++, &PinPropertyItems[KSPROPERTY_PIN_NAME], sizeof(KSPROPERTY_ITEM) );
        RtlCopyMemory(pDevPropItems++, &AudioPropertyItems[KSPROPERTY_AUDIO_DEV_SPECIFIC], sizeof(KSPROPERTY_ITEM) );

        if ( pDevPropSet ) {
            pDevPropSet->Set             = &KSPROPSETID_Pin;
            pDevPropSet->PropertiesCount = ulNumPinPropItems;
            pDevPropSet->PropertyItem    = pPinProps;
            pDevPropSet->FastIoCount     = 0;
            pDevPropSet->FastIoTable     = NULL;


            pDevPropSet++;

            pDevPropSet->Set             = &KSPROPSETID_Audio;
            pDevPropSet->PropertiesCount = ulNumAudioPropItems;
            pDevPropSet->PropertyItem    = pAudioProp;
            pDevPropSet->FastIoCount     = 0;
            pDevPropSet->FastIoTable     = NULL;

        }
    }

    if (pNumItems) {
        *pNumItems = ulNumPinPropItems;
    }

}

VOID
BuildPinPropertySet( PHW_DEVICE_EXTENSION pHwDevExt,
                     PKSPROPERTY_ITEM pStrmPropItems,
                     PKSPROPERTY_SET pStrmPropSet,
                     PULONG pNumItems,
                     PULONG pNumSets )
{
    ULONG ulNumAudioProps  = 3;
    ULONG NumDrmAudioStreamProps = 1;

//    ULONG ulNumStreamProps = 1;
//    ULONG ulNumConnectionProps = 1;

    // For now we hardcode this to a known set.
//    *pNumSets = 3;
    *pNumSets = 2;

//    if (pNumItems) *pNumItems = ulNumAudioProps + ulNumStreamProps + ulNumConnectionProps;
    if (pNumItems) *pNumItems = ulNumAudioProps +
                                NumDrmAudioStreamProps ;

    if (pStrmPropItems) {
        PKSPROPERTY_ITEM pAudItms = pStrmPropItems;
        PKSPROPERTY_ITEM pDRMItms = pStrmPropItems + ulNumAudioProps;
//        PKSPROPERTY_ITEM pStrmItms = pStrmPropItems + ulNumAudioProps;
//        PKSPROPERTY_ITEM pConnItms = pStrmPropItems + (ulNumAudioProps+ulNumStreamProps);

        RtlCopyMemory(pStrmPropItems++, &AudioPropertyItems[KSPROPERTY_AUDIO_LATENCY], sizeof(KSPROPERTY_ITEM) );
        RtlCopyMemory(pStrmPropItems++, &AudioPropertyItems[KSPROPERTY_AUDIO_POSITION], sizeof(KSPROPERTY_ITEM) );
        RtlCopyMemory(pStrmPropItems++, &AudioPropertyItems[KSPROPERTY_AUDIO_SAMPLING_RATE], sizeof(KSPROPERTY_ITEM) );
//        RtlCopyMemory(pStrmPropItems++, &AudioPropertyItems[KSPROPERTY_AUDIO_SAMPLING_RATE], sizeof(KSPROPERTY_ITEM) );
//        RtlCopyMemory(pStrmPropItems++, &StreamItm[0], sizeof(KSPROPERTY_ITEM) );
//        RtlCopyMemory(pStrmPropItems,   &ConnectionItm[0], sizeof(KSPROPERTY_ITEM) );

        RtlCopyMemory(pStrmPropItems++, &DrmAudioStreamPropertyItems[KSPROPERTY_DRMAUDIOSTREAM_CONTENTID], sizeof(KSPROPERTY_ITEM) );


        if (pStrmPropSet) {

            // Audio Property Set
            pStrmPropSet->Set             = &KSPROPSETID_Audio;
            pStrmPropSet->PropertiesCount = ulNumAudioProps;
            pStrmPropSet->PropertyItem    = pAudItms;
            pStrmPropSet->FastIoCount     = 0;
            pStrmPropSet->FastIoTable     = NULL;
            pStrmPropSet++;

            // DRM Property Set
            pStrmPropSet->Set             = &KSPROPSETID_DrmAudioStream;
            pStrmPropSet->PropertiesCount = NumDrmAudioStreamProps;
            pStrmPropSet->PropertyItem    = pDRMItms;
            pStrmPropSet->FastIoCount     = 0;
            pStrmPropSet->FastIoTable     = NULL;
            pStrmPropSet++;
/*
            // Stream Property Set
            pStrmPropSet->Set             = &KSPROPSETID_Stream;
            pStrmPropSet->PropertiesCount = ulNumStreamProps;
            pStrmPropSet->PropertyItem    = pStrmItms;
            pStrmPropSet->FastIoCount     = 0;
            pStrmPropSet->FastIoTable     = NULL;
            pStrmPropSet++;

            // Connection Properties
            pStrmPropSet->Set             = &KSPROPSETID_Connection;
            pStrmPropSet->PropertiesCount = ulNumConnectionProps;
            pStrmPropSet->PropertyItem    = pConnItms;
            pStrmPropSet->FastIoCount     = 0;
            pStrmPropSet->FastIoTable     = NULL;
*/
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\drivers\avcaudio\parsedsc.c ===
#include "Common.h"

UCHAR ucFDFs[MAX_SFC_COUNT] = { SFC_32000Hz,
                                SFC_44100Hz,
                                SFC_48000Hz,
                                SFC_96000Hz };


PAUDIO_SUBUNIT_DEPENDENT_INFO 
ParseFindAudioSubunitDependentInfo(
    PSUBUNIT_IDENTIFIER_DESCRIPTOR pSubunitIdDesc )
{
    PUCHAR pTmpOffset = (PUCHAR)pSubunitIdDesc;
    ULONG ulASUOffset, ulNumRootLists;

    ulNumRootLists = (ULONG)((pSubunitIdDesc->ucNumberOfRootObjectListsHi<<8) |
                              pSubunitIdDesc->ucNumberOfRootObjectListsLo     );

    _DbgPrintF( DEBUGLVL_VERBOSE, (" ulNumRootLists %d\n",ulNumRootLists));
    ulASUOffset = 8 + (ulNumRootLists * (ULONG)pSubunitIdDesc->ucSizeOfListID);

    return (PAUDIO_SUBUNIT_DEPENDENT_INFO)&pTmpOffset[ulASUOffset];

}

PCONFIGURATION_DEPENDENT_INFO
ParseFindFirstAudioConfiguration(
    PSUBUNIT_IDENTIFIER_DESCRIPTOR pSubunitIdDesc )
{
    PAUDIO_SUBUNIT_DEPENDENT_INFO pAudioSUDepInfo;

    pAudioSUDepInfo = ParseFindAudioSubunitDependentInfo( pSubunitIdDesc );

    return (PCONFIGURATION_DEPENDENT_INFO)(pAudioSUDepInfo + 1);
}

PSOURCE_PLUG_LINK_INFO
ParseFindSourcePlugLinkInfo(
    PCONFIGURATION_DEPENDENT_INFO pConfigDepInfo )
{
    return (PSOURCE_PLUG_LINK_INFO)
            ((PUCHAR)pConfigDepInfo + (3*sizeof(USHORT)) +
             (ULONG)bswapw(pConfigDepInfo->usMasterClusterStructureLength) );
}

PFUNCTION_BLOCKS_INFO
ParseFindFunctionBlocksInfo(
    PCONFIGURATION_DEPENDENT_INFO pConfigDepInfo )
{
    PSOURCE_PLUG_LINK_INFO pSourcePlugInfo = ParseFindSourcePlugLinkInfo(pConfigDepInfo);

    return (PFUNCTION_BLOCKS_INFO)(pSourcePlugInfo->pSourceID + (ULONG)pSourcePlugInfo->ucNumLinks);
}

VOID
ParseFunctionBlock( 
    PFUNCTION_BLOCK_DEPENDENT_INFO pFBDepInfo,
    PFUNCTION_BLOCK pFunctionBlock )
{
    PUCHAR pcFBDepInfo = (PUCHAR)pFBDepInfo;
    ULONG ulFBIndx = sizeof(FUNCTION_BLOCK_DEPENDENT_INFO);

    pFunctionBlock->pBase  = pFBDepInfo;
    pFunctionBlock->ulType = (ULONG)pFBDepInfo->ucType;
    pFunctionBlock->ulBlockId = (ULONG)(*(PUSHORT)&pFBDepInfo->ucType);
    pFunctionBlock->ulNumInputPlugs = (ULONG)pFBDepInfo->ucNumberOfInputPlugs;

    pFunctionBlock->pSourceId = (PSOURCE_ID)&pcFBDepInfo[ulFBIndx];

    ulFBIndx += (pFunctionBlock->ulNumInputPlugs * sizeof(SOURCE_ID));

    pFunctionBlock->pChannelCluster = (PFBLOCK_CHANNEL_CLUSTER)&pcFBDepInfo[ulFBIndx];

    ulFBIndx += ((ULONG)bswapw(pFunctionBlock->pChannelCluster->usLength) + sizeof(USHORT));

    pFunctionBlock->ulFunctionTypeInfoLength = (ULONG)bswapw(*(PUSHORT)(&pcFBDepInfo[ulFBIndx]));

    ulFBIndx += sizeof(USHORT);

	pFunctionBlock->pFunctionTypeInfo = &pcFBDepInfo[ulFBIndx];
			
    _DbgPrintF( DEBUGLVL_VERBOSE, (" pFunctionBlock: %x pFBDepInfo: %x\n",
                                     pFunctionBlock, pFBDepInfo ));

}

NTSTATUS
ParseAudioSubunitDescriptor( 
    PKSDEVICE pKsDevice )
{
    PHW_DEVICE_EXTENSION pHwDevExt = (PHW_DEVICE_EXTENSION)pKsDevice->Context;
    PAUDIO_SUBUNIT_INFORMATION pAudioSubunitInfo = pHwDevExt->pAvcSubunitInformation;

    PSUBUNIT_IDENTIFIER_DESCRIPTOR pSubunitIdDesc = pAudioSubunitInfo->pSubunitIdDesc;
    PAUDIO_SUBUNIT_DEPENDENT_INFO pAudioSUDepInfo;
    PCONFIGURATION_DEPENDENT_INFO pConfigDepInfo;
    PSOURCE_PLUG_LINK_INFO pSourcePlugInfo;
    PFUNCTION_BLOCK_DEPENDENT_INFO pFBDepInfo;
    PFBLOCK_CHANNEL_CLUSTER pFBChannelCluster;
    ULONG ulNumConfigs;
    PAUDIO_CONFIGURATION pAudioConfig;
    PFUNCTION_BLOCK pFunctionBlocks;
    PFUNCTION_BLOCKS_INFO pFunctionBlocksInfo;
    ULONG i;

#ifdef SA_HACK
    PAVC_UNIT_INFORMATION pUnitInfo = pHwDevExt->pAvcUnitInformation;
    if (( pUnitInfo->IEC61883UnitIds.VendorID == SA_VENDOR_ID ) &&
        ( pUnitInfo->IEC61883UnitIds.ModelID  == SA_MODEL_ID  )) {

        PUCHAR pTmpOffset = (PUCHAR)pSubunitIdDesc;
        *((PUSHORT)&pTmpOffset[22]) = usBitSwapper(*((PUSHORT)&pTmpOffset[22]));
//        *((PUSHORT)&pTmpOffset[48]) = usBitSwapper(*((PUSHORT)&pTmpOffset[48]));
//        *((PUSHORT)&pTmpOffset[50]) = usBitSwapper(*((PUSHORT)&pTmpOffset[50]));
    }

#endif

    _DbgPrintF( DEBUGLVL_TERSE, ("[ParseAudioSubunitDescriptor] %x\n", pSubunitIdDesc));

    pAudioSUDepInfo = ParseFindAudioSubunitDependentInfo( pSubunitIdDesc );
    ulNumConfigs = (ULONG)pAudioSUDepInfo->ucNumberOfConfigurations;

    pAudioConfig = 
        pAudioSubunitInfo->pAudioConfigurations = 
                  (PAUDIO_CONFIGURATION)AllocMem( NonPagedPool, 
                                                  ulNumConfigs * sizeof(AUDIO_CONFIGURATION) );
    if ( !pAudioConfig ) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    KsAddItemToObjectBag(pKsDevice->Bag, pAudioConfig, FreeMem);

    pConfigDepInfo = (PCONFIGURATION_DEPENDENT_INFO)(pAudioSUDepInfo + 1);

    _DbgPrintF( DEBUGLVL_VERBOSE, (" ucNumberOfConfigurations %d\n",pAudioSUDepInfo->ucNumberOfConfigurations));

    for (i=0; i<ulNumConfigs; i++ ) {
        ULONG j;

        pAudioConfig[i].pBase = pConfigDepInfo;

        // Get the Master Channel Cluster information
        pAudioConfig[i].ChannelCluster.ulNumberOfChannels = 
            (ULONG)pConfigDepInfo->ucNumberOfChannels;
        pAudioConfig[i].ChannelCluster.ulPredefinedChannelConfig = 
            (ULONG)usBitSwapper(bswapw(pConfigDepInfo->usPredefinedChannelConfig));

        _DbgPrintF( DEBUGLVL_VERBOSE, (" ulNumberOfChannels: %d\n",pAudioConfig[i].ChannelCluster.ulNumberOfChannels));
        _DbgPrintF( DEBUGLVL_VERBOSE, (" ulPredefinedChannelConfig: %x\n",pAudioConfig[i].ChannelCluster.ulPredefinedChannelConfig));

        // ISSUE-2001/01/10-dsisolak Need to figure out what to do with Undefined channels!

        pSourcePlugInfo = ParseFindSourcePlugLinkInfo( pConfigDepInfo );
        pAudioConfig[i].ulNumberOfSourcePlugs = (ULONG)pSourcePlugInfo->ucNumLinks;
        pAudioConfig[i].pSourceId = pSourcePlugInfo->pSourceID;

        pFunctionBlocksInfo = ParseFindFunctionBlocksInfo( pConfigDepInfo );
        pAudioConfig[i].ulNumberOfFunctionBlocks = (ULONG)pFunctionBlocksInfo->ucNumBlocks;

        pFunctionBlocks = 
            pAudioConfig[i].pFunctionBlocks = (PFUNCTION_BLOCK)
                     AllocMem( NonPagedPool, (ULONG)pFunctionBlocksInfo->ucNumBlocks * sizeof(FUNCTION_BLOCK));
        if ( !pFunctionBlocks )  return STATUS_INSUFFICIENT_RESOURCES;

        KsAddItemToObjectBag(pKsDevice->Bag, pFunctionBlocks, FreeMem);

        pFBDepInfo = pFunctionBlocksInfo->FBDepInfo;
        for (j=0; j<pAudioConfig[i].ulNumberOfFunctionBlocks; j++) {
            PUCHAR pcFBDepInfo = (PUCHAR)pFBDepInfo;

            ParseFunctionBlock( pFBDepInfo, &pFunctionBlocks[j] );

            pFBDepInfo = (PFUNCTION_BLOCK_DEPENDENT_INFO)
                (pcFBDepInfo + ((ULONG)bswapw(pFBDepInfo->usLength)) + 2);
        }

        pConfigDepInfo = (PCONFIGURATION_DEPENDENT_INFO)
            ((PUCHAR)pConfigDepInfo + (ULONG)bswap(pConfigDepInfo->usLength));
    }

    return STATUS_SUCCESS;
}

VOID
CountTopologyComponents(
    PHW_DEVICE_EXTENSION pHwDevExt,
    PULONG pNumCategories,
    PULONG pNumNodes,
    PULONG pNumConnections,
    PULONG pbmCategories )
{
    PAUDIO_SUBUNIT_INFORMATION pAudioSubunitInfo = pHwDevExt->pAvcSubunitInformation;

    // ISSUE-2001/01/10-dsisolak: Assuming only one configuration
    PAUDIO_CONFIGURATION pAudioConfiguration = pAudioSubunitInfo->pAudioConfigurations;
    PFUNCTION_BLOCK pFunctionBlocks = pAudioConfiguration->pFunctionBlocks;
    ULONG i;
    union {
        PVOID pFBInfo;
        PFEATURE_FUNCTION_BLOCK pFeature;
        PCODEC_FUNCTION_BLOCK pCodec;
        PPROCESS_FUNCTION_BLOCK pProcess;
    } u;

    // Initialize Values
    *pNumCategories  = 1; // Need to add space for KSCATEGORY_AUDIO
    *pNumNodes       = 0;
    *pNumConnections = 0;
    *pbmCategories   = 0;

    // Go through device plugs and create nodes/connections for them
    for (i=0; i<pAudioSubunitInfo->ulDevicePinCount; i++) {
        KSPIN_DATAFLOW KsDataFlow = pAudioSubunitInfo->pPinDescriptors[i].AvcPinDescriptor.PinDescriptor.DataFlow;
        (*pNumNodes)++;
        (*pNumConnections)++;
        if ( pAudioSubunitInfo->pPinDescriptors[i].fStreamingPin ) {
            (*pNumConnections)++;
            if ( KSPIN_DATAFLOW_OUT == KsDataFlow ) {
                if ( !(*pbmCategories & KSPIN_DATAFLOW_IN ) ) {
                    (*pbmCategories) |= KSPIN_DATAFLOW_IN;
                    (*pNumCategories)++;
                }
            }
        }
        else {
            if ( !(*pbmCategories & KsDataFlow) ) {
                (*pbmCategories) |= KsDataFlow;
                (*pNumCategories)++;
            }
        }
    }
    
    // Go through the function blocks and count nodes and connections
    for (i=0; i<pAudioConfiguration->ulNumberOfFunctionBlocks; i++) {
        u.pFBInfo = pFunctionBlocks[i].pFunctionTypeInfo;
//        _DbgPrintF(DEBUGLVL_VERBOSE, ("u.pFBInfo: %x\n",u.pFBInfo));

        switch( pFunctionBlocks[i].ulType ) {

            case FB_SELECTOR:
                (*pNumNodes)++;
                (*pNumConnections) += pFunctionBlocks[i].ulNumInputPlugs;
                break;

            case FB_FEATURE:
                {

                 ULONG bmMergedControls = 0;
                 ULONG bmControls;
                 ULONG j, k;
                 ULONG ulNumChannels = pFunctionBlocks[i].pChannelCluster->ucNumberOfChannels;

                 _DbgPrintF(DEBUGLVL_TERSE, ("[CountTopologyComponents]Feature Fblk # Channels: %x\n",ulNumChannels));

                 ASSERT(u.pFeature->ucControlSize <= sizeof(ULONG) );

#ifdef MASTER_FIX

                 // First Check if there are Master channel controls
                 bmControls = 0;
                 for (j=0; j<u.pFeature->ucControlSize; j++) {
                     bmControls <<= 8;
                     bmControls |= u.pFeature->bmaControls[j];
                 }

                 _DbgPrintF(DEBUGLVL_TERSE, ("[CountTopologyComponents]Master Controls: %x\n",bmControls));

#ifdef SUM_HACK
                 // Add a sum node to put before the Master Control. Thus the fader will not 
                 // show up in sndvol unless there is another Feature unit later.
                 if ( bmControls ) {
                     (*pNumConnections)++;
                     (*pNumNodes)++;
                 }
#endif

                 while (bmControls) {
                     bmControls = (bmControls & (bmControls-1));
                     (*pNumConnections)++;
                     (*pNumNodes)++;
                 }


                 // Create a new node and connection for each feature.
                 for (k=0; k<ulNumChannels; k++) {
                     bmControls = 0;
                     for (j=0; j<u.pFeature->ucControlSize; j++) {
                         bmControls <<= 8;
                         bmControls |= u.pFeature->bmaControls[(k+1)*u.pFeature->ucControlSize+j];
                     }
                     bmMergedControls |= bmControls;
                 }

                 _DbgPrintF(DEBUGLVL_TERSE, ("[CountTopologyComponents]Channel Controls: %x\n",bmControls));

                 // Count the nodes and connections
                 while (bmMergedControls) {
                     bmMergedControls = (bmMergedControls & (bmMergedControls-1));
                     (*pNumConnections)++;
                     (*pNumNodes)++;
                 }

#else
                 // Create a new node and connection for each feature.
                 for (k=0; k<=ulNumChannels; k++) {
                     bmControls = 0;
                     for (j=0; j<u.pFeature->ucControlSize; j++) {
                         bmControls <<= 8;
                         bmControls |= u.pFeature->bmaControls[k*u.pFeature->ucControlSize+j];
                     }
                     bmMergedControls |= bmControls;
                 }

                 // Count the nodes and connections
                 while (bmMergedControls) {
                     bmMergedControls = (bmMergedControls & (bmMergedControls-1));
                     (*pNumConnections)++;
                     (*pNumNodes)++;
                 }

                 if ( 
#endif

                }
                break;

            case FB_PROCESSING:
                (*pNumNodes)++;
                (*pNumConnections) += pFunctionBlocks[i].ulNumInputPlugs;
                break;

            case FB_CODEC:
                (*pNumNodes)++;
                (*pNumConnections) += pFunctionBlocks[i].ulNumInputPlugs;
                break;

            default:
                TRAP;
                break;
        }
    }
}

ULONG
CountDeviceBridgePins( 
    PKSDEVICE pKsDevice )
{
    PHW_DEVICE_EXTENSION pHwDevExt = (PHW_DEVICE_EXTENSION)pKsDevice->Context;
    PAUDIO_SUBUNIT_INFORMATION pAudioSubunitInfo = pHwDevExt->pAvcSubunitInformation;
    PFW_PIN_DESCRIPTOR pFwPinDescriptor = pAudioSubunitInfo->pPinDescriptors;
    ULONG ulBridgePinCount = 0;
    ULONG i;

    for (i=0; i<pAudioSubunitInfo->ulDevicePinCount; pFwPinDescriptor++, i++) {
        if ( !pFwPinDescriptor->fStreamingPin ) {
            ulBridgePinCount++;
        }
/*
        else if ( pAvcPreconnectInfo->Flags & KSPIN_FLAG_AVC_PERMANENT ) { 
            if ( !( pAvcPreconnectInfo->Flags & (KSPIN_FLAG_AVC_FIXEDPCR | KSPIN_FLAG_AVC_PCRONLY) ) ) {
                ulBridgePinCount++;
            }
        }
        else {
            TRAP; // ISSUE-2001/01/10-dsisolak Need to heuristically determine what connections are
                  // possible for this Subunit Plug.
        }
*/
    }

    return ulBridgePinCount;
}

ULONG
CountFormatsForPin( 
    PKSDEVICE pKsDevice, 
    ULONG ulPinNumber )
{
    PHW_DEVICE_EXTENSION pHwDevExt = pKsDevice->Context;
    PFW_PIN_DESCRIPTOR pPinDesc = 
        &(((PAUDIO_SUBUNIT_INFORMATION)pHwDevExt->pAvcSubunitInformation)->pPinDescriptors[ulPinNumber]);
    ULONG ulFormatCnt = 0;
    ULONG ulTransportCnt = 0;
    ULONG i;

    if ( pPinDesc->fFakePin ) ulFormatCnt = ulTransportCnt = 1; // Only one format for fake pins: Analog
    else if ( !pPinDesc->fStreamingPin ) ulFormatCnt = ulTransportCnt = 1; // Only one format for bridge pins: Analog
    else {
        for (i=0; i<MAX_SFC_COUNT; i++) {
            if ( pPinDesc->bmFormats & (1<<ucFDFs[i]) ) {
                ulFormatCnt++;
            }
            if ( pPinDesc->bmTransports & (1<<i) ) {
                ulTransportCnt++;
            }
        }
    }

    _DbgPrintF( DEBUGLVL_VERBOSE, ("Pin # %d: ulFormatCnt: %d, ulTransportCnt: %d\n",
                                    ulPinNumber, ulFormatCnt, ulTransportCnt ));

    ASSERT((ulFormatCnt * ulTransportCnt) >= 1);
    ASSERT(ulTransportCnt == 1);  // ISSUE-2001/01/10-dsisolak: What to do about multiple transports for a data type?

    return (ulFormatCnt * ulTransportCnt);
}

VOID
ConvertDescriptorToDatarange(
    ULONG ulFormatType,
    ULONG ulChannelCount,
    ULONG ulTransportType,
    ULONG ulSampleRate,
    PFWAUDIO_DATARANGE pAudioDataRange )
{
	PKSDATARANGE_AUDIO pKsAudioRange = &pAudioDataRange->KsDataRangeAudio;

	// Create the KSDATARANGE_AUDIO structure
    pKsAudioRange->DataRange.FormatSize = sizeof(KSDATARANGE_AUDIO);
    pKsAudioRange->DataRange.Reserved   = 0;
    pKsAudioRange->DataRange.Flags      = 0;
    pKsAudioRange->DataRange.SampleSize = 0;
    pKsAudioRange->DataRange.MajorFormat = KSDATAFORMAT_TYPE_AUDIO; // Everything is Audio.
    pKsAudioRange->DataRange.Specifier   = KSDATAFORMAT_SPECIFIER_WAVEFORMATEX;

    // Map the USB format to a KS sub-format, if possible.
    switch ( ulFormatType ) {
        case AUDIO_DATA_TYPE_PCM:
        case AUDIO_DATA_TYPE_PCM8:
            pKsAudioRange->DataRange.SubFormat = KSDATAFORMAT_SUBTYPE_PCM;         break;
        case AUDIO_DATA_TYPE_IEEE_FLOAT:
            pKsAudioRange->DataRange.SubFormat = KSDATAFORMAT_SUBTYPE_IEEE_FLOAT;  break;
        case AUDIO_DATA_TYPE_AC3:
            pKsAudioRange->DataRange.SubFormat = KSDATAFORMAT_SUBTYPE_AC3_AUDIO;   break;
        case AUDIO_DATA_TYPE_MPEG:
            pKsAudioRange->DataRange.SubFormat = KSDATAFORMAT_SUBTYPE_MPEG;        break;
        default:
            // This USB format does not map to a sub-format!
            pKsAudioRange->DataRange.SubFormat = GUID_NULL;                        break;
    }

    // Fill-in the correct data for the specified WAVE format.
    switch( ulFormatType & DATA_FORMAT_TYPE_MASK ) {

        case AUDIO_DATA_TYPE_TIME_BASED:
            // Fill in the audio range information
            pKsAudioRange->MaximumChannels   = ulChannelCount;
			pAudioDataRange->ulTransportType = ulTransportType;

            switch(ulTransportType) {
			    case MLAN_AM824_IEC958:
                case MLAN_AM824_RAW:
					 pKsAudioRange->MinimumBitsPerSample =
						 pKsAudioRange->MaximumBitsPerSample = 32;
                     pAudioDataRange->ulValidDataBits = 24;

					 break;

                case MLAN_24BIT_PACKED:
					 pKsAudioRange->MinimumBitsPerSample =
						 pKsAudioRange->MaximumBitsPerSample = 24;
                     pAudioDataRange->ulValidDataBits = 24; // 24bits in 24bits packed
					 break;

			    default:
					 TRAP;
					 break;
            }

			pKsAudioRange->MinimumSampleFrequency = ulSampleRate;
            pKsAudioRange->MaximumSampleFrequency = ulSampleRate;

            break;

        default:
            // This format does not map to a WAVE format!

            TRAP;
            break;
    }

}

void
GetPinDataRanges( 
    PKSDEVICE pKsDevice, 
    ULONG ulPinNumber, 
    PKSDATARANGE_AUDIO *ppAudioDataRanges,
    PFWAUDIO_DATARANGE pAudioDataRange )
{
    PHW_DEVICE_EXTENSION pHwDevExt = (PHW_DEVICE_EXTENSION)pKsDevice->Context;
    PAUDIO_SUBUNIT_INFORMATION pAudioSubunitInfo = pHwDevExt->pAvcSubunitInformation;
    PFW_PIN_DESCRIPTOR pPinDescriptor = &pAudioSubunitInfo->pPinDescriptors[ulPinNumber];
    PAUDIO_CONFIGURATION pAudioConfig = pAudioSubunitInfo->pAudioConfigurations;
    ULONG ulFormatCount = CountFormatsForPin( pKsDevice, ulPinNumber );

    ULONG ulChannelConfig = pAudioConfig->ChannelCluster.ulPredefinedChannelConfig;
    ULONG ulChannelCnt    = pAudioConfig->ChannelCluster.ulNumberOfChannels;

    ULONG ulSRBit;
    ULONG ulSFCMask;
    ULONG i;

    _DbgPrintF( DEBUGLVL_VERBOSE, ("[GetPinDataRanges]: Transport:%x, SR:%x\n",
                                   pPinDescriptor->bmTransports,
                                   pPinDescriptor->bmFormats ));

    ASSERT( pPinDescriptor->bmTransports == (1<<EVT_AM824) );

    // For each Sample Rate create a separate datarange?

    for (i=0,ulSRBit=0;i<ulFormatCount;i++) {
        
        while ( !(pPinDescriptor->bmFormats & (1<<ucFDFs[ulSRBit])) ) ulSRBit++;
        
        // Find the channel config for this pin;
        ulSFCMask = ucFDFs[ulSRBit];
        ConvertDescriptorToDatarange( AUDIO_DATA_TYPE_PCM,
                                      ulChannelCnt,
                                      EVT_AM824,
                                      (ulSFCMask & SFC_32000Hz ) ? 32000 :
                                      (ulSFCMask & SFC_44100Hz ) ? 44100 :
                                      (ulSFCMask & SFC_48000Hz ) ? 48000 :
                                                                   96000 ,
                                      &pAudioDataRange[i] );

        ppAudioDataRanges[i] = &pAudioDataRange[i].KsDataRangeAudio;

		// Fill in Misc. Datarange info
		pAudioDataRange[i].ulDataType      = AUDIO_DATA_TYPE_PCM; // Assuming PCM for now.
		pAudioDataRange[i].ulNumChannels   = ulChannelCnt;
		pAudioDataRange[i].ulChannelConfig = ulChannelConfig; 
		pAudioDataRange[i].ulSlotSize      = pAudioDataRange[i].KsDataRangeAudio.MinimumBitsPerSample>>3;
        pAudioDataRange[i].pFwPinDescriptor = pPinDescriptor;

        _DbgPrintF( DEBUGLVL_VERBOSE, ("[GetPinDataRanges]: pAudioDataRange[%d]: %x\n",i, &pAudioDataRange[i]));
    }
}

BOOLEAN
IsSampleRateInRange(
    PFWAUDIO_DATARANGE pFWAudioRange,
    ULONG ulSampleRate )
{

    ULONG ulMinSampleRate, ulMaxSampleRate;
    BOOLEAN bInRange = FALSE;

    if ( (pFWAudioRange->ulDataType & DATA_FORMAT_TYPE_MASK ) == AUDIO_DATA_TYPE_TIME_BASED) {
        // Currently very simplistic. Need to update when devices get more sophisticated
        if ( ulSampleRate == pFWAudioRange->KsDataRangeAudio.MinimumSampleFrequency )
            bInRange = TRUE;
    }

	return bInRange;
}

VOID
GetCategoryForBridgePin(
    PKSDEVICE pKsDevice, 
    ULONG ulBridgePinNumber,
    GUID* pTTypeGUID )
{
    PHW_DEVICE_EXTENSION pHwDevExt = (PHW_DEVICE_EXTENSION)pKsDevice->Context;
    PAUDIO_SUBUNIT_INFORMATION pAudioSubunitInfo = pHwDevExt->pAvcSubunitInformation;
    PFW_PIN_DESCRIPTOR pPinDescriptor = &pAudioSubunitInfo->pPinDescriptors[ulBridgePinNumber];
    PAVCPRECONNECTINFO pAvcPreconnectInfo = &pPinDescriptor->AvcPreconnectInfo.ConnectInfo;

    if ( pPinDescriptor->fFakePin ) {
        INIT_USB_TERMINAL(pTTypeGUID, 0x0301); // KSNODETYPE_SPEAKER
    }
    else if ( KSPIN_DATAFLOW_OUT == pAvcPreconnectInfo->DataFlow ){
        INIT_USB_TERMINAL(pTTypeGUID, 0x0301); // KSNODETYPE_SPEAKER
    }
    else {
        INIT_USB_TERMINAL(pTTypeGUID, 0x0201); // KSNODETYPE_MICROPHONE
    }
}


PFWAUDIO_DATARANGE
GetDataRangeForFormat(
    PKSDATAFORMAT pFormat,
    PFWAUDIO_DATARANGE pFwDataRange,
    ULONG ulDataRangeCnt )
{
    PFWAUDIO_DATARANGE pOutFwDataRange = NULL;

    union {
        PWAVEFORMATEX pDataFmtWave;
        PWAVEFORMATPCMEX pDataFmtPcmEx;
    } u;

    PKSDATARANGE pStreamRange;
    ULONG ulFormatType;
    ULONG fFound = FALSE;
    ULONG i;

    u.pDataFmtWave = &((PKSDATAFORMAT_WAVEFORMATEX)pFormat)->WaveFormatEx;

    for ( i=0; ((i<ulDataRangeCnt) && !fFound); ) {
        // Verify the Format GUIDS first
        pStreamRange = (PKSDATARANGE)&pFwDataRange[i].KsDataRangeAudio;
        if ( IsEqualGUID(&pFormat->MajorFormat, &pStreamRange->MajorFormat) &&
             IsEqualGUID(&pFormat->SubFormat,   &pStreamRange->SubFormat)   &&
             IsEqualGUID(&pFormat->Specifier,   &pStreamRange->Specifier) ) {

            // Based on the Data Type check remainder of format paramters
            ulFormatType = pFwDataRange[i].ulDataType & DATA_FORMAT_TYPE_MASK;
            switch( ulFormatType ) {
                case AUDIO_DATA_TYPE_TIME_BASED:
                    if ( u.pDataFmtWave->wFormatTag == WAVE_FORMAT_EXTENSIBLE ) {
                        if ((pFwDataRange[i].ulNumChannels   == u.pDataFmtPcmEx->Format.nChannels      ) &&
                           ((pFwDataRange[i].ulSlotSize<<3)  == u.pDataFmtPcmEx->Format.wBitsPerSample ) &&
                           ( pFwDataRange[i].ulValidDataBits == u.pDataFmtPcmEx->Samples.wValidBitsPerSample ) )
                            fFound = TRUE;
                    }
                    else {
                        if ((pFwDataRange[i].ulNumChannels   == u.pDataFmtWave->nChannels      ) &&
                           ( pFwDataRange[i].ulValidDataBits == u.pDataFmtWave->wBitsPerSample ))
                            fFound = TRUE;
                    }

                    // If all other paramters match check sample rate
                    if ( fFound ) {
						fFound = IsSampleRateInRange( &pFwDataRange[i], u.pDataFmtWave->nSamplesPerSec );
                    }

                    break;

                case AUDIO_DATA_TYPE_COMPRESSED:
/*
                    fFound = IsSampleRateInRange( u1.pT2AudioDescriptor,
                                                  u.pDataFmtWave->nSamplesPerSec,
                                                  ulFormatType );
                    break;
*/
                default:
                    TRAP;
                    break;
            }

        }

        if (!fFound) i++;
    }

    if ( fFound ) {
        pOutFwDataRange = &pFwDataRange[i];
    }

    return pOutFwDataRange;
}

ULONG
FindSourceForSrcPlug( 
    PHW_DEVICE_EXTENSION pHwDevExt, 
    ULONG ulPinId )
{
    PAUDIO_SUBUNIT_INFORMATION pAudioSubunitInfo = pHwDevExt->pAvcSubunitInformation;

    PFW_PIN_DESCRIPTOR pFwPinDescriptor = &pAudioSubunitInfo->pPinDescriptors[ulPinId];
    PSOURCE_ID pSourceId = &pFwPinDescriptor->SourceId;

    _DbgPrintF(DEBUGLVL_VERBOSE,("FindSourceForSrcPlug: ulPinId: %x pSourceId: %x\n",
                                   ulPinId, pSourceId ));

    return (ULONG)*(PUSHORT)pSourceId;
}

USHORT
usBitSwapper(USHORT usInVal)
{
    ULONG i;
    USHORT usRetVal = 0;

    _DbgPrintF( DEBUGLVL_BLAB, ("[usBitSwapper] Preswap: %x\n",usInVal));

    for ( i=0; i<(sizeof(USHORT)*8); i++ ) {
        usRetVal |= (usInVal & (1<<i)) ? (0x8000>>i) : 0;
    }

    _DbgPrintF( DEBUGLVL_BLAB, ("[usBitSwapper] Postswap: %x\n",usRetVal));

    return usRetVal;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\drivers\avcaudio\intrsect.c ===
#include "Common.h"


ULONG
GetIntersectFormatSize( PFWAUDIO_DATARANGE pAudioDataRange )
{
    GUID* pSubFormat = &pAudioDataRange->KsDataRangeAudio.DataRange.SubFormat;
    ULONG rval = 0;

    if (IS_VALID_WAVEFORMATEX_GUID(pSubFormat)) {
        if (( (pAudioDataRange->ulSlotSize<<3) <= 16 ) &&
            ( pAudioDataRange->ulNumChannels   <= 2 )){
            rval = sizeof(KSDATAFORMAT_WAVEFORMATEX);
        }
        else {
            rval = sizeof( KSDATAFORMAT ) + sizeof( WAVEFORMATPCMEX );
        }
    }
    else
        rval = sizeof( KSDATAFORMAT ) + sizeof( WAVEFORMATPCMEX );

    return rval;
}

ULONG
ConvertDatarangeToFormat(
    PFWAUDIO_DATARANGE pAudioDataRange,
    PKSDATAFORMAT pFormat )
{
    GUID* pSubFormat = &pAudioDataRange->KsDataRangeAudio.DataRange.SubFormat;

    // Copy datarange directly from interface info.
    *pFormat = pAudioDataRange->KsDataRangeAudio.DataRange;

    if ( IS_VALID_WAVEFORMATEX_GUID(pSubFormat) ) {
        if (( (pAudioDataRange->ulSlotSize<<3) <= 16 ) &&
            ( pAudioDataRange->ulNumChannels   <= 2 )){
             // Don't think this will happen but just in case...
            
			PWAVEFORMATEX pWavFormatEx = (PWAVEFORMATEX)(pFormat+1) ;

            pWavFormatEx->wFormatTag      = EXTRACT_WAVEFORMATEX_ID(pSubFormat);
            pWavFormatEx->nChannels       = (WORD)pAudioDataRange->ulNumChannels;
            pWavFormatEx->nSamplesPerSec  = pAudioDataRange->ulMaxSampleRate;
            pWavFormatEx->wBitsPerSample  = (WORD)(pAudioDataRange->ulSlotSize<<3);
            pWavFormatEx->nBlockAlign     = (pWavFormatEx->nChannels * pWavFormatEx->wBitsPerSample)/8;
            pWavFormatEx->nAvgBytesPerSec = pWavFormatEx->nSamplesPerSec * pWavFormatEx->nBlockAlign;
            pWavFormatEx->cbSize          = 0;

            pFormat->FormatSize = sizeof( KSDATAFORMAT_WAVEFORMATEX );
        }
        else {
            PWAVEFORMATPCMEX pWavFormatPCMEx = (PWAVEFORMATPCMEX)(pFormat+1) ;
            pWavFormatPCMEx->Format.wFormatTag      = WAVE_FORMAT_EXTENSIBLE;
            pWavFormatPCMEx->Format.nChannels       = (WORD)pAudioDataRange->ulNumChannels;
            pWavFormatPCMEx->Format.nSamplesPerSec  = pAudioDataRange->ulMaxSampleRate;
            pWavFormatPCMEx->Format.wBitsPerSample  = (WORD)pAudioDataRange->ulSlotSize<<3;
            pWavFormatPCMEx->Format.nBlockAlign     = pWavFormatPCMEx->Format.nChannels *
                                                      (WORD)pAudioDataRange->ulSlotSize;
            pWavFormatPCMEx->Format.nAvgBytesPerSec = pWavFormatPCMEx->Format.nSamplesPerSec *
                                                      pWavFormatPCMEx->Format.nBlockAlign;
            pWavFormatPCMEx->Format.cbSize          = sizeof(WAVEFORMATPCMEX) - sizeof(WAVEFORMATEX);
            pWavFormatPCMEx->Samples.wValidBitsPerSample = (WORD)pAudioDataRange->ulValidDataBits;
            pWavFormatPCMEx->dwChannelMask          = pAudioDataRange->ulChannelConfig;
            pWavFormatPCMEx->SubFormat              = KSDATAFORMAT_SUBTYPE_PCM;

            pFormat->FormatSize = sizeof( KSDATAFORMAT ) + sizeof( WAVEFORMATPCMEX );
        }
    }

    return pFormat->FormatSize;
}


BOOLEAN
CheckFormatMatch(
    PKSDATARANGE_AUDIO pInDataRange,
    PKSDATARANGE_AUDIO pInterfaceRange )
{
    PKSDATARANGE pInRange = (PKSDATARANGE)pInDataRange;
    PKSDATARANGE pStreamRange = (PKSDATARANGE)pInterfaceRange;
    BOOLEAN fRval = FALSE;

    // Check Format and subformat types
    if (IsEqualGUID(&pInRange->MajorFormat, &pStreamRange->MajorFormat) ||
        IsEqualGUID(&pInRange->MajorFormat, &KSDATAFORMAT_TYPE_WILDCARD)) {
        if (IsEqualGUID(&pInRange->SubFormat, &pStreamRange->SubFormat) ||
            IsEqualGUID(&pInRange->SubFormat, &KSDATAFORMAT_TYPE_WILDCARD)) {
            if (IsEqualGUID(&pInRange->Specifier, &pStreamRange->Specifier) ||
                IsEqualGUID(&pInRange->Specifier, &KSDATAFORMAT_TYPE_WILDCARD)) {
                fRval = TRUE;
            }
        }
    }

    // Now that we know we have an audio format check the dataranges
    if ( fRval ) {

      if (pInDataRange->DataRange.FormatSize >= sizeof(KSDATARANGE_AUDIO)) {

        fRval = FALSE;
        if ( pInDataRange->MaximumChannels >= pInterfaceRange->MaximumChannels ) {
            if ( pInDataRange->MaximumSampleFrequency >= pInterfaceRange->MaximumSampleFrequency ) {
                if (pInDataRange->MinimumSampleFrequency <= pInterfaceRange->MaximumSampleFrequency ) {
                    if ( pInDataRange->MaximumBitsPerSample >= pInterfaceRange->MaximumBitsPerSample) {
                        if ( pInDataRange->MinimumBitsPerSample <= pInterfaceRange->MaximumBitsPerSample) {
                            fRval = TRUE;
                        }
                    }
                    else if ( pInDataRange->MinimumBitsPerSample >= pInterfaceRange->MinimumBitsPerSample ) {
                        fRval = TRUE;
                    }
                }
            }
            else if ( pInDataRange->MinimumSampleFrequency >= pInterfaceRange->MinimumSampleFrequency ) {
                if ( pInDataRange->MaximumBitsPerSample >= pInterfaceRange->MaximumBitsPerSample) {
                    if ( pInDataRange->MinimumBitsPerSample <= pInterfaceRange->MaximumBitsPerSample) {
                        fRval = TRUE;
                    }
                }
                else if ( pInDataRange->MinimumBitsPerSample >= pInterfaceRange->MinimumBitsPerSample ) {
                    fRval = TRUE;
                }
            }
        }
      }
    }

    return fRval;
}


VOID
GetMaxSampleRate(
    PFWAUDIO_DATARANGE pFWAudioRange,
    ULONG ulRequestedMaxSR,
    ULONG ulFormatType )
{

    ULONG ulMaxSampleRate = 0;
    ULONG ulIFMaxSR;
    ULONG j;

    if ( ulFormatType == AUDIO_DATA_TYPE_TIME_BASED) {
        pFWAudioRange->ulMaxSampleRate = 
            pFWAudioRange->KsDataRangeAudio.MaximumSampleFrequency;
/*
		PPCM_FORMAT pPCMFmt = (PPCM_FORMAT)pFWAudioRange->pFormat;
        if (pPCMFmt->ulSampleRateType == 0) {
            ulIFMaxSR = pFWAudioRange->KsDataRangeAudio.MaximumSampleFrequency;
            pFWAudioRange->ulMaxSampleRate = ( ulIFMaxSR < ulRequestedMaxSR ) ?
                                               ulIFMaxSR : ulRequestedMaxSR;
        }
        else {
            pFWAudioRange->ulMaxSampleRate = 0;
            for ( j=0; j<pPCMFmt->ulSampleRateType; j++ ) {
                ulIFMaxSR  = pPCMFmt->pSampleRate[j];
                if ( ( ulIFMaxSR <= ulRequestedMaxSR ) &&
                     ( ulIFMaxSR > pFWAudioRange->ulMaxSampleRate ) )
                    pFWAudioRange->ulMaxSampleRate = ulIFMaxSR;
            }
        }
  */
    }

/*
    else { // Its Type II
        pT2AudioDesc = (PAUDIO_CLASS_TYPE2_STREAM)pFWAudioRange->pAudioDescriptor;
        if (pT2AudioDesc->bSampleFreqType == 0) {
            ulIFMaxSR = pFWAudioRange->KsDataRangeAudio.MaximumSampleFrequency;
            pFWAudioRange->ulMaxSampleRate = ( ulIFMaxSR < ulRequestedMaxSR ) ?
                                               ulIFMaxSR : ulRequestedMaxSR;
        }
        else {
            pFWAudioRange->ulMaxSampleRate = 0;
            for ( j=0; j<pT2AudioDesc->bSampleFreqType; j++ ) {
                ulIFMaxSR  = pT2AudioDesc->pSampleRate[j].bSampleFreqByte1 +
                      256L * pT2AudioDesc->pSampleRate[j].bSampleFreqByte2 +
                    65536L * pT2AudioDesc->pSampleRate[j].bSampleFreqByte3;
                if ( ( ulIFMaxSR <= ulRequestedMaxSR ) &&
                     ( ulIFMaxSR > pFWAudioRange->ulMaxSampleRate ) )
                    pFWAudioRange->ulMaxSampleRate = ulIFMaxSR;
            }
        }
    }
*/

}

PFWAUDIO_DATARANGE
FindBestMatchForInterfaces(
    PFWAUDIO_DATARANGE *ppFWAudioRange,
    ULONG ulAudioRangeCount,
    ULONG ulRequestedMaxSR  )
{
    PFWAUDIO_DATARANGE pFWAudioRange;

    ULONG ulMaxSampleRate = 0;
    ULONG ulMaxChannels   = 0;
    ULONG ulMaxSampleSize = 0;
    ULONG ulRngeCnt;
    ULONG ulFormatType;
    ULONG i;

     ulFormatType = ppFWAudioRange[0]->ulDataType & DATA_FORMAT_TYPE_MASK;
    // Determine if this is Time Based or Compressed Data Format. Since we've already weeded
    // out the impossibilities via CheckFormatMatch this should be the same for all
    // interfaces left in the list.

    for ( i=0; i<ulAudioRangeCount; i++ ) {
        GetMaxSampleRate( ppFWAudioRange[i],
                          ulRequestedMaxSR,
                          ulFormatType );
    }

    // Now eliminate lower frequency interfaces. First find the best then
    // eliminate others that don't meet it.
    for ( i=0; i<ulAudioRangeCount; i++ ) {
        pFWAudioRange = ppFWAudioRange[i];
        if ( pFWAudioRange->ulMaxSampleRate > ulMaxSampleRate ) {
            ulMaxSampleRate = pFWAudioRange->ulMaxSampleRate;
        }
    }
    for ( i=0, ulRngeCnt=ulAudioRangeCount; i<ulAudioRangeCount; i++ ) {
        pFWAudioRange = ppFWAudioRange[i];
        if ( pFWAudioRange->ulMaxSampleRate < ulMaxSampleRate ) {
            ppFWAudioRange[i] = NULL; ulRngeCnt--;
        }
    }


    if ((ulFormatType == AUDIO_DATA_TYPE_TIME_BASED) && (ulRngeCnt > 1)) {
        // Now find the highest number of channels and eliminate others
        for ( i=0; i<ulAudioRangeCount; i++ ) {
            if ( ppFWAudioRange[i] ) {

                if ( ppFWAudioRange[i]->ulNumChannels > ulMaxChannels ) {
                    ulMaxChannels = ppFWAudioRange[i]->ulNumChannels;
                }
                if ( ppFWAudioRange[i]->ulValidDataBits > ulMaxSampleSize ) {
                    ulMaxSampleSize = ppFWAudioRange[i]->ulValidDataBits;
                }
            }
        }

        for ( i=0; ((i<ulAudioRangeCount) && (ulRngeCnt>1)); i++ ) {
            if ( ppFWAudioRange[i] ) {
                if ( ppFWAudioRange[i]->ulNumChannels < ulMaxChannels ) {
                    ppFWAudioRange[i] = NULL; ulRngeCnt--;
                }
            }
        }

        for ( i=0; ((i<ulAudioRangeCount) && (ulRngeCnt>1)); i++ ) {
            if ( ppFWAudioRange[i] ) {
                if ( ppFWAudioRange[i]->ulValidDataBits < ulMaxSampleSize ) {
                    ppFWAudioRange[i] = NULL; ulRngeCnt--;
                }
            }
        }
    }

    i=0;
    while ( !ppFWAudioRange[i] ) i++;

    return ppFWAudioRange[i];
}

PFWAUDIO_DATARANGE
FindDataIntersection(
    PKSDATARANGE_AUDIO pKsAudioRange,
    PFWAUDIO_DATARANGE *ppFWAudioRanges,
    ULONG ulAudioRangeCount )
{
    ULONG ulMaximumSampleFrequency = MAX_ULONG;

    PFWAUDIO_DATARANGE *ppFWAudioRange;
    PFWAUDIO_DATARANGE pFWAudioRange;
    PFWAUDIO_DATARANGE pMatchedRange;
    ULONG ulRngeCnt = 0;
    ULONG i;

    // Allocate space for copy of range pointers
    ppFWAudioRange = (PFWAUDIO_DATARANGE *)AllocMem(NonPagedPool, ulAudioRangeCount*sizeof(PFWAUDIO_DATARANGE));
    if ( !ppFWAudioRange ) {
        return NULL;
    }

    // Make a list of those ranges which match the input request
    for (i=0; i<ulAudioRangeCount; i++) {
        pFWAudioRange = ppFWAudioRanges[i];
        if ( CheckFormatMatch(pKsAudioRange, &pFWAudioRange->KsDataRangeAudio) ) {
            ppFWAudioRange[ulRngeCnt++] = ppFWAudioRanges[i];
        }
    }

    // Set this ulMaximumSampleFrequency only if it exists in pKsAudioRange
    if (pKsAudioRange->DataRange.FormatSize >= sizeof(KSDATARANGE_AUDIO)) {
        ulMaximumSampleFrequency = pKsAudioRange->MaximumSampleFrequency;
    }

    // If there are no matches return NULL
    if ( ulRngeCnt == 0 ) {
        FreeMem( ppFWAudioRange );
        return NULL;
    }

    // If there is only 1 match we're done
    else if ( ulRngeCnt == 1 ) {
        pMatchedRange = ppFWAudioRange[0];
        GetMaxSampleRate( pMatchedRange,
                          ulMaximumSampleFrequency,
                          pMatchedRange->ulDataType & DATA_FORMAT_TYPE_MASK );
        FreeMem( ppFWAudioRange );
        return pMatchedRange;
    }

    // Now narrow choices based on best possible match.
    pMatchedRange =
        FindBestMatchForInterfaces( ppFWAudioRange,
                                    ulRngeCnt,
                                    pKsAudioRange->MaximumSampleFrequency );
    FreeMem(ppFWAudioRange);

    return pMatchedRange;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\drivers\avcaudio\property.h ===
#ifndef ___PROPERTY_H___
#define ___PROPERTY_H___

/*****************************************************************************

                        Definitions of Properties

*****************************************************************************/
// Declare Handlers for Pin Properties
NTSTATUS
GetPinName( PIRP pIrp, PKSP_PIN pPin, PVOID pData );


// Declare Handlers for Item Map
NTSTATUS 
GetSetSampleRate( PIRP pIrp, PKSPROPERTY pKsProperty, PVOID pData );
NTSTATUS 
GetSetVolumeLevel( PIRP pIrp, PKSPROPERTY pKsProperty, PVOID pData );
NTSTATUS 
GetSetToneLevel( PIRP pIrp, PKSPROPERTY pKsProperty, PVOID pData );
NTSTATUS 
GetSetCopyProtection( PIRP pIrp, PKSPROPERTY pKsProperty, PVOID pData );
NTSTATUS 
GetSetMixLevels( PIRP pIrp, PKSPROPERTY pKsProperty, PVOID pData );
NTSTATUS 
GetMuxSource( PIRP pIrp, PKSPROPERTY pKsProperty, PVOID pData );
NTSTATUS 
SetMuxSource( PIRP pIrp, PKSPROPERTY pKsProperty, PVOID pData );
NTSTATUS 
GetSetBoolean( PIRP pIrp, PKSPROPERTY pKsProperty, PVOID pData );
NTSTATUS 
GetSetEqualizerLevels( PIRP pIrp, PKSPROPERTY pKsProperty, PVOID pData );
NTSTATUS 
GetNumEqualizerBands( PIRP pIrp, PKSPROPERTY pKsProperty, PVOID pData );
NTSTATUS 
GetEqualizerBands( PIRP pIrp, PKSPROPERTY pKsProperty, PVOID pData );
NTSTATUS 
GetSetAudioControlLevel( PIRP pIrp, PKSPROPERTY pKsProperty, PVOID pData );
NTSTATUS 
GetSetDeviceSpecific( PIRP pIrp, PKSPROPERTY pKsProperty, PVOID pData );
NTSTATUS 
GetAudioLatency( PIRP pIrp, PKSPROPERTY pKsProperty, PVOID pData );
NTSTATUS 
GetChannelConfiguration( PIRP pIrp, PKSPROPERTY pKsProperty, PVOID pData );
NTSTATUS 
GetAudioPosition( PIRP pIrp, PKSPROPERTY pKsProperty, PVOID pData );
NTSTATUS 
GetSetSampleRate( PIRP pIrp, PKSPROPERTY pKsProperty, PVOID pData );
NTSTATUS
GetSetChannelConfig( PIRP pIrp, PKSPROPERTY pKsProperty, PVOID pData );

NTSTATUS 
GetBasicSupportBoolean( PIRP pIrp, PKSPROPERTY pKsProperty, PVOID pData );

NTSTATUS 
GetBasicSupport( PIRP pIrp, PKSPROPERTY pKsProperty, PVOID pData );

NTSTATUS
GetSetTopologyNodeEnable( PIRP pIrp, PKSPROPERTY pKsProperty, PVOID pData );

// Declare Handler for DRM
NTSTATUS
DrmAudioStream_SetContentId(
    IN PIRP pIrp,
    IN PKSP_DRMAUDIOSTREAM_CONTENTID pProperty,
    IN PKSDRMAUDIOSTREAM_CONTENTID pvData
    );

static const
KSPROPERTY_ITEM PinPropertyItems[]={
    {
     (ULONG) KSPROPERTY_PIN_CINSTANCES,  // PropertyId
     (PFNKSHANDLER) FALSE,               // pfnGetHandler
     0,                                  // MinProperty
     0,                                  // MinData
     (PFNKSHANDLER) FALSE,               // pfnSetHandler
     NULL,                               // PKSPROPERTY_VALUES Values
     0,                                  // RelationsCount
     NULL,                               // PKSPROPERTY Relations
     NULL,                               // PFNKSHANDLER SupportHandler
     0                                   // SerializedSize
    },

    {
     (ULONG) KSPROPERTY_PIN_CTYPES,      // PropertyId
     (PFNKSHANDLER) FALSE,               // pfnGetHandler
     0,                                  // MinProperty
     0,                                  // MinData
     (PFNKSHANDLER) FALSE,               // pfnSetHandler
     NULL,                               // PKSPROPERTY_VALUES Values
     0,                                  // RelationsCount
     NULL,                               // PKSPROPERTY Relations
     NULL,                               // PFNKSHANDLER SupportHandler
     0                                   // SerializedSize
    },

    {
     (ULONG) KSPROPERTY_PIN_DATAFLOW,    // PropertyId
     (PFNKSHANDLER) FALSE,               // pfnGetHandler
     0,                                  // MinProperty
     0,                                  // MinData
     (PFNKSHANDLER) FALSE,               // pfnSetHandler
     NULL,                               // PKSPROPERTY_VALUES Values
     0,                                  // RelationsCount
     NULL,                               // PKSPROPERTY Relations
     NULL,                               // PFNKSHANDLER SupportHandler
     0                                   // SerializedSize
    },

    {
     (ULONG) KSPROPERTY_PIN_DATARANGES,  // PropertyId
     (PFNKSHANDLER) FALSE,               // pfnGetHandler
     0,                                  // MinProperty
     0,                                  // MinData
     (PFNKSHANDLER) FALSE,               // pfnSetHandler
     NULL,                               // PKSPROPERTY_VALUES Values
     0,                                  // RelationsCount
     NULL,                               // PKSPROPERTY Relations
     NULL,                               // PFNKSHANDLER SupportHandler
     0                                   // SerializedSize
    },

    {
     (ULONG) KSPROPERTY_PIN_DATAINTERSECTION,  // PropertyId
     (PFNKSHANDLER) FALSE,               // pfnGetHandler
     0,                                  // MinProperty
     0,                                  // MinData
     (PFNKSHANDLER) FALSE,               // pfnSetHandler
     NULL,                               // PKSPROPERTY_VALUES Values
     0,                                  // RelationsCount
     NULL,                               // PKSPROPERTY Relations
     NULL,                               // PFNKSHANDLER SupportHandler
     0                                   // SerializedSize
    },

    {
     (ULONG) KSPROPERTY_PIN_INTERFACES,  // PropertyId
     (PFNKSHANDLER) FALSE,               // pfnGetHandler
     0,                                  // MinProperty
     0,                                  // MinData
     (PFNKSHANDLER) FALSE,               // pfnSetHandler
     NULL,                               // PKSPROPERTY_VALUES Values
     0,                                  // RelationsCount
     NULL,                               // PKSPROPERTY Relations
     NULL,                               // PFNKSHANDLER SupportHandler
     0                                   // SerializedSize
    },

    {
     (ULONG) KSPROPERTY_PIN_MEDIUMS,     // PropertyId
     (PFNKSHANDLER) FALSE,               // pfnGetHandler
     0,                                  // MinProperty
     0,                                  // MinData
     (PFNKSHANDLER) FALSE,               // pfnSetHandler
     NULL,                               // PKSPROPERTY_VALUES Values
     0,                                  // RelationsCount
     NULL,                               // PKSPROPERTY Relations
     NULL,                               // PFNKSHANDLER SupportHandler
     0                                   // SerializedSize
    },

    {
     (ULONG) KSPROPERTY_PIN_COMMUNICATION,  // PropertyId
     (PFNKSHANDLER) FALSE,               // pfnGetHandler
     0,                                  // MinProperty
     0,                                  // MinData
     (PFNKSHANDLER) FALSE,               // pfnSetHandler
     NULL,                               // PKSPROPERTY_VALUES Values
     0,                                  // RelationsCount
     NULL,                               // PKSPROPERTY Relations
     NULL,                               // PFNKSHANDLER SupportHandler
     0                                   // SerializedSize
    },

    {
     (ULONG) KSPROPERTY_PIN_GLOBALCINSTANCES,  // PropertyId
     (PFNKSHANDLER) FALSE,               // pfnGetHandler
     0,                                  // MinProperty
     0,                                  // MinData
     (PFNKSHANDLER) FALSE,               // pfnSetHandler
     NULL,                               // PKSPROPERTY_VALUES Values
     0,                                  // RelationsCount
     NULL,                               // PKSPROPERTY Relations
     NULL,                               // PFNKSHANDLER SupportHandler
     0                                   // SerializedSize
    },

    {
     (ULONG) KSPROPERTY_PIN_NECESSARYINSTANCES,  // PropertyId
     (PFNKSHANDLER) FALSE,               // pfnGetHandler
     0,                                  // MinProperty
     0,                                  // MinData
     (PFNKSHANDLER) FALSE,               // pfnSetHandler
     NULL,                               // PKSPROPERTY_VALUES Values
     0,                                  // RelationsCount
     NULL,                               // PKSPROPERTY Relations
     NULL,                               // PFNKSHANDLER SupportHandler
     0                                   // SerializedSize
    },

    {
     (ULONG) KSPROPERTY_PIN_PHYSICALCONNECTION,  // PropertyId
     (PFNKSHANDLER) FALSE,               // pfnGetHandler
     0,                                  // MinProperty
     0,                                  // MinData
     (PFNKSHANDLER) FALSE,               // pfnSetHandler
     NULL,                               // PKSPROPERTY_VALUES Values
     0,                                  // RelationsCount
     NULL,                               // PKSPROPERTY Relations
     NULL,                               // PFNKSHANDLER SupportHandler
     0                                   // SerializedSize
    },

    {
     (ULONG) KSPROPERTY_PIN_CATEGORY,    // PropertyId
     (PFNKSHANDLER) FALSE,               // pfnGetHandler
     0,                                  // MinProperty
     0,                                  // MinData
     (PFNKSHANDLER) FALSE,               // pfnSetHandler
     NULL,                               // PKSPROPERTY_VALUES Values
     0,                                  // RelationsCount
     NULL,                               // PKSPROPERTY Relations
     NULL,                               // PFNKSHANDLER SupportHandler
     0                                   // SerializedSize
    },

    {
     (ULONG) KSPROPERTY_PIN_NAME,        // PropertyId
     (PFNKSHANDLER) GetPinName,          // pfnGetHandler
     sizeof(KSP_PIN),                    // MinProperty
     0,                                  // MinData
     (PFNKSHANDLER) FALSE,               // pfnSetHandler
     NULL,                               // PKSPROPERTY_VALUES Values
     0,                                  // RelationsCount
     NULL,                               // PKSPROPERTY Relations
     NULL,                               // PFNKSHANDLER SupportHandler
     0                                   // SerializedSize
    },

    {
     (ULONG) KSPROPERTY_PIN_CONSTRAINEDDATARANGES,  // PropertyId
     (PFNKSHANDLER) FALSE,               // pfnGetHandler
     0,                                  // MinProperty
     0,                                  // MinData
     (PFNKSHANDLER) FALSE,               // pfnSetHandler
     NULL,                               // PKSPROPERTY_VALUES Values
     0,                                  // RelationsCount
     NULL,                               // PKSPROPERTY Relations
     NULL,                               // PFNKSHANDLER SupportHandler
     0                                   // SerializedSize
    },

    {
     (ULONG) KSPROPERTY_PIN_PROPOSEDATAFORMAT,  // PropertyId
     (PFNKSHANDLER) FALSE,               // pfnGetHandler
     0,                                  // MinProperty
     0,                                  // MinData
     (PFNKSHANDLER) FALSE,               // pfnSetHandler
     NULL,                               // PKSPROPERTY_VALUES Values
     0,                                  // RelationsCount
     NULL,                               // PKSPROPERTY Relations
     NULL,                               // PFNKSHANDLER SupportHandler
     0                                   // SerializedSize
    }
};

static const 
KSPROPERTY_ITEM AudioPropertyItems[]={
    {
     (ULONG) 0,                          // PropertyId (There is no property 0)
     (PFNKSHANDLER) FALSE,               // GetSupported
     0,                                  // MinProperty
     0,                                  // MinData
     (PFNKSHANDLER) FALSE,               // SetSupported
     NULL,                               // PKSPROPERTY_VALUES Values
     0,                                  // RelationsCount
     NULL,                               // PKSPROPERTY Relations
     NULL,                               // PFNKSHANDLER SupportHandler
     0                                   // SerializedSize
    },

    {
     (ULONG) KSPROPERTY_AUDIO_LATENCY,   // PropertyId
     GetAudioLatency,                    // GetSupported
     sizeof (KSNODEPROPERTY),            // MinProperty
     sizeof (LONGLONG),                  // MinData
     NULL,                               // SetSupported
     NULL,                               // PKSPROPERTY_VALUES Values
     0,                                  // RelationsCount
     NULL,                               // PKSPROPERTY Relations
     NULL,                               // PFNKSHANDLER SupportHandler
     0                                   // SerializedSize
    },

    {
     (ULONG) KSPROPERTY_AUDIO_COPY_PROTECTION, // PropertyId
     GetSetCopyProtection,               // GetSupported
     sizeof (KSNODEPROPERTY),            // MinProperty
     sizeof (KSAUDIO_COPY_PROTECTION),   // MinData
     GetSetCopyProtection,               // SetSupported
     NULL,                               // PKSPROPERTY_VALUES Values
     0,                                  // RelationsCount
     NULL,                               // PKSPROPERTY Relations
     NULL,                               // PFNKSHANDLER SupportHandler
     0                                   // SerializedSize
    },

    {
     (ULONG) KSPROPERTY_AUDIO_CHANNEL_CONFIG, // PropertyId
     GetChannelConfiguration,            // GetSupported
     sizeof (KSNODEPROPERTY),            // MinProperty
     sizeof (KSAUDIO_CHANNEL_CONFIG),    // MinData
     NULL,                               // SetSupported
     NULL,                               // PKSPROPERTY_VALUES Values
     0,                                  // RelationsCount
     NULL,                               // PKSPROPERTY Relations
     NULL,                               // PFNKSHANDLER SupportHandler
     0                                   // SerializedSize
    },
        
    {
     (ULONG) KSPROPERTY_AUDIO_VOLUMELEVEL, // PropertyId
     GetSetVolumeLevel,                  // GetSupported
     sizeof (KSNODEPROPERTY_AUDIO_CHANNEL), // MinProperty
     sizeof (ULONG),                     // MinData
     GetSetVolumeLevel,                  // SetSupported
     NULL,                               // PKSPROPERTY_VALUES Values
     0,                                  // RelationsCount
     NULL,                               // PKSPROPERTY Relations
     GetBasicSupport,                    // PFNKSHANDLER SupportHandler
     0                                   // SerializedSize
    },

    {
     (ULONG) KSPROPERTY_AUDIO_POSITION,  // PropertyId
     GetAudioPosition,                   // GetSupported
     sizeof (KSPROPERTY),                // MinProperty
     sizeof (KSAUDIO_POSITION),          // MinData
     NULL,                               // SetSupported
     NULL,                               // PKSPROPERTY_VALUES Values
     0,                                  // RelationsCount
     NULL,                               // PKSPROPERTY Relations
     NULL,                               // PFNKSHANDLER SupportHandler
     0                                   // SerializedSize
    },

    {
     (ULONG) KSPROPERTY_AUDIO_DYNAMIC_RANGE, // PropertyId
     NULL,                               // GetSupported
     sizeof (KSNODEPROPERTY),            // MinProperty
     sizeof (ULONG),                     // MinData
     NULL,                               // SetSupported
     NULL,                               // PKSPROPERTY_VALUES Values
     0,                                  // RelationsCount
     NULL,                               // PKSPROPERTY Relations
     NULL,                               // PFNKSHANDLER SupportHandler
     0                                   // SerializedSize
    },

    {
     (ULONG) KSPROPERTY_AUDIO_QUALITY,   // PropertyId
     NULL,                               // GetSupported
     sizeof (KSPROPERTY),                // MinProperty
     sizeof (KSAUDIO_POSITION),          // MinData
     NULL,                               // SetSupported
     NULL,                               // PKSPROPERTY_VALUES Values
     0,                                  // RelationsCount
     NULL,                               // PKSPROPERTY Relations
     NULL,                               // PFNKSHANDLER SupportHandler
     0                                   // SerializedSize
    },

    {
     (ULONG) KSPROPERTY_AUDIO_SAMPLING_RATE, // PropertyId
     GetSetSampleRate,                   // GetSupported
     sizeof (KSNODEPROPERTY),            // MinProperty
     sizeof (ULONG),                     // MinData
     GetSetSampleRate,                   // SetSupported
     NULL,                               // PKSPROPERTY_VALUES Values
     0,                                  // RelationsCount
     NULL,                               // PKSPROPERTY Relations
     NULL,                               // PFNKSHANDLER SupportHandler
     0                                   // SerializedSize
    },

    {
     (ULONG) KSPROPERTY_AUDIO_DYNAMIC_SAMPLING_RATE, // PropertyId
     NULL,                               // GetSupported
     sizeof (KSNODEPROPERTY),            // MinProperty
     sizeof (BOOL),                      // MinData
     NULL,                               // SetSupported
     NULL,                               // PKSPROPERTY_VALUES Values
     0,                                  // RelationsCount
     NULL,                               // PKSPROPERTY Relations
     NULL,                               // PFNKSHANDLER SupportHandler
     0                                   // SerializedSize
    },

    {
     (ULONG) KSPROPERTY_AUDIO_MIX_LEVEL_TABLE, // PropertyId
     GetSetMixLevels,                    // GetSupported
     sizeof (KSNODEPROPERTY),            // MinProperty
     sizeof (KSAUDIO_MIXLEVEL),          // MinData
     GetSetMixLevels,                    // SetSupported
     NULL,                               // PKSPROPERTY_VALUES Values
     0,                                  // RelationsCount
     NULL,                               // PKSPROPERTY Relations
     NULL,                               // PFNKSHANDLER SupportHandler
     0                                   // SerializedSize
    },

    {
     (ULONG) KSPROPERTY_AUDIO_MIX_LEVEL_CAPS, // PropertyId
     GetSetMixLevels,                    // GetSupported
     sizeof (KSNODEPROPERTY),            // MinProperty
     sizeof (ULONG) + sizeof(ULONG),     // MinData
     NULL,                               // SetSupported
     NULL,                               // PKSPROPERTY_VALUES Values
     0,                                  // RelationsCount
     NULL,                               // PKSPROPERTY Relations
     NULL,                               // PFNKSHANDLER SupportHandler
     0                                   // SerializedSize
    },

    {
     (ULONG) KSPROPERTY_AUDIO_MUX_SOURCE, // PropertyId
     GetMuxSource,                       // GetSupported
     sizeof (KSNODEPROPERTY),            // MinProperty
     sizeof (ULONG),                     // MinData
     SetMuxSource,                       // SetSupported
     NULL,                               // PKSPROPERTY_VALUES Values
     0,                                  // RelationsCount
     NULL,                               // PKSPROPERTY Relations
     NULL,                               // PFNKSHANDLER SupportHandler
     0                                   // SerializedSize
    },

    {
     (ULONG) KSPROPERTY_AUDIO_MUTE,      // PropertyId
     GetSetBoolean,                      // GetSupported
     sizeof (KSNODEPROPERTY_AUDIO_CHANNEL), // MinProperty
     sizeof (BOOL),                      // MinData
     GetSetBoolean,                      // SetSupported
     NULL,                               // PKSPROPERTY_VALUES Values
     0,                                  // RelationsCount
     NULL,                               // PKSPROPERTY Relations
     NULL,                               // PFNKSHANDLER SupportHandler
     0                                   // SerializedSize
    },

    {
     (ULONG) KSPROPERTY_AUDIO_BASS,      // PropertyId
     GetSetToneLevel,                    // GetSupported
     sizeof (KSNODEPROPERTY_AUDIO_CHANNEL),  // MinProperty
     sizeof (ULONG),                     // MinData
     GetSetToneLevel,                    // SetSupported
     NULL,                               // PKSPROPERTY_VALUES Values
     0,                                  // RelationsCount
     NULL,                               // PKSPROPERTY Relations
     GetBasicSupport,                    // PFNKSHANDLER SupportHandler
     0                                   // SerializedSize
    },

    {
     (ULONG) KSPROPERTY_AUDIO_MID,       // PropertyId
     GetSetToneLevel,                    // GetSupported
     sizeof (KSNODEPROPERTY_AUDIO_CHANNEL), // MinProperty
     sizeof (ULONG),                     // MinData
     GetSetToneLevel,                    // SetSupported
     NULL,                               // PKSPROPERTY_VALUES Values
     0,                                  // RelationsCount
     NULL,                               // PKSPROPERTY Relations
     GetBasicSupport,                    // PFNKSHANDLER SupportHandler
     0                                   // SerializedSize
    },

    {
     (ULONG) KSPROPERTY_AUDIO_TREBLE,    // PropertyId
     GetSetToneLevel,                    // GetSupported
     sizeof (KSNODEPROPERTY_AUDIO_CHANNEL), // MinProperty
     sizeof (ULONG),                     // MinData
     GetSetToneLevel,                    // SetSupported
     NULL,                               // PKSPROPERTY_VALUES Values
     0,                                  // RelationsCount
     NULL,                               // PKSPROPERTY Relations
     GetBasicSupport,                    // PFNKSHANDLER SupportHandler
     0                                   // SerializedSize
    },

    {
     (ULONG) KSPROPERTY_AUDIO_BASS_BOOST, // PropertyId
     GetSetBoolean,                      // GetSupported
     sizeof (KSNODEPROPERTY_AUDIO_CHANNEL), // MinProperty
     sizeof (ULONG),                     // MinData
     GetSetBoolean,                      // SetSupported
     NULL,                               // PKSPROPERTY_VALUES Values
     0,                                  // RelationsCount
     NULL,                               // PKSPROPERTY Relations
     NULL,                               // PFNKSHANDLER SupportHandler
     0                                   // SerializedSize
    },

    {
     (ULONG) KSPROPERTY_AUDIO_EQ_LEVEL,  // PropertyId
     GetSetEqualizerLevels,              // GetSupported
     sizeof (KSNODEPROPERTY_AUDIO_CHANNEL), // MinProperty
     sizeof (ULONG),                     // MinData
     GetSetEqualizerLevels,              // SetSupported
     NULL,                               // PKSPROPERTY_VALUES Values
     0,                                  // RelationsCount
     NULL,                               // PKSPROPERTY Relations
     GetBasicSupport,                    // PFNKSHANDLER SupportHandler
     0                                   // SerializedSize
    },

    {
     (ULONG) KSPROPERTY_AUDIO_NUM_EQ_BANDS, // PropertyId
     GetNumEqualizerBands,               // GetSupported
     sizeof (KSNODEPROPERTY_AUDIO_CHANNEL),  // MinProperty
     sizeof (ULONG),                     // MinData
     GetNumEqualizerBands,               // SetSupported
     NULL,                               // PKSPROPERTY_VALUES Values
     0,                                  // RelationsCount
     NULL,                               // PKSPROPERTY Relations
     NULL,                               // PFNKSHANDLER SupportHandler
     0                                   // SerializedSize
    },

    {
     (ULONG) KSPROPERTY_AUDIO_EQ_BANDS,  // PropertyId
     GetEqualizerBands,                  // GetSupported
     sizeof (KSNODEPROPERTY_AUDIO_CHANNEL), // MinProperty
     sizeof (ULONG),                     // MinData
     GetEqualizerBands,                  // SetSupported
     NULL,                               // PKSPROPERTY_VALUES Values
     0,                                  // RelationsCount
     NULL,                               // PKSPROPERTY Relations
     NULL,                               // PFNKSHANDLER SupportHandler
     0                                   // SerializedSize
    },

    {
     (ULONG) KSPROPERTY_AUDIO_AGC,       // PropertyId
     GetSetBoolean,                      // GetSupported
     sizeof (KSNODEPROPERTY_AUDIO_CHANNEL), // MinProperty
     sizeof (ULONG),                     // MinData
     GetSetBoolean,                      // SetSupported
     NULL,                               // PKSPROPERTY_VALUES Values
     0,                                  // RelationsCount
     NULL,                               // PKSPROPERTY Relations
     NULL,                               // PFNKSHANDLER SupportHandler
     0                                   // SerializedSize
    },
        
    {
     (ULONG) KSPROPERTY_AUDIO_DELAY,     // PropertyId
     NULL,                               // GetSupported
     sizeof (KSNODEPROPERTY_AUDIO_CHANNEL), // MinProperty
     sizeof (KSTIME),                    // MinData
     NULL,                               // SetSupported
     NULL,                               // PKSPROPERTY_VALUES Values
     0,                                  // RelationsCount
     NULL,                               // PKSPROPERTY Relations
     NULL,                               // PFNKSHANDLER SupportHandler
     0                                   // SerializedSize
    },

    {
     (ULONG) KSPROPERTY_AUDIO_LOUDNESS,  // PropertyId
     GetSetBoolean,                      // GetSupported
     sizeof (KSNODEPROPERTY_AUDIO_CHANNEL), // MinProperty
     sizeof (ULONG),                     // MinData
     GetSetBoolean,                      // SetSupported
     NULL,                               // PKSPROPERTY_VALUES Values
     0,                                  // RelationsCount
     NULL,                               // PKSPROPERTY Relations
     NULL,                               // PFNKSHANDLER SupportHandler
     0                                   // SerializedSize
    },
        
    {
     (ULONG) KSPROPERTY_AUDIO_WIDE_MODE, // PropertyId
     NULL,                               // GetSupported
     sizeof (KSNODEPROPERTY),            // MinProperty
     sizeof (ULONG),                     // MinData
     NULL,                               // SetSupported
     NULL,                               // PKSPROPERTY_VALUES Values
     0,                                  // RelationsCount
     NULL,                               // PKSPROPERTY Relations
     NULL,                               // PFNKSHANDLER SupportHandler
     0                                   // SerializedSize
    },

    {
     (ULONG) KSPROPERTY_AUDIO_WIDENESS,  // PropertyId
     GetSetAudioControlLevel,            // GetSupported
     sizeof (KSNODEPROPERTY),            // MinProperty
     sizeof (ULONG),                     // MinData
     GetSetAudioControlLevel,            // SetSupported
     NULL,                               // PKSPROPERTY_VALUES Values
     0,                                  // RelationsCount
     NULL,                               // PKSPROPERTY Relations
     NULL,                               // PFNKSHANDLER SupportHandler
     0                                   // SerializedSize
    },

    {
     (ULONG) KSPROPERTY_AUDIO_REVERB_LEVEL, // PropertyId
     GetSetAudioControlLevel,            // GetSupported
     sizeof (KSNODEPROPERTY),            // MinProperty
     sizeof (ULONG),                     // MinData
     GetSetAudioControlLevel,            // SetSupported
     NULL,                               // PKSPROPERTY_VALUES Values
     0,                                  // RelationsCount
     NULL,                               // PKSPROPERTY Relations
     NULL,                               // PFNKSHANDLER SupportHandler
     0                                   // SerializedSize
    },

    {
     (ULONG) KSPROPERTY_AUDIO_CHORUS_LEVEL, // PropertyId
     GetSetAudioControlLevel,            // GetSupported
     sizeof (KSNODEPROPERTY),            // MinProperty
     sizeof (ULONG),                     // MinData
     GetSetAudioControlLevel,            // SetSupported
     NULL,                               // PKSPROPERTY_VALUES Values
     0,                                  // RelationsCount
     NULL,                               // PKSPROPERTY Relations
     NULL,                               // PFNKSHANDLER SupportHandler
     0                                   // SerializedSize
    },

    {
     (ULONG) KSPROPERTY_AUDIO_DEV_SPECIFIC, // PropertyId
     GetSetDeviceSpecific,               // GetSupported
     sizeof (KSNODEPROPERTY_AUDIO_DEV_SPECIFIC),  // MinProperty
     sizeof (BYTE),                      // MinData
     GetSetDeviceSpecific,               // SetSupported
     NULL,                               // PKSPROPERTY_VALUES Values
     0,                                  // RelationsCount
     NULL,                               // PKSPROPERTY Relations
     NULL,                               // PFNKSHANDLER SupportHandler
     0                                   // SerializedSize
    }
};


// AC-3 Property set.

static const KSPROPERTY_ITEM AC3PropItm[]={
    {
     (ULONG) 0,                          // PropertyId (There is no property 0)
     (PFNKSHANDLER) FALSE,               // GetSupported
     0,                                  // MinProperty
     0,                                  // MinData
     (PFNKSHANDLER) FALSE,               // SetSupported
     NULL,                               // PKSPROPERTY_VALUES Values
     0,                                  // RelationsCount
     NULL,                               // PKSPROPERTY Relations
     NULL,                               // PFNKSHANDLER SupportHandler
     0                                   // SerializedSize
    },

    {
     (ULONG) KSPROPERTY_AC3_ERROR_CONCEALMENT,  // PropertyId
     (PFNKSHANDLER) TRUE,                // GetSupported
     sizeof (KSNODEPROPERTY),            // MinProperty
     sizeof (BOOLEAN),                   // MinData
     (PFNKSHANDLER) TRUE,                // SetSupported
     NULL,                               // PKSPROPERTY_VALUES Values
     0,                                  // RelationsCount
     NULL,                               // PKSPROPERTY Relations
     NULL,                               // PFNKSHANDLER SupportHandler
     0                                   // SerializedSize
    },

    {
     (ULONG) KSPROPERTY_AC3_ALTERNATE_AUDIO,  // PropertyId
     (PFNKSHANDLER) TRUE,                // GetSupported
     sizeof (KSNODEPROPERTY),          // MinProperty
     sizeof (KSAC3_ALTERNATE_AUDIO),                  // MinData
     (PFNKSHANDLER) TRUE,               // SetSupported
     NULL,                               // PKSPROPERTY_VALUES Values
     0,                                  // RelationsCount
     NULL,                               // PKSPROPERTY Relations
     NULL,                               // PFNKSHANDLER SupportHandler
     0                                   // SerializedSize
    },

    {
     (ULONG) KSPROPERTY_AC3_DOWNMIX,  // PropertyId
     (PFNKSHANDLER) TRUE,                // GetSupported
     sizeof (KSNODEPROPERTY),          // MinProperty
     sizeof (KSAC3_DOWNMIX),                  // MinData
     (PFNKSHANDLER) TRUE,               // SetSupported
     NULL,                               // PKSPROPERTY_VALUES Values
     0,                                  // RelationsCount
     NULL,                               // PKSPROPERTY Relations
     NULL,                               // PFNKSHANDLER SupportHandler
     0                                   // SerializedSize
    },

    {
     (ULONG) KSPROPERTY_AC3_BIT_STREAM_MODE,  // PropertyId
     (PFNKSHANDLER) TRUE,                // GetSupported
     sizeof (KSNODEPROPERTY),          // MinProperty
     sizeof (ULONG),                  // MinData
     (PFNKSHANDLER) TRUE,               // SetSupported
     NULL,                               // PKSPROPERTY_VALUES Values
     0,                                  // RelationsCount
     NULL,                               // PKSPROPERTY Relations
     NULL,                               // PFNKSHANDLER SupportHandler
     0                                   // SerializedSize
    },

    {
     (ULONG) KSPROPERTY_AC3_DIALOGUE_LEVEL,  // PropertyId
     (PFNKSHANDLER) TRUE,                // GetSupported
     sizeof (KSNODEPROPERTY),            // MinProperty
     sizeof (ULONG),                     // MinData
     (PFNKSHANDLER) TRUE,                // SetSupported
     NULL,                               // PKSPROPERTY_VALUES Values
     0,                                  // RelationsCount
     NULL,                               // PKSPROPERTY Relations
     NULL,                               // PFNKSHANDLER SupportHandler
     0                                   // SerializedSize
    },

    {
     (ULONG) KSPROPERTY_AC3_LANGUAGE_CODE,  // PropertyId
     (PFNKSHANDLER) TRUE,                // GetSupported
     sizeof (KSNODEPROPERTY),            // MinProperty
     sizeof (ULONG),                     // MinData
     (PFNKSHANDLER) TRUE,                // SetSupported
     NULL,                               // PKSPROPERTY_VALUES Values
     0,                                  // RelationsCount
     NULL,                               // PKSPROPERTY Relations
     NULL,                               // PFNKSHANDLER SupportHandler
     0                                   // SerializedSize
    },

    {
     (ULONG) KSPROPERTY_AC3_ROOM_TYPE,   // PropertyId
     (PFNKSHANDLER) TRUE,                // GetSupported
     sizeof (KSNODEPROPERTY),            // MinProperty
     sizeof (BOOLEAN),                   // MinData
     (PFNKSHANDLER) TRUE,                // SetSupported
     NULL,                               // PKSPROPERTY_VALUES Values
     0,                                  // RelationsCount
     NULL,                               // PKSPROPERTY Relations
     NULL,                               // PFNKSHANDLER SupportHandler
     0                                   // SerializedSize
    }
};

static const KSPROPERTY_ITEM TopologyItm[]={
    {
     (ULONG) KSPROPERTY_TOPOLOGYNODE_ENABLE,  // PropertyId
     GetSetTopologyNodeEnable,           // GetSupported
     sizeof (KSNODEPROPERTY),            // MinProperty
     sizeof (BOOLEAN),                   // MinData
     GetSetTopologyNodeEnable,           // SetSupported
     NULL,                               // PKSPROPERTY_VALUES Values
     0,                                  // RelationsCount
     NULL,                               // PKSPROPERTY Relations
     NULL,                               // PFNKSHANDLER SupportHandler
     0                                   // SerializedSize
    }
};

static const KSPROPERTY_ITEM ConnectionItm[]={
  DEFINE_KSPROPERTY_ITEM_CONNECTION_ALLOCATORFRAMING(NULL)
};

static const KSPROPERTY_ITEM StreamItm[]={
  DEFINE_KSPROPERTY_ITEM_STREAM_ALLOCATOR(NULL,NULL)
};


// Property sets for individual node types

static const 
KSPROPERTY_ITEM VolumePropertyItem[]={
    {
     (ULONG) KSPROPERTY_AUDIO_VOLUMELEVEL,  // PropertyId
     GetSetVolumeLevel,                     // GetSupported
     sizeof (KSNODEPROPERTY_AUDIO_CHANNEL), // MinProperty
     sizeof (ULONG),                     // MinData
     GetSetVolumeLevel,                  // SetSupported
     NULL,                               // PKSPROPERTY_VALUES Values
     0,                                  // RelationsCount
     NULL,                               // PKSPROPERTY Relations
     GetBasicSupport,                    // PFNKSHANDLER SupportHandler
     0                                   // SerializedSize
    }
};

static const 
KSPROPERTY_ITEM MutePropertyItem[]={
    {
     (ULONG) KSPROPERTY_AUDIO_MUTE,  // PropertyId
     GetSetBoolean,                     // GetSupported
     sizeof (KSNODEPROPERTY_AUDIO_CHANNEL), // MinProperty
     sizeof (ULONG),                     // MinData
     GetSetBoolean,                      // SetSupported
     NULL,                               // PKSPROPERTY_VALUES Values
     0,                                  // RelationsCount
     NULL,                               // PKSPROPERTY Relations
     GetBasicSupportBoolean,             // PFNKSHANDLER SupportHandler
     0                                   // SerializedSize
    }
};

static const 
KSPROPERTY_ITEM BassPropertyItem[]={
    {
     (ULONG) KSPROPERTY_AUDIO_BASS,  // PropertyId
     GetSetToneLevel,                     // GetSupported
     sizeof (KSNODEPROPERTY_AUDIO_CHANNEL), // MinProperty
     sizeof (ULONG),                     // MinData
     GetSetToneLevel,                         // SetSupported
     NULL,                               // PKSPROPERTY_VALUES Values
     0,                                  // RelationsCount
     NULL,                               // PKSPROPERTY Relations
     GetBasicSupport,                    // PFNKSHANDLER SupportHandler
     0                                   // SerializedSize
    }
};

static const 
KSPROPERTY_ITEM TreblePropertyItem[]={
    {
     (ULONG) KSPROPERTY_AUDIO_TREBLE,  // PropertyId
     GetSetToneLevel,                     // GetSupported
     sizeof (KSNODEPROPERTY_AUDIO_CHANNEL), // MinProperty
     sizeof (ULONG),                     // MinData
     GetSetToneLevel,                         // SetSupported
     NULL,                               // PKSPROPERTY_VALUES Values
     0,                                  // RelationsCount
     NULL,                               // PKSPROPERTY Relations
     GetBasicSupport,                    // PFNKSHANDLER SupportHandler
     0                                   // SerializedSize
    }
};

static const 
KSPROPERTY_ITEM MidrangePropertyItem[]={
    {
     (ULONG) KSPROPERTY_AUDIO_MID,  // PropertyId
     GetSetToneLevel,                     // GetSupported
     sizeof (KSNODEPROPERTY_AUDIO_CHANNEL), // MinProperty
     sizeof (ULONG),                     // MinData
     GetSetToneLevel,                         // SetSupported
     NULL,                               // PKSPROPERTY_VALUES Values
     0,                                  // RelationsCount
     NULL,                               // PKSPROPERTY Relations
     GetBasicSupport,                    // PFNKSHANDLER SupportHandler
     0                                   // SerializedSize
    }
};

static const 
KSPROPERTY_ITEM BassBoostPropertyItem[]={
    {
     (ULONG) KSPROPERTY_AUDIO_BASS_BOOST, // PropertyId
     GetSetBoolean,                      // GetSupported
     sizeof (KSNODEPROPERTY_AUDIO_CHANNEL), // MinProperty
     sizeof (ULONG),                     // MinData
     GetSetBoolean,                      // SetSupported
     NULL,                               // PKSPROPERTY_VALUES Values
     0,                                  // RelationsCount
     NULL,                               // PKSPROPERTY Relations
     NULL,                               // PFNKSHANDLER SupportHandler
     0                                   // SerializedSize
    }
};

static const 
KSPROPERTY_ITEM EqualizerPropertyItems[]={
    {
     (ULONG) KSPROPERTY_AUDIO_EQ_LEVEL,  // PropertyId
     GetSetEqualizerLevels,              // GetSupported
     sizeof (KSNODEPROPERTY_AUDIO_CHANNEL), // MinProperty
     sizeof (ULONG),                     // MinData
     GetSetEqualizerLevels,              // SetSupported
     NULL,                               // PKSPROPERTY_VALUES Values
     0,                                  // RelationsCount
     NULL,                               // PKSPROPERTY Relations
     GetBasicSupport,                    // PFNKSHANDLER SupportHandler
     0                                   // SerializedSize
    },

    {
     (ULONG) KSPROPERTY_AUDIO_NUM_EQ_BANDS, // PropertyId
     GetNumEqualizerBands,               // GetSupported
     sizeof (KSNODEPROPERTY_AUDIO_CHANNEL),  // MinProperty
     sizeof (ULONG),                     // MinData
     GetNumEqualizerBands,               // SetSupported
     NULL,                               // PKSPROPERTY_VALUES Values
     0,                                  // RelationsCount
     NULL,                               // PKSPROPERTY Relations
     NULL,                               // PFNKSHANDLER SupportHandler
     0                                   // SerializedSize
    },

    {
     (ULONG) KSPROPERTY_AUDIO_EQ_BANDS,  // PropertyId
     GetEqualizerBands,                  // GetSupported
     sizeof (KSNODEPROPERTY_AUDIO_CHANNEL), // MinProperty
     sizeof (ULONG),                     // MinData
     GetEqualizerBands,                  // SetSupported
     NULL,                               // PKSPROPERTY_VALUES Values
     0,                                  // RelationsCount
     NULL,                               // PKSPROPERTY Relations
     NULL,                               // PFNKSHANDLER SupportHandler
     0                                   // SerializedSize
    }
};

static const 
KSPROPERTY_ITEM MixerPropertyItems[]={
    {
     (ULONG) KSPROPERTY_AUDIO_MIX_LEVEL_TABLE, // PropertyId
     GetSetMixLevels,                    // GetSupported
     sizeof (KSNODEPROPERTY),            // MinProperty
     sizeof (KSAUDIO_MIXLEVEL),          // MinData
     GetSetMixLevels,                    // SetSupported
     NULL,                               // PKSPROPERTY_VALUES Values
     0,                                  // RelationsCount
     NULL,                               // PKSPROPERTY Relations
     NULL,                               // PFNKSHANDLER SupportHandler
     0                                   // SerializedSize
    },

    {
     (ULONG) KSPROPERTY_AUDIO_MIX_LEVEL_CAPS, // PropertyId
     GetSetMixLevels,                    // GetSupported
     sizeof (KSNODEPROPERTY),            // MinProperty
     sizeof (ULONG) + sizeof(ULONG),     // MinData
     NULL,                               // SetSupported
     NULL,                               // PKSPROPERTY_VALUES Values
     0,                                  // RelationsCount
     NULL,                               // PKSPROPERTY Relations
     NULL,                               // PFNKSHANDLER SupportHandler
     0                                   // SerializedSize
    }
};

static const 
KSPROPERTY_ITEM AGCPropertyItem[]={
    {
     (ULONG) KSPROPERTY_AUDIO_AGC,       // PropertyId
     GetSetBoolean,                      // GetSupported
     sizeof (KSNODEPROPERTY_AUDIO_CHANNEL), // MinProperty
     sizeof (ULONG),                     // MinData
     GetSetBoolean,                      // SetSupported
     NULL,                               // PKSPROPERTY_VALUES Values
     0,                                  // RelationsCount
     NULL,                               // PKSPROPERTY Relations
     NULL,                               // PFNKSHANDLER SupportHandler
     0                                   // SerializedSize
    }
};

static const 
KSPROPERTY_ITEM MuxPropertyItem[]={
    {
     (ULONG) KSPROPERTY_AUDIO_MUX_SOURCE, // PropertyId
     GetMuxSource,                       // GetSupported
     sizeof (KSNODEPROPERTY),            // MinProperty
     sizeof (ULONG),                     // MinData
     SetMuxSource,                       // SetSupported
     NULL,                               // PKSPROPERTY_VALUES Values
     0,                                  // RelationsCount
     NULL,                               // PKSPROPERTY Relations
     NULL,                               // PFNKSHANDLER SupportHandler
     0                                   // SerializedSize
    }
};

static const 
KSPROPERTY_ITEM LoudnessPropertyItem[]={
    {
     (ULONG) KSPROPERTY_AUDIO_LOUDNESS,  // PropertyId
     GetSetBoolean,                      // GetSupported
     sizeof (KSNODEPROPERTY_AUDIO_CHANNEL), // MinProperty
     sizeof (ULONG),                     // MinData
     GetSetBoolean,                      // SetSupported
     NULL,                               // PKSPROPERTY_VALUES Values
     0,                                  // RelationsCount
     NULL,                               // PKSPROPERTY Relations
     NULL,                               // PFNKSHANDLER SupportHandler
     0                                   // SerializedSize
    },
};

/*
static const
KSPROPERTY_ITEM ChannelConfigPropertyItem[]={
    {
     (ULONG) KSPROPERTY_AUDIO_LOUDNESS,  // PropertyId
     GetSetChannelConfig,                // GetSupported
     sizeof (KSNODEPROPERTY),            // MinProperty
     sizeof (ULONG),                     // MinData
     GetSetChannelConfig,                // SetSupported
     NULL,                               // PKSPROPERTY_VALUES Values
     0,                                  // RelationsCount
     NULL,                               // PKSPROPERTY Relations
     NULL,                               // PFNKSHANDLER SupportHandler
     0                                   // SerializedSize
    },
};
*/

static DEFINE_KSPROPERTY_SET_TABLE(NodePropertySetTable)
{
    DEFINE_KSPROPERTY_SET( &GUID_NULL,                     // NODE_TYPE_NONE
                           0,
                           NULL,
                           0, NULL ),

    DEFINE_KSPROPERTY_SET( &GUID_NULL,                     // NODE_TYPE_DAC
                           0,
                           NULL,
                           0, NULL ),

    DEFINE_KSPROPERTY_SET( &GUID_NULL,                     // NODE_TYPE_ADC
                           0,
                           NULL,
                           0, NULL ),

    DEFINE_KSPROPERTY_SET( &GUID_NULL,                     // NODE_TYPE_SRC
                           0,
                           NULL,
                           0, NULL ),

    DEFINE_KSPROPERTY_SET( &KSPROPSETID_Audio,             // NODE_TYPE_SUPERMIX
                           SIZEOF_ARRAY(MixerPropertyItems),
                           (PVOID) MixerPropertyItems,
                           0, NULL),

    DEFINE_KSPROPERTY_SET( &KSPROPSETID_Audio,             // NODE_TYPE_MUX
                           SIZEOF_ARRAY(MuxPropertyItem),
                           (PVOID) MuxPropertyItem,
                           0, NULL),

    DEFINE_KSPROPERTY_SET( &GUID_NULL,                     // NODE_TYPE_SUM
                           0,
                           NULL,
                           0, NULL ),

    DEFINE_KSPROPERTY_SET( &KSPROPSETID_Audio,             // NODE_TYPE_MUTE
                           SIZEOF_ARRAY(MutePropertyItem),
                           (PVOID) MutePropertyItem,
                           0, NULL ),

    DEFINE_KSPROPERTY_SET( &KSPROPSETID_Audio,             // NODE_TYPE_VOLUME
                           SIZEOF_ARRAY(VolumePropertyItem),
                           (PVOID) VolumePropertyItem,
                           0, NULL ),

    DEFINE_KSPROPERTY_SET( &KSPROPSETID_Audio,             // NODE_TYPE_BASS
                           SIZEOF_ARRAY(BassPropertyItem),
                           (PVOID) BassPropertyItem,
                           0, NULL ),

    DEFINE_KSPROPERTY_SET( &KSPROPSETID_Audio,             // NODE_TYPE_MID
                           SIZEOF_ARRAY(MidrangePropertyItem),
                           (PVOID) MidrangePropertyItem,
                           0, NULL ),

    DEFINE_KSPROPERTY_SET( &KSPROPSETID_Audio,             // NODE_TYPE_TREBLE
                           SIZEOF_ARRAY(TreblePropertyItem),
                           (PVOID) TreblePropertyItem,
                           0, NULL ),

    DEFINE_KSPROPERTY_SET( &KSPROPSETID_Audio,            // NODE_TYPE_BASS_BOOST
                           SIZEOF_ARRAY(BassBoostPropertyItem),
                           (PVOID) BassBoostPropertyItem,
                           0, NULL ),

    DEFINE_KSPROPERTY_SET( &KSPROPSETID_Audio,            // NODE_TYPE_EQUALIZER
                           SIZEOF_ARRAY(EqualizerPropertyItems),
                           (PVOID) EqualizerPropertyItems,
                           0, NULL ),

    DEFINE_KSPROPERTY_SET( &KSPROPSETID_Audio,            // NODE_TYPE_AGC
                           SIZEOF_ARRAY(AGCPropertyItem),
                           (PVOID) AGCPropertyItem,
                           0, NULL ),

    DEFINE_KSPROPERTY_SET( &GUID_NULL,                     // NODE_TYPE_DELAY
                           0,
                           NULL,
                           0, NULL ),

    DEFINE_KSPROPERTY_SET( &KSPROPSETID_Audio,             // NODE_TYPE_LOUDNESS
                           SIZEOF_ARRAY(LoudnessPropertyItem),
                           (PVOID) LoudnessPropertyItem,
                           0, NULL ),

    DEFINE_KSPROPERTY_SET( &GUID_NULL,                     // NODE_TYPE_DELAY
                           0,
                           NULL,
                           0, NULL ),

    DEFINE_KSPROPERTY_SET( &GUID_NULL,                     // NODE_TYPE_PROLOGIC
                           0,
                           NULL,
                           0, NULL ),

    DEFINE_KSPROPERTY_SET( &GUID_NULL,                     // NODE_TYPE_STEREO_WIDE
                           0,
                           NULL,
                           0, NULL ),

    DEFINE_KSPROPERTY_SET( &GUID_NULL,                     // NODE_TYPE_REVERB
                           0,
                           NULL,
                           0, NULL ),

    DEFINE_KSPROPERTY_SET( &GUID_NULL,                     // NODE_TYPE_CHORUS
                           0,
                           NULL,
                           0, NULL ),

    DEFINE_KSPROPERTY_SET( &GUID_NULL,                     // NODE_TYPE_DEV_SPEC
                           0,
                           NULL,
                           0, NULL ),

    DEFINE_KSPROPERTY_SET( &GUID_NULL,                     // KSPROPERTY_AUDIO_DEMUX_DEST
                           0,
                           NULL,
                           0, NULL )

/*
KSPROPERTY_AUDIO_STEREO_ENHANCE,
KSPROPERTY_AUDIO_MANUFACTURE_GUID,
KSPROPERTY_AUDIO_PRODUCT_GUID,
KSPROPERTY_AUDIO_CPU_RESOURCES,
KSPROPERTY_AUDIO_STEREO_SPEAKER_GEOMETRY,
KSPROPERTY_AUDIO_SURROUND_ENCODE,
KSPROPERTY_AUDIO_3D_INTERFACE,
KSPROPERTY_AUDIO_PEAKMETER,
KSPROPERTY_AUDIO_ALGORITHM_INSTANCE,
KSPROPERTY_AUDIO_FILTER_STATE,
KSPROPERTY_AUDIO_PREFERRED_STATUS
*/
};


// DRM
DEFINE_KSPROPERTY_TABLE(DrmAudioStreamPropertyItems) {
    DEFINE_KSPROPERTY_ITEM (
        KSPROPERTY_DRMAUDIOSTREAM_CONTENTID,            // idProperty
        NULL,                                           // pfnGetHandler
        sizeof(KSP_DRMAUDIOSTREAM_CONTENTID),           // cbMinGetPropertyInput
        sizeof(KSDRMAUDIOSTREAM_CONTENTID),             // cbMinGetDataInput
        DrmAudioStream_SetContentId,                    // pfnSetHandler
        0,                                              // Values
        0,                                              // RelationsCount
        NULL,                                           // Relations
        NULL,                                           // SupportHandler
        0                                               // SerializedSize
    )
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\drivers\avcaudio\registry.c ===
#include "Common.h"

#define AVC_VIRTUAL_DEVICE_KEY L"Virtual1394Device"
#define SPEAKER_GROUP_ID  L"AudioGroupGUID"
#define SPEAKER_GROUP_CFG L"AudioGroupConfig"

PSZ
DbgUnicode2Sz(
    PWSTR pwstr )
{
    static char sz[256];
    UNICODE_STRING UnicodeString;
    ANSI_STRING AnsiString;

    sz[0] = '\0';
    if(pwstr != NULL) {
        RtlInitUnicodeString(&UnicodeString, pwstr);
        RtlInitAnsiString(&AnsiString, sz);
        AnsiString.MaximumLength = sizeof(sz);
        RtlUnicodeStringToAnsiString(&AnsiString, &UnicodeString, FALSE);
    }
    return(sz);
}

NTSTATUS
OpenDeviceInterface(
    PWSTR pwstrDevice,
    PHANDLE pHandle )
{
    IO_STATUS_BLOCK IoStatusBlock;
    UNICODE_STRING UnicodeDeviceString;
    OBJECT_ATTRIBUTES ObjectAttributes;

    _DbgPrintF( DEBUGLVL_VERBOSE, ("OpenDeviceInterface: (%s) \n", DbgUnicode2Sz(pwstrDevice)));

    RtlInitUnicodeString(&UnicodeDeviceString, pwstrDevice);

    InitializeObjectAttributes(
        &ObjectAttributes,
        &UnicodeDeviceString,
        OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,
        NULL,
        NULL);

    return( ZwCreateFile( pHandle,
                GENERIC_READ | GENERIC_WRITE,
                &ObjectAttributes,
                &IoStatusBlock,
                NULL,
                FILE_ATTRIBUTE_NORMAL,
                0,
                FILE_OPEN,
                0,
                NULL,
                0));
}


static NTSTATUS
RegistryOpenKey(
    PCWSTR pcwstr,
    PHANDLE pHandle,
    HANDLE hRootDir )
{
    UNICODE_STRING UnicodeDeviceString;
    OBJECT_ATTRIBUTES ObjectAttributes;

    RtlInitUnicodeString(&UnicodeDeviceString, pcwstr);

    InitializeObjectAttributes(
      &ObjectAttributes,
      &UnicodeDeviceString,
      OBJ_CASE_INSENSITIVE,
      hRootDir,
      NULL);

    return(ZwOpenKey(
      pHandle,
      KEY_READ | KEY_NOTIFY | KEY_WRITE,
      &ObjectAttributes));
}

NTSTATUS
RegistryQueryValue(
    HANDLE hkey,
    PCWSTR pcwstrValueName,
    PKEY_VALUE_FULL_INFORMATION *ppkvfi )
{
    UNICODE_STRING ustrValueName;
    NTSTATUS Status;
    ULONG cbValue;

    *ppkvfi = NULL;
    RtlInitUnicodeString(&ustrValueName, pcwstrValueName);
    Status = ZwQueryValueKey(
      hkey,
      &ustrValueName,
      KeyValueFullInformation,
      NULL,
      0,
      &cbValue);

    if(Status != STATUS_BUFFER_OVERFLOW &&
       Status != STATUS_BUFFER_TOO_SMALL) {
        goto exit;
    }

    *ppkvfi = (PKEY_VALUE_FULL_INFORMATION)AllocMem(PagedPool, cbValue);
    if(*ppkvfi == NULL) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto exit;
    }

    Status = ZwQueryValueKey(
      hkey,
      &ustrValueName,
      KeyValueFullInformation,
      *ppkvfi,
      cbValue,
      &cbValue);

    if(!NT_SUCCESS(Status)) {
        FreeMem( *ppkvfi );
        *ppkvfi = NULL;
        goto exit;
    }
exit:
    return(Status);
}

NTSTATUS
RegistryReadMultiDeviceConfig(
    PKSDEVICE pKsDevice,
    PBOOLEAN pfMultiDevice,
    GUID *pSpkrGrpGUID,
    PULONG pChannelConfig )
{
    PKEY_VALUE_FULL_INFORMATION pkvfi = NULL;
    HANDLE hRootHandle;
    NTSTATUS ntStatus;
    UNICODE_STRING ustrGUID;
    PCWSTR pGuidString;

    _DbgPrintF(DEBUGLVL_VERBOSE, ("[RegistryReadMultiDeviceConfig] Enter\n"));

    *pfMultiDevice  = FALSE;
    *pChannelConfig = 0;

    // Determine if this is a virtual device instance
    ntStatus = IoOpenDeviceRegistryKey(
        pKsDevice->NextDeviceObject,
        PLUGPLAY_REGKEY_DEVICE,
        KEY_READ,
        &hRootHandle );

    if ( NT_SUCCESS(ntStatus) ) {
        ntStatus = RegistryQueryValue( hRootHandle, SPEAKER_GROUP_ID, &pkvfi );
        if ( NT_SUCCESS(ntStatus) ) {
            pGuidString = (PCWSTR)(((PUCHAR)pkvfi) + pkvfi->DataOffset);
            RtlInitUnicodeString(&ustrGUID, pGuidString);
            ntStatus = RtlGUIDFromString( &ustrGUID, pSpkrGrpGUID );
            FreeMem(pkvfi);
            ntStatus = RegistryQueryValue( hRootHandle, SPEAKER_GROUP_CFG, &pkvfi );
            if ( NT_SUCCESS(ntStatus) ) {
                if( pkvfi->Type == REG_DWORD ) {
                    *pfMultiDevice = TRUE;
                    *pChannelConfig = *((PULONG)(((PUCHAR)pkvfi) + pkvfi->DataOffset));
                }
                else {
                    ntStatus = STATUS_INVALID_PARAMETER;
                }
                FreeMem(pkvfi);
            }
        }
    }

    _DbgPrintF(DEBUGLVL_VERBOSE, ("[RegistryReadMultiDeviceConfig] Leave Status; %x\n",ntStatus));
    return ntStatus;
}


NTSTATUS
RegistryReadVirtualDeviceEntry(
    PKSDEVICE pKsDevice,
    PBOOLEAN pfVirtualDevice )
{
    HANDLE hRootHandle;
    NTSTATUS ntStatus;

    *pfVirtualDevice = FALSE;

    // Determine if this is a virtual device instance
    ntStatus = IoOpenDeviceRegistryKey(
        pKsDevice->NextDeviceObject,
        PLUGPLAY_REGKEY_DRIVER,
        KEY_ALL_ACCESS,
        &hRootHandle );

    if (NT_SUCCESS(ntStatus)) {
        OBJECT_ATTRIBUTES DeviceAttributes;
        HANDLE hDevHandle;
        UNICODE_STRING uniName;

        // Determine whether this is a virtual device
        RtlInitUnicodeString( &uniName, AVC_VIRTUAL_DEVICE_KEY );

        InitializeObjectAttributes(
            &DeviceAttributes,
            &uniName,
            OBJ_CASE_INSENSITIVE,
            hRootHandle,
            NULL);

        // Try to access the virtual device list key
        ntStatus = ZwOpenKey(
            &hDevHandle,
            KEY_ALL_ACCESS,
            &DeviceAttributes );

        if ( NT_SUCCESS(ntStatus) ) {

            _DbgPrintF(DEBUGLVL_VERBOSE, ("fVirtualSubunitFlag = TRUE\n"));
            *pfVirtualDevice = TRUE;
            ZwClose(hDevHandle);
        }
        else {
            ntStatus = STATUS_SUCCESS;
        }

        ZwClose(hRootHandle);
    }
    else {
        _DbgPrintF(DEBUGLVL_VERBOSE, ("IoOpenDeviceRegistryKey Failed!"));
        TRAP;
    }

    return ntStatus;
}

NTSTATUS
RegistryReadVirtualizeKey(
    PUNICODE_STRING pustrFilterName,
    PULONG pVirtualizeFlag )
{
    PKEY_VALUE_FULL_INFORMATION pkvfi = NULL;
    HANDLE hkeyDeviceClass = NULL;
    HANDLE hkeyValue = NULL;
    NTSTATUS ntStatus;

    ntStatus = IoOpenDeviceInterfaceRegistryKey( pustrFilterName,
                                                 KEY_READ ,
                                                 &hkeyDeviceClass );

    if ( NT_SUCCESS(ntStatus) ) {
#if 0
        HANDLE hKeyHandle;
        OBJECT_ATTRIBUTES DeviceAttributes;
        HANDLE hDevHandle;
        UNICODE_STRING uniName;

        RtlInitUnicodeString(&uniName, AVC_VIRTUAL_DEVICE_KEY);

        InitializeObjectAttributes(
            &DeviceAttributes,
            &uniName,
            OBJ_CASE_INSENSITIVE,
            hkeyDeviceClass,
            NULL);

        ntStatus = ZwCreateKey( &hKeyHandle,  
                                KEY_ALL_ACCESS,
                                &DeviceAttributes,
                                0L,
                                NULL,
                                REG_OPTION_NON_VOLATILE,
                                NULL );
        _DbgPrintF( DEBUGLVL_VERBOSE, ("Key Created Status: %x\n",ntStatus));
        if ( NT_SUCCESS(ntStatus) ) {
            ZwClose(hKeyHandle);
        }
        TRAP;
#endif
        ntStatus = RegistryOpenKey( AVC_VIRTUAL_DEVICE_KEY, &hkeyValue, hkeyDeviceClass );
        if ( NT_SUCCESS(ntStatus) ) {
            ntStatus = RegistryQueryValue( hkeyValue, L"Enabled", &pkvfi );
            if ( NT_SUCCESS(ntStatus) ) {
                if( pkvfi->Type == REG_DWORD ) {
                    ntStatus = STATUS_SUCCESS;
                    *pVirtualizeFlag = *((PULONG)(((PUCHAR)pkvfi) + pkvfi->DataOffset));
                }
                else {
                    ntStatus = STATUS_INVALID_PARAMETER;
                }
                FreeMem( pkvfi );
            }
        }
    }

    if ( hkeyDeviceClass )
        ZwClose( hkeyDeviceClass );

    if ( hkeyValue )
        ZwClose( hkeyValue );

    return ntStatus;

}

/*
NTSTATUS
GetLocalDeviceObjects( 
    PWSTR *pwstrDeviceInterface,
    PFILE_OBJECT *pFileObject,
    PDEVICE_OBJECT *pDeviceObject )
{
    PPNP_NOTIFICATION_INFO pPnPNotificationInfo;
    UNICODE_STRING ustrInterfaceName;
    NTSTATUS ntStatus = STATUS_SUCCESS;
    KIRQL KIrql;

    KeAcquireSpinLock( &AvcSubunitGlobalInfo.AvcGlobalInfoSpinlock, &KIrql);
    if ( !IsListEmpty(&AvcSubunitGlobalInfo.DeviceInterfaceSymlinkList) ) {
        pPnPNotificationInfo = (PPNP_NOTIFICATION_INFO)
            RemoveHeadList(&AvcSubunitGlobalInfo.DeviceInterfaceSymlinkList);
    }
    else {
        ntStatus = STATUS_NO_MORE_ENTRIES;
    }
    KeReleaseSpinLock( &AvcSubunitGlobalInfo.AvcGlobalInfoSpinlock, KIrql);

    _DbgPrintF( DEBUGLVL_VERBOSE, ("pPnPNotificationInfo: %x Status: %x\n",
                                   pPnPNotificationInfo, ntStatus ));

    if ( NT_SUCCESS(ntStatus) ) {
        *pwstrDeviceInterface = pPnPNotificationInfo->pwstrDeviceInterface;
        RtlInitUnicodeString( &ustrInterfaceName, *pwstrDeviceInterface );
        ntStatus = IoGetDeviceObjectPointer( &ustrInterfaceName,
                                             FILE_READ_DATA | FILE_WRITE_DATA,
                                             pFileObject, pDeviceObject );
        FreeMem(pPnPNotificationInfo);
    }

    return ntStatus;
}
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\drivers\avcaudio\timer.c ===
#include "Common.h"

#ifdef PSEUDO_HID

extern VOID
HwEventGenerateOnNode(
    PKSDEVICE pKsDevice,
    PULONG pNodeId );

VOID
TimerGetControlChanges(
    PKSDEVICE pKsDevice )
{
    PHW_DEVICE_EXTENSION pHwDevExt = pKsDevice->Context;
    PTOPOLOGY_NODE_INFO pNodeInfo = (PTOPOLOGY_NODE_INFO)pHwDevExt->KsFilterDescriptor.NodeDescriptors;
    ULONG ulNodeCount = pHwDevExt->KsFilterDescriptor.NodeDescriptorsCount;
    ULONG i;

    if ( pHwDevExt->ulFilterCount ) {
        // If a node is eventable, check the control's current value and send event if changed.
        for ( i=0; i<ulNodeCount; i++ ) {
            if ( pNodeInfo[i].fEventable && pNodeInfo[i].ulEventsEnabled ) {
                BOOLEAN bControlChange = FALSE;
                // Poll the device's control level
//                _DbgPrintF( DEBUGLVL_VERBOSE, ("[TimerGetControlChanges] Node %d\n", i) );
                pNodeInfo[i].pCacheUpdateRtn( pKsDevice, &pNodeInfo[i], &bControlChange );
                if ( bControlChange ) {
                    HwEventGenerateOnNode( pKsDevice, &i );
                }
            }
        }
    }
}

VOID
TimerWorkItem(
    PKSDEVICE pKsDevice )
{
    PHW_DEVICE_EXTENSION pHwDevExt = pKsDevice->Context;
    PAVC_UNIT_INFORMATION pUnitInfo = pHwDevExt->pAvcUnitInformation;
    BOOLEAN bPowerStateChange = FALSE;
    AVC_BOOLEAN bPowerState = AVC_ON;
    NTSTATUS ntStatus;
    KIRQL kIrql;

    if ( pHwDevExt->fSurpriseRemoved ) goto exit;

    // Need to check all control values if the node events are enabled.

    // Check Power if device allows. We need to add or remove filter factories
    // if the power comes on/off
    if ( pUnitInfo->fAvcCapabilities[AVC_CAP_POWER].fStatus ) {
        ntStatus = AvcPower( pKsDevice, TRUE, AVC_CTYPE_STATUS, &bPowerState );
        if ( NT_SUCCESS(ntStatus) ) {
            if ( bPowerState != pUnitInfo->bPowerState ) {
                _DbgPrintF( DEBUGLVL_TERSE, ("Power State Change: From: %x To: %x\n",
                                             pUnitInfo->bPowerState, bPowerState) );
                bPowerStateChange = TRUE;
                pUnitInfo->bPowerState = bPowerState;
            }
        }
    }

    if ( bPowerStateChange ) {
        if ( bPowerState == AVC_OFF ) {
            // Destroy Filter Factory
            ntStatus = FilterDestroyFilterFactory( pKsDevice );
            _DbgPrintF( DEBUGLVL_TERSE, ("Destroyed Filter Factory Status: %x\n", ntStatus ));
        }
        else {
            // Create Filter Factory
            ntStatus = FilterCreateFilterFactory( pKsDevice, TRUE );
            _DbgPrintF( DEBUGLVL_TERSE, ("Created Filter Factory Status: %x\n", ntStatus ));
        }
    }

    if ( bPowerState == AVC_ON ) {
        // Check for control changes.
        TimerGetControlChanges( pKsDevice );
    }

exit:
    KeAcquireSpinLock( &pHwDevExt->TimerSpinLock, &kIrql );
    pHwDevExt->bTimerWorkItemQueued = FALSE;
    KeSetEvent( &pHwDevExt->kTimerWIEvent, 0, FALSE );
    KeReleaseSpinLock( &pHwDevExt->TimerSpinLock, kIrql );
    
}

VOID
TimerDPCCallBack(
    IN struct _KDPC *Dpc,
    IN PKSDEVICE pKsDevice,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2 )
{
    PHW_DEVICE_EXTENSION pHwDevExt = pKsDevice->Context;

    // Queue a work item to check power and control levels if not already queued.
    KeAcquireSpinLockAtDpcLevel( &pHwDevExt->TimerSpinLock );
    if ( !pHwDevExt->bTimerWorkItemQueued ) {
        pHwDevExt->bTimerWorkItemQueued = TRUE;
        KeReleaseSpinLockFromDpcLevel(&pHwDevExt->TimerSpinLock);
        ExQueueWorkItem( &pHwDevExt->TimerWorkItem, DelayedWorkQueue );
    }
    else {
        KeReleaseSpinLockFromDpcLevel(&pHwDevExt->TimerSpinLock);
    }
}

NTSTATUS
TimerInitialize(
    PKSDEVICE pKsDevice )
{
    PHW_DEVICE_EXTENSION pHwDevExt = pKsDevice->Context;
    PKTIMER pKTimer = &pHwDevExt->kTimer;
    PKDPC pKDpc = &pHwDevExt->TimerDPC;
    BOOLEAN bResult;
    LARGE_INTEGER  LITime;

    _DbgPrintF( DEBUGLVL_VERBOSE, ("[TimerInitialize]WI ADDR %x TimerDPCCallBack: %x\n",
                                 TimerWorkItem, TimerDPCCallBack ) );

    ExInitializeWorkItem( &pHwDevExt->TimerWorkItem, TimerWorkItem, pKsDevice );

    KeInitializeSpinLock( &pHwDevExt->TimerSpinLock );

    KeInitializeDpc( pKDpc, TimerDPCCallBack, pKsDevice );

    KeInitializeTimer(pKTimer);

    KeInitializeEvent( &pHwDevExt->kTimerWIEvent, SynchronizationEvent, FALSE );

    pHwDevExt->bTimerWorkItemQueued = FALSE;

    LITime.QuadPart = -10000000;
    bResult = KeSetTimerEx( pKTimer, LITime, 500, pKDpc );

    return STATUS_SUCCESS;

}

NTSTATUS
TimerStop( 
    PHW_DEVICE_EXTENSION pHwDevExt )
{
    NTSTATUS ntStatus = STATUS_UNSUCCESSFUL;
    KIRQL kIrql;
    BOOLEAN bResult = KeCancelTimer( &pHwDevExt->kTimer );

    if ( bResult ) ntStatus = STATUS_SUCCESS;

    _DbgPrintF( DEBUGLVL_VERBOSE, ( "Timer Cancelled: %x bTimerWorkItemQueued %x\n",
                                   bResult, pHwDevExt->bTimerWorkItemQueued));
    
    KeAcquireSpinLock( &pHwDevExt->TimerSpinLock, &kIrql );
    if ( pHwDevExt->bTimerWorkItemQueued ) {
        KeResetEvent( &pHwDevExt->kTimerWIEvent );
        KeReleaseSpinLock( &pHwDevExt->TimerSpinLock, kIrql );
        KeWaitForSingleObject( &pHwDevExt->kTimerWIEvent,
                               Executive,
                               KernelMode,
                               FALSE,
                               NULL );
    }
    else
        KeReleaseSpinLock( &pHwDevExt->TimerSpinLock, kIrql );

    return ntStatus;

}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\drivers\avcaudio\topology.c ===
#include "Common.h"

#include "nameguid.h"
#include "HwEvent.h"

#if DBG
char CntrlStrings[13][28] = { 
"Wrong",
"MUTE_CONTROL",
"VOLUME_CONTROL",
"LR_BALANCE_CONTROL",
"FR_BALANCE_CONTROL",
"BASS_CONTROL",
"MID_CONTROL",
"TREBLE_CONTROL",
"GRAPHIC_EQUALIZER_CONTROL",
"AUTOMATIC_GAIN_CONTROL",
"DELAY_CONTROL",
"BASS_BOOST_CONTROL",
"LOUDNESS_CONTROL"
};
#endif

extern
NTSTATUS
UpdateDbLevelControlCache(
    PKSDEVICE pKsDevice,
    PTOPOLOGY_NODE_INFO pNodeInfo,
    PBOOLEAN pfChanged );

extern
NTSTATUS
UpdateBooleanControlCache(
    PKSDEVICE pKsDevice,
    PTOPOLOGY_NODE_INFO pNodeInfo,
    PBOOLEAN pfChanged );

static GUID AVCNODENAME_BassBoost = {STATIC_USBNODENAME_BassBoost};

// Map of Audio properties to nodes
// ULONG MapPropertyToNode[KSPROPERTY_AUDIO_3D_INTERFACE+1];

typedef
NTSTATUS
(*PFUNCTION_BLK_PROCESS_RTN)( PKSDEVICE pKsDevice,
                              PFUNCTION_BLOCK pFunctionBlock,
                              PTOPOLOGY_NODE_INFO pNodeDescriptors,
                              PKSTOPOLOGY_CONNECTION pConnections,
                              PULONG pNodeIndex,
                              PULONG pConnectionIndex );

ULONG
ConvertPinTypeToNodeType(
    PFW_PIN_DESCRIPTOR pFwPinDescriptor,
    GUID *TopologyNode,
    GUID *TopologyNodeName )
{
    ULONG NodeType = NODE_TYPE_NONE;

    if ( pFwPinDescriptor->fStreamingPin ) {
        // All endpoints support SRC
        *TopologyNode = KSNODETYPE_SRC;
        NodeType = NODE_TYPE_SRC;
    }
    else {

        switch ( pFwPinDescriptor->AvcPinDescriptor.PinDescriptor.DataFlow ) {
            case KSPIN_DATAFLOW_IN:
                *TopologyNode = KSNODETYPE_ADC;
                NodeType = NODE_TYPE_ADC;
                break;
            case KSPIN_DATAFLOW_OUT:
                *TopologyNode = KSNODETYPE_DAC;
                NodeType = NODE_TYPE_DAC;
                break;
            default:
                *TopologyNode = GUID_NULL;
                NodeType = NODE_TYPE_NONE;
                break;
            }
    }

    *TopologyNodeName = *TopologyNode;
    return NodeType;
}

#ifdef MASTER_FIX
NTSTATUS
TopologyNodesFromFeatureFBControls(
    PKSDEVICE pKsDevice,
    PFUNCTION_BLOCK pFunctionBlock,
    PTOPOLOGY_NODE_INFO pNodeInfo,
    PKSTOPOLOGY_CONNECTION pConnections,
    PULONG pNodeIndex,
    PULONG pConnectionIndex,
    BOOLEAN bMasterChannel,
    ULONG ulSourceNode )
{
    PHW_DEVICE_EXTENSION pHwDevExt = (PHW_DEVICE_EXTENSION)pKsDevice->Context;
    PKSTOPOLOGY_CONNECTION pConnection = pConnections + *pConnectionIndex;
    PFEATURE_FUNCTION_BLOCK pFeatureFBlk = (PFEATURE_FUNCTION_BLOCK)pFunctionBlock->pFunctionTypeInfo;

    ULONG ulConnectionsCount = *pConnectionIndex;
    ULONG ulNodeNumber       = *pNodeIndex;
    ULONG ulNumChannels      = (bMasterChannel) ? 1 : (ULONG)pFunctionBlock->pChannelCluster->ucNumberOfChannels;

    PULONG pChannelCntrls;
    ULONG ulCurControlChannels;
    ULONG ulMergedControls;
    ULONG ulCurrentControl;
    ULONG bmControls;
    ULONG i, j;

    _DbgPrintF( DEBUGLVL_VERBOSE, ("[TopologyNodesFromFeatureFB] 1: pFunctionBlock: %x, pNodeInfo: %x pConnection: %x Master Flag: %d\n",
                                     pFunctionBlock, pNodeInfo, pConnection, bMasterChannel ));
    _DbgPrintF( DEBUGLVL_VERBOSE, ("[TopologyNodesFromFeatureFB] 2: ulNodeNumber: %d\n", ulNodeNumber ));

    pChannelCntrls = (PULONG)AllocMem( NonPagedPool, ulNumChannels*sizeof(ULONG) );
    if ( !pChannelCntrls ) return STATUS_INSUFFICIENT_RESOURCES;

    // For the sake of simplicity, we create a super-set of all controls available on all channels.
    ulMergedControls = 0;

    if ( bMasterChannel ) {
        bmControls = 0;
        for ( j=0; j<pFeatureFBlk->ucControlSize; j++ ) {
            bmControls <<= 8;
            bmControls |= pFeatureFBlk->bmaControls[j];
        }

        pChannelCntrls[0] = bmControls;
        ulMergedControls  = bmControls;

#ifdef SUM_HACK
        if ( ulMergedControls ) {

            _DbgPrintF(DEBUGLVL_TERSE, ("SUM: pNode: %x, pConnection: %x Source: %x\n",
                                         &pNodeInfo[ulNodeNumber], pConnection, ulSourceNode ));

            // Insert a sum node
            pNodeInfo[ulNodeNumber].KsNodeDesc.Type = &KSNODETYPE_SUM;
            pNodeInfo[ulNodeNumber].KsNodeDesc.Name = &KSNODETYPE_SUM;
            pNodeInfo[ulNodeNumber].ulNodeType      = NODE_TYPE_SUM;

            // Make the connection
            pConnection->FromNode    = ulSourceNode;
            pConnection->FromNodePin = 0;
            pConnection->ToNode      = ulNodeNumber;
            pConnection->ToNodePin   = 1;
            pConnection++; ulConnectionsCount++;

            ulSourceNode = ( ABSOLUTE_NODE_FLAG | ulNodeNumber++ );
        }
#endif

    }
    else {
        for ( i=0; i<ulNumChannels; i++ ) {
            bmControls = 0;
            for ( j=0; j<pFeatureFBlk->ucControlSize; j++ ) {
                bmControls <<= 8;
                bmControls |= pFeatureFBlk->bmaControls[(i+1)*pFeatureFBlk->ucControlSize+j];
            }

            pChannelCntrls[i] = bmControls;
            ulMergedControls |= bmControls;
        }
    }

    if ( !ulMergedControls ) {
        FreeMem(pChannelCntrls);
        return STATUS_MEMBER_NOT_IN_GROUP;
    }

    while ( ulMergedControls ) {
        ulCurrentControl = ulMergedControls - (ulMergedControls & (ulMergedControls-1));
        ulMergedControls = (ulMergedControls & (ulMergedControls-1));

        pNodeInfo[ulNodeNumber].fMasterChannel = bMasterChannel;

        // Copy Block Id for easier parsing later
        pNodeInfo[ulNodeNumber].ulBlockId = pFunctionBlock->ulBlockId;

        // Determine which channels this control is valid for
        if ( bMasterChannel ) {
            ulCurControlChannels = 1;
            pNodeInfo[ulNodeNumber].ulChannelConfig = 1;
        }
        else {
            ulCurControlChannels = 0;
            pNodeInfo[ulNodeNumber].ulChannelConfig = 0;
        
            for ( i=0; i<ulNumChannels; i++ ) {

                if (pChannelCntrls[i] & ulCurrentControl) {
                    // Determine which Channel pChannelCntrls[i] reflects

                    // ISSUE-2001/01/10-dsisolak: Does not consider undefined channel configurations
                    ULONG ulTmpConfig  = (ULONG)bswapw(pFunctionBlock->pChannelCluster->usPredefinedChannelConfig);
                    ULONG ulCurChannel = ulTmpConfig - (ulTmpConfig & (ulTmpConfig-1));
  
                    ulCurControlChannels++;

                    for (j=0; j<i; j++) {
                        ulTmpConfig = (ulTmpConfig & (ulTmpConfig-1));
                        ulCurChannel = ulTmpConfig - (ulTmpConfig & (ulTmpConfig-1));
                    }

                    pNodeInfo[ulNodeNumber].ulChannelConfig |= ulCurChannel;
                }
            }

        }

        pNodeInfo[ulNodeNumber].ulChannels = ulCurControlChannels;

        // Make the connection
        pConnection->FromNode    = ulSourceNode;
        pConnection->FromNodePin = 0;
        pConnection->ToNode      = ulNodeNumber;
        pConnection->ToNodePin   = 1;
        pConnection++; ulConnectionsCount++;

        // Make the node
        pNodeInfo[ulNodeNumber].pFunctionBlk = pFunctionBlock;
        switch ( ulCurrentControl ) {
            case MUTE_FLAG:
                pNodeInfo[ulNodeNumber].KsNodeDesc.Type = &KSNODETYPE_MUTE;
                if ( bMasterChannel ) pNodeInfo[ulNodeNumber].KsNodeDesc.Name = &KSAUDFNAME_MASTER_MUTE;
                else                  pNodeInfo[ulNodeNumber].KsNodeDesc.Name = &KSNODETYPE_MUTE;
                pNodeInfo[ulNodeNumber].ulNodeType      = NODE_TYPE_MUTE;
                pNodeInfo[ulNodeNumber].ulControlType   = MUTE_CONTROL;
                pNodeInfo[ulNodeNumber].fEventable      = TRUE;
                pNodeInfo[ulNodeNumber].pCacheUpdateRtn = UpdateBooleanControlCache;
                break;

            case VOLUME_FLAG:
                pNodeInfo[ulNodeNumber].KsNodeDesc.Type = &KSNODETYPE_VOLUME;
                if ( bMasterChannel ) pNodeInfo[ulNodeNumber].KsNodeDesc.Name = &KSAUDFNAME_MASTER_VOLUME;
                else                  pNodeInfo[ulNodeNumber].KsNodeDesc.Name = &KSNODETYPE_VOLUME;
                pNodeInfo[ulNodeNumber].ulNodeType      = NODE_TYPE_VOLUME;
                pNodeInfo[ulNodeNumber].ulControlType   = VOLUME_CONTROL;
                pNodeInfo[ulNodeNumber].fEventable      = TRUE;
                pNodeInfo[ulNodeNumber].pCacheUpdateRtn = UpdateDbLevelControlCache;
                break;

            case BASS_BOOST_FLAG:
                pNodeInfo[ulNodeNumber].KsNodeDesc.Type = &KSNODETYPE_TONE;
                pNodeInfo[ulNodeNumber].KsNodeDesc.Name = &AVCNODENAME_BassBoost;
                pNodeInfo[ulNodeNumber].ulNodeType      = NODE_TYPE_BASS_BOOST;
                pNodeInfo[ulNodeNumber].ulControlType   = BASS_BOOST_CONTROL;
                pNodeInfo[ulNodeNumber].fEventable      = TRUE;
                pNodeInfo[ulNodeNumber].pCacheUpdateRtn = UpdateBooleanControlCache;
                break;

            case TREBLE_FLAG:
                pNodeInfo[ulNodeNumber].KsNodeDesc.Type = &KSNODETYPE_TONE;
                pNodeInfo[ulNodeNumber].KsNodeDesc.Name = &KSNODETYPE_TONE;
                pNodeInfo[ulNodeNumber].ulNodeType      = NODE_TYPE_TREBLE;
                pNodeInfo[ulNodeNumber].ulControlType   = TREBLE_CONTROL;
                pNodeInfo[ulNodeNumber].fEventable      = TRUE;
                pNodeInfo[ulNodeNumber].pCacheUpdateRtn = UpdateDbLevelControlCache;
                break;

            case MID_FLAG:
                pNodeInfo[ulNodeNumber].KsNodeDesc.Type = &KSNODETYPE_TONE;
                pNodeInfo[ulNodeNumber].KsNodeDesc.Name = &KSNODETYPE_TONE;
                pNodeInfo[ulNodeNumber].ulNodeType      = NODE_TYPE_MID;
                pNodeInfo[ulNodeNumber].ulControlType   = MID_CONTROL;
                pNodeInfo[ulNodeNumber].fEventable      = TRUE;
                pNodeInfo[ulNodeNumber].pCacheUpdateRtn = UpdateDbLevelControlCache;
                break;

            case BASS_FLAG:
                pNodeInfo[ulNodeNumber].KsNodeDesc.Type = &KSNODETYPE_TONE;
                pNodeInfo[ulNodeNumber].KsNodeDesc.Name = &KSNODETYPE_TONE;
                pNodeInfo[ulNodeNumber].ulNodeType      = NODE_TYPE_BASS;
                pNodeInfo[ulNodeNumber].ulControlType   = BASS_CONTROL;
                pNodeInfo[ulNodeNumber].fEventable      = TRUE;
                pNodeInfo[ulNodeNumber].pCacheUpdateRtn = UpdateDbLevelControlCache;
                break;

            case GRAPHIC_EQUALIZER_FLAG:
                pNodeInfo[ulNodeNumber].KsNodeDesc.Type = &KSNODETYPE_EQUALIZER;
                pNodeInfo[ulNodeNumber].KsNodeDesc.Name = &KSNODETYPE_EQUALIZER;
                pNodeInfo[ulNodeNumber].ulNodeType      = NODE_TYPE_EQUALIZER;
                pNodeInfo[ulNodeNumber].ulControlType   = GRAPHIC_EQUALIZER_CONTROL;
                break;

            case AUTOMATIC_GAIN_FLAG:
                pNodeInfo[ulNodeNumber].KsNodeDesc.Type = &KSNODETYPE_AGC;
                pNodeInfo[ulNodeNumber].KsNodeDesc.Name = &KSNODETYPE_AGC;
                pNodeInfo[ulNodeNumber].ulNodeType      = NODE_TYPE_AGC;
                pNodeInfo[ulNodeNumber].ulControlType   = AUTOMATIC_GAIN_CONTROL;
                break;

            case DELAY_FLAG:
                pNodeInfo[ulNodeNumber].KsNodeDesc.Type = &KSNODETYPE_DELAY;
                pNodeInfo[ulNodeNumber].KsNodeDesc.Name = &KSNODETYPE_DELAY;
                pNodeInfo[ulNodeNumber].ulNodeType      = NODE_TYPE_DELAY;
                pNodeInfo[ulNodeNumber].ulControlType   = DELAY_CONTROL;
                break;

            case LOUDNESS_FLAG:
                pNodeInfo[ulNodeNumber].KsNodeDesc.Type = &KSNODETYPE_LOUDNESS;
                pNodeInfo[ulNodeNumber].KsNodeDesc.Name = &KSNODETYPE_LOUDNESS;
                pNodeInfo[ulNodeNumber].ulNodeType      = NODE_TYPE_LOUDNESS;
                pNodeInfo[ulNodeNumber].ulControlType   = LOUDNESS_CONTROL;
                break;

            default:
                pNodeInfo[ulNodeNumber].KsNodeDesc.Type = &KSNODETYPE_DEV_SPECIFIC;
                pNodeInfo[ulNodeNumber].KsNodeDesc.Name = &KSNODETYPE_DEV_SPECIFIC;
                pNodeInfo[ulNodeNumber].ulNodeType      = NODE_TYPE_DEV_SPEC;
                pNodeInfo[ulNodeNumber].ulControlType   = DEV_SPECIFIC_CONTROL;
                break;
        }

        // Setup Control Caches for Mixerline support
        switch ( ulCurrentControl ) {
            case VOLUME_FLAG:
            case TREBLE_FLAG:
            case MID_FLAG:
            case BASS_FLAG:
            case DELAY_FLAG:
               {
                PDB_LEVEL_CACHE pRngeCache =
                      (PDB_LEVEL_CACHE)AllocMem( NonPagedPool, ulCurControlChannels * sizeof(DB_LEVEL_CACHE) );
                ULONG ulChannelMap = pNodeInfo[ulNodeNumber].ulChannelConfig;
                NTSTATUS ntStatus;

                // Fill in initial cache info
                pNodeInfo[ulNodeNumber].ulCacheValid      = FALSE;
                pNodeInfo[ulNodeNumber].pCachedValues     = pRngeCache;
                pNodeInfo[ulNodeNumber].ulNumCachedValues = ulCurControlChannels;
                _DbgPrintF(DEBUGLVL_TERSE, ("ulNodeNumber %d\n", ulNodeNumber ));
                for (i=0, j=0xffffffff; i<ulCurControlChannels; i++ ) {
                    while ( !(pChannelCntrls[++j] & ulCurrentControl) );
                    pRngeCache[i].ulChannelIndex  = j + ((bMasterChannel) ? 0 : 1);
                    _DbgPrintF(DEBUGLVL_TERSE, ("bMasterChannel: %d, pRngeCache[%d].ulChannelIndex: %d j: %d\n",
                    	                         bMasterChannel, i, pRngeCache[i].ulChannelIndex, j));
                    pRngeCache[i].ulChannelNumber = (ulChannelMap - (ulChannelMap & (ulChannelMap-1)))>>1;
                    ulChannelMap = (ulChannelMap & (ulChannelMap-1));

                    ntStatus = InitializeDbLevelCache( pKsDevice,
                                                       &pNodeInfo[ulNodeNumber],
                                                       &pRngeCache[i],
                                                       (ulCurrentControl == VOLUME_FLAG ) ? 16:8);
                    if (NT_SUCCESS(ntStatus)) {
                        pNodeInfo[ulNodeNumber].ulCacheValid |= 1<<i;
                    }
                }
                
                // Bag the cache for easy cleanup.
                KsAddItemToObjectBag(pKsDevice->Bag, pRngeCache, FreeMem);

               } break;

            case MUTE_FLAG:
            case BASS_BOOST_FLAG:
            case AUTOMATIC_GAIN_FLAG:
            case LOUDNESS_FLAG:
               {
                PBOOLEAN_CTRL_CACHE pBCache =
                      (PBOOLEAN_CTRL_CACHE)AllocMem( NonPagedPool, ulCurControlChannels * sizeof(BOOLEAN_CTRL_CACHE) );
                ULONG ulChannelMap = pNodeInfo[ulNodeNumber].ulChannelConfig;

                // Fill in initial cache info
                pNodeInfo[ulNodeNumber].ulCacheValid      = FALSE;
                pNodeInfo[ulNodeNumber].pCachedValues     = pBCache;
                pNodeInfo[ulNodeNumber].ulNumCachedValues = ulCurControlChannels;

                for (i=0, j=0xffffffff; i<ulCurControlChannels; i++ ) {
                    while ( !(pChannelCntrls[++j] & ulCurrentControl) );
                    pBCache[i].ulChannelIndex  = j + ((bMasterChannel) ? 0 : 1);
                    pBCache[i].ulChannelNumber = (ulChannelMap - (ulChannelMap & (ulChannelMap-1)))>>1;
                    ulChannelMap = (ulChannelMap & (ulChannelMap-1));
                }

                // Bag the cache for easy cleanup.
                KsAddItemToObjectBag(pKsDevice->Bag, pBCache, FreeMem);

                // ensure that no mute nodes are set upon enumeration
                if ( ulCurrentControl == MUTE_FLAG ) {
                    NTSTATUS ntStatus;
                    ULONG UnMute = AVC_OFF;

                    ntStatus = 
                        CreateFeatureFBlockRequest( pKsDevice,
                                                    &pNodeInfo[ulNodeNumber],
                                                    pBCache->ulChannelIndex,
                                                    &UnMute,
                                                    1,
                                                    FB_SET_CUR );
                }

                DbgLog("BlCache", pBCache, ulNodeNumber, ulCurrentControl, ulCurControlChannels );

               } break;

            case GRAPHIC_EQUALIZER_FLAG:
               {
                ULONG ulChannelMap = pNodeInfo[ulNodeNumber].ulChannelConfig;
            	PGEQ_CTRL_CACHE pGeqCache;
               	PGEQ_RANGE pGeqRange;
                NTSTATUS ntStatus = STATUS_SUCCESS;

                pGeqCache = AllocMem( PagedPool, ulCurControlChannels * sizeof(GEQ_CTRL_CACHE));
                if ( !pGeqCache ) TRAP; // ISSUE-2001/07/30-dsisolak Check for allocation failure.

                for (i=0, j=0xffffffff; ((i<ulCurControlChannels) && NT_SUCCESS(ntStatus)); i++ ) {

                    while ( !(pChannelCntrls[++j] & ulCurrentControl) );

                    pGeqCache[i].ulChannelIndex  = j + ((bMasterChannel) ? 0 : 1);
                    pGeqCache[i].ulChannelNumber = (ulChannelMap - (ulChannelMap & (ulChannelMap-1)))>>1;
                    ulChannelMap = (ulChannelMap & (ulChannelMap-1));

                    // Get the number of bands and extra bands
              	    ntStatus = InitializeGeqLevelCache( pKsDevice, 
              	                                        pNodeInfo, 
              	                                        &pGeqCache[i] );
                    if ( NT_SUCCESS(ntStatus) ) {
                        KsAddItemToObjectBag(pKsDevice->Bag, pGeqCache[i].pRanges, FreeMem);
                    }
                }
                if ( NT_SUCCESS(ntStatus) ) {
                    KsAddItemToObjectBag(pKsDevice->Bag, pGeqCache, FreeMem);
                }
                else
                	FreeMem(pGeqCache);
               }
               break;
            default:
                 break;
        }

        _DbgPrintF( DEBUGLVL_TERSE, ("Node: %d Feature: %x %s pNodeInfo: %x\n",
                                        ulNodeNumber,
                                        pNodeInfo[ulNodeNumber].ulControlType,
                                        (pNodeInfo[ulNodeNumber].ulControlType == DEV_SPECIFIC_CONTROL) ?
                                            "DEVICE_SPECIFIC" :
                                            CntrlStrings[pNodeInfo[ulNodeNumber].ulControlType],
                                        &pNodeInfo[ulNodeNumber] ));

        ulSourceNode = ( ABSOLUTE_NODE_FLAG | ulNodeNumber++ );
    }


    *pNodeIndex       = ulNodeNumber;
    *pConnectionIndex = ulConnectionsCount;

    FreeMem(pChannelCntrls);


    return STATUS_SUCCESS;
}


NTSTATUS
ProcessFeatureFunctionBlock( 
    PKSDEVICE pKsDevice,
    PFUNCTION_BLOCK pFunctionBlock,
    PTOPOLOGY_NODE_INFO pNodeInfo,
    PKSTOPOLOGY_CONNECTION pConnections,
    PULONG pNodeIndex,
    PULONG pConnectionIndex )
{
    ULONG ulSourceNode = (ULONG)*(PUSHORT)pFunctionBlock->pSourceId;
    NTSTATUS ntStatus;

    _DbgPrintF( DEBUGLVL_VERBOSE, ("[ProcessFeatureFunctionBlock]: pFunctionBlock: %x, pNodeInfo: %x\n",
                                     pFunctionBlock, pNodeInfo ));

    // Create nodes for Master Channel controls
    ntStatus = 
        TopologyNodesFromFeatureFBControls( pKsDevice,
                                            pFunctionBlock,
                                            pNodeInfo,
                                            pConnections,
                                            pNodeIndex,
                                            pConnectionIndex,
#ifdef SUM_HACK
                                            FALSE,
#else
                                            TRUE,
#endif
                                            ulSourceNode );

    if ( NT_SUCCESS(ntStatus) || (ntStatus == STATUS_MEMBER_NOT_IN_GROUP )) {
        if ( NT_SUCCESS(ntStatus) ) {
            ulSourceNode = ( ABSOLUTE_NODE_FLAG | (*pNodeIndex-1) );
        }

        // Create nodes for individual channel controls
        ntStatus = 
            TopologyNodesFromFeatureFBControls( pKsDevice,
                                                pFunctionBlock,
                                                pNodeInfo,
                                                pConnections,
                                                pNodeIndex,
                                                pConnectionIndex,
#ifdef SUM_HACK
                                                TRUE,
#else
                                                FALSE,
#endif
                                                ulSourceNode );

        if ( ntStatus == STATUS_MEMBER_NOT_IN_GROUP ) ntStatus = STATUS_SUCCESS;
    }

    return ntStatus;
}

#else

NTSTATUS
ProcessFeatureFunctionBlock( 
    PKSDEVICE pKsDevice,
    PFUNCTION_BLOCK pFunctionBlock,
    PTOPOLOGY_NODE_INFO pNodeInfo,
    PKSTOPOLOGY_CONNECTION pConnections,
    PULONG pNodeIndex,
    PULONG pConnectionIndex )
{
    PHW_DEVICE_EXTENSION pHwDevExt = (PHW_DEVICE_EXTENSION)pKsDevice->Context;
    PKSTOPOLOGY_CONNECTION pConnection = pConnections + *pConnectionIndex;
    PFEATURE_FUNCTION_BLOCK pFeatureFBlk = (PFEATURE_FUNCTION_BLOCK)pFunctionBlock->pFunctionTypeInfo;

    ULONG ulConnectionsCount = *pConnectionIndex;
    ULONG ulNodeNumber       = *pNodeIndex;
    ULONG ulNumChannels      = (ULONG)pFunctionBlock->pChannelCluster->ucNumberOfChannels;

    PULONG pChannelCntrls;
    ULONG ulCurControlChannels;
    ULONG ulMergedControls;
    ULONG ulCurrentControl;
    ULONG bmChannelConfig;
    ULONG ulSourceNode;
    ULONG bmControls;
    ULONG i, j;

    _DbgPrintF( DEBUGLVL_VERBOSE, ("[ProcessFeatureFunctionBlock]: pFunctionBlock: %x, pNodeInfo: %x pConnection: %x\n",
                                     pFunctionBlock, pNodeInfo, pConnection ));

    pChannelCntrls = (PULONG)AllocMem( NonPagedPool, (ulNumChannels+1)*sizeof(ULONG) );
    if ( !pChannelCntrls ) return STATUS_INSUFFICIENT_RESOURCES;

    // ISSUE-2001/01/10-dsisolak: Does not consider undefined channel configurations
    bmChannelConfig = (ULONG)bswapw(pFunctionBlock->pChannelCluster->usPredefinedChannelConfig);

    // For the sake of simplicity, we create a super-set of all controls available on all channels.
    ulMergedControls = 0;

    for ( i=0; i<=ulNumChannels; i++ ) {
        bmControls = 0;
        for ( j=0; j<pFeatureFBlk->ucControlSize; j++ ) {
            bmControls <<= 8;
            bmControls |= pFeatureFBlk->bmaControls[i*pFeatureFBlk->ucControlSize+j];
        }

        pChannelCntrls[i] = bmControls;
        ulMergedControls |= bmControls;
    }

    ulSourceNode = (ULONG)*(PUSHORT)pFunctionBlock->pSourceId;

    while ( ulMergedControls ) {
        ulCurrentControl = ulMergedControls - (ulMergedControls & (ulMergedControls-1));
        ulMergedControls = (ulMergedControls & (ulMergedControls-1));

        // Copy Block Id for easier parsing later
        pNodeInfo[ulNodeNumber].ulBlockId = pFunctionBlock->ulBlockId;

        // Determine which channels this control is valid for
        ulCurControlChannels = 0;
        pNodeInfo[ulNodeNumber].ulChannelConfig = 0;
        for ( i=0; i<=ulNumChannels; i++ ) {

            if (pChannelCntrls[i] & ulCurrentControl) {
                // Determine which Channel pChannelCntrls[i] reflects

                // NEED TO SHIFT bmChannelConfig and ADD 1 for omnipresent master channel
                ULONG ulTmpConfig = (bmChannelConfig<<1)+1;
                ULONG ulCurChannel = ulTmpConfig - (ulTmpConfig & (ulTmpConfig-1));
  
                ulCurControlChannels++;

                for (j=0; j<i; j++) {
                    ulTmpConfig = (ulTmpConfig & (ulTmpConfig-1));
                    ulCurChannel = ulTmpConfig - (ulTmpConfig & (ulTmpConfig-1));
                }

                pNodeInfo[ulNodeNumber].ulChannelConfig |= ulCurChannel;
            }
        }

        pNodeInfo[ulNodeNumber].ulChannels = ulCurControlChannels;

        // Make the connection
        pConnection->FromNode    = ulSourceNode;
        pConnection->FromNodePin = 0;
        pConnection->ToNode      = ulNodeNumber;
        pConnection->ToNodePin   = 1;
        pConnection++; ulConnectionsCount++;

        // Make the node
        pNodeInfo[ulNodeNumber].pFunctionBlk = pFunctionBlock;
        switch ( ulCurrentControl ) {
            case MUTE_FLAG:
                pNodeInfo[ulNodeNumber].KsNodeDesc.Type = &KSNODETYPE_MUTE;
                pNodeInfo[ulNodeNumber].KsNodeDesc.Name = &KSNODETYPE_MUTE;
                pNodeInfo[ulNodeNumber].ulNodeType      = NODE_TYPE_MUTE;
                pNodeInfo[ulNodeNumber].ulControlType   = MUTE_CONTROL;
                pNodeInfo[ulNodeNumber].fEventable      = TRUE;
                pNodeInfo[ulNodeNumber].pCacheUpdateRtn = UpdateBooleanControlCache;
                break;

            case VOLUME_FLAG:
                pNodeInfo[ulNodeNumber].KsNodeDesc.Type = &KSNODETYPE_VOLUME;
                pNodeInfo[ulNodeNumber].KsNodeDesc.Name = &KSNODETYPE_VOLUME;
                pNodeInfo[ulNodeNumber].ulNodeType      = NODE_TYPE_VOLUME;
                pNodeInfo[ulNodeNumber].ulControlType   = VOLUME_CONTROL;
                pNodeInfo[ulNodeNumber].fEventable      = TRUE;
                pNodeInfo[ulNodeNumber].pCacheUpdateRtn = UpdateDbLevelControlCache;
                break;

            case BASS_BOOST_FLAG:
                pNodeInfo[ulNodeNumber].KsNodeDesc.Type = &KSNODETYPE_TONE;
                pNodeInfo[ulNodeNumber].KsNodeDesc.Name = &AVCNODENAME_BassBoost;
                pNodeInfo[ulNodeNumber].ulNodeType      = NODE_TYPE_BASS_BOOST;
                pNodeInfo[ulNodeNumber].ulControlType   = BASS_BOOST_CONTROL;
                pNodeInfo[ulNodeNumber].fEventable      = TRUE;
                pNodeInfo[ulNodeNumber].pCacheUpdateRtn = UpdateBooleanControlCache;
                break;

            case TREBLE_FLAG:
                pNodeInfo[ulNodeNumber].KsNodeDesc.Type = &KSNODETYPE_TONE;
                pNodeInfo[ulNodeNumber].KsNodeDesc.Name = &KSNODETYPE_TONE;
                pNodeInfo[ulNodeNumber].ulNodeType      = NODE_TYPE_TREBLE;
                pNodeInfo[ulNodeNumber].ulControlType   = TREBLE_CONTROL;
                pNodeInfo[ulNodeNumber].fEventable      = TRUE;
                pNodeInfo[ulNodeNumber].pCacheUpdateRtn = UpdateDbLevelControlCache;
                break;

            case MID_FLAG:
                pNodeInfo[ulNodeNumber].KsNodeDesc.Type = &KSNODETYPE_TONE;
                pNodeInfo[ulNodeNumber].KsNodeDesc.Name = &KSNODETYPE_TONE;
                pNodeInfo[ulNodeNumber].ulNodeType      = NODE_TYPE_MID;
                pNodeInfo[ulNodeNumber].ulControlType   = MID_CONTROL;
                pNodeInfo[ulNodeNumber].fEventable      = TRUE;
                pNodeInfo[ulNodeNumber].pCacheUpdateRtn = UpdateDbLevelControlCache;
                break;

            case BASS_FLAG:
                pNodeInfo[ulNodeNumber].KsNodeDesc.Type = &KSNODETYPE_TONE;
                pNodeInfo[ulNodeNumber].KsNodeDesc.Name = &KSNODETYPE_TONE;
                pNodeInfo[ulNodeNumber].ulNodeType      = NODE_TYPE_BASS;
                pNodeInfo[ulNodeNumber].ulControlType   = BASS_CONTROL;
                pNodeInfo[ulNodeNumber].fEventable      = TRUE;
                pNodeInfo[ulNodeNumber].pCacheUpdateRtn = UpdateDbLevelControlCache;
                break;

            case GRAPHIC_EQUALIZER_FLAG:
                pNodeInfo[ulNodeNumber].KsNodeDesc.Type = &KSNODETYPE_EQUALIZER;
                pNodeInfo[ulNodeNumber].KsNodeDesc.Name = &KSNODETYPE_EQUALIZER;
                pNodeInfo[ulNodeNumber].ulNodeType      = NODE_TYPE_EQUALIZER;
                pNodeInfo[ulNodeNumber].ulControlType   = GRAPHIC_EQUALIZER_CONTROL;
                break;

            case AUTOMATIC_GAIN_FLAG:
                pNodeInfo[ulNodeNumber].KsNodeDesc.Type = &KSNODETYPE_AGC;
                pNodeInfo[ulNodeNumber].KsNodeDesc.Name = &KSNODETYPE_AGC;
                pNodeInfo[ulNodeNumber].ulNodeType      = NODE_TYPE_AGC;
                pNodeInfo[ulNodeNumber].ulControlType   = AUTOMATIC_GAIN_CONTROL;
                break;

            case DELAY_FLAG:
                pNodeInfo[ulNodeNumber].KsNodeDesc.Type = &KSNODETYPE_DELAY;
                pNodeInfo[ulNodeNumber].KsNodeDesc.Name = &KSNODETYPE_DELAY;
                pNodeInfo[ulNodeNumber].ulNodeType      = NODE_TYPE_DELAY;
                pNodeInfo[ulNodeNumber].ulControlType   = DELAY_CONTROL;
                break;

            case LOUDNESS_FLAG:
                pNodeInfo[ulNodeNumber].KsNodeDesc.Type = &KSNODETYPE_LOUDNESS;
                pNodeInfo[ulNodeNumber].KsNodeDesc.Name = &KSNODETYPE_LOUDNESS;
                pNodeInfo[ulNodeNumber].ulNodeType      = NODE_TYPE_LOUDNESS;
                pNodeInfo[ulNodeNumber].ulControlType   = LOUDNESS_CONTROL;
                break;

            default:
                pNodeInfo[ulNodeNumber].KsNodeDesc.Type = &KSNODETYPE_DEV_SPECIFIC;
                pNodeInfo[ulNodeNumber].KsNodeDesc.Name = &KSNODETYPE_DEV_SPECIFIC;
                pNodeInfo[ulNodeNumber].ulNodeType      = NODE_TYPE_DEV_SPEC;
                pNodeInfo[ulNodeNumber].ulControlType   = DEV_SPECIFIC_CONTROL;
                break;
        }

        _DbgPrintF( DEBUGLVL_VERBOSE, ("Feature: %x pNodeInfo: %x\n", 
                                        pNodeInfo[ulNodeNumber].ulControlType,
                                        &pNodeInfo[ulNodeNumber] ));

        // Setup Control Caches for Mixerline support
        switch ( ulCurrentControl ) {
            case VOLUME_FLAG:
            case TREBLE_FLAG:
            case MID_FLAG:
            case BASS_FLAG:
            case DELAY_FLAG:
               {
                PDB_LEVEL_CACHE pRngeCache =
                      (PDB_LEVEL_CACHE)AllocMem( NonPagedPool, ulCurControlChannels * sizeof(DB_LEVEL_CACHE) );
                ULONG ulChannelMap = pNodeInfo[ulNodeNumber].ulChannelConfig;
                NTSTATUS ntStatus;

                // Fill in initial cache info
                pNodeInfo[ulNodeNumber].ulCacheValid      = FALSE;
                pNodeInfo[ulNodeNumber].pCachedValues     = pRngeCache;
                pNodeInfo[ulNodeNumber].ulNumCachedValues = ulCurControlChannels;
                for (i=0, j=0xffffffff; i<ulCurControlChannels; i++ ) {
                    while ( !(pChannelCntrls[++j] & ulCurrentControl) );
                    pRngeCache[i].ulChannelIndex  = j;
                    pRngeCache[i].ulChannelNumber = (ulChannelMap - (ulChannelMap & (ulChannelMap-1)))>>1;
                    ulChannelMap = (ulChannelMap & (ulChannelMap-1));

                    ntStatus = InitializeDbLevelCache( pKsDevice,
                                                       &pNodeInfo[ulNodeNumber],
                                                       &pRngeCache[i],
                                                       (ulCurrentControl == VOLUME_FLAG ) ? 16:8);
                    if (NT_SUCCESS(ntStatus)) {
                        pNodeInfo[ulNodeNumber].ulCacheValid |= 1<<i;
                    }

                }
                // Bag the cache for easy cleanup.
                KsAddItemToObjectBag(pKsDevice->Bag, pRngeCache, FreeMem);

               } break;

            case MUTE_FLAG:
            case BASS_BOOST_FLAG:
            case AUTOMATIC_GAIN_FLAG:
            case LOUDNESS_FLAG:
               {
                PBOOLEAN_CTRL_CACHE pBCache =
                      (PBOOLEAN_CTRL_CACHE)AllocMem( NonPagedPool, ulCurControlChannels * sizeof(BOOLEAN_CTRL_CACHE) );
                ULONG ulChannelMap = pNodeInfo[ulNodeNumber].ulChannelConfig;

                // Fill in initial cache info
                pNodeInfo[ulNodeNumber].ulCacheValid      = FALSE;
                pNodeInfo[ulNodeNumber].pCachedValues     = pBCache;
                pNodeInfo[ulNodeNumber].ulNumCachedValues = ulCurControlChannels;

                for (i=0, j=0xffffffff; i<ulCurControlChannels; i++ ) {
                    while ( !(pChannelCntrls[++j] & ulCurrentControl) );
                    pBCache[i].ulChannelIndex  = j;
                    pBCache[i].ulChannelNumber = (ulChannelMap - (ulChannelMap & (ulChannelMap-1)))>>1;
                    ulChannelMap = (ulChannelMap & (ulChannelMap-1));
                }

                // Bag the cache for easy cleanup.
                KsAddItemToObjectBag(pKsDevice->Bag, pBCache, FreeMem);

                // ensure that no mute nodes are set upon enumeration
                if ( ulCurrentControl == MUTE_FLAG ) {
                    NTSTATUS ntStatus;
                    ULONG UnMute = AVC_OFF;

                    ntStatus = 
                        CreateFeatureFBlockRequest( pKsDevice,
                                                    &pNodeInfo[ulNodeNumber],
                                                    pBCache->ulChannelIndex,
                                                    &UnMute,
                                                    1,
                                                    FB_SET_CUR );
                }

                DbgLog("BlCache", pBCache, ulNodeNumber, ulCurrentControl, ulCurControlChannels );

               } break;

            case GRAPHIC_EQUALIZER_FLAG:
               // Currently GEQ is not Cached
            default:
                 break;
        }

        ulSourceNode = ( ABSOLUTE_NODE_FLAG | ulNodeNumber++ );
    }


    *pNodeIndex       = ulNodeNumber;
    *pConnectionIndex = ulConnectionsCount;

    FreeMem(pChannelCntrls);


    return STATUS_SUCCESS;
}

#endif

NTSTATUS
ProcessSelectorFunctionBlock( 
    PKSDEVICE pKsDevice,
    PFUNCTION_BLOCK pFunctionBlock,
    PTOPOLOGY_NODE_INFO pNodeDescriptors,
    PKSTOPOLOGY_CONNECTION pConnections,
    PULONG pNodeIndex,
    PULONG pConnectionIndex )
{
    return STATUS_SUCCESS;
}

NTSTATUS
ProcessProcessingFunctionBlock( 
    PKSDEVICE pKsDevice,
    PFUNCTION_BLOCK pFunctionBlock,
    PTOPOLOGY_NODE_INFO pNodeDescriptors,
    PKSTOPOLOGY_CONNECTION pConnections,
    PULONG pNodeIndex,
    PULONG pConnectionIndex )
{
    PTOPOLOGY_NODE_INFO pNodeInfo = pNodeDescriptors + *pNodeIndex;
    PKSTOPOLOGY_CONNECTION pConnection = pConnections + *pConnectionIndex;

    _DbgPrintF( DEBUGLVL_VERBOSE, ("[ProcessProcessingFunctionBlock]: pFunctionBlock: %x, pNodeInfo: %x pConnection: %x\n",
                                     pFunctionBlock, pNodeInfo, pConnection ));

    pNodeInfo->pFunctionBlk    = pFunctionBlock;
    pNodeInfo->ulBlockId       = pFunctionBlock->ulBlockId;
    pNodeInfo->KsNodeDesc.Type = &KSNODETYPE_DEV_SPECIFIC;
    pNodeInfo->KsNodeDesc.Name = &KSNODETYPE_DEV_SPECIFIC;
    pNodeInfo->ulNodeType      = NODE_TYPE_DEV_SPEC;
    pNodeInfo->ulControlType   = DEV_SPECIFIC_CONTROL;

    pConnection->FromNode    = (ULONG)*(PUSHORT)pFunctionBlock->pSourceId;
    pConnection->FromNodePin = 0;
    pConnection->ToNode      = (*pNodeIndex)++;
    pConnection->ToNodePin   = 1;

    (*pConnectionIndex)++;

    return STATUS_SUCCESS;
}

NTSTATUS
ProcessCodecFunctionBlock( 
    PKSDEVICE pKsDevice,
    PFUNCTION_BLOCK pFunctionBlock,
    PTOPOLOGY_NODE_INFO pNodeDescriptors,
    PKSTOPOLOGY_CONNECTION pConnections,
    PULONG pNodeIndex,
    PULONG pConnectionIndex )
{
    return STATUS_SUCCESS;
}

NTSTATUS
ProcessPinDescriptor( 
    PKSDEVICE pKsDevice,
    ULONG ulPinId,
    PTOPOLOGY_NODE_INFO pTopologyNodeInfo,
    PKSTOPOLOGY_CONNECTION pConnections,
    PULONG pNodeIndex,
    PULONG pConnectionIndex )
{
    PHW_DEVICE_EXTENSION pHwDevExt = (PHW_DEVICE_EXTENSION)pKsDevice->Context;
    PAUDIO_SUBUNIT_INFORMATION pAudioSubunitInfo = pHwDevExt->pAvcSubunitInformation;

    PTOPOLOGY_NODE_INFO pNodeInfo = pTopologyNodeInfo + *pNodeIndex;
    PKSTOPOLOGY_CONNECTION pConnection = pConnections + *pConnectionIndex;
    PFW_PIN_DESCRIPTOR pFwPinDescriptor = &pAudioSubunitInfo->pPinDescriptors[ulPinId];
    ULONG ulPlugNum = pFwPinDescriptor->AvcPreconnectInfo.ConnectInfo.SubunitPlugNumber;

    pNodeInfo->ulPinId = ulPinId;
    pNodeInfo->ulNodeType =
                 ConvertPinTypeToNodeType( pFwPinDescriptor,
                                           (GUID *)pNodeInfo->KsNodeDesc.Type,
                                           (GUID *)pNodeInfo->KsNodeDesc.Name );

    _DbgPrintF(DEBUGLVL_VERBOSE,("ProcessPin: ID; %d pNodeInfo: %x pConnection: %x \n", 
                                ulPinId, pNodeInfo, pConnection));

	switch( pFwPinDescriptor->AvcPinDescriptor.PinDescriptor.DataFlow ) {
	    case KSPIN_DATAFLOW_IN:

	        pNodeInfo->ulBlockId = SUBUNIT_DESTINATION_PLUG_TYPE | (ulPlugNum<<8);

            // Make the connection to this node
            pConnection->FromNodePin = ulPinId;
            pConnection->FromNode    = KSFILTER_NODE;
            pConnection->ToNode      = (*pNodeIndex)++;
            pConnection->ToNodePin   = 1;
            (*pConnectionIndex)++;
	        break;

		case KSPIN_DATAFLOW_OUT:

	        pNodeInfo->ulBlockId = SUBUNIT_SOURCE_PLUG_TYPE | (ulPlugNum<<8);

            pConnection->FromNode    = FindSourceForSrcPlug( pHwDevExt, ulPinId );
            pConnection->FromNodePin = 0;
            pConnection->ToNode      = (*pNodeIndex)++;
            pConnection->ToNodePin   = 1;
            pConnection++; (*pConnectionIndex)++;

            // Make the connection to the outside world
            pConnection->ToNodePin   = ulPinId;
            pConnection->FromNode    = SUBUNIT_SOURCE_PLUG_TYPE | (ulPlugNum<<8);
            pConnection->FromNodePin = 0;
            pConnection->ToNode      = KSFILTER_NODE;
            (*pConnectionIndex)++;
            break;

		default:
			return STATUS_NOT_IMPLEMENTED;
	}

    return STATUS_SUCCESS;
}


PFUNCTION_BLK_PROCESS_RTN 
pFunctionBlockProcessRtn[MAX_FUNCTION_BLOCK_TYPES] = {
    ProcessSelectorFunctionBlock,
    ProcessFeatureFunctionBlock,
    ProcessProcessingFunctionBlock,
    ProcessCodecFunctionBlock,
};

NTSTATUS
BuildFilterTopology( PKSDEVICE pKsDevice )
{
    PHW_DEVICE_EXTENSION pHwDevExt = (PHW_DEVICE_EXTENSION)pKsDevice->Context;
    PAUDIO_SUBUNIT_INFORMATION pAudioSubunitInfo = pHwDevExt->pAvcSubunitInformation;
    PKSFILTER_DESCRIPTOR pFilterDesc = &pHwDevExt->KsFilterDescriptor;
    NTSTATUS ntStatus = STATUS_SUCCESS;

    // ISSUE-2001/01/10-dsisolak Assume only 1 configuration for now
    PAUDIO_CONFIGURATION pAudioConfiguration = pAudioSubunitInfo->pAudioConfigurations;
    PFUNCTION_BLOCK pFunctionBlocks = pAudioConfiguration->pFunctionBlocks;

    ULONG ulNumCategories;
    ULONG ulNumNodes;
    ULONG ulNumConnections;
    ULONG bmCategories;

    GUID* pCategoryGUIDs;
    GUID* pTmpGUIDptr;
    PTOPOLOGY_NODE_INFO pNodeDescriptors;
    PKSTOPOLOGY_CONNECTION pConnections;

    ULONG ulNodeIndex = 0;
    ULONG ulConnectionIndex = 0;
    ULONG i;

    // Now that we've processed the Audio Subunit descriptor
    // a bit lets munch through it and build our topology.
    CountTopologyComponents( pHwDevExt,
                             &ulNumCategories,
                             &ulNumNodes,
                             &ulNumConnections,
                             &bmCategories );

    _DbgPrintF( DEBUGLVL_VERBOSE, ("ulNumCategories %d, ulNumNodes %d, ulNumConnections %d, bmCategories %x \n",
                                    ulNumCategories, ulNumNodes, ulNumConnections, bmCategories ));

    // Set the Node Descriptor size to be that of the KS descriptor +
    // necessary local information.
    pFilterDesc->NodeDescriptorSize = sizeof(TOPOLOGY_NODE_INFO);

    // Allocate Space for Topology Items
    pCategoryGUIDs = (GUID*)
        AllocMem( NonPagedPool, (ulNumCategories  * sizeof(GUID)) +
                                (ulNumNodes       * ( sizeof(TOPOLOGY_NODE_INFO) +
                                                      sizeof(GUID) +
                                                      sizeof(GUID) ) ) +
                                (ulNumConnections * sizeof(KSTOPOLOGY_CONNECTION)) );
    if ( !pCategoryGUIDs ) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    // Bag the topology for easy cleanup.
    KsAddItemToObjectBag(pKsDevice->Bag, pCategoryGUIDs, FreeMem);

    // Set the pointers to the different topology components
    pNodeDescriptors = (PTOPOLOGY_NODE_INFO)(pCategoryGUIDs + ulNumCategories);
    pConnections = (PKSTOPOLOGY_CONNECTION)(pNodeDescriptors + ulNumNodes);

    pFilterDesc->Categories      = (const GUID*)pCategoryGUIDs;
    pFilterDesc->NodeDescriptors = (const KSNODE_DESCRIPTOR*)pNodeDescriptors;
    pFilterDesc->Connections     = (const KSTOPOLOGY_CONNECTION*)pConnections;

    // Clear all Node info structures
    RtlZeroMemory(pNodeDescriptors, ulNumNodes * sizeof(TOPOLOGY_NODE_INFO));

    // Initialize Node GUID Pointers
    pTmpGUIDptr = (GUID *)(pConnections + ulNumConnections);
    for ( i=0; i<ulNumNodes; i++ ) {
        pNodeDescriptors[i].KsNodeDesc.Type = pTmpGUIDptr++;
        pNodeDescriptors[i].KsNodeDesc.Name = pTmpGUIDptr++;
        pNodeDescriptors[i].KsNodeDesc.AutomationTable = 
                           &pNodeDescriptors[i].KsAutomationTable;
    }

    // Fill in Filter Categories
    i=0;
    pCategoryGUIDs[i++] = KSCATEGORY_AUDIO;
    if ( bmCategories & KSPIN_DATAFLOW_OUT )
        pCategoryGUIDs[i++] = KSCATEGORY_RENDER;
    if ( bmCategories & KSPIN_DATAFLOW_IN )
        pCategoryGUIDs[i++] = KSCATEGORY_CAPTURE;

    ASSERT (i==ulNumCategories);

    pFilterDesc->CategoriesCount = ulNumCategories;

    // First go through plugs and assign topology components for them.
    for (i=0; ((i<pAudioSubunitInfo->ulDevicePinCount) && NT_SUCCESS(ntStatus)); i++) {
        ntStatus = ProcessPinDescriptor(  pKsDevice,
                                          i,
                                          pNodeDescriptors,
                                          pConnections,
                                          &ulNodeIndex,
                                          &ulConnectionIndex );
    }

    for (i=0; ((i<pAudioConfiguration->ulNumberOfFunctionBlocks) && NT_SUCCESS(ntStatus)); i++) {
        ntStatus = 
            (*pFunctionBlockProcessRtn[pFunctionBlocks[i].ulType & 0xf])( pKsDevice,
                                                                          &pFunctionBlocks[i],
                                                                          pNodeDescriptors,
                                                                          pConnections,
                                                                          &ulNodeIndex,
                                                                          &ulConnectionIndex );
    }

    if ( !NT_SUCCESS(ntStatus) ) return ntStatus;

    // Set Topology component counts in Filter Descriptor
    pFilterDesc->NodeDescriptorsCount = ulNodeIndex;
    pFilterDesc->ConnectionsCount     = ulConnectionIndex;

    DbgLog("TopoAdr", pFilterDesc->NodeDescriptors, pFilterDesc->Connections, ulConnectionIndex, ulNodeIndex);

    // Fix-up all of the connections to map their node #'s correctly.
    for (i=0; i < ulConnectionIndex; i++) {
        if (pConnections->FromNode != KSFILTER_NODE) {
            if (pConnections->FromNode & ABSOLUTE_NODE_FLAG)
                pConnections->FromNode = (pConnections->FromNode & NODE_MASK);
            else {
                // Find the correct node number for FromNode.
                // Note: if a unit has multiple nodes, the From node is always the last node
                // for that unit.
                for ( ulNodeIndex=ulNumNodes; ulNodeIndex > 0; ulNodeIndex-- ) {
                    if ( pConnections->FromNode == pNodeDescriptors[ulNodeIndex-1].ulBlockId ) {
                        pConnections->FromNode = ulNodeIndex-1;
                        break;
                    }
                }
            }
        }

        pConnections++;
    }

    // For each node initialize its automation table for its associated properties.
    for (i=0; i<ulNumNodes; i++) {
        BuildNodePropertySet( &pNodeDescriptors[i] );

#ifdef PSEUDO_HID
        if ( pNodeDescriptors[i].fEventable ) {
//            _DbgPrintF( DEBUGLVL_VERBOSE, ("Node: %d pNodeDescriptors: %x \n", i, &pNodeDescriptors[i] ));

            pNodeDescriptors[i].KsAutomationTable.EventSetsCount = 1;
            pNodeDescriptors[i].KsAutomationTable.EventItemSize  = sizeof(KSEVENT_ITEM);
            pNodeDescriptors[i].KsAutomationTable.EventSets      = HwEventSetTable;
        }
#endif

    }

    // Stick this here as a convienience
    // Initialize Map of Audio Properties to nodes
//    MapFuncsToNodeTypes( MapPropertyToNode );

    return ntStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\drivers\usbaudio.2\debug.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 2000
//
//  File:       debug.h
//
//--------------------------------------------------------------------------

#ifndef __DEBUG_H
#define __DEBUG_H

#define DBGMEMMAP 0

#if (DBG)
#define STR_MODULENAME "'USB Audio: "
#endif

#ifdef LOG_TO_FILE

NTSTATUS NTAPI 
FileOpenRoutine (
    PHW_DEVICE_EXTENSION deviceExtension
    );

NTSTATUS NTAPI 
FileIoRoutine (
    PHW_DEVICE_EXTENSION deviceExtension,
    PVOID buffer, 
    ULONG length
    );

NTSTATUS NTAPI 
FileCloseRoutine (
    PHW_DEVICE_EXTENSION deviceExtension
    );

#endif

#if DBG && DBGMEMMAP

typedef struct {
    ULONG TotalBytes;
    KSPIN_LOCK SpinLock;
    LIST_ENTRY List;
} MEM_TRACKER, *PMEM_TRACKER;

extern PMEM_TRACKER UsbAudioMemMap;

VOID
InitializeMemoryList( VOID );

PVOID
USBAudioAllocateTrack(
    IN POOL_TYPE PoolType,
    IN ULONG NumberOfBytes
    );

VOID
USBAudioDeallocateTrack(
    PVOID pMem
    );

#define AllocMem USBAudioAllocateTrack
#define FreeMem USBAudioDeallocateTrack

#else

#define AllocMem ExAllocatePool
#define FreeMem ExFreePool

#endif

#if DBG
VOID
DumpUnitDescriptor( PUCHAR pAddr );

VOID
DumpAllUnitDescriptors( 
    PUCHAR BeginAddr, PUCHAR EndAddr );

VOID
DumpDescriptor( PVOID pDescriptor );

VOID
DumpAllDescriptors(
    PUSB_CONFIGURATION_DESCRIPTOR pConfigurationDescriptor 
    );

#define DumpDesc DumpDescriptor
#define DumpAllDesc DumpAllDescriptors
#define DumpAllUnits DumpAllUnitDescriptors
#define DumpUnitDesc DumpUnitDescriptor

#else

#define DumpDesc(a)
#define DumpAllDesc(a)
#define DumpAllUnits(a,b)
#define DumpUnitDesc(a)

#endif

#if DBG

#define TRAP DbgBreakPoint()

#define DEBUGLVL_BLAB    3
#define DEBUGLVL_VERBOSE 2
#define DEBUGLVL_TERSE   1
#define DEBUGLVL_ERROR   0

#if !defined(DEBUG_LEVEL)
#define DEBUG_LEVEL DEBUGLVL_VERBOSE
#endif

extern ULONG USBAudioDebugLevel;

#define PCM2USB_KdPrint(_x_) \
{\
    if ( USBAudioDebugLevel >= DEBUGLVL_VERBOSE ) {\
        DbgPrint(STR_MODULENAME); \
        DbgPrint _x_ ;\
    } \
}

#define _DbgPrintF(lvl, strings) \
{ \
    if ((lvl) <= USBAudioDebugLevel) {\
        DbgPrint(STR_MODULENAME);\
        DbgPrint##strings;\
        if ((lvl) == DEBUGLVL_ERROR) {\
             DbgBreakPoint();\
        } \
    } \
}

#else

#define TRAP 
#define PCM2USB_KdPrint(_x_)
#define _DbgPrintF(lvl, strings)

#endif

#include "dbglog.h"

//------------------------------- End of File --------------------------------
#endif // #ifndef __DEBUG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\drivers\usbaudio.2\common.h ===
#ifndef __COMMON_H__
#define __COMMON_H__


/*++

Copyright (C) Microsoft Corporation, 1996 - 2000

Module Name:

   common.h

Abstract:

   This is the WDM ksshell minidriver.  This module contains
   header definitions and include files needed by all modules in the project

Author:

Environment:

   Kernel mode only


Revision History:

--*/

#include <stdarg.h>
#include <stdio.h>

#include <wdm.h>
#include <windef.h>

#include <ks.h>

#include <mmsystem.h>
#define NOBITMAP
#include <mmreg.h>
#include <ksmedia.h>
#include <midi.h>

#include <usbdrivr.h>

#include <unknown.h>
#include <drmk.h>

#ifndef _WIN64
#define DRM_USBAUDIO
#endif 

#include "Descript.h"
#include "USBAudio.h"

#include "debug.h"
#include "proto.h"


#define INIT_CODE       code_seg("INIT", "CODE")
#define INIT_DATA       data_seg("INIT", "DATA")
#define LOCKED_CODE     code_seg(".text", "CODE")
#define LOCKED_DATA     data_seg(".data", "DATA")
#define LOCKED_BSS      bss_seg(".data", "DATA")
#define PAGEABLE_CODE   code_seg("PAGE", "CODE")
#define PAGEABLE_DATA   data_seg("PAGEDATA", "DATA")
#define PAGEABLE_BSS    bss_seg("PAGEDATA", "DATA")

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\drivers\usbaudio.2\dbglog.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 2000
//
//  File:       dbglog.h
//
//--------------------------------------------------------------------------

#ifndef __DBGLOG_H
#define __DBGLOG_H

#define DEBUG_LOG 1

#if DBG && DEBUG_LOG

#define DBG_LOG_STRNG   "DBG_BUFFER"

// structures and calls to save data in debug buffer
typedef struct _DEBUG_LOG_ENTRY {
    CHAR     le_name[8];      // Identifying string
    LARGE_INTEGER SysTime;    // System Time
//    ULONG    Irql;            // Current Irql
    ULONG_PTR le_info1;       // entry specific info
    ULONG_PTR le_info2;       // entry specific info
    ULONG_PTR le_info3;       // entry specific info
    ULONG_PTR le_info4;       // entry specific info
} DEBUG_LOG_ENTRY, *PDEBUG_LOG_ENTRY;

typedef struct _DBG_BUFFER {
    UCHAR LGFlag[16];
    ULONG EntryCount;
    PDEBUG_LOG_ENTRY pLogHead;
    PDEBUG_LOG_ENTRY pLogTail;
    PDEBUG_LOG_ENTRY pLog;
} DBG_BUFFER, *PDBG_BUFFER;

VOID
DbugLogEntry(
    IN CHAR *Name,
    IN ULONG_PTR Info1,
    IN ULONG_PTR Info2,
    IN ULONG_PTR Info3,
    IN ULONG_PTR Info4
    );

VOID
DbugLogInitialization(void);

VOID
DbugLogUninitialization(void);

#define DbgLogInit() DbugLogInitialization()
#define DbgLogUninit() DbugLogUninitialization()
#define DbgLog(a,b,c,d,e) DbugLogEntry(a,(ULONG_PTR)b,(ULONG_PTR)c,(ULONG_PTR)d, (ULONG_PTR)e)

#else
#define DbgLogInit()
#define DbgLogUninit()
#define DbgLog(a,b,c,d,e)
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\drivers\usbaudio.2\debug.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 2000
//
//  File:       debug.c
//
//--------------------------------------------------------------------------

#include "common.h"

#if DBG && DEBUG_LOG

#define LOGSIZE     1024

PDBG_BUFFER gpLogPtr;
KSPIN_LOCK LogSpinLock;
ULONG ulNumDevices = 0;

#ifdef _X86_
#ifndef UNDER_NT

VOID __cdecl
dprintf(
    PSZ pszFmt,
    PVOID Arg1,
    ...
)
{
    __asm mov esi, [pszFmt]
    __asm lea edi, [Arg1]
    __asm mov eax, 0x73
    __asm int 41h
}

CHAR
dgetc(
)
{
    __asm mov ax, 0x77          // get command char
    __asm mov bl, 1             // get char
    __asm int 41h
    __asm or ah, ah
    __asm jnz morechars
    __asm mov al, ah
morechars:
    __asm movzx eax, al
}

CHAR
DebugGetCommandChar(
)
{
    __asm mov ax, 0x77          // get command char
    __asm mov bl, 1             // get char
    __asm int 41h
    __asm or ah, ah
    __asm jnz morechars
    __asm mov al, ah
morechars:
    __asm movzx eax, al
}

VOID
DumpUSBAudioLog( ULONG Count )
{
    ULONG HeadPtr;
    ULONG TailPtr;
    ULONG CurrPtr;
    ULONG LogPtr;
    ULONG i;

    PDBG_BUFFER pDbgLog;

    pDbgLog = gpLogPtr;

    if ( strcmp(pDbgLog->LGFlag, "DBG_BUFFER") ) {
        dprintf("ERROR: Debug Log Flag Mismatch: %x\n", pDbgLog);
        return;
    }

    LogPtr  =  (ULONG)pDbgLog->pLog;
    HeadPtr = ((ULONG)pDbgLog->pLogHead - LogPtr)/sizeof( DEBUG_LOG_ENTRY );
    TailPtr = ((ULONG)pDbgLog->pLogTail - LogPtr)/sizeof( DEBUG_LOG_ENTRY );

    if ( !Count || ( Count > pDbgLog->EntryCount ) ) {
        Count = pDbgLog->EntryCount;
    }

    dprintf("USB Debug Log: Printing %d entries\n", (PVOID)Count);

    CurrPtr = HeadPtr;
    for (i=0;((i<Count) && (CurrPtr<=TailPtr));i++,CurrPtr++) {
//        dprintf ("%8s: %2d %08x   %08x %08x %08x %08x\n",
        dprintf ("%8s: %08x   %08x %08x %08x %08x\n",
                          pDbgLog->pLog[CurrPtr].le_name,
//                         LogPtr[CurrPtr].Irql,
                          pDbgLog->pLog[CurrPtr].SysTime.LowPart/1000,
                          pDbgLog->pLog[CurrPtr].le_info1,
                          pDbgLog->pLog[CurrPtr].le_info2,
                          pDbgLog->pLog[CurrPtr].le_info3,
                          pDbgLog->pLog[CurrPtr].le_info4
                          );
    }

    for (CurrPtr=0;((i<Count) && (CurrPtr<HeadPtr));i++,CurrPtr++) {
//        dprintf ("%8s: %2d %08x   %08x %08x %08x %08x\n",
        dprintf ("%8s: %08x   %08x %08x %08x %08x\n",
                          pDbgLog->pLog[CurrPtr].le_name,
//                          LogPtr[CurrPtr].Irql,
                          pDbgLog->pLog[CurrPtr].SysTime.LowPart/1000,
                          pDbgLog->pLog[CurrPtr].le_info1,
                          pDbgLog->pLog[CurrPtr].le_info2,
                          pDbgLog->pLog[CurrPtr].le_info3,
                          pDbgLog->pLog[CurrPtr].le_info4
                          );
    }
}

VOID
DebugCommand(
)
{
    CHAR c;
    ULONG Count = 0;
    ULONG ulDigit;

    while((c = DebugGetCommandChar()) != '\0') {
        if (c >= '0' && c <= '9') {
            ulDigit = c - '0';
            Count = (Count * 10) + ulDigit;
        }
    }
    DumpUSBAudioLog(Count);
}

VOID
DebugDotCommand(
)
{
    DebugCommand();
    __asm xor eax, eax
    __asm retf
}

VOID
InitializeDebuggerCommand(
)
{
    static char *pszHelp = ".Z [n] - Dump [n] USBAudio Debug Log Entries\n";

    __asm {
        _emit 0xcd
        _emit 0x20
        _emit 0xc1
        _emit 0x00
        _emit 0x01
        _emit 0x00
        jz exitlab

        mov bl, 'Z'
        mov esi, offset DebugDotCommand
        mov edi, pszHelp
        mov eax, 0x70   // DS_RegisterDotCommand
        int 41h
exitlab:
    }
}

VOID
UninitializeDebuggerCommand(
)
{
    __asm {
        _emit 0xcd
        _emit 0x20
        _emit 0xc1
        _emit 0x00
        _emit 0x01
        _emit 0x00
        jz exitlab

        mov bl, 'Z'
        mov eax, 0x72   // DS_DeRegisterDotCommand
        int 41h
exitlab:
    }
}

#endif // ! UNDER_NT
#endif // _X86_

VOID
DbugLogInitialization(void)
{
    if (0 == ulNumDevices) {

#ifndef UNDER_NT
        InitializeDebuggerCommand();
#endif

        gpLogPtr = AllocMem( NonPagedPool, sizeof( DBG_BUFFER ));
        if ( !gpLogPtr ) {
            _DbgPrintF( DEBUGLVL_TERSE, ("Could NOT Allocate debug buffer ptr\n"));
            return;
        }
        gpLogPtr->pLog = AllocMem( NonPagedPool, sizeof(DEBUG_LOG_ENTRY) * LOGSIZE );
        if ( !gpLogPtr->pLog ) {
            FreeMem( gpLogPtr );
            gpLogPtr = NULL;
            _DbgPrintF( DEBUGLVL_TERSE, ("Could NOT Allocate debug buffer\n"));
            return;
        }

        strcpy(gpLogPtr->LGFlag, DBG_LOG_STRNG);

        gpLogPtr->pLogHead = gpLogPtr->pLog;
        gpLogPtr->pLogTail = gpLogPtr->pLogHead + LOGSIZE - 1;
        gpLogPtr->EntryCount = 0;

        KeInitializeSpinLock(&LogSpinLock);
    }

    ulNumDevices++;
}

VOID
DbugLogUninitialization(void)
{
    ulNumDevices--;
    _DbgPrintF(DEBUGLVL_TERSE,("[DbugLogUninitialization] ulNumDevices=%d\n",ulNumDevices));
    if (0 == ulNumDevices) {

        _DbgPrintF(DEBUGLVL_TERSE,("[DbugLogUninitialization] Freeing\n"));
        if ( gpLogPtr->pLog ) {
            FreeMem( gpLogPtr->pLog );
        }

        if ( gpLogPtr ) {
            FreeMem( gpLogPtr );
        }

#ifndef UNDER_NT
        UninitializeDebuggerCommand();
#endif
    }
}

VOID
DbugLogEntry(
    IN CHAR *Name,
    IN ULONG_PTR Info1,
    IN ULONG_PTR Info2,
    IN ULONG_PTR Info3,
    IN ULONG_PTR Info4
    )
/*++

Routine Description:

    Adds an Entry to USBD log.

Arguments:

Return Value:

    None.

--*/
{
    KIRQL irql;

    if (gpLogPtr == NULL)
        return;

    KeAcquireSpinLock( &LogSpinLock, &irql );
    if (gpLogPtr->pLogHead > gpLogPtr->pLog)
        gpLogPtr->pLogHead -= 1;    // Decrement to next entry
    else
        gpLogPtr->pLogHead = gpLogPtr->pLogTail;

    if (strlen(Name) > 7)
        strcpy(gpLogPtr->pLogHead->le_name, "*strER*");
    else
        strcpy(gpLogPtr->pLogHead->le_name, Name);
//    LogPtr->pLogHead->Irql = irql;
    KeQuerySystemTime( &gpLogPtr->pLogHead->SysTime );
    gpLogPtr->pLogHead->le_info1 = Info1;
    gpLogPtr->pLogHead->le_info2 = Info2;
    gpLogPtr->pLogHead->le_info3 = Info3;
    gpLogPtr->pLogHead->le_info4 = Info4;

    gpLogPtr->EntryCount++;

    KeReleaseSpinLock( &LogSpinLock, irql );

    return;
}

#endif

#if DBG && DBGMEMMAP

#pragma LOCKED_DATA
PMEM_TRACKER UsbAudioMemMap;
#pragma PAGEABLE_DATA

VOID
InitializeMemoryList( VOID )
{
   UsbAudioMemMap = ExAllocatePool( NonPagedPool, sizeof( MEM_TRACKER ) );
   if ( !UsbAudioMemMap ) {
       _DbgPrintF(DEBUGLVL_TERSE, ("MEMORY TRACKER ALLOCATION FAILED!!!"));
       TRAP;
   }
   UsbAudioMemMap->TotalBytes = 0;
   InitializeListHead( &UsbAudioMemMap->List );
   KeInitializeSpinLock( &UsbAudioMemMap->SpinLock );
   _DbgPrintF(DEBUGLVL_TERSE, ("'Initialize MEMORY TRACKER UsbAudioMemMap: %x\n",
               UsbAudioMemMap));
}

PVOID
USBAudioAllocateTrack(
    POOL_TYPE PoolType,
    ULONG NumberOfBytes
    )
{
    PVOID pMem;
    KIRQL irql;
    ULONG TotalReqSize = NumberOfBytes + sizeof(ULONG) + sizeof(LIST_ENTRY);

    if ( !(pMem = ExAllocatePool( PoolType, TotalReqSize ) ) ) {
        TRAP;
        return pMem;
    }

    RtlZeroMemory( pMem, TotalReqSize );

    KeAcquireSpinLock( &UsbAudioMemMap->SpinLock, &irql );
    InsertHeadList( &UsbAudioMemMap->List, (PLIST_ENTRY)pMem );
    UsbAudioMemMap->TotalBytes += NumberOfBytes;
    KeReleaseSpinLock( &UsbAudioMemMap->SpinLock, irql );

    pMem = (PLIST_ENTRY)pMem + 1;

    *(PULONG)pMem = NumberOfBytes;

    pMem = (PULONG)pMem + 1;

    return pMem;
}

VOID
USBAudioDeallocateTrack(
    PVOID pMem
    )
{
    PULONG pNumberOfBytes = (PULONG)pMem - 1;
    PLIST_ENTRY ple = (PLIST_ENTRY)pNumberOfBytes - 1;
    KIRQL irql;

    KeAcquireSpinLock( &UsbAudioMemMap->SpinLock, &irql );
    RemoveEntryList(ple);
    UsbAudioMemMap->TotalBytes -= *pNumberOfBytes;
    KeReleaseSpinLock( &UsbAudioMemMap->SpinLock, irql );


    ExFreePool(ple);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\drivers\usbaudio.2\capture.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 2000
//
//  File:       capture.c
//
//--------------------------------------------------------------------------

#include "common.h"

#define INPUT_PACKETS_PER_REQ    10

NTSTATUS
CaptureReQueueUrb( 
    PCAPTURE_DATA_BUFFER_INFO pCapBufInfo );

NTSTATUS
CaptureBytePosition(
    PKSPIN pKsPin,
    PKSAUDIO_POSITION pPosition )
{
    PPIN_CONTEXT pPinContext = pKsPin->Context;
    PCAPTURE_PIN_CONTEXT pCapturePinContext = pPinContext->pCapturePinContext;
    ULONG ulCurrentFrame;
    KIRQL irql;
    NTSTATUS ntStatus = STATUS_SUCCESS;
    ULONG ulInputDataBytes, ulOutputBufferBytes;

    //  Routine currently assumes TypeI data
    ASSERT( (pPinContext->pUsbAudioDataRange->ulUsbDataFormat & USBAUDIO_DATA_FORMAT_TYPE_MASK) ==
             USBAUDIO_DATA_FORMAT_TYPE_I_UNDEFINED );


    KeAcquireSpinLock( &pPinContext->PinSpinLock, &irql );
    ntStatus = KsPinGetAvailableByteCount( pKsPin, 
                                           &ulInputDataBytes,
                                           &ulOutputBufferBytes );

    DbgLog("CapPos1", irql, pCapturePinContext->ulAvgBytesPerSec, ulInputDataBytes, ulOutputBufferBytes );

    if ( !NT_SUCCESS(ntStatus) ) {
        KeReleaseSpinLock( &pPinContext->PinSpinLock, irql );
        DbgLog( "CapBPEr", ntStatus, pKsPin, 0, 0 );
        TRAP;
    	return ntStatus;
    }
    
    pPosition->PlayOffset = pPosition->WriteOffset = pPinContext->ullWriteOffset;

    if ( pPinContext->fStreamStartedFlag ) {
        ntStatus = GetCurrentUSBFrame(pPinContext, &ulCurrentFrame);

        if (NT_SUCCESS(ntStatus)) {
        	// Add all completed URBs if they are less than submitted
        	pPosition->PlayOffset = pPinContext->ullTotalBytesReturned;
        	
        	// Calculate current offset based on Current frame.
        	if ((ulCurrentFrame - pPinContext->ulStreamUSBStartFrame ) < 0x7fffffff) {
            	pPosition->PlayOffset += 
            	    (( ulCurrentFrame - pPinContext->ulStreamUSBStartFrame ) *
            	    pCapturePinContext->ulAvgBytesPerSec) / 1000;
            	if ( pPosition->PlayOffset > pPosition->WriteOffset + ulOutputBufferBytes)
                    pPosition->PlayOffset = pPosition->WriteOffset + ulOutputBufferBytes;
            }

            ASSERT(pPosition->PlayOffset>=pPosition->WriteOffset);
            ASSERT(pPosition->PlayOffset<=pPosition->WriteOffset + ulOutputBufferBytes);

            DbgLog("CapBPos", pPosition->PlayOffset, pPosition->WriteOffset, 
                              ulCurrentFrame, pPinContext->ulStreamUSBStartFrame );
        }

    }

    KeReleaseSpinLock( &pPinContext->PinSpinLock, irql );

    DbgLog("CapPos2", irql, pCapturePinContext->ulAvgBytesPerSec, pPosition->WriteOffset, pPosition->PlayOffset );

    return ntStatus;

}

VOID
CaptureAvoidPipeStarvationWorker( PKSPIN pKsPin )
{
    PPIN_CONTEXT pPinContext = pKsPin->Context;
    PCAPTURE_PIN_CONTEXT pCapturePinContext = pPinContext->pCapturePinContext;
    ULONG ulInputDataBytes, ulOutputBufferBytes;
    PCAPTURE_DATA_BUFFER_INFO pCapBufInfo;
    KIRQL irql;

    // Grab the process mutex
    KsPinAcquireProcessingMutex( pKsPin );

    // First make sure that data buffer starvation still in affect
    if ( NT_SUCCESS( KsPinGetAvailableByteCount( pKsPin, 
                                                 &ulInputDataBytes,
                                                 &ulOutputBufferBytes ) ) ) {
        NTSTATUS ntStatus;

        DbgLog("CapAPSW", ulInputDataBytes, ulOutputBufferBytes, 0, 0 );      

        if ( !ulOutputBufferBytes ) {

            // Grab spinlock to remove first full buffer from queue
            KeAcquireSpinLock( &pPinContext->PinSpinLock, &irql );
            pCapBufInfo = (PCAPTURE_DATA_BUFFER_INFO)RemoveHeadList(&pCapturePinContext->FullBufferQueue);
            KeReleaseSpinLock(&pPinContext->PinSpinLock, irql);

            // Release the processing mutex
            KsPinReleaseProcessingMutex( pKsPin );

            // Account for the lost bytes? Set discontinuity flag
            pCapturePinContext->fDataDiscontinuity = TRUE;
            pCapturePinContext->ulErrantPackets += INPUT_PACKETS_PER_REQ;

            // Resubmit the request
            ntStatus = CaptureReQueueUrb( pCapBufInfo );
        }
        else {
            KsPinReleaseProcessingMutex( pKsPin );
        }
    
    }
    else {
        KsPinReleaseProcessingMutex( pKsPin );
    }

}

VOID
CaptureGateOnWorkItem( PKSPIN pKsPin )
{
    PPIN_CONTEXT pPinContext = pKsPin->Context;
    PCAPTURE_PIN_CONTEXT pCapturePinContext = pPinContext->pCapturePinContext;
    KIRQL irql;

    _DbgPrintF(DEBUGLVL_VERBOSE,("[CaptureGateOnWorkItem] pin %d\n",pKsPin->Id));

    do
    {
        // Don't want to turn on the gate if we are not running
        KeAcquireSpinLock( &pPinContext->PinSpinLock, &irql );
        if (!pCapturePinContext->fRunning) {
            KeReleaseSpinLock( &pPinContext->PinSpinLock, irql );
        }
        else {
            KeReleaseSpinLock( &pPinContext->PinSpinLock, irql );

            // Acquire the Process Mutex to ensure there will be no new requests during the gate operation
            KsPinAcquireProcessingMutex( pKsPin );

            KsGateTurnInputOn( KsPinGetAndGate(pKsPin) );

            KsPinAttemptProcessing( pKsPin, TRUE );

            DbgLog("CProcOn", pKsPin, 0, 0, 0 );

            KsPinReleaseProcessingMutex( pKsPin );
        }
    } while ( KsDecrementCountedWorker(pCapturePinContext->GateOnWorkerObject) );
}

NTSTATUS
CaptureCompleteCallback(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP pIrp,
    PCAPTURE_DATA_BUFFER_INFO pCapBufInfo )
{
    PKSPIN pKsPin = pCapBufInfo->pKsPin;
    PPIN_CONTEXT pPinContext = pKsPin->Context;
    PCAPTURE_PIN_CONTEXT pCapturePinContext = pPinContext->pCapturePinContext;
    NTSTATUS ntStatus = pIrp->IoStatus.Status;
    KIRQL irql;

    DbgLog("CUrbCmp", pCapBufInfo, pPinContext, pCapBufInfo->pUrb, ntStatus );

    if ( pCapBufInfo->pUrb->UrbIsochronousTransfer.Hdr.Status ) {
        DbgLog("CUrbErr", pCapBufInfo, pPinContext,
                          pCapBufInfo->pUrb->UrbIsochronousTransfer.Hdr.Status, 0 );
        ntStatus = STATUS_DEVICE_DATA_ERROR;
    }

    KeAcquireSpinLock(&pPinContext->PinSpinLock, &irql);
    if ( pCapturePinContext->fRunning ) {
        BOOLEAN fNeedToProcess;
        ULONG i;

        if ( pPinContext->fUrbError ) {
            DbgLog("CapUrEr", pCapBufInfo, pPinContext, pCapBufInfo->pUrb, ntStatus );
            // Queue errant URB
            InsertTailList( &pCapturePinContext->UrbErrorQueue, &pCapBufInfo->List );

            if ( 0 == InterlockedDecrement(&pPinContext->ulOutstandingUrbCount) ) {
                KeSetEvent( &pPinContext->PinStarvationEvent, 0, FALSE );
            }
            KeReleaseSpinLock(&pPinContext->PinSpinLock, irql);
            return STATUS_MORE_PROCESSING_REQUIRED;
        }

        else if (!NT_SUCCESS(ntStatus)) {
            DbgLog("CapNTEr", pCapBufInfo, pPinContext, pCapBufInfo->pUrb, ntStatus );
            pPinContext->fUrbError = TRUE;

//          pPinContext->fStreamStartedFlag = FALSE;
            if ( 0 == InterlockedDecrement(&pPinContext->ulOutstandingUrbCount) )
                KeSetEvent( &pPinContext->PinStarvationEvent, 0, FALSE );

            // Queue errant URB and queue work item
            InsertTailList( &pCapturePinContext->UrbErrorQueue, &pCapBufInfo->List );

            KeReleaseSpinLock(&pPinContext->PinSpinLock, irql);

            KsIncrementCountedWorker(pCapturePinContext->ResetWorkerObject);

            return STATUS_MORE_PROCESSING_REQUIRED;
        }

        if ( 0 == InterlockedDecrement(&pPinContext->ulOutstandingUrbCount) ) {
            DbgLog("CapStrv", pCapBufInfo, pPinContext, pCapBufInfo->pUrb, ntStatus );
            pPinContext->fUrbError = TRUE;
            KsIncrementCountedWorker(pCapturePinContext->ResetWorkerObject);
            KeSetEvent( &pPinContext->PinStarvationEvent, 0, FALSE );
        }
        else if ( 2 == pPinContext->ulOutstandingUrbCount ) {
            ULONG ulInputDataBytes, ulOutputBufferBytes;
            if ( NT_SUCCESS( KsPinGetAvailableByteCount( pKsPin, 
                                                         &ulInputDataBytes,
                                                         &ulOutputBufferBytes ) ) ) {
                DbgLog("CapStv2", ulInputDataBytes, ulOutputBufferBytes, 0, 0 );
                if ( !ulOutputBufferBytes ) {

                    // Data starvation has occurred. Need to requeue before pipe starvation occurs.
                    KsIncrementCountedWorker(pCapturePinContext->RequeueWorkerObject);
                }
            }
        }

        // Queue the completed URB for processing
        fNeedToProcess = IsListEmpty( &pCapturePinContext->FullBufferQueue ) &&
                                      !pCapturePinContext->fProcessing;
        InsertTailList( &pCapturePinContext->FullBufferQueue, &pCapBufInfo->List );

        if ( fNeedToProcess ) {
            pCapturePinContext->fProcessing = TRUE;

            // Queue a work item to handle this so that we don't race with the gate
            // count in the processing routine

            KsIncrementCountedWorker(pCapturePinContext->GateOnWorkerObject);
        }

        for (i=0; i<INPUT_PACKETS_PER_REQ; i++) {
        	PUSBD_ISO_PACKET_DESCRIPTOR pIsoPacket = 
        		    &pCapBufInfo->pUrb->UrbIsochronousTransfer.IsoPacket[i];
            if ( USBD_SUCCESS(pIsoPacket->Status) )
                pPinContext->ullTotalBytesReturned += pIsoPacket->Length;
        }

        pPinContext->ulStreamUSBStartFrame = 
                    pCapBufInfo->pUrb->UrbIsochronousTransfer.StartFrame +
                    INPUT_PACKETS_PER_REQ;
        DbgLog( "CapCBPs", pPinContext->ullTotalBytesReturned,
        	               pPinContext->ulStreamUSBStartFrame,
        	               pPinContext->ullWriteOffset,
        	               pPinContext->ulOutstandingUrbCount );

    }
    else if ( 0 == InterlockedDecrement(&pPinContext->ulOutstandingUrbCount) ) {
        DbgLog("CapNtRn", pCapBufInfo, pPinContext, pCapBufInfo->pUrb, ntStatus );
        KeSetEvent( &pPinContext->PinStarvationEvent, 0, FALSE );
    }
    KeReleaseSpinLock(&pPinContext->PinSpinLock, irql);

    return STATUS_MORE_PROCESSING_REQUIRED;
}

VOID
CaptureInitializeUrbAndIrp( PCAPTURE_DATA_BUFFER_INFO pCapBufInfo )
{
    PKSPIN pKsPin = pCapBufInfo->pKsPin;
    PPIN_CONTEXT pPinContext = pKsPin->Context;
    PIRP pIrp = pCapBufInfo->pIrp;
    PURB pUrb = pCapBufInfo->pUrb;
    PIO_STACK_LOCATION pNextStack;
    ULONG siz, j;

    siz = GET_ISO_URB_SIZE(INPUT_PACKETS_PER_REQ);

    // Initialize all URBs to zero
    RtlZeroMemory(pUrb, siz);

    pUrb->UrbIsochronousTransfer.Hdr.Length      = (USHORT) siz;
    pUrb->UrbIsochronousTransfer.Hdr.Function    = URB_FUNCTION_ISOCH_TRANSFER;
    pUrb->UrbIsochronousTransfer.PipeHandle      = pPinContext->hPipeHandle;
    pUrb->UrbIsochronousTransfer.TransferFlags   = USBD_START_ISO_TRANSFER_ASAP |
                                                   USBD_TRANSFER_DIRECTION_IN;
    pUrb->UrbIsochronousTransfer.StartFrame      = 0;
    pUrb->UrbIsochronousTransfer.NumberOfPackets = INPUT_PACKETS_PER_REQ;

    for ( j=0; j<INPUT_PACKETS_PER_REQ; j++ )
      pUrb->UrbIsochronousTransfer.IsoPacket[j].Offset = j*pPinContext->ulMaxPacketSize;

    pUrb->UrbIsochronousTransfer.TransferBuffer       = pCapBufInfo->pData;
    pUrb->UrbIsochronousTransfer.TransferBufferLength = INPUT_PACKETS_PER_REQ*
                                                        pPinContext->ulMaxPacketSize;

    IoInitializeIrp( pIrp,
                     IoSizeOfIrp(pPinContext->pNextDeviceObject->StackSize),
                     pPinContext->pNextDeviceObject->StackSize );

    pNextStack = IoGetNextIrpStackLocation(pIrp);
    ASSERT(pNextStack != NULL);

    pNextStack->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
    pNextStack->Parameters.Others.Argument1 = pCapBufInfo->pUrb;
    pNextStack->Parameters.DeviceIoControl.IoControlCode = IOCTL_INTERNAL_USB_SUBMIT_URB;

    IoSetCompletionRoutine ( pIrp, CaptureCompleteCallback, pCapBufInfo, TRUE, TRUE, TRUE );

    DbgLog("IniIrpU", pCapBufInfo, pIrp, pUrb, pNextStack );

}

NTSTATUS
CaptureReQueueUrb( PCAPTURE_DATA_BUFFER_INFO pCapBufInfo )
{
    PKSPIN pKsPin = pCapBufInfo->pKsPin;
    PPIN_CONTEXT pPinContext = pKsPin->Context;
    PCAPTURE_PIN_CONTEXT pCapturePinContext = pPinContext->pCapturePinContext;
    KIRQL irql;

    NTSTATUS ntStatus = STATUS_SUCCESS;

    KeAcquireSpinLock(&pPinContext->PinSpinLock, &irql);
    if ( pCapturePinContext->fRunning ) {
        KeReleaseSpinLock(&pPinContext->PinSpinLock, irql);

        CaptureInitializeUrbAndIrp( pCapBufInfo );

        InterlockedIncrement(&pPinContext->ulOutstandingUrbCount);

        DbgLog("ReQue", pPinContext, pPinContext->ulOutstandingUrbCount,
                        pCapBufInfo, 0);
        ASSERT(pPinContext->ulOutstandingUrbCount <= CAPTURE_URBS_PER_PIN);

        ntStatus = IoCallDriver( pPinContext->pNextDeviceObject,
                                 pCapBufInfo->pIrp );
    }
    else
        KeReleaseSpinLock(&pPinContext->PinSpinLock, irql);

    return ntStatus;

}

VOID
CaptureResetWorkItem( PKSPIN pKsPin )
{
    PPIN_CONTEXT pPinContext = pKsPin->Context;
    PCAPTURE_PIN_CONTEXT pCapturePinContext = pPinContext->pCapturePinContext;
    PCAPTURE_DATA_BUFFER_INFO pCapBufInfo = NULL;
    NTSTATUS ntStatus;
    KIRQL irql;

    _DbgPrintF(DEBUGLVL_VERBOSE,("[CaptureResetWorkItem] pin %d\n",pKsPin->Id));

    do
    {
        // Acquire the Process Mutex to ensure there will be no new requests during the reset
        KsPinAcquireProcessingMutex( pKsPin );

        pCapturePinContext->fDataDiscontinuity = TRUE;

        ntStatus = 
            KeWaitForMutexObject( &pCapturePinContext->CaptureInitMutex,
                                  Executive,
                                  KernelMode,
                                  FALSE,
                                  NULL );

        // Abort the Pipe and wait for it to clear
        ntStatus = AbortUSBPipe( pPinContext );
        if ( NT_SUCCESS(ntStatus) ) {

            // IF still running resubmit errant Urbs
            KeAcquireSpinLock( &pPinContext->PinSpinLock, &irql );
            if ( pCapturePinContext->fRunning ) {

                // Requeue Urbs
                while ( !IsListEmpty(&pCapturePinContext->UrbErrorQueue) ) {
                    pCapBufInfo = (PCAPTURE_DATA_BUFFER_INFO)RemoveHeadList(&pCapturePinContext->UrbErrorQueue);
                    KeReleaseSpinLock( &pPinContext->PinSpinLock, irql );
                    ntStatus = CaptureReQueueUrb( pCapBufInfo );
                    KeAcquireSpinLock( &pPinContext->PinSpinLock, &irql );

                    if ( !NT_SUCCESS(ntStatus) ) {
                        // An error here means that the ResetWorkerObject has been incremented
                        // and the UrbErrorQueue has another entry. If we just keep trying to
                        // empty the UrbErrorQueue, we stand the chance of going into an infinite
                        // loop (especially if this failed due to Surprise Removal).
                        //
                        // Breaking out now lets the AbortUSBPipe get another stab at clearing
                        // things up. If it fails, then we know something is very wrong, and
                        // we will halt the recovery process.
                        break;
                    }
                }
                KeReleaseSpinLock( &pPinContext->PinSpinLock, irql );
            }
            else
                KeReleaseSpinLock( &pPinContext->PinSpinLock, irql );
        }

        KeReleaseMutex( &pCapturePinContext->CaptureInitMutex, FALSE );

        KsPinReleaseProcessingMutex( pKsPin );
    } while (KsDecrementCountedWorker(pCapturePinContext->ResetWorkerObject));
}

NTSTATUS
CaptureProcess( PKSPIN pKsPin )
{
    PPIN_CONTEXT pPinContext = pKsPin->Context;
    PCAPTURE_PIN_CONTEXT pCapturePinContext = pPinContext->pCapturePinContext;
    PCAPTURE_DATA_BUFFER_INFO pCapBufInfo = NULL;
    PUSBD_ISO_PACKET_DESCRIPTOR pIsoPacket;
    PKSSTREAM_POINTER pKsStreamPtr;
    ULONG ulStreamRemaining;
    ULONG ulIsochBuffer;
    ULONG ulIsochRemaining;
    ULONG ulIsochBufferOffset;
    PUCHAR pIsochData;
    KIRQL irql;

    // While there is device data available and there are data buffers to
    // be filled copy device data to data buffers.

    DbgLog("CapProc", pKsPin, pPinContext, pCapturePinContext, 0 );

    // First check if there is a capture buffer in use and complete it if so
    if ( pCapturePinContext->pCaptureBufferInUse ) {
        pCapBufInfo         = pCapturePinContext->pCaptureBufferInUse;
        pIsoPacket          = pCapBufInfo->pUrb->UrbIsochronousTransfer.IsoPacket;
        ulIsochBuffer       = pCapturePinContext->ulIsochBuffer;
        ulIsochBufferOffset = pCapturePinContext->ulIsochBufferOffset;
        ulIsochRemaining    = pIsoPacket[ulIsochBuffer].Length - ulIsochBufferOffset;
        pIsochData          = pCapBufInfo->pData + pIsoPacket[ulIsochBuffer].Offset;

        pCapturePinContext->pCaptureBufferInUse = NULL;
        DbgLog("CapInf1", pCapBufInfo, ulIsochBuffer, ulIsochBufferOffset, pIsochData );
    }
    else {
        BOOLEAN fFound = FALSE;
        KeAcquireSpinLock(&pPinContext->PinSpinLock, &irql);

        while ( !IsListEmpty( &pCapturePinContext->FullBufferQueue) && !fFound ) {
            pCapBufInfo = (PCAPTURE_DATA_BUFFER_INFO)RemoveHeadList(&pCapturePinContext->FullBufferQueue);
            KeReleaseSpinLock(&pPinContext->PinSpinLock, irql);

            ulIsochBuffer = 0;
            pIsoPacket = pCapBufInfo->pUrb->UrbIsochronousTransfer.IsoPacket;
            while ( USBD_ERROR(pIsoPacket[ulIsochBuffer].Status) && 
                  ( ulIsochBuffer < INPUT_PACKETS_PER_REQ) ) {
                ulIsochBuffer++;
                pCapturePinContext->ulErrantPackets++;
                pCapturePinContext->fDataDiscontinuity = TRUE;
            }

            fFound = ulIsochBuffer < INPUT_PACKETS_PER_REQ;

            KeAcquireSpinLock(&pPinContext->PinSpinLock, &irql);

            if ( !fFound ) {
                // Requeue used capture buffer
                NTSTATUS ntStatus = CaptureReQueueUrb( pCapBufInfo );
                if ( !NT_SUCCESS(ntStatus) ) {
                    // Log this, but it's okay to continue flushing the data we already have
                    DbgLog("CReQErr", pCapBufInfo, pCapturePinContext, pPinContext, ntStatus );
                }
            }
        }

        if ( !fFound ) {
            _DbgPrintF(DEBUGLVL_TERSE,("[CaptureProcess] No valid data returned from device yet. Returning STATUS_PENDING!\n"));
            KsGateTurnInputOff( KsPinGetAndGate(pKsPin) );
            pCapturePinContext->fProcessing = FALSE;
            KeReleaseSpinLock(&pPinContext->PinSpinLock, irql);
            DbgLog("CapBail", pKsPin, pPinContext, pCapturePinContext, pCapturePinContext->fProcessing );
            return STATUS_PENDING;
        }
        else {
            // Set stream started flag if not already done
            if ( !pPinContext->fStreamStartedFlag ) {
                pPinContext->fStreamStartedFlag    = TRUE;
            }
            KeReleaseSpinLock(&pPinContext->PinSpinLock, irql);

            ulIsochBufferOffset = 0;
            pIsochData          = pCapBufInfo->pData;
            ulIsochRemaining    = pIsoPacket[ulIsochBuffer].Length;
            DbgLog("CapInf2", pCapBufInfo, ulIsochBuffer, ulIsochBufferOffset, pIsochData );
        }
    }

    // Get leading edge
    pKsStreamPtr = KsPinGetLeadingEdgeStreamPointer( pKsPin, KSSTREAM_POINTER_STATE_LOCKED );
    if ( !pKsStreamPtr ) {
        _DbgPrintF(DEBUGLVL_VERBOSE,("[CaptureProcess] Leading edge is NULL\n"));
        DbgLog("CapBl2", pKsPin, pPinContext, pCapturePinContext, pCapturePinContext->fProcessing );
        return STATUS_SUCCESS;
    }

    if (  pCapturePinContext->fDataDiscontinuity && pKsStreamPtr->StreamHeader ) {
        pKsStreamPtr->StreamHeader->OptionsFlags |= KSSTREAM_HEADER_OPTIONSF_DATADISCONTINUITY;
        pCapturePinContext->fDataDiscontinuity = FALSE;
    }

    ulStreamRemaining = pKsStreamPtr->OffsetOut.Remaining;

    DbgLog("DatPtr", pKsStreamPtr, pKsStreamPtr->OffsetOut.Data, pKsStreamPtr->StreamHeader->Data, 0);

    // Fill buffer with captured data
    while ( pKsStreamPtr && pCapBufInfo ) {

        ULONG ulCopySize = ( ulIsochRemaining <= ulStreamRemaining ) ?
                             ulIsochRemaining  : ulStreamRemaining;

        DbgLog("CapLp1", pKsStreamPtr, pCapBufInfo, ulIsochRemaining, ulStreamRemaining );
        DbgLog("CapLp2", pKsStreamPtr->OffsetOut.Data, pIsochData, 0, 0 );

        ASSERT((LONG)ulStreamRemaining > 0);
        ASSERT((LONG)ulIsochBufferOffset >= 0);

        RtlCopyMemory( pKsStreamPtr->OffsetOut.Data,
                       pIsochData + ulIsochBufferOffset,
                       ulCopySize );

        ulStreamRemaining -= ulCopySize;
        ulIsochRemaining  -= ulCopySize;

        // Check if done with this stream header
        if ( !ulStreamRemaining ) {
            KsStreamPointerAdvanceOffsetsAndUnlock( pKsStreamPtr, 0, ulCopySize, TRUE );
            // Get Next stream header if there is one.
            if ( pKsStreamPtr = KsPinGetLeadingEdgeStreamPointer( pKsPin, KSSTREAM_POINTER_STATE_LOCKED )) {
                ulStreamRemaining = pKsStreamPtr->OffsetOut.Remaining;
            }
        }
        else {
            KsStreamPointerAdvanceOffsets( pKsStreamPtr, 0, ulCopySize, FALSE );
        }

        pPinContext->ullWriteOffset += ulCopySize;

        // Check if Done with isoch cycle data
        if ( !ulIsochRemaining ) {

            // Check if not done with capture buffer
            while (( ++ulIsochBuffer < INPUT_PACKETS_PER_REQ ) && 
                     USBD_ERROR(pIsoPacket[ulIsochBuffer].Status) );

            if ( ulIsochBuffer < INPUT_PACKETS_PER_REQ ) {
                ulIsochBufferOffset = 0;
                pIsochData = pCapBufInfo->pData + pIsoPacket[ulIsochBuffer].Offset;
                ulIsochRemaining = pIsoPacket[ulIsochBuffer].Length;
            }
            else {
                NTSTATUS ntStatus;
                BOOLEAN fFound = FALSE;

                // Requeue used capture buffer
                ntStatus = CaptureReQueueUrb( pCapBufInfo );
                if ( !NT_SUCCESS(ntStatus) ) {
                    // Log this, but it's okay to continue flushing the data we already have
                    DbgLog("CReQErr", pCapBufInfo, pCapturePinContext, pPinContext, ntStatus );
                }

                // Check if there is more captured data queued
                // Grab Spinlock to check capture queue
                KeAcquireSpinLock(&pPinContext->PinSpinLock, &irql);
                while ( !IsListEmpty( &pCapturePinContext->FullBufferQueue ) & !fFound) {
                    pCapBufInfo = (PCAPTURE_DATA_BUFFER_INFO)
                           RemoveHeadList(&pCapturePinContext->FullBufferQueue);
                    KeReleaseSpinLock(&pPinContext->PinSpinLock, irql);

                    // Find the first good packet in the Urb.

                    ulIsochBuffer = 0;
                    pIsoPacket = pCapBufInfo->pUrb->UrbIsochronousTransfer.IsoPacket;

                    while ( USBD_ERROR(pIsoPacket[ulIsochBuffer].Status) && 
                          ( ulIsochBuffer < INPUT_PACKETS_PER_REQ) ) {
                        ulIsochBuffer++;
                        pCapturePinContext->ulErrantPackets++;
                        pCapturePinContext->fDataDiscontinuity = TRUE;
                    }

                    fFound = ulIsochBuffer < INPUT_PACKETS_PER_REQ;

                    KeAcquireSpinLock(&pPinContext->PinSpinLock, &irql);
                }
                if ( !fFound ) {
                    KsGateTurnInputOff( KsPinGetAndGate(pKsPin) );
                    pCapturePinContext->fProcessing = FALSE;
                    KeReleaseSpinLock(&pPinContext->PinSpinLock, irql);

                    DbgLog("CPrcOff", pCapBufInfo, pCapturePinContext, pPinContext, pCapturePinContext->fProcessing );
                    pCapBufInfo = NULL;
                }
                else {
                    KeReleaseSpinLock(&pPinContext->PinSpinLock, irql);
                    ulIsochBufferOffset = 0;
                    ulIsochRemaining = pIsoPacket[ulIsochBuffer].Length;
                    pIsochData       = pCapBufInfo->pData + pIsoPacket[ulIsochBuffer].Offset;
                }
            }
        }
        else {
            ulIsochBufferOffset += ulCopySize;
        }
    }

    if ( !pCapBufInfo ) {
        if ( pKsStreamPtr ) {
            KsStreamPointerUnlock(pKsStreamPtr, FALSE);
        }

        DbgLog("CapPend", pCapturePinContext, pPinContext, pCapturePinContext->fProcessing, 0 );

        // No more capture buffers pending from the device.  Return STATUS_PENDING so that KS
        // doesn't keep calling back into the process routine.  The AndGate should have been
        // turned off at this point to prevent an endless loop too.
        return STATUS_PENDING;
    }
    else { // if ( !pKsStreamPtr )
        pCapturePinContext->pCaptureBufferInUse = pCapBufInfo;
        pCapturePinContext->ulIsochBuffer       = ulIsochBuffer;
        pCapturePinContext->ulIsochBufferOffset = ulIsochBufferOffset;

        DbgLog("CapScss", pCapturePinContext, pPinContext, pCapturePinContext->fProcessing, 0 );

        // Allow KS to call us back if there is more available buffers from the client.  We
        // are ready to process more data.
        return STATUS_SUCCESS;
    }
}

NTSTATUS
CaptureStartIsocTransfer(
    PPIN_CONTEXT pPinContext
    )
{
    PCAPTURE_PIN_CONTEXT pCapturePinContext = pPinContext->pCapturePinContext;
    PCAPTURE_DATA_BUFFER_INFO pCapBufInfo;
    NTSTATUS ntStatus;
    ULONG i;

    if (!pCapturePinContext->fRunning) {


        ntStatus = 
            KeWaitForMutexObject( &pCapturePinContext->CaptureInitMutex,
                                  Executive,
                                  KernelMode,
                                  FALSE,
                                  NULL );

        pCapturePinContext->fRunning = TRUE;
        pCapBufInfo = pCapturePinContext->CaptureDataBufferInfo;

        for ( i=0; i<CAPTURE_URBS_PER_PIN; i++, pCapBufInfo++ ) {
            InterlockedIncrement(&pPinContext->ulOutstandingUrbCount);

            ASSERT(pPinContext->ulOutstandingUrbCount <= CAPTURE_URBS_PER_PIN);
            DbgLog("CapStrt", pPinContext, pPinContext->ulOutstandingUrbCount,
                              pCapturePinContext->CaptureDataBufferInfo[i].pIrp, i);

            CaptureInitializeUrbAndIrp( pCapBufInfo );

            ntStatus = IoCallDriver( pPinContext->pNextDeviceObject,
                                     pCapturePinContext->CaptureDataBufferInfo[i].pIrp);

            if ( !NT_SUCCESS(ntStatus) ) {
                pCapturePinContext->fRunning = FALSE;
                return ntStatus;
            }
        }

        KeReleaseMutex( &pCapturePinContext->CaptureInitMutex, FALSE );

    }

    return STATUS_SUCCESS;
}


NTSTATUS
CaptureStateChange(
    PKSPIN pKsPin,
    KSSTATE OldKsState,
    KSSTATE NewKsState )
{
    PPIN_CONTEXT pPinContext = pKsPin->Context;
    PCAPTURE_PIN_CONTEXT pCapturePinContext = pPinContext->pCapturePinContext;
    NTSTATUS ntStatus = STATUS_SUCCESS;
    KIRQL irql;

    _DbgPrintF(DEBUGLVL_VERBOSE,("[CaptureStateChange] NewKsState: %d pKsPin: %x\n", NewKsState, pKsPin));
    DbgLog("CState", pPinContext, pCapturePinContext, NewKsState, OldKsState );

    if (OldKsState != NewKsState) {
        switch(NewKsState) {
            case KSSTATE_STOP:
                if ( pCapturePinContext->fRunning ) AbortUSBPipe( pPinContext );

                KeAcquireSpinLock( &pPinContext->PinSpinLock, &irql );
                pPinContext->fUrbError = FALSE;
                pCapturePinContext->fRunning = FALSE;
                pCapturePinContext->ulErrantPackets = 0;
                pCapturePinContext->fDataDiscontinuity = FALSE;
                pCapturePinContext->fProcessing = FALSE;
                pPinContext->ullWriteOffset = 0;
                pPinContext->ullTotalBytesReturned = 0;

                InitializeListHead( &pCapturePinContext->UrbErrorQueue );
                InitializeListHead( &pCapturePinContext->FullBufferQueue  );
                KeReleaseSpinLock( &pPinContext->PinSpinLock, irql );

                break;

            case KSSTATE_ACQUIRE:
            case KSSTATE_PAUSE:
                KeAcquireSpinLock( &pPinContext->PinSpinLock, &irql );
                pPinContext->fUrbError = FALSE;
                pCapturePinContext->fRunning = FALSE;
                pCapturePinContext->fDataDiscontinuity = FALSE;
                pCapturePinContext->ulErrantPackets = 0;
                pCapturePinContext->fProcessing = FALSE;
                pCapturePinContext->pCaptureBufferInUse = NULL;
                pCapturePinContext->ulIsochBuffer = 0;
                pCapturePinContext->ulIsochBufferOffset = 0;

                InitializeListHead( &pCapturePinContext->UrbErrorQueue );
                InitializeListHead( &pCapturePinContext->FullBufferQueue  );
                KeReleaseSpinLock( &pPinContext->PinSpinLock, irql );

                USBAudioPinWaitForStarvation( pKsPin );
                break;

            case KSSTATE_RUN:
                ntStatus = CaptureStartIsocTransfer( pPinContext );
                break;

        }
    }

    return STATUS_SUCCESS;
}

NTSTATUS
CaptureStreamInit( PKSPIN pKsPin )
{
    PPIN_CONTEXT pPinContext = pKsPin->Context;
    PCAPTURE_PIN_CONTEXT pCapturePinContext;
    PCAPTURE_DATA_BUFFER_INFO pCapBufInfo;
    PKSALLOCATOR_FRAMING_EX pKsAllocatorFramingEx;
    ULONG ulUrbSize = GET_ISO_URB_SIZE(INPUT_PACKETS_PER_REQ);
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PUCHAR pData;
    PURB pUrbs;
    ULONG BufferSize;
    ULONG i;

    _DbgPrintF(DEBUGLVL_VERBOSE,("[CaptureStreamInit] pKsPin: %x\n", pKsPin));

    pPinContext->PinType = WaveIn;

    // Allocate Capture Context and data buffers
    pCapturePinContext = pPinContext->pCapturePinContext =
        AllocMem(NonPagedPool, sizeof(CAPTURE_PIN_CONTEXT) +
                               CAPTURE_URBS_PER_PIN *
                                        ( ulUrbSize +
                                        ( (pPinContext->ulMaxPacketSize) * INPUT_PACKETS_PER_REQ )) );
    if (!pCapturePinContext)
        return STATUS_INSUFFICIENT_RESOURCES;

    KsAddItemToObjectBag(pKsPin->Bag, pCapturePinContext, FreeMem);

    pCapBufInfo = pCapturePinContext->CaptureDataBufferInfo;

    pUrbs = (PURB)(pCapturePinContext + 1);

    pData = (PUCHAR)pUrbs + ulUrbSize * CAPTURE_URBS_PER_PIN;

    for ( i=0; i<CAPTURE_URBS_PER_PIN; i++, pCapBufInfo++ ) {
        pCapBufInfo->pKsPin = pKsPin;
        pCapBufInfo->pData  = pData + (i*pPinContext->ulMaxPacketSize*INPUT_PACKETS_PER_REQ);
        pCapBufInfo->pUrb   = (PURB)((PUCHAR)pUrbs + (ulUrbSize*i));
        pCapBufInfo->pIrp   = IoAllocateIrp( pPinContext->pNextDeviceObject->StackSize, FALSE );
        if (!pCapBufInfo->pIrp) return STATUS_INSUFFICIENT_RESOURCES;
        KsAddItemToObjectBag(pKsPin->Bag, pCapBufInfo->pIrp, IoFreeIrp);
    }

    // Set pCapturePinContext->ulAvgBytesPerSec for position info
    switch( pPinContext->pUsbAudioDataRange->ulUsbDataFormat & USBAUDIO_DATA_FORMAT_TYPE_MASK ) {
        case USBAUDIO_DATA_FORMAT_TYPE_I_UNDEFINED:
            {
                PKSDATAFORMAT_WAVEFORMATEX pFmt = (PKSDATAFORMAT_WAVEFORMATEX)pKsPin->ConnectionFormat;
                pCapturePinContext->ulAvgBytesPerSec = pFmt->WaveFormatEx.nAvgBytesPerSec;
                pCapturePinContext->ulCurrentSampleRate = pFmt->WaveFormatEx.nSamplesPerSec;
                pCapturePinContext->ulBytesPerSample = ((ULONG)pFmt->WaveFormatEx.wBitsPerSample >> 3) *
                                                        (ULONG)pFmt->WaveFormatEx.nChannels;

                // Set the current Sample rate
                ntStatus = SetSampleRate(pKsPin, &pCapturePinContext->ulCurrentSampleRate);
                if (!NT_SUCCESS(ntStatus)) {
                    return ntStatus;
                }
            }
            break;
        case USBAUDIO_DATA_FORMAT_TYPE_II_UNDEFINED:
        case USBAUDIO_DATA_FORMAT_TYPE_III_UNDEFINED:
        default:
            return STATUS_NOT_SUPPORTED;
            break;
    }

    // Set up allocator framing based on gBufferDuration which is read from
    // the registry.  gBufferDuration is the desired duration in usec.

    BufferSize = (ULONG)(((pCapturePinContext->ulCurrentSampleRate * (ULONGLONG)gBufferDuration) + 0 )/1000000) * pCapturePinContext->ulBytesPerSample;

    // Make sure we always have space for at least one sample.

    if (!BufferSize) {
        BufferSize = pCapturePinContext->ulBytesPerSample;
    }

    pKsAllocatorFramingEx = (PKSALLOCATOR_FRAMING_EX)pKsPin->Descriptor->AllocatorFraming;
    pKsAllocatorFramingEx->FramingItem[0].FramingRange.Range.MinFrameSize = 
    pKsAllocatorFramingEx->FramingItem[0].FramingRange.Range.MaxFrameSize = BufferSize;
    pKsAllocatorFramingEx->FramingItem[0].FramingRange.Range.Stepping = pCapturePinContext->ulBytesPerSample;

    // Initialize the Full Buffer list
    InitializeListHead( &pCapturePinContext->FullBufferQueue );

    // Set initial running flag to FALSE
    pCapturePinContext->fRunning = FALSE;

    // Set initial running flag to FALSE
    pCapturePinContext->fProcessing = FALSE;

    // Set initial Data Discontinuity flag to FALSE
    pCapturePinContext->fDataDiscontinuity = FALSE;

    // Initialize buffer in use pointer
    pCapturePinContext->pCaptureBufferInUse = NULL;

    // Initialize Worker item, object and list for potential error recovery
    InitializeListHead( &pCapturePinContext->UrbErrorQueue );

    ExInitializeWorkItem( &pCapturePinContext->ResetWorkItem,
                          CaptureResetWorkItem,
                          pKsPin );

    ntStatus = KsRegisterCountedWorker( CriticalWorkQueue,
                                        &pCapturePinContext->ResetWorkItem,
                                        &pCapturePinContext->ResetWorkerObject );
    if (!NT_SUCCESS(ntStatus)) {
        return ntStatus;
    }

    // Initialize Worker item for turning the Gate on when new data arrives from the deveice
    ExInitializeWorkItem( &pCapturePinContext->GateOnWorkItem,
                          CaptureGateOnWorkItem,
                          pKsPin );

    ntStatus = KsRegisterCountedWorker( CriticalWorkQueue,
                                        &pCapturePinContext->GateOnWorkItem,
                                        &pCapturePinContext->GateOnWorkerObject );
    if (!NT_SUCCESS(ntStatus)) {
        return ntStatus;
    }

    // Initialize Worker item, object and list for potential error recovery
    InitializeListHead( &pCapturePinContext->OutstandingUrbQueue );

    ExInitializeWorkItem( &pCapturePinContext->RequeueWorkItem,
                          CaptureAvoidPipeStarvationWorker,
                          pKsPin );

    ntStatus = KsRegisterCountedWorker( CriticalWorkQueue,
                                        &pCapturePinContext->RequeueWorkItem,
                                        &pCapturePinContext->RequeueWorkerObject);
    if (!NT_SUCCESS(ntStatus)) {
        return ntStatus;
    }

    KeInitializeMutex( &pCapturePinContext->CaptureInitMutex, PASSIVE_LEVEL );

    // Disable Processing on the pin until data is available.
    KsGateTurnInputOff( KsPinGetAndGate(pKsPin) );

    return ntStatus;
}

NTSTATUS
CaptureStreamClose( PKSPIN pKsPin )
{
    PPIN_CONTEXT pPinContext = pKsPin->Context;
    PCAPTURE_PIN_CONTEXT pCapturePinContext = pPinContext->pCapturePinContext;

    _DbgPrintF(DEBUGLVL_TERSE,("[CaptureStreamClose] pin %d pKsPin: %x\n",pKsPin->Id, pKsPin));

    // Clear out all pending KS workitems by unregistering the worker routine
    KsUnregisterWorker( pCapturePinContext->ResetWorkerObject );
    KsUnregisterWorker( pCapturePinContext->GateOnWorkerObject );

    // Wait for all outstanding Urbs to complete.
    USBAudioPinWaitForStarvation( pKsPin );

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\drivers\usbaudio.2\descript.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 2000
//
//  File:       descript.c
//
//--------------------------------------------------------------------------

#include "common.h"

#if DBG

VOID
DumpGenericDescriptor( PUCHAR pDescriptor )
{
    ULONG i, j;

    _DbgPrintF(DEBUGLVL_VERBOSE,("-------------------------\n"));
    _DbgPrintF(DEBUGLVL_VERBOSE,("GENERIC DESCRIPTOR: %x\n  ",pDescriptor));

    for (i=0; i<pDescriptor[0];) {
       for ( j=0; (j<16 && i<pDescriptor[0]); j++, i++ )
           _DbgPrintF(DEBUGLVL_VERBOSE,(" 0x%2.2x",pDescriptor[i] ));
       _DbgPrintF(DEBUGLVL_VERBOSE,("\n ",pDescriptor[i] ));
    }
}

VOID DumpHeaderUnit( PAUDIO_HEADER_UNIT pDescriptor )
{
    ULONG i;

    _DbgPrintF(DEBUGLVL_VERBOSE,("-------------------------\n"));
    _DbgPrintF(DEBUGLVL_VERBOSE,("HEADER UNIT: %x\n",pDescriptor));
    _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  Length:            0x%2.2x\n",pDescriptor->bLength));
    _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  DescriptorType:    0x%2.2x\n",pDescriptor->bDescriptorType));
    _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  DescriptorSubtype: 0x%2.2x\n",pDescriptor->bDescriptorSubtype));
    _DbgPrintF(DEBUGLVL_VERBOSE,("   SHORT bcdAudioSpec:      0x%4.4x\n",pDescriptor->bcdAudioSpec));
    _DbgPrintF(DEBUGLVL_VERBOSE,("   SHORT TotalLength:       0x%4.4x\n",pDescriptor->wTotalLength));
    _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  InCollection:      0x%2.2x (# Streaming I/F's)\n",pDescriptor->bInCollection));
    for ( i=0; i<pDescriptor->bInCollection; i++ )
        _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  baInterfaceNr[%d]:  0x%2.2x\n",i,pDescriptor->baInterfaceNr[i]));

}

VOID DumpInputTerminal( PAUDIO_INPUT_TERMINAL pDescriptor )
{
    _DbgPrintF(DEBUGLVL_VERBOSE,("-------------------------\n"));
    _DbgPrintF(DEBUGLVL_VERBOSE,("INPUT TERMINAL: %x\n",pDescriptor));
    _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  Length:            0x%2.2x\n",pDescriptor->bLength));
    _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  DescriptorType:    0x%2.2x\n",pDescriptor->bDescriptorType));
    _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  DescriptorSubtype: 0x%2.2x\n",pDescriptor->bDescriptorSubtype));
    _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  bUnitID:           0x%2.2x\n",pDescriptor->bUnitID));
    _DbgPrintF(DEBUGLVL_VERBOSE,("   SHORT wTerminalType:     0x%4.4x\n",pDescriptor->wTerminalType));
    _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  bAssocTerminal:    0x%2.2x\n",pDescriptor->bAssocTerminal));
    _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  bNrChannels:       0x%2.2x\n",pDescriptor->bNrChannels));
    _DbgPrintF(DEBUGLVL_VERBOSE,("   SHORT wChannelConfig:    0x%4.4x\n",pDescriptor->wChannelConfig));
    _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  iChannelNames:     0x%2.2x\n",pDescriptor->iChannelNames));
    _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  iTerminal:         0x%2.2x\n",pDescriptor->iTerminal));

}

VOID DumpOutputTerminal( PAUDIO_OUTPUT_TERMINAL pDescriptor )
{
    _DbgPrintF(DEBUGLVL_VERBOSE,("-------------------------\n"));
    _DbgPrintF(DEBUGLVL_VERBOSE,("OUTPUT TERMINAL: %x\n",pDescriptor));
    _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  Length:            0x%2.2x\n",pDescriptor->bLength));
    _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  DescriptorType:    0x%2.2x\n",pDescriptor->bDescriptorType));
    _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  DescriptorSubtype: 0x%2.2x\n",pDescriptor->bDescriptorSubtype));
    _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  bUnitID:           0x%2.2x\n",pDescriptor->bUnitID));
    _DbgPrintF(DEBUGLVL_VERBOSE,("   SHORT wTerminalType:     0x%4.4x\n",pDescriptor->wTerminalType));
    _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  bAssocTerminal:    0x%2.2x\n",pDescriptor->bAssocTerminal));
    _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  bSourceID:         0x%2.2x\n",pDescriptor->bSourceID));
    _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  iTerminal:         0x%2.2x\n",pDescriptor->iTerminal));
}

VOID DumpMixerUnit( PAUDIO_MIXER_UNIT pDescriptor )
{
    ULONG i;
    PAUDIO_MIXER_UNIT_CHANNELS pMixChannels =
           (PAUDIO_MIXER_UNIT_CHANNELS)(pDescriptor->baSourceID + pDescriptor->bNrInPins);

    _DbgPrintF(DEBUGLVL_VERBOSE,("-------------------------\n"));
    _DbgPrintF(DEBUGLVL_VERBOSE,("MIXER UNIT: %x\n",pDescriptor));
    _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  Length:            0x%2.2x\n",pDescriptor->bLength));
    _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  DescriptorType:    0x%2.2x\n",pDescriptor->bDescriptorType));
    _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  DescriptorSubtype: 0x%2.2x\n",pDescriptor->bDescriptorSubtype));
    _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  bUnitID:           0x%2.2x\n",pDescriptor->bUnitID));
    _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  bNrInPins:         0x%2.2x\n",pDescriptor->bNrInPins));

    for (i=0;i<pDescriptor->bNrInPins; i++)
        _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  baSourceID[%d]:     0x%2.2x\n",i,pDescriptor->baSourceID[i]));

    _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  bNrChannels:       0x%2.2x\n",pMixChannels->bNrChannels));
    _DbgPrintF(DEBUGLVL_VERBOSE,("   SHORT wChannelConfig:    0x%4.4x\n",pMixChannels->wChannelConfig));
    _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  iChannelNames:     0x%2.2x\n",pMixChannels->iChannelNames));
    _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  bmControls:        0x%2.2x\n",pMixChannels->bmControls[0]));

}

VOID DumpSelectorUnit( PAUDIO_SELECTOR_UNIT pDescriptor )
{
    ULONG i;

    _DbgPrintF(DEBUGLVL_VERBOSE,("-------------------------\n"));
    _DbgPrintF(DEBUGLVL_VERBOSE,("SELECTOR UNIT: %x\n",pDescriptor));
    _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  Length:            0x%2.2x\n",pDescriptor->bLength));
    _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  DescriptorType:    0x%2.2x\n",pDescriptor->bDescriptorType));
    _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  DescriptorSubtype: 0x%2.2x\n",pDescriptor->bDescriptorSubtype));
    _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  bUnitID:           0x%2.2x\n",pDescriptor->bUnitID));
    _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  bNrInPins:         0x%2.2x\n",pDescriptor->bNrInPins));

    for (i=0;i<pDescriptor->bNrInPins; i++)
        _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  baSourceID[%d]:     0x%2.2x\n",i,pDescriptor->baSourceID[i]));
}

VOID DumpFeatureUnit( PAUDIO_FEATURE_UNIT pDescriptor )
{
    ULONG i;
    PUCHAR pCurrentOffset = pDescriptor->bmaControls;
    ULONG ulControlVal = 0;

    _DbgPrintF(DEBUGLVL_VERBOSE,("-------------------------\n"));
    _DbgPrintF(DEBUGLVL_VERBOSE,("FEATURE UNIT: %x\n",pDescriptor));
    _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  Length:            0x%2.2x\n",pDescriptor->bLength));
    _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  DescriptorType:    0x%2.2x\n",pDescriptor->bDescriptorType));
    _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  DescriptorSubtype: 0x%2.2x\n",pDescriptor->bDescriptorSubtype));
    _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  bUnitID:           0x%2.2x\n",pDescriptor->bUnitID));
    _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  bSourceID:         0x%2.2x\n",pDescriptor->bSourceID));
    _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  bControlSize:      0x%2.2x\n",pDescriptor->bControlSize));
    _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  bmaControls:\n"));

    while ( pCurrentOffset < ((PUCHAR)pDescriptor + (pDescriptor->bLength-1)) ) {
        ulControlVal = 0;
        for ( i=pDescriptor->bControlSize; i>0; i--) {
            ulControlVal<<=8;
            ulControlVal |= (pCurrentOffset[i-1]);
        }
        pCurrentOffset += pDescriptor->bControlSize;
        if (pDescriptor->bControlSize == 1) {
            _DbgPrintF(DEBUGLVL_VERBOSE,("            0x%2.2x\n",ulControlVal));
        }
        else if ( pDescriptor->bControlSize == 2 ) {
            _DbgPrintF(DEBUGLVL_VERBOSE,("            0x%4.4x\n",ulControlVal));
        }
        else if ( pDescriptor->bControlSize == 3 ) {
            _DbgPrintF(DEBUGLVL_VERBOSE,("            0x%6.6x\n",ulControlVal));
        }
        else if ( pDescriptor->bControlSize == 4 ) {
            _DbgPrintF(DEBUGLVL_VERBOSE,("            0x%8.8x\n",ulControlVal));
        }
    }
    _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  iFeature:          0x%2.2x\n",pCurrentOffset[0]));

    _DbgPrintF(DEBUGLVL_VERBOSE,("\n"));
}

VOID DumpProcessUnit( PAUDIO_PROCESSING_UNIT pDescriptor )
{
    ULONG i;

    _DbgPrintF(DEBUGLVL_VERBOSE,("-------------------------\n"));
    _DbgPrintF(DEBUGLVL_VERBOSE,("PROCESSING UNIT: %x\n",pDescriptor));
    _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  Length:            0x%2.2x\n",pDescriptor->bLength));
    _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  DescriptorType:    0x%2.2x\n",pDescriptor->bDescriptorType));
    _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  DescriptorSubtype: 0x%2.2x\n",pDescriptor->bDescriptorSubtype));
    _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  bUnitID:           0x%2.2x\n",pDescriptor->bUnitID));
    _DbgPrintF(DEBUGLVL_VERBOSE,("   SHORT wProcessType:      0x%2.2x\n",pDescriptor->wProcessType));
    _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  bNrInPins:         0x%2.2x\n",pDescriptor->bNrInPins));

    for (i=0;i<pDescriptor->bNrInPins; i++)
        _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  baSourceID[%d]:     0x%2.2x\n",i,pDescriptor->baSourceID[i]));

}

VOID DumpExtensionUnit( PAUDIO_EXTENSION_UNIT pDescriptor )
{
    ULONG i;

    _DbgPrintF(DEBUGLVL_VERBOSE,("-------------------------\n"));
    _DbgPrintF(DEBUGLVL_VERBOSE,("EXTENSION UNIT: %x\n",pDescriptor));
    _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  Length:            0x%2.2x\n",pDescriptor->bLength));
    _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  DescriptorType:    0x%2.2x\n",pDescriptor->bDescriptorType));
    _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  DescriptorSubtype: 0x%2.2x\n",pDescriptor->bDescriptorSubtype));
    _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  bUnitID:           0x%2.2x\n",pDescriptor->bUnitID));
    _DbgPrintF(DEBUGLVL_VERBOSE,("   SHORT wExtensionCode:    0x%2.2x\n",pDescriptor->wExtensionCode));
    _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  bNrInPins:         0x%2.2x\n",pDescriptor->bNrInPins));

    for (i=0;i<pDescriptor->bNrInPins; i++)
        _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  baSourceID[%d]:     0x%2.2x\n",i,pDescriptor->baSourceID[i]));
}

VOID
DumpUnitDescriptor( PUCHAR pAddr )
{
   PAUDIO_UNIT pCommonDesc = (PAUDIO_UNIT)pAddr;

   switch( pCommonDesc->bDescriptorSubtype ) {
       case HEADER_UNIT:     DumpHeaderUnit((PAUDIO_HEADER_UNIT)pCommonDesc);        break;
       case INPUT_TERMINAL:  DumpInputTerminal((PAUDIO_INPUT_TERMINAL)pCommonDesc);  break;
       case OUTPUT_TERMINAL: DumpOutputTerminal((PAUDIO_OUTPUT_TERMINAL)pCommonDesc);break;
       case MIXER_UNIT:      DumpMixerUnit((PAUDIO_MIXER_UNIT)pCommonDesc);          break;
       case SELECTOR_UNIT:   DumpSelectorUnit((PAUDIO_SELECTOR_UNIT)pCommonDesc);    break;
       case FEATURE_UNIT:    DumpFeatureUnit((PAUDIO_FEATURE_UNIT)pCommonDesc);      break;
       case PROCESSING_UNIT: DumpProcessUnit((PAUDIO_PROCESSING_UNIT)pCommonDesc);   break;
       case EXTENSION_UNIT:  DumpExtensionUnit((PAUDIO_EXTENSION_UNIT)pCommonDesc);  break;
       default:  DumpGenericDescriptor( (PUCHAR)pCommonDesc );                       break;
   }
}

VOID
DumpAllUnitDescriptors( PUCHAR BeginAddr, PUCHAR EndAddr )
{
    PUCHAR pCurrentOffset = BeginAddr;

    _DbgPrintF(DEBUGLVL_VERBOSE,("------------ DUMPING ALL DESCRIPTORS ------------\n"));

    while ( pCurrentOffset < EndAddr ) {
        DumpUnitDescriptor( pCurrentOffset );
        pCurrentOffset += pCurrentOffset[0];
    }
}

VOID
DumpDeviceDescriptor( PUSB_DEVICE_DESCRIPTOR pDescriptor )
{
    _DbgPrintF(DEBUGLVL_VERBOSE,("-------------------------\n"));
    _DbgPrintF(DEBUGLVL_VERBOSE,("DEVICE DESCRIPTOR: %x\n",pDescriptor));
    _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  Length:            0x%2.2x\n",pDescriptor->bLength));
    _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  DescriptorType:    0x%2.2x\n",pDescriptor->bDescriptorType));
    _DbgPrintF(DEBUGLVL_VERBOSE,("   SHORT bcdUSB:            0x%4.4x\n",pDescriptor->bcdUSB));
    _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  DeviceClass:       0x%2.2x\n",pDescriptor->bDeviceClass));
    _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  DeviceSubClass:    0x%2.2x\n",pDescriptor->bDeviceSubClass));
    _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  DeviceProtocol:    0x%2.2x\n",pDescriptor->bDeviceProtocol));
    _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  bMaxPacketSize:    0x%2.2x\n",pDescriptor->bMaxPacketSize0));
    _DbgPrintF(DEBUGLVL_VERBOSE,("   SHORT idVendor:          0x%4.4x\n",pDescriptor->idVendor));
    _DbgPrintF(DEBUGLVL_VERBOSE,("   SHORT idProduct:         0x%4.4x\n",pDescriptor->idProduct));
    _DbgPrintF(DEBUGLVL_VERBOSE,("   SHORT bcdDevice:         0x%4.4x\n",pDescriptor->bcdDevice));
    _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  Manufacturer:      0x%2.2x\n",pDescriptor->iManufacturer));
    _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  Product:           0x%2.2x\n",pDescriptor->iProduct));
    _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  SerialNumber:      0x%2.2x\n",pDescriptor->iSerialNumber));
    _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  NumConfigurations: 0x%2.2x\n",pDescriptor->bNumConfigurations));

}

VOID
DumpConfigDescriptor(
    PUSB_CONFIGURATION_DESCRIPTOR pDescriptor
    )
{
    _DbgPrintF(DEBUGLVL_VERBOSE,("-------------------------\n"));
    _DbgPrintF(DEBUGLVL_VERBOSE,("CONFIGURATION DESCRIPTOR: %x\n",pDescriptor));
    _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  Length:             0x%2.2x\n",pDescriptor->bLength));
    _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  DescriptorType:     0x%2.2x\n",pDescriptor->bDescriptorType));
    _DbgPrintF(DEBUGLVL_VERBOSE,("   SHORT TotalLength:        0x%4.4x\n",pDescriptor->wTotalLength));
    _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  NumInterfaces:      0x%2.2x\n",pDescriptor->bNumInterfaces));
    _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  ConfigurationValue: 0x%2.2x\n",pDescriptor->bConfigurationValue));
    _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  Configuration:      0x%2.2x\n",pDescriptor->iConfiguration));
    _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  bmAttributes:       0x%2.2x\n",pDescriptor->bmAttributes));
    _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  MaxPower:           0x%2.2x\n",pDescriptor->MaxPower));

}

VOID
DumpEndpointDescriptor(
    PUSB_INTERRUPT_ENDPOINT_DESCRIPTOR pDescriptor
    )
{
    _DbgPrintF(DEBUGLVL_VERBOSE,("-------------------------\n"));
    _DbgPrintF(DEBUGLVL_VERBOSE,("ENDPOINT DESCRIPTOR: %x\n",pDescriptor));
    _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  Length:           0x%2.2x\n",pDescriptor->bLength));
    _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  DescriptorType:   0x%2.2x\n",pDescriptor->bDescriptorType));
    _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  EndpointAddress:  0x%2.2x\n",pDescriptor->bEndpointAddress));
    _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  bmAttributes:     0x%2.2x\n",pDescriptor->bmAttributes));
    _DbgPrintF(DEBUGLVL_VERBOSE,("   SHORT MaxPacketSize:    0x%4.4x\n",pDescriptor->wMaxPacketSize));
    _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  Interval:         0x%2.2x\n",pDescriptor->bInterval));
    if (pDescriptor->bLength >= sizeof(USB_INTERRUPT_ENDPOINT_DESCRIPTOR)) {
        _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  Refresh:          0x%2.2x\n",pDescriptor->bRefresh));
        _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  SynchAddress:     0x%2.2x\n",pDescriptor->bSynchAddress));
    }

}

VOID
DumpInterfaceDescriptor(
    PUSB_INTERFACE_DESCRIPTOR pDescriptor
    )
{
    _DbgPrintF(DEBUGLVL_VERBOSE,("-------------------------\n"));
    _DbgPrintF(DEBUGLVL_VERBOSE,("INTERFACE DESCRIPTOR: %x\n",pDescriptor));
    _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  Length:             0x%2.2x\n",pDescriptor->bLength));
    _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  DescriptorType:     0x%2.2x\n",pDescriptor->bDescriptorType));
    _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  bInterfaceNumber:   0x%2.2x\n",pDescriptor->bInterfaceNumber));
    _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  bAlternateSetting:  0x%2.2x\n",pDescriptor->bAlternateSetting));
    _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  bNumEndpoints:      0x%2.2x\n",pDescriptor->bNumEndpoints));
    _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  bInterfaceClass:    0x%2.2x",pDescriptor->bInterfaceClass));
    if (pDescriptor->bInterfaceClass == USB_DEVICE_CLASS_AUDIO) {
        _DbgPrintF(DEBUGLVL_VERBOSE,(" (Audio)\n"));
    }
    else {
        _DbgPrintF(DEBUGLVL_VERBOSE,("\n"));
    }
    _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  bInterfaceSubClass: 0x%2.2x",pDescriptor->bInterfaceSubClass));
    if ( pDescriptor->bInterfaceSubClass == AUDIO_SUBCLASS_CONTROL ) {
        _DbgPrintF(DEBUGLVL_VERBOSE,(" (Audio Control)\n"));
    }
    else if ( pDescriptor->bInterfaceSubClass == AUDIO_SUBCLASS_STREAMING ) {
        _DbgPrintF(DEBUGLVL_VERBOSE,(" (Audio Streaming)\n"));
    }
    else if ( pDescriptor->bInterfaceSubClass == AUDIO_SUBCLASS_MIDISTREAMING ) {
        _DbgPrintF(DEBUGLVL_VERBOSE,(" (Audio MIDI Streaming)\n"));
    }
    else {
        _DbgPrintF(DEBUGLVL_VERBOSE,("\n"));
    }
    _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  bInterfaceProtocol: 0x%2.2x\n",pDescriptor->bInterfaceProtocol));
    _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  iInterface:         0x%2.2x\n",pDescriptor->iInterface));
}


VOID
DumpAudioSubclassSpecificEndpointDescriptor(PAUDIO_ENDPOINT_DESCRIPTOR pDescriptor)
{
    _DbgPrintF(DEBUGLVL_VERBOSE,("-------------------------\n"));
    _DbgPrintF(DEBUGLVL_VERBOSE,("CS AUDIO ENDPOINT DESCRIPTOR: %x\n",pDescriptor));
    _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  Length:             0x%2.2x\n",pDescriptor->bLength));
    _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  DescriptorType:     0x%2.2x\n",pDescriptor->bDescriptorType));
    _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  DescriptorSubType:  0x%2.2x\n",pDescriptor->bDescriptorSubtype));
    _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  bmAttributes:       0x%2.2x\n",pDescriptor->bmAttributes));
    _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  bLockDelayUnits:    0x%2.2x\n",pDescriptor->bLockDelayUnits));
    _DbgPrintF(DEBUGLVL_VERBOSE,("   SHORT wLockDelay:         0x%4.4x\n",pDescriptor->wLockDelay));
}

VOID
DumpMIDISubclassSpecificEndpointDescriptor(PMIDISTREAMING_ENDPOINT_DESCRIPTOR pDescriptor)
{
    ULONG i;

    _DbgPrintF(DEBUGLVL_VERBOSE,("-------------------------\n"));
    _DbgPrintF(DEBUGLVL_VERBOSE,("CS MIDI ENDPOINT DESCRIPTOR: %x\n",pDescriptor));
    _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  Length:             0x%2.2x\n",pDescriptor->bLength));
    _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  DescriptorType:     0x%2.2x\n",pDescriptor->bDescriptorType));
    _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  DescriptorSubType:  0x%2.2x\n",pDescriptor->bDescriptorSubtype));
    _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  bNumEmbMIDIJack:    0x%2.2x\n",pDescriptor->bNumEmbMIDIJack));
    for (i=0;i<pDescriptor->bNumEmbMIDIJack; i++)
        _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  baAssocJackID[%d]:   0x%2.2x\n",i,pDescriptor->baAssocJackID[i]));
}

VOID
DumpClassSpecificEndpointDescriptor(PUCHAR pDescriptor, ULONG SubClassFlag)
{
    ULONG ulDescriptorSubtype = (ULONG)((PUCHAR)pDescriptor)[2];

    switch (SubClassFlag) {
        case AUDIO_SUBCLASS_CONTROL:
            switch(ulDescriptorSubtype) {
                default:
                    DumpGenericDescriptor( pDescriptor );
                    break;
            }
            break;

        case AUDIO_SUBCLASS_STREAMING:
            switch(ulDescriptorSubtype) {
                case AS_GENERAL:
                    DumpAudioSubclassSpecificEndpointDescriptor((PAUDIO_ENDPOINT_DESCRIPTOR)pDescriptor);
                    break;
                default:
                    DumpGenericDescriptor( pDescriptor );
                    break;
            }
            break;

        case AUDIO_SUBCLASS_MIDISTREAMING:
            switch(ulDescriptorSubtype) {
                case MS_GENERAL:
                    DumpMIDISubclassSpecificEndpointDescriptor((PMIDISTREAMING_ENDPOINT_DESCRIPTOR)pDescriptor);
                    break;
                default:
                    DumpGenericDescriptor( pDescriptor );
                    break;
            }
            break;

        default:
            DumpGenericDescriptor( pDescriptor );
            break;
    }
}

VOID
DumpAudioSubclassSpecificGeneralDescriptor(PAUDIO_GENERAL_STREAM pDescriptor)
{
    _DbgPrintF(DEBUGLVL_VERBOSE,("-------------------------\n"));
    _DbgPrintF(DEBUGLVL_VERBOSE,("CS GENERAL STREAM DESCRIPTOR: %x\n",pDescriptor));
    _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  Length:             0x%2.2x\n",pDescriptor->bLength));
    _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  DescriptorType:     0x%2.2x\n",pDescriptor->bDescriptorType));
    _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  DescriptorSubType:  0x%2.2x\n",pDescriptor->bDescriptorSubtype));
    _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  bTerminalLink:      0x%2.2x\n",pDescriptor->bTerminalLink));
    _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  bDelay:             0x%2.2x\n",pDescriptor->bDelay));
    _DbgPrintF(DEBUGLVL_VERBOSE,("   SHORT wFormatTag:         0x%4.4x\n",pDescriptor->wFormatTag));
}

VOID
DumpAudioSubclassSpecificFormatTypeDescriptor(PAUDIO_CLASS_STREAM pDescriptor)
{
    PAUDIO_CLASS_TYPE1_STREAM pT1Desc = (PAUDIO_CLASS_TYPE1_STREAM)pDescriptor;
    PAUDIO_CLASS_TYPE2_STREAM pT2Desc = (PAUDIO_CLASS_TYPE2_STREAM)pDescriptor;
    ULONG MinSampleRate, MaxSampleRate;
    ULONG i;

    _DbgPrintF(DEBUGLVL_VERBOSE,("-------------------------\n"));
    _DbgPrintF(DEBUGLVL_VERBOSE,("CS FORMAT TYPE DESCRIPTOR: %x\n",pDescriptor));
    _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  Length:             0x%2.2x\n",pDescriptor->bLength));
    _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  DescriptorType:     0x%2.2x\n",pDescriptor->bDescriptorType));
    _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  DescriptorSubType:  0x%2.2x\n",pDescriptor->bDescriptorSubtype));
    _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  bFormatType:        0x%2.2x\n",pDescriptor->bFormatType));

    if (pDescriptor->bFormatType == 1) {
        _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  bNumberOfChannels:  0x%2.2x\n",pT1Desc->bNumberOfChannels));
        _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  bSlotSize:          0x%2.2x\n",pT1Desc->bSlotSize));
        _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  bBitsPerSample:     0x%2.2x\n",pT1Desc->bBitsPerSample));
        _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  bSampleFreqType:    0x%2.2x\n",pT1Desc->bSampleFreqType));
        if (pT1Desc->bSampleFreqType == 0) { // Continuous Range
            MinSampleRate = pT1Desc->pSampleRate[0].bSampleFreqByte1 +
                     256L * pT1Desc->pSampleRate[0].bSampleFreqByte2 +
                   65536L * pT1Desc->pSampleRate[0].bSampleFreqByte3;
            MaxSampleRate = pT1Desc->pSampleRate[1].bSampleFreqByte1 +
                     256L * pT1Desc->pSampleRate[1].bSampleFreqByte2 +
                   65536L * pT1Desc->pSampleRate[1].bSampleFreqByte3;
            _DbgPrintF(DEBUGLVL_VERBOSE,("   3BYTE MinSampleRate       0x%6.6x\n",MinSampleRate));
            _DbgPrintF(DEBUGLVL_VERBOSE,("   3BYTE MaxSampleRate       0x%6.6x\n",MaxSampleRate));
        }
        else {
            for ( i=0; i<(ULONG)pT1Desc->bSampleFreqType; i++ ) {
                MaxSampleRate = pT1Desc->pSampleRate[i].bSampleFreqByte1 +
                         256L * pT1Desc->pSampleRate[i].bSampleFreqByte2 +
                       65536L * pT1Desc->pSampleRate[i].bSampleFreqByte3;
                _DbgPrintF(DEBUGLVL_VERBOSE,("   3BYTE SampleRate[%x]       0x%6.6x\n",i,MaxSampleRate));
            }
        }
    }
    else if (pDescriptor->bFormatType == 2) {
        _DbgPrintF(DEBUGLVL_VERBOSE,("   SHORT wMaxBitRate:        0x%4.4x\n",pT2Desc->wMaxBitRate));
        _DbgPrintF(DEBUGLVL_VERBOSE,("   SHORT wSamplesPerFrame:   0x%4.4x\n",pT2Desc->wSamplesPerFrame));
        _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  bSampleFreqType:    0x%2.2x\n",pT2Desc->bSampleFreqType));
    if (pT2Desc->bSampleFreqType == 0) { // Continuous Range
            MinSampleRate = pT2Desc->pSampleRate[0].bSampleFreqByte1 +
                     256L * pT2Desc->pSampleRate[0].bSampleFreqByte2 +
                   65536L * pT2Desc->pSampleRate[0].bSampleFreqByte3;
            MaxSampleRate = pT2Desc->pSampleRate[1].bSampleFreqByte1 +
                     256L * pT2Desc->pSampleRate[1].bSampleFreqByte2 +
                   65536L * pT2Desc->pSampleRate[1].bSampleFreqByte3;
            _DbgPrintF(DEBUGLVL_VERBOSE,("   3BYTE MinSampleRate        0x%6.6x\n",MinSampleRate));
            _DbgPrintF(DEBUGLVL_VERBOSE,("   3BYTE MaxSampleRate        0x%6.6x\n",MaxSampleRate));
        }
        else {
            for ( i=0; i<(ULONG)pT2Desc->bSampleFreqType; i++ ) {
                MaxSampleRate = pT2Desc->pSampleRate[i].bSampleFreqByte1 +
                         256L * pT2Desc->pSampleRate[i].bSampleFreqByte2 +
                       65536L * pT2Desc->pSampleRate[i].bSampleFreqByte3;
                _DbgPrintF(DEBUGLVL_VERBOSE,("   3BYTE SampleRate[%x]      0x%6.6x\n",i,MaxSampleRate));
            }
        }
    }
}

VOID
DumpMIDISubclassSpecificGeneralDescriptor(PMIDISTREAMING_GENERAL_STREAM pDescriptor)
{
    _DbgPrintF(DEBUGLVL_VERBOSE,("-------------------------\n"));
    _DbgPrintF(DEBUGLVL_VERBOSE,("MS GENERAL STREAM DESCRIPTOR: %x\n",pDescriptor));
    _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  Length:             0x%2.2x\n",pDescriptor->bLength));
    _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  DescriptorType:     0x%2.2x\n",pDescriptor->bDescriptorType));
    _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  DescriptorSubType:  0x%2.2x\n",pDescriptor->bDescriptorSubtype));
    _DbgPrintF(DEBUGLVL_VERBOSE,("   SHORT bcdAudioSpec:       0x%4.4x\n",pDescriptor->bcdAudioSpec));
    _DbgPrintF(DEBUGLVL_VERBOSE,("   SHORT TotalLength:        0x%4.4x\n",pDescriptor->wTotalLength));
}

VOID
DumpMIDISubclassSpecificMIDIOutJackDescriptor(PMIDISTREAMING_MIDIOUT_JACK pDescriptor)
{
    ULONG i;
    PMIDISTREAMING_SOURCECONNECTIONS pConnections;

    _DbgPrintF(DEBUGLVL_VERBOSE,("-------------------------\n"));
    _DbgPrintF(DEBUGLVL_VERBOSE,("MS MIDI OUT JACK DESCRIPTOR: %x\n",pDescriptor));
    _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  Length:             0x%2.2x\n",pDescriptor->bLength));
    _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  DescriptorType:     0x%2.2x\n",pDescriptor->bDescriptorType));
    _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  DescriptorSubType:  0x%2.2x\n",pDescriptor->bDescriptorSubtype));
    _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  bJackType:          0x%2.2x",pDescriptor->bJackType));
    if (pDescriptor->bJackType == JACK_TYPE_EMBEDDED) {
        _DbgPrintF(DEBUGLVL_VERBOSE,(" (Embedded)\n"));
    } else if (pDescriptor->bJackType == JACK_TYPE_EXTERNAL) {
        _DbgPrintF(DEBUGLVL_VERBOSE,(" (External)\n"));
    } else {
        _DbgPrintF(DEBUGLVL_VERBOSE,("\n"));
    }
    _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  bJackID:            0x%2.2x\n",pDescriptor->bJackID));
    _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  bNrInputPins:       0x%2.2x\n",pDescriptor->bNrInputPins));
    for (i=0;i<pDescriptor->bNrInputPins; i++) {
        pConnections = &pDescriptor->baSourceConnections[i];

        _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  SourceID[%d]:        0x%2.2x\n",i,pConnections->SourceID));
        _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  SourcePin[%d]:       0x%2.2x\n",i,pConnections->SourcePin));
    }

}

VOID
DumpMIDISubclassSpecificMIDIInJackDescriptor(PMIDISTREAMING_MIDIIN_JACK pDescriptor)
{
    _DbgPrintF(DEBUGLVL_VERBOSE,("-------------------------\n"));
    _DbgPrintF(DEBUGLVL_VERBOSE,("MS MIDI IN JACK DESCRIPTOR: %x\n",pDescriptor));
    _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  Length:             0x%2.2x\n",pDescriptor->bLength));
    _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  DescriptorType:     0x%2.2x\n",pDescriptor->bDescriptorType));
    _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  DescriptorSubType:  0x%2.2x\n",pDescriptor->bDescriptorSubtype));
    _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  bJackType:          0x%2.2x",pDescriptor->bJackType));
    if (pDescriptor->bJackType == JACK_TYPE_EMBEDDED) {
        _DbgPrintF(DEBUGLVL_VERBOSE,(" (Embedded)\n"));
    } else if (pDescriptor->bJackType == JACK_TYPE_EXTERNAL) {
        _DbgPrintF(DEBUGLVL_VERBOSE,(" (External)\n"));
    } else {
        _DbgPrintF(DEBUGLVL_VERBOSE,("\n"));
    }
    _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  bJackID:            0x%2.2x\n",pDescriptor->bJackID));
}

VOID
DumpMIDISubclassSpecificElementDescriptor(PMIDISTREAMING_ELEMENT pDescriptor)
{
    ULONG i;
    PMIDISTREAMING_SOURCECONNECTIONS pConnections;
    PMIDISTREAMING_ELEMENT2 pElementDescriptor2;

    _DbgPrintF(DEBUGLVL_VERBOSE,("-------------------------\n"));
    _DbgPrintF(DEBUGLVL_VERBOSE,("MS ELEMENT DESCRIPTOR: %x\n",pDescriptor));
    _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  Length:             0x%2.2x\n",pDescriptor->bLength));
    _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  DescriptorType:     0x%2.2x\n",pDescriptor->bDescriptorType));
    _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  DescriptorSubType:  0x%2.2x\n",pDescriptor->bDescriptorSubtype));
    _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  bElementID:         0x%2.2x\n",pDescriptor->bElementID));
    _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  bNrInputPins:       0x%2.2x\n",pDescriptor->bNrInputPins));
    for ( i=0;i<pDescriptor->bNrInputPins; i++ ) {
        pConnections = &pDescriptor->baSourceConnections[i];

        _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  SourceID[%d]:       0x%2.2x\n",i,pConnections->SourceID));
        _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  SourcePin[%d]:      0x%2.2x\n",i,pConnections->SourcePin));
    }

    pElementDescriptor2 = (PMIDISTREAMING_ELEMENT2)&pDescriptor->baSourceConnections[i];
    _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  bNrOutputPins:      0x%2.2x\n",pElementDescriptor2->bNrOutputPins));
    _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  bInTerminalLink:    0x%2.2x\n",pElementDescriptor2->bInTerminalLink));
    _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  bOutTerminalLink:   0x%2.2x\n",pElementDescriptor2->bOutTerminalLink));
    _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  bElCapsSize:        0x%2.2x\n",pElementDescriptor2->bElCapsSize));
    for ( i=0; i<pElementDescriptor2->bElCapsSize; i++ )
        _DbgPrintF(DEBUGLVL_VERBOSE,("   BYTE  bmElementCaps[%d]:  0x%2.2x\n",i,pElementDescriptor2->bmElementCaps[i]));
}

VOID
DumpClassSpecInterfaceDescriptor( PVOID pDescriptor, ULONG SubClassFlag)
{
    ULONG ulDescriptorSubtype = (ULONG)((PUCHAR)pDescriptor)[2];

    switch (SubClassFlag) {
        case AUDIO_SUBCLASS_CONTROL:
            switch(ulDescriptorSubtype) {
                case HEADER_UNIT:
                    DumpHeaderUnit( (PAUDIO_HEADER_UNIT)pDescriptor );
                    break;
                case INPUT_TERMINAL:
                    DumpInputTerminal( (PAUDIO_INPUT_TERMINAL)pDescriptor );
                    break;
                case OUTPUT_TERMINAL:
                    DumpOutputTerminal( (PAUDIO_OUTPUT_TERMINAL)pDescriptor );
                    break;
                case MIXER_UNIT:
                    DumpMixerUnit((PAUDIO_MIXER_UNIT)pDescriptor);
                    break;
                case SELECTOR_UNIT:
                    DumpSelectorUnit((PAUDIO_SELECTOR_UNIT)pDescriptor);
                    break;
                case FEATURE_UNIT:
                    DumpFeatureUnit((PAUDIO_FEATURE_UNIT)pDescriptor);
                    break;
                case PROCESSING_UNIT:
                    DumpProcessUnit((PAUDIO_PROCESSING_UNIT)pDescriptor);
                    break;
                case EXTENSION_UNIT:
                    DumpExtensionUnit((PAUDIO_EXTENSION_UNIT)pDescriptor);
                    break;
                default:
                    DumpGenericDescriptor( pDescriptor );
                    break;
            }
            break;

        case AUDIO_SUBCLASS_STREAMING:
            switch(ulDescriptorSubtype) {
                case AS_GENERAL:
                    DumpAudioSubclassSpecificGeneralDescriptor((PAUDIO_GENERAL_STREAM)pDescriptor);
                    break;
                case FORMAT_TYPE:
                    DumpAudioSubclassSpecificFormatTypeDescriptor((PAUDIO_CLASS_STREAM)pDescriptor);
                    break;
                case FORMAT_SPECIFIC:
                    DumpGenericDescriptor( pDescriptor );
                    break;
                default:
                    DumpGenericDescriptor( pDescriptor );
                    break;
            }
            break;

        case AUDIO_SUBCLASS_MIDISTREAMING:
            switch(ulDescriptorSubtype) {
                case MS_HEADER:
                    DumpMIDISubclassSpecificGeneralDescriptor((PMIDISTREAMING_GENERAL_STREAM)pDescriptor);
                    break;
                case MIDI_IN_JACK:
                    DumpMIDISubclassSpecificMIDIInJackDescriptor((PMIDISTREAMING_MIDIIN_JACK)pDescriptor);
                    break;
                case MIDI_OUT_JACK:
                    DumpMIDISubclassSpecificMIDIOutJackDescriptor((PMIDISTREAMING_MIDIOUT_JACK)pDescriptor);
                    break;
                case MIDI_ELEMENT:
                    DumpMIDISubclassSpecificElementDescriptor((PMIDISTREAMING_ELEMENT)pDescriptor);
                    break;
                default:
                    DumpGenericDescriptor( pDescriptor );
                    break;
            }
            break;

        default:
            DumpGenericDescriptor( pDescriptor );
            break;
    }
}

VOID
DumpAllDescriptors(
    PUSB_CONFIGURATION_DESCRIPTOR pConfigurationDescriptor
    )
{
    ULONG ulFlag = SUBCLASS_UNDEFINED;
    PUCHAR pDescriptor = (PUCHAR)pConfigurationDescriptor;

    if ( pConfigurationDescriptor->bDescriptorType != USB_CONFIGURATION_DESCRIPTOR_TYPE )
        return;

    while ( pDescriptor < ((PUCHAR)pConfigurationDescriptor +
                                   pConfigurationDescriptor->wTotalLength) ) {
        switch ( ((PUCHAR)pDescriptor)[1] ) {
            case USB_CONFIGURATION_DESCRIPTOR_TYPE:
                DumpConfigDescriptor( (PUSB_CONFIGURATION_DESCRIPTOR)pDescriptor );
                break;
            case USB_INTERFACE_DESCRIPTOR_TYPE:
                DumpInterfaceDescriptor( (PUSB_INTERFACE_DESCRIPTOR)pDescriptor );
                ulFlag = ((PUSB_INTERFACE_DESCRIPTOR)pDescriptor)->bInterfaceSubClass;
                break;
            case USB_ENDPOINT_DESCRIPTOR_TYPE:
                DumpEndpointDescriptor( (PUSB_INTERRUPT_ENDPOINT_DESCRIPTOR)pDescriptor );
                break;
            case USB_INTERFACE_DESCRIPTOR_TYPE | USB_CLASS_AUDIO:
                DumpClassSpecInterfaceDescriptor( pDescriptor, ulFlag );
                break;
            case USB_ENDPOINT_DESCRIPTOR_TYPE  | USB_CLASS_AUDIO:
                DumpClassSpecificEndpointDescriptor( pDescriptor, ulFlag );
                break;
            case USB_STRING_DESCRIPTOR_TYPE:
            default:
                DumpGenericDescriptor( pDescriptor );
                break;
        }
        pDescriptor += pDescriptor[0];
    }

}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\drivers\usbaudio.2\descript.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 2000
//
//  File:       descript.h
//
//--------------------------------------------------------------------------

#ifndef ___DESCRIPTORS_H___
#define ___DESCRIPTORS_H___

#define USBAUDIO_POOL_TAG 'AbsU'

#define MS_PER_SEC 1000

#define USB_CLASS_AUDIO     0x20

#define ABSOLUTE_NODE_FLAG  0x80000000L
#define NODE_MASK           0x7fffffffL

// Class Specific Endpoint Feature enable bits
#define ENDPOINT_SAMPLE_FREQ_MASK       1
#define ENDPOINT_PITCH_MASK             2

// Class Specific Endpoint Lock Delay bits
#define EP_LOCK_DELAY_UNITS_MS          1
#define EP_LOCK_DELAY_UNITS_SAMPLES     2

// Channel Config
#define LEFT_CHANNEL            0x01
#define RIGHT_CHANNEL           0x02
#define CENTER_CHANNEL          0x04
#define LFE_CHANNEL             0x08
#define LEFT_SURROUND_CHANNEL   0x10
#define RIGHT_SURROUND_CHANNEL  0x20
#define LEFT_CENTER_CHANNEL     0x40
#define RIGHT_CENTER_CHANNEL    0x80
#define SURROUND_CHANNEL        0x100
#define SIDE_LEFT_CHANNEL       0x200
#define SIDE_RIGHT_CHANNEL      0x400
#define TOP_CHANNEL             0x800

// Audio sub-classes
#define SUBCLASS_UNDEFINED              0x00
#define AUDIO_SUBCLASS_CONTROL          0x01
#define AUDIO_SUBCLASS_STREAMING        0x02
#define AUDIO_SUBCLASS_MIDISTREAMING    0x03

// Audio Class-Specific AC Interface Descriptor Subtypes
#define HEADER_UNIT     0x01
#define INPUT_TERMINAL  0x02
#define OUTPUT_TERMINAL 0x03
#define MIXER_UNIT      0x04
#define SELECTOR_UNIT   0x05
#define FEATURE_UNIT    0x06
#define PROCESSING_UNIT 0x07
#define EXTENSION_UNIT  0x08
#define MAX_TYPE_UNIT   0x09

// Audio Class-Specific AS Interface Descriptor Subtypes
#define AS_GENERAL      0x01
#define FORMAT_TYPE     0x02
#define FORMAT_SPECIFIC 0x03

// Processing Unit Process Types
#define UP_DOWNMIX_PROCESS          0x01
#define DOLBY_PROLOGIC_PROCESS      0x02
#define STEREO_EXTENDER_PROCESS     0x03
#define REVERBERATION_PROCESS       0x04
#define CHORUS_PROCESS              0x05
#define DYN_RANGE_COMP_PROCESS      0x06

// Audio Class-Specific Endpoint Descriptor Subtypes
#define EP_GENERAL  0x01

// Audio Class-Specific MS Interface Descriptor Subtypes
#define MS_HEADER       0x01
#define MIDI_IN_JACK    0x02
#define MIDI_OUT_JACK   0x03
#define MIDI_ELEMENT    0x04

// Audio Class-Specific MS Endpoint Descriptor Subtypes
#define MS_GENERAL      0x01

// Audio MS MIDI IN and OUT Jack types
#define JACK_TYPE_EMBEDDED      0x01
#define JACK_TYPE_EXTERNAL      0x02

// Class-Specific Request Codes
#define CLASS_SPECIFIC_GET_MASK 0x80

#define SET_CUR 0x01
#define GET_CUR 0x81
#define SET_MIN 0x02
#define GET_MIN 0x82
#define SET_MAX 0x03
#define GET_MAX 0x83
#define SET_RES 0x04
#define GET_RES 0x84
#define SET_MEM 0x05
#define GET_MEM 0x85
#define GET_STAT    0xFF

// Terminal Control Selectors
#define COPY_PROTECT_CONTROL    0x01

// Feature Unit Control Selectors
#define MUTE_CONTROL                0x01
#define VOLUME_CONTROL              0x02
#define BASS_CONTROL                0x03
#define MID_CONTROL                 0x04
#define TREBLE_CONTROL              0x05
#define GRAPHIC_EQUALIZER_CONTROL   0x06
#define AUTOMATIC_GAIN_CONTROL      0x07
#define DELAY_CONTROL               0x08
#define BASS_BOOST_CONTROL          0x09
#define LOUDNESS_CONTROL            0x0A

// Feature Unit Flags
#define MUTE_FLAG               0x01
#define VOLUME_FLAG             0x02
#define BASS_FLAG               0x04
#define MID_FLAG                0x08
#define TREBLE_FLAG             0x10
#define GRAPHIC_EQUALIZER_FLAG  0x20
#define AUTOMATIC_GAIN_FLAG     0x40
#define DELAY_FLAG              0x80
#define BASS_BOOST_FLAG         0x100
#define LOUDNESS_FLAG           0x200

// Up/Down-mix Processing Unit Control Selectors
#define UD_ENABLE_CONTROL       0x01
#define UD_MODE_SELECT_CONTROL  0x02

// Dolby Prologic Processing Unit Control Selectors
#define DP_ENABLE_CONTROL       0x01
#define DP_MODE_SELECT_CONTROL  0x02

// 3D_Stereo Extender Processing Unit Control Selectors
#define ENABLE_CONTROL          0x01
#define SPACIOUSNESS_CONTROL    0x03

// Reverberation Processing Unit Control Selectors
#define RV_ENABLE_CONTROL       0x01
#define REVERB_LEVEL_CONTROL    0x02
#define REVERB_TIME_CONTROL     0x03
#define REVERB_FEEDBACK_CONTROL 0x04

// Chorus Processing Unit Control Selectors
#define CH_ENABLE_CONTROL       0x01
#define CHORUS_LEVEL_CONTROL    0x02
#define CHORUS_RATE_CONTROL     0x03
#define CHORUS_DEPTH_CONTROL    0x04

// Dynamic Range Compressor Unit Control Selectors
#define DR_ENABLE_CONTROL           0x01
#define COMPRESSION_RATE_CONTROL    0x02
#define MAXAMPL_CONTROL             0x03
#define THRESHOLD_CONTROL           0x04
#define ATTACK_TIME                 0x05
#define RELEASE_TIME                0x06

// Extension Unit Control Selectors
#define XU_ENABLE_CONTROL       0x01

// Endpoint Control Selectors
#define SAMPLING_FREQ_CONTROL   0x01
#define PITCH_CONTROL   0x02

// Endpoint Bitmapped Attributes
#define EP_SYNC_TYPE_MASK       0xc
#define EP_ASYNC_SYNC_TYPE      0x4
#define EP_SHARED_SHARE_TYPE    0x10

// Controls for error checking only
#define DEV_SPECIFIC_CONTROL 0x1001

// bmRequestType field values for requests
#define USB_COMMAND_TO_INTERFACE 0x21
#define USB_COMMAND_TO_ENDPOINT  0x22

// Terminal type masks
#define USB_Streaming       0x0101
#define Input_Mask          0x0200
#define Output_Mask         0x0300
#define Bidirectional_Mask  0x0400
#define Telephony_Mask      0x0500
#define External_Mask       0x0600
#define Embedded_Mask       0x0700

// External terminal types
#define External_Undefined              0x0600  // I/O External Terminal, undefined Type.
#define Analog_connector                0x0601  // I/O A generic analog connector.
#define Digital_audio_interface         0x0602  // I/O A generic digital audio interface.
#define Line_connector                  0x0603  // I/O An analog connector at standard line
                                                // levels. Usually uses 3.5mm.
#define Legacy_audio_connector          0x0604  // I/O An input connector assumed to be
                                                // connected to the lineout of the legacy
                                                // audio system of the host computer. Used
                                                // for backward compatibility.
#define SPDIF_interface                 0x0605  // I/O An S/PDIF digital audio interface. The
                                                // Associated Interface descriptor can be
                                                // used to reference an interface used for
                                                // controlling special functions of this
                                                // interface.
#define DA_stream_1394                  0x0606  // I/O An interface to audio streams on a 1394 bus.
#define DV_stream soundtrack_1394       0x0607  // I/O An interface to soundtrack of A/V stream
                                                // on a 1394 bus.

// Embedded terminal types
#define Embedded_Undefined              0x0700
#define Level_Calibration_Noise_Source  0x0701
#define Equalization_Noise              0x0702
#define CD_player                       0x0703
#define DAT                             0x0704
#define DCC                             0x0705
#define MiniDisk                        0x0706
#define Analog_Tape                     0x0707
#define Phonograph                      0x0708
#define VCR_Audio                       0x0709
#define Video_Disc_Audio                0x070A
#define DVD_Audio                       0x070B
#define TV_Tuner_Audio                  0x070C
#define Satellite_Receiver_Audio        0x070D
#define Cable_Tuner_Audio               0x070E
#define DSS_Audio                       0x070F
#define Radio_Receiver                  0x0710
#define Radio_Transmitter               0x0711
#define Multitrack_Recorder             0x0712
#define Synthesizer                     0x0713

#define USBAUDIO_DATA_FORMAT_TYPE_MASK         0xF000

// Audio Data Format Type I codes
#define USBAUDIO_DATA_FORMAT_TYPE_I_UNDEFINED  0x0000
#define USBAUDIO_DATA_FORMAT_PCM               0x0001
#define USBAUDIO_DATA_FORMAT_PCM8              0x0002
#define USBAUDIO_DATA_FORMAT_IEEE_FLOAT        0x0003
#define USBAUDIO_DATA_FORMAT_ALAW              0x0004
#define USBAUDIO_DATA_FORMAT_MULAW             0x0005

// Audio Data Format Type II codes
#define USBAUDIO_DATA_FORMAT_TYPE_II_UNDEFINED  0x1000
#define USBAUDIO_DATA_FORMAT_MPEG               0x1001
#define USBAUDIO_DATA_FORMAT_AC3                0x1002

// Audio Data Format Type III codes
#define USBAUDIO_DATA_FORMAT_TYPE_III_UNDEFINED 0x2000
#define USBAUDIO_DATA_FORMAT_IEC1937_AC3        0x2001
#define USBAUDIO_DATA_FORMAT_IEC1937_MPEG1_1    0x2002

// Map KSNODE_TYPE GUIDs to Indexes
#define NODE_TYPE_NONE          0
#define NODE_TYPE_DAC           1
#define NODE_TYPE_ADC           2
#define NODE_TYPE_SRC           3
#define NODE_TYPE_SUPERMIX      4
#define NODE_TYPE_MUX           5
#define NODE_TYPE_SUM           6
#define NODE_TYPE_MUTE          7
#define NODE_TYPE_VOLUME        8
#define NODE_TYPE_BASS          9
#define NODE_TYPE_MID           10
#define NODE_TYPE_TREBLE        11
#define NODE_TYPE_BASS_BOOST    12
#define NODE_TYPE_EQUALIZER     13
#define NODE_TYPE_AGC           14
#define NODE_TYPE_DELAY         15
#define NODE_TYPE_LOUDNESS      16
#define NODE_TYPE_PROLOGIC      17
#define NODE_TYPE_STEREO_WIDE   18
#define NODE_TYPE_REVERB        19
#define NODE_TYPE_CHORUS        20
#define NODE_TYPE_DEV_SPEC      21

#define MapFuncsToNodeTypes( a ) \
{\
    a[KSPROPERTY_AUDIO_LATENCY]               = NODE_TYPE_NONE; \
    a[KSPROPERTY_AUDIO_COPY_PROTECTION]       = NODE_TYPE_NONE; \
    a[KSPROPERTY_AUDIO_CHANNEL_CONFIG]        = NODE_TYPE_NONE; \
    a[KSPROPERTY_AUDIO_VOLUMELEVEL]           = NODE_TYPE_VOLUME; \
    a[KSPROPERTY_AUDIO_POSITION]              = NODE_TYPE_NONE; \
    a[KSPROPERTY_AUDIO_DYNAMIC_RANGE]         = NODE_TYPE_NONE; \
    a[KSPROPERTY_AUDIO_QUALITY]               = NODE_TYPE_NONE; \
    a[KSPROPERTY_AUDIO_SAMPLING_RATE]         = NODE_TYPE_SRC; \
    a[KSPROPERTY_AUDIO_DYNAMIC_SAMPLING_RATE] = NODE_TYPE_SRC; \
    a[KSPROPERTY_AUDIO_MIX_LEVEL_TABLE]       = NODE_TYPE_SUPERMIX; \
    a[KSPROPERTY_AUDIO_MIX_LEVEL_CAPS]        = NODE_TYPE_SUPERMIX; \
    a[KSPROPERTY_AUDIO_MUX_SOURCE]            = NODE_TYPE_MUX; \
    a[KSPROPERTY_AUDIO_MUTE]                  = NODE_TYPE_MUTE; \
    a[KSPROPERTY_AUDIO_BASS]                  = NODE_TYPE_BASS; \
    a[KSPROPERTY_AUDIO_MID]                   = NODE_TYPE_MID; \
    a[KSPROPERTY_AUDIO_TREBLE]                = NODE_TYPE_TREBLE; \
    a[KSPROPERTY_AUDIO_BASS_BOOST]            = NODE_TYPE_BASS_BOOST; \
    a[KSPROPERTY_AUDIO_EQ_LEVEL]              = NODE_TYPE_EQUALIZER; \
    a[KSPROPERTY_AUDIO_NUM_EQ_BANDS]          = NODE_TYPE_EQUALIZER; \
    a[KSPROPERTY_AUDIO_EQ_BANDS]              = NODE_TYPE_EQUALIZER; \
    a[KSPROPERTY_AUDIO_AGC]                   = NODE_TYPE_AGC; \
    a[KSPROPERTY_AUDIO_DELAY]                 = NODE_TYPE_DELAY; \
    a[KSPROPERTY_AUDIO_LOUDNESS]              = NODE_TYPE_LOUDNESS; \
    a[KSPROPERTY_AUDIO_WIDE_MODE]             = NODE_TYPE_STEREO_WIDE; \
    a[KSPROPERTY_AUDIO_WIDENESS]              = NODE_TYPE_STEREO_WIDE; \
    a[KSPROPERTY_AUDIO_REVERB_LEVEL]          = NODE_TYPE_REVERB; \
    a[KSPROPERTY_AUDIO_CHORUS_LEVEL]          = NODE_TYPE_CHORUS; \
    a[KSPROPERTY_AUDIO_DEV_SPECIFIC]          = NODE_TYPE_DEV_SPEC; \
    a[KSPROPERTY_AUDIO_DEMUX_DEST]            = NODE_TYPE_NONE; \
    a[KSPROPERTY_AUDIO_STEREO_ENHANCE]        = NODE_TYPE_NONE; \
    a[KSPROPERTY_AUDIO_MANUFACTURE_GUID]      = NODE_TYPE_NONE; \
    a[KSPROPERTY_AUDIO_PRODUCT_GUID]          = NODE_TYPE_NONE; \
    a[KSPROPERTY_AUDIO_CPU_RESOURCES]         = NODE_TYPE_NONE; \
    a[KSPROPERTY_AUDIO_STEREO_SPEAKER_GEOMETRY] = NODE_TYPE_NONE; \
    a[KSPROPERTY_AUDIO_SURROUND_ENCODE]       = NODE_TYPE_NONE; \
    a[KSPROPERTY_AUDIO_3D_INTERFACE]          = NODE_TYPE_NONE; \
}

//=====================================================================//

#pragma pack( push, pcm2usb_structs, 1)

// Sample Rate
typedef struct {
    UCHAR bSampleFreqByte1;
    UCHAR bSampleFreqByte2;
    UCHAR bSampleFreqByte3;
    } AUDIO_SAMPLE_RATE, *PAUDIO_SAMPLE_RATE;

// Audio Format Type Descriptor
typedef struct {
    UCHAR bLength;              // Size of this descriptor in bytes
    UCHAR bDescriptorType;      // CS_INTERFACE descriptor type
    UCHAR bDescriptorSubtype;   // descriptor subtype
    UCHAR bFormatType;
    UCHAR bNumberOfChannels;
    UCHAR bSlotSize;
    UCHAR bBitsPerSample;
    UCHAR bSampleFreqType;
    AUDIO_SAMPLE_RATE pSampleRate[];
    } AUDIO_CLASS_TYPE1_STREAM,   AUDIO_CLASS_STREAM,
    *PAUDIO_CLASS_TYPE1_STREAM, *PAUDIO_CLASS_STREAM;

// Audio Format Type Descriptor
typedef struct {
    UCHAR bLength;              // Size of this descriptor in bytes
    UCHAR bDescriptorType;      // CS_INTERFACE descriptor type
    UCHAR bDescriptorSubtype;   // descriptor subtype
    UCHAR bFormatType;
    USHORT wMaxBitRate;
    USHORT wSamplesPerFrame;
    UCHAR bSampleFreqType;
    AUDIO_SAMPLE_RATE pSampleRate[];
    } AUDIO_CLASS_TYPE2_STREAM, *PAUDIO_CLASS_TYPE2_STREAM;

// Audio Class-Specific stream interface general descriptor

typedef struct {
    UCHAR bLength;              // Size of this descriptor in bytes
    UCHAR bDescriptorType;      // CS_INTERFACE descriptor type
    UCHAR bDescriptorSubtype;   // AS_GENERAL descriptor subtype
    UCHAR bTerminalLink;        // The terminal id connected to the endpoint for this interface
    UCHAR bDelay;               // Delay introduced by the data path
    USHORT wFormatTag;          // The audio data format used to communicate with this endpoint
    } AUDIO_GENERAL_STREAM, *PAUDIO_GENERAL_STREAM;

// Audio Specific Descriptor
typedef struct {
    UCHAR bLength;              // Size of this descriptor in bytes
    UCHAR bDescriptorType;      // CS_INTERFACE descriptor type
    UCHAR bDescriptorSubtype;   // descriptor subtype
    } AUDIO_SPECIFIC, *PAUDIO_SPECIFIC;

// Audio Unit Descriptor
typedef struct {
    UCHAR bLength;              // Size of this descriptor in bytes
    UCHAR bDescriptorType;      // CS_INTERFACE descriptor type
    UCHAR bDescriptorSubtype;   // descriptor subtype
    UCHAR bUnitID;              // Constant uniquely identifying the Unit
    } AUDIO_UNIT, *PAUDIO_UNIT;

// Audio Header Unit
typedef struct {
    UCHAR bLength;              // Size of this descriptor in bytes
    UCHAR bDescriptorType;      // CS_INTERFACE descriptor type
    UCHAR bDescriptorSubtype;   // HEADER_UNIT descriptor subtype
    USHORT bcdAudioSpec;        // USB audio class spec revision number
    USHORT wTotalLength;        // Total length, including all units and terminals
    UCHAR bInCollection;        // number of audio streaming interfaces
    UCHAR baInterfaceNr[];      // interface number array
    } AUDIO_HEADER_UNIT, *PAUDIO_HEADER_UNIT;

// Audio Input Terminal Descriptor
typedef struct {
    UCHAR bLength;              // Size of this descriptor in bytes
    UCHAR bDescriptorType;      // CS_INTERFACE descriptor type
    UCHAR bDescriptorSubtype;   // INPUT_TERMINAL descriptor subtype
    UCHAR bUnitID;              // Constant uniquely identifying the Unit
    USHORT wTerminalType;       // Type of terminal
    UCHAR bAssocTerminal;       // Associated output terminal
    UCHAR bNrChannels;          // Number of logical output channels in the cluster
    USHORT wChannelConfig;      // Spatial locations of the logical channels
    UCHAR iChannelNames;        // Index of 1st string descriptor describing channels
    UCHAR iTerminal;            // Index of string descriptor describing this unit
    } AUDIO_INPUT_TERMINAL, *PAUDIO_INPUT_TERMINAL;

// Audio Output Terminal Descriptor
typedef struct {
    UCHAR bLength;              // Size of this descriptor in bytes
    UCHAR bDescriptorType;      // CS_INTERFACE descriptor type
    UCHAR bDescriptorSubtype;   // OUTPUT_TERMINAL descriptor subtype
    UCHAR bUnitID;              // Constant uniquely identifying the Unit
    USHORT wTerminalType;       // Type of terminal
    UCHAR bAssocTerminal;       // Associated input terminal
    UCHAR bSourceID;            // ID of Unit or Terminal connected to this Terminal
    UCHAR iTerminal;            // Index of string descriptor describing this unit
    } AUDIO_OUTPUT_TERMINAL, *PAUDIO_OUTPUT_TERMINAL;

// Audio Mixer Unit Descriptor
typedef struct {
    UCHAR bLength;              // Size of this descriptor in bytes
    UCHAR bDescriptorType;      // CS_INTERFACE descriptor type
    UCHAR bDescriptorSubtype;   // MIXER_UNIT descriptor subtype
    UCHAR bUnitID;              // Constant uniquely identifying the Unit
    UCHAR bNrInPins;            // Number of input pins
    UCHAR baSourceID[];         // Unit or Terminal ID for each input
    } AUDIO_MIXER_UNIT, *PAUDIO_MIXER_UNIT;

typedef struct {
    UCHAR bNrChannels;          // Number of output channels
    USHORT wChannelConfig;      // Spatial Location of channels
    UCHAR iChannelNames;        // Index to string desc. for first channel
    UCHAR bmControls[];         // Bitmap of which controls are programmable
    } AUDIO_MIXER_UNIT_CHANNELS, *PAUDIO_MIXER_UNIT_CHANNELS;

// Audio Selector Unit Descriptor
typedef struct {
    UCHAR bLength;              // Size of this descriptor in bytes
    UCHAR bDescriptorType;      // CS_INTERFACE descriptor type
    UCHAR bDescriptorSubtype;   // SELECTOR_UNIT descriptor subtype
    UCHAR bUnitID;              // Constant uniquely identifying the Unit
    UCHAR bNrInPins;            // Number of input pins
    UCHAR baSourceID[];         // Unit or Terminal ID for each input
    } AUDIO_SELECTOR_UNIT, *PAUDIO_SELECTOR_UNIT;

// Audio Feature Unit Descriptor
typedef struct {
    UCHAR bLength;              // Size of this descriptor in bytes
    UCHAR bDescriptorType;      // CS_INTERFACE descriptor type
    UCHAR bDescriptorSubtype;   // FEATURE_UNIT descriptor subtype
    UCHAR bUnitID;              // Constant uniquely identifying the Unit
    UCHAR bSourceID;            // ID of Unit or Terminal connected to this Feature Unit
    UCHAR bControlSize;         // Size (in bytes) of each element in bmaProps array
    UCHAR bmaControls[];        // Indicates available controls for each channel
    } AUDIO_FEATURE_UNIT, *PAUDIO_FEATURE_UNIT;

// Audio Processing Unit Descriptor
typedef struct {
    UCHAR bLength;              // Size of this descriptor in bytes
    UCHAR bDescriptorType;      // CS_INTERFACE descriptor type
    UCHAR bDescriptorSubtype;   // PROCESSING_UNIT descriptor subtype
    UCHAR bUnitID;              // Constant uniquely identifying the Unit
    USHORT wProcessType;        // Type of processing performed by this Unit
    UCHAR bNrInPins;            // Number of input pins
    UCHAR baSourceID[];         // Unit or Terminal ID for each input
    } AUDIO_PROCESSING_UNIT, *PAUDIO_PROCESSING_UNIT;

// Audio Channel Info Block
typedef struct {
    UCHAR bNrChannels;          // Number of output channels in the cluster
    USHORT wChannelConfig;      // Spatial locations of the logical channels
    UCHAR iChannelNames;        // Channel names
    UCHAR bControlSize;         // Size in bytes of the bmControls field
    UCHAR bmControls[];         // Bit-mapped controls available
    } AUDIO_CHANNELS, *PAUDIO_CHANNELS;

// Audio Extension Unit Descriptor
typedef struct {
    UCHAR bLength;              // Size of this descriptor in bytes
    UCHAR bDescriptorType;      // CS_INTERFACE descriptor type
    UCHAR bDescriptorSubtype;   // EXTENSION_UNIT descriptor subtype
    UCHAR bUnitID;              // Constant uniquely identifying the Unit
    USHORT wExtensionCode;      // Vendor-specific code identifying the Unit
    UCHAR bNrInPins;            // Number of input pins
    UCHAR baSourceID[];         // Unit or Terminal ID for each input
    } AUDIO_EXTENSION_UNIT, *PAUDIO_EXTENSION_UNIT;

// AC Interrupt Endpoint Descriptor
typedef struct _USB_INTERRUPT_ENDPOINT_DESCRIPTOR {
    UCHAR bLength;
    UCHAR bDescriptorType;
    UCHAR bEndpointAddress;
    UCHAR bmAttributes;
    USHORT wMaxPacketSize;
    UCHAR bInterval;
    UCHAR bRefresh;
    UCHAR bSynchAddress;
} USB_INTERRUPT_ENDPOINT_DESCRIPTOR, *PUSB_INTERRUPT_ENDPOINT_DESCRIPTOR;

typedef struct _AUDIO_ENDPOINT_DESCRIPTOR {
    UCHAR bLength;
    UCHAR bDescriptorType;
    UCHAR bDescriptorSubtype;
    UCHAR bmAttributes;
    UCHAR bLockDelayUnits;
    USHORT wLockDelay;
} AUDIO_ENDPOINT_DESCRIPTOR, *PAUDIO_ENDPOINT_DESCRIPTOR;

typedef struct _PIN_TERMINAL_MAP {
    ULONG PinNumber;
    ULONG BridgePin;
    union {
        PAUDIO_UNIT pUnit;
        PAUDIO_INPUT_TERMINAL pInput;
        PAUDIO_OUTPUT_TERMINAL pOutput;
    };
} PIN_TERMINAL_MAP, *PPIN_TERMINAL_MAP;

// MIDI Streaming Class-Specific stream interface general descriptor
typedef struct {
    UCHAR bLength;              // Size of this descriptor in bytes
    UCHAR bDescriptorType;      // CS_INTERFACE descriptor type
    UCHAR bDescriptorSubtype;   // MS_HEADER descriptor subtype
    USHORT bcdAudioSpec;        // USB audio class spec revision number
    USHORT wTotalLength;        // Total length, including all units and terminals

    } MIDISTREAMING_GENERAL_STREAM, *PMIDISTREAMING_GENERAL_STREAM;

// MIDI Streaming Source Connections
typedef struct {
    UCHAR SourceID;
    UCHAR SourcePin;
    } MIDISTREAMING_SOURCECONNECTIONS, *PMIDISTREAMING_SOURCECONNECTIONS;

// MIDI Streaming Element Descriptor, part 1
typedef struct {
    UCHAR bLength;              // Size of this descriptor in bytes
    UCHAR bDescriptorType;      // CS_INTERFACE descriptor type
    UCHAR bDescriptorSubtype;   // ELEMENT
    UCHAR bElementID;           // ID of this element
    UCHAR bNrInputPins;         // Number of input pins of this element
    MIDISTREAMING_SOURCECONNECTIONS baSourceConnections[]; // Source connection information
    } MIDISTREAMING_ELEMENT, *PMIDISTREAMING_ELEMENT;

// MIDI Streaming Element Descriptor, part 2 (the rest of the element descriptor)
typedef struct {
    UCHAR bNrOutputPins;        // number of output pins on the element
    UCHAR bInTerminalLink;      // terminal id of the input terminal
    UCHAR bOutTerminalLink;     // terminal id of the output terminal
    UCHAR bElCapsSize;          // size of bmElementCaps
    UCHAR bmElementCaps[];      // caps bitmap
    } MIDISTREAMING_ELEMENT2, *PMIDISTREAMING_ELEMENT2;

// MIDI Streaming MIDI IN Jack Descriptor
typedef struct {
    UCHAR bLength;              // Size of this descriptor in bytes
    UCHAR bDescriptorType;      // CS_INTERFACE descriptor type
    UCHAR bDescriptorSubtype;   // Jack subtype
    UCHAR bJackType;            // EMBEDDED vs. EXTERNAL
    UCHAR bJackID;              // ID of the Jack
    } MIDISTREAMING_MIDIIN_JACK, *PMIDISTREAMING_MIDIIN_JACK;


// MIDI Streaming MIDI OUT Jack Descriptor
typedef struct {
    UCHAR bLength;              // Size of this descriptor in bytes
    UCHAR bDescriptorType;      // CS_INTERFACE descriptor type
    UCHAR bDescriptorSubtype;   // Jack subtype
    UCHAR bJackType;            // EMBEDDED vs. EXTERNAL
    UCHAR bJackID;              // ID of the Jack
    UCHAR bNrInputPins;         // Number of input pins on this jack
    MIDISTREAMING_SOURCECONNECTIONS baSourceConnections[]; // Source connection information
    } MIDISTREAMING_MIDIOUT_JACK, *PMIDISTREAMING_MIDIOUT_JACK;


// MIDI Streaming MIDI Endpoint Descriptor
typedef struct _MIDISTREAMING_ENDPOINT_DESCRIPTOR {
    UCHAR bLength;              // Size of this descriptor in bytes
    UCHAR bDescriptorType;      // CS_ENDPOINT descriptor type
    UCHAR bDescriptorSubtype;   // MS_GENERAL descriptor subtype
    UCHAR bNumEmbMIDIJack;      // Number of embedded jacks
    UCHAR baAssocJackID[];      // IDs of the embedded jacks
} MIDISTREAMING_ENDPOINT_DESCRIPTOR, *PMIDISTREAMING_ENDPOINT_DESCRIPTOR;


#pragma pack( pop, pcm2usb_structs )

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\drivers\usbaudio.2\filter.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 2000
//
//  File:       filter.c
//
//--------------------------------------------------------------------------

#include "common.h"

NTSTATUS
USBAudioFilterCreate(
    IN OUT PKSFILTER pKsFilter,
    IN PIRP Irp
    )
{
    PKSFILTERFACTORY pKsFilterFactory;
    PKSDEVICE pKsDevice;
    PFILTER_CONTEXT pFilterContext;

    _DbgPrintF(DEBUGLVL_VERBOSE,("[FilterCreate]\n"));

    PAGED_CODE();

    ASSERT(pKsFilter);
    ASSERT(Irp);

    pKsFilterFactory = KsFilterGetParentFilterFactory( pKsFilter );
    if ( !pKsFilterFactory ) {
        return STATUS_INVALID_PARAMETER;
    }

    pKsDevice = KsFilterFactoryGetParentDevice( pKsFilterFactory );
    if ( !pKsDevice ) {
        return STATUS_INVALID_PARAMETER;
    }

    // Allocate the Filter Context
    pFilterContext = pKsFilter->Context = AllocMem(NonPagedPool, sizeof(FILTER_CONTEXT));
    if ( !pFilterContext ) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory( pFilterContext, sizeof(FILTER_CONTEXT) );

    // Bag the context for easy cleanup.
    KsAddItemToObjectBag(pKsFilter->Bag, pFilterContext, FreeMem);

    // Get the hardware device extension and save it in the filter context.
    pFilterContext->pHwDevExt = pKsDevice->Context;
    pFilterContext->pNextDeviceObject = pKsDevice->NextDeviceObject;

    return STATUS_SUCCESS;
}

const
KSFILTER_DISPATCH
USBAudioFilterDispatch =
{
    USBAudioFilterCreate,
    NULL, // Close
    NULL, // Process
    NULL // Reset
};

NTSTATUS
USBAudioSyncGetStringDescriptor(
    IN PDEVICE_OBJECT DevicePDO,
    IN UCHAR Index,
    IN USHORT LangId,
    IN OUT PUSB_STRING_DESCRIPTOR Buffer,
    IN ULONG BufferLength,
    IN PULONG BytesReturned,
    IN BOOLEAN ExpectHeader
    )
 /* ++
  *
  * Description:
  *
  * Return:
  *
  * NTSTATUS
  *
  * -- */
{

    NTSTATUS ntStatus = STATUS_SUCCESS;
    PURB urb;

    PAGED_CODE();
    _DbgPrintF(DEBUGLVL_VERBOSE,("[USBAudioSyncGetStringDescriptor] enter\n"));

    //
    // Allocate an Urb .
    //

    urb = AllocMem(NonPagedPool, sizeof(struct _URB_CONTROL_DESCRIPTOR_REQUEST));

    if (NULL == urb) {
        _DbgPrintF(DEBUGLVL_VERBOSE,("[USBAudioSyncGetStringDescriptor] failed to alloc Urb\n"));
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    }


    if (urb) {

        //
        // got the urb no try to get descriptor data
        //

        UsbBuildGetDescriptorRequest(urb,
                                     (USHORT) sizeof (struct _URB_CONTROL_DESCRIPTOR_REQUEST),
                                     USB_STRING_DESCRIPTOR_TYPE,
                                     Index,
                                     LangId,
                                     Buffer,
                                     NULL,
                                     BufferLength,
                                     NULL);

        ntStatus = SubmitUrbToUsbdSynch(DevicePDO, urb);

        if (NT_SUCCESS(ntStatus) &&
            urb->UrbControlDescriptorRequest.TransferBufferLength > BufferLength) {

            _DbgPrintF(DEBUGLVL_VERBOSE,("[USBAudioSyncGetStringDescriptor] Invalid length returned, possible buffer overrun\n"));
            ntStatus = STATUS_DEVICE_DATA_ERROR;
        }

        if (NT_SUCCESS(ntStatus) && BytesReturned) {
            *BytesReturned =
                urb->UrbControlDescriptorRequest.TransferBufferLength;
        }

        if (NT_SUCCESS(ntStatus) &&
            urb->UrbControlDescriptorRequest.TransferBufferLength != Buffer->bLength &&
            ExpectHeader) {

            _DbgPrintF(DEBUGLVL_VERBOSE,("[USBAudioSyncGetStringDescriptor] Bogus Descriptor from devce xfer buf %d descriptor %d\n",
                urb->UrbControlDescriptorRequest.TransferBufferLength,
                Buffer->bLength));
            ntStatus = STATUS_DEVICE_DATA_ERROR;
        }

        _DbgPrintF(DEBUGLVL_VERBOSE,("[USBAudioSyncGetStringDescriptor] GetDeviceDescriptor, string descriptor = %x\n",
                Buffer));

        FreeMem(urb);
    } else {
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    }

    return ntStatus;
}

NTSTATUS
USBAudioCheckDeviceLanguage(
    IN PDEVICE_OBJECT DevicePDO,
    IN LANGID LanguageId
    )
 /* ++
  *
  * Description:
  *
  * queries the device for a supported language id -- if the device supports
  * the language then the index for this language is returned .
  *
  * DevicePDO - device object to call with urb request
  *
  * LanguageId -
  *
  * Return:
  *
  * success if a particular language is is supported by a device
  *
  * -- */
{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PUSB_STRING_DESCRIPTOR usbString;
    PUSHORT supportedLangId;
    ULONG numLangIds, i;
    ULONG length;

    PAGED_CODE();

    usbString = AllocMem(NonPagedPool, MAXIMUM_USB_STRING_LENGTH);

    if (usbString) {
        //
        // first get the array of supported languages
        //
        ntStatus = USBAudioSyncGetStringDescriptor(DevicePDO,
                                                   0, //index 0
                                                   0, //langid 0
                                                   usbString,
                                                   MAXIMUM_USB_STRING_LENGTH,
                                                   &length,
                                                   TRUE);

        //
        // now check for the requested language in the array of supported
        // languages
        //

        //
        // NOTE: this seems a bit much -- we should be able to just ask for
        // the string with a given language id and expect it to fail but since
        // the array of supported languages is part of the USB spec we may as
        // well check it.
        //

        if (NT_SUCCESS(ntStatus)) {

            // subtract size of header
            numLangIds = (length - 2)/2;
            supportedLangId = (PUSHORT) &usbString->bString;

            _DbgPrintF(DEBUGLVL_VERBOSE,("[USBAudioCheckDeviceLanguage] NumLangIds = %d\n", numLangIds));

            ntStatus = STATUS_NOT_SUPPORTED;
            for (i=0; i<numLangIds; i++) {
                if (*supportedLangId == LanguageId) {

                    ntStatus = STATUS_SUCCESS;
                    break;
                }
                supportedLangId++;
            }
        }

        FreeMem(usbString);

    } else {
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    }

    if (!NT_SUCCESS(ntStatus)) {
        _DbgPrintF(DEBUGLVL_VERBOSE,("[USBAudioCheckDeviceLanguage]Language %x -- not supported by this device = %x\n", LanguageId));
    }

    return ntStatus;

}

NTSTATUS
USBAudioGetStringFromDevice(
    IN PDEVICE_OBJECT DevicePDO,
    IN OUT PWCHAR *StringBuffer,
    IN OUT PUSHORT StringBufferLength,
    IN LANGID LanguageId,
    IN UCHAR StringIndex
    )
 /* ++
  *
  * Description:
  *
  * queries the device for the string then allocates a buffer just big enough to hold it.
  *
  * *SerialNumberBuffer is null if an error occurs, otherwise it is filled in
  *  with a pointer to the NULL terminated UNICODE serial number for the device
  *
  * DeviceObject - deviceobject to call with urb request
  *
  * LanguageId - 16 bit language id
  *
  * StringIndex - USB string Index to fetch
  *
  * Return:
  *
  * NTSTATUS code
  *
  * -- */
{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PUSB_STRING_DESCRIPTOR usbString;
    PVOID tmp;

    PAGED_CODE();

    *StringBuffer = NULL;
    *StringBufferLength = 0;

    usbString = AllocMem(NonPagedPool, MAXIMUM_USB_STRING_LENGTH);

    if (usbString) {

        ntStatus = USBAudioCheckDeviceLanguage(DevicePDO, LanguageId);

        if (NT_SUCCESS(ntStatus)) {
            //
            // this device supports our language,
            // go ahead and try to get the serial number
            //

            ntStatus = USBAudioSyncGetStringDescriptor(DevicePDO,
                                                       StringIndex, //index
                                                       LanguageId, //langid
                                                       usbString,
                                                       MAXIMUM_USB_STRING_LENGTH,
                                                       NULL,
                                                       TRUE);

            if (NT_SUCCESS(ntStatus)) {

                //
                // device returned a string!!!
                //

                _DbgPrintF(DEBUGLVL_VERBOSE,("[USBAudioGetStringFromDevice] Device returned string = %x\n", usbString));

                //
                // allocate a buffer and copy the string to it
                //
                // NOTE: must use stock alloc function because
                // PnP frees this string.

                tmp = AllocMem(PagedPool, usbString->bLength);
                if (tmp) {
                    RtlZeroMemory(tmp, usbString->bLength);
                    RtlCopyMemory(tmp,
                                  &usbString->bString,
                                  usbString->bLength-2);
                    *StringBuffer = tmp;
                    *StringBufferLength = usbString->bLength;
                } else {
                    ntStatus = STATUS_INSUFFICIENT_RESOURCES;
                }
            }
        }

        FreeMem(usbString);

    } else {
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    }

    return ntStatus;
}

NTSTATUS
USBAudioRegSetValue(
    IN HANDLE hKey,
    IN PCWSTR szValueName,
    IN ULONG  Type,
    IN PVOID  pData,
    IN ULONG  cbData
)
{
    UNICODE_STRING ustr;

    RtlInitUnicodeString( &ustr, szValueName );

    return ZwSetValueKey( hKey,
                          &ustr,
                          0,
                          Type,
                          pData,
                          cbData );
}

NTSTATUS
USBAudioRegGetValue(
    IN HANDLE hKey,
    IN PCWSTR szValueName,
    PKEY_VALUE_FULL_INFORMATION *ppkvfi
)
{
    UNICODE_STRING ustrValueName;
    NTSTATUS Status;
    ULONG cbValue;

    *ppkvfi = NULL;
    RtlInitUnicodeString(&ustrValueName, szValueName);
    Status = ZwQueryValueKey(
      hKey,
      &ustrValueName,
      KeyValueFullInformation,
      NULL,
      0,
      &cbValue);

    if(Status != STATUS_BUFFER_OVERFLOW &&
       Status != STATUS_BUFFER_TOO_SMALL) {
        goto exit;
    }

    *ppkvfi = (PKEY_VALUE_FULL_INFORMATION)AllocMem(PagedPool, cbValue);
    if(*ppkvfi == NULL) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto exit;
    }

    Status = ZwQueryValueKey(
      hKey,
      &ustrValueName,
      KeyValueFullInformation,
      *ppkvfi,
      cbValue,
      &cbValue);

    if(!NT_SUCCESS(Status)) {
        FreeMem( *ppkvfi );
        *ppkvfi = NULL;
        goto exit;
    }
exit:
    return(Status);
}

VOID
USBAudioRegCloseKey( IN HANDLE hKey )
{
    ZwClose( hKey );
}

NTSTATUS
USBAudioRegCreateMediaCategoriesKey(
    IN PUNICODE_STRING puKeyName,
    OUT PHANDLE phKey
)
{
    HANDLE            hMediaCategoriesKey;
    OBJECT_ATTRIBUTES ObjectAttributes;
    UNICODE_STRING    ustr;
    ULONG             Disposition;
    NTSTATUS          ntStatus;

    // Open a key for the MediaCategories branch of the registry
    RtlInitUnicodeString( &ustr, MediaCategories );
    InitializeObjectAttributes( &ObjectAttributes,
                                &ustr,
                                OBJ_CASE_INSENSITIVE, // Attributes
                                NULL,
                                NULL );               // Security

    ntStatus = ZwOpenKey( &hMediaCategoriesKey,
                          KEY_ALL_ACCESS,
                          &ObjectAttributes );
    if (!NT_SUCCESS(ntStatus)) {
        return ntStatus;
    }

    // Now create a key for szKeyName
    InitializeObjectAttributes( &ObjectAttributes,
                                puKeyName,
                                OBJ_CASE_INSENSITIVE, // Attributes
                                hMediaCategoriesKey,
                                NULL );               // Security

    ntStatus = ZwCreateKey( phKey,
                            KEY_ALL_ACCESS,
                            &ObjectAttributes,
                            0,                  // TitleIndex
                            NULL,               // Class
                            REG_OPTION_NON_VOLATILE,
                            &Disposition);

    ZwClose( hMediaCategoriesKey );

    return ntStatus;
}

NTSTATUS
USBAudioInitProductNameKey(
    IN PKSDEVICE pKsDevice,
    IN GUID *ProductNameGuid
)
{
    PHW_DEVICE_EXTENSION pHwDevExt = pKsDevice->Context;
    PUSB_DEVICE_DESCRIPTOR pDeviceDescriptor = pHwDevExt->pDeviceDescriptor;
    UNICODE_STRING ProductNameGuidString;
    PWCHAR StringBuffer = NULL;
    USHORT StringBufferLength;
    HANDLE hProductNameKey = NULL;
    NTSTATUS ntStatus;

    ASSERT(pDeviceDescriptor);

    //  Guid to SZ
    ntStatus = RtlStringFromGUID( ProductNameGuid, &ProductNameGuidString );
    if (!NT_SUCCESS(ntStatus)) {
        _DbgPrintF(DEBUGLVL_VERBOSE,("[USBAudioInitProductNameKey] Create unicode string from GUID\n"));
        return ntStatus;
    }

    //  Get the string from the device
    ntStatus = USBAudioGetStringFromDevice(pKsDevice->NextDeviceObject,
                                           &StringBuffer,
                                           &StringBufferLength,
                                           0x0409, // good'ol american english
                                           pDeviceDescriptor->iProduct);
    if (NT_SUCCESS(ntStatus) && (StringBuffer != NULL)) {

        //  Create the Product Name key in the registry under MediaCategories
        ntStatus = USBAudioRegCreateMediaCategoriesKey( &ProductNameGuidString,
                                                        &hProductNameKey );
        if (NT_SUCCESS(ntStatus)) {

            //  Place the Product string into the registry
            ntStatus = USBAudioRegSetValue( hProductNameKey,
                                            NodeNameValue,
                                            REG_SZ,
                                            StringBuffer,
                                            StringBufferLength);  // size in bytes
        }
        else {
            _DbgPrintF(DEBUGLVL_VERBOSE,("[USBAudioInitProductNameKey] Failed to create registry key\n"));
        }
    }
    else {
        _DbgPrintF(DEBUGLVL_VERBOSE,("[USBAudioInitProductNameKey] Device failed to give a product string\n"));
    }

    // Cleanup after ourselves
    RtlFreeUnicodeString( &ProductNameGuidString );

    if (hProductNameKey) {
        USBAudioRegCloseKey( hProductNameKey );
    }

    if (StringBuffer) {
        FreeMem( StringBuffer );
    }

    return ntStatus;
}

BOOL
IsValidProductStringDescriptor(
    IN PKSDEVICE pKsDevice,
    IN PUSB_DEVICE_DESCRIPTOR pDeviceDescriptor
)
{
    HANDLE hRootHandle;
    PKEY_VALUE_FULL_INFORMATION pkvfi = NULL;
    NTSTATUS ntStatus;

    if (pDeviceDescriptor->iProduct == 0) {
        return FALSE;
    }

    // Read the registry to figure out if we are supposed to ignore the HW string
    ntStatus = IoOpenDeviceRegistryKey(
        pKsDevice->PhysicalDeviceObject,
        PLUGPLAY_REGKEY_DRIVER,
        KEY_ALL_ACCESS,
        &hRootHandle );

    if (NT_SUCCESS(ntStatus)) {
        ntStatus = USBAudioRegGetValue( hRootHandle, L"IgnoreHwString", &pkvfi );
        if ( NT_SUCCESS(ntStatus) ) {
            if( pkvfi->Type == REG_DWORD ) {
                if (1 == *((PULONG)(((PUCHAR)pkvfi) + pkvfi->DataOffset)) ) {
                    ntStatus = STATUS_SUCCESS;
                }
            }
            else {
                ntStatus = STATUS_INVALID_PARAMETER;
            }
            FreeMem( pkvfi );
        }

        ZwClose(hRootHandle);

        //  STATUS_SUCCESS means that we found the ignore hw string key and it was set to 1
        if (NT_SUCCESS(ntStatus)) {
            _DbgPrintF(DEBUGLVL_VERBOSE, ("Ignoring the string descriptor!\n"));
            return FALSE;
        }
    }
    else {
        _DbgPrintF(DEBUGLVL_VERBOSE, ("IoOpenDeviceRegistryKey Failed!\n"));
    }

    return TRUE;
}

NTSTATUS
USBAudioInitComponentId(
    IN PKSDEVICE pKsDevice,
    IN OUT PKSCOMPONENTID ComponentId
)
{
    PHW_DEVICE_EXTENSION pHwDevExt = pKsDevice->Context;
    PKSFILTER_DESCRIPTOR pUSBAudioFilterDescriptor = &pHwDevExt->USBAudioFilterDescriptor;
    PUSB_DEVICE_DESCRIPTOR pDeviceDescriptor = pHwDevExt->pDeviceDescriptor;
    NTSTATUS ntStatus;

    ASSERT(pDeviceDescriptor);
    ASSERT(pUSBAudioFilterDescriptor);

    INIT_USBAUDIO_MID( &ComponentId->Manufacturer, pDeviceDescriptor->idVendor);
    INIT_USBAUDIO_PID( &ComponentId->Product, pDeviceDescriptor->idProduct);
    ComponentId->Component = KSCOMPONENTID_USBAUDIO;

    //  Check to make sure that string descriptor index is valid
    if (!IsValidProductStringDescriptor(pKsDevice, pDeviceDescriptor)) {
        ComponentId->Name = GUID_NULL;
    }
    else {
        // Create a GUID for the product string and place the string gathered from the device
        // into the registry if it exists
        INIT_USBAUDIO_PRODUCT_NAME( &ComponentId->Name,
                                    pDeviceDescriptor->idVendor,
                                    pDeviceDescriptor->idProduct,
                                    pDeviceDescriptor->iProduct);

        ntStatus = USBAudioInitProductNameKey( pKsDevice, &ComponentId->Name );
        if (!NT_SUCCESS(ntStatus)) {
            ComponentId->Name = GUID_NULL;
        }
    }

    ComponentId->Version = (ULONG)(pDeviceDescriptor->bcdDevice >> 8);
    ComponentId->Revision = (ULONG)pDeviceDescriptor->bcdDevice & 0xFF;

    return STATUS_SUCCESS;
}

NTSTATUS
USBAudioCreateFilterContext( PKSDEVICE pKsDevice )
{
    PHW_DEVICE_EXTENSION pHwDevExt = pKsDevice->Context;
    PKSFILTER_DESCRIPTOR pUSBAudioFilterDescriptor = &pHwDevExt->USBAudioFilterDescriptor;
    PKSCOMPONENTID pKsComponentId;
    NTSTATUS ntStatus = STATUS_SUCCESS;
#define FILTER_PROPS
#ifdef FILTER_PROPS
    PKSAUTOMATION_TABLE pKsAutomationTable;
    PKSPROPERTY_ITEM pDevPropItems;
    PKSPROPERTY_SET pDevPropSet;
    ULONG ulNumPropItems;
    ULONG ulNumPropSets;
#endif

    PAGED_CODE();

    //TRAP;

    RtlZeroMemory( pUSBAudioFilterDescriptor, sizeof(KSFILTER_DESCRIPTOR) );

    // Fill in static values of USBAudioFilterDescriptor
    pUSBAudioFilterDescriptor->Dispatch      = &USBAudioFilterDispatch;
    pUSBAudioFilterDescriptor->ReferenceGuid = &KSNAME_Filter;
    pUSBAudioFilterDescriptor->Version       = KSFILTER_DESCRIPTOR_VERSION;
    pUSBAudioFilterDescriptor->Flags         = 0;

    pKsComponentId = AllocMem(NonPagedPool, sizeof(KSCOMPONENTID) );
    if (!pKsComponentId) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    // Bag the KSCOMPONENTID for easy cleanup.
    KsAddItemToObjectBag(pKsDevice->Bag, pKsComponentId, FreeMem);
    RtlZeroMemory(pKsComponentId, sizeof(KSCOMPONENTID));

    // Fill in the allocated KSCOMPONENTID with values obtained from the device descriptors
    ntStatus = USBAudioInitComponentId ( pKsDevice, pKsComponentId );
    if ( !NT_SUCCESS(ntStatus) ) {
        return ntStatus;
    }

    pUSBAudioFilterDescriptor->ComponentId = pKsComponentId;


    // Build the descriptors for the device pins
    ntStatus = USBAudioPinBuildDescriptors( pKsDevice,
                                            (PKSPIN_DESCRIPTOR_EX *)&pUSBAudioFilterDescriptor->PinDescriptors,
                                            &pUSBAudioFilterDescriptor->PinDescriptorsCount,
                                            &pUSBAudioFilterDescriptor->PinDescriptorSize );
    if ( !NT_SUCCESS(ntStatus) ) {
        return ntStatus;
    }

    // Build the Topology for the device filter
    ntStatus = BuildUSBAudioFilterTopology( pKsDevice );
    if ( !NT_SUCCESS(ntStatus) ) {
        return ntStatus;
    }

#ifdef FILTER_PROPS // if there are properties that need supported on the filter, use this code
    // Build the Filter Property Sets
    BuildFilterPropertySet( pUSBAudioFilterDescriptor,
                            NULL,
                            NULL,
                            &ulNumPropItems,
                            &ulNumPropSets );

    pKsAutomationTable = AllocMem(NonPagedPool, sizeof(KSAUTOMATION_TABLE) +
                                                (ulNumPropItems * sizeof(KSPROPERTY_ITEM)) +
                                                (ulNumPropSets  * sizeof(KSPROPERTY_SET)));

    if (!pKsAutomationTable ) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    // Bag the context for easy cleanup.
    KsAddItemToObjectBag(pKsDevice->Bag, pKsAutomationTable, FreeMem);

    RtlZeroMemory(pKsAutomationTable, sizeof(KSAUTOMATION_TABLE));

    pDevPropItems = (PKSPROPERTY_ITEM)(pKsAutomationTable + 1);
    pDevPropSet   = (PKSPROPERTY_SET)(pDevPropItems + ulNumPropItems);

    BuildFilterPropertySet( pUSBAudioFilterDescriptor,
                            pDevPropItems,
                            pDevPropSet,
                            &ulNumPropItems,
                            &ulNumPropSets );

    pUSBAudioFilterDescriptor->AutomationTable = (const KSAUTOMATION_TABLE *)pKsAutomationTable;
    pKsAutomationTable->PropertySetsCount = ulNumPropSets;
    pKsAutomationTable->PropertyItemSize  = sizeof(KSPROPERTY_ITEM);
    pKsAutomationTable->PropertySets      = (const KSPROPERTY_SET *)pDevPropSet;

    DbgLog("CreFilF", pUSBAudioFilterDescriptor, pDevPropSet, pDevPropItems, pKsDevice);
#else
    pUSBAudioFilterDescriptor->AutomationTable = NULL;

    DbgLog("CreFilF", pUSBAudioFilterDescriptor, pKsDevice, 0, 0);
#endif


    // Create the Filter for the device
    ntStatus = KsCreateFilterFactory( pKsDevice->FunctionalDeviceObject,
                                      pUSBAudioFilterDescriptor,
                                      L"GLOBAL",
                                      NULL,
                                      KSCREATE_ITEM_FREEONSTOP,
                                      NULL,
                                      NULL,
                                      NULL );

    if (!NT_SUCCESS(ntStatus) ) {
        return ntStatus;
    }

    return ntStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\drivers\usbaudio.2\device.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 2000
//
//  File:       device.c
//
//--------------------------------------------------------------------------

#include <initguid.h>
#include "common.h"
#include "perf.h"

NTSTATUS
USBAudioAddDevice(
    IN PKSDEVICE Device
)
{
    //DbgPrint("USB Audio in the house.\n");
    _DbgPrintF(DEBUGLVL_TERSE,("[CreateDevice]\n"));

    PAGED_CODE();

    ASSERT(Device);

    return STATUS_SUCCESS;
}

NTSTATUS
USBAudioPnpStart(
    IN PKSDEVICE pKsDevice,
    IN PIRP Irp,
    IN PCM_RESOURCE_LIST TranslatedResources,
    IN PCM_RESOURCE_LIST UntranslatedResources
    )
{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    _DbgPrintF(DEBUGLVL_TERSE,("[PnpStart]\n"));

    PAGED_CODE();

    ASSERT(pKsDevice);
    ASSERT(Irp);


#if DBG && DBGMEMMAP
    InitializeMemoryList();
#endif

    // Initialize Debug log

    DbgLogInit();
    DbgLog("TEST",1,2,3,4);

    //
    // Since we can get more than one PnpStart call without having a matching
    // PnpClose call, we need to make sure that we don't reinitialize our
    // context information for this pKsDevice.
    //
    if (!pKsDevice->Started) {
        // Allocate space for the Device Context
        pKsDevice->Context = AllocMem( NonPagedPool, sizeof(HW_DEVICE_EXTENSION));
        if (!pKsDevice->Context) {
            return STATUS_INSUFFICIENT_RESOURCES;
        }
        RtlZeroMemory(pKsDevice->Context, sizeof(HW_DEVICE_EXTENSION));

        // Bag the context for easy cleanup.
        KsAddItemToObjectBag(pKsDevice->Bag, pKsDevice->Context, FreeMem);

        ((PHW_DEVICE_EXTENSION)pKsDevice->Context)->pNextDeviceObject = pKsDevice->NextDeviceObject;

        ntStatus = StartUSBAudioDevice( pKsDevice );
        if (NT_SUCCESS(ntStatus)) {
            ((PHW_DEVICE_EXTENSION)pKsDevice->Context)->fDeviceStopped = FALSE;
            ntStatus = USBAudioCreateFilterContext( pKsDevice );
        }

        // Get the bus interface on USB
        if (NT_SUCCESS(ntStatus)) {
            ntStatus = USBAudioGetUsbBusInterface( pKsDevice );
        }

        // Initialize perf logging.
        PerfRegisterProvider(pKsDevice->PhysicalDeviceObject);

        //
        // Individual MIDI pins (=device) are exposed for every MIDI jack.  Multiple jacks are
        // addressed via a single endpoint using the Code Index Number.  In order to arbitrate for
        // all of these pins on the same endpoint, the context needs to be stored at the KsDevice
        // level.
        //
        ((PHW_DEVICE_EXTENSION)pKsDevice->Context)->ulInterfaceNumberSelected = MAX_ULONG;
        ((PHW_DEVICE_EXTENSION)pKsDevice->Context)->pMIDIPipeInfo = NULL;
        ((PHW_DEVICE_EXTENSION)pKsDevice->Context)->Pipes = NULL;
    }
    else {
        _DbgPrintF(DEBUGLVL_TERSE,("[PnpStart] ignoring second start\n"));
    }

    return ntStatus;
}

NTSTATUS
USBAudioPnpQueryStop(
    IN PKSDEVICE Device,
    IN PIRP Irp
    )
{
    _DbgPrintF(DEBUGLVL_TERSE,("[PnpQueryStop]\n"));

    PAGED_CODE();

    ASSERT(Device);
    ASSERT(Irp);

    return STATUS_SUCCESS;
}

void
USBAudioPnpCancelStop(
    IN PKSDEVICE Device,
    IN PIRP Irp
    )
{
    _DbgPrintF(DEBUGLVL_TERSE,("[PnpCancelStop]\n"));

    PAGED_CODE();

    ASSERT(Device);
    ASSERT(Irp);
}

void
USBAudioPnpStop(
    IN PKSDEVICE pKsDevice,
    IN PIRP pIrp )
{
    _DbgPrintF(DEBUGLVL_TERSE,("[PnpStop]\n"));

    PAGED_CODE();

    DbgLogUninit();

    ASSERT(pKsDevice);
    ASSERT(pIrp);

    // Set a flag that the device needs to be stopped.
    StopUSBAudioDevice( pKsDevice );
    ((PHW_DEVICE_EXTENSION)pKsDevice->Context)->fDeviceStopped = TRUE;

    PerfUnregisterProvider(pKsDevice->PhysicalDeviceObject);
}

NTSTATUS
USBAudioPnpQueryRemove(
    IN PKSDEVICE Device,
    IN PIRP Irp
    )
{
    _DbgPrintF(DEBUGLVL_TERSE,("[PnpQueryRemove]\n"));

    PAGED_CODE();

    ASSERT(Device);
    ASSERT(Irp);

    return STATUS_SUCCESS;
}

void
USBAudioPnpCancelRemove(
    IN PKSDEVICE Device,
    IN PIRP Irp
    )
{
    _DbgPrintF(DEBUGLVL_TERSE,("[PnpCancelRemove]\n"));

    PAGED_CODE();

    ASSERT(Device);
    ASSERT(Irp);
}

void
USBAudioPnpRemove(
    IN PKSDEVICE pKsDevice,
    IN PIRP pIrp
    )
{
    //DbgPrint("USB Audio leaving the house.\n");
    _DbgPrintF(DEBUGLVL_TERSE,("[PnpRemove]\n"));

    PAGED_CODE();

    ASSERT(pKsDevice);
    ASSERT(pIrp);

    if (!((PHW_DEVICE_EXTENSION)pKsDevice->Context)->fDeviceStopped) {

        // Probable surprise removal during device start
        StopUSBAudioDevice( pKsDevice );
        ((PHW_DEVICE_EXTENSION)pKsDevice->Context)->fDeviceStopped = TRUE;

        PerfUnregisterProvider(pKsDevice->PhysicalDeviceObject);
    }
    // In Win9x, if this occurs before a Stop on a pin then there has been a Surprise Removal.
}

NTSTATUS
USBAudioPnpQueryCapabilities(
    IN PKSDEVICE Device,
    IN PIRP Irp,
    IN OUT PDEVICE_CAPABILITIES pCapabilities
    )
{
    _DbgPrintF(DEBUGLVL_TERSE,("[PnpQueryCapabilities]\n"));

    PAGED_CODE();

    ASSERT(Device);
    ASSERT(Irp);

    pCapabilities->Size              = sizeof(DEVICE_CAPABILITIES);
    pCapabilities->Version           = 1;  // the version documented here is version 1
    pCapabilities->LockSupported     = FALSE;
    pCapabilities->EjectSupported    = FALSE; // Ejectable in S0
    pCapabilities->Removable         = TRUE;
    pCapabilities->DockDevice        = FALSE;
    pCapabilities->UniqueID          = FALSE;
    pCapabilities->SilentInstall     = TRUE;
    pCapabilities->RawDeviceOK       = FALSE;
    pCapabilities->SurpriseRemovalOK = TRUE;
    pCapabilities->HardwareDisabled  = FALSE;

    pCapabilities->DeviceWake        = PowerDeviceUnspecified;
    pCapabilities->D1Latency         = 0;
    pCapabilities->D2Latency         = 0;
    pCapabilities->D3Latency         = 20000; // 2 Seconds (in 100 usec units)

    return STATUS_SUCCESS;
}

void
USBAudioSurpriseRemoval(
    IN PKSDEVICE pKsDevice,
    IN PIRP pIrp
    )
{
    //DbgPrint("USB Audio leaving the house by surprise.\n");
    _DbgPrintF(DEBUGLVL_TERSE,("[SurpriseRemoval]\n"));

    PAGED_CODE();

    ASSERT(pKsDevice);
    ASSERT(pIrp);

    // For any currently streaming pin on any open filter of the device,
    // clean up and quit it.
}

NTSTATUS
USBAudioQueryPower(
    IN PKSDEVICE pKsDevice,
    IN PIRP pIrp,
    IN DEVICE_POWER_STATE DeviceTo,
    IN DEVICE_POWER_STATE DeviceFrom,
    IN SYSTEM_POWER_STATE SystemTo,
    IN SYSTEM_POWER_STATE SystemFrom,
    IN POWER_ACTION Action )
{
    _DbgPrintF(DEBUGLVL_TERSE,("[USBAudioQueryPower] SysFrom: %d SysTo: %d DevFrom: %d DevTo: %d\n",
                               SystemFrom, SystemTo, DeviceFrom, DeviceTo));
    return STATUS_SUCCESS;
}

void
USBAudioSetPower(
    IN PKSDEVICE pKsDevice,
    IN PIRP pIrp,
    IN DEVICE_POWER_STATE To,
    IN DEVICE_POWER_STATE From )
{
    PKSFILTERFACTORY pKsFilterFactory;
    PKSFILTER pKsFilter;
    PKSPIN pKsPin;
    PPIN_CONTEXT pPinContext;
    ULONG i;
    NTSTATUS ntStatus;

    _DbgPrintF(DEBUGLVL_TERSE,("[USBAudioSetPower] From: %d To: %d\n",
                                From, To ));

    // First restore device settings from cached values
    if (To == PowerDeviceD0) {
        RestoreCachedSettings(pKsDevice);
    }

    pKsFilterFactory = KsDeviceGetFirstChildFilterFactory( pKsDevice );

    while (pKsFilterFactory) {
        // Find each open filter for this filter factory
        pKsFilter = KsFilterFactoryGetFirstChildFilter( pKsFilterFactory );

        while (pKsFilter) {

            KsFilterAcquireControl( pKsFilter );

            // Find each open pin for this open filter
            for ( i = 0; i < pKsFilter->Descriptor->PinDescriptorsCount; i++) {

                pKsPin = KsFilterGetFirstChildPin( pKsFilter, i );

                while (pKsPin) {

                    pPinContext = pKsPin->Context;
                    if ( (pPinContext->PinType == WaveOut) ||
                         (pPinContext->PinType == WaveIn) )  {
                        switch(To) {
                            case PowerDeviceD0:

                                // For the open Pin open the gate and restart data pump.
                                USBAudioPinReturnFromStandby( pKsPin );
                                break;

                            case PowerDeviceD1:
                            case PowerDeviceD2:
                            case PowerDeviceD3:

                                // For the open Pin close the gate and wait til all activity stops.
                                USBAudioPinGoToStandby( pKsPin );
                                break;
                        }
                    }

                    // Get the next pin
                    pKsPin = KsPinGetNextSiblingPin( pKsPin );
                }
            }

            KsFilterReleaseControl( pKsFilter );

            // Get the next Filter
            pKsFilter = KsFilterGetNextSiblingFilter( pKsFilter );
        }
        // Get the next Filter Factory
        pKsFilterFactory = KsFilterFactoryGetNextSiblingFilterFactory( pKsFilterFactory );
    }

    _DbgPrintF(DEBUGLVL_TERSE,("exit [USBAudioSetPower] From: %d To: %d\n",
                                From, To ));
}

NTSTATUS
USBAudioDeferIrpCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
/*++

Routine Description:

    This routine is called when the port driver completes an IRP.


Arguments:

    DeviceObject - Pointer to the device object for the class device.

    Irp - Irp completed.

    Context - Driver defined context.

Return Value:

    The function value is the final status from the operation.

--*/
{
    PKEVENT event = Context;


    KeSetEvent(event,
               1,
               FALSE);

    return STATUS_MORE_PROCESSING_REQUIRED;

}

NTSTATUS
USBAudioGetUsbBusInterface(
    IN PKSDEVICE pKsDevice
    )
/*++

Routine Description:

    Query the stack for the 'USBDI' bus interface

Arguments:

Return Value:


--*/
{
    PIO_STACK_LOCATION nextStack;
    PIRP Irp;
    NTSTATUS ntStatus;
    KEVENT event;
    PHW_DEVICE_EXTENSION pHwDevExt;

    pHwDevExt = pKsDevice->Context;

    Irp = IoAllocateIrp(
        pKsDevice->NextDeviceObject->StackSize, FALSE);

    if (!Irp) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    pHwDevExt->pBusIf = AllocMem(NonPagedPool, sizeof(USB_BUS_INTERFACE_USBDI_V0));
    if (!pHwDevExt->pBusIf) {
        IoFreeIrp(Irp);
        return STATUS_UNSUCCESSFUL;
    }

    // Bag the bus interface for easy cleanup.
    KsAddItemToObjectBag(pKsDevice->Bag, pHwDevExt->pBusIf, FreeMem);

    // All PnP IRP's need the Status field initialized to STATUS_NOT_SUPPORTED.
    Irp->IoStatus.Status = STATUS_NOT_SUPPORTED;

    KeInitializeEvent(&event, NotificationEvent, FALSE);

    IoSetCompletionRoutine(Irp,
                           USBAudioDeferIrpCompletion,
                           &event,
                           TRUE,
                           TRUE,
                           TRUE);

    nextStack = IoGetNextIrpStackLocation(Irp);
    ASSERT(nextStack != NULL);
    nextStack->MajorFunction= IRP_MJ_PNP;
    nextStack->MinorFunction= IRP_MN_QUERY_INTERFACE;
    nextStack->Parameters.QueryInterface.Interface = (PINTERFACE) pHwDevExt->pBusIf;
    nextStack->Parameters.QueryInterface.InterfaceSpecificData =
        NULL;
    nextStack->Parameters.QueryInterface.InterfaceType =
        &USB_BUS_INTERFACE_USBDI_GUID;
    nextStack->Parameters.QueryInterface.Size =
        sizeof(*pHwDevExt->pBusIf);
    nextStack->Parameters.QueryInterface.Version =
       USB_BUSIF_USBDI_VERSION_0;

    ntStatus = IoCallDriver(pKsDevice->NextDeviceObject,
                            Irp);

    if (ntStatus == STATUS_PENDING) {

        KeWaitForSingleObject(
            &event,
            Suspended,
            KernelMode,
            FALSE,
            NULL);

        ntStatus = Irp->IoStatus.Status;
    }

    if (NT_SUCCESS(ntStatus)) {
        // we have a bus interface
        ASSERT(pHwDevExt->pBusIf->Version == USB_BUSIF_USBDI_VERSION_0);
        ASSERT(pHwDevExt->pBusIf->Size == sizeof(*pHwDevExt->pBusIf));
    }
    else {
        pHwDevExt->pBusIf = NULL;
        _DbgPrintF( DEBUGLVL_TERSE,("[USBAudioGetUsbBusInterface] Failed to get bus interface: %x\n", ntStatus));
        DbgLog("GetBIEr", ntStatus, 0, 0, 0);
    }

    IoFreeIrp(Irp);

    return ntStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\drivers\usbaudio.2\hardware.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 2000
//
//  File:       hardware.c
//
//--------------------------------------------------------------------------

#include "common.h"

#define ONKYO_HACK

#ifdef ONKYO_HACK
#define ONKYO_VID 0x08BB
#define ONKYO_PID 0x2702
#endif

#if DBG
//#define DUMPDESC
#endif

NTSTATUS
USBAudioCancelCompleteSynch(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN PKEVENT          pKevent
    )
{
    ASSERT(pKevent);
    KeSetEvent(pKevent, 0, FALSE);
    return STATUS_MORE_PROCESSING_REQUIRED;
}

NTSTATUS
SubmitUrbToUsbdSynch(PDEVICE_OBJECT pNextDeviceObject, PURB pUrb)
{
    NTSTATUS ntStatus, status = STATUS_SUCCESS;
    PIRP pIrp;
    KEVENT Kevent;
    IO_STATUS_BLOCK ioStatus;
    PIO_STACK_LOCATION nextStack;

    // issue a synchronous request
    KeInitializeEvent(&Kevent, NotificationEvent, FALSE);

    pIrp = IoBuildDeviceIoControlRequest(
                IOCTL_INTERNAL_USB_SUBMIT_URB,
                pNextDeviceObject,
                NULL,
                0,
                NULL,
                0,
                TRUE, /* INTERNAL */
                &Kevent,
                &ioStatus);

    if ( !pIrp ) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    IoSetCompletionRoutine(
        pIrp,
        USBAudioCancelCompleteSynch,
        &Kevent,
        TRUE,
        TRUE,
        TRUE
        );

    // Call the class driver to perform the operation.  If the returned status
    // is PENDING, wait for the request to complete.

    nextStack = IoGetNextIrpStackLocation(pIrp);
    ASSERT(nextStack != NULL);

    // pass the URB to the USB driver stack
    nextStack->Parameters.Others.Argument1 = pUrb;

    ntStatus = IoCallDriver(pNextDeviceObject, pIrp );

    if (ntStatus == STATUS_PENDING) {
        // Irp is pending. we have to wait till completion..
        LARGE_INTEGER timeout;

        // Specify a timeout of 5 seconds to wait for this call to complete.
        //
        timeout.QuadPart = -10000 * 5000;

        status = KeWaitForSingleObject(&Kevent, Executive, KernelMode, FALSE, &timeout);
        if (status == STATUS_TIMEOUT) {
            //
            // We got it to the IRP before it was completed. We can cancel
            // the IRP without fear of losing it, as the completion routine
            // won't let go of the IRP until we say so.
            //
            IoCancelIrp(pIrp);

            KeWaitForSingleObject(&Kevent, Executive, KernelMode, FALSE, NULL);

            // Return STATUS_TIMEOUT
            ioStatus.Status = status;
        }

    } else {
        ioStatus.Status = ntStatus;
    }

    IoCompleteRequest(pIrp, IO_NO_INCREMENT);

    ntStatus = ioStatus.Status;

    return ntStatus;
}

NTSTATUS
SelectDeviceConfiguration(
    PKSDEVICE pKsDevice,
    PUSB_CONFIGURATION_DESCRIPTOR pConfigurationDescriptor )
{
    PHW_DEVICE_EXTENSION pHwDevExt = pKsDevice->Context;
    PUSB_INTERFACE_DESCRIPTOR pAudioStreamingInterface;
    PUSB_INTERFACE_DESCRIPTOR pMIDIStreamingInterface;
    PUSB_INTERFACE_DESCRIPTOR pControlInterface;
    PUSB_INTERFACE_DESCRIPTOR pAudioInterface;
    PAUDIO_HEADER_UNIT pHeader;
    NTSTATUS ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    ULONG i, j = 0;
    PURB pUrb;

    // Allocate an interface list.
    pHwDevExt->pInterfaceList = AllocMem( NonPagedPool, sizeof(USBD_INTERFACE_LIST_ENTRY) *
                                            (pConfigurationDescriptor->bNumInterfaces + 1) );
    if (!pHwDevExt->pInterfaceList) {
        return ntStatus;
    }

    //
    //  Validate the we have a legal ADC device by verifing if an Audio Streaming
    //  interface exists so must at least one Control interface
    //
    pAudioStreamingInterface = USBD_ParseConfigurationDescriptorEx (
                                  pConfigurationDescriptor,
                                  (PVOID) pConfigurationDescriptor,
                                  -1,        // interface number
                                  -1,        //  (Alternate Setting)
                                  USB_DEVICE_CLASS_AUDIO,        // Audio Class (Interface Class)
                                  AUDIO_SUBCLASS_STREAMING,        // Stream subclass (Interface Sub-Class)
                                  -1 ) ;    // protocol don't care    (InterfaceProtocol)

    if ( pAudioStreamingInterface ) {
        // Get the first control interface
        pControlInterface = USBD_ParseConfigurationDescriptorEx (
                               pConfigurationDescriptor,
                               (PVOID) pConfigurationDescriptor,
                               -1,        // interface number
                               -1,        //  (Alternate Setting)
                               USB_DEVICE_CLASS_AUDIO,        // Audio Class (Interface Class)
                               AUDIO_SUBCLASS_CONTROL,        // control subclass (Interface Sub-Class)
                               -1 );

        if (!pControlInterface) {
            // Give up because this is an invalid ADC device
            FreeMem(pHwDevExt->pInterfaceList);
            return STATUS_INVALID_PARAMETER;
        }
    }

    // Get the first Audio interface
    pAudioInterface = USBD_ParseConfigurationDescriptorEx (
                                pConfigurationDescriptor,
                                pConfigurationDescriptor,
                                -1,        // interface number
                                -1,        //  (Alternate Setting)
                                USB_DEVICE_CLASS_AUDIO,        // Audio Class (Interface Class)
                                -1,        // any subclass (Interface Sub-Class)
                                -1 );
    // Nothing to see here, move on
    if ( !pAudioInterface ) {
        FreeMem(pHwDevExt->pInterfaceList);
        return STATUS_INVALID_PARAMETER;
    }

    // Loop through the audio device class interfaces
    while (pAudioInterface) {

        switch (pAudioInterface->bInterfaceSubClass) {
            case AUDIO_SUBCLASS_MIDISTREAMING:
                _DbgPrintF(DEBUGLVL_VERBOSE,("[SelectDeviceConfiguration] Found MIDIStreaming at %x\n",pAudioInterface));
                pHwDevExt->pInterfaceList[j++].InterfaceDescriptor = pAudioInterface;
                break;
            case AUDIO_SUBCLASS_STREAMING:
                // This subclass is handled with the control class since they have to come together
                _DbgPrintF(DEBUGLVL_VERBOSE,("[SelectDeviceConfiguration] Found AudioStreaming at %x\n",pAudioInterface));
                break;
            case AUDIO_SUBCLASS_CONTROL:
                _DbgPrintF(DEBUGLVL_VERBOSE,("[SelectDeviceConfiguration] Found AudioControl at %x\n",pAudioInterface));
                pHwDevExt->pInterfaceList[j++].InterfaceDescriptor = pAudioInterface;

                pHeader = (PAUDIO_HEADER_UNIT)
                         GetAudioSpecificInterface( pConfigurationDescriptor,
                                                    pAudioInterface,
                                                    HEADER_UNIT );
                if ( !pHeader ) {
                    FreeMem(pHwDevExt->pInterfaceList);
                    return STATUS_INVALID_PARAMETER;
                }

                // Find each interface associated with this header
                for ( i=0; i<pHeader->bInCollection; i++ ) {
                    pAudioStreamingInterface = USBD_ParseConfigurationDescriptorEx (
                                pConfigurationDescriptor,
                                (PVOID)pConfigurationDescriptor,
                                (LONG)pHeader->baInterfaceNr[i],  // Interface number
                                -1,                               // Alternate Setting
                                USB_DEVICE_CLASS_AUDIO,           // Audio Class (Interface Class)
                                AUDIO_SUBCLASS_STREAMING,         // Audio Streaming (Interface Sub-Class)
                                -1 ) ;                            // protocol don't care    (InterfaceProtocol)

                    if ( pAudioStreamingInterface ) {
                        pHwDevExt->pInterfaceList[j++].InterfaceDescriptor = pAudioStreamingInterface;
                    } else {
                        // If there is no audio streaming interface, make sure that there is at least a MIDI interface
                        pMIDIStreamingInterface = USBD_ParseConfigurationDescriptorEx (
                                    pConfigurationDescriptor,
                                    (PVOID)pConfigurationDescriptor,
                                    (LONG)pHeader->baInterfaceNr[i],  // Interface number
                                    -1,                               // Alternate Setting
                                    USB_DEVICE_CLASS_AUDIO,           // Audio Class (Interface Class)
                                    AUDIO_SUBCLASS_MIDISTREAMING,     // Audio Streaming (Interface Sub-Class)
                                    -1 ) ;                            // protocol don't care    (InterfaceProtocol)

                        if ( !pMIDIStreamingInterface ) {
                            FreeMem(pHwDevExt->pInterfaceList);
                            return STATUS_INVALID_PARAMETER;
                        }
                    }
                }
                break;
            default:
                _DbgPrintF(DEBUGLVL_VERBOSE,("SelectDeviceConfiguration: Invalid SubClass %x\n  ",pAudioInterface->bInterfaceSubClass));
                break;
        }

        // pAudioInterface = GetNextAudioInterface(pConfigurationDescriptor, pAudioInterface);

        // Get the next audio descriptor for this InterfaceNumber
        pAudioInterface = USBD_ParseConfigurationDescriptorEx (
                               pConfigurationDescriptor,
                               ((PUCHAR)pAudioInterface + pAudioInterface->bLength),
                               -1,
                               -1,                     // Alternate Setting
                               USB_DEVICE_CLASS_AUDIO, // Audio Class (Interface Class)
                               -1,                     // Interface Sub-Class
                               -1 ) ;                  // protocol don't care (InterfaceProtocol)

        _DbgPrintF(DEBUGLVL_VERBOSE,("[SelectDeviceConfiguration] Next audio interface at %x\n",pAudioInterface));
    }

    pHwDevExt->pInterfaceList[j].InterfaceDescriptor = NULL; // Mark end of interface list

    pUrb = USBD_CreateConfigurationRequestEx( pConfigurationDescriptor,
                                              pHwDevExt->pInterfaceList ) ;
    if ( !pUrb ) {
        FreeMem(pHwDevExt->pInterfaceList);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    // Request the configuration
    ntStatus = SubmitUrbToUsbdSynch(pKsDevice->NextDeviceObject, pUrb);
    if (!NT_SUCCESS(ntStatus) || !USBD_SUCCESS(URB_STATUS(pUrb))) {
        FreeMem(pHwDevExt->pInterfaceList);
        ExFreePool(pUrb);
        return ntStatus;
    }

    // Save the configuration Handle to Select Interfaces later
    pHwDevExt->ConfigurationHandle = pUrb->UrbSelectConfiguration.ConfigurationHandle;

    // Bag the interface list for easy cleanup
    KsAddItemToObjectBag(pKsDevice->Bag, pHwDevExt->pInterfaceList, FreeMem);

    _DbgPrintF(DEBUGLVL_VERBOSE,("[SelectDeviceConfiguration] NumInterfaces=%d InterfacesFound=%d\n",pConfigurationDescriptor->bNumInterfaces, j));
    ASSERT(j == pConfigurationDescriptor->bNumInterfaces);

    // Save the interfaces for this configuration as they will be deallocated with the URB
    for (i=0; i<j; i++) {
        PUSBD_INTERFACE_INFORMATION pInterfaceInfo;
        pInterfaceInfo = pHwDevExt->pInterfaceList[i].Interface;
        pHwDevExt->pInterfaceList[i].Interface = AllocMem(NonPagedPool, pInterfaceInfo->Length);

        if (!pHwDevExt->pInterfaceList[i].Interface) {
            ExFreePool(pUrb);
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        KsAddItemToObjectBag(pKsDevice->Bag, pHwDevExt->pInterfaceList[i].Interface, FreeMem);

        RtlCopyMemory(pHwDevExt->pInterfaceList[i].Interface, pInterfaceInfo, pInterfaceInfo->Length);
    }

    ExFreePool(pUrb);

    return STATUS_SUCCESS;
}

NTSTATUS
StartUSBAudioDevice( PKSDEVICE pKsDevice )
{
    PHW_DEVICE_EXTENSION pHwDevExt = pKsDevice->Context;
    PUSB_DEVICE_DESCRIPTOR pDeviceDescriptor;
    PUSB_CONFIGURATION_DESCRIPTOR pConfigurationDescriptor;
    ULONG ulTotalDescriptorsSize;
    NTSTATUS ntStatus;
    PURB pUrb;

    // Allocate an urb to use
    pUrb = AllocMem(NonPagedPool, sizeof(struct _URB_CONTROL_DESCRIPTOR_REQUEST));
    if (!pUrb) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    // Allocate a device descriptor
    pDeviceDescriptor = AllocMem(NonPagedPool, sizeof(USB_DEVICE_DESCRIPTOR));
    if (!pDeviceDescriptor) {
        FreeMem(pUrb);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    // Get the device descriptor for this device
    UsbBuildGetDescriptorRequest( pUrb,
                                  (USHORT) sizeof (struct _URB_CONTROL_DESCRIPTOR_REQUEST),
                                  USB_DEVICE_DESCRIPTOR_TYPE,
                                  0,
                                  0,
                                  pDeviceDescriptor,
                                  NULL,
                                  sizeof(USB_DEVICE_DESCRIPTOR),
                                  NULL );

    ntStatus = SubmitUrbToUsbdSynch(pKsDevice->NextDeviceObject, pUrb);
    if (!NT_SUCCESS(ntStatus)) {
        FreeMem(pDeviceDescriptor);
        FreeMem(pUrb);
        return ntStatus;
    }

    KsAddItemToObjectBag(pKsDevice->Bag, pDeviceDescriptor, FreeMem);

    // Get the Configuration Descriptor and all others
    pConfigurationDescriptor = AllocMem(NonPagedPool, sizeof(USB_CONFIGURATION_DESCRIPTOR));
    if (!pConfigurationDescriptor) {
        FreeMem(pUrb);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    // Call down the first time just to get the total number of bytes for the descriptors.
    UsbBuildGetDescriptorRequest( pUrb,
                                  (USHORT) sizeof (struct _URB_CONTROL_DESCRIPTOR_REQUEST),
                                  USB_CONFIGURATION_DESCRIPTOR_TYPE,
                                  0,
                                  0,
                                  pConfigurationDescriptor,
                                  NULL,
                                  sizeof(USB_CONFIGURATION_DESCRIPTOR),
                                  NULL);

    ntStatus = SubmitUrbToUsbdSynch(pKsDevice->NextDeviceObject, pUrb);
    if (!NT_SUCCESS(ntStatus)) {
        FreeMem(pUrb);
        FreeMem(pConfigurationDescriptor);
        return ntStatus;
    }

    // Reallocate and call again to fill in all descriptors.
    ulTotalDescriptorsSize = pConfigurationDescriptor->wTotalLength;
    FreeMem(pConfigurationDescriptor);
    pConfigurationDescriptor = AllocMem(NonPagedPool, ulTotalDescriptorsSize);
    if (!pConfigurationDescriptor) {
        FreeMem(pUrb);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    UsbBuildGetDescriptorRequest( pUrb,
                                  (USHORT) sizeof (struct _URB_CONTROL_DESCRIPTOR_REQUEST),
                                  USB_CONFIGURATION_DESCRIPTOR_TYPE,
                                  0,
                                  0,
                                  pConfigurationDescriptor,
                                  NULL,
                                  ulTotalDescriptorsSize,
                                  NULL);

    ntStatus = SubmitUrbToUsbdSynch(pKsDevice->NextDeviceObject, pUrb);
    if (!NT_SUCCESS(ntStatus)) {
        FreeMem(pConfigurationDescriptor);
        return ntStatus;
    }

    KsAddItemToObjectBag(pKsDevice->Bag, pConfigurationDescriptor, FreeMem);

    // Free up the URB
    FreeMem(pUrb);

    ntStatus = SelectDeviceConfiguration( pKsDevice, pConfigurationDescriptor );
    if (NT_SUCCESS(ntStatus)) {
        // Save the Configuration and Device Descriptor pointers.
        pHwDevExt->pDeviceDescriptor = pDeviceDescriptor;
        pHwDevExt->pConfigurationDescriptor = pConfigurationDescriptor;

#ifdef DUMPDESC
        {
            ULONG LastLevel = USBAudioDebugLevel;

            USBAudioDebugLevel = DEBUGLVL_BLAB;
            DumpAllDesc(pConfigurationDescriptor);
            USBAudioDebugLevel = LastLevel;
        }
#endif
    }

#ifdef ONKYO_HACK
    _DbgPrintF( DEBUGLVL_TERSE, ("Vendor ID: %x, Product ID: %x\n", 
                                 pDeviceDescriptor->idVendor,
                                 pDeviceDescriptor->idProduct) );

    if (( pDeviceDescriptor->idVendor  == ONKYO_VID ) &&
        ( pDeviceDescriptor->idProduct == ONKYO_PID )) {

        *((PUCHAR)pConfigurationDescriptor + 0x36) ^= 2;
    }
#endif

    return ntStatus;

}

NTSTATUS
StopUSBAudioDevice( PKSDEVICE pKsDevice )
{
    PHW_DEVICE_EXTENSION pHwDevExt = pKsDevice->Context;
    PKSFILTERFACTORY pKsFilterFactory;
    PKSFILTER pKsFilter;
    PKSPIN pKsPin;
    ULONG i;
    PPIN_CONTEXT pPinContext;
    NTSTATUS ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    PURB pUrb;

    //
    // 1. Take care of outstanding MIDI Out Urbs
    //
    KsAcquireDevice( pKsDevice );

    pKsFilterFactory = KsDeviceGetFirstChildFilterFactory( pKsDevice );

    while (pKsFilterFactory) {
        // Find each open filter for this filter factory
        pKsFilter = KsFilterFactoryGetFirstChildFilter( pKsFilterFactory );

        while (pKsFilter) {

            KsFilterAcquireControl( pKsFilter );

            for ( i = 0; i < pKsFilter->Descriptor->PinDescriptorsCount; i++) {

                // Find each open pin for this open filter
                pKsPin = KsFilterGetFirstChildPin( pKsFilter, i );

                _DbgPrintF(DEBUGLVL_VERBOSE,("[StopUSBAudioDevice] Trying filter (%x), pinid (%d), pin (%x)\n",pKsFilter,i,pKsPin));

                while (pKsPin) {

                   pPinContext = pKsPin->Context;
                   if (pPinContext->PinType == MidiOut) {
                       // Found a MidiOut pin to cleanup
                       _DbgPrintF(DEBUGLVL_VERBOSE,("[StopUSBAudioDevice] Cleaning up MIDI Out pin (%x)\n",pKsPin));
                       AbortUSBPipe( pPinContext );
                   }

                   // Get the next pin
                   pKsPin = KsPinGetNextSiblingPin( pKsPin );
                }
            }

            KsFilterReleaseControl( pKsFilter );

            // Get the next Filter
            pKsFilter = KsFilterGetNextSiblingFilter( pKsFilter );
        }
        // Get the next Filter Factory
        pKsFilterFactory = KsFilterFactoryGetNextSiblingFilterFactory( pKsFilterFactory );
    }

    KsReleaseDevice( pKsDevice );

    //
    // 2. Cleanup outstanding MIDI In Urbs
    //
    //  Free any currently allocated PipeInfo
    if (pHwDevExt->pMIDIPipeInfo) {
        USBMIDIInFreePipeInfo( pHwDevExt->pMIDIPipeInfo );
        pHwDevExt->pMIDIPipeInfo = NULL;
    }

    if (pHwDevExt->Pipes) {
        FreeMem(pHwDevExt->Pipes);
        pHwDevExt->Pipes = NULL;
    }

    // 3. Send a select configuration urb with a NULL pointer for the configuration
    // handle, this closes the configuration and puts the device in the 'unconfigured'
    // state.

    pUrb = AllocMem(NonPagedPool, sizeof(struct _URB_SELECT_CONFIGURATION));
    if ( pUrb ) {

        UsbBuildSelectConfigurationRequest( pUrb,
                                            (USHORT)sizeof(struct _URB_SELECT_CONFIGURATION),
                                            NULL);

        ntStatus = SubmitUrbToUsbdSynch( pKsDevice->NextDeviceObject, pUrb );

        FreeMem(pUrb);
    }

    return STATUS_SUCCESS;

}

NTSTATUS
SelectStreamingAudioInterface(
    PUSB_INTERFACE_DESCRIPTOR pInterfaceDescriptor,
    PHW_DEVICE_EXTENSION pHwDevExt,
    PKSPIN pKsPin )
{
    PUSBD_INTERFACE_INFORMATION pInterfaceInfo;
    NTSTATUS ntStatus = STATUS_INVALID_DEVICE_REQUEST;
    USHORT ulInterfaceLength;
    ULONG ulNumEndpoints, j;
    BOOLEAN fIsZeroBW = FALSE;
    ULONG size;
    PURB pUrb;

    // Possible Surprise Removal occurred
    if (pHwDevExt->fDeviceStopped) {
        return STATUS_DEVICE_DOES_NOT_EXIST;
    }

    fIsZeroBW = IsZeroBWInterface( pHwDevExt->pConfigurationDescriptor,
                                   pInterfaceDescriptor );

    ulNumEndpoints = (ULONG)pInterfaceDescriptor->bNumEndpoints;

    // Allocate an interface request
    ulInterfaceLength = (USHORT)GET_USBD_INTERFACE_SIZE(ulNumEndpoints);

    size = GET_SELECT_INTERFACE_REQUEST_SIZE(ulNumEndpoints);

    pUrb = AllocMem(NonPagedPool, size);
    if (!pUrb) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    RtlZeroMemory(pUrb, size);

    // Find the correct interface in our list
    for (j=0; j < pHwDevExt->pConfigurationDescriptor->bNumInterfaces; j++) {
        if ( pHwDevExt->pInterfaceList[j].InterfaceDescriptor->bInterfaceNumber ==
             pInterfaceDescriptor->bInterfaceNumber )
            break;
    }

    // Didn't find a match
    if (j == pHwDevExt->pConfigurationDescriptor->bNumInterfaces) {
        FreeMem( pUrb );
        return STATUS_INVALID_DEVICE_REQUEST;
    }

    // Initialize the interface information
    pInterfaceInfo = &pUrb->UrbSelectInterface.Interface;
    pInterfaceInfo->InterfaceNumber  = pInterfaceDescriptor->bInterfaceNumber;
    pInterfaceInfo->Length           = ulInterfaceLength;
    pInterfaceInfo->AlternateSetting = pInterfaceDescriptor->bAlternateSetting;

    if ( !fIsZeroBW ) { // There must be a Pin if this is not 0 BW
        PPIN_CONTEXT pPinContext = pKsPin->Context;
        ULONG ulFormat = pPinContext->pUsbAudioDataRange->ulUsbDataFormat & USBAUDIO_DATA_FORMAT_TYPE_MASK;
        if (ulFormat == USBAUDIO_DATA_FORMAT_TYPE_I_UNDEFINED )
            // We assume that usually nobody sends us more than 250 ms. of PCM Data per header.
            //    USBD should Adjust if it is more supossedly.
            pInterfaceInfo->Pipes[0].MaximumTransferSize = pPinContext->ulMaxPacketSize * 250;

            if (pPinContext->pUsbAudioDataRange->pSyncEndpointDescriptor == NULL) {
                pInterfaceInfo->Pipes[0].PipeFlags |= USBD_PF_MAP_ADD_TRANSFERS;
            }
        else if (ulFormat == USBAUDIO_DATA_FORMAT_TYPE_II_UNDEFINED )
            pInterfaceInfo->Pipes[0].MaximumTransferSize = (1920*2)+32; // Max AC-3 Syncframe size
    }
    else if ( ulNumEndpoints )  // Zero BW but has an endpoint
        pInterfaceInfo->Pipes[0].MaximumTransferSize = 0;

    // set up the input parameters in our interface request structure.
    pUrb->UrbHeader.Length = (USHORT) size;
    pUrb->UrbHeader.Function = URB_FUNCTION_SELECT_INTERFACE;
    pUrb->UrbSelectInterface.ConfigurationHandle = pHwDevExt->ConfigurationHandle;

    ntStatus = SubmitUrbToUsbdSynch(pHwDevExt->pNextDeviceObject, pUrb);
    if (!NT_SUCCESS(ntStatus) || !USBD_SUCCESS(pUrb->UrbSelectInterface.Hdr.Status)) {
        _DbgPrintF(DEBUGLVL_VERBOSE,("SelectStreamingAudioInterface: Select interface failed %x\n",ntStatus));
        FreeMem(pUrb);
        return ntStatus;
    }

    if ( !fIsZeroBW ) {
        PPIN_CONTEXT pPinContext = pKsPin->Context;

        // NOTE: We assume first pipe is data pipe!!!
        pPinContext->ulNumberOfPipes = pInterfaceInfo->NumberOfPipes;
        pPinContext->hPipeHandle = pInterfaceInfo->Pipes[0].PipeHandle;

#ifdef DRM_USBAUDIO
        //  Check to see if secure data is being streamed
        if (pPinContext->DrmContentId) {
            // Forward content to common class driver PDO
            ntStatus = DrmForwardContentToDeviceObject(pPinContext->DrmContentId,
                                                       pPinContext->pNextDeviceObject,
                                                       pPinContext->hPipeHandle);
            if (!NT_SUCCESS(ntStatus)) {
                FreeMem(pUrb);
                return ntStatus;
            }
        }
#endif
        //  Free any existing pipe information
        if (pPinContext->Pipes) {
            FreeMem(pPinContext->Pipes);
        }

        pPinContext->Pipes = (PUSBD_PIPE_INFORMATION)
               AllocMem( NonPagedPool, pPinContext->ulNumberOfPipes*sizeof(USBD_PIPE_INFORMATION));
        if (!pPinContext->Pipes) {
            FreeMem(pUrb);
            return STATUS_INSUFFICIENT_RESOURCES;
        }
        RtlCopyMemory( pPinContext->Pipes,
                       pInterfaceInfo->Pipes,
                       pPinContext->ulNumberOfPipes*sizeof(USBD_PIPE_INFORMATION) );

        _DbgPrintF(DEBUGLVL_VERBOSE,("[SelectStreamingAudioInterface] PipeHandle=%x\n", pPinContext->hPipeHandle));
    }
    else {
        _DbgPrintF(DEBUGLVL_VERBOSE,("[SelectStreamingAudioInterface] ZeroBandwidth\n"));
    }

    FreeMem(pUrb);

    return ntStatus;
}

NTSTATUS
SelectStreamingMIDIInterface(
    PHW_DEVICE_EXTENSION pHwDevExt,
    PKSPIN pKsPin )
{
    PUSBD_INTERFACE_INFORMATION pInterfaceInfo;
    PKSFILTER pKsFilter = NULL;
    PFILTER_CONTEXT pFilterContext = NULL;
    PPIN_CONTEXT pPinContext = NULL;
    NTSTATUS ntStatus = STATUS_INVALID_DEVICE_REQUEST;
    USHORT ulInterfaceLength;
    ULONG ulNumEndpoints, j;
    ULONG ulInterfaceNumber;
    ULONG ulEndpointNumber;
    BOOLEAN fIsZeroBW = FALSE;
    ULONG size;
    PURB pUrb;

    if (pKsPin) {
        pPinContext = pKsPin->Context;

        if (pKsFilter = KsPinGetParentFilter( pKsPin )) {
            if (pFilterContext = pKsFilter->Context) {
                pHwDevExt = pFilterContext->pHwDevExt;
            }
        }
    }

    if (!pFilterContext || !pPinContext || !pHwDevExt) {
        _DbgPrintF(DEBUGLVL_TERSE,("[SelectStreamingMIDIInterface] failed to get context\n"));
        return STATUS_INVALID_PARAMETER;
    }

    // Possible Surprise Removal occurred
    if (pHwDevExt->fDeviceStopped) {
        return STATUS_DEVICE_DOES_NOT_EXIST;
    }

    ulInterfaceNumber = pPinContext->pMIDIPinContext->ulInterfaceNumber;
    ulEndpointNumber = pPinContext->pMIDIPinContext->ulEndpointNumber;
    ulNumEndpoints = (ULONG)pHwDevExt->pInterfaceList[ulInterfaceNumber].InterfaceDescriptor->bNumEndpoints;

    _DbgPrintF(DEBUGLVL_VERBOSE,("[SelectStreamingMIDIInterface] Interface=%d Endpoint=%d NumEndpoints=%d CurrentSelectedInterface=%d\n",
                                 ulInterfaceNumber,
                                 ulEndpointNumber,
                                 ulNumEndpoints,
                                 pHwDevExt->ulInterfaceNumberSelected));

    ASSERT(ulNumEndpoints > ulEndpointNumber);

    // Check to see if interface is already opened
    if (pHwDevExt->ulInterfaceNumberSelected == ulInterfaceNumber) {
        _DbgPrintF(DEBUGLVL_VERBOSE,("[SelectStreamingMIDIInterface] Interface already selected %d\n",ulInterfaceNumber));

        pPinContext->ulNumberOfPipes = pHwDevExt->ulNumberOfMIDIPipes;
        pPinContext->hPipeHandle = pHwDevExt->Pipes[ulEndpointNumber].PipeHandle;

        pPinContext->Pipes = (PUSBD_PIPE_INFORMATION)
               AllocMem( NonPagedPool, pPinContext->ulNumberOfPipes*sizeof(USBD_PIPE_INFORMATION));
        if (!pPinContext->Pipes) {
            return STATUS_INSUFFICIENT_RESOURCES;
        }
        RtlCopyMemory( pPinContext->Pipes,
                       pHwDevExt->Pipes,
                       pPinContext->ulNumberOfPipes*sizeof(USBD_PIPE_INFORMATION) );

        // Add Pipes to Pin Bag
        KsAddItemToObjectBag(pKsPin->Bag, pPinContext->Pipes, FreeMem);

        ntStatus = STATUS_SUCCESS;
    }
    else {
        //  Free any currently allocated PipeInfo
        if (pHwDevExt->pMIDIPipeInfo) {
            USBMIDIInFreePipeInfo( pHwDevExt->pMIDIPipeInfo );
        }

        if (pHwDevExt->Pipes) {
            FreeMem(pHwDevExt->Pipes);
        }

        // Allocate an interface request
        ulInterfaceLength = (USHORT)GET_USBD_INTERFACE_SIZE(ulNumEndpoints);

        size = GET_SELECT_INTERFACE_REQUEST_SIZE(ulNumEndpoints);

        pUrb = AllocMem(NonPagedPool, size);
        if (!pUrb) {
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        // Copy the interface information
        pInterfaceInfo = &pUrb->UrbSelectInterface.Interface;
        RtlCopyMemory( pInterfaceInfo,
                       pHwDevExt->pInterfaceList[ulInterfaceNumber].Interface,
                       ulInterfaceLength );
        pInterfaceInfo->Length = ulInterfaceLength;
        pInterfaceInfo->AlternateSetting =
            pHwDevExt->pInterfaceList[ulInterfaceNumber].InterfaceDescriptor->bAlternateSetting;

        for ( j=0; j < ulNumEndpoints; j++) {
            pInterfaceInfo->Pipes[j].MaximumTransferSize = pPinContext->ulMaxPacketSize;
        }

        // set up the input parameters in our interface request structure.
        pUrb->UrbHeader.Length = (USHORT) size;
        pUrb->UrbHeader.Function = URB_FUNCTION_SELECT_INTERFACE;
        pUrb->UrbSelectInterface.ConfigurationHandle = pHwDevExt->ConfigurationHandle;

        ntStatus = SubmitUrbToUsbdSynch(pHwDevExt->pNextDeviceObject, pUrb);
        if (!NT_SUCCESS(ntStatus) || !USBD_SUCCESS(pUrb->UrbSelectInterface.Hdr.Status)) {
            FreeMem(pUrb);
            return ntStatus;
        }

        pPinContext->ulNumberOfPipes = pInterfaceInfo->NumberOfPipes;
        pPinContext->hPipeHandle = pInterfaceInfo->Pipes[ulEndpointNumber].PipeHandle;

        _DbgPrintF(DEBUGLVL_VERBOSE,("[SelectStreamingMIDIInterface] NumberOfPipes=%d PipeHandle=%x\n",
                                     pPinContext->ulNumberOfPipes,
                                     pPinContext->hPipeHandle));

        pPinContext->Pipes = (PUSBD_PIPE_INFORMATION)
               AllocMem( NonPagedPool, pPinContext->ulNumberOfPipes*sizeof(USBD_PIPE_INFORMATION));
        if (!pPinContext->Pipes) {
            FreeMem(pUrb);
            return STATUS_INSUFFICIENT_RESOURCES;
        }
        RtlCopyMemory( pPinContext->Pipes,
                       pInterfaceInfo->Pipes,
                       pPinContext->ulNumberOfPipes*sizeof(USBD_PIPE_INFORMATION) );

        // Add Pipes to Pin Bag
        KsAddItemToObjectBag(pKsPin->Bag, pPinContext->Pipes, FreeMem);

        // Now update the Hardware context
        _DbgPrintF(DEBUGLVL_VERBOSE,("[SelectStreamingMIDIInterface] Interface selected %d\n",ulInterfaceNumber));
        pHwDevExt->ulInterfaceNumberSelected = ulInterfaceNumber;
        pHwDevExt->ulNumberOfMIDIPipes = pInterfaceInfo->NumberOfPipes;
        pHwDevExt->hPipeHandle = pInterfaceInfo->Pipes[ulEndpointNumber].PipeHandle;

        pHwDevExt->Pipes = (PUSBD_PIPE_INFORMATION)
               AllocMem( NonPagedPool, pHwDevExt->ulNumberOfMIDIPipes*sizeof(USBD_PIPE_INFORMATION));
        if (!pHwDevExt->Pipes) {
            FreeMem(pUrb);
            return STATUS_INSUFFICIENT_RESOURCES;
        }
        RtlCopyMemory( pHwDevExt->Pipes,
                       pInterfaceInfo->Pipes,
                       pHwDevExt->ulNumberOfMIDIPipes*sizeof(USBD_PIPE_INFORMATION) );

        FreeMem(pUrb);
    }

    // Make sure a valid pipe handle is set
    ASSERT(pPinContext->hPipeHandle);

    return ntStatus;
}

NTSTATUS
SelectZeroBandwidthInterface(
    PHW_DEVICE_EXTENSION pHwDevExt,
    ULONG ulPinNumber )
{
    PUSB_CONFIGURATION_DESCRIPTOR pConfigurationDescriptor = pHwDevExt->pConfigurationDescriptor;
    PUSB_INTERFACE_DESCRIPTOR pInterfaceDescriptor;
    BOOLEAN fFound = FALSE;
    NTSTATUS ntStatus;

    // Possible Surprise Removal occurred
    if (pHwDevExt->fDeviceStopped) {
        return STATUS_DEVICE_DOES_NOT_EXIST;
    }

    // First Find the 0 BW interface
    pInterfaceDescriptor =
        GetFirstAudioStreamingInterface( pConfigurationDescriptor, ulPinNumber );

    while ( pInterfaceDescriptor && !(fFound = IsZeroBWInterface(pConfigurationDescriptor, pInterfaceDescriptor)) ) {
        pInterfaceDescriptor = GetNextAudioInterface(pConfigurationDescriptor, pInterfaceDescriptor);
    }

    if ( !fFound ) {
        TRAP; // This is a device design error. all interfaces must include 0 BW setting
        ntStatus = STATUS_INVALID_DEVICE_REQUEST;
    }
    else
        ntStatus =
            SelectStreamingAudioInterface( pInterfaceDescriptor, pHwDevExt, NULL );

    return ntStatus;
}

NTSTATUS
ResetUSBPipe( PDEVICE_OBJECT pNextDeviceObject,
              USBD_PIPE_HANDLE hPipeHandle )
{
    NTSTATUS ntStatus;
    PURB pUrb;

    ASSERT(hPipeHandle);

    pUrb = AllocMem(NonPagedPool, sizeof(struct _URB_PIPE_REQUEST));
    if (!pUrb)
        return STATUS_INSUFFICIENT_RESOURCES;

    // Do the initial Abort
    pUrb->UrbHeader.Length = (USHORT) sizeof (struct _URB_PIPE_REQUEST);
    pUrb->UrbHeader.Function = URB_FUNCTION_SYNC_RESET_PIPE_AND_CLEAR_STALL;
    pUrb->UrbPipeRequest.PipeHandle = hPipeHandle;
    ntStatus = SubmitUrbToUsbdSynch( pNextDeviceObject, pUrb );

    FreeMem( pUrb );
    return ntStatus;

}

NTSTATUS
AbortUSBPipe( PPIN_CONTEXT pPinContext )
{
    NTSTATUS ntStatus;
    PURB pUrb;
    KIRQL irql;

    //DbgPrint("Performing Abort of USB Audio Pipe!!!\n");
    ASSERT(pPinContext->hPipeHandle);
    DbgLog("AbrtP", pPinContext, pPinContext->hPipeHandle, 0, 0 );

    pUrb = AllocMem(NonPagedPool, sizeof(struct _URB_PIPE_REQUEST));
    if (!pUrb)
        return STATUS_INSUFFICIENT_RESOURCES;

    // Do the initial Abort
    pUrb->UrbHeader.Length = (USHORT) sizeof (struct _URB_PIPE_REQUEST);
    pUrb->UrbHeader.Function = URB_FUNCTION_ABORT_PIPE;
    pUrb->UrbPipeRequest.PipeHandle = pPinContext->hPipeHandle;
    ntStatus = SubmitUrbToUsbdSynch(pPinContext->pNextDeviceObject, pUrb);

    if ( !NT_SUCCESS(ntStatus) ) {
        _DbgPrintF(DEBUGLVL_VERBOSE,("Abort Failed %x\n",ntStatus));
    }

    // Wait for all urbs on the pipe to clear
    KeAcquireSpinLock( &pPinContext->PinSpinLock, &irql );
    if ( pPinContext->ulOutstandingUrbCount ) {
        KeResetEvent( &pPinContext->PinStarvationEvent );
        KeReleaseSpinLock( &pPinContext->PinSpinLock, irql );
        KeWaitForSingleObject( &pPinContext->PinStarvationEvent,
                               Executive,
                               KernelMode,
                               FALSE,
                               NULL );
    }
    else
        KeReleaseSpinLock( &pPinContext->PinSpinLock, irql );

    // Now reset the pipe and continue
    RtlZeroMemory( pUrb, sizeof (struct _URB_PIPE_REQUEST) );
    pUrb->UrbHeader.Function = URB_FUNCTION_SYNC_RESET_PIPE_AND_CLEAR_STALL;
    pUrb->UrbHeader.Length = (USHORT) sizeof (struct _URB_PIPE_REQUEST);
    pUrb->UrbPipeRequest.PipeHandle = pPinContext->hPipeHandle;

    ntStatus = SubmitUrbToUsbdSynch(pPinContext->pNextDeviceObject, pUrb);

    pPinContext->fUrbError = FALSE;

    FreeMem(pUrb);

    return ntStatus;
}

NTSTATUS
GetCurrentUSBFrame(
    IN PPIN_CONTEXT pPinContext,
    OUT PULONG pUSBFrame
    )
/*++
GetCurrentUSBFrame

Arguments:
    pPinContext - pointer to the pin context for this instance

    pUSBFrame - pointer to storage for the current USB frame number

Return Value:
    NTSTATUS
--*/
{
    NTSTATUS ntStatus;
    ULONG ulCurrentUSBFrame;

    // Use function-based interfaces if available
    if (pPinContext->pHwDevExt->pBusIf) {

        // Call function-based ISO interface on USB to enable RT support
        ntStatus = pPinContext->pHwDevExt->pBusIf->QueryBusTime( pPinContext->pHwDevExt->pBusIf->BusContext,
                                                                 &ulCurrentUSBFrame);
    }
    else {

        ntStatus = STATUS_NOT_SUPPORTED;

    }


    if (NT_SUCCESS(ntStatus) && pUSBFrame!=NULL) {
        *pUSBFrame=ulCurrentUSBFrame;
        }

    return ntStatus;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\drivers\usbaudio.2\intrsect.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 2000
//
//  File:       intrsect.c
//
//--------------------------------------------------------------------------

#include "common.h"

ULONG
GetIntersectFormatSize( PUSBAUDIO_DATARANGE pAudioDataRange )
{
    GUID* pSubFormat = &pAudioDataRange->KsDataRangeAudio.DataRange.SubFormat;
    PAUDIO_CLASS_STREAM pAudioDescriptor = pAudioDataRange->pAudioDescriptor;
    ULONG rval = 0;

    if (IS_VALID_WAVEFORMATEX_GUID(pSubFormat)) {
        if (( pAudioDescriptor->bBitsPerSample <=16 ) &&
            ( pAudioDescriptor->bNumberOfChannels <=2 )){
            rval = sizeof(KSDATAFORMAT_WAVEFORMATEX);
        }
        else {
            rval = sizeof( KSDATAFORMAT ) + sizeof( WAVEFORMATPCMEX );
        }
    }
    else
        rval = sizeof( KSDATAFORMAT ) + sizeof( WAVEFORMATPCMEX );

    return rval;
}

ULONG
ConvertDatarangeToFormat(
    PUSBAUDIO_DATARANGE pAudioDataRange,
    PKSDATAFORMAT pFormat )
{
    GUID* pSubFormat = &pAudioDataRange->KsDataRangeAudio.DataRange.SubFormat;
    PAUDIO_CLASS_STREAM pAudioDescriptor = pAudioDataRange->pAudioDescriptor;

    // Copy datarange directly from interface info.
    *pFormat = pAudioDataRange->KsDataRangeAudio.DataRange;

    if ( IS_VALID_WAVEFORMATEX_GUID(pSubFormat) ) {
        if (( pAudioDescriptor->bBitsPerSample    <=16 ) &&
            ( pAudioDescriptor->bNumberOfChannels <=2 )){
            PWAVEFORMATEX pWavFormatEx = (PWAVEFORMATEX)(pFormat+1) ;

            pWavFormatEx->wFormatTag      = EXTRACT_WAVEFORMATEX_ID(pSubFormat);
            pWavFormatEx->nChannels       = (WORD)pAudioDescriptor->bNumberOfChannels;
            pWavFormatEx->nSamplesPerSec  = pAudioDataRange->ulMaxSampleRate;
            pWavFormatEx->wBitsPerSample  = (WORD)pAudioDescriptor->bBitsPerSample;
            pWavFormatEx->nBlockAlign     = (pWavFormatEx->nChannels * pWavFormatEx->wBitsPerSample)/8;
            pWavFormatEx->nAvgBytesPerSec = pWavFormatEx->nSamplesPerSec * pWavFormatEx->nBlockAlign;
            pWavFormatEx->cbSize          = 0;

            pFormat->FormatSize = sizeof( KSDATAFORMAT_WAVEFORMATEX );
        }
        else {
            PWAVEFORMATPCMEX pWavFormatPCMEx = (PWAVEFORMATPCMEX)(pFormat+1) ;
            pWavFormatPCMEx->Format.wFormatTag      = WAVE_FORMAT_EXTENSIBLE;
            pWavFormatPCMEx->Format.nChannels       = (WORD)pAudioDescriptor->bNumberOfChannels;
            pWavFormatPCMEx->Format.nSamplesPerSec  = pAudioDataRange->ulMaxSampleRate;
            pWavFormatPCMEx->Format.wBitsPerSample  = (WORD)pAudioDescriptor->bSlotSize<<3;
            pWavFormatPCMEx->Format.nBlockAlign     = (pWavFormatPCMEx->Format.nChannels *
                                                       pWavFormatPCMEx->Format.wBitsPerSample)>>3;
            pWavFormatPCMEx->Format.nAvgBytesPerSec = pWavFormatPCMEx->Format.nSamplesPerSec *
                                                      pWavFormatPCMEx->Format.nBlockAlign;
            pWavFormatPCMEx->Format.cbSize          = sizeof(WAVEFORMATPCMEX) - sizeof(WAVEFORMATEX);
            pWavFormatPCMEx->Samples.wValidBitsPerSample = (WORD)pAudioDescriptor->bBitsPerSample;
            pWavFormatPCMEx->dwChannelMask          = pAudioDataRange->ulChannelConfig;
            pWavFormatPCMEx->SubFormat              = KSDATAFORMAT_SUBTYPE_PCM;

            pFormat->FormatSize = sizeof( KSDATAFORMAT ) + sizeof( WAVEFORMATPCMEX );
        }
    }
    else {
        // NOTE: Hardcoded for AC-3
        // TODO: Need to support generic Type II
        PAUDIO_CLASS_TYPE2_STREAM pT2AudioDescriptor = (PAUDIO_CLASS_TYPE2_STREAM)pAudioDataRange->pAudioDescriptor;
        PWAVEFORMATEX pWavFormatEx = (PWAVEFORMATEX)(pFormat+1) ;

        pWavFormatEx->wFormatTag      = WAVE_FORMAT_UNKNOWN;  // Used for AC-3

        pWavFormatEx->nChannels       = (WORD)6;
        pWavFormatEx->nSamplesPerSec  = pAudioDataRange->ulMaxSampleRate;
        pWavFormatEx->wBitsPerSample  = (WORD)0;
        pWavFormatEx->nBlockAlign     = (pWavFormatEx->nChannels * pWavFormatEx->wBitsPerSample)/8;
        pWavFormatEx->nAvgBytesPerSec = pWavFormatEx->nSamplesPerSec * pWavFormatEx->nBlockAlign;
        pWavFormatEx->cbSize          = 0;

        pFormat->FormatSize = sizeof( KSDATAFORMAT_WAVEFORMATEX );
    }

    return pFormat->FormatSize;
}

BOOLEAN
CheckFormatMatch(
    PKSDATARANGE_AUDIO pInDataRange,
    PKSDATARANGE_AUDIO pInterfaceRange )
{
    PKSDATARANGE pInRange = (PKSDATARANGE)pInDataRange;
    PKSDATARANGE pStreamRange = (PKSDATARANGE)pInterfaceRange;
    BOOLEAN fRval = FALSE;

    // Check Format and subformat types
    if (IsEqualGUID(&pInRange->MajorFormat, &pStreamRange->MajorFormat) ||
        IsEqualGUID(&pInRange->MajorFormat, &KSDATAFORMAT_TYPE_WILDCARD)) {
        if (IsEqualGUID(&pInRange->SubFormat, &pStreamRange->SubFormat) ||
            IsEqualGUID(&pInRange->SubFormat, &KSDATAFORMAT_TYPE_WILDCARD)) {
            if (IsEqualGUID(&pInRange->Specifier, &pStreamRange->Specifier) ||
                IsEqualGUID(&pInRange->Specifier, &KSDATAFORMAT_TYPE_WILDCARD)) {
                fRval = TRUE;
            }
        }
    }

    // Now that we know we have an audio format check the dataranges
    if ( fRval ) {
        fRval = FALSE;

        if (pInDataRange->DataRange.FormatSize >= sizeof(KSDATARANGE_AUDIO)) {
            if ( pInDataRange->MaximumChannels >= pInterfaceRange->MaximumChannels ) {
                if ( pInDataRange->MaximumSampleFrequency >= pInterfaceRange->MaximumSampleFrequency ) {
                    if (pInDataRange->MinimumSampleFrequency <= pInterfaceRange->MaximumSampleFrequency ) {
                        if ( pInDataRange->MaximumBitsPerSample >= pInterfaceRange->MaximumBitsPerSample) {
                            if ( pInDataRange->MinimumBitsPerSample <= pInterfaceRange->MaximumBitsPerSample) {
                                fRval = TRUE;
                            }
                        }
                        else if ( pInDataRange->MinimumBitsPerSample >= pInterfaceRange->MinimumBitsPerSample ) {
                            fRval = TRUE;
                        }
                    }
                }
                else if ( pInDataRange->MinimumSampleFrequency >= pInterfaceRange->MinimumSampleFrequency ) {
                    if ( pInDataRange->MaximumBitsPerSample >= pInterfaceRange->MaximumBitsPerSample) {
                        if ( pInDataRange->MinimumBitsPerSample <= pInterfaceRange->MaximumBitsPerSample) {
                            fRval = TRUE;
                        }
                    }
                    else if ( pInDataRange->MinimumBitsPerSample >= pInterfaceRange->MinimumBitsPerSample ) {
                        fRval = TRUE;
                    }
                }
            }
        }
        else {
            // If no audio specific range info, consider this a match
            fRval = TRUE;
        }
    }

    return fRval;
}

VOID
GetMaxSampleRate(
    PUSBAUDIO_DATARANGE pUSBAudioRange,
    ULONG ulRequestedMaxSR,
    ULONG ulFormatType )
{
    PAUDIO_CLASS_TYPE1_STREAM pT1AudioDesc;
    PAUDIO_CLASS_TYPE2_STREAM pT2AudioDesc;

    ULONG ulMaxSampleRate = 0;
    ULONG ulIFMaxSR;
    ULONG j;

    if ( ulFormatType == USBAUDIO_DATA_FORMAT_TYPE_I_UNDEFINED) {
        pT1AudioDesc = (PAUDIO_CLASS_TYPE1_STREAM)pUSBAudioRange->pAudioDescriptor;
        if (pT1AudioDesc->bSampleFreqType == 0) {
            ulIFMaxSR = pUSBAudioRange->KsDataRangeAudio.MaximumSampleFrequency;
            pUSBAudioRange->ulMaxSampleRate = ( ulIFMaxSR < ulRequestedMaxSR ) ?
                                                ulIFMaxSR : ulRequestedMaxSR;
        }
        else {
            pUSBAudioRange->ulMaxSampleRate = 0;
            for ( j=0; j<pT1AudioDesc->bSampleFreqType; j++ ) {
                ulIFMaxSR  = pT1AudioDesc->pSampleRate[j].bSampleFreqByte1 +
                      256L * pT1AudioDesc->pSampleRate[j].bSampleFreqByte2 +
                    65536L * pT1AudioDesc->pSampleRate[j].bSampleFreqByte3;
                if ( ( ulIFMaxSR <= ulRequestedMaxSR ) &&
                     ( ulIFMaxSR > pUSBAudioRange->ulMaxSampleRate ) )
                    pUSBAudioRange->ulMaxSampleRate = ulIFMaxSR;
            }
        }
    }
    else { // Its Type II
        pT2AudioDesc = (PAUDIO_CLASS_TYPE2_STREAM)pUSBAudioRange->pAudioDescriptor;
        if (pT2AudioDesc->bSampleFreqType == 0) {
            ulIFMaxSR = pUSBAudioRange->KsDataRangeAudio.MaximumSampleFrequency;
            pUSBAudioRange->ulMaxSampleRate = ( ulIFMaxSR < ulRequestedMaxSR ) ?
                                                ulIFMaxSR : ulRequestedMaxSR;
        }
        else {
            pUSBAudioRange->ulMaxSampleRate = 0;
            for ( j=0; j<pT2AudioDesc->bSampleFreqType; j++ ) {
                ulIFMaxSR  = pT2AudioDesc->pSampleRate[j].bSampleFreqByte1 +
                      256L * pT2AudioDesc->pSampleRate[j].bSampleFreqByte2 +
                    65536L * pT2AudioDesc->pSampleRate[j].bSampleFreqByte3;
                if ( ( ulIFMaxSR <= ulRequestedMaxSR ) &&
                     ( ulIFMaxSR > pUSBAudioRange->ulMaxSampleRate ) )
                    pUSBAudioRange->ulMaxSampleRate = ulIFMaxSR;
            }
        }
    }
}

PUSBAUDIO_DATARANGE
FindBestMatchForInterfaces(
    PUSBAUDIO_DATARANGE *ppUSBAudioRange,
    ULONG ulAudioRangeCount,
    ULONG ulRequestedMaxSR  )
{
    PUSBAUDIO_DATARANGE pUSBAudioRange;
    PAUDIO_CLASS_TYPE1_STREAM pT1AudioDesc;

    ULONG ulMaxSampleRate = 0;
    ULONG ulMaxChannels   = 0;
    ULONG ulMaxSampleSize = 0;
    ULONG ulRngeCnt;
    ULONG ulFormatType;
    ULONG i;

     ulFormatType = ppUSBAudioRange[0]->ulUsbDataFormat & USBAUDIO_DATA_FORMAT_TYPE_MASK;
    // Determine if this is Type I or Type II interface. Since we've already weeded
    // out the impossibilities via CheckFormatMatch this should be the same for all
    // interfaces left in the list.

    for ( i=0; i<ulAudioRangeCount; i++ ) {
        GetMaxSampleRate( ppUSBAudioRange[i],
                          ulRequestedMaxSR,
                          ulFormatType );
    }

    // Now eliminate lower frequency interfaces. First find the best then
    // eliminate others that don't meet it.
    for ( i=0; i<ulAudioRangeCount; i++ ) {
        pUSBAudioRange = ppUSBAudioRange[i];
        if ( pUSBAudioRange->ulMaxSampleRate > ulMaxSampleRate ) {
            ulMaxSampleRate = pUSBAudioRange->ulMaxSampleRate;
        }
    }
    for ( i=0, ulRngeCnt=ulAudioRangeCount; i<ulAudioRangeCount; i++ ) {
        pUSBAudioRange = ppUSBAudioRange[i];
        if ( pUSBAudioRange->ulMaxSampleRate < ulMaxSampleRate ) {
            ppUSBAudioRange[i] = NULL; ulRngeCnt--;
        }
    }

    if ((ulFormatType == USBAUDIO_DATA_FORMAT_TYPE_I_UNDEFINED) && (ulRngeCnt > 1)) {
        // Now find the highest number of channels and eliminate others
        for ( i=0; i<ulAudioRangeCount; i++ ) {
            if ( ppUSBAudioRange[i] ) {
                pT1AudioDesc = ppUSBAudioRange[i]->pAudioDescriptor;
                if ( (ULONG)pT1AudioDesc->bNumberOfChannels > ulMaxChannels ) {
                    ulMaxChannels = (ULONG)pT1AudioDesc->bNumberOfChannels;
                }
                if ( (ULONG)pT1AudioDesc->bBitsPerSample > ulMaxSampleSize ) {
                    ulMaxSampleSize = (ULONG)pT1AudioDesc->bBitsPerSample;
                }
            }
        }

        for ( i=0; ((i<ulAudioRangeCount) && (ulRngeCnt>1)); i++ ) {
            if ( ppUSBAudioRange[i] ) {
                pT1AudioDesc = ppUSBAudioRange[i]->pAudioDescriptor;
                if ( (ULONG)pT1AudioDesc->bNumberOfChannels < ulMaxChannels ) {
                    ppUSBAudioRange[i] = NULL; ulRngeCnt--;
                }
            }
        }

        for ( i=0; ((i<ulAudioRangeCount) && (ulRngeCnt>1)); i++ ) {
            if ( ppUSBAudioRange[i] ) {
                pT1AudioDesc = ppUSBAudioRange[i]->pAudioDescriptor;
                if ( (ULONG)pT1AudioDesc->bBitsPerSample < ulMaxSampleSize ) {
                    ppUSBAudioRange[i] = NULL; ulRngeCnt--;
                }
            }
        }
    }

    i=0;
    while ( !ppUSBAudioRange[i] ) i++;

    return ppUSBAudioRange[i];
}

PUSBAUDIO_DATARANGE
FindDataIntersection(
    PKSDATARANGE_AUDIO pKsAudioRange,
    PUSBAUDIO_DATARANGE *ppUSBAudioRanges,
    ULONG ulAudioRangeCount )
{
    PUSBAUDIO_DATARANGE *ppUSBAudioRange;
    PUSBAUDIO_DATARANGE pUSBAudioRange;
    PUSBAUDIO_DATARANGE pMatchedRange;
    ULONG ulRngeCnt = 0;
    ULONG ulMaximumSampleFrequency = MAX_ULONG;  // default high value, if no audio
    ULONG i;                                     // data range info is sent.

    // Allocate space for copy of range pointers
    ppUSBAudioRange = AllocMem(NonPagedPool, ulAudioRangeCount*sizeof(PUSBAUDIO_DATARANGE));
    if ( !ppUSBAudioRange ) {
        return NULL;
    }

    // Make a list of those ranges which match the input request
    for (i=0; i<ulAudioRangeCount; i++) {
        pUSBAudioRange = ppUSBAudioRanges[i];
        if ( CheckFormatMatch(pKsAudioRange, &pUSBAudioRange->KsDataRangeAudio) ) {
            ppUSBAudioRange[ulRngeCnt++] = ppUSBAudioRanges[i];
        }
    }

    // Set this ulMaximumSampleFrequency only if it exists in pKsAudioRange
    if (pKsAudioRange->DataRange.FormatSize >= sizeof(KSDATARANGE_AUDIO)) {
        ulMaximumSampleFrequency = pKsAudioRange->MaximumSampleFrequency;
    }

    // If there are no matches return NULL
    if ( ulRngeCnt == 0 ) {
        FreeMem( ppUSBAudioRange );
        return NULL;
    }

    // If there is only 1 match we're done
    else if ( ulRngeCnt == 1 ) {
        pMatchedRange = ppUSBAudioRange[0];
        GetMaxSampleRate( pMatchedRange,
                          ulMaximumSampleFrequency,
                          pMatchedRange->ulUsbDataFormat & USBAUDIO_DATA_FORMAT_TYPE_MASK );
        FreeMem( ppUSBAudioRange );
        return pMatchedRange;
    }

    // Now narrow choices based on best possible match.
    pMatchedRange =
        FindBestMatchForInterfaces( ppUSBAudioRange,
                                    ulRngeCnt,
                                    ulMaximumSampleFrequency );
    FreeMem(ppUSBAudioRange);

    return pMatchedRange;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\drivers\usbaudio.2\midiin.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 2000
//
//  File:       midiin.c
//
//--------------------------------------------------------------------------

#include "common.h"

/* * A simple helper function to return the current
 * system time in 100 nanosecond units. It uses KeQueryPerformanceCounter
 */
ULONGLONG
GetCurrentTime
(   void
)
{
    LARGE_INTEGER   liFrequency,liTime;

    //  total ticks since system booted
    liTime = KeQueryPerformanceCounter(&liFrequency);

    // Convert ticks to 100ns units.
#ifndef UNDER_NT

    //
    //  HACKHACK! Since timeGetTime assumes 1193 VTD ticks per millisecond,
    //  instead of 1193.182 (or 1193.18 -- really spec'ed as 1193.18175),
    //  we should do the same (on Win 9x codebase only).
    //
    //  This means we drop the bottom three digits of the frequency.
    //  We need to fix this when the fix to timeGetTime is checked in.
    //  instead we do this:
    //
    liFrequency.QuadPart /= 1000;           //  drop the precision on the floor
    liFrequency.QuadPart *= 1000;           //  drop the precision on the floor

#endif  //  !UNDER_NT    //  Convert ticks to 100ns units.

    //
    return (KSCONVERT_PERFORMANCE_TIME(liFrequency.QuadPart,liTime));
}

NTSTATUS AbortMIDIInPipe
(
    IN PMIDI_PIPE_INFORMATION pMIDIPipeInfo
)
{
    NTSTATUS ntStatus;
    PURB pUrb;
    KIRQL irql;

    ASSERT(pMIDIPipeInfo->hPipeHandle);

    _DbgPrintF(DEBUGLVL_VERBOSE,("[AbortMIDIInPipe] pin %x\n",pMIDIPipeInfo));

    pUrb = AllocMem(NonPagedPool, sizeof(struct _URB_PIPE_REQUEST));
    if (!pUrb)
        return STATUS_INSUFFICIENT_RESOURCES;

    // Do the initial Abort
    pUrb->UrbHeader.Length = (USHORT) sizeof (struct _URB_PIPE_REQUEST);
    pUrb->UrbHeader.Function = URB_FUNCTION_ABORT_PIPE;
    pUrb->UrbPipeRequest.PipeHandle = pMIDIPipeInfo->hPipeHandle;
    ntStatus = SubmitUrbToUsbdSynch(pMIDIPipeInfo->pNextDeviceObject, pUrb);

    if ( !NT_SUCCESS(ntStatus) ) {
        _DbgPrintF(DEBUGLVL_VERBOSE,("Abort Failed %x\n",ntStatus));
    }

    // Wait for all urbs on the pipe to clear
    KeAcquireSpinLock( &pMIDIPipeInfo->PipeSpinLock, &irql );
    if ( pMIDIPipeInfo->ulOutstandingUrbCount ) {
        KeResetEvent( &pMIDIPipeInfo->PipeStarvationEvent );
        KeReleaseSpinLock( &pMIDIPipeInfo->PipeSpinLock, irql );
        KeWaitForSingleObject( &pMIDIPipeInfo->PipeStarvationEvent,
                               Executive,
                               KernelMode,
                               FALSE,
                               NULL );
    }
    else
        KeReleaseSpinLock( &pMIDIPipeInfo->PipeSpinLock, irql );

    // Now reset the pipe and continue
    RtlZeroMemory( pUrb, sizeof (struct _URB_PIPE_REQUEST) );
    pUrb->UrbHeader.Function = URB_FUNCTION_SYNC_RESET_PIPE_AND_CLEAR_STALL;
    pUrb->UrbHeader.Length = (USHORT) sizeof (struct _URB_PIPE_REQUEST);
    pUrb->UrbPipeRequest.PipeHandle = pMIDIPipeInfo->hPipeHandle;

    ntStatus = SubmitUrbToUsbdSynch(pMIDIPipeInfo->pNextDeviceObject, pUrb);

    FreeMem(pUrb);

    if ( NT_SUCCESS(ntStatus) ) {
        pMIDIPipeInfo->fUrbError = FALSE;
    }

    return ntStatus;
}

VOID
USBMIDIInGateOnWorkItem( PKSPIN pKsPin )
{
    PPIN_CONTEXT pPinContext = pKsPin->Context;
    PMIDI_PIN_CONTEXT pMIDIPinContext = pPinContext->pMIDIPinContext;
    PMIDIIN_PIN_CONTEXT pMIDIInPinContext = pMIDIPinContext->pMIDIInPinContext;
    KIRQL irql;

    _DbgPrintF(DEBUGLVL_VERBOSE,("[USBMIDIInGateOnWorkItem] pin %d\n",pKsPin->Id));

    // Don't want to turn on the gate if we are not running
//    KeAcquireSpinLock( &pPinContext->PinSpinLock, &irql );
//    if (!pMIDIInPinContext->fRunning) {
//        pMIDIInPinContext->fProcessing = FALSE;
//        KeReleaseSpinLock( &pPinContext->PinSpinLock, irql );
//        return;
//    }
//    KeReleaseSpinLock( &pPinContext->PinSpinLock, irql );

    do
    {
        // Acquire the Process Mutex to ensure there will be no new requests during the gate operation
        KsPinAcquireProcessingMutex( pKsPin );

        KsGateTurnInputOn( KsPinGetAndGate(pKsPin) );

        KsPinAttemptProcessing( pKsPin, TRUE );

        DbgLog("MProcOn", pKsPin, 0, 0, 0 );

        KsPinReleaseProcessingMutex( pKsPin );
    } while (KsDecrementCountedWorker(pMIDIInPinContext->GateOnWorkerObject));
}

NTSTATUS
USBMIDIInInitializeUrbAndIrp( PMIDIIN_URB_BUFFER_INFO pMIDIInBufInfo )
{
    PKSPIN pKsPin = pMIDIInBufInfo->pKsPin;
    PMIDI_PIPE_INFORMATION pMIDIPipeInfo = pMIDIInBufInfo->pMIDIPipeInfo;
    PPIN_CONTEXT pPinContext = pKsPin->Context;
    PIRP pIrp = pMIDIInBufInfo->pIrp;
    PURB pUrb = pMIDIInBufInfo->pUrb;
    PIO_STACK_LOCATION pNextStack;
    ULONG ulUrbSize = sizeof( struct _URB_BULK_OR_INTERRUPT_TRANSFER );

    RtlZeroMemory(pUrb, ulUrbSize);

    pUrb->UrbBulkOrInterruptTransfer.Hdr.Length = (USHORT) sizeof( struct _URB_BULK_OR_INTERRUPT_TRANSFER );
    pUrb->UrbBulkOrInterruptTransfer.Hdr.Function = URB_FUNCTION_BULK_OR_INTERRUPT_TRANSFER;
    pUrb->UrbBulkOrInterruptTransfer.PipeHandle = pMIDIPipeInfo->hPipeHandle;
    pUrb->UrbBulkOrInterruptTransfer.TransferFlags = USBD_TRANSFER_DIRECTION_IN;
    // short packet is not treated as an error.
    pUrb->UrbBulkOrInterruptTransfer.TransferFlags |= USBD_SHORT_TRANSFER_OK;
    pUrb->UrbBulkOrInterruptTransfer.UrbLink = NULL;
    pUrb->UrbBulkOrInterruptTransfer.TransferBufferMDL = NULL;
    pUrb->UrbBulkOrInterruptTransfer.TransferBuffer = pMIDIInBufInfo->pData;
    pUrb->UrbBulkOrInterruptTransfer.TransferBufferLength = (int) pMIDIPipeInfo->ulMaxPacketSize;

    pIrp->IoStatus.Status = STATUS_SUCCESS;

    RtlZeroMemory(pMIDIInBufInfo->pData,pMIDIPipeInfo->ulMaxPacketSize);

    IoInitializeIrp( pIrp,
                     IoSizeOfIrp(pMIDIPipeInfo->pNextDeviceObject->StackSize),
                     pMIDIPipeInfo->pNextDeviceObject->StackSize );

    pNextStack = IoGetNextIrpStackLocation(pIrp);
    ASSERT(pNextStack != NULL);

    pNextStack->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
    pNextStack->Parameters.Others.Argument1 = pMIDIInBufInfo->pUrb;
    pNextStack->Parameters.DeviceIoControl.IoControlCode = IOCTL_INTERNAL_USB_SUBMIT_URB;

    IoSetCompletionRoutine ( pIrp, USBMIDIInCompleteCallback, pMIDIInBufInfo, TRUE, TRUE, TRUE );

    DbgLog("IniIrpM", pMIDIInBufInfo, pIrp, pUrb, pNextStack );

    return STATUS_SUCCESS;
}

NTSTATUS
USBMIDIInReQueueUrb( PMIDIIN_URB_BUFFER_INFO pMIDIInBufInfo )
{
    PMIDI_PIPE_INFORMATION pMIDIPipeInfo = pMIDIInBufInfo->pMIDIPipeInfo;
    KIRQL irql;
    NTSTATUS ntStatus = STATUS_SUCCESS;

    USBMIDIInInitializeUrbAndIrp( pMIDIInBufInfo );

    InterlockedIncrement(&pMIDIPipeInfo->ulOutstandingUrbCount);
    ntStatus = IoCallDriver( pMIDIPipeInfo->pNextDeviceObject,
                             pMIDIInBufInfo->pIrp );

    return ntStatus;

}

VOID
USBMIDIInRequeueWorkItem
(
    IN PMIDI_PIPE_INFORMATION pMIDIPipeInfo
)
{
    PMIDIIN_URB_BUFFER_INFO pMIDIInBufInfo = NULL;
    NTSTATUS ntStatus = STATUS_SUCCESS;
    KIRQL irql;

    _DbgPrintF(DEBUGLVL_VERBOSE,("[USBMIDIInRequeueWorkItem] pMidiPipeInfo %x\n",pMIDIPipeInfo));

    do
    {
        // Clear out any error if need be
        if (pMIDIPipeInfo->fUrbError) {
            ntStatus = AbortMIDIInPipe( pMIDIPipeInfo );  // TODO: Returning STATUS_DEVICE_DATA_ERROR (0xc000009c)
            if ( !NT_SUCCESS(ntStatus) ) {
                // TRAP; // Figure out what to do here
                pMIDIPipeInfo->fRunning = FALSE;
                _DbgPrintF(DEBUGLVL_VERBOSE,("[USBMIDIInRequeueWorkItem] Abort Failed %x\n",ntStatus));
            }
        }

        if ( NT_SUCCESS(ntStatus) && !pMIDIPipeInfo->fUrbError) {
            KeAcquireSpinLock( &pMIDIPipeInfo->PipeSpinLock, &irql );
            // Requeue Urbs
            while ( !IsListEmpty(&pMIDIPipeInfo->EmptyBufferQueue) ) {
                pMIDIInBufInfo = (PMIDIIN_URB_BUFFER_INFO)RemoveHeadList(&pMIDIPipeInfo->EmptyBufferQueue);
                KeReleaseSpinLock( &pMIDIPipeInfo->PipeSpinLock, irql );
                ntStatus = USBMIDIInReQueueUrb( pMIDIInBufInfo );
                if ( !NT_SUCCESS(ntStatus) ) {
                    //TRAP; // Figure out what to do here
                    pMIDIPipeInfo->fRunning = FALSE;
                    KeAcquireSpinLock( &pMIDIPipeInfo->PipeSpinLock, &irql );
                    _DbgPrintF(DEBUGLVL_VERBOSE,("[USBMIDIInRequeueWorkItem] Requeue Failed %x\n",ntStatus));
                    break;
                }
                KeAcquireSpinLock( &pMIDIPipeInfo->PipeSpinLock, &irql );
            }
            KeReleaseSpinLock( &pMIDIPipeInfo->PipeSpinLock, irql );
        }
    } while (KsDecrementCountedWorker(pMIDIPipeInfo->RequeueUrbWorkerObject));

    return;
}

NTSTATUS
AddMIDIEventToPinQueue
(
    IN PMIDI_PIPE_INFORMATION pMIDIPipeInfo,
    IN PUSBMIDIEVENTPACKET pMIDIEventPacket
)
{
    PMIDIIN_PIN_LISTENTRY pMIDIInPinListEntry;
    PLIST_ENTRY ple;
    PKSPIN pKsPin;
    PPIN_CONTEXT pPinContext;
    PMIDI_PIN_CONTEXT pMIDIPinContext;
    PMIDIIN_PIN_CONTEXT pMIDIInPinContext;
    PMIDIIN_USBMIDIEVENT_INFO pUSBMIDIEventInfo;
    ULONG CableNumber;
    ULONG PinCableNumber;
    BOOL fNeedToProcess;
    KIRQL irql;

    // Undefined Message, don't add to pin queue
    if (pMIDIEventPacket->ByteLayout.CodeIndexNumber == 0x0 ||
        pMIDIEventPacket->ByteLayout.CodeIndexNumber == 0x1 ) {
        return STATUS_SUCCESS;
    }

    // Given this cable number, find the right pin
    CableNumber = pMIDIEventPacket->ByteLayout.CableNumber;

    KeAcquireSpinLock( &pMIDIPipeInfo->PipeSpinLock, &irql );

    for(ple = pMIDIPipeInfo->MIDIInActivePinList.Flink;
        ple != &pMIDIPipeInfo->MIDIInActivePinList;
        ple = ple->Flink)
    {
        pMIDIInPinListEntry = CONTAINING_RECORD(ple, MIDIIN_PIN_LISTENTRY, List);
        pKsPin = pMIDIInPinListEntry->pKsPin;
        pPinContext = pKsPin->Context;
        pMIDIPinContext = pPinContext->pMIDIPinContext;
        pMIDIInPinContext = pMIDIPinContext->pMIDIInPinContext;

        KeReleaseSpinLock( &pMIDIPipeInfo->PipeSpinLock, irql );

        PinCableNumber = pMIDIPinContext->ulCableNumber;
        if (CableNumber == PinCableNumber) {

            _DbgPrintF(DEBUGLVL_VERBOSE,("[AddMIDIEventToPinQueue] Found CableNumber(%d) on pKsPin(%x)\n",
                                       pMIDIPinContext->ulCableNumber, pKsPin));

            KeAcquireSpinLock( &pPinContext->PinSpinLock, &irql );

            if ( (pMIDIInPinContext->fRunning) &&
                 (!IsListEmpty( &pMIDIInPinContext->USBMIDIEmptyEventQueue )) ) {
                pUSBMIDIEventInfo = (PMIDIIN_USBMIDIEVENT_INFO)RemoveHeadList(&pMIDIInPinContext->USBMIDIEmptyEventQueue);

                // Copy the midi event and store the 100ns time this buffer was received
                pUSBMIDIEventInfo->USBMIDIEvent = *pMIDIEventPacket;
                pUSBMIDIEventInfo->ullTimeStamp = GetCurrentTime();

                // Queue the event for processing
                fNeedToProcess = IsListEmpty( &pMIDIInPinContext->USBMIDIEventQueue ) &&
                                         !pMIDIInPinContext->fProcessing;

                InsertTailList( &pMIDIInPinContext->USBMIDIEventQueue, &pUSBMIDIEventInfo->List );

                KeReleaseSpinLock( &pPinContext->PinSpinLock, irql );

                if ( fNeedToProcess ) {
                    pMIDIInPinContext->fProcessing = TRUE;

                    // Queue a work item to handle this so that we don't race with the gate
                    // count in the processing routine
                    KsIncrementCountedWorker(pMIDIInPinContext->GateOnWorkerObject);
                }
            }
            else {
                DbgLog("Dropped", pKsPin, *((LPDWORD)pMIDIEventPacket), 0, 0 );
                KeReleaseSpinLock( &pPinContext->PinSpinLock, irql );
            }

            KeAcquireSpinLock( &pMIDIPipeInfo->PipeSpinLock, &irql );
            break;
        }

        KeAcquireSpinLock( &pMIDIPipeInfo->PipeSpinLock, &irql );
    }

    KeReleaseSpinLock( &pMIDIPipeInfo->PipeSpinLock, irql );

    return STATUS_SUCCESS;
}

NTSTATUS
USBMIDIInCompleteCallback(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP pIrp,
    PMIDIIN_URB_BUFFER_INFO pMIDIInBufInfo )
{
    PUCHAR pMIDIInData;
    ULONG ulMIDIInRemaining;
    PMIDI_PIPE_INFORMATION pMIDIPipeInfo = pMIDIInBufInfo->pMIDIPipeInfo;
    NTSTATUS ntStatus = pIrp->IoStatus.Status;
    KIRQL irql;

    _DbgPrintF(DEBUGLVL_VERBOSE,("[USBMIDIInCompleteCallback] pMIDIPipeInfo %x\n",pMIDIPipeInfo));
    DbgLog("MIData", *((LPDWORD)pMIDIInBufInfo->pData),
                     *((LPDWORD)pMIDIInBufInfo->pData+1),
                     *((LPDWORD)pMIDIInBufInfo->pData+2),
                     *((LPDWORD)pMIDIInBufInfo->pData+3) );

    if ( pMIDIInBufInfo->pUrb->UrbBulkOrInterruptTransfer.Hdr.Status ) {
        DbgLog("MUrbErr", pMIDIInBufInfo, pMIDIPipeInfo,
                          pMIDIInBufInfo->pUrb->UrbBulkOrInterruptTransfer.Hdr.Status, 0 );
        ntStatus = STATUS_DEVICE_DATA_ERROR;
        pMIDIPipeInfo->fUrbError = TRUE;
    }

    ulMIDIInRemaining = pMIDIInBufInfo->pUrb->UrbBulkOrInterruptTransfer.TransferBufferLength;
    pMIDIInData       = pMIDIInBufInfo->pData;
    while ( ulMIDIInRemaining >= sizeof(USBMIDIEVENTPACKET)) {
        AddMIDIEventToPinQueue(pMIDIPipeInfo, (PUSBMIDIEVENTPACKET)pMIDIInData);

        pMIDIInData += sizeof(USBMIDIEVENTPACKET);
        ulMIDIInRemaining -= sizeof(USBMIDIEVENTPACKET);
    }

    // Put Urb back on Empty urb queue
    KeAcquireSpinLock(&pMIDIPipeInfo->PipeSpinLock, &irql);
    InsertTailList( &pMIDIPipeInfo->EmptyBufferQueue, &pMIDIInBufInfo->List );
    KeReleaseSpinLock(&pMIDIPipeInfo->PipeSpinLock, irql);

    if ( 0 == InterlockedDecrement(&pMIDIPipeInfo->ulOutstandingUrbCount) ) {
        _DbgPrintF(DEBUGLVL_VERBOSE,("[USBMIDIInCompleteCallback] Out of Urbs on pMIDIPipeInfo %x\n",pMIDIPipeInfo));
        KeSetEvent( &pMIDIPipeInfo->PipeStarvationEvent, 0, FALSE );
    }

    // Fire work item to requeue urb to device
    if ( pMIDIPipeInfo->fRunning ) {
        KsIncrementCountedWorker(pMIDIPipeInfo->RequeueUrbWorkerObject);
    }

    return STATUS_MORE_PROCESSING_REQUIRED;
}

ULONG ConvertCINToBytes
(
    BYTE CodeIndexNumber
)
{
    ULONG NumBytes = 0;

    switch (CodeIndexNumber) {
    case 0x5:
    case 0xF:
        NumBytes = 1;
        break;

    case 0x2:
    case 0x6:
    case 0xC:
    case 0xD:
        NumBytes = 2;
        break;

    case 0x3:
    case 0x4:
    case 0x7:
    case 0x8:
    case 0x9:
    case 0xA:
    case 0xB:
    case 0xE:
        NumBytes = 3;
        break;

    default:
        _DbgPrintF( DEBUGLVL_VERBOSE, ("[ConvertCINToBytes] Unknown CIN received from device\n"));
    }

    return NumBytes;
}

VOID CopyUSBMIDIEvent
(
    PMIDIIN_USBMIDIEVENT_INFO pUSBMIDIEventInfo,
    PMIDIIN_PIN_CONTEXT pMIDIInPinContext,
    PUCHAR pStreamPtrData,
    PUSBMIDIEVENTPACKET pMIDIPacket,
    PULONG pulCopySize
)
{
    PKSMUSICFORMAT pMusicHdr;
    ULONG BytesToCopy;

    ASSERT(*pulCopySize >= sizeof(*pMusicHdr) + sizeof(DWORD));

    pMusicHdr = (PKSMUSICFORMAT)pStreamPtrData;

    // Copy the MIDI data
    BytesToCopy = ConvertCINToBytes(pMIDIPacket->ByteLayout.CodeIndexNumber);
    RtlCopyMemory(pStreamPtrData+
                  sizeof(*pMusicHdr) +   // jump over the music header
                  pMusicHdr->ByteCount,  // and already written bytes
                  &pMIDIPacket->ByteLayout.MIDI_0, // jump over the CIN and CN
                  BytesToCopy);

    // TODO: For multiple music headers, need to produce proper TimeDeltaMs value
    if (pUSBMIDIEventInfo->ullTimeStamp < pMIDIInPinContext->ullStartTime ) {
        _DbgPrintF( DEBUGLVL_TERSE, ("[CopyUSBMIDIEvent] Event came in before pin went to KSSTATE_RUN!\n"));
        pMusicHdr->TimeDeltaMs = 0;
    }
    else {
        pMusicHdr->TimeDeltaMs =
            (ULONG)((pUSBMIDIEventInfo->ullTimeStamp - pMIDIInPinContext->ullStartTime) / 10000); // 100ns->Ms for delta MSec
    }
    pMusicHdr->ByteCount += BytesToCopy;

    {
        LPBYTE MIDIData = pStreamPtrData+sizeof(*pMusicHdr);
        _DbgPrintF( DEBUGLVL_VERBOSE, ("'[CopyUSBMIDIEvent] MIDIData = 0x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x\n",
                                      *MIDIData,    *(MIDIData+1), *(MIDIData+2),
                                      *(MIDIData+3),*(MIDIData+4), *(MIDIData+5),
                                      *(MIDIData+6),*(MIDIData+7), *(MIDIData+8),
                                      *(MIDIData+9),*(MIDIData+10),*(MIDIData+11)) );
    }

    // update the actual copy size
    //*pulCopySize = sizeof(*pMusicHdr) + ((pMusicHdr->ByteCount + 3) & ~3);
    *pulCopySize = sizeof(*pMusicHdr) + pMusicHdr->ByteCount;
    _DbgPrintF( DEBUGLVL_VERBOSE, ("'[CopyUSBMIDIEvent] Copied %d bytes\n",*pulCopySize));

    return;
}

BOOL IsRealTimeEvent
(
    USBMIDIEVENTPACKET MIDIPacket
)
{
    return IS_REALTIME(MIDIPacket.ByteLayout.MIDI_0);
}

NTSTATUS
USBMIDIInProcessStreamPtr( PKSPIN pKsPin )
{
    PPIN_CONTEXT pPinContext = pKsPin->Context;
    PMIDI_PIN_CONTEXT pMIDIPinContext = pPinContext->pMIDIPinContext;
    PMIDIIN_PIN_CONTEXT pMIDIInPinContext = pMIDIPinContext->pMIDIInPinContext;
    PMIDI_PIPE_INFORMATION pMIDIPipeInfo = pMIDIInPinContext->pMIDIPipeInfo;
    PMIDIIN_USBMIDIEVENT_INFO pUSBMIDIEventInfo = NULL;
    PKSSTREAM_POINTER pKsStreamPtr;
    ULONG ulStreamRemaining;
    KIRQL irql;

    _DbgPrintF( DEBUGLVL_VERBOSE, ("[USBMIDIInProcessStreamPtr] pKsPin %x\n",pKsPin));
    DbgLog("MInProc", pKsPin, pPinContext, pMIDIPinContext, pMIDIInPinContext );

    KeAcquireSpinLock(&pPinContext->PinSpinLock, &irql);
    if ( !IsListEmpty( &pMIDIInPinContext->USBMIDIEventQueue )) {
        pUSBMIDIEventInfo = (PMIDIIN_USBMIDIEVENT_INFO)RemoveHeadList(&pMIDIInPinContext->USBMIDIEventQueue);
        // Set stream started flag if not already done
        if ( !pPinContext->fStreamStartedFlag ) {
            pPinContext->fStreamStartedFlag = TRUE;
        }
        KeReleaseSpinLock(&pPinContext->PinSpinLock, irql);
    }
    else {
        KeReleaseSpinLock(&pPinContext->PinSpinLock, irql);
        KsGateTurnInputOff( KsPinGetAndGate(pKsPin) );
        pMIDIInPinContext->fProcessing = FALSE;
        _DbgPrintF(DEBUGLVL_VERBOSE,("[USBMIDIInProcessStreamPtr] No buffers ready yet!\n"));
        return STATUS_PENDING;
    }

    // Get leading edge
    pKsStreamPtr = KsPinGetLeadingEdgeStreamPointer( pKsPin, KSSTREAM_POINTER_STATE_LOCKED );
    if ( !pKsStreamPtr ) {
        _DbgPrintF(DEBUGLVL_VERBOSE,("[MIDIInProcessStreamPtr] Leading edge is NULL\n"));
        return STATUS_SUCCESS;
    }

    ulStreamRemaining = pKsStreamPtr->OffsetOut.Remaining;

    // check to see if there is room for more data into the stream
    while ( pKsStreamPtr && pUSBMIDIEventInfo) {
        ULONG ulCopySize = 0;

        //if (*((LPDWORD)pUSBMIDIEventInfo->USBMIDIEvent)) {
        //    DbgLog("MIData2", *((LPDWORD)pMIDIInData), pMIDIInBufInfo, ulMIDIInRemaining, pMIDIInData );
        //}

        // Undefined Message, ignore
        if (pUSBMIDIEventInfo->USBMIDIEvent.ByteLayout.CodeIndexNumber == 0x0 ||
            pUSBMIDIEventInfo->USBMIDIEvent.ByteLayout.CodeIndexNumber == 0x1 ) {
            _DbgPrintF( DEBUGLVL_VERBOSE, ("'[USBMIDIInProcessStreamPtr] Undefined Message, ignore\n"));
        }
        else {
            // Valid USB MIDI Message
            ulCopySize = ulStreamRemaining;

            DbgLog("MInLp", pKsStreamPtr, pUSBMIDIEventInfo, ulStreamRemaining, pKsStreamPtr->OffsetOut.Data );

            //
            //  If this is a realtime message, complete any pending sysex data and
            //  allow the realtime message to completed by itself
            //
            if (IsRealTimeEvent(pUSBMIDIEventInfo->USBMIDIEvent)) {

                if (pMIDIInPinContext->ulMIDIBytesCopiedToStream) {
                    // Complete the dword-aligned buffer
                    KsStreamPointerAdvanceOffsetsAndUnlock( pKsStreamPtr,
                                                            0,
                                                            (pMIDIInPinContext->ulMIDIBytesCopiedToStream + 3) & ~3,
                                                            TRUE );
                    pMIDIInPinContext->ulMIDIBytesCopiedToStream = 0;

                    // Get Next stream header if there is one.
                    if ( pKsStreamPtr = KsPinGetLeadingEdgeStreamPointer( pKsPin, KSSTREAM_POINTER_STATE_LOCKED )) {
                        ulStreamRemaining = pKsStreamPtr->OffsetOut.Remaining;
                    }
                    else {
                        continue;
                    }
                }

                DbgLog("MInRT", pKsStreamPtr, pUSBMIDIEventInfo, ulStreamRemaining, pKsStreamPtr->OffsetOut.Data );
            }

            CopyUSBMIDIEvent( pUSBMIDIEventInfo,
                              pMIDIInPinContext,
                              pKsStreamPtr->OffsetOut.Data,
                              &pUSBMIDIEventInfo->USBMIDIEvent,
                              &ulCopySize );

            //
            // Complete frame if EOX, short message or ran out of room in frame for
            // continuation of SysEx
            //
            if ( (pUSBMIDIEventInfo->USBMIDIEvent.ByteLayout.CodeIndexNumber != 0x4) ||
                 (ulCopySize + 3 > ulStreamRemaining) ) {

                if (ulCopySize + 3 > ulStreamRemaining) {
                    _DbgPrintF( DEBUGLVL_VERBOSE, ("'[USBMIDIInProcessStreamPtr] Ending SysEx subpacket\n"));
                }

                // Complete the dword-aligned buffer
                KsStreamPointerAdvanceOffsetsAndUnlock( pKsStreamPtr, 0, (ulCopySize + 3) & ~3, TRUE );
                pMIDIInPinContext->ulMIDIBytesCopiedToStream = 0;
                // Get Next stream header if there is one.
                if ( pKsStreamPtr = KsPinGetLeadingEdgeStreamPointer( pKsPin, KSSTREAM_POINTER_STATE_LOCKED )) {
                    ulStreamRemaining = pKsStreamPtr->OffsetOut.Remaining;
                }
            }
            else {
                //
                // store the total bytes copied so far so that those bytes
                // can be completed if the stream goes to a stop state
                //
                pMIDIInPinContext->ulMIDIBytesCopiedToStream = ulCopySize;
            }
        }

        // Add this Event entry back to the free queue
        InsertTailList( &pMIDIInPinContext->USBMIDIEmptyEventQueue, &pUSBMIDIEventInfo->List );

        // Check if there is more captured data queued
        // Grab Spinlock to check capture queue
        KeAcquireSpinLock(&pPinContext->PinSpinLock, &irql);
        if ( !IsListEmpty( &pMIDIInPinContext->USBMIDIEventQueue )) {
            pUSBMIDIEventInfo =
                (PMIDIIN_USBMIDIEVENT_INFO)RemoveHeadList(&pMIDIInPinContext->USBMIDIEventQueue);
            KeReleaseSpinLock(&pPinContext->PinSpinLock, irql);
        }
        else {
            KsGateTurnInputOff( KsPinGetAndGate(pKsPin) );
            pMIDIInPinContext->fProcessing = FALSE;
            pUSBMIDIEventInfo = NULL;
            DbgLog("MPrcOff", pUSBMIDIEventInfo, pMIDIInPinContext, pPinContext, 0 );
            KeReleaseSpinLock(&pPinContext->PinSpinLock, irql);
        }
    }

    if ( !pUSBMIDIEventInfo ) {
        if ( pKsStreamPtr )
            KsStreamPointerUnlock(pKsStreamPtr, FALSE);

        // No more capture buffers pending from the device.  Return STATUS_PENDING so that KS
        // doesn't keep calling back into the process routine.  The AndGate should have been
        // turned off at this point to prevent an endless loop too.
        return STATUS_PENDING;
    }
    else { // if ( !pKsStreamPtr )
        _DbgPrintF(DEBUGLVL_VERBOSE,("[MIDIInProcessStreamPtr] Starving Capture Pin\n"));

        // Allow KS to call us back if there is more available buffers from the client.  We
        // are ready to process more data.
        return STATUS_SUCCESS;
    }
}

NTSTATUS
USBMIDIInStartBulkTransfer(
    PMIDI_PIPE_INFORMATION pMIDIPipeInfo
    )
{
    PMIDIIN_URB_BUFFER_INFO pMIDIInBufInfo;
    NTSTATUS ntStatus;
    ULONG i;
    KIRQL irql;

    KeAcquireSpinLock(&pMIDIPipeInfo->PipeSpinLock, &irql);
    pMIDIPipeInfo->fRunning = TRUE;
    while ( !IsListEmpty( &pMIDIPipeInfo->EmptyBufferQueue )) {
        pMIDIInBufInfo = (PMIDIIN_URB_BUFFER_INFO)RemoveHeadList(&pMIDIPipeInfo->EmptyBufferQueue);
        KeReleaseSpinLock(&pMIDIPipeInfo->PipeSpinLock, irql);

        InterlockedIncrement(&pMIDIPipeInfo->ulOutstandingUrbCount);

        USBMIDIInInitializeUrbAndIrp( pMIDIInBufInfo );

        ntStatus = IoCallDriver( pMIDIPipeInfo->pNextDeviceObject,
                                 pMIDIInBufInfo->pIrp);

        if ( !NT_SUCCESS(ntStatus) ) {
            TRAP;
            pMIDIPipeInfo->fRunning = FALSE;
            return ntStatus;
        }
        KeAcquireSpinLock(&pMIDIPipeInfo->PipeSpinLock, &irql);
    }
    KeReleaseSpinLock(&pMIDIPipeInfo->PipeSpinLock, irql);

    return STATUS_SUCCESS;
}

NTSTATUS
USBMIDIInStateChange(
    PKSPIN pKsPin,
    KSSTATE OldKsState,
    KSSTATE NewKsState )
{
    PPIN_CONTEXT pPinContext = pKsPin->Context;
    PMIDI_PIN_CONTEXT pMIDIPinContext = pPinContext->pMIDIPinContext;
    PMIDIIN_PIN_CONTEXT pMIDIInPinContext = pMIDIPinContext->pMIDIInPinContext;
    PMIDIIN_USBMIDIEVENT_INFO pUSBMIDIEventInfo;
    PKSSTREAM_POINTER pKsStreamPtr;
    NTSTATUS ntStatus = STATUS_SUCCESS;
    ULONGLONG currentTime100ns;
    KIRQL irql;

    _DbgPrintF(DEBUGLVL_TERSE,("[USBMIDIInStateChange] NewKsState: %d\n", NewKsState));

    currentTime100ns = GetCurrentTime();

    if (OldKsState == KSSTATE_RUN) {
        ASSERT(currentTime100ns >= pMIDIInPinContext->ullStartTime);
        pMIDIInPinContext->ullPauseTime = currentTime100ns - pMIDIInPinContext->ullStartTime;
    }

    switch(NewKsState) {
        case KSSTATE_STOP:
            // complete any pending sysex messages
            if ( pKsStreamPtr = KsPinGetLeadingEdgeStreamPointer( pKsPin, KSSTREAM_POINTER_STATE_LOCKED )) {
                pKsStreamPtr->StreamHeader->OptionsFlags |= KSSTREAM_HEADER_OPTIONSF_DATADISCONTINUITY;
                KsStreamPointerAdvanceOffsetsAndUnlock( pKsStreamPtr,
                                                        0,
                                                        (pMIDIInPinContext->ulMIDIBytesCopiedToStream + 3) & ~3,
                                                        TRUE );
                pMIDIInPinContext->ulMIDIBytesCopiedToStream = 0;
            }

            KeAcquireSpinLock( &pPinContext->PinSpinLock, &irql );
            pMIDIInPinContext->fRunning = FALSE;
            while ( !IsListEmpty(&pMIDIInPinContext->USBMIDIEventQueue) ) {
                pUSBMIDIEventInfo = (PMIDIIN_USBMIDIEVENT_INFO)RemoveHeadList(&pMIDIInPinContext->USBMIDIEventQueue);

                //  Clear out the entry and place back on the empty queue
                RtlZeroMemory(pUSBMIDIEventInfo,sizeof(MIDIIN_USBMIDIEVENT_INFO));
                InsertTailList( &pMIDIInPinContext->USBMIDIEmptyEventQueue, &pUSBMIDIEventInfo->List );
            }
            KeReleaseSpinLock( &pPinContext->PinSpinLock, irql );
            break;
        case KSSTATE_ACQUIRE:
        case KSSTATE_PAUSE:
            KeAcquireSpinLock( &pPinContext->PinSpinLock, &irql );
            if ((NewKsState == KSSTATE_ACQUIRE) &&
                (OldKsState == KSSTATE_STOP)) {
                pMIDIInPinContext->ullPauseTime = 0;
                pMIDIInPinContext->ullStartTime = 0;
            }

            pMIDIInPinContext->fRunning = FALSE;
            while ( !IsListEmpty(&pMIDIInPinContext->USBMIDIEventQueue) ) {
                pUSBMIDIEventInfo = (PMIDIIN_USBMIDIEVENT_INFO)RemoveHeadList(&pMIDIInPinContext->USBMIDIEventQueue);

                //  Clear out the entry and place back on the empty queue
                RtlZeroMemory(pUSBMIDIEventInfo,sizeof(MIDIIN_USBMIDIEVENT_INFO));
                InsertTailList( &pMIDIInPinContext->USBMIDIEmptyEventQueue, &pUSBMIDIEventInfo->List );
            }
            KeReleaseSpinLock( &pPinContext->PinSpinLock, irql );
            break;
        case KSSTATE_RUN:
            KeAcquireSpinLock( &pPinContext->PinSpinLock, &irql );
            ASSERT(currentTime100ns >= pMIDIInPinContext->ullPauseTime);
            pMIDIInPinContext->ullStartTime = currentTime100ns - pMIDIInPinContext->ullPauseTime;
            pMIDIInPinContext->fRunning = TRUE;
            KeReleaseSpinLock( &pPinContext->PinSpinLock, irql );
            break;
    }

    return ntStatus;
}

NTSTATUS
USBMIDIPipeInit
(
    PHW_DEVICE_EXTENSION pHwDevExt,
    PKSPIN               pKsPin
)
{
    PPIN_CONTEXT pPinContext = pKsPin->Context;
    ULONG ulUrbSize = sizeof( struct _URB_BULK_OR_INTERRUPT_TRANSFER );
    PMIDIIN_URB_BUFFER_INFO pMIDIInBufInfo;
    PMIDI_PIPE_INFORMATION pMIDIPipeInfo;
    PUCHAR pData;
    PURB pUrbs;
    NTSTATUS ntStatus;
    UINT i;

    _DbgPrintF(DEBUGLVL_TERSE,("[USBMIDIPipeInit] pHwDevExt(%x) pKsPin(%x)\n",
                               pHwDevExt, pKsPin));

    ASSERT(!pHwDevExt->pMIDIPipeInfo);

    // Allocate memory for pipe info, capture buffers and urbs
    pMIDIPipeInfo = AllocMem(NonPagedPool, sizeof(MIDI_PIPE_INFORMATION) +
                                 MIDIIN_URBS_PER_PIPE * (ulUrbSize + pPinContext->ulMaxPacketSize));
    if (!pMIDIPipeInfo)
        return STATUS_INSUFFICIENT_RESOURCES;

    RtlZeroMemory(pMIDIPipeInfo,sizeof(MIDI_PIPE_INFORMATION));

    // Store in pipe info for easy access
    pMIDIPipeInfo->pHwDevExt = pHwDevExt;
    pMIDIPipeInfo->pNextDeviceObject = pPinContext->pNextDeviceObject;
    pMIDIPipeInfo->ulNumberOfPipes = pPinContext->ulNumberOfPipes;
    pMIDIPipeInfo->hPipeHandle = pPinContext->hPipeHandle;
    pMIDIPipeInfo->ulMaxPacketSize = pPinContext->ulMaxPacketSize;

    pMIDIPipeInfo->Pipes = (PUSBD_PIPE_INFORMATION)
           AllocMem( NonPagedPool, pPinContext->ulNumberOfPipes*sizeof(USBD_PIPE_INFORMATION));
    if (!pMIDIPipeInfo->Pipes) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    RtlCopyMemory( pMIDIPipeInfo->Pipes,
                   pPinContext->Pipes,
                   pPinContext->ulNumberOfPipes*sizeof(USBD_PIPE_INFORMATION) );

    // Protection for data structures
    KeInitializeSpinLock(&pMIDIPipeInfo->PipeSpinLock);

    // Setup offsets for memory pool
    pUrbs = (PURB)(pMIDIPipeInfo + 1);
    pData = (PUCHAR)pUrbs + ulUrbSize * MIDIIN_URBS_PER_PIPE;

    // Initialize the Empty Buffer list
    InitializeListHead( &pMIDIPipeInfo->EmptyBufferQueue );

    pMIDIInBufInfo = pMIDIPipeInfo->CaptureDataBufferInfo;
    for ( i=0; i<MIDIIN_URBS_PER_PIPE; i++, pMIDIInBufInfo++ ) {
        pMIDIInBufInfo->pMIDIPipeInfo = pMIDIPipeInfo;
        pMIDIInBufInfo->pKsPin        = pKsPin;
        pMIDIInBufInfo->pData         = pData + (i * pPinContext->ulMaxPacketSize );
        pMIDIInBufInfo->pUrb          = (PURB)((PUCHAR)pUrbs + (ulUrbSize*i));
        pMIDIInBufInfo->pIrp          = IoAllocateIrp( pPinContext->pNextDeviceObject->StackSize, FALSE );

        // cleanup all irps and pipe info on failure
        if (!pMIDIInBufInfo->pIrp) {
            UINT j;

            pMIDIInBufInfo = pMIDIPipeInfo->CaptureDataBufferInfo;
            for ( j=0; j<i; j++, pMIDIInBufInfo++ ) {
                if (pMIDIInBufInfo->pIrp) {
                    IoFreeIrp( pMIDIInBufInfo->pIrp );
                }
            }
            FreeMem( pMIDIPipeInfo );
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        InsertTailList( &pMIDIPipeInfo->EmptyBufferQueue, &pMIDIInBufInfo->List );
    }

    // Initialize Worker item, object and list for potential error recovery
    ExInitializeWorkItem( &pMIDIPipeInfo->RequeueUrbWorkItem,
                          USBMIDIInRequeueWorkItem,
                          pMIDIPipeInfo );

    ntStatus = KsRegisterCountedWorker( CriticalWorkQueue,
                                        &pMIDIPipeInfo->RequeueUrbWorkItem,
                                        &pMIDIPipeInfo->RequeueUrbWorkerObject );
    if (!NT_SUCCESS(ntStatus)) {
        // cleanup all irps and pipe info on failure
        pMIDIInBufInfo = pMIDIPipeInfo->CaptureDataBufferInfo;
        for ( i=0; i<MIDIIN_URBS_PER_PIPE; i++, pMIDIInBufInfo++ ) {
            ASSERT( pMIDIInBufInfo->pIrp );
            IoFreeIrp( pMIDIInBufInfo->pIrp );
        }
        FreeMem( pMIDIPipeInfo );
        return ntStatus;
    }

    // Initialize Pin Starvation Event
    KeInitializeEvent( &pMIDIPipeInfo->PipeStarvationEvent, NotificationEvent, FALSE );

    // Initialize the Pin List
    InitializeListHead(&pMIDIPipeInfo->MIDIInActivePinList);

    // Finally, add the pipe info to the device context
    if (NT_SUCCESS(ntStatus)) {
        pHwDevExt->pMIDIPipeInfo = pMIDIPipeInfo;
    }

    return ntStatus;
}

PMIDI_PIPE_INFORMATION
USBMIDIInGetPipeInfo( PKSPIN pKsPin )
{
    // Find the device that this pin is created from
    PKSFILTER pKsFilter = NULL;
    PKSFILTERFACTORY pKsFilterFactory = NULL;
    PKSDEVICE pKsDevice = NULL;
    PHW_DEVICE_EXTENSION pHwDevExt = NULL;
    NTSTATUS ntStatus;

    if (pKsPin) {
        if (pKsFilter = KsPinGetParentFilter( pKsPin )) {
            if (pKsFilterFactory = KsFilterGetParentFilterFactory( pKsFilter )) {
                if (pKsDevice = KsFilterFactoryGetParentDevice( pKsFilterFactory )) {
                    pHwDevExt = pKsDevice->Context;
                }
            }
        }
    }

    if (!pHwDevExt) {
        return NULL;
    }

    // If no pipe information already, initialize new pipeinfo structure
    if (!pHwDevExt->pMIDIPipeInfo) {
        ntStatus = USBMIDIPipeInit( pHwDevExt, pKsPin );
    }

    return pHwDevExt->pMIDIPipeInfo;
}

NTSTATUS
USBMIDIInFreePipeInfo( PMIDI_PIPE_INFORMATION pMIDIPipeInfo )
{
    PMIDIIN_URB_BUFFER_INFO pMIDIInBufInfo;
    UINT i;

    // Clear out all pending KS workitems by unregistering the worker routine
    KsUnregisterWorker( pMIDIPipeInfo->RequeueUrbWorkerObject );

    // Make sure that no URBs are outstanding
    pMIDIPipeInfo->fRunning = FALSE;
    AbortMIDIInPipe( pMIDIPipeInfo );

    // Free the allocated irps
    pMIDIInBufInfo = pMIDIPipeInfo->CaptureDataBufferInfo;
    for ( i=0; i<MIDIIN_URBS_PER_PIPE; i++, pMIDIInBufInfo++ ) {
        IoFreeIrp( pMIDIInBufInfo->pIrp );
    }

    // Free the allocated pipes
    FreeMem( pMIDIPipeInfo->Pipes );

    // No more references to the pipe, so free context information
    pMIDIPipeInfo->pHwDevExt->pMIDIPipeInfo = NULL;
    FreeMem( pMIDIPipeInfo );

    return STATUS_SUCCESS;
}

NTSTATUS
USBMIDIInRemovePinFromPipe
(
    IN PMIDI_PIPE_INFORMATION pMidiPipeInfo,
    IN PKSPIN pKsPin
)
{
    PMIDIIN_PIN_LISTENTRY pMIDIInPinListEntry;
    PLIST_ENTRY ple;
    BOOL fListEmpty;
    NTSTATUS ntStatus = STATUS_SUCCESS;
    KIRQL irql;

    KeAcquireSpinLock( &pMidiPipeInfo->PipeSpinLock, &irql );

    //  Remove pin from list of ones that are serviced by this endpoint
    for(ple = pMidiPipeInfo->MIDIInActivePinList.Flink;
        ple != &pMidiPipeInfo->MIDIInActivePinList;
        ple = ple->Flink)
    {
        pMIDIInPinListEntry = CONTAINING_RECORD(ple, MIDIIN_PIN_LISTENTRY, List);
        if (pMIDIInPinListEntry->pKsPin == pKsPin) {
            RemoveEntryList(&pMIDIInPinListEntry->List);
            FreeMem ( pMIDIInPinListEntry );
            break;
        }
    }

    fListEmpty = IsListEmpty(&pMidiPipeInfo->MIDIInActivePinList);

    KeReleaseSpinLock( &pMidiPipeInfo->PipeSpinLock, irql );

    //
    //  USBMIDIInFreePipeInfo( pMidiPipeInfo ) is called upon shutdown of device
    //  or a change in the selected interface
    //

    return ntStatus;
}

NTSTATUS
USBMIDIInAddPinToPipe
(
    IN PMIDI_PIPE_INFORMATION pMIDIPipeInfo,
    IN PKSPIN pKsPin
)
{
    PMIDIIN_PIN_LISTENTRY pMIDIInPinListEntry;
    BOOL fListEmpty;
    KIRQL irql;
    NTSTATUS ntStatus = STATUS_SUCCESS;

    pMIDIInPinListEntry =
        AllocMem(NonPagedPool, sizeof(MIDIIN_PIN_LISTENTRY));
    if (!pMIDIInPinListEntry) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    pMIDIInPinListEntry->pKsPin = pKsPin;

    KeAcquireSpinLock( &pMIDIPipeInfo->PipeSpinLock, &irql );

    fListEmpty = IsListEmpty(&pMIDIPipeInfo->MIDIInActivePinList);

    // Add this pin to the list of ones that are serviceable by this endpoint
    InsertTailList( &pMIDIPipeInfo->MIDIInActivePinList, &pMIDIInPinListEntry->List );

    KeReleaseSpinLock( &pMIDIPipeInfo->PipeSpinLock, irql );

    //  If this is the first Pin added to the pipe, start the data pump
    if (fListEmpty) {
        ntStatus = USBMIDIInStartBulkTransfer( pMIDIPipeInfo );
        if (!NT_SUCCESS(ntStatus)) {
            USBMIDIInRemovePinFromPipe( pMIDIPipeInfo, pKsPin);
        }
    }

    return ntStatus;
}

NTSTATUS
USBMIDIInStreamInit( IN PKSPIN pKsPin )
{
    PPIN_CONTEXT pPinContext = pKsPin->Context;
    PMIDI_PIN_CONTEXT pMIDIPinContext = pPinContext->pMIDIPinContext;
    PMIDIIN_PIN_CONTEXT pMIDIInPinContext;
    NTSTATUS ntStatus = STATUS_SUCCESS;
    UINT i;

    // Allocate Capture Context
    pMIDIInPinContext = pMIDIPinContext->pMIDIInPinContext =
        AllocMem(NonPagedPool, sizeof(MIDIIN_PIN_CONTEXT));
    if (!pMIDIInPinContext)
        return STATUS_INSUFFICIENT_RESOURCES;

    RtlZeroMemory( pMIDIInPinContext, sizeof(MIDIIN_PIN_CONTEXT) );

    KsAddItemToObjectBag(pKsPin->Bag, pMIDIInPinContext, FreeMem);

    // Set initial running flag to FALSE
    pMIDIInPinContext->fRunning = FALSE;

    // Set initial running flag to FALSE
    pMIDIInPinContext->fProcessing = FALSE;

    // No bytes copied to stream yet
    pMIDIInPinContext->ulMIDIBytesCopiedToStream = 0;

    // Initialize the Event lists
    InitializeListHead( &pMIDIInPinContext->USBMIDIEventQueue );
    InitializeListHead( &pMIDIInPinContext->USBMIDIEmptyEventQueue );

    for ( i=0; i<MIDIIN_EVENTS_PER_PIN; i++) {
        InsertTailList( &pMIDIInPinContext->USBMIDIEmptyEventQueue, &pMIDIInPinContext->USBMIDIEventInfo[i].List );
    }

    // Initialize Worker item for turning the Gate on when new data arrives from the device
    ExInitializeWorkItem( &pMIDIInPinContext->GateOnWorkItem,
                          USBMIDIInGateOnWorkItem,
                          pKsPin );

    ntStatus = KsRegisterCountedWorker( CriticalWorkQueue,
                                        &pMIDIInPinContext->GateOnWorkItem,
                                        &pMIDIInPinContext->GateOnWorkerObject );
    if (!NT_SUCCESS(ntStatus))
        return ntStatus;

    // Disable Processing on the pin until data is available.
    KsGateTurnInputOff( KsPinGetAndGate(pKsPin) );

    // Get pipe info for this pin
    pMIDIInPinContext->pMIDIPipeInfo = USBMIDIInGetPipeInfo( pKsPin );
    if (!pMIDIInPinContext->pMIDIPipeInfo)
        return STATUS_INSUFFICIENT_RESOURCES;

    // Add new pin to pipe info
    ntStatus = USBMIDIInAddPinToPipe( pMIDIInPinContext->pMIDIPipeInfo, pKsPin );

    return ntStatus;
}

NTSTATUS
USBMIDIInStreamClose( PKSPIN pKsPin )
{
    PPIN_CONTEXT pPinContext = pKsPin->Context;
    PMIDI_PIN_CONTEXT pMIDIPinContext = pPinContext->pMIDIPinContext;
    PMIDIIN_PIN_CONTEXT pMIDIInPinContext = pMIDIPinContext->pMIDIInPinContext;
    PMIDI_PIPE_INFORMATION pMIDIPipeInfo = pMIDIInPinContext->pMIDIPipeInfo;

    _DbgPrintF(DEBUGLVL_TERSE,("[USBMIDIInStreamClose] pin %d\n",pKsPin->Id));

    KsUnregisterWorker( pMIDIInPinContext->GateOnWorkerObject );

    USBMIDIInRemovePinFromPipe( pMIDIPipeInfo, pKsPin);

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\drivers\usbaudio.2\midiout.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 2000
//
//  File:       midiout.c
//
//--------------------------------------------------------------------------

#include "common.h"

#define OUTSTANDING_URB_HIGHWATERMARK 10

BYTE
GenerateCodeIndexNumber (
    IN PMIDI_PIN_CONTEXT pMIDIPinContext,
    PBYTE MusicData, // only operate on 3 bytes at a time
    ULONG ulMusicDataBytesLeft,
    PULONG pulBytesUsed,
    BOOL fSysEx,
    BYTE bRunningStatus,
    PBOOL bUsedRunningStatusByte
)
{
    PMIDIOUT_PIN_CONTEXT pMIDIOutPinContext = pMIDIPinContext->pMIDIOutPinContext;
    BYTE StatusByte;
    BYTE CodeIndexNumber = 0xF;  // set it to something
    BYTE RealTimeByte;
    UINT i;

    StatusByte = *MusicData;
    *pulBytesUsed = 0;

    ASSERT(ulMusicDataBytesLeft); // guaranteed that at least one byte is valid
    ASSERT(!pMIDIOutPinContext->ulBytesCached); // there should be no bytes cached at this time

    if (!IS_STATUS(StatusByte) && !fSysEx) {
        StatusByte = bRunningStatus;
        *bUsedRunningStatusByte = TRUE;
    }
    else {
        *bUsedRunningStatusByte = FALSE;
    }

    // Check if any of the three bytes contain EOX making sure that it is ok
    // to touch the data by checking how many bytes are left in the stream
    if ( (ulMusicDataBytesLeft > 1) && IS_EOX( *(MusicData+1) ) ) {
        _DbgPrintF( DEBUGLVL_VERBOSE, ("Found EOX - 2nd byte\n"));
        CodeIndexNumber = 0x6;
        *pulBytesUsed = 2;
    }
    else if ( (ulMusicDataBytesLeft > 2) && IS_EOX( *(MusicData+2) ) ) {
        _DbgPrintF( DEBUGLVL_VERBOSE, ("Found EOX - 3rd byte\n"));
        CodeIndexNumber = 0x7;
        *pulBytesUsed = 3;
    }
    else if ( (ulMusicDataBytesLeft > 1) && IS_REALTIME( *(MusicData+1) ) ) {
        _DbgPrintF( DEBUGLVL_VERBOSE, ("Found RealTime - 2nd byte\n"));
        CodeIndexNumber = 0xF;
        *pulBytesUsed = 1;

        // exchange first two bytes
        RealTimeByte = *(MusicData+1);
        *(MusicData+1) = *(MusicData);
        *(MusicData) = RealTimeByte;
    }
    else if ( (ulMusicDataBytesLeft > 2) && IS_REALTIME( *(MusicData+2) ) ) {
        _DbgPrintF( DEBUGLVL_VERBOSE, ("Found RealTime - 3rd byte\n"));
        CodeIndexNumber = 0xF;
        *pulBytesUsed = 1;

        // save real time message, slide byte 1 and 2, and restore real time
        // message in vacated byte 1.
        RealTimeByte = *(MusicData+2);
        *(MusicData+2) = *(MusicData+1);
        *(MusicData+1) = *(MusicData);
        *(MusicData) = RealTimeByte;
    }
    else if ( IS_SYSTEM(StatusByte) || IS_DATA_BYTE(StatusByte) || fSysEx ) {
        if (IS_EOX( StatusByte ) || (StatusByte == MIDI_TUNEREQ) ) {
            _DbgPrintF( DEBUGLVL_VERBOSE, ("Found EOX - 1st byte\n"));
            CodeIndexNumber = 0x5;
            *pulBytesUsed = 1;
        } else if( IS_REALTIME(StatusByte) ) {
            _DbgPrintF( DEBUGLVL_VERBOSE, ("Found RealTime - 1st byte\n"));
            CodeIndexNumber = 0xF;
            *pulBytesUsed = 1;
        } else if ( (StatusByte == MIDI_SONGPP) ) {
            // ||   (StatusByte == 0xF4)  // ignore undefined messages for now.
            // ||   (StatusByte == 0xF5) ) {
            CodeIndexNumber = 0x3;
            ASSERT(ulMusicDataBytesLeft >= 3);
            *pulBytesUsed = 3;
        } else if ( (StatusByte == MIDI_MTC) ||
                    (StatusByte == MIDI_SONGS) ) {
            CodeIndexNumber = 0x2;
            *pulBytesUsed = 2;
        }
        // Start or continuation of SysEx
        else if ( fSysEx || IS_SYSEX(StatusByte) || IS_DATA_BYTE(StatusByte) ) {
            _DbgPrintF( DEBUGLVL_VERBOSE, ("SysEx\n"));

            // Store the extra bytes to be played when there is a complete 3-byte sysex
            if (ulMusicDataBytesLeft < 3 ) {
                _DbgPrintF( DEBUGLVL_VERBOSE, ("[GenerateCodeIndexNumber] Caching bytes %d\n",
                                             ulMusicDataBytesLeft));
                pMIDIOutPinContext->ulBytesCached = ulMusicDataBytesLeft;
                for (i = 0; i < ulMusicDataBytesLeft; i++) {
                    pMIDIOutPinContext->CachedBytes[i];
                }
                *pulBytesUsed = 0;
            }
            else {
                CodeIndexNumber = 0x4;
                *pulBytesUsed = 3;
            }
        }
        else {
            _DbgPrintF( DEBUGLVL_VERBOSE, ("Invalid MIDI Byte %x\n", StatusByte));
            //ASSERT(0);
        }
    }
    else if ( IS_STATUS(StatusByte) ) {
        CodeIndexNumber = StatusByte >> 4;
        if ( (StatusByte < MIDI_PCHANGE) || (StatusByte >= MIDI_PBEND) ) {
            *pulBytesUsed = 3;
        }
        else {
            *pulBytesUsed = 2;
        }

        //  Adjust bytes used because of running status
        if (*bUsedRunningStatusByte) {
            (*pulBytesUsed)--;
        }
    }
    else {
        _DbgPrintF( DEBUGLVL_VERBOSE, ("Invalid MIDI Byte %x\n", StatusByte));
        //ASSERT(0);
    }

    //
    //  Cache the running status
    //
    if ( (StatusByte >= MIDI_NOTEOFF) && (StatusByte < MIDI_CLOCK) ) {
        pMIDIOutPinContext->bRunningStatus =
            (BYTE)((StatusByte < MIDI_SYSX) ? StatusByte : 0);
    }

    *pulBytesUsed = min(*pulBytesUsed, ulMusicDataBytesLeft);

    return CodeIndexNumber;
}

USBMIDIEVENTPACKET
CreateUSBMIDIEventPacket (
    IN PMIDI_PIN_CONTEXT pMIDIPinContext,
    LPBYTE pMIDIBytes,
    ULONG ulMusicDataBytesLeft,
    PULONG pulBytesUsed,
    BOOL fSysEx
)
{
    PMIDIOUT_PIN_CONTEXT pMIDIOutPinContext = pMIDIPinContext->pMIDIOutPinContext;
    USBMIDIEVENTPACKET MIDIPacket;
    BYTE bRunningStatus;
    BOOL bUsedRunningStatusByte;
    ULONG ulBytesCached = 0;

    MIDIPacket.RawBytes = 0;

    // Fill in the Cable Number
    MIDIPacket.ByteLayout.CableNumber = (UCHAR)pMIDIPinContext->ulCableNumber;

    // Now time for a little magic.  Since the MusicHdr is no longer important,
    // place the cached bytes over the top of the MusicHdr and reset the head
    // pointer to the cached bytes.
    ASSERT(pMIDIOutPinContext->ulBytesCached <= MAX_NUM_CACHED_MIDI_BYTES);
    if (pMIDIOutPinContext->ulBytesCached > 0 ) {
        _DbgPrintF( DEBUGLVL_VERBOSE, ("[CreateUSBMIDIEventPacket] Using cached bytes %d\n",
                                     pMIDIOutPinContext->ulBytesCached));

        if (pMIDIOutPinContext->ulBytesCached > 1 ) {
            pMIDIBytes = pMIDIBytes--;
            *pMIDIBytes = pMIDIOutPinContext->CachedBytes[1];
        }

        pMIDIBytes = pMIDIBytes--;
        *pMIDIBytes = pMIDIOutPinContext->CachedBytes[0];

        // keep track of how many bytes were added to the stream.
        ulBytesCached = pMIDIOutPinContext->ulBytesCached;
        pMIDIOutPinContext->ulBytesCached = 0;
    }

    // Grab locally because it is changed in GenerateCodeIndexNumber and we want
    // the original value below
    bRunningStatus = pMIDIOutPinContext->bRunningStatus;

    // Fill in the Code Index Number
    MIDIPacket.ByteLayout.CodeIndexNumber = GenerateCodeIndexNumber(pMIDIPinContext,
                                                                    pMIDIBytes,
                                                                    ulMusicDataBytesLeft,
                                                                    pulBytesUsed,
                                                                    fSysEx,
                                                                    bRunningStatus,
                                                                    &bUsedRunningStatusByte);

    // Fill in the MIDI 1.0 bytes
    if (*pulBytesUsed > 0) {
        UINT i = 0;
        if (bUsedRunningStatusByte) {
            MIDIPacket.ByteLayout.MIDI_0 = bRunningStatus;
        }
        else {
            MIDIPacket.ByteLayout.MIDI_0 = *(pMIDIBytes);
            i++;
        }

        if (*pulBytesUsed > i) {
            MIDIPacket.ByteLayout.MIDI_1 = *(pMIDIBytes+i);
            i++;

            if (*pulBytesUsed > i) {
                MIDIPacket.ByteLayout.MIDI_2 = *(pMIDIBytes+i);
            }
        }
    }

    // don't report the cached bytes as used
    *pulBytesUsed = *pulBytesUsed - ulBytesCached;

    _DbgPrintF( DEBUGLVL_BLAB, ("MIDIEventPacket = 0x%08lx, ulBytesUsed = 0x%08lx\n",
                                  MIDIPacket, *pulBytesUsed));
    return MIDIPacket;
}

NTSTATUS
USBMIDIBulkCompleteCallback (
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP pIrp,
    PKSSTREAM_POINTER pKsStreamPtr )
{
    PPIN_CONTEXT pPinContext = pKsStreamPtr->Pin->Context;
    PMIDI_PIN_CONTEXT pMIDIPinContext = pPinContext->pMIDIPinContext;
    PMIDIOUT_PIN_CONTEXT pMIDIOutPinContext = pMIDIPinContext->pMIDIOutPinContext;
    PURB pUrb = pKsStreamPtr->Context;
    KIRQL irql;
    NTSTATUS ntStatus;

    ntStatus = pIrp->IoStatus.Status;
    if (!NT_SUCCESS(ntStatus)) {
        _DbgPrintF( DEBUGLVL_BLAB, ("[USBMIDIBulkCompleteCallback] ntStatus = 0x%08lx\n", ntStatus));
    }

    KeAcquireSpinLock( &pPinContext->PinSpinLock, &irql );
    if ( 0 == InterlockedDecrement(&pPinContext->ulOutstandingUrbCount) ) {
        KeSetEvent( &pPinContext->PinStarvationEvent, 0, FALSE );
    } else if (pPinContext->ulOutstandingUrbCount < OUTSTANDING_URB_HIGHWATERMARK) {
        KeSetEvent( &pMIDIOutPinContext->PinSaturationEvent, 0, FALSE );
    }
    KeReleaseSpinLock( &pPinContext->PinSpinLock, irql );

    // Free our URB storage, decend the links
    while (pUrb) {
        PURB pUrbNext;

        pUrbNext = pUrb->UrbBulkOrInterruptTransfer.UrbLink;
        FreeMem(pUrb->UrbBulkOrInterruptTransfer.TransferBuffer); // pUSBMIDIEventPacket;
        FreeMem(pUrb);
        pUrb = pUrbNext;
    }

    // Free Irp
    IoFreeIrp( pIrp );

    // Delete the cloned stream pointer
    KsStreamPointerDelete( pKsStreamPtr );

    return ( STATUS_MORE_PROCESSING_REQUIRED );
}

PURB CreateMIDIBulkUrb(
    PPIN_CONTEXT pPinContext,
    ULONG TransferDirection,
    PUSBMIDIEVENTPACKET pUSBMIDIEventPacket
)
{
    PURB pUrb;
    ULONG ulUrbSize = sizeof( struct _URB_BULK_OR_INTERRUPT_TRANSFER );

    pUrb = AllocMem( NonPagedPool, ulUrbSize );
    if (!pUrb) {
        return pUrb;
    }

    RtlZeroMemory(pUrb, ulUrbSize);

    pUrb->UrbBulkOrInterruptTransfer.Hdr.Length = (USHORT) sizeof( struct _URB_BULK_OR_INTERRUPT_TRANSFER );
    pUrb->UrbBulkOrInterruptTransfer.Hdr.Function = URB_FUNCTION_BULK_OR_INTERRUPT_TRANSFER;
    pUrb->UrbBulkOrInterruptTransfer.PipeHandle = pPinContext->hPipeHandle;
    pUrb->UrbBulkOrInterruptTransfer.TransferFlags = TransferDirection;
    // short packet is not treated as an error.
    pUrb->UrbBulkOrInterruptTransfer.TransferFlags |= USBD_SHORT_TRANSFER_OK;
    pUrb->UrbBulkOrInterruptTransfer.UrbLink = NULL;
    pUrb->UrbBulkOrInterruptTransfer.TransferBufferMDL = NULL;
    pUrb->UrbBulkOrInterruptTransfer.TransferBuffer = pUSBMIDIEventPacket;
    pUrb->UrbBulkOrInterruptTransfer.TransferBufferLength = (int) pPinContext->ulMaxPacketSize;

    DbgLog("MOData", *((LPDWORD)pUSBMIDIEventPacket),
                     *((LPDWORD)pUSBMIDIEventPacket+1),
                     *((LPDWORD)pUSBMIDIEventPacket+2),
                     *((LPDWORD)pUSBMIDIEventPacket+3) );
    DbgLog("MOData1", *((LPDWORD)pUSBMIDIEventPacket+4),
                      *((LPDWORD)pUSBMIDIEventPacket+5),
                      *((LPDWORD)pUSBMIDIEventPacket+6),
                      *((LPDWORD)pUSBMIDIEventPacket+7) );
    DbgLog("MOData2", *((LPDWORD)pUSBMIDIEventPacket+8),
                      *((LPDWORD)pUSBMIDIEventPacket+9),
                      *((LPDWORD)pUSBMIDIEventPacket+10),
                      *((LPDWORD)pUSBMIDIEventPacket+11) );
    DbgLog("MOData3", *((LPDWORD)pUSBMIDIEventPacket+12),
                      *((LPDWORD)pUSBMIDIEventPacket+13),
                      *((LPDWORD)pUSBMIDIEventPacket+14),
                      *((LPDWORD)pUSBMIDIEventPacket+15) );

    return pUrb;
}

NTSTATUS
SendBulkMIDIRequest(
    IN PKSSTREAM_POINTER pKsStreamPtr,
    PKSMUSICFORMAT MusicHdr,
    PULONG pulBytesConsumed
)
{
    PPIN_CONTEXT pPinContext = pKsStreamPtr->Pin->Context;
    PMIDI_PIN_CONTEXT pMIDIPinContext = pPinContext->pMIDIPinContext;
    PMIDIOUT_PIN_CONTEXT pMIDIOutPinContext = pMIDIPinContext->pMIDIOutPinContext;
    PKSSTREAM_POINTER pKsCloneStreamPtr;
    PUSBMIDIEVENTPACKET pUSBMIDIEventPacket;
    ULONG ulPacketSize;
    ULONG ulPacketOffset;
    LPBYTE pMIDIBytes;
    ULONG ulBytesUsedForPacket;
    ULONG ulBytesConsumedInStream = sizeof(KSMUSICFORMAT);
    ULONG ulBytesLeftInMusicHdr;
    BOOL bSysEx = FALSE;
    PIO_STACK_LOCATION nextStack;
    PURB pUrb;
    PIRP pIrp;
    KIRQL irql;
    NTSTATUS ntStatus = STATUS_SUCCESS;

    // Initial value
    *pulBytesConsumed = 0;

    // Get a pointer to the MIDI data
    pMIDIBytes = (LPBYTE)(MusicHdr+1);
    ulBytesLeftInMusicHdr = MusicHdr->ByteCount;

    ASSERT(ulBytesLeftInMusicHdr < 0xFFFF0000);  // sanity check for now

    _DbgPrintF( DEBUGLVL_BLAB, ("ulBytesLeft = 0x%08lx\n",ulBytesLeftInMusicHdr));
    while (ulBytesLeftInMusicHdr) {

        if ( !NT_SUCCESS( KsStreamPointerClone( pKsStreamPtr, NULL, 0, &pKsCloneStreamPtr ) ) ) {
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        pIrp = IoAllocateIrp( pPinContext->pNextDeviceObject->StackSize, FALSE );
        if ( !pIrp ) {
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        ulPacketSize = pPinContext->ulMaxPacketSize;
        ulPacketOffset = 0;

        // Allocate USBMIDI Event Packet
        pUSBMIDIEventPacket = AllocMem( NonPagedPool, ulPacketSize );
        if ( !pUSBMIDIEventPacket ) {
            IoFreeIrp(pIrp);
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        RtlZeroMemory(pUSBMIDIEventPacket, ulPacketSize);

        while (ulPacketSize && ulBytesLeftInMusicHdr) {
            *(pUSBMIDIEventPacket+ulPacketOffset) =
                                   CreateUSBMIDIEventPacket( pMIDIPinContext,
                                                             pMIDIBytes,
                                                             ulBytesLeftInMusicHdr,
                                                             &ulBytesUsedForPacket,
                                                             bSysEx );

            // Must be an error in the stream or can't get enough sysex data for a 3-byte message
            if (!ulBytesUsedForPacket) {
                KsStreamPointerDelete( pKsCloneStreamPtr );
                FreeMem(pUSBMIDIEventPacket);
                IoFreeIrp(pIrp);
                return STATUS_SUCCESS;
            }

            // Update USB MIDI packet offsets
            ulPacketOffset++;
            ulPacketSize -= sizeof(USBMIDIEVENTPACKET);

            // Update the stream position
            pMIDIBytes += ulBytesUsedForPacket;
            ulBytesConsumedInStream += ulBytesUsedForPacket;
            ulBytesLeftInMusicHdr -= min(ulBytesUsedForPacket,ulBytesLeftInMusicHdr);
            _DbgPrintF( DEBUGLVL_BLAB, ("ulBytesLeft = 0x%08lx\n",ulBytesLeftInMusicHdr));

            ASSERT(ulBytesLeftInMusicHdr < 0xFFFF0000);  // sanity check for now

            // If there are bytes left we must be in SysEx mode
            bSysEx = TRUE;
        }

        pUrb = CreateMIDIBulkUrb(pPinContext, USBD_TRANSFER_DIRECTION_OUT, pUSBMIDIEventPacket);
        if ( !pUrb ) {
            FreeMem(pUSBMIDIEventPacket);
            IoFreeIrp(pIrp);
            return STATUS_INSUFFICIENT_RESOURCES;
        }
        pKsCloneStreamPtr->Context = pUrb;

        pIrp->IoStatus.Status = STATUS_SUCCESS;

        nextStack = IoGetNextIrpStackLocation(pIrp);
        ASSERT(nextStack != NULL);

        nextStack->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
        nextStack->Parameters.Others.Argument1 = pUrb;
        nextStack->Parameters.DeviceIoControl.IoControlCode = IOCTL_INTERNAL_USB_SUBMIT_URB;

        // failure to allocate, clean up and return failure
        if (!pUSBMIDIEventPacket || !pUrb) {
            pUrb = nextStack->Parameters.Others.Argument1;
            while (pUrb) {
                PURB pUrbNext;

                pUrbNext = pUrb->UrbBulkOrInterruptTransfer.UrbLink;
                FreeMem(pUrb->UrbBulkOrInterruptTransfer.TransferBuffer); // pUSBMIDIEventPacket;
                FreeMem(pUrb);
                pUrb = pUrbNext;
            }
            IoFreeIrp(pIrp);
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        _DbgPrintF( DEBUGLVL_BLAB, ("Pipe = 0x%08lx, pUrb = 0x%08lx\n",
                                      pUrb->UrbBulkOrInterruptTransfer.PipeHandle,
                                      nextStack->Parameters.Others.Argument1));

        IoSetCompletionRoutine ( pIrp, USBMIDIBulkCompleteCallback, pKsCloneStreamPtr, TRUE, TRUE, TRUE );

        InterlockedIncrement( &pPinContext->ulOutstandingUrbCount );

        ntStatus = IoCallDriver( pPinContext->pNextDeviceObject, pIrp );
        if (NT_ERROR(ntStatus)) {
            _DbgPrintF( DEBUGLVL_TERSE, ("SendBulkMIDIRequest failed with status 0x%08lx\n",ntStatus));
            return ntStatus;
        }

        KeAcquireSpinLock( &pPinContext->PinSpinLock, &irql );
        if (pPinContext->ulOutstandingUrbCount >= OUTSTANDING_URB_HIGHWATERMARK) {
            KeResetEvent( &pMIDIOutPinContext->PinSaturationEvent );
            KeReleaseSpinLock( &pPinContext->PinSpinLock, irql );

            DbgLog("MOWait", pPinContext, pPinContext->ulOutstandingUrbCount, 0, 0 );

            KeWaitForSingleObject( &pMIDIOutPinContext->PinSaturationEvent,
                                   Executive,
                                   KernelMode,
                                   FALSE,
                                   NULL );
        }
        else {
            KeReleaseSpinLock( &pPinContext->PinSpinLock, irql );
        }

    }  // while (ulBytesLeftInMusicHdr)

    *pulBytesConsumed = ulBytesConsumedInStream;

    return ntStatus;
}

NTSTATUS
USBMIDIOutProcessStreamPtr( IN PKSPIN pKsPin )
{
    PPIN_CONTEXT pPinContext = pKsPin->Context;
    PMIDI_PIN_CONTEXT pMIDIPinContext = pPinContext->pMIDIPinContext;
    PKSSTREAM_POINTER pKsStreamPtr, pKsCloneStreamPtr;
    PKSSTREAM_POINTER_OFFSET pKsStreamPtrOffsetIn;
    PKSMUSICFORMAT MusicHdr;
    ULONG ulMusicFrameSize;
    ULONG ulBytesConsumed;
    NTSTATUS ntStatus = STATUS_SUCCESS;

    // Get the next Stream pointer from queue
    pKsStreamPtr = KsPinGetLeadingEdgeStreamPointer( pKsPin, KSSTREAM_POINTER_STATE_LOCKED );
    if ( !pKsStreamPtr ) {
        _DbgPrintF(DEBUGLVL_VERBOSE,("[USBMIDIOutProcessStreamPtr] Leading edge is NULL\n"));
        return STATUS_SUCCESS;
    }

    // Get a pointer to the data information from the stream pointer
    pKsStreamPtrOffsetIn = &pKsStreamPtr->OffsetIn;

    while ( pKsStreamPtrOffsetIn->Remaining > sizeof(KSMUSICFORMAT) ) {

        // Clone Stream pointer to keep queue moving.
        if ( NT_SUCCESS( KsStreamPointerClone( pKsStreamPtr, NULL, 0, &pKsCloneStreamPtr ) ) ) {

            MusicHdr = (PKSMUSICFORMAT)pKsStreamPtrOffsetIn->Data;
            ulMusicFrameSize = sizeof(KSMUSICFORMAT) + ((MusicHdr->ByteCount + 3) & ~3);

            if (pKsStreamPtrOffsetIn->Count < sizeof(KSMUSICFORMAT)) {
                _DbgPrintF(DEBUGLVL_TERSE,("[USBMIDIPinProcess] not enough data for PKSMUSICFORMAT\n"));
                KsStreamPointerDelete( pKsCloneStreamPtr );
                break;
            }
            else {
                // Consume as much of this MusicHdr as possible
                ntStatus = SendBulkMIDIRequest( pKsCloneStreamPtr,
                                                MusicHdr,
                                                &ulBytesConsumed ); // including KSMUSICFORMAT
            }

            DbgLog("MOProc", pKsCloneStreamPtr, MusicHdr, ulBytesConsumed, ulMusicFrameSize);

            // All bytes of this music header are consumed, move on to the
            // next music header
            if (ulMusicFrameSize == ((ulBytesConsumed + 3) & ~3) ) {
                pKsStreamPtrOffsetIn->Remaining -= ulMusicFrameSize;
                pKsStreamPtrOffsetIn->Data += ulMusicFrameSize;
            }
            else {
                _DbgPrintF(DEBUGLVL_TERSE,("[USBMIDIPinProcess] All bytes of this music header were not consumed\n"));
                //ASSERT(0); // shouldn't get here, but we should continue
                pKsStreamPtrOffsetIn->Remaining -= ulMusicFrameSize;
                pKsStreamPtrOffsetIn->Data += ulMusicFrameSize;
            }

            // Delete the stream pointer to release the buffer.
            KsStreamPointerDelete( pKsCloneStreamPtr );

        }
        else {
            _DbgPrintF(DEBUGLVL_TERSE,("[USBMIDIPinProcess] couldn't allocate clone\n"));
            break;
        }
    }

    // Unlock the stream pointer. This will really only unlock after last clone is deleted.
    KsStreamPointerUnlock( pKsStreamPtr, TRUE );

    return ntStatus;
}

NTSTATUS
USBMIDIOutStateChange(
    PKSPIN pKsPin,
    KSSTATE OldKsState,
    KSSTATE NewKsState )
{
    PPIN_CONTEXT pPinContext = pKsPin->Context;

    _DbgPrintF(DEBUGLVL_TERSE,("[USBMIDIOutStateChange] NewKsState: %d\n", NewKsState));

    switch(NewKsState) {
        case KSSTATE_STOP:
            USBMIDIOutPinWaitForStarvation( pKsPin );
            _DbgPrintF(DEBUGLVL_TERSE,("[USBMIDIOutStateChange] Finished Stop\n"));
            break;

        case KSSTATE_ACQUIRE:
        case KSSTATE_PAUSE:
            USBMIDIOutPinWaitForStarvation( pKsPin );
            _DbgPrintF(DEBUGLVL_TERSE,("[USBMIDIOutStateChange] Finished Acquire or Pause\n"));
            break;
        case KSSTATE_RUN:
        default:
            break;
    }

    return STATUS_SUCCESS;
}

NTSTATUS
USBMIDIOutStreamInit( PKSPIN pKsPin )
{
    PPIN_CONTEXT pPinContext = pKsPin->Context;
    PMIDI_PIN_CONTEXT pMIDIPinContext = pPinContext->pMIDIPinContext;

    pMIDIPinContext->pMIDIOutPinContext = AllocMem( NonPagedPool, sizeof(MIDIOUT_PIN_CONTEXT));
    if ( !pMIDIPinContext->pMIDIOutPinContext ) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    // Bag the context for easy cleanup.
    KsAddItemToObjectBag(pKsPin->Bag, pMIDIPinContext->pMIDIOutPinContext, FreeMem);

    // Initialize Pin Starvation Event
    KeInitializeEvent( &pMIDIPinContext->pMIDIOutPinContext->PinSaturationEvent, NotificationEvent, FALSE );

    // Initialize the MIDI byte cache and running status
    pMIDIPinContext->pMIDIOutPinContext->ulBytesCached = 0;
    pMIDIPinContext->pMIDIOutPinContext->bRunningStatus = 0;

    return STATUS_SUCCESS;
}

NTSTATUS
USBMIDIOutStreamClose( PKSPIN pKsPin )
{
    KIRQL irql;
    PPIN_CONTEXT pPinContext = pKsPin->Context;

    PAGED_CODE();

    // Wait for all outstanding Urbs to complete.
    KeAcquireSpinLock( &pPinContext->PinSpinLock, &irql );
    if ( pPinContext->ulOutstandingUrbCount ) {
        KeResetEvent( &pPinContext->PinStarvationEvent );
        KeReleaseSpinLock( &pPinContext->PinSpinLock, irql );
        KeWaitForSingleObject( &pPinContext->PinStarvationEvent,
                               Executive,
                               KernelMode,
                               FALSE,
                               NULL );
    }
    else
        KeReleaseSpinLock( &pPinContext->PinSpinLock, irql );

    _DbgPrintF(DEBUGLVL_TERSE,("[USBMIDIOutStreamClose] Finished closing pin (%x)\n",pKsPin));

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\drivers\usbaudio.2\perf.h ===
//---------------------------------------------------------------------------
//
//  Module:   perf.d
//
//  Description:
//
//
//@@BEGIN_MSINTERNAL
//
//  History:   Date       Author      Comment
//             --------------------------------------------------------------
//             01/02/01   ArthurZ     Created
//
//@@END_MSINTERNAL
//---------------------------------------------------------------------------
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1995-1999 Microsoft Corporation.  All Rights Reserved.
//
//---------------------------------------------------------------------------

#include <wmistr.h>
#include <evntrace.h>

extern NTSTATUS
(*PerfSystemControlDispatch) (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

extern ULONG TraceEnable;

#define PerfInstrumentationEnabled() (TraceEnable != 0)

#define USBAUDIO_SOURCE_GLITCH 4

VOID
PerfRegisterProvider (
    IN PDEVICE_OBJECT DeviceObject
    );

VOID
PerfUnregisterProvider (
    IN PDEVICE_OBJECT DeviceObject
    );

NTSTATUS
PerfWmiDispatch (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

VOID
PerfLogGlitch (
    IN ULONG_PTR InstanceId,
    IN ULONG Type,
    IN LONGLONG CurrentTime,
    IN LONGLONG PreviousTime
    );


//---------------------------------------------------------------------------
//  End of File: perf.c
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\drivers\usbaudio.2\nameguid.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 2000
//
//  File:       nameguid.h
//
//--------------------------------------------------------------------------


#define STATIC_USBNODENAME_BassBoost \
    0x1A71EBE0L, 0x959E, 0x11D1, 0xB4, 0x48, 0x00, 0xA0, 0xC9, 0x25, 0x5A, 0xC1

#define STATIC_USBNODENAME_StereoExtender \
    0xFD4F0300L, 0x9632, 0x11D1, 0xB4, 0x48, 0x00, 0xA0, 0xC9, 0x25, 0x5A, 0xC1
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\drivers\usbaudio.2\perf.c ===
//---------------------------------------------------------------------------
//
//  Module:   perf.c
//
//  Description:
//
//
//@@BEGIN_MSINTERNAL
//
//  History:   Date       Author      Comment
//             --------------------------------------------------------------
//             12/12/00   ArthurZ     Created
//
//@@END_MSINTERNAL
//---------------------------------------------------------------------------
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1995-1999 Microsoft Corporation.  All Rights Reserved.
//
//---------------------------------------------------------------------------

#include "common.h"
#include "perf.h"

#define PROC_REG_PATH L"System\\CurrentControlSet\\Services\\Usbaudio"

GUID ControlGuid =
{ 0x28cf047a, 0x2437, 0x4b24, 0xb6, 0x53, 0xb9, 0x44, 0x6a, 0x41, 0x9a, 0x69 };

GUID TraceGuid = 
{ 0xd6464a84, 0xa358, 0x4013, 0xa1, 0xe8, 0x6e, 0x2f, 0xb4, 0x8a, 0xab, 0x93 };

ULONG TraceEnable;
TRACEHANDLE LoggerHandle;

NTSTATUS
(*PerfSystemControlDispatch) (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

typedef struct PERFINFO_AUDIOGLITCH {
    ULONGLONG   cycleCounter;
    ULONG       glitchType;
    LONGLONG   sampleTime;
    LONGLONG   previousTime;
    ULONG_PTR       instanceId;
} PERFINFO_AUDIOGLITCH, *PPERFINFO_AUDIOGLITCH;

typedef struct PERFINFO_WMI_AUDIOGLITCH {
    EVENT_TRACE_HEADER          header;
    PERFINFO_AUDIOGLITCH        data;
} PERFINFO_WMI_AUDIO_GLITCH, *PPERFINFO_WMI_AUDIOGLITCH;

///////////////////////////////////////////////////////////////////////////

VOID
PerfRegisterProvider (
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine registers this component as a WMI event tracing provider.

--*/

{
    IoWMIRegistrationControl (DeviceObject, WMIREG_ACTION_REGISTER);
}

///////////////////////////////////////////////////////////////////////////

VOID
PerfUnregisterProvider (
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine unregisters this component as a WMI event tracing provider.

--*/

{
    IoWMIRegistrationControl (DeviceObject, WMIREG_ACTION_DEREGISTER);
}

///////////////////////////////////////////////////////////////////////////

NTSTATUS
RegisterWmiGuids (
    IN PWMIREGINFO WmiRegInfo,
    IN ULONG RegInfoSize,
    IN PULONG ReturnSize
    )

/*++

Routine Description:

    This routine registers WMI event tracing streams.

--*/

{
    ULONG SizeNeeded;
    PWMIREGGUIDW WmiRegGuidPtr;
    ULONG status;
    ULONG GuidCount;
    ULONG RegistryPathSize;
    PUCHAR Temp;

    if (WmiRegInfo == NULL ||
        ReturnSize == NULL ) {
        return STATUS_INVALID_PARAMETER;
    }

    GuidCount = 1;

    RegistryPathSize = sizeof (PROC_REG_PATH) - sizeof (WCHAR) + sizeof (USHORT);
    SizeNeeded = sizeof (WMIREGINFOW) + GuidCount * sizeof (WMIREGGUIDW) + RegistryPathSize;

    if (SizeNeeded > RegInfoSize) {
        if ( RegInfoSize >= sizeof(ULONG) ) {
            *((PULONG)WmiRegInfo) = SizeNeeded;
            *ReturnSize = sizeof (ULONG);
            return STATUS_BUFFER_OVERFLOW;
        }
        else {
            *ReturnSize = 0;
            return STATUS_BUFFER_TOO_SMALL;
        }
    }

    RtlZeroMemory (WmiRegInfo, SizeNeeded);
    WmiRegInfo->BufferSize = SizeNeeded;
    WmiRegInfo->GuidCount = GuidCount;

    WmiRegGuidPtr = WmiRegInfo->WmiRegGuid;
    WmiRegGuidPtr->Guid = ControlGuid;
    WmiRegGuidPtr->Flags |= (WMIREG_FLAG_TRACED_GUID | WMIREG_FLAG_TRACE_CONTROL_GUID);

    Temp = (PUCHAR)(WmiRegGuidPtr + 1);
    WmiRegInfo->RegistryPath = PtrToUlong ((PVOID)(Temp - (PUCHAR)WmiRegInfo));
    *((PUSHORT)Temp) = (USHORT)(sizeof (PROC_REG_PATH) - sizeof (WCHAR));

    Temp += sizeof (USHORT);
    RtlCopyMemory (Temp, PROC_REG_PATH, sizeof (PROC_REG_PATH) - sizeof (WCHAR));

    *ReturnSize = SizeNeeded;

    return STATUS_SUCCESS;
}

///////////////////////////////////////////////////////////////////////////

NTSTATUS
PerfWmiDispatch (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine handles IRP_MJ_SYSTEM_CONTROL calls. It processes
    WMI requests and passes everything else on to KS.

--*/

{
    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation (Irp);
    ULONG ReturnSize=0;
    PWNODE_HEADER Wnode;
    NTSTATUS ntStatus = STATUS_SUCCESS;

    if ((PDEVICE_OBJECT)IrpSp->Parameters.WMI.ProviderId != DeviceObject) {
        return PerfSystemControlDispatch (DeviceObject, Irp);
    }

    switch (IrpSp->MinorFunction) {

    case IRP_MN_REGINFO:
        ntStatus = RegisterWmiGuids ((PWMIREGINFO)IrpSp->Parameters.WMI.Buffer,
                          IrpSp->Parameters.WMI.BufferSize,
                          &ReturnSize);
        break;
    
    case IRP_MN_ENABLE_EVENTS:
        InterlockedExchange ((PLONG)&TraceEnable, 1);
        Wnode = (PWNODE_HEADER)IrpSp->Parameters.WMI.Buffer;
        if (IrpSp->Parameters.WMI.BufferSize >= sizeof (WNODE_HEADER)) {
            LoggerHandle = Wnode->HistoricalContext;
        }
        break;

    case IRP_MN_DISABLE_EVENTS:
        InterlockedExchange ((PLONG)&TraceEnable, 0);
        break;

    case IRP_MN_ENABLE_COLLECTION:
    case IRP_MN_DISABLE_COLLECTION:
        break;

    default:
        return PerfSystemControlDispatch (DeviceObject, Irp);
    }

    Irp->IoStatus.Status = ntStatus;
    Irp->IoStatus.Information = ReturnSize;
    IoCompleteRequest (Irp, IO_NO_INCREMENT);
    return ntStatus;
}

///////////////////////////////////////////////////////////////////////////

VOID
PerfLogGlitch (
    IN ULONG_PTR InstanceId,
    IN ULONG Type,
    IN LONGLONG CurrentTime,
    IN LONGLONG PreviousTime
    )

/*++

Routine Description:

    This routine logs a WMI event tracing event with an audio glitch GUID
    and the supplied glitch type.

--*/

{
    PERFINFO_WMI_AUDIO_GLITCH Event;

    if (LoggerHandle == (TRACEHANDLE)NULL || TraceEnable == 0) {
        return;
    }

    RtlZeroMemory (&Event, sizeof (Event));
    Event.header.Size = sizeof (Event);
    Event.header.Flags = WNODE_FLAG_TRACED_GUID;
    Event.header.Guid = TraceGuid;
    Event.data.glitchType = Type;
    Event.data.instanceId = InstanceId;
    Event.data.sampleTime = CurrentTime;
    Event.data.previousTime = PreviousTime;

    ((PWNODE_HEADER)&Event)->HistoricalContext = LoggerHandle;

    IoWMIWriteEvent ((PVOID)&Event);
}

//---------------------------------------------------------------------------
//  End of File: perf.c
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\drivers\usbaudio.2\property.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 2000
//
//  File:       property.c
//
//--------------------------------------------------------------------------

#include "common.h"
#include "Property.h"

#define DB_SCALE_16BIT 0x100
#define DB_SCALE_8BIT  0x4000

#define MAX_EQ_BANDS 30

#define NEGATIVE_INFINITY 0xFFFF8000

extern ULONG MapPropertyToNode[KSPROPERTY_AUDIO_3D_INTERFACE+1];

#define GET_NODE_INFO_FROM_FILTER(pKsFilter,ulNodeID) \
        &((PTOPOLOGY_NODE_INFO)(pKsFilter)->Descriptor->NodeDescriptors)[(ulNodeID)]

#define MAXPINNAME      256
#define STR_PINNAME     TEXT("%s [%d]")

NTSTATUS
USBAudioRegReadNameValue(
    IN PIRP Irp,
    IN const GUID* Category,
    OUT PVOID NameBuffer
    )
/*++

Routine Description:

    Queries the "Name" key from the specified category GUID. This is used
    by the topology handler to query for the value from the name GUID or
    topology GUID. If the buffer length is sizeof(ULONG), then the size of
    the buffer needed is returned, else the buffer is filled with the name.

Arguments:

    Irp -
        Contains the IRP with the property request being handled.

    Category -
        The GUID to locate the name value for.

    NameBuffer -
        The place in which to put the value.

Return Value:

    Returns STATUS_SUCCESS, else a buffer size or memory error. Always fills
    in the IO_STATUS_BLOCK.Information field of the PIRP.IoStatus element
    within the IRP. It does not set the IO_STATUS_BLOCK.Status field, nor
    complete the IRP however.

--*/
{
    OBJECT_ATTRIBUTES               ObjectAttributes;
    NTSTATUS                        Status;
    HANDLE                          CategoryKey;
    KEY_VALUE_PARTIAL_INFORMATION   PartialInfoHeader;
    WCHAR                           RegistryPath[sizeof(MediaCategories) + 39];
    UNICODE_STRING                  RegistryString;
    UNICODE_STRING                  ValueName;
    ULONG                           BytesReturned;

    //
    // Build the registry key path to the specified category GUID.
    //
    Status = RtlStringFromGUID(Category, &RegistryString);
    if (!NT_SUCCESS(Status)) {
        return Status;
    }
    wcscpy(RegistryPath, MediaCategories);
    wcscat(RegistryPath, RegistryString.Buffer);
    RtlFreeUnicodeString(&RegistryString);
    RtlInitUnicodeString(&RegistryString, RegistryPath);
    InitializeObjectAttributes(&ObjectAttributes, &RegistryString, OBJ_CASE_INSENSITIVE, NULL, NULL);
    if (!NT_SUCCESS(Status = ZwOpenKey(&CategoryKey, KEY_READ, &ObjectAttributes))) {
        return Status;
    }
    //
    // Read the "Name" value beneath this category key.
    //
    RtlInitUnicodeString(&ValueName, NodeNameValue);
    Status = ZwQueryValueKey(
        CategoryKey,
        &ValueName,
        KeyValuePartialInformation,
        &PartialInfoHeader,
        sizeof(PartialInfoHeader),
        &BytesReturned);
    //
    // Even if the read did not cause an overflow, just take the same
    // code path, as such a thing would not normally happen.
    //
    if ((Status == STATUS_BUFFER_OVERFLOW) || NT_SUCCESS(Status)) {
        ULONG   BufferLength;

        BufferLength = IoGetCurrentIrpStackLocation(Irp)->Parameters.DeviceIoControl.OutputBufferLength;
        //
        // Determine if this is just a query for the length of the
        // buffer needed, or a query for the actual data.
        //
        if (!BufferLength) {
            //
            // Return just the size of the string needed.
            //
            Irp->IoStatus.Information = BytesReturned - FIELD_OFFSET(KEY_VALUE_PARTIAL_INFORMATION, Data);
            Status = STATUS_BUFFER_OVERFLOW;
        } else if (BufferLength < BytesReturned - FIELD_OFFSET(KEY_VALUE_PARTIAL_INFORMATION, Data)) {
            Status = STATUS_BUFFER_TOO_SMALL;
        } else {
            PKEY_VALUE_PARTIAL_INFORMATION  PartialInfoBuffer;

            //
            // Allocate a buffer for the actual size of data needed.
            //
            PartialInfoBuffer = AllocMem( PagedPool, BytesReturned );
            if (PartialInfoBuffer) {
                //
                // Retrieve the actual name.
                //
                Status = ZwQueryValueKey(
                    CategoryKey,
                    &ValueName,
                    KeyValuePartialInformation,
                    PartialInfoBuffer,
                    BytesReturned,
                    &BytesReturned);
                if (NT_SUCCESS(Status)) {
                    //
                    // Make sure that there is always a value.
                    //
                    if (!PartialInfoBuffer->DataLength || (PartialInfoBuffer->Type != REG_SZ)) {
                        Status = STATUS_UNSUCCESSFUL;
                    } else {
                        RtlCopyMemory(
                            NameBuffer,
                            PartialInfoBuffer->Data,
                            PartialInfoBuffer->DataLength);
                        Irp->IoStatus.Information = PartialInfoBuffer->DataLength;
                    }
                }
                FreeMem(PartialInfoBuffer);
            } else {
                Status = STATUS_INSUFFICIENT_RESOURCES;
            }
        }
    }
    ZwClose(CategoryKey);
    return Status;
}

ULONG
GetPinIndex(
    PUSB_CONFIGURATION_DESCRIPTOR pConfigurationDescriptor,
    ULONG PinId )
{
    KSPIN_DATAFLOW DataFlow;
    ULONG i,j;
    ULONG DataFlowInIndex = 0;
    ULONG DataFlowOutIndex = 0;
    ULONG ulAudioPinCount;
    ULONG ulAudioStreamingPinCount, ulAudioBridgePinCount;
    ULONG ulMIDIPinCount, ulMIDIBridgePinCount;

    //  Jump past the Audio pins by figuring out where they start
    ulAudioPinCount = CountTerminalUnits(pConfigurationDescriptor,
                                         &ulAudioBridgePinCount,
                                         &ulMIDIPinCount,
                                         &ulMIDIBridgePinCount);

    ulAudioStreamingPinCount = ulAudioPinCount -
                               ulAudioBridgePinCount -
                               ulMIDIPinCount;

    _DbgPrintF(DEBUGLVL_BLAB,("[GetPinIndex] AC:%x, ASC:%x, ABC:%x, MC:%x, MBC:%x\n",
                               ulAudioPinCount,
                               ulAudioStreamingPinCount,
                               ulAudioBridgePinCount,
                               ulMIDIPinCount,
                               ulMIDIBridgePinCount));

    // Test to see if this pin id is in the range of MIDI Streaming pins
    if ( (PinId >= ulAudioPinCount - ulMIDIPinCount) &&
         (PinId < ulAudioPinCount - ulMIDIBridgePinCount) ) {

        for (i=ulAudioPinCount - ulMIDIPinCount,j=0;
             i<ulAudioPinCount - ulMIDIBridgePinCount;
             i++,j++) {
            DataFlow = GetDataFlowDirectionForMIDIInterface( pConfigurationDescriptor, j, FALSE );
            if (i == PinId) {
                if (DataFlow == KSPIN_DATAFLOW_OUT) {
                    return DataFlowOutIndex+1;
                }
                else {
                    return DataFlowInIndex+1;
                }
            }

            if (DataFlow == KSPIN_DATAFLOW_OUT) {
                DataFlowOutIndex++;
            }
            else {
                DataFlowInIndex++;
            }
        }
    }
    else {
        return MAX_ULONG;
    }

    // Shouldn't get here
    ASSERT(0);
    return MAX_ULONG;
}

NTSTATUS
GetPinName( PIRP pIrp, PKSP_PIN pKsPropPin, PVOID pData )
{
    ULONG BufferLength;
    WCHAR szTemp[MAXPINNAME];
    PWCHAR StringBuffer;
    ULONG StringLength;
    ULONG ulPinIndex;
    NTSTATUS Status;
    PKEY_VALUE_FULL_INFORMATION pkvfi = NULL;

    PKSFILTER pKsFilter = KsGetFilterFromIrp(pIrp);
    PFILTER_CONTEXT pFilterContext;
    PHW_DEVICE_EXTENSION pHwDevExt;

    if ( NULL == pKsFilter ) {
        TRAP;
        return STATUS_INVALID_PARAMETER;
    }

    pFilterContext = pKsFilter->Context;
    pHwDevExt      = pFilterContext->pHwDevExt;

    ASSERT(pKsFilter);
    ASSERT(pFilterContext);
    ASSERT(pHwDevExt);

    _DbgPrintF(DEBUGLVL_VERBOSE,("[GetPinName] pKsPropPin->PinId %x\n",pKsPropPin->PinId));

    ulPinIndex =
        GetPinIndex( pHwDevExt->pConfigurationDescriptor, pKsPropPin->PinId );
    if (ulPinIndex != MAX_ULONG) {

        BufferLength = IoGetCurrentIrpStackLocation(pIrp)->Parameters.DeviceIoControl.OutputBufferLength;

        // Get the Friendly name for this device and append a subscript if there
        // is more than one pin on this device.

        StringBuffer = AllocMem(NonPagedPool, MAXPINNAME);
        if (!StringBuffer) {
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        //
        //  Using DeviceDescription, perhaps the name should be acquired from the FriendlyName
        //  on the device interface, but this seems to work.
        //
        Status = IoGetDeviceProperty(
            pFilterContext->pNextDeviceObject,
            DevicePropertyDeviceDescription,
            MAXPINNAME,
            StringBuffer,
            &StringLength);

        if(!NT_SUCCESS(Status)) {
            _DbgPrintF(DEBUGLVL_VERBOSE,("[GetPinName] IoGetDeviceProperty failed (%x)\n", Status));
            FreeMem(StringBuffer);
            return Status;
        }

        swprintf(szTemp, STR_PINNAME, StringBuffer, ulPinIndex);
        StringLength = (wcslen(szTemp) + 1) * sizeof(WCHAR);

        //  Compute actual length adding the pin subscript
        if (!BufferLength) {
            _DbgPrintF(DEBUGLVL_BLAB,("[GetPinName] StringLength: %x\n",StringLength));
            pIrp->IoStatus.Information = StringLength;
            Status = STATUS_BUFFER_OVERFLOW;
        }
        else if (BufferLength < StringLength) {
            Status = STATUS_BUFFER_TOO_SMALL;
        }
        else {
            BufferLength = BufferLength / sizeof(WCHAR);
            if ( (ulPinIndex < 2) || (ulPinIndex == MAX_ULONG) ) {
                wcsncpy(pData, StringBuffer, min(BufferLength,MAXPINNAME));
                StringLength = (wcslen(pData) + 1) * sizeof(WCHAR);
            }
            else {
                wcsncpy(pData, szTemp, min(BufferLength,MAXPINNAME));
            }
            _DbgPrintF(DEBUGLVL_BLAB,("[GetPinName] String: %ls\n",pData));
            ASSERT(StringLength <= BufferLength * sizeof(WCHAR));
            pIrp->IoStatus.Information = StringLength;
            Status = STATUS_SUCCESS;
        }

        FreeMem(StringBuffer);
    }
    else {
        const KSFILTER_DESCRIPTOR *pKsFilterDescriptor = pKsFilter->Descriptor;
        const KSPIN_DESCRIPTOR_EX *pKsPinDescriptor = pKsFilterDescriptor->PinDescriptors;
        KSPIN_DESCRIPTOR PinDescriptor;
        UINT i;

        for (i=0; i<pKsPropPin->PinId; i++) {
            pKsPinDescriptor =
                (PKSPIN_DESCRIPTOR_EX)(
                    (PUCHAR)pKsPinDescriptor + pKsFilterDescriptor->PinDescriptorSize);
        }

        PinDescriptor = pKsPinDescriptor->PinDescriptor;

        if (PinDescriptor.Name) {
            return USBAudioRegReadNameValue( pIrp, PinDescriptor.Name, pData );
        }
        if (PinDescriptor.Category) {
            return USBAudioRegReadNameValue( pIrp, PinDescriptor.Category, pData );
        }
    }

    return Status;
}

NTSTATUS
GetSetProperty(
    PDEVICE_OBJECT pNextDeviceObject,
    USHORT FunctionClass,
    ULONG  DirectionFlag,
    UCHAR  RequestType,
    USHORT wValueHi,
    USHORT wValueLo,
    USHORT wIndexHi,
    USHORT wIndexLo,
    PVOID  pData,
    ULONG  LengthOfData )
{
    NTSTATUS ntStatus = STATUS_INVALID_DEVICE_REQUEST;
    PURB pUrb;

    // Allocate an urb to use
    pUrb = AllocMem(NonPagedPool, sizeof(struct _URB_CONTROL_VENDOR_OR_CLASS_REQUEST));
    if ( pUrb ) {
        // Build the request
        UsbBuildVendorRequest( pUrb,
                               FunctionClass,
                               (USHORT) sizeof(struct _URB_CONTROL_VENDOR_OR_CLASS_REQUEST),
                               DirectionFlag, // transferflags == OUT
                               0, // request type reserved bits
                               RequestType,
                               (USHORT) ((wValueHi << 8) | wValueLo),
                               (USHORT) ((wIndexHi << 8) | wIndexLo),
                               pData,
                               NULL,
                               LengthOfData,
                               NULL);

        ntStatus = SubmitUrbToUsbdSynch(pNextDeviceObject, pUrb);

        DbgLog("GSProp", ntStatus, 0, 0, 0);

        FreeMem(pUrb);
    }

    return ntStatus;
}

NTSTATUS
GetSetByte(
    PDEVICE_OBJECT pNextDeviceObject,
    PTOPOLOGY_NODE_INFO pNodeInfo,
    ULONG ulChannel,
    PULONG plData,
    UCHAR ucRequestType )
{
    NTSTATUS ntStatus;
    PUCHAR pData;

    pData = AllocMem(NonPagedPool, sizeof(UCHAR));
    if (!pData) return STATUS_INSUFFICIENT_RESOURCES;

    if ( !(ucRequestType & CLASS_SPECIFIC_GET_MASK) )
        *pData = (UCHAR)*plData;

    ntStatus = GetSetProperty( pNextDeviceObject,
                               URB_FUNCTION_CLASS_INTERFACE,
                               (ucRequestType & CLASS_SPECIFIC_GET_MASK) ?
                                              USBD_TRANSFER_DIRECTION_IN :
                                              USBD_TRANSFER_DIRECTION_OUT,
                               ucRequestType,
                               (USHORT)pNodeInfo->ulControlType,
                               (USHORT)ulChannel,
                               (USHORT)((PAUDIO_UNIT)pNodeInfo->pUnit)->bUnitID,
                               (USHORT)pNodeInfo->MapNodeToCtrlIF,
                               pData,
                               sizeof(UCHAR) );

    if ((ucRequestType & CLASS_SPECIFIC_GET_MASK ) && NT_SUCCESS( ntStatus ) )
       *plData = (ULONG)(*pData);

    FreeMem(pData);

    return ntStatus;

}

NTSTATUS
GetSetShort(
    PDEVICE_OBJECT pNextDeviceObject,
    PTOPOLOGY_NODE_INFO pNodeInfo,
    ULONG ulChannel,
    PULONG plData,
    UCHAR ucRequestType )
{
    NTSTATUS ntStatus;
    PUSHORT pData;

    pData = AllocMem(NonPagedPool, sizeof(USHORT));
    if (!pData) return STATUS_INSUFFICIENT_RESOURCES;

    if ( !(ucRequestType & CLASS_SPECIFIC_GET_MASK) )
        *pData = (USHORT)*plData;

    ntStatus = GetSetProperty( pNextDeviceObject,
                               URB_FUNCTION_CLASS_INTERFACE,
                               (ucRequestType & CLASS_SPECIFIC_GET_MASK) ?
                                              USBD_TRANSFER_DIRECTION_IN :
                                              USBD_TRANSFER_DIRECTION_OUT,
                               ucRequestType,
                               (USHORT)pNodeInfo->ulControlType,
                               (USHORT)ulChannel,
                               (USHORT)((PAUDIO_UNIT)pNodeInfo->pUnit)->bUnitID,
                               (USHORT)pNodeInfo->MapNodeToCtrlIF,
                               pData,
                               sizeof(USHORT) );

    if ((ucRequestType & CLASS_SPECIFIC_GET_MASK ) && NT_SUCCESS( ntStatus ) )
       *plData = (ULONG)(*pData);

    FreeMem(pData);

    return ntStatus;

}

NTSTATUS
GetSetDBLevel(
    PDEVICE_OBJECT pNextDeviceObject,
    PTOPOLOGY_NODE_INFO pNodeInfo,
    PLONG plData,
    ULONG ulChannel,
    ULONG ulDataBitCount,
    UCHAR ucRequestType )
{
    NTSTATUS (*GetSetFunc)(PDEVICE_OBJECT, PTOPOLOGY_NODE_INFO, ULONG, PULONG, UCHAR );

    PDB_LEVEL_CACHE pDbCache = (PDB_LEVEL_CACHE)pNodeInfo->pCachedValues;
    NTSTATUS ntStatus = STATUS_INVALID_DEVICE_REQUEST;
    LONG lScaleFactor;
    LONG lData;

    // Determine if this is a request for beyond # of channels available
    if ( ulChannel >= pNodeInfo->ulChannels ) {
        return ntStatus;
    }

    if ( !(pNodeInfo->ulCacheValid & (1<<ulChannel) ) ) {
        return ntStatus;
    }

    // Find the Cache for the requested channel
    pDbCache += ulChannel;
    DbgLog("GSDbLvl", &pNodeInfo, ulChannel, pDbCache, pDbCache->ulChannelIndex );

    ASSERT((ulDataBitCount == 8) || (ulDataBitCount == 16));

    if ( ulDataBitCount == 8 ) {
        lScaleFactor = DB_SCALE_8BIT;
        GetSetFunc   = GetSetByte;
    }
    else {
        lScaleFactor = DB_SCALE_16BIT;
        GetSetFunc   = GetSetShort;
    }

    switch((ULONG)ucRequestType) {
        case GET_CUR:
            *plData = pDbCache->lLastValueSet;
            ntStatus = STATUS_SUCCESS;
            break;
        case SET_CUR:
            if ( *plData == pDbCache->lLastValueSet ) {
                ntStatus = STATUS_SUCCESS;
            }
            else {
                if ( *plData < pDbCache->Range.Bounds.SignedMinimum ) {
                    if ( ulDataBitCount == 16 )
                        lData = NEGATIVE_INFINITY; // Detect volume control to silence
                    else
                        lData = pDbCache->Range.Bounds.SignedMinimum / lScaleFactor;
                }
                else if ( *plData > pDbCache->Range.Bounds.SignedMaximum ) {
                    lData = pDbCache->Range.Bounds.SignedMaximum / lScaleFactor;
                }
                else  {
                    lData = *plData / lScaleFactor;
                }

                ntStatus = (*GetSetFunc)( pNextDeviceObject,
                                          pNodeInfo,
                                          pDbCache->ulChannelIndex,
                                          &lData,
                                          SET_CUR );
                if ( NT_SUCCESS(ntStatus) ) {
                    pDbCache->lLastValueSet = *plData;
                }
            }
            break;
        default:
            ntStatus  = STATUS_INVALID_DEVICE_REQUEST;
            break;
    }

    return ntStatus;
}

NTSTATUS
GetDbLevelRange(
    PDEVICE_OBJECT pNextDeviceObject,
    PTOPOLOGY_NODE_INFO pNodeInfo,
    ULONG ulChannel,
    ULONG ulDataBitCount,
    PKSPROPERTY_STEPPING_LONG pRange )
{
    NTSTATUS (*GetFunc)(PDEVICE_OBJECT, PTOPOLOGY_NODE_INFO, ULONG, PULONG, UCHAR );
    NTSTATUS ntStatus = STATUS_INVALID_DEVICE_REQUEST;
    LONG lData;
    UCHAR ucRequestType;

    ASSERT((ulDataBitCount == 8) || (ulDataBitCount == 16));

    GetFunc = ( ulDataBitCount == 8 ) ? GetSetByte : GetSetShort;

    for ( ucRequestType=GET_MIN; ucRequestType<=GET_RES; ucRequestType++ ) {

        ntStatus = (*GetFunc)( pNextDeviceObject,
                               pNodeInfo,
                               ulChannel,
                               &lData,
                               ucRequestType );

        if ( !NT_SUCCESS(ntStatus) ) {
            _DbgPrintF(DEBUGLVL_VERBOSE,("'GetDbLevelRange ERROR: %x\n",ntStatus));
            break;
        }
        else {
            if ( ulDataBitCount == 8 ) {
                lData = (LONG)((CHAR)(lData))  * DB_SCALE_8BIT;
            }
            else {
                lData = (LONG)((SHORT)(lData)) * DB_SCALE_16BIT;
            }

            switch( ucRequestType ) {
                case GET_MIN:
                    pRange->Bounds.SignedMinimum = lData;
                    break;
                case GET_MAX:
                    pRange->Bounds.SignedMaximum = lData;
                    break;
                case GET_RES:
                    pRange->SteppingDelta = lData;
                    break;
            }
        }
    }

    DbgLog("DBRnge", ntStatus, pRange, ucRequestType, pNodeInfo );

    return ntStatus;
}

NTSTATUS
InitializeDbLevelCache(
    PDEVICE_OBJECT pNextDeviceObject,
    PTOPOLOGY_NODE_INFO pNodeInfo,
    PDB_LEVEL_CACHE pDbCache,
    ULONG ulDataBitCount )
{
    NTSTATUS (*GetSetFunc)(PDEVICE_OBJECT, PTOPOLOGY_NODE_INFO, ULONG, PULONG, UCHAR );
    NTSTATUS ntStatus;
    LONG lScaleFactor;
    LONG lData;

    ASSERT((ulDataBitCount == 8) || (ulDataBitCount == 16));

    if ( ulDataBitCount == 8 ) {
        lScaleFactor = DB_SCALE_8BIT;
        GetSetFunc  = GetSetByte;
    }
    else {
        lScaleFactor = DB_SCALE_16BIT;
        GetSetFunc  = GetSetShort;
    }

    ntStatus = GetDbLevelRange( pNextDeviceObject,
                                pNodeInfo,
                                pDbCache->ulChannelIndex,
                                ulDataBitCount,
                                &pDbCache->Range );

    if ( NT_SUCCESS(ntStatus) ) {
        ntStatus = (*GetSetFunc)( pNextDeviceObject,
                                  pNodeInfo,
                                  pDbCache->ulChannelIndex,
                                  &lData,
                                  GET_CUR );

        if ( NT_SUCCESS(ntStatus) ) {
            if ( pNodeInfo->ulControlType == VOLUME_CONTROL ) {
                pDbCache->lLastValueSet = (LONG)((SHORT)lData) * lScaleFactor;
                _DbgPrintF(DEBUGLVL_VERBOSE,("InitDbCache: pDbCache->lLastValueSet=%d\n",pDbCache->lLastValueSet));
                if ( (pDbCache->lLastValueSet >= pDbCache->Range.Bounds.SignedMaximum) ||
                     (pDbCache->lLastValueSet <= pDbCache->Range.Bounds.SignedMinimum) ) {
                    lData = ( pDbCache->Range.Bounds.SignedMinimum +
                             ( pDbCache->Range.Bounds.SignedMaximum - pDbCache->Range.Bounds.SignedMinimum) / 2 )
                            / lScaleFactor;
                   _DbgPrintF(DEBUGLVL_VERBOSE,("InitDbCache: volume at max (%d) or min (%d), setting to average %d\n",
                                               pDbCache->Range.Bounds.SignedMaximum,
                                               pDbCache->Range.Bounds.SignedMinimum,
                                               lData));
                }
                ntStatus = (*GetSetFunc)( pNextDeviceObject,
                                          pNodeInfo,
                                          pDbCache->ulChannelIndex,
                                          &lData,
                                          SET_CUR );
                if ( NT_SUCCESS(ntStatus) ) {
                    pDbCache->lLastValueSet = (LONG)((SHORT)lData) * lScaleFactor;
                    _DbgPrintF(DEBUGLVL_VERBOSE,("InitDbCache: setting lastvalue to %d\n",pDbCache->lLastValueSet));
                }
                else {
                    _DbgPrintF(DEBUGLVL_VERBOSE,("InitDbCache: error setting volume %d\n",lData));
                }
            }
            else {
                pDbCache->lLastValueSet = (LONG)((CHAR)lData) * lScaleFactor;
            }
        }
    }

    return ntStatus;

}


NTSTATUS
GetSetProcessingUnitValue(
    PDEVICE_OBJECT pNextDeviceObject,
    PTOPOLOGY_NODE_INFO pNodeInfo,
    UCHAR ucCommand,
    USHORT usControlSelector,
    PVOID pValue,
    ULONG ulValSize )
{
    ULONG ulDirectionFlag =
        (ucCommand & CLASS_SPECIFIC_GET_MASK) ? USBD_TRANSFER_DIRECTION_IN :
                                                USBD_TRANSFER_DIRECTION_OUT;
    PVOID pVal;
    NTSTATUS ntStatus = STATUS_INSUFFICIENT_RESOURCES;

    pVal = AllocMem(NonPagedPool, ulValSize);


    if (pVal) {

        if (!ulDirectionFlag) {
            RtlCopyMemory(pVal, pValue, ulValSize);
        }

        ntStatus = GetSetProperty( pNextDeviceObject,
                                   URB_FUNCTION_CLASS_INTERFACE,
                                   ulDirectionFlag,
                                   ucCommand,
                                   usControlSelector,
                                   (USHORT)0,
                                   (USHORT)((PAUDIO_UNIT)pNodeInfo->pUnit)->bUnitID,
                                   (USHORT)pNodeInfo->MapNodeToCtrlIF,
                                   pVal,
                                   ulValSize );

        if ( NT_SUCCESS(ntStatus) ) {
            if (ulDirectionFlag)
                RtlCopyMemory(pValue, pVal, ulValSize);
        }

        FreeMem( pVal );

    }

    return ntStatus;
}

NTSTATUS
GetSetProcessingUnitEnable(
    PDEVICE_OBJECT pNextDeviceObject,
    PTOPOLOGY_NODE_INFO pNodeInfo,
    UCHAR ucCommand,
    PBOOL pEnable )
{
    NTSTATUS ntStatus;
    UCHAR ucEnable = (UCHAR)*pEnable;

    ntStatus = GetSetProcessingUnitValue( pNextDeviceObject,
                                          pNodeInfo,
                                          ucCommand,
                                          (USHORT)ENABLE_CONTROL,
                                          pEnable,
                                          sizeof(UCHAR) );
    if (NT_SUCCESS(ntStatus)) {
        if (ucCommand == GET_CUR)
            *pEnable = (BOOL)ucEnable;
    }

    return ntStatus;
}

NTSTATUS
GetProcessingUnitRange(
    PDEVICE_OBJECT pNextDeviceObject,
    PTOPOLOGY_NODE_INFO pNodeInfo,
    ULONG ulControl,
    ULONG ulCntrlSize,
    LONG  lScaleFactor,
    PKSPROPERTY_STEPPING_LONG pRange )
{
    NTSTATUS ntStatus = STATUS_INVALID_PARAMETER;
    UCHAR ucRequestType;
    LONG lData;

    for ( ucRequestType=GET_MIN; ucRequestType<=GET_RES; ucRequestType++ ) {

        ntStatus = GetSetProcessingUnitValue( pNextDeviceObject,
                                              pNodeInfo,
                                              ucRequestType,
                                              (USHORT)ulControl,
                                              &lData,
                                              ulCntrlSize );

        if ( !NT_SUCCESS(ntStatus) ) {
            _DbgPrintF(DEBUGLVL_VERBOSE,("'GetProcessingUnitRange ERROR: %x\n",ntStatus));
            break;
        }

        if ( ulCntrlSize == sizeof(CHAR) ) {
            lData = (LONG)((CHAR)(lData)) * lScaleFactor;
        }
        else {
            lData = (LONG)((SHORT)(lData)) * lScaleFactor;
        }

        switch (ucRequestType) {
            case GET_MIN:
                pRange->Bounds.SignedMinimum = lData;
                break;
            case GET_MAX:
                pRange->Bounds.SignedMaximum = lData;
                break;
            case GET_RES:
                pRange->SteppingDelta = lData;
                break;
        }
    }

    return ntStatus;
}

// Begin PIN Based Audio Properties
NTSTATUS
GetSampleRate( PKSPIN pKsPin, PULONG pSampleRate )
{
    PPIN_CONTEXT pPinContext = (PPIN_CONTEXT)pKsPin->Context;
    PUSBAUDIO_DATARANGE pUsbAudioDataRange = pPinContext->pUsbAudioDataRange;
    ULONG ulFormatType = pUsbAudioDataRange->ulUsbDataFormat & USBAUDIO_DATA_FORMAT_TYPE_MASK;

    if ( ulFormatType == USBAUDIO_DATA_FORMAT_TYPE_I_UNDEFINED ) {
        PTYPE1_PIN_CONTEXT pT1PinContext = pPinContext->pType1PinContext;

        *pSampleRate = pT1PinContext->ulOriginalSampleRate;

        return STATUS_SUCCESS;
    }
    else
        return STATUS_INVALID_DEVICE_REQUEST;
}

NTSTATUS
SetSampleRate( PKSPIN pKsPin, PULONG pSampleRate )
{
    PPIN_CONTEXT pPinContext = (PPIN_CONTEXT)pKsPin->Context;
    PHW_DEVICE_EXTENSION pHwDevExt = pPinContext->pHwDevExt;
    PUSBAUDIO_DATARANGE pUsbAudioDataRange = pPinContext->pUsbAudioDataRange;
    ULONG ulFormatType = pUsbAudioDataRange->ulUsbDataFormat & USBAUDIO_DATA_FORMAT_TYPE_MASK;
    PAUDIO_CLASS_STREAM pAudioDescriptor = pUsbAudioDataRange->pAudioDescriptor;
    BOOLEAN fSRSettable =
        (( pUsbAudioDataRange->pAudioEndpointDescriptor->bmAttributes & ENDPOINT_SAMPLE_FREQ_MASK ) != 0 );
    NTSTATUS ntStatus = STATUS_SUCCESS;

    // Hack to fix bug in bmAttributes on Canopus device
    if ( ( !fSRSettable ) &&
            ( pKsPin->DataFlow == KSPIN_DATAFLOW_OUT ) &&
            ( pAudioDescriptor->bSampleFreqType > 1) ) {
         fSRSettable = TRUE;
    }

    else if ( !IsSampleRateInRange( pAudioDescriptor,
                                    *pSampleRate,
                                    ulFormatType ) ) {
         ntStatus = STATUS_INVALID_DEVICE_REQUEST;
    }

    if ( NT_SUCCESS(ntStatus) && fSRSettable ) {
        ntStatus =
            GetSetProperty( pPinContext->pNextDeviceObject,
                            URB_FUNCTION_CLASS_ENDPOINT,
                            USBD_TRANSFER_DIRECTION_OUT,
                            (UCHAR)SET_CUR,
                            SAMPLING_FREQ_CONTROL,
                            0,
                            0,
                            pUsbAudioDataRange->pEndpointDescriptor->bEndpointAddress,
                            pSampleRate,
                            3 ); // 3 byte sample rate value

    }

    if ( NT_SUCCESS(ntStatus) ) {
        if (ulFormatType == USBAUDIO_DATA_FORMAT_TYPE_I_UNDEFINED) {
            if ( pKsPin->DataFlow == KSPIN_DATAFLOW_IN ) {
                PTYPE1_PIN_CONTEXT pT1PinContext = pPinContext->pType1PinContext;

                _DbgPrintF( DEBUGLVL_VERBOSE, ("[SetSampleRate] Setting sample rate from %d to %d\n",
                            pT1PinContext->ulCurrentSampleRate, *pSampleRate));

                pT1PinContext->ulOriginalSampleRate = *pSampleRate;
                pT1PinContext->ulCurrentSampleRate  = *pSampleRate;
                pT1PinContext->fSampleRateChanged = TRUE;
            }
            else {
                PCAPTURE_PIN_CONTEXT pCapturePinContext = pPinContext->pCapturePinContext;

                PKSDATAFORMAT_WAVEFORMATEX pFmt = (PKSDATAFORMAT_WAVEFORMATEX)pKsPin->ConnectionFormat;
                pCapturePinContext->ulCurrentSampleRate = *pSampleRate;
                pCapturePinContext->ulAvgBytesPerSec    = pCapturePinContext->ulCurrentSampleRate *
                                                          pCapturePinContext->ulBytesPerSample;
            }
        }
    }

    return ntStatus;

}

NTSTATUS
GetSetSampleRate( PIRP pIrp, PKSPROPERTY pKsProperty, PVOID pValue )
{
    PKSPIN pKsPin;
    NTSTATUS ntStatus;

    TRAP;

    pKsPin = KsGetPinFromIrp(pIrp);
    if (!pKsPin) {
        return STATUS_INVALID_PARAMETER;
    }

    if ( pKsProperty->Flags & KSPROPERTY_TYPE_GET ) {
        ntStatus = GetSampleRate( pKsPin, (PULONG)pValue );
    }
    else{
        ntStatus = SetSampleRate( pKsPin, (PULONG)pValue );
    }

    if ( NT_SUCCESS(ntStatus )) {
        pIrp->IoStatus.Information = sizeof(ULONG);
    }

    return ntStatus;
}


NTSTATUS
GetAudioLatency( PIRP pIrp, PKSPROPERTY pKsProperty, PVOID pValue )
{
    PKSPIN pKsPin;
    PPIN_CONTEXT pPinContext;
    PUSBAUDIO_DATARANGE pUsbAudioDataRange;

    PAUDIO_GENERAL_STREAM pGeneralDescriptor;
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PKSTIME pLatency = (PKSTIME) pValue;

    pKsPin = KsGetPinFromIrp(pIrp);
    if (!pKsPin) {
        return STATUS_INVALID_PARAMETER;
    }
    pPinContext = pKsPin->Context;
    pUsbAudioDataRange = pPinContext->pUsbAudioDataRange;

    // Find the general descriptor
    pGeneralDescriptor =
        (PAUDIO_GENERAL_STREAM) GetAudioSpecificInterface(
                                    pPinContext->pHwDevExt->pConfigurationDescriptor,
                                    pUsbAudioDataRange->pInterfaceDescriptor,
                                    AS_GENERAL);
    if ( pGeneralDescriptor ) {

        pLatency->Time = pGeneralDescriptor->bDelay;
        pLatency->Numerator = 10000;
        pLatency->Denominator = 1;

        pIrp->IoStatus.Information = sizeof (KSTIME);
    }
    else {
        ntStatus = STATUS_INVALID_PARAMETER;
    }

    return ntStatus;
}

NTSTATUS
GetAudioPosition( PIRP pIrp, PKSPROPERTY pProperty, PVOID pValue )
{
    PKSPIN pKsPin;
    PPIN_CONTEXT pPinContext;
    PKSAUDIO_POSITION pPosition = pValue;
    NTSTATUS ntStatus = STATUS_SUCCESS;

    ASSERT(pProperty->Flags & KSPROPERTY_TYPE_GET);

    pKsPin = KsGetPinFromIrp(pIrp);
    if (!pKsPin) {
        return STATUS_INVALID_PARAMETER;
    }
    pPinContext = pKsPin->Context;

    pPosition->WriteOffset = pPinContext->ullWriteOffset;

    if ( pKsPin->DataFlow == KSPIN_DATAFLOW_OUT )
        ntStatus = CaptureBytePosition(pKsPin, pPosition);

    // Otherwise initialize render stream structures based on stream type.
    else {

        switch( pPinContext->pUsbAudioDataRange->ulUsbDataFormat & USBAUDIO_DATA_FORMAT_TYPE_MASK) {
            case USBAUDIO_DATA_FORMAT_TYPE_I_UNDEFINED:
                ntStatus = TypeIRenderBytePosition( pPinContext, pPosition );
                break;

            case USBAUDIO_DATA_FORMAT_TYPE_II_UNDEFINED:
            case USBAUDIO_DATA_FORMAT_TYPE_III_UNDEFINED:
                // ISSUE-2001/01/12-dsisolak: This is not right. Needs repair...
                pPosition->PlayOffset = pPinContext->ullWriteOffset;
                break;
        }
    }

    DbgLog("GetPos", pPinContext, pPinContext->ullWriteOffset,
                     pPosition->WriteOffset, pPosition->PlayOffset);

    pIrp->IoStatus.Information = sizeof(KSAUDIO_POSITION);

    return ntStatus;
}


// Begin NODE Based Audio Properties

NTSTATUS
GetSetCopyProtection( PIRP pIrp, PKSPROPERTY pKsProperty, PVOID pData )
{
    PKSFILTER pKsFilter;
    PFILTER_CONTEXT pFilterContext;
    PTOPOLOGY_NODE_INFO pNodeInfo;
    PKSAUDIO_COPY_PROTECTION pProtect = (PKSAUDIO_COPY_PROTECTION) pData;
    UCHAR RequestType = (pKsProperty->Flags & KSPROPERTY_TYPE_GET) ? GET_CUR : SET_CUR;
    NTSTATUS ntStatus;
    ULONG ulData;

    pKsFilter = KsGetFilterFromIrp(pIrp);
    if (!pKsFilter) {
        return STATUS_INVALID_PARAMETER;
    }
    pFilterContext = pKsFilter->Context;
    pNodeInfo = GET_NODE_INFO_FROM_FILTER(pKsFilter,((PKSNODEPROPERTY)pKsProperty)->NodeId);

    if (pKsProperty->Flags & KSPROPERTY_TYPE_SET) {
        ulData = ((pProtect->fOriginal && pProtect->fCopyrighted) ? 1 : pProtect->fOriginal ? 2 : 0);
    }

    ntStatus = GetSetByte( pFilterContext->pNextDeviceObject,
                           pNodeInfo,
                           0,
                           &ulData,
                           RequestType );

    if ( NT_SUCCESS(ntStatus) ) {
        if (pKsProperty->Flags & KSPROPERTY_TYPE_SET) {
            pProtect->fCopyrighted = ulData;
            pProtect->fOriginal = (ulData & 0x01);
        }

        pIrp->IoStatus.Information = sizeof (KSAUDIO_COPY_PROTECTION);
    }

    return ntStatus;
}

NTSTATUS
GetChannelConfiguration( PIRP pIrp, PKSPROPERTY pKsProperty, PVOID pData )
{
    PKSFILTER pKsFilter;
    PFILTER_CONTEXT pFilterContext;
    PTOPOLOGY_NODE_INFO pNodeInfo;
    KSAUDIO_CHANNEL_CONFIG *pKsAudioChannelConfig = pData;
    NTSTATUS ntStatus = STATUS_SUCCESS;

    pKsFilter = KsGetFilterFromIrp(pIrp);
    if (!pKsFilter) {
        return STATUS_INVALID_PARAMETER;
    }
    pFilterContext = pKsFilter->Context;
    pNodeInfo = GET_NODE_INFO_FROM_FILTER(pKsFilter,((PKSNODEPROPERTY)pKsProperty)->NodeId);

    // Build the channel config data
    pKsAudioChannelConfig->ActiveSpeakerPositions =
         GetChannelConfigForUnit( pFilterContext->pHwDevExt->pConfigurationDescriptor,
                                  ((PAUDIO_UNIT)pNodeInfo->pUnit)->bUnitID );

    if (pKsAudioChannelConfig->ActiveSpeakerPositions == 0) {
        ULONG ulNumChannels = CountInputChannels( pFilterContext->pHwDevExt->pConfigurationDescriptor,
                                                  (ULONG)((PAUDIO_UNIT)pNodeInfo->pUnit)->bUnitID);
        if (ulNumChannels == 1)
            pKsAudioChannelConfig->ActiveSpeakerPositions = KSAUDIO_SPEAKER_MONO;
        else
            pKsAudioChannelConfig->ActiveSpeakerPositions = SPEAKER_RESERVED;
    }

    pIrp->IoStatus.Information = sizeof(KSAUDIO_CHANNEL_CONFIG);
    return ntStatus;
}


NTSTATUS
GetSetMixLevels( PIRP pIrp, PKSPROPERTY pKsProperty, PVOID pValue )
{
    PKSFILTER pKsFilter;
    PFILTER_CONTEXT pFilterContext;
    PTOPOLOGY_NODE_INFO pNodeInfo;
    PHW_DEVICE_EXTENSION pHwDevExt;

    USHORT UnitNumber;
    USHORT CtrlIf;
    PAUDIO_MIXER_UNIT pMixer;
    PAUDIO_MIXER_UNIT_CHANNELS pMixChannels;
    PSHORT pUsbMin, pUsbMax, pUsbRes, pUsbCur;
    ULONG nChannels, InputChannels, OutChannels, PinChannels;
    ULONG ChannelIndex, i, siz;
    PKSAUDIO_MIX_CAPS pMixCaps;
    PKSAUDIO_MIXLEVEL pMixLevel;
    PKSAUDIO_MIXCAP_TABLE pMixCapTable = NULL;
    PKSAUDIO_MIXLEVEL pMixLevelTable = NULL;
    NTSTATUS ntStatus = STATUS_SUCCESS;

    pKsFilter = KsGetFilterFromIrp(pIrp);
    if (!pKsFilter) {
        return STATUS_INVALID_PARAMETER;
    }
    pFilterContext = pKsFilter->Context;
    pNodeInfo  = GET_NODE_INFO_FROM_FILTER(pKsFilter,((PKSNODEPROPERTY)pKsProperty)->NodeId);
    pHwDevExt  = pFilterContext->pHwDevExt;
    UnitNumber = (USHORT)((PAUDIO_UNIT)pNodeInfo->pUnit)->bUnitID;
    CtrlIf     = pNodeInfo->MapNodeToCtrlIF;

    if ( pKsProperty->Id == KSPROPERTY_AUDIO_MIX_LEVEL_TABLE )
        pMixLevelTable = pValue;
    else if ( pKsProperty->Id == KSPROPERTY_AUDIO_MIX_LEVEL_CAPS )
        pMixCapTable = pValue;

    // We have to figure out how many output channels we have.
    pMixer = pNodeInfo->pUnit;

    pMixChannels = (PAUDIO_MIXER_UNIT_CHANNELS)(pMixer->baSourceID + pMixer->bNrInPins);

    OutChannels = pMixChannels->bNrChannels;

    // Now we have to figure out how many input channels we have.
    InputChannels = 0;
    for (i=0; i < pMixer->bNrInPins; i++) {
        // For each input pin, we walk the stream to discover the number of input channels.
        nChannels = CountInputChannels( pHwDevExt->pConfigurationDescriptor,
                                        pMixer->baSourceID[i] );
        InputChannels += nChannels;
        if ( i == pNodeInfo->ulPinNumber ) {
            PinChannels = nChannels;
            ChannelIndex = (InputChannels - nChannels) * OutChannels;
        }
    }

    // Calculate the size of the mix level table
    siz = InputChannels * OutChannels * sizeof(SHORT);

    if ( pMixCapTable ) {
        pMixCapTable->InputChannels  = PinChannels;
        pMixCapTable->OutputChannels = OutChannels;

        // If the request is simply for the number of input and output channels fill in structure and
        // return
        if ( pIrp->IoStatus.Information == 2*sizeof(ULONG) ) {
            return ntStatus;
        }
    }

    pUsbMin = AllocMem(NonPagedPool, siz*4); // Min, Max, Res, and Current
    if ( !pUsbMin ) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    // Initialize pointers for these even if we don't use them all
    pUsbMax = (PUSHORT)((PUCHAR)pUsbMin + siz);
    pUsbRes = (PUSHORT)((PUCHAR)pUsbMax + siz);
    pUsbCur = (PUSHORT)((PUCHAR)pUsbRes + siz);

    // If getting mix Caps and only want # of channels
    if ( pMixCapTable ) {

        // Get Min, Max, and Res
        for ( i=GET_MIN; i<GET_RES; i++ ) {
            ntStatus = GetSetProperty( pFilterContext->pNextDeviceObject,
                                URB_FUNCTION_CLASS_INTERFACE,
                                USBD_TRANSFER_DIRECTION_IN,
                                (UCHAR)i,
                                0,  // We get all the controls at once
                                0,
                                UnitNumber,
                                CtrlIf,
                                (PUCHAR)pUsbMin+(siz*i),
                                siz );

            if ( !NT_SUCCESS(ntStatus) ) {
                FreeMem( pUsbMin );
                return ntStatus;
            }
        }
    }

    // Get/Set the current values
    if ( pMixLevelTable) {

        // Get the minimum values
        ntStatus = GetSetProperty( pFilterContext->pNextDeviceObject,
                               URB_FUNCTION_CLASS_INTERFACE,
                               USBD_TRANSFER_DIRECTION_IN,
                               GET_MIN,
                               0,  // We get all the controls at once
                               0,
                               UnitNumber,
                               CtrlIf,
                               pUsbMin,
                               siz );

        if ( !NT_SUCCESS(ntStatus) ) {
            FreeMem(pUsbMin);
            return ntStatus;
        }

        ntStatus = GetSetProperty(pFilterContext->pNextDeviceObject,
                                URB_FUNCTION_CLASS_INTERFACE,
                                USBD_TRANSFER_DIRECTION_IN,
                                GET_CUR,
                                0,  // We get all the controls at once
                                0,
                                UnitNumber,
                                CtrlIf,
                                pUsbCur,
                                siz );

        if (!NT_SUCCESS(ntStatus)) {
            FreeMem( pUsbMin );
            return ntStatus;
        }

        if ( pKsProperty->Flags & KSPROPERTY_TYPE_SET ) {
           PUCHAR pCtrlBitmap = pMixChannels->bmControls;
           ULONG bmBytes = ((InputChannels*OutChannels)/8) +
                           (((InputChannels*OutChannels)%8) > 0) - 1;
           ULONG j, k;
            // Map the mix values to the usb structure
            pMixLevel = pMixLevelTable;
            for (i=0; i < PinChannels * OutChannels; i++) {
                if (pMixLevel->Mute)
                    pUsbCur[ChannelIndex + i] = pUsbMin[ChannelIndex + i];
                else
                    pUsbCur[ChannelIndex + i] = (SHORT)(pMixLevel->Level / DB_SCALE_16BIT);
                pMixLevel++;
            }

            k=0;
            for ( i=0; i<InputChannels*OutChannels; i++) {
                j = bmBytes - (i/8);
                if (pCtrlBitmap[j] & 0x80>>(i%8)) {
                    pUsbCur[k++] = pUsbCur[i];
                }
            }

            // Set the mix table
            ntStatus = GetSetProperty(pFilterContext->pNextDeviceObject,
                                URB_FUNCTION_CLASS_INTERFACE,
                                USBD_TRANSFER_DIRECTION_OUT,
                                SET_CUR,
                                (USHORT)0xFF,  // We get all the controls at once
                                (USHORT)0xFF,
                                UnitNumber,
                                CtrlIf,
                                pUsbCur,
                                k*sizeof(SHORT) );

            if (!NT_SUCCESS(ntStatus)) {
                FreeMem( pUsbMin );
                return ntStatus;
            }
        }
    }

    // Map the mix values to our structure.
    if ( pKsProperty->Flags & KSPROPERTY_TYPE_GET ) {
        pMixCaps = pMixCapTable->Capabilities;
        pMixLevel = pMixLevelTable;
        for (i=0; i < PinChannels * OutChannels; i++) {
            if (pMixCapTable) {
                pMixCaps->Minimum = (LONG)((SHORT)pUsbMin[ChannelIndex+i]) * DB_SCALE_16BIT;
                pMixCaps->Maximum = (LONG)((SHORT)pUsbMax[ChannelIndex+i]) * DB_SCALE_16BIT;
                pMixCaps->Reset   = (LONG)((SHORT)pUsbRes[ChannelIndex+i]) * DB_SCALE_16BIT;
                pMixCaps->Mute    = TRUE;
                pMixCaps++;
            }
            else if (pMixLevelTable) {
                pMixLevel->Level = (LONG)((SHORT)pUsbCur[ChannelIndex+i]) * DB_SCALE_16BIT;
                pMixLevel->Mute  = (pUsbCur[ChannelIndex+i] == pUsbMin[ChannelIndex+i]);
                pMixLevel++;
            }
        }
    }

    if (pMixCapTable) {
        pIrp->IoStatus.Information = (2*sizeof(ULONG)) +
                    PinChannels * OutChannels * sizeof (KSAUDIO_MIX_CAPS);
    }
    else if (pMixLevelTable) {
        pIrp->IoStatus.Information = PinChannels * OutChannels * sizeof (KSAUDIO_MIXLEVEL);
    }

    FreeMem(pUsbMin);

    return STATUS_SUCCESS;
}

NTSTATUS
GetMuxSource( PIRP pIrp, PKSPROPERTY pKsProperty, PVOID pValue )
{
    PKSFILTER pKsFilter;
    PFILTER_CONTEXT pFilterContext;
    PTOPOLOGY_NODE_INFO pNodeInfo;

    PAUDIO_SELECTOR_UNIT pSel;
    NTSTATUS ntStatus;
    UCHAR ucData;

    pKsFilter = KsGetFilterFromIrp(pIrp);
    if (!pKsFilter) {
        return STATUS_INVALID_PARAMETER;
    }
    pFilterContext = pKsFilter->Context;
    pNodeInfo = GET_NODE_INFO_FROM_FILTER(pKsFilter,((PKSNODEPROPERTY)pKsProperty)->NodeId);
    pSel = pNodeInfo->pUnit;

    ntStatus = GetSetProperty( pFilterContext->pNextDeviceObject,
                               URB_FUNCTION_CLASS_INTERFACE,
                               USBD_TRANSFER_DIRECTION_IN,
                               GET_CUR,
                               0,
                               0,
                               (USHORT)pSel->bUnitID,
                               (USHORT)pNodeInfo->MapNodeToCtrlIF,
                               &ucData,
                               sizeof(UCHAR) );

    if ( !NT_SUCCESS(ntStatus) ) {
        return ntStatus;
    }

    *(PULONG)pValue = (ULONG)ucData;

    pIrp->IoStatus.Information = sizeof(ULONG);

    return ntStatus;
}


NTSTATUS
SetMuxSource( PIRP pIrp, PKSPROPERTY pKsProperty, PVOID pValue )
{
    PKSFILTER pKsFilter;
    PFILTER_CONTEXT pFilterContext;
    PTOPOLOGY_NODE_INFO pNodeInfo;

    PAUDIO_SELECTOR_UNIT pSel;
    NTSTATUS ntStatus;
    UCHAR ucData;

    pKsFilter = KsGetFilterFromIrp(pIrp);
    if (!pKsFilter) {
        return STATUS_INVALID_PARAMETER;
    }
    pFilterContext = pKsFilter->Context;
    pNodeInfo = GET_NODE_INFO_FROM_FILTER(pKsFilter,((PKSNODEPROPERTY)pKsProperty)->NodeId);
    pSel = pNodeInfo->pUnit;

    // Data is the pin number.
    ucData = *(PUCHAR)pValue;

    ntStatus = GetSetProperty( pFilterContext->pNextDeviceObject,
                               URB_FUNCTION_CLASS_INTERFACE,
                               USBD_TRANSFER_DIRECTION_OUT,
                               SET_CUR,
                               0,
                               0,
                               (USHORT) pSel->bUnitID,
                               (USHORT) pNodeInfo->MapNodeToCtrlIF,
                               &ucData,
                               sizeof(UCHAR) );

    pIrp->IoStatus.Information = sizeof(ULONG);

    return ntStatus;
}


NTSTATUS
GetEqualizerValues(
    PDEVICE_OBJECT pNextDeviceObject,
    PTOPOLOGY_NODE_INFO pNodeInfo,
    USHORT usChannel,
    UCHAR  Command,
    PLONG  EqLevel,
    PULONG EqBands,
    PULONG NumEqBands)
{

    PUCHAR pData;
    // NOTE: The second one is really 31.5 Hz - how should we handle it?
    ULONG BandFreq[] =
        { 25,   32,   40,   50,   63,   80,   100,   125,   160,   200,
          250,  315,  400,  500,  630,  800,  1000,  1250,  1600,  2000,
          2500, 3150, 4000, 5000, 6300, 8000, 10000, 12500, 16000, 20000 };
    ULONG siz;
    ULONG bmBandsPresent;
    ULONG Band;
    ULONG UsbBand;
    NTSTATUS Status;

    // TODO: Optimize by setting up cache for EQ

    // Allocate space for 30 bands
    siz = MAX_EQ_BANDS * sizeof(UCHAR) + sizeof(ULONG);
    pData = AllocMem(NonPagedPool, siz);
    if ( !pData ) return STATUS_INSUFFICIENT_RESOURCES;

    Status = GetSetProperty( pNextDeviceObject,
                             URB_FUNCTION_CLASS_INTERFACE,
                             USBD_TRANSFER_DIRECTION_IN,
                             Command,
                             GRAPHIC_EQUALIZER_CONTROL,
                             (USHORT)(usChannel + 1),
                             (USHORT)((PAUDIO_UNIT)pNodeInfo->pUnit)->bUnitID,
                             (USHORT)pNodeInfo->MapNodeToCtrlIF,
                             pData,
                             siz );

      if (NT_SUCCESS(Status)) {

        bmBandsPresent = *((PULONG)pData);
        Band = 0;
        UsbBand = 0;

        if (NumEqBands) *NumEqBands = 0;
        while (bmBandsPresent) {
            if (bmBandsPresent & 1) {
                // Put the data into our structure
                if (EqLevel)
                    EqLevel[Band] = (LONG)((CHAR)pData[sizeof(ULONG)+Band]) * DB_SCALE_8BIT;
                else if (EqBands)
                    EqBands[Band] = BandFreq[UsbBand];
                if (NumEqBands)
                    (*NumEqBands)++;

                Band++;
            }
            bmBandsPresent >>= 1;
            UsbBand++;
        }
      }

    FreeMem(pData);

    return Status;
}

NTSTATUS
SetEqualizerValues(
    PDEVICE_OBJECT pNextDeviceObject,
    PTOPOLOGY_NODE_INFO pNodeInfo,
    USHORT usChannel,
    PULONG pNumBands,
    PLONG  EqLevel )
{
    USHORT UnitNumber = (USHORT)((PAUDIO_UNIT)pNodeInfo->pUnit)->bUnitID;
    USHORT CtrlIF     = (USHORT)pNodeInfo->MapNodeToCtrlIF;
    ULONG siz, bmBandsPresent, Band, UsbBand;
    NTSTATUS ntStatus;
    PUCHAR pData;

    // Allocate space for 30 bands
    siz = MAX_EQ_BANDS * sizeof(UCHAR) + sizeof(ULONG);
    pData = AllocMem(NonPagedPool, siz);
    if (!pData) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    // Get the bands present
    ntStatus = GetSetProperty( pNextDeviceObject,
                               URB_FUNCTION_CLASS_INTERFACE,
                               USBD_TRANSFER_DIRECTION_IN,
                               GET_CUR,
                               GRAPHIC_EQUALIZER_CONTROL,
                               (USHORT)(usChannel + 1),
                               UnitNumber,
                               CtrlIF,
                               pData,
                               siz );

    if (!NT_SUCCESS(ntStatus) ) {
        FreeMem(pData);
        return ntStatus;
    }

    bmBandsPresent = *((PULONG)pData);
    Band = 0;
    UsbBand = 0;
    while (bmBandsPresent) {
        if (bmBandsPresent & 1) {
            // Put the data into the usb structure
            pData[sizeof(ULONG) + Band] = (UCHAR) (EqLevel[Band] / DB_SCALE_8BIT);
            Band++;
        }
        bmBandsPresent >>= 1;
        UsbBand++;
    }

    ntStatus = GetSetProperty( pNextDeviceObject,
                               URB_FUNCTION_CLASS_INTERFACE,
                               USBD_TRANSFER_DIRECTION_OUT,
                               SET_CUR,
                               GRAPHIC_EQUALIZER_CONTROL,
                               (USHORT)(usChannel + 1),
                               UnitNumber,
                               CtrlIF,
                               pData,
                               Band + sizeof(ULONG) );

    *pNumBands = Band;

    FreeMem(pData);

    return ntStatus;
}

NTSTATUS
GetNumEqualizerBands( PIRP pIrp, PKSPROPERTY pProperty, PVOID pValue )
{
    PKSNODEPROPERTY_AUDIO_CHANNEL pNAC = (PKSNODEPROPERTY_AUDIO_CHANNEL)pProperty;
    PKSFILTER pKsFilter;
    PFILTER_CONTEXT pFilterContext;
    PTOPOLOGY_NODE_INFO pNodeInfo;
    NTSTATUS ntStatus = STATUS_INVALID_DEVICE_REQUEST;

    pKsFilter = KsGetFilterFromIrp(pIrp);
    if (!pKsFilter) {
        return STATUS_INVALID_PARAMETER;
    }
    pFilterContext = pKsFilter->Context;
    pNodeInfo = GET_NODE_INFO_FROM_FILTER(pKsFilter,pNAC->NodeProperty.NodeId);

    ntStatus = GetEqualizerValues( pFilterContext->pNextDeviceObject,
                                   pNodeInfo,
                                   (USHORT)pNAC->Channel,
                                   GET_CUR,
                                   NULL,
                                   NULL,
                                   pValue );

    if ( NT_SUCCESS(ntStatus) )
        pIrp->IoStatus.Information = sizeof(ULONG);

    return ntStatus;
}


NTSTATUS
GetEqualizerBands( PIRP pIrp, PKSPROPERTY pProperty, PVOID pValue )
{
    PKSNODEPROPERTY_AUDIO_CHANNEL pNAC = (PKSNODEPROPERTY_AUDIO_CHANNEL)pProperty;
    PKSFILTER pKsFilter;
    PFILTER_CONTEXT pFilterContext;
    PTOPOLOGY_NODE_INFO pNodeInfo;
    NTSTATUS ntStatus = STATUS_INVALID_DEVICE_REQUEST;
    ULONG ulNumBands;

    pKsFilter = KsGetFilterFromIrp(pIrp);
    if (!pKsFilter) {
        return STATUS_INVALID_PARAMETER;
    }
    pFilterContext = pKsFilter->Context;
    pNodeInfo = GET_NODE_INFO_FROM_FILTER(pKsFilter,pNAC->NodeProperty.NodeId);

    ntStatus = GetEqualizerValues( pFilterContext->pNextDeviceObject,
                                   pNodeInfo,
                                   (USHORT)pNAC->Channel,
                                   GET_CUR,
                                   NULL,
                                   pValue,
                                   &ulNumBands );

    if ( NT_SUCCESS(ntStatus) )
        pIrp->IoStatus.Information = sizeof(ULONG) * ulNumBands;

    return ntStatus;
}


NTSTATUS
GetSetEqualizerLevels( PIRP pIrp, PKSPROPERTY pProperty, PVOID pValue )
{
    PKSNODEPROPERTY_AUDIO_CHANNEL pNAC = (PKSNODEPROPERTY_AUDIO_CHANNEL)pProperty;
    PKSFILTER pKsFilter;
    PFILTER_CONTEXT pFilterContext;
    PTOPOLOGY_NODE_INFO pNodeInfo;
    NTSTATUS ntStatus = STATUS_INVALID_DEVICE_REQUEST;
    ULONG ulNumBands;

    pKsFilter = KsGetFilterFromIrp(pIrp);
    if (!pKsFilter) {
        return STATUS_INVALID_PARAMETER;
    }
    pFilterContext = pKsFilter->Context;
    pNodeInfo = GET_NODE_INFO_FROM_FILTER(pKsFilter,pNAC->NodeProperty.NodeId);

    if ( pProperty->Flags & KSPROPERTY_TYPE_GET ) {
        ntStatus = GetEqualizerValues( pFilterContext->pNextDeviceObject,
                                       pNodeInfo,
                                       (USHORT)pNAC->Channel,
                                       GET_CUR,
                                       pValue,
                                       NULL,
                                       &ulNumBands );
    }
    else if ( pProperty->Flags & KSPROPERTY_TYPE_SET ) {
        ntStatus = SetEqualizerValues( pFilterContext->pNextDeviceObject,
                                       pNodeInfo,
                                       (USHORT)pNAC->Channel,
                                       &ulNumBands,
                                       pValue );
    }

    if ( NT_SUCCESS(ntStatus) )
        pIrp->IoStatus.Information = ulNumBands * sizeof(LONG);

    return ntStatus;
}

NTSTATUS
GetEqDbRanges( PDEVICE_OBJECT pNextDeviceObject,
               PTOPOLOGY_NODE_INFO pNodeInfo,
               USHORT usChannel,
               PKSPROPERTY_STEPPING_LONG pEqBandSteps )
{
    ULONG ulNumEqBands;
    PLONG pMinEqLevels;
    PLONG pMaxEqLevels;
    PLONG pResEqLevels;
    NTSTATUS ntStatus;
    ULONG i, j;

    ntStatus = GetEqualizerValues( pNextDeviceObject,
                                   pNodeInfo,
                                   usChannel,
                                   GET_CUR,
                                   NULL,
                                   NULL,
                                   &ulNumEqBands );

    if ( !NT_SUCCESS(ntStatus) ) return ntStatus;

    pMinEqLevels = (PULONG)AllocMem( NonPagedPool, 3*ulNumEqBands*sizeof(LONG) );
    if ( !pMinEqLevels ) return STATUS_INSUFFICIENT_RESOURCES;

    pMaxEqLevels = pMinEqLevels + ulNumEqBands;
    pResEqLevels = pMaxEqLevels + ulNumEqBands;

    for ( i=GET_MIN, j=0; i<=GET_RES; i++, j++ ) {
        ntStatus = GetEqualizerValues( pNextDeviceObject,
                                       pNodeInfo,
                                       usChannel,
                                       (UCHAR)i,
                                       pMinEqLevels + (ulNumEqBands*j),
                                       NULL,
                                       NULL );
        if ( !NT_SUCCESS(ntStatus) ) {
            FreeMem(pMinEqLevels);
            return ntStatus;
        }

    }

    for (i=0; i<ulNumEqBands; i++) {
        pEqBandSteps[i].Bounds.SignedMinimum = pMinEqLevels[i];
        pEqBandSteps[i].Bounds.SignedMaximum = pMaxEqLevels[i];
        pEqBandSteps[i].SteppingDelta        = pResEqLevels[i];
    }

    FreeMem(pMinEqLevels);

    return ntStatus;

}

NTSTATUS
GetSetDeviceSpecific( PIRP pIrp, PKSPROPERTY pProperty, PVOID pValue )
{
    PKSFILTER pKsFilter = NULL;
    PFILTER_CONTEXT pFilterContext = NULL;
    PKSNODEPROPERTY_AUDIO_DEV_SPECIFIC pDevSpecNodeProp =
                                    (PKSNODEPROPERTY_AUDIO_DEV_SPECIFIC) pProperty;
    UCHAR  bRequest = (UCHAR)((pDevSpecNodeProp->DevSpecificId & 0xFF000000)>>24);
    UCHAR  bmRequestType = (UCHAR)((pDevSpecNodeProp->DevSpecificId & 0x00FF0000)>>16);
    USHORT wValue = (USHORT)(pDevSpecNodeProp->DevSpecificId & 0xFFFF);
    USHORT wIndex = (USHORT)((pDevSpecNodeProp->DeviceInfo & 0xFFFF0000)>>16);
    USHORT wLength = (USHORT)(pDevSpecNodeProp->DeviceInfo & 0xFFFF);
    ULONG  DirectionFlag;
    USHORT FunctionClass;
    NTSTATUS ntStatus;

    pKsFilter = KsGetFilterFromIrp(pIrp);
    if (pKsFilter) {
        pFilterContext = pKsFilter->Context;
    }

    if (!pFilterContext) {
        return STATUS_INVALID_PARAMETER;
    }

    DirectionFlag = (bRequest & CLASS_SPECIFIC_GET_MASK) ? USBD_TRANSFER_DIRECTION_IN :
                                                           USBD_TRANSFER_DIRECTION_OUT;

    FunctionClass = (bmRequestType == USB_COMMAND_TO_INTERFACE) ? URB_FUNCTION_CLASS_INTERFACE :
                    (bmRequestType == USB_COMMAND_TO_ENDPOINT)  ? URB_FUNCTION_CLASS_ENDPOINT  :
                    0;

    if ( !FunctionClass ) {
        return STATUS_NOT_SUPPORTED;
    }

    _DbgPrintF(DEBUGLVL_VERBOSE,("'DevSpecificId: %x\n",pDevSpecNodeProp->DevSpecificId));
    _DbgPrintF(DEBUGLVL_VERBOSE,("'DeviceInfo: %x\n",pDevSpecNodeProp->DeviceInfo));


    _DbgPrintF(DEBUGLVL_VERBOSE,("'FunctionClass: %x\n",FunctionClass));
    _DbgPrintF(DEBUGLVL_VERBOSE,("'DirectionFlag: %x\n",DirectionFlag));
    _DbgPrintF(DEBUGLVL_VERBOSE,("'bRequest: %x\n",bRequest));
    _DbgPrintF(DEBUGLVL_VERBOSE,("'bmRequestType: %x\n",bmRequestType));
    _DbgPrintF(DEBUGLVL_VERBOSE,("'wValue: %x\n",wValue));
    _DbgPrintF(DEBUGLVL_VERBOSE,("'wIndex: %x\n",wIndex));
    _DbgPrintF(DEBUGLVL_VERBOSE,("'wLength: %x\n",wLength));

    ntStatus = GetSetProperty( pFilterContext->pNextDeviceObject,
                               FunctionClass,
                               DirectionFlag,
                               bRequest,
                               (USHORT) ((wValue & 0xFF00)>>8),
                               (USHORT) (wValue & 0xFF),
                               (USHORT) ((wIndex & 0xFF00)>>8),
                               (USHORT) (wIndex & 0xFF),
                               pValue,
                               wLength );

    if ( NT_SUCCESS(ntStatus) ) {
        pIrp->IoStatus.Information = (ULONG)wLength;
    }

    return ntStatus;
}


NTSTATUS
GetSetAudioControlLevel( PIRP pIrp, PKSPROPERTY pProperty, PVOID pValue )
{
    PKSFILTER pKsFilter;
    PFILTER_CONTEXT pFilterContext;
    PTOPOLOGY_NODE_INFO pNodeInfo;
    UCHAR ucRequestType = (pProperty->Flags & KSPROPERTY_TYPE_GET) ? GET_CUR : SET_CUR;
    PPROCESS_CTRL_CACHE pPCtrlCache;
    PPROCESS_CTRL_RANGE pPCtrlRange;

    ULONG ulControlType =
          (pProperty->Id == KSPROPERTY_AUDIO_REVERB_LEVEL) ? REVERB_LEVEL_CONTROL :
          (pProperty->Id == KSPROPERTY_AUDIO_CHORUS_LEVEL) ? CHORUS_LEVEL_CONTROL :
                                                             SPACIOUSNESS_CONTROL ;
    ULONG ulData;
    NTSTATUS ntStatus;

//    TRAP;

    pKsFilter = KsGetFilterFromIrp(pIrp);
    if (!pKsFilter) {
        return STATUS_INVALID_PARAMETER;
    }
    pFilterContext = pKsFilter->Context;
    pNodeInfo = GET_NODE_INFO_FROM_FILTER(pKsFilter,((PKSNODEPROPERTY)pProperty)->NodeId);
    pPCtrlCache = (PPROCESS_CTRL_CACHE)(pNodeInfo->pCachedValues);
    pPCtrlRange = (PPROCESS_CTRL_RANGE)(pPCtrlCache+1);

    _DbgPrintF(DEBUGLVL_VERBOSE,("[GetSetAudioControlLevel] pNodeInfo %x\n",pNodeInfo));

    if ( pNodeInfo->ulControlType != ulControlType ) {
        return STATUS_INVALID_DEVICE_REQUEST;
    }

    if ( SET_CUR == ucRequestType ) {
        ulData = (*((PULONG)pValue)) / 0x10000L;
    }

    ntStatus = GetSetByte( pFilterContext->pNextDeviceObject,
                           pNodeInfo,
                           0,
                           &ulData,
                           ucRequestType );

    if ( NT_SUCCESS(ntStatus) ) {
        if ( GET_CUR == ucRequestType ) {
            *((PULONG)pValue) = ulData * 0x10000L;
        }
        pIrp->IoStatus.Information = sizeof(ULONG);
    }

    return ntStatus;
}


NTSTATUS
GetSetBoolean( PIRP pIrp, PKSPROPERTY pProperty, PVOID pValue )
{
    PKSNODEPROPERTY_AUDIO_CHANNEL pNAC = (PKSNODEPROPERTY_AUDIO_CHANNEL)pProperty;
    PKSFILTER pKsFilter;
    PFILTER_CONTEXT pFilterContext;
    PTOPOLOGY_NODE_INFO pNodeInfo;
    ULONG ulChannel = pNAC->Channel;
    PBOOLEAN_CTRL_CACHE pBoolCache;
    UCHAR ucRequestType  = (pProperty->Flags & KSPROPERTY_TYPE_GET) ? GET_CUR : SET_CUR;
    NTSTATUS ntStatus = STATUS_INVALID_DEVICE_REQUEST;

    pKsFilter = KsGetFilterFromIrp(pIrp);
    if (!pKsFilter) {
        return STATUS_INVALID_PARAMETER;
    }
    pFilterContext = pKsFilter->Context;
    pNodeInfo = GET_NODE_INFO_FROM_FILTER(pKsFilter,pNAC->NodeProperty.NodeId);
    pBoolCache = (PBOOLEAN_CTRL_CACHE)pNodeInfo->pCachedValues;

    _DbgPrintF(DEBUGLVL_VERBOSE,("[GetSetBoolean] pNodeInfo %x\n",pNodeInfo));

    // Determine if this is a request for beyond # of channels available
    if ( ulChannel >= pNodeInfo->ulChannels ) {
        return ntStatus;
    }

    // Find the Cache for the requested channel
    pBoolCache += ulChannel;
    DbgLog("GSBool", &pNodeInfo, ulChannel, pBoolCache, pBoolCache->ulChannelIndex );

    if ( pNodeInfo->ulCacheValid & (1<<ulChannel)  ) {
        if ( ucRequestType == GET_CUR ) {
            *(PBOOL)pValue = pBoolCache->fLastValueSet;
            ntStatus = STATUS_SUCCESS;
        }
        else if ( pBoolCache->fLastValueSet == *(PBOOL)pValue ){
            ntStatus = STATUS_SUCCESS;
        }
        else {
            ntStatus = GetSetByte( pFilterContext->pNextDeviceObject,
                                   pNodeInfo,
                                   pBoolCache->ulChannelIndex,
                                   pValue,
                                   ucRequestType );
        }
    }
    else {
        ntStatus = GetSetByte( pFilterContext->pNextDeviceObject,
                               pNodeInfo,
                               pBoolCache->ulChannelIndex,
                               pValue,
                               ucRequestType );

        if ( NT_SUCCESS(ntStatus) ) {
            pNodeInfo->ulCacheValid |= (1<<ulChannel) ;
        }
    }

    if ( NT_SUCCESS(ntStatus)) {
        pBoolCache->fLastValueSet = *(PBOOL)pValue;
        pIrp->IoStatus.Information = sizeof(BOOL);
    }

    return ntStatus;
}

NTSTATUS
GetSetVolumeLevel( PIRP pIrp, PKSPROPERTY pProperty, PVOID pValue )
{
    PKSNODEPROPERTY_AUDIO_CHANNEL pNAC = (PKSNODEPROPERTY_AUDIO_CHANNEL)pProperty;
    PKSFILTER pKsFilter;
    PFILTER_CONTEXT pFilterContext;
    PTOPOLOGY_NODE_INFO pNodeInfo;
    UCHAR ucRequestType = (pProperty->Flags & KSPROPERTY_TYPE_GET) ? GET_CUR : SET_CUR;
    NTSTATUS ntStatus;

    pKsFilter = KsGetFilterFromIrp(pIrp);
    if (!pKsFilter) {
        return STATUS_INVALID_PARAMETER;
    }
    pFilterContext = pKsFilter->Context;
    pNodeInfo = GET_NODE_INFO_FROM_FILTER(pKsFilter,pNAC->NodeProperty.NodeId);

    _DbgPrintF(DEBUGLVL_VERBOSE,("[GetSetVolumeLevel] pNodeInfo %x\n",pNodeInfo));
//    TRAP;

    ntStatus = GetSetDBLevel( pFilterContext->pNextDeviceObject,
                              pNodeInfo,
                              pValue,
                              pNAC->Channel,
                              16,
                              ucRequestType );

    if ( NT_SUCCESS(ntStatus) ) {
        pIrp->IoStatus.Information = sizeof(ULONG);
    }

    return ntStatus;
}

NTSTATUS
GetSetToneLevel( PIRP pIrp, PKSPROPERTY pProperty, PVOID pValue )
{
    PKSNODEPROPERTY_AUDIO_CHANNEL pNAC = (PKSNODEPROPERTY_AUDIO_CHANNEL)pProperty;
    PKSFILTER pKsFilter;
    PFILTER_CONTEXT pFilterContext;
    PTOPOLOGY_NODE_INFO pNodeInfo;

    UCHAR ucRequestType = (pProperty->Flags & KSPROPERTY_TYPE_GET) ? GET_CUR : SET_CUR;
    NTSTATUS ntStatus;

    pKsFilter = KsGetFilterFromIrp(pIrp);
    if (!pKsFilter) {
        return STATUS_INVALID_PARAMETER;
    }
    pFilterContext = pKsFilter->Context;
    pNodeInfo = GET_NODE_INFO_FROM_FILTER(pKsFilter,pNAC->NodeProperty.NodeId);

    _DbgPrintF(DEBUGLVL_VERBOSE,("[GetSetToneLevel] pNodeInfo %x\n",pNodeInfo));

    ntStatus = GetSetDBLevel( pFilterContext->pNextDeviceObject,
                              pNodeInfo,
                              pValue,
                              pNAC->Channel,
                              8,
                              ucRequestType );

    if ( NT_SUCCESS(ntStatus) ) {
        pIrp->IoStatus.Information = sizeof(ULONG);
    }

    return ntStatus;
}

NTSTATUS
GetBasicSupportBoolean( PIRP pIrp, PKSPROPERTY pKsProperty, PVOID pData )
{
    PKSNODEPROPERTY pNodeProperty  = (PKSNODEPROPERTY)pKsProperty;
    PKSFILTER pKsFilter;
    PFILTER_CONTEXT pFilterContext;
    PTOPOLOGY_NODE_INFO pNodeInfo;
    PIO_STACK_LOCATION pIrpStack   = IoGetCurrentIrpStackLocation( pIrp );
    PKSPROPERTY_DESCRIPTION pPropDesc = pData;
    NTSTATUS ntStatus = STATUS_INVALID_DEVICE_REQUEST; //Assume failure, hope for better
    ULONG ulOutputBufferLength = pIrpStack->Parameters.DeviceIoControl.OutputBufferLength;

#ifdef DEBUG
    if ( ulOutputBufferLength != sizeof(ULONG) ) {
        ULONG ulInputBufferLength;

        ulInputBufferLength = pIrpStack->Parameters.DeviceIoControl.InputBufferLength;
        ASSERT(ulInputBufferLength >= sizeof( KSNODEPROPERTY ));
    }
#endif

    pKsFilter = KsGetFilterFromIrp(pIrp);
    if (!pKsFilter) {
        return STATUS_INVALID_PARAMETER;
    }
    pFilterContext = pKsFilter->Context;
    pNodeInfo = GET_NODE_INFO_FROM_FILTER(pKsFilter,pNodeProperty->NodeId);

    _DbgPrintF(DEBUGLVL_VERBOSE,("[GetBasicSupportBoolean] pNodeInfo %x NodeId %x\n",
                                 pNodeInfo,
                                 pNodeProperty->NodeId));

    if ( ulOutputBufferLength == sizeof(ULONG) ) {
        PULONG pAccessFlags = pData;
        *pAccessFlags = KSPROPERTY_TYPE_BASICSUPPORT |
                        KSPROPERTY_TYPE_GET |
                        KSPROPERTY_TYPE_SET;
        ntStatus = STATUS_SUCCESS;
    }
    else if ( ulOutputBufferLength >= sizeof( KSPROPERTY_DESCRIPTION )) {
        ULONG ulNumChannels = pNodeInfo->ulChannels;

        _DbgPrintF(DEBUGLVL_VERBOSE,("[GetBasicSupportBoolean] ulChannelConfig %x ulNumChannels %x\n",
                                     pNodeInfo->ulChannelConfig,
                                     ulNumChannels));

        pPropDesc->AccessFlags = KSPROPERTY_TYPE_BASICSUPPORT |
                                 KSPROPERTY_TYPE_GET |
                                 KSPROPERTY_TYPE_SET;
        pPropDesc->DescriptionSize   = sizeof(KSPROPERTY_DESCRIPTION) +
                                       sizeof(KSPROPERTY_MEMBERSHEADER);
        pPropDesc->PropTypeSet.Set   = KSPROPTYPESETID_General;
        pPropDesc->PropTypeSet.Id    = VT_BOOL;
        pPropDesc->PropTypeSet.Flags = 0;
        pPropDesc->MembersListCount  = 1;
        pPropDesc->Reserved          = 0;

        pIrp->IoStatus.Information = sizeof( KSPROPERTY_DESCRIPTION );
        ntStatus = STATUS_SUCCESS;

        if ( ulOutputBufferLength > sizeof(KSPROPERTY_DESCRIPTION)){

            PKSPROPERTY_MEMBERSHEADER pMembers = (PKSPROPERTY_MEMBERSHEADER)(pPropDesc + 1);

            pMembers->MembersFlags = 0;
            pMembers->MembersSize  = 0;
            pMembers->MembersCount = ulNumChannels;
            pMembers->Flags        = KSPROPERTY_MEMBER_FLAG_BASICSUPPORT_MULTICHANNEL;
            // If there is a Master channel, make this node UNIFORM
            if (pNodeInfo->ulChannelConfig & 1) {
                pMembers->Flags |= KSPROPERTY_MEMBER_FLAG_BASICSUPPORT_UNIFORM;
            }
            pIrp->IoStatus.Information = pPropDesc->DescriptionSize;
        }
    }

    return ntStatus;
}

NTSTATUS
GetBasicSupport( PIRP pIrp, PKSPROPERTY pKsProperty, PVOID pData )
{
    PKSNODEPROPERTY pNodeProperty  = (PKSNODEPROPERTY)pKsProperty;
    PKSFILTER pKsFilter;
    PFILTER_CONTEXT pFilterContext;
    PTOPOLOGY_NODE_INFO pNodeInfo;
    PIO_STACK_LOCATION pIrpStack = IoGetCurrentIrpStackLocation( pIrp );
    PKSPROPERTY_DESCRIPTION pPropDesc = pData;
    NTSTATUS ntStatus = STATUS_INVALID_DEVICE_REQUEST; //Assume failure, hope for better
    ULONG ulOutputBufferLength = pIrpStack->Parameters.DeviceIoControl.OutputBufferLength;

    pKsFilter = KsGetFilterFromIrp(pIrp);
    if (!pKsFilter) {
        return STATUS_INVALID_PARAMETER;
    }
    pFilterContext = pKsFilter->Context;
    pNodeInfo = GET_NODE_INFO_FROM_FILTER(pKsFilter,pNodeProperty->NodeId);

#ifdef DEBUG
    if ( ulOutputBufferLength != sizeof(ULONG) ) {
        ULONG ulInputBufferLength;

        ulInputBufferLength = pIrpStack->Parameters.DeviceIoControl.InputBufferLength;
        ASSERT(ulInputBufferLength >= sizeof( KSNODEPROPERTY ));
    }
#endif

    _DbgPrintF(DEBUGLVL_VERBOSE,("[GetBasicSupport] pNodeInfo %x NodeId %x\n",pNodeInfo,pNodeProperty->NodeId));

    if ( ulOutputBufferLength == sizeof(ULONG) ) {
        PULONG pAccessFlags = pData;
        *pAccessFlags = KSPROPERTY_TYPE_BASICSUPPORT |
                        KSPROPERTY_TYPE_GET |
                        KSPROPERTY_TYPE_SET;
        ntStatus = STATUS_SUCCESS;
    }
    else if ( ulOutputBufferLength >= sizeof( KSPROPERTY_DESCRIPTION )) {
        ULONG ulNumChannels = pNodeInfo->ulChannels;

        if ( pNodeProperty->Property.Id == KSPROPERTY_AUDIO_EQ_LEVEL ) {
            ntStatus = GetEqualizerValues( pFilterContext->pNextDeviceObject,
                                           pNodeInfo,
                                           (USHORT)0xffff, // NOTE: Assuming master channel
                                           GET_CUR,
                                           NULL,
                                           NULL,
                                           &ulNumChannels );
            if ( !NT_SUCCESS( ntStatus ) )
                return ntStatus;
        }

        pPropDesc->AccessFlags = KSPROPERTY_TYPE_BASICSUPPORT |
                                 KSPROPERTY_TYPE_GET |
                                 KSPROPERTY_TYPE_SET;
        pPropDesc->DescriptionSize   = sizeof(KSPROPERTY_DESCRIPTION)   +
                                       sizeof(KSPROPERTY_MEMBERSHEADER) +
                                       (sizeof(KSPROPERTY_STEPPING_LONG) * ulNumChannels );
        pPropDesc->PropTypeSet.Set   = KSPROPTYPESETID_General;
        pPropDesc->PropTypeSet.Id    = VT_I4;
        pPropDesc->PropTypeSet.Flags = 0;
        pPropDesc->MembersListCount  = 1;
        pPropDesc->Reserved          = 0;

        pIrp->IoStatus.Information = sizeof( KSPROPERTY_DESCRIPTION );
        ntStatus = STATUS_SUCCESS;

        if ( ulOutputBufferLength > sizeof(KSPROPERTY_DESCRIPTION)){

            PKSPROPERTY_MEMBERSHEADER pMembers = (PKSPROPERTY_MEMBERSHEADER)(pPropDesc + 1);
            PKSPROPERTY_STEPPING_LONG pRange   = (PKSPROPERTY_STEPPING_LONG)(pMembers + 1);

            pMembers->MembersFlags = KSPROPERTY_MEMBER_STEPPEDRANGES;
            pMembers->MembersSize  = sizeof(KSPROPERTY_STEPPING_LONG);
            pMembers->MembersCount = ulNumChannels;
            pMembers->Flags        = KSPROPERTY_MEMBER_FLAG_BASICSUPPORT_MULTICHANNEL;
            // If there is a Master channel, make this node UNIFORM
            if (pNodeInfo->ulChannelConfig & 1) {
                pMembers->Flags |= KSPROPERTY_MEMBER_FLAG_BASICSUPPORT_UNIFORM;
            }

            switch ( pNodeProperty->Property.Id ) {
                case KSPROPERTY_AUDIO_VOLUMELEVEL:
                case KSPROPERTY_AUDIO_BASS:
                case KSPROPERTY_AUDIO_MID:
                case KSPROPERTY_AUDIO_TREBLE:
                    {
                        ULONG ulControlType =
                            (pNodeProperty->Property.Id == KSPROPERTY_AUDIO_VOLUMELEVEL) ? VOLUME_CONTROL  :
                            (pNodeProperty->Property.Id == KSPROPERTY_AUDIO_BASS)        ? BASS_CONTROL  :
                            (pNodeProperty->Property.Id == KSPROPERTY_AUDIO_MID )        ? MID_CONTROL   :
                                                                                           TREBLE_CONTROL;
                        PDB_LEVEL_CACHE pDbCache = pNodeInfo->pCachedValues;
                        ULONG ulControlSize = (ulControlType == VOLUME_CONTROL ) ? 16 : 8;
                        ULONG i;

                        for (i=0; i<ulNumChannels; i++) {
                            if (pNodeInfo->ulCacheValid & (1<<i)) { // If we already got this don't do it again
                                RtlCopyMemory(&pRange[i],&pDbCache[i].Range, sizeof(KSPROPERTY_STEPPING_LONG));
                                ntStatus = STATUS_SUCCESS;
                            }
                            else {
                                ntStatus = GetDbLevelRange( pFilterContext->pNextDeviceObject,
                                                            pNodeInfo,
                                                            pDbCache[i].ulChannelIndex,
                                                            ulControlSize,
                                                            &pRange[i] );
                                if ( !NT_SUCCESS(ntStatus) ) {
                                    break;
                                }
                            }
                        }

                        if ( NT_SUCCESS(ntStatus) )
                            pIrp->IoStatus.Information = pPropDesc->DescriptionSize;
                    }
                    break;

                case KSPROPERTY_AUDIO_EQ_LEVEL:
                    ntStatus = GetEqDbRanges( pFilterContext->pNextDeviceObject,
                                              pNodeInfo,
                                              (USHORT)0xffff, //NOTE: Assuming master channel
                                              pRange );
                    pIrp->IoStatus.Information = pPropDesc->DescriptionSize;
                    break;

                case KSPROPERTY_AUDIO_WIDENESS:
                    // Need a range of spaciousness percentages
                default:
                    ntStatus = STATUS_INVALID_PARAMETER;
                    break;
            }
        }
    }

    return ntStatus;
}

NTSTATUS
GetSetTopologyNodeEnable( PIRP pIrp, PKSPROPERTY pKsProperty, PVOID pData )
{
    PKSNODEPROPERTY pNodeProperty  = (PKSNODEPROPERTY)pKsProperty;
    PKSFILTER pKsFilter;
    PFILTER_CONTEXT pFilterContext;
    PTOPOLOGY_NODE_INFO pNodeInfo;
    PPROCESS_CTRL_CACHE pPCtrlCache;
    UCHAR ucCommand;
    PBOOL pEnable = pData;
    NTSTATUS ntStatus = STATUS_INVALID_DEVICE_REQUEST;

    pKsFilter = KsGetFilterFromIrp(pIrp);
    if (!pKsFilter) {
        return STATUS_INVALID_PARAMETER;
    }
    pFilterContext = pKsFilter->Context;
    pNodeInfo   = GET_NODE_INFO_FROM_FILTER(pKsFilter,pNodeProperty->NodeId);
    pPCtrlCache = (PPROCESS_CTRL_CACHE)pNodeInfo->pCachedValues;
    ucCommand   = (pNodeProperty->Property.Flags & KSPROPERTY_TYPE_GET ) ?
                                        (UCHAR)GET_CUR : (UCHAR)SET_CUR;

    switch ( pNodeInfo->ulNodeType ) {
        case NODE_TYPE_SUPERMIX:
        case NODE_TYPE_PROLOGIC:
        case NODE_TYPE_STEREO_WIDE:
        case NODE_TYPE_REVERB:
        case NODE_TYPE_CHORUS:
            if ( pPCtrlCache ) {
                if ( pPCtrlCache->fEnableBit ) {
                    ntStatus =
                      GetSetProcessingUnitEnable(  pFilterContext->pNextDeviceObject,
                                                   pNodeInfo,
                                                   ucCommand,
                                                   pEnable );

                    if (NT_SUCCESS(ntStatus)) {
                        pPCtrlCache->fEnabled = *pEnable;
                    }
                }
            }
            break;
        default:
            break;
    }

    return ntStatus;
}

//----------------------------------------------------------------------------
//
// Restore node property values after standby
//
//----------------------------------------------------------------------------

VOID
RestoreCachedSettings(
    PKSDEVICE pKsDevice )
{
    PHW_DEVICE_EXTENSION pHwDevExt = pKsDevice->Context;
    PKSFILTER_DESCRIPTOR pUSBAudioFilterDescriptor = &pHwDevExt->USBAudioFilterDescriptor;
    PTOPOLOGY_NODE_INFO pNodeInfo = (PTOPOLOGY_NODE_INFO)pUSBAudioFilterDescriptor->NodeDescriptors;

    NTSTATUS (*GetSetFunc)(PDEVICE_OBJECT, PTOPOLOGY_NODE_INFO, ULONG, PULONG, UCHAR );
    NTSTATUS ntStatus = STATUS_SUCCESS;

    LONG ScaleFactor;
    LONG lData;

    ULONG ulChannel;
    ULONG ulNodeId;

    _DbgPrintF( DEBUGLVL_VERBOSE,("RestoreCachedSettings: pHwDevExt = %x\n", pHwDevExt));

    // Loop through all of the nodes restoring the caches values for all
    for (ulNodeId=0; ulNodeId<pUSBAudioFilterDescriptor->NodeDescriptorsCount; ulNodeId++, pNodeInfo++) {

        _DbgPrintF( DEBUGLVL_VERBOSE,("RestoreCachedSettings: Node=%d, pNodeInfo=%x\n",ulNodeId,pNodeInfo));

        switch ( pNodeInfo->ulControlType ) {
            case MUTE_CONTROL :
            case BASS_BOOST_CONTROL :
            case GRAPHIC_EQUALIZER_CONTROL :
            case AUTOMATIC_GAIN_CONTROL :
            case LOUDNESS_CONTROL :
               {
                   PBOOLEAN_CTRL_CACHE pBoolCache = (PBOOLEAN_CTRL_CACHE)pNodeInfo->pCachedValues;
                   for (ulChannel = 0; ulChannel < pNodeInfo->ulChannels; ulChannel++, pBoolCache++) {
                       _DbgPrintF( DEBUGLVL_VERBOSE,("RestoreCachedSettings: BoolVal=%d\n",pBoolCache->fLastValueSet));

                       if (!(pNodeInfo->ulCacheValid & (1<<ulChannel))) {
                           continue;
                       }

                       ntStatus = GetSetByte( pHwDevExt->pNextDeviceObject,
                                              pNodeInfo,
                                              pBoolCache->ulChannelIndex,
                                              (PULONG)&pBoolCache->fLastValueSet,
                                              SET_CUR );
                   }
               } break;

            case VOLUME_CONTROL :
            case TREBLE_CONTROL :
            case MID_CONTROL :
            case BASS_CONTROL :
            case DELAY_CONTROL :
               {
                   PDB_LEVEL_CACHE pDbCache = (PDB_LEVEL_CACHE)pNodeInfo->pCachedValues;
                   if (pNodeInfo->ulControlType == VOLUME_CONTROL) {
                       ScaleFactor = DB_SCALE_16BIT;
                       GetSetFunc  = GetSetShort;
                   }
                   else {
                       ScaleFactor = DB_SCALE_8BIT;
                       GetSetFunc  = GetSetByte;
                   }

                   for (ulChannel = 0; ulChannel < pNodeInfo->ulChannels; ulChannel++, pDbCache++) {

                       if (!(pNodeInfo->ulCacheValid & (1<<ulChannel))) {
                           continue;
                       }

                       lData = pDbCache->lLastValueSet;

                       if ( lData < pDbCache->Range.Bounds.SignedMinimum ) {
                           if ( ScaleFactor == 16 )
                               lData = NEGATIVE_INFINITY; // Hack to detect volume control to silence
                           else
                               lData = pDbCache->Range.Bounds.SignedMinimum / ScaleFactor;
                       }
                       else if ( lData > pDbCache->Range.Bounds.SignedMaximum ) {
                           lData = pDbCache->Range.Bounds.SignedMaximum / ScaleFactor;
                       }
                       else {
                           lData = lData / ScaleFactor;
                       }

                       _DbgPrintF( DEBUGLVL_VERBOSE,("RestoreCachedSettings: SetVal=%d\n",lData));
                       ntStatus = (*GetSetFunc)( pHwDevExt->pNextDeviceObject,
                                                 pNodeInfo,
                                                 pDbCache->ulChannelIndex,
                                                 &lData,
                                                 SET_CUR );
                    }
                } break;

            default :
                break;
        }

        if (!NT_SUCCESS(ntStatus)) {
            _DbgPrintF( DEBUGLVL_VERBOSE,("RestoreCachedSettings: Failed on node %x, ntStatus=%x\n",ulNodeId,ntStatus));
        }
    }
}

#ifdef DRM_USBAUDIO
//----------------------------------------------------------------------------
//
// Start DRM Propery Handlers
//
//----------------------------------------------------------------------------

NTSTATUS DrmAudioStream_SetContentId
(
    IN PIRP                          pIrp,
    IN PKSP_DRMAUDIOSTREAM_CONTENTID pProperty,
    IN PKSDRMAUDIOSTREAM_CONTENTID   pData
)
{
    PKSPIN pKsPin;
    PPIN_CONTEXT pPinContext;
    PKSFILTER pKsFilter;
    PFILTER_CONTEXT pFilterContext;
    PHW_DEVICE_EXTENSION pHwDevExt;
    DRMRIGHTS DrmRights;
    ULONG ContentId;
    NTSTATUS ntStatus = STATUS_SUCCESS;

    pKsPin = KsGetPinFromIrp(pIrp);
    if (!pKsPin) {
        return STATUS_INVALID_PARAMETER;
    }
    pPinContext = pKsPin->Context;

    pKsFilter = KsGetFilterFromIrp(pIrp);
    if (!pKsFilter) {
        return STATUS_INVALID_PARAMETER;
    }
    pFilterContext = pKsFilter->Context;
    pHwDevExt = pFilterContext->pHwDevExt;

    KsPinAcquireProcessingMutex(pKsPin);

    // Extract content ID and rights
    ContentId = pData->ContentId;
    DrmRights = pData->DrmRights;

    // If device has digital outputs and rights require them disabled,
    //  then we fail since we have no way to disable the digital outputs.
    if (DrmRights.DigitalOutputDisable && pHwDevExt->fDigitalOutput) {
        _DbgPrintF(DEBUGLVL_VERBOSE,("[DrmAudioStream_SetContentId] Found a digital endpoint and content has digital disabled\n"));
        ntStatus = STATUS_NOT_IMPLEMENTED;
    }

    if (NT_SUCCESS(ntStatus)) {

        ASSERT(pProperty->DrmForwardContentToDeviceObject);

        // Forward content to common class driver PDO
        ntStatus = pProperty->DrmForwardContentToDeviceObject(ContentId,
                                                              pPinContext->pNextDeviceObject,
                                                              pPinContext->hPipeHandle);
        if ( NT_SUCCESS(ntStatus) ) {
            //  Store this in the pin context because we need to reforward if the pipe handle
            //  changes due to a power state change.
            pPinContext->DrmContentId = ContentId;
        }
    }

    KsPinReleaseProcessingMutex(pKsPin);

    return ntStatus;
}
#endif
//----------------------------------------------------------------------------
//
// End DRM Property Handlers
//
// Start RT Property Handlers
//
//----------------------------------------------------------------------------

#ifdef RTAUDIO
NTSTATUS RtAudio_GetAudioPositionFunction
(
    IN PIRP                          pIrp,
    IN PKSPROPERTY                   pProperty,
    OUT PRTAUDIOGETPOSITION         *pfnRtAudioGetPosition
)
{
    PKSPIN pKsPin;
    PPIN_CONTEXT pPinContext;
    NTSTATUS ntStatus;

    pKsPin = KsGetPinFromIrp(pIrp);
    if (!pKsPin) {
        return STATUS_INVALID_PARAMETER;
    }
    pPinContext = pKsPin->Context;

    ASSERT(pPinContext->pUsbAudioDataRange);

    if (pPinContext->pUsbAudioDataRange->pSyncEndpointDescriptor == NULL) {
        *pfnRtAudioGetPosition = RtAudioTypeIGetPlayPosition;
        pIrp->IoStatus.Information = sizeof(*pfnRtAudioGetPosition);
        ntStatus = STATUS_SUCCESS;
    }
    else {
        //DbgPrint("RtAudio not supported on Async audio endpoint.\n");
        *pfnRtAudioGetPosition = NULL;
        pIrp->IoStatus.Information = 0;
        ntStatus = STATUS_NOT_SUPPORTED;
    }

    return ntStatus;
}
#endif

//----------------------------------------------------------------------------
//
// End RT Property Handlers
//
// Start Building Property Sets
//
//----------------------------------------------------------------------------

VOID
BuildNodePropertySet(
    PTOPOLOGY_NODE_INFO pNodeInfo )
{
    ULONG ulNodeType = pNodeInfo->ulNodeType;
    PKSPROPERTY_SET pPropSet = (PKSPROPERTY_SET)&NodePropertySetTable[ulNodeType];

    if ( pPropSet->PropertiesCount ) {
        pNodeInfo->KsAutomationTable.PropertySetsCount = 1;
        pNodeInfo->KsAutomationTable.PropertyItemSize  = sizeof(KSPROPERTY_ITEM);
        pNodeInfo->KsAutomationTable.PropertySets      = pPropSet;
    }
}

VOID
BuildFilterPropertySet(
    PKSFILTER_DESCRIPTOR pFilterDesc,
    PKSPROPERTY_ITEM pDevPropItems,
    PKSPROPERTY_SET pDevPropSet,
    PULONG pNumItems,
    PULONG pNumSets )
{
    ULONG ulNumPinPropItems = 1;
    PKSPROPERTY_ITEM pPinProps = pDevPropItems;

    ASSERT(pNumSets);

    *pNumSets = 1; // There always is an Pin property set

    if ( pDevPropItems ) {
        RtlCopyMemory(pDevPropItems++, &PinPropertyItems[KSPROPERTY_PIN_NAME], sizeof(KSPROPERTY_ITEM) );

        if ( pDevPropSet ) {
            pDevPropSet->Set             = &KSPROPSETID_Pin;
            pDevPropSet->PropertiesCount = ulNumPinPropItems;
            pDevPropSet->PropertyItem    = pPinProps;
            pDevPropSet->FastIoCount     = 0;
            pDevPropSet->FastIoTable     = NULL;
        }
    }

    if (pNumItems) {
        *pNumItems = ulNumPinPropItems;
    }

}

VOID
BuildPinPropertySet( PHW_DEVICE_EXTENSION pHwDevExt,
                     PKSPROPERTY_ITEM pStrmPropItems,
                     PKSPROPERTY_SET pStrmPropSet,
                     PULONG pNumItems,
                     PULONG pNumSets )
{
    ULONG NumAudioProps = 3;
#ifdef DRM_USBAUDIO
    ULONG NumDrmAudioStreamProps = 1;
#else
    ULONG NumDrmAudioStreamProps = 0;
#endif
#ifdef RTAUDIO
    ULONG NumRtAudioProps = 1;
#else
    ULONG NumRtAudioProps = 0;
#endif
    ULONG NumStreamProps = 1;
    ULONG NumConnectionProps = 1;

    // For now we hardcode this to a known set.

    *pNumSets = 5;

#ifndef RTAUDIO
    *pNumSets =     *pNumSets -1;
#endif

#ifndef DRM_USBAUDIO
    *pNumSets =     *pNumSets -1;
#endif


    if (pNumItems) *pNumItems = NumAudioProps +
                                NumDrmAudioStreamProps +
                                NumRtAudioProps +
                                NumStreamProps +
                                NumConnectionProps;

    if (pStrmPropItems) {
        PKSPROPERTY_ITEM pAudItms = pStrmPropItems;
        PKSPROPERTY_ITEM pDRMItms = pStrmPropItems + NumAudioProps;
        PKSPROPERTY_ITEM pRtItms = pStrmPropItems + (NumAudioProps+NumDrmAudioStreamProps);
        PKSPROPERTY_ITEM pStrmItms = pStrmPropItems + (NumAudioProps+NumDrmAudioStreamProps+NumRtAudioProps);
        PKSPROPERTY_ITEM pConnItms = pStrmPropItems + (NumAudioProps+NumDrmAudioStreamProps+NumRtAudioProps+NumStreamProps);
        RtlCopyMemory(pStrmPropItems++, &AudioPropertyItems[KSPROPERTY_AUDIO_LATENCY], sizeof(KSPROPERTY_ITEM) );
        RtlCopyMemory(pStrmPropItems++, &AudioPropertyItems[KSPROPERTY_AUDIO_POSITION], sizeof(KSPROPERTY_ITEM) );
        RtlCopyMemory(pStrmPropItems++, &AudioPropertyItems[KSPROPERTY_AUDIO_SAMPLING_RATE], sizeof(KSPROPERTY_ITEM) );
#ifdef DRM_USBAUDIO
        RtlCopyMemory(pStrmPropItems++, &DrmAudioStreamPropertyItems[KSPROPERTY_DRMAUDIOSTREAM_CONTENTID], sizeof(KSPROPERTY_ITEM) );
#endif
#ifdef RTAUDIO
        RtlCopyMemory(pStrmPropItems++, &RtAudioPropertyItems[KSPROPERTY_RTAUDIO_GETPOSITIONFUNCTION], sizeof(KSPROPERTY_ITEM) );
#endif
        RtlCopyMemory(pStrmPropItems++, &StreamItm[0], sizeof(KSPROPERTY_ITEM) );
        RtlCopyMemory(pStrmPropItems,   &ConnectionItm[0], sizeof(KSPROPERTY_ITEM) );

        if (pStrmPropSet) {

            // Audio Property Set
            pStrmPropSet->Set             = &KSPROPSETID_Audio;
            pStrmPropSet->PropertiesCount = NumAudioProps;
            pStrmPropSet->PropertyItem    = pAudItms;
            pStrmPropSet->FastIoCount     = 0;
            pStrmPropSet->FastIoTable     = NULL;
            pStrmPropSet++;

 
#ifdef DRM_USBAUDIO
            // DRM Property Set
            pStrmPropSet->Set             = &KSPROPSETID_DrmAudioStream;
            pStrmPropSet->PropertiesCount = NumDrmAudioStreamProps;
            pStrmPropSet->PropertyItem    = pDRMItms;
            pStrmPropSet->FastIoCount     = 0;
            pStrmPropSet->FastIoTable     = NULL;
            pStrmPropSet++;
#endif

#ifdef RTAUDIO
            // RT Property Set
            pStrmPropSet->Set             = &KSPROPSETID_RtAudio;
            pStrmPropSet->PropertiesCount = NumRtAudioProps;
            pStrmPropSet->PropertyItem    = pRtItms;
            pStrmPropSet->FastIoCount     = 0;
            pStrmPropSet->FastIoTable     = NULL;
            pStrmPropSet++;
#endif

            // Stream Property Set
            pStrmPropSet->Set             = &KSPROPSETID_Stream;
            pStrmPropSet->PropertiesCount = NumStreamProps;
            pStrmPropSet->PropertyItem    = pStrmItms;
            pStrmPropSet->FastIoCount     = 0;
            pStrmPropSet->FastIoTable     = NULL;
            pStrmPropSet++;

            // Connection Properties
            pStrmPropSet->Set             = &KSPROPSETID_Connection;
            pStrmPropSet->PropertiesCount = NumConnectionProps;
            pStrmPropSet->PropertyItem    = pConnItms;
            pStrmPropSet->FastIoCount     = 0;
            pStrmPropSet->FastIoTable     = NULL;

        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\drivers\usbaudio.2\parsedsc.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 2000
//
//  File:       parsedsc.c
//
//--------------------------------------------------------------------------

#include "common.h"


PUSB_INTERFACE_DESCRIPTOR
GetNextAudioInterface(
    PUSB_CONFIGURATION_DESCRIPTOR pConfigurationDescriptor,
    PUSB_INTERFACE_DESCRIPTOR pInterfaceDescriptor )
{
    ULONG ulInterfaceNumber;

    // IF descriptor is NULL there are no more beyond it.
    if ( !pInterfaceDescriptor ) return NULL;

    // Remember the InterfaceNumber
    ulInterfaceNumber = pInterfaceDescriptor->bInterfaceNumber;

    // Advance to the next one
    pInterfaceDescriptor = (PUSB_INTERFACE_DESCRIPTOR)
            ((PUCHAR)pInterfaceDescriptor + pInterfaceDescriptor->bLength);

    // Get the next audio descriptor for this InterfaceNumber
    pInterfaceDescriptor = USBD_ParseConfigurationDescriptorEx (
                           pConfigurationDescriptor,
                           (PVOID) pInterfaceDescriptor,
                           ulInterfaceNumber,      // Interface number
                           -1,                     // Alternate Setting
                           USB_DEVICE_CLASS_AUDIO, // Audio Class (Interface Class)
                           -1,                     // Interface Sub-Class
                           -1 ) ;                  // protocol don't care (InterfaceProtocol)

    return ( pInterfaceDescriptor );
}

PUSB_INTERFACE_DESCRIPTOR
GetFirstAudioStreamingInterface(
    PUSB_CONFIGURATION_DESCRIPTOR pConfigurationDescriptor,
    ULONG ulInterfaceNumber )
{
    PUSB_INTERFACE_DESCRIPTOR pInterfaceDescriptor;
    PUSB_INTERFACE_DESCRIPTOR pControlInterface;
    PAUDIO_HEADER_UNIT pHeader;

    // Get the first control interface
    pControlInterface = USBD_ParseConfigurationDescriptorEx (
                        pConfigurationDescriptor,
                        pConfigurationDescriptor,
                        -1,        // interface number
                        -1,        //  (Alternate Setting)
                        USB_DEVICE_CLASS_AUDIO,        // Audio Class (Interface Class)
                        AUDIO_SUBCLASS_CONTROL,        // control subclass (Interface Sub-Class)
                        -1 );

    if ( !pControlInterface ) return NULL;

    pHeader = (PAUDIO_HEADER_UNIT)
                  GetAudioSpecificInterface( pConfigurationDescriptor,
                                             pControlInterface,
                                             HEADER_UNIT);
    if ( !pHeader ) return NULL;

    // Get the first audio descriptor for this InterfaceNumber
    // Remember: the InterfaceNumber is virtual: we only include audio streaming interfaces!
    while ( ulInterfaceNumber >= pHeader->bInCollection ) {

        ulInterfaceNumber -= pHeader->bInCollection;

        // Get Next Control Interface
        pControlInterface = USBD_ParseConfigurationDescriptorEx (
                        pConfigurationDescriptor,
                        (PUCHAR)pControlInterface + pControlInterface->bLength,
                        -1,                      // Interface number
                        -1,                      // Alternate Setting
                        USB_DEVICE_CLASS_AUDIO,  // Audio Class (Interface Class)
                        AUDIO_SUBCLASS_CONTROL,  // control subclass (Interface Sub-Class)
                        -1 );

        if ( !pControlInterface ) return NULL;

        pHeader = (PAUDIO_HEADER_UNIT)
                   GetAudioSpecificInterface( pConfigurationDescriptor,
                                              pControlInterface,
                                              HEADER_UNIT);
        if ( !pHeader ) return NULL;
    }

    pInterfaceDescriptor = USBD_ParseConfigurationDescriptorEx (
                           pConfigurationDescriptor,
                           (PVOID) pConfigurationDescriptor,
                           pHeader->baInterfaceNr[ulInterfaceNumber], // Interface number
                           -1,                       // Alternate Setting
                           USB_DEVICE_CLASS_AUDIO,   // Audio Class (Interface Class)
                           AUDIO_SUBCLASS_STREAMING, // Stream subclass (Interface Sub-Class)
                           -1 ) ;                    // protocol don't care (InterfaceProtocol)

    return ( pInterfaceDescriptor );
}

PAUDIO_SPECIFIC
GetAudioSpecificInterface(
    PUSB_CONFIGURATION_DESCRIPTOR pConfigurationDescriptor,
    PUSB_INTERFACE_DESCRIPTOR pInterfaceDescriptor,
    LONG lDescriptorSubtype )
{
    PAUDIO_SPECIFIC pDescriptor;

    // Find the stream descriptor for this interface and subtype
    pDescriptor = (PAUDIO_SPECIFIC)pInterfaceDescriptor;

    // Get the next audio interface descriptor.
    pInterfaceDescriptor =
         GetNextAudioInterface( pConfigurationDescriptor, pInterfaceDescriptor );

    do {
        pDescriptor = (PAUDIO_SPECIFIC)
            USBD_ParseDescriptors( (PVOID)pConfigurationDescriptor,
                                   pConfigurationDescriptor->wTotalLength,
                                   (PUCHAR)pDescriptor + pDescriptor->bLength,
                                   USB_CLASS_AUDIO | USB_INTERFACE_DESCRIPTOR_TYPE );

        if (pDescriptor == NULL ||
            (pInterfaceDescriptor && pDescriptor > ((PAUDIO_SPECIFIC)pInterfaceDescriptor)))
            return NULL;
    } while (lDescriptorSubtype != -1L &&
           pDescriptor->bDescriptorSubtype != lDescriptorSubtype);

    return pDescriptor;
}

PUSB_ENDPOINT_DESCRIPTOR
GetEndpointDescriptor(
    PUSB_CONFIGURATION_DESCRIPTOR pConfigurationDescriptor,
    PUSB_INTERFACE_DESCRIPTOR pInterfaceDescriptor,
    BOOLEAN fGetAudioSpecificEndpoint )
{
    PUSB_INTERFACE_DESCRIPTOR pDescriptor;
    PUSB_ENDPOINT_DESCRIPTOR  pEndpointDescriptor;
    ULONG DescriptorType =
        USB_ENDPOINT_DESCRIPTOR_TYPE | ((fGetAudioSpecificEndpoint) ? USB_CLASS_AUDIO : 0);

    // Get the next audio interface descriptor to check boundry
    pDescriptor = GetNextAudioInterface( pConfigurationDescriptor,
                                         pInterfaceDescriptor);

    pEndpointDescriptor = (PUSB_ENDPOINT_DESCRIPTOR)
           USBD_ParseDescriptors( pConfigurationDescriptor,
                                  pConfigurationDescriptor->wTotalLength ,
                                  (PVOID) pInterfaceDescriptor,
                                  DescriptorType );

    if ( pEndpointDescriptor )
        if (pDescriptor && ((PVOID)pEndpointDescriptor > (PVOID)pDescriptor))
           pEndpointDescriptor = NULL;

    return pEndpointDescriptor;
}

PUSB_ENDPOINT_DESCRIPTOR
GetSyncEndpointDescriptor(
    PUSB_CONFIGURATION_DESCRIPTOR pConfigurationDescriptor,
    PUSB_INTERFACE_DESCRIPTOR pInterfaceDescriptor )
{
    PUSB_ENDPOINT_DESCRIPTOR pSyncEPDescriptor = NULL;
    PUSB_ENDPOINT_DESCRIPTOR pEndpointDescriptor;
    PUSB_INTERFACE_DESCRIPTOR pDescriptor;
    ULONG ulSyncEndpointAddr;

    // Get the next audio interface descriptor to check boundry
    pDescriptor = GetNextAudioInterface( pConfigurationDescriptor,
                                         pInterfaceDescriptor);
    pEndpointDescriptor =
        GetEndpointDescriptor( pConfigurationDescriptor,
                               pInterfaceDescriptor,
                               FALSE );

    if ( pEndpointDescriptor  &&
       (( pEndpointDescriptor->bmAttributes & EP_SYNC_TYPE_MASK) == EP_ASYNC_SYNC_TYPE )) {
        ulSyncEndpointAddr = (ULONG)
           ((PUSB_INTERRUPT_ENDPOINT_DESCRIPTOR)pEndpointDescriptor)->bSynchAddress;

        // Hack to get old DalSemi devices to work.
        ulSyncEndpointAddr |= 0x80;

        pSyncEPDescriptor = (PUSB_ENDPOINT_DESCRIPTOR)
            USBD_ParseDescriptors( pConfigurationDescriptor,
                                   pConfigurationDescriptor->wTotalLength ,
                                   (PUCHAR)pEndpointDescriptor + pEndpointDescriptor->bLength,
                                   USB_ENDPOINT_DESCRIPTOR_TYPE );
        if (pSyncEPDescriptor &&
           ((ULONG)pSyncEPDescriptor->bEndpointAddress == ulSyncEndpointAddr) ) {
            if (pDescriptor && ((PVOID)pSyncEPDescriptor > (PVOID)pDescriptor))
               pSyncEPDescriptor = NULL;
        }
        else
            pSyncEPDescriptor = NULL;
    }

    return pSyncEPDescriptor;
}


ULONG
GetMaxPacketSizeForInterface(
    PUSB_CONFIGURATION_DESCRIPTOR pConfigurationDescriptor,
    PUSB_INTERFACE_DESCRIPTOR pInterfaceDescriptor )
{
    PUSB_ENDPOINT_DESCRIPTOR pEndpointDescriptor;

    pEndpointDescriptor = GetEndpointDescriptor( pConfigurationDescriptor,
                                                 pInterfaceDescriptor,
                                                 FALSE );

    if ( pEndpointDescriptor ) {
        return( (ULONG)pEndpointDescriptor->wMaxPacketSize );
    }
    else {
        return 0;
    }

}


PAUDIO_UNIT
GetUnit(
    PUSB_CONFIGURATION_DESCRIPTOR pConfigurationDescriptor,
    ULONG ulUnitId )
{
    PUSB_INTERFACE_DESCRIPTOR pControlIFDescriptor;
    PAUDIO_HEADER_UNIT pHeader;
    PAUDIO_UNIT pUnit = NULL;
    ULONG fUnitFound = FALSE;

    // Starting at the configuration descriptor, find the control interface.
    pControlIFDescriptor = USBD_ParseConfigurationDescriptorEx (
                             pConfigurationDescriptor,
                             (PVOID) pConfigurationDescriptor,
                             -1,                     // Interface number
                             -1,                     // Alternate Setting
                             USB_DEVICE_CLASS_AUDIO, // Audio Class (Interface Class)
                             AUDIO_SUBCLASS_CONTROL, // control subclass (Interface Sub-Class)
                             -1 ) ;                  // protocol don't care (InterfaceProtocol)

    while ( pControlIFDescriptor && !fUnitFound ) {
        if ( pHeader = (PAUDIO_HEADER_UNIT)
            USBD_ParseDescriptors( (PVOID) pConfigurationDescriptor,
                                   pConfigurationDescriptor->wTotalLength,
                                   (PVOID) pControlIFDescriptor,
                                   USB_CLASS_AUDIO | USB_INTERFACE_DESCRIPTOR_TYPE ) ) {
            pUnit = (PAUDIO_UNIT)
                USBD_ParseDescriptors( (PVOID)pHeader,
                                       pHeader->wTotalLength,
                                       (PVOID)pHeader,
                                       USB_CLASS_AUDIO | USB_INTERFACE_DESCRIPTOR_TYPE );
            while ( pUnit && (pUnit->bUnitID != ulUnitId )) {
                pUnit = (PAUDIO_UNIT) ((PUCHAR)pUnit + pUnit->bLength);
                if ((PUCHAR)pUnit >= ((PUCHAR)pHeader + pHeader->wTotalLength))
                    pUnit = NULL;
            }
            if ( pUnit && (pUnit->bUnitID == ulUnitId )) {
                fUnitFound = TRUE;
            }
        }
        if ( !fUnitFound )
            pControlIFDescriptor = USBD_ParseConfigurationDescriptorEx (
                                 pConfigurationDescriptor,
                                 ((PUCHAR)pControlIFDescriptor + pControlIFDescriptor->bLength),
                                 -1,                     // Interface number
                                 -1,                     // Alternate Setting
                                 USB_DEVICE_CLASS_AUDIO, // Audio Class (Interface Class)
                                 AUDIO_SUBCLASS_CONTROL, // control subclass (Interface Sub-Class)
                                 -1 ) ;                  // protocol don't care (InterfaceProtocol)
    }

    return pUnit;
}


BOOLEAN
IsSupportedFormat(
    PUSB_CONFIGURATION_DESCRIPTOR pConfigurationDescriptor,
    PUSB_INTERFACE_DESCRIPTOR pInterfaceDescriptor )
{
    BOOLEAN fSupported = FALSE;
    PAUDIO_CLASS_STREAM pAudioDescriptor;
    PAUDIO_GENERAL_STREAM pGeneralDescriptor = (PAUDIO_GENERAL_STREAM)
                GetAudioSpecificInterface( pConfigurationDescriptor,
                                           pInterfaceDescriptor,
                                           AS_GENERAL);

    if ( pGeneralDescriptor ) {
        switch ( pGeneralDescriptor->wFormatTag ) {
            case USBAUDIO_DATA_FORMAT_PCM:
                // Find the format-specific descriptor
                pAudioDescriptor = (PAUDIO_CLASS_STREAM)
                    USBD_ParseDescriptors( (PVOID)pConfigurationDescriptor,
                                           pConfigurationDescriptor->wTotalLength,
                                           (PVOID)((PUCHAR)pGeneralDescriptor + pGeneralDescriptor->bLength),
                                           USB_CLASS_AUDIO | USB_INTERFACE_DESCRIPTOR_TYPE );

                if ( pAudioDescriptor && (pAudioDescriptor->bBitsPerSample != 8))
                    fSupported = TRUE;
                break;
            case USBAUDIO_DATA_FORMAT_PCM8:
            case USBAUDIO_DATA_FORMAT_IEEE_FLOAT:
            case USBAUDIO_DATA_FORMAT_ALAW:
            case USBAUDIO_DATA_FORMAT_MULAW:
            case USBAUDIO_DATA_FORMAT_MPEG:
            case USBAUDIO_DATA_FORMAT_AC3:
                fSupported = TRUE;
                break;
            default:
                break;
        }
    }

    return fSupported;

}


BOOLEAN
IsZeroBWInterface(
    PUSB_CONFIGURATION_DESCRIPTOR pConfigurationDescriptor,
    PUSB_INTERFACE_DESCRIPTOR pInterfaceDescriptor )
{
    BOOLEAN ZeroBWFound = FALSE;

    if ( (ULONG)pInterfaceDescriptor->bNumEndpoints == 0 ) {
        ZeroBWFound = TRUE;
    }
    else if ( (ULONG)pInterfaceDescriptor->bNumEndpoints == 1 ) {
        ULONG MaxPacketSize =
               GetMaxPacketSizeForInterface( pConfigurationDescriptor,
                                             pInterfaceDescriptor );

        if ( !MaxPacketSize ) ZeroBWFound = TRUE;
    }

    return ZeroBWFound;
}

ULONG
CountTerminalUnits(
    PUSB_CONFIGURATION_DESCRIPTOR pConfigurationDescriptor,
    PULONG pAudioBridgePinCount,
    PULONG pMIDIPinCount,
    PULONG pMIDIBridgePinCount)
{
    PUSB_INTERFACE_DESCRIPTOR pAudioInterface;
    PAUDIO_HEADER_UNIT pHeader;

    union {
        PAUDIO_UNIT                 pUnit;
        PAUDIO_INPUT_TERMINAL       pInput;
        PAUDIO_MIXER_UNIT           pMixer;
        PAUDIO_PROCESSING_UNIT      pProcess;
        PAUDIO_EXTENSION_UNIT       pExtension;
        PAUDIO_FEATURE_UNIT         pFeature;
        PAUDIO_SELECTOR_UNIT        pSelector;
        PMIDISTREAMING_ELEMENT      pMIDIElement;
        PMIDISTREAMING_MIDIIN_JACK  pMIDIInJack;
        PMIDISTREAMING_MIDIOUT_JACK pMIDIOutJack;
    } u;

    PMIDISTREAMING_GENERAL_STREAM pGeneralMIDIStreamDescriptor;
    ULONG ulAudioBridgePinCount = 0;
    ULONG ulMIDIBridgePinCount = 0;
    ULONG ulAudioPinCount = 0;
    ULONG ulMIDIPinCount = 0;


    // Starting at the configuration descriptor, find the first audio interface.
    pAudioInterface = USBD_ParseConfigurationDescriptorEx (
                           pConfigurationDescriptor,
                           (PVOID) pConfigurationDescriptor,
                           -1,                     // Interface number
                           -1,                     // Alternate Setting
                           USB_DEVICE_CLASS_AUDIO, // Audio Class (Interface Class)
                           -1,                     // any subclass (Interface Sub-Class)
                           -1 ) ;                  // protocol don't care (InterfaceProtocol)

    while ( pAudioInterface ) {
        switch (pAudioInterface->bInterfaceSubClass) {
            case AUDIO_SUBCLASS_CONTROL:

                _DbgPrintF(DEBUGLVL_VERBOSE,("[CountTerminalUnits] Found AudioControl at %x\n",pAudioInterface));
                if ( pHeader = (PAUDIO_HEADER_UNIT)
                    USBD_ParseDescriptors( (PVOID) pConfigurationDescriptor,
                                           pConfigurationDescriptor->wTotalLength,
                                           (PVOID) pAudioInterface,
                                           USB_CLASS_AUDIO | USB_INTERFACE_DESCRIPTOR_TYPE ) ) {
                    u.pUnit = (PAUDIO_UNIT)
                        USBD_ParseDescriptors( (PVOID)pHeader,
                                               pHeader->wTotalLength,
                                               ((PUCHAR)pHeader + pHeader->bLength),
                                               USB_CLASS_AUDIO | USB_INTERFACE_DESCRIPTOR_TYPE );
                    while ( u.pUnit ) {
                        switch (u.pUnit->bDescriptorSubtype) {
                            case INPUT_TERMINAL:
                            case OUTPUT_TERMINAL:
                                if ( u.pInput->wTerminalType != USB_Streaming) {
                                   ulAudioBridgePinCount++;
                                }
                                ulAudioPinCount++;
                                break;

                            default:
                                break;
                        }

                        u.pUnit = (PAUDIO_UNIT) ((PUCHAR)u.pUnit + u.pUnit->bLength);
                        if ( (PUCHAR)u.pUnit >= ((PUCHAR)pHeader + pHeader->wTotalLength)) {
                            u.pUnit = NULL;
                        }
                    }
                }
                break;
            case AUDIO_SUBCLASS_MIDISTREAMING:

                _DbgPrintF(DEBUGLVL_VERBOSE,("[CountTerminalUnits] Found MIDIStreaming at %x\n",pAudioInterface));

                if ( pGeneralMIDIStreamDescriptor = (PMIDISTREAMING_GENERAL_STREAM)
                    USBD_ParseDescriptors( (PVOID) pConfigurationDescriptor,
                                           pConfigurationDescriptor->wTotalLength,
                                           (PVOID) pAudioInterface,
                                           USB_CLASS_AUDIO | USB_INTERFACE_DESCRIPTOR_TYPE ) ) {
                    u.pUnit = (PAUDIO_UNIT)
                        USBD_ParseDescriptors( (PVOID)pGeneralMIDIStreamDescriptor,
                                               pGeneralMIDIStreamDescriptor->wTotalLength,
                                               ((PUCHAR)pGeneralMIDIStreamDescriptor + pGeneralMIDIStreamDescriptor->bLength),
                                               USB_CLASS_AUDIO | USB_INTERFACE_DESCRIPTOR_TYPE );
                    while ( u.pUnit ) {
                        switch (u.pUnit->bDescriptorSubtype) {
                            case MIDI_IN_JACK:
                            case MIDI_OUT_JACK:
                                if ( u.pMIDIInJack->bJackType != JACK_TYPE_EMBEDDED) {
                                   ulMIDIBridgePinCount++;
                                }
                                ulMIDIPinCount++;
                                ulAudioPinCount++;
                                break;

                            case MIDI_ELEMENT:
                                break;

                            default:
                                break;
                        }

                        // Find the next unit.
                        u.pUnit = (PAUDIO_UNIT) USBD_ParseDescriptors(
                                            (PVOID) pGeneralMIDIStreamDescriptor,
                                            pGeneralMIDIStreamDescriptor->wTotalLength,
                                            (PUCHAR)u.pUnit + u.pUnit->bLength,
                                            USB_CLASS_AUDIO | USB_INTERFACE_DESCRIPTOR_TYPE );
                    }
                }
                break;
            case AUDIO_SUBCLASS_STREAMING:
                break;
            default:
                break;
        }

        // pAudioInterface = GetNextAudioInterface(pConfigurationDescriptor, pAudioInterface);

        // Get the next audio descriptor for this InterfaceNumber
        pAudioInterface = USBD_ParseConfigurationDescriptorEx (
                               pConfigurationDescriptor,
                               ((PUCHAR)pAudioInterface + pAudioInterface->bLength),
                               -1,
                               -1,                     // Alternate Setting
                               USB_DEVICE_CLASS_AUDIO, // Audio Class (Interface Class)
                               -1,                     // Interface Sub-Class
                               -1 ) ;                  // protocol don't care (InterfaceProtocol)

        _DbgPrintF(DEBUGLVL_VERBOSE,("[CountTerminalUnits] Next audio interface at %x\n",pAudioInterface));
    }

    if ( pAudioBridgePinCount )
        *pAudioBridgePinCount = ulAudioBridgePinCount;

    if ( pMIDIPinCount )
        *pMIDIPinCount = ulMIDIPinCount;

    if ( pMIDIBridgePinCount )
        *pMIDIBridgePinCount = ulMIDIBridgePinCount;

    _DbgPrintF(DEBUGLVL_VERBOSE,("[CountTerminalUnits] AudioBridge=%d MIDIPin=%d MIDIBridgePin=%d\n",
                                 ulAudioBridgePinCount,
                                 ulMIDIPinCount,
                                 ulMIDIBridgePinCount));

    return ulAudioPinCount;
}


ULONG
CountFormatsForAudioStreamingInterface(
    PUSB_CONFIGURATION_DESCRIPTOR pConfigurationDescriptor,
    ULONG ulInterfaceNumber )
{
    PUSB_INTERFACE_DESCRIPTOR pInterfaceDescriptor;
    ULONG ulCount = 0;

    pInterfaceDescriptor =
        GetFirstAudioStreamingInterface( pConfigurationDescriptor, ulInterfaceNumber );

    while ( pInterfaceDescriptor ) {
        if ( !IsZeroBWInterface( pConfigurationDescriptor, pInterfaceDescriptor ) &&
              IsSupportedFormat( pConfigurationDescriptor, pInterfaceDescriptor )) {
            ulCount++;
        }
        pInterfaceDescriptor =
            GetNextAudioInterface( pConfigurationDescriptor, pInterfaceDescriptor );
    }

    return ulCount;
}

ULONG
CountInputChannels(
    PUSB_CONFIGURATION_DESCRIPTOR pConfigurationDescriptor,
    ULONG ulUnitID )
{
    union {
        PAUDIO_UNIT pUnit;
        PAUDIO_INPUT_TERMINAL pInput;
        PAUDIO_MIXER_UNIT pSourceMixer;
        PAUDIO_PROCESSING_UNIT pProcess;
        PAUDIO_EXTENSION_UNIT pExtension;
        PAUDIO_FEATURE_UNIT pFeature;
        PAUDIO_SELECTOR_UNIT pSelector;
    } u;
    ULONG ulChannels = 0;

    // we walk the stream to discover the number of input channels.
    u.pUnit = GetUnit(pConfigurationDescriptor, ulUnitID);
    while (u.pUnit) {
        switch (u.pUnit->bDescriptorSubtype) {
            case INPUT_TERMINAL:
                ulChannels = u.pInput->bNrChannels;
                return ulChannels;

            case MIXER_UNIT:
                ulChannels = *(u.pSourceMixer->baSourceID + u.pSourceMixer->bNrInPins);
                return ulChannels;

            case SELECTOR_UNIT:
                // NOTE: This assumes all inputs have the same number of channels!
                u.pUnit = GetUnit(pConfigurationDescriptor, u.pSelector->baSourceID[0]);
                break;

            case FEATURE_UNIT:
                u.pUnit = GetUnit(pConfigurationDescriptor, u.pFeature->bSourceID);
                break;

            case PROCESSING_UNIT:
                ulChannels = *(u.pProcess->baSourceID + u.pProcess->bNrInPins);
                return ulChannels;

            case EXTENSION_UNIT:
                ulChannels = *(u.pExtension->baSourceID + u.pExtension->bNrInPins);
                return ulChannels;

            default:
                u.pUnit = NULL;
                break;
            }
        }

    return ulChannels;
}


VOID
ConvertInterfaceToDataRange(
    PUSB_CONFIGURATION_DESCRIPTOR pConfigurationDescriptor,
    PUSB_INTERFACE_DESCRIPTOR pInterfaceDescriptor,
    PUSBAUDIO_DATARANGE pUSBAudioDataRange
    )
{
    PKSDATARANGE_AUDIO pKsAudioRange = &pUSBAudioDataRange->KsDataRangeAudio;
    PAUDIO_CLASS_STREAM  pAudioDescriptor = NULL;
    PAUDIO_GENERAL_STREAM pGeneralDescriptor;
    ULONG SampleRate;
    ULONG i;

    // Find the general stream descriptor for this interface
    pGeneralDescriptor = (PAUDIO_GENERAL_STREAM)
            GetAudioSpecificInterface( pConfigurationDescriptor,
                                       pInterfaceDescriptor,
                                       AS_GENERAL );

    if ( pGeneralDescriptor) {

       // Find the format-specific descriptor
       pAudioDescriptor = (PAUDIO_CLASS_STREAM)
           USBD_ParseDescriptors( (PVOID)pConfigurationDescriptor,
                                  pConfigurationDescriptor->wTotalLength,
                                  (PVOID) ((PUCHAR)pGeneralDescriptor + pGeneralDescriptor->bLength),
                                  USB_CLASS_AUDIO | USB_INTERFACE_DESCRIPTOR_TYPE );

    }

    if (!pAudioDescriptor)
        return;

    pUSBAudioDataRange->pAudioDescriptor = pAudioDescriptor;
    pUSBAudioDataRange->ulUsbDataFormat  = (ULONG)pGeneralDescriptor->wFormatTag;

    // Create the KSDATARANGE_AUDIO structure
    pKsAudioRange->DataRange.FormatSize = sizeof(KSDATARANGE_AUDIO);
    pKsAudioRange->DataRange.Reserved   = 0;
    pKsAudioRange->DataRange.Flags      = 0;
    pKsAudioRange->DataRange.SampleSize = 0;
    pKsAudioRange->DataRange.MajorFormat = KSDATAFORMAT_TYPE_AUDIO; // Everything is Audio.
    pKsAudioRange->DataRange.Specifier = KSDATAFORMAT_SPECIFIER_WAVEFORMATEX;

    // Map the USB format to a KS sub-format, if possible.
    switch ( pGeneralDescriptor->wFormatTag ) {
        case USBAUDIO_DATA_FORMAT_PCM8:
        case USBAUDIO_DATA_FORMAT_PCM:
            pKsAudioRange->DataRange.SubFormat = KSDATAFORMAT_SUBTYPE_PCM;         break;
        case USBAUDIO_DATA_FORMAT_IEEE_FLOAT:
            pKsAudioRange->DataRange.SubFormat = KSDATAFORMAT_SUBTYPE_IEEE_FLOAT;  break;
        case USBAUDIO_DATA_FORMAT_ALAW:
            pKsAudioRange->DataRange.SubFormat = KSDATAFORMAT_SUBTYPE_ALAW;        break;
        case USBAUDIO_DATA_FORMAT_MULAW:
            pKsAudioRange->DataRange.SubFormat = KSDATAFORMAT_SUBTYPE_MULAW;       break;
        case USBAUDIO_DATA_FORMAT_MPEG:
            pKsAudioRange->DataRange.SubFormat = KSDATAFORMAT_SUBTYPE_MPEG;        break;
        case USBAUDIO_DATA_FORMAT_AC3:
            pKsAudioRange->DataRange.SubFormat = KSDATAFORMAT_SUBTYPE_AC3_AUDIO;   break;
        default:
            // This USB format does not map to a sub-format!
            pKsAudioRange->DataRange.SubFormat = GUID_NULL;                        break;
    }

    // Fill-in the correct data for the specified WAVE format.
    switch( pGeneralDescriptor->wFormatTag & USBAUDIO_DATA_FORMAT_TYPE_MASK) {
        case USBAUDIO_DATA_FORMAT_TYPE_I_UNDEFINED:
            // Fill in the audio range information
            pKsAudioRange->MaximumChannels      = pAudioDescriptor->bNumberOfChannels;
            pKsAudioRange->MinimumBitsPerSample = pAudioDescriptor->bSlotSize<<3;
            pKsAudioRange->MaximumBitsPerSample = pAudioDescriptor->bSlotSize<<3;
            pKsAudioRange->MinimumSampleFrequency =
                         pAudioDescriptor->pSampleRate[0].bSampleFreqByte1 +
                  256L * pAudioDescriptor->pSampleRate[0].bSampleFreqByte2 +
                65536L * pAudioDescriptor->pSampleRate[0].bSampleFreqByte3;
            pKsAudioRange->MaximumSampleFrequency = pKsAudioRange->MinimumSampleFrequency;

            if ( pAudioDescriptor->bSampleFreqType == 0 ) {
                // Continuous range of sampling rates
                pKsAudioRange->MaximumSampleFrequency =
                                pAudioDescriptor->pSampleRate[1].bSampleFreqByte1 +
                         256L * pAudioDescriptor->pSampleRate[1].bSampleFreqByte2 +
                       65536L * pAudioDescriptor->pSampleRate[1].bSampleFreqByte3;
            }

            if ( pAudioDescriptor->bSampleFreqType > 1 ) {
                // Series of sampling rates
                // We convert this to a range by finding the min and max
                for (i=0; i<pAudioDescriptor->bSampleFreqType; i++) {
                    SampleRate = pAudioDescriptor->pSampleRate[i].bSampleFreqByte1 +
                          256L * pAudioDescriptor->pSampleRate[i].bSampleFreqByte2 +
                        65536L * pAudioDescriptor->pSampleRate[i].bSampleFreqByte3;

                       if (SampleRate < pKsAudioRange->MinimumSampleFrequency)
                           pKsAudioRange->MinimumSampleFrequency = SampleRate;

                       if (SampleRate > pKsAudioRange->MaximumSampleFrequency)
                           pKsAudioRange->MaximumSampleFrequency = SampleRate;
                }
            }
            break;
        case USBAUDIO_DATA_FORMAT_TYPE_II_UNDEFINED:
            // NOTE: The Type II format hardcoded to match DShow AC-3
            pKsAudioRange->MaximumChannels = 6;
            pKsAudioRange->MinimumBitsPerSample = 0;
            pKsAudioRange->MaximumBitsPerSample = 0;
            pKsAudioRange->MinimumSampleFrequency = 48000L;
            pKsAudioRange->MaximumSampleFrequency = 48000L;
            break;
        case USBAUDIO_DATA_FORMAT_TYPE_III_UNDEFINED:
            // TODO: Support Type III formats
            break;
        default:
            // This USB format does not map to a WAVE format!
            break;
    }
}

VOID
CountTopologyComponents(
    PUSB_CONFIGURATION_DESCRIPTOR pConfigurationDescriptor,
    PULONG pNumCategories,
    PULONG pNumNodes,
    PULONG pNumConnections,
    PULONG pbmCategories )
{
    PUSB_INTERFACE_DESCRIPTOR pControlIFDescriptor;
    PAUDIO_HEADER_UNIT pHeader;
    PUSB_INTERFACE_DESCRIPTOR pMIDIStreamingDescriptor;
    PMIDISTREAMING_GENERAL_STREAM pGeneralMIDIStreamDescriptor;

    union {
        PAUDIO_UNIT                 pUnit;
        PAUDIO_INPUT_TERMINAL       pInput;
        PAUDIO_MIXER_UNIT           pMixer;
        PAUDIO_PROCESSING_UNIT      pProcess;
        PAUDIO_EXTENSION_UNIT       pExtension;
        PAUDIO_FEATURE_UNIT         pFeature;
        PAUDIO_SELECTOR_UNIT        pSelector;
        PMIDISTREAMING_ELEMENT      pMIDIElement;
        PMIDISTREAMING_MIDIIN_JACK  pMIDIInJack;
        PMIDISTREAMING_MIDIOUT_JACK pMIDIOutJack;
    } u;

    ULONG ulNumChannels;
    ULONG bmControls;
    ULONG bmMergedControls;
    ULONG i, j;

    // Initialize Values
    *pNumCategories  = 0;
    *pNumNodes       = 0;
    *pNumConnections = 0;
    *pbmCategories   = 0;

    // Starting at the configuration descriptor, find the first control interface.
    pControlIFDescriptor = USBD_ParseConfigurationDescriptorEx (
                             pConfigurationDescriptor,
                             (PVOID) pConfigurationDescriptor,
                             -1,                     // Interface number
                             -1,                     // Alternate Setting
                             USB_DEVICE_CLASS_AUDIO, // Audio Class (Interface Class)
                             AUDIO_SUBCLASS_CONTROL, // control subclass (Interface Sub-Class)
                             -1 ) ;                  // protocol don't care (InterfaceProtocol)

    while ( pControlIFDescriptor ) {
        if ( pHeader = (PAUDIO_HEADER_UNIT)
            USBD_ParseDescriptors( (PVOID) pConfigurationDescriptor,
                                   pConfigurationDescriptor->wTotalLength,
                                   (PVOID) pControlIFDescriptor,
                                   USB_CLASS_AUDIO | USB_INTERFACE_DESCRIPTOR_TYPE ) ) {
            u.pUnit = (PAUDIO_UNIT)
                USBD_ParseDescriptors( (PVOID)pHeader,
                                       pHeader->wTotalLength,
                                       (PVOID)pHeader,
                                       USB_CLASS_AUDIO | USB_INTERFACE_DESCRIPTOR_TYPE );
            while ( u.pUnit ) {
                switch (u.pUnit->bDescriptorSubtype) {
                    case INPUT_TERMINAL:
                    case OUTPUT_TERMINAL:
                        (*pNumNodes)++;
                        (*pNumConnections)++;

                        // Input and Output terminals map the same way for this value.
                        if ( u.pInput->wTerminalType != USB_Streaming) {
                           (*pNumConnections)++;
                        }
                        else if ( !(*pbmCategories & (1<<u.pUnit->bDescriptorSubtype)) ) {
                            (*pbmCategories) |= (1<<u.pUnit->bDescriptorSubtype);
                            (*pNumCategories)++;
                        }
                        break;

                    case FEATURE_UNIT:
                        ulNumChannels = CountInputChannels( pConfigurationDescriptor,
                                                            u.pUnit->bUnitID );

                        bmMergedControls = 0;
                        for (i=0; i<=ulNumChannels; i++) {
                            bmControls = 0;
                            for (j=u.pFeature->bControlSize; j>0; j--) {
                                bmControls <<= 8;
                                bmControls |= u.pFeature->bmaControls[i*u.pFeature->bControlSize+j-1];
                            }

                            bmMergedControls |= bmControls;
                        }

                        // Count the nodes and connections
                        while (bmMergedControls) {
                            bmMergedControls = (bmMergedControls & (bmMergedControls-1));
                            (*pNumConnections)++;
                            (*pNumNodes)++;
                        }
                        break;

                    case MIXER_UNIT:
                        // The mixer unit always generates N+1 nodes and 2*N connections
                        (*pNumNodes) += u.pMixer->bNrInPins + 1;
                        (*pNumConnections) += 2*u.pMixer->bNrInPins;
                        break;

                    case SELECTOR_UNIT:
                        (*pNumNodes)++;
                        (*pNumConnections) += u.pSelector->bNrInPins;
                        break;

                    case PROCESSING_UNIT:
                        (*pNumNodes)++;
                        (*pNumConnections) += u.pProcess->bNrInPins;
                        break;

                    case EXTENSION_UNIT:
                        (*pNumNodes)++;
                        (*pNumConnections) += u.pExtension->bNrInPins;
                        break;

                    default:
                        break;
                }

                u.pUnit = (PAUDIO_UNIT) ((PUCHAR)u.pUnit + u.pUnit->bLength);
                if ( (PUCHAR)u.pUnit >= ((PUCHAR)pHeader + pHeader->wTotalLength)) {
                    u.pUnit = NULL;
                }
            }
        }

        pControlIFDescriptor = USBD_ParseConfigurationDescriptorEx (
                                 pConfigurationDescriptor,
                                 ((PUCHAR)pControlIFDescriptor + pControlIFDescriptor->bLength),
                                 -1,                     // Interface number
                                 -1,                     // Alternate Setting
                                 USB_DEVICE_CLASS_AUDIO, // Audio Class (Interface Class)
                                 AUDIO_SUBCLASS_CONTROL, // control subclass (Interface Sub-Class)
                                 -1 ) ;                  // protocol don't care (InterfaceProtocol)
    }

    // Now that we have had fun with audio, let's try MIDI
    pMIDIStreamingDescriptor = USBD_ParseConfigurationDescriptorEx (
                         pConfigurationDescriptor,
                         (PVOID) pConfigurationDescriptor,
                         -1,                     // Interface number
                         -1,                     // Alternate Setting
                         USB_DEVICE_CLASS_AUDIO, // Audio Class (Interface Class)
                         AUDIO_SUBCLASS_MIDISTREAMING,  // first subclass (Interface Sub-Class)
                         -1 ) ;                  // protocol don't care (InterfaceProtocol)

    while ( pMIDIStreamingDescriptor ) {
        if ( pGeneralMIDIStreamDescriptor = (PMIDISTREAMING_GENERAL_STREAM)
            USBD_ParseDescriptors( (PVOID) pConfigurationDescriptor,
                                   pConfigurationDescriptor->wTotalLength,
                                   (PVOID) pMIDIStreamingDescriptor,
                                   USB_CLASS_AUDIO | USB_INTERFACE_DESCRIPTOR_TYPE ) ) {
            u.pUnit = (PAUDIO_UNIT)
                USBD_ParseDescriptors( (PVOID)pGeneralMIDIStreamDescriptor,
                                       pGeneralMIDIStreamDescriptor->wTotalLength,
                                       ((PUCHAR)pGeneralMIDIStreamDescriptor + pGeneralMIDIStreamDescriptor->bLength),
                                       USB_CLASS_AUDIO | USB_INTERFACE_DESCRIPTOR_TYPE );
            while ( u.pUnit ) {
                switch (u.pUnit->bDescriptorSubtype) {
                    case MIDI_IN_JACK:
                        if ( u.pMIDIInJack->bJackType == JACK_TYPE_EMBEDDED) {
                            if ( !(*pbmCategories & (1<<u.pUnit->bDescriptorSubtype)) ) {
                                (*pbmCategories) |= (1<<u.pUnit->bDescriptorSubtype);
                                (*pNumCategories)++;
                            }
                        }
                        break;
                    case MIDI_OUT_JACK:
                        (*pNumConnections) += u.pMIDIOutJack->bNrInputPins;

                        if ( u.pMIDIOutJack->bJackType == JACK_TYPE_EMBEDDED) {
                            if ( !(*pbmCategories & (1<<u.pUnit->bDescriptorSubtype)) ) {
                                (*pbmCategories) |= (1<<u.pUnit->bDescriptorSubtype);
                                (*pNumCategories)++;
                            }
                        }
                        break;

                    case MIDI_ELEMENT:
                        (*pNumNodes)++;
                        (*pNumConnections) += u.pMIDIElement->bNrInputPins +
                            u.pMIDIElement->baSourceConnections[u.pMIDIElement->bNrInputPins].SourceID;
                        break;

                    default:
                        break;
                }

                // Find the next unit.
                u.pUnit = (PAUDIO_UNIT) USBD_ParseDescriptors(
                                    (PVOID) pGeneralMIDIStreamDescriptor,
                                    pGeneralMIDIStreamDescriptor->wTotalLength,
                                    (PUCHAR)u.pUnit + u.pUnit->bLength,
                                    USB_CLASS_AUDIO | USB_INTERFACE_DESCRIPTOR_TYPE );
            }
        }

        // Get next MIDI Streaming Interface
        pMIDIStreamingDescriptor = USBD_ParseConfigurationDescriptorEx (
                             pConfigurationDescriptor,
                             ((PUCHAR)pMIDIStreamingDescriptor + pMIDIStreamingDescriptor->bLength),
                             -1,                     // Interface number
                             -1,                     // Alternate Setting
                             USB_DEVICE_CLASS_AUDIO, // Audio Class (Interface Class)
                             AUDIO_SUBCLASS_MIDISTREAMING,  // next MIDI Streaming Interface (Interface Sub-Class)
                             -1 ) ;                  // protocol don't care (InterfaceProtocol)
    }
}

KSPIN_DATAFLOW
GetDataFlowDirectionForInterface(
    PUSB_CONFIGURATION_DESCRIPTOR pConfigurationDescriptor,
    ULONG ulInterfaceNumber )
{
    PUSB_INTERFACE_DESCRIPTOR pInterfaceDescriptor;
    PUSB_ENDPOINT_DESCRIPTOR  pEndpointDescriptor;
    KSPIN_DATAFLOW KsPinDataFlow = KSPIN_DATAFLOW_IN;

    pInterfaceDescriptor =
            GetFirstAudioStreamingInterface( pConfigurationDescriptor, ulInterfaceNumber );

    while ( pInterfaceDescriptor &&
          ( IsZeroBWInterface( pConfigurationDescriptor, pInterfaceDescriptor ) ||
           !IsSupportedFormat( pConfigurationDescriptor, pInterfaceDescriptor ))) {
       pInterfaceDescriptor =
                     GetNextAudioInterface( pConfigurationDescriptor, pInterfaceDescriptor );
    }

    pEndpointDescriptor = GetEndpointDescriptor( pConfigurationDescriptor,
                                                 pInterfaceDescriptor,
                                                 FALSE );

    if ( pEndpointDescriptor &&
       ( pEndpointDescriptor->bEndpointAddress & USB_ENDPOINT_DIRECTION_MASK)) {
        KsPinDataFlow = KSPIN_DATAFLOW_OUT;
    }

    return KsPinDataFlow;
}

KSPIN_DATAFLOW
GetDataFlowDirectionForMIDIInterface(
    PUSB_CONFIGURATION_DESCRIPTOR pConfigurationDescriptor,
    ULONG ulPinNumber,
    BOOL fBridgePin )
{
    PUSB_INTERFACE_DESCRIPTOR pMIDIStreamingDescriptor;
    PMIDISTREAMING_GENERAL_STREAM pGeneralMIDIStreamDescriptor;
    KSPIN_DATAFLOW KsPinDataFlow = KSPIN_DATAFLOW_IN;
    ULONG ulMIDIBridgePinCount = 0;
    ULONG ulMIDIStreamingPinCount = 0;

    union {
        PAUDIO_UNIT                 pUnit;
        PMIDISTREAMING_ELEMENT      pMIDIElement;
        PMIDISTREAMING_MIDIIN_JACK  pMIDIInJack;
        PMIDISTREAMING_MIDIOUT_JACK pMIDIOutJack;
    } u;

    // Starting at the configuration descriptor, find the first MIDI interface.
    pMIDIStreamingDescriptor = USBD_ParseConfigurationDescriptorEx (
                         pConfigurationDescriptor,
                         (PVOID) pConfigurationDescriptor,
                         -1,                     // Interface number
                         -1,                     // Alternate Setting
                         USB_DEVICE_CLASS_AUDIO, // Audio Class (Interface Class)
                         AUDIO_SUBCLASS_MIDISTREAMING,  // first subclass (Interface Sub-Class)
                         -1 ) ;                  // protocol don't care (InterfaceProtocol)

    while ( pMIDIStreamingDescriptor ) {
        if ( pGeneralMIDIStreamDescriptor = (PMIDISTREAMING_GENERAL_STREAM)
            USBD_ParseDescriptors( (PVOID) pConfigurationDescriptor,
                                   pConfigurationDescriptor->wTotalLength,
                                   (PVOID) pMIDIStreamingDescriptor,
                                   USB_CLASS_AUDIO | USB_INTERFACE_DESCRIPTOR_TYPE ) ) {
            u.pUnit = (PAUDIO_UNIT)
                USBD_ParseDescriptors( (PVOID)pGeneralMIDIStreamDescriptor,
                                       pGeneralMIDIStreamDescriptor->wTotalLength,
                                       ((PUCHAR)pGeneralMIDIStreamDescriptor + pGeneralMIDIStreamDescriptor->bLength),
                                       USB_CLASS_AUDIO | USB_INTERFACE_DESCRIPTOR_TYPE );
            while ( u.pUnit ) {
                switch (u.pUnit->bDescriptorSubtype) {
                    case MIDI_IN_JACK:
                    case MIDI_OUT_JACK:
                        if (fBridgePin) {
                            if ( (ulPinNumber == ulMIDIBridgePinCount) &&
                                 ( u.pMIDIInJack->bJackType != JACK_TYPE_EMBEDDED) ) {
                                return (u.pUnit->bDescriptorSubtype == MIDI_IN_JACK) ? KSPIN_DATAFLOW_IN : KSPIN_DATAFLOW_OUT;
                            }
                        } else {  // Looking for a Streaming Pin
                            if ( (ulPinNumber == ulMIDIStreamingPinCount) &&
                                 ( u.pMIDIInJack->bJackType == JACK_TYPE_EMBEDDED) ) {
                                return (u.pUnit->bDescriptorSubtype == MIDI_IN_JACK) ? KSPIN_DATAFLOW_IN : KSPIN_DATAFLOW_OUT;
                            }
                        }

                        if ( u.pMIDIInJack->bJackType != JACK_TYPE_EMBEDDED) {
                           ulMIDIBridgePinCount++;
                        } else {
                           ulMIDIStreamingPinCount++;
                        }
                        break;

                    case MIDI_ELEMENT:
                        break;

                    default:
                        break;
                }


                // Find the next unit.
                u.pUnit = (PAUDIO_UNIT) USBD_ParseDescriptors(
                                    (PVOID) pGeneralMIDIStreamDescriptor,
                                    pGeneralMIDIStreamDescriptor->wTotalLength,
                                    (PUCHAR)u.pUnit + u.pUnit->bLength,
                                    USB_CLASS_AUDIO | USB_INTERFACE_DESCRIPTOR_TYPE );
            }
        }

        // Get next MIDI Streaming Interface
        pMIDIStreamingDescriptor = USBD_ParseConfigurationDescriptorEx (
                             pConfigurationDescriptor,
                             ((PUCHAR)pMIDIStreamingDescriptor + pMIDIStreamingDescriptor->bLength),
                             -1,                     // Interface number
                             -1,                     // Alternate Setting
                             USB_DEVICE_CLASS_AUDIO, // Audio Class (Interface Class)
                             AUDIO_SUBCLASS_MIDISTREAMING,  // next MIDI Streaming Interface (Interface Sub-Class)
                             -1 ) ;                  // protocol don't care (InterfaceProtocol)
    }

    ASSERT(0);  // should only get here if the MIDI interface is not found
    return KsPinDataFlow;
}

PAUDIO_UNIT
GetTerminalUnitForInterface(
    PUSB_CONFIGURATION_DESCRIPTOR pConfigurationDescriptor,
    PUSB_INTERFACE_DESCRIPTOR pInterfaceDescriptor )
{
    ULONG ulTerminalLinkId = 0xFFFFFFFF;
    PAUDIO_UNIT pUnit = NULL;

    PAUDIO_GENERAL_STREAM pGeneralDescriptor =
               (PAUDIO_GENERAL_STREAM) GetAudioSpecificInterface(
                                                        pConfigurationDescriptor,
                                                        pInterfaceDescriptor,
                                                        AS_GENERAL);

    if ( pGeneralDescriptor ){
        ulTerminalLinkId = (ULONG)pGeneralDescriptor->bTerminalLink;
        pUnit = GetUnit( pConfigurationDescriptor, ulTerminalLinkId );
    }

    return pUnit;
}

PAUDIO_UNIT
GetTerminalUnitForBridgePin(
    PUSB_CONFIGURATION_DESCRIPTOR pConfigurationDescriptor,
    ULONG ulBridgePinNumber )
{
    PUSB_INTERFACE_DESCRIPTOR pControlIFDescriptor;
    PAUDIO_HEADER_UNIT pHeader;
    PAUDIO_UNIT pUnit = NULL;
    BOOLEAN fFound = FALSE;
    ULONG ulBridgePinCount = 0;

    // Starting at the configuration descriptor, find the control interface.
    pControlIFDescriptor = USBD_ParseConfigurationDescriptorEx (
                             pConfigurationDescriptor,
                             (PVOID) pConfigurationDescriptor,
                             -1,                     // Interface number
                             -1,                     // Alternate Setting
                             USB_DEVICE_CLASS_AUDIO, // Audio Class (Interface Class)
                             AUDIO_SUBCLASS_CONTROL, // control subclass (Interface Sub-Class)
                             -1 ) ;                  // protocol don't care (InterfaceProtocol)

    while ( pControlIFDescriptor && !fFound ) {
        if ( pHeader = (PAUDIO_HEADER_UNIT)
            USBD_ParseDescriptors( (PVOID) pConfigurationDescriptor,
                                   pConfigurationDescriptor->wTotalLength,
                                   (PVOID) pControlIFDescriptor,
                                   USB_CLASS_AUDIO | USB_INTERFACE_DESCRIPTOR_TYPE ) ) {
            pUnit = (PAUDIO_UNIT)
                USBD_ParseDescriptors( (PVOID)pHeader,
                                       pHeader->wTotalLength,
                                       (PVOID)pHeader,
                                       USB_CLASS_AUDIO | USB_INTERFACE_DESCRIPTOR_TYPE );
            while ( pUnit && !fFound ) {
                switch (pUnit->bDescriptorSubtype) {
                    case INPUT_TERMINAL:
                        if ( ((PAUDIO_INPUT_TERMINAL)pUnit)->wTerminalType != USB_Streaming) {
                            if ( ulBridgePinCount++ == ulBridgePinNumber ) {
                                fFound = TRUE;
                            }
                        }
                        break;

                    case OUTPUT_TERMINAL:
                        if ( ((PAUDIO_OUTPUT_TERMINAL)pUnit)->wTerminalType != USB_Streaming) {
                            if ( ulBridgePinCount++ == ulBridgePinNumber ) {
                                fFound = TRUE;
                            }
                        }
                        break;

                    default:
                        break;
                }

                if ( !fFound ) {
                    pUnit = (PAUDIO_UNIT) ((PUCHAR)pUnit + pUnit->bLength);
                    if ((PUCHAR)pUnit >= ((PUCHAR)pHeader + pHeader->wTotalLength))
                        pUnit = NULL;
                }
            }
        }
        if (!fFound )
            pControlIFDescriptor = USBD_ParseConfigurationDescriptorEx (
                                 pConfigurationDescriptor,
                                 ((PUCHAR)pControlIFDescriptor + pControlIFDescriptor->bLength),
                                 -1,                     // Interface number
                                 -1,                     // Alternate Setting
                                 USB_DEVICE_CLASS_AUDIO, // Audio Class (Interface Class)
                                 AUDIO_SUBCLASS_CONTROL, // control subclass (Interface Sub-Class)
                                 -1 ) ;                  // protocol don't care (InterfaceProtocol)
    }

    return pUnit;
}

BOOL
IsBridgePinDigital(
    PUSB_CONFIGURATION_DESCRIPTOR pConfigurationDescriptor,
    ULONG ulBridgePinNumber)
{
    union {
        PAUDIO_UNIT pUnit;
        PAUDIO_INPUT_TERMINAL pInput;
        PAUDIO_OUTPUT_TERMINAL pOutput;
    } u;
    BOOL fDigitalOut = FALSE;

    u.pUnit = GetTerminalUnitForBridgePin( pConfigurationDescriptor,
                                           ulBridgePinNumber );

    if ( u.pUnit ) {
        if ( u.pUnit->bDescriptorSubtype == INPUT_TERMINAL ) {
            switch ( u.pInput->wTerminalType ) {
                // add new digital types here
                case Digital_audio_interface:
                case SPDIF_interface:
                    fDigitalOut = TRUE;
                    break;
                default:
                    fDigitalOut = FALSE;
                    break;
            }
        }
        else {
            fDigitalOut = FALSE;
        }
    }

    return fDigitalOut;
}

VOID
GetCategoryForBridgePin(
    PUSB_CONFIGURATION_DESCRIPTOR pConfigurationDescriptor,
    ULONG ulBridgePinNumber,
    GUID* pTTypeGUID )
{
    union {
        PAUDIO_UNIT pUnit;
        PAUDIO_INPUT_TERMINAL pInput;
        PAUDIO_OUTPUT_TERMINAL pOutput;
    } u;

    u.pUnit = GetTerminalUnitForBridgePin( pConfigurationDescriptor,
                                           ulBridgePinNumber );

    if ( u.pUnit ) {
        if ( u.pUnit->bDescriptorSubtype == INPUT_TERMINAL ) {
            INIT_USB_TERMINAL(pTTypeGUID, u.pInput->wTerminalType );
        }
        else {
            INIT_USB_TERMINAL(pTTypeGUID, u.pOutput->wTerminalType );
        }
    }
}

KSPIN_DATAFLOW
GetDataFlowForBridgePin(
    PUSB_CONFIGURATION_DESCRIPTOR pConfigurationDescriptor,
    ULONG ulBridgePinNumber )
{
    union {
        PAUDIO_UNIT pUnit;
        PAUDIO_INPUT_TERMINAL pInput;
        PAUDIO_OUTPUT_TERMINAL pOutput;
    } u;

    KSPIN_DATAFLOW KsPinDataFlow = 0;

    if ( u.pUnit = GetTerminalUnitForBridgePin( pConfigurationDescriptor,
                                           ulBridgePinNumber ) ) {
        KsPinDataFlow = ( u.pUnit->bDescriptorSubtype == INPUT_TERMINAL ) ?
                               KSPIN_DATAFLOW_IN : KSPIN_DATAFLOW_OUT;
    }

    return KsPinDataFlow;
}


LONG
GetPinNumberForStreamingTerminalUnit(
    PUSB_CONFIGURATION_DESCRIPTOR pConfigurationDescriptor,
    UCHAR ulTerminalNumber )
{
    PUSB_INTERFACE_DESCRIPTOR pInterfaceDescriptor;
    PAUDIO_GENERAL_STREAM pGeneralStream;
    ULONG ulPinNumber = 0;

    // Find the PinNumber
    pInterfaceDescriptor = GetFirstAudioStreamingInterface(pConfigurationDescriptor, ulPinNumber);
    while (pInterfaceDescriptor) {
        // Find the general stream descriptor for this interface
        pGeneralStream = (PAUDIO_GENERAL_STREAM) GetAudioSpecificInterface(
                                                pConfigurationDescriptor,
                                                pInterfaceDescriptor,
                                                AS_GENERAL);

        if (pGeneralStream && pGeneralStream->bTerminalLink == ulTerminalNumber)
            // We found the correct stream!
            return ulPinNumber;

        pInterfaceDescriptor =
            GetNextAudioInterface(pConfigurationDescriptor, pInterfaceDescriptor);

        if (!pInterfaceDescriptor) {
            // Move to next pin
            ulPinNumber++;
            pInterfaceDescriptor = GetFirstAudioStreamingInterface(pConfigurationDescriptor, ulPinNumber);
        }
    }

    return (-1L);
}

LONG
GetPinNumberForMIDIJack(
    PUSB_CONFIGURATION_DESCRIPTOR pConfigurationDescriptor,
    UCHAR ulJackID,
    ULONG pMIDIStreamingPinStartIndex,
    ULONG pBridgePinStartIndex)
{
    PUSB_INTERFACE_DESCRIPTOR pMIDIStreamingDescriptor;
    PMIDISTREAMING_GENERAL_STREAM pGeneralMIDIStreamDescriptor;
    ULONG ulNumBridgePins = 0;
    ULONG ulNumEmbeddedPins = 0;
    union {
        PAUDIO_UNIT                 pUnit;
        PMIDISTREAMING_MIDIIN_JACK  pMIDIInJack;
    } u;

    // Find the PinNumber
    pMIDIStreamingDescriptor = USBD_ParseConfigurationDescriptorEx (
                         pConfigurationDescriptor,
                         (PVOID) pConfigurationDescriptor,
                         -1,                     // Interface number
                         -1,                     // Alternate Setting
                         USB_DEVICE_CLASS_AUDIO, // Audio Class (Interface Class)
                         AUDIO_SUBCLASS_MIDISTREAMING,  // first subclass (Interface Sub-Class)
                         -1 ) ;                  // protocol don't care (InterfaceProtocol)
    while (pMIDIStreamingDescriptor) {
        // Find the general stream descriptor for this interface
        pGeneralMIDIStreamDescriptor = (PMIDISTREAMING_GENERAL_STREAM)
                                    USBD_ParseDescriptors( (PVOID) pConfigurationDescriptor,
                                                           pConfigurationDescriptor->wTotalLength,
                                                           (PVOID) pMIDIStreamingDescriptor,
                                                           USB_CLASS_AUDIO | USB_INTERFACE_DESCRIPTOR_TYPE );
        if (!pGeneralMIDIStreamDescriptor) {
            return (-1L);
        }

        u.pUnit = (PAUDIO_UNIT)
            USBD_ParseDescriptors( (PVOID)pGeneralMIDIStreamDescriptor,
                                   pGeneralMIDIStreamDescriptor->wTotalLength,
                                   ((PUCHAR)pGeneralMIDIStreamDescriptor + pGeneralMIDIStreamDescriptor->bLength),
                                   USB_CLASS_AUDIO | USB_INTERFACE_DESCRIPTOR_TYPE );
        while ( u.pUnit ) {

            if (u.pMIDIInJack->bJackID == ulJackID) {
                if (u.pMIDIInJack->bJackType == JACK_TYPE_EMBEDDED) {
                    return pMIDIStreamingPinStartIndex + ulNumEmbeddedPins;
                } else {
                    return pBridgePinStartIndex + ulNumBridgePins;
                }
            }

            if (u.pMIDIInJack->bJackType == JACK_TYPE_EMBEDDED) {
                ulNumEmbeddedPins++;
            } else {
                ulNumBridgePins++;
            }

            // Find the next unit.
            u.pUnit = (PAUDIO_UNIT) USBD_ParseDescriptors(
                                (PVOID) pGeneralMIDIStreamDescriptor,
                                pGeneralMIDIStreamDescriptor->wTotalLength,
                                (PUCHAR)u.pUnit + u.pUnit->bLength,
                                USB_CLASS_AUDIO | USB_INTERFACE_DESCRIPTOR_TYPE );
        }

        // Get next MIDI Streaming Interface
        pMIDIStreamingDescriptor = USBD_ParseConfigurationDescriptorEx (
                             pConfigurationDescriptor,
                             ((PUCHAR)pMIDIStreamingDescriptor + pMIDIStreamingDescriptor->bLength),
                             -1,                     // Interface number
                             -1,                     // Alternate Setting
                             USB_DEVICE_CLASS_AUDIO, // Audio Class (Interface Class)
                             AUDIO_SUBCLASS_MIDISTREAMING,  // next MIDI Streaming Interface (Interface Sub-Class)
                             -1 ) ;                  // protocol don't care (InterfaceProtocol)
    }

    return (-1L);
}

ULONG
GetChannelConfigForUnit( PUSB_CONFIGURATION_DESCRIPTOR pConfigurationDescriptor,
                         ULONG ulUnitNumber )
{
    union {
        PAUDIO_UNIT pUnit;
        PAUDIO_INPUT_TERMINAL  pInput;
        PAUDIO_OUTPUT_TERMINAL pOutput;
        PAUDIO_MIXER_UNIT      pMixer;
        PAUDIO_SELECTOR_UNIT   pSelector;
        PAUDIO_FEATURE_UNIT    pFeature;
        PAUDIO_PROCESSING_UNIT pProcess;
        PAUDIO_EXTENSION_UNIT  pExtension;
    } u;
    PAUDIO_CHANNELS pChannelInfo;
    PAUDIO_MIXER_UNIT_CHANNELS pMixChannels;

    ULONG ulChannelConfig = 0;

    u.pUnit = GetUnit(pConfigurationDescriptor, ulUnitNumber);
    while (u.pUnit) {
        switch (u.pUnit->bDescriptorSubtype) {
            case INPUT_TERMINAL:
                ulChannelConfig = (ULONG)u.pInput->wChannelConfig;
                u.pUnit = NULL;
                break;
            case OUTPUT_TERMINAL:
                u.pUnit = GetUnit(pConfigurationDescriptor, u.pOutput->bSourceID);
                break;
            case MIXER_UNIT:
                pMixChannels = (PAUDIO_MIXER_UNIT_CHANNELS)(u.pMixer->baSourceID + u.pMixer->bNrInPins);
                ulChannelConfig = (ULONG)pMixChannels->wChannelConfig;
                u.pUnit = NULL;
                break;
            case SELECTOR_UNIT:
                // NOTE: This assumes all inputs have the same number of channels!
                u.pUnit = GetUnit(pConfigurationDescriptor, u.pSelector->baSourceID[0]);
                break;
            case FEATURE_UNIT:
                u.pUnit = GetUnit(pConfigurationDescriptor, u.pFeature->bSourceID);
                break;
            case PROCESSING_UNIT:
            case EXTENSION_UNIT:
                pChannelInfo = (PAUDIO_CHANNELS)(u.pProcess->baSourceID + u.pProcess->bNrInPins);
                ulChannelConfig = (ULONG)pChannelInfo->wChannelConfig;
                u.pUnit = NULL;
                break;
            default:
                u.pUnit = NULL;
                break;
        }
    }

    return ulChannelConfig;
}

UCHAR
GetUnitControlInterface( PHW_DEVICE_EXTENSION pHwDevExt,
                         UCHAR bUnitId )
{
    PUSB_CONFIGURATION_DESCRIPTOR pConfigurationDescriptor = pHwDevExt->pConfigurationDescriptor;
    PUSB_INTERFACE_DESCRIPTOR pControlInterface;
    UCHAR ucCntrlIfNumber = 0xff;
    PVOID pStartPosition;

    // Starting at the configuration descriptor, find the control interface.
    pStartPosition = pConfigurationDescriptor;
    while ( pControlInterface = USBD_ParseConfigurationDescriptorEx (
                        pConfigurationDescriptor,
                        pStartPosition,
                        -1,        // interface number
                        -1,        //  (Alternate Setting)
                        USB_DEVICE_CLASS_AUDIO,        // Audio Class (Interface Class)
                        AUDIO_SUBCLASS_CONTROL,        // control subclass (Interface Sub-Class)
                        -1 ) )    // protocol don't care    (InterfaceProtocol)
    {
        PAUDIO_HEADER_UNIT pHeader;
        PAUDIO_UNIT pUnit;

        ucCntrlIfNumber = pControlInterface->bInterfaceNumber;

        pHeader = (PAUDIO_HEADER_UNIT) GetAudioSpecificInterface(
                                                pConfigurationDescriptor,
                                                pControlInterface,
                                                HEADER_UNIT);

        // Move to the next descriptor
        pUnit = (PAUDIO_UNIT) ((PUCHAR)pHeader + pHeader->bLength);
        while ((pUnit < (PAUDIO_UNIT)((PUCHAR)pHeader + pHeader->wTotalLength)) &&
               (pUnit->bUnitID != bUnitId)){
            pUnit = (PAUDIO_UNIT) ((PUCHAR)pUnit + pUnit->bLength);
        }
        if ( pUnit->bUnitID == bUnitId ) break;

        pStartPosition = (PUCHAR)pControlInterface + pControlInterface->bLength;
    }

    return ucCntrlIfNumber;

}

BOOLEAN
IsSampleRateInRange(
    PVOID pAudioDescriptor,
    ULONG ulSampleRate,
    ULONG ulFormatType )
{

    PAUDIO_CLASS_TYPE1_STREAM pT1AudioDescriptor = pAudioDescriptor;
    PAUDIO_CLASS_TYPE2_STREAM pT2AudioDescriptor = pAudioDescriptor;
    ULONG ulMinSampleRate, ulMaxSampleRate;
    BOOLEAN bInRange = FALSE;

    if ( ulFormatType == USBAUDIO_DATA_FORMAT_TYPE_I_UNDEFINED ) {
        // Find the format-specific descriptor
        if (pT1AudioDescriptor->bSampleFreqType == 0) {
            // Continuous range available
            ulMinSampleRate = pT1AudioDescriptor->pSampleRate[0].bSampleFreqByte1 +
                       256L * pT1AudioDescriptor->pSampleRate[0].bSampleFreqByte2 +
                     65536L * pT1AudioDescriptor->pSampleRate[0].bSampleFreqByte3;
            ulMaxSampleRate = pT1AudioDescriptor->pSampleRate[1].bSampleFreqByte1 +
                       256L * pT1AudioDescriptor->pSampleRate[1].bSampleFreqByte2 +
                     65536L * pT1AudioDescriptor->pSampleRate[1].bSampleFreqByte3;
            if ( (ulMinSampleRate <= ulSampleRate) && (ulMaxSampleRate >= ulSampleRate) ) {
                bInRange = TRUE;
            }
        }
        else {
            ULONG i;
            for (i=0; i<(ULONG)pT1AudioDescriptor->bSampleFreqType; i++) {
                ulMaxSampleRate = pT1AudioDescriptor->pSampleRate[i].bSampleFreqByte1 +
                           256L * pT1AudioDescriptor->pSampleRate[i].bSampleFreqByte2 +
                         65536L * pT1AudioDescriptor->pSampleRate[i].bSampleFreqByte3;
                if ( ulMaxSampleRate == ulSampleRate ) {
                    // We have a match!
                    bInRange = TRUE;
                    break;
                }
            }
        }
    }

    else if (ulFormatType == USBAUDIO_DATA_FORMAT_TYPE_II_UNDEFINED ) {
        // Find the format-specific descriptor
        if (pT2AudioDescriptor->bSampleFreqType == 0) {
            // Continuous range available
            ulMinSampleRate = pT2AudioDescriptor->pSampleRate[0].bSampleFreqByte1 +
                       256L * pT2AudioDescriptor->pSampleRate[0].bSampleFreqByte2 +
                     65536L * pT2AudioDescriptor->pSampleRate[0].bSampleFreqByte3;
            ulMaxSampleRate = pT2AudioDescriptor->pSampleRate[1].bSampleFreqByte1 +
                       256L * pT2AudioDescriptor->pSampleRate[1].bSampleFreqByte2 +
                     65536L * pT2AudioDescriptor->pSampleRate[1].bSampleFreqByte3;
            if ( (ulMinSampleRate <= ulSampleRate) && (ulMaxSampleRate >= ulSampleRate) ) {
                // We have a match!
                bInRange = TRUE;
            }
        }
        else {
            ULONG i;
            for (i=0; i<(ULONG)pT2AudioDescriptor->bSampleFreqType; i++) {
                ulMaxSampleRate = pT2AudioDescriptor->pSampleRate[i].bSampleFreqByte1 +
                           256L * pT2AudioDescriptor->pSampleRate[i].bSampleFreqByte2 +
                         65536L * pT2AudioDescriptor->pSampleRate[i].bSampleFreqByte3;
                if ( ulMaxSampleRate == ulSampleRate ) {
                    // We have a match!
                    bInRange = TRUE;
                    break;
                }
            }
        }
    }

    return bInRange;
}

PUSBAUDIO_DATARANGE
GetUsbDataRangeForFormat(
    PKSDATAFORMAT pFormat,
    PUSBAUDIO_DATARANGE pUsbDataRange,
    ULONG ulUsbDataRangeCnt )
{
    PUSBAUDIO_DATARANGE pOutUsbDataRange = NULL;
    union {
        PAUDIO_CLASS_STREAM pAudioDescriptor;
        PAUDIO_CLASS_TYPE1_STREAM pT1AudioDescriptor;
        PAUDIO_CLASS_TYPE2_STREAM pT2AudioDescriptor;
    } u1;

    union {
        PWAVEFORMATEX pDataFmtWave;
        PWAVEFORMATPCMEX pDataFmtPcmEx;
    } u2;

    PKSDATARANGE pStreamRange;
    ULONG ulFormatType;
    ULONG fFound = FALSE;
    ULONG i;

    u2.pDataFmtWave = &((PKSDATAFORMAT_WAVEFORMATEX)pFormat)->WaveFormatEx;

    for ( i=0; ((i<ulUsbDataRangeCnt) && !fFound); ) {
        // Verify the Format GUIDS first
        pStreamRange = (PKSDATARANGE)&pUsbDataRange[i].KsDataRangeAudio;
        if ( IsEqualGUID(&pFormat->MajorFormat, &pStreamRange->MajorFormat) &&
             IsEqualGUID(&pFormat->SubFormat,   &pStreamRange->SubFormat)   &&
             IsEqualGUID(&pFormat->Specifier,   &pStreamRange->Specifier) ) {

            u1.pAudioDescriptor = pUsbDataRange[i].pAudioDescriptor;

            // Based on the Data Type check remainder of format paramters
            ulFormatType = pUsbDataRange[i].ulUsbDataFormat & USBAUDIO_DATA_FORMAT_TYPE_MASK;
            switch( ulFormatType ) {
                case USBAUDIO_DATA_FORMAT_TYPE_I_UNDEFINED:
                    if ( u2.pDataFmtWave->wFormatTag == WAVE_FORMAT_EXTENSIBLE ) {
                        if ( (u1.pT1AudioDescriptor->bNumberOfChannels == u2.pDataFmtPcmEx->Format.nChannels      ) &&
                            ((u1.pT1AudioDescriptor->bSlotSize<<3)     == u2.pDataFmtPcmEx->Format.wBitsPerSample ) &&
                             (u1.pT1AudioDescriptor->bBitsPerSample    == u2.pDataFmtPcmEx->Samples.wValidBitsPerSample ) )
                            fFound = TRUE;
                    }
                    else {
                        if ( (u1.pT1AudioDescriptor->bNumberOfChannels == u2.pDataFmtWave->nChannels     ) &&
                             (u1.pT1AudioDescriptor->bBitsPerSample    == u2.pDataFmtWave->wBitsPerSample) )
                            fFound = TRUE;
                    }

                    // If all other paramters match check sample rate
                    if ( fFound ) {
                        fFound = IsSampleRateInRange( u1.pT1AudioDescriptor,
                                                      u2.pDataFmtWave->nSamplesPerSec,
                                                      ulFormatType );
                    }
                    break;
                case USBAUDIO_DATA_FORMAT_TYPE_II_UNDEFINED:
                    fFound = IsSampleRateInRange( u1.pT2AudioDescriptor,
                                                  u2.pDataFmtWave->nSamplesPerSec,
                                                  ulFormatType );
                    break;
                case USBAUDIO_DATA_FORMAT_TYPE_III_UNDEFINED:
                default:
                    break;
            }

        }

        if (!fFound) i++;
    }

    if ( fFound ) {
        pOutUsbDataRange = &pUsbDataRange[i];
    }

    return pOutUsbDataRange;
}

ULONG
GetPinDataRangesFromInterface(
    ULONG ulInterfaceNumber,
    PUSB_CONFIGURATION_DESCRIPTOR pConfigurationDescriptor,
    PKSDATARANGE_AUDIO *ppKsAudioRange,
    PUSBAUDIO_DATARANGE pAudioDataRange )
{
    PUSB_INTERFACE_DESCRIPTOR pInterfaceDescriptor;
    ULONG ulDataRangeCount = 0;
    ULONG i;

    ulDataRangeCount =
        CountFormatsForAudioStreamingInterface( pConfigurationDescriptor, ulInterfaceNumber );

    if ( ulDataRangeCount ) {

        pInterfaceDescriptor =
                GetFirstAudioStreamingInterface( pConfigurationDescriptor, ulInterfaceNumber );

        while ( pInterfaceDescriptor &&
              ( IsZeroBWInterface( pConfigurationDescriptor, pInterfaceDescriptor ) ||
               !IsSupportedFormat( pConfigurationDescriptor, pInterfaceDescriptor ))) {
            pInterfaceDescriptor =
                     GetNextAudioInterface( pConfigurationDescriptor, pInterfaceDescriptor );
        }

        for ( i=0; i<ulDataRangeCount; i++ ) {
            ppKsAudioRange[i] = &pAudioDataRange[i].KsDataRangeAudio;
            ConvertInterfaceToDataRange( pConfigurationDescriptor,
                                         pInterfaceDescriptor,
                                         &pAudioDataRange[i] );

            pAudioDataRange[i].pTerminalUnit =
                GetTerminalUnitForInterface( pConfigurationDescriptor,
                                             pInterfaceDescriptor);

            pAudioDataRange[i].ulChannelConfig =
                GetChannelConfigForUnit( pConfigurationDescriptor,
                                         pAudioDataRange[i].pTerminalUnit->bUnitID );

            pAudioDataRange[i].pInterfaceDescriptor = pInterfaceDescriptor;

            pAudioDataRange[i].pAudioEndpointDescriptor = (PAUDIO_ENDPOINT_DESCRIPTOR)
                GetEndpointDescriptor( pConfigurationDescriptor,
                                       pInterfaceDescriptor,
                                       TRUE );

            pAudioDataRange[i].pEndpointDescriptor =
                GetEndpointDescriptor( pConfigurationDescriptor,
                                       pInterfaceDescriptor,
                                       FALSE );

            // If any of these fail this device has bad descriptors
            ASSERT(pAudioDataRange[i].pTerminalUnit);
            ASSERT(pAudioDataRange[i].pAudioEndpointDescriptor);
            ASSERT(pAudioDataRange[i].pEndpointDescriptor);

            // Check if there is an async endpoint and save the pointer if there is.
            pAudioDataRange[i].pSyncEndpointDescriptor =
                GetSyncEndpointDescriptor( pConfigurationDescriptor,
                                            pInterfaceDescriptor );
            pInterfaceDescriptor =
                     GetNextAudioInterface( pConfigurationDescriptor, pInterfaceDescriptor );
            while ( pInterfaceDescriptor &&
                   ( IsZeroBWInterface( pConfigurationDescriptor, pInterfaceDescriptor ) ||
                    !IsSupportedFormat( pConfigurationDescriptor, pInterfaceDescriptor ))) {
                pInterfaceDescriptor =
                     GetNextAudioInterface( pConfigurationDescriptor, pInterfaceDescriptor );
            }
        }
    }

    return ulDataRangeCount;
}

VOID
GetContextForMIDIPin
(
    PKSPIN pKsPin,
    PUSB_CONFIGURATION_DESCRIPTOR pConfigurationDescriptor,
    PMIDI_PIN_CONTEXT pMIDIPinContext
)
{
    PUSB_INTERFACE_DESCRIPTOR pControlInterface;
    PUSB_INTERFACE_DESCRIPTOR pAudioInterface;
    PUSB_INTERFACE_DESCRIPTOR pAudioStreamingInterface;
    PAUDIO_HEADER_UNIT pHeader;
    PMIDISTREAMING_GENERAL_STREAM pGeneralMIDIStreamDescriptor;
    PMIDISTREAMING_ENDPOINT_DESCRIPTOR pMIDIEPDescriptor;
    ULONG i;

    union {
        PAUDIO_UNIT                 pUnit;
        PAUDIO_INPUT_TERMINAL       pInput;
        PAUDIO_MIXER_UNIT           pMixer;
        PAUDIO_PROCESSING_UNIT      pProcess;
        PAUDIO_EXTENSION_UNIT       pExtension;
        PAUDIO_FEATURE_UNIT         pFeature;
        PAUDIO_SELECTOR_UNIT        pSelector;
        PMIDISTREAMING_ELEMENT      pMIDIElement;
        PMIDISTREAMING_MIDIIN_JACK  pMIDIInJack;
        PMIDISTREAMING_MIDIOUT_JACK pMIDIOutJack;
    } u;

    ULONG ulPinCount = 0;
    ULONG ulInterfaceCount = 0;
    ULONG ulEndpointCount = 0;

    pMIDIPinContext->ulEndpointNumber = MAX_ULONG;
    pMIDIPinContext->ulInterfaceNumber = MAX_ULONG;

    //  Starting at the configuration descriptor, find the first audio interface.
    //  We are counting the number of AudioStreaming Pins in this while loop
    pControlInterface = USBD_ParseConfigurationDescriptorEx (
                           pConfigurationDescriptor,
                           (PVOID) pConfigurationDescriptor,
                           -1,                     // Interface number
                           -1,                     // Alternate Setting
                           USB_DEVICE_CLASS_AUDIO, // Audio Class (Interface Class)
                           AUDIO_SUBCLASS_CONTROL, // any subclass (Interface Sub-Class)
                           -1 ) ;                  // protocol don't care (InterfaceProtocol)

    while ( pControlInterface ) {
        if ( pHeader = (PAUDIO_HEADER_UNIT)
            USBD_ParseDescriptors( (PVOID) pConfigurationDescriptor,
                                   pConfigurationDescriptor->wTotalLength,
                                   (PVOID) pControlInterface,
                                   USB_CLASS_AUDIO | USB_INTERFACE_DESCRIPTOR_TYPE ) ) {
            u.pUnit = (PAUDIO_UNIT)
                USBD_ParseDescriptors( (PVOID)pHeader,
                                       pHeader->wTotalLength,
                                       ((PUCHAR)pHeader + pHeader->bLength),
                                       USB_CLASS_AUDIO | USB_INTERFACE_DESCRIPTOR_TYPE );
            while ( u.pUnit ) {
                switch (u.pUnit->bDescriptorSubtype) {
                    case INPUT_TERMINAL:
                    case OUTPUT_TERMINAL:
                        ulPinCount++;
                        break;

                    default:
                        break;
                }

                u.pUnit = (PAUDIO_UNIT) ((PUCHAR)u.pUnit + u.pUnit->bLength);
                if ( (PUCHAR)u.pUnit >= ((PUCHAR)pHeader + pHeader->wTotalLength)) {
                    u.pUnit = NULL;
                }
            }
        }

        pControlInterface = USBD_ParseConfigurationDescriptorEx (
                               pConfigurationDescriptor,
                               (PUCHAR)pControlInterface + pControlInterface->bLength,
                               -1,                     // Interface number
                               -1,                     // Alternate Setting
                               USB_DEVICE_CLASS_AUDIO, // Audio Class (Interface Class)
                               AUDIO_SUBCLASS_CONTROL, // any subclass (Interface Sub-Class)
                               -1 ) ;                  // protocol don't care (InterfaceProtocol)
    }

    // Get the first Audio interface
    pAudioInterface = USBD_ParseConfigurationDescriptorEx (
                                pConfigurationDescriptor,
                                pConfigurationDescriptor,
                                -1,        // interface number
                                -1,        //  (Alternate Setting)
                                USB_DEVICE_CLASS_AUDIO,        // Audio Class (Interface Class)
                                -1,        // any subclass (Interface Sub-Class)
                                -1 );

    // Loop through the audio device class interfaces
    while (pAudioInterface) {

        switch (pAudioInterface->bInterfaceSubClass) {
            case AUDIO_SUBCLASS_STREAMING:
                // This subclass is handled with the control class since they have to come together
                _DbgPrintF(DEBUGLVL_VERBOSE,("[GetContextForMIDIPin] Found AudioStreaming at %x\n",pAudioInterface));
                break;
            case AUDIO_SUBCLASS_CONTROL:
                _DbgPrintF(DEBUGLVL_VERBOSE,("[GetContextForMIDIPin] Found AudioControl at %x\n",pAudioInterface));
                ulInterfaceCount++;

                pHeader = (PAUDIO_HEADER_UNIT)
                         GetAudioSpecificInterface( pConfigurationDescriptor,
                                                    pAudioInterface,
                                                    HEADER_UNIT );
                if ( pHeader ) {
                    // Find each interface associated with this header
                    for ( i=0; i<pHeader->bInCollection; i++ ) {
                        pAudioStreamingInterface = USBD_ParseConfigurationDescriptorEx (
                                    pConfigurationDescriptor,
                                    (PVOID)pConfigurationDescriptor,
                                    (LONG)pHeader->baInterfaceNr[i],  // Interface number
                                    -1,                               // Alternate Setting
                                    USB_DEVICE_CLASS_AUDIO,           // Audio Class (Interface Class)
                                    AUDIO_SUBCLASS_STREAMING,         // Audio Streaming (Interface Sub-Class)
                                    -1 ) ;                            // protocol don't care    (InterfaceProtocol)

                        if ( pAudioStreamingInterface ) {
                            ulInterfaceCount++;
                        }
                    }
                }
                break;
            case AUDIO_SUBCLASS_MIDISTREAMING:
                _DbgPrintF(DEBUGLVL_VERBOSE,("[GetContextForMIDIPin] Found MIDIStreaming at %x\n",pAudioInterface));
                if ( pGeneralMIDIStreamDescriptor = (PMIDISTREAMING_GENERAL_STREAM)
                    USBD_ParseDescriptors( (PVOID) pConfigurationDescriptor,
                                           pConfigurationDescriptor->wTotalLength,
                                           (PVOID) pAudioInterface,
                                           USB_CLASS_AUDIO | USB_INTERFACE_DESCRIPTOR_TYPE ) ) {
                    u.pUnit = (PAUDIO_UNIT)
                        USBD_ParseDescriptors( (PVOID)pGeneralMIDIStreamDescriptor,
                                               pGeneralMIDIStreamDescriptor->wTotalLength,
                                               ((PUCHAR)pGeneralMIDIStreamDescriptor + pGeneralMIDIStreamDescriptor->bLength),
                                               USB_CLASS_AUDIO | USB_INTERFACE_DESCRIPTOR_TYPE );
                    while ( u.pUnit ) {
                        switch (u.pUnit->bDescriptorSubtype) {
                            case MIDI_IN_JACK:
                            case MIDI_OUT_JACK:

                                if ( (pKsPin->Id == ulPinCount) &&
                                     (u.pMIDIInJack->bJackType == JACK_TYPE_EMBEDDED) ) {
                                    // Setting the Interface Number for this pin
                                    pMIDIPinContext->ulInterfaceNumber = ulInterfaceCount;
                                    pMIDIPinContext->ulJackID = u.pMIDIInJack->bJackID;

                                    _DbgPrintF(DEBUGLVL_VERBOSE,("[GetContextForMIDIPin] IC=%d JID=%x\n",
                                                                 pMIDIPinContext->ulInterfaceNumber,
                                                                 pMIDIPinContext->ulJackID));

                                    // Found the interface, now find the endpoint number
                                    pMIDIEPDescriptor = (PMIDISTREAMING_ENDPOINT_DESCRIPTOR)
                                        USBD_ParseDescriptors( pConfigurationDescriptor,
                                                               pConfigurationDescriptor->wTotalLength,
                                                               (PUCHAR)pGeneralMIDIStreamDescriptor,
                                                               USB_ENDPOINT_DESCRIPTOR_TYPE | USB_CLASS_AUDIO);
                                    while (pMIDIEPDescriptor) {

                                        // Check all of the jacks connected to this endpoint
                                        for (i=0; i<pMIDIEPDescriptor->bNumEmbMIDIJack;i++) {
                                            if (pMIDIEPDescriptor->baAssocJackID[i] == pMIDIPinContext->ulJackID) {
                                                pMIDIPinContext->ulCableNumber = i;
                                                pMIDIPinContext->ulEndpointNumber = ulEndpointCount;

                                                _DbgPrintF(DEBUGLVL_VERBOSE,("[GetContextForMIDIPin] CN=%d EP=%d\n",
                                                                             pMIDIPinContext->ulCableNumber,
                                                                             pMIDIPinContext->ulEndpointNumber));
                                            }
                                        }

                                        ulEndpointCount++;

                                        pMIDIEPDescriptor = (PMIDISTREAMING_ENDPOINT_DESCRIPTOR)
                                            USBD_ParseDescriptors( pConfigurationDescriptor,
                                                                   pConfigurationDescriptor->wTotalLength,
                                                                   (PUCHAR)pMIDIEPDescriptor + pMIDIEPDescriptor->bLength,
                                                                   USB_ENDPOINT_DESCRIPTOR_TYPE | USB_CLASS_AUDIO);
                                    }
                                }

                                if (u.pMIDIInJack->bJackType == JACK_TYPE_EMBEDDED) {
                                    ulPinCount++;
                                }
                                break;

                            case MIDI_ELEMENT:
                                break;

                            default:
                                break;
                        }

                        //  Found what we are looking for, stop looking
                        if (pMIDIPinContext->ulEndpointNumber != MAX_ULONG) {
                            break;
                        }

                        // Find the next unit.
                        u.pUnit = (PAUDIO_UNIT) USBD_ParseDescriptors(
                                            (PVOID) pGeneralMIDIStreamDescriptor,
                                            pGeneralMIDIStreamDescriptor->wTotalLength,
                                            (PUCHAR)u.pUnit + u.pUnit->bLength,
                                            USB_CLASS_AUDIO | USB_INTERFACE_DESCRIPTOR_TYPE );
                    }
                }

                ulInterfaceCount++;
                break;

            default:
                _DbgPrintF(DEBUGLVL_VERBOSE,("[GetContextForMIDIPin]: Invalid SubClass %x\n  ",pAudioInterface->bInterfaceSubClass));
                break;
        }

        // Get the next audio descriptor for this InterfaceNumber
        pAudioInterface = USBD_ParseConfigurationDescriptorEx (
                               pConfigurationDescriptor,
                               ((PUCHAR)pAudioInterface + pAudioInterface->bLength),
                               -1,
                               -1,                     // Alternate Setting
                               USB_DEVICE_CLASS_AUDIO, // Audio Class (Interface Class)
                               -1,                     // Interface Sub-Class
                               -1 ) ;                  // protocol don't care (InterfaceProtocol)

        _DbgPrintF(DEBUGLVL_VERBOSE,("[GetContextForMIDIPin] Next audio interface at %x\n",pAudioInterface));
    }

    // Check to make sure that we found the correct information
    ASSERT(pMIDIPinContext->ulEndpointNumber != MAX_ULONG);
    ASSERT(pMIDIPinContext->ulInterfaceNumber != MAX_ULONG);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\drivers\usbaudio.2\pin.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 2000
//
//  File:       pin.c
//
//--------------------------------------------------------------------------

#include "common.h"

#define USBMIDI_MIN_FRAMECOUNT  1
#define USBMIDI_MAX_FRAMECOUNT  10

NTSTATUS
USBAudioPinValidateDataFormat(
    PKSPIN pKsPin,
    PUSBAUDIO_DATARANGE pUSBAudioRange )
{
    PKSDATARANGE_AUDIO pKsDataRangeAudio = &pUSBAudioRange->KsDataRangeAudio;
    PKSDATAFORMAT pFormat = pKsPin->ConnectionFormat;
    NTSTATUS ntStatus = STATUS_NO_MATCH;
    union {
        PWAVEFORMATEX    pWavFmtEx;
        PWAVEFORMATPCMEX pWavFmtPCMEx;
    } u;

    u.pWavFmtEx = (PWAVEFORMATEX)(pFormat + 1);

    if ( IS_VALID_WAVEFORMATEX_GUID(&pKsDataRangeAudio->DataRange.SubFormat) ) {
        if ( pKsDataRangeAudio->MaximumChannels == u.pWavFmtEx->nChannels ) {
            if ( pKsDataRangeAudio->MaximumBitsPerSample == (ULONG)u.pWavFmtEx->wBitsPerSample ) {
                if ( IsSampleRateInRange( pUSBAudioRange->pAudioDescriptor,
                                          u.pWavFmtEx->nSamplesPerSec,
                                          pUSBAudioRange->ulUsbDataFormat & USBAUDIO_DATA_FORMAT_TYPE_MASK ) ){
                    if ( u.pWavFmtEx->wFormatTag == WAVE_FORMAT_EXTENSIBLE ) {
                        if ((u.pWavFmtPCMEx->Samples.wValidBitsPerSample == pUSBAudioRange->pAudioDescriptor->bBitsPerSample) &&
                            (u.pWavFmtPCMEx->dwChannelMask == pUSBAudioRange->ulChannelConfig))
                                ntStatus = STATUS_SUCCESS;
                    }
                    else if ((u.pWavFmtEx->nChannels <= 2) && (u.pWavFmtEx->wBitsPerSample <= 16)) {
                            ntStatus = STATUS_SUCCESS;
                    }
                }
            }
        }
    }
    // else Type 2
    else {
        if ( pKsDataRangeAudio->MaximumChannels == u.pWavFmtEx->nChannels ) {
            if ( pKsDataRangeAudio->MaximumBitsPerSample == (ULONG)u.pWavFmtEx->wBitsPerSample ) {
                if ( IsSampleRateInRange( pUSBAudioRange->pAudioDescriptor,
                                          u.pWavFmtEx->nSamplesPerSec,
                                          pUSBAudioRange->ulUsbDataFormat & USBAUDIO_DATA_FORMAT_TYPE_MASK ) ){
                    ntStatus = STATUS_SUCCESS;
                }
            }
        }
    }

    return ntStatus;

}

NTSTATUS
USBAudioPinCreate(
    IN OUT PKSPIN pKsPin,
    IN PIRP pIrp )
{
    PKSFILTER pKsFilter = NULL;
    PFILTER_CONTEXT pFilterContext = NULL;
    PHW_DEVICE_EXTENSION pHwDevExt = NULL;
    PPIN_CONTEXT pPinContext = NULL;
    PUSBAUDIO_DATARANGE pUsbAudioDataRange;

    NTSTATUS ntStatus = STATUS_SUCCESS;

    PAGED_CODE();

    ASSERT(pKsPin);
    ASSERT(pIrp);

    if (pKsPin) {
        if (pKsFilter = KsPinGetParentFilter( pKsPin )) {
            if (pFilterContext = pKsFilter->Context) {
                pHwDevExt = pFilterContext->pHwDevExt;
            }
        }
    }

    if (!pHwDevExt) {
        _DbgPrintF(DEBUGLVL_TERSE,("[PinCreate] failed to get context\n"));
        return STATUS_INVALID_PARAMETER;
    }

    _DbgPrintF(DEBUGLVL_TERSE,("[PinCreate] pin %d\n",pKsPin->Id));

    //  In the case of multiple filters created on a device the pin possible count is maintained on the
    //  device level in order to ensure that too many pins aren't opened on the device
    if ( pHwDevExt->pPinInstances[pKsPin->Id].CurrentCount <
         pHwDevExt->pPinInstances[pKsPin->Id].PossibleCount ) {

        pHwDevExt->pPinInstances[pKsPin->Id].CurrentCount++;
    }
    else {
        _DbgPrintF(DEBUGLVL_TERSE,("[PinCreate] failed with CurrentCount=%d and PossibleCount=%d\n",
                                   pHwDevExt->pPinInstances[pKsPin->Id].CurrentCount,
                                   pHwDevExt->pPinInstances[pKsPin->Id].PossibleCount));
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    // Allocate the Context for the Pin and initialize it
    pPinContext = pKsPin->Context = AllocMem(NonPagedPool, sizeof(PIN_CONTEXT));
    if (!pPinContext) {
        pHwDevExt->pPinInstances[pKsPin->Id].CurrentCount--;
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(pPinContext,sizeof(PIN_CONTEXT));

    // Bag the context for easy cleanup.
    KsAddItemToObjectBag(pKsPin->Bag, pPinContext, FreeMem);

    // Save the Hardware extension in the Pin Context
    pPinContext->pHwDevExt             = pHwDevExt;
    pPinContext->pNextDeviceObject = pFilterContext->pNextDeviceObject;

    // Initialize hSystemStateHandle
    pPinContext->hSystemStateHandle = NULL;

    // Initialize the DRM Content ID
    pPinContext->DrmContentId = 0;

    // Find the Streaming Interface to match the data format of the Pin.
    pUsbAudioDataRange =
        GetUsbDataRangeForFormat( pKsPin->ConnectionFormat,
                                  (PUSBAUDIO_DATARANGE)pKsPin->Descriptor->PinDescriptor.DataRanges[0],
                                  pKsPin->Descriptor->PinDescriptor.DataRangesCount );
    if ( !pUsbAudioDataRange ) {
        pHwDevExt->pPinInstances[pKsPin->Id].CurrentCount--;
        return STATUS_INVALID_DEVICE_REQUEST;
    }

    // Save the USB DataRange Structure selected in the Pin Context
    pPinContext->pUsbAudioDataRange = pUsbAudioDataRange;

    // Get the Max Packet Size for the interface
    pPinContext->ulMaxPacketSize =
             GetMaxPacketSizeForInterface( pHwDevExt->pConfigurationDescriptor,
                                           pUsbAudioDataRange->pInterfaceDescriptor );

    // Rely on USB to fail the Select Interface call if there is not enough bandwidth.
    // This should result in one (and only one) popup from the USB UI component.
    //
    //if ( (LONG)pPinContext->ulMaxPacketSize >
    //                GetAvailableUSBBusBandwidth( pPinContext->pNextDeviceObject ) ) {
    //    return STATUS_INSUFFICIENT_RESOURCES;
    //}

    // Have the hardware select the interface
    ntStatus = SelectStreamingAudioInterface( pUsbAudioDataRange->pInterfaceDescriptor,
                                              pHwDevExt, pKsPin );
    if ( !NT_SUCCESS(ntStatus) ) {
        pHwDevExt->pPinInstances[pKsPin->Id].CurrentCount--;
        return ntStatus;
    } else {
        ASSERT(pPinContext->hPipeHandle);
    }

    // Initialize Pin SpinLock
    KeInitializeSpinLock(&pPinContext->PinSpinLock);

    // Initialize Pin Starvation Event
    KeInitializeEvent( &pPinContext->PinStarvationEvent, NotificationEvent, FALSE );

    // Setup approriate allocator framing for the interface selected.
    ntStatus = KsEdit( pKsPin, &pKsPin->Descriptor, USBAUDIO_POOLTAG );
    if ( NT_SUCCESS(ntStatus) ) {
        ntStatus = KsEdit( pKsPin, &pKsPin->Descriptor->AllocatorFraming, USBAUDIO_POOLTAG );
    }

    //  KsEdit failed above
    if ( !NT_SUCCESS(ntStatus) ) {
        pHwDevExt->pPinInstances[pKsPin->Id].CurrentCount--;
        return ntStatus;
    }

    // Now do format specific initialization
    if ( pKsPin->DataFlow == KSPIN_DATAFLOW_OUT ) {
        ntStatus = CaptureStreamInit( pKsPin );
        pPinContext->PinType = WaveIn;
    }
    else {
        switch( pUsbAudioDataRange->ulUsbDataFormat & USBAUDIO_DATA_FORMAT_TYPE_MASK ) {
            case USBAUDIO_DATA_FORMAT_TYPE_I_UNDEFINED:
                ntStatus = TypeIRenderStreamInit( pKsPin );
                break;
            case USBAUDIO_DATA_FORMAT_TYPE_II_UNDEFINED:
                ntStatus = TypeIIRenderStreamInit( pKsPin );
                break;
            case USBAUDIO_DATA_FORMAT_TYPE_III_UNDEFINED:
            default:
                ntStatus = STATUS_NOT_SUPPORTED;
                break;
        }
        pPinContext->PinType = WaveOut;
    }

    //  Failed to initialize pin
    if ( !NT_SUCCESS(ntStatus) ) {
        pHwDevExt->pPinInstances[pKsPin->Id].CurrentCount--;
    }

    return ntStatus;
}

NTSTATUS
USBAudioPinClose(
    IN PKSPIN pKsPin,
    IN PIRP Irp
    )
{
    PKSFILTER pKsFilter = NULL;
    PFILTER_CONTEXT pFilterContext = NULL;
    PHW_DEVICE_EXTENSION pHwDevExt = NULL;
    PPIN_CONTEXT pPinContext = NULL;
    NTSTATUS ntStatus = STATUS_SUCCESS;

    PAGED_CODE();

    ASSERT(pKsPin);
    ASSERT(Irp);

    if (pKsPin) {
        pPinContext = pKsPin->Context;

        if (pKsFilter = KsPinGetParentFilter( pKsPin )) {
            if (pFilterContext = pKsFilter->Context) {
                pHwDevExt = pFilterContext->pHwDevExt;
            }
        }
    }

    if (!pHwDevExt || !pPinContext) {
        _DbgPrintF(DEBUGLVL_TERSE,("[PinClose] failed to get context\n"));
        return STATUS_INVALID_PARAMETER;
    }

    _DbgPrintF(DEBUGLVL_TERSE,("[PinClose] pin %d\n",pKsPin->Id));

    // Now do format specific close
    if ( pKsPin->DataFlow == KSPIN_DATAFLOW_OUT ) {
        ntStatus = CaptureStreamClose( pKsPin );
    }
    else {
        switch( pPinContext->pUsbAudioDataRange->ulUsbDataFormat & USBAUDIO_DATA_FORMAT_TYPE_MASK ) {
            case USBAUDIO_DATA_FORMAT_TYPE_I_UNDEFINED:
                ntStatus = TypeIRenderStreamClose( pKsPin );
                break;
            case USBAUDIO_DATA_FORMAT_TYPE_II_UNDEFINED:
                ntStatus = TypeIIRenderStreamClose( pKsPin );
                break;
            case USBAUDIO_DATA_FORMAT_TYPE_III_UNDEFINED:
            default:
                ntStatus = STATUS_NOT_SUPPORTED;
                break;
        }
    }

    ntStatus = SelectZeroBandwidthInterface( pPinContext->pHwDevExt, pKsPin->Id );

    //  Free any existing pipe information
    if (pPinContext->Pipes) {
        FreeMem(pPinContext->Pipes);
    }

    pHwDevExt->pPinInstances[pKsPin->Id].CurrentCount--;

    return ntStatus;
}

NTSTATUS
USBAudioPinSetDeviceState(
    IN PKSPIN pKsPin,
    IN KSSTATE ToState,
    IN KSSTATE FromState
    )
{
    PPIN_CONTEXT pPinContext = pKsPin->Context;
    NTSTATUS ntStatus;

    PAGED_CODE();

    ASSERT(pKsPin);

    _DbgPrintF(DEBUGLVL_VERBOSE,("[PinSetDeviceState] pin %d\n",pKsPin->Id));

    if ( pKsPin->DataFlow == KSPIN_DATAFLOW_OUT ) {
        ntStatus = CaptureStateChange( pKsPin, FromState, ToState );
    }
    else {
        switch( pPinContext->pUsbAudioDataRange->ulUsbDataFormat & USBAUDIO_DATA_FORMAT_TYPE_MASK ) {
            case USBAUDIO_DATA_FORMAT_TYPE_I_UNDEFINED:
                ntStatus = TypeIStateChange( pKsPin, FromState, ToState );
                break;
            case USBAUDIO_DATA_FORMAT_TYPE_II_UNDEFINED:
                ntStatus = TypeIIStateChange( pKsPin, FromState, ToState );
                break;
            case USBAUDIO_DATA_FORMAT_TYPE_III_UNDEFINED:
            default:
                ntStatus = STATUS_NOT_SUPPORTED;
                break;
        }
    }

    if ( NT_SUCCESS(ntStatus) ) {
        if ( ToState == KSSTATE_RUN ) {
            if (!pPinContext->hSystemStateHandle) {
                // register the system state as busy
                pPinContext->hSystemStateHandle = PoRegisterSystemState( pPinContext->hSystemStateHandle,
                                                                         ES_SYSTEM_REQUIRED | ES_CONTINUOUS );
                _DbgPrintF(DEBUGLVL_VERBOSE,("[PinSetDeviceState] PoRegisterSystemState %x\n",pPinContext->hSystemStateHandle));
            }
        }
        else {
            if (pPinContext->hSystemStateHandle) {
                _DbgPrintF(DEBUGLVL_VERBOSE,("[PinSetDeviceState] PoUnregisterSystemState %x\n",pPinContext->hSystemStateHandle));
                PoUnregisterSystemState( pPinContext->hSystemStateHandle );
                pPinContext->hSystemStateHandle = NULL;
            }
        }
    }

    return ntStatus;
}


NTSTATUS
USBAudioPinSetDataFormat(
    IN PKSPIN pKsPin,
    IN PKSDATAFORMAT OldFormat OPTIONAL,
    IN PKSMULTIPLE_ITEM OldAttributeList OPTIONAL,
    IN const KSDATARANGE* DataRange,
    IN const KSATTRIBUTE_LIST* AttributeRange OPTIONAL
    )
{

    NTSTATUS ntStatus = STATUS_NO_MATCH;

    PAGED_CODE();

    ASSERT(pKsPin);

    _DbgPrintF(DEBUGLVL_VERBOSE,("[PinSetDataFormat] pin %d\n",pKsPin->Id));

    // If the old format is not NULL then the pin has already been created.
    if ( OldFormat ) {
        PPIN_CONTEXT pPinContext = (PPIN_CONTEXT)pKsPin->Context;
        ULONG ulFormatType = pPinContext->pUsbAudioDataRange->ulUsbDataFormat & USBAUDIO_DATA_FORMAT_TYPE_MASK;

        // If the pin has already been created make sure no other interface is used
        if ((PUSBAUDIO_DATARANGE)DataRange == pPinContext->pUsbAudioDataRange) {
            ntStatus = USBAudioPinValidateDataFormat(  pKsPin, (PUSBAUDIO_DATARANGE)DataRange );
        }

        if ( NT_SUCCESS(ntStatus) && (ulFormatType == USBAUDIO_DATA_FORMAT_TYPE_I_UNDEFINED)) {
            PULONG pSampleRate = AllocMem(NonPagedPool, sizeof(ULONG));
            *pSampleRate =
                ((PKSDATAFORMAT_WAVEFORMATEX)pKsPin->ConnectionFormat)->WaveFormatEx.nSamplesPerSec;
            ntStatus = SetSampleRate( pKsPin, pSampleRate );
            FreeMem(pSampleRate);
        }
    }
    // Otherwise simply check if this is a valid format
    else
        ntStatus = USBAudioPinValidateDataFormat(  pKsPin, (PUSBAUDIO_DATARANGE)DataRange );

    return ntStatus;
}

NTSTATUS
USBAudioPinProcess(
    IN PKSPIN pKsPin )
{
    PPIN_CONTEXT pPinContext = pKsPin->Context;
    NTSTATUS ntStatus = STATUS_NOT_SUPPORTED;

    DbgLog("PinProc", pKsPin, pPinContext, 0, 0);

    if (pKsPin->DataFlow == KSPIN_DATAFLOW_IN) {
        switch( pPinContext->pUsbAudioDataRange->ulUsbDataFormat & USBAUDIO_DATA_FORMAT_TYPE_MASK ) {
            case USBAUDIO_DATA_FORMAT_TYPE_I_UNDEFINED:
                ntStatus = TypeIProcessStreamPtr( pKsPin );
                break;
            case USBAUDIO_DATA_FORMAT_TYPE_II_UNDEFINED:
                ntStatus = TypeIIProcessStreamPtr( pKsPin );
                break;
            case USBAUDIO_DATA_FORMAT_TYPE_III_UNDEFINED:
            default:
                break;
        }
    }
    else
        ntStatus = CaptureProcess( pKsPin );

    return ntStatus;
}

void
USBAudioPinReset( PKSPIN pKsPin )
{
    _DbgPrintF(DEBUGLVL_VERBOSE,("[USBAudioPinReset] pin %d\n",pKsPin->Id));
    if (pKsPin->DataFlow == KSPIN_DATAFLOW_OUT) {
        _DbgPrintF(DEBUGLVL_VERBOSE,("Reset Capture pin %d\n",pKsPin->Id));
    }

}

NTSTATUS
USBAudioPinDataIntersect(
    IN PVOID Context,
    IN PIRP pIrp,
    IN PKSP_PIN pKsPinProperty,
    IN PKSDATARANGE DataRange,
    IN PKSDATARANGE MatchingDataRange,
    IN ULONG DataBufferSize,
    OUT PVOID pData OPTIONAL,
    OUT PULONG pDataSize )
{
    PKSFILTER pKsFilter = KsGetFilterFromIrp(pIrp);
    ULONG ulPinId = pKsPinProperty->PinId;
    PKSPIN_DESCRIPTOR_EX pKsPinDescriptorEx;
    PUSBAUDIO_DATARANGE pUsbAudioRange;
    NTSTATUS ntStatus = STATUS_NO_MATCH;

    if (!pKsFilter) {
        return ntStatus;
    }

    pKsPinDescriptorEx = (PKSPIN_DESCRIPTOR_EX)&pKsFilter->Descriptor->PinDescriptors[ulPinId];

    pUsbAudioRange =
        FindDataIntersection((PKSDATARANGE_AUDIO)DataRange,
                             (PUSBAUDIO_DATARANGE *)pKsPinDescriptorEx->PinDescriptor.DataRanges,
                             pKsPinDescriptorEx->PinDescriptor.DataRangesCount);

    if ( pUsbAudioRange ) {

        *pDataSize = GetIntersectFormatSize( pUsbAudioRange );

        if ( !DataBufferSize ) {
            ntStatus = STATUS_BUFFER_OVERFLOW;
        }
        else if ( *pDataSize > DataBufferSize ) {
            ntStatus = STATUS_INVALID_DEVICE_REQUEST;
        }
        else if ( *pDataSize <= DataBufferSize ) {
            ConvertDatarangeToFormat( pUsbAudioRange,
                                      (PKSDATAFORMAT)pData );
            ntStatus = STATUS_SUCCESS;
        }
    }

    return ntStatus;
}

VOID
USBAudioPinWaitForStarvation( PKSPIN pKsPin )
{
    PPIN_CONTEXT pPinContext = pKsPin->Context;
    KIRQL irql;

    // Wait for all outstanding Urbs to complete.
    KeAcquireSpinLock( &pPinContext->PinSpinLock, &irql );
    if ( pPinContext->ulOutstandingUrbCount ) {
        KeResetEvent( &pPinContext->PinStarvationEvent );
        KeReleaseSpinLock( &pPinContext->PinSpinLock, irql );

        KeWaitForSingleObject( &pPinContext->PinStarvationEvent,
                               Executive,
                               KernelMode,
                               FALSE,
                               NULL );
    }
    else
        KeReleaseSpinLock( &pPinContext->PinSpinLock, irql );
}

VOID
USBMIDIOutPinWaitForStarvation( PKSPIN pKsPin )
{
    PPIN_CONTEXT pPinContext = pKsPin->Context;
    NTSTATUS ntStatus;
    LARGE_INTEGER timeout;
    KIRQL irql;

    // Wait for all outstanding Urbs to complete.
    KeAcquireSpinLock( &pPinContext->PinSpinLock, &irql );
    if ( pPinContext->ulOutstandingUrbCount ) {
        KeResetEvent( &pPinContext->PinStarvationEvent );
        KeReleaseSpinLock( &pPinContext->PinSpinLock, irql );

        // Specify a timeout of 1 second to wait for this call to complete.
        timeout.QuadPart = -10000 * 1000;

        ntStatus = KeWaitForSingleObject( &pPinContext->PinStarvationEvent,
                                          Executive,
                                          KernelMode,
                                          FALSE,
                                          &timeout );
        if (ntStatus == STATUS_TIMEOUT) {
             ntStatus = STATUS_IO_TIMEOUT;

            // Perform an abort
            //
            AbortUSBPipe( pPinContext );

            // And wait until the cancel completes
            //
            KeWaitForSingleObject(&pPinContext->PinStarvationEvent,
                                  Executive,
                                  KernelMode,
                                  FALSE,
                                  NULL);
        }
    }
    else
        KeReleaseSpinLock( &pPinContext->PinSpinLock, irql );
}

VOID
USBAudioPinReturnFromStandby(
    PKSPIN pKsPin )
{
    PPIN_CONTEXT pPinContext = pKsPin->Context;
    ULONG ulFormatType = pPinContext->pUsbAudioDataRange->ulUsbDataFormat & USBAUDIO_DATA_FORMAT_TYPE_MASK;
    NTSTATUS ntStatus;

    // Reselect the interface that was selected before the standby.
    ntStatus =
        SelectStreamingAudioInterface( pPinContext->pUsbAudioDataRange->pInterfaceDescriptor,
                                       pPinContext->pHwDevExt,
                                       pKsPin );

    // For those devices that require it reset the sample rate on the interface
    // if this is a Type I stream.
    if (ulFormatType == USBAUDIO_DATA_FORMAT_TYPE_I_UNDEFINED) {
        ULONG ulSampleRate = ((PKSDATAFORMAT_WAVEFORMATEX)pKsPin->ConnectionFormat)->WaveFormatEx.nSamplesPerSec;
        ntStatus = SetSampleRate( pKsPin, &ulSampleRate );
    }

    if ( pKsPin->DataFlow == KSPIN_DATAFLOW_OUT ) {
        PCAPTURE_PIN_CONTEXT pCapturePinContext = pPinContext->pCapturePinContext;
        pPinContext->fUrbError = FALSE;
        pCapturePinContext->fRunning = FALSE;
        pCapturePinContext->fProcessing = FALSE;
        pCapturePinContext->pCaptureBufferInUse = NULL;
        pCapturePinContext->ulIsochBuffer = 0;
        pCapturePinContext->ulIsochBufferOffset = 0;

        InitializeListHead( &pCapturePinContext->UrbErrorQueue );
        InitializeListHead( &pCapturePinContext->FullBufferQueue  );

        if (KSSTATE_RUN == pKsPin->DeviceState) {
            ntStatus = CaptureStartIsocTransfer( pPinContext );
        }
    }

    // Turn on Gate to begin sending data buffers to pin.
    KsGateTurnInputOn( KsPinGetAndGate(pKsPin) );
    KsPinAttemptProcessing( pKsPin, TRUE );

}

VOID
USBAudioPinGoToStandby(
    PKSPIN pKsPin )
{
    PPIN_CONTEXT pPinContext = pKsPin->Context;
    KIRQL irql;
    NTSTATUS ntStatus;

    _DbgPrintF(DEBUGLVL_TERSE,("[USBAudioPinGoToStandby] pKsPin: %x \n",pKsPin));

    // Turn off Gate to stop data buffers to pin.
    DbgLog("SBKsGt1", pKsPin, KsPinGetAndGate(pKsPin), 
                      KsPinGetAndGate(pKsPin)->Count, 0 );

    KsGateTurnInputOff( KsPinGetAndGate(pKsPin) );

    DbgLog("SBKsGt2", pKsPin, KsPinGetAndGate(pKsPin), 
                      KsPinGetAndGate(pKsPin)->Count, 0 );

    // Wait on mutex to ensure that any other processing on the pin is completed.
    KsPinAcquireProcessingMutex( pKsPin );

    // Release the mutex. The gate should hold off any further processing.
    KsPinReleaseProcessingMutex( pKsPin );

    if ( pKsPin->DataFlow == KSPIN_DATAFLOW_OUT ) {
        PCAPTURE_PIN_CONTEXT pCapturePinContext = pPinContext->pCapturePinContext;
        pCapturePinContext->fRunning = FALSE;
    }

    // Abort the Pipe to force release of pending irps
    ntStatus = AbortUSBPipe( pPinContext );
    if ( !NT_SUCCESS(ntStatus) ) {
        TRAP;
    }

    DbgLog("SBAbrtd", pKsPin, pPinContext, 0, 0 );

    // If this is an Async endpoint device make sure no Async Poll
    // requests are still outstanding.
    if ( pKsPin->DataFlow == KSPIN_DATAFLOW_IN ) {
        if ( (pPinContext->pUsbAudioDataRange->ulUsbDataFormat & USBAUDIO_DATA_FORMAT_TYPE_MASK)
                == USBAUDIO_DATA_FORMAT_TYPE_I_UNDEFINED ) {
            if ( pPinContext->pUsbAudioDataRange->pSyncEndpointDescriptor ) {
                PTYPE1_PIN_CONTEXT pT1PinContext = pPinContext->pType1PinContext;
                KeAcquireSpinLock(&pPinContext->PinSpinLock, &irql);
                if ( pT1PinContext->SyncEndpointInfo.fSyncRequestInProgress ) {
                    KeResetEvent( &pT1PinContext->SyncEndpointInfo.SyncPollDoneEvent );
                    KeReleaseSpinLock(&pPinContext->PinSpinLock, irql);
                    KeWaitForSingleObject( &pT1PinContext->SyncEndpointInfo.SyncPollDoneEvent,
                                           Executive,
                                           KernelMode,
                                           FALSE,
                                           NULL );
                }
                else
                    KeReleaseSpinLock(&pPinContext->PinSpinLock, irql);
            }
        }
    }

    // Select the Zero Bandwidth interface.
    ntStatus = SelectZeroBandwidthInterface(pPinContext->pHwDevExt, pKsPin->Id);

    DbgLog("SBZbwIf", pKsPin, pPinContext, 0, 0 );

}

NTSTATUS
USBMIDIPinValidateDataFormat(
    PKSPIN pKsPin,
    PUSBAUDIO_DATARANGE pUSBAudioRange )
{
    _DbgPrintF(DEBUGLVL_TERSE,("[USBMIDIPinValidateDataFormat] pin %d\n",pKsPin->Id));

    return STATUS_NOT_SUPPORTED;
}

NTSTATUS
USBMIDIPinCreate(
    IN OUT PKSPIN pKsPin,
    IN PIRP pIrp
    )
{
    PKSFILTER pKsFilter = NULL;
    PFILTER_CONTEXT pFilterContext = NULL;
    PHW_DEVICE_EXTENSION pHwDevExt = NULL;
    PPIN_CONTEXT pPinContext = NULL;
    PKSALLOCATOR_FRAMING_EX pKsAllocatorFramingEx;
    PUSB_ENDPOINT_DESCRIPTOR pEndpointDescriptor;
    ULONG ulInterfaceNumber;
    NTSTATUS ntStatus = STATUS_SUCCESS;

    PAGED_CODE();

    ASSERT(pKsPin);
    ASSERT(pIrp);

    if (pKsPin) {
        if (pKsFilter = KsPinGetParentFilter( pKsPin )) {
            if (pFilterContext = pKsFilter->Context) {
                pHwDevExt = pFilterContext->pHwDevExt;
            }
        }
    }

    if (!pHwDevExt) {
        _DbgPrintF(DEBUGLVL_TERSE,("[USBMIDIPinCreate] failed to get context\n"));
        return STATUS_INVALID_PARAMETER;
    }

    _DbgPrintF(DEBUGLVL_VERBOSE,("[USBMIDIPinCreate] pin %d pKsFilter=%x\n",pKsPin->Id, pKsFilter));

    //  In the case of multiple filters created on a device the pin possible count is maintained on the
    //  device level in order to ensure that too many pins aren't opened on the device
    if ( pHwDevExt->pPinInstances[pKsPin->Id].CurrentCount <
         pHwDevExt->pPinInstances[pKsPin->Id].PossibleCount ) {

        pHwDevExt->pPinInstances[pKsPin->Id].CurrentCount++;
    }
    else {
        _DbgPrintF(DEBUGLVL_TERSE,("[PinCreate] failed with CurrentCount=%d and PossibleCount=%d\n",
                                   pHwDevExt->pPinInstances[pKsPin->Id].CurrentCount,
                                   pHwDevExt->pPinInstances[pKsPin->Id].PossibleCount));
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    // Allocate the Context for the Pin and initialize it
    pPinContext = pKsPin->Context = AllocMem(NonPagedPool, sizeof(PIN_CONTEXT));
    if (!pPinContext) {
        pHwDevExt->pPinInstances[pKsPin->Id].CurrentCount--;
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    // Bag the context for easy cleanup.
    KsAddItemToObjectBag(pKsPin->Bag, pPinContext, FreeMem);

    // Save the Hardware extension in the Pin Context
    pPinContext->pHwDevExt             = pHwDevExt;
    pPinContext->pNextDeviceObject = pFilterContext->pNextDeviceObject;

    // Initialize hSystemStateHandle
    pPinContext->hSystemStateHandle = NULL;

    pPinContext->pMIDIPinContext = AllocMem( NonPagedPool, sizeof(MIDI_PIN_CONTEXT));
    if ( !pPinContext->pMIDIPinContext ) {
        pHwDevExt->pPinInstances[pKsPin->Id].CurrentCount--;
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    // Bag the context for easy cleanup.
    KsAddItemToObjectBag(pKsPin->Bag, pPinContext->pMIDIPinContext, FreeMem);

    // Get the interface number and endpoint number for this MIDI pin
    GetContextForMIDIPin( pKsPin,
                          pHwDevExt->pConfigurationDescriptor,
                          pPinContext->pMIDIPinContext );

    // Get the Max Packet Size for the interface
    ulInterfaceNumber = pPinContext->pMIDIPinContext->ulInterfaceNumber;
    pEndpointDescriptor =
        GetEndpointDescriptor( pHwDevExt->pConfigurationDescriptor,
                               pHwDevExt->pInterfaceList[ulInterfaceNumber].InterfaceDescriptor,
                               FALSE);
    pPinContext->ulMaxPacketSize = (ULONG)pEndpointDescriptor->wMaxPacketSize;

    // Have the hardware select the interface
    ntStatus = SelectStreamingMIDIInterface( pHwDevExt, pKsPin );
    if ( !NT_SUCCESS(ntStatus) ) {
        pHwDevExt->pPinInstances[pKsPin->Id].CurrentCount--;
        return ntStatus;
    }

    // Initialize Pin SpinLock
    KeInitializeSpinLock(&pPinContext->PinSpinLock);

    // Set initial Outstanding Urb Count
    pPinContext->ulOutstandingUrbCount = 0;

    // Zero out Write counter
    pPinContext->ullWriteOffset = 0;

    // Clear the Urb Error Flag
    pPinContext->fUrbError = FALSE;

    // Initialize Pin Starvation Event
    KeInitializeEvent( &pPinContext->PinStarvationEvent, NotificationEvent, FALSE );

    // Setup approriate allocator framing for the interface selected.
    ntStatus = KsEdit( pKsPin, &pKsPin->Descriptor, USBAUDIO_POOLTAG );
    if ( NT_SUCCESS(ntStatus) ) {

        ntStatus = KsEdit( pKsPin, &pKsPin->Descriptor->AllocatorFraming, USBAUDIO_POOLTAG );
        if ( NT_SUCCESS(ntStatus) ) {

            // Set up allocator
            pKsAllocatorFramingEx = (PKSALLOCATOR_FRAMING_EX)pKsPin->Descriptor->AllocatorFraming;
            pKsAllocatorFramingEx->FramingItem[0].FramingRange.Range.MinFrameSize = USBMIDI_MIN_FRAMECOUNT * sizeof(KSMUSICFORMAT);
            pKsAllocatorFramingEx->FramingItem[0].FramingRange.Range.MaxFrameSize = USBMIDI_MAX_FRAMECOUNT * sizeof(KSMUSICFORMAT);
            pKsAllocatorFramingEx->FramingItem[0].FramingRange.Range.Stepping = sizeof(KSMUSICFORMAT);
        }
    }

    //  KsEdit failed above
    if ( !NT_SUCCESS(ntStatus) ) {
        pHwDevExt->pPinInstances[pKsPin->Id].CurrentCount--;
        return ntStatus;
    }

    // Now initialize data flow specific features
    if ( pKsPin->DataFlow == KSPIN_DATAFLOW_OUT ) {
        ntStatus = USBMIDIInStreamInit( pKsPin );
        pPinContext->PinType = MidiIn;
    }
    else {
        ntStatus = USBMIDIOutStreamInit( pKsPin );
        pPinContext->PinType = MidiOut;
    }

    //  Failed to initialize MIDI pin
    if ( !NT_SUCCESS(ntStatus) ) {
        pHwDevExt->pPinInstances[pKsPin->Id].CurrentCount--;
    }

    return ntStatus;
}

NTSTATUS
USBMIDIPinClose(
    IN PKSPIN pKsPin,
    IN PIRP Irp
    )
{
    PKSFILTER pKsFilter = NULL;
    PFILTER_CONTEXT pFilterContext = NULL;
    PHW_DEVICE_EXTENSION pHwDevExt = NULL;
    PPIN_CONTEXT pPinContext = NULL;
    NTSTATUS ntStatus = STATUS_SUCCESS;

    PAGED_CODE();

    ASSERT(pKsPin);
    ASSERT(Irp);

    if (pKsPin) {
        pPinContext = pKsPin->Context;

        if (pKsFilter = KsPinGetParentFilter( pKsPin )) {
            if (pFilterContext = pKsFilter->Context) {
                pHwDevExt = pFilterContext->pHwDevExt;
            }
        }
    }

    if (!pHwDevExt || !pPinContext) {
        _DbgPrintF(DEBUGLVL_TERSE,("[USBMIDIPinCreate] failed to get context\n"));
        return STATUS_INVALID_PARAMETER;
    }

    _DbgPrintF(DEBUGLVL_TERSE,("[USBMIDIPinClose] pin %d\n",pKsPin->Id));

    // Now do format specific close
    if ( pKsPin->DataFlow == KSPIN_DATAFLOW_OUT ) {
        ntStatus = USBMIDIInStreamClose( pKsPin );
    }
    else {
        ntStatus = USBMIDIOutStreamClose( pKsPin );
    }

    pHwDevExt->pPinInstances[pKsPin->Id].CurrentCount--;
    return ntStatus;
}

NTSTATUS
USBMIDIPinSetDeviceState(
    IN PKSPIN pKsPin,
    IN KSSTATE ToState,
    IN KSSTATE FromState
    )
{
    PPIN_CONTEXT pPinContext = pKsPin->Context;
    NTSTATUS ntStatus = STATUS_SUCCESS;

    PAGED_CODE();

    ASSERT(pKsPin);

    _DbgPrintF(DEBUGLVL_TERSE,("[USBMIDIPinSetDeviceState] pin %d\n",pKsPin->Id));

    if ( pKsPin->DataFlow == KSPIN_DATAFLOW_OUT ) {
        ntStatus = USBMIDIInStateChange( pKsPin, FromState, ToState );
    }
    else {
        ntStatus = USBMIDIOutStateChange( pKsPin, FromState, ToState );
    }

    if ( ToState == KSSTATE_RUN ) {
        if (!pPinContext->hSystemStateHandle) {
            // register the system state as busy
            pPinContext->hSystemStateHandle = PoRegisterSystemState( pPinContext->hSystemStateHandle,
                                                                     ES_SYSTEM_REQUIRED | ES_CONTINUOUS );
            _DbgPrintF(DEBUGLVL_TERSE,("[PinSetDeviceState] PoRegisterSystemState %x\n",pPinContext->hSystemStateHandle));
        }
    }
    else {
        if (pPinContext->hSystemStateHandle) {
            _DbgPrintF(DEBUGLVL_TERSE,("[PinSetDeviceState] PoUnregisterSystemState %x\n",pPinContext->hSystemStateHandle));
            PoUnregisterSystemState( pPinContext->hSystemStateHandle );
            pPinContext->hSystemStateHandle = NULL;
        }
    }

    return ntStatus;
}


NTSTATUS
USBMIDIPinSetDataFormat(
    IN PKSPIN pKsPin,
    IN PKSDATAFORMAT OldFormat OPTIONAL,
    IN PKSMULTIPLE_ITEM OldAttributeList OPTIONAL,
    IN const KSDATARANGE* DataRange,
    IN const KSATTRIBUTE_LIST* AttributeRange OPTIONAL
    )
{
    _DbgPrintF(DEBUGLVL_TERSE,("[USBMIDIPinSetDataFormat] pin %d\n",pKsPin->Id));
    return STATUS_SUCCESS;
}

NTSTATUS
USBMIDIPinProcess(
    IN PKSPIN pKsPin )
{
    NTSTATUS ntStatus = STATUS_NOT_SUPPORTED;

    if (pKsPin->DataFlow == KSPIN_DATAFLOW_IN) {
        _DbgPrintF(DEBUGLVL_VERBOSE,("[USBMIDIPinProcess] Render pin %d\n",pKsPin->Id));
        ntStatus = USBMIDIOutProcessStreamPtr( pKsPin );
    }
    else
    {
        _DbgPrintF(DEBUGLVL_VERBOSE,("[USBMIDIPinProcess] Capture pin %d\n",pKsPin->Id));
        ntStatus = USBMIDIInProcessStreamPtr( pKsPin );
    }

    return ntStatus;
}

void
USBMIDIPinReset( PKSPIN pKsPin )
{
    _DbgPrintF(DEBUGLVL_TERSE,("[USBMIDIPinReset] pin %d\n",pKsPin->Id));
}

LONGLONG FASTCALL
USBAudioCorrelatedTime(
    IN PKSPIN pKsPin,
    OUT PLONGLONG PhysicalTime )
{
    PPIN_CONTEXT pPinContext;
    PCAPTURE_PIN_CONTEXT pCapturePinContext;
    PTYPE1_PIN_CONTEXT pT1PinContext;
    ULONG ulAvgBytesPerSec;
    KSAUDIO_POSITION KsPosition;

    if (pKsPin) {

        pPinContext = pKsPin->Context;
        if (pPinContext) {

            if ( pKsPin->DataFlow == KSPIN_DATAFLOW_OUT ) {

                pCapturePinContext = pPinContext->pCapturePinContext;
                if (pCapturePinContext) {

                    if (pCapturePinContext->ulCurrentSampleRate) {

                        // Get the current audio byte offset
                        CaptureBytePosition(pKsPin, &KsPosition);

                        // Convert offset to a time offset based on a nanosecond clock
                        *PhysicalTime = ( (KsPosition.PlayOffset /
                                           pCapturePinContext->ulBytesPerSample) * 1000000) /
                                           pCapturePinContext->ulCurrentSampleRate;

                        DbgLog("CapPos", pKsPin, pPinContext,
                               (ULONG)( (*PhysicalTime) >> 32), (ULONG)(*PhysicalTime));
                        return *PhysicalTime;
                    }
                }
            }
            else {
                switch( pPinContext->pUsbAudioDataRange->ulUsbDataFormat & USBAUDIO_DATA_FORMAT_TYPE_MASK ) {
                    case USBAUDIO_DATA_FORMAT_TYPE_I_UNDEFINED:
                        pT1PinContext = pPinContext->pType1PinContext;
                        if (pT1PinContext) {

                            if (pT1PinContext->ulCurrentSampleRate) {

                                TypeIRenderBytePosition(pPinContext, &KsPosition);

                                // Convert offset to a time offset based on a nanosecond clock
                                *PhysicalTime = ( (KsPosition.WriteOffset /
                                                   pT1PinContext->ulBytesPerSample) * 1000000) /
                                                   pT1PinContext->ulCurrentSampleRate;
                                DbgLog("RendPos", pKsPin, pPinContext, (ULONG)(*PhysicalTime)>>32, (ULONG)(*PhysicalTime));
                                return *PhysicalTime;
                            }
                        }

                        break;
                    case USBAUDIO_DATA_FORMAT_TYPE_II_UNDEFINED:
                    case USBAUDIO_DATA_FORMAT_TYPE_III_UNDEFINED:
                    default:
                        return *PhysicalTime; // not supported
                        break;
                }
            }
        }
    }

    _DbgPrintF(DEBUGLVL_TERSE,("[USBAudioCorrelatedTime] Invalid pin!\n"));
    return *PhysicalTime;
}

NTSTATUS
USBMIDIPinDataIntersect(
    IN PVOID Context,
    IN PIRP pIrp,
    IN PKSP_PIN pKsPinProperty,
    IN PKSDATARANGE DataRange,
    IN PKSDATARANGE MatchingDataRange,
    IN ULONG DataBufferSize,
    OUT PVOID pData OPTIONAL,
    OUT PULONG pDataSize )
{
    _DbgPrintF(DEBUGLVL_TERSE,("[USBMIDIPinDataIntersect]\n"));
    return STATUS_NOT_IMPLEMENTED;
}

static
const
KSCLOCK_DISPATCH USBAudioClockDispatch =
{
    NULL, // SetTimer
    NULL, // CancelTimer
    USBAudioCorrelatedTime, // CorrelatedTime
    NULL // Resolution
};

const
KSPIN_DISPATCH
USBAudioPinDispatch =
{
    USBAudioPinCreate,
    USBAudioPinClose,
    USBAudioPinProcess,
    USBAudioPinReset,// Reset
    USBAudioPinSetDataFormat,
    USBAudioPinSetDeviceState,
    NULL, // Connect
    NULL, // Disconnect
    NULL, // &USBAudioClockDispatch, // Clock
    NULL  // Allocator
};

const
KSPIN_DISPATCH
USBMIDIPinDispatch =
{
    USBMIDIPinCreate,
    USBMIDIPinClose,
    USBMIDIPinProcess,
    USBMIDIPinReset,// Reset
    USBMIDIPinSetDataFormat,
    USBMIDIPinSetDeviceState,
    NULL,// Connect
    NULL // Disconnect
};

const
KSDATAFORMAT AudioBridgePinDataFormat[] =
{
    sizeof(KSDATAFORMAT),
    0,
    0,
    0,
    {STATIC_KSDATAFORMAT_TYPE_AUDIO},
    {STATIC_KSDATAFORMAT_SUBTYPE_ANALOG},
    {STATIC_KSDATAFORMAT_SPECIFIER_NONE}
};

const
KSDATAFORMAT MIDIBridgePinDataFormat[] =
{
    sizeof(KSDATAFORMAT),
    0,
    0,
    0,
    {STATIC_KSDATAFORMAT_TYPE_MUSIC},
    {STATIC_KSDATAFORMAT_SUBTYPE_MIDI_BUS},
    {STATIC_KSDATAFORMAT_SPECIFIER_NONE}
};

const
KSDATARANGE_MUSIC MIDIStreamingPinDataFormat[] =
{
    {
        {
            sizeof(KSDATARANGE_MUSIC),
            0,
            0,
            0,
            {STATIC_KSDATAFORMAT_TYPE_MUSIC},
            {STATIC_KSDATAFORMAT_SUBTYPE_MIDI},
            {STATIC_KSDATAFORMAT_SPECIFIER_NONE}
        },
        {STATIC_KSMUSIC_TECHNOLOGY_PORT},
        0,
        0,
        0xFFFF
    }
};

DEFINE_KSPIN_INTERFACE_TABLE(PinInterface) {
   {
    STATICGUIDOF(KSINTERFACESETID_Standard),
    KSINTERFACE_STANDARD_STREAMING,
    0
   }
};

DEFINE_KSPIN_MEDIUM_TABLE(PinMedium) {
    {
     STATICGUIDOF(KSMEDIUMSETID_Standard),
     KSMEDIUM_TYPE_ANYINSTANCE,
     0
    }
};

const
PKSDATAFORMAT pAudioBridgePinFormats = (PKSDATAFORMAT)AudioBridgePinDataFormat;

const
PKSDATAFORMAT pMIDIBridgePinFormats = (PKSDATAFORMAT)MIDIBridgePinDataFormat;

const
PKSDATAFORMAT pMIDIStreamingPinFormats = (PKSDATAFORMAT)MIDIStreamingPinDataFormat;

DECLARE_SIMPLE_FRAMING_EX(
    AllocatorFraming,
    STATIC_KSMEMORY_TYPE_KERNEL_NONPAGED,
    KSALLOCATOR_REQUIREMENTF_SYSTEM_MEMORY |
    KSALLOCATOR_REQUIREMENTF_PREFERENCES_ONLY,
    8,
    sizeof(ULONG) - 1,
    0,
    0
);

NTSTATUS
USBAudioPinBuildDescriptors(
    PKSDEVICE pKsDevice,
    PKSPIN_DESCRIPTOR_EX *ppPinDescEx,
    PULONG pNumPins,
    PULONG pPinDecSize )
{
    PHW_DEVICE_EXTENSION pHwDevExt = pKsDevice->Context;
    PKSPIN_DESCRIPTOR_EX pPinDescEx;
    PKSAUTOMATION_TABLE pKsAutomationTable;
    PKSALLOCATOR_FRAMING_EX pKsAllocatorFramingEx;
    PPIN_CINSTANCES pPinInstances;
    ULONG ulNumPins, i, j;
    ULONG ulNumStreamPins;
    ULONG ulNumAudioBridgePins = 0;
    ULONG ulNumMIDIPins = 0;
    ULONG ulNumMIDIBridgePins = 0;
    PKSPROPERTY_ITEM pStrmPropItems;
    PKSPROPERTY_SET pStrmPropSet;
    ULONG ulNumPropertyItems;
    ULONG ulNumPropertySets;
    GUID *pTTypeGUID;
    GUID *pMIDIBridgeGUID;
    ULONG ulAudioFormatCount = 0;
    PKSDATARANGE_AUDIO *ppAudioDataRanges;
    PUSBAUDIO_DATARANGE pAudioDataRange;
    PKSDATARANGE_MUSIC *ppMIDIStreamingDataRanges;
    NTSTATUS ntStatus;

    // Determine the number of Pins in the Filter ( Should = # of Terminal Units )
    ulNumPins = CountTerminalUnits( pHwDevExt->pConfigurationDescriptor,
                                    &ulNumAudioBridgePins,
                                    &ulNumMIDIPins,
                                    &ulNumMIDIBridgePins);
    ASSERT(ulNumPins >= ulNumAudioBridgePins + ulNumMIDIPins);
    ulNumStreamPins = ulNumPins - ulNumAudioBridgePins - ulNumMIDIPins;

    // Determine the number of Properties and Property Sets for the Pin.
    BuildPinPropertySet( pHwDevExt,
                         NULL,
                         NULL,
                         &ulNumPropertyItems,
                         &ulNumPropertySets );

    // Count the total number of data ranges in the device.
    for ( i=0; i<ulNumStreamPins; i++ ) {
        ulAudioFormatCount +=
            CountFormatsForAudioStreamingInterface( pHwDevExt->pConfigurationDescriptor, i );
    }

    // Allocate all the space we need to describe the Pins in the device.
    *pPinDecSize = sizeof(KSPIN_DESCRIPTOR_EX);
    *pNumPins = ulNumPins;
    pPinDescEx = *ppPinDescEx =
                 AllocMem(NonPagedPool, (ulNumPins *
                                         ( sizeof(KSPIN_DESCRIPTOR_EX) +
                                           sizeof(KSAUTOMATION_TABLE)  +
                                           sizeof(KSALLOCATOR_FRAMING_EX) +
                                           sizeof(PIN_CINSTANCES) )) +
                                        (ulAudioFormatCount *
                                         (  sizeof(PKSDATARANGE_AUDIO)  +
                                            sizeof(USBAUDIO_DATARANGE) )) +
                                        (ulNumPropertySets*sizeof(KSPROPERTY_SET)) +
                                        (ulNumPropertyItems*sizeof(KSPROPERTY_ITEM)) +
                                        (ulNumMIDIPins*sizeof(KSDATARANGE_MUSIC)) +
                                        (ulNumAudioBridgePins*sizeof(GUID)) +
                                        (ulNumMIDIBridgePins*sizeof(GUID)) );
    if ( !pPinDescEx )
        return STATUS_INSUFFICIENT_RESOURCES;

    KsAddItemToObjectBag(pKsDevice->Bag, pPinDescEx, FreeMem);

    // Zero out all descriptors to start
    RtlZeroMemory(pPinDescEx, ulNumPins*sizeof(KSPIN_DESCRIPTOR_EX));

    // Set the pointer for the Automation Tables
    pKsAutomationTable = (PKSAUTOMATION_TABLE)(pPinDescEx + ulNumPins);
    RtlZeroMemory(pKsAutomationTable, ulNumPins * sizeof(KSAUTOMATION_TABLE));

    // Set pointers to Pin instance count
    pHwDevExt->pPinInstances = pPinInstances = (PPIN_CINSTANCES)(pKsAutomationTable + ulNumPins);

    // Set pointers to Property Sets for Streaming Pins
    pStrmPropSet   = (PKSPROPERTY_SET)(pPinInstances + ulNumPins);
    pStrmPropItems = (PKSPROPERTY_ITEM)(pStrmPropSet + ulNumPropertySets);

    // Set pointer to Terminal Type GUIDS
    pTTypeGUID = (GUID *)(pStrmPropItems + ulNumPropertyItems);

    // Set Pointers for DataRange pointers and DataRanges for streaming Pins
    ppAudioDataRanges = (PKSDATARANGE_AUDIO *)(pTTypeGUID + ulNumAudioBridgePins);
    pAudioDataRange   = (PUSBAUDIO_DATARANGE)(ppAudioDataRanges + ulAudioFormatCount);

    // Set pointer to Allocator Framing structures for Streaming Pins
    pKsAllocatorFramingEx = (PKSALLOCATOR_FRAMING_EX)(pAudioDataRange + ulAudioFormatCount);

    // Set pointer to DataRanges for MIDI Pins
    ppMIDIStreamingDataRanges = (PKSDATARANGE_MUSIC *)(pKsAllocatorFramingEx + ulNumPins);

    // Set pointer to MIDI Bridge GUIDS
    pMIDIBridgeGUID = (GUID *)(ppMIDIStreamingDataRanges + ulNumMIDIPins);

    BuildPinPropertySet( pHwDevExt,
                         pStrmPropItems,
                         pStrmPropSet,
                         &ulNumPropertyItems,
                         &ulNumPropertySets );

    // Fill in descriptors for streaming pins first
    for ( i=0; i<(ulNumPins-ulNumAudioBridgePins-ulNumMIDIPins); i++ ) {
        ULONG ulFormatsForPin;
        pPinDescEx[i].Dispatch = &USBAudioPinDispatch;
        pPinDescEx[i].AutomationTable = &pKsAutomationTable[i];


        pKsAutomationTable[i].PropertySetsCount = ulNumPropertySets;
        pKsAutomationTable[i].PropertyItemSize  = sizeof(KSPROPERTY_ITEM);
        pKsAutomationTable[i].PropertySets      = pStrmPropSet;

        pPinDescEx[i].PinDescriptor.InterfacesCount = 1;
        pPinDescEx[i].PinDescriptor.Interfaces      = PinInterface;
        pPinDescEx[i].PinDescriptor.MediumsCount    = 1;
        pPinDescEx[i].PinDescriptor.Mediums         = PinMedium;

        ulFormatsForPin =
            CountFormatsForAudioStreamingInterface( pHwDevExt->pConfigurationDescriptor, i );

        pPinDescEx[i].PinDescriptor.DataRangesCount = ulFormatsForPin;

        pPinDescEx[i].PinDescriptor.DataRanges = (const PKSDATARANGE *)ppAudioDataRanges;
        GetPinDataRangesFromInterface( i, pHwDevExt->pConfigurationDescriptor,
                                       ppAudioDataRanges, pAudioDataRange );

        ppAudioDataRanges += ulFormatsForPin;
        pAudioDataRange   += ulFormatsForPin;

        pPinDescEx[i].PinDescriptor.DataFlow =
                GetDataFlowDirectionForInterface( pHwDevExt->pConfigurationDescriptor, i);

        if ( pPinDescEx[i].PinDescriptor.DataFlow == KSPIN_DATAFLOW_IN ) {
            pPinDescEx[i].PinDescriptor.Communication = KSPIN_COMMUNICATION_SINK;
            pPinDescEx[i].PinDescriptor.Category = (GUID*) &KSCATEGORY_AUDIO;
            pPinDescEx[i].Flags = KSPIN_FLAG_RENDERER;
        }
        else {
            pPinDescEx[i].PinDescriptor.Communication = KSPIN_COMMUNICATION_BOTH;
            pPinDescEx[i].PinDescriptor.Category = (GUID*) &PINNAME_CAPTURE;
            pPinDescEx[i].Flags = KSPIN_FLAG_CRITICAL_PROCESSING | KSPIN_FLAG_PROCESS_IN_RUN_STATE_ONLY;
        }

        // Set max instances to 1 for all pins.
        pPinDescEx[i].InstancesPossible  = 1;
        pPinDescEx[i].InstancesNecessary = 0;

        // Keep track of pin instance count at the filter level (stored in device context)
        pPinInstances[i].PossibleCount = 1;
        pPinInstances[i].CurrentCount  = 0;

        pPinDescEx[i].IntersectHandler = USBAudioPinDataIntersect;

        // Set up Allocator Framing
        pPinDescEx[i].AllocatorFraming = &AllocatorFraming;

        // Finally set the 0 BW interface for the Pin
        ntStatus = SelectZeroBandwidthInterface( pHwDevExt, i );
        if ( !NT_SUCCESS(ntStatus) ) return STATUS_DEVICE_CONFIGURATION_ERROR;
    }

    // Now fill in descriptors for audio bridge pins
    for ( j=0; j<ulNumAudioBridgePins; j++, i++ ) {
        pPinDescEx[i].Dispatch = NULL;
        pPinDescEx[i].AutomationTable = NULL;

        pPinDescEx[i].PinDescriptor.InterfacesCount = 1;
        pPinDescEx[i].PinDescriptor.Interfaces = PinInterface;
        pPinDescEx[i].PinDescriptor.MediumsCount = 1;
        pPinDescEx[i].PinDescriptor.Mediums = PinMedium;
        pPinDescEx[i].PinDescriptor.DataRangesCount = 1;
        pPinDescEx[i].PinDescriptor.DataRanges = &pAudioBridgePinFormats;
        pPinDescEx[i].PinDescriptor.Communication = KSPIN_COMMUNICATION_BRIDGE;
        pPinDescEx[i].PinDescriptor.DataFlow =
                      GetDataFlowForBridgePin( pHwDevExt->pConfigurationDescriptor, j);

        pPinDescEx[i].PinDescriptor.Category = &pTTypeGUID[j];
        GetCategoryForBridgePin( pHwDevExt->pConfigurationDescriptor, j, &pTTypeGUID[j] );
        if (IsBridgePinDigital(pHwDevExt->pConfigurationDescriptor, j)) {
            _DbgPrintF(DEBUGLVL_VERBOSE,("[USBAudioPinBuildDescriptors] Found digital bridge pin (%d)\n",j));
            pHwDevExt->fDigitalOutput = TRUE;
        }

        pPinDescEx[i].InstancesPossible  = 0;
        pPinDescEx[i].InstancesNecessary = 0;

        // Keep track of pin instance count at the filter level (stored in device context)
        pPinInstances[i].PossibleCount = 0;
        pPinInstances[i].CurrentCount  = 0;
    }

    // Now fill in descriptors for MIDI Streaming pins
    for ( j=0; j<ulNumMIDIPins-ulNumMIDIBridgePins; j++, i++ ) {
        pPinDescEx[i].Dispatch = &USBMIDIPinDispatch;
        pPinDescEx[i].AutomationTable = NULL;

        pPinDescEx[i].PinDescriptor.InterfacesCount = 1;
        pPinDescEx[i].PinDescriptor.Interfaces      = PinInterface;
        pPinDescEx[i].PinDescriptor.MediumsCount    = 1;
        pPinDescEx[i].PinDescriptor.Mediums         = PinMedium;

        pPinDescEx[i].PinDescriptor.DataRangesCount = 1;
        pPinDescEx[i].PinDescriptor.DataRanges = &pMIDIStreamingPinFormats;

#if 0
        pPinDescEx[i].PinDescriptor.DataRanges = &ppMIDIStreamingDataRanges;

        // Create the KSDATARANGE_MUSIC structure
        ppMIDIStreamingDataRanges->DataRange.FormatSize = sizeof(KSDATARANGE_MUSIC);
        ppMIDIStreamingDataRanges->DataRange.Reserved   = 0;
        ppMIDIStreamingDataRanges->DataRange.Flags      = 0;
        ppMIDIStreamingDataRanges->DataRange.SampleSize = 0;
        ppMIDIStreamingDataRanges->DataRange.MajorFormat = KSDATAFORMAT_TYPE_MUSIC;
        ppMIDIStreamingDataRanges->DataRange.SubFormat = KSDATAFORMAT_SUBTYPE_MIDI;
        ppMIDIStreamingDataRanges->DataRange.Specifier = KSDATAFORMAT_SPECIFIER_NONE;
        ppMIDIStreamingDataRanges->Technology = KSMUSIC_TECHNOLOGY_PORT;
        ppMIDIStreamingDataRanges->Channels = 0;
        ppMIDIStreamingDataRanges->Notes = 0;
        ppMIDIStreamingDataRanges->ChannelMask = 0xFFFF;
        ppMIDIStreamingDataRanges++;
#endif

        pPinDescEx[i].PinDescriptor.DataFlow =
            GetDataFlowDirectionForMIDIInterface( pHwDevExt->pConfigurationDescriptor, j, FALSE);

        pPinDescEx[i].PinDescriptor.Communication = KSPIN_COMMUNICATION_SINK;

        if ( pPinDescEx[i].PinDescriptor.DataFlow == KSPIN_DATAFLOW_IN ) {
            pPinDescEx[i].PinDescriptor.Communication = KSPIN_COMMUNICATION_SINK;
            pPinDescEx[i].PinDescriptor.Category = (GUID*)&KSCATEGORY_WDMAUD_USE_PIN_NAME;
            pPinDescEx[i].Flags = KSPIN_FLAG_RENDERER | KSPIN_FLAG_CRITICAL_PROCESSING;
        }
        else {
            pPinDescEx[i].PinDescriptor.Communication = KSPIN_COMMUNICATION_BOTH;
            pPinDescEx[i].PinDescriptor.Category = (GUID*)&KSCATEGORY_WDMAUD_USE_PIN_NAME;
            pPinDescEx[i].Flags = KSPIN_FLAG_CRITICAL_PROCESSING;
        }

        // Set max instances to 1 for all pins.
        pPinDescEx[i].InstancesPossible  = 1;
        pPinDescEx[i].InstancesNecessary = 0;

        // Keep track of pin instance count at the filter level (stored in device context)
        pPinInstances[i].PossibleCount = 1;
        pPinInstances[i].CurrentCount  = 0;

        pPinDescEx[i].IntersectHandler = USBMIDIPinDataIntersect;

        // Set up Allocator Framing
        pPinDescEx[i].AllocatorFraming = &AllocatorFraming;
    }

    // Now fill in descriptors for MIDI bridge pins
    for ( j=0; j<ulNumMIDIBridgePins; j++, i++ ) {
        pPinDescEx[i].Dispatch = NULL;
        pPinDescEx[i].AutomationTable = NULL;

        pPinDescEx[i].PinDescriptor.InterfacesCount = 1;
        pPinDescEx[i].PinDescriptor.Interfaces = PinInterface;
        pPinDescEx[i].PinDescriptor.MediumsCount = 1;
        pPinDescEx[i].PinDescriptor.Mediums = PinMedium;
        pPinDescEx[i].PinDescriptor.DataRangesCount = 1;
        pPinDescEx[i].PinDescriptor.DataRanges = &pMIDIBridgePinFormats;
        pPinDescEx[i].PinDescriptor.Communication = KSPIN_COMMUNICATION_BRIDGE;
        pPinDescEx[i].PinDescriptor.DataFlow =
            GetDataFlowDirectionForMIDIInterface( pHwDevExt->pConfigurationDescriptor, j, TRUE);
        pPinDescEx[i].PinDescriptor.Category = (GUID*) &KSCATEGORY_AUDIO;

        pPinDescEx[i].InstancesPossible  = 0;
        pPinDescEx[i].InstancesNecessary = 0;

        // Keep track of pin instance count at the filter level (stored in device context)
        pPinInstances[i].PossibleCount = 0;
        pPinInstances[i].CurrentCount  = 0;
    }

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\drivers\usbaudio.2\proto.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 2000
//
//  File:       proto.h
//
//--------------------------------------------------------------------------

#ifndef _USBAUDIO_PROTO_H_
#define _USBAUDIO_PROTO_H_

// Device.c

NTSTATUS
USBAudioAddDevice( IN PKSDEVICE Device );

NTSTATUS
USBAudioPnpStart(
    IN PKSDEVICE Device,
    IN PIRP Irp,
    IN PCM_RESOURCE_LIST TranslatedResources,
    IN PCM_RESOURCE_LIST UntranslatedResources
    );

NTSTATUS
USBAudioPnpQueryStop(
    IN PKSDEVICE Device,
    IN PIRP Irp
    );

void
USBAudioPnpCancelStop(
    IN PKSDEVICE Device,
    IN PIRP Irp
    );

void
USBAudioPnpStop(
    IN PKSDEVICE Device,
    IN PIRP Irp
    );

NTSTATUS
USBAudioPnpQueryRemove(
    IN PKSDEVICE Device,
    IN PIRP Irp
    );

void
USBAudioPnpCancelRemove(
    IN PKSDEVICE Device,
    IN PIRP Irp
    );

void
USBAudioPnpRemove(
    IN PKSDEVICE Device,
    IN PIRP Irp
    );

NTSTATUS
USBAudioPnpQueryCapabilities(
    IN PKSDEVICE Device,
    IN PIRP Irp,
    IN OUT PDEVICE_CAPABILITIES Capabilities
    );

void
USBAudioSurpriseRemoval(
    IN PKSDEVICE Device,
    IN PIRP Irp
    );

NTSTATUS
USBAudioQueryPower(
    IN PKSDEVICE pKsDevice,
    IN PIRP pIrp,
    IN DEVICE_POWER_STATE DeviceTo,
    IN DEVICE_POWER_STATE DeviceFrom,
    IN SYSTEM_POWER_STATE SystemTo,
    IN SYSTEM_POWER_STATE SystemFrom,
    IN POWER_ACTION Action
    );

void
USBAudioSetPower(
    IN PKSDEVICE pKsDevice,
    IN PIRP pIrp,
    IN DEVICE_POWER_STATE To,
    IN DEVICE_POWER_STATE From
    );

NTSTATUS
USBAudioDeferIrpCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

NTSTATUS
USBAudioGetUsbBusInterface(
    IN PKSDEVICE pKsDevice
    );

// Filter.c

NTSTATUS
USBAudioCreateFilterContext(
    PKSDEVICE pKsDevice
    );

// Pin.c

NTSTATUS
USBAudioPinBuildDescriptors(
    PKSDEVICE pKsDevice,
    PKSPIN_DESCRIPTOR_EX *ppPinDescEx,
    PULONG pNumPins,
    PULONG pPinDecSize
    );

VOID
USBAudioPinWaitForStarvation(
    PKSPIN pKsPin
    );

VOID
USBMIDIOutPinWaitForStarvation(
    PKSPIN pKsPin
    );

VOID
USBAudioPinReturnFromStandby(
    PKSPIN pKsPin
    );

VOID
USBAudioPinGoToStandby(
    PKSPIN pKsPin );

// Property.c

NTSTATUS
GetSetByte(
    PDEVICE_OBJECT pNextDeviceObject,
    PTOPOLOGY_NODE_INFO pNodeInfo,
    ULONG ulChannel,
    PULONG plData,
    UCHAR ucRequestType );

NTSTATUS
InitializeDbLevelCache(
    PDEVICE_OBJECT pNextDeviceObject,
    PTOPOLOGY_NODE_INFO pNodeInfo,
    PDB_LEVEL_CACHE pDbCache,
    ULONG ulDataBitCount
    );

NTSTATUS
GetSetProcessingUnitEnable(
    PDEVICE_OBJECT pNextDeviceObject,
    PTOPOLOGY_NODE_INFO pNodeInfo,
    UCHAR ucCommand,
    PBOOL pEnable
    );

NTSTATUS
GetProcessingUnitRange(
    PDEVICE_OBJECT pNextDeviceObject,
    PTOPOLOGY_NODE_INFO pNodeInfo,
    ULONG ulControl,
    ULONG ulCntrlSize,
    LONG  lScaleFactor,
    PKSPROPERTY_STEPPING_LONG pRange
    );

NTSTATUS
SetSampleRate(
    PKSPIN pKsPin,
    PULONG pSampleRate
    );

VOID
RestoreCachedSettings(
    PKSDEVICE pKsDevice
    );

VOID
BuildNodePropertySet(
    PTOPOLOGY_NODE_INFO pNodeInfo
    );

VOID
BuildFilterPropertySet(
    PKSFILTER_DESCRIPTOR pFilterDesc,
    PKSPROPERTY_ITEM pDevPropItems,
    PKSPROPERTY_SET pDevPropSet,
    PULONG pNumItems,
    PULONG pNumSets
    );

VOID
BuildPinPropertySet(
    PHW_DEVICE_EXTENSION pHwDevExt,
    PKSPROPERTY_ITEM pStrmPropItems,
    PKSPROPERTY_SET pStrmPropSet,
    PULONG pNumItems,
    PULONG pNumSets
    );
#ifdef DRM_USBAUDIO
NTSTATUS
DrmAudioStream_SetContentId(
    IN PIRP pIrp,
    IN PKSP_DRMAUDIOSTREAM_CONTENTID pProperty,
    IN PKSDRMAUDIOSTREAM_CONTENTID pvData
    );
#endif
#ifdef RTAUDIO
NTSTATUS RtAudio_GetAudioPositionFunction(
    IN PIRP pIrp,
    IN PKSPROPERTY pProperty,
    OUT PRTAUDIOGETPOSITION *pfnRtAudioGetPosition
    );
#endif

// Topology.c

NTSTATUS
BuildUSBAudioFilterTopology(
    PKSDEVICE pKsDevice
    );


// Hardware.c

NTSTATUS
USBAudioCancelCompleteSynch(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN PKEVENT          pKevent
    );

NTSTATUS
SubmitUrbToUsbdSynch(
    PDEVICE_OBJECT pNextDeviceObject,
    PURB pUrb
    );

NTSTATUS
StartUSBAudioDevice(
    PKSDEVICE  pKsDevice
    );

NTSTATUS
StopUSBAudioDevice(
    PKSDEVICE pKsDevice
    );

NTSTATUS
SelectStreamingAudioInterface(
    PUSB_INTERFACE_DESCRIPTOR pInterfaceDescriptor,
    PHW_DEVICE_EXTENSION pHwDevExt,
    PKSPIN pKsPin );

NTSTATUS
SelectStreamingMIDIInterface(
    PHW_DEVICE_EXTENSION pHwDevExt,
    PKSPIN pKsPin );

NTSTATUS
SelectZeroBandwidthInterface(
    PHW_DEVICE_EXTENSION pHwDevExt,
    ULONG ulPinNumber );

NTSTATUS
ResetUSBPipe(
    PDEVICE_OBJECT pNextDeviceObject,
    USBD_PIPE_HANDLE hPipeHandle
    );

NTSTATUS
AbortUSBPipe(
    PPIN_CONTEXT pPinContext
    );

NTSTATUS
GetCurrentUSBFrame(
    IN PPIN_CONTEXT pPinContext,
    OUT PULONG pUSBFrame
    );


// ParseDsc.c
PUSB_INTERFACE_DESCRIPTOR
GetNextAudioInterface(
    PUSB_CONFIGURATION_DESCRIPTOR pConfigurationDescriptor,
    PUSB_INTERFACE_DESCRIPTOR pInterfaceDescriptor );

PUSB_INTERFACE_DESCRIPTOR
GetFirstAudioStreamingInterface(
    PUSB_CONFIGURATION_DESCRIPTOR pConfigurationDescriptor,
    ULONG ulInterfaceNumber );

PAUDIO_SPECIFIC
GetAudioSpecificInterface(
    PUSB_CONFIGURATION_DESCRIPTOR pConfigurationDescriptor,
    PUSB_INTERFACE_DESCRIPTOR pInterfaceDescriptor,
    LONG lDescriptorSubtype
    );

PUSB_ENDPOINT_DESCRIPTOR
GetEndpointDescriptor(
    PUSB_CONFIGURATION_DESCRIPTOR pConfigurationDescriptor,
    PUSB_INTERFACE_DESCRIPTOR pInterfaceDescriptor,
    BOOLEAN fGetAudioSpecificEndpoint
    );


ULONG
GetMaxPacketSizeForInterface(
    PUSB_CONFIGURATION_DESCRIPTOR pConfigurationDescriptor,
    PUSB_INTERFACE_DESCRIPTOR pInterfaceDescriptor
    );

BOOLEAN
IsZeroBWInterface(
    PUSB_CONFIGURATION_DESCRIPTOR pConfigurationDescriptor,
    PUSB_INTERFACE_DESCRIPTOR pInterfaceDescriptor
    );

ULONG
CountTerminalUnits(
    PUSB_CONFIGURATION_DESCRIPTOR pConfigurationDescriptor,
    PULONG pAudioBridgePinCount,
    PULONG pMIDIPinCount,
    PULONG pMIDIBridgePinCount
    );

ULONG
CountFormatsForAudioStreamingInterface(
    PUSB_CONFIGURATION_DESCRIPTOR pConfigurationDescriptor,
    ULONG ulInterfaceNumber
    );

ULONG
CountInputChannels(
    PUSB_CONFIGURATION_DESCRIPTOR pConfigurationDescriptor,
    ULONG ulUnitID
    );

VOID
CountTopologyComponents(
    PUSB_CONFIGURATION_DESCRIPTOR pConfigurationDescriptor,
    PULONG pNumCategories,
    PULONG pNumNodes,
    PULONG pNumConnections,
    PULONG pbmCategories
    );

KSPIN_DATAFLOW
GetDataFlowDirectionForInterface(
    PUSB_CONFIGURATION_DESCRIPTOR pConfigurationDescriptor,
    ULONG ulInterfaceNumber
    );

KSPIN_DATAFLOW
GetDataFlowDirectionForMIDIInterface(
    PUSB_CONFIGURATION_DESCRIPTOR pConfigurationDescriptor,
    ULONG ulPinNumber,
    BOOL fBridgePin
    );

ULONG
GetPinDataRangesFromInterface(
    ULONG ulInterfaceNumber,
    PUSB_CONFIGURATION_DESCRIPTOR pConfigurationDescriptor,
    PKSDATARANGE_AUDIO *ppKsAudioRange,
    PUSBAUDIO_DATARANGE pKsAudioRange
    );

BOOL
IsBridgePinDigital(
    PUSB_CONFIGURATION_DESCRIPTOR pConfigurationDescriptor,
    ULONG ulBridgePinNumber);

VOID
GetCategoryForBridgePin(
    PUSB_CONFIGURATION_DESCRIPTOR pConfigurationDescriptor,
    ULONG ulBridgePinNumber,
    GUID* pTTypeGUID
    );

KSPIN_DATAFLOW
GetDataFlowForBridgePin(
    PUSB_CONFIGURATION_DESCRIPTOR pConfigurationDescriptor,
    ULONG ulBridgePinNumber
    );

LONG
GetPinNumberForStreamingTerminalUnit(
    PUSB_CONFIGURATION_DESCRIPTOR pConfigurationDescriptor,
    UCHAR ulTerminalNumber
    );

LONG
GetPinNumberForMIDIJack(
    PUSB_CONFIGURATION_DESCRIPTOR pConfigurationDescriptor,
    UCHAR ulJackID,
    ULONG pMIDIStreamingPinStartIndex,
    ULONG pBridgePinStartIndex);

ULONG
GetChannelConfigForUnit(
    PUSB_CONFIGURATION_DESCRIPTOR pConfigurationDescriptor,
    ULONG ulUnitNumber
    );

UCHAR
GetUnitControlInterface(
    PHW_DEVICE_EXTENSION pHwDevExt,
    UCHAR bUnitId
    );

PUSBAUDIO_DATARANGE
GetUsbDataRangeForFormat(
    PKSDATAFORMAT pFormat,
    PUSBAUDIO_DATARANGE pUsbDataRange,
    ULONG ulUsbDataRangeCnt
    );

BOOLEAN
IsSampleRateInRange(
    PVOID pAudioDescriptor,
    ULONG ulSampleRate,
    ULONG ulFormatType
    );

VOID
GetContextForMIDIPin
(
    PKSPIN pKsPin,
    PUSB_CONFIGURATION_DESCRIPTOR pConfigurationDescriptor,
    PMIDI_PIN_CONTEXT pMIDIPinContext
);

// TypeI.c
NTSTATUS
RtAudioTypeIGetPlayPosition(
    IN PFILE_OBJECT PinFileObject,
    OUT PUCHAR *ppPlayPosition,
    OUT PLONG plOffset
    );

NTSTATUS
TypeIRenderBytePosition(
    PPIN_CONTEXT pPinContext,
    PKSAUDIO_POSITION pPosition
    );


NTSTATUS
TypeIRenderStreamInit(
    PKSPIN pKsPin
    );

NTSTATUS
TypeIProcessStreamPtr(
    PKSPIN pKsPin
    );


NTSTATUS
TypeIStateChange(
    PKSPIN pKsPin,
    KSSTATE OldKsState,
    KSSTATE NewKsState
    );

NTSTATUS
TypeIRenderStreamClose(
    PKSPIN pKsPin
    );

// TypeII.c

NTSTATUS
TypeIIRenderStreamInit(
    PKSPIN pKsPin
    );

NTSTATUS
TypeIIProcessStreamPtr(
    PKSPIN pKsPin
    );


NTSTATUS
TypeIIStateChange(
    PKSPIN pKsPin,
    KSSTATE OldKsState,
    KSSTATE NewKsState
    );

NTSTATUS
TypeIIRenderStreamClose(
    PKSPIN pKsPin
    );

// Capture.c

NTSTATUS
CaptureBytePosition(
    PKSPIN pKsPin,
    PKSAUDIO_POSITION pPosition
    );

NTSTATUS
CaptureStreamInit(
    PKSPIN pKsPin
    );

NTSTATUS
CaptureProcess(
    PKSPIN pKsPin
    );

NTSTATUS
CaptureStartIsocTransfer(
    PPIN_CONTEXT pPinContext
    );

NTSTATUS
CaptureStateChange(
    PKSPIN pKsPin,
    KSSTATE OldKsState,
    KSSTATE NewKsState
    );

NTSTATUS
CaptureStreamClose(
     PKSPIN pKsPin
     );

// Intrsect.c
ULONG
GetIntersectFormatSize(
    PUSBAUDIO_DATARANGE pAudioDataRange
    );

ULONG
ConvertDatarangeToFormat(
    PUSBAUDIO_DATARANGE pAudioDataRange,
    PKSDATAFORMAT pFormat
    );


PUSBAUDIO_DATARANGE
FindDataIntersection(
    PKSDATARANGE_AUDIO pKsAudioRange,
    PUSBAUDIO_DATARANGE *ppUSBAudioRanges,
    ULONG ulAudioRangeCount
    );

// midiout.c
NTSTATUS
SendBulkMIDIRequest(
    IN PKSSTREAM_POINTER pKsPin,
    PKSMUSICFORMAT MusicHdr,
    PULONG pulBytesConsumed
    );

NTSTATUS
USBMIDIOutProcessStreamPtr(
    IN PKSPIN pKsPin
    );

NTSTATUS
USBMIDIOutStateChange(
    PKSPIN pKsPin,
    KSSTATE OldKsState,
    KSSTATE NewKsState
    );

NTSTATUS
USBMIDIOutStreamInit(
    IN PKSPIN pKsPin
    );

NTSTATUS
USBMIDIOutStreamClose(
    PKSPIN pKsPin
    );

// midiin.c
NTSTATUS
USBMIDIInCompleteCallback(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP pIrp,
    PMIDIIN_URB_BUFFER_INFO pMIDIInBufInfo
    );

NTSTATUS
USBMIDIInFreePipeInfo(
    PMIDI_PIPE_INFORMATION pMIDIPipeInfo
    );

NTSTATUS
USBMIDIInStateChange(
    PKSPIN pKsPin,
    KSSTATE OldKsState,
    KSSTATE NewKsState
    );

NTSTATUS
USBMIDIInProcessStreamPtr(
    IN PKSPIN pKsPin
    );

NTSTATUS
USBMIDIInStreamInit(
    IN PKSPIN pKsPin
    );

NTSTATUS
USBMIDIInStreamClose(
    PKSPIN pKsPin
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\drivers\usbaudio.2\property.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 2000
//
//  File:       property.h
//
//--------------------------------------------------------------------------

#ifndef ___PROPERTY_H___
#define ___PROPERTY_H___

/*****************************************************************************

                        Definitions of Properties

*****************************************************************************/
// Declare Handlers for Pin Properties
NTSTATUS
GetPinName( PIRP pIrp, PKSP_PIN pPin, PVOID pData );

// Declare Handlers for Item Map
NTSTATUS
GetSetSampleRate( PIRP pIrp, PKSPROPERTY pKsProperty, PVOID pData );
NTSTATUS
GetSetVolumeLevel( PIRP pIrp, PKSPROPERTY pKsProperty, PVOID pData );
NTSTATUS
GetSetToneLevel( PIRP pIrp, PKSPROPERTY pKsProperty, PVOID pData );
NTSTATUS
GetSetCopyProtection( PIRP pIrp, PKSPROPERTY pKsProperty, PVOID pData );
//NTSTATUS
//GetSetDynamicRange( PIRP pIrp, PKSPROPERTY pKsProperty, PVOID pData );
NTSTATUS
GetSetMixLevels( PIRP pIrp, PKSPROPERTY pKsProperty, PVOID pData );
NTSTATUS
GetMuxSource( PIRP pIrp, PKSPROPERTY pKsProperty, PVOID pData );
NTSTATUS
SetMuxSource( PIRP pIrp, PKSPROPERTY pKsProperty, PVOID pData );
NTSTATUS
GetSetBoolean( PIRP pIrp, PKSPROPERTY pKsProperty, PVOID pData );
NTSTATUS
GetSetEqualizerLevels( PIRP pIrp, PKSPROPERTY pKsProperty, PVOID pData );
NTSTATUS
GetNumEqualizerBands( PIRP pIrp, PKSPROPERTY pKsProperty, PVOID pData );
NTSTATUS
GetEqualizerBands( PIRP pIrp, PKSPROPERTY pKsProperty, PVOID pData );
NTSTATUS
GetSetAudioControlLevel( PIRP pIrp, PKSPROPERTY pKsProperty, PVOID pData );
NTSTATUS
GetSetDeviceSpecific( PIRP pIrp, PKSPROPERTY pKsProperty, PVOID pData );
NTSTATUS
GetAudioLatency( PIRP pIrp, PKSPROPERTY pKsProperty, PVOID pData );
NTSTATUS
GetChannelConfiguration( PIRP pIrp, PKSPROPERTY pKsProperty, PVOID pData );
NTSTATUS
GetAudioPosition( PIRP pIrp, PKSPROPERTY pKsProperty, PVOID pData );
NTSTATUS
GetSetSampleRate( PIRP pIrp, PKSPROPERTY pKsProperty, PVOID pData );

NTSTATUS
GetBasicSupport( PIRP pIrp, PKSPROPERTY pKsProperty, PVOID pData );
NTSTATUS
GetBasicSupportBoolean( PIRP pIrp, PKSPROPERTY pKsProperty, PVOID pData );

NTSTATUS
GetSetTopologyNodeEnable( PIRP pIrp, PKSPROPERTY pKsProperty, PVOID pData );

static const
KSPROPERTY_ITEM PinPropertyItems[]={
    {
     (ULONG) KSPROPERTY_PIN_CINSTANCES,  // PropertyId
     (PFNKSHANDLER) NULL,               // pfnGetHandler
     0,                                  // MinProperty
     0,                                  // MinData
     (PFNKSHANDLER) NULL,               // pfnSetHandler
     NULL,                               // PKSPROPERTY_VALUES Values
     0,                                  // RelationsCount
     NULL,                               // PKSPROPERTY Relations
     NULL,                               // PFNKSHANDLER SupportHandler
     0                                   // SerializedSize
    },

    {
     (ULONG) KSPROPERTY_PIN_CTYPES,      // PropertyId
     (PFNKSHANDLER) NULL,               // pfnGetHandler
     0,                                  // MinProperty
     0,                                  // MinData
     (PFNKSHANDLER) NULL,               // pfnSetHandler
     NULL,                               // PKSPROPERTY_VALUES Values
     0,                                  // RelationsCount
     NULL,                               // PKSPROPERTY Relations
     NULL,                               // PFNKSHANDLER SupportHandler
     0                                   // SerializedSize
    },

    {
     (ULONG) KSPROPERTY_PIN_DATAFLOW,    // PropertyId
     (PFNKSHANDLER) NULL,               // pfnGetHandler
     0,                                  // MinProperty
     0,                                  // MinData
     (PFNKSHANDLER) NULL,               // pfnSetHandler
     NULL,                               // PKSPROPERTY_VALUES Values
     0,                                  // RelationsCount
     NULL,                               // PKSPROPERTY Relations
     NULL,                               // PFNKSHANDLER SupportHandler
     0                                   // SerializedSize
    },

    {
     (ULONG) KSPROPERTY_PIN_DATARANGES,  // PropertyId
     (PFNKSHANDLER) NULL,               // pfnGetHandler
     0,                                  // MinProperty
     0,                                  // MinData
     (PFNKSHANDLER) NULL,               // pfnSetHandler
     NULL,                               // PKSPROPERTY_VALUES Values
     0,                                  // RelationsCount
     NULL,                               // PKSPROPERTY Relations
     NULL,                               // PFNKSHANDLER SupportHandler
     0                                   // SerializedSize
    },

    {
     (ULONG) KSPROPERTY_PIN_DATAINTERSECTION,  // PropertyId
     (PFNKSHANDLER) NULL,               // pfnGetHandler
     0,                                  // MinProperty
     0,                                  // MinData
     (PFNKSHANDLER) NULL,               // pfnSetHandler
     NULL,                               // PKSPROPERTY_VALUES Values
     0,                                  // RelationsCount
     NULL,                               // PKSPROPERTY Relations
     NULL,                               // PFNKSHANDLER SupportHandler
     0                                   // SerializedSize
    },

    {
     (ULONG) KSPROPERTY_PIN_INTERFACES,  // PropertyId
     (PFNKSHANDLER) NULL,               // pfnGetHandler
     0,                                  // MinProperty
     0,                                  // MinData
     (PFNKSHANDLER) NULL,               // pfnSetHandler
     NULL,                               // PKSPROPERTY_VALUES Values
     0,                                  // RelationsCount
     NULL,                               // PKSPROPERTY Relations
     NULL,                               // PFNKSHANDLER SupportHandler
     0                                   // SerializedSize
    },

    {
     (ULONG) KSPROPERTY_PIN_MEDIUMS,     // PropertyId
     (PFNKSHANDLER) NULL,               // pfnGetHandler
     0,                                  // MinProperty
     0,                                  // MinData
     (PFNKSHANDLER) NULL,               // pfnSetHandler
     NULL,                               // PKSPROPERTY_VALUES Values
     0,                                  // RelationsCount
     NULL,                               // PKSPROPERTY Relations
     NULL,                               // PFNKSHANDLER SupportHandler
     0                                   // SerializedSize
    },

    {
     (ULONG) KSPROPERTY_PIN_COMMUNICATION,  // PropertyId
     (PFNKSHANDLER) NULL,               // pfnGetHandler
     0,                                  // MinProperty
     0,                                  // MinData
     (PFNKSHANDLER) NULL,               // pfnSetHandler
     NULL,                               // PKSPROPERTY_VALUES Values
     0,                                  // RelationsCount
     NULL,                               // PKSPROPERTY Relations
     NULL,                               // PFNKSHANDLER SupportHandler
     0                                   // SerializedSize
    },

    {
     (ULONG) KSPROPERTY_PIN_GLOBALCINSTANCES,  // PropertyId
     (PFNKSHANDLER) NULL,               // pfnGetHandler
     0,                                  // MinProperty
     0,                                  // MinData
     (PFNKSHANDLER) NULL,               // pfnSetHandler
     NULL,                               // PKSPROPERTY_VALUES Values
     0,                                  // RelationsCount
     NULL,                               // PKSPROPERTY Relations
     NULL,                               // PFNKSHANDLER SupportHandler
     0                                   // SerializedSize
    },

    {
     (ULONG) KSPROPERTY_PIN_NECESSARYINSTANCES,  // PropertyId
     (PFNKSHANDLER) NULL,               // pfnGetHandler
     0,                                  // MinProperty
     0,                                  // MinData
     (PFNKSHANDLER) NULL,               // pfnSetHandler
     NULL,                               // PKSPROPERTY_VALUES Values
     0,                                  // RelationsCount
     NULL,                               // PKSPROPERTY Relations
     NULL,                               // PFNKSHANDLER SupportHandler
     0                                   // SerializedSize
    },

    {
     (ULONG) KSPROPERTY_PIN_PHYSICALCONNECTION,  // PropertyId
     (PFNKSHANDLER) NULL,               // pfnGetHandler
     0,                                  // MinProperty
     0,                                  // MinData
     (PFNKSHANDLER) NULL,               // pfnSetHandler
     NULL,                               // PKSPROPERTY_VALUES Values
     0,                                  // RelationsCount
     NULL,                               // PKSPROPERTY Relations
     NULL,                               // PFNKSHANDLER SupportHandler
     0                                   // SerializedSize
    },

    {
     (ULONG) KSPROPERTY_PIN_CATEGORY,    // PropertyId
     (PFNKSHANDLER) NULL,               // pfnGetHandler
     0,                                  // MinProperty
     0,                                  // MinData
     (PFNKSHANDLER) NULL,               // pfnSetHandler
     NULL,                               // PKSPROPERTY_VALUES Values
     0,                                  // RelationsCount
     NULL,                               // PKSPROPERTY Relations
     NULL,                               // PFNKSHANDLER SupportHandler
     0                                   // SerializedSize
    },

    {
     (ULONG) KSPROPERTY_PIN_NAME,        // PropertyId
     (PFNKSHANDLER) GetPinName,          // pfnGetHandler
     sizeof(KSP_PIN),                    // MinProperty
     0,                                  // MinData
     (PFNKSHANDLER) NULL,               // pfnSetHandler
     NULL,                               // PKSPROPERTY_VALUES Values
     0,                                  // RelationsCount
     NULL,                               // PKSPROPERTY Relations
     NULL,                               // PFNKSHANDLER SupportHandler
     0                                   // SerializedSize
    },

    {
     (ULONG) KSPROPERTY_PIN_CONSTRAINEDDATARANGES,  // PropertyId
     (PFNKSHANDLER) NULL,               // pfnGetHandler
     0,                                  // MinProperty
     0,                                  // MinData
     (PFNKSHANDLER) NULL,               // pfnSetHandler
     NULL,                               // PKSPROPERTY_VALUES Values
     0,                                  // RelationsCount
     NULL,                               // PKSPROPERTY Relations
     NULL,                               // PFNKSHANDLER SupportHandler
     0                                   // SerializedSize
    },

    {
     (ULONG) KSPROPERTY_PIN_PROPOSEDATAFORMAT,  // PropertyId
     (PFNKSHANDLER) NULL,               // pfnGetHandler
     0,                                  // MinProperty
     0,                                  // MinData
     (PFNKSHANDLER) NULL,               // pfnSetHandler
     NULL,                               // PKSPROPERTY_VALUES Values
     0,                                  // RelationsCount
     NULL,                               // PKSPROPERTY Relations
     NULL,                               // PFNKSHANDLER SupportHandler
     0                                   // SerializedSize
    }
};

static const
KSPROPERTY_ITEM AudioPropertyItems[]={
    {
     (ULONG) 0,                          // PropertyId (There is no property 0)
     (PFNKSHANDLER) NULL,               // pfnGetHandler
     0,                                  // MinProperty
     0,                                  // MinData
     (PFNKSHANDLER) NULL,               // pfnSetHandler
     NULL,                               // PKSPROPERTY_VALUES Values
     0,                                  // RelationsCount
     NULL,                               // PKSPROPERTY Relations
     NULL,                               // PFNKSHANDLER SupportHandler
     0                                   // SerializedSize
    },

    {
     (ULONG) KSPROPERTY_AUDIO_LATENCY,   // PropertyId
     GetAudioLatency,                    // pfnGetHandler
     sizeof (KSPROPERTY),                // MinProperty
     sizeof (KSTIME),                    // MinData
     NULL,                               // pfnSetHandler
     NULL,                               // PKSPROPERTY_VALUES Values
     0,                                  // RelationsCount
     NULL,                               // PKSPROPERTY Relations
     NULL,                               // PFNKSHANDLER SupportHandler
     0                                   // SerializedSize
    },

    {
     (ULONG) KSPROPERTY_AUDIO_COPY_PROTECTION, // PropertyId
     GetSetCopyProtection,               // pfnGetHandler
     sizeof (KSPROPERTY),                // MinProperty
     sizeof (KSAUDIO_COPY_PROTECTION),   // MinData
     GetSetCopyProtection,               // pfnSetHandler
     NULL,                               // PKSPROPERTY_VALUES Values
     0,                                  // RelationsCount
     NULL,                               // PKSPROPERTY Relations
     NULL,                               // PFNKSHANDLER SupportHandler
     0                                   // SerializedSize
    },

    {
     (ULONG) KSPROPERTY_AUDIO_CHANNEL_CONFIG, // PropertyId
     GetChannelConfiguration,            // pfnGetHandler
     sizeof (KSNODEPROPERTY),            // MinProperty
     sizeof (KSAUDIO_CHANNEL_CONFIG),    // MinData
     NULL,                               // pfnSetHandler
     NULL,                               // PKSPROPERTY_VALUES Values
     0,                                  // RelationsCount
     NULL,                               // PKSPROPERTY Relations
     NULL,                               // PFNKSHANDLER SupportHandler
     0                                   // SerializedSize
    },

    {
     (ULONG) KSPROPERTY_AUDIO_VOLUMELEVEL, // PropertyId
     GetSetVolumeLevel,                  // pfnGetHandler
     sizeof (KSNODEPROPERTY_AUDIO_CHANNEL), // MinProperty
     sizeof (ULONG),                     // MinData
     GetSetVolumeLevel,                  // pfnSetHandler
     NULL,                               // PKSPROPERTY_VALUES Values
     0,                                  // RelationsCount
     NULL,                               // PKSPROPERTY Relations
     GetBasicSupport,                    // PFNKSHANDLER SupportHandler
     0                                   // SerializedSize
    },

    {
     (ULONG) KSPROPERTY_AUDIO_POSITION,  // PropertyId
     GetAudioPosition,                   // pfnGetHandler
     sizeof (KSPROPERTY),                // MinProperty
     sizeof (KSAUDIO_POSITION),          // MinData
     NULL,                               // pfnSetHandler
     NULL,                               // PKSPROPERTY_VALUES Values
     0,                                  // RelationsCount
     NULL,                               // PKSPROPERTY Relations
     NULL,                               // PFNKSHANDLER SupportHandler
     0                                   // SerializedSize
    },

    {
     (ULONG) KSPROPERTY_AUDIO_DYNAMIC_RANGE, // PropertyId
     NULL,                               // pfnGetHandler
     sizeof (KSNODEPROPERTY),            // MinProperty
     sizeof (KSAUDIO_DYNAMIC_RANGE),     // MinData
     NULL,                               // pfnSetHandler
     NULL,                               // PKSPROPERTY_VALUES Values
     0,                                  // RelationsCount
     NULL,                               // PKSPROPERTY Relations
     NULL,                               // PFNKSHANDLER SupportHandler
     0                                   // SerializedSize
    },

    {
     (ULONG) KSPROPERTY_AUDIO_QUALITY,   // PropertyId
     NULL,                               // pfnGetHandler
     sizeof (KSPROPERTY),                // MinProperty
     sizeof (ULONG),                     // MinData
     NULL,                               // pfnSetHandler
     NULL,                               // PKSPROPERTY_VALUES Values
     0,                                  // RelationsCount
     NULL,                               // PKSPROPERTY Relations
     NULL,                               // PFNKSHANDLER SupportHandler
     0                                   // SerializedSize
    },

    {
     (ULONG) KSPROPERTY_AUDIO_SAMPLING_RATE, // PropertyId
     GetSetSampleRate,                   // pfnGetHandler
     sizeof (KSNODEPROPERTY),            // MinProperty
     sizeof (ULONG),                     // MinData
     GetSetSampleRate,                   // pfnSetHandler
     NULL,                               // PKSPROPERTY_VALUES Values
     0,                                  // RelationsCount
     NULL,                               // PKSPROPERTY Relations
     NULL,                               // PFNKSHANDLER SupportHandler
     0                                   // SerializedSize
    },

    {
     (ULONG) KSPROPERTY_AUDIO_DYNAMIC_SAMPLING_RATE, // PropertyId
     NULL,                               // pfnGetHandler
     sizeof (KSNODEPROPERTY),            // MinProperty
     sizeof (BOOL),                      // MinData
     NULL,                               // pfnSetHandler
     NULL,                               // PKSPROPERTY_VALUES Values
     0,                                  // RelationsCount
     NULL,                               // PKSPROPERTY Relations
     NULL,                               // PFNKSHANDLER SupportHandler
     0                                   // SerializedSize
    },

    {
     (ULONG) KSPROPERTY_AUDIO_MIX_LEVEL_TABLE, // PropertyId
     GetSetMixLevels,                    // pfnGetHandler
     sizeof (KSNODEPROPERTY),            // MinProperty
     sizeof (KSAUDIO_MIXLEVEL),          // MinData
     GetSetMixLevels,                    // pfnSetHandler
     NULL,                               // PKSPROPERTY_VALUES Values
     0,                                  // RelationsCount
     NULL,                               // PKSPROPERTY Relations
     NULL,                               // PFNKSHANDLER SupportHandler
     0                                   // SerializedSize
    },

    {
     (ULONG) KSPROPERTY_AUDIO_MIX_LEVEL_CAPS, // PropertyId
     GetSetMixLevels,                    // pfnGetHandler
     sizeof (KSNODEPROPERTY),            // MinProperty
     sizeof (ULONG) + sizeof(ULONG),     // MinData
     NULL,                               // pfnSetHandler
     NULL,                               // PKSPROPERTY_VALUES Values
     0,                                  // RelationsCount
     NULL,                               // PKSPROPERTY Relations
     NULL,                               // PFNKSHANDLER SupportHandler
     0                                   // SerializedSize
    },

    {
     (ULONG) KSPROPERTY_AUDIO_MUX_SOURCE, // PropertyId
     GetMuxSource,                       // pfnGetHandler
     sizeof (KSNODEPROPERTY),            // MinProperty
     sizeof (ULONG),                     // MinData
     SetMuxSource,                       // pfnSetHandler
     NULL,                               // PKSPROPERTY_VALUES Values
     0,                                  // RelationsCount
     NULL,                               // PKSPROPERTY Relations
     NULL,                               // PFNKSHANDLER SupportHandler
     0                                   // SerializedSize
    },

    {
     (ULONG) KSPROPERTY_AUDIO_MUTE,      // PropertyId
     GetSetBoolean,                      // pfnGetHandler
     sizeof (KSNODEPROPERTY_AUDIO_CHANNEL), // MinProperty
     sizeof (BOOL),                      // MinData
     GetSetBoolean,                      // pfnSetHandler
     NULL,                               // PKSPROPERTY_VALUES Values
     0,                                  // RelationsCount
     NULL,                               // PKSPROPERTY Relations
     NULL,                               // PFNKSHANDLER SupportHandler
     0                                   // SerializedSize
    },

    {
     (ULONG) KSPROPERTY_AUDIO_BASS,      // PropertyId
     GetSetToneLevel,                    // pfnGetHandler
     sizeof (KSNODEPROPERTY_AUDIO_CHANNEL),  // MinProperty
     sizeof (ULONG),                     // MinData
     GetSetToneLevel,                    // pfnSetHandler
     NULL,                               // PKSPROPERTY_VALUES Values
     0,                                  // RelationsCount
     NULL,                               // PKSPROPERTY Relations
     GetBasicSupport,                    // PFNKSHANDLER SupportHandler
     0                                   // SerializedSize
    },

    {
     (ULONG) KSPROPERTY_AUDIO_MID,       // PropertyId
     GetSetToneLevel,                    // pfnGetHandler
     sizeof (KSNODEPROPERTY_AUDIO_CHANNEL), // MinProperty
     sizeof (ULONG),                     // MinData
     GetSetToneLevel,                    // pfnSetHandler
     NULL,                               // PKSPROPERTY_VALUES Values
     0,                                  // RelationsCount
     NULL,                               // PKSPROPERTY Relations
     GetBasicSupport,                    // PFNKSHANDLER SupportHandler
     0                                   // SerializedSize
    },

    {
     (ULONG) KSPROPERTY_AUDIO_TREBLE,    // PropertyId
     GetSetToneLevel,                    // pfnGetHandler
     sizeof (KSNODEPROPERTY_AUDIO_CHANNEL), // MinProperty
     sizeof (ULONG),                     // MinData
     GetSetToneLevel,                    // pfnSetHandler
     NULL,                               // PKSPROPERTY_VALUES Values
     0,                                  // RelationsCount
     NULL,                               // PKSPROPERTY Relations
     GetBasicSupport,                    // PFNKSHANDLER SupportHandler
     0                                   // SerializedSize
    },

    {
     (ULONG) KSPROPERTY_AUDIO_BASS_BOOST, // PropertyId
     GetSetBoolean,                      // pfnGetHandler
     sizeof (KSNODEPROPERTY_AUDIO_CHANNEL), // MinProperty
     sizeof (ULONG),                     // MinData
     GetSetBoolean,                      // pfnSetHandler
     NULL,                               // PKSPROPERTY_VALUES Values
     0,                                  // RelationsCount
     NULL,                               // PKSPROPERTY Relations
     NULL,                               // PFNKSHANDLER SupportHandler
     0                                   // SerializedSize
    },

    {
     (ULONG) KSPROPERTY_AUDIO_EQ_LEVEL,  // PropertyId
     GetSetEqualizerLevels,              // pfnGetHandler
     sizeof (KSNODEPROPERTY_AUDIO_CHANNEL), // MinProperty
     sizeof (ULONG),                     // MinData
     GetSetEqualizerLevels,              // pfnSetHandler
     NULL,                               // PKSPROPERTY_VALUES Values
     0,                                  // RelationsCount
     NULL,                               // PKSPROPERTY Relations
     GetBasicSupport,                    // PFNKSHANDLER SupportHandler
     0                                   // SerializedSize
    },

    {
     (ULONG) KSPROPERTY_AUDIO_NUM_EQ_BANDS, // PropertyId
     GetNumEqualizerBands,               // pfnGetHandler
     sizeof (KSNODEPROPERTY_AUDIO_CHANNEL),  // MinProperty
     sizeof (ULONG),                     // MinData
     GetNumEqualizerBands,               // pfnSetHandler
     NULL,                               // PKSPROPERTY_VALUES Values
     0,                                  // RelationsCount
     NULL,                               // PKSPROPERTY Relations
     NULL,                               // PFNKSHANDLER SupportHandler
     0                                   // SerializedSize
    },

    {
     (ULONG) KSPROPERTY_AUDIO_EQ_BANDS,  // PropertyId
     GetEqualizerBands,                  // pfnGetHandler
     sizeof (KSNODEPROPERTY_AUDIO_CHANNEL), // MinProperty
     sizeof (ULONG),                     // MinData
     GetEqualizerBands,                  // pfnSetHandler
     NULL,                               // PKSPROPERTY_VALUES Values
     0,                                  // RelationsCount
     NULL,                               // PKSPROPERTY Relations
     NULL,                               // PFNKSHANDLER SupportHandler
     0                                   // SerializedSize
    },

    {
     (ULONG) KSPROPERTY_AUDIO_AGC,       // PropertyId
     GetSetBoolean,                      // pfnGetHandler
     sizeof (KSNODEPROPERTY_AUDIO_CHANNEL), // MinProperty
     sizeof (ULONG),                     // MinData
     GetSetBoolean,                      // pfnSetHandler
     NULL,                               // PKSPROPERTY_VALUES Values
     0,                                  // RelationsCount
     NULL,                               // PKSPROPERTY Relations
     NULL,                               // PFNKSHANDLER SupportHandler
     0                                   // SerializedSize
    },

    {
     (ULONG) KSPROPERTY_AUDIO_DELAY,     // PropertyId
     NULL,                               // pfnGetHandler
     sizeof (KSNODEPROPERTY_AUDIO_CHANNEL), // MinProperty
     sizeof (KSTIME),                    // MinData
     NULL,                               // pfnSetHandler
     NULL,                               // PKSPROPERTY_VALUES Values
     0,                                  // RelationsCount
     NULL,                               // PKSPROPERTY Relations
     NULL,                               // PFNKSHANDLER SupportHandler
     0                                   // SerializedSize
    },

    {
     (ULONG) KSPROPERTY_AUDIO_LOUDNESS,  // PropertyId
     GetSetBoolean,                      // pfnGetHandler
     sizeof (KSNODEPROPERTY_AUDIO_CHANNEL), // MinProperty
     sizeof (ULONG),                     // MinData
     GetSetBoolean,                      // pfnSetHandler
     NULL,                               // PKSPROPERTY_VALUES Values
     0,                                  // RelationsCount
     NULL,                               // PKSPROPERTY Relations
     NULL,                               // PFNKSHANDLER SupportHandler
     0                                   // SerializedSize
    },

    {
     (ULONG) KSPROPERTY_AUDIO_WIDE_MODE, // PropertyId
     NULL,                               // pfnGetHandler
     sizeof (KSNODEPROPERTY),            // MinProperty
     sizeof (ULONG),                     // MinData
     NULL,                               // pfnSetHandler
     NULL,                               // PKSPROPERTY_VALUES Values
     0,                                  // RelationsCount
     NULL,                               // PKSPROPERTY Relations
     NULL,                               // PFNKSHANDLER SupportHandler
     0                                   // SerializedSize
    },

    {
     (ULONG) KSPROPERTY_AUDIO_WIDENESS,  // PropertyId
     GetSetAudioControlLevel,            // pfnGetHandler
     sizeof (KSNODEPROPERTY),            // MinProperty
     sizeof (ULONG),                     // MinData
     GetSetAudioControlLevel,            // pfnSetHandler
     NULL,                               // PKSPROPERTY_VALUES Values
     0,                                  // RelationsCount
     NULL,                               // PKSPROPERTY Relations
     NULL,                               // PFNKSHANDLER SupportHandler
     0                                   // SerializedSize
    },

    {
     (ULONG) KSPROPERTY_AUDIO_REVERB_LEVEL, // PropertyId
     GetSetAudioControlLevel,            // pfnGetHandler
     sizeof (KSNODEPROPERTY),            // MinProperty
     sizeof (ULONG),                     // MinData
     GetSetAudioControlLevel,            // pfnSetHandler
     NULL,                               // PKSPROPERTY_VALUES Values
     0,                                  // RelationsCount
     NULL,                               // PKSPROPERTY Relations
     NULL,                               // PFNKSHANDLER SupportHandler
     0                                   // SerializedSize
    },

    {
     (ULONG) KSPROPERTY_AUDIO_CHORUS_LEVEL, // PropertyId
     GetSetAudioControlLevel,            // pfnGetHandler
     sizeof (KSNODEPROPERTY),            // MinProperty
     sizeof (ULONG),                     // MinData
     GetSetAudioControlLevel,            // pfnSetHandler
     NULL,                               // PKSPROPERTY_VALUES Values
     0,                                  // RelationsCount
     NULL,                               // PKSPROPERTY Relations
     NULL,                               // PFNKSHANDLER SupportHandler
     0                                   // SerializedSize
    },

    {
     (ULONG) KSPROPERTY_AUDIO_DEV_SPECIFIC, // PropertyId
     GetSetDeviceSpecific,               // pfnGetHandler
     sizeof (KSNODEPROPERTY_AUDIO_DEV_SPECIFIC),  // MinProperty
     sizeof (BYTE),                      // MinData
     GetSetDeviceSpecific,               // pfnSetHandler
     NULL,                               // PKSPROPERTY_VALUES Values
     0,                                  // RelationsCount
     NULL,                               // PKSPROPERTY Relations
     NULL,                               // PFNKSHANDLER SupportHandler
     0                                   // SerializedSize
    }
};

#ifdef RTAUDIO
// RT Pos
DEFINE_KSPROPERTY_TABLE(RtAudioPropertyItems) {
    DEFINE_KSPROPERTY_ITEM (
        KSPROPERTY_RTAUDIO_GETPOSITIONFUNCTION,         // idProperty
        RtAudio_GetAudioPositionFunction,               // pfnGetHandler
        sizeof(KSPROPERTY),                             // cbMinGetPropertyInput
        sizeof(PRTAUDIOGETPOSITION),                    // cbMinGetDataInput
        NULL,                                           // pfnSetHandler
        0,                                              // Values
        0,                                              // RelationsCount
        NULL,                                           // Relations
        NULL,                                           // SupportHandler
        0                                               // SerializedSize
    )
};
#endif
#ifdef DRM_USBAUDIO
// DRM
DEFINE_KSPROPERTY_TABLE(DrmAudioStreamPropertyItems) {
    DEFINE_KSPROPERTY_ITEM (
        KSPROPERTY_DRMAUDIOSTREAM_CONTENTID,            // idProperty
        NULL,                                           // pfnGetHandler
        sizeof(KSP_DRMAUDIOSTREAM_CONTENTID),           // cbMinGetPropertyInput
        sizeof(KSDRMAUDIOSTREAM_CONTENTID),             // cbMinGetDataInput
        DrmAudioStream_SetContentId,                    // pfnSetHandler
        0,                                              // Values
        0,                                              // RelationsCount
        NULL,                                           // Relations
        NULL,                                           // SupportHandler
        0                                               // SerializedSize
    )
};
#endif
// AC-3 Property set.

static const KSPROPERTY_ITEM AC3PropItm[]={
    {
     (ULONG) 0,                          // PropertyId (There is no property 0)
     (PFNKSHANDLER) NULL,               // pfnGetHandler
     0,                                  // MinProperty
     0,                                  // MinData
     (PFNKSHANDLER) NULL,               // pfnSetHandler
     NULL,                               // PKSPROPERTY_VALUES Values
     0,                                  // RelationsCount
     NULL,                               // PKSPROPERTY Relations
     NULL,                               // PFNKSHANDLER SupportHandler
     0                                   // SerializedSize
    },

    {
     (ULONG) KSPROPERTY_AC3_ERROR_CONCEALMENT,  // PropertyId
     (PFNKSHANDLER) NULL,                // pfnGetHandler
     sizeof (KSNODEPROPERTY),            // MinProperty
     sizeof (BOOLEAN),                   // MinData
     (PFNKSHANDLER) NULL,                // pfnSetHandler
     NULL,                               // PKSPROPERTY_VALUES Values
     0,                                  // RelationsCount
     NULL,                               // PKSPROPERTY Relations
     NULL,                               // PFNKSHANDLER SupportHandler
     0                                   // SerializedSize
    },

    {
     (ULONG) KSPROPERTY_AC3_ALTERNATE_AUDIO,  // PropertyId
     (PFNKSHANDLER) NULL,                // pfnGetHandler
     sizeof (KSNODEPROPERTY),          // MinProperty
     sizeof (KSAC3_ALTERNATE_AUDIO),                  // MinData
     (PFNKSHANDLER) NULL,               // pfnSetHandler
     NULL,                               // PKSPROPERTY_VALUES Values
     0,                                  // RelationsCount
     NULL,                               // PKSPROPERTY Relations
     NULL,                               // PFNKSHANDLER SupportHandler
     0                                   // SerializedSize
    },

    {
     (ULONG) KSPROPERTY_AC3_DOWNMIX,  // PropertyId
     (PFNKSHANDLER) NULL,                // pfnGetHandler
     sizeof (KSNODEPROPERTY),          // MinProperty
     sizeof (KSAC3_DOWNMIX),                  // MinData
     (PFNKSHANDLER) NULL,               // pfnSetHandler
     NULL,                               // PKSPROPERTY_VALUES Values
     0,                                  // RelationsCount
     NULL,                               // PKSPROPERTY Relations
     NULL,                               // PFNKSHANDLER SupportHandler
     0                                   // SerializedSize
    },

    {
     (ULONG) KSPROPERTY_AC3_BIT_STREAM_MODE,  // PropertyId
     (PFNKSHANDLER) NULL,                // pfnGetHandler
     sizeof (KSNODEPROPERTY),          // MinProperty
     sizeof (ULONG),                  // MinData
     (PFNKSHANDLER) NULL,               // pfnSetHandler
     NULL,                               // PKSPROPERTY_VALUES Values
     0,                                  // RelationsCount
     NULL,                               // PKSPROPERTY Relations
     NULL,                               // PFNKSHANDLER SupportHandler
     0                                   // SerializedSize
    },

    {
     (ULONG) KSPROPERTY_AC3_DIALOGUE_LEVEL,  // PropertyId
     (PFNKSHANDLER) NULL,                // pfnGetHandler
     sizeof (KSNODEPROPERTY),            // MinProperty
     sizeof (ULONG),                     // MinData
     (PFNKSHANDLER) NULL,                // pfnSetHandler
     NULL,                               // PKSPROPERTY_VALUES Values
     0,                                  // RelationsCount
     NULL,                               // PKSPROPERTY Relations
     NULL,                               // PFNKSHANDLER SupportHandler
     0                                   // SerializedSize
    },

    {
     (ULONG) KSPROPERTY_AC3_LANGUAGE_CODE,  // PropertyId
     (PFNKSHANDLER) NULL,                // pfnGetHandler
     sizeof (KSNODEPROPERTY),            // MinProperty
     sizeof (ULONG),                     // MinData
     (PFNKSHANDLER) NULL,                // pfnSetHandler
     NULL,                               // PKSPROPERTY_VALUES Values
     0,                                  // RelationsCount
     NULL,                               // PKSPROPERTY Relations
     NULL,                               // PFNKSHANDLER SupportHandler
     0                                   // SerializedSize
    },

    {
     (ULONG) KSPROPERTY_AC3_ROOM_TYPE,   // PropertyId
     (PFNKSHANDLER) NULL,                // pfnGetHandler
     sizeof (KSNODEPROPERTY),            // MinProperty
     sizeof (BOOLEAN),                   // MinData
     (PFNKSHANDLER) NULL,                // pfnSetHandler
     NULL,                               // PKSPROPERTY_VALUES Values
     0,                                  // RelationsCount
     NULL,                               // PKSPROPERTY Relations
     NULL,                               // PFNKSHANDLER SupportHandler
     0                                   // SerializedSize
    }
};

static const KSPROPERTY_ITEM TopologyItm[]={
    {
     (ULONG) KSPROPERTY_TOPOLOGYNODE_ENABLE,  // PropertyId
     GetSetTopologyNodeEnable,           // pfnGetHandler
     sizeof (KSNODEPROPERTY),            // MinProperty
     sizeof (BOOLEAN),                   // MinData
     GetSetTopologyNodeEnable,           // pfnSetHandler
     NULL,                               // PKSPROPERTY_VALUES Values
     0,                                  // RelationsCount
     NULL,                               // PKSPROPERTY Relations
     NULL,                               // PFNKSHANDLER SupportHandler
     0                                   // SerializedSize
    }
};

static const KSPROPERTY_ITEM ConnectionItm[]={
  DEFINE_KSPROPERTY_ITEM_CONNECTION_ALLOCATORFRAMING(NULL)
};

static const KSPROPERTY_ITEM StreamItm[]={
  DEFINE_KSPROPERTY_ITEM_STREAM_ALLOCATOR(NULL,NULL)
};


// Property sets for individual node types

static const
KSPROPERTY_ITEM VolumePropertyItem[]={
    {
     (ULONG) KSPROPERTY_AUDIO_VOLUMELEVEL,  // PropertyId
     GetSetVolumeLevel,                     // pfnGetHandler
     sizeof (KSNODEPROPERTY_AUDIO_CHANNEL), // MinProperty
     sizeof (ULONG),                     // MinData
     GetSetVolumeLevel,                  // pfnSetHandler
     NULL,                               // PKSPROPERTY_VALUES Values
     0,                                  // RelationsCount
     NULL,                               // PKSPROPERTY Relations
     GetBasicSupport,                    // PFNKSHANDLER SupportHandler
     0                                   // SerializedSize
    }
};

static const
KSPROPERTY_ITEM MutePropertyItem[]={
    {
     (ULONG) KSPROPERTY_AUDIO_MUTE,  // PropertyId
     GetSetBoolean,                     // pfnGetHandler
     sizeof (KSNODEPROPERTY_AUDIO_CHANNEL), // MinProperty
     sizeof (ULONG),                     // MinData
     GetSetBoolean,                      // pfnSetHandler
     NULL,                               // PKSPROPERTY_VALUES Values
     0,                                  // RelationsCount
     NULL,                               // PKSPROPERTY Relations
     GetBasicSupportBoolean,             // PFNKSHANDLER SupportHandler
     0                                   // SerializedSize
    }
};

static const
KSPROPERTY_ITEM BassPropertyItem[]={
    {
     (ULONG) KSPROPERTY_AUDIO_BASS,  // PropertyId
     GetSetToneLevel,                     // pfnGetHandler
     sizeof (KSNODEPROPERTY_AUDIO_CHANNEL), // MinProperty
     sizeof (ULONG),                     // MinData
     GetSetToneLevel,                         // pfnSetHandler
     NULL,                               // PKSPROPERTY_VALUES Values
     0,                                  // RelationsCount
     NULL,                               // PKSPROPERTY Relations
     GetBasicSupport,                    // PFNKSHANDLER SupportHandler
     0                                   // SerializedSize
    }
};

static const
KSPROPERTY_ITEM TreblePropertyItem[]={
    {
     (ULONG) KSPROPERTY_AUDIO_TREBLE,  // PropertyId
     GetSetToneLevel,                     // pfnGetHandler
     sizeof (KSNODEPROPERTY_AUDIO_CHANNEL), // MinProperty
     sizeof (ULONG),                     // MinData
     GetSetToneLevel,                         // pfnSetHandler
     NULL,                               // PKSPROPERTY_VALUES Values
     0,                                  // RelationsCount
     NULL,                               // PKSPROPERTY Relations
     GetBasicSupport,                    // PFNKSHANDLER SupportHandler
     0                                   // SerializedSize
    }
};

static const
KSPROPERTY_ITEM MidrangePropertyItem[]={
    {
     (ULONG) KSPROPERTY_AUDIO_MID,  // PropertyId
     GetSetToneLevel,                     // pfnGetHandler
     sizeof (KSNODEPROPERTY_AUDIO_CHANNEL), // MinProperty
     sizeof (ULONG),                     // MinData
     GetSetToneLevel,                         // pfnSetHandler
     NULL,                               // PKSPROPERTY_VALUES Values
     0,                                  // RelationsCount
     NULL,                               // PKSPROPERTY Relations
     GetBasicSupport,                    // PFNKSHANDLER SupportHandler
     0                                   // SerializedSize
    }
};

static const
KSPROPERTY_ITEM BassBoostPropertyItem[]={
    {
     (ULONG) KSPROPERTY_AUDIO_BASS_BOOST, // PropertyId
     GetSetBoolean,                      // pfnGetHandler
     sizeof (KSNODEPROPERTY_AUDIO_CHANNEL), // MinProperty
     sizeof (ULONG),                     // MinData
     GetSetBoolean,                      // pfnSetHandler
     NULL,                               // PKSPROPERTY_VALUES Values
     0,                                  // RelationsCount
     NULL,                               // PKSPROPERTY Relations
     NULL,                               // PFNKSHANDLER SupportHandler
     0                                   // SerializedSize
    }
};

static const
KSPROPERTY_ITEM EqualizerPropertyItems[]={
    {
     (ULONG) KSPROPERTY_AUDIO_EQ_LEVEL,  // PropertyId
     GetSetEqualizerLevels,              // pfnGetHandler
     sizeof (KSNODEPROPERTY_AUDIO_CHANNEL), // MinProperty
     sizeof (ULONG),                     // MinData
     GetSetEqualizerLevels,              // pfnSetHandler
     NULL,                               // PKSPROPERTY_VALUES Values
     0,                                  // RelationsCount
     NULL,                               // PKSPROPERTY Relations
     GetBasicSupport,                    // PFNKSHANDLER SupportHandler
     0                                   // SerializedSize
    },

    {
     (ULONG) KSPROPERTY_AUDIO_NUM_EQ_BANDS, // PropertyId
     GetNumEqualizerBands,               // pfnGetHandler
     sizeof (KSNODEPROPERTY_AUDIO_CHANNEL),  // MinProperty
     sizeof (ULONG),                     // MinData
     GetNumEqualizerBands,               // pfnSetHandler
     NULL,                               // PKSPROPERTY_VALUES Values
     0,                                  // RelationsCount
     NULL,                               // PKSPROPERTY Relations
     NULL,                               // PFNKSHANDLER SupportHandler
     0                                   // SerializedSize
    },

    {
     (ULONG) KSPROPERTY_AUDIO_EQ_BANDS,  // PropertyId
     GetEqualizerBands,                  // pfnGetHandler
     sizeof (KSNODEPROPERTY_AUDIO_CHANNEL), // MinProperty
     sizeof (ULONG),                     // MinData
     GetEqualizerBands,                  // pfnSetHandler
     NULL,                               // PKSPROPERTY_VALUES Values
     0,                                  // RelationsCount
     NULL,                               // PKSPROPERTY Relations
     NULL,                               // PFNKSHANDLER SupportHandler
     0                                   // SerializedSize
    }
};

static const
KSPROPERTY_ITEM MixerPropertyItems[]={
    {
     (ULONG) KSPROPERTY_AUDIO_MIX_LEVEL_TABLE, // PropertyId
     GetSetMixLevels,                    // pfnGetHandler
     sizeof (KSNODEPROPERTY),            // MinProperty
     sizeof (KSAUDIO_MIXLEVEL),          // MinData
     GetSetMixLevels,                    // pfnSetHandler
     NULL,                               // PKSPROPERTY_VALUES Values
     0,                                  // RelationsCount
     NULL,                               // PKSPROPERTY Relations
     NULL,                               // PFNKSHANDLER SupportHandler
     0                                   // SerializedSize
    },

    {
     (ULONG) KSPROPERTY_AUDIO_MIX_LEVEL_CAPS, // PropertyId
     GetSetMixLevels,                    // pfnGetHandler
     sizeof (KSNODEPROPERTY),            // MinProperty
     sizeof (ULONG) + sizeof(ULONG),     // MinData
     NULL,                               // pfnSetHandler
     NULL,                               // PKSPROPERTY_VALUES Values
     0,                                  // RelationsCount
     NULL,                               // PKSPROPERTY Relations
     NULL,                               // PFNKSHANDLER SupportHandler
     0                                   // SerializedSize
    }
};

static const
KSPROPERTY_ITEM AGCPropertyItem[]={
    {
     (ULONG) KSPROPERTY_AUDIO_AGC,       // PropertyId
     GetSetBoolean,                      // pfnGetHandler
     sizeof (KSNODEPROPERTY_AUDIO_CHANNEL), // MinProperty
     sizeof (ULONG),                     // MinData
     GetSetBoolean,                      // pfnSetHandler
     NULL,                               // PKSPROPERTY_VALUES Values
     0,                                  // RelationsCount
     NULL,                               // PKSPROPERTY Relations
     NULL,                               // PFNKSHANDLER SupportHandler
     0                                   // SerializedSize
    }
};

static const
KSPROPERTY_ITEM MuxPropertyItem[]={
    {
     (ULONG) KSPROPERTY_AUDIO_MUX_SOURCE, // PropertyId
     GetMuxSource,                       // pfnGetHandler
     sizeof (KSNODEPROPERTY),            // MinProperty
     sizeof (ULONG),                     // MinData
     SetMuxSource,                       // pfnSetHandler
     NULL,                               // PKSPROPERTY_VALUES Values
     0,                                  // RelationsCount
     NULL,                               // PKSPROPERTY Relations
     NULL,                               // PFNKSHANDLER SupportHandler
     0                                   // SerializedSize
    }
};

static const
KSPROPERTY_ITEM LoudnessPropertyItem[]={
    {
     (ULONG) KSPROPERTY_AUDIO_LOUDNESS,  // PropertyId
     GetSetBoolean,                      // pfnGetHandler
     sizeof (KSNODEPROPERTY_AUDIO_CHANNEL), // MinProperty
     sizeof (ULONG),                     // MinData
     GetSetBoolean,                      // pfnSetHandler
     NULL,                               // PKSPROPERTY_VALUES Values
     0,                                  // RelationsCount
     NULL,                               // PKSPROPERTY Relations
     NULL,                               // PFNKSHANDLER SupportHandler
     0                                   // SerializedSize
    },
};

static DEFINE_KSPROPERTY_SET_TABLE(NodePropertySetTable)
{
    DEFINE_KSPROPERTY_SET( &GUID_NULL,                     // NODE_TYPE_NONE
                           0,
                           NULL,
                           0, NULL ),

    DEFINE_KSPROPERTY_SET( &GUID_NULL,                     // NODE_TYPE_DAC
                           0,
                           NULL,
                           0, NULL ),

    DEFINE_KSPROPERTY_SET( &GUID_NULL,                     // NODE_TYPE_ADC
                           0,
                           NULL,
                           0, NULL ),

    DEFINE_KSPROPERTY_SET( &GUID_NULL,                     // NODE_TYPE_SRC
                           0,
                           NULL,
                           0, NULL ),

    DEFINE_KSPROPERTY_SET( &KSPROPSETID_Audio,             // NODE_TYPE_SUPERMIX
                           SIZEOF_ARRAY(MixerPropertyItems),
                           (PVOID) MixerPropertyItems,
                           0, NULL),

    DEFINE_KSPROPERTY_SET( &KSPROPSETID_Audio,             // NODE_TYPE_MUX
                           SIZEOF_ARRAY(MuxPropertyItem),
                           (PVOID) MuxPropertyItem,
                           0, NULL),

    DEFINE_KSPROPERTY_SET( &GUID_NULL,                     // NODE_TYPE_SUM
                           0,
                           NULL,
                           0, NULL ),

    DEFINE_KSPROPERTY_SET( &KSPROPSETID_Audio,             // NODE_TYPE_MUTE
                           SIZEOF_ARRAY(MutePropertyItem),
                           (PVOID) MutePropertyItem,
                           0, NULL ),

    DEFINE_KSPROPERTY_SET( &KSPROPSETID_Audio,             // NODE_TYPE_VOLUME
                           SIZEOF_ARRAY(VolumePropertyItem),
                           (PVOID) VolumePropertyItem,
                           0, NULL ),

    DEFINE_KSPROPERTY_SET( &KSPROPSETID_Audio,             // NODE_TYPE_BASS
                           SIZEOF_ARRAY(BassPropertyItem),
                           (PVOID) BassPropertyItem,
                           0, NULL ),

    DEFINE_KSPROPERTY_SET( &KSPROPSETID_Audio,             // NODE_TYPE_MID
                           SIZEOF_ARRAY(MidrangePropertyItem),
                           (PVOID) MidrangePropertyItem,
                           0, NULL ),

    DEFINE_KSPROPERTY_SET( &KSPROPSETID_Audio,             // NODE_TYPE_TREBLE
                           SIZEOF_ARRAY(TreblePropertyItem),
                           (PVOID) TreblePropertyItem,
                           0, NULL ),

    DEFINE_KSPROPERTY_SET( &KSPROPSETID_Audio,            // NODE_TYPE_BASS_BOOST
                           SIZEOF_ARRAY(BassBoostPropertyItem),
                           (PVOID) BassBoostPropertyItem,
                           0, NULL ),

    DEFINE_KSPROPERTY_SET( &KSPROPSETID_Audio,            // NODE_TYPE_EQUALIZER
                           SIZEOF_ARRAY(EqualizerPropertyItems),
                           (PVOID) EqualizerPropertyItems,
                           0, NULL ),

    DEFINE_KSPROPERTY_SET( &KSPROPSETID_Audio,            // NODE_TYPE_AGC
                           SIZEOF_ARRAY(AGCPropertyItem),
                           (PVOID) AGCPropertyItem,
                           0, NULL ),

    DEFINE_KSPROPERTY_SET( &GUID_NULL,                     // NODE_TYPE_DELAY
                           0,
                           NULL,
                           0, NULL ),

    DEFINE_KSPROPERTY_SET( &KSPROPSETID_Audio,             // NODE_TYPE_LOUDNESS
                           SIZEOF_ARRAY(LoudnessPropertyItem),
                           (PVOID) LoudnessPropertyItem,
                           0, NULL ),

    DEFINE_KSPROPERTY_SET( &GUID_NULL,                     // NODE_TYPE_DELAY
                           0,
                           NULL,
                           0, NULL ),

    DEFINE_KSPROPERTY_SET( &GUID_NULL,                     // NODE_TYPE_PROLOGIC
                           0,
                           NULL,
                           0, NULL ),

    DEFINE_KSPROPERTY_SET( &GUID_NULL,                     // NODE_TYPE_STEREO_WIDE
                           0,
                           NULL,
                           0, NULL ),

    DEFINE_KSPROPERTY_SET( &GUID_NULL,                     // NODE_TYPE_REVERB
                           0,
                           NULL,
                           0, NULL ),

    DEFINE_KSPROPERTY_SET( &GUID_NULL,                     // NODE_TYPE_CHORUS
                           0,
                           NULL,
                           0, NULL ),

    DEFINE_KSPROPERTY_SET( &GUID_NULL,                     // NODE_TYPE_DEV_SPEC
                           0,
                           NULL,
                           0, NULL )

};

/*

    a[KSPROPERTY_AUDIO_POSITION]              = NODE_TYPE_NONE; \
    a[KSPROPERTY_AUDIO_DYNAMIC_RANGE]         = NODE_TYPE_NONE; \
    a[KSPROPERTY_AUDIO_SAMPLING_RATE]         = NODE_TYPE_SRC; \
    a[KSPROPERTY_AUDIO_DYNAMIC_SAMPLING_RATE] = NODE_TYPE_SRC; \
    a[KSPROPERTY_AUDIO_DELAY]                 = NODE_TYPE_DELAY; \
    a[KSPROPERTY_AUDIO_WIDE_MODE]             = NODE_TYPE_STEREO_WIDE; \
    a[KSPROPERTY_AUDIO_WIDENESS]              = NODE_TYPE_STEREO_WIDE; \
    a[KSPROPERTY_AUDIO_REVERB_LEVEL]          = NODE_TYPE_REVERB; \
    a[KSPROPERTY_AUDIO_CHORUS_LEVEL]          = NODE_TYPE_CHORUS; \
    a[KSPROPERTY_AUDIO_DEV_SPECIFIC]          = NODE_TYPE_DEV_SPEC; \
    a[KSPROPERTY_AUDIO_DEMUX_DEST]            = NODE_TYPE_NONE; \
    a[KSPROPERTY_AUDIO_STEREO_ENHANCE]        = NODE_TYPE_NONE; \
    a[KSPROPERTY_AUDIO_MANUFACTURE_GUID]      = NODE_TYPE_NONE; \
    a[KSPROPERTY_AUDIO_PRODUCT_GUID]          = NODE_TYPE_NONE; \
    a[KSPROPERTY_AUDIO_CPU_RESOURCES]         = NODE_TYPE_NONE; \
    a[KSPROPERTY_AUDIO_STEREO_SPEAKER_GEOMETRY] = NODE_TYPE_NONE; \
    a[KSPROPERTY_AUDIO_SURROUND_ENCODE]       = NODE_TYPE_NONE; \
    a[KSPROPERTY_AUDIO_3D_INTERFACE]          = NODE_TYPE_NONE; \

*/
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\drivers\usbaudio.2\topology.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 2000
//
//  File:       topology.c
//
//--------------------------------------------------------------------------

#include "common.h"
#include "nameguid.h"

static GUID USBNODENAME_BassBoost = {STATIC_USBNODENAME_BassBoost};

// Map of Audio properties to nodes
ULONG MapPropertyToNode[KSPROPERTY_AUDIO_3D_INTERFACE+1];

#if DBG
//#define TOPODBG
#endif

#ifdef TOPODBG

#define NUM_CATEGORIES  10
#define NUM_NODETYPES   15

struct {
        CONST GUID *apguidCategory;
        char *CategoryString;
} CategoryLookupTable[NUM_CATEGORIES] = {
    { &KSCATEGORY_AUDIO,              "Audio" },
    { &KSCATEGORY_BRIDGE,             "Bridge" },
    { &KSCATEGORY_RENDER,             "Render" },
    { &KSCATEGORY_CAPTURE,            "Capture"},
    { &KSCATEGORY_MIXER,              "Mixer"  },
    { &KSCATEGORY_DATATRANSFORM,      "Data Transform" },
    { &KSCATEGORY_INTERFACETRANSFORM, "Interface Transform"},
    { &KSCATEGORY_MEDIUMTRANSFORM,    "Medium Transform" },
    { &KSCATEGORY_DATACOMPRESSOR,     "Data Compressor" },
    { &KSCATEGORY_DATADECOMPRESSOR,   "Data Decompressor" }
};

struct {
        CONST GUID *Guid;
        char *String;
} NodeLookupTable[NUM_NODETYPES] = {
    { &KSNODETYPE_DAC,          "DAC" },
    { &KSNODETYPE_ADC,          "ADC" },
    { &KSNODETYPE_SRC,          "SRC" },
    { &KSNODETYPE_SUPERMIX,     "SuperMIX"},
    { &KSNODETYPE_SUM,          "Sum" },
    { &KSNODETYPE_MUTE,         "Mute"},
    { &KSNODETYPE_VOLUME,       "Volume" },
    { &KSNODETYPE_TONE,         "Tone" },
    { &KSNODETYPE_AGC,          "AGC" },
    { &KSNODETYPE_DELAY,        "Delay" },
    { &KSNODETYPE_MUX,          "Mux" },
    { &KSNODETYPE_LOUDNESS,     "Loudness" },
    { &KSNODETYPE_DEV_SPECIFIC, "Device Specific" },
    { &KSNODETYPE_STEREO_WIDE,  "Stereo Extender" },
    { &KSNODETYPE_EQUALIZER,    "Graphic Equalizer" }

};

DbugDumpTopology( PKSFILTER_DESCRIPTOR pFilterDesc )
{
    PTOPOLOGY_NODE_INFO pNodeDescriptors = (PTOPOLOGY_NODE_INFO)pFilterDesc->NodeDescriptors;
    const KSTOPOLOGY_CONNECTION* pConnection = pFilterDesc->Connections;
    ULONG i,j;
    ULONG OldLvl = USBAudioDebugLevel;

    USBAudioDebugLevel = 3;

    for (i=0;i<pFilterDesc->CategoriesCount;i++) {
        for ( j=0;j<NUM_CATEGORIES; j++)
           if ( IsEqualGUID( &pFilterDesc->Categories[i], CategoryLookupTable[j].apguidCategory ) )
               _DbgPrintF(DEBUGLVL_VERBOSE,("Category: %s\n",CategoryLookupTable[j].CategoryString ))
    }

    for (i=0;i<pFilterDesc->NodeDescriptorsCount;i++) {
        for ( j=0;j<NUM_NODETYPES; j++)
           if ( IsEqualGUID( pNodeDescriptors[i].KsNodeDesc.Type, NodeLookupTable[j].Guid ) )
               _DbgPrintF(DEBUGLVL_VERBOSE,("Node[%d]: %s\n",i,NodeLookupTable[j].String ))
    }

    for (i=0;i<pFilterDesc->ConnectionsCount;i++) {
        _DbgPrintF(DEBUGLVL_VERBOSE,("FromNode:%4d FromPin:%4d -->ToNode:%4d ToPin:%4d\n",
                      pConnection->FromNode,
                      pConnection->FromNodePin,
                      pConnection->ToNode,
                      pConnection->ToNodePin ));
        pConnection++;
    }

    USBAudioDebugLevel = OldLvl;

}
#endif


ULONG
ConvertTermTypeToNodeType(
    WORD wTerminalType,
    GUID *TopologyNode,
    GUID *TopologyNodeName,
    UCHAR DescriptorSubtype
    )
{
    ULONG NodeType = NODE_TYPE_NONE;

    if (wTerminalType == USB_Streaming) {
        // All endpoints support SRC
        *TopologyNode = KSNODETYPE_SRC;
        NodeType = NODE_TYPE_SRC;
    }
    else {

        switch (wTerminalType & 0xFF00) {
            case Input_Mask:
                *TopologyNode = KSNODETYPE_ADC;
                NodeType = NODE_TYPE_ADC;
                break;
            case Output_Mask:
                *TopologyNode = KSNODETYPE_DAC;
                NodeType = NODE_TYPE_DAC;
                break;
            case Bidirectional_Mask:
            case External_Mask:
                switch (DescriptorSubtype) {
                    case INPUT_TERMINAL:
                        *TopologyNode = KSNODETYPE_ADC;
                        NodeType = NODE_TYPE_ADC;
                        break;
                    case OUTPUT_TERMINAL:
                        *TopologyNode = KSNODETYPE_DAC;
                        NodeType = NODE_TYPE_DAC;
                        break;
                    default:
                        *TopologyNode = KSNODETYPE_DEV_SPECIFIC;
                        NodeType = NODE_TYPE_DEV_SPEC;
                        break;
                }
                break;
            case Embedded_Mask:
                switch (wTerminalType) {
                    case Level_Calibration_Noise_Source:
                    case Equalization_Noise:
                    case Radio_Transmitter:
                        *TopologyNode = KSNODETYPE_DAC;
                        NodeType = NODE_TYPE_DAC;
                        break;
                    case CD_player:
                    case Phonograph:
                    case Video_Disc_Audio:
                    case DVD_Audio:
                    case TV_Tuner_Audio:
                    case Satellite_Receiver_Audio:
                    case Cable_Tuner_Audio:
                    case DSS_Audio:
                    case Radio_Receiver:
                    case Synthesizer:
                        *TopologyNode = KSNODETYPE_ADC;
                        NodeType = NODE_TYPE_ADC;
                        break;
                    default:
                        // TODO: We need to define a "source or sink" node
                        *TopologyNode = KSNODETYPE_DEV_SPECIFIC;
                        NodeType = NODE_TYPE_DEV_SPEC;
                        break;
                }
                break;
            default:
                // This node has no corresponding guid.
                *TopologyNode = KSNODETYPE_DEV_SPECIFIC;
                NodeType = NODE_TYPE_DEV_SPEC;
                break;
        }
    }

   *TopologyNodeName = *TopologyNode;
    return NodeType;
}

VOID
ProcessMIDIOutJack( PHW_DEVICE_EXTENSION pHwDevExt,
                    PMIDISTREAMING_MIDIOUT_JACK pMIDIOutJack,
                    PKSTOPOLOGY_CONNECTION pConnections,
                    PULONG pConnectionIndex,
                    ULONG pMIDIStreamingPinStartIndex,
                    PULONG pMIDIStreamingPinCurrentIndex,
                    ULONG pBridgePinStartIndex,
                    PULONG pBridgePinCurrentIndex)
{
    ULONG i;
    PKSTOPOLOGY_CONNECTION pConnection = pConnections + *pConnectionIndex;

    for ( i=0; i < pMIDIOutJack->bNrInputPins; i++ ) {

        if ( pMIDIOutJack->bJackType == JACK_TYPE_EMBEDDED ) {
            pConnection->ToNodePin = (*pMIDIStreamingPinCurrentIndex)++;
            pConnection->FromNodePin = GetPinNumberForMIDIJack(
                                             pHwDevExt->pConfigurationDescriptor,
                                             pMIDIOutJack->baSourceConnections[i].SourceID,
                                             pMIDIStreamingPinStartIndex,
                                             pBridgePinStartIndex);
        } else {
            pConnection->ToNodePin = (*pBridgePinCurrentIndex)++;
            pConnection->FromNodePin = GetPinNumberForMIDIJack(
                                             pHwDevExt->pConfigurationDescriptor,
                                             pMIDIOutJack->baSourceConnections[i].SourceID,
                                             pMIDIStreamingPinStartIndex,
                                             pBridgePinStartIndex);
        }

        // Make the connection to this node
        pConnection->FromNode  = KSFILTER_NODE;
        pConnection->ToNode    = KSFILTER_NODE;

        pConnection++;
        (*pConnectionIndex)++;
    }
}

VOID
ProcessInputTerminalUnit( PKSDEVICE pKsDevice,
                          PAUDIO_UNIT pUnit,
                          PTOPOLOGY_NODE_INFO pTopologyNodeInfo,
                          PKSTOPOLOGY_CONNECTION pConnections,
                          PULONG pNodeIndex,
                          PULONG pConnectionIndex,
                          PULONG pBridgePinIndex )
{
    PHW_DEVICE_EXTENSION pHwDevExt = pKsDevice->Context;
    PAUDIO_INPUT_TERMINAL pInput = (PAUDIO_INPUT_TERMINAL)pUnit;
    PTOPOLOGY_NODE_INFO pNodeInfo = pTopologyNodeInfo + *pNodeIndex;
    PKSTOPOLOGY_CONNECTION pConnection = pConnections + *pConnectionIndex;

    pNodeInfo->pUnit = pInput;
    pNodeInfo->ulNodeType =
                 ConvertTermTypeToNodeType( pInput->wTerminalType,
                                            (GUID *)pNodeInfo->KsNodeDesc.Type,
                                            (GUID *)pNodeInfo->KsNodeDesc.Name,
                                            pInput->bDescriptorSubtype );

    // If this is a "real" pin, find FromNodePin.
    if ( pInput->wTerminalType == USB_Streaming ) {
        pConnection->FromNodePin = GetPinNumberForStreamingTerminalUnit(
                                             pHwDevExt->pConfigurationDescriptor,
                                             pInput->bUnitID );
    }
    else {
        // This is an input terminal from the next bridge pin
        pConnection->FromNodePin = (*pBridgePinIndex)++;
    }

    // Make the connection to this node
    pConnection->FromNode  = KSFILTER_NODE;
    pConnection->ToNode    = (*pNodeIndex)++;
    pConnection->ToNodePin = 1;
    (*pConnectionIndex)++;
}

VOID 
ProcessOutputTerminalUnit( PKSDEVICE pKsDevice,
                           PAUDIO_UNIT pUnit,
                           PTOPOLOGY_NODE_INFO pTopologyNodeInfo,
                           PKSTOPOLOGY_CONNECTION pConnections,
                           PULONG pNodeIndex,
                           PULONG pConnectionIndex,
                           PULONG pBridgePinIndex )
{
    PHW_DEVICE_EXTENSION pHwDevExt = pKsDevice->Context;
    PAUDIO_OUTPUT_TERMINAL pOutput = (PAUDIO_OUTPUT_TERMINAL)pUnit;
                           
    PTOPOLOGY_NODE_INFO pNodeInfo = pTopologyNodeInfo + *pNodeIndex;
    PKSTOPOLOGY_CONNECTION pConnection = pConnections + *pConnectionIndex;

    pNodeInfo->pUnit = pOutput;
    pNodeInfo->ulNodeType =
                 ConvertTermTypeToNodeType( pOutput->wTerminalType,
                                            (GUID *)pNodeInfo->KsNodeDesc.Type,
                                            (GUID *)pNodeInfo->KsNodeDesc.Name,
                                            pOutput->bDescriptorSubtype );

    // Make the connection to this node
    pConnection->FromNode    = pOutput->bSourceID;
    pConnection->FromNodePin = 0;
    pConnection->ToNode      = (*pNodeIndex)++;
    pConnection->ToNodePin   = 1;
    pConnection++; (*pConnectionIndex)++;

    // If this is a "real" pin, find ToNodePin.
    if ( pOutput->wTerminalType == USB_Streaming) {
        pConnection->ToNodePin =
            GetPinNumberForStreamingTerminalUnit( pHwDevExt->pConfigurationDescriptor,
                                                  pOutput->bUnitID );
    }
    else { // Not a streaming terminal
        // This is an output terminal to the next bridge pin
        pConnection->ToNodePin = (*pBridgePinIndex)++;
    }

    // Make the connection to the outside world
    pConnection->FromNode    = pOutput->bUnitID;
    pConnection->FromNodePin = 0;
    pConnection->ToNode      = KSFILTER_NODE;
    (*pConnectionIndex)++;

}

VOID 
ProcessMixerUnit( PKSDEVICE pKsDevice,
                  PAUDIO_UNIT pUnit,
                  PTOPOLOGY_NODE_INFO pTopologyNodeInfo,
                  PKSTOPOLOGY_CONNECTION pConnections,
                  PULONG pNodeIndex,
                  PULONG pConnectionIndex,
                  PULONG pBridgePinIndex )
{
    PHW_DEVICE_EXTENSION pHwDevExt = pKsDevice->Context;
    PAUDIO_MIXER_UNIT pMixer = (PAUDIO_MIXER_UNIT)pUnit;

    PTOPOLOGY_NODE_INFO pNodeInfo = pTopologyNodeInfo + *pNodeIndex;
    PKSTOPOLOGY_CONNECTION pConnection = pConnections + *pConnectionIndex;
    ULONG i;

    // Each input stream has a super-mixer
    for (i=0; i<pMixer->bNrInPins; i++) {
        pNodeInfo->pUnit           = pMixer;
        pNodeInfo->ulPinNumber     = i;
        pNodeInfo->ulNodeType      = NODE_TYPE_SUPERMIX;
        pNodeInfo->KsNodeDesc.Type = &KSNODETYPE_SUPERMIX;
        pNodeInfo->KsNodeDesc.Name = &KSNODETYPE_SUPERMIX;
        pNodeInfo->MapNodeToCtrlIF =
                               GetUnitControlInterface( pHwDevExt, pMixer->bUnitID );

        pConnection->FromNode    = pMixer->baSourceID[i];
        pConnection->FromNodePin = 0;
        pConnection->ToNode      = *pNodeIndex;
        pConnection->ToNodePin   = 1;
        pNodeInfo++; (*pNodeIndex)++;
        pConnection++; (*pConnectionIndex)++;
    }

    // All the super-mix outputs are summed.
    pNodeInfo->pUnit           = pMixer;
    pNodeInfo->ulNodeType      = NODE_TYPE_SUM;
    pNodeInfo->KsNodeDesc.Type = &KSNODETYPE_SUM;
    pNodeInfo->KsNodeDesc.Type = &KSNODETYPE_SUM;
    for (i=0; i<pMixer->bNrInPins; i++) {
        pConnection->FromNode    = (ABSOLUTE_NODE_FLAG | (*pNodeIndex-1-i));
        pConnection->FromNodePin = 0;
        pConnection->ToNode      = *pNodeIndex;
        pConnection->ToNodePin   = 1;
        pConnection++; (*pConnectionIndex)++;
    }
    (*pNodeIndex)++;
}

VOID 
ProcessSelectorUnit( PKSDEVICE pKsDevice,
                     PAUDIO_UNIT pUnit,
                     PTOPOLOGY_NODE_INFO pTopologyNodeInfo,
                     PKSTOPOLOGY_CONNECTION pConnections,
                     PULONG pNodeIndex,
                     PULONG pConnectionIndex,
                     PULONG pBridgePinIndex )
{
    PHW_DEVICE_EXTENSION pHwDevExt = pKsDevice->Context;
    PAUDIO_SELECTOR_UNIT pSelector = (PAUDIO_SELECTOR_UNIT)pUnit;

    PTOPOLOGY_NODE_INFO pNodeInfo = pTopologyNodeInfo + *pNodeIndex;
    PKSTOPOLOGY_CONNECTION pConnection = pConnections + *pConnectionIndex;
    ULONG i;

    pNodeInfo->pUnit            = pSelector;
    pNodeInfo->KsNodeDesc.Type  = &KSNODETYPE_MUX;
    pNodeInfo->KsNodeDesc.Name  = &KSNODETYPE_MUX;
    pNodeInfo->ulNodeType       = NODE_TYPE_MUX;
    pNodeInfo->MapNodeToCtrlIF  = 
             GetUnitControlInterface( pHwDevExt, pSelector->bUnitID );

    for (i=0; i<pSelector->bNrInPins; i++) {
        pConnection->FromNode = pSelector->baSourceID[i];
        pConnection->FromNodePin = 0;
        pConnection->ToNode = *pNodeIndex;
        pConnection->ToNodePin = 1+i;
        pConnection++; (*pConnectionIndex)++;
    }
    (*pNodeIndex)++;
}

VOID
ProcessFeatureUnit( PKSDEVICE pKsDevice,
                    PAUDIO_UNIT pUnit,
                    PTOPOLOGY_NODE_INFO pNodeInfo,
                    PKSTOPOLOGY_CONNECTION pConnections,
                    PULONG pNodeIndex,
                    PULONG pConnectionIndex,
                    PULONG pBridgePinIndex )
{
    PHW_DEVICE_EXTENSION pHwDevExt = pKsDevice->Context;
    PAUDIO_FEATURE_UNIT pFeature = (PAUDIO_FEATURE_UNIT)pUnit;

    PKSTOPOLOGY_CONNECTION pConnection = pConnections + *pConnectionIndex;
    ULONG ulConnectionsCount = *pConnectionIndex;
    ULONG ulNodeNumber       = *pNodeIndex;

    PULONG pChannelCntrls;
    ULONG ulCurControlChannels;
    ULONG ulNumChannels;
    ULONG ulMergedControls;
    ULONG ulCurrentControl;
    ULONG bmChannelConfig;
    ULONG ulSourceNode;
    ULONG bmControls;
    size_t i, j;

    ulNumChannels = CountInputChannels(pHwDevExt->pConfigurationDescriptor, pFeature->bUnitID);

    pChannelCntrls = AllocMem( NonPagedPool, (ulNumChannels+1)*sizeof(ULONG) );
    if ( !pChannelCntrls ) return;

    bmChannelConfig = GetChannelConfigForUnit( pHwDevExt->pConfigurationDescriptor, pFeature->bUnitID);

    // For the sake of simplicity, we create a super-set of all controls available on all channels.
    ulMergedControls = 0;

    for ( i=0; i<=ulNumChannels; i++ ) {
        bmControls = 0;
        for ( j=pFeature->bControlSize; j>0; j-- ) {
            bmControls <<= 8;
            bmControls |= pFeature->bmaControls[i*pFeature->bControlSize+j-1];
        }

        pChannelCntrls[i] = bmControls;
        ulMergedControls |= bmControls;
    }

    ulSourceNode = pFeature->bSourceID;
    while ( ulMergedControls ) {
        ulCurrentControl = ulMergedControls - (ulMergedControls & (ulMergedControls-1));
        ulMergedControls = (ulMergedControls & (ulMergedControls-1));

        // Determine which channels this control is valid for
        ulCurControlChannels = 0;
        pNodeInfo[ulNodeNumber].ulChannelConfig = 0;
        for ( i=0; i<=ulNumChannels; i++ ) {

            DbgLog("pChanI0", ulNodeNumber, i, pChannelCntrls[i], ulCurrentControl );

            if (pChannelCntrls[i] & ulCurrentControl) {
                // Determine which Channel pChannelCntrls[i] reflects

                // NEED TO SHIFT bmChannelConfig and ADD 1 for omnipresent master channel
                ULONG ulTmpConfig = (bmChannelConfig<<1)+1;
                ULONG ulCurChannel = ulTmpConfig - (ulTmpConfig & (ulTmpConfig-1));

                ulCurControlChannels++;
                DbgLog("pChanI1", i, pChannelCntrls[i], ulCurrentControl, ulCurControlChannels );

                for (j=0; j<i; j++) {
                    ulTmpConfig = (ulTmpConfig & (ulTmpConfig-1));
                    ulCurChannel = ulTmpConfig - (ulTmpConfig & (ulTmpConfig-1));
                }

                pNodeInfo[ulNodeNumber].ulChannelConfig |= ulCurChannel;
                DbgLog("pChanI2", j, ulTmpConfig, ulCurChannel, pNodeInfo[ulNodeNumber].ulChannelConfig );
            }
        }

        pNodeInfo[ulNodeNumber].ulChannels = ulCurControlChannels;

        // Make the connection
        pConnection->FromNode    = ulSourceNode;
        pConnection->FromNodePin = 0;
        pConnection->ToNode      = ulNodeNumber;
        pConnection->ToNodePin   = 1;
        pConnection++; ulConnectionsCount++;

        // Make the node
        pNodeInfo[ulNodeNumber].MapNodeToCtrlIF =
                               GetUnitControlInterface( pHwDevExt, pFeature->bUnitID );
        pNodeInfo[ulNodeNumber].pUnit = pFeature;
        switch ( ulCurrentControl ) {
            case MUTE_FLAG:
                pNodeInfo[ulNodeNumber].KsNodeDesc.Type = &KSNODETYPE_MUTE;
                pNodeInfo[ulNodeNumber].KsNodeDesc.Name = &KSNODETYPE_MUTE;
                pNodeInfo[ulNodeNumber].ulNodeType      = NODE_TYPE_MUTE;
                pNodeInfo[ulNodeNumber].ulControlType   = MUTE_CONTROL;
                break;
            case VOLUME_FLAG:
                pNodeInfo[ulNodeNumber].KsNodeDesc.Type = &KSNODETYPE_VOLUME;
                pNodeInfo[ulNodeNumber].KsNodeDesc.Name = &KSNODETYPE_VOLUME;
                pNodeInfo[ulNodeNumber].ulNodeType      = NODE_TYPE_VOLUME;
                pNodeInfo[ulNodeNumber].ulControlType   = VOLUME_CONTROL;
                break;
            case BASS_BOOST_FLAG:
                pNodeInfo[ulNodeNumber].KsNodeDesc.Type = &KSNODETYPE_TONE;
                pNodeInfo[ulNodeNumber].KsNodeDesc.Name = &USBNODENAME_BassBoost;
                pNodeInfo[ulNodeNumber].ulNodeType      = NODE_TYPE_BASS_BOOST;
                pNodeInfo[ulNodeNumber].ulControlType   = BASS_BOOST_CONTROL;
                break;
            case TREBLE_FLAG:
                pNodeInfo[ulNodeNumber].KsNodeDesc.Type = &KSNODETYPE_TONE;
                pNodeInfo[ulNodeNumber].KsNodeDesc.Name = &KSNODETYPE_TONE;
                pNodeInfo[ulNodeNumber].ulNodeType      = NODE_TYPE_TREBLE;
                pNodeInfo[ulNodeNumber].ulControlType   = TREBLE_CONTROL;
                break;
            case MID_FLAG:
                pNodeInfo[ulNodeNumber].KsNodeDesc.Type = &KSNODETYPE_TONE;
                pNodeInfo[ulNodeNumber].KsNodeDesc.Name = &KSNODETYPE_TONE;
                pNodeInfo[ulNodeNumber].ulNodeType      = NODE_TYPE_MID;
                pNodeInfo[ulNodeNumber].ulControlType   = MID_CONTROL;
                break;
            case BASS_FLAG:
                pNodeInfo[ulNodeNumber].KsNodeDesc.Type = &KSNODETYPE_TONE;
                pNodeInfo[ulNodeNumber].KsNodeDesc.Name = &KSNODETYPE_TONE;
                pNodeInfo[ulNodeNumber].ulNodeType      = NODE_TYPE_BASS;
                pNodeInfo[ulNodeNumber].ulControlType   = BASS_CONTROL;
                break;
            case GRAPHIC_EQUALIZER_FLAG:
                pNodeInfo[ulNodeNumber].KsNodeDesc.Type = &KSNODETYPE_EQUALIZER;
                pNodeInfo[ulNodeNumber].KsNodeDesc.Name = &KSNODETYPE_EQUALIZER;
                pNodeInfo[ulNodeNumber].ulNodeType      = NODE_TYPE_EQUALIZER;
                pNodeInfo[ulNodeNumber].ulControlType   = GRAPHIC_EQUALIZER_CONTROL;
                break;
            case AUTOMATIC_GAIN_FLAG:
                pNodeInfo[ulNodeNumber].KsNodeDesc.Type = &KSNODETYPE_AGC;
                pNodeInfo[ulNodeNumber].KsNodeDesc.Name = &KSNODETYPE_AGC;
                pNodeInfo[ulNodeNumber].ulNodeType     = NODE_TYPE_AGC;
                pNodeInfo[ulNodeNumber].ulControlType  = AUTOMATIC_GAIN_CONTROL;
                break;
            case DELAY_FLAG:
                pNodeInfo[ulNodeNumber].KsNodeDesc.Type = &KSNODETYPE_DELAY;
                pNodeInfo[ulNodeNumber].KsNodeDesc.Name = &KSNODETYPE_DELAY;
                pNodeInfo[ulNodeNumber].ulNodeType     = NODE_TYPE_DELAY;
                pNodeInfo[ulNodeNumber].ulControlType  = DELAY_CONTROL;
                break;
            case LOUDNESS_FLAG:
                pNodeInfo[ulNodeNumber].KsNodeDesc.Type = &KSNODETYPE_LOUDNESS;
                pNodeInfo[ulNodeNumber].KsNodeDesc.Name = &KSNODETYPE_LOUDNESS;
                pNodeInfo[ulNodeNumber].ulNodeType     = NODE_TYPE_LOUDNESS;
                pNodeInfo[ulNodeNumber].ulControlType  = LOUDNESS_CONTROL;
                break;
            default:
                pNodeInfo[ulNodeNumber].KsNodeDesc.Type = &KSNODETYPE_DEV_SPECIFIC;
                pNodeInfo[ulNodeNumber].KsNodeDesc.Name = &KSNODETYPE_DEV_SPECIFIC;
                pNodeInfo[ulNodeNumber].ulNodeType     = NODE_TYPE_DEV_SPEC;
                pNodeInfo[ulNodeNumber].ulControlType  = DEV_SPECIFIC_CONTROL;
                break;
        }

        // Setup Control Caches for Mixerline support
        switch ( ulCurrentControl ) {
            case VOLUME_FLAG:
            case TREBLE_FLAG:
            case MID_FLAG:
            case BASS_FLAG:
            case DELAY_FLAG:
               {
                PDB_LEVEL_CACHE pRngeCache =
                      AllocMem( NonPagedPool, ulCurControlChannels * sizeof(DB_LEVEL_CACHE) );
                ULONG ulChannelMap = pNodeInfo[ulNodeNumber].ulChannelConfig;
                NTSTATUS ntStatus;

                // Fill in initial cache info
                pNodeInfo[ulNodeNumber].ulCacheValid      = FALSE;
                pNodeInfo[ulNodeNumber].pCachedValues     = pRngeCache;
                pNodeInfo[ulNodeNumber].ulNumCachedValues = ulCurControlChannels;
                for (i=0, j=-1; i<ulCurControlChannels; i++ ) {
                    while ( !(pChannelCntrls[++j] & ulCurrentControl) );
                    pRngeCache[i].ulChannelIndex  = j;
                    pRngeCache[i].ulChannelNumber = (ulChannelMap - (ulChannelMap & (ulChannelMap-1)))>>1;
                    ulChannelMap = (ulChannelMap & (ulChannelMap-1));
                    ntStatus = InitializeDbLevelCache( pKsDevice->NextDeviceObject,
                                                       &pNodeInfo[ulNodeNumber],
                                                       &pRngeCache[i],
                                                       (ulCurrentControl == VOLUME_FLAG ) ? 16:8);
                    if (NT_SUCCESS(ntStatus)) {
                        pNodeInfo[ulNodeNumber].ulCacheValid |= 1<<i;
                    }
                }
                // Bag the cache for easy cleanup.
                KsAddItemToObjectBag(pKsDevice->Bag, pRngeCache, FreeMem);

                DbgLog("DBCache", pRngeCache, ulNodeNumber, ulCurrentControl, ulCurControlChannels );

               } break;

            case MUTE_FLAG:
            case BASS_BOOST_FLAG:
            case AUTOMATIC_GAIN_FLAG:
            case LOUDNESS_FLAG:
               {
                PBOOLEAN_CTRL_CACHE pBCache =
                      AllocMem( NonPagedPool, ulCurControlChannels * sizeof(BOOLEAN_CTRL_CACHE) );
                ULONG ulChannelMap = pNodeInfo[ulNodeNumber].ulChannelConfig;

                // Fill in initial cache info
                pNodeInfo[ulNodeNumber].ulCacheValid      = FALSE;
                pNodeInfo[ulNodeNumber].pCachedValues     = pBCache;
                pNodeInfo[ulNodeNumber].ulNumCachedValues = ulCurControlChannels;

                for (i=0, j=-1; i<ulCurControlChannels; i++ ) {
                    while ( !(pChannelCntrls[++j] & ulCurrentControl) );
                    pBCache[i].ulChannelIndex  = j;
                    pBCache[i].ulChannelNumber = (ulChannelMap - (ulChannelMap & (ulChannelMap-1)))>>1;
                    ulChannelMap = (ulChannelMap & (ulChannelMap-1));
                }

                // Bag the cache for easy cleanup.
                KsAddItemToObjectBag(pKsDevice->Bag, pBCache, FreeMem);

                // ensure that no mute nodes are set upon enumeration
                if ( ulCurrentControl == MUTE_FLAG ) {
                    NTSTATUS NtStatus;
                    ULONG UnMute = 0;

                    NtStatus = GetSetByte( pKsDevice->NextDeviceObject,
                                &pNodeInfo[ulNodeNumber],
                                pBCache->ulChannelIndex,
                                &UnMute,
                                SET_CUR );
                }

                DbgLog("BlCache", pBCache, ulNodeNumber, ulCurrentControl, ulCurControlChannels );

               } break;
            case GRAPHIC_EQUALIZER_FLAG:
               // Currently GEQ is not Cached
            default:
                 break;
        }

        ulSourceNode = ( ABSOLUTE_NODE_FLAG | ulNodeNumber++ );
    }

    *pNodeIndex       = ulNodeNumber;
    *pConnectionIndex = ulConnectionsCount;

    FreeMem(pChannelCntrls);

}

#define MAX_PROCESS_CONTROLS 6
ULONG ProcessUnitControlsMap[DYN_RANGE_COMP_PROCESS+1][MAX_PROCESS_CONTROLS] =
    { { 0, 0, 0, 0, 0, 0 },       // No 0 Process
      { UD_ENABLE_CONTROL,
        UD_MODE_SELECT_CONTROL },
      { DP_ENABLE_CONTROL,
        DP_MODE_SELECT_CONTROL },
      { ENABLE_CONTROL,
        SPACIOUSNESS_CONTROL },
      { RV_ENABLE_CONTROL,
        0,                        // Reverb Type Control Undefined in spec
        REVERB_LEVEL_CONTROL,
        REVERB_TIME_CONTROL,
        REVERB_FEEDBACK_CONTROL },
      { CH_ENABLE_CONTROL,
        CHORUS_LEVEL_CONTROL,
        CHORUS_RATE_CONTROL,
        CHORUS_DEPTH_CONTROL },
      { DR_ENABLE_CONTROL,
        COMPRESSION_RATE_CONTROL,
        MAXAMPL_CONTROL,
        THRESHOLD_CONTROL,
        ATTACK_TIME,
        RELEASE_TIME } };


VOID
ProcessProcessingUnit( PKSDEVICE pKsDevice,
                       PAUDIO_UNIT pUnit,
                       PTOPOLOGY_NODE_INFO pTopologyNodeInfo,
                       PKSTOPOLOGY_CONNECTION pConnections,
                       PULONG pNodeIndex,
                       PULONG pConnectionIndex,
                       PULONG pBridgePinIndex )
{
    PAUDIO_PROCESSING_UNIT pProcessor = (PAUDIO_PROCESSING_UNIT)pUnit;
    PTOPOLOGY_NODE_INFO pNodeInfo = pTopologyNodeInfo + *pNodeIndex;
    PKSTOPOLOGY_CONNECTION pConnection = pConnections + *pConnectionIndex;
    PHW_DEVICE_EXTENSION pHwDevExt = pKsDevice->Context;
    ULONG ulConnectionsCount = *pConnectionIndex;
    PAUDIO_CHANNELS pAudioChannels;
    PPROCESS_CTRL_CACHE pPCtrlCache;
    ULONG ulCacheSize = 0;
    ULONG i, j;

    pNodeInfo->pUnit = pProcessor;
    pNodeInfo->MapNodeToCtrlIF =
                   GetUnitControlInterface( pHwDevExt, pProcessor->bUnitID );

    switch ( pProcessor->wProcessType ) {
        case UP_DOWNMIX_PROCESS:
            pNodeInfo->KsNodeDesc.Type = &KSNODETYPE_SUPERMIX;
            pNodeInfo->KsNodeDesc.Name = &KSNODETYPE_SUPERMIX;
            pNodeInfo->ulNodeType      = NODE_TYPE_SUPERMIX;
            break;

        case DOLBY_PROLOGIC_PROCESS:
            pNodeInfo->KsNodeDesc.Type = &KSNODETYPE_PROLOGIC_DECODER;
            pNodeInfo->KsNodeDesc.Name = &KSNODETYPE_PROLOGIC_DECODER;
            pNodeInfo->ulNodeType      = NODE_TYPE_PROLOGIC;
            break;

        case STEREO_EXTENDER_PROCESS:
            pNodeInfo->KsNodeDesc.Type = &KSNODETYPE_STEREO_WIDE;
            pNodeInfo->KsNodeDesc.Name = &KSNODETYPE_STEREO_WIDE;
            pNodeInfo->ulNodeType      = NODE_TYPE_STEREO_WIDE;
            pNodeInfo->ulControlType   = SPACIOUSNESS_CONTROL;
            break;

        case REVERBERATION_PROCESS:
            pNodeInfo->KsNodeDesc.Type = &KSNODETYPE_REVERB;
            pNodeInfo->KsNodeDesc.Name = &KSNODETYPE_REVERB;
            pNodeInfo->ulNodeType      = NODE_TYPE_REVERB;
            pNodeInfo->ulControlType   = REVERB_LEVEL_CONTROL;
            break;

        case CHORUS_PROCESS:
            pNodeInfo->KsNodeDesc.Type = &KSNODETYPE_CHORUS;
            pNodeInfo->KsNodeDesc.Name = &KSNODETYPE_CHORUS;
            pNodeInfo->ulNodeType      = NODE_TYPE_CHORUS;
            pNodeInfo->ulControlType   = CHORUS_LEVEL_CONTROL;
            break;

        // TODO: Need to support Compressor Processing Unit correctly.
        //       Using loudness just won't cut it.
        case DYN_RANGE_COMP_PROCESS:
            pNodeInfo->KsNodeDesc.Type = &KSNODETYPE_LOUDNESS;
            pNodeInfo->KsNodeDesc.Name = &KSNODETYPE_LOUDNESS;
            pNodeInfo->ulNodeType      = NODE_TYPE_LOUDNESS;
            pNodeInfo->ulControlType   = LOUDNESS_CONTROL;
            break;

        default:
            pNodeInfo->KsNodeDesc.Type = &KSNODETYPE_DEV_SPECIFIC;
            pNodeInfo->KsNodeDesc.Name = &KSNODETYPE_DEV_SPECIFIC;
            pNodeInfo->ulNodeType      = NODE_TYPE_DEV_SPEC;
            pNodeInfo->ulControlType   = DEV_SPECIFIC_CONTROL;
            break;
    }

    // Determine the size of the cache needed for the controls
    ulCacheSize = sizeof(PROCESS_CTRL_CACHE);
    pAudioChannels = (PAUDIO_CHANNELS)(pProcessor->baSourceID + pProcessor->bNrInPins);
    for (i=0; i<pAudioChannels->bControlSize; i++) {
        for (j=1; j<8; j++) {
            if ( pAudioChannels->bmControls[i] & (1<<j))
                ulCacheSize += sizeof(PROCESS_CTRL_RANGE);
        }
    }

    // Allocate and initialize cache
    pPCtrlCache = (PPROCESS_CTRL_CACHE)AllocMem( NonPagedPool, ulCacheSize );
    if ( pPCtrlCache ) {
        PPROCESS_CTRL_RANGE pPCtrlRange = (PPROCESS_CTRL_RANGE)(pPCtrlCache+1);

        pNodeInfo->ulCacheValid  = FALSE;
        pNodeInfo->pCachedValues = pPCtrlCache;

        pPCtrlCache->fEnableBit = pAudioChannels->bmControls[0] & ENABLE_CONTROL;
        if ( pPCtrlCache->fEnableBit ) {
            GetSetProcessingUnitEnable( pKsDevice->NextDeviceObject,
                                        pNodeInfo,
                                        GET_CUR,
                                        &pPCtrlCache->fEnabled );
        }
        else
            pPCtrlCache->fEnabled = TRUE;

        // Determine data ranges for units which allow values.
        switch(pProcessor->wProcessType) {
            case STEREO_EXTENDER_PROCESS:
            case REVERBERATION_PROCESS:
                if (pAudioChannels->bmControls[0] & 2) {
                    GetProcessingUnitRange( pKsDevice->NextDeviceObject,
                                            pNodeInfo,
                                            pNodeInfo->ulControlType,
                                            sizeof(UCHAR),
                                            (0x10000/100),
                                            &pPCtrlRange->Range );

               } break;
            default:
                 break;
        }

        // Bag the cache for easy cleanup.
        KsAddItemToObjectBag(pKsDevice->Bag, pPCtrlCache, FreeMem);

    }

    for (i=0; i<pProcessor->bNrInPins; i++) {
        pConnection->FromNode = pProcessor->baSourceID[i];
        pConnection->FromNodePin = 0;
        pConnection->ToNode = *pNodeIndex;
        pConnection->ToNodePin = 1;
        pConnection++; ulConnectionsCount++;
    }

    *pConnectionIndex = ulConnectionsCount;
    (*pNodeIndex)++;

}

VOID

ProcessExtensionUnit( PKSDEVICE pKsDevice,
                      PAUDIO_UNIT pUnit,
                      PTOPOLOGY_NODE_INFO pTopologyNodeInfo,
                      PKSTOPOLOGY_CONNECTION pConnections,
                      PULONG pNodeIndex,
                      PULONG pConnectionIndex,
                      PULONG pBridgePinIndex )
{
    PAUDIO_EXTENSION_UNIT pExtension = (PAUDIO_EXTENSION_UNIT)pUnit;
    PTOPOLOGY_NODE_INFO pNodeInfo = pTopologyNodeInfo + *pNodeIndex;
    PKSTOPOLOGY_CONNECTION pConnection = pConnections  + *pConnectionIndex;
    ULONG ulConnectionsCount = *pConnectionIndex;
    ULONG i;

    pNodeInfo->pUnit           = pExtension;
    pNodeInfo->KsNodeDesc.Type = &KSNODETYPE_DEV_SPECIFIC;
    pNodeInfo->KsNodeDesc.Name = &KSNODETYPE_DEV_SPECIFIC;
    pNodeInfo->ulNodeType      = NODE_TYPE_DEV_SPEC;
    pNodeInfo->ulControlType   = DEV_SPECIFIC_CONTROL;

    for (i=0; i<pExtension->bNrInPins; i++) {
        pConnection->FromNode = pExtension->baSourceID[i];
        pConnection->FromNodePin = 0;
        pConnection->ToNode = *pNodeIndex;
        pConnection->ToNodePin = 1;
        pConnection++; ulConnectionsCount++;
    }

    *pConnectionIndex = ulConnectionsCount;
    (*pNodeIndex)++;
}

VOID
ProcessUnknownUnit( PKSDEVICE pKsDevice,
                    PAUDIO_UNIT pUnit,
                    PTOPOLOGY_NODE_INFO pTopologyNodeInfo,
                    PKSTOPOLOGY_CONNECTION pConnections,
                    PULONG pNodeIndex,
                    PULONG pConnectionIndex,
                    PULONG pBridgePinIndex )
{
    return;
}


typedef 
VOID 
(*PUNIT_PROCESS_RTN)( PKSDEVICE pKsDevice,
                      PAUDIO_UNIT pUnit,
                      PTOPOLOGY_NODE_INFO pTopologyNodeInfo,
                      PKSTOPOLOGY_CONNECTION pConnections,
                      PULONG pNodeIndex,
                      PULONG pConnectionIndex,
                      PULONG pBridgePinIndex );

PUNIT_PROCESS_RTN
pUnitProcessRtn[MAX_TYPE_UNIT] = {
    ProcessUnknownUnit,
    ProcessUnknownUnit,
    ProcessInputTerminalUnit,
    ProcessOutputTerminalUnit,
    ProcessMixerUnit,
    ProcessSelectorUnit,
    ProcessFeatureUnit,
    ProcessProcessingUnit,
    ProcessExtensionUnit
};

NTSTATUS
BuildUSBAudioFilterTopology( PKSDEVICE pKsDevice )
{
    PHW_DEVICE_EXTENSION pHwDevExt   = pKsDevice->Context;
    PKSFILTER_DESCRIPTOR pFilterDesc = &pHwDevExt->USBAudioFilterDescriptor;

    PUSB_INTERFACE_DESCRIPTOR pControlIFDescriptor;
    PAUDIO_HEADER_UNIT pHeader;
    PUSB_INTERFACE_DESCRIPTOR pMIDIStreamingDescriptor;
    PMIDISTREAMING_GENERAL_STREAM pGeneralMIDIStreamDescriptor;

    union {
        PAUDIO_UNIT                 pUnit;
        PAUDIO_INPUT_TERMINAL       pInput;
        PAUDIO_OUTPUT_TERMINAL      pOutput;
        PAUDIO_MIXER_UNIT           pMixer;
        PAUDIO_PROCESSING_UNIT      pProcessor;
        PAUDIO_EXTENSION_UNIT       pExtension;
        PAUDIO_FEATURE_UNIT         pFeature;
        PAUDIO_SELECTOR_UNIT        pSelector;
        PMIDISTREAMING_ELEMENT      pMIDIElement;
        PMIDISTREAMING_MIDIIN_JACK  pMIDIInJack;
        PMIDISTREAMING_MIDIOUT_JACK pMIDIOutJack;
    } u;

    ULONG ulNumCategories;
    ULONG ulNumNodes;
    ULONG ulNumConnections;
    ULONG bmCategories;

    GUID* pCategoryGUIDs;
    GUID* pTmpGUIDptr;
    PTOPOLOGY_NODE_INFO pNodeDescriptors;
    PKSTOPOLOGY_CONNECTION pConnections;

    ULONG ulNodeIndex = 0;
    ULONG ulConnectionIndex = 0;
    ULONG ulBridgePinCurrentIndex = 0;
    ULONG ulBridgePinStartIndex = 0;
    ULONG ulMIDIStreamingPinCurrentIndex = 0;
    ULONG ulMIDIStreamingPinStartIndex = 0;
    ULONG i;

    _DbgPrintF(DEBUGLVL_VERBOSE,("Building USB Topology\n"));

    // Count Items for Topology Allocation
    CountTopologyComponents( pHwDevExt->pConfigurationDescriptor,
                             &ulNumCategories,
                             &ulNumNodes,
                             &ulNumConnections,
                             &bmCategories );

    ulNumCategories += 1; // Need to add space for KSCATEGORY_AUDIO category

    // Set the Node Descriptor size to be that of the KS descriptor +
    // necessary local information.
    pFilterDesc->NodeDescriptorSize = sizeof(TOPOLOGY_NODE_INFO);

    // Allocate Space for Topology Items
    pCategoryGUIDs =
        AllocMem( NonPagedPool, (ulNumCategories  * sizeof(GUID)) +
                                (ulNumNodes       * ( sizeof(TOPOLOGY_NODE_INFO) +
                                                      sizeof(GUID) +
                                                      sizeof(GUID) ) ) +
                                (ulNumConnections * sizeof(KSTOPOLOGY_CONNECTION)) );
    if ( !pCategoryGUIDs ) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    // Bag the topology for easy cleanup.
    KsAddItemToObjectBag(pKsDevice->Bag, pCategoryGUIDs, FreeMem);

    // Set the pointers to the different topology components
    pNodeDescriptors = (PTOPOLOGY_NODE_INFO)(pCategoryGUIDs + ulNumCategories);
    pConnections = (PKSTOPOLOGY_CONNECTION)(pNodeDescriptors + ulNumNodes);

    pFilterDesc->Categories      = (const GUID*)pCategoryGUIDs;
    pFilterDesc->NodeDescriptors = (const KSNODE_DESCRIPTOR*)pNodeDescriptors;
    pFilterDesc->Connections     = (const KSTOPOLOGY_CONNECTION*)pConnections;

    // Clear all Node info structures
    RtlZeroMemory(pNodeDescriptors, ulNumNodes * sizeof(TOPOLOGY_NODE_INFO));

    // Initialize Node GUID Pointers
    pTmpGUIDptr = (GUID *)(pConnections + ulNumConnections);
    for ( i=0; i<ulNumNodes; i++ ) {
        pNodeDescriptors[i].KsNodeDesc.Type = pTmpGUIDptr++;
        pNodeDescriptors[i].KsNodeDesc.Name = pTmpGUIDptr++;
        pNodeDescriptors[i].KsNodeDesc.AutomationTable = &pNodeDescriptors[i].KsAutomationTable;
    }

    // Fill in Filter Categories
    i=0;
    pCategoryGUIDs[i++] = KSCATEGORY_AUDIO;
    if ( bmCategories & (1<<INPUT_TERMINAL) )
        pCategoryGUIDs[i++] = KSCATEGORY_RENDER;
    if ( bmCategories & (1<<OUTPUT_TERMINAL) )
        pCategoryGUIDs[i++] = KSCATEGORY_CAPTURE;

    ASSERT (i==ulNumCategories);

    pFilterDesc->CategoriesCount = ulNumCategories;

    // Determine first bridge pin number
    {
        PKSPIN_DESCRIPTOR_EX pPinDescriptors = (PKSPIN_DESCRIPTOR_EX)pFilterDesc->PinDescriptors;
        for ( i=0; i<pFilterDesc->PinDescriptorsCount; i++) {
            if (pPinDescriptors[i].PinDescriptor.Communication == KSPIN_COMMUNICATION_BRIDGE)
                break;
        }
        ulBridgePinCurrentIndex = i;
    }

    // For each Audio Control interface find the associated Units and
    // create topology nodes from them
    pControlIFDescriptor = USBD_ParseConfigurationDescriptorEx (
                                   pHwDevExt->pConfigurationDescriptor,
                                   (PVOID)pHwDevExt->pConfigurationDescriptor,
                                   -1,                     // Interface number
                                   -1,                     // Alternate Setting
                                   USB_DEVICE_CLASS_AUDIO, // Audio Class (Interface Class)
                                   AUDIO_SUBCLASS_CONTROL, // control subclass (Interface Sub-Class)
                                   -1 );

    // Now Process each Audio Unit to form the Topology
    while ( pControlIFDescriptor ) {

        pHeader = (PAUDIO_HEADER_UNIT)
                GetAudioSpecificInterface( pHwDevExt->pConfigurationDescriptor,
                                           pControlIFDescriptor,
                                           HEADER_UNIT );

        if (!pHeader) {
            return STATUS_INVALID_DEVICE_REQUEST;
        }

        // Find the first unit.
        u.pUnit = (PAUDIO_UNIT)
                USBD_ParseDescriptors( (PVOID) pHeader,
                                       pHeader->wTotalLength,
                                       (PUCHAR)pHeader + pHeader->bLength,
                                       USB_CLASS_AUDIO | USB_INTERFACE_DESCRIPTOR_TYPE );

        while (u.pUnit) {
            _DbgPrintF(DEBUGLVL_VERBOSE,("'Map Unit: 0x%x\n",u.pUnit->bUnitID));

            pUnitProcessRtn[u.pUnit->bDescriptorSubtype]( pKsDevice,
                                                          u.pUnit,
                                                          pNodeDescriptors,
                                                          pConnections,
                                                          &ulNodeIndex,
                                                          &ulConnectionIndex,
                                                          &ulBridgePinCurrentIndex );
            // Find the next unit.
            u.pUnit = (PAUDIO_UNIT) USBD_ParseDescriptors(
                                (PVOID) pHeader,
                                pHeader->wTotalLength,
                                (PUCHAR)u.pUnit + u.pUnit->bLength,
                                USB_CLASS_AUDIO | USB_INTERFACE_DESCRIPTOR_TYPE );
        }

        // Get the next Control Interface (if any)
        pControlIFDescriptor = USBD_ParseConfigurationDescriptorEx (
                                   pHwDevExt->pConfigurationDescriptor,
                                   ((PUCHAR)pControlIFDescriptor + pControlIFDescriptor->bLength),
                                   -1,                     // Interface number
                                   -1,                     // Alternate Setting
                                   USB_DEVICE_CLASS_AUDIO, // Audio Class (Interface Class)
                                   AUDIO_SUBCLASS_CONTROL, // control subclass (Interface Sub-Class)
                                   -1 );

    }

    // Determine first MIDI bridge pin number (we should have used up all of the audio bridge pins by now)
    {
        PKSPIN_DESCRIPTOR_EX pPinDescriptors = (PKSPIN_DESCRIPTOR_EX)pFilterDesc->PinDescriptors;

        // If this is true, no audio streaming pins were found
        if (i == ulBridgePinCurrentIndex) {
            ulMIDIStreamingPinStartIndex = 0;
            ulMIDIStreamingPinCurrentIndex = 0;
            ulBridgePinStartIndex = ulBridgePinCurrentIndex;
        } else {
            ulMIDIStreamingPinStartIndex = ulBridgePinCurrentIndex;
            ulMIDIStreamingPinCurrentIndex = ulBridgePinCurrentIndex;

            for ( i = ulMIDIStreamingPinStartIndex; i<pFilterDesc->PinDescriptorsCount; i++) {
                if (pPinDescriptors[i].PinDescriptor.Communication == KSPIN_COMMUNICATION_BRIDGE) {
                    ulBridgePinStartIndex = i;
                    ulBridgePinCurrentIndex = i;
                    break;
                }
            }
        }
    }

    _DbgPrintF(DEBUGLVL_VERBOSE,("ulBridgePinStartIndex  : 0x%x\n",ulBridgePinStartIndex));
    _DbgPrintF(DEBUGLVL_VERBOSE,("ulBridgePinCurrentIndex: 0x%x\n",ulBridgePinCurrentIndex));
    _DbgPrintF(DEBUGLVL_VERBOSE,("ulMIDIStreamingPinStartIndex: 0x%x\n",ulMIDIStreamingPinStartIndex));
    _DbgPrintF(DEBUGLVL_VERBOSE,("ulMIDIStreamingPinCurrentIndex: 0x%x\n",ulMIDIStreamingPinCurrentIndex));

    // Now that we have had fun with audio, let's try MIDI
    pMIDIStreamingDescriptor = USBD_ParseConfigurationDescriptorEx (
                         pHwDevExt->pConfigurationDescriptor,
                         (PVOID) pHwDevExt->pConfigurationDescriptor,
                         -1,                     // Interface number
                         -1,                     // Alternate Setting
                         USB_DEVICE_CLASS_AUDIO, // Audio Class (Interface Class)
                         AUDIO_SUBCLASS_MIDISTREAMING,  // first subclass (Interface Sub-Class)
                         -1 ) ;                  // protocol don't care (InterfaceProtocol)

    while (pMIDIStreamingDescriptor) {
        pGeneralMIDIStreamDescriptor = (PMIDISTREAMING_GENERAL_STREAM)
                                  USBD_ParseDescriptors( (PVOID) pHwDevExt->pConfigurationDescriptor,
                                                         pHwDevExt->pConfigurationDescriptor->wTotalLength,
                                                         (PVOID) pMIDIStreamingDescriptor,
                                                         USB_CLASS_AUDIO | USB_INTERFACE_DESCRIPTOR_TYPE );
        if (!pGeneralMIDIStreamDescriptor) {
            return STATUS_INVALID_DEVICE_REQUEST;
        }

        u.pUnit = (PAUDIO_UNIT)
            USBD_ParseDescriptors( (PVOID)pGeneralMIDIStreamDescriptor,
                                   pGeneralMIDIStreamDescriptor->wTotalLength,
                                   ((PUCHAR)pGeneralMIDIStreamDescriptor + pGeneralMIDIStreamDescriptor->bLength),
                                   USB_CLASS_AUDIO | USB_INTERFACE_DESCRIPTOR_TYPE );
        while ( u.pUnit ) {
            _DbgPrintF(DEBUGLVL_VERBOSE,("'Map Unit: 0x%x\n",u.pUnit->bUnitID));
            switch (u.pUnit->bDescriptorSubtype) {
                case MIDI_IN_JACK:
                    _DbgPrintF(DEBUGLVL_VERBOSE,("'MIDI_IN_JACK %d\n",u.pMIDIInJack->bJackID));
                    if (u.pMIDIInJack->bJackType == JACK_TYPE_EMBEDDED) {
                        ulMIDIStreamingPinCurrentIndex++;
                    } else {
                        ulBridgePinCurrentIndex++;
                    }
                    break;

                case MIDI_OUT_JACK:
                    _DbgPrintF(DEBUGLVL_VERBOSE,("'MIDI_OUT_JACK %d\n",u.pMIDIOutJack->bJackID));
                    ProcessMIDIOutJack( pHwDevExt,
                                        u.pMIDIOutJack,
                                        pConnections,
                                        &ulConnectionIndex,
                                        ulMIDIStreamingPinStartIndex,
                                        &ulMIDIStreamingPinCurrentIndex,
                                        ulBridgePinStartIndex,
                                        &ulBridgePinCurrentIndex );
                    break;

                case MIDI_ELEMENT:
                    _DbgPrintF(DEBUGLVL_VERBOSE,("'MIDI_ELEMENT %d\n",u.pMIDIElement->bElementID));
                    //ProcessMIDIElement( pHwDevExt,
                    //                    u.pMIDIElement,
                    //                    pNodeDescriptors,
                    //                    pConnections,
                    //                    &ulNodeIndex,
                    //                    &ulConnectionIndex,
                    //                    &ulBridgePinIndex );
                    break;

                default:
                    break;
            }

            // Find the next unit.
            u.pUnit = (PAUDIO_UNIT) USBD_ParseDescriptors(
                                (PVOID) pGeneralMIDIStreamDescriptor,
                                pGeneralMIDIStreamDescriptor->wTotalLength,
                                (PUCHAR)u.pUnit + u.pUnit->bLength,
                                USB_CLASS_AUDIO | USB_INTERFACE_DESCRIPTOR_TYPE );

        }

        // Get next MIDI Streaming Interface
        pMIDIStreamingDescriptor = USBD_ParseConfigurationDescriptorEx (
                             pHwDevExt->pConfigurationDescriptor,
                             ((PUCHAR)pMIDIStreamingDescriptor + pMIDIStreamingDescriptor->bLength),
                             -1,                     // Interface number
                             -1,                     // Alternate Setting
                             USB_DEVICE_CLASS_AUDIO, // Audio Class (Interface Class)
                             AUDIO_SUBCLASS_MIDISTREAMING,  // next MIDI Streaming Interface (Interface Sub-Class)
                             -1 ) ;                  // protocol don't care (InterfaceProtocol)
    }

    //ASSERT(ulNumConnections == ulConnectionIndex);
    ASSERT(ulNumNodes == ulNodeIndex);

    DbgLog("TopoCnt", ulNumConnections, ulConnectionIndex, ulNumNodes, ulNodeIndex);

    // Set Topology component counts in Filter Descriptor
    pFilterDesc->NodeDescriptorsCount = ulNodeIndex;
    pFilterDesc->ConnectionsCount     = ulConnectionIndex;

    DbgLog("TopoAdr", pFilterDesc->NodeDescriptors, pFilterDesc->Connections, ulConnectionIndex, ulNodeIndex);

    // Fix-up all of the connections to map their node #'s correctly.
    for (i=0; i < ulConnectionIndex; i++) {
        if (pConnections->FromNode != KSFILTER_NODE) {
            if (pConnections->FromNode & ABSOLUTE_NODE_FLAG)
                pConnections->FromNode = (pConnections->FromNode & NODE_MASK);
            else {
                // Find the correct node number for FromNode.
                // Note: if a unit has multiple nodes, the From node is always the last node
                // for that unit.
                for ( ulNodeIndex=ulNumNodes; ulNodeIndex > 0; ulNodeIndex-- ) {
                    if (pConnections->FromNode == (ULONG)
                            ((PAUDIO_UNIT)pNodeDescriptors[ulNodeIndex-1].pUnit)->bUnitID) {
                        pConnections->FromNode = ulNodeIndex-1;
                        break;
                    }
                }
            }
        }

        pConnections++;
    }

    // For each node initialize its automation table for its associated properties.
    for (i=0; i<ulNumNodes; i++) {
        BuildNodePropertySet( &pNodeDescriptors[i] );
    }

    // Stick this here as a convienience
    // Initialize Map of Audio Properties to nodes
    MapFuncsToNodeTypes( MapPropertyToNode );


#ifdef TOPODBG
    DbugDumpTopology( pFilterDesc );
#endif

    return STATUS_SUCCESS;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\drivers\usbaudio.2\typeii.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 2000
//
//  File:       typeii.c
//
//--------------------------------------------------------------------------

#include "common.h"

#define FRAME_START_NOT_FOUND     0x80000000
#define NUM_AC3_SAMPLERATE_CODES  3
#define NUM_AC3_FRAMESIZE_CODES   38
#define MAX_SYNCFRAME_SIZE        1920<<1

ULONG AC3FrameSizeLookupTable[NUM_AC3_FRAMESIZE_CODES][NUM_AC3_SAMPLERATE_CODES] =
    { {   64,   69,   96 },
      {   64,   70,   96 },
      {   80,   87,  120 },
      {   80,   88,  120 },
      {   96,  104,  144 },
      {   96,  105,  144 },
      {  112,  121,  168 },
      {  112,  122,  168 },
      {  128,  139,  192 },
      {  128,  140,  192 },
      {  160,  174,  240 },
      {  160,  175,  240 },
      {  192,  208,  288 },
      {  192,  209,  288 },
      {  224,  243,  336 },
      {  224,  244,  336 },
      {  256,  278,  384 },
      {  256,  279,  384 },
      {  320,  348,  480 },
      {  320,  349,  480 },
      {  384,  417,  576 },
      {  384,  418,  576 },
      {  448,  487,  672 },
      {  448,  488,  672 },
      {  512,  557,  768 },
      {  512,  558,  768 },
      {  640,  696,  960 },
      {  640,  697,  960 },
      {  768,  835, 1152 },
      {  768,  836, 1152 },
      {  896,  975, 1344 },
      {  896,  976, 1344 },
      { 1024, 1114, 1536 },
      { 1024, 1115, 1536 },
      { 1152, 1253, 1728 },
      { 1152, 1254, 1728 },
      { 1280, 1393, 1920 },
      { 1280, 1394, 1920 } };



static ULONG
AC3FindFrameStart(
    PUCHAR pData,
    ULONG DataUsed,
    ULONG ulCurrentOffset )
{
    ULONG i = ulCurrentOffset;

    while ( i < (DataUsed-1) ) {
        if ( pData[i] == 0x0b ) {
            if ( pData[i+1] == 0x77 )
                return i;
        }
        else if ( pData[i] == 0x77 ) {
            if ( pData[i+1] == 0x0b )
                return i;
        }
        i++;
    }
    return FRAME_START_NOT_FOUND;
}

static ULONG
AC3GetFrameSize( PUCHAR pData )
{
    UCHAR FrameSizeCode;
    ULONG FrameSizeCodeOffset = 4;

    if ( pData[0] == 0x77 ) FrameSizeCodeOffset++;

    FrameSizeCode = pData[FrameSizeCodeOffset];

    DbgLog("T2FrmSi", pData, FrameSizeCode, FrameSizeCodeOffset, 0 );

    ASSERT( ((ULONG)(FrameSizeCode & 0x3F) < NUM_AC3_FRAMESIZE_CODES ) &&
            ((ULONG)((FrameSizeCode & 0xC0)>>6) < NUM_AC3_SAMPLERATE_CODES ) );

    // Sizes are word size double for byte
    return AC3FrameSizeLookupTable[(ULONG)(FrameSizeCode & 0x3F)]
                                  [(ULONG)((FrameSizeCode & 0xC0)>>6)] * 2;
}

ULONG
TypeIIGetFrameSize(
    IN PKSPIN pKsPin,
    PUCHAR pData,
    PUCHAR pBufData,
    ULONG ulPartialBufferSize )
{
    PPIN_CONTEXT pPinContext = pKsPin->Context;
    PUSBAUDIO_DATARANGE pUsbAudioDataRange = pPinContext->pUsbAudioDataRange;
    ULONG ulFrameSize = 0;

    switch( pUsbAudioDataRange->ulUsbDataFormat ) {
        case USBAUDIO_DATA_FORMAT_AC3:
            if (ulPartialBufferSize >= 5) { 
                ulFrameSize = AC3GetFrameSize( pBufData );
            }
            else if (ulPartialBufferSize) {
                RtlCopyMemory(pBufData+ulPartialBufferSize, pData, 8-ulPartialBufferSize);
                ulFrameSize = AC3GetFrameSize( pBufData );
            }
            else
                ulFrameSize = AC3GetFrameSize( pData );

            break;
        case USBAUDIO_DATA_FORMAT_MPEG:
        default:
            TRAP;
            break;
    }

    return ulFrameSize;
}

NTSTATUS
TypeIIProcessCallback(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP pIrp,
    PTYPE2_BUF_INFO pT2BufInfo )
{
    PKSPIN pKsPin = pT2BufInfo->pKsPin;
    PPIN_CONTEXT pPinContext = pKsPin->Context;
    PTYPE2_PIN_CONTEXT pType2PinContext = pPinContext->pType2PinContext;
    PKSSTREAM_POINTER pKsStreamPtr = pT2BufInfo->pContext;
    PURB pUrb = pT2BufInfo->pUrb;
    NTSTATUS ntStatus;
    KIRQL irql;

    ntStatus = pIrp->IoStatus.Status;

    DbgLog("T2PcCbk", pKsPin, pPinContext, pType2PinContext, pT2BufInfo );

    if ( pUrb->UrbIsochronousTransfer.Hdr.Status ) {
        ntStatus = STATUS_DEVICE_DATA_ERROR;
    }

    if ( !NT_SUCCESS(ntStatus) )  {
        pPinContext->fUrbError = TRUE ;
    }

    if ( pKsStreamPtr ) {
        // If error, set status code
        if (!NT_SUCCESS (ntStatus)) {
            KsStreamPointerSetStatusCode (pKsStreamPtr, ntStatus);
        }

        // Delete the stream pointer to release the buffer.
        KsStreamPointerDelete( pKsStreamPtr );
        pT2BufInfo->pContext = NULL;
    }

    KeAcquireSpinLock(&pPinContext->PinSpinLock, &irql);
    if ( 0 == InterlockedDecrement(&pPinContext->ulOutstandingUrbCount) ) {
        pPinContext->fUrbError = TRUE ;
        KeSetEvent( &pPinContext->PinStarvationEvent, 0, FALSE );
    }

    if ( IsListEmpty(&pType2PinContext->Type2BufferList) ) {
        InsertTailList(&pType2PinContext->Type2BufferList, &pT2BufInfo->List);
        KeReleaseSpinLock(&pPinContext->PinSpinLock, irql);
        KsPinAttemptProcessing( pKsPin, FALSE );
    }
    else {
        InsertTailList(&pType2PinContext->Type2BufferList, &pT2BufInfo->List);
        KeReleaseSpinLock(&pPinContext->PinSpinLock, irql);
    }

    return STATUS_MORE_PROCESSING_REQUIRED;
}

NTSTATUS
TypeIIBuildIsochRequest(
    PKSPIN pKsPin,
    PTYPE2_BUF_INFO pT2BufInfo,
    ULONG ulCurrentFrameSize)
{
    PPIN_CONTEXT pPinContext = pKsPin->Context;
    PTYPE2_PIN_CONTEXT pType2PinContext = pPinContext->pType2PinContext;
    ULONG ulNumberOfPackets = pType2PinContext->ulMaxPacketsPerFrame;
    ULONG ulNumDataPackets  = (ulCurrentFrameSize / pPinContext->ulMaxPacketSize) +
                             ((ulCurrentFrameSize % pPinContext->ulMaxPacketSize) > 0);
    ULONG ulUrbSize = GET_ISO_URB_SIZE(ulNumberOfPackets);
    PIO_STACK_LOCATION nextStack;
    PURB pUrb = pT2BufInfo->pUrb;
    PIRP pIrp = pT2BufInfo->pIrp;
    KIRQL irql;
    ULONG i,j;

    DbgLog("T2BldRq", pKsPin, pPinContext, pType2PinContext, pT2BufInfo );

    RtlZeroMemory(pUrb, ulUrbSize);

    IoInitializeIrp( pIrp,
                     IoSizeOfIrp(pPinContext->pNextDeviceObject->StackSize),
                     pPinContext->pNextDeviceObject->StackSize );

    pUrb->UrbIsochronousTransfer.Hdr.Length      = (USHORT)ulUrbSize;
    pUrb->UrbIsochronousTransfer.Hdr.Function    = URB_FUNCTION_ISOCH_TRANSFER;
    pUrb->UrbIsochronousTransfer.PipeHandle      = pPinContext->hPipeHandle;
    pUrb->UrbIsochronousTransfer.TransferFlags   = USBD_START_ISO_TRANSFER_ASAP;
    pUrb->UrbIsochronousTransfer.NumberOfPackets = ulNumberOfPackets;
    pUrb->UrbIsochronousTransfer.TransferBuffer  = pT2BufInfo->pBuffer;

    // While frame data incomplete fill packets with data
    for (i=0;i<ulNumDataPackets;i++) {
            pUrb->UrbIsochronousTransfer.IsoPacket[i].Offset =
                                          i * pPinContext->ulMaxPacketSize;
    }

    // Complete the Urb with NULL packets as per USB spec.
    for(j=0 ;i<ulNumberOfPackets;i++,j++ ) {
//        pUrb->UrbIsochronousTransfer.IsoPacket[i].Offset = ulCurrentFrameSize+j;
        pUrb->UrbIsochronousTransfer.IsoPacket[i].Offset = ulCurrentFrameSize;
    }

//    pUrb->UrbIsochronousTransfer.TransferBufferLength = ulCurrentFrameSize+j;
    pUrb->UrbIsochronousTransfer.TransferBufferLength = ulCurrentFrameSize;

    pIrp->IoStatus.Status = STATUS_SUCCESS;
    pIrp->IoStatus.Information = 0;

    nextStack = IoGetNextIrpStackLocation(pIrp);
    ASSERT(nextStack != NULL);

    nextStack->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
    nextStack->Parameters.Others.Argument1 = pUrb;
    nextStack->Parameters.DeviceIoControl.IoControlCode = IOCTL_INTERNAL_USB_SUBMIT_URB;

    IoSetCompletionRoutine( pIrp, TypeIIProcessCallback, pT2BufInfo, TRUE, TRUE, TRUE ) ;

    KeAcquireSpinLock(&pPinContext->PinSpinLock, &irql);
    InterlockedIncrement(&pPinContext->ulOutstandingUrbCount);
    KeReleaseSpinLock(&pPinContext->PinSpinLock, irql);

    return IoCallDriver(pPinContext->pNextDeviceObject, pIrp);
}

NTSTATUS
TypeIIProcessStreamPtr( PKSPIN pKsPin )
{
    PPIN_CONTEXT pPinContext = pKsPin->Context;
    PTYPE2_PIN_CONTEXT pType2PinContext = pPinContext->pType2PinContext;
    PUSBAUDIO_DATARANGE pUsbAudioDataRange = pPinContext->pUsbAudioDataRange;
    PKSSTREAM_POINTER pKsStreamPtr, pKsCloneStreamPtr;
    PKSSTREAM_POINTER_OFFSET pKsStreamPtrOffsetIn;
    PTYPE2_BUF_INFO pT2BufInfo;
    PUCHAR pBufData, pData;
    ULONG ulCurrentFrameSize;
    ULONG ulCopySize;
    NTSTATUS ntStatus;
    KIRQL irql;

    DbgLog("T2Proc0", pKsPin, pPinContext, pType2PinContext, 0 );

    // Check for a data error. If error flag set abort the pipe and start again.
    if ( pPinContext->fUrbError ) {
        AbortUSBPipe( pPinContext );
    }

    // Get the next stream pointer from the queue
    pKsStreamPtr = KsPinGetLeadingEdgeStreamPointer( pKsPin, KSSTREAM_POINTER_STATE_LOCKED );
    if ( !pKsStreamPtr ) {
        _DbgPrintF(DEBUGLVL_VERBOSE,("[TypeIIProcessStreamPtr] Leading edge is NULL\n"));
        return STATUS_SUCCESS;
    }

    DbgLog("T2Proc1", pKsPin, pPinContext, pType2PinContext, pKsStreamPtr );

    _DbgPrintF(DEBUGLVL_VERBOSE, ("'TypeIIProcess: pKsPin: %x pKsStreamPtr: %x\n",pKsPin,pKsStreamPtr) );

    pKsStreamPtrOffsetIn = &pKsStreamPtr->OffsetIn;
    pData = pKsStreamPtrOffsetIn->Data;

    // ISSUE-2001/01/10-dsisolak Need to make sure this is a data buffer and not a data format change.
    if ( pKsStreamPtr->StreamHeader->OptionsFlags & KSSTREAM_HEADER_OPTIONSF_ENDOFSTREAM ) {
        if ( !pData ) {
            KsStreamPointerUnlock( pKsStreamPtr, TRUE );
            return STATUS_SUCCESS;
        }
    }
    else if ( pKsStreamPtr->StreamHeader->OptionsFlags & KSSTREAM_HEADER_OPTIONSF_TYPECHANGED) {
        TRAP;
        // Need to change data formats if possible???.
    }


    KeAcquireSpinLock(&pPinContext->PinSpinLock, &irql);

    // While there is data available and data buffers to put it in fill 'em up
    while ( pKsStreamPtr && !IsListEmpty(&pType2PinContext->Type2BufferList ) ) {
        pT2BufInfo = (PTYPE2_BUF_INFO)pType2PinContext->Type2BufferList.Flink;
        KeReleaseSpinLock(&pPinContext->PinSpinLock, irql);

        pBufData = pT2BufInfo->pBuffer;

        _DbgPrintF(DEBUGLVL_VERBOSE, ("'pData; %x pBuf %x PartialBufferSize: %d\n",
                              pData, pBufData, pType2PinContext->ulPartialBufferSize) );

        ulCurrentFrameSize = TypeIIGetFrameSize( pKsPin,
                                                 pData,
                                                 pBufData,
                                                 pType2PinContext->ulPartialBufferSize );

        ulCopySize = ulCurrentFrameSize - pType2PinContext->ulPartialBufferSize;
        if ( ulCopySize >= pKsStreamPtrOffsetIn->Remaining )
            ulCopySize = pKsStreamPtrOffsetIn->Remaining;

        RtlCopyMemory( pBufData+pType2PinContext->ulPartialBufferSize,
                       pData,
                       ulCopySize );

        pType2PinContext->ulPartialBufferSize += ulCopySize;

        if ( ulCopySize == pKsStreamPtrOffsetIn->Remaining ) {

            // Clone pointer and discard this one
            if ( NT_SUCCESS( KsStreamPointerClone( pKsStreamPtr, NULL, 0, &pKsCloneStreamPtr ) ) ) {
                pT2BufInfo->pContext = pKsCloneStreamPtr;
                // Unlock the stream pointer. This will really only unlock after last clone is deleted.
                KsStreamPointerUnlock( pKsStreamPtr, TRUE );
                pKsStreamPtr =
                   KsPinGetLeadingEdgeStreamPointer( pKsPin, KSSTREAM_POINTER_STATE_LOCKED );
                _DbgPrintF(DEBUGLVL_VERBOSE, ("'TypeIIProcess: pKsStreamPtr: %x\n",pKsStreamPtr) );
                if ( pKsStreamPtr ) {
                    pKsStreamPtrOffsetIn = &pKsStreamPtr->OffsetIn;
                    pData = pKsStreamPtrOffsetIn->Data;
                }
            }
        }
        else {
            // Update remaining count in stream pointer
            KsStreamPointerAdvanceOffsets( pKsStreamPtr, ulCopySize, 0, FALSE );
            pData = pKsStreamPtrOffsetIn->Data;
        }

        // If the frame is complete submit the URB
        if ( pType2PinContext->ulPartialBufferSize == ulCurrentFrameSize ) {
            KeAcquireSpinLock(&pPinContext->PinSpinLock, &irql);
            pT2BufInfo = (PTYPE2_BUF_INFO)RemoveHeadList(&pType2PinContext->Type2BufferList);
            KeReleaseSpinLock(&pPinContext->PinSpinLock, irql);
            pType2PinContext->ulPartialBufferSize = 0;
            ntStatus = TypeIIBuildIsochRequest(pKsPin, pT2BufInfo, ulCurrentFrameSize);
        }

        KeAcquireSpinLock(&pPinContext->PinSpinLock, &irql);
    }

    KeReleaseSpinLock(&pPinContext->PinSpinLock, irql);

    if (pKsStreamPtr) {
        KsStreamPointerUnlock( pKsStreamPtr, FALSE );
        ntStatus = STATUS_PENDING;
    }
    else
        ntStatus = STATUS_SUCCESS;

    return ntStatus;
}

VOID
TypeIIWaitForStarvation( PKSPIN pKsPin )
{
    PPIN_CONTEXT pPinContext = pKsPin->Context;
    PTYPE2_PIN_CONTEXT pType2PinContext = pPinContext->pType2PinContext;
    PTYPE2_BUF_INFO pT2BufInfo;
    KIRQL irql;

    DbgLog("T2Strv1", pKsPin, pPinContext, pType2PinContext, 0 );

    USBAudioPinWaitForStarvation( pKsPin );

    DbgLog("T2Strv2", pKsPin, pPinContext, pType2PinContext, 0 );

    // Once we've starved make sure there are no outstanding Clone Stream Pointers.
    pT2BufInfo = (PTYPE2_BUF_INFO)pType2PinContext->Type2BufferList.Flink;
    while (pT2BufInfo != (PTYPE2_BUF_INFO)&pType2PinContext->Type2BufferList) {
        if (pT2BufInfo->pContext) {
            KsStreamPointerDelete( (PKSSTREAM_POINTER)pT2BufInfo->pContext );
            pT2BufInfo->pContext = NULL;
            
        }
        pT2BufInfo = (PTYPE2_BUF_INFO)pT2BufInfo->List.Flink;
    }
}

NTSTATUS
TypeIIStateChange(
    PKSPIN pKsPin,
    KSSTATE OldKsState,
    KSSTATE NewKsState )
{
    PPIN_CONTEXT pPinContext = pKsPin->Context;
    PTYPE2_PIN_CONTEXT pType2PinContext = pPinContext->pType2PinContext;

    DbgLog("T2State", pKsPin, pPinContext, OldKsState, NewKsState );

    switch(NewKsState) {
        case KSSTATE_STOP:
            // Need to wait until outstanding Urbs complete
            TypeIIWaitForStarvation( pKsPin );

            pType2PinContext->ulPartialBufferSize  = 0;
        default:
            break;
    }
    return STATUS_SUCCESS;
}

NTSTATUS
TypeIIRenderStreamInit( PKSPIN pKsPin )
{
    PPIN_CONTEXT pPinContext = pKsPin->Context;
    PTYPE2_PIN_CONTEXT pType2PinContext;
    PUCHAR pFrameBuffer;
    PURB pUrbs;
    ULONG i;

    ULONG ulMaxPacketsPerFrame = 32; // NOTE: Assuming AC-3 for now
    ULONG ulUrbSize = GET_ISO_URB_SIZE( ulMaxPacketsPerFrame );

    pType2PinContext = pPinContext->pType2PinContext =
            AllocMem( NonPagedPool, sizeof(TYPE2_PIN_CONTEXT) +
                                    (NUM_T2_BUFFERS * ( ulUrbSize +
                                                      ( ulMaxPacketsPerFrame * pPinContext->ulMaxPacketSize ))));
    if ( !pType2PinContext ) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    // Bag the Type2 context for easy cleanup.
    KsAddItemToObjectBag(pKsPin->Bag, pType2PinContext, FreeMem);

    // Set pointers for URBs and Data Buffers
    pUrbs = (PURB)(pType2PinContext + 1);

    pFrameBuffer = (PUCHAR)pUrbs + ( ulUrbSize * NUM_T2_BUFFERS );

    RtlZeroMemory( pFrameBuffer, NUM_T2_BUFFERS *
                                 pPinContext->ulMaxPacketSize * ulMaxPacketsPerFrame );

    // Initialize Buffer info structure list
    InitializeListHead( &pType2PinContext->Type2BufferList );

    // Save Max Packets Per Frame Value
    pType2PinContext->ulMaxPacketsPerFrame = ulMaxPacketsPerFrame;

    // Initialize Buffer info structures
    for ( i=0; i<NUM_T2_BUFFERS; i++ ) {
        InsertHeadList( &pType2PinContext->Type2BufferList,
                        &pType2PinContext->Type2Buffers[i].List );
        pType2PinContext->Type2Buffers[i].pKsPin   = pKsPin;
        pType2PinContext->Type2Buffers[i].pContext = NULL;
        pType2PinContext->Type2Buffers[i].pBuffer  = &pFrameBuffer[i * pPinContext->ulMaxPacketSize *
                                                                  ulMaxPacketsPerFrame];
        pType2PinContext->Type2Buffers[i].pUrb = (PURB)((PUCHAR)pUrbs + (i*ulUrbSize));
        pType2PinContext->Type2Buffers[i].pIrp =
                  IoAllocateIrp( pPinContext->pNextDeviceObject->StackSize, FALSE );
        if ( !pType2PinContext->Type2Buffers[i].pIrp ) {
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        // Bag the irps for easy cleanup.
        KsAddItemToObjectBag(pKsPin->Bag, pType2PinContext->Type2Buffers[i].pIrp, IoFreeIrp);
    }

    // Initialize misc. info fields
    pType2PinContext->ulPartialBufferSize  = 0;

    return STATUS_SUCCESS;
}


NTSTATUS
TypeIIRenderStreamClose( PKSPIN pKsPin )
{
    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\drivers\usbaudio.2\typei.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 2000
//
//  File:       typei.c
//
//--------------------------------------------------------------------------

#include "common.h"
#include "perf.h"

#define LOW_WATERMARK   5
extern ULONG TraceEnable;
extern TRACEHANDLE LoggerHandle;

NTSTATUS
RtAudioTypeIGetPlayPosition(
    IN PFILE_OBJECT PinFileObject,
    OUT PUCHAR *ppPlayPosition,
    OUT PLONG plOffset)
{
    PKSPIN pKsPin;
    PPIN_CONTEXT pPinContext;
    PTYPE1_PIN_CONTEXT pT1PinContext;
    ULONG ulCurrentFrame;
    PLIST_ENTRY ple;
    PISO_URB_INFO pIsoUrbInfoTemp;
    PUCHAR pPlayPosInUrb = NULL;
    LONG lPlayPosOffset = 0;
    PURB pUrb;
    ULONG ulStartFrame;
    KIRQL Irql;
    NTSTATUS ntStatus;
    ULONG MinFramesAhead=MAX_ULONG;

    //
    //  Get the KSPIN from the file object
    //
    pKsPin = (PKSPIN)KsGetObjectFromFileObject( PinFileObject );
    if (!pKsPin) {
        return STATUS_UNSUCCESSFUL;
    }

    pPinContext = pKsPin->Context;
    pT1PinContext = pPinContext->pType1PinContext;

    //
    // search the pending transfers to see which one is going out now
    //
    KeAcquireSpinLock( &pPinContext->PinSpinLock, &Irql );

    //
    //  Get the current frame counter so we know where the hardware is
    //
    ntStatus = GetCurrentUSBFrame( pPinContext, &ulCurrentFrame );

    if (NT_SUCCESS(ntStatus)) {

        for(ple = pT1PinContext->UrbInUseList.Flink;
            ple != &pT1PinContext->UrbInUseList;
            ple = ple->Flink)
        {
            pIsoUrbInfoTemp = (PISO_URB_INFO)ple;
            pUrb = pIsoUrbInfoTemp->pUrb;

            // DbgLog("CHECK", &pT1PinContext->UrbInUseList, pIsoUrbInfoTemp, pUrb, 0);

            //
            // see if this urb is the one that is currently being played
            //
            ulStartFrame = pUrb->UrbIsochronousTransfer.StartFrame;
            if (ulStartFrame != 0) {
                DbgLog("RT1BPos", ulCurrentFrame, ulStartFrame, 0, 0);

                if ( (ulCurrentFrame - ulStartFrame) < pUrb->UrbIsochronousTransfer.NumberOfPackets ) {

                    pPlayPosInUrb=(PUCHAR)pUrb->UrbIsochronousTransfer.TransferBuffer;

                    lPlayPosOffset=(ulCurrentFrame - ulStartFrame);

                    // This measurement is valid.  Make sure we don't lose it
                    // because of any earlier FramesAhead measurements.
                    MinFramesAhead=MAX_ULONG;

                    break;
                }
                else {
                    ULONG FramesAhead;

                    FramesAhead=(ulStartFrame-ulCurrentFrame);

                    if (FramesAhead<MinFramesAhead) {

                        MinFramesAhead=FramesAhead;

                        pPlayPosInUrb=(PUCHAR)pUrb->UrbIsochronousTransfer.TransferBuffer;

                        lPlayPosOffset=-(LONG)FramesAhead;

                    }
                }

            }
            else {
                // Start Frame is not set yet
                _DbgPrintF( DEBUGLVL_TERSE, ("'[RtAudioTypeIGetPlayPosition] Start Frame is not set for pUrb: %x\n", pUrb));
            }
        }

    }

    KeReleaseSpinLock(&pPinContext->PinSpinLock, Irql);


    // Clear out the closest URB information if it is too far from the
    // current position.  If the closest URB in our list is more than 150ms
    // away from the current position, then we drop the data on the floor.

    // Note that we ALWAYS set the MinFramesAhead to 0xffffffff in the
    // case when we find a position inside an URB - so that this code never
    // clears that position information.

    if (MinFramesAhead!=MAX_ULONG && MinFramesAhead>150) {

        pPlayPosInUrb = NULL;
        lPlayPosOffset = 0;

        _DbgPrintF( DEBUGLVL_TERSE, ("'[RtAudioTypeIGetPlayPosition] Couldn't find matching urb!\n"));

    }


    *ppPlayPosition = pPlayPosInUrb;
    *plOffset      = lPlayPosOffset;

    DbgLog("RtPos", pPlayPosInUrb, lPlayPosOffset, 0, 0);

    return ntStatus;
}

NTSTATUS
TypeIAsyncEPPollCallback(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP pIrp,
    PSYNC_ENDPOINT_INFO pSyncEPInfo )
{
    PPIN_CONTEXT pPinContext = pSyncEPInfo->pContext;
    PTYPE1_PIN_CONTEXT pT1PinContext = pPinContext->pType1PinContext;

    ULONG SRWhole;
    ULONG SRFraction;
    ULONG SampleRate;
    KIRQL Irql;

    SRWhole = (((ULONG)pSyncEPInfo->Buffer[2]<<2) | ((ULONG)pSyncEPInfo->Buffer[1]>>6)) * 1000;
    SRFraction = (((ULONG)pSyncEPInfo->Buffer[1]<<4) | ((ULONG)pSyncEPInfo->Buffer[0]>>4)) & 0x3FF;
    SRFraction = (SRFraction*1000) / 1024;
    SampleRate = SRWhole + SRFraction;

    DbgLog("T1AsECB", SampleRate,
                      (ULONG)pSyncEPInfo->Buffer[2],
                      (ULONG)pSyncEPInfo->Buffer[1],
                      (ULONG)pSyncEPInfo->Buffer[0]);

    if ( SampleRate && ( SampleRate != pT1PinContext->ulCurrentSampleRate )) {
        KeAcquireSpinLock( &pPinContext->PinSpinLock, &Irql );
        pT1PinContext->ulCurrentSampleRate = SampleRate;
        pT1PinContext->fSampleRateChanged = TRUE;
        KeReleaseSpinLock( &pPinContext->PinSpinLock, Irql );
    }

    pSyncEPInfo->ulNextPollFrame = pSyncEPInfo->pUrb->UrbIsochronousTransfer.StartFrame +
                                   pSyncEPInfo->ulRefreshRate;

    KeAcquireSpinLock(&pPinContext->PinSpinLock, &Irql);
    pSyncEPInfo->fSyncRequestInProgress = FALSE;
    KeSetEvent( &pSyncEPInfo->SyncPollDoneEvent, 0, FALSE );
    KeReleaseSpinLock(&pPinContext->PinSpinLock, Irql);

    return ( STATUS_MORE_PROCESSING_REQUIRED );
}

VOID
TypeIAsyncEndpointPoll(
    PDEVICE_OBJECT pNextDeviceObject,
    PSYNC_ENDPOINT_INFO pSyncEPInfo )
{
    PURB pUrb = pSyncEPInfo->pUrb;
    PIRP pIrp = pSyncEPInfo->pIrp;
    PIO_STACK_LOCATION nextStack;

    // First Reset the pipe.
    ResetUSBPipe( pNextDeviceObject,
                  pSyncEPInfo->hSyncPipeHandle );

    RtlZeroMemory(pUrb, GET_ISO_URB_SIZE(1));

    pUrb->UrbIsochronousTransfer.Hdr.Length      = (USHORT)GET_ISO_URB_SIZE(1);
    pUrb->UrbIsochronousTransfer.Hdr.Function    = URB_FUNCTION_ISOCH_TRANSFER;
    pUrb->UrbIsochronousTransfer.PipeHandle      = pSyncEPInfo->hSyncPipeHandle;
    pUrb->UrbIsochronousTransfer.TransferFlags   = USBD_START_ISO_TRANSFER_ASAP |
                                                   USBD_TRANSFER_DIRECTION_IN;
    pUrb->UrbIsochronousTransfer.NumberOfPackets = 1;

    pUrb->UrbIsochronousTransfer.IsoPacket[0].Offset = 0;

    pUrb->UrbIsochronousTransfer.TransferBuffer       = pSyncEPInfo->Buffer;
    pUrb->UrbIsochronousTransfer.TransferBufferLength = SYNC_ENDPOINT_DATA_SIZE;

    IoInitializeIrp( pIrp,
                     IoSizeOfIrp(pNextDeviceObject->StackSize),
                     pNextDeviceObject->StackSize );

    nextStack = IoGetNextIrpStackLocation(pIrp);
    ASSERT(nextStack != NULL);

    nextStack->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
    nextStack->Parameters.Others.Argument1 = pUrb;
    nextStack->Parameters.DeviceIoControl.IoControlCode = IOCTL_INTERNAL_USB_SUBMIT_URB;

    IoSetCompletionRoutine( pIrp, TypeIAsyncEPPollCallback, pSyncEPInfo, TRUE, TRUE, TRUE );

    IoCallDriver(pNextDeviceObject, pIrp);

}

NTSTATUS
TypeIRenderBytePosition(
    PPIN_CONTEXT pPinContext,
    PKSAUDIO_POSITION pPosition )
{
    PTYPE1_PIN_CONTEXT pT1PinContext = pPinContext->pType1PinContext;
    PISO_URB_INFO pIsoUrbInfo;
    ULONG ulStartFrame, ulCurrentFrame;
    PLIST_ENTRY ple;
    PURB pUrb;
    KIRQL irql;
    NTSTATUS ntStatus = STATUS_SUCCESS;

    pPosition->PlayOffset = 0;

    KeAcquireSpinLock( &pPinContext->PinSpinLock, &irql );

    if ( pPinContext->fStreamStartedFlag ) {

        KeReleaseSpinLock( &pPinContext->PinSpinLock, irql );

        ntStatus = GetCurrentUSBFrame( pPinContext, &ulCurrentFrame );
        if (NT_SUCCESS(ntStatus)) {

            KeAcquireSpinLock( &pPinContext->PinSpinLock, &irql );

            DbgLog("T1BPos1", pPinContext, pT1PinContext, ulCurrentFrame, 0);

            for( ple = pT1PinContext->UrbInUseList.Flink;
                 ple != &pT1PinContext->UrbInUseList;
                 ple = ple->Flink) {
                ULONG ulNumPackets;

                pIsoUrbInfo = (PISO_URB_INFO)ple;
                pUrb = pIsoUrbInfo->pUrb;
                ulNumPackets = pUrb->UrbIsochronousTransfer.NumberOfPackets;

                ulStartFrame = pUrb->UrbIsochronousTransfer.StartFrame;

                if (ulStartFrame != 0) {

       	            DbgLog("T1BPos2", ulStartFrame, ulCurrentFrame, ulNumPackets, 0);

                    // Determine if this is the current Frame being rendered.
                    if (( ulCurrentFrame - ulStartFrame ) < ulNumPackets ){
                        PUSBD_ISO_PACKET_DESCRIPTOR pIsoPacket = 
                            &pUrb->UrbIsochronousTransfer.IsoPacket[ulCurrentFrame - ulStartFrame];
                        ULONG ulFrameBytes = (( ulCurrentFrame - ulStartFrame ) == (ulNumPackets-1)) ?
                                             pIsoUrbInfo->ulTransferBufferLength-pIsoPacket[0].Offset :
                                             pIsoPacket[1].Offset-pIsoPacket[0].Offset;

         	            DbgLog("StrtFr1", ulStartFrame, ulCurrentFrame, ulNumPackets, ulFrameBytes);
         	            DbgLog("StrtFr2", pUrb, pIsoPacket, 
         	                              pIsoUrbInfo->ulTransferBufferLength, 
         	                              0);
         	            ASSERT((LONG)ulFrameBytes > 0);

                        pPosition->PlayOffset += pIsoPacket[0].Offset;
                        
         	            // If this is the current frame determine if there have been 
         	            // multiple position requests during this frame. If so, "interpolate".
         	            if ( ulCurrentFrame == pPinContext->ulCurrentFrame ){
         	                if ( pPinContext->ulFrameRepeatCount++ < 8 ) {
         	                    pPosition->PlayOffset += pPinContext->ulFrameRepeatCount*
         	                                            (ulFrameBytes>>3);
         	                }
         	                else {
         	                    pPosition->PlayOffset += ulFrameBytes; // Possible repeat here
         	                }
         	            }
         	            else {
         	                pPinContext->ulFrameRepeatCount = 0;
         	                pPinContext->ulCurrentFrame = ulCurrentFrame;
         	            }
         	            break;
                    }
                    else if (( ulCurrentFrame - ulStartFrame ) < 0x7fffffff){
                        // Current position is past this urb.
                        // Add this URB's byte count to total
                        pPosition->PlayOffset += pIsoUrbInfo->ulTransferBufferLength;
                    }
        	    }
        	}

            pPosition->PlayOffset += pPinContext->ullTotalBytesReturned;
            KeReleaseSpinLock( &pPinContext->PinSpinLock, irql );

        }
    }
    else {
        pPosition->PlayOffset += pPinContext->ullTotalBytesReturned;
        KeReleaseSpinLock( &pPinContext->PinSpinLock, irql );
    }

#if DBG
    {
     if ( pPinContext->ullOldPlayOffset > pPosition->PlayOffset ) TRAP;
     pPinContext->ullOldPlayOffset = pPosition->PlayOffset;
    }
#endif

    return ntStatus;

}

NTSTATUS
TypeI1MsCompleteCallback(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP pIrp,
    PMSEC_BUF_INFO p1MsBufInfo )
{
    PPIN_CONTEXT pPinContext = (PPIN_CONTEXT)p1MsBufInfo->pContext;
    PTYPE1_PIN_CONTEXT pT1PinContext = pPinContext->pType1PinContext;
    KIRQL Irql;

    // Check for errors and Decrement outstanding URB count
    KeAcquireSpinLock( &pPinContext->PinSpinLock, &Irql );
    if ( p1MsBufInfo->pUrb->UrbIsochronousTransfer.Hdr.Status ) {
        pPinContext->fUrbError = TRUE;
    }

    if ( 0 == InterlockedDecrement(&pPinContext->ulOutstandingUrbCount) ) {
        pPinContext->fUrbError = TRUE ;
        pPinContext->fStreamStartedFlag = FALSE;
        KeSetEvent( &pPinContext->PinStarvationEvent, 0, FALSE );
    }

    pPinContext->ullTotalBytesReturned += p1MsBufInfo->ulTransferBufferLength;
    DbgLog("RetUrb1", p1MsBufInfo->ulTransferBufferLength, pPinContext->ullTotalBytesReturned, 
                      p1MsBufInfo->pUrb, 0 );

    // Remove from the pending list
    RemoveEntryList(&p1MsBufInfo->List);

    // Put 1ms info structure back on queue.
    InsertTailList( &pT1PinContext->MSecBufList, &p1MsBufInfo->List );

    KeReleaseSpinLock( &pPinContext->PinSpinLock, Irql );

    // release 1ms resource semaphore
    KeReleaseSemaphore( &pT1PinContext->MsecBufferSemaphore, 0, 1, FALSE );

    return ( STATUS_MORE_PROCESSING_REQUIRED );
}

VOID
TypeIBuild1MsecIsocRequest(
    PMSEC_BUF_INFO p1MsBufInfo )
{
    PPIN_CONTEXT pPinContext = (PPIN_CONTEXT)p1MsBufInfo->pContext;
    PTYPE1_PIN_CONTEXT pT1PinContext = pPinContext->pType1PinContext;
    PURB pUrb = p1MsBufInfo->pUrb;
    PIRP pIrp = p1MsBufInfo->pIrp;
    PIO_STACK_LOCATION nextStack;
    KIRQL Irql;

    RtlZeroMemory(pUrb, GET_ISO_URB_SIZE(1));

    pUrb->UrbIsochronousTransfer.Hdr.Length           = (USHORT)GET_ISO_URB_SIZE(1);
    pUrb->UrbIsochronousTransfer.Hdr.Function         = URB_FUNCTION_ISOCH_TRANSFER;
    pUrb->UrbIsochronousTransfer.PipeHandle           = pPinContext->hPipeHandle;
    pUrb->UrbIsochronousTransfer.TransferFlags        = USBD_START_ISO_TRANSFER_ASAP;
    pUrb->UrbIsochronousTransfer.NumberOfPackets      = 1;
    pUrb->UrbIsochronousTransfer.TransferBuffer       = p1MsBufInfo->pBuffer;
    pUrb->UrbIsochronousTransfer.TransferBufferLength = p1MsBufInfo->ulTransferBufferLength;

    IoInitializeIrp( pIrp,
                     IoSizeOfIrp(pPinContext->pNextDeviceObject->StackSize),
                     pPinContext->pNextDeviceObject->StackSize );

    nextStack = IoGetNextIrpStackLocation(pIrp);
    ASSERT(nextStack != NULL);

    nextStack->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
    nextStack->Parameters.Others.Argument1 = pUrb;
    nextStack->Parameters.DeviceIoControl.IoControlCode = IOCTL_INTERNAL_USB_SUBMIT_URB;

    IoSetCompletionRoutine ( pIrp, TypeI1MsCompleteCallback, p1MsBufInfo, TRUE, TRUE, TRUE );

    InterlockedIncrement(&pPinContext->ulOutstandingUrbCount); 

    KeAcquireSpinLock(&pPinContext->PinSpinLock, &Irql);
    InsertTailList( &pT1PinContext->UrbInUseList, &p1MsBufInfo->List );
    KeReleaseSpinLock(&pPinContext->PinSpinLock, Irql);

    IoCallDriver(pPinContext->pNextDeviceObject, pIrp);

}

NTSTATUS
TypeICompleteCallback (
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP pIrp,
    PKSSTREAM_POINTER pKsStreamPtr )
{
    PPIN_CONTEXT pPinContext = pKsStreamPtr->Pin->Context;
    PTYPE1_PIN_CONTEXT pT1PinContext = pPinContext->pType1PinContext;
    PISO_URB_INFO pIsoUrbInfo = pKsStreamPtr->Context;
    PURB pUrb = pIsoUrbInfo->pUrb;
    NTSTATUS ntStatus;
    KIRQL Irql;
    LOGICAL Glitch = FALSE;
    LARGE_INTEGER currentPC;

    ntStatus = pIrp->IoStatus.Status;

    if ( pUrb->UrbIsochronousTransfer.Hdr.Status ) {
        DbgLog("UrbErr1", pKsStreamPtr->Pin, pPinContext,
                          pKsStreamPtr, pUrb->UrbIsochronousTransfer.Hdr.Status );
        ntStatus = STATUS_DEVICE_DATA_ERROR;
    }

    KeAcquireSpinLock(&pPinContext->PinSpinLock, &Irql);

    if ( !NT_SUCCESS(ntStatus) )  {
        pPinContext->fUrbError = TRUE ;
        pPinContext->fStreamStartedFlag = FALSE;
        DbgLog("UrbErr2", pKsStreamPtr->Pin, pPinContext, pKsStreamPtr, ntStatus );
    }

    if ( 0 == InterlockedDecrement(&pPinContext->ulOutstandingUrbCount) ) {
        Glitch = TRUE;
        pPinContext->fUrbError = TRUE ;
        pPinContext->fStreamStartedFlag = FALSE;
        KeSetEvent( &pPinContext->PinStarvationEvent, 0, FALSE );
    }
//    else if ( !pPinContext->fStreamStartedFlag && !pPinContext->fUrbError ) {
//        pPinContext->fStreamStartedFlag = TRUE;
//    }

    pPinContext->ullTotalBytesReturned += pIsoUrbInfo->ulTransferBufferLength;

    DbgLog("RetUrb", pIsoUrbInfo->ulTransferBufferLength, pPinContext->ullTotalBytesReturned, 
                     pUrb, pKsStreamPtr );

    RemoveEntryList(&pIsoUrbInfo->List);

    KeReleaseSpinLock(&pPinContext->PinSpinLock, Irql);

    FreeMem ( pIsoUrbInfo );

    if (LoggerHandle && TraceEnable) {
        currentPC = KeQueryPerformanceCounter (NULL);

        if (Glitch) {
            if (!pPinContext->GraphJustStarted) {
                if (pPinContext->StarvationDetected==FALSE) {
                    pPinContext->StarvationDetected = TRUE;
                    PerfLogGlitch((ULONG_PTR)pPinContext, TRUE,currentPC.QuadPart,pPinContext->LastStateChangeTimeSample);
                } //if
            }
        }
        else if (pPinContext->StarvationDetected) {    
            pPinContext->StarvationDetected = FALSE;
            PerfLogGlitch((ULONG_PTR)pPinContext, FALSE,currentPC.QuadPart,pPinContext->LastStateChangeTimeSample);
        } //if

        pPinContext->LastStateChangeTimeSample = currentPC.QuadPart;
    } //if

    pPinContext->GraphJustStarted = FALSE;

    // If error, set status code
    if (!NT_SUCCESS (ntStatus)) {
        KsStreamPointerSetStatusCode (pKsStreamPtr, ntStatus);
    }

    // Free Irp
    IoFreeIrp( pIrp );

    // Delete the stream pointer to release the buffer.
    KsStreamPointerDelete( pKsStreamPtr );

    return ( STATUS_MORE_PROCESSING_REQUIRED );
}

NTSTATUS
TypeILockDelayCompleteCallback (
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP pIrp,
    PKSSTREAM_POINTER pKsStreamPtr )
{
    PPIN_CONTEXT pPinContext = pKsStreamPtr->Pin->Context;
    PTYPE1_PIN_CONTEXT pT1PinContext = pPinContext->pType1PinContext;
    PISO_URB_INFO pIsoUrbInfo = pKsStreamPtr->Context;
    PURB pUrb = pIsoUrbInfo->pUrb;
    NTSTATUS ntStatus;
    KIRQL Irql;

    ntStatus = pIrp->IoStatus.Status;

    if ( pUrb->UrbIsochronousTransfer.Hdr.Status ) {
        DbgLog("UrbErr1", pKsStreamPtr->Pin, pPinContext,
                          pKsStreamPtr, pUrb->UrbIsochronousTransfer.Hdr.Status );
        ntStatus = STATUS_DEVICE_DATA_ERROR;
    }

    KeAcquireSpinLock(&pPinContext->PinSpinLock, &Irql);
    if ( !NT_SUCCESS(ntStatus) )  {
        pPinContext->fUrbError = TRUE ;
    }

    if ( 0 == InterlockedDecrement(&pPinContext->ulOutstandingUrbCount) ) {
        pPinContext->fUrbError = TRUE ;
        KeSetEvent( &pPinContext->PinStarvationEvent, 0, FALSE );
    }

    KeReleaseSpinLock(&pPinContext->PinSpinLock, Irql);

    // Free our URB storage
    FreeMem( pIsoUrbInfo );

    // Free Irp
    IoFreeIrp( pIrp );

    // Free the stream pointer and data buffer.
    FreeMem( pKsStreamPtr );

    return ( STATUS_MORE_PROCESSING_REQUIRED );
}


NTSTATUS
TypeIBuildIsochRequest(
    PKSSTREAM_POINTER pKsStreamPtr,
    PVOID pCompletionRoutine )
{
    PPIN_CONTEXT pPinContext = pKsStreamPtr->Pin->Context;
    PKSSTREAM_POINTER_OFFSET pKsStreamPtrOffsetIn = &pKsStreamPtr->OffsetIn;
    PTYPE1_PIN_CONTEXT pT1PinContext = pPinContext->pType1PinContext;
	ULONG ulSampleCount = pKsStreamPtrOffsetIn->Remaining / pT1PinContext->ulBytesPerSample;
    ULONG ulNumberOfPackets = ulSampleCount / pT1PinContext->ulSamplesPerPacket;
	ULONG ulCurrentPacketSize, i = 0;

    ULONG ulUrbSize = GET_ISO_URB_SIZE( ulNumberOfPackets );
    ULONG ulDataOffset = 0;
    PIO_STACK_LOCATION nextStack;
    PISO_URB_INFO pIsoUrbInfo;
    PURB pUrb;
    PIRP pIrp;
    KIRQL Irql;
    NTSTATUS ntStatus = STATUS_SUCCESS;

    ASSERT( (pKsStreamPtrOffsetIn->Remaining % pT1PinContext->ulBytesPerSample) == 0 );

    pIrp = IoAllocateIrp( pPinContext->pNextDeviceObject->StackSize, FALSE );
    if ( !pIrp ) {
        if (pCompletionRoutine == TypeILockDelayCompleteCallback) {
            FreeMem( pKsStreamPtr );
        }
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    pIsoUrbInfo = AllocMem( NonPagedPool, sizeof( ISO_URB_INFO ) + ulUrbSize );
    if (!pIsoUrbInfo) {
        IoFreeIrp(pIrp);
        if (pCompletionRoutine == TypeILockDelayCompleteCallback) {
            FreeMem( pKsStreamPtr );
        }
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    pIsoUrbInfo->pUrb = pUrb = (PURB)(pIsoUrbInfo + 1);

    pKsStreamPtr->Context = pIsoUrbInfo;
    RtlZeroMemory(pUrb, ulUrbSize);

    pUrb->UrbIsochronousTransfer.Hdr.Length      = (USHORT)ulUrbSize;
    pUrb->UrbIsochronousTransfer.Hdr.Function    = URB_FUNCTION_ISOCH_TRANSFER;
    pUrb->UrbIsochronousTransfer.PipeHandle      = pPinContext->hPipeHandle;
    pUrb->UrbIsochronousTransfer.TransferFlags   = USBD_START_ISO_TRANSFER_ASAP;
    pUrb->UrbIsochronousTransfer.TransferBuffer  = pKsStreamPtrOffsetIn->Data;

	ulCurrentPacketSize = 
		( ((pT1PinContext->ulLeftoverFraction+pT1PinContext->ulFractionSize) >= MS_PER_SEC) +
        pT1PinContext->ulSamplesPerPacket );

    DbgLog( "BldPreL", ulCurrentPacketSize, ulSampleCount, pKsStreamPtrOffsetIn->Data, 0 );

	while ( ulSampleCount >= ulCurrentPacketSize ) {
        pUrb->UrbIsochronousTransfer.IsoPacket[i++].Offset = ulDataOffset;

        pUrb->UrbIsochronousTransfer.NumberOfPackets++;
        ASSERT( pUrb->UrbIsochronousTransfer.NumberOfPackets <= ulNumberOfPackets );

		pT1PinContext->ulLeftoverFraction += pT1PinContext->ulFractionSize;
		pT1PinContext->ulLeftoverFraction %= MS_PER_SEC;

        DbgLog( "BldLp", ulCurrentPacketSize, ulSampleCount, pKsStreamPtrOffsetIn->Data, ulDataOffset );

        ulDataOffset                    += ulCurrentPacketSize * pT1PinContext->ulBytesPerSample;
		pKsStreamPtrOffsetIn->Remaining -= ulCurrentPacketSize * pT1PinContext->ulBytesPerSample;
		ulSampleCount -= ulCurrentPacketSize;

    	ulCurrentPacketSize = 
	    	( ((pT1PinContext->ulLeftoverFraction+pT1PinContext->ulFractionSize) >= MS_PER_SEC) +
            pT1PinContext->ulSamplesPerPacket );

    }

    pUrb->UrbIsochronousTransfer.TransferBufferLength = ulDataOffset;
    pIsoUrbInfo->ulTransferBufferLength = ulDataOffset;
    pKsStreamPtrOffsetIn->Data += ulDataOffset;

    // Gotta save off the leftovers before submitting this Urb.
    if ( pKsStreamPtrOffsetIn->Remaining ) {
        PMSEC_BUF_INFO pCurrent1MsBuf;

        DbgLog( "BldRemn", pKsStreamPtrOffsetIn->Remaining, pKsStreamPtrOffsetIn->Count,
                           pKsStreamPtrOffsetIn->Data, ulDataOffset);

        KeWaitForSingleObject( &pT1PinContext->MsecBufferSemaphore,
                               Executive,
                               KernelMode,
                               FALSE,
                               NULL );

        KeAcquireSpinLock( &pPinContext->PinSpinLock, &Irql );
        if ( !IsListEmpty( &pT1PinContext->MSecBufList )) {
            pCurrent1MsBuf = (PMSEC_BUF_INFO)pT1PinContext->MSecBufList.Flink;
            KeReleaseSpinLock( &pPinContext->PinSpinLock, Irql );

            pCurrent1MsBuf->ulTransferBufferLength = pKsStreamPtrOffsetIn->Remaining;

            // Copy next partial to next 1ms buffer
            RtlCopyMemory( pCurrent1MsBuf->pBuffer,
                           pKsStreamPtrOffsetIn->Data,
                           pKsStreamPtrOffsetIn->Remaining );

		    pT1PinContext->ulPartialBufferSize = (ulCurrentPacketSize*pT1PinContext->ulBytesPerSample) - 
												 pKsStreamPtrOffsetIn->Remaining;
             DbgLog( "PartBuf", ulCurrentPacketSize, ulSampleCount, 
                                pT1PinContext->ulPartialBufferSize, 0 );
            pT1PinContext->ulLeftoverFraction += pT1PinContext->ulFractionSize;
            pT1PinContext->ulLeftoverFraction %= MS_PER_SEC;
        }
        else {
            KeReleaseSpinLock( &pPinContext->PinSpinLock, Irql );
        }

    }

    pIrp->IoStatus.Status = STATUS_SUCCESS;

    nextStack = IoGetNextIrpStackLocation(pIrp);
    ASSERT(nextStack != NULL);

    nextStack->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
    nextStack->Parameters.Others.Argument1 = pUrb;
    nextStack->Parameters.DeviceIoControl.IoControlCode = IOCTL_INTERNAL_USB_SUBMIT_URB;

    IoSetCompletionRoutine ( pIrp, pCompletionRoutine, pKsStreamPtr, TRUE, TRUE, TRUE );

    InterlockedIncrement( &pPinContext->ulOutstandingUrbCount );

    // Add Urb to InUse list
    if (pCompletionRoutine == TypeICompleteCallback) {
        KeAcquireSpinLock(&pPinContext->PinSpinLock, &Irql);
        // DbgLog("ADD", &pT1PinContext->UrbInUseList, pIsoUrbInfo, pUrb, 0);
        InsertTailList( &pT1PinContext->UrbInUseList, &pIsoUrbInfo->List );
        KeReleaseSpinLock(&pPinContext->PinSpinLock, Irql);
    }

    ntStatus = IoCallDriver( pPinContext->pNextDeviceObject, pIrp );

    if ( NT_SUCCESS(ntStatus) ) {
        if (pCompletionRoutine == TypeICompleteCallback) {
            KeAcquireSpinLock(&pPinContext->PinSpinLock, &Irql);
            pPinContext->fStreamStartedFlag = TRUE;
            KeReleaseSpinLock(&pPinContext->PinSpinLock, Irql);
        }
    }
    
    return ntStatus;
}

NTSTATUS
TypeILockDelay( PKSPIN pKsPin )
{
    PPIN_CONTEXT pPinContext = pKsPin->Context;
    PUSBAUDIO_DATARANGE pUsbAudioDataRange = pPinContext->pUsbAudioDataRange;
    PTYPE1_PIN_CONTEXT pT1PinContext = pPinContext->pType1PinContext;
    ULONG ulLockFrames = 0;
    ULONG ulLockSamples;
    ULONG ulDelayBytes;
    NTSTATUS ntStatus = STATUS_SUCCESS;

    // Only values 1 and 2 are defined
    ASSERT(pUsbAudioDataRange->pAudioEndpointDescriptor->bLockDelayUnits < 3);

    // Calculate the size of the delay for the current sample rate.
    switch ( pUsbAudioDataRange->pAudioEndpointDescriptor->bLockDelayUnits ) {
        case EP_LOCK_DELAY_UNITS_MS:
            // Delay is in milliseconds.
            ulLockFrames  =
                (ULONG)pUsbAudioDataRange->pAudioEndpointDescriptor->wLockDelay;
            break;

        case EP_LOCK_DELAY_UNITS_SAMPLES:
            // Delay is in samples. Adjust to nearest ms boundry.
            ulLockFrames =
                (ULONG)pUsbAudioDataRange->pAudioEndpointDescriptor->wLockDelay /
                pT1PinContext->ulSamplesPerPacket;
            break;

        default:
            ntStatus = STATUS_INVALID_PARAMETER;
            break;
    }

    // Ensure that at least something is sent down to the device
    if ( ulLockFrames == 0 ) {
        ulLockFrames++;
    }

    if ( NT_SUCCESS(ntStatus) ) {
        PKSSTREAM_POINTER pKsStreamPtr;
        ULONG ulAllocSize;
        // Calculate the number of the samples to fill the frames and
        // create the pseudo queue pointer for the zeroed data buffer.
        ulLockSamples = ulLockFrames * pT1PinContext->ulSamplesPerPacket +
                        (( ulLockFrames * pT1PinContext->ulFractionSize ) / MS_PER_SEC);
        ulDelayBytes  = ulLockSamples * pT1PinContext->ulBytesPerSample;

        DbgLog( "LockD", ulLockFrames, ulLockSamples,
                pT1PinContext->ulCurrentSampleRate,
                pT1PinContext->ulBytesPerSample );

        _DbgPrintF( DEBUGLVL_TERSE,
                  ("[TypeILockDelay] ulLockFrames: %x ulLockSamples: %x DelayBytes %x\n",
                    ulLockFrames, ulLockSamples, ulDelayBytes));

        ulAllocSize = sizeof(KSSTREAM_POINTER) + ulDelayBytes;
        pKsStreamPtr = AllocMem( NonPagedPool, ulAllocSize );
        if ( pKsStreamPtr ) {
            KIRQL Irql;
            KeAcquireSpinLock( &pPinContext->PinSpinLock, &Irql );
            //
            // NOTE: Resetting the sample rate will cause kmixer and usbaudio to be out of sync
            // w.r.t. their leftover fractions.
            //
            // This might have the side effect of breaking synchronous devices, of which none
            // exist as of today, Feb. 21, 2000.
            //
            //pT1PinContext->fSampleRateChanged = FALSE;
            KeReleaseSpinLock( &pPinContext->PinSpinLock, Irql );

            RtlZeroMemory( pKsStreamPtr, ulAllocSize );
            pKsStreamPtr->Pin                = pKsPin;
            pKsStreamPtr->OffsetIn.Data      = (PUCHAR)(pKsStreamPtr+1);
            pKsStreamPtr->OffsetIn.Count     = ulDelayBytes;
            pKsStreamPtr->OffsetIn.Remaining = ulDelayBytes;
            ntStatus = TypeIBuildIsochRequest( pKsStreamPtr,
                                               TypeILockDelayCompleteCallback );
            if ( !NT_SUCCESS(ntStatus) ) {
                _DbgPrintF( DEBUGLVL_TERSE,("[TypeILockDelay] Status Error: %x\n", ntStatus ));
            }
        }
        else
            ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    }

    return ntStatus;
}


NTSTATUS
TypeIProcessStreamPtr( PKSPIN pKsPin )
{
    PPIN_CONTEXT pPinContext = pKsPin->Context;
    PTYPE1_PIN_CONTEXT pT1PinContext = pPinContext->pType1PinContext;
	PKSSTREAM_POINTER pKsStreamPtr, pKsCloneStreamPtr;
    PKSSTREAM_POINTER_OFFSET pKsStreamPtrOffsetIn;
    PMSEC_BUF_INFO pCurrent1MsBuf;
    KIRQL irql;
    NTSTATUS ntStatus = STATUS_SUCCESS;

    // Check for a data error. If error flag set abort the pipe and start again.
    if ( pPinContext->fUrbError ) {
        AbortUSBPipe( pPinContext );
    }

    KeAcquireSpinLock( &pPinContext->PinSpinLock, &irql );
    if ( pT1PinContext->fSampleRateChanged ) {
        pT1PinContext->ulSamplesPerPacket = pT1PinContext->ulCurrentSampleRate / MS_PER_SEC;
        pT1PinContext->ulFractionSize     = pT1PinContext->ulCurrentSampleRate % MS_PER_SEC;
        pT1PinContext->fSampleRateChanged = FALSE;

        DbgLog( "T1CSRCh", pT1PinContext->ulCurrentSampleRate, 
                           pT1PinContext->ulSamplesPerPacket,
                           pT1PinContext->ulFractionSize,
                           pT1PinContext->ulLeftoverFraction );
    }
    KeReleaseSpinLock( &pPinContext->PinSpinLock, irql );

    if ( pT1PinContext->fLockDelayRequired ) {
        pT1PinContext->fLockDelayRequired = FALSE;
        ntStatus = TypeILockDelay( pKsPin );
    }

    // Get the next Stream pointer from queue
    pKsStreamPtr = KsPinGetLeadingEdgeStreamPointer( pKsPin, KSSTREAM_POINTER_STATE_LOCKED );
    if ( !pKsStreamPtr ) {
        _DbgPrintF(DEBUGLVL_VERBOSE,("[TypeIProcessStreamPtr] Leading edge is NULL\n"));
        return STATUS_SUCCESS;
    }

    DbgLog("T1Proc", pKsPin, pPinContext, pKsStreamPtr, pPinContext->fUrbError);

    // Clone Stream pointer to keep queue moving.
    if ( NT_SUCCESS( KsStreamPointerClone( pKsStreamPtr, NULL, 0, &pKsCloneStreamPtr ) ) ) {

        // Get a pointer to the data information from the stream pointer
        pKsStreamPtrOffsetIn = &pKsCloneStreamPtr->OffsetIn;

        // Set the write offset for position info
        pPinContext->ullWriteOffset += pKsStreamPtrOffsetIn->Count;

        DbgLog("ByteCnt", pKsStreamPtrOffsetIn->Data, pKsStreamPtrOffsetIn->Count, 0, 0);


        // Copy partial ms data to current 1ms buffer and send if full
        if ( pT1PinContext->ulPartialBufferSize ) {

            KeAcquireSpinLock(&pPinContext->PinSpinLock, &irql);
            pCurrent1MsBuf = (PMSEC_BUF_INFO)RemoveHeadList(&pT1PinContext->MSecBufList);
            KeReleaseSpinLock(&pPinContext->PinSpinLock, irql);

            RtlCopyMemory( pCurrent1MsBuf->pBuffer + pCurrent1MsBuf->ulTransferBufferLength,
                           pKsStreamPtrOffsetIn->Data,
                           pT1PinContext->ulPartialBufferSize );

            pCurrent1MsBuf->ulTransferBufferLength += pT1PinContext->ulPartialBufferSize;
            TypeIBuild1MsecIsocRequest( pCurrent1MsBuf );

            pKsStreamPtrOffsetIn->Remaining -= pT1PinContext->ulPartialBufferSize;
            pKsStreamPtrOffsetIn->Data      += pT1PinContext->ulPartialBufferSize;

			pT1PinContext->ulPartialBufferSize = 0;

        }

        // Create the URB for the majority of the data
        ntStatus = TypeIBuildIsochRequest( pKsCloneStreamPtr,
                                           TypeICompleteCallback );
         if ( NT_SUCCESS(ntStatus)) ntStatus = STATUS_SUCCESS;

        // If there is a sync endpoint, poll it for feedback
        if ( pPinContext->pUsbAudioDataRange->pSyncEndpointDescriptor ) {
            ULONG ulCurrentFrame;
            if (NT_SUCCESS( GetCurrentUSBFrame(pPinContext, &ulCurrentFrame)) &&
                (LONG)(ulCurrentFrame-pT1PinContext->SyncEndpointInfo.ulNextPollFrame) >= 0) {

                 KeAcquireSpinLock(&pPinContext->PinSpinLock, &irql);
                 if ( !pT1PinContext->SyncEndpointInfo.fSyncRequestInProgress ) {
                     pT1PinContext->SyncEndpointInfo.fSyncRequestInProgress = TRUE;
                    KeReleaseSpinLock(&pPinContext->PinSpinLock, irql);
                     TypeIAsyncEndpointPoll( pPinContext->pNextDeviceObject,
                                             &pT1PinContext->SyncEndpointInfo );
                 }
                 else
                     KeReleaseSpinLock(&pPinContext->PinSpinLock, irql);
            }
        }
    }

    // Unlock the stream pointer. This will really only unlock after last clone is deleted.
    KsStreamPointerUnlock( pKsStreamPtr, TRUE );

    return ntStatus;
}

NTSTATUS
TypeIStateChange(
    PKSPIN pKsPin,
    KSSTATE OldKsState,
    KSSTATE NewKsState )
{
    PPIN_CONTEXT pPinContext = pKsPin->Context;
    PTYPE1_PIN_CONTEXT pT1PinContext = pPinContext->pType1PinContext;
    NTSTATUS ntStatus = STATUS_SUCCESS;
    KIRQL irql;

    switch(NewKsState) {
        case KSSTATE_STOP:
            KeAcquireSpinLock( &pPinContext->PinSpinLock, &irql );

            // Need to reset position counters and stream running flag
            pPinContext->fStreamStartedFlag = FALSE;
            pPinContext->ullWriteOffset = 0;

            pPinContext->ullTotalBytesReturned = 0;
            pPinContext->ulCurrentFrame = 0;
            pPinContext->ulFrameRepeatCount = 0;

            // Reset to original Sample rate
            pT1PinContext->ulCurrentSampleRate = pT1PinContext->ulOriginalSampleRate;
            pT1PinContext->fSampleRateChanged = TRUE;
            pT1PinContext->ulLeftoverFraction  = 0;

            KeReleaseSpinLock( &pPinContext->PinSpinLock, irql );

            pPinContext->StarvationDetected = FALSE;
            break;

        case KSSTATE_ACQUIRE:
            break;

        case KSSTATE_PAUSE:
            KeAcquireSpinLock( &pPinContext->PinSpinLock, &irql );

            // Reset to original Sample rate on Async endpoints
            // Don't do for adaptive endpoints, or else we will have to do a copy
            // which is bad for real-time mixing
            if ( pPinContext->pUsbAudioDataRange->pSyncEndpointDescriptor ) {
                pT1PinContext->ulCurrentSampleRate = pT1PinContext->ulOriginalSampleRate;
                pT1PinContext->fSampleRateChanged = TRUE;
                pT1PinContext->ulLeftoverFraction  = 0;
            }

            KeReleaseSpinLock( &pPinContext->PinSpinLock, irql );
            break;

        case KSSTATE_RUN:
            pPinContext->GraphJustStarted = TRUE;
            break;
    }

    return ntStatus;
}

NTSTATUS
TypeIRenderStreamInit( PKSPIN pKsPin )
{
    PPIN_CONTEXT pPinContext = pKsPin->Context;
    PUSBAUDIO_DATARANGE pUsbAudioDataRange = pPinContext->pUsbAudioDataRange;
    PKSALLOCATOR_FRAMING_EX pKsAllocatorFramingEx;
    PTYPE1_PIN_CONTEXT pT1PinContext;
    PWAVEFORMATEX pWavFormat;
    PMSEC_BUF_INFO pMsInfo;
    ULONG_PTR pMSBuffers;
    ULONG_PTR pUrbs;
    NTSTATUS ntStatus;
    ULONG BufferSize;
    ULONG NumPages, i;

    // In order to ensure that none of the 1ms buffers cross a page boundary, we
    // are careful to allocate enough space so that we never have to straddle one
    // of the audio buffers across a page boundary.  We also make sure to adjust
    // any that would cross a page boundary, up to the start of the next page.
    // This is to prevent a copy by lower levels of the usb stack, since the UHCD
    // usb hardware cannot deal with a 1ms block that crosses a page boundary.

    // Furthermore, all of the 1ms buffers must be quadword aligned on 64 bit machines.

    // First we calculate how many aligned 1 ms buffers fit in a page.
    i=PAGE_SIZE/(pPinContext->ulMaxPacketSize + sizeof(PVOID)-1);

    if (!i) {
        // If we get here it will be because we finally have USB audio devices
        // that support such high sampling rates and sample sizes that they require a datarate
        // higher than 1 PAGE per ms.  On x86 that would be 4,096,000 bytes per second.
        // That is more than the bandwidth of the USB bus, although it can be supported on USB2.

        // Calculate how many pages per ms we need.
        i=(pPinContext->ulMaxPacketSize + sizeof(PVOID)-1)/PAGE_SIZE;
        if ((pPinContext->ulMaxPacketSize + sizeof(PVOID)-1)%PAGE_SIZE) {
            i++;
        }

        // Now calculate the total number of pages that we need.
        NumPages=NUM_1MSEC_BUFFERS*i;
    }
    else {
        // Now calculate how many pages we need for the 1ms buffers.
        NumPages=NUM_1MSEC_BUFFERS/i;
        if (NUM_1MSEC_BUFFERS%i) {
            NumPages++;
        }
    }

    pPinContext->pType1PinContext=NULL;

    // Allocate space for Type I stream specific information.
    // In order to make sure that the system doesn't shift our allocation and thus
    // invalidate our space calculations and our code for shifting buffers that cross
    // page boundaries, we round this allocation up to an even number of pages.
    pT1PinContext = AllocMem( NonPagedPool, (( NumPages*PAGE_SIZE + sizeof(TYPE1_PIN_CONTEXT) +
                              NUM_1MSEC_BUFFERS * (GET_ISO_URB_SIZE( 1 ) + sizeof(PVOID)-1) +
                              PAGE_SIZE-1)/PAGE_SIZE)*PAGE_SIZE );

    if ( !pT1PinContext ) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    pMSBuffers = (ULONG_PTR)pT1PinContext;

    // Bag the Type1 context for easy cleanup.
    KsAddItemToObjectBag(pKsPin->Bag, pT1PinContext, FreeMem);

    // Set pointers for 1 MS buffers and URBs (even though they may not be used)
    pUrbs = pMSBuffers + NumPages*PAGE_SIZE;
    pT1PinContext = pPinContext->pType1PinContext = (PTYPE1_PIN_CONTEXT)((pUrbs + (NUM_1MSEC_BUFFERS * (GET_ISO_URB_SIZE(1) + sizeof(PVOID)-1)))&~(sizeof(PVOID)-1));

    // Fill in 1ms buffer information structures and init the semaphore
    pMsInfo = pT1PinContext->MSBufInfos;
    InitializeListHead(&pT1PinContext->MSecBufList);
    for (i=0; i<NUM_1MSEC_BUFFERS; i++, pMsInfo++) {
        pMsInfo->pContext = pPinContext;
        pMsInfo->pBuffer = (PUCHAR)pMSBuffers;
        pMsInfo->pUrb = (PURB)pUrbs;

        // Calculate the location of the next ms buffer.  If the next buffer crosses 
        // a page boundary then start it at the beginning of the next page.
        pMSBuffers+=pPinContext->ulMaxPacketSize+sizeof(PVOID)-1;
        pMSBuffers&=~(sizeof(PVOID)-1);
        if ((pMSBuffers^(pMSBuffers+pPinContext->ulMaxPacketSize))&~(PAGE_SIZE-1)) {
            pMSBuffers&=~(PAGE_SIZE-1);
            pMSBuffers+=PAGE_SIZE;
        }

        // Calculate the next urb location.
        pUrbs+=GET_ISO_URB_SIZE(1)+sizeof(PVOID)-1;
        pUrbs&=~(sizeof(PVOID)-1);

        pMsInfo->pIrp = IoAllocateIrp( pPinContext->pNextDeviceObject->StackSize, FALSE );
        if ( !pMsInfo->pIrp ) {
            return STATUS_INSUFFICIENT_RESOURCES;
        }
        // Bag the irps for easy cleanup.
        KsAddItemToObjectBag(pKsPin->Bag, pMsInfo->pIrp, IoFreeIrp);
        InsertTailList( &pT1PinContext->MSecBufList, &pMsInfo->List );
    }

    // Initialize the semaphore for the 1ms buffer structures
    KeInitializeSemaphore( &pT1PinContext->MsecBufferSemaphore, NUM_1MSEC_BUFFERS, NUM_1MSEC_BUFFERS );

    // Initialize the list head for in use list
    InitializeListHead(&pT1PinContext->UrbInUseList);

    // Initialize Packet size and Leftover counters.
    pWavFormat = &((PKSDATAFORMAT_WAVEFORMATEX)pKsPin->ConnectionFormat)->WaveFormatEx;
    pT1PinContext->ulOriginalSampleRate = pWavFormat->nSamplesPerSec;
    pT1PinContext->ulCurrentSampleRate  = pWavFormat->nSamplesPerSec;
    pT1PinContext->ulBytesPerSample     = ((ULONG)pWavFormat->wBitsPerSample >> 3) *
                                          (ULONG)pWavFormat->nChannels;
    pT1PinContext->ulPartialBufferSize = 0;
    pT1PinContext->fSampleRateChanged  = TRUE;
    pT1PinContext->fLockDelayRequired  = FALSE;
    pT1PinContext->ulLeftoverFraction  = 0;

    // Set the current Sample rate
    ntStatus = SetSampleRate(pKsPin, &pT1PinContext->ulCurrentSampleRate);
    if (!NT_SUCCESS(ntStatus)) {
        return ntStatus;
    }

    if ( pUsbAudioDataRange->pSyncEndpointDescriptor ) {
        PSYNC_ENDPOINT_INFO pSyncEndpointInfo = &pT1PinContext->SyncEndpointInfo;
        PUSB_INTERRUPT_ENDPOINT_DESCRIPTOR pInterruptEndpointDescriptor = (PUSB_INTERRUPT_ENDPOINT_DESCRIPTOR)pUsbAudioDataRange->pSyncEndpointDescriptor;

        pSyncEndpointInfo->pUrb = AllocMem( NonPagedPool, GET_ISO_URB_SIZE( 1 ) );
        if ( !pSyncEndpointInfo->pUrb ) {
            return STATUS_INSUFFICIENT_RESOURCES;
        }
        KsAddItemToObjectBag(pKsPin->Bag, pSyncEndpointInfo->pUrb, FreeMem);
        pSyncEndpointInfo->pIrp =
            IoAllocateIrp( pPinContext->pNextDeviceObject->StackSize, FALSE );
        if ( !pSyncEndpointInfo->pIrp ) {
           return STATUS_INSUFFICIENT_RESOURCES;
        }
        KsAddItemToObjectBag(pKsPin->Bag, pSyncEndpointInfo->pIrp, IoFreeIrp);

        pSyncEndpointInfo->fSyncRequestInProgress = FALSE;
        pSyncEndpointInfo->ulNextPollFrame = 0;
        pSyncEndpointInfo->hSyncPipeHandle = NULL;
        pSyncEndpointInfo->pContext = pPinContext;
        pSyncEndpointInfo->ulRefreshRate = 1<<(ULONG)pInterruptEndpointDescriptor->bRefresh;

        _DbgPrintF( DEBUGLVL_VERBOSE, ("ulRefreshRate: %d\n",pSyncEndpointInfo->ulRefreshRate));

        KeInitializeEvent( &pSyncEndpointInfo->SyncPollDoneEvent,
                           SynchronizationEvent,
                           FALSE );

        ASSERT(pSyncEndpointInfo->ulRefreshRate >= 32); // Make sure refresh is reasonable

        for ( i=0; i<pPinContext->ulNumberOfPipes; i++ ) {
            if ( (ULONG)pPinContext->Pipes[i].EndpointAddress ==
                           (ULONG)pUsbAudioDataRange->pSyncEndpointDescriptor->bEndpointAddress ) {
                pSyncEndpointInfo->hSyncPipeHandle = pPinContext->Pipes[i].PipeHandle;
                break;
            }
        }
        if ( !pSyncEndpointInfo->hSyncPipeHandle ) {
            return STATUS_DEVICE_DATA_ERROR;
        }
    }
    // Need to check for lock delay (Note: If async this is illegal)
    else if (( pUsbAudioDataRange->pAudioEndpointDescriptor->bLockDelayUnits ) &&
             ( pUsbAudioDataRange->pAudioEndpointDescriptor->wLockDelay )) {
        pT1PinContext->fLockDelayRequired = TRUE;
    }

    // Set up allocator framing based on gBufferDuration which is read from
    // the registry.  gBufferDuration is the desired duration in usec.

    BufferSize = (ULONG)(((pT1PinContext->ulCurrentSampleRate * (ULONGLONG)gBufferDuration) + 0 )/1000000) * pT1PinContext->ulBytesPerSample;

    // Make sure we always have space for at least one sample.

    if (!BufferSize) {
        BufferSize = pT1PinContext->ulBytesPerSample;
    }

    pKsAllocatorFramingEx = (PKSALLOCATOR_FRAMING_EX)pKsPin->Descriptor->AllocatorFraming;
    pKsAllocatorFramingEx->FramingItem[0].FramingRange.Range.MinFrameSize = 
    pKsAllocatorFramingEx->FramingItem[0].FramingRange.Range.MaxFrameSize = BufferSize;
    pKsAllocatorFramingEx->FramingItem[0].FramingRange.Range.Stepping = pT1PinContext->ulBytesPerSample;

    // Return success
    return STATUS_SUCCESS;
}

NTSTATUS
TypeIRenderStreamClose( PKSPIN pKsPin )
{
    PPIN_CONTEXT pPinContext = pKsPin->Context;
    KIRQL irql;

    // Should not be necessary since close should never happen while
    // there are outstanding requests as they have stream pointers attached
    // Still, it couldn't hurt...
    USBAudioPinWaitForStarvation( pKsPin );

    // If this is an Async endpoint device make sure no Async Poll
    // requests are still outstanding.
    if ( pPinContext->pUsbAudioDataRange->pSyncEndpointDescriptor ) {
        PTYPE1_PIN_CONTEXT pT1PinContext = pPinContext->pType1PinContext;
        KeAcquireSpinLock(&pPinContext->PinSpinLock, &irql);
        if ( pT1PinContext->SyncEndpointInfo.fSyncRequestInProgress ) {
            KeResetEvent( &pT1PinContext->SyncEndpointInfo.SyncPollDoneEvent );
            KeReleaseSpinLock(&pPinContext->PinSpinLock, irql);
            KeWaitForSingleObject( &pT1PinContext->SyncEndpointInfo.SyncPollDoneEvent,
                                   Executive,
                                   KernelMode,
                                   FALSE,
                                   NULL );
        }
        else
            KeReleaseSpinLock(&pPinContext->PinSpinLock, irql);
    }


    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\drivers\usbaudio.2\usbaudio.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 2000
//
//  File:       usbaudio.h
//
//--------------------------------------------------------------------------

#ifndef _USBAUDIO_H_
#define _USBAUDIO_H_

#define USBAUDIO_POOLTAG 'ABSU'

#define MAX_ULONG  ((ULONG) -1)

static const WCHAR MediaCategories[] = L"\\Registry\\Machine\\SYSTEM\\CurrentControlSet\\Control\\MediaCategories\\";
static const WCHAR NodeNameValue[] =   L"Name";

extern ULONG gBufferDuration;

//
// Structure forward declarations.
//
typedef struct _MIDI_PIPE_INFORMATION
MIDI_PIPE_INFORMATION, *PMIDI_PIPE_INFORMATION;
typedef struct _HW_DEVICE_EXTENSION
HW_DEVICE_EXTENSION, *PHW_DEVICE_EXTENSION;


// Cached Values for DB Level Controls
typedef struct {
    ULONG ulChannelNumber;
    ULONG ulChannelIndex;
    LONG lLastValueSet;
    KSPROPERTY_STEPPING_LONG Range;
} DB_LEVEL_CACHE, *PDB_LEVEL_CACHE;

// Structure to Cache channel based Boolean control values
typedef struct {
    ULONG ulChannelNumber;
    ULONG ulChannelIndex;
    BOOL fLastValueSet;
} BOOLEAN_CTRL_CACHE, *PBOOLEAN_CTRL_CACHE;

// Cached Values for Processing Unit Node ranges
typedef struct {
    ULONG ulControlBit;
    ULONG ulControlSelector;
    LONG lLastValueSet;
    KSPROPERTY_STEPPING_LONG Range;
} PROCESS_CTRL_RANGE, *PPROCESS_CTRL_RANGE;

// Cached Values for Processing Unit Node controls
typedef struct {
    BOOL fEnableBit;
    BOOL fEnabled;
    ULONG bmControlBitMap;
} PROCESS_CTRL_CACHE, *PPROCESS_CTRL_CACHE;

// Information about each Topology node
typedef struct _TOPOLOGY_NODE_INFO {
    KSNODE_DESCRIPTOR KsNodeDesc;         // 3 Long Words
    KSAUTOMATION_TABLE KsAutomationTable; // 9 Long Words
    PVOID pUnit;
    UCHAR MapNodeToCtrlIF;
    ULONG ulNodeType;
    ULONG fBypassFlag; // Flag is set if the node can be bypassed.
    union {
        ULONG ulControlType;
        ULONG ulPinNumber;
    };
    ULONG ulChannelConfig;
    ULONG ulChannels;
    ULONG ulCacheValid;
    ULONG ulNumCachedValues;
    PVOID pCachedValues;
} TOPOLOGY_NODE_INFO, *PTOPOLOGY_NODE_INFO;

// DataRange Structures to associate Interfaces with Datarange
typedef struct _USBAUDIO_DATARANGE {

    KSDATARANGE_AUDIO KsDataRangeAudio;

    PUSB_INTERFACE_DESCRIPTOR pInterfaceDescriptor;

    PAUDIO_CLASS_STREAM pAudioDescriptor;

    PAUDIO_ENDPOINT_DESCRIPTOR pAudioEndpointDescriptor;

    PUSB_ENDPOINT_DESCRIPTOR pEndpointDescriptor;

    PUSB_ENDPOINT_DESCRIPTOR pSyncEndpointDescriptor;

    PAUDIO_UNIT pTerminalUnit;

    ULONG ulChannelConfig;

    ULONG ulUsbDataFormat;

    ULONG ulMaxSampleRate;

} USBAUDIO_DATARANGE, *PUSBAUDIO_DATARANGE;

// SubContext for Type I render pins
typedef struct {
    LIST_ENTRY List;
    ULONG ulTransferBufferLength;
    PURB   pUrb;
} ISO_URB_INFO, *PISO_URB_INFO;

typedef struct {
    ISO_URB_INFO;
    PIRP   pIrp;
    PKSPIN pKsPin;
    PUCHAR pBuffer;
    PVOID  pContext;
} MSEC_BUF_INFO, *PMSEC_BUF_INFO, TYPE2_BUF_INFO, *PTYPE2_BUF_INFO;

#define SYNC_ENDPOINT_DATA_SIZE 3

typedef struct _SYNC_ENDPOINT_INFO {
    PURB pUrb;
    PIRP pIrp;
    PVOID pContext;
    ULONG ulNextPollFrame;
    ULONG ulRefreshRate;
    ULONG fSyncRequestInProgress;
    USBD_PIPE_HANDLE hSyncPipeHandle;
    UCHAR Buffer[SYNC_ENDPOINT_DATA_SIZE];
    UCHAR Rsvd;
    KEVENT SyncPollDoneEvent;
} SYNC_ENDPOINT_INFO, *PSYNC_ENDPOINT_INFO;

#define NUM_1MSEC_BUFFERS 12

typedef struct _TYPE1_PIN_CONTEXT {
    ULONG ulCurrentSampleRate;
    ULONG ulOriginalSampleRate;
    ULONG ulLeftoverFraction;
    ULONG ulSamplesPerPacket;
    ULONG ulBytesPerSample;
    ULONG ulFractionSize;
    ULONG ulPartialBufferSize;
    ULONG fSampleRateChanged;
    ULONG fLockDelayRequired;
    LIST_ENTRY MSecBufList;
    KSEMAPHORE MsecBufferSemaphore;
    MSEC_BUF_INFO MSBufInfos[NUM_1MSEC_BUFFERS];
    LIST_ENTRY UrbInUseList;
    SYNC_ENDPOINT_INFO SyncEndpointInfo;
} TYPE1_PIN_CONTEXT, *PTYPE1_PIN_CONTEXT;

// SubContext for Capture pins
#define CAPTURE_URBS_PER_PIN      8

typedef struct _CAPTURE_DATA_BUFFER_INFO {
    LIST_ENTRY List;
    PKSPIN pKsPin;
    PIRP   pIrp;
    PURB   pUrb;
    PUCHAR pData;
} CAPTURE_DATA_BUFFER_INFO, *PCAPTURE_DATA_BUFFER_INFO;

typedef struct _CAPTURE_PIN_CONTEXT {
    ULONG fRunning;
    ULONG fProcessing;
    ULONG fDataDiscontinuity;
    ULONG ulAvgBytesPerSec;
    ULONG ulCurrentSampleRate;
    ULONG ulBytesPerSample;
    ULONG ulIsochBuffer;
    ULONG ulIsochBufferOffset;
    ULONG ulErrantPackets;
    LIST_ENTRY UrbErrorQueue;
    LIST_ENTRY FullBufferQueue;
    LIST_ENTRY OutstandingUrbQueue;
    PKSWORKER GateOnWorkerObject;
    WORK_QUEUE_ITEM GateOnWorkItem;
    PKSWORKER ResetWorkerObject;
    WORK_QUEUE_ITEM ResetWorkItem;
    PKSWORKER RequeueWorkerObject;
    WORK_QUEUE_ITEM RequeueWorkItem;
    KMUTEX CaptureInitMutex;
    PCAPTURE_DATA_BUFFER_INFO pCaptureBufferInUse;
    CAPTURE_DATA_BUFFER_INFO CaptureDataBufferInfo[CAPTURE_URBS_PER_PIN];
} CAPTURE_PIN_CONTEXT, *PCAPTURE_PIN_CONTEXT;

// SubContext for Type II render pins
#define NUM_T2_BUFFERS  32

typedef struct _TYPE2_PIN_CONTEXT {
    ULONG ulMaxPacketsPerFrame;
    ULONG ulPartialBufferSize;
    LIST_ENTRY Type2BufferList;
    TYPE2_BUF_INFO Type2Buffers[NUM_T2_BUFFERS];
} TYPE2_PIN_CONTEXT, *PTYPE2_PIN_CONTEXT;

#define MAX_NUM_CACHED_MIDI_BYTES 2

typedef struct _MIDIOUT_PIN_CONTEXT {
    ULONG   ulBytesCached;
    KEVENT  PinSaturationEvent;
    BYTE    CachedBytes[MAX_NUM_CACHED_MIDI_BYTES];
    BYTE    bRunningStatus;
} MIDIOUT_PIN_CONTEXT, *PMIDIOUT_PIN_CONTEXT;

typedef union _USBMIDIEVENTPACKET {
    struct {
        BYTE   CodeIndexNumber : 4;
        BYTE   CableNumber : 4;
        BYTE   MIDI_0;
        BYTE   MIDI_1;
        BYTE   MIDI_2;
    } ByteLayout;

    ULONG RawBytes;
} USBMIDIEVENTPACKET, *PUSBMIDIEVENTPACKET;

typedef struct _MIDIIN_URB_BUFFER_INFO {
    LIST_ENTRY  List;
    PMIDI_PIPE_INFORMATION pMIDIPipeInfo;
    PKSPIN      pKsPin;
    PIRP        pIrp;
    PURB        pUrb;
    PUCHAR      pData;
    ULONGLONG   ullTimeStamp;
} MIDIIN_URB_BUFFER_INFO, *PMIDIIN_URB_BUFFER_INFO;

typedef struct _MIDIIN_USBMIDIEVENT_INFO {
    LIST_ENTRY          List;
    USBMIDIEVENTPACKET  USBMIDIEvent;
    ULONGLONG           ullTimeStamp;
} MIDIIN_USBMIDIEVENT_INFO, *PMIDIIN_USBMIDIEVENT_INFO;

#define MIDIIN_EVENTS_PER_PIN  1024
//#define MIDIIN_EVENTS_PER_PIN  32

typedef struct _MIDIIN_PIN_CONTEXT {
    ULONG fRunning;
    ULONG fProcessing;
    ULONG ulMIDIBytesCopiedToStream;
    ULONGLONG ullStartTime;
    ULONGLONG ullPauseTime;
    PMIDI_PIPE_INFORMATION pMIDIPipeInfo;
    PKSWORKER GateOnWorkerObject;
    WORK_QUEUE_ITEM GateOnWorkItem;

    LIST_ENTRY USBMIDIEventQueue;
    LIST_ENTRY USBMIDIEmptyEventQueue;
    MIDIIN_USBMIDIEVENT_INFO USBMIDIEventInfo[MIDIIN_EVENTS_PER_PIN];
} MIDIIN_PIN_CONTEXT, *PMIDIIN_PIN_CONTEXT;

typedef struct _MIDI_PIN_CONTEXT {
    ULONG ulJackID;
    ULONG ulInterfaceNumber;
    ULONG ulEndpointNumber;
    ULONG ulCableNumber;
    union {
        PMIDIOUT_PIN_CONTEXT pMIDIOutPinContext;
        PMIDIIN_PIN_CONTEXT pMIDIInPinContext;
    };
} MIDI_PIN_CONTEXT, *PMIDI_PIN_CONTEXT;

typedef enum {
    WaveOut,
    WaveIn,
    MidiOut,
    MidiIn
} PINTYPE;

// Context for each opened pin
typedef struct _PIN_CONTEXT {

    PHW_DEVICE_EXTENSION pHwDevExt;

    PDEVICE_OBJECT pNextDeviceObject;

    PUSBAUDIO_DATARANGE pUsbAudioDataRange;

    PINTYPE PinType;

    ULONG ulMaxPacketSize;

    ULONG ulOutstandingUrbCount;

    ULONG fUrbError;

    ULONG ulNumberOfPipes;
    USBD_PIPE_HANDLE hPipeHandle;
    PUSBD_PIPE_INFORMATION Pipes;

    // DRM
    ULONG DrmContentId;

    union {
        PTYPE1_PIN_CONTEXT   pType1PinContext;
        PTYPE2_PIN_CONTEXT   pType2PinContext;
        PCAPTURE_PIN_CONTEXT pCapturePinContext;
        PMIDI_PIN_CONTEXT    pMIDIPinContext;
    };

    ULONG fStreamStartedFlag;
    ULONG ulStreamUSBStartFrame;

#if DBG
    ULONGLONG ullOldPlayOffset;
#endif

    ULONGLONG ullWriteOffset;
    ULONGLONG ullTotalBytesReturned;
    ULONG ulCurrentFrame;
    ULONG ulFrameRepeatCount;
    
    KSPIN_LOCK PinSpinLock;

    KEVENT PinStarvationEvent;

    HANDLE hSystemStateHandle;

    BOOLEAN StarvationDetected;
    LONGLONG LastStateChangeTimeSample;
    BOOLEAN GraphJustStarted;

} PIN_CONTEXT, *PPIN_CONTEXT;

typedef struct _MIDIIN_PIN_LISTENTRY {
    LIST_ENTRY  List;
    PKSPIN      pKsPin;
    PVOID       pContext;
} MIDIIN_PIN_LISTENTRY, *PMIDIIN_PIN_LISTENTRY;

#define MIDIIN_URBS_PER_PIPE       256
//#define MIDIIN_URBS_PER_PIPE       32

typedef struct _MIDI_PIPE_INFORMATION {
    PHW_DEVICE_EXTENSION pHwDevExt;
    PDEVICE_OBJECT pNextDeviceObject;

    ULONG ulInterfaceNumber;
    ULONG ulEndpointNumber;

    BOOL fRunning;
    ULONG ulOutstandingUrbCount;
    KEVENT PipeStarvationEvent;

    ULONG fUrbError;

    ULONG ulNumberOfPipes;
    USBD_PIPE_HANDLE hPipeHandle;
    PUSBD_PIPE_INFORMATION Pipes;
    ULONG ulMaxPacketSize;

    PKSWORKER RequeueUrbWorkerObject;
    WORK_QUEUE_ITEM RequeueUrbWorkItem;
    LIST_ENTRY EmptyBufferQueue;
    PMIDIIN_URB_BUFFER_INFO pCaptureBufferInUse;
    MIDIIN_URB_BUFFER_INFO CaptureDataBufferInfo[MIDIIN_URBS_PER_PIPE];

    KSPIN_LOCK PipeSpinLock;
    LIST_ENTRY MIDIInActivePinList;
} MIDI_PIPE_INFORMATION, *PMIDI_PIPE_INFORMATION;

typedef struct _PIN_CINSTANCES
{
    ULONG   PossibleCount;
    ULONG   CurrentCount;
}
PIN_CINSTANCES, *PPIN_CINSTANCES;

// Hardware device extension
typedef struct _HW_DEVICE_EXTENSION {

    ULONG fDeviceStopped;

    PDEVICE_OBJECT pNextDeviceObject;

    PUSB_CONFIGURATION_DESCRIPTOR pConfigurationDescriptor;
    PUSB_DEVICE_DESCRIPTOR pDeviceDescriptor;

    KSFILTER_DESCRIPTOR USBAudioFilterDescriptor;

    PUSBD_INTERFACE_LIST_ENTRY pInterfaceList;
    USBD_CONFIGURATION_HANDLE ConfigurationHandle;

    BOOL fDigitalOutput;

    PUSB_BUS_INTERFACE_USBDI_V0 pBusIf;

    PPIN_CINSTANCES pPinInstances;  // array of pin instances

    ULONG ulInterfaceNumberSelected;
    ULONG ulNumberOfMIDIPipes;
    USBD_PIPE_HANDLE hPipeHandle;
    PUSBD_PIPE_INFORMATION Pipes;

    PMIDI_PIPE_INFORMATION pMIDIPipeInfo;

} HW_DEVICE_EXTENSION, *PHW_DEVICE_EXTENSION;

// Context for the device filter
typedef struct _FILTER_CONTEXT {

    PHW_DEVICE_EXTENSION pHwDevExt;

    PDEVICE_OBJECT pNextDeviceObject;

} FILTER_CONTEXT, *PFILTER_CONTEXT;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\drivers\usbaudio.2\usbaudio.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 2000
//
//  File:       usbaudio.c
//
//--------------------------------------------------------------------------

#include "common.h"
#include "perf.h"
#include <ksmediap.h>

ULONG gBufferDuration;

#if DBG
ULONG USBAudioDebugLevel = DEBUGLVL_TERSE;
#endif

const
KSDEVICE_DISPATCH
USBAudioDeviceDispatch =
{
    USBAudioAddDevice,
    USBAudioPnpStart,
    NULL, // Post Start
    USBAudioPnpQueryStop,
    USBAudioPnpCancelStop,
    USBAudioPnpStop,
    USBAudioPnpQueryRemove,
    USBAudioPnpCancelRemove,
    USBAudioPnpRemove,
    USBAudioPnpQueryCapabilities,
    USBAudioSurpriseRemoval,
    USBAudioQueryPower,
    USBAudioSetPower
};

const
KSDEVICE_DESCRIPTOR
USBAudioDeviceDescriptor =
{
    &USBAudioDeviceDispatch,
    0,
    NULL
};


NTSTATUS
QueryRegistryValueEx(
    ULONG Hive,
    PWSTR pwstrRegistryPath,
    PWSTR pwstrRegistryValue,
    ULONG uValueType,
    PVOID *ppValue,
    PVOID pDefaultData,
    ULONG DefaultDataLength
)
{
    PRTL_QUERY_REGISTRY_TABLE pRegistryValueTable = NULL;
    UNICODE_STRING usString;
    DWORD dwValue;
    NTSTATUS Status = STATUS_SUCCESS;
    usString.Buffer = NULL;

    pRegistryValueTable = (PRTL_QUERY_REGISTRY_TABLE) ExAllocatePoolWithTag(
                            PagedPool,
                            (sizeof(RTL_QUERY_REGISTRY_TABLE)*2),
                            'aBSU');

    if(!pRegistryValueTable) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto exit;
    }

    RtlZeroMemory(pRegistryValueTable, (sizeof(RTL_QUERY_REGISTRY_TABLE)*2));

    pRegistryValueTable[0].Flags = RTL_QUERY_REGISTRY_DIRECT;
    pRegistryValueTable[0].Name = pwstrRegistryValue;
    pRegistryValueTable[0].DefaultType = uValueType;
    pRegistryValueTable[0].DefaultLength = DefaultDataLength;
    pRegistryValueTable[0].DefaultData = pDefaultData;

    switch (uValueType) {
        case REG_SZ:
            pRegistryValueTable[0].EntryContext = &usString;
            break;
        case REG_DWORD:
            pRegistryValueTable[0].EntryContext = &dwValue;
            break;
        default:
            Status = STATUS_INVALID_PARAMETER ;
            goto exit;
    }

    Status = RtlQueryRegistryValues(
      Hive,
      pwstrRegistryPath,
      pRegistryValueTable,
      NULL,
      NULL);

    if(!NT_SUCCESS(Status)) {
        goto exit;
    }

    switch (uValueType) {
        case REG_SZ:
            *ppValue = ExAllocatePoolWithTag(
                        PagedPool,
                        usString.Length + sizeof(UNICODE_NULL),
                        'aBSU');
            if(!(*ppValue)) {
                RtlFreeUnicodeString(&usString);
                Status = STATUS_INSUFFICIENT_RESOURCES;
                goto exit;
            }
            memcpy(*ppValue, usString.Buffer, usString.Length);
            ((PWCHAR)*ppValue)[usString.Length/sizeof(WCHAR)] = UNICODE_NULL;

            RtlFreeUnicodeString(&usString);
            break;

        case REG_DWORD:
            *ppValue = ExAllocatePoolWithTag(
                        PagedPool,
                        sizeof(DWORD),
                        'aBSU');
            if(!(*ppValue)) {
                Status = STATUS_INSUFFICIENT_RESOURCES;
                goto exit;
            }
            *((DWORD *)(*ppValue)) = dwValue;
            break;

        default:
            Status = STATUS_INVALID_PARAMETER ;
            goto exit;
    }
exit:
    if (pRegistryValueTable) {
        ExFreePool(pRegistryValueTable);
    }
    return(Status);
}


ULONG
GetUlongFromRegistry(
    PWSTR pwstrRegistryPath,
    PWSTR pwstrRegistryValue,
    ULONG DefaultValue
)
{
    PVOID      pulValue ;
    ULONG       ulValue ;
    NTSTATUS    Status ;

    Status = QueryRegistryValueEx(RTL_REGISTRY_ABSOLUTE,
                         pwstrRegistryPath,
                         pwstrRegistryValue,
                         REG_DWORD,
                         &pulValue,
                         &DefaultValue,
                         sizeof(DWORD));
    if (NT_SUCCESS(Status)) {
        ulValue = *((PULONG)pulValue);
        ExFreePool(pulValue);
    }
    else {
        ulValue = DefaultValue;
    }
    return ( ulValue ) ;
}


NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPathName
    )
/*++

Routine Description:

    Sets up the driver object.

Arguments:

    DriverObject -
        Driver object for this instance.

    RegistryPathName -
        Contains the registry path which was used to load this instance.

Return Values:

    Returns STATUS_SUCCESS if the driver was initialized.

--*/
{
    NTSTATUS RetValue;

    _DbgPrintF(DEBUGLVL_TERSE,("[DriverEntry]\n\tUSBAudioDeviceDescriptor@%x\n\tUSBAudioDeviceDescriptor->Dispatch@%x\n",
                               &USBAudioDeviceDescriptor,
                               USBAudioDeviceDescriptor.Dispatch));

    // Query the registry for the default audio buffer duration.

    gBufferDuration = GetUlongFromRegistry( CORE_AUDIO_BUFFER_DURATION_PATH,
                                            CORE_AUDIO_BUFFER_DURATION_VALUE,
                                            DEFAULT_CORE_AUDIO_BUFFER_DURATION );

    // Limit duration maximum.

    if ( gBufferDuration > MAX_CORE_AUDIO_BUFFER_DURATION ) {

        gBufferDuration = MAX_CORE_AUDIO_BUFFER_DURATION;

    }

    // Limit duration minimum.

    if ( gBufferDuration < MIN_CORE_AUDIO_BUFFER_DURATION ) {

        gBufferDuration = MIN_CORE_AUDIO_BUFFER_DURATION;

    }

#if !(MIN_CORE_AUDIO_BUFFER_DURATION/1000)
#error MIN_CORE_AUDIO_BUFFER_DURATION less than 1ms not yet supported in usbaudio!
#endif

    RetValue = KsInitializeDriver(
        DriverObject,
        RegistryPathName,
        &USBAudioDeviceDescriptor);

    //
    // Insert a WMI event tracing handler.
    //
    
    PerfSystemControlDispatch = DriverObject->MajorFunction[IRP_MJ_SYSTEM_CONTROL];
    DriverObject->MajorFunction[IRP_MJ_SYSTEM_CONTROL] = PerfWmiDispatch;

    return RetValue;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\drm\krm\cryptk\cbc64ws4.cpp ===
#include "crptkPCH.h"
//-----------------------------------------------------------------------------
//
// File:   CBC64WS4.cpp
//
// Microsoft Digital Rights Management
// Copyright (C) 1998-1999 Microsoft Corporation, All Rights Reserved
//
// Description:
//
//-----------------------------------------------------------------------------

/*

chain-sum MAC scheme 4.5: multiply-&-swap rounds plus sum (reversible -- reversal code included)

6/15/98 mj
8/22/98 mj
8/31/98 mj
9/21/98 mj
2/4/99 mj

*/


#include "cbckey.h"




#ifndef SHCLASS
#define SHCLASS
#endif



//
// C version
//

#define WORDSWAP(d) \
	((d >> 16) + (d << 16))

// pairwise independent function and summing step
#define C_STEP(L1, L2, L3, L4, L5, L6) \
	t += *Data++; \
	t *= L1; \
	t = WORDSWAP(t); \
	t *= L2; \
	t = WORDSWAP(t); \
	t *= L3; \
	t = WORDSWAP(t); \
	t *= L4; \
	t = WORDSWAP(t); \
	t *= L5; \
	t += L6; \
	sum += t;

// MAC function
// returns half of 64-bit MAC, and places other half in *pKey2
UINT32 CBC64WS4_asm(
          UINT32   *Data,
          unsigned NumDWORDBlocks,
          UINT32   *pKey2,
		  CBCKey key)
{
	UINT32 sum = 0, t = 0;
	while (NumDWORDBlocks > 0) {
		C_STEP(key.a1, key.b1, key.c1, key.d1, key.e1, key.f1);
		C_STEP(key.a2, key.b2, key.c2, key.d2, key.e2, key.f2);
		NumDWORDBlocks -= 2;
	}
	*pKey2 = t;
	return sum;
}




//
// inverse MAC
//

// compute gcd(a, b) = x*a + y*b
static void egcd(UINT64 a, UINT64 b, __int64 &gcd, __int64 &x, __int64 &y)
{
	if (b == 0) {
		gcd = a; x = 1; y = 1;
	}
	else {
		egcd(b, a % b, gcd, x, y);
		__int64 t = y;
		y = x - y*(a/b);
		x = t;
	}
}

// invert n mod 2^32
UINT32 inv32(UINT32 n)
{
	__int64 gcd, in, x;
	__int64 modulus = (__int64)1<<32;
	egcd(modulus, n, gcd, x, in);
	while (in < 0)
		in += modulus;
	return (UINT32) in;
}





// step to reverse action of multiply-&-swap rounds
#define INV_STEP_C(iL1, iL2, iL3, iL4, iL5) \
	tmp *= iL5; \
	tmp = WORDSWAP(tmp); \
	tmp *= iL4; \
	tmp = WORDSWAP(tmp); \
	tmp *= iL3; \
	tmp = WORDSWAP(tmp); \
	tmp *= iL2; \
	tmp = WORDSWAP(tmp); \
	tmp *= iL1;

// inverse MAC function
// decrypts last two blocks of Data
// (replaces 64-bit ciphertext Data[NumDWORDBlocks - 1] and Data[NumDWORDBlocks - 2] with
// plaintext, and returns the plaintext in the return value and *pKey2 -- change as required)
UINT32 InvCBC64WS4_asm(
          UINT32   *Data,
          unsigned NumDWORDBlocks,
          UINT32   *pKey2,
		  CBCKey key,
		  CBCKey ikey )
{
	UINT32 yn, yn1, yn2, xn, xn1;

	UINT32 sum32, tmp;


	// Invert last two blocks (sum and 32-bit MAC).  This requires the encrypted last two
	// blocks and the (NumDWORDBlocks-2) plaintext blocks.
	sum32 = CBC64WS4_asm(Data, NumDWORDBlocks - 2, &yn2, key) + Data[NumDWORDBlocks - 1];



	yn = Data[NumDWORDBlocks - 1];
	yn1 = Data[NumDWORDBlocks - 2] - sum32;

	// last word
	tmp = yn - key.f2;
	INV_STEP_C(ikey.a2, ikey.b2, ikey.c2, ikey.d2, ikey.e2);
	xn = tmp - yn1;

	// next-to-last word
	tmp = yn1 - key.f1;
	INV_STEP_C(ikey.a1, ikey.b1, ikey.c1, ikey.d1, ikey.e1);
	xn1 = tmp - yn2;

	Data[NumDWORDBlocks - 2] = *pKey2 = (UINT32) xn1;
	Data[NumDWORDBlocks - 1] = (UINT32) xn;
	return (UINT32) xn;
}

void CBC64InitState( CBCState *cbcstate ) {
  cbcstate->sum = 0; cbcstate->t = 0; cbcstate->dwBufLen = 0;
}


void CBC64Init( CBCKey *cbckey, CBCState *cbcstate, BYTE *pKey ) {
  UINT32 *p;

  cbcstate->sum = 0; cbcstate->t = 0; cbcstate->dwBufLen = 0;
  p = (UINT32 *)pKey;
  cbckey->a1 = *p++ | 0x00000001;
  cbckey->b1 = *p++ | 0x00000001;
  cbckey->c1 = *p++ | 0x00000001;
  cbckey->d1 = *p++ | 0x00000001;
  cbckey->e1 = *p++ | 0x00000001;
  cbckey->f1 = *p++ | 0x00000001;
  cbckey->a2 = *p++ | 0x00000001;
  cbckey->b2 = *p++ | 0x00000001;
  cbckey->c2 = *p++ | 0x00000001;
  cbckey->d2 = *p++ | 0x00000001;
  cbckey->e2 = *p++ | 0x00000001;
  cbckey->f2 = *p++ | 0x00000001;
}

void CBC64InvKey( CBCKey *cbckey, CBCKey *cbcInvKey ) {
  cbcInvKey->a1 = inv32( cbckey->a1 );
  cbcInvKey->a2 = inv32( cbckey->a2 );
  cbcInvKey->b1 = inv32( cbckey->b1 );
  cbcInvKey->b2 = inv32( cbckey->b2 );
  cbcInvKey->c1 = inv32( cbckey->c1 );
  cbcInvKey->c2 = inv32( cbckey->c2 );
  cbcInvKey->d1 = inv32( cbckey->d1 );
  cbcInvKey->d2 = inv32( cbckey->d2 );
  cbcInvKey->e1 = inv32( cbckey->e1 );
  cbcInvKey->e2 = inv32( cbckey->e2 );
  cbcInvKey->f1 = inv32( cbckey->f1 );
  cbcInvKey->f2 = inv32( cbckey->f2 );
}


// pairwise independent function and summing step
#define MP_C_STEP(Data,L1, L2, L3, L4, L5, L6) \
	t += *Data++; \
	t *= L1; \
	t = WORDSWAP(t); \
	t *= L2; \
	t = WORDSWAP(t); \
	t *= L3; \
	t = WORDSWAP(t); \
	t *= L4; \
	t = WORDSWAP(t); \
	t *= L5; \
	t += L6; \
	sum += t;




void CBC64Update( CBCKey *key, CBCState *cbcstate,DWORD dwLen, BYTE *pData )
{
	DWORD i, copylen=0, tmp;
	DWORD *p;
	UINT32 sum,t;

	sum = cbcstate->sum; t = cbcstate->t;
	if ( cbcstate->dwBufLen > 0 ) {
		copylen = min( dwLen, 8 - cbcstate->dwBufLen );
		for ( i=0; i<copylen; i++ )
			cbcstate->buf[ cbcstate->dwBufLen + i ] = pData[i];
		cbcstate->dwBufLen += copylen;
		if ( cbcstate->dwBufLen == 8 ) {
			p = (DWORD *)cbcstate->buf;
			MP_C_STEP( p, key->a1, key->b1, key->c1, key->d1, key->e1, key->f1 );
			MP_C_STEP( p, key->a2, key->b2, key->c2, key->d2, key->e2, key->f2 );
			cbcstate->dwBufLen = 0;
			}
	}

	tmp = (dwLen - copylen) / 8;
	p = (DWORD *)(pData + copylen);

#ifndef WIN32
#define ARMBUG
#endif

#ifndef ARMBUG
	while (tmp > 0) {
		MP_C_STEP( p, key->a1, key->b1, key->c1, key->d1, key->e1, key->f1);
		MP_C_STEP( p, key->a2, key->b2, key->c2, key->d2, key->e2, key->f2);
		tmp--;
	}
#else
DWORD AllignedDWORD( DWORD * );
DWORD *q;
	while (tmp > 0) {
		q = (DWORD *)cbcstate->buf;
		*q = AllignedDWORD( p++ );
		MP_C_STEP( q, key->a1, key->b1, key->c1, key->d1, key->e1, key->f1);
		*q = AllignedDWORD( p++ );
		MP_C_STEP( q, key->a2, key->b2, key->c2, key->d2, key->e2, key->f2);
		tmp--;
	}

#endif

	tmp = copylen + ((dwLen-copylen) / 8) * 8;
	if ( tmp < dwLen ) {
		for ( i=tmp; i<dwLen; i++ )
			cbcstate->buf[ i - tmp ] = pData[i];
		cbcstate->dwBufLen = dwLen - tmp;
	}

	cbcstate->sum = sum; cbcstate->t = t;
}



UINT32 CBC64Finalize( CBCKey *key, CBCState *cbcstate, UINT32 *pKey2 ) {
	DWORD i, *p;
	UINT32 sum,t;

	if ( cbcstate->dwBufLen > 0 ) {
		for ( i=cbcstate->dwBufLen; i<8; i++ )
			cbcstate->buf[ i ] = 0;
		sum = cbcstate->sum; t = cbcstate->t;
		p = (DWORD *)cbcstate->buf;
		MP_C_STEP( p, key->a1, key->b1, key->c1, key->d1, key->e1, key->f1 );
		MP_C_STEP( p, key->a2, key->b2, key->c2, key->d2, key->e2, key->f2 );
		cbcstate->dwBufLen = 0;
		cbcstate->sum = sum; cbcstate->t = t;
	}

	*pKey2 = cbcstate->t;
	return cbcstate->sum;
}



UINT32 CBC64Invert( CBCKey *key, CBCKey *ikey, UINT32 MacA1, UINT32 MacA2,
		UINT32 MacB1, UINT32 MacB2, UINT32 *pInvKey2 )
{
        UINT32 tmp;
	UINT32 yn, yn1, xn, xn1;

	MacA1 += MacB2;
	yn = MacB2;
	yn1 = MacB1 - MacA1;

	// last word
	tmp = yn - key->f2;
	INV_STEP_C(ikey->a2, ikey->b2, ikey->c2, ikey->d2, ikey->e2);
	xn = tmp - yn1;

	// next-to-last word
	tmp = yn1 - key->f1;
	INV_STEP_C(ikey->a1, ikey->b1, ikey->c1, ikey->d1, ikey->e1);
	xn1 = tmp - MacA2;

	*pInvKey2 = (UINT32) xn1;
	return (UINT32) xn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\drm\krm\cryptk\crptkpch.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	cryptk.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "crptkPCH.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\drm\krm\cryptk\crptkpch.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_cryptkPCH_H__C90220B6_2C31_4C37_B64B_FE26AC602AB0__INCLUDED_)
#define AFX_cryptkPCH_H__C90220B6_2C31_4C37_B64B_FE26AC602AB0__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifndef WIN32_LEAN_AND_MEAN		
	#define WIN32_LEAN_AND_MEAN		// Exclude rarely-used stuff from Windows headers
#endif

#ifdef _KBLD
	#include "DRMKMain/drmkPCH.h"
#else
	#include "KRMProxy/krmpPCH.h"
#endif


// TODO: reference additional headers your program requires here

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__C90220B6_2C31_4C37_B64B_FE26AC602AB0__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\drm\krm\cryptk\bv4.cpp ===
/* Microsoft Corporation (C) 2000 */

#include "crptkPCH.h"
#include "bv4.h"

void bv4_key_C(BV4_KEYSTRUCT *pState, DWORD dwLen, unsigned char *buf)
{
    if (pState == NULL)
    {
        return; // Too bad we return void.
    }
    int keyLength = dwLen;
    BYTE *key = buf;
    
    DWORD i;
    
    for (i = 0; i < 256; i++) 
    {
        pState->p_T[i] = (unsigned char)i;
    }
    
    // fill k with the key, repeated as many times as necessary 
    // to fill the entire array;
    DWORD k[256];  // contains only 8-bit values zero-extended to 32 bits.
    int keyPos = 0;
    for (i = 0; i < 256; i++) 
    {
        if (keyPos >= keyLength) 
        {
            keyPos = 0;
        }
        k[i] = key[keyPos++];
    }
    
    DWORD j = 0;
    for (i = 0; i < 256; i++) 
    {
        j = (j + pState->p_T[i] + k[i]) & 0xff;
        DWORD tmp = pState->p_T[i];
        pState->p_T[i] = pState->p_T[j];
        pState->p_T[j] = (unsigned char)tmp;
    }
    
    // treat alpha and beta as one contiguous array of 33 4-byte blocks.
    // see "Applied Cryptography", 1996, by Bruce Schneier, p. 397.
    
    i = 0;
    j = 0;
    for (int m = 0; m < 33; m++) 
    {
        DWORD nextDword = 0;
        // gather up the next 4 bytes of keys into one DWORD
        for (int n = 0; n < 4; n++) 
        {
          i = (i+1) & 0xff;
          DWORD ti = pState->p_T[i];
          j = (j+ti) & 0xff;
          // swap T[i] and T[j];
          DWORD tj = pState->p_T[j];
          pState->p_T[i] = (unsigned char)tj;
          pState->p_T[j] = (unsigned char)ti;
          DWORD t = (ti+tj) & 0xff;
          DWORD kk = pState->p_T[t];
          nextDword |= kk << (n*8);
        }
        if (m == 0) 
        {
            pState->p_alpha = nextDword;
        } 
        else 
        {
            pState->p_beta[m-1] = nextDword;
        }
    }
    
    // keep the final state as the state we need for the new algorithm.
    // T has already been updated.
    pState->p_R = (unsigned char)i;
    pState->p_S = (unsigned char)j;
}

// cipher: generate a stream of 32-bit keys and xor them with the
// contents of buffer.   This can be used to encrypt/decrypt 
// a stream of data.
void bv4_C(BV4_KEYSTRUCT *pState, DWORD dwLen, unsigned char *buf)
{
    if (pState == NULL)
    {
        return; // Too bad we return void.
    }
    DWORD *buffer = (DWORD *)buf;
    DWORD bufferLength = dwLen / sizeof(DWORD);
    
    DWORD *last = buffer + bufferLength;

    // load field values into local variables
    // the following change on every iteration of the loop
    DWORD r = pState->p_R;
    DWORD s = pState->p_S;
    DWORD alpha = pState->p_alpha;


    // the following are loop invariant
    unsigned char *t = pState->p_T;
    DWORD *beta = pState->p_beta;

    for (last = buffer + bufferLength; buffer < last; buffer++) 
    {
      r = (r+1) & 0xff;
      DWORD tr = t[r];
      s = (s+tr) & 0xff;
      DWORD ts = t[s];
      t[r] = (unsigned char)ts;
      t[s] = (unsigned char)tr;
      DWORD tmp = (ts+tr) & 0xff;
      DWORD randPad = alpha * t[tmp];
      *buffer = randPad^(*buffer);
      alpha = alpha + beta[s & 0x1f];
    }

    // update the field values from the local variables
    pState->p_R = (unsigned char)r;
    pState->p_S = (unsigned char)s;
    pState->p_alpha = alpha;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\drm\krm\drmk\device.cpp ===
/*++

Copyright (C) Microsoft Corporation, 1998 - 1999

Module Name:

    device.cpp

Abstract:

    This module contains the device implementation for audio.sys.

Author:


	Paul England (pengland) from a sample source filter by
    Dale Sather  (DaleSat) 31-Jul-1998

--*/

#define DEFINE_FILTER_DESCRIPTORS_ARRAY
#include "private.h"
#include "../DRMKMain/KGlobs.h"
#include "../DRMKMain/KRMStubs.h"

//-----------------------------------------------------------------------------
extern "C" NTSTATUS DriverEntry(IN PDRIVER_OBJECT DriverObject, IN PUNICODE_STRING RegistryPathName)
{
    return STATUS_SUCCESS;
}

//-----------------------------------------------------------------------------
// DllInitialize and DllUnload
//
EXTERN_C NTSTATUS DllInitialize(PUNICODE_STRING RegistryPath)
{
    NTSTATUS ntStatus;
    _DbgPrintF(DEBUGLVL_VERBOSE,("DRMK:DllInitialize"));
    ntStatus=InitializeDriver();
    return ntStatus;
}

EXTERN_C NTSTATUS DllUnload(void)
{
    PAGED_CODE();
    _DbgPrintF(DEBUGLVL_VERBOSE,("DRMK:DllUnload"));
    CleanupDriver();
    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\drm\krm\drmk\audclass.cpp ===
/*++

Copyright (C) Microsoft Corporation, 1998 - 1999

Module Name:

    audclass.cpp

Abstract:

    This module contains audio class code.

Author:

      Paul England (pengland) from the AUDIO.sys ks2 sample code

	  Dale Sather  (DaleSat) 31-Jul-1998

--*/

#include "private.h"

#ifdef ALLOC_PRAGMA
#pragma code_seg("PAGE")
#endif // ALLOC_PRAGMA

#ifdef ALLOC_DATA_PRAGMA
#pragma const_seg("PAGECONST")
#endif // ALLOC_DATA_PRAGMA

NTSTATUS
DRMAudioIntersectHandlerInPin(
    IN PVOID Filter,
    IN PIRP Irp,
    IN PKSP_PIN PinInstance,
    IN PKSDATARANGE CallerDataRange,
    IN PKSDATARANGE DescriptorDataRange,
    IN ULONG BufferSize,
    OUT PVOID Data OPTIONAL,
    OUT PULONG DataSize
    )

/*++

Routine Description:

    This routine handles pin intersection queries by determining the
    intersection between two data ranges.

Arguments:

    Filter -
        Contains a void pointer to the  filter structure.

    Irp -
        Contains a pointer to the data intersection property request.

    PinInstance -
        Contains a pointer to a structure indicating the pin in question.

    CallerDataRange -
        Contains a pointer to one of the data ranges supplied by the client
        in the data intersection request.  The format type, subtype and
        specifier are compatible with the DescriptorDataRange.

    DescriptorDataRange -
        Contains a pointer to one of the data ranges from the pin descriptor
        for the pin in question.  The format type, subtype and specifier are
        compatible with the CallerDataRange.

    BufferSize -
        Contains the size in bytes of the buffer pointed to by the Data
        argument.  For size queries, this value will be zero.

    Data -
        Optionally contains a pointer to the buffer to contain the data format
        structure representing the best format in the intersection of the
        two data ranges.  For size queries, this pointer will be NULL.

    DataSize -
        Contains a pointer to the location at which to deposit the size of the
        data format.  This information is supplied by the function when the
        format is actually delivered and in response to size queries.

Return Value:

    STATUS_SUCCESS if there is an intersection and it fits in the supplied
    buffer, STATUS_BUFFER_OVERFLOW for successful size queries, STATUS_NO_MATCH
    if the intersection is empty, or STATUS_BUFFER_TOO_SMALL if the supplied
    buffer is too small.

--*/

/*++ 

  DRMK Routine description
  In-pin intersection handler accepts any WAVE_FORMAT_DRM format.  The output pin format
  is modified to correspond to the input pin DRM-encapsulated format.
  
--*/

{
    _DbgPrintF(DEBUGLVL_VERBOSE,("[DRMAudioIntersectHandler - IN]"));

    PAGED_CODE();

    ASSERT(Filter);
    ASSERT(Irp);
    ASSERT(PinInstance);
    ASSERT(CallerDataRange);
    ASSERT(DescriptorDataRange);
    ASSERT(DataSize);

    //
    // Descriptor data range must be WAVEFORMATEX or DSOUND
    //
    ASSERT(IsEqualGUIDAligned(DescriptorDataRange->Specifier,KSDATAFORMAT_SPECIFIER_WAVEFORMATEX) ||
	   IsEqualGUIDAligned(DescriptorDataRange->Specifier,KSDATAFORMAT_SPECIFIER_DSOUND      ));
	   
    PKSDATARANGE_AUDIO descriptorDataRange = PKSDATARANGE_AUDIO(DescriptorDataRange);

    //
    // Caller data range may be wildcard or WAVEFORMATEX or DSOUND
    //
    PKSDATARANGE_AUDIO callerDataRange;
    if (IsEqualGUIDAligned(CallerDataRange->Specifier,KSDATAFORMAT_SPECIFIER_WILDCARD)) {
        //
        // Wildcard.  Do not try to look at the specifier.
        //
        callerDataRange = NULL;
    } else {
        //
        // WAVEFORMATEX or DSOUND.  Validate the specifier ranges.
        //
        ASSERT(IsEqualGUIDAligned(CallerDataRange->Specifier,KSDATAFORMAT_SPECIFIER_WAVEFORMATEX) ||
	       IsEqualGUIDAligned(CallerDataRange->Specifier,KSDATAFORMAT_SPECIFIER_DSOUND      ));

        callerDataRange = PKSDATARANGE_AUDIO(CallerDataRange);

        if ((CallerDataRange->FormatSize != sizeof(*callerDataRange)) ||
            (callerDataRange->MaximumSampleFrequency <
             descriptorDataRange->MinimumSampleFrequency) ||
            (descriptorDataRange->MaximumSampleFrequency <
             callerDataRange->MinimumSampleFrequency) ||
            (callerDataRange->MaximumBitsPerSample <
             descriptorDataRange->MinimumBitsPerSample) ||
            (descriptorDataRange->MaximumBitsPerSample <
             callerDataRange->MinimumBitsPerSample)) {

            _DbgPrintF(DEBUGLVL_VERBOSE,("[DRMINSCT PinIntersectHandler IN]  STATUS_NO_MATCH"));
            return STATUS_NO_MATCH;
        }
    }

    SIZE_T cbDataFormat;
    if (!callerDataRange || IsEqualGUIDAligned(callerDataRange->DataRange.Specifier,KSDATAFORMAT_SPECIFIER_WAVEFORMATEX)) {
        cbDataFormat = sizeof(KSDATAFORMAT_WAVEFORMATEX) + sizeof(DRMWAVEFORMAT) - sizeof(WAVEFORMATEX);
    } else {
        ASSERT(IsEqualGUIDAligned(callerDataRange->DataRange.Specifier,KSDATAFORMAT_SPECIFIER_DSOUND));
        cbDataFormat = sizeof(KSDATAFORMAT_DSOUND) + sizeof(DRMWAVEFORMAT) - sizeof(WAVEFORMATEX);
    }

    if (BufferSize == 0) {
        // Size query - return the size.
        *DataSize = (ULONG)cbDataFormat;
        _DbgPrintF(DEBUGLVL_VERBOSE,("[DRMINSCT PinIntersectHandler IN]  STATUS_BUFFER_OVERFLOW"));
        return STATUS_BUFFER_OVERFLOW;
    }

    PKSDATAFORMAT dataFormat = PKSDATAFORMAT(Data);
    ASSERT(dataFormat);

    if (BufferSize < cbDataFormat) {
        // Buffer is too small.
        _DbgPrintF(DEBUGLVL_VERBOSE,("[DRMINSCT PinIntersectHandler IN]  STATUS_BUFFER_TOO_SMALL"));
        return STATUS_BUFFER_TOO_SMALL;
    }

    //
    // Gotta build the format.
    //
    *DataSize = (ULONG)cbDataFormat;

    RtlZeroMemory(dataFormat, cbDataFormat);

    PDRMWAVEFORMAT drmFormat;
    if (!callerDataRange || IsEqualGUIDAligned(callerDataRange->DataRange.Specifier,KSDATAFORMAT_SPECIFIER_WAVEFORMATEX)) {
        drmFormat = (PDRMWAVEFORMAT)&PKSDATAFORMAT_WAVEFORMATEX(dataFormat)->WaveFormatEx;
    } else {
    	// Note dataFormat->BufferDesc.Flags and Control are memset to 0 above
        drmFormat = (PDRMWAVEFORMAT)&PKSDATAFORMAT_DSOUND(dataFormat)->BufferDesc.WaveFormatEx;
    }
    
    // First let's fill out the wfxSecure format based on the data intersection
    // Without more info, all we can do is propose PCM as the secure format
    drmFormat->wfxSecure.wFormatTag = WAVE_FORMAT_PCM;
    if (callerDataRange) {
        drmFormat->wfxSecure.nChannels      = (USHORT) min(callerDataRange->MaximumChannels,descriptorDataRange->MaximumChannels);
        drmFormat->wfxSecure.nSamplesPerSec = min(callerDataRange->MaximumSampleFrequency,descriptorDataRange->MaximumSampleFrequency);
        drmFormat->wfxSecure.wBitsPerSample = (USHORT) min(callerDataRange->MaximumBitsPerSample,descriptorDataRange->MaximumBitsPerSample);
    } else {
        drmFormat->wfxSecure.nChannels      = (USHORT) descriptorDataRange->MaximumChannels;
        drmFormat->wfxSecure.nSamplesPerSec = descriptorDataRange->MaximumSampleFrequency;
        drmFormat->wfxSecure.wBitsPerSample = (USHORT) descriptorDataRange->MaximumBitsPerSample;
    }
    drmFormat->wfxSecure.nBlockAlign     = (drmFormat->wfxSecure.wBitsPerSample * drmFormat->wfxSecure.nChannels) / 8;
    drmFormat->wfxSecure.nAvgBytesPerSec = drmFormat->wfxSecure.nBlockAlign * drmFormat->wfxSecure.nSamplesPerSec;
    drmFormat->wfxSecure.cbSize          = 0;

    // Now fill out the drm waveformat.  If we someday frame the scrambled data, then
    // we should update this to reflect the framing
    drmFormat->wfx.wFormatTag      = WAVE_FORMAT_DRM;
    drmFormat->wfx.nChannels       = drmFormat->wfxSecure.nChannels;
    drmFormat->wfx.nSamplesPerSec  = drmFormat->wfxSecure.nSamplesPerSec;
    drmFormat->wfx.wBitsPerSample  = drmFormat->wfxSecure.wBitsPerSample;
    drmFormat->wfx.nBlockAlign     = drmFormat->wfxSecure.nBlockAlign;
    drmFormat->wfx.nAvgBytesPerSec = drmFormat->wfxSecure.nAvgBytesPerSec;
    drmFormat->wfx.cbSize          = sizeof(*drmFormat) - sizeof(WAVEFORMATEX);

    // Now finish off some of the fields in the base KSDATAFORMAT_WAVE structure
    // Note all the guids are in the descriptor's data range.
    RtlCopyMemory(dataFormat,DescriptorDataRange,sizeof(*dataFormat));
    dataFormat->FormatSize = (ULONG)cbDataFormat;
    dataFormat->SampleSize = drmFormat->wfx.nBlockAlign;

   _DbgPrintF(DEBUGLVL_VERBOSE,("[DRMINSCT PinIntersectHandler(in)]  DONE OK\n"));
    return STATUS_SUCCESS;
}
//-------------------------------------------------------------------------------------
// OUT
NTSTATUS
DRMAudioIntersectHandlerOutPin(
    IN PVOID Filter,
    IN PIRP Irp,
    IN PKSP_PIN PinInstance,
    IN PKSDATARANGE CallerDataRange,
    IN PKSDATARANGE DescriptorDataRange,
    IN ULONG BufferSize,
    OUT PVOID Data OPTIONAL,
    OUT PULONG DataSize
    )

/*++

Routine Description:

    This routine handles pin intersection queries by determining the
    intersection between two data ranges.

Arguments:

    Filter -
        Contains a void pointer to the  filter structure.

    Irp -
        Contains a pointer to the data intersection property request.

    PinInstance -
        Contains a pointer to a structure indicating the pin in question.

    CallerDataRange -
        Contains a pointer to one of the data ranges supplied by the client
        in the data intersection request.  The format type, subtype and
        specifier are compatible with the DescriptorDataRange.

    DescriptorDataRange -
        Contains a pointer to one of the data ranges from the pin descriptor
        for the pin in question.  The format type, subtype and specifier are
        compatible with the CallerDataRange.

    BufferSize -
        Contains the size in bytes of the buffer pointed to by the Data
        argument.  For size queries, this value will be zero.

    Data -
        Optionally contains a pointer to the buffer to contain the data format
        structure representing the best format in the intersection of the
        two data ranges.  For size queries, this pointer will be NULL.

    DataSize -
        Contains a pointer to the location at which to deposit the size of the
        data format.  This information is supplied by the function when the
        format is actually delivered and in response to size queries.

Return Value:

    STATUS_SUCCESS if there is an intersection and it fits in the supplied
    buffer, STATUS_BUFFER_OVERFLOW for successful size queries, STATUS_NO_MATCH
    if the intersection is empty, or STATUS_BUFFER_TOO_SMALL if the supplied
    buffer is too small.

--*/

/*++ 

  DRMK Routine description
  Out-pin intersection handler specifies the exact encapsulated data format passed to the 
  input pin.
  
--*/
{

    _DbgPrintF(DEBUGLVL_VERBOSE,("[DRMAudioIntersectHandler]"));

    PAGED_CODE();

    ASSERT(Filter);
    ASSERT(Irp);
    ASSERT(PinInstance);
    ASSERT(CallerDataRange);
    ASSERT(DescriptorDataRange);
    ASSERT(DataSize);

    // Must negotiate InPin before OutPin
    PKSFILTER filter = (PKSFILTER) Filter;
    FilterInstance* instance=(FilterInstance*) filter->Context;
    if (!KsFilterGetFirstChildPin(filter,PIN_ID_INPUT)) {
        _DbgPrintF(DEBUGLVL_VERBOSE,("[DRMINSCT Must connect IN before OUT]  -  STATUS_NO_MATCH"));
        return STATUS_NO_MATCH;
    };

    //
    // If we edited the output data range properly, then KS should not
    // ask us to intersect a specifier that doesn't match our required
    // output format specifier
    //
    ASSERT(IsEqualGUIDAligned(DescriptorDataRange->Specifier,instance->OutDataFormat->Specifier));
    PKSDATARANGE_AUDIO descriptorDataRange = PKSDATARANGE_AUDIO(DescriptorDataRange);

    //
    // Caller data range may be wildcard or WAVEFORMATEX or DSOUND
    //
    PKSDATARANGE_AUDIO callerDataRange;
    if (IsEqualGUIDAligned(CallerDataRange->Specifier,KSDATAFORMAT_SPECIFIER_WILDCARD)) {
        //
        // Wildcard.  Do not try to look at the specifier.
        //
        callerDataRange = NULL;
    } else {
        //
        // Not a wild card, so KS should not ask us to intersect a specifier that
        // does not match our required output format specifier (is this true)?
        //
        ASSERT(IsEqualGUIDAligned(CallerDataRange->Specifier,instance->OutDataFormat->Specifier));

        callerDataRange = PKSDATARANGE_AUDIO(CallerDataRange);

        if ((CallerDataRange->FormatSize != sizeof(*callerDataRange)) ||
            (callerDataRange->MaximumSampleFrequency <
             descriptorDataRange->MinimumSampleFrequency) ||
            (descriptorDataRange->MaximumSampleFrequency <
             callerDataRange->MinimumSampleFrequency) ||
            (callerDataRange->MaximumBitsPerSample <
             descriptorDataRange->MinimumBitsPerSample) ||
            (descriptorDataRange->MaximumBitsPerSample <
             callerDataRange->MinimumBitsPerSample)) {

            _DbgPrintF(DEBUGLVL_VERBOSE,("[DRMINSCT PinIntersectHandler OUT]  STATUS_NO_MATCH"));
            return STATUS_NO_MATCH;
        }
    }

    if (BufferSize == 0) {
        // Size query - return the size.
        *DataSize = instance->OutDataFormat->FormatSize;
        _DbgPrintF(DEBUGLVL_VERBOSE,("[DRMINSCT PinIntersectHandler OUT]  STATUS_BUFFER_OVERFLOW"));
        return STATUS_BUFFER_OVERFLOW;
    }

    PKSDATAFORMAT dataFormat = (PKSDATAFORMAT)Data;
    ASSERT(dataFormat);

    if (BufferSize < instance->OutDataFormat->FormatSize) {
        // Buffer is too small.
        _DbgPrintF(DEBUGLVL_VERBOSE,("[DRMINSCT PinIntersectHandler OUT]  STATUS_BUFFER_TOO_SMALL"));
        return STATUS_BUFFER_TOO_SMALL;
    }

    // Input PinCreate builds the required output format in the filter-context, derived from the
    // secure audio format that it encapsulated in the DRMWAVEFORMAT.  Just copy it.
    *DataSize = instance->OutDataFormat->FormatSize;
    RtlCopyMemory(dataFormat, instance->OutDataFormat, instance->OutDataFormat->FormatSize);

   _DbgPrintF(DEBUGLVL_VERBOSE,("[DRMINSCT PinIntersectHandler(out)]  DONE OK\n"));
    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\drm\krm\drmkaud\private.h ===
/*++

Copyright (C) Microsoft Corporation, 1998 - 2000

Module Name:

    private.h

Abstract:

    This module contains private definitions for DRMK.sys

Author:
    Frank Yerrace (FrankYe) 18-Sep-2000
    Dale Sather  (DaleSat) 31-Jul-1998

--*/

extern "C" {
#include <wdm.h>
}
#include <unknown.h>
#include <ks.h>

#include <windef.h>
#include <stdio.h>
#include <windef.h>
#include <unknown.h>
#include <kcom.h>

#if (DBG)
#define STR_MODULENAME "DRMKAUD:"
#endif
#include <ksdebug.h>

#define POOLTAG 'AMRD'

#pragma code_seg("PAGE")

EXTERN_C void DrmGetFilterDescriptor(const KSFILTER_DESCRIPTOR ** ppDrmFitlerDescriptor);
EXTERN_C NTSTATUS __stdcall DriverEntry(IN PDRIVER_OBJECT DriverObject, IN PUNICODE_STRING RegistryPathName);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\drm\krm\drmk\initguid.cpp ===
#define INITGUID
#include "guiddef.h"
#include "inc/punknown.h"
#include "inc/KrmCommStructs.h"
#include "ks.h"
#include "drmk.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\drm\krm\drmkmain\audiodescrambler.cpp ===
#include "drmkPCH.h"
#include "CryptoHelpers.h"
#include "KList.h"
#include "../DRMKMain/StreamMgr.h"
#include "AudioDescrambler.h"
//------------------------------------------------------------------------------
// When doing noise addition, we only decryptt the low bits.  These constants define
// the number of bits encrypted.  
// If you change this, change the contants in DRMKMain, too.
WORD mask16=(WORD) 0x3FFF;
char mask8=(char) 0x7F;
//------------------------------------------------------------------------------
DRM_STATUS DescrambleBlock(WAVEFORMATEX* Wfx, DWORD StreamId, 
							BYTE* Dest, DWORD DestSize, DWORD* DestUsed,
							BYTE* Src, DWORD SrcSize, DWORD* SrcUsed,
							BOOL InitKey, STREAMKEY* streamKey, 
							DWORD FrameSize){
	if(StreamId==0){
		// StreamId==0 is a dummy debugging stream that is unencrypted
		DWORD NumBytes=min(SrcSize, DestSize);
		memcpy(Dest, Src, NumBytes);
		*SrcUsed=NumBytes;
		*DestUsed=NumBytes;
		return DRM_OK;
	};

	*SrcUsed=0;
	*DestUsed=0;
	DWORD blockLen=min(SrcSize, DestSize);
	blockLen=blockLen/FrameSize*FrameSize;
	if(blockLen==0){
		_DbgPrintF(DEBUGLVL_VERBOSE,("Not enough data"));
		return DRM_DATALENGTH;
	};
	static bool firstTime=true;
	if(firstTime){
		_DbgPrintF(DEBUGLVL_VERBOSE,("Descramble: streamId=%d, isPCM=%d, (bits=%d, mono=%d), FrameSize=%d\n",
		StreamId, Wfx->wFormatTag, (int) Wfx->wBitsPerSample, (int) Wfx->nChannels, FrameSize));
		firstTime=false;
	};
	
	if(InitKey){
            if(TheStreamMgr!=NULL){
                STREAMKEY* theStreamKey;
                DRM_STATUS stat=TheStreamMgr->getKey(StreamId, theStreamKey);
                // note, we keep a local copy.  If you call an encryption fucntion on this
                // key, state in streamManager will NOT be updated.
                if(stat!=KRM_OK){
                    _DbgPrintF(DEBUGLVL_VERBOSE,("Can't get key for stream: %x", StreamId));
                    return stat;
                };
                *streamKey= *theStreamKey;
            } else {
                _DbgPrintF(DEBUGLVL_VERBOSE,("TheStreamMgr not initted"));
                return KRM_SYSERR;
            };
	};	
	
	DWORD bitsPerSample=Wfx->wBitsPerSample;
	DWORD numChannels=Wfx->nChannels;
	bool isPcm=(Wfx->wFormatTag==WAVE_FORMAT_PCM);
	
	// for non-pcm, we scramble al but the msb in each byte.
	DWORD effectiveBitsPerSample=bitsPerSample;
	if(!isPcm)effectiveBitsPerSample=8;
	
	// We deal with data in FrameSize lumps
	DWORD numLumps=blockLen/FrameSize;
	for(DWORD k=0;k<numLumps;k++){
		
		BYTE* inData=Src+k*FrameSize;
		BYTE* outData=Dest+k*FrameSize;
		memcpy(outData, inData,  FrameSize);

		// If the frame is all zeros, pass it unscrambled (the audio system inserts
		// blank frames.  These will not necessarily have been scrambled.  we take 
		// a frame of zeros as a special case and do not unscramble).  
		DWORD* inBuffer=reinterpret_cast<DWORD*> (inData);
		DWORD numDwordsPerFrame=FrameSize/4;
		bool isBlankFrame=true;
		for(DWORD kk=0;kk<numDwordsPerFrame;kk++){
			if(inBuffer[kk]!=0){
				isBlankFrame=false;
				break;
			};
		};
		if(isBlankFrame){
			_DbgPrintF(DEBUGLVL_VERBOSE,("Blank buffer"));
			continue;
		};

		// we seed the packet sample key with some MSBs from the data stream
		// (these are not encrypted).  We take bits from the first 64 samples.
		// We could tune this for speed/security.
		int samplesForSeed=64;
		__int64 seed=0;
		if(effectiveBitsPerSample==8){
			// grab MSBs
			for(int j=0;j<samplesForSeed; j++){
				BYTE c=inData[j] & ~mask8;
				c >>= 7;
				seed = (seed << 1) + c;
			};
		} else {
			for(int j=0;j<samplesForSeed; j++){
				WORD& w= (WORD&) *((WORD*) &inData[j*2]);
				WORD m=w & ~mask16;
				
				m >>= 14;
				seed = (seed << 1) + m;
			};
		};
		// MAC the seed using the main stream key.  Generate the packet key from the mac.
		// (user mode performs identical operations to generate the scrmabling key)
		CBCKey macKey;
		CBCState macState;
		DRM_STATUS stat=CryptoHelpers::InitMac(macKey, macState, (BYTE*) streamKey, sizeof(STREAMKEY));
		DRMDIGEST mac;
		stat=CryptoHelpers::Mac(macKey, (BYTE*) &seed, sizeof(seed), mac);
		STREAMKEY packetKey;
		bv4_key_C(&packetKey, sizeof(mac),(BYTE*) &mac);
		
		// If there has been a fatal error (usually out-of-memory somewhere)
		// we do not descramble (an alternative would be to return silence).
		if(TheStreamMgr->getFatalError()==DRM_OK){
			// We have already copied the inBlock to the outBlock, now we can decrypt it
			CryptoHelpers::Xcrypt(packetKey, outData, FrameSize);
			// We know about noise addition on 8 and 16 bit PCM audio.  Other
			// audio formats get treated like 8 bit audio.
			DWORD numSamples=FrameSize/(effectiveBitsPerSample/8);
			if(effectiveBitsPerSample==16){
				WORD* in=(WORD*) inData;
				WORD* out=(WORD*) outData;
				for(DWORD j=0;j<numSamples;j++){
					out[j]=(out[j] & mask16) | (in[j] & ~mask16);
				};
			} 
			if(effectiveBitsPerSample==8){
				char* in=(char*) inData;
				char* out=(char*) outData;
				for(DWORD j=0;j<numSamples;j++){
					out[j]=(out[j] & mask8) | (in[j] & ~mask8);
				};
			};
		};
	}; // of loop over blocks

	*SrcUsed=blockLen; 
	*DestUsed=blockLen;

	return DRM_OK;
};
//------------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\drm\krm\drmk\drmfilter.cpp ===
/*++

Copyright (C) Microsoft Corporation, 1998 - 1999

Module Name:

    DRMFilter.cpp

Abstract:

    This module contains a DRM format translation filter.

Author:
    Paul England (pengland) from ks2 sample code by Dale Sather
    Frank Yerrace


--*/

#include "private.h"
#include "../DRMKMain/KGlobs.h"
#include "../DRMKMain/KList.h"
#include "../DRMKMain/StreamMgr.h"
#include "../DRMKMain/AudioDescrambler.h"
#include "../DRMKMain/KRMStubs.h"


#ifdef ALLOC_PRAGMA
#pragma code_seg("PAGE")
#endif // ALLOC_PRAGMA

#ifdef ALLOC_DATA_PRAGMA
#pragma const_seg("PAGECONST")
#endif // ALLOC_DATA_PRAGMA

typedef struct _POSITIONRANGE {
    ULONGLONG Start;
    ULONGLONG End;
} POSITIONRANGE, *PPOSITIONRANGE;

#define DEFAULT_DRM_FRAME_SIZE     1024

#ifdef ALLOC_PRAGMA
#pragma code_seg()
#endif // ALLOC_PRAGMA

BOOLEAN
DRMKsGeneratePositionEvent(
    IN PVOID Context,
    IN PKSEVENT_ENTRY EventEntry
    )
/*++

Routine Description:
    This routine is a callback from KsGenerateEvents.  Given the position
    range (passed as the context) this routine determines whether the specified
    position event should be signaled.

Arguments:
    Context -
    
    EventEntry -
    
Return Value:
    BOOLEAN
--*/
{
    PPOSITIONRANGE positionRange = (PPOSITIONRANGE)Context;
    PDRMLOOPEDSTREAMING_POSITION_EVENT_ENTRY eventEntry = (PDRMLOOPEDSTREAMING_POSITION_EVENT_ENTRY)EventEntry;
    return (eventEntry->Position >= positionRange->Start && eventEntry->Position <= positionRange->End);
}


NTSTATUS DRMInputPinAddLoopedStreamingPositionEvent(
    IN PIRP Irp,
    IN PKSEVENTDATA EventData,
    IN PKSEVENT_ENTRY EventEntry
)
/*++

Routine Description:

Arguments:
    
Return Value:
    NTSTATUS
--*/
{
    PLOOPEDSTREAMING_POSITION_EVENT_DATA eventData = (PLOOPEDSTREAMING_POSITION_EVENT_DATA)EventData;
    PDRMLOOPEDSTREAMING_POSITION_EVENT_ENTRY eventEntry = (PDRMLOOPEDSTREAMING_POSITION_EVENT_ENTRY)EventEntry;
    PKSPIN Pin = KsGetPinFromIrp(Irp);
    ASSERT(Pin);
    if (!Pin) return STATUS_INVALID_PARAMETER;
    eventEntry->Position = eventData->Position;
    KsPinAddEvent(Pin, EventEntry);
    return STATUS_SUCCESS;
}


#ifdef ALLOC_PRAGMA
#pragma code_seg("PAGE")
#endif // ALLOC_PRAGMA

NTSTATUS
SetDataRangeFromDataFormat(
    IN FilterInstance* myInstance,
    IN PKSPIN_DESCRIPTOR OutputPinDescriptor,
    IN PKSDATAFORMAT InDataFormat,
    IN PWAVEFORMATEX OutDataFormat
)
/*++

Routine Description:
    This routine modifies the OutputPinDescriptor and myInstance->OutDataFormat
    based on the connection format.

Arguments:
    myInstance -
        Current Filter Instance. Its OutDataFormat and OutWfx will be modified.
    OutputPinDescriptor  -
        Output Pin Descritor. Its DataRanges will be modified.
    InDataFormat -
        InputPin connection format.
    OutDataFormat -
        New output pin connection format. 
        
Return Value:
    STATUS_SUCCESS.

--*/
{
    NTSTATUS ntStatus = STATUS_SUCCESS;

    ASSERT(myInstance);
    ASSERT(OutputPinDescriptor);
    ASSERT(InDataFormat);
    ASSERT(OutDataFormat);

    //
    // Modify the OutputPinDescriptor 
    // 
    GUID& outFormatSpecifierGuid=OutputPinDescriptor->DataRanges[0]->Specifier;
    GUID& outSubFormatGuid=OutputPinDescriptor->DataRanges[0]->SubFormat;

    outFormatSpecifierGuid = InDataFormat->Specifier;

    if (OutDataFormat->wFormatTag == WAVE_FORMAT_EXTENSIBLE) 
    {
        PWAVEFORMATEXTENSIBLE wfex = (PWAVEFORMATEXTENSIBLE) OutDataFormat;
        outSubFormatGuid = wfex->SubFormat;
    } 
    else 
    {
        INIT_WAVEFORMATEX_GUID(&outSubFormatGuid, OutDataFormat->wFormatTag);
    }

    PKSDATARANGE_AUDIO DataRange =
        reinterpret_cast<PKSDATARANGE_AUDIO>(OutputPinDescriptor->DataRanges[0]);
    
    DataRange->MaximumChannels = OutDataFormat->nChannels;
    DataRange->MinimumBitsPerSample = 
        DataRange->MaximumBitsPerSample = OutDataFormat->wBitsPerSample;
    DataRange->MinimumSampleFrequency = 
        DataRange->MaximumSampleFrequency = OutDataFormat->nSamplesPerSec;

    //
    // Now we build the required output KSDATAFORMAT structure
    //
    if (IsEqualGUIDAligned(outFormatSpecifierGuid, KSDATAFORMAT_SPECIFIER_WAVEFORMATEX)) 
    {
        SIZE_T cbOutDataFormatWf = 
            sizeof(KSDATAFORMAT_WAVEFORMATEX) + OutDataFormat->cbSize;
        PKSDATAFORMAT_WAVEFORMATEX OutDataFormatWf = 
            (PKSDATAFORMAT_WAVEFORMATEX) new BYTE[cbOutDataFormatWf];
        if (OutDataFormatWf) {
            RtlZeroMemory(OutDataFormatWf,cbOutDataFormatWf);
            OutDataFormatWf->DataFormat.FormatSize = (ULONG)cbOutDataFormatWf;
            OutDataFormatWf->DataFormat.SampleSize = OutDataFormat->nBlockAlign;
            OutDataFormatWf->DataFormat.MajorFormat = KSDATAFORMAT_TYPE_AUDIO;
            OutDataFormatWf->DataFormat.SubFormat = outSubFormatGuid;
            OutDataFormatWf->DataFormat.Specifier = KSDATAFORMAT_SPECIFIER_WAVEFORMATEX;

            RtlCopyMemory(
                &OutDataFormatWf->WaveFormatEx, 
                OutDataFormat, 
                sizeof(*OutDataFormat) + OutDataFormat->cbSize);
            myInstance->OutDataFormat = (PKSDATAFORMAT) OutDataFormatWf;
            myInstance->OutWfx = &OutDataFormatWf->WaveFormatEx;
        } 
        else 
        {
            ntStatus = STATUS_INSUFFICIENT_RESOURCES;
        }
    } 
    else 
    {
        ASSERT(IsEqualGUIDAligned(outFormatSpecifierGuid, KSDATAFORMAT_SPECIFIER_DSOUND));
        PKSDATAFORMAT_DSOUND InDataFormatDs = 
            (PKSDATAFORMAT_DSOUND) InDataFormat;
        SIZE_T cbOutDataFormatDs = 
            sizeof(KSDATAFORMAT_DSOUND) + OutDataFormat->cbSize;
        PKSDATAFORMAT_DSOUND OutDataFormatDs = 
            (PKSDATAFORMAT_DSOUND) new BYTE[cbOutDataFormatDs];
        if (OutDataFormatDs) 
        {
            RtlZeroMemory(OutDataFormatDs,cbOutDataFormatDs);
            OutDataFormatDs->DataFormat.FormatSize = (ULONG)cbOutDataFormatDs;
            OutDataFormatDs->DataFormat.SampleSize = OutDataFormat->nBlockAlign;
            OutDataFormatDs->DataFormat.MajorFormat = KSDATAFORMAT_TYPE_AUDIO;
            OutDataFormatDs->DataFormat.SubFormat = outSubFormatGuid;
            OutDataFormatDs->DataFormat.Specifier = KSDATAFORMAT_SPECIFIER_DSOUND;
            OutDataFormatDs->BufferDesc.Flags = InDataFormatDs->BufferDesc.Flags;
            OutDataFormatDs->BufferDesc.Control = InDataFormatDs->BufferDesc.Control;

            RtlCopyMemory(
                &OutDataFormatDs->BufferDesc.WaveFormatEx, 
                OutDataFormat, 
                sizeof(*OutDataFormat) + OutDataFormat->cbSize);
            myInstance->OutDataFormat = (PKSDATAFORMAT)OutDataFormatDs;
            myInstance->OutWfx = &OutDataFormatDs->BufferDesc.WaveFormatEx;
        } 
        else 
        {
            ntStatus = STATUS_INSUFFICIENT_RESOURCES;
        }
    }

    return ntStatus;
} // SetDataRangeFromDataFormat


NTSTATUS
DRMOutputPinCreate(
    IN PKSPIN OutputPin,
    IN PIRP Irp
)
/*++

Routine Description:
    This routine is called when an output pin is created.

Arguments:
    Pin -
        Contains a pointer to the pin structure.
    Irp -
        Contains a pointer to the create IRP.
Return Value:
    STATUS_SUCCESS.

KRM-Specific
	Must connect inPin before outPin.
	Called on outPin connection.  Generally connection refused (STATUS_NO_MATCH) if outPin
	is attempted before inPin.  This is because outPin format is determined by the encapsulated inPin
	format.
	You can disconnect and reconnect the outPin if the inPin remains connected.  If you disconnect the
	inPin you must reconnect the outPin.
  

--*/
{

    PAGED_CODE();
    NTSTATUS ntStatus;
    
    //
    // SECURITY
    // We will not let UserMode create a pin. 
    // This is a basic Attack surface reduction fix.
    // 
    if (KernelMode != Irp->RequestorMode)
    {
        _DbgPrintF(DEBUGLVL_TERSE,("[DRMOutputPinCreate: Only KernelMode can create pin]"));
        return STATUS_INVALID_DEVICE_REQUEST;
    }

    PKSFILTER Filter=KsPinGetParentFilter(OutputPin);
    ASSERT(Filter);
    if (!Filter) 
    {
        return STATUS_INVALID_PARAMETER;
    }
    
    FilterInstance* myInstance=(FilterInstance*) Filter->Context;

    //
    // Creating an output pin.  Confirm there is already an input pin.
    //
    PKSPIN InputPin = KsFilterGetFirstChildPin(Filter,PIN_ID_INPUT);
    if (!InputPin)
    {
        return STATUS_NO_MATCH;
    }

    //
    // Note that the input pin is created first. DrmInputPinCreate 
    // routine sets myInstance->frameSize. If frameSize is 0, something
    // must be wrong.
    //
    if (myInstance->frameSize == 0) 
    {
        return STATUS_INVALID_DEVICE_REQUEST;
    }

    OutputPinInstance* myPin=new OutputPinInstance;
    if (!myPin) return STATUS_INSUFFICIENT_RESOURCES;
    RtlZeroMemory(myPin,sizeof(*myPin));
    OutputPin->Context = const_cast<PVOID>(reinterpret_cast<const void *>(myPin));

    //
    // Set the output compression of the output pin.
    //
    ntStatus = KsEdit(OutputPin,&OutputPin->Descriptor,POOLTAG);
    if (NT_SUCCESS(ntStatus)) {
        ntStatus = KsEdit(OutputPin,&OutputPin->Descriptor->AllocatorFraming,POOLTAG);
        if (NT_SUCCESS(ntStatus)) {
            //
            // Edit the allocator max outstanding frames to have at least 200ms of data
            //
            PWAVEFORMATEX waveformat = NULL;
    
            if (IsEqualGUIDAligned(OutputPin->ConnectionFormat->Specifier, KSDATAFORMAT_SPECIFIER_WAVEFORMATEX))
            {
                PKSDATAFORMAT_WAVEFORMATEX format = reinterpret_cast<PKSDATAFORMAT_WAVEFORMATEX>(OutputPin->ConnectionFormat);
                waveformat = reinterpret_cast<PWAVEFORMATEX>(&format->WaveFormatEx);
            }
            else if (IsEqualGUIDAligned(OutputPin->ConnectionFormat->Specifier, KSDATAFORMAT_SPECIFIER_DSOUND))
            {
                PKSDATAFORMAT_DSOUND format = reinterpret_cast<PKSDATAFORMAT_DSOUND>(InputPin->ConnectionFormat);
                waveformat = reinterpret_cast<PWAVEFORMATEX>(&format->BufferDesc.WaveFormatEx);
            }
            else
            {
                //
                // This should never happen, because the filter only supports 
                // the above two specifiers and KS should reject the rest of
                // the specifiers before calling PinCreate function.
                //
                _DbgPrintF(DEBUGLVL_TERSE,("[DRMOutputPinCreate: Unexpected Specifier Pin=%X]", OutputPin));
                ASSERT(FALSE);
            }

            // If waveformat is null, we will not edit the FrameCount.
            if (waveformat)
            {
                // This calculates the number of outstanding frames to have
                // at least 200 ms of data.
                ULONG Frames = 
                    ((waveformat->nAvgBytesPerSec + (myInstance->frameSize * 5 - 1)) / (myInstance->frameSize * 5));

                _DbgPrintF(DEBUGLVL_TERSE,("[DRMOutputPinCreate: nAvgBytesPerSec=%d, Frames=%d]", waveformat->nAvgBytesPerSec, Frames));

                PKS_FRAMING_ITEM frameitem = 
                    const_cast<PKS_FRAMING_ITEM>(&OutputPin->Descriptor->AllocatorFraming->FramingItem[0]);
                frameitem->Frames = Frames;
                frameitem->FramingRange.Range.MinFrameSize = 
                    frameitem->FramingRange.Range.MaxFrameSize = 
                        myInstance->frameSize;
            }
          
            // Notify StreamMgr of the output pin (downstream) component
            PFILE_OBJECT nextComponentFileObject = KsPinGetConnectedPinFileObject(OutputPin);
            PDEVICE_OBJECT nextComponentDeviceObject = KsPinGetConnectedPinDeviceObject(OutputPin);
            
            ASSERT(nextComponentFileObject && nextComponentDeviceObject);
            ASSERT(TheStreamMgr);
            
            if(myInstance->StreamId!=0) 
            {
                ntStatus = TheStreamMgr->setRecipient(
                    myInstance->StreamId, 
                    nextComponentFileObject, 
                    nextComponentDeviceObject);
            }
        }
    }

    // If there's been a failure, we rely on KS to free
    // allocations done due to KS Edit.

    if (!NT_SUCCESS(ntStatus))
    {
        delete myPin;
    }

    return ntStatus;
}

NTSTATUS
DRMInputPinCreate(
   IN PKSPIN InputPin,
   IN PIRP Irp
)
/*++

Routine Description:
    This routine is called when an input pin is created.

Arguments:
    Pin -
        Contains a pointer to the pin structure.
    Irp -
        Contains a pointer to the create IRP.
Return Value:
    STATUS_SUCCESS.

KRM-Specific
	Must connect inPin before outPin.
	Called on inPin connection.  Generally connection refused (STATUS_NO_MATCH) if outPin
	is attempted before inPin.  This is because outPin format is determined by the encapsulated inPin
	format.
	You can disconnect and reconnect the outPin if the inPin remains connected.  If you disconnect the
	inPin you must reconnect the outPin.
  

--*/
{
    PAGED_CODE();
    PDRMWAVEFORMAT drmFormat;
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PKSPIN_DESCRIPTOR OutputPinDescriptor;

    //
    // SECURITY
    // We will not let UserMode create a pin. 
    // This is a basic Attack surface reduction fix.
    // 
    if (KernelMode != Irp->RequestorMode)
    {
        _DbgPrintF(DEBUGLVL_TERSE,("[DRMInputPinCreate: Only KernelMode can create pin]"));
        return STATUS_INVALID_DEVICE_REQUEST;
    }

    PKSFILTER Filter=KsPinGetParentFilter(InputPin);
    ASSERT(Filter);
    if (!Filter) 
    {
        return STATUS_INVALID_PARAMETER;
    }
    
    FilterInstance* myInstance=(FilterInstance*) Filter->Context;

    //
    // Creating an input pin.  Confirm that there is no output pin yet.
    //
    if (NULL != KsFilterGetFirstChildPin(Filter, PIN_ID_OUTPUT)) 
    {
        return STATUS_NO_MATCH;
    }
    
    //
    // Create Input pin context.
    //
    InputPinInstance* myPin = new InputPinInstance;
    if (!myPin) 
    {
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    RtlZeroMemory(myPin,sizeof(*myPin));
    InputPin->Context = const_cast<PVOID>(reinterpret_cast<const void *>(myPin));

    //
    // Prepare to edit some aspects of the pin descriptors.
    // Specifically change OutputPinDescriptor to reflect InputPin
    // connection format.
    // To do that, we edit DataRanges of the OutputPin in Filter Descriptor.
    //
    ntStatus = KsEdit(Filter,&Filter->Descriptor,POOLTAG);
    if (NT_SUCCESS(ntStatus))
    {
        ntStatus = KsEditSized(
            Filter,
            &Filter->Descriptor->PinDescriptors,
            2 * sizeof(KSPIN_DESCRIPTOR_EX),
            2 * sizeof(KSPIN_DESCRIPTOR_EX),
            POOLTAG);
        if (NT_SUCCESS(ntStatus))
        {
            OutputPinDescriptor = const_cast<PKSPIN_DESCRIPTOR>
                (&Filter->Descriptor->PinDescriptors[PIN_ID_OUTPUT].PinDescriptor);

            //
            // Interpret connection format
            //
            if (IsEqualGUIDAligned(KSDATAFORMAT_SPECIFIER_DSOUND, 
                InputPin->ConnectionFormat->Specifier))
            {
                PKSDATAFORMAT_DSOUND dsformat = 
                    reinterpret_cast<PKSDATAFORMAT_DSOUND>(InputPin->ConnectionFormat);
                drmFormat = (PDRMWAVEFORMAT)&dsformat->BufferDesc.WaveFormatEx;
                _DbgPrintF(DEBUGLVL_BLAB,("[DRMPinCreate: KSDATAFORMAT_SPECIFIER_DSOUND]"));
            } 
            else 
            {
                PKSDATAFORMAT_WAVEFORMATEX format = 
                    reinterpret_cast<PKSDATAFORMAT_WAVEFORMATEX>(InputPin->ConnectionFormat);
                drmFormat = reinterpret_cast<PDRMWAVEFORMAT>(&format->WaveFormatEx);
                _DbgPrintF(DEBUGLVL_BLAB,("[DRMPinCreate: KSDATAFORMAT_SPECIFIER_WFX]"));                
            }

            ASSERT(WAVE_FORMAT_DRM == drmFormat->wfx.wFormatTag);

            //
            // Validate size of the drmFormat
            //
            if (drmFormat->wfx.cbSize >= (sizeof(DRMWAVEFORMAT) - sizeof(WAVEFORMATEX))) 
            {
                PWAVEFORMATEX outFormat = &drmFormat->wfxSecure;
        
                // Save the stream Info in the filter context
                myInstance->StreamId=drmFormat->ulContentId;
                myInstance->frameSize=drmFormat->wfx.nBlockAlign;
                
                // Log error to stream to indicate it needs authentication
                TheStreamMgr->logErrorToStream(myInstance->StreamId, DRM_AUTHREQUIRED);
                
                /*
                Fix up the output pin descriptor datarange to limit it as much
                as possible according to the input format, as follows:
        
                The output datarange format specifier should be unchanged
        
                The output datarange subtype should be the appropriate subtype
                according to the output format's wFormatTag as follows:
        
                if wfxSecure.wFormatTag == WAVE_FORMAT_EXTENSIBLE then
                    SubType = WAVEFORMATEXTENSIBLE.SubType
                else
                    SubType = INIT_WAVEFORMATEX_GUID(Guid, wFormatTag)
        
                The output datarange max channels should be set to the number of input channels
        
                The output datarange bits per sample should be limited to the input bits per channel
        
                The output dataramge frequency should be limited to the input frequency
                */
        
                // Edit it to have one KSDATARANGE entry
                OutputPinDescriptor->DataRangesCount = 1;
                ntStatus = KsEditSized(
                    Filter,
                    &OutputPinDescriptor->DataRanges,
                    1 * sizeof(PKSDATARANGE),
                    1 * sizeof(PKSDATARANGE),
                    POOLTAG);
                if (NT_SUCCESS(ntStatus)) 
                {
                    ntStatus = KsEditSized(
                        Filter,
                        &OutputPinDescriptor->DataRanges[0],
                        sizeof(KSDATARANGE_AUDIO),
                        sizeof(KSDATARANGE_AUDIO),
                        POOLTAG);
                    if (NT_SUCCESS(ntStatus))
                    {
                        ntStatus = SetDataRangeFromDataFormat(
                            myInstance,
                            OutputPinDescriptor,
                            InputPin->ConnectionFormat,
                            outFormat);

                        if (!NT_SUCCESS(ntStatus)) 
                        {
                            KsDiscard(Filter,OutputPinDescriptor->DataRanges[0]);
                        }
                    }

                    if (!NT_SUCCESS(ntStatus)) 
                    {
                        KsDiscard(Filter,OutputPinDescriptor->DataRanges);                    
                    }
                }
            } 
            else 
            {
                // Invalid DRMWAVEFORMAT structure
                ntStatus = STATUS_NO_MATCH;
            }

            if (!NT_SUCCESS(ntStatus)) 
            {
                KsDiscard(Filter,Filter->Descriptor->PinDescriptors);                
            }
        }

        //
        // Set input pin framing requirements.
        //
        if (NT_SUCCESS(ntStatus)) 
        {
            ntStatus = KsEdit(InputPin, &InputPin->Descriptor, POOLTAG);
            if (NT_SUCCESS(ntStatus)) 
            {
                ntStatus = KsEdit(InputPin, &InputPin->Descriptor->AllocatorFraming, POOLTAG);
                if (NT_SUCCESS(ntStatus)) 
                {
                    PKS_FRAMING_ITEM frameitem = 
                        const_cast<PKS_FRAMING_ITEM>(&InputPin->Descriptor->AllocatorFraming->FramingItem[0]);

                    frameitem->FramingRange.Range.MinFrameSize = 
                        frameitem->FramingRange.Range.MaxFrameSize = 
                            myInstance->frameSize;
                }
            }

            //
            // KS will clean InputPin->ObjectBag when closing the pin.
            // So do not bother to call KsDiscard.
            //
        }

        if (!NT_SUCCESS(ntStatus)) 
        {
            Filter->Descriptor = &DrmFilterDescriptor;
            KsDiscard(Filter,Filter->Descriptor);            
        }
    }

    if (!NT_SUCCESS(ntStatus)) {
        delete myPin;
        myPin = NULL;
    }

    _DbgPrintF(DEBUGLVL_BLAB,("[DrmInputPinCreate Done]"));

    return ntStatus;
}


NTSTATUS
DRMOutputPinClose(
    IN PKSPIN Pin,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is called when a pin is closed.

Arguments:

    Pin -
        Contains a pointer to the pin structure.

    Irp -
        Contains a pointer to the close IRP.

Return Value:

    STATUS_SUCCESS.

KRM-Specific
	Pin-close order is not specified, but disconnecting the inPin disables further outPin 
	connections until the inPin is reconnected.
  
--*/

{
    PAGED_CODE();
    _DbgPrintF(DEBUGLVL_BLAB,("[DRMProcess: Pin Close]"));

    PKSFILTER Filter=KsPinGetParentFilter(Pin);
    ASSERT(Filter);
    if (!Filter) return STATUS_INVALID_PARAMETER;
    
    FilterInstance* myInstance=(FilterInstance*) Filter->Context;

    // Disconnecting the OutputPin
    ASSERT(Pin->Context);
    delete Pin->Context;
    Pin->Context = NULL;

    ASSERT(TheStreamMgr);
    if(myInstance->StreamId!=0) TheStreamMgr->clearRecipient(myInstance->StreamId);

    return STATUS_SUCCESS;
}

NTSTATUS
DRMInputPinClose(
    IN PKSPIN Pin,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is called when a pin is closed.

Arguments:

    Pin -
        Contains a pointer to the pin structure.

    Irp -
        Contains a pointer to the close IRP.

Return Value:

    STATUS_SUCCESS.

KRM-Specific
	Pin-close order is not specified, but disconnecting the inPin disables further outPin 
	connections until the inPin is reconnected.
  
--*/

{
    PAGED_CODE();
    _DbgPrintF(DEBUGLVL_BLAB,("[DRMProcess: Pin Close]"));

    // Disconnecting the InputPin
    PIO_STACK_LOCATION IrpStack = IoGetCurrentIrpStackLocation(Irp);
    
    InputPinInstance* inputPin = (InputPinInstance*)Pin->Context;
    
    PKSFILTER filter = KsPinGetParentFilter(Pin);
    ASSERT(filter);
    if (!filter) return STATUS_INVALID_PARAMETER;
    
    FilterInstance* myInstance=(FilterInstance*) filter->Context;

    // Tell the DRM framework that there is no valid downstream component
    ASSERT(TheStreamMgr);
    if(myInstance->StreamId!=0) TheStreamMgr->clearRecipient(myInstance->StreamId);

    const KSPIN_DESCRIPTOR * outputPinDescriptor =
        &filter->Descriptor->PinDescriptors[PIN_ID_OUTPUT].PinDescriptor;

    //
    // Restore filter descriptor.
    //
    filter->Descriptor = &DrmFilterDescriptor;
    KsDiscard(filter, outputPinDescriptor->DataRanges[0]);
    KsDiscard(filter, outputPinDescriptor->DataRanges);
    KsDiscard(filter, filter->Descriptor->PinDescriptors);
    KsDiscard(filter, filter->Descriptor);

    ASSERT(Pin->Context);
    delete Pin->Context;
    Pin->Context = NULL;

    ASSERT(myInstance->OutDataFormat);
    delete myInstance->OutDataFormat;
    myInstance->OutDataFormat = NULL;

    return STATUS_SUCCESS;
}

NTSTATUS 
KsResetState
(
    PKSPIN                  Pin, 
    KSRESET                 ResetValue
)
{
    NTSTATUS            Status = STATUS_INVALID_DEVICE_REQUEST;
    PFILE_OBJECT        pFileObject;
    ULONG               BytesReturned ;

    pFileObject = KsPinGetConnectedPinFileObject(Pin);
    
	ASSERT( pFileObject );

	if (pFileObject) {
	    Status = KsSynchronousIoControlDevice (
	                   pFileObject,
	                   KernelMode,
	                   IOCTL_KS_RESET_STATE,
	                   &ResetValue,
	                   sizeof (ResetValue),
	                   &ResetValue,
	                   sizeof (ResetValue),
	                   &BytesReturned ) ;
   	}

   	return Status;
}

VOID
DRMFilterReset(
    IN PKSFILTER Filter
    )
{
    PKSPIN InputPin = KsFilterGetFirstChildPin(Filter, PIN_ID_INPUT);
    PKSPIN OutputPin = KsFilterGetFirstChildPin(Filter, PIN_ID_OUTPUT);
    NTSTATUS            Status = STATUS_INVALID_DEVICE_REQUEST;

    KsFilterAcquireControl(Filter);

    if (InputPin) {
	    InputPinInstance* myInputPin = (InputPinInstance*)InputPin->Context;
	    myInputPin->BasePosition = 0;
    }

	// Now we reset the pin below us.
	if (OutputPin) {
  		OutputPinInstance* myOutputPin = (OutputPinInstance*) OutputPin->Context;
		Status = KsResetState(OutputPin, KSRESET_BEGIN);
		if ( NT_SUCCESS(Status) ) {
			Status = KsResetState(OutputPin, KSRESET_END);
		}
	    myOutputPin->BytesWritten = 0;

	    if (!NT_SUCCESS(Status)) {
		    _DbgPrintF(DEBUGLVL_TERSE,("[DRMFilterReset: Reset could not be propagated]"));
	    }
    }
    
    KsFilterReleaseControl(Filter);
}

NTSTATUS
DRMPinGetPosition(
    IN PIRP                  pIrp,
    IN PKSPROPERTY           pProperty,
    IN OUT PKSAUDIO_POSITION pPosition
)
/*++

Routine Description:

    This routine...

Arguments:

    pIrp -
    pPropert-
    pPosition-

Return Value:

    NTSTATUS

KRM-Specific:
--*/
{
    NTSTATUS ntstatus;
    KSPROPERTY Property;
    PIKSCONTROL pIKsControl;

    // _DbgPrintF(DEBUGLVL_BLAB,("[DRMPinGetPosition]"));

    PKSPIN Pin = KsGetPinFromIrp(pIrp);
    ASSERT(Pin);
    if (!Pin) return STATUS_INVALID_PARAMETER;
    ASSERT(PIN_ID_INPUT == Pin->Id);
    
    PKSFILTER Filter = KsPinGetParentFilter(Pin);
    ASSERT(Filter);
    if (!Filter) return STATUS_INVALID_PARAMETER;
    
    KsFilterAcquireControl(Filter);
    
    PKSPIN OutputPin = KsFilterGetFirstChildPin(Filter,PIN_ID_OUTPUT);
    if (OutputPin) {
        InputPinInstance*  myPin       = (InputPinInstance*)Pin->Context;
        OutputPinInstance* myOutputPin = (OutputPinInstance*)OutputPin->Context;
        FilterInstance*    myFilter    = (FilterInstance*)Filter->Context;
        
        Property.Set = KSPROPSETID_Audio;
        Property.Id = KSPROPERTY_AUDIO_POSITION;
        Property.Flags = KSPROPERTY_TYPE_GET;
    
        ntstatus = KsPinGetConnectedPinInterface(OutputPin,&IID_IKsControl,(PVOID*)&pIKsControl);
        if (NT_SUCCESS(ntstatus))
        {
            KSAUDIO_POSITION Position;
            ULONG cbReturned;
            
            ntstatus = pIKsControl->KsProperty(&Property, sizeof(Property),
                                             &Position, sizeof(Position),
                                             &cbReturned);
            if (NT_SUCCESS(ntstatus))
            {
                ULONGLONG cbSent = myOutputPin->BytesWritten;
                if (cbSent < Position.PlayOffset || cbSent < Position.WriteOffset) {
                    _DbgPrintF(DEBUGLVL_TERSE,("[DRMPinGetPosition:dp=%d,dw=%d]", (int)cbSent - (int)Position.PlayOffset, (int)cbSent - (int)Position.WriteOffset));
                }
    
                if (KSINTERFACE_STANDARD_LOOPED_STREAMING == Pin->ConnectionInterface.Id)
                {
                if (myPin->PendingSetPosition) {
                    pPosition->PlayOffset = myPin->SetPosition;
                    pPosition->WriteOffset = myPin->SetPosition;
                } else {
                    LONGLONG StreamPosition;
                    // Compute play position from downstream play position,
                    // rounding down to a frame start.
                    StreamPosition = max((LONGLONG)(Position.PlayOffset - myPin->BasePosition), 0);
                    StreamPosition -= StreamPosition % myFilter->frameSize;
                    pPosition->PlayOffset = (StreamPosition + myPin->StartPosition) % max(myPin->Loop.BytesAvailable,1);
                    pPosition->WriteOffset = myPin->OffsetPosition;
                    // _DbgPrintF(DEBUGLVL_TERSE,("[DRMPinGP:r=%d,b=%d,s=%d,a=%d,p=%d]", (int)Position.PlayOffset, (int)myPin->BasePosition, (int)myPin->StartPosition, (int)myPin->Loop.BytesAvailable, (int)pPosition->PlayOffset));
                }
                } else {
                    ASSERT(KSINTERFACE_STANDARD_STREAMING == Pin->ConnectionInterface.Id);
                    ASSERT(0 == myPin->BasePosition);
                    pPosition->PlayOffset = Position.PlayOffset;
                    pPosition->WriteOffset = myPin->OffsetPosition;
                }
    
                pIrp->IoStatus.Information = sizeof(*pPosition);
            }
    
            pIKsControl->Release();
        }
    } else {
    
        // No output pin connected
        pPosition->PlayOffset = 0;
        pPosition->WriteOffset = 0;
        ntstatus = STATUS_SUCCESS;
    }
    
    KsFilterReleaseControl(Filter);
    
     // _DbgPrintF(DEBUGLVL_BLAB,("[DRMPinGetPosition:p=%d,w=%d", (int)pPosition->PlayOffset, (int)pPosition->WriteOffset));
    return ntstatus;
}

NTSTATUS DRMPinSetPosition
(
    IN PIRP                  pIrp,
    IN PKSPROPERTY           pProperty,
    IN OUT PKSAUDIO_POSITION pPosition
)
/*++

Routine Description:

    This routine...

Arguments:

    pIrp -
    pPropert-
    pPosition-

Return Value:

    NTSTATUS

KRM-Specific:
--*/
{
    NTSTATUS ntstatus;
    
    PKSPIN Pin = KsGetPinFromIrp(pIrp);
    ASSERT(Pin);
    if (!Pin) return STATUS_INVALID_PARAMETER;
    ASSERT(PIN_ID_INPUT == Pin->Id);
    
    // _DbgPrintF(DEBUGLVL_BLAB,("[DRMPinSetPosition p=%d]", (int)pPosition->PlayOffset));

    PKSFILTER Filter = KsPinGetParentFilter(Pin);
    ASSERT(Filter);
    if (!Filter) return STATUS_INVALID_PARAMETER;
    
    if (KSINTERFACE_STANDARD_LOOPED_STREAMING != Pin->ConnectionInterface.Id) return STATUS_INVALID_DEVICE_REQUEST;
    
    KsFilterAcquireControl(Filter);
    
    InputPinInstance* myInputPin = (InputPinInstance*)Pin->Context;
    FilterInstance* myFilter = (FilterInstance*)Filter->Context;
    
    // TODO: How much should we validate the position here?
    
    // If not a frame aligned position, fail.
    if (0 == (pPosition->PlayOffset % myFilter->frameSize)) {
        myInputPin->SetPosition = pPosition->PlayOffset;
        myInputPin->PendingSetPosition = TRUE;
        
        if (KSSTATE_RUN != Pin->DeviceState) {
            myInputPin->OffsetPosition = myInputPin->SetPosition;
            myInputPin->StartPosition = myInputPin->SetPosition;
        
            PKSPIN OutputPin = KsFilterGetFirstChildPin(Filter,PIN_ID_OUTPUT);
            if (OutputPin) {
                OutputPinInstance* myOutputPin = (OutputPinInstance*) OutputPin->Context;
                myInputPin->BasePosition = myOutputPin->BytesWritten;
            } else {
                myInputPin->BasePosition = 0;
            }
        }
        ntstatus = STATUS_SUCCESS;
    } else {
        _DbgPrintF(DEBUGLVL_ERROR,("[DRMPinSetPosition: PlayOffset not frame aligned]"));
        ntstatus = STATUS_INVALID_PARAMETER;
    }
    
    KsFilterReleaseControl(Filter);
    
    return ntstatus;
}


VOID DRMPreProcess
(
    PKSFILTER Filter, 
    PKSPROCESSPIN_INDEXENTRY ProcessPinsIndex
)
/*++

Routine Description:

    This routine is called from DRMProcess before processing any data

Arguments:

    Filter -
        Contains a pointer to the  filter structure.

    ProcessPinsIndex -
        Contains a pointer to an array of process pin index entries.  This
        array is indexed by pin ID.  An index entry indicates the number 
        of pin instances for the corresponding pin type and points to the
        first corresponding process pin structure in the ProcessPins array.
        This allows process pin structures to be quickly accessed by pin ID
        when the number of instances per type is not known in advance.

Return Value:

    none

KRM-Specific
--*/
{
    // Input pin
    ASSERT(1 == ProcessPinsIndex[PIN_ID_INPUT].Count);
    PKSPROCESSPIN Process = ProcessPinsIndex[PIN_ID_INPUT].Pins[0];
    PKSPIN Pin = Process->Pin;

    if (KSINTERFACE_STANDARD_LOOPED_STREAMING == Pin->ConnectionInterface.Id) {
        InputPinInstance* myInputPin = (InputPinInstance*)Pin->Context;

        // If Data or BytesAvailable changed, start at the beginning of the frame.
        if (myInputPin->Loop.Data != Process->Data || myInputPin->Loop.BytesAvailable != Process->BytesAvailable) {
            myInputPin->OffsetPosition = 0;
            myInputPin->StartPosition = 0;
            
            ASSERT(1 == ProcessPinsIndex[PIN_ID_OUTPUT].Count);
            PKSPIN OutputPin = ProcessPinsIndex[PIN_ID_OUTPUT].Pins[0]->Pin;
            ASSERT(OutputPin);
            
            OutputPinInstance* myOutputPin = (OutputPinInstance*) OutputPin->Context;
            myInputPin->BasePosition = myOutputPin->BytesWritten;
        }

        if (myInputPin->PendingSetPosition) {
            // _DbgPrintF(DEBUGLVL_BLAB,("[DRMPreProcess: PendingSetPosition p=%d]", (int)myInputPin->SetPosition));
            ASSERT(1 == ProcessPinsIndex[PIN_ID_OUTPUT].Count);
            PKSPIN OutputPin = ProcessPinsIndex[PIN_ID_OUTPUT].Pins[0]->Pin;
            ASSERT(OutputPin);
            
            OutputPinInstance* myOutputPin = (OutputPinInstance*) OutputPin->Context;
            myInputPin->PendingSetPosition = FALSE;
            if (myInputPin->SetPosition >= Process->BytesAvailable) {
                myInputPin->SetPosition = 0;
            }
            myInputPin->OffsetPosition = myInputPin->SetPosition;
            myInputPin->StartPosition = myInputPin->SetPosition;
            myInputPin->BasePosition = myOutputPin->BytesWritten;
        }

        // Stash away Data and BytesAvailable
        myInputPin->Loop.Data = Process->Data;
        myInputPin->Loop.BytesAvailable = Process->BytesAvailable;

        // Looping should be handled in DRMPostProcess
        ASSERT(myInputPin->OffsetPosition < myInputPin->Loop.BytesAvailable);

        if (Process->Data && Process->BytesAvailable) {
            // Get the current pointer and size
            Process->Data = ((PBYTE) myInputPin->Loop.Data + myInputPin->OffsetPosition);
            Process->BytesAvailable = (ULONG)(myInputPin->Loop.BytesAvailable - myInputPin->OffsetPosition);
        }
    }
}

VOID DRMPostProcess
(
    PKSFILTER Filter, 
    PKSPROCESSPIN_INDEXENTRY ProcessPinsIndex
)
/*++

Routine Description:

    This routine is called from DRMProcess after processing any data

Arguments:

    Filter -
        Contains a pointer to the  filter structure.

    ProcessPinsIndex -
        Contains a pointer to an array of process pin index entries.  This
        array is indexed by pin ID.  An index entry indicates the number 
        of pin instances for the corresponding pin type and points to the
        first corresponding process pin structure in the ProcessPins array.
        This allows process pin structures to be quickly accessed by pin ID
        when the number of instances per type is not known in advance.

Return Value:

    none

KRM-Specific
--*/
{
    PKSPROCESSPIN Process;
    PKSPIN Pin;
    
    // Input pin
    ASSERT(1 == ProcessPinsIndex[PIN_ID_INPUT].Count);
    Process = ProcessPinsIndex[PIN_ID_INPUT].Pins[0];
    Pin = Process->Pin;

    InputPinInstance* myInputPin = (InputPinInstance*)Pin->Context;
    
    // Process events
    POSITIONRANGE PositionRange;
    PositionRange.Start = myInputPin->OffsetPosition,
    PositionRange.End   = myInputPin->OffsetPosition+Process->BytesUsed-1;
    KsPinGenerateEvents(Pin,
                        &KSEVENTSETID_LoopedStreaming,
                        KSEVENT_LOOPEDSTREAMING_POSITION,
                        0, NULL,
                        DRMKsGeneratePositionEvent,
                        &PositionRange);
    
    if (KSINTERFACE_STANDARD_LOOPED_STREAMING == Pin->ConnectionInterface.Id) {
        myInputPin->OffsetPosition += Process->BytesUsed;
        
        // Loop or terminate if necessary
        ASSERT(myInputPin->OffsetPosition <= myInputPin->Loop.BytesAvailable);
        if ((myInputPin->OffsetPosition) >= myInputPin->Loop.BytesAvailable) {
            myInputPin->OffsetPosition = 0;
            if (Process->StreamPointer && (Process->StreamPointer->StreamHeader->OptionsFlags & KSSTREAM_HEADER_OPTIONSF_LOOPEDDATA)) {
                // Loop
                Process->BytesUsed = 0;
            } else {
                // Terminate this frame
                Process->BytesUsed = myInputPin->Loop.BytesAvailable;
            }
        } else {
            Process->BytesUsed = 0;
        }

        // Fix the data and size pointers back to their originals.
        Process->Data = myInputPin->Loop.Data;
        Process->BytesAvailable = myInputPin->Loop.BytesAvailable;
    } else {
        ASSERT(KSINTERFACE_STANDARD_STREAMING == Pin->ConnectionInterface.Id);
        myInputPin->OffsetPosition += Process->BytesUsed;
    }

    // Output pin
    ASSERT(1 == ProcessPinsIndex[PIN_ID_OUTPUT].Count);
    Process = ProcessPinsIndex[PIN_ID_OUTPUT].Pins[0];
    Pin = Process->Pin;

    ASSERT(KSINTERFACE_STANDARD_STREAMING == Pin->ConnectionInterface.Id);
    OutputPinInstance* myOutputPin = (OutputPinInstance*) Pin->Context;
    myOutputPin->BytesWritten += Process->BytesUsed;
}


NTSTATUS
DRMProcess(
    IN PKSFILTER Filter,
    IN PKSPROCESSPIN_INDEXENTRY ProcessPinsIndex
    )

/*++

Routine Description:

    This routine is called when there is data to be processed.

Arguments:

    Filter -
        Contains a pointer to the  filter structure.

    ProcessPinsIndex -
        Contains a pointer to an array of process pin index entries.  This
        array is indexed by pin ID.  An index entry indicates the number 
        of pin instances for the corresponding pin type and points to the
        first corresponding process pin structure in the ProcessPins array.
        This allows process pin structures to be quickly accessed by pin ID
        when the number of instances per type is not known in advance.

Return Value:

    STATUS_SUCCESS or STATUS_PENDING.

KRM-Specific
	This routine is called to process (decrypt) an audio data block.  We forward this
	request to the DRMK framework.
  
	--*/

{
    PAGED_CODE();
	
    PKSPROCESSPIN inPin = ProcessPinsIndex[PIN_ID_INPUT].Pins[0];
    PKSPROCESSPIN outPin = ProcessPinsIndex[PIN_ID_OUTPUT].Pins[0];

    FilterInstance* instance=(FilterInstance*) Filter->Context;

    DRMPreProcess(Filter, ProcessPinsIndex);

    //
    // Determine how much data we can process this time.
    //
    ULONG inByteCount = inPin->BytesAvailable;
    ULONG outByteCount = outPin->BytesAvailable;
    ULONG bytesToProcess=min(inByteCount, outByteCount);

    if (0 == bytesToProcess) {
	_DbgPrintF(DEBUGLVL_BLAB,("[DRMProcess: STATUS_PENDING]"));
        return STATUS_PENDING;
    }

    //
    // Call the transform function to process the data.
    //
    if(instance->StreamId==0){
        // StreamId==0 is not encrypted.  It is used to represent DRM-bundled 
        // plainext audio.
        memcpy(outPin->Data, inPin->Data, bytesToProcess);
        inPin->BytesUsed=bytesToProcess;
        outPin->BytesUsed=bytesToProcess;
    } else {
       	// else is a proper encrypted stream
        DRM_STATUS stat;
        stat=DescrambleBlock(instance->OutWfx, instance->StreamId, 
                        (BYTE*) outPin->Data, outPin->BytesAvailable, &outPin->BytesUsed, 
                        (BYTE*) inPin->Data, bytesToProcess, &inPin->BytesUsed, 
                        instance->initKey, &instance->streamKey, 
                        instance->frameSize);
        
        if(stat!=DRM_OK){
            _DbgPrintF(DEBUGLVL_VERBOSE, ("DescrambleBlock error - bad BufSize (in, out)=(%d, %d)\n",
                    inPin->BytesAvailable, outPin->BytesAvailable));
            return STATUS_PENDING;              
            //
            // ISSUE: 04/24/2002 ALPERS
            // alpers returning pending would cause the graph to stall.
            // read the message from wmessmer below.
            // STATUS_PENDING is an indication that this processing loop 
            // should be discontinued and that the filter should not be called 
            // back based on existing conditions until another triggering event 
            // happens (frame arrival that would normally trigger processing 
            // or a call to KsFilterAttemptProcessing).
            // If every pin has a queued frame and the flags are left as 
            // default (only call processing when new frame arrives into 
            // previously "empty" queue), returning STATUS_PENDING will stop 
            // processing until the filter manually calls 
            // KsFilterAttemptProcessing or the graph stops and starts again.
            //
        };
        if(instance->initKey)instance->initKey=false;
    };

    // debugging
    /*
    counter++;
    if(counter%10==1  && counter <200){
        _DbgPrintF("Processed: stat==%x, in, out, (%d %d) , (%d %d)]\n", stat,
	           inPin->BytesAvailable, inPin->BytesUsed,
		   outPin->BytesAvailable, outPin->BytesUsed 
		  );
    };
    */

    DRMPostProcess(Filter, ProcessPinsIndex);

    return STATUS_SUCCESS;
}

/*++

Routine Description:
	Called when filter is created.  Local filter context is a FilterInstance.  This structure
	will hold the streamId, the audio format, etc.
	As well as this, the KRM framework is notified of the new filter instance.  KRM 
  
--*/
NTSTATUS
DRMFilterCreate(
    IN PKSFILTER Filter,
    IN PIRP Irp
    )
{
    _DbgPrintF(DEBUGLVL_VERBOSE,("[DRMFilterCreate::X]"));
    FilterInstance* newInstance=new FilterInstance;
    if (!newInstance){
		_DbgPrintF(DEBUGLVL_VERBOSE,("[DRMFilterCreate] - out of memory(1)"));
		return STATUS_INSUFFICIENT_RESOURCES;
	};

    RtlZeroMemory(newInstance,sizeof(*newInstance));
    Filter->Context = const_cast<PVOID>(reinterpret_cast<const void *>(newInstance));

	newInstance->initKey=true;
	newInstance->decryptorRunning=false;
	newInstance->frameSize=0;

    NTSTATUS stat = KRMStubs::InitializeConnection(Irp);
	if(stat==STATUS_INSUFFICIENT_RESOURCES){
	    _DbgPrintF(DEBUGLVL_VERBOSE,("[DRMFilterCreate] - out of memory(2)"));
		delete newInstance;
		Filter->Context=NULL;
		return stat;
	};
	
    return STATUS_SUCCESS;
};

/*++

Routine Description:
	Called when filter is destroyed.  Local state is removed, and KRM is notified that the filter has
	been destroyed so that it can clean up too.
  
--*/
NTSTATUS
DRMFilterClose(
    IN PKSFILTER Filter,
    IN PIRP Irp
    ){
    
    _DbgPrintF(DEBUGLVL_VERBOSE,("[DRMFilterClose]"));
    // tell TheStreamMgr that the stream is dead
    DWORD StreamId=((FilterInstance*)(Filter->Context))->StreamId;
    ASSERT(TheStreamMgr);
    // if(StreamId!=0)TheStreamMgr->destroyStream(StreamId);

    delete (FilterInstance*) Filter->Context;
    KRMStubs::CleanupConnection(Irp);
    return STATUS_SUCCESS;
};

typedef struct {
    KSPROPERTY Property;
    DWORD inSize;
    DWORD outSize;
} SACPROPERTY, *PSACPROPERTY;

NTSTATUS
DrmFilterGetSAC(
    IN PIRP                  pIrp,
    IN BYTE*                 InBuf,
    IN OUT BYTE*             OutBuf
)
/*++

Routine Description:

    This routine...

Arguments:

    pIrp -
    pPropert-
    pSAC-

Return Value:

    NTSTATUS

KRM-Specific:
--*/
{
    _DbgPrintF(DEBUGLVL_BLAB,("DrmFilterGetSAC: %x, %x", InBuf, OutBuf));

    PSACPROPERTY property = (PSACPROPERTY) InBuf;

    DWORD inSize = property->inSize;
    DWORD outSize = property->outSize;

    PIO_STACK_LOCATION     irpStack = IoGetCurrentIrpStackLocation(pIrp);
    DWORD inSizeIrp=irpStack->Parameters.DeviceIoControl.InputBufferLength;
    DWORD outSizeIrp=irpStack->Parameters.DeviceIoControl.OutputBufferLength;

    pIrp->IoStatus.Information = 0;

    //
    // SECURITY NOTE:
    // Ks guarantess that the inSizeIrp is at least sizeof(SACPROPERTY) because
    // of DrmFilterPropertySet definition. So the subtraction cannot underflow.
    //
    if (inSizeIrp - sizeof(property) < inSize) 
    {
        _DbgPrintF(DEBUGLVL_TERSE,("Invalid InputSize inSize: %d ", inSize));
        return STATUS_INVALID_PARAMETER;
    }

    if (outSizeIrp < outSize) 
    {
        _DbgPrintF(DEBUGLVL_TERSE,("Invalid OutputSize outSize: %d ", outSize));
        return STATUS_INVALID_PARAMETER;
    }

    DWORD* inComm=(DWORD*) (property+1);
    BYTE* ioBuf= (BYTE*)(property + 1);

    _DbgPrintF(DEBUGLVL_VERBOSE,("inSize, outSize %d, %d ", inSize, outSize));
    _DbgPrintF(DEBUGLVL_VERBOSE,("inSizeIrp, outSizeIrp %d, %d ", inSizeIrp, outSizeIrp));
    _DbgPrintF(DEBUGLVL_VERBOSE,("---InCommand %x, %x, %x ", inComm[0], inComm[1], inComm[2]));

    if(outSize>inSize){
        memcpy(OutBuf, ioBuf, inSize);
        ioBuf=OutBuf;
    };

    NTSTATUS ntStatus=TheKrmStubs->processCommandBuffer(ioBuf, inSize, outSize, pIrp);

    // Note - kernel processing code expects a shared IO buffer.  This is counter to the
    // KS view of the world, so we use the input buffer or the output buffer (whichever 
    // is larger

    memcpy(OutBuf, ioBuf, pIrp->IoStatus.Information);

    return ntStatus;
}

//
// The following constants make up the pin descriptor.
//
const
KSDATARANGE_AUDIO 
PinDataRangesStream[] =
{
    // in-range
    {
        {
            sizeof(PinDataRangesStream[0]),
            0,
            0,
            0,
            STATICGUIDOF(KSDATAFORMAT_TYPE_AUDIO),
            STATICGUIDOF(KSDATAFORMAT_SUBTYPE_DRM),
            STATICGUIDOF(KSDATAFORMAT_SPECIFIER_WAVEFORMATEX)
        },
        6,      // Max number of channels.
        8,      // Minimum number of bits per sample.
        32,     // Maximum number of bits per channel.
        1,      // Minimum rate.
        100000  // Maximum rate.
    },
    // in-range
    {
        {
            sizeof(PinDataRangesStream[0]),
            0,
            0,
            0,
            STATICGUIDOF(KSDATAFORMAT_TYPE_AUDIO),
            STATICGUIDOF(KSDATAFORMAT_SUBTYPE_DRM),
            STATICGUIDOF(KSDATAFORMAT_SPECIFIER_DSOUND)
        },
        6,      // Max number of channels.
        8,      // Minimum number of bits per sample.
        32,     // Maximum number of bits per channel.
        1,      // Minimum rate.
        100000  // Maximum rate.
    },
    // out-range
    {
        {
            sizeof(PinDataRangesStream[0]),
            0,
            0,
            0,
            STATICGUIDOF(KSDATAFORMAT_TYPE_AUDIO),
            STATICGUIDOF(KSDATAFORMAT_SUBTYPE_WILDCARD),
            STATICGUIDOF(KSDATAFORMAT_SPECIFIER_DSOUND)
        },
        6,      // Max number of channels.
        8,      // Minimum number of bits per sample.
        32,     // Maximum number of bits per channel.
        1,      // Minimum rate.
        100000  // Maximum rate.
    },
    // out-range
    {
        {
            sizeof(PinDataRangesStream[0]),
            0,
            0,
            0,
            STATICGUIDOF(KSDATAFORMAT_TYPE_AUDIO),
            STATICGUIDOF(KSDATAFORMAT_SUBTYPE_WILDCARD),
            STATICGUIDOF(KSDATAFORMAT_SPECIFIER_WAVEFORMATEX)
        },
        6,      // Max number of channels.
        8,      // Minimum number of bits per sample.
        32,     // Maximum number of bits per channel.
        1,      // Minimum rate.
        100000  // Maximum rate.
    }
};

const
PKSDATARANGE 
DataRangeIn[] =
{
    PKSDATARANGE(&PinDataRangesStream[0]),
    PKSDATARANGE(&PinDataRangesStream[1])
};

const
PKSDATARANGE 
DataRangeOut[] =
{
    PKSDATARANGE(&PinDataRangesStream[2]),
    PKSDATARANGE(&PinDataRangesStream[3])
                                            
};

//
// For input, our only requirement is that we get 1024 byte frames
//
DECLARE_SIMPLE_FRAMING_EX(
    AllocatorFramingInput, 
    STATIC_KSMEMORY_TYPE_KERNEL_PAGED, 
    KSALLOCATOR_REQUIREMENTF_SYSTEM_MEMORY | 
    KSALLOCATOR_REQUIREMENTF_INPLACE_MODIFIER |
    KSALLOCATOR_REQUIREMENTF_PREFERENCES_ONLY,
    0,      // Max outstanding frames
    1023,   //
    DEFAULT_DRM_FRAME_SIZE,   //
    DEFAULT_DRM_FRAME_SIZE    //
);

//
// We don't want too much buffering because it will increase the delta
// between dsound play/write positions.  At the same time we don't want
// less buffering than kmixer will have on its output (80ms).  So we'll
// go with 200ms of buffer on the output.
//
// We use a static structure tuned for 44.1KHz 16-bit stereo data but
// edit the allocator on output pin creation to adjust for whatever the
// data format is.
//
DECLARE_SIMPLE_FRAMING_EX(
    AllocatorFramingOutput, 
    STATIC_KSMEMORY_TYPE_KERNEL_PAGED, 
    KSALLOCATOR_REQUIREMENTF_SYSTEM_MEMORY | 
    KSALLOCATOR_REQUIREMENTF_INPLACE_MODIFIER |
    KSALLOCATOR_REQUIREMENTF_PREFERENCES_ONLY,
    36,     // Max outstanding frames
    1023,   //
    DEFAULT_DRM_FRAME_SIZE,   //
    DEFAULT_DRM_FRAME_SIZE    //
);


const
KSPIN_DISPATCH
OutputPinDispatch =
{
    DRMOutputPinCreate,
    DRMOutputPinClose,
    NULL,// Process
    NULL,// Reset
    NULL,// SetDataFormat
    NULL,// SetDeviceState
    NULL,// Connect
    NULL // Disconnect
};

const
KSPIN_DISPATCH
InputPinDispatch =
{
    DRMInputPinCreate,
    DRMInputPinClose,
    NULL,// Process
    NULL,// Reset
    NULL,// SetDataFormat
    NULL,// SetDeviceState
    NULL,// Connect
    NULL // Disconnect
};

const
KSPIN_INTERFACE
InputPinInterfaces[] =
{
    {
        STATICGUIDOF(KSINTERFACESETID_Standard),
        KSINTERFACE_STANDARD_STREAMING
    }, 
    {
        STATICGUIDOF(KSINTERFACESETID_Standard),
        KSINTERFACE_STANDARD_LOOPED_STREAMING
    }
} ;

DEFINE_KSPROPERTY_TABLE(InputPinPropertiesAudio) {
    DEFINE_KSPROPERTY_ITEM(
        KSPROPERTY_AUDIO_POSITION,                       // idProperty
        DRMPinGetPosition,                               // pfnGetHandler
        sizeof(KSPROPERTY),                              // cbMinGetPropertyInput
        sizeof(KSAUDIO_POSITION),                        // cbMinGetDataInput
        DRMPinSetPosition,                               // pfnSetHandler
        0,                                               // Values
        0,                                               // RelationsCount
        NULL,                                            // Relations
        NULL,                                            // SupportHandler
        0                                                // SerializedSize
    )
};

DEFINE_KSPROPERTY_SET_TABLE(InputPinPropertySets) {
    DEFINE_KSPROPERTY_SET(
        &KSPROPSETID_Audio,
        SIZEOF_ARRAY(InputPinPropertiesAudio),
        InputPinPropertiesAudio,
        0,
        NULL
    )
};

DEFINE_KSEVENT_TABLE(InputPinEventsLoopedStreaming) {
    DEFINE_KSEVENT_ITEM(
        KSEVENT_LOOPEDSTREAMING_POSITION,
        sizeof(LOOPEDSTREAMING_POSITION_EVENT_DATA),
        sizeof(DRMLOOPEDSTREAMING_POSITION_EVENT_ENTRY) - sizeof(KSEVENT_ENTRY),
        DRMInputPinAddLoopedStreamingPositionEvent,
        NULL, // DRMInputPinRemoveLoopedStreamingPositionEvent,
        NULL  // DRMInputPinSupportLoopedStreamingPositionEvent
    )
};

DEFINE_KSEVENT_SET_TABLE(InputPinEventSets) {
    DEFINE_KSEVENT_SET(
        &KSEVENTSETID_LoopedStreaming,
        SIZEOF_ARRAY(InputPinEventsLoopedStreaming),
        InputPinEventsLoopedStreaming
    )
};

DEFINE_KSAUTOMATION_TABLE(InputPinAutomation) {
    DEFINE_KSAUTOMATION_PROPERTIES(InputPinPropertySets),
    DEFINE_KSAUTOMATION_METHODS_NULL,
    DEFINE_KSAUTOMATION_EVENTS(InputPinEventSets)
};

const
KSPIN_DESCRIPTOR_EX
PinDescriptors[] =
{
    {   
        // OUTPUT Pin (Id 0, PIN_ID_OUTPUT)
        &OutputPinDispatch,
        NULL,//Automation
        {
            DEFINE_KSPIN_DEFAULT_INTERFACES,
            DEFINE_KSPIN_DEFAULT_MEDIUMS,
            SIZEOF_ARRAY(DataRangeOut),
            DataRangeOut,
            KSPIN_DATAFLOW_OUT,
            KSPIN_COMMUNICATION_BOTH,
            NULL,//Category
            NULL,//Name
            0
        },
        0,  // KSPIN_FLAGS_*
        1,
        1,
        &AllocatorFramingOutput,
        DRMAudioIntersectHandlerOutPin
    },
    {   
        // INPUT Pin (Id 1, PIN_ID_INPUT)
        &InputPinDispatch,
        &InputPinAutomation,//Automation
        {
             SIZEOF_ARRAY(InputPinInterfaces),
             &InputPinInterfaces[0],
             DEFINE_KSPIN_DEFAULT_MEDIUMS,
             SIZEOF_ARRAY(DataRangeIn),
             DataRangeIn,
             KSPIN_DATAFLOW_IN,
             KSPIN_COMMUNICATION_BOTH,
             NULL,//Category
             NULL,//Name
             0
        },
        KSPIN_FLAG_PROCESS_IN_RUN_STATE_ONLY,   // KSPIN_FLAGS_*
        1,
        1,
        &AllocatorFramingInput,
        DRMAudioIntersectHandlerInPin
    }
};

//
// The list of categories for the filter.
//
const
GUID
Categories[] =
{
    STATICGUIDOF(KSCATEGORY_DATATRANSFORM),
    STATICGUIDOF(KSCATEGORY_AUDIO),
    STATICGUIDOF(KSCATEGORY_DRM_DESCRAMBLE)
};

//
// This type of definition is required because the compiler will not otherwise
// put these GUIDs in a paged segment.
//
const
GUID
NodeType = {STATICGUIDOF(KSNODETYPE_DRM_DESCRAMBLE)};

//
// The list of node descriptors.
//
const
KSNODE_DESCRIPTOR
NodeDescriptors[] =
{
    DEFINE_NODE_DESCRIPTOR(NULL,&NodeType,NULL)
};

//
// The filter dispatch table.
//
const
KSFILTER_DISPATCH
FilterDispatch =
{
    DRMFilterCreate, 
    DRMFilterClose, 
    DRMProcess,
    (PFNKSFILTERVOID) DRMFilterReset  // Reset
};

DEFINE_KSPROPERTY_TABLE(DrmFilterPropertiesDrmAudioStream) {
    DEFINE_KSPROPERTY_ITEM(
        1,  // Should define a constant in a header             // idProperty
        DrmFilterGetSAC,                                 // pfnGetHandler
        sizeof(SACPROPERTY),                             // cbMinGetPropertyInput
        sizeof(LONG),                                    // cbMinGetDataInput
        NULL,                                            // pfnSetHandler
        0,                                               // Values
        0,                                               // RelationsCount
        NULL,                                            // Relations
        NULL,                                            // SupportHandler
        0                                                // SerializedSize
    )
};

DEFINE_KSPROPERTY_SET_TABLE(DrmFilterPropertySets) {
    DEFINE_KSPROPERTY_SET(
        &KSPROPSETID_DrmAudioStream,
        SIZEOF_ARRAY(DrmFilterPropertiesDrmAudioStream),
        DrmFilterPropertiesDrmAudioStream,
        0,
        NULL
    )
};

DEFINE_KSAUTOMATION_TABLE(DrmFilterAutomation) {
    DEFINE_KSAUTOMATION_PROPERTIES(DrmFilterPropertySets),
    DEFINE_KSAUTOMATION_METHODS_NULL,
    DEFINE_KSAUTOMATION_EVENTS_NULL
};

#define STATIC_REFERENCE_ID \
    0xabd61e00, 0x9350, 0x47e2, 0xa6, 0x32, 0x44, 0x38, 0xb9, 0xc, 0x66, 0x41  
DEFINE_GUIDSTRUCT("ABD61E00-9350-47e2-A632-4438B90C6641", REFERENCE_ID);

#define REFERENCE_ID DEFINE_GUIDNAMED(REFERENCE_ID)

DEFINE_KSFILTER_DESCRIPTOR(DrmFilterDescriptor)
{   
    &FilterDispatch,
    &DrmFilterAutomation, //AutomationTable;
    KSFILTER_DESCRIPTOR_VERSION,
    0,//Flags
    &REFERENCE_ID,
    DEFINE_KSFILTER_PIN_DESCRIPTORS(PinDescriptors),
    DEFINE_KSFILTER_CATEGORIES(Categories),
    DEFINE_KSFILTER_NODE_DESCRIPTORS(NodeDescriptors),
    DEFINE_KSFILTER_DEFAULT_CONNECTIONS,
    NULL // ComponentId
};

extern "C" void DrmGetFilterDescriptor(const KSFILTER_DESCRIPTOR **ppDescriptor)
{
    *ppDescriptor = &DrmFilterDescriptor;
    return;
}

//****************************
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\drm\krm\drmk\private.h ===
/*++

Copyright (C) Microsoft Corporation, 1998 - 2000

Module Name:

    private.h

Abstract:

    This module contains private definitions for DRMK.sys

Author:

      Paul England (PEngland) from sample code by 
	  Dale Sather  (DaleSat) 31-Jul-1998

--*/

extern "C" {
	#include <wdm.h>
}
#include <unknown.h>
#include <ks.h>

#include <windef.h>
#include <stdio.h>
#include <windef.h>
#define NOBITMAP
#include <mmreg.h>
#undef NOBITMAP
#include <ks.h>
#include "ksmedia.h"
#include <unknown.h>
#include <kcom.h>

#if (DBG)
#define STR_MODULENAME "KDRM:"
#endif
#include <ksdebug.h>

#define POOLTAG '2mrD'

#include "inc/KrmCommStructs.h"
#include "inc/DrmErrs.h"
#include <drmk.h>

#pragma code_seg("PAGE")

#define PIN_ID_OUTPUT 0
#define PIN_ID_INPUT  1

// 
struct FilterInstance{
	DWORD StreamId;					// StreamId (known elsewhere as ContentId) is unique-per-stream
	PKSDATAFORMAT OutDataFormat;	// Output KS data format
	PWAVEFORMATEX OutWfx;			// Pointer to the waveformatex embedded somewhere within *OutDataFormat
	STREAMKEY streamKey;			// initially set to the value obtained from StreamManager
	bool initKey;					// has the streamKey been initted?
	bool decryptorRunning;			// has the Descrambler seen the start frame?
	DWORD frameSize;				// size of frame (calculated from OutWfx by Descrambler)
};

struct InputPinInstance
{
    // For LOOPED_STREAMING pins:
    //  the frame's original loop pointer and size
    struct {
	PVOID Data;
	ULONG BytesAvailable;
    } Loop;
    //  the output pin's position when the frame was started or
    //  its position last set
    ULONGLONG BasePosition;
    //  the position within the frame when it was started or
    //  its position last set
    ULONGLONG StartPosition;
    //  the next copy-from position within the frame
    ULONGLONG OffsetPosition;
    //  the position last set, and a flag indicating that this
    //  position needs to be set by the Process function
    ULONGLONG SetPosition;
    BOOL      PendingSetPosition;
};

struct OutputPinInstance
{
    // count of bytes written to the output
    ULONGLONG BytesWritten;
};

typedef struct {
    KSEVENT_ENTRY EventEntry;
    ULONGLONG Position;
} DRMLOOPEDSTREAMING_POSITION_EVENT_ENTRY, *PDRMLOOPEDSTREAMING_POSITION_EVENT_ENTRY;

NTSTATUS
DRMAudioIntersectHandlerInPin(
    IN PVOID Filter,
    IN PIRP Irp,
    IN PKSP_PIN PinInstance,
    IN PKSDATARANGE CallerDataRange,
    IN PKSDATARANGE DescriptorDataRange,
    IN ULONG BufferSize,
    OUT PVOID Data OPTIONAL,
    OUT PULONG DataSize
    );

NTSTATUS
DRMAudioIntersectHandlerOutPin(
    IN PVOID Filter,
    IN PIRP Irp,
    IN PKSP_PIN PinInstance,
    IN PKSDATARANGE CallerDataRange,
    IN PKSDATARANGE DescriptorDataRange,
    IN ULONG BufferSize,
    OUT PVOID Data OPTIONAL,
    OUT PULONG DataSize
    );


//
// DRMFilter.cpp
//
extern
const
KSFILTER_DESCRIPTOR 
DrmFilterDescriptor;

//
// Filters table.
//

#ifdef DEFINE_FILTER_DESCRIPTORS_ARRAY

DEFINE_KSFILTER_DESCRIPTOR_TABLE(FilterDescriptors)
{   
	&DrmFilterDescriptor

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\drm\krm\drmkaud\device.cpp ===
/*++

Copyright (C) Microsoft Corporation, 1998 - 1999

Module Name:

    device.cpp

Abstract:

    This module contains the device implementation for audio.sys.

Author:


    Frank Yerrace (FrankYe) 18-Sep-2000
    Dale Sather  (DaleSat) 31-Jul-1998

--*/
#include "private.h"

//
// Filters table.
//
const KSFILTER_DESCRIPTOR* FilterDescriptors[] =
{   
	NULL    // Placeholder for DRM fitler descriptor
};

const
KSDEVICE_DESCRIPTOR 
DeviceDescriptor =
{   
    NULL,
    SIZEOF_ARRAY(FilterDescriptors),
    FilterDescriptors
};

NTSTATUS 
__stdcall
DriverEntry
(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPathName
)
/*++

Routine Description:

    Sets up the driver object.

Arguments:

    DriverObject -
        Driver object for this instance.

    RegistryPathName -
        Contains the registry path which was used to load this instance.

Return Values:

    Returns STATUS_SUCCESS if the driver was initialized.

--*/
{
    _DbgPrintF(DEBUGLVL_VERBOSE,("[DrmkAud:DriverEntry]"));
    const KSFILTER_DESCRIPTOR * pDrmFilterDescriptor;
    DrmGetFilterDescriptor(&pDrmFilterDescriptor);
    FilterDescriptors[0] = pDrmFilterDescriptor;
    return KsInitializeDriver(DriverObject, RegistryPathName, &DeviceDescriptor);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\drm\krm\drmkmain\audiodescrambler.h ===
#ifndef AudioDescrambler_h
#define AudioDescrambler_h

// Descramble/decrypt a block of audio data.
DRM_STATUS DescrambleBlock(WAVEFORMATEX* Wfx, DWORD StreamId, 			   // wfx of embedded audio
				BYTE* Dest, DWORD DestSize, DWORD* DestUsed,   // as you might expect
				BYTE* Src, DWORD SrcSize, DWORD* SrcUsed,	   // as you might expect
				BOOL InitKey,								// set to init the streamKek from 
				STREAMKEY* streamKey, 						// the streamManager
				DWORD FrameSize							// frameSize.  If zero, the frameSize is calculated
				);											// based on the Wfx and FrameSize is set (ie do this
															// once.)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\drm\krm\drmkmain\drmkpch.h ===
#if !defined(AFX_STDAFX_H__0AE93D2D_68D1_4D39_8BEA_BF7086C82135__INCLUDED_)
#define AFX_STDAFX_H__0AE93D2D_68D1_4D39_8BEA_BF7086C82135__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

extern "C"{
	#include <wdm.h>
};
#include "MyNew.h"
#include <unknown.h>
#include <ksdebug.h>
#include <ks.h>
#include <ksmedia.h>
#define NOBITMAP
#include <mmreg.h>

#include "KGlobs.h"
#include "../inc/DrmErrs.h"
#include "KrmCommStructs.h"
#include "KGlobs.h"
#include "drmk.h"


#if (DBG)
#define STR_MODULENAME "DRMKMain:"
#endif

#pragma code_seg("PAGE")

#endif // !defined(AFX_STDAFX_H__0AE93D2D_68D1_4D39_8BEA_BF7086C82135__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\drm\krm\drmkmain\handlemgr.cpp ===
#include "drmkPCH.h"
#include "CBCKey.h"
#include "KList.h"
#include "HandleMgr.h"
//------------------------------------------------------------------------------
HandleMgr* TheHandleMgr=NULL;
//------------------------------------------------------------------------------
HandleMgr::HandleMgr(){
	KCritical c(critMgr);
	TheHandleMgr=this;
	return;
};
//------------------------------------------------------------------------------
HandleMgr::~HandleMgr(){
	KCritical c(critMgr);
	POS p=connects.getHeadPosition();
	while(p!=NULL){
		ConnectStruct* cs=connects.getNext(p);
		delete cs;
	};
	return;
};
//------------------------------------------------------------------------------
bool HandleMgr::newHandle(PVOID HandleRef, OUT ConnectStruct*& TheConnect){
	if(!critMgr.isOK()){
		_DbgPrintF(DEBUGLVL_VERBOSE,("Out of memory"));
		return false;
	};
	KCritical c(critMgr);
	POS p=connects.getHeadPosition();
	while(p!=NULL){
		ConnectStruct* cs=connects.getNext(p);
		if(cs->handleRef==HandleRef){
			_DbgPrintF(DEBUGLVL_VERBOSE,("Handle already exists"));
			return false;
		};
	};
	TheConnect=new ConnectStruct;
	if(TheConnect==NULL){
		_DbgPrintF(DEBUGLVL_VERBOSE,("Out of memory"));
		return false;
	};
	memset(TheConnect, 0, sizeof(*TheConnect));
	TheConnect->handleRef=HandleRef;
	TheConnect->secureStreamStarted=false;
	bool ok=connects.addTail(TheConnect);
	if(!ok){
		delete TheConnect;
		return false;
	};
	return true;
};
//------------------------------------------------------------------------------
bool HandleMgr::deleteHandle(PVOID HandleRef){
	if(!critMgr.isOK()){
		_DbgPrintF(DEBUGLVL_VERBOSE,("Out of memory"));
		return false;
	};
	KCritical c(critMgr);
	POS p=connects.getHeadPosition();
	while(p!=NULL){
		POS oldP=p;
		ConnectStruct* cs=connects.getNext(p);
		if(cs->handleRef==HandleRef){
			ConnectStruct* cs1=connects.getAt(oldP);
			delete cs1;
			connects.removeAt(oldP);
			return true;
		};
	};
	_DbgPrintF(DEBUGLVL_VERBOSE,("Handle does not exist"));
	return false;
};
//------------------------------------------------------------------------------
ConnectStruct* HandleMgr::getConnection(PVOID HandleRef){
	if(!critMgr.isOK()){
		_DbgPrintF(DEBUGLVL_VERBOSE,("Out of memory"));
		return false;
	};
	KCritical c(critMgr);
	POS p=connects.getHeadPosition();
	while(p!=NULL){
		ConnectStruct* cs=connects.getNext(p);
		if(cs->handleRef==HandleRef)return cs;
	};
	_DbgPrintF(DEBUGLVL_VERBOSE,("Handle does not exist"));
	return NULL;
};
//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\drm\krm\drmkmain\encraption.h ===
/*++

Copyright (C) Microsoft Corporation, 2002 - 2002

Module Name:

    encraption.h

Abstract:

    This module contains simple obfuscation algorithm to hide communication
    keys.

Author:
    Carsten Hansen
    Alper Selcuk


--*/


#ifndef _ENCRAPTION_H
#define _ENCRAPTION_H

//=============================================================================
//
// This routine clears the given key. The encryption/decryption method is 
// developed by CarstenH.
//
NTSTATUS __forceinline ClearKey(
    const BYTE *PrivKey, 
    BYTE *ClearKey,
    ULONG KeySize, 
    ULONG MagicNumber2)
{
    const char * pszName = "Microsoft Corporation";

    /* Convert the obfuscated key to clear */
    BYTE *clearDRMKPriv;

    clearDRMKPriv = (BYTE *) ExAllocatePool(PagedPool, KeySize);
    if (NULL == clearDRMKPriv) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    /* Permute bytes */
    int k = 1;
    clearDRMKPriv[0] = PrivKey[0];
    do {
        int l = k * MagicNumber2 % (KeySize - 1);
        clearDRMKPriv[k] = PrivKey[l];
        if (l == 1)
            break;
        k = l;
    } while (1);
    clearDRMKPriv[KeySize - 1] = PrivKey[KeySize - 1];

    /* Swap nibbles */
    DWORD * pdw = (DWORD *) clearDRMKPriv;
    DWORD * qdw = (DWORD *) (clearDRMKPriv + KeySize);
    DWORD granularity = 4;
    for (; pdw < qdw; ++ pdw)
    {
        DWORD temp = 0xF0F0F0F0;
        temp &= *pdw;
        *pdw ^= temp;
        temp ^= (*pdw << granularity);
        *pdw |= (*pdw << granularity);
        *pdw ^= (temp >> granularity);
    }

    /* XOR with "Microsoft" */
    ULONG len = strlen(pszName);
    for (ULONG i = 0, j = 0; i < KeySize; ++i)
    {
        clearDRMKPriv[i] ^= pszName[j];
        ++j;
        if (j > len)
            j = 0;
    }

    RtlCopyMemory(ClearKey, clearDRMKPriv, KeySize);

    RtlZeroMemory(clearDRMKPriv, KeySize);
    ExFreePool(clearDRMKPriv);

    return STATUS_SUCCESS;
}

/* Obfuscation algorithm.
	{
		// XOR with "Microsoft" 
		int len = strlen(pszName);
		for (int i = 0, j = 0; i < sizeof(objDRMKPriv); ++i)
		{
			objDRMKPriv[i] = DRMKpriv[i] ^ pszName[j];
			++j;
			if (j > len)
				j = 0;
		}

		// Swap nibbles 
		DWORD * pdw = (DWORD *) objDRMKPriv;
		DWORD * qdw = (DWORD *) (objDRMKPriv + sizeof(objDRMKPriv));
		DWORD granularity = 4;
		for (; pdw < qdw; ++ pdw)
		{
			DWORD temp = 0xF0F0F0F0;
			temp &= *pdw;
			*pdw ^= temp;
			temp ^= (*pdw << granularity);
			*pdw |= (*pdw << granularity);
			*pdw ^= (temp >> granularity);
		}

		// Permute bytes
		int k = 1;
		BYTE temp = objDRMKPriv[k];
		do {
			int l = k * MAGIC_NUMBER_1 % (sizeof(objDRMKPriv) - 1);
			if (l == 1)
				break;
			objDRMKPriv[k] = objDRMKPriv[l];
			k = l;
		} while (1);
		objDRMKPriv[k] = temp;
	}
*/

/* Clean Key and Cert
static const BYTE DRMKpriv[20] = {
        0x80, 0x0B, 0x97, 0x30, 0x7A, 0xFB, 0x1B, 0x3B, 
        0xB7, 0xB2, 0x0F, 0x44, 0x63, 0xD8, 0xA5, 0x2D, 
        0xD5, 0xBC, 0x3D, 0x75};
static const BYTE DRMKCert[104] = {
        0x00, 0x01, 0x00, 0x00, 0x38, 0x00, 0x00, 0x00,
        0x46, 0xB1, 0x18, 0x76, 0x66, 0xBE, 0x91, 0xEC,
        0xBD, 0x06, 0x50, 0x72, 0x1B, 0x8C, 0xD3, 0x55,
        0xD2, 0x1A, 0xB7, 0x60, 0x6C, 0x65, 0xDD, 0xE4,
        0x54, 0xCE, 0xFD, 0xEB, 0x4A, 0x9F, 0x0A, 0x5A,
        0xD1, 0x44, 0xB2, 0x32, 0xB9, 0xA0, 0x84, 0x67,
        0x55, 0xD7, 0xFE, 0x45, 0xD5, 0x16, 0x36, 0x7B,
        0xEC, 0x3C, 0xFF, 0x7D, 0x4C, 0x09, 0x9A, 0x7B,
        0xB4, 0x6C, 0xEF, 0x2B, 0xC5, 0xF8, 0xA3, 0xC4,
        0xE2, 0x57, 0xC5, 0x87, 0xA6, 0x75, 0x85, 0xFE,
        0xE2, 0x34, 0xA3, 0x30, 0xAE, 0x4D, 0xDB, 0x23,
        0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x06,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01};
*/

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\drm\krm\drmkmain\handlemgr.h ===
#ifndef HandleMgr_h
#define HandleMgr_h
// This class manages an impedance mismatch between IOCT processing and KS stream 
// processing.  Specifically, filters are passed KSPIN and IRP state, and keep 
// per-filter instance data in parent filter "context."  This information is unavailable
// to IOCT processing.  However, the stream encryption and communication keys are
// needed in both.
// The common structure available in both worls is the FILE_HANDLE.  This class contains
// a list of FILE_HANDLES that can be used to map between worlds.
// This is only used and referenced on IOCTL processing and for filter creation and 
// destruction.

// todo - efficiency
//-----------------------------------------------------------------------------
struct ConnectStruct{
    PVOID handleRef;                // the FILE_HANDLE
    STREAMKEY serverKey;            // stream key for SAC in kernel
    CBCKey serverCBCKey;            // MAC key in kernel
    CBCState serverCBCState;        // MAC state
    bool secureStreamStarted;       // whether we're running encrypted
    DWORD streamId;                 // StreamId
};
//-----------------------------------------------------------------------------
class HandleMgr{
public:
    HandleMgr();
    ~HandleMgr();
    bool newHandle(PVOID HandleRef, OUT ConnectStruct*& TheConnect);
    bool deleteHandle(PVOID HandleRef);
    ConnectStruct* getConnection(PVOID HandleRef);

    KCritMgr& getCritMgr(){return critMgr;};
    
protected:
    KList<ConnectStruct*> connects;
    KCritMgr critMgr;
};
extern HandleMgr* TheHandleMgr;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\drm\krm\drmkmain\iohelp.h ===
/* iohelp.h
 * Copyright (c) 2001 Microsoft Corporation
 */

EXTERN_C
PDEVICE_OBJECT
IoGetLowerDeviceObject(
    IN  PDEVICE_OBJECT  DeviceObject
    );

EXTERN_C
NTSTATUS
IoDeviceIsVerifier(
    PDEVICE_OBJECT DeviceObject
    );

EXTERN_C
NTSTATUS
IoDeviceIsAcpi(
    PDEVICE_OBJECT DeviceObject
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\drm\krm\drmkmain\authstubs.cpp ===
#include "drmkPCH.h"
#include "KList.h"
#include "StreamMgr.h"
#include "iohelp.h"

//-------------------------------------------------------------------------------------------------
//	Package implements the DRMK authentication stubs.  Routines are called to notify DRMK of downstream
//	components and to notify DRMK of the creation and destruction of composite streams.  ContentId
//	in this file is called StreamId elsewhere.
//-------------------------------------------------------------------------------------------------
static NTSTATUS GetDeviceObjectDispatchTable(IN DWORD ContentId, IN _DEVICE_OBJECT* pDevO, IN BOOL fCheckAttached);
static NTSTATUS GetFileObjectDispatchTable(IN DWORD ContentId, IN PFILE_OBJECT pF);
//-------------------------------------------------------------------------------------------------
/*
	Routine called by a splitter component.  Any stream with ContentId==0 is considered unprotected.
*/
NTSTATUS DrmCreateContentMixed(IN PULONG paContentId,
			       IN ULONG cContentId,
			       OUT PULONG pMixedContentId)
{
	KCritical s(TheStreamMgr->getCritMgr());
	if((NULL==paContentId && !(cContentId!=0)) || NULL==pMixedContentId){
		_DbgPrintF(DEBUGLVL_VERBOSE,("Invalid NULL-parameter for DrmCreateContentMixed"));
		TheStreamMgr->logErrorToStream(0, STATUS_INVALID_PARAMETER);
		return STATUS_INVALID_PARAMETER;
	};
	_DbgPrintF(DEBUGLVL_VERBOSE,("DrmCreateMixed for N streams, N= %d", cContentId));
	DRM_STATUS stat = TheStreamMgr->createCompositeStream(pMixedContentId, paContentId, cContentId);
    if(stat==DRM_OK){
		return STATUS_SUCCESS;
	}
	// only error is out-of-memory  
	TheStreamMgr->setFatalError(STATUS_INSUFFICIENT_RESOURCES);
	return STATUS_INSUFFICIENT_RESOURCES;
}
//------------------------------IO-------------------------------------------------------------------
/*
	Routine called by a component to notify KRM of a downstream COM object that will process audio.
	DrmForwardContent will collect its authentication function, and set the DRMRIGHTS bits appropriately.
*/
NTSTATUS DrmForwardContentToInterface(ULONG ContentId, PUNKNOWN pUnknown, ULONG NumMethods)
{

	
    NTSTATUS Status;
    PDRMAUDIOSTREAM DrmAudioStream;
    
    _DbgPrintF(DEBUGLVL_VERBOSE,("***IN ForwardToInterface"));

    if(NULL == pUnknown){
        _DbgPrintF(DEBUGLVL_VERBOSE,("Invalid NULL-parameter for DrmForwardContentToInterface"));
        TheStreamMgr->logErrorToStream(ContentId, STATUS_INVALID_PARAMETER);
        return STATUS_INVALID_PARAMETER;
    };

    Status = pUnknown->QueryInterface(IID_IDrmAudioStream, (PVOID*)&DrmAudioStream);
    if (!NT_SUCCESS(Status)){
        _DbgPrintF(DEBUGLVL_VERBOSE,("QI Failed for StreamId= %x (Status=%d, %x)", ContentId, Status, Status));
        TheStreamMgr->logErrorToStream(ContentId, Status);
        return Status;		
    };
	
    // ReferenceAquirer calls Release() when it goes out of scope
    ReferenceAquirer<PDRMAUDIOSTREAM> aq(DrmAudioStream);

    // rights are most permissive.  If ContentId!=0, we query the mixed stream that compose
    // this stream to restrict the rights.
    DRMRIGHTS DrmRights={FALSE, FALSE, FALSE};
    
    if(ContentId!=0){
        KCritical s(TheStreamMgr->getCritMgr());
        _DbgPrintF(DEBUGLVL_VERBOSE,("Adding %d methods", NumMethods));
        // get the pointer to the vtbl
        PVOID* vtbl= *((PVOID**) pUnknown);
        // and add NumMethods of from the vtbl
        for(ULONG j=0;j<NumMethods;j++){
            _DbgPrintF(DEBUGLVL_VERBOSE,("ADDING = %x", vtbl[j]));
            if (vtbl[j]) {
                Status = TheStreamMgr->addProvingFunction(ContentId, vtbl[j]);
            } else {
                Status = STATUS_INVALID_PARAMETER;
            }
            if(!NT_SUCCESS(Status)){
                _DbgPrintF(DEBUGLVL_VERBOSE,("addProveFunc Failed for StreamId= %x", ContentId));
                TheStreamMgr->logErrorToStream(ContentId, Status);
                return Status;		
            };
        };
        Status=TheStreamMgr->getRights(ContentId, &DrmRights);
        if(!NT_SUCCESS(Status)){
            _DbgPrintF(DEBUGLVL_VERBOSE,("getRights failed for StreamId= %x", ContentId));
            TheStreamMgr->logErrorToStream(ContentId, Status);
            return Status;		
        };
    };

    _DbgPrintF(DEBUGLVL_VERBOSE,("About to SetContentId "));
    Status = DrmAudioStream->SetContentId(ContentId, &DrmRights);

    if(!NT_SUCCESS(Status)){
        _DbgPrintF(DEBUGLVL_VERBOSE,("SetContentId failed for StreamId= %x (Status=%d, %x)", ContentId, Status, Status));
        if (STATUS_NOT_IMPLEMENTED == Status) {
            TheStreamMgr->logErrorToStream(ContentId, DRM_RIGHTSNOTSUPPORTED);
        } else {
            TheStreamMgr->logErrorToStream(ContentId, Status);
        }
        return Status;		
    };
    return STATUS_SUCCESS;
}

//-------------------------------------------------------------------------------------------------
/*
	Routine called by a component to notify KRM of a downstream FILE object that will process audio.
	DrmForwardContent will collect its authentication function, and set the DRMRIGHTS bits appropriately.
*/
NTSTATUS DrmForwardContentToFileObject(IN ULONG ContentId,
				       IN PFILE_OBJECT FileObject)
{
    KSP_DRMAUDIOSTREAM_CONTENTID Property;
    KSDRMAUDIOSTREAM_CONTENTID PropertyValue;
    ULONG cbReturned;
    NTSTATUS Status;

    _DbgPrintF(DEBUGLVL_VERBOSE,("***IN ForwardToFileObject"));
    
    if (FileObject)
    {
        KCritical s(TheStreamMgr->getCritMgr());
    
        if (0 != ContentId) {
            NTSTATUS stat=GetFileObjectDispatchTable(ContentId, FileObject);
        }
    
        Property.Property.Set   = KSPROPSETID_DrmAudioStream;
        Property.Property.Id    = KSPROPERTY_DRMAUDIOSTREAM_CONTENTID;
        Property.Property.Flags = KSPROPERTY_TYPE_SET;
        
        Property.Context = FileObject;
        
        Property.DrmAddContentHandlers =           DrmAddContentHandlers;
        Property.DrmCreateContentMixed =           DrmCreateContentMixed;
        Property.DrmDestroyContent     =           DrmDestroyContent;
        Property.DrmForwardContentToDeviceObject = DrmForwardContentToDeviceObject;
        Property.DrmForwardContentToFileObject =   DrmForwardContentToFileObject;
        Property.DrmForwardContentToInterface =    DrmForwardContentToInterface;
        Property.DrmGetContentRights =             DrmGetContentRights;
        
    
        PropertyValue.ContentId = ContentId;
        Status = TheStreamMgr->getRights(ContentId, &PropertyValue.DrmRights);
        if(!NT_SUCCESS(Status)){
            _DbgPrintF(DEBUGLVL_VERBOSE,("Bad getRights for StreamId= %x", ContentId));
            return Status;		
        };
    } else {
        _DbgPrintF(DEBUGLVL_VERBOSE,("Invalid NULL-parameter for DrmForwardContentToFileObject"));
        TheStreamMgr->logErrorToStream(ContentId, STATUS_INVALID_PARAMETER);
        return STATUS_INVALID_PARAMETER;
    }

    Status = KsSynchronousIoControlDevice(FileObject, KernelMode, IOCTL_KS_PROPERTY,
                                            &Property, sizeof(Property),
                                            &PropertyValue, sizeof(PropertyValue),
                                            &cbReturned);
    
    // TBD: translate STATUS_PROPSET_NOT_FOUND to something better
    
    if(!NT_SUCCESS(Status)){
        _DbgPrintF(DEBUGLVL_VERBOSE,("Bad IoControl(1b) for StreamId= %x on driver.  Device with load address [%x] does not support DRM property,(Status=%d, %x)", 
                ContentId, IoGetRelatedDeviceObject(FileObject)->DriverObject->DriverStart,Status, Status));
        if (STATUS_NOT_IMPLEMENTED == Status) {
            TheStreamMgr->logErrorToStream(ContentId, DRM_RIGHTSNOTSUPPORTED);
        } else {
            TheStreamMgr->logErrorToStream(ContentId, Status);
        }
        return Status;		
    };		

    //This may be confusing.  We're logging an error here to indicate
    //that DrmForwardContentToFileObject was called.  This error will
    //later be propagated up to krmproxy and used to adjust the security
    //level of the drivers, since DrmForwardContentToFileObject opens a
    //security hole.  We return success from the function after logging
    //because we want driver walking to continue from this point, not
    //fail, since this is not a fatal error.
    //This error code can be overwritten later by another call to
    //logErrorToStream, but it will be overwritten either with a fatal
    //error or with DRM_BADDRMLEVEL again.
    TheStreamMgr->logErrorToStream(ContentId, DRM_BADDRMLEVEL);
    
    return STATUS_SUCCESS;
}

//-------------------------------------------------------------------------------------------------
/*
	Routine called by a component to notify KRM of a downstream DEVICE object that will process audio.
	DrmForwardContent will collect its authentication function, and set the DRMRIGHTS bits appropriately.
*/
NTSTATUS DrmForwardContentToDeviceObject(IN ULONG ContentId,
				         IN PVOID Reserved,
				         IN PCDRMFORWARD DrmForward)
{
    _DbgPrintF(DEBUGLVL_VERBOSE,("***IN ForwardToDeviceObject"));

    PDEVICE_OBJECT DeviceObject;
    PFILE_OBJECT FileObject;
    PVOID Context;
    NTSTATUS Status;

    KSP_DRMAUDIOSTREAM_CONTENTID Property;
    KSDRMAUDIOSTREAM_CONTENTID PropertyValue;

    Status = STATUS_SUCCESS;

    if (NULL != Reserved) {
    	//
    	// This is an older driver which passes the DeviceObject as the
    	// second param and the Context as the third param.
    	//
    	DeviceObject = (PDEVICE_OBJECT)Reserved;
    	FileObject = NULL;
    	Context = (PVOID)DrmForward;
    } else {
    	if (0 != DrmForward->Flags) {
    	    Status = STATUS_INVALID_PARAMETER;
            TheStreamMgr->logErrorToStream(ContentId, Status);
    	} else {
            DeviceObject = DrmForward->DeviceObject;
            FileObject = DrmForward->FileObject;
            Context = DrmForward->Context;
    	}
    }

    if (!NT_SUCCESS(Status)) return Status;
    	
    if (DeviceObject)
    {
        KCritical s(TheStreamMgr->getCritMgr());

        if (0 != ContentId) {
            NTSTATUS stat=GetDeviceObjectDispatchTable(ContentId, DeviceObject, FALSE);
        }
    
        Property.Property.Set   = KSPROPSETID_DrmAudioStream;
        Property.Property.Id    = KSPROPERTY_DRMAUDIOSTREAM_CONTENTID;
        Property.Property.Flags = KSPROPERTY_TYPE_SET;
        
        Property.Context = Context;
        
        Property.DrmAddContentHandlers =           DrmAddContentHandlers;
        Property.DrmCreateContentMixed =           DrmCreateContentMixed;
        Property.DrmDestroyContent     =           DrmDestroyContent;
        Property.DrmForwardContentToDeviceObject = DrmForwardContentToDeviceObject;
        Property.DrmForwardContentToFileObject =   DrmForwardContentToFileObject;
        Property.DrmForwardContentToInterface =    DrmForwardContentToInterface;
        Property.DrmGetContentRights =             DrmGetContentRights;
    
        PropertyValue.ContentId = ContentId;
        Status = TheStreamMgr->getRights(ContentId, &PropertyValue.DrmRights);
        if(!NT_SUCCESS(Status)){
            _DbgPrintF(DEBUGLVL_VERBOSE,("Bad getRights for StreamId= %x", ContentId));
            return Status;		
        };
    } else {
        _DbgPrintF(DEBUGLVL_VERBOSE,("Invalid NULL-parameter for DrmForwardContentToFileObject"));
        TheStreamMgr->logErrorToStream(ContentId, STATUS_INVALID_PARAMETER);
        return STATUS_INVALID_PARAMETER;
    }
    
    KEVENT Event;
    PIRP Irp;
    IO_STATUS_BLOCK IoStatusBlock;
    
    KeInitializeEvent(&Event, NotificationEvent, FALSE);
    Irp = IoBuildDeviceIoControlRequest(
        IOCTL_KS_PROPERTY,
        DeviceObject,
        &Property,
        sizeof(Property),
        &PropertyValue,
        sizeof(PropertyValue),
        FALSE,
        &Event,
        &IoStatusBlock);
    if (Irp) {
        //
        // Originating in kernel, no need to probe buffers, etc.
        //
        Irp->RequestorMode = KernelMode;

        //
        // Set the file object in the next stack location
        //
        IoGetNextIrpStackLocation(Irp)->FileObject = FileObject;
    
        //
        Status = IoCallDriver(DeviceObject, Irp);
        if (Status == STATUS_PENDING) {
            //
            // This waits using KernelMode, so that the stack, and therefore the
            // event on that stack, is not paged out.
            //
            KeWaitForSingleObject(&Event, Suspended, KernelMode, FALSE, NULL);
            Status = IoStatusBlock.Status;
        }
    } else {
        Status = STATUS_INSUFFICIENT_RESOURCES;
    }
                                                                                
    // TBD: translate STATUS_PROPSET_NOT_FOUND to something better
    
    if(!NT_SUCCESS(Status)){
        _DbgPrintF(DEBUGLVL_VERBOSE,("Bad IoControl for StreamId(2)= %x (Status=%d, %x)", ContentId, Status, Status));
        if (STATUS_NOT_IMPLEMENTED == Status) {
            TheStreamMgr->logErrorToStream(ContentId, DRM_RIGHTSNOTSUPPORTED);
        } else {
            TheStreamMgr->logErrorToStream(ContentId, Status);
        }
        return Status;		
    };		

    return STATUS_SUCCESS;
}

//--------------------------------------------------------------------------
NTSTATUS DrmDestroyContent(IN ULONG ContentId)
{
    KCritical s(TheStreamMgr->getCritMgr());
    _DbgPrintF(DEBUGLVL_VERBOSE,("DestroyStream for StreamId= %x", ContentId));
    NTSTATUS stat = TheStreamMgr->destroyStream(ContentId);
    if (!NT_SUCCESS(stat)){
        _DbgPrintF(DEBUGLVL_VERBOSE,("Bad destroyStream for StreamId= %d", ContentId));
        // not sure if we should flag this as fatal (we sure can't log it to any stream)
        // TheStreamMgr->logErrorToStream(0, Status);
        return stat;		
    };		
    return STATUS_SUCCESS;
}
//---------------------------------------------------------------------------
NTSTATUS DrmGetContentRights(IN DWORD ContentId, OUT DRMRIGHTS* DrmRights){
    KCritical s(TheStreamMgr->getCritMgr());
    NTSTATUS Status=TheStreamMgr->getRights(ContentId, DrmRights);
    if(!NT_SUCCESS(Status)){
        _DbgPrintF(DEBUGLVL_VERBOSE,("getRights failed for StreamId= %x", ContentId));
        return Status;		
    };
    return Status;
};

//---------------------------------------------------------------------------
NTSTATUS DrmAddContentHandlers(IN ULONG ContentId, IN PVOID* paHandlers, IN ULONG NumHandlers)
{
    KCritical s(TheStreamMgr->getCritMgr());
    ULONG i;
    NTSTATUS Status = STATUS_SUCCESS;
    
    if (0 != ContentId) {
        for (i = 0; i < NumHandlers && NT_SUCCESS(Status); i++) {
            if (paHandlers[i]) {
                Status = TheStreamMgr->addProvingFunction(ContentId, paHandlers[i]);
                if(!NT_SUCCESS(Status)){
                    _DbgPrintF(DEBUGLVL_VERBOSE,("addProveFunc Failed for StreamId= %x", ContentId));
                    TheStreamMgr->logErrorToStream(ContentId, Status);
                };
            }
        }
    }
    
    return Status;
}

//---------------------------------------------------------------------------
static NTSTATUS GetFileObjectDispatchTable(IN DWORD ContentId, IN PFILE_OBJECT pF){
    if(pF==NULL){
        _DbgPrintF(DEBUGLVL_VERBOSE,("Invalid FILE_OBJECT on stream %x", ContentId));
        return STATUS_INVALID_PARAMETER;		
    };
    PDEVICE_OBJECT pDevO=pF->DeviceObject;
    if(pDevO==NULL){
        _DbgPrintF(DEBUGLVL_VERBOSE,("Invalid DEVICE_OBJECT for stream %x on PFILE_OBJECT = %x", ContentId, pF));
        return STATUS_INVALID_PARAMETER;		
    };
    NTSTATUS stat=GetDeviceObjectDispatchTable(ContentId, pDevO, TRUE);
    if(!NT_SUCCESS(stat)){
        return stat;
    };
    return stat;
};
//---------------------------------------------------------------------------
static NTSTATUS GetDeviceObjectDispatchTable(IN DWORD ContentId, IN _DEVICE_OBJECT* pDevO, BOOL fCheckAttached){
    _DRIVER_OBJECT* pDriverObject=pDevO->DriverObject;
    if(pDriverObject==NULL){
        _DbgPrintF(DEBUGLVL_VERBOSE,("Invalid PDRIVER_OBJECT for stream %x", ContentId));
        return STATUS_INVALID_PARAMETER;		
    };

    // collect the dispatch table.
    for(DWORD j=0;j<IRP_MJ_MAXIMUM_FUNCTION;j++){
        PDRIVER_DISPATCH pDisp=pDriverObject->MajorFunction[j];			
        if(pDisp==NULL)continue;
        // _DbgPrintF(DEBUGLVL_VERBOSE,("DISPATCH (%3d) devO =%10x, func=%10x", j, pDevO, pDisp));
        	
        DRM_STATUS stat=TheStreamMgr->addProvingFunction(ContentId, pDisp);
        if(stat!=DRM_OK){
            _DbgPrintF(DEBUGLVL_VERBOSE,("bad AddProve on stream %x (error=%x)", ContentId));
            return STATUS_INSUFFICIENT_RESOURCES;
        };
    };
    // collect the other driver entry points 
	
    const DWORD numMiscEntries=4;
    PVOID miscEntry[numMiscEntries];
    miscEntry[0]=pDriverObject->DriverExtension->AddDevice;
    miscEntry[1]=pDriverObject->DriverUnload;
    miscEntry[2]=pDriverObject->DriverStartIo;
    miscEntry[3]=pDriverObject->DriverInit;
    for(j=0;j<numMiscEntries;j++){
        if(NULL!=miscEntry[j]){
            DRM_STATUS stat=TheStreamMgr->addProvingFunction(ContentId, miscEntry[j]);
            if(stat!=DRM_OK){
                _DbgPrintF(DEBUGLVL_VERBOSE,("bad AddProve on stream %x (error=%x)", ContentId));
                return STATUS_INSUFFICIENT_RESOURCES;
            };
        };
    };
	
    // collect the fastIo dispatch points (if they are present)
    FAST_IO_DISPATCH* pFastIo=pDriverObject->FastIoDispatch;
    if(NULL!=pFastIo){
        ULONG numFastIo=(pFastIo->SizeOfFastIoDispatch - sizeof(pFastIo->SizeOfFastIoDispatch)) / sizeof(PVOID);
        if(numFastIo!=0){
            _DbgPrintF(DEBUGLVL_VERBOSE,("FASTIO DISPATCH: Num=", numFastIo));

            // Collect the FastIo entries.  wdm.h makes has some strict requirements on 
            // editing this structure, which means that we can pick up the entries as if
            // they were in a real array.

            PVOID* fastIoTable= (PVOID*)&(pFastIo->FastIoCheckIfPossible);
            for(ULONG j=0;j<numFastIo;j++){
                PVOID fastIoEntry= *(fastIoTable+j);
                if(NULL!=fastIoEntry){
                    DRM_STATUS stat=TheStreamMgr->addProvingFunction(ContentId, fastIoEntry);
                    if(stat!=DRM_OK){
                        _DbgPrintF(DEBUGLVL_VERBOSE,("bad AddProve on stream %x (error=%x)", ContentId));
                        return STATUS_INSUFFICIENT_RESOURCES;
                    };
                };
            };
        };
    };
	
    // now traverse the driver stack (if there is one)
    if (fCheckAttached) {
        _DEVICE_OBJECT* pNextDevice=pDevO->AttachedDevice;
        if(NULL == pNextDevice)return STATUS_SUCCESS;
        NTSTATUS stat=GetDeviceObjectDispatchTable(ContentId, pNextDevice, fCheckAttached);
        if(!NT_SUCCESS(stat)){
            _DbgPrintF(DEBUGLVL_VERBOSE,("Failed to add dispatch entries from attached device on stream=%x ", ContentId));
            return stat;		
        };
    }

    // Verifier and Acpi are special case filter drivers.  Instead of modifying them
    // to handle DRM, we assume that it blindly "forwards" everything to the next
    // lower driver
    if (NT_SUCCESS(IoDeviceIsVerifier(pDevO)) || NT_SUCCESS(IoDeviceIsAcpi(pDevO)))
    {
    	PDEVICE_OBJECT LowerDeviceObject = IoGetLowerDeviceObject(pDevO);
        _DbgPrintF(DEBUGLVL_TERSE,("Detected Verifier or Acpi on DO %p, checked lower DO", pDevO));
    	if (LowerDeviceObject)
    	{
    	    NTSTATUS status = GetDeviceObjectDispatchTable(ContentId, LowerDeviceObject, FALSE);
    	    ObDereferenceObject(LowerDeviceObject);
    	    if (!NT_SUCCESS(status)) return status;
    	}
    	else
    	{
    	   return STATUS_INVALID_DEVICE_REQUEST;
    	}
    }


    return STATUS_SUCCESS;
};
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\drm\krm\drmkmain\iohelp.c ===
/* iohelp.c
 * Copyright (c) 2001 Microsoft Corporation
 */

#include <ntddk.h>
#include <ntimage.h>
#include <ntldr.h>


/*++

IoGetLowerDeviceObject

Routine Description:

    This routine gets the next lower device object on the device stack.

Parameters:

    DeviceObject - Supplies a pointer to the deviceObject whose next device object needs
                    to be obtained.

ReturnValue:

    NULL if driver is unloaded or marked for unload or if there is no attached deviceobject.
    Otherwise a referenced pointer to the deviceobject is returned.

Notes:

--*/
PDEVICE_OBJECT
IoGetLowerDeviceObject(
    IN  PDEVICE_OBJECT  DeviceObject
);

/*++

IoDeviceIsVerifier

Routine Description:

    This routine checks whether the device object is the Verifier.

Parameters:

    DeviceObject - Supplies a pointer to the deviceObject whose to be checked
    
ReturnValue:

    TRUE if the device object is Verifier

Notes:

    This function simply checks whether the driver name is \Driver\Verifier

--*/
NTSTATUS IoDeviceIsVerifier(PDEVICE_OBJECT DeviceObject)
{
    
    UNICODE_STRING DriverName;
    const PCWSTR strDriverName = L"\\Driver\\Verifier";

    RtlInitUnicodeString(&DriverName, strDriverName);
    if (RtlEqualUnicodeString(&DriverName, &DeviceObject->DriverObject->DriverName, TRUE)) return STATUS_SUCCESS;

    return STATUS_NOT_SUPPORTED;
}


/*++

IoDeviceIsAcpi

Routine Description:

    This routine checks whether the device object is the Acpi.

Parameters:

    DeviceObject - Supplies a pointer to the deviceObject whose to be checked
    
ReturnValue:

    TRUE if the device object is Acpi

Notes:

--*/
NTSTATUS IoDeviceIsAcpi(PDEVICE_OBJECT DeviceObject)
{
    UNICODE_STRING Name;
    PKLDR_DATA_TABLE_ENTRY Section;
    const PCWSTR strDriverName = L"\\Driver\\Acpi";
    const PCWSTR strDllName = L"acpi.sys";

    RtlInitUnicodeString(&Name, strDriverName);
    if (RtlEqualUnicodeString(&Name, &DeviceObject->DriverObject->DriverName, TRUE)) return STATUS_SUCCESS;

    RtlInitUnicodeString(&Name, strDllName);
    Section = DeviceObject->DriverObject->DriverSection;
    if (RtlEqualUnicodeString(&Name, &Section->BaseDllName, TRUE)) return STATUS_SUCCESS;

    return STATUS_NOT_SUPPORTED;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\drm\krm\drmkmain\kglobs.cpp ===
#include "drmkPCH.h"
#include "KGlobs.h"
//-----------------------------------------------------------------------------
KCritMgr::KCritMgr(){
    myMutex=(PKMUTEX)ExAllocatePoolWithTag(NonPagedPool, sizeof(KMUTEX), 'kmrD');
    if(myMutex==NULL){
        allocatedOK=false;
        _DbgPrintF(DEBUGLVL_VERBOSE,("Allocation failed in KCritMgr"));
        return;
    } else { 
        allocatedOK=true;
    };
    KeInitializeMutex(myMutex, 0);	
    return;
};
//-----------------------------------------------------------------------------
KCritMgr::~KCritMgr(){
    if(myMutex!=NULL)ExFreePool(myMutex);
    return;
};
//-----------------------------------------------------------------------------
KCritical::KCritical(const KCritMgr& critMgr){
    hisMutex =critMgr.myMutex;
    NTSTATUS stat=KeWaitForMutexObject(hisMutex, Executive, KernelMode, FALSE, NULL);
};
//-----------------------------------------------------------------------------
KCritical::~KCritical(){
    KeReleaseMutex(hisMutex, FALSE);
};
//-----------------------------------------------------------------------------
void * _cdecl operator new(size_t S){
    return ExAllocatePoolWithTag(PagedPool, S, 'kmrD');
};
//-----------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\drm\krm\drmkmain\kglobs.h ===
#ifndef kglobs_h
#define kglobs_h

// KRM global useful classes

//-------------------------------------------------------------------------------------------------
// Encapsulated a mutex.  Best used as a class member
class KCritMgr{
friend class KCritical;
public:
	KCritMgr();
	~KCritMgr();
	bool isOK(){return allocatedOK;};
protected:
	PKMUTEX	myMutex;
	bool allocatedOK;
};
//-------------------------------------------------------------------------------------------------
// Encapsulated the acuisition and release of a mutex in conjunction with KCritMgr.  
// Best used as an automatic
class KCritical{
public:
	KCritical(const KCritMgr& critMgr);
	~KCritical();
protected:
	PKMUTEX hisMutex;
};
//-------------------------------------------------------------------------------------------------
// to 'Release' a COM interface on context destruction (a sort of 'smart pointer'.)  
// Best used as an automatic
template<class T>
class ReferenceAquirer{
public:
	ReferenceAquirer(T& t):myT(t){return;};
	~ReferenceAquirer(){myT->Release();};
protected:
	T& myT;
};


//#undef _DbgPrintF
//#define _DbgPrintF(lvl, strings) DbgPrint(STR_MODULENAME);DbgPrint##strings;DbgPrint("\n");

//-------------------------------------------------------------------------------------------------
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\drm\krm\drmkmain\klist.h ===
#ifndef KList_h
#define KList_h

typedef void* POS;
template <class T>
class KList{
public:
	KList();
	~KList();
	void empty();
	bool addTail(const T& t);
	bool addHead(const T& t);
	T& getTail() const;
	T& getHead() const;
	POS getHeadPosition() const;
	T& getAt(POS& P);
	T& getNext(POS& P);
	void removeHead();
	void removeTail();
	void removeAt(POS& P);
	int getCount() const {return count;};
protected:
	struct Node{
		T Obj;
		Node* last;
		Node* next;
	};
	Node* head;
	Node* tail;
	int count;

};
#include "KList.cpp"

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\drm\krm\drmkmain\krmstubs.h ===
#ifndef KRMStubs_h
#define KRMStubs_h

class KRMStubs{
public:
    KRMStubs();
    ~KRMStubs();
    // Main entry point for DRM IOCTLs
    NTSTATUS processIoctl(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp);
    NTSTATUS processCommandBuffer(IN BYTE* InBuf, IN DWORD InLen, IN DWORD OutBufSize, IN OUT PIRP Irp);

    static DWORD returnKernelMemory(BYTE* StartAddress, DWORD Len, BYTE* OutBuf);
    NTSTATUS initStream(BYTE* encText, struct ConnectStruct* Conn);
    static NTSTATUS InitializeConnection(PIRP Pirp);
    static NTSTATUS CleanupConnection(PIRP Pirp);

    KCritMgr& getCritMgr(){return critMgr;};

protected:
    NTSTATUS preSend(class SBuffer& Msg, struct ConnectStruct* Conn);
    NTSTATUS postReceive(BYTE* Data, DWORD DatLen, struct ConnectStruct* Conn);
    KCritMgr critMgr;
};

NTSTATUS InitializeDriver();
NTSTATUS CleanupDriver();


extern KRMStubs* TheKrmStubs;	

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\drm\krm\drmkmain\krmstubs.cpp ===
#include "drmkPCH.h"

#include "KList.h"
#include "StreamMgr.h"
#include "SBuffer.h"
#include "CryptoHelpers.h"
#include "HandleMgr.h"
#include "KRMStubs.h"
#include "encraption.h"

//------------------------------------------------------------------------------
// 
// These are not the actual keys. The encraption algorithm in encraption.h
// is used to get clear keys.
//
static const BYTE DRMKpriv[20] = {
        0xDC, 0xC4, 0x26, 0xB2, 0x4F, 0x11, 0x24, 0x8A,
        0x51, 0xAC, 0x88, 0xF5, 0x47, 0x4B, 0xD5, 0x8C,
        0x3C, 0x45, 0x29, 0xA1};
static const BYTE DRMKCert[104] = {
        0xD4, 0x3F, 0xC8, 0x44, 0xCD, 0x86, 0x41, 0xE9,
        0x7C, 0x23, 0x36, 0xAD, 0xC3, 0x22, 0x4F, 0x27,
        0xC6, 0x1B, 0x5B, 0x9C, 0x75, 0x2A, 0x86, 0x32,
        0x7E, 0x37, 0x24, 0x8D, 0x2B, 0x51, 0xF6, 0x6A,
        0x31, 0x69, 0xA3, 0x66, 0xA8, 0x30, 0xC9, 0x4A,
        0x23, 0xCC, 0x30, 0xD8, 0x19, 0x19, 0x7B, 0x9A,
        0xF6, 0x32, 0xB5, 0xD8, 0x4C, 0x37, 0x1A, 0x91,
        0x13, 0x71, 0xF6, 0x63, 0x41, 0x1B, 0x1A, 0x06,
        0x57, 0xEC, 0x7A, 0xF8, 0x47, 0x41, 0xEF, 0x5E,
        0xB9, 0x02, 0xE9, 0xE9, 0xA1, 0x52, 0x34, 0xC4,
        0xCD, 0x7F, 0xDE, 0xF6, 0x09, 0x27, 0xE8, 0xB6,
        0x27, 0xF0, 0x93, 0xD8, 0xE2, 0x07, 0xD2, 0xD1,
        0x64, 0x8B, 0xF6, 0xD7, 0x57, 0x2C, 0xB2, 0x37};
//------------------------------------------------------------------------------
const DWORD KrmVersionNumber=100;
//------------------------------------------------------------------------------
KRMStubs* TheKrmStubs=NULL;
//------------------------------------------------------------------------------
DRM_STATUS GetKernelDigest(
    BYTE *startAddress, 
    ULONG len,
    DRMDIGEST *pDigest
)
{
    BYTE* seed = (BYTE*) "a3fs9F7012341234KS84Wd04j=c50asj4*4dlcj5-q8m;ldhgfddd";
    CBCKey key;
    CBCState state;
    CBC64Init(&key, &state, seed);
    CBC64Update(&key, &state, len/16*16, startAddress);
    pDigest->w1=CBC64Finalize(&key, &state, (UINT32*) &pDigest->w2);

    return DRM_OK;
} // GetKernelDigest

//------------------------------------------------------------------------------
KRMStubs::KRMStubs(){
	ASSERT(TheKrmStubs==NULL);
	TheKrmStubs=this;	
	return;
};
//------------------------------------------------------------------------------
KRMStubs::~KRMStubs(){
	return;
};
//------------------------------------------------------------------------------
// Main entry point for KRM IOCTL processing.  KRMINIT1 and KRMINIT2 are 
// plaintext commands, after this, the command block and the reply
// are digested and encrypted.
NTSTATUS KRMStubs::processIoctl(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp){

    PIO_STACK_LOCATION     irpStack = IoGetCurrentIrpStackLocation(Irp);
    DWORD comm;
    DWORD inSize=irpStack->Parameters.DeviceIoControl.InputBufferLength;
    DWORD outSize=irpStack->Parameters.DeviceIoControl.OutputBufferLength;
    DWORD bufSize=inSize>outSize?inSize:outSize;

    if(!critMgr.isOK()){
        _DbgPrintF(DEBUGLVL_VERBOSE,("Out of memory"));
        return STATUS_INSUFFICIENT_RESOURCES;
    };

    _DbgPrintF(DEBUGLVL_VERBOSE,("inSize, outSize %d, %d\n", inSize, outSize));

    for(DWORD j=0;j<inSize;j++){
        _DbgPrintF(DEBUGLVL_VERBOSE,("%x ", (DWORD) *(((BYTE*) Irp->AssociatedIrp.SystemBuffer)+j)));
    };

    return processCommandBuffer((BYTE* ) Irp->AssociatedIrp.SystemBuffer, inSize, outSize, Irp);
};	
//------------------------------------------------------------------------------
NTSTATUS KRMStubs::processCommandBuffer(IN BYTE* InBuf, IN DWORD InLen, IN DWORD OutBufSize, IN OUT PIRP Irp){

    _DbgPrintF(DEBUGLVL_VERBOSE,("Process command buffer (command size= %d)", InLen));

    DWORD bufSize=InLen>OutBufSize?InLen:OutBufSize;

    //
    // We must have at least communication code + terminator input space.
    //
    if (bufSize < 2 * sizeof(DWORD)) {
        _DbgPrintF(DEBUGLVL_TERSE, ("Input buffer too small"));
        return STATUS_BUFFER_TOO_SMALL;
    }

    PIO_STACK_LOCATION     irpStack = IoGetCurrentIrpStackLocation(Irp);
    PFILE_OBJECT file=irpStack->FileObject;
    ConnectStruct* connection=TheHandleMgr->getConnection(file);
    if(connection==NULL) {
        _DbgPrintF(DEBUGLVL_TERSE, ("Connection does not exist %d\n", file));
        return STATUS_BAD_DESCRIPTOR_FORMAT;
    };

    bool secureStreamWillStart=false;

    if(connection->secureStreamStarted) {
        if (STATUS_SUCCESS != postReceive(InBuf, InLen, connection)) {
            _DbgPrintF(DEBUGLVL_TERSE, ("PostReceive error"));
            return STATUS_BAD_DESCRIPTOR_FORMAT;
        }
    }

    SBuffer s(InBuf, bufSize);
    DWORD comm;
    s >> comm;
    if (KRM_OK != s.getLastError()) {
        _DbgPrintF(DEBUGLVL_TERSE, ("Bad communication code"));
        return STATUS_BAD_DESCRIPTOR_FORMAT;
    }

    //
    // if secure communication is not established reject all requests except
    // the initialization calls.
    //
    if (!connection->secureStreamStarted &&
        (_KRMINIT1 != comm && _KRMINIT2 != comm)) {
        _DbgPrintF(DEBUGLVL_TERSE, ("Bad communication pattern"));
        return STATUS_BAD_DESCRIPTOR_FORMAT;
    }

    DRM_STATUS stat;
    switch(comm){
        case _GETKERNELDIGEST:
        {
            //
            // ISSUE: 04/05/2002 ALPERS.
            // Note that this handler is not 64 bit compatible. Just follows
            // the rest of the property handler.
            //
            DWORD startAddress, len;
            DRMDIGEST newDigest = { 0, 0 };                

            s >> startAddress >> len;
            stat = s.getLastError();
            if (KRM_SUCCESS(stat)) {
                stat = checkTerm(s);
            }

            //
            // Make sure the output buffer can hold len bytes.
            //
            if (KRM_SUCCESS(stat)) {
                if (s.getLen() < sizeof(stat) + sizeof(newDigest) + sizeof(DWORD) + 64) {
                    stat = KRM_BUFSIZE;
                    _DbgPrintF(DEBUGLVL_TERSE, ("_GETKERNELDIGEST - invalid output buffer size"));                
                }
            }

            if (KRM_SUCCESS(stat)) {
                //
                // ISSUE: 04/05/2002 ALPERS
                // (SECURITY NOTE: Potential DOS attack)
                // Note that startAddress and Len are coming from user mode 
                // and there is no validation.
                // This IOCTL can only be send through the secure IOCTL 
                // interface. In order to attack here, the attacker has to
                // figure out the secure IOCTL channel.
                // There is one level of defense.
                //
                // TODO: As a second line of defense, DRMK can collect the 
                // same module information and compare the given address
                // to its list.
                //
                // The reason we get the KernelAddress from UserMode is 
                // because of the relocation code in UserMode. The code reads
                // the driver image from disk, parses PE format and finds 
                // the section that contains the provingFunction.
                // startAddress is the beginning of the section that 
                // contains provingFunction.
                //
                stat = GetKernelDigest((BYTE *) ULongToPtr(startAddress), len, &newDigest);
            }

            s.reset();
            s << stat << newDigest.w1 << newDigest.w2;

            break;
        }
        //-----------------
        case _KRMINIT1:
        {
            // return the version number and the cert
            DWORD drmVersionNumber;
            CERT krmCert;

            s >> drmVersionNumber;
            stat = s.getLastError();
            if (KRM_SUCCESS(stat)) {
                stat = checkTerm(s);
            }
            
            if (KRM_SUCCESS(stat)) {
                _DbgPrintF(DEBUGLVL_VERBOSE,("Doing KRMINIT1, for DRM version %d", drmVersionNumber));

                NTSTATUS Status = 
                    ClearKey(DRMKCert, (BYTE *) &krmCert, sizeof(DRMKCert), 5);
                if (NT_SUCCESS(Status)) {
                    s.reset();
                    s << (DWORD) KRM_OK << KrmVersionNumber;
                    s.append((BYTE*) &krmCert, sizeof(krmCert));
                    stat = s.getLastError();
                }
                else {
                    stat = KRM_SYSERR;
                }
            }
        
            if (!KRM_SUCCESS(stat)) {
                s.reset();
                s << stat;
            }
            
            break;
        };
        //-----------------
        case _KRMINIT2:
        {
            DWORD datLen;
            s >> datLen;
            stat = s.getLastError();
            if (KRM_SUCCESS(stat)) {
                DWORD bufLenShouldBe=PK_ENC_CIPHERTEXT_LEN;
                if (bufLenShouldBe == datLen) {
                    unsigned int pos;
                    stat = s.getGetPosAndAdvance(&pos, datLen);
                    if (KRM_SUCCESS(stat)) {
                        BYTE* cipherText=s.getBuf()+pos;
                        stat=initStream(cipherText, connection);
                        if (stat != DRM_OK) {
                            _DbgPrintF(DEBUGLVL_TERSE, ("BAD InitString"));
                        };
                    }
                } 
                else {
                    _DbgPrintF(DEBUGLVL_TERSE, ("KRMINIT2 - bad string"));
                    stat = KRM_SYSERR;
                };
            }
            
            if (KRM_SUCCESS(stat)) {
                stat = checkTerm(s);
            }

            s.reset();
            s << stat;

            if (KRM_SUCCESS(stat)) {
                secureStreamWillStart=true;
            }

            break;
        };
        //-----------------
        case _CREATESTREAM:
        {
            KCritical sect(critMgr);
            DWORD handle;
            DRMRIGHTS rights; 
            STREAMKEY key;
            DWORD streamId = 0;
            
            s >> handle >> &rights >> &key;
            stat = s.getLastError();
            if (KRM_SUCCESS(stat)) {
                stat = checkTerm(s);
            }

            //
            // The input buffer is much bigger than output buffer.
            // Therefore we are sure that SBuffer has enough space
            // for the output buffer.
            //
            
            if (KRM_SUCCESS(stat)) {
                stat = TheStreamMgr->createStream(ULongToPtr(handle), &streamId, &rights, &key);
            }

            if (KRM_SUCCESS(stat)) {
                connection->streamId = streamId;
            }

            s.reset();
            s << stat << streamId;
            
            break;
        };
        //-----------------
        case _DESTROYSTREAM:
        {
            KCritical sect(critMgr);
            DWORD streamId;
            s >> streamId; 
            stat = s.getLastError();
            if (KRM_SUCCESS(stat)) {
                stat = checkTerm(s);
            }
            
            if (KRM_SUCCESS(stat)) {
                stat = TheStreamMgr->destroyStream(streamId);
            }
            
            s.reset();
            s << stat;
            break;
        };
        //-----------------
        case _DESTROYSTREAMSBYHANDLE:
        {
            KCritical sect(critMgr);
            DWORD handle;
            s >> handle;
            stat = s.getLastError();
            if (KRM_SUCCESS(stat)) {
                stat = checkTerm(s);
            }

            if (KRM_SUCCESS(stat)) {
                stat = TheStreamMgr->destroyAllStreamsByHandle(ULongToHandle(handle));
            }

            s.reset();
            s << stat;
            break;
        };
        //-----------------
        case _WALKDRIVERS:
        {
            KCritical sect(critMgr);
            DWORD StreamId, MaxDrivers, len;
            s >> StreamId >> MaxDrivers;
            stat = s.getLastError();
            if (KRM_SUCCESS(stat)) {
                stat = checkTerm(s);
            }

            // check buffer size.
            if (KRM_SUCCESS(stat)) {
                len = sizeof(DWORD) * MaxDrivers;
                if ((s.getLen() < len + 64) || (len > len + 64)) {
                    stat = KRM_BUFSIZE;
                    _DbgPrintF(DEBUGLVL_TERSE,("_WALKDRIVERS : Invalid buffer size"));
                }
            }

            s.reset();
            //
            // Due to difficulties in maintaining security in the presence of Verifier
            // we return an error if Verifier is detected.
            //
            if (KRM_SUCCESS(stat)) {
                ULONG VerifierFlags;
                if (NT_SUCCESS(MmIsVerifierEnabled(&VerifierFlags))) {
                    stat = DRM_VERIFIERENABLED;
                }
            }

            if (KRM_SUCCESS(stat)) {
                if (MaxDrivers==0) {
                    // just check that the stream is good
                    DWORD errorCode;

                    stat = TheStreamMgr->getStreamErrorCode(StreamId, errorCode);
                    if (KRM_SUCCESS(stat)) {
                        stat = errorCode;
                    }
                    
                    if (KRM_SUCCESS(stat)) {
                        ULONG numDrivers;
                        stat = TheStreamMgr->walkDrivers(StreamId, NULL, numDrivers, 0);
                        if (KRM_SUCCESS(stat)) {
                            stat=TheStreamMgr->getStreamErrorCode(StreamId, errorCode);
                            if (KRM_SUCCESS(stat)) {
                                stat = errorCode;
                            }
                        }
                    }

                    s << stat << (DWORD) 0;
                }
                else {
                    // do a full authentication run
                    PVOID* drivers = new PVOID[MaxDrivers];
                    if (drivers!=NULL) {
                        DWORD numDrivers = 0;
                        stat = TheStreamMgr->walkDrivers(StreamId, drivers, numDrivers, MaxDrivers);

                        s << stat << numDrivers;

                        //
                        // We checked the buffer size upfront. This should not
                        // fail during stream operations.
                        //
                        if ((stat==DRM_OK) || 
                            (stat==DRM_BADDRMLEVEL)) {
                            // todo - perhaps a block copy
                            for (DWORD j = 0; j < numDrivers; j++) {
                                s << drivers[j];
                                ASSERT(KRM_SUCCESS(s.getLastError()));
                            };
                        } 

                        delete[] drivers;
                    } 
                    else {
                        // allocation failed
                        s << (DWORD) DRM_OUTOFMEMORY << (DWORD) 0;
                    };
                };
            }
            else {
                s << stat << (DWORD) 0;
            }
            break;
        }
        //-----------------
        default:
        {
            s.reset();
            s << KRM_BADIOCTL;
            break;
        };
    };

    term(s);
    //
    // We are ignoring if we cannot put the terminator here.
    // KRMProxy does not care anyway.
    //

    if (connection->secureStreamStarted) {
        //
        // ignore the return value. In case of failure we will have crap
        // in SBuffer. And we will return it to user mode.
        // 
        preSend(s, connection); 
    }
    if (secureStreamWillStart) {
        connection->secureStreamStarted = true;
    }

    _DbgPrintF(DEBUGLVL_VERBOSE,("Returning %d bytes", s.getPutPos()));
    Irp->IoStatus.Information=s.getPutPos();

    return STATUS_SUCCESS;
};
//------------------------------------------------------------------------------
NTSTATUS KRMStubs::initStream(BYTE* encText, ConnectStruct* Conn){
    PRIVKEY myPrivKey;
    NTSTATUS Status;

    Status = ClearKey(DRMKpriv, myPrivKey.x, sizeof(DRMKpriv), 2);
    if (NT_SUCCESS(Status)) {
        //
        // ISSUE: 04/24/2002 ALPERS
        // CDRMPKCrypto allocates memory in its constructor. If the memory
        // allocation fails, all functions in that object return error codes.
        // Yet we are not checking the error code from PKdecrypt.
        //
        CDRMPKCrypto decryptor;
        BYTE decryptedText[PK_ENC_PLAINTEXT_LEN];
        decryptor.PKdecrypt(&myPrivKey, encText, decryptedText);
        bv4_key_C(&Conn->serverKey, sizeof(decryptedText),decryptedText );
        CryptoHelpers::InitMac(Conn->serverCBCKey, Conn->serverCBCState, decryptedText, sizeof(decryptedText));
    }

    return Status;
};

//------------------------------------------------------------------------------
NTSTATUS InitializeDriver(){
    NTSTATUS DriverInitializeStatus;

    _DbgPrintF(DEBUGLVL_VERBOSE,("Initializing Driver"));
    
    // Note - these dynamic allocations are 'global objects' that offer services to 
    // the DRMK driver.
    // The services are referenced through the global pointers:
    //  TheStreamManager, TheTGBuilder, TheKrmStubs, and TheHandleMgr 
    void* temp=NULL;
#pragma prefast(suppress:14, "There is really no leak here. The cleanup is CleanupDriver")    
    temp=new StreamMgr;
    if (temp)
    {
        temp = new KRMStubs;
    }
    if (temp) 
    {
        temp = new HandleMgr;
    }

    //
    // Make sure the internal states of the objects are OK.
    //  
    if (temp)
    {
        if (!TheStreamMgr->getCritMgr().isOK() ||
            !TheKrmStubs->getCritMgr().isOK() ||
            !TheHandleMgr->getCritMgr().isOK())
        {
            _DbgPrintF(DEBUGLVL_TERSE, ("CritMgr allocation failed in DRMK:InitializeDriver"));
            temp = NULL;
        }
    }
    
    if (temp) 
    {
        DriverInitializeStatus = STATUS_SUCCESS;
    } 
    else 
    {
        _DbgPrintF(DEBUGLVL_TERSE,("operator::new failed in DRMK:InitializeDriver"));
        DriverInitializeStatus = STATUS_INSUFFICIENT_RESOURCES;
        CleanupDriver();
    }
    
    return DriverInitializeStatus;
};
//------------------------------------------------------------------------------
NTSTATUS CleanupDriver(){
    _DbgPrintF(DEBUGLVL_VERBOSE,("Cleaning up Driver"));
    delete TheStreamMgr;TheStreamMgr=NULL;
    delete TheKrmStubs;TheKrmStubs=NULL;
    delete TheHandleMgr;TheHandleMgr=NULL;
    return STATUS_SUCCESS;
};

//------------------------------------------------------------------------------
NTSTATUS KRMStubs::InitializeConnection(PIRP Pirp){
    PIO_STACK_LOCATION     irpStack = IoGetCurrentIrpStackLocation(Pirp);
    PFILE_OBJECT file=irpStack->FileObject;
    _DbgPrintF(DEBUGLVL_VERBOSE,("InititializeConnection %d", file));
    ConnectStruct* conn;
    bool ok=TheHandleMgr->newHandle(file, conn);
    if(!ok){
        _DbgPrintF(DEBUGLVL_VERBOSE,("Out of memory"));
        return STATUS_INSUFFICIENT_RESOURCES;
    };
    return STATUS_SUCCESS;
};
//------------------------------------------------------------------------------
NTSTATUS KRMStubs::CleanupConnection(PIRP Pirp){
    PIO_STACK_LOCATION     irpStack = IoGetCurrentIrpStackLocation(Pirp);
    PFILE_OBJECT file=irpStack->FileObject;
    _DbgPrintF(DEBUGLVL_VERBOSE,("CleanupConnection %x", file));
    ConnectStruct* conn=TheHandleMgr->getConnection(file);
    if(conn==NULL){
        _DbgPrintF(DEBUGLVL_VERBOSE,("Connection does not exist "));
        return STATUS_INVALID_PARAMETER_1;
    };
    TheStreamMgr->destroyStream(conn->streamId);
    TheHandleMgr->deleteHandle(file);
    return STATUS_SUCCESS;
};
//------------------------------------------------------------------------------
// see twin function in KComm
NTSTATUS KRMStubs::preSend(class SBuffer& Msg, ConnectStruct* Conn){
    // first digest
    DRMDIGEST digest;
    DRM_STATUS stat=CryptoHelpers::Mac(Conn->serverCBCKey, Msg.getBuf(), Msg.getPutPos(), digest);
    if(stat!=DRM_OK){
        _DbgPrintF(DEBUGLVL_VERBOSE,("Bad MAC"));
        return STATUS_DRIVER_INTERNAL_ERROR;
    };
    Msg << &digest;
    stat = Msg.getLastError();
    if (KRM_OK == stat) {
        // then encrypt msg + digest
        stat=CryptoHelpers::Xcrypt(Conn->serverKey, Msg.getBuf(), Msg.getPutPos());
        if(stat!=DRM_OK){
            _DbgPrintF(DEBUGLVL_VERBOSE,("Bad XCrypt"));
            return STATUS_DRIVER_INTERNAL_ERROR;
        };
    }
    return STATUS_SUCCESS;
};
//------------------------------------------------------------------------------
// see twin function in KComm
NTSTATUS KRMStubs::postReceive(BYTE* Data, DWORD DatLen,  ConnectStruct* Conn){
    _DbgPrintF(DEBUGLVL_VERBOSE,("PostReceive on %d", DatLen));
    // decrypt
    DRM_STATUS stat=CryptoHelpers::Xcrypt(Conn->serverKey, Data, DatLen);
    if(stat!=DRM_OK){
        _DbgPrintF(DEBUGLVL_VERBOSE,("Bad XCrypt(2)"));
        return STATUS_DRIVER_INTERNAL_ERROR;
    };
    // check digest
    DRMDIGEST digest;
    if (DatLen <= sizeof(DRMDIGEST)) return STATUS_INVALID_PARAMETER;
        stat=CryptoHelpers::Mac(Conn->serverCBCKey, Data, DatLen-sizeof(DRMDIGEST), digest);
    if(stat!=DRM_OK){
        _DbgPrintF(DEBUGLVL_VERBOSE,("Bad MAC(2)"));
        return STATUS_DRIVER_INTERNAL_ERROR;
    };
    DRMDIGEST* msgDigest=(DRMDIGEST*) (Data+DatLen-sizeof(DRMDIGEST));
    int match=memcmp(&digest, msgDigest, sizeof(DRMDIGEST));
    if(match==0)return STATUS_SUCCESS;
    memset(Data, 0, DatLen);
    _DbgPrintF(DEBUGLVL_VERBOSE,("MAC does not match(2)"));
    return STATUS_DRIVER_INTERNAL_ERROR;
};
//------------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\drm\krm\drmkmain\streammgr.cpp ===
#include "drmkPCH.h"
#include "KList.h"
#include "VRoot.h"
#include "StreamMgr.h"
//------------------------------------------------------------------------------
StreamMgr* TheStreamMgr=NULL;
// 'secondary root - lowest secondary stream ID
#define SEC_ROOT 0x80000000
//------------------------------------------------------------------------------
StreamMgr::StreamMgr(){
	TheStreamMgr=this;
	nextStreamId=1;
	nextCompositeId=SEC_ROOT+1;
	criticalErrorCode=STATUS_SUCCESS;
	if(!critMgr.isOK()){
		_DbgPrintF(DEBUGLVL_VERBOSE,("Out of memory"));
		criticalErrorCode=STATUS_INSUFFICIENT_RESOURCES;
	};
	return;
};
//------------------------------------------------------------------------------
StreamMgr::~StreamMgr(){
    {
        KCritical s(critMgr);
        POS p=primary.getHeadPosition();
        while(p!=NULL){
            StreamInfo* info=primary.getNext(p);
            delete info;
        };
        p=composite.getHeadPosition();
        while(p!=NULL){
            CompositeStreamInfo* info=composite.getNext(p);
            delete info;
        };
    };
    return;
};
//------------------------------------------------------------------------------
DRM_STATUS StreamMgr::createStream(HANDLE Handle, DWORD* StreamId, 
                                   const DRMRIGHTS* RightsStruct, IN STREAMKEY* Key){
	
	*StreamId = 0xFFFFffff;
	StreamInfo* newInfo=new StreamInfo;
	if(newInfo==NULL){
		_DbgPrintF(DEBUGLVL_BLAB,("Out of memory"));
		return DRM_OUTOFMEMORY;		
	};

	newInfo->StreamId=nextStreamId++;
	newInfo->Handle=Handle;
	newInfo->Key= *Key;
	newInfo->Rights= *RightsStruct;
	newInfo->drmFormat=NULL;
	newInfo->streamStatus=DRM_OK;
	newInfo->streamWalked=false;
	newInfo->newProveFuncs=false;
	
	newInfo->OutType=IsUndefined;
	newInfo->OutInt=NULL;
	newInfo->OutPinFileObject=NULL;
	newInfo->OutPinDeviceObject=NULL;
	bool ok=addStream(*newInfo);
	if(!ok){
		_DbgPrintF(DEBUGLVL_BLAB,("Out of memory"));
		delete newInfo;
		return DRM_OUTOFMEMORY;		
	};
	*StreamId= newInfo->StreamId;
	return KRM_OK;
};
//------------------------------------------------------------------------------
DRM_STATUS StreamMgr::destroyStream(DWORD StreamId){
    KCritical s(critMgr);
    if(StreamId==0){
        return KRM_OK;
    };
    POS pos=getStreamPos(StreamId);
    if(pos==NULL)return KRM_BADSTREAM;
    bool primary=StreamId<SEC_ROOT;
    deleteStreamAt(primary, pos);
    return KRM_OK;
};
//------------------------------------------------------------------------------
// The 'handle' allows streams to be collected into a group and deleted together.
// It is mostly for debugging
DRM_STATUS StreamMgr::destroyAllStreamsByHandle(HANDLE Handle){
    KCritical s(critMgr);
    POS p=primary.getHeadPosition();
    while(p!=NULL){
            POS oldP=p;
            StreamInfo* stream=primary.getNext(p);
            if(stream->Handle==Handle){
                    delete stream;
                    primary.removeAt(oldP);
            };
    };
    return KRM_OK;
};
//------------------------------------------------------------------------------
// Called by a filter to instuct StreamMgr that a mixed stream is being created.
DRM_STATUS StreamMgr::createCompositeStream(OUT DWORD* StreamId, IN DWORD* StreamInArray, DWORD NumStreams){
	KCritical s(critMgr);
	CompositeStreamInfo* newStream=new CompositeStreamInfo;;
	if(newStream==NULL){
		_DbgPrintF(DEBUGLVL_BLAB,("Out of memory"));
		return DRM_OUTOFMEMORY;		
	};
	for(DWORD j=0;j<NumStreams;j++){
		if(StreamInArray[j]==0)continue;
		bool ok=newStream->parents.addTail(StreamInArray[j]);
		if(!ok){
			delete newStream;
			_DbgPrintF(DEBUGLVL_BLAB,("Out of memory"));
			return DRM_OUTOFMEMORY;		
		};
	};
	newStream->StreamId=nextCompositeId++;
	bool ok=composite.addTail(newStream);
	if(!ok){
		delete newStream;
		_DbgPrintF(DEBUGLVL_BLAB,("Out of memory"));
		return DRM_OUTOFMEMORY;		
	};
	*StreamId=newStream->StreamId;
	return DRM_OK;
};
//------------------------------------------------------------------------------
DRM_STATUS StreamMgr::destroyCompositeStream(IN DWORD CompositeStreamId){
	bool primary=(CompositeStreamId<SEC_ROOT);
	ASSERT(!primary);
	if(primary)return KRM_BADSTREAM;
	return destroyStream(CompositeStreamId);
};
//------------------------------------------------------------------------------
// get the data encryption key for a stream.
DRM_STATUS StreamMgr::getKey(IN DWORD StreamId, OUT STREAMKEY*& Key){
	KCritical s(critMgr);
	Key=NULL;
	if(StreamId>=SEC_ROOT)return KRM_NOTPRIMARY;
	POS pos=getStreamPos(StreamId);
	if(pos==NULL)return KRM_BADSTREAM;
	Key=&(primary.getAt(pos)->Key);
	return KRM_OK;
};
//------------------------------------------------------------------------------
bool StreamMgr::addStream(StreamInfo& NewInfo){
	KCritical s(critMgr);
	return primary.addTail(&NewInfo);
};
//------------------------------------------------------------------------------
POS StreamMgr::getStreamPos(DWORD StreamId){
	KCritical s(critMgr);
	if(StreamId<SEC_ROOT){
		POS p=primary.getHeadPosition();
		while(p!=NULL){
			POS oldPos=p;
			if(primary.getNext(p)->StreamId==StreamId)return oldPos;
		};
		return NULL;
	} else {
		POS p=composite.getHeadPosition();
		while(p!=NULL){
			POS oldPos=p;
			if(composite.getNext(p)->StreamId==StreamId)return oldPos;
		};
		return NULL;
	};
};
//------------------------------------------------------------------------------
void StreamMgr::deleteStreamAt(bool Primary,POS pos){
	KCritical s(critMgr);
	if(Primary){
		StreamInfo* it=primary.getAt(pos);
		primary.removeAt(pos);
		delete it;
	} else {
		CompositeStreamInfo* it=composite.getAt(pos);
		composite.removeAt(pos);
		delete it;
	};
};
//------------------------------------------------------------------------------
DRM_STATUS StreamMgr::getRights(DWORD StreamId,DRMRIGHTS* Rights){
	KCritical s(critMgr);
    DEFINE_DRMRIGHTS_DEFAULT(DrmRightsDefault);
    *Rights = DrmRightsDefault;
	return getRightsWorker(StreamId, Rights);
};
//------------------------------------------------------------------------------
bool StreamMgr::isPrimaryStream(DWORD StreamId){
	return StreamId<SEC_ROOT;
};
//------------------------------------------------------------------------------
// called recursively from the getRights parent
DRM_STATUS StreamMgr::getRightsWorker(DWORD StreamId, DRMRIGHTS* Rights){
	if(isPrimaryStream(StreamId)){
		if(StreamId==0){
			// stream is unprotected - no further restrictions
			return DRM_OK;
		};
		// else a protected primary stream
		POS p=getStreamPos(StreamId);
		if(p==NULL){
			// if the primary stream has gone, then it does not care about
			// the stream rights.   We do not flag an error
			_DbgPrintF(DEBUGLVL_BLAB,("Bad primary stream (getRightsWorker) %x", StreamId));
			return KRM_OK;
		};
		StreamInfo* s=primary.getAt(p);
		// set rights to most restrictive of current stream and current settings
		if(s->Rights.CopyProtect)Rights->CopyProtect=TRUE;
		if(s->Rights.DigitalOutputDisable)Rights->DigitalOutputDisable=TRUE;
		return DRM_OK;
	} else {
		// For composite streams, any of the parent streams can reduce the 
		// current settings.  We descend to the primary parents thru recursion.
		// Note, for this to work, we must have 'monotonic rights' - there should
		// be no case where two components disagree on 'more restrictive'
		POS pos=getStreamPos(StreamId);
		if(pos==NULL){
			_DbgPrintF(DEBUGLVL_BLAB,("Bad secondary stream"));
			Rights->CopyProtect=TRUE;
			Rights->DigitalOutputDisable=TRUE;
			return KRM_BADSTREAM;
		};
		CompositeStreamInfo* thisComp=composite.getAt(pos);
		
		POS p=thisComp->parents.getHeadPosition();
		while(p!=NULL){
			DWORD streamId=thisComp->parents.getNext(p);
			if(streamId==0)continue;	// unprotected - no change to rights
			// else allow the parent stream (and its parents) to 
			// further restrict rights
			DRM_STATUS stat=getRightsWorker(streamId, Rights);
			if(stat!=DRM_OK)return stat;
		};
	};
	return DRM_OK;
};
//------------------------------------------------------------------------------
// Proving function is only of interest to parent stream.  We recurse up the
// stream parentage to all parents and add the proving fucntion to their lists.
DRM_STATUS StreamMgr::addProvingFunction(DWORD StreamId,PVOID Func){
	KCritical s(critMgr);
	
	if(isPrimaryStream(StreamId)){
		StreamInfo* si=getPrimaryStream(StreamId);
		if(si==NULL){
			_DbgPrintF(DEBUGLVL_VERBOSE,("Bad primary stream (addProveFunc) %x", StreamId));
			return DRM_BADPARAM;
		};
		// check to see if we already have this provinFunc
		POS p=si->proveFuncs.getHeadPosition();
		while(p!=NULL){
			PVOID addr=si->proveFuncs.getNext(p);	
			if(addr==Func)return DRM_OK;
		};
		// if not, add it...
		bool ok=si->proveFuncs.addTail(Func);
		if(!ok){
			_DbgPrintF(DEBUGLVL_VERBOSE,("Out of memory"));
			return DRM_OUTOFMEMORY;		
		};
		si->newProveFuncs = TRUE;
		return DRM_OK;
	}; 
	// else is secondary...recurse to root.
	CompositeStreamInfo* comp=getCompositeStream(StreamId);
	if(comp==NULL){
		_DbgPrintF(DEBUGLVL_VERBOSE,("Bad streamId %x", StreamId));
		return DRM_BADPARAM;
	};
	POS p=comp->parents.getHeadPosition();
	while(p!=NULL){
		DWORD parentId=comp->parents.getNext(p);
		addProvingFunction(parentId, Func);
	};
	return DRM_OK;
};
//------------------------------------------------------------------------------
StreamMgr::StreamInfo* StreamMgr::getPrimaryStream(DWORD StreamId){
	KCritical s(critMgr);
	POS pos=getStreamPos(StreamId);
	if(pos==NULL)return NULL;
	return primary.getAt(pos);
};
//------------------------------------------------------------------------------
StreamMgr::CompositeStreamInfo* StreamMgr::getCompositeStream(DWORD StreamId){
	KCritical s(critMgr);
	POS pos=getStreamPos(StreamId);
	if(pos==NULL)return NULL;
	return composite.getAt(pos);
};
//------------------------------------------------------------------------------
DRM_STATUS StreamMgr::walkDrivers(DWORD StreamId, PVOID* ProveFuncList, DWORD& NumDrivers, DWORD MaxDrivers)
{
    DRM_STATUS stat;
    VRoot root;
    PFILE_OBJECT OutPinFileObject;
    PDEVICE_OBJECT OutPinDeviceObject;
    PUNKNOWN OutInt;

    OutPinFileObject = NULL;
    OutPinDeviceObject = NULL;
    OutInt = NULL;

    {
    	KCritical s(critMgr);
        StreamInfo* stream;

    	stream=getPrimaryStream(StreamId);
    	if(stream==NULL)return KRM_BADSTREAM;
    	if (0 != MaxDrivers) stream->proveFuncs.empty();
    	stream->newProveFuncs=false;
    	stream->streamStatus=DRM_OK;
    	if(stream->OutType==IsUndefined){
            NumDrivers=0;
            // no output stream.
            _DbgPrintF(DEBUGLVL_VERBOSE,("No registered output module for stream %x", StreamId));
            return KRM_BADSTREAM;
    	};

        //
        // We must reference the downstream object or interface before
        // releasing the StreamMgr mutex (i.e., before KCritical s goes out of
        // scope).  Otherwise the downstream object/interface might be
        // destroyed after we release the StreamMgr mutex but before we
        // initiate validation on the downstream object/interface.
        //

        if ((stream->OutType == IsHandle) && stream->OutPinFileObject && stream->OutPinDeviceObject)
        {
            OutPinFileObject = stream->OutPinFileObject;
            OutPinDeviceObject = stream->OutPinDeviceObject;
        }
        else if ((stream->OutType == IsInterface) && stream->OutInt)
        {
            OutInt = stream->OutInt;
        }

        if (OutPinFileObject) ObReferenceObject(OutPinFileObject);
        if (OutInt) OutInt->AddRef();
    }

    if (OutPinFileObject) stat = root.initiateValidation(OutPinFileObject, OutPinDeviceObject, StreamId);
    if (OutInt) stat = root.initiateValidation(OutInt, StreamId);

    if (OutPinFileObject) ObDereferenceObject(OutPinFileObject);
    if (OutInt) OutInt->Release();

    {
        KCritical s(critMgr);
        StreamInfo* stream;
        
        // If STATUS_NOT_IMPLEMENTED, see if stream had DRM_RIGHTSNOTSUPPORTED logged as an error
        if (STATUS_NOT_IMPLEMENTED == stat) {
            DWORD errorStream;
            if (DRM_OK == TheStreamMgr->getStreamErrorCode(StreamId, errorStream)) {
                if (DRM_RIGHTSNOTSUPPORTED == errorStream) {
                    stat = errorStream;
                }
            }
        }


        //Check to see if the stream had DRM_BADDRMLEVEL set.  This return
        //code indicates that one or more drivers called
        //DrmForwardContentToFileObject, but otherwise no fatal errors
        //occurred.  This should be treated as a success with the return
        //code propagated to the caller.
        {
            DWORD errorStream;
            if (DRM_OK == TheStreamMgr->getStreamErrorCode(StreamId, errorStream)) {
                if (DRM_BADDRMLEVEL == errorStream) {
                    stat = errorStream;
                }
            }
        }

               
        // Although it would probably be due to a user-mode bug, we should not
        // assume that stream is still valid.  Let's get the stream once again
        // from the StreamId
        stream=getPrimaryStream(StreamId);
        if(stream==NULL)return KRM_BADSTREAM;

        // pass out the array of ProveFuncs	(there might've been an error, but we pass out what we can)
        POS p=stream->proveFuncs.getHeadPosition();
        DWORD count=0;
        while(p!=NULL){
            PVOID pf=stream->proveFuncs.getNext(p);
            if(count<MaxDrivers){
            	ProveFuncList[count]=pf;
            };
            count++;
        };
        NumDrivers=count;
        // if there was an error on the walk, return that too.
        if((stat!=DRM_OK) && (DRM_BADDRMLEVEL!=stat)){
        	// bug - todo - return some useful information
        	_DbgPrintF(DEBUGLVL_VERBOSE,("VRoot::initiateValidation(streeamId=%d)  returned  (%d, %x)", StreamId, stat, stat));
        	NumDrivers=0;
        	return stat;
        };

        // if checking stack and new funcs were added
        if ((0 == MaxDrivers) && (stream->newProveFuncs))
        	return DRM_AUTHREQUIRED;

        // and finally, inform if there was insufficient buffer space.

        if((0 == MaxDrivers) || (count<MaxDrivers))
        	return (DRM_OK == stat) ? KRM_OK : stat;
        else 
        	return KRM_BUFSIZE;
    }
};
//------------------------------------------------------------------------------
DRM_STATUS StreamMgr::setRecipient(DWORD StreamId, PFILE_OBJECT OutPinFileObject, PDEVICE_OBJECT OutPinDeviceObject){
	KCritical s(critMgr);
	StreamInfo* stream=getPrimaryStream(StreamId);
	if(stream==NULL)return KRM_BADSTREAM;
	stream->OutPinFileObject=OutPinFileObject;
	stream->OutPinDeviceObject=OutPinDeviceObject;
	stream->OutType=IsHandle;
	return DRM_OK;
};
//------------------------------------------------------------------------------
DRM_STATUS StreamMgr::setRecipient(DWORD StreamId, PUNKNOWN OutInt){
	KCritical s(critMgr);
	StreamInfo* stream=getPrimaryStream(StreamId);
	if(stream==NULL)return KRM_BADSTREAM;
	stream->OutInt=OutInt;
	stream->OutType=IsInterface;
	return DRM_OK;
};
//------------------------------------------------------------------------------
DRM_STATUS StreamMgr::clearRecipient(IN DWORD StreamId){
	KCritical s(critMgr);
	StreamInfo* stream=getPrimaryStream(StreamId);
	if(stream==NULL)return KRM_BADSTREAM;
	stream->OutType=IsUndefined;
    stream->OutPinFileObject = NULL;
    stream->OutPinDeviceObject = NULL;
    stream->OutInt = NULL;
	return DRM_OK;
};
//------------------------------------------------------------------------------
void StreamMgr::logErrorToStream(IN DWORD StreamId, DWORD ErrorCode){
	KCritical s(critMgr);
	logErrorToStreamWorker(StreamId, ErrorCode);
	return;
};
//------------------------------------------------------------------------------
void StreamMgr::logErrorToStreamWorker(IN DWORD StreamId, DWORD ErrorCode){
	// don't allow an error to be cancelled too easily
	if(ErrorCode==0)return;
	if(isPrimaryStream(StreamId)){
		StreamInfo* info=getPrimaryStream(StreamId);
		if(info==NULL){
			_DbgPrintF(DEBUGLVL_BLAB,("Bad primary stream (logErrorToStreamWorker) %x", StreamId));
			// if a primary stream does not exist, this is not considered
			// to be sufficient to set the panic flag.
			return;
		};
		info->streamStatus=ErrorCode;
		return;
	};
	CompositeStreamInfo* comp=getCompositeStream(StreamId);
	ASSERT(comp!=NULL);
	if(comp==NULL){
		_DbgPrintF(DEBUGLVL_VERBOSE,("Bad streamId %x", StreamId));
		// if the secondary stream does not exist, we do not know what streams
		// are affected by the error, so the only safe thing is to panic.
		setFatalError(KRM_BADSTREAM);
		return;
	};
	// log the error with all of the streams parents, recursing back to the
	// primary streams.
	POS p=comp->parents.getHeadPosition();
	while(p!=NULL){
		DWORD parentId=comp->parents.getNext(p);
		logErrorToStreamWorker(parentId, ErrorCode);
	};
	return;
};
//------------------------------------------------------------------------------
DRM_STATUS StreamMgr::getStreamErrorCode(IN DWORD StreamId, OUT DWORD& ErrorCode){
	KCritical s(critMgr);
	StreamInfo* info=getPrimaryStream(StreamId);
	ErrorCode=DRM_AUTHFAILURE;
	if(info==NULL){
		_DbgPrintF(DEBUGLVL_BLAB,("Bad primary stream(getStreamErrorCode) %x", StreamId));
		return KRM_BADSTREAM;
	};
	ErrorCode=info->streamStatus;
	return DRM_OK;
};
//------------------------------------------------------------------------------
DRM_STATUS StreamMgr::clearStreamError(IN DWORD StreamId){
	KCritical s(critMgr);
	StreamInfo* info=getPrimaryStream(StreamId);
	if(info==NULL){
		_DbgPrintF(DEBUGLVL_BLAB,("Bad primary stream (clearStreamError) %x", StreamId));
		return KRM_BADSTREAM;
	};
	info->streamStatus=DRM_OK;
	return DRM_OK;
};
//------------------------------------------------------------------------------
void StreamMgr::setFatalError(DWORD ErrorCode){
	if(criticalErrorCode!=STATUS_SUCCESS) return;
	criticalErrorCode=ErrorCode;
};
//------------------------------------------------------------------------------
NTSTATUS StreamMgr::getFatalError(){
	return criticalErrorCode;
};

//------------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\drm\krm\drmkmain\klist.cpp ===
//------------------------------------------------------------------------------
template<class T>
KList<T>::KList(){
	count=0;
	head=NULL;
	tail=NULL;
	return;
};
//------------------------------------------------------------------------------
template<class T>
KList<T>::~KList(){
	empty();
	return;
};
//------------------------------------------------------------------------------
template<class T>
void KList<T>::empty(){
	Node* n=head;
	while(n!=NULL){
		Node* nextN=n->next;
		delete n;
		n=nextN;
	};
	head=NULL;
	tail=NULL;
	count=0;
};
//------------------------------------------------------------------------------
template<class T>
bool KList<T>::addTail(const T& t){
	Node* n=new Node;
	if(n==NULL){
	    _DbgPrintF(DEBUGLVL_VERBOSE,("KList: out of memory]"));
		return false;
	};
	n->next=n->last=NULL;
	n->Obj=t;
	if(tail!=NULL){
		ASSERT(tail->next==NULL);
		n->last=tail;
		tail->next=n;
		tail=n;
	} else {
		head=n;
		tail=n;
	};
	count++;
	return true;;
};
//------------------------------------------------------------------------------
template<class T>
bool KList<T>::addHead(const T& t){
	Node* n=new Node;
	if(n==NULL){
	    _DbgPrintF(DEBUGLVL_VERBOSE,("KList: out of memory]"));
		return false;
	};
	n->next=n->last=NULL;
	n->Obj=t;
	if(head!=NULL){
		assert(head->last==NULL);
		n->next=head;
		head->last=n;
		head=n;
	} else {
		head=n;
		tail=n;
	};
	count++;
	return true;
};
//------------------------------------------------------------------------------
template<class T>
T& KList<T>::getHead() const {
	ASSERT(count!=0);
	return head->Obj;
};
//------------------------------------------------------------------------------
template<class T>
T& KList<T>::getTail() const {
	ASSERT(count!=0);
	return tail->Obj;
};
//------------------------------------------------------------------------------
template<class T>
POS KList<T>::getHeadPosition() const{
	return (POS) head;
};
//------------------------------------------------------------------------------
template<class T>
T& KList<T>::getAt(POS& P){
	ASSERT(count!=0);
	return ((Node*)P)->Obj;
};
//------------------------------------------------------------------------------
template<class T>
T& KList<T>::getNext(POS& P){
	ASSERT(count!=0);
	T& ret=((Node*)P)->Obj;
	P = (POS)((Node*)P)->next;
	return ret;
};
//------------------------------------------------------------------------------
template<class T>
void KList<T>::removeHead(){
	ASSERT(count>=1);
	Node* oldHead=head;
	head=head->next;
	head->last=NULL;
	delete oldHead;
	count--;
};
//------------------------------------------------------------------------------
template<class T>
void KList<T>::removeTail(){
	ASSERT(count>=1);
	Node* oldTail=tail;
	tail=tail->last;
	tail->next=NULL;
	delete oldTail;
	count--;
};
//------------------------------------------------------------------------------
template<class T>
void KList<T>::removeAt(POS& P){
	ASSERT(count>=1);
	Node* theNode= (Node*)P;
	Node* lastNode=theNode->last;
	Node* nextNode=theNode->next;
	delete theNode;
	if(head==theNode){head=nextNode;if(nextNode!=NULL)nextNode->last=NULL;}
	if(tail==theNode){tail=lastNode;if(lastNode!=NULL)lastNode->next=NULL;};
	if(lastNode!=NULL)lastNode->next=nextNode;
	if(nextNode!=NULL)nextNode->last=lastNode;
	count--;
	return;
};
//------------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\drm\krm\drmkmain\mynew.h ===
#ifndef mynew_h
#define mynew_h

#ifndef _NEW_DELETE_OPERATORS_
#define _NEW_DELETE_OPERATORS_


/*****************************************************************************
 * ::new()
 *****************************************************************************
 * New function for creating objects with a specified allocation tag.
 */
inline PVOID operator new
(
    size_t          iSize,
    POOL_TYPE       poolType
)
{
    PVOID result = ExAllocatePoolWithTag(poolType,iSize,'3mrD');

    if (result)
    {
        RtlZeroMemory(result,iSize);
    }

    return result;
}

/*****************************************************************************
 * ::new()
 *****************************************************************************
 * New function for creating objects with a specified allocation tag.
 */
inline PVOID operator new
(
    size_t          iSize,
    POOL_TYPE       poolType,
    ULONG           tag
)
{
    PVOID result = ExAllocatePoolWithTag(poolType,iSize,tag);

    if (result)
    {
        RtlZeroMemory(result,iSize);
    }

    return result;
}

/*****************************************************************************
 * ::delete()
 *****************************************************************************
 * Delete function.
 */
inline void __cdecl operator delete
(
    PVOID pVoid
)
{
    if (pVoid) 
    {
        ExFreePool(pVoid);
    }
}


#endif //!_NEW_DELETE_OPERATORS_



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\drm\krm\drmkmain\vroot.h ===
#ifndef VRoot_h
#define VRoot_h

// KS "Validation Root"
// Functions called to kick off the graph validation process, and provide
// the proving and validation functions for DRMK itself.

class VRoot: public IDrmAudioStream{
public:
	VRoot();
	DRM_STATUS initiateValidation(PFILE_OBJECT OutPinFileObject, PDEVICE_OBJECT OutPinDeviceObject, DWORD StreamId);
	DRM_STATUS initiateValidation(IUnknown* OutPin, DWORD StreamId);
	static NTSTATUS MyProvingFunction(PVOID AudioObject, PVOID DrmContext);
	NTSTATUS provingFunction(PVOID DrmContext);
	//  IUnknown
	STDMETHODIMP QueryInterface(REFIID, void **);
	STDMETHODIMP_(ULONG) AddRef(void);
	STDMETHODIMP_(ULONG) Release(void);

	IMP_IDrmAudioStream;
protected:
	DWORD myStreamId;
	
	// OutPin is FILE_OBJECT or IUnknown
	enum OutPinType{IsUndefined, IsFileObject, IsCOM};
	PFILE_OBJECT outPinFileObject;
	PDEVICE_OBJECT outPinDeviceObject;
	IUnknown* outPinUnk;
	OutPinType outPinType;
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\drm\krm\drmkmain\vroot.cpp ===
#include "drmkPCH.h"
#include <winerror.h>
#include "VRoot.h"
//------------------------------------------------------------------------------
VRoot::VRoot(){
	outPinType=IsUndefined;
	outPinUnk=NULL;
	outPinFileObject=NULL;
	outPinDeviceObject=NULL;
};
//------------------------------------------------------------------------------
DRM_STATUS VRoot::initiateValidation(PFILE_OBJECT OutPinFileObject, PDEVICE_OBJECT OutPinDeviceObject, DWORD StreamId){
	// validate myself - kick off by forwarding to myself
	outPinFileObject=OutPinFileObject;
	outPinDeviceObject = OutPinDeviceObject;
	outPinType=IsFileObject;
	myStreamId=StreamId;
	IUnknown* myUnk=static_cast<IUnknown*>(this);

	// numMethods is 3 (IUnknown) + 1 (IDrmAudioStream)
	ULONG numComMethods=3 + 1;
	NTSTATUS stat = DrmForwardContentToInterface(StreamId, myUnk, numComMethods);
	if(!NT_SUCCESS(stat)){
		_DbgPrintF(DEBUGLVL_VERBOSE,("DrmForwardContentToInterface(FILE_OBJECT) error on stream %d (Status=%d, %x)", StreamId, stat, stat));
		return stat;
	};
	// In the process of the above ForwardContent call weexpect some callbacks into 
	// StreamMgr telling us about DispatchTable and COM fucntions that will touch premium content
	return DRM_OK;
};
//------------------------------------------------------------------------------
DRM_STATUS VRoot::initiateValidation(IUnknown* OutPin, DWORD StreamId){
	myStreamId=StreamId;
	outPinUnk=OutPin;
	outPinType=IsCOM;
	IUnknown* myUnk=static_cast<IUnknown*>(this);
	
	NTSTATUS stat = DrmForwardContentToInterface(StreamId, myUnk, 4);
	if(!NT_SUCCESS(stat)){
		_DbgPrintF(DEBUGLVL_VERBOSE,("DrmForwardContentToInterface(INTERFACE) error on stream %d (Status=%d, %x)", StreamId, stat, stat));
		return stat;
	};
	// In the process of the above ForwardContent call weexpect some callbacks into 
	// StreamMgr telling us about DispatchTable and COM fucntions that will touch premium content
	return DRM_OK;
};
//------------------------------------------------------------------------------
STDMETHODIMP VRoot::QueryInterface(REFIID iid, void ** ppInt){
	if(iid==IID_IUnknown){
		*ppInt=static_cast<void*> (this);
		AddRef();
		return S_OK;
	};
	if(iid==IID_IDrmAudioStream){
		*ppInt = static_cast<void*> (this);
		AddRef();
		return S_OK;
	};
	*ppInt=NULL;
	return E_NOINTERFACE;
};
//------------------------------------------------------------------------------
STDMETHODIMP_(ULONG) VRoot::AddRef(void){
	return 0;
};
//------------------------------------------------------------------------------
STDMETHODIMP_(ULONG) VRoot::Release(void){
	return 0;
};
//------------------------------------------------------------------------------
NTSTATUS __stdcall VRoot::SetContentId(IN ULONG ContentId, IN PCDRMRIGHTS DrmRights){

	DWORD theStreamId=  ContentId;
	_DbgPrintF(DEBUGLVL_VERBOSE,("VRoot for %d on behest of %d", myStreamId, theStreamId));
	if(outPinType==IsCOM){
		if(outPinUnk==NULL){
			_DbgPrintF(DEBUGLVL_VERBOSE,("VRoot:: OutInterface not set for for stream %x", ContentId));
			return STATUS_INVALID_PARAMETER;
		}

		NTSTATUS stat = DrmForwardContentToInterface(theStreamId, outPinUnk, 4);
		return stat;
	};
	if(outPinType==IsFileObject){
		if(outPinFileObject==NULL){
			_DbgPrintF(DEBUGLVL_VERBOSE,("VRoot:: out FILE_OBJECT not set for for stream %x", ContentId));
			return STATUS_INVALID_PARAMETER;
		}
		DRMFORWARD DrmForward;
		RtlZeroMemory(&DrmForward, sizeof(DrmForward));
		DrmForward.Flags = 0;
		DrmForward.DeviceObject = outPinDeviceObject;
		DrmForward.FileObject = outPinFileObject;
		DrmForward.Context = outPinFileObject;
		DRM_STATUS stat=DrmForwardContentToDeviceObject(theStreamId, NULL, &DrmForward);
		return stat;
	};	
	// should not get here
	_DbgPrintF(DEBUGLVL_ERROR,("DRMK: No output pin set"));
	return STATUS_INVALID_PARAMETER;

};
//------------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\drm\krm\inc\bv4.h ===
#ifndef bv4_h
#define bv4_h
#ifdef __cplusplus
extern "C" {
#endif

#define RC4_TABLESIZE 256
#define BV4_Y_TABLESIZE 32

typedef struct BV4_KEYSTRUCT
{
  unsigned char p_T[RC4_TABLESIZE];		
  unsigned char p_R, p_S;		
  DWORD p_alpha;				
  DWORD p_beta[BV4_Y_TABLESIZE];
} BV4_KEYSTRUCT;

void bv4_key_C(BV4_KEYSTRUCT *pState, DWORD dwLen, unsigned char *buf);
void bv4_C(BV4_KEYSTRUCT *pState, DWORD dwLen,unsigned char *buf);

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\drm\krm\inc\cryptohelpers.h ===
#ifndef CryptoHelpers_h
#define CryptoHelpers_h

#include "CBCKey.h"
class CryptoHelpers{
public:
	static DRM_STATUS InitMac(CBCKey& macKey, CBCState& macState,BYTE* Data, DWORD DatSize);
	static DRM_STATUS Mac(CBCKey& Key, BYTE* Data, DWORD DatLen, OUT DRMDIGEST& Digest);
	static DRM_STATUS Xcrypt(STREAMKEY& Key, BYTE* Data, DWORD DatLen);

protected:
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\drm\krm\inc\cbckey.h ===
//-----------------------------------------------------------------------------
//
// File:   cbckey.h
//
// Microsoft Digital Rights Management
// Copyright (C) Microsoft Corporation, 1998 - 1999, All Rights Reserved
//
// Description:
//
//-----------------------------------------------------------------------------


#ifndef __CBCMAC_H__
#define __CBCMAC_H__

// #define _TEST_MAC to compile code in a "default" environment
#ifndef _TEST_MAC
#define _TEST_MAC
#endif

#ifdef _TEST_MAC
#define SHCLASS
#endif


typedef struct _CBCKey {
    UINT32 a1, b1, c1, d1, e1, f1, a2, b2, c2, d2, e2, f2;
} CBCKey;

UINT32 CBC64WS4_asm(
          UINT32   *Data,
          unsigned NumDWORDBlocks,
          UINT32   *pKey2,
		  CBCKey key );

UINT32 InvCBC64WS4_asm(
          UINT32   *Data,
          unsigned NumDWORDBlocks,
          UINT32   *pKey2,
		  CBCKey key,
		  CBCKey ikey );

UINT32 inv32(UINT32 n);

typedef struct {
  UINT32 sum,t;
  BYTE buf[8];
  DWORD dwBufLen;
} CBCState;

void CBC64Init( CBCKey *cbckey, CBCState *cbcstate, BYTE *pKey );
void CBC64InitState( CBCState *cbcstate );
void CBC64InvKey( CBCKey *cbcKey, CBCKey *cbcInvKey );
void CBC64Update( CBCKey *key, CBCState *cbcstate,DWORD dwLen, BYTE *pData );
UINT32 CBC64Finalize( CBCKey *key, CBCState *cbcstate, UINT32 *pKey2 );
UINT32 CBC64Invert( CBCKey *key, CBCKey *ikey, UINT32 MacA1, UINT32 MacA2,
		UINT32 MacB1, UINT32 MacB2, UINT32 *pInvKey2 );









#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\drm\krm\drmkmain\streammgr.h ===
#ifndef StreamMgr_h
#define StreamMgr_h

// Handles DRM streams.  Each protected audio stream has a streamId generated
// by this class.  Each stream has rights information provided by DRM.  This 
// class is responsible for mapping DRM rights to kernel rights, streamId 
// lifetime managment and construction of composite streamIds required by
// mixers.
// Composite streams start 0x80000000.  Primary streams start at 0x0.  Simple
// streams can be tagged with the handle held by the process that created them.

// bug todo - primary and composite should be maps, not lists (probably)


#define INVALID_POS	0xffffffff

class StreamMgr{
public:
	StreamMgr();
	~StreamMgr();
	// these are called by DRM when streams are explicitly created and destroyed
	DRM_STATUS createStream(HANDLE Handle, DWORD* StreamId, const DRMRIGHTS* RightsStruct, IN STREAMKEY* Key);
	DRM_STATUS destroyStream(DWORD StreamId);
	// this is called when the KRM-handle is closed (by whatever means)
	DRM_STATUS destroyAllStreamsByHandle(HANDLE Handle);
	// This is called by the KS2 graph when a mixer is encountered
	DRM_STATUS createCompositeStream(OUT DWORD* StreamId, IN DWORD* StreamInArray, DWORD NumStreams);
	DRM_STATUS destroyCompositeStream(IN DWORD CompositeStreamId);
	// get a key for a primary stream
	DRM_STATUS getKey(IN DWORD StreamId, OUT STREAMKEY*& Key);
	// query rights for primary or composite streams
	DRM_STATUS getRights(DWORD StreamId,DRMRIGHTS* Rights);
	// notify of new proving function associated with a stream.
	DRM_STATUS addProvingFunction(DWORD StreamId,PVOID Func);
	// initiate driver graph walk 
	DRM_STATUS walkDrivers(DWORD StreamId, PVOID* ProveFuncList, DWORD& NumDrivers, DWORD MaxDrivers);
	// allow drmk filter to inform StreamMgr of output pin (several forms) 
	DRM_STATUS setRecipient(IN DWORD StreamId, IN PFILE_OBJECT OutPinFileObject, IN PDEVICE_OBJECT OutPinDeviceObject);
	DRM_STATUS setRecipient(IN DWORD StreamId, IN IUnknown* OutPin);
	DRM_STATUS clearRecipient(IN DWORD StreamId);
	
	// authentication errors can be 'logged to a stream'
	void logErrorToStream(IN DWORD StreamId, DWORD ErrorCode);
	// Query error-status of (primary) streams
	DRM_STATUS getStreamErrorCode(IN DWORD StreamId, OUT DWORD& ErrorCode);
	DRM_STATUS clearStreamError(IN DWORD StreamId);

	// fatal errors (e.g. memory starvation) should switch off all stream.
	void setFatalError(DWORD ErrorCode);
	NTSTATUS getFatalError();

	KCritMgr& getCritMgr(){return critMgr;};

protected:
	enum OutPinType{IsUndefined, IsInterface, IsHandle};
	// Describes a primary stream
	struct StreamInfo{
		DWORD StreamId;
		HANDLE Handle;
		STREAMKEY Key;		
		DRMRIGHTS Rights;
		KList<PVOID> proveFuncs;
		BOOL newProveFuncs;
		OutPinType OutType;
		PFILE_OBJECT OutPinFileObject;
		PDEVICE_OBJECT OutPinDeviceObject;
		PUNKNOWN OutInt;
		BYTE* drmFormat;
		bool streamWalked;
		DRM_STATUS streamStatus;
	};
	// describes a composite stream
	struct CompositeStreamInfo{
		DWORD StreamId;
		KList<DWORD> parents;
	};
	//-----------
	bool addStream(StreamInfo& NewInfo);
	POS getStreamPos(DWORD StreamId);
	void deleteStreamAt(bool primary,POS pos);
	bool isPrimaryStream(DWORD StreamId);
	StreamInfo* getPrimaryStream(DWORD StreamId);
	CompositeStreamInfo* getCompositeStream(DWORD StreamId);
	DRM_STATUS getRightsWorker(DWORD StreamId, DRMRIGHTS* Rights);
	void logErrorToStreamWorker(IN DWORD StreamId, DWORD ErrorCode);

	//-----------
	DWORD nextStreamId;
	DWORD nextCompositeId;
	KList<StreamInfo*> primary;
	KList<CompositeStreamInfo*> composite;
	KCritMgr critMgr;
	volatile NTSTATUS criticalErrorCode;
};


extern StreamMgr* TheStreamMgr;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\drm\krm\inc\krmcommstructs.h ===
#ifndef krmcommsstructs_h
#define krmcommsstructs_h

#include "BV4.h"
#include "pkcrypto.h"

// symmetric stream key
typedef  BV4_KEYSTRUCT STREAMKEY, *PSTREAMKEY;

// DRM message and file digest
typedef struct DRMDIGESTtag{
    UINT32 w1;
    UINT32 w2;
} DRMDIGEST, *PDRMDIGEST;

// Connection structure (to build test graphs)
struct Conn{
    DWORD src;
    DWORD dest;
};

//----------------ECC cert section -----------------------
#define VERSION_LEN          4
#define DATE_LEN             4
#define RIGHTS_LEN           4
#define APPSEC_LEN           4
#define SER_NUM_LEN          4
#define ISSUER_LEN           4
#define SUBJ_LEN             4
#define INT_LEN              4

#define USER_MODE_X
typedef struct CERTDATAtag{
    PUBKEY pk;
    BYTE expiryDate[DATE_LEN];
    BYTE serialNumber[SER_NUM_LEN];
    BYTE issuer[ISSUER_LEN];
    BYTE subject[SUBJ_LEN];
} CERTDATA, *PCERTDATA;


typedef struct CERTtag{
    BYTE certVersion[VERSION_LEN];
    BYTE datalen[INT_LEN];
    BYTE sign[PK_ENC_SIGNATURE_LEN];
    CERTDATA cd;
} CERT, *PCERT;

typedef struct __DrmHandleTag {void* P;} *__DrmHandle;
typedef struct __StreamHandleTag {void* P;} *__StreamHandle;

// These "typed handles" are references to a KRM connection and a stream respectively
typedef __DrmHandle DRMHANDLE, *PDRMHANDLE;
typedef __StreamHandle STREAMHANDLE, *PSTREAMHANDLE;

// Definitions for driver authentication failures and callbacks
enum AuthFailureEnum {AuthOK, AuthNoCert, AuthNoDRMBit, AuthTampered, AuthCantParse, AuthBadProvingFunc, AuthBadImage};
typedef struct AUTHSTRUCTtag{
    char path[MAX_PATH];
    enum AuthFailureEnum type;
} AUTHSTRUCT , *PAUTHSTRUCT;
typedef void (*AuthFail)(DWORD StreamId, AUTHSTRUCT* Comp, DWORD NumComponents, PVOID Context);


// KRM operation ordinals
#define _KRMINIT                    1
#define _GETKERNELDATA              2 // not used.
#define _CREATESTREAM               3
#define _DESTROYSTREAM              4
#define _DESTROYSTREAMSBYHANDLE     5
#define _WALKDRIVERS                6
#define _KRMINIT1                   7
#define _KRMINIT2                   8
#define _DENUM                      9 // not used.
#define _GETKERNELDIGEST            12

typedef NTSTATUS DRM_STATUS;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\drm\krm\inc\drmerrs.h ===
#ifndef drmerrs_h
#define drmerrs_h
 
typedef long DRM_STATUS;

// bug - don't know how to assign this
#define DRM_ERROR_ROOT                  0x80000000

// DRM-generated errors 
#define DRM_OK                          0
#define DRM_SYSERR                      DRM_ERROR_ROOT + 100	 // bad - assert-like error
#define DRM_KRM_NOT_RUNNING             DRM_ERROR_ROOT + 101
#define DRM_KRM_COMMS                   DRM_ERROR_ROOT + 102
#define DRM_FILENOTFOUND                DRM_ERROR_ROOT + 103
#define DRM_FILEERR                     DRM_ERROR_ROOT + 104
#define DRM_BADFILE                     DRM_ERROR_ROOT + 105
#define DRM_BADTYPE                     DRM_ERROR_ROOT + 106
#define DRM_DEVENUMERATE                DRM_ERROR_ROOT + 107
#define DRM_DEVDETAIL                   DRM_ERROR_ROOT + 108
#define DRM_KRMNOTFOUND                 DRM_ERROR_ROOT + 109
#define DRM_NOTTRUSTED                  DRM_ERROR_ROOT + 110
#define DRM_FILENOTINCAT                DRM_ERROR_ROOT + 111
#define DRM_BADHANDLE                   DRM_ERROR_ROOT + 112
#define DRM_AUTHFAILURE                 DRM_ERROR_ROOT + 113
#define DRM_BADDRIVER                   DRM_ERROR_ROOT + 114
#define DRM_BADPARAM                    DRM_ERROR_ROOT + 115
#define DRM_BADKRMCERTSIG               DRM_ERROR_ROOT + 116
#define DRM_BADKRMCERT                  DRM_ERROR_ROOT + 117
#define DRM_OUTOFMEMORY                 DRM_ERROR_ROOT + 118
#define DRM_BADLIBRARY                  DRM_ERROR_ROOT + 119
#define DRM_MISSINGLIBRARY              DRM_ERROR_ROOT + 120
#define DRM_MISSINGDLL                  DRM_ERROR_ROOT + 122
#define DRM_BADPROVINGFUNCTION          DRM_ERROR_ROOT + 123
#define DRM_DATALENGTH                  DRM_ERROR_ROOT + 124
#define DRM_BUFSIZE                     DRM_ERROR_ROOT + 125
#define DRM_AUTHREQUIRED                DRM_ERROR_ROOT + 126
#define DRM_BADDRMLEVEL                 DRM_ERROR_ROOT + 127
#define DRM_NODRMATTRIB                 DRM_ERROR_ROOT + 128
#define DRM_RIGHTSNOTSUPPORTED          DRM_ERROR_ROOT + 129
#define DRM_VERIFIERENABLED             DRM_ERROR_ROOT + 130

// KRM-DRM comms
#define KRM_OK                          0
#define KRM_BADIOCTL                    DRM_ERROR_ROOT + 200
#define KRM_BUFSIZE                     DRM_ERROR_ROOT + 201
#define KRM_BADALIGNMENT                DRM_ERROR_ROOT + 202
#define KRM_BADADDRESS                  DRM_ERROR_ROOT + 203
#define KRM_OUTOFHANDLES                DRM_ERROR_ROOT + 204
#define KRM_BADSTREAM                   DRM_ERROR_ROOT + 205
#define KRM_SYSERR                      DRM_ERROR_ROOT + 206    // bad - assert-like error
#define DRM_BADKRMVERSION               DRM_ERROR_ROOT + 207
#define KRM_BADTERMINATOR               DRM_ERROR_ROOT + 208

// mist KRM errors
#define KRM_NOTPRIMARY                  DRM_ERROR_ROOT + 300

// macros
#define KRM_SUCCESS(x) (KRM_OK == x)

// DRM Errors that will be propaged to users
#define DRM_INVALIDPROVING              DRM_ERROR_ROOT + 1000   // Proving function is not in text seg
#define DRM_BADIMAGE                    DRM_ERROR_ROOT + 1001   // Image digest does not match PE file

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\drm\krm\inc\punknown.h ===
/*****************************************************************************
 * punknown.h - IUnknown definitions
 *****************************************************************************
 * Copyright (C) Microsoft Corporation, 1996 - 1999
 */

#ifndef _UNKNOWN_H_
#define _UNKNOWN_H_

#ifdef __cplusplus
extern "C" {
#include <wdm.h>
}
#else
#include <wdm.h>
#endif

#include <windef.h>
#define COM_NO_WINDOWS_H
#include <basetyps.h>
#ifdef PUT_GUIDS_HERE
#include <initguid.h>
#endif


DEFINE_GUID(IID_IUnknown,
0x00000000, 0x0000, 0x0000, 0x00, 0x00, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x46);

/*****************************************************************************
 * IUnknown
 *****************************************************************************
 * Base interface for otherwise unknown objects.
 */
#undef INTERFACE
#define INTERFACE IUnknown
DECLARE_INTERFACE(IUnknown)
{
    STDMETHOD(QueryInterface)
    (   THIS_
        IN      REFIID,
        OUT     PVOID *
    )   PURE;

    STDMETHOD_(ULONG,AddRef)
    (   THIS
    )   PURE;

    STDMETHOD_(ULONG,Release)
    (   THIS
    )   PURE;
};
#undef INTERFACE

typedef IUnknown *PUNKNOWN;

/*****************************************************************************
 * PFNCREATEINSTANCE
 *****************************************************************************
 * Type for object create function.
 */
typedef
HRESULT
(*PFNCREATEINSTANCE)
(
    OUT PUNKNOWN *  Unknown,
    IN  REFCLSID    ClassId,
    IN  PUNKNOWN    OuterUnknown,
    IN  POOL_TYPE   PoolType
);





#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\drm\krm\inc\pkcrypto.h ===
//-----------------------------------------------------------------------------
//
// File:   pkcrypto.h
//
// Microsoft Digital Rights Management
// Copyright (C) 1998-1999 Microsoft Corporation, All Rights Reserved
//
// Description:
//  public key crypto library
//
// Author:	marcuspe
//
//-----------------------------------------------------------------------------

#ifndef __DRMPKCRYPTO_H__
#define __DRMPKCRYPTO_H__


/*
#ifdef USER_MODE
#include <wtypes.h>
#else
#define S_OK 0
#define E_FAIL 1
#define E_INVALIDARG 2
#define CHAR_BIT 8
#endif
*/

#define LNGQDW 5

/*
typedef struct {
	DWORD y[2*LNGQDW];
} PUBKEY;

typedef struct {
	DWORD x[LNGQDW];
} PRIVKEY;
*/

#define PK_ENC_PUBLIC_KEY_LEN	(2 * LNGQDW * sizeof(DWORD))
#define PK_ENC_PRIVATE_KEY_LEN	(    LNGQDW * sizeof(DWORD))
#define PK_ENC_PLAINTEXT_LEN	((LNGQDW-1) * sizeof(DWORD))
#define PK_ENC_CIPHERTEXT_LEN	(4 * LNGQDW * sizeof(DWORD))
#define PK_ENC_SIGNATURE_LEN	(2 * LNGQDW * sizeof(DWORD))


typedef struct {
	BYTE y[ PK_ENC_PUBLIC_KEY_LEN ];
} PUBKEY;

typedef struct {
	BYTE x[ PK_ENC_PRIVATE_KEY_LEN ];
} PRIVKEY;



class CDRMPKCrypto {
private:
	char *pkd;
public:
	CDRMPKCrypto();
	~CDRMPKCrypto();
	HRESULT PKinit();
	HRESULT PKencrypt( PUBKEY *pk, BYTE *in, BYTE *out );
	HRESULT PKdecrypt( PRIVKEY *pk, BYTE *in, BYTE *out );
	HRESULT PKsign( PRIVKEY *privkey, BYTE  *buffer, DWORD lbuf, BYTE *sign );
	BOOL PKverify( PUBKEY *pubkey, BYTE *buffer, DWORD lbuf, BYTE *sign );
	HRESULT PKGenKeyPair( PUBKEY *pPub, PRIVKEY *pPriv );
};

extern "C" {
  extern void random_bytes(BYTE*, DWORD);

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\drm\krm\ukshared\cryptohelpers.cpp ===
#include "uksPCH.h"
#include "DrmErrs.h"
#include "CBCKey.h"
#include "KrmCommStructs.h"
#include "CryptoHelpers.h"
//------------------------------------------------------------------------------
DRM_STATUS CryptoHelpers::InitMac(CBCKey& macKey, CBCState& macState,BYTE* Data, DWORD DatSize){
	STREAMKEY myKey;
	bv4_key_C(&myKey, DatSize, Data);
	BYTE buf[64];
	memset(buf, 0, sizeof(buf));
	bv4_C(&myKey, 64, buf);
	CBC64Init(&macKey, &macState, buf);
	return DRM_OK;
};
//------------------------------------------------------------------------------
DRM_STATUS CryptoHelpers::Mac(CBCKey& Key, BYTE* Data, DWORD DatLen, OUT DRMDIGEST& Digest){
	CBCState state;
	CBC64InitState(&state);
	CBC64Update(&Key, &state, DatLen, Data);
	Digest.w1=CBC64Finalize(&Key, &state, &Digest.w2);
	return DRM_OK;
};
//------------------------------------------------------------------------------
DRM_STATUS CryptoHelpers::Xcrypt(STREAMKEY& Key, BYTE* Data, DWORD DatLen){
	bv4_C(&Key, DatLen, Data);
	return DRM_OK;
};
//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\drm\krm\inc\sbuffer.h ===
#ifndef SBuffer_h
#define SBuffer_h

#include "KrmCommStructs.h"

class SBuffer{
friend DRM_STATUS checkTerm(SBuffer& S);
public:
    SBuffer(BYTE* Buf, unsigned int Len);   // caller supplied;
    void reset();                           // reset get/put pointer
    ~SBuffer();

    // Insertion operators
    SBuffer& operator << (const DWORD Val);
    SBuffer& operator << (const PVOID Ptr);
    SBuffer& operator << (const PDRMRIGHTS R);
    SBuffer& operator << (const PSTREAMKEY S);
    SBuffer& operator << (const PCERT C);
    SBuffer& operator << (const PDRMDIGEST D);

    // Extraction operators
    SBuffer& operator >> (DWORD& Val);
    SBuffer& operator >> (PDRMRIGHTS R);
    SBuffer& operator >> (PSTREAMKEY S);
    SBuffer& operator >> (PCERT C);

    // buffer access
    BYTE* getBuf(){return buf;};
    unsigned int getPutPos(){return putPos;};
    unsigned int getLen(){return len;};
    DRM_STATUS getGetPosAndAdvance(unsigned int *pos, unsigned int Len);
    DRM_STATUS getPutPosAndAdvance(unsigned int *pos, unsigned int Len);
    DRM_STATUS append(BYTE* Data, DWORD datLen);

    // error return
    DRM_STATUS getLastError(){return lasterror;};

protected:
    void err(const char* Msg, DRM_STATUS err);

    DRM_STATUS lasterror;
    unsigned int len;
    unsigned int getPos, putPos;
    BYTE* buf;
};

// sentinels
DRM_STATUS term(SBuffer& S);
DRM_STATUS checkTerm(SBuffer& S);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\drm\krm\ukshared\ukspch.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__8B19E1AB_699E_4618_91B9_01DE7D941F08__INCLUDED_)
#define AFX_STDAFX_H__8B19E1AB_699E_4618_91B9_01DE7D941F08__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifndef WIN32_LEAN_AND_MEAN		
	#define WIN32_LEAN_AND_MEAN		// Exclude rarely-used stuff from Windows headers
#endif

#ifdef _KBLD
	#include "DRMKMain/drmkPCH.h"
#else
	#include "KRMProxy/krmpPCH.h"
#endif



// TODO: reference additional headers your program requires here

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__8B19E1AB_699E_4618_91B9_01DE7D941F08__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\drm\krm\ukshared\ukspch.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	UKShared.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "uksPCH.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\drm\krm\ukshared\sbuffer.cpp ===
#include "uksPCH.h"

extern "C" {
#include <wdm.h>
}
#include <ks.h>

#include "inc/KrmCommStructs.h"
#include "SBuffer.h"

//------------------------------------------------------------------------------
SBuffer::SBuffer(BYTE* BufX, unsigned int Len){
    buf=BufX;
    getPos=0;
    putPos=0;
    len=Len;
    lasterror=KRM_OK;
};
//------------------------------------------------------------------------------
SBuffer::~SBuffer(){
    buf=NULL;
};
//------------------------------------------------------------------------------
void SBuffer::reset(){
    getPos=0;
    putPos=0;
    lasterror=KRM_OK;    
};
//------------------------------------------------------------------------------
DRM_STATUS SBuffer::append(BYTE* Data, DWORD datLen){
    unsigned int p;

    if (KRM_OK == getPutPosAndAdvance(&p,datLen)) {
        memcpy(buf+p, Data, datLen);
    }
    return lasterror;
};
//------------------------------------------------------------------------------
void SBuffer::err(const char* Msg, DRM_STATUS err){
    lasterror = err;
#ifdef DBG
    DbgPrint("DRMK:");DbgPrint((char*) Msg);DbgPrint("\n");
#endif
	ASSERT(FALSE);
};
//------------------------------------------------------------------------------
DRM_STATUS SBuffer::getGetPosAndAdvance(unsigned int *pos, unsigned int Len) {
    if (KRM_OK == lasterror) {
        if (Len > len-getPos) {
            err("pop overflow", KRM_BUFSIZE);
        }
        else {
            *pos=getPos;
            getPos+=Len;
        }
    }
    
    return lasterror;
};
//------------------------------------------------------------------------------
DRM_STATUS SBuffer::getPutPosAndAdvance(unsigned int *pos, unsigned int Len) {
    if (KRM_OK == lasterror) {
        if (Len > len-putPos) {
            err("push overflow", KRM_BUFSIZE);
        }
        else {
            *pos=putPos;
            putPos+=Len;
        }
    }
    
    return lasterror;
};
//------------------------------------------------------------------------------
#define INSERT(_TYPE, _OBJADDR)                                         \
    if (KRM_OK == lasterror) {                                          \
        unsigned int _size=sizeof(_TYPE);                               \
        if (_size > len-putPos) {                                       \
            err("push overflow",KRM_BUFSIZE);                           \
        }                                                               \
        else {                                                          \
            memcpy(buf+putPos, _OBJADDR, _size);                        \
            putPos+=_size;                                              \
        }                                                               \
    }                                                                   \
    return *this;                                                           
//------------------------------------------------------------------------------
#define EXTRACT(_TYPE, _OBJADDR)                                        \
    if (KRM_OK == lasterror) {                                          \
        unsigned int _size = sizeof(_TYPE);                             \
        if(_size > len-getPos) {                                        \
            err("pop overflow",KRM_BUFSIZE);                            \
        }                                                               \
        else {                                                          \
            memcpy(_OBJADDR, buf+getPos, _size);                        \
            getPos += _size;                                            \
        }                                                               \
    }                                                                   \
    return *this;                                                       
//------------------------------------------------------------------------------
SBuffer& SBuffer::operator << (const DWORD Val) {
    INSERT(DWORD, &Val);
};
//------------------------------------------------------------------------------
SBuffer& SBuffer::operator << (const PVOID Ptr) {
    INSERT(DWORD, &Ptr);
};
//------------------------------------------------------------------------------
SBuffer& SBuffer::operator << (PDRMRIGHTS R) {
    INSERT(DRMRIGHTS, R);
};
//------------------------------------------------------------------------------
SBuffer& SBuffer::operator << (PSTREAMKEY S) {
    INSERT(STREAMKEY, S);
};
//------------------------------------------------------------------------------
SBuffer& SBuffer::operator << (PCERT C) {
    INSERT(CERT, C);
};
//------------------------------------------------------------------------------
SBuffer& SBuffer::operator << (PDRMDIGEST D) {
    INSERT(DRMDIGEST, D);
};
//------------------------------------------------------------------------------
SBuffer& SBuffer::operator >> (DWORD& Val) {
    EXTRACT(DWORD, &Val);
};
//------------------------------------------------------------------------------
SBuffer& SBuffer::operator >> (DRMRIGHTS* R) {
    EXTRACT(DRMRIGHTS, R);
};
//------------------------------------------------------------------------------
SBuffer& SBuffer::operator >> (PSTREAMKEY S) {
    EXTRACT(STREAMKEY, S);
};
//------------------------------------------------------------------------------
SBuffer& SBuffer::operator >> (PCERT C) {
    EXTRACT(CERT, C);
};
//------------------------------------------------------------------------------
DRM_STATUS term(SBuffer& S) {
    if (KRM_OK == S.getLastError()) {
        S << 0xFFFFffff;
    }

    return S.getLastError();
};
//------------------------------------------------------------------------------
DRM_STATUS checkTerm(SBuffer& S) {
    if (KRM_OK == S.getLastError()) {
        DWORD Val = 0;
        S >> Val;

        if (KRM_OK == S.getLastError()) {
            if (Val != 0xFFFFffff) {
                S.err("Bad terminator", KRM_BADTERMINATOR);
            }
        }

        ASSERT(Val==0xFFFFffff);
    }

    return S.getLastError();;
};
//------------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\filters\kmixer\common.h ===
//---------------------------------------------------------------------------
//
//  Module:   common.h
//
//  Description:
//
//
//@@BEGIN_MSINTERNAL
//  Development Team:
//     Bryan A. Woodruff
//
//  History:   Date       Author      Comment
//
//@@END_MSINTERNAL
//---------------------------------------------------------------------------
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1995-2000 Microsoft Corporation.  All Rights Reserved.
//
//---------------------------------------------------------------------------

#include <wdm.h>

#include <windef.h>

#include <memory.h>
#include <stddef.h>
#include <stdio.h>
#include <limits.h>
#include <stdlib.h>
#include <tchar.h>
#include <conio.h>

#define NOBITMAP
#include <mmsystem.h>
#include <mmreg.h>
#undef NOBITMAP
#include <ks.h>
#include <ksmediap.h>
#include <ksdebug.h>
#include <swenum.h>
#include <math.h>

#include "modeflag.h"
#include "rsiir.h"
#include "slocal.h"
#include "rfcvec.h"
#include "rfiir.h"
#include "flocal.h"
#include "fpconv.h"
#include "private.h"

#ifdef REALTIME_THREAD
#include "rt.h"
VOID RtMix(PVOID Context, ThreadStats *Statistics);
#endif

#if DBG
#define INVALID_POINTER (PVOID)(-1)
#else
#define INVALID_POINTER NULL
#endif

#define INIT_CODE       code_seg("INIT", "CODE")
#define INIT_DATA       data_seg("INIT", "DATA")
#define LOCKED_CODE     code_seg(".text", "CODE")
#define LOCKED_DATA     data_seg(".data", "DATA")

#ifdef REALTIME_THREAD
#define PAGEABLE_CODE     code_seg(".text", "CODE")
#define PAGEABLE_DATA     data_seg(".data", "DATA")
#else
#define PAGEABLE_CODE   code_seg("PAGE", "CODE")
#define PAGEABLE_DATA   data_seg("PAGEDATA", "DATA")
#endif

#pragma PAGEABLE_CODE
#pragma PAGEABLE_DATA

//---------------------------------------------------------------------------
//  End of File: common.h
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\filters\kmixer\clock.c ===
//---------------------------------------------------------------------------
//
//  Module:   clock.c
//
//  Description:
//
//      KS Clock support routines
//
//@@BEGIN_MSINTERNAL
//  Development Team:
//     S.Mohanraj
//
//  History:   Date       Author      Comment
//  Original   2/5/98     S.Mohanraj  Added Clock support
//
//  To Do:     Date       Author      Comment
//
//@@END_MSINTERNAL                                         
//
//  Copyright (c) 1996-2000 Microsoft Corporation.  All Rights Reserved.
//
//---------------------------------------------------------------------------

#include "common.h"

DEFINE_KSDISPATCH_TABLE(
        MxClockDispatchTable,
        MxClockDispatchIoControl,
        KsDispatchInvalidDeviceRequest,
        KsDispatchInvalidDeviceRequest,
        KsDispatchInvalidDeviceRequest,
        MxClockDispatchClose,
        KsDispatchInvalidDeviceRequest,
        KsDispatchInvalidDeviceRequest,
        KsDispatchFastIoDeviceControlFailure,
        KsDispatchFastReadFailure,
        KsDispatchFastWriteFailure
) ;

DEFINE_KSPROPERTY_CLOCKSET( 
    MxClockPropertyHandlers,
    MxGetTime,
    MxGetPhysicalTime,
    MxGetCorrelatedTime,
    MxGetCorrelatedPhysicalTime,
    MxGetResolution,
    MxGetState,
    MxGetFunctionTable );

DEFINE_KSPROPERTY_SET_TABLE( MxClockPropertyTable )
{
    DEFINE_KSPROPERTY_SET( 
        &KSPROPSETID_Clock,
        SIZEOF_ARRAY( MxClockPropertyHandlers ),
        MxClockPropertyHandlers,
        0, 
        NULL)
};

DEFINE_KSEVENT_TABLE( MxClockEventHandlers ) {
    DEFINE_KSEVENT_ITEM(
        KSEVENT_CLOCK_INTERVAL_MARK,
        sizeof( KSEVENT_TIME_INTERVAL ),
        sizeof( ULONGLONG ) + sizeof( ULONGLONG ),
        (PFNKSADDEVENT) MxAddClockEvent,
        NULL,
        NULL),
    DEFINE_KSEVENT_ITEM(
        KSEVENT_CLOCK_POSITION_MARK,
        sizeof( KSEVENT_TIME_MARK ),
        sizeof( ULONGLONG ),
        (PFNKSADDEVENT) MxAddClockEvent,
        NULL,
        NULL)
};

DEFINE_KSEVENT_SET_TABLE( MxClockEventTable )
{
    DEFINE_KSEVENT_SET( 
        &KSEVENTSETID_Clock, 
        SIZEOF_ARRAY( MxClockEventHandlers ),
        MxClockEventHandlers)
};

NTSTATUS
MxClockDispatchCreate(
    IN  PDEVICE_OBJECT  pDeviceObject,
    IN  PIRP            pIrp
)
{
    NTSTATUS                Status ;
    PKSCLOCK_CREATE         pClockCreate ;
    PFILE_OBJECT            ParentObject ;
    PMIXER_SINK_INSTANCE    pMixerSink ;
    PIO_STACK_LOCATION      pIrpStack ;
    PCLOCK_INSTANCE         pClock ;
    PFILTER_INSTANCE        pFilterInstance ;

    pIrpStack = IoGetCurrentIrpStackLocation(pIrp) ;
    
    ParentObject = pIrpStack->FileObject->RelatedFileObject ;
    pMixerSink = ParentObject->FsContext ;
    pFilterInstance = pMixerSink->Header.pFilterFileObject->FsContext ;

    KeWaitForSingleObject ( &pFilterInstance->ControlMutex,
                               Executive,
                               KernelMode,
                               FALSE,
                               NULL ) ;

    if ( pMixerSink->pClock ) {
        // We do not support multiple clock creates.
        Status = STATUS_DEVICE_BUSY ;
        goto exit ;
    }
    
    Status = KsValidateClockCreateRequest(pIrp, &pClockCreate) ;
    if ( NT_SUCCESS(Status) ) {
        pClock = ExAllocatePoolWithTag(NonPagedPool,
                                      sizeof(CLOCK_INSTANCE),
                                      'XIMK') ;
                                      
        if ( pClock ) {
            KsAllocateObjectHeader(&pClock->Header.ObjectHeader,
                                   0,
                                   NULL,
                                   pIrp,
                                   &MxClockDispatchTable) ;
                                   
            pClock->pMixerSink = pMixerSink ;
            pClock->pFilterInstance =
                 ((PMIXER_INSTHDR)pMixerSink)->pFilterFileObject->FsContext ;
            pClock->Header.PinId = ((PMIXER_INSTHDR)pMixerSink)->PinId ;
            KeInitializeSpinLock(&pClock->EventLock) ;
            InitializeListHead(&pClock->EventQueue) ;
            pMixerSink->pClock = pClock ;
            pIrpStack->FileObject->FsContext = pClock ;
            pClock->PhysicalTime = 0 ;
            pClock->pFileObject = pIrpStack->FileObject ;
            ObReferenceObject(ParentObject) ;
        }
        else {
            Status = STATUS_INSUFFICIENT_RESOURCES ;
        }
    }
exit:    
    KeReleaseMutex ( &pFilterInstance->ControlMutex, FALSE ) ;
    
    pIrp->IoStatus.Status = Status;
    IoCompleteRequest( pIrp, IO_NO_INCREMENT );

    return Status;
}

NTSTATUS
MxClockDispatchClose(
    IN  PDEVICE_OBJECT  pDeviceObject,
    IN  PIRP            pIrp
)
{
    NTSTATUS                Status ;
    PIO_STACK_LOCATION      pIrpStack ;
    PCLOCK_INSTANCE         pClock ;
    PFILTER_INSTANCE        pFilterInstance ;
    PMIXER_SINK_INSTANCE    pMixerSink ;
    
    pIrpStack = IoGetCurrentIrpStackLocation( pIrp );
    pClock = pIrpStack->FileObject->FsContext ;
    pMixerSink = pClock->pMixerSink ;
    pFilterInstance = pMixerSink->Header.pFilterFileObject->FsContext ;

    KeWaitForSingleObject ( &pFilterInstance->ControlMutex,
                               Executive,
                               KernelMode,
                               FALSE,
                               NULL ) ;
                               
    pMixerSink->pClock = NULL ;
    KsFreeEventList( pIrpStack->FileObject,
                     &pClock->EventQueue,
                     KSEVENTS_SPINLOCK,
                     &pClock->EventLock );
    KsFreeObjectHeader(pClock->Header.ObjectHeader) ;
    ExFreePool(pClock) ;
    ObDereferenceObject(pIrpStack->FileObject->RelatedFileObject) ;
    KeReleaseMutex ( &pFilterInstance->ControlMutex, FALSE ) ;

    Status = STATUS_SUCCESS ;
    pIrp->IoStatus.Status = Status;
    IoCompleteRequest( pIrp, IO_NO_INCREMENT );

    return Status;
}

NTSTATUS
MxClockDispatchIoControl(
    IN  PDEVICE_OBJECT  pDeviceObject,
    IN  PIRP            pIrp
)
{
    NTSTATUS            Status ;
    PIO_STACK_LOCATION  pIrpStack ;
    PCLOCK_INSTANCE     pClock ;
    
    PAGED_CODE();

    ASSERT( pDeviceObject );
    ASSERT( pIrp );

    pIrpStack = IoGetCurrentIrpStackLocation( pIrp );
    pClock = pIrpStack->FileObject->FsContext ;
    switch (pIrpStack->Parameters.DeviceIoControl.IoControlCode) {

        case IOCTL_KS_PROPERTY:
            Status = KsPropertyHandler( pIrp, 
                                        SIZEOF_ARRAY( MxClockPropertyTable ),
                                        (PKSPROPERTY_SET) MxClockPropertyTable );
            break;

        case IOCTL_KS_ENABLE_EVENT:
            Status = KsEnableEvent( pIrp, 
                                    SIZEOF_ARRAY( MxClockEventTable ), 
                                    (PKSEVENT_SET) MxClockEventTable, 
                                    NULL, 
                                    KSEVENTS_NONE,
                                    NULL);
            break;

        case IOCTL_KS_DISABLE_EVENT:
            Status = KsDisableEvent( pIrp, 
                                     &pClock->EventQueue,
                                     KSEVENTS_SPINLOCK,
                                     &pClock->EventLock );
            break;

        default:
            return KsDefaultDeviceIoCompletion( pDeviceObject, pIrp );

    }

    pIrp->IoStatus.Status = Status;
    IoCompleteRequest(pIrp, IO_NO_INCREMENT);

    return Status;
}

NTSTATUS
MxGetTime
(
    PIRP            pIrp,
    PKSPROPERTY     pProperty,
    PULONGLONG      pTime
)
{
    PIO_STACK_LOCATION  pIrpStack ;

    PAGED_CODE() ;
    pIrpStack = IoGetCurrentIrpStackLocation(pIrp) ;

    *pTime = MxFastGetTime(pIrpStack->FileObject) ;

    pIrp->IoStatus.Information = sizeof(ULONGLONG) ;
    return(STATUS_SUCCESS) ;
}

NTSTATUS
MxGetPhysicalTime
(
    PIRP            pIrp,
    PKSPROPERTY     pProperty,
    PULONGLONG      pPhysicalTime
)
{
    PIO_STACK_LOCATION  pIrpStack ;

    PAGED_CODE() ;
    pIrpStack = IoGetCurrentIrpStackLocation(pIrp) ;

    *pPhysicalTime = MxFastGetPhysicalTime(pIrpStack->FileObject) ;

    pIrp->IoStatus.Information = sizeof(ULONGLONG) ;
    return(STATUS_SUCCESS) ;
}

NTSTATUS
MxGetCorrelatedTime
(
    PIRP                pIrp,
    PKSPROPERTY         pProperty,
    PKSCORRELATED_TIME  pCorrelatedTime
)
{
    PIO_STACK_LOCATION  pIrpStack ;

    PAGED_CODE() ;
    pIrpStack = IoGetCurrentIrpStackLocation(pIrp) ;

    pCorrelatedTime->Time =
                MxFastGetCorrelatedTime(pIrpStack->FileObject,
                                        &pCorrelatedTime->SystemTime) ;

    pIrp->IoStatus.Information = sizeof(KSCORRELATED_TIME) ;
    return(STATUS_SUCCESS) ;
}

NTSTATUS
MxGetCorrelatedPhysicalTime
(
    PIRP            pIrp,
    PKSPROPERTY     pProperty,
    PKSCORRELATED_TIME  pCorrelatedPhysicalTime
)
{
    PIO_STACK_LOCATION  pIrpStack ;

    PAGED_CODE() ;
    pIrpStack = IoGetCurrentIrpStackLocation(pIrp) ;

    pCorrelatedPhysicalTime->Time =
                MxFastGetCorrelatedPhysicalTime(pIrpStack->FileObject,
                                      &pCorrelatedPhysicalTime->SystemTime) ;

    pIrp->IoStatus.Information = sizeof(KSCORRELATED_TIME) ;
    return(STATUS_SUCCESS) ;
}

NTSTATUS
MxGetResolution
(
    PIRP            pIrp,
    PKSPROPERTY     pProperty,
    PKSRESOLUTION   pResolution
)
{
    PIO_STACK_LOCATION      pIrpStack ;
    PMIXER_SINK_INSTANCE    pMixerSink ;
    PFILTER_INSTANCE        pFilterInstance ;
    
    PAGED_CODE() ;
    
    pIrpStack = IoGetCurrentIrpStackLocation(pIrp) ;

    pMixerSink = pIrpStack->FileObject->RelatedFileObject->FsContext ;
    //
    // Setup pFilterInstance for accessing MIXBUFFERDURATION
    //
    pFilterInstance = (PFILTER_INSTANCE)pMixerSink->Header.pFilterFileObject->FsContext ;

    pResolution->Granularity = MxConvertBytesToTime(pMixerSink, 1) ;

    pResolution->Error =
                ((_100NS_UNITS_PER_SECOND / 1000) * MIXBUFFERDURATION) / 2 ;

    pIrp->IoStatus.Information = sizeof(KSRESOLUTION) ;
    return(STATUS_SUCCESS) ;
}

NTSTATUS
MxGetState
(
    PIRP            pIrp,
    PKSPROPERTY     pProperty,
    PKSSTATE        pState
)
{
    PIO_STACK_LOCATION      pIrpStack ;
    PMIXER_SINK_INSTANCE    pMixerSink ;
    
    PAGED_CODE() ;
    
    pIrpStack = IoGetCurrentIrpStackLocation(pIrp) ;

    pMixerSink = pIrpStack->FileObject->RelatedFileObject->FsContext ;
    
    *pState = pMixerSink->SinkState ;
    
    pIrp->IoStatus.Information = sizeof(KSSTATE) ;
    return(STATUS_SUCCESS) ;
}

NTSTATUS
MxGetFunctionTable
(
    PIRP                    pIrp,
    PKSPROPERTY             pProperty,
    PKSCLOCK_FUNCTIONTABLE  pClockFunctionTable
)
{
    PIO_STACK_LOCATION  pIrpStack ;

    PAGED_CODE() ;
    pIrpStack = IoGetCurrentIrpStackLocation(pIrp) ;

    pClockFunctionTable->GetTime = MxFastGetTime ;
    pClockFunctionTable->GetPhysicalTime = MxFastGetPhysicalTime ;
    pClockFunctionTable->GetCorrelatedTime = MxFastGetCorrelatedTime ;
    pClockFunctionTable->GetCorrelatedPhysicalTime =
                                MxFastGetCorrelatedPhysicalTime ;
    
    pIrp->IoStatus.Information = sizeof(KSCLOCK_FUNCTIONTABLE) ;
    return(STATUS_SUCCESS) ;
}

LONGLONG
FASTCALL
MxFastGetTime
(
    PFILE_OBJECT    pFileObject
)
{
    PMIXER_SINK_INSTANCE    pMixerSink ;
    PCLOCK_INSTANCE         pClock ;

    pClock = pFileObject->FsContext ;
    pMixerSink = pClock->pMixerSink ;

    return (MxConvertBytesToTime(pMixerSink, pMixerSink->WriteOffset)) ;
    
}

LONGLONG
FASTCALL
MxFastGetPhysicalTime
(
    PFILE_OBJECT    pFileObject
)
{
    PCLOCK_INSTANCE         pClock ;
    PMIXER_SINK_INSTANCE    pMixerSink ;
    
    pClock = pFileObject->FsContext ;
    pMixerSink = pClock->pMixerSink ;

    return (MxConvertBytesToTime(pMixerSink, pClock->PhysicalTime)) ;
}

LONGLONG
FASTCALL
MxFastGetCorrelatedTime
(
    PFILE_OBJECT    pFileObject,
    PLONGLONG       pSystemTime
)
{
    LARGE_INTEGER   Time, Frequency ;

    Time = KeQueryPerformanceCounter(&Frequency) ;
    //
    //  Convert ticks to 100ns units.
    //
    *pSystemTime = KSCONVERT_PERFORMANCE_TIME(Frequency.QuadPart,Time);

    return (MxFastGetTime(pFileObject)) ;
}

LONGLONG
FASTCALL
MxFastGetCorrelatedPhysicalTime
(
    PFILE_OBJECT    pFileObject,
    PLONGLONG       pSystemTime
)
{
    LARGE_INTEGER   Time, Frequency ;

    Time = KeQueryPerformanceCounter(&Frequency) ;
    //
    //  Convert ticks to 100ns units.
    //
    *pSystemTime = KSCONVERT_PERFORMANCE_TIME(Frequency.QuadPart,Time);
                   
    return (MxFastGetPhysicalTime(pFileObject)) ;
}

MxUpdatePhysicalTime 
(

    PCLOCK_INSTANCE pClock,
    ULONGLONG       Increment           // in Bytes
)
{
    ULONG fool;
    fool = (ULONG) (pClock->PhysicalTime += Increment);  
    // keep it in bytes till we need to convert it (in the Get function)
    return fool;
}

LONGLONG
MxConvertBytesToTime
(
    PMIXER_SINK_INSTANCE    pMixerSink,
    ULONGLONG               Bytes
)
{
    LONGLONG    Time ;
    
	Time = (_100NS_UNITS_PER_SECOND /
            (pMixerSink->BytesPerSample) * Bytes) /
            pMixerSink->WaveFormatEx.nSamplesPerSec ;
    return (Time) ;
}

#pragma LOCKED_CODE
#pragma LOCKED_DATA

NTSTATUS
MxAddClockEvent
(
    PIRP                    pIrp,
    PKSEVENT_TIME_INTERVAL  pEventTime,
    PKSEVENT_ENTRY          EventEntry
)
{
    PIO_STACK_LOCATION      pIrpStack ;
    PCLOCK_INSTANCE         pClock ;
    PFILTER_INSTANCE        pFilterInstance ;
    PMIXER_SINK_INSTANCE    pMixerSink ;
    PKSINTERVAL             Interval;
    KIRQL                   irqlOld ;

    pIrpStack = IoGetCurrentIrpStackLocation( pIrp );
    pClock = pIrpStack->FileObject->FsContext ;
    pMixerSink = pClock->pMixerSink ;
    pFilterInstance = pMixerSink->Header.pFilterFileObject->FsContext ;

    KeWaitForSingleObject ( &pFilterInstance->ControlMutex,
                               Executive,
                               KernelMode,
                               FALSE,
                               NULL ) ;

    //
    // Space for the interval is located at the end of the basic 
    // event structure.
    //
    Interval = (PKSINTERVAL)(EventEntry + 1);
    //
    // Either just an event time was passed, or a time base plus an 
    // interval. In both cases the first LONGLONG is present and saved.
    //
    // Note, KS_CLOCK_POSITION_MARK is a single-shot event
    Interval->TimeBase = pEventTime->TimeBase;
    if (EventEntry->EventItem->EventId == KSEVENT_CLOCK_INTERVAL_MARK) {
        Interval->Interval = pEventTime->Interval;
    }

    KeAcquireSpinLock( &pClock->EventLock, &irqlOld );
    InsertHeadList( &pClock->EventQueue, &EventEntry->ListEntry );
    KeReleaseSpinLock( &pClock->EventLock, irqlOld );
    
    if (pMixerSink->SinkState == KSSTATE_RUN) {
        // If this event is passed signal immediately.
        MxGenerateClockEvents( pMixerSink->pClock ) ;
    }

    KeReleaseMutex ( &pFilterInstance->ControlMutex, FALSE ) ;
    return ( STATUS_SUCCESS ) ;
}

MxGenerateClockEvents
(
    PCLOCK_INSTANCE    pClock
)
{
    LONGLONG                Time;
    PLIST_ENTRY             ListEntry;
    KIRQL                   irqlOld ;
    PKSEVENT_ENTRY          EventEntry;
    PKSINTERVAL             Interval;
    LONGLONG                Intervals;

    Time = MxFastGetTime( pClock->pFileObject );

    KeAcquireSpinLock( &pClock->EventLock, &irqlOld );

    for(ListEntry = pClock->EventQueue.Flink; 
            ListEntry != &pClock->EventQueue;) {

        EventEntry = 
            (PKSEVENT_ENTRY)
                CONTAINING_RECORD( ListEntry, KSEVENT_ENTRY, ListEntry );
                
        //
        // Pre-inc, KsGenerateEvent() can remove this item from the list.
        //    
        ListEntry = ListEntry->Flink;
        //
        // The event-specific data was added onto the end of the entry.
        //
        Interval = (PKSINTERVAL)(EventEntry + 1);
        //
        // Time for this event to go off.
        //
        if (Interval->TimeBase <= Time) {
            _DbgPrintF(
                DEBUGLVL_VERBOSE, ("Generating event for time: %ld at time: %ld",
                Interval->TimeBase, Time) );
            if (EventEntry->EventItem->EventId != 
                    KSEVENT_CLOCK_INTERVAL_MARK) {
                //
                // A single-shot should only go off once, so make
                // it a value which will never be reached again.
                //
                Interval->TimeBase = 0x7fffffffffffffff;
                
            } else {
                //
                // An interval timer should only go off once per time,
                // so update it to the next timeout.
                //
                Intervals = 
                    (Time - Interval->TimeBase + Interval->Interval - 1) / Interval->Interval;
                Interval->TimeBase += Intervals * Interval->Interval;
            } 

            KsGenerateEvent( EventEntry );
        }
    }

    KeReleaseSpinLock( &pClock->EventLock, irqlOld );
    
    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\filters\kmixer\dbg.c ===
//---------------------------------------------------------------------------
//
//  Module:   device.c
//
//  Description:
//
//
//@@BEGIN_MSINTERNAL
//  Development Team:
//     S.Mohanraj
//
//  History:   Date       Author      Comment
//
//@@END_MSINTERNAL
//---------------------------------------------------------------------------
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1995-2000 Microsoft Corporation.  All Rights Reserved.
//
//---------------------------------------------------------------------------

#include "common.h"

#ifdef DEBUG

extern  PFILTER_INSTANCE    gpFilterInstance ;

VOID
DebugCommand(
) ;
VOID
DebugDotCommand(
) ;
VOID
InitializeDebug(
);
VOID
UninitializeDebug(
);
VOID __cdecl
dprintf(
    PSZ pszFmt,
    ...
);
CHAR 
DebugGetCommandChar(
);
VOID
DumpSink
(
    PMIXER_SINK_INSTANCE    pMixerSink
);
VOID
DumpSinkPinStatistics
(
    VOID
);
VOID
DumpSinkPins
(
    VOID
);
VOID
DumpActiveSinkPins
(
    VOID
);
VOID
DumpSourcePinStatistics
(
    VOID
);

VOID
DebugCommand(
)
{
    CHAR c;
    while((c = DebugGetCommandChar()) != '\0') {
	    switch(c) {
	     case 'N':
            DumpSinkPinStatistics();
            break;
	     case 'P':
		    DumpSinkPins();
		    break;
	     case 'S':
		    DumpSourcePinStatistics();
		    break;
	     case 'A':
		    DumpActiveSinkPins();
		    break;
		 case '?':
		    dprintf(".X[N|P|A|S]\n");
		    dprintf("N - sink pin statistics\n");
		    dprintf("P - sink pin structures\n");
		    dprintf("A - active sink pin structures\n");
		    dprintf("S - source pin statistics\n");
		    return;
	     default:
		    if(c >= '0' && c <= '9') {
		    }
		    break;
	    }
    }
}

VOID
DebugDotCommand(
)
{
    DebugCommand();
    __asm xor eax, eax
    __asm retf
}

VOID
InitializeDebug(
)
{
    static char *pszHelp = ".K - Dump System Audio Driver data structures\n";
	
    __asm {
	_emit 0xcd
	_emit 0x20
	_emit 0xc1
	_emit 0x00
	_emit 0x01
	_emit 0x00
	jz exitlab

	mov bl, 'X'
	mov esi, offset DebugDotCommand
	mov edi, pszHelp
	mov eax, 0x70	// DS_RegisterDotCommand
	int 41h
exitlab:
    }
}

VOID
UninitializeDebug(
)
{
    __asm {
	_emit 0xcd
	_emit 0x20
	_emit 0xc1
	_emit 0x00
	_emit 0x01
	_emit 0x00
	jz exitlab

	mov bl, 'X'
	mov eax, 0x72 	// DS_DeRegisterDotCommand
	int 41h
exitlab:
    }
}

VOID __cdecl
dprintf(
    PSZ pszFmt,
    ULONG Arg1,
    ...
)
{
    __asm mov esi, [pszFmt]
    __asm lea edi, [Arg1]
    __asm mov eax, 0x73
    __asm int 41h
}

CHAR 
DebugGetCommandChar(
)
{
    __asm mov ax, 0x77		// get command char
    __asm mov bl, 1		// get char
    __asm int 41h
    __asm or ah, ah
    __asm jnz morechars
    __asm mov al, ah
morechars:
    __asm movzx eax, al
}


VOID
DumpSink
(
    PMIXER_SINK_INSTANCE    pMixerSink
)
{
    PSZ psz = "?";

    switch(pMixerSink->InterfaceId) {
        case KSINTERFACE_STANDARD_STREAMING:
	   psz = "STREAMING";
	   break;
        case KSINTERFACE_STANDARD_LOOPED_STREAMING:
	   psz = "LOOPED_STREAMING";
	   break;
	case KSINTERFACE_MEDIA_WAVE_QUEUED:
	   psz = "WAVE_QUEUED";
	   break;
    }
    dprintf("Sink[%x](%d-%d)::%d-ch, %d-bit, %d rate i: %s\n",
                (ULONG)pMixerSink,
                pMixerSink->SinkState,
                pMixerSink->SinkStatus,
                pMixerSink->WaveFormatEx.nChannels,
                pMixerSink->WaveFormatEx.wBitsPerSample,
                pMixerSink->WaveFormatEx.nSamplesPerSec,
		psz) ;
}


VOID
DumpSinkPinStatistics
(
    VOID
)
{
    PLIST_ENTRY            ple ;
    PMIXER_SOURCE_INSTANCE pMixerSource ;
    
    if ( gpFilterInstance ) {
        ple = gpFilterInstance->SourceConnectionList.Flink ;
        pMixerSource = (PMIXER_SOURCE_INSTANCE) CONTAINING_RECORD (ple,
                                                                MIXER_INSTHDR, 
                                                                NextInstance) ;
        dprintf("Number of pins = %d\n", pMixerSource->nSinkPins) ;
        dprintf("Number of Active pins = %d\n", gpFilterInstance->ActivePins) ;
        dprintf("Number of Paused pins = %d\n", gpFilterInstance->PausedPins) ;
    }
}

VOID
DumpSinkPins
(
    VOID
)
{
    PLIST_ENTRY            ple ;
    PMIXER_SINK_INSTANCE   pMixerSink ;
    
    if ( gpFilterInstance ) {
        ple = gpFilterInstance->SinkConnectionList.Flink ;
        while ( ple != &gpFilterInstance->SinkConnectionList ) {
        
            pMixerSink = (PMIXER_SINK_INSTANCE) CONTAINING_RECORD (ple,
                                                                MIXER_INSTHDR, 
                                                                NextInstance) ;
            DumpSink(pMixerSink) ;
            ple = pMixerSink->Header.NextInstance.Flink ;
        }
    }
}
VOID
DumpActiveSinkPins
(
    VOID
)
{
    PLIST_ENTRY            ple ;
    PMIXER_SINK_INSTANCE   pMixerSink ;
    
    if ( gpFilterInstance ) {
        ple = gpFilterInstance->ActiveSinkList.Flink ;
        while ( ple != &gpFilterInstance->ActiveSinkList ) {
        
            pMixerSink = (PMIXER_SINK_INSTANCE) CONTAINING_RECORD (ple,
                                                                MIXER_SINK_INSTANCE, 
                                                                ActiveQueue) ;
            DumpSink(pMixerSink) ;
            ple = pMixerSink->ActiveQueue.Flink ;
        }
    }
}
VOID
DumpSourcePinStatistics
(
    VOID
)
{
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\filters\kmixer\device.c ===
//---------------------------------------------------------------------------
//
//  Module:   device.c
//
//  Description:
//
//
//@@BEGIN_MSINTERNAL
//  Development Team:
//     S.Mohanraj
//
//  History:   Date       Author      Comment
//
//@@END_MSINTERNAL
//---------------------------------------------------------------------------
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1995-2000 Microsoft Corporation.  All Rights Reserved.
//
//---------------------------------------------------------------------------

#define IRPMJFUNCDESC
#define NO_REMAPPING_ALLOC

#include "common.h"
#include <ksguid.h>
#include "perf.h"

#ifdef TIME_BOMB
#include "..\..\timebomb\timebomb.c"
#endif

const WCHAR FilterTypeName[] = KSSTRING_Filter;

VOID
InitializeDebug(
);

VOID
UninitializeDebug(
);

KSDISPATCH_TABLE PinDispatchTable =
{
    PinDispatchIoControl,
    NULL,
    PinDispatchWrite,
    NULL,
    PinDispatchClose,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL
};

static const WCHAR DeviceTypeName[] = L"GLOBAL";

DEFINE_KSCREATE_DISPATCH_TABLE(CreateItems)
{
    DEFINE_KSCREATE_ITEM(
        FilterDispatchGlobalCreate,
        &FilterTypeName,
        NULL),

    DEFINE_KSCREATE_ITEM(
        FilterDispatchGlobalCreate,
        &DeviceTypeName,
	    NULL)
};

#ifdef USE_CAREFUL_ALLOCATIONS
LIST_ENTRY  gleMemoryHead;
ULONG   cbMemoryUsage = 0;
#endif

extern ULONG    gDisableMmx ;
#ifdef _X86_
extern  ULONG   gfMmxPresent ;
#endif

//---------------------------------------------------------------------------
//---------------------------------------------------------------------------

NTSTATUS
DispatchPnp(
    IN PDEVICE_OBJECT   pDeviceObject,
    IN PIRP             pIrp
)
{
    PIO_STACK_LOCATION pIrpStack;

    pIrpStack = IoGetCurrentIrpStackLocation( pIrp );

    switch(pIrpStack->MinorFunction) {

        case IRP_MN_QUERY_PNP_DEVICE_STATE:
            //
            // Mark the device as not disableable.
            //
            pIrp->IoStatus.Information |= PNP_DEVICE_NOT_DISABLEABLE;
            break;
    }
    return(KsDefaultDispatchPnp(pDeviceObject, pIrp));
}

VOID
DriverUnload(
    IN PDRIVER_OBJECT DriverObject
)
{
#ifdef DEBUG
    UninitializeDebug();
#endif
}

NTSTATUS DriverEntry
(
    IN PDRIVER_OBJECT    DriverObject,
    IN PUNICODE_STRING   usRegistryPathName
)
{
    KFLOATING_SAVE       FloatSave;
    NTSTATUS             Status;
    PIO_ERROR_LOG_PACKET ErrorLogEntry;

#ifdef TIME_BOMB
    if (HasEvaluationTimeExpired()) {
        return STATUS_EVALUATION_EXPIRATION;
    }
#endif

#ifdef USE_CAREFUL_ALLOCATIONS
    InitializeListHead ( &gleMemoryHead ) ;
#endif

    PerfSystemControlDispatch = KsDefaultForwardIrp;

    DriverObject->MajorFunction[IRP_MJ_PNP] = DispatchPnp;
    DriverObject->MajorFunction[IRP_MJ_POWER] = KsDefaultDispatchPower;
    DriverObject->MajorFunction[IRP_MJ_SYSTEM_CONTROL] = PerfWmiDispatch;
    DriverObject->DriverUnload = DriverUnload;
    DriverObject->DriverExtension->AddDevice = AddDevice;

    Status = SaveFloatState(&FloatSave);
    if (!NT_SUCCESS(Status)) {
        // The floating point processor is unusable.
        ErrorLogEntry = (PIO_ERROR_LOG_PACKET)
                    IoAllocateErrorLogEntry( DriverObject, (UCHAR) (ERROR_LOG_MAXIMUM_SIZE) );

        if (ErrorLogEntry == NULL) {
            return Status;
        }

        RtlZeroMemory(ErrorLogEntry, sizeof(IO_ERROR_LOG_PACKET));
        ErrorLogEntry->ErrorCode = IO_ERR_INTERNAL_ERROR;
        ErrorLogEntry->FinalStatus = Status;

        IoWriteErrorLogEntry( ErrorLogEntry );

        return Status;
    }
    RestoreFloatState(&FloatSave);

    //
    // Get all tunable parameters from registry into global vars
    //
    GetMixerSettingsFromRegistry() ;

    //
    // Set MmxPresent Flag
    //
#ifdef _X86_
    if ( gDisableMmx ) {
        gfMmxPresent = 0 ;
    }
    else {
        gfMmxPresent = IsMmxPresent() ;
    }
#endif

    KsSetMajorFunctionHandler(DriverObject, IRP_MJ_CREATE);
    KsSetMajorFunctionHandler(DriverObject, IRP_MJ_CLOSE);
    KsSetMajorFunctionHandler(DriverObject, IRP_MJ_DEVICE_CONTROL);
    KsSetMajorFunctionHandler(DriverObject, IRP_MJ_WRITE);

#ifdef DEBUG
    InitializeDebug();
#endif

    return STATUS_SUCCESS;

}

NTSTATUS
AddDevice(
    IN PDRIVER_OBJECT   DriverObject,
    IN PDEVICE_OBJECT   pdo
)
/*++

Routine Description:

    When a new device is detected, PnP calls this entry point with the
    new PhysicalDeviceObject (PDO). The driver creates an associated 
    FunctionalDeviceObject (FDO).

Arguments:

    DriverObject -
        Pointer to the driver object.

    PhysicalDeviceObject -
        Pointer to the new physical device object.

Return Values:

    STATUS_SUCCESS or an appropriate error condition.

--*/
{
    NTSTATUS            Status;
    PSOFTWARE_INSTANCE  pSoftwareInstance;
    UNICODE_STRING      usDeviceName;
    PDEVICE_OBJECT      fdo = NULL;

    //
    // The Software Bus Enumerator expects to establish links 
    // using this device name.
    //

    _DbgPrintF( DEBUGLVL_VERBOSE, ("AddDevice") );

    RtlInitUnicodeString( &usDeviceName, STR_DEVICENAME );
        
    Status = IoCreateDevice( 
      DriverObject, 
      sizeof( SOFTWARE_INSTANCE ),
      NULL,
      FILE_DEVICE_KS,
      0,
      FALSE,
      &fdo );

    if (!NT_SUCCESS( Status )) {
        _DbgPrintF( DEBUGLVL_VERBOSE, ("failed to create FDO: %08x", Status) );
        goto exit;
    }

    pSoftwareInstance = (PSOFTWARE_INSTANCE) fdo->DeviceExtension;

    Status = KsAllocateDeviceHeader(
      &pSoftwareInstance->DeviceHeader,
      SIZEOF_ARRAY( CreateItems ),
      (PKSOBJECT_CREATE_ITEM)CreateItems );
    
    if (!NT_SUCCESS( Status )) {
        _DbgPrintF( DEBUGLVL_VERBOSE, ("failed to create header: %08x", Status) );
        goto exit;
    }
    
    KsSetDevicePnpAndBaseObject(
      pSoftwareInstance->DeviceHeader,
      IoAttachDeviceToDeviceStack(fdo, pdo ),
      fdo );

    fdo->Flags |= DO_DIRECT_IO ;
    fdo->Flags |= DO_POWER_PAGABLE ;
    fdo->Flags &= ~DO_DEVICE_INITIALIZING;
exit:
    if(!NT_SUCCESS(Status) && fdo != NULL) {
        _DbgPrintF( DEBUGLVL_VERBOSE, ("removing fdo") );
        IoDeleteDevice( fdo );
    }

    return Status;
}

#ifdef USE_CAREFUL_ALLOCATIONS
PVOID 
AllocMem(
    IN POOL_TYPE PoolType,
    IN ULONG size,
    IN ULONG Tag
)
{
    PVOID pp;
    ASSERT(size != 0);
    size += sizeof(ULONG) + sizeof(LIST_ENTRY);
#ifdef REALTIME_THREAD
    pp = ExAllocatePoolWithTag(NonPagedPool, size, Tag);
#else
    pp = ExAllocatePoolWithTag(PoolType, size, Tag);
#endif
   if(pp == NULL) {
        _DbgPrintF( DEBUGLVL_VERBOSE, ("AllocMem Failed") ) ;
    } else {
	    RtlZeroMemory(pp, size);
	    cbMemoryUsage += size;
	    *((PULONG)(pp)) = size;
	    pp = ((PULONG)(pp)) + 1;
	    InsertHeadList(&gleMemoryHead, ((PLIST_ENTRY)(pp)));
	    pp = ((PLIST_ENTRY)(pp)) + 1;
    }

    return pp;
}

//
// Ignores NULL input pointers.
//

VOID 
FreeMem(
    IN PVOID p
)
{
    if(p != NULL) {
	    PLIST_ENTRY ple = ((PLIST_ENTRY)p) - 1;
	    PULONG pul = ((PULONG)ple) - 1;
	    RemoveEntryList(ple);
	    cbMemoryUsage -= *pul;
	    ple->Flink = NULL;
	    ple->Blink = NULL;
	    ExFreePool(pul);
    }
}

VOID
ValidateAccess(
    PVOID p
)
{
    BOOL   fValid;
    PLIST_ENTRY ple;
    PULONG pul;
        
    ple = gleMemoryHead.Flink ;
    fValid = FALSE;
    while ( ple != &gleMemoryHead ) {
        pul = ((PULONG)ple) - 1;
        if ((ULONG)((PBYTE)p - (PBYTE)pul) < (*pul)) {
            fValid = TRUE;
        }
        ple = ple->Flink ;
    }
    ASSERT(fValid);
}
#else
#ifdef REALTIME_THREAD
PVOID 
AllocMem(
    IN POOL_TYPE PoolType,
    IN ULONG size,
    IN ULONG Tag
)
{
#ifdef DEBUG

    if (RtThread()) {
        DbgBreakPoint();
    }

#endif
    return ExAllocatePoolWithTag(NonPagedPool, size, Tag);
}
#endif
#endif


#ifdef REALTIME_THREAD


NTSTATUS
MxWaitForSingleObject (
    IN PVOID Object,
    IN KWAIT_REASON WaitReason,
    IN KPROCESSOR_MODE WaitMode,
    IN BOOLEAN Alertable,
    IN PLARGE_INTEGER Timeout OPTIONAL
    )
{

    return KeWaitForSingleObject(Object, WaitReason, WaitMode, Alertable, Timeout);
    
}


LONG
MxReleaseMutex (
    IN PRKMUTEX Mutex,
    IN BOOLEAN Wait
    )
{

    return KeReleaseMutex(Mutex, Wait);

}



NTSTATUS
RtWaitForSingleObject (
    PFILTER_INSTANCE pFilterInstance,
    IN PVOID Object,
    IN KWAIT_REASON WaitReason,
    IN KPROCESSOR_MODE WaitMode,
    IN BOOLEAN Alertable,
    IN PLARGE_INTEGER Timeout OPTIONAL
    )
{
    NTSTATUS status;

    status = KeWaitForSingleObject(Object, WaitReason, WaitMode, Alertable, Timeout);
    if (pFilterInstance->RealTimeThread && Object == (PVOID)(&pFilterInstance->ControlMutex)) {

        KIRQL OldIrql;
        PVOID Address;

        Address=_ReturnAddress();

        // Spew to the NT Kern buffer so we can figure out who is holding off the
        // mix and why.

        //DbgPrint("'RtWait: %p\r\n", Address);

        // We must pause the rt mix, too.
        KeAcquireSpinLock ( &pFilterInstance->MixSpinLock, &OldIrql ) ;
        pFilterInstance->fPauseMix++;
        KeReleaseSpinLock ( &pFilterInstance->MixSpinLock, OldIrql ) ;
    }
    
    return status;

}



LONG
RtReleaseMutex (
    PFILTER_INSTANCE pFilterInstance,
    IN PRKMUTEX Mutex,
    IN BOOLEAN Wait
    )
{

    if (pFilterInstance->RealTimeThread && Mutex == (PRKMUTEX)(&pFilterInstance->ControlMutex)) {

        KIRQL OldIrql;
        PVOID Address;

        Address=_ReturnAddress();

        // Spew to the NT Kern buffer so we can figure out who is holding off the
        // mix and why.

        //DbgPrint("'RtRelease: %p\r\n", Address);

        // We must resume the rt mix, too
        KeAcquireSpinLock ( &pFilterInstance->MixSpinLock, &OldIrql ) ;
        pFilterInstance->fPauseMix--;
        KeReleaseSpinLock ( &pFilterInstance->MixSpinLock, OldIrql ) ;
    }

    return KeReleaseMutex(Mutex, Wait);

}


#endif

//---------------------------------------------------------------------------
//  End of File: device.c
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\filters\kmixer\dxcrt.c ===
//---------------------------------------------------------------------------
//
//  Module:   dxcrt.c
//
//  Description:
//
//
//@@BEGIN_MSINTERNAL
//  Development Team:
//     S.Mohanraj
//
//  History:   Date       Author      Comment
//
//@@END_MSINTERNAL
//---------------------------------------------------------------------------
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1995-2000 Microsoft Corporation.  All Rights Reserved.
//
//---------------------------------------------------------------------------

#include <math.h>

double _stdcall pow2( double x )
{
    return pow(2.0,x);
}

double _stdcall fylog2x( double y, double x )
{
    return( y*log(x)/log(2.0) );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\filters\kmixer\fir.h ===
//---------------------------------------------------------------------------
//
//  Module:   fir.h
//
//  Description:
//
//
//@@BEGIN_MSINTERNAL
//  Development Team:
//     Jeff Taylor
//
//  History:   Date       Author      Comment
//
//  To Do:     Date       Author      Comment
//
//@@END_MSINTERNAL
//
//  Copyright (c) 1996-2000 Microsoft Corporation.  All Rights Reserved.
//
//---------------------------------------------------------------------------

//===========================================================================
//===========================================================================

#define FILTER_SIZE_NONE        320
#define FILTER_SIZE_LOW			320
#define FILTER_SIZE_BASIC		3360
#define FILTER_SIZE_ADVANCED	9600

FLOAT	DuplicatingFilter[] ;
FLOAT	LowQualityFilter[] ;
FLOAT	BasicFilter[] ;
FLOAT	AdvancedFilter[] ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\filters\kmixer\flocal.inl ===
/*++

    Copyright (c) 1998-2000 Microsoft Corporation.  All Rights Reserved.

Module Name:

    flocal.inl

Abstract:

    This is the in-line functions 
    for the floating point, IIR 3D localizer 

Author:

    Jay Stokes (jstokes) 22-Apr-1998

--*/

#if !defined(FLOATLOCALIZER_INLINE)
#define FLOATLOCALIZER_INLINE
#pragma once

// ---------------------------------------------------------------------------
// Make sure inlines are out-of-line in debug version

/*
#if !defined(DEBUG)
#define INLINE __forceinline
#else
#define INLINE
#endif

// ---------------------------------------------------------------------------
// Constants

const enum EFilterMethod CeFloatFilterMethodInit(tagCanonical);

// ---------------------------------------------------------------------------
// Floating-point localizer

// Default constructor
INLINE FloatLocalizer::FloatLocalizer()
{
	STATUS status;
	InitData(CeFloatFilterMethodInit, &status);
	ASSERT(status == STATUS_OK);
}

// "Partial" constructor
INLINE FloatLocalizer::FloatLocalizer(const EFilterMethod CeFilterMethod, STATUS* const CpStatus)
{
	ASSERT(CeFilterMethod >= 0 && CeFilterMethod < efiltermethodCount);
	CHECK_POINTER(CpStatus);

	InitData(CeFilterMethod, CpStatus);
}
*/

#endif

// End of FLOATLOCALIZER.INL
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\filters\kmixer\flocal.c ===
/*++

    Copyright (c) 1998-2000 Microsoft Corporation.  All Rights Reserved.

Module Name:

    flocal.c

Abstract:

    This module implements floating point, IIR 3D localizer 

Author:

    Jay Stokes (jstokes) 22-Apr-1998

--*/

// Project-specific INCLUDEs
#include "common.h"

// ---------------------------------------------------------------------------
// Constants

#define CoeffsInit 0.0f


// ---------------------------------------------------------------------------
// Floating-point localizer

// "Regular" constructor
NTSTATUS FloatLocalizerCreate
(
    PFLOAT_LOCALIZER*  Localizer
) 
{
    NTSTATUS Status = STATUS_SUCCESS;

    *Localizer = ExAllocatePoolWithTag
                 ( 
                     PagedPool, 
                     sizeof(FLOAT_LOCALIZER), 
                     'XIMK' 
                 );

    if(*Localizer)
    {
        RtlZeroMemory( *Localizer, sizeof(FLOAT_LOCALIZER) );
    } else {
        Status = STATUS_INSUFFICIENT_RESOURCES;
    }

    return Status;
}

// Destructor
VOID FloatLocalizerDestroy
(
    PFLOAT_LOCALIZER Localizer
)
{
    UINT Filter;

    if (Localizer) { 
        // Free resources
        if (Localizer->TempFloatBuffer) {
            ExFreePool(Localizer->TempFloatBuffer);
            Localizer->TempFloatBuffer = NULL;
        }
        FloatLocalizerFreeBufferMemory(Localizer);
        for (Filter=0; Filter<efilterCount; ++Filter) {
            if (Localizer->OverlapBuffer[Filter]) {
                ExFreePool(Localizer->OverlapBuffer[Filter]);
                Localizer->OverlapBuffer[Filter] = NULL;
            }
            RfIirDestroy(Localizer->Iir[Filter]);
            Localizer->Iir[Filter] = NULL;
        }

        ExFreePool(Localizer);
    }

}

// Localize
VOID FloatLocalizerLocalize
(
    PMIXER_SINK_INSTANCE    pMixerSink,
    PFLOAT              InData, 
    PFLOAT              OutData, 
    UINT                NumSamples,
    BOOL                MixOutput
)
{
    PFLOAT_LOCALIZER    Localizer;
    UINT        Filter;
    PFLOAT      OutLeft;
    PFLOAT      OutRight;
    FLOAT       FilterLeft;
    FLOAT       FilterRight;
    FLOAT       Sum;
    FLOAT       Difference;
    UINT        ChannelOffset;
    FLOAT       FilterOut;
    UINT        st;
    UINT        OutputOverlapLength;
    FLOAT       NumOverlapSamplesFactor;
    EChannel    eLeft;
    EChannel    eRight;
    FLOAT       CrossFadeFactor;
    FLOAT       InverseCrossFadeFactor;
    FLOAT       TempSum;
    FLOAT       TempDifference;
#if defined(LOG_TO_FILE) && defined(LOG_HRTF_DATA)
    PFILTER_INSTANCE    pFilterInstance ;
#endif

    ASSERT(InData);
    ASSERT(OutData);
    ASSERT(NumSamples > 0);

    Localizer = pMixerSink->pFloatLocalizer;

    // Mute if Localizer is bad
    if(!Localizer) {
        for (st=0; st<2*NumSamples; ++st) {
            OutData[st] = 0.0f;
        }
        return;
    }
#ifndef REALTIME_THREAD
    // Reallocate (dynamically grow) memory, if necessary
    if (NumSamples > Localizer->PreviousNumSamples 
        || !Localizer->FilterOut[tagDelta]
        || !Localizer->FilterOut[tagSigma] ) {
        
        Localizer->PreviousNumSamples = NumSamples;
        FloatLocalizerFreeBufferMemory(Localizer);

        Localizer->FilterOut[tagSigma] = 
            ExAllocatePoolWithTag
            (
                PagedPool, 
                NumSamples*sizeof(FLOAT), 
                'XIMK'
            );


        Localizer->FilterOut[tagDelta] = 
            ExAllocatePoolWithTag
            (
                PagedPool, 
                NumSamples*sizeof(FLOAT), 
                'XIMK'
            );

        if(!Localizer->FilterOut[tagDelta] ||
           !Localizer->FilterOut[tagSigma] ) {

            if (Localizer->FilterOut[tagDelta] ) {
                ExFreePool(Localizer->FilterOut[tagDelta]);
                Localizer->FilterOut[tagDelta] = NULL; 
            }    

            if (Localizer->FilterOut[tagSigma] ) {
                ExFreePool(Localizer->FilterOut[tagSigma]);
                Localizer->FilterOut[tagSigma] = NULL; 
            }


            for (st=0; st<2*NumSamples; ++st) {
                OutData[st] = 0.0f;
            }

            return;
        }

    }
#else
        if(NumSamples > Localizer->PreviousNumSamples ||
           !Localizer->FilterOut[tagDelta] ||
           !Localizer->FilterOut[tagSigma] ) {

            for (st=0; st<2*NumSamples; ++st) {
                OutData[st] = 0.0f;
            }

            return;
        }
#endif

    // Perform floating-point filtering
    for (Filter=0; Filter<efilterCount; ++Filter) {
        ASSERT(Localizer->Iir[Filter]);
        FloatLocalizerFilterOverlap
        (
            Localizer, 
            Filter,
            InData, 
            Localizer->FilterOut[Filter], 
            NumSamples
        );
    }

    // Calculate overlap length
    if (Localizer->CrossFadeOutput) {
        // Calculate overlap length
        if (Localizer->OutputOverlapLength > NumSamples)
            OutputOverlapLength = NumSamples;
        else
            OutputOverlapLength = Localizer->OutputOverlapLength;
        NumOverlapSamplesFactor = 1.0f / (FLOAT)(OutputOverlapLength - 1);
    }
                                                                             
    // Process both (sigma and delta) filters
    // Swap channels if azimuth is negative
    if (TRUE == Localizer->SwapChannels) {
        eLeft  = tagRight;
        eRight = tagLeft;
    } else {
        eLeft  = tagLeft;
        eRight = tagRight;
    }

    
    // Non-zero angle: Process delta filter
    OutLeft = &OutData[eLeft];
    OutRight = &OutData[eRight];

    for (st=0; st<NumSamples; ++st) {
        // Calculate sum and difference
        ChannelOffset = (st * echannelCount);
        FilterLeft = *(Localizer->FilterOut[tagLeft] + st);
        FilterRight = *(Localizer->FilterOut[tagRight] + st);

        Sum = FilterRight + FilterLeft;
        Difference = FilterRight - FilterLeft;

#if DETECT_HRTF_SATURATION
        // Saturate sum to maximum
        if (Sum > MaxSaturation) {
            Sum = MaxSaturation;
            _DbgPrintF
            (
                DEBUGLVL_VERBOSE,
                ("Sum exceeded maximum saturation value\n")
            );
        }
        
        // Saturate sum to minimum
        if (Sum < MinSaturation) {
            Sum = MinSaturation;
            _DbgPrintF
            (
                DEBUGLVL_VERBOSE,
                ("Sum exceeded minimum saturation value\n")
            );
        }

        // Saturate difference to maximum
        if (Difference > MaxSaturation) {
            Difference = MaxSaturation;
            _DbgPrintF
            (
                DEBUGLVL_VERBOSE,
                ("Difference exceeded maximum saturation value\n")
            );
        }
        
        // Saturate difference to minimum
        if (Difference < MinSaturation) {
            Difference = MinSaturation;
            _DbgPrintF
            (
                DEBUGLVL_VERBOSE,
                ("Difference exceeded minimum saturation value\n")
            );
        }
#endif // DETECT_HRTF_SATURATION

        // Check for zero azimuth transition
        if (Localizer->CrossFadeOutput && st<OutputOverlapLength) {
            // Cross-fade left/right channel switch transition
            // Calculate cross-fade factor
            CrossFadeFactor = (FLOAT)(st * NumOverlapSamplesFactor);
            ASSERT(CrossFadeFactor >= 0.0f && CrossFadeFactor <= 1.0f);
            InverseCrossFadeFactor = 1.0f - CrossFadeFactor;
            ASSERT(InverseCrossFadeFactor >= 0.0f && InverseCrossFadeFactor <= 1.0f);

            // Calculate cross-faded sample
            TempDifference = Difference;
            TempSum = Sum;
            Difference = TempSum * InverseCrossFadeFactor + TempDifference * CrossFadeFactor;
            Sum = TempDifference * InverseCrossFadeFactor + TempSum * CrossFadeFactor;

        }

        // Assign sum and difference
        if (!MixOutput) {
            OutLeft[ChannelOffset] = Difference;
            OutRight[ChannelOffset] = Sum;
        } else {
            OutLeft[ChannelOffset] += Difference;
            OutRight[ChannelOffset] += Sum;
        }
    }

    Localizer->CrossFadeOutput = FALSE;  // Make sure we don't cross fade output a second time

#if defined(LOG_TO_FILE) && defined(LOG_HRTF_DATA)
    pFilterInstance = pMixerSink->Header.pFilterFileObject->FsContext ;
    FileIoRoutine (pFilterInstance,
                   OutData,
                   2*NumSamples*sizeof(FLOAT));
#endif

}

// Initialize data
NTSTATUS FloatLocalizerInitData
(
    PFLOAT_LOCALIZER            Localizer,
    KSDS3D_HRTF_FILTER_METHOD   FilterMethod,
    UINT                        MaxSize,
    KSDS3D_HRTF_FILTER_QUALITY  Quality,
    UINT                        FilterMuteLength,
    UINT                        FilterOverlapLength,
    UINT                        OutputOverlapLength
)
{
    UINT        Filter;
    NTSTATUS    Status;

    ASSERT(FilterMethod >= 0 && FilterMethod < KSDS3D_FILTER_METHOD_COUNT);

    FloatLocalizerFreeBufferMemory(Localizer);
        
    Localizer->PreviousNumSamples = 0;
    Localizer->FirstUpdate = TRUE;
    Localizer->OutputOverlapLength = OutputOverlapLength;

    Status = FloatLocalizerSetTransitionBufferLength
             ( 
                 Localizer, 
                 FilterMuteLength,
                 FilterOverlapLength 
             ); 
        

    if(NT_SUCCESS(Status))
    {
        for (Filter=0; Filter<efilterCount && NT_SUCCESS(Status); ++Filter) {
            // Check for filter method
            switch (FilterMethod) {
                case DIRECT_FORM:
                    if(Localizer->Iir[Filter])
                        RfIirDestroy((Localizer->Iir[Filter]));
                        
                    // Direct form is supported
                    Status = RfIirCreate(&(Localizer->Iir[Filter]));
                    if (NT_SUCCESS(Status)) {
                        Status = RfIirInitData(Localizer->Iir[Filter], MaxSize, MaxSize, Quality);
                    } 
                break;
    
                default:
                    // All others are not supported
                    Localizer->Iir[Filter] = NULL;
                    Status = STATUS_INVALID_PARAMETER;
                    ASSERT(0);
                break;
            }
    
            Localizer->FilterOut[Filter] = NULL;
        }
    }

    // If failure, free other memory.
    if (!NT_SUCCESS(Status)) {
        for (Filter=0; Filter<efilterCount; ++Filter) {
            if(Localizer->OverlapBuffer[Filter]) {
                ExFreePool(Localizer->OverlapBuffer[Filter]);
                Localizer->OverlapBuffer[Filter] = NULL;
            }
            RfIirDestroy(Localizer->Iir[Filter]);
            Localizer->Iir[Filter] = NULL;
        }
    }

    return Status;
}

// Update Filter Coefficients 
NTSTATUS FloatLocalizerUpdateCoeffs
(
    PFLOAT_LOCALIZER    Localizer,
    UINT                NumSigmaCoeffs,
    PFLOAT              pSigmaCoeffs,
    UINT                NumDeltaCoeffs,
    PFLOAT              pDeltaCoeffs,
    BOOL                SwapChannels,
    BOOL                ZeroAzimuth,
    BOOL                CrossFadeOutput
)
{
    BOOL        UpdateFlag;
    NTSTATUS    Status = STATUS_SUCCESS;
    FLOAT       Zero = 0.0f;

    Localizer->SwapChannels = SwapChannels;
    Localizer->ZeroAzimuth = ZeroAzimuth;
    Localizer->CrossFadeOutput = CrossFadeOutput;

    if(!Localizer->FirstUpdate)
    {
        UpdateFlag = TRUE;
    }
    else
    {
        UpdateFlag = FALSE;
        Localizer->FirstUpdate = FALSE;
    }

    Status = RfIirSetCoeffs(Localizer->Iir[tagSigma], pSigmaCoeffs, NumSigmaCoeffs,UpdateFlag);
    if (NT_SUCCESS(Status)) {
        if (!ZeroAzimuth) {
            Status = RfIirSetCoeffs(Localizer->Iir[tagDelta], pDeltaCoeffs, NumDeltaCoeffs,UpdateFlag);
        } else {
            Status = RfIirSetCoeffs(Localizer->Iir[tagDelta], &Zero, 1,UpdateFlag);
        }
    }

    return Status;
}


// Free buffer memory
VOID FloatLocalizerFreeBufferMemory
(
    PFLOAT_LOCALIZER Localizer
)
{
    UINT Filter;

    for (Filter=0; Filter<efilterCount; ++Filter) {
        if (Localizer->FilterOut[Filter]) {
            ExFreePool(Localizer->FilterOut[Filter]);
            Localizer->FilterOut[Filter] = NULL;
        }
    }
}

// Set transition buffer length
NTSTATUS FloatLocalizerSetTransitionBufferLength
(
    PFLOAT_LOCALIZER Localizer,
    UINT MuteLength,
    UINT OverlapLength
)
{
    NTSTATUS Status;

    ASSERT(OverlapLength > 0);
    ASSERT(MuteLength > 0);
    ASSERT(OverlapLength > MuteLength);
    
    Status = FloatLocalizerSetOverlapLength(Localizer,OverlapLength);
    if(NT_SUCCESS(Status)) {
        Localizer->FilterMuteLength = MuteLength;
    }

    return(Status);
}

// Set overlap buffer length
NTSTATUS FloatLocalizerSetOverlapLength
(
    PFLOAT_LOCALIZER Localizer,
    UINT OverlapLength
)
{
    NTSTATUS Status = STATUS_SUCCESS;
    PFLOAT SigmaOverlapBuffer;
    PFLOAT DeltaOverlapBuffer;

    ASSERT(OverlapLength > 0);

    // Grow overlap buffer if necessary
    if (!Localizer->OverlapBuffer[tagSigma] ||
        !Localizer->OverlapBuffer[tagDelta] ||
        OverlapLength > Localizer->OutputOverlapLength) {

        SigmaOverlapBuffer = 
            ExAllocatePoolWithTag
            (
                PagedPool, 
                OverlapLength*sizeof(FLOAT), 
                'XIMK'
            );

        if(!SigmaOverlapBuffer) {
            Status = STATUS_INSUFFICIENT_RESOURCES;
        }

        if(NT_SUCCESS(Status)) {
            DeltaOverlapBuffer = 
                ExAllocatePoolWithTag
                (
                    PagedPool, 
                    OverlapLength*sizeof(FLOAT), 
                    'XIMK'
                );

            if(!DeltaOverlapBuffer) {
                ExFreePool(SigmaOverlapBuffer);
                SigmaOverlapBuffer = NULL;
                Status = STATUS_INSUFFICIENT_RESOURCES;
            }
        }

        if(NT_SUCCESS(Status)) {
            if(Localizer->OverlapBuffer[tagSigma]) {
                ExFreePool(Localizer->OverlapBuffer[tagSigma]);
            }
            Localizer->OverlapBuffer[tagSigma] = SigmaOverlapBuffer;

            if(Localizer->OverlapBuffer[tagDelta]) {
                ExFreePool(Localizer->OverlapBuffer[tagDelta]);
            }
            Localizer->OverlapBuffer[tagDelta] = DeltaOverlapBuffer;

            Localizer->FilterOverlapLength = OverlapLength;
        }

    }

    ASSERT(Localizer->OverlapBuffer[tagSigma]);
    ASSERT(Localizer->OverlapBuffer[tagDelta]);

    return(Status);

} 

// Filter a block of samples
VOID FloatLocalizerFilterOverlap
(
    PFLOAT_LOCALIZER Localizer,
    UINT   Filter,
    PFLOAT InData, 
    PFLOAT OutData, 
    UINT NumSamples
)
{
    FLOAT_IIR_STATE IirStateNew;
    PRFIIR Iir;
    UINT NumOverlapSamples;
    PFLOAT OverlapBuffer;
    UINT Old;
    UINT ui;
    FLOAT NumOverlapSamplesFactor;
    UINT FilterMuteLength;
    UINT Lap;
    UINT Dat;
    UINT st;
    FLOAT CrossFadeFactor;

    ASSERT(InData);
    ASSERT(OutData);

    Iir = Localizer->Iir[Filter];
    OverlapBuffer = Localizer->OverlapBuffer[Filter];

    ASSERT(Iir);
    ASSERT(OverlapBuffer);

    // Process overlap, if necessary
    if (TRUE == Iir->DoOverlap) {
        // Save current (i.e. new) filter state (with the new coefficients), 
        // don't copy circular vector because it's all zeros anyway
        RfIirGetAllState(Iir, &IirStateNew, FALSE);

        // Reset old filter state, including circular vector
        RfIirSetState(Iir, Iir->IirStateOld, TRUE);

        // Determine size of overlap buffer
        if (NumSamples >= Localizer->FilterOverlapLength)
            NumOverlapSamples = Localizer->FilterOverlapLength;            
        else
            NumOverlapSamples = NumSamples;
        
        // Filter overlap buffer
        Iir->FunctionFilter(Iir, InData, OverlapBuffer, NumOverlapSamples);

        // Initialize the filter's tap delay line
        RfIirInitTapDelayLine(&IirStateNew, InData[0]);
        
        // Set back to current (i.e. new) filter state 
        // with circular vector because we initialize it explicitly
        RfIirSetState(Iir, &IirStateNew, TRUE);

    }

    // Filter "real" data
    Iir->FunctionFilter(Iir, InData, OutData, NumSamples);

    // Process overlap buffer
    if (Iir->DoOverlap == TRUE) {
        // Clamp length down
        ASSERT(Localizer->FilterMuteLength > 0);
        ASSERT(Localizer->FilterMuteLength < Localizer->FilterOverlapLength);

        if (Localizer->FilterMuteLength > NumOverlapSamples)
            FilterMuteLength = NumOverlapSamples;
        else
            FilterMuteLength = Localizer->FilterMuteLength;

        // Copy data from old filter for transient mute length
        RtlCopyBytes(OutData, OverlapBuffer, FilterMuteLength*sizeof(FLOAT));
        
        if (NumOverlapSamples > FilterMuteLength) {
            // Cross-fade into new filter data for rest of buffer
            NumOverlapSamplesFactor = 1.0f / 
                    (FLOAT)(NumOverlapSamples - FilterMuteLength - 1);
            for (st=FilterMuteLength; st<NumOverlapSamples; ++st) {
                CrossFadeFactor = (FLOAT)((st - FilterMuteLength) 
                                  * NumOverlapSamplesFactor);
                ASSERT(CrossFadeFactor >= 0.0f && CrossFadeFactor <= 1.0f);
                OutData[st] = CrossFadeFactor * OutData[st] 
                            + (1.0f - CrossFadeFactor) * OverlapBuffer[st];
            }
        }

        // Reset overlap flag
        Iir->DoOverlap = FALSE;
    }
 
}

// End of FLOATLOCALIZER.CPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\filters\kmixer\filt3d.c ===
//--------------------------------------------------------------------------;
//
//  File: filter.c
//
//  Copyright (c) 1996-2000 Microsoft Corporation.  All Rights Reserved.
//
//  Abstract:
//
//	3D filter functions called by the mixer.  This code is built in ring 3
// 	and ring 0.
//
//  History:
//	07/09/96    DannyMi	created 
//
//--------------------------------------------------------------------------;

#include "common.h"

// use the lightning-quick neato Itd3dFilterSampleAsm or the dog slow Itd3dFilterSampleC?
#ifdef _X86_
#define Itd3dFilterSample Itd3dFilterSampleC
#else
#define Itd3dFilterSample Itd3dFilterSampleC
#endif



// don't ask
BYTE _fltused;


//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\

// This is the 3D mixing code.  Grace gives us a sample that it was going to
// play, and we return a different number (that sample with 3D effects) which
// Grace will use instead.

// We cache a whole bunch of samples that she has sent us, because we are
// premixing some sound that may get thrown away, and we need be able to back
// up and find out what samples we were given BEFORE the point we rewind to.
// We also need to know some of the 3D parameters we were using at the point
// we rewind to, because if we don't revert to using the same parameters as
// we were the first time through, you will hear that as an audible glitch.

// But we are saving a sample cache of 10K samples or so, and to save the 3D
// state for each sample would take about 1Meg per 3D sound!  There's no way
// we can afford to do that.  So we save our state every 128 samples, and have
// a private agreement with Grace that she will always rewind us on 128 sample
// boundaries.

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\

//
// Here is a simple float to long conversion that has unpredictable rounding
//
__forceinline LONG FloatToLongRX(float f)
{
    LONG l;

#ifdef _X86_
    _asm fld f;
    _asm fistp l;
#else
    l = (long) f;
#endif

    return l;
}


// We will need to remember at least cSamples in our cache, because that is
// how much we may be asked to rewind.  The actual cache size we use must be
// a power of 2 for the math to work in FirNextSample
//
NTSTATUS Itd3dFilterPrepare(PITDCONTEXT pItd, int cSamples)
{
    _DbgPrintF(DEBUGLVL_VERBOSE, ("Itd3dFilterPrepare: this 3D channel needs a %d sample cache", cSamples));

    // we already have a cache big enough
    if (pItd->cSampleCache && pItd->cSampleCache >= cSamples) {
        _DbgPrintF(DEBUGLVL_VERBOSE, ("Our current cache of %d is big enough", pItd->cSampleCache));
	    return STATUS_SUCCESS;
    }

    if (pItd->pSampleCache)
    {
    	ExFreePool(pItd->pSampleCache);
        pItd->pSampleCache = NULL;
    }

    // !!! is this necessary?
    // find the next higher power of 2
    pItd->cSampleCache = 1;
    cSamples -= 1;
    while (cSamples >= 1) {
	    cSamples >>= 1;
    	pItd->cSampleCache <<= 1;
    }

    // if we're not at least this big, we can't do our left-right delay and low
    // pass filter
    if (pItd->cSampleCache < CACHE_MINSIZE)
    	pItd->cSampleCache = CACHE_MINSIZE;

    pItd->pSampleCache = (PLONG) ExAllocatePoolWithTag( PagedPool, pItd->cSampleCache * sizeof(LONG), 'XIMK' );
    if (pItd->pSampleCache == NULL) {
	    _DbgPrintF(DEBUGLVL_VERBOSE, ("**** CAN'T ALLOC MEM FOR 3D cache - NO 3D EFFECTS!"));
	    pItd->cSampleCache = 0;
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    // We need 1/128th as many entries for saving our state
    pItd->cStateCache = pItd->cSampleCache / MIXER_REWINDGRANULARITY + 1;
    pItd->pStateCache = (PFIRSTATE) ExAllocatePoolWithTag( PagedPool, pItd->cStateCache * sizeof(FIRSTATE), 'XIMK' );
    if (pItd->pStateCache == NULL) {
    	_DbgPrintF(DEBUGLVL_VERBOSE, ("**** CAN'T ALLOC MEM FOR 3D cache - NO 3D EFFECTS!"));
    	pItd->cStateCache = 0;
    	pItd->cSampleCache = 0;
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    _DbgPrintF(DEBUGLVL_VERBOSE, ("Using a %d sample and %d state cache", pItd->cSampleCache, pItd->cStateCache));

    return STATUS_SUCCESS;
}


// free our cache stuff
//
void Itd3dFilterUnprepare(PITDCONTEXT pItd)
{
    _DbgPrintF(DEBUGLVL_VERBOSE, ("Itd3dFilterUnprepare:"));
    if (pItd->pSampleCache)
    {
    	ExFreePool(pItd->pSampleCache);
        pItd->pSampleCache = NULL;
    }
    if (pItd->pStateCache)
    {
    	ExFreePool(pItd->pStateCache);
        pItd->pStateCache = NULL;
    }
    pItd->cSampleCache = 0;
    pItd->cStateCache = 0;
}

// clear our filter of cached samples - we're starting to play
//
void Itd3dFilterClear(PITDCONTEXT pItd)
{
    _DbgPrintF(DEBUGLVL_VERBOSE, ("Itd3dFilterClear:"));

	RtlZeroMemory(pItd->pSampleCache, pItd->cSampleCache * sizeof(LONG));
	RtlZeroMemory(pItd->pStateCache, pItd->cStateCache * sizeof(FIRSTATE));
    pItd->iCurSample = 0;

    // clearing is a time to save our first state information.
    // !!! is this right?
    pItd->pStateCache[0].LastDryAttenuation = pItd->LastDryAttenuation;
    pItd->pStateCache[0].LastWetAttenuation = pItd->LastWetAttenuation;
#ifdef SMOOTH_ITD
    pItd->pStateCache[0].iLastDelay = pItd->iLastDelay;
#endif
    if (pItd->cStateCache > 1)
        pItd->iCurState = 1;	// next time we save it'll be at location 1
    pItd->iStateTick = 0;	// have seen no samples since saving

    return;
}

// Before we mix 1000 (or so) 3D samples, we call this function to prepare
// to mix the next batch.  The only thing it has to worry about is our
// volume smoothing.
// We are currently using Last***Attenuation and want to get to
// Total***Attenuation. Instead of figuring out sample by sample how much
// closer to move each sample (too expensive) we figure out right now how
// much we will move closer and do that for every sample in this batch.  But
// the danger of extracting that test to this level is that maybe we will
// go too far and actually overshoot Total***Attenation, causing possible
// clipping, or oscillating if we later try to correct it, and over-correct.
// If we are going to overshoot, we will recalculate how much to move each    
// sample such that we will end up at our target at the end of this batch of
// samples. (Or you can compile it to be lazy and give up when it's close).
void Itd3dFilterChunkUpdate(PITDCONTEXT pItd, int cSamples)
{
    D3DVALUE attRatio, c, w, d;

    // Due to rounding error, we'll take forever to get exactly to where
    // we want to be, so close counts.  If we don't snap ourselves to where
    // we want to be, we could clip.
    d = pItd->TotalDryAttenuation - pItd->LastDryAttenuation;
    w = pItd->TotalWetAttenuation - pItd->LastWetAttenuation;
    if (d && d > -.0001f && d < .0001f) {
    	pItd->LastDryAttenuation = pItd->TotalDryAttenuation;
    }
    if (w && w > -.0001f && w < .0001f) {
	    pItd->LastWetAttenuation = pItd->TotalWetAttenuation;
    }

    // Dry attenuation wants to be higher than it is
    if (pItd->TotalDryAttenuation > pItd->LastDryAttenuation) {
    	// or we may never get anywhere
    	if (pItd->LastDryAttenuation == 0.f)
    	    pItd->LastDryAttenuation = .0001f; // small enough not to click
    	// after gaining in volume throughout this entire range of samples
    	// we will end up going too high!
     	// VolSmoothScale is just 2^(8/f), so each sample goes up 
    	// 2^(8/f), so n samples goes up (2^(8/f))^n or 2^(8n/f)
    	attRatio = pItd->TotalDryAttenuation / pItd->LastDryAttenuation;
    	if (pow2(8. * cSamples / pItd->iSmoothFreq) > attRatio) {
#if 1
         // calculate what value besides 8 to use to end up at our
    	    // target after cSamples multiplies
    	    c = (D3DVALUE)fylog2x((double)pItd->iSmoothFreq / cSamples,
    		attRatio);
    	    pItd->VolSmoothScaleDry = (D3DVALUE)pow2(c / pItd->iSmoothFreq);
#else
    	    // decide we're happy where we are.
         // we will never get to our real destination
    	    pItd->VolSmoothScaleDry = 1.f;
    	    pItd->TotalDryAttenuation = pItd->LastDryAttenuation;
#endif
    	} else {
    	    // This is the value to multiply by every time
    	    pItd->VolSmoothScaleDry = pItd->VolSmoothScale;
    	}

        // Dry attenuation wants to be less than it is
    } else if (pItd->TotalDryAttenuation < pItd->LastDryAttenuation) {

    	// after lowering the volume throughout this entire range of samples
    	// we will end up going too low!  going down from Last to Total is
    	// the same as going up from Total to Last
     	// VolSmoothScale is just 2^(8/f), so each sample goes up 
    	// 2^(8/f), so n samples goes up (2^(8/f))^n or 2^(8n/f)
    	attRatio = pItd->TotalDryAttenuation ?
			pItd->LastDryAttenuation / pItd->TotalDryAttenuation :
 		999999;
    	if (pow2(8. * cSamples / pItd->iSmoothFreq) > attRatio) {
#if 1
    	    // calculate what value besides 8 to use to end up at our
    	    // target after cSamples multiplies
    	    c = (D3DVALUE)fylog2x((double)pItd->iSmoothFreq / cSamples,
							attRatio);
    	    pItd->VolSmoothScaleDry = 1.f / (D3DVALUE)pow2(c / pItd->iSmoothFreq);
#else
    	    // decide we're happy where we are.
    	    // we will never get to our real destination
    	    pItd->VolSmoothScaleDry = 1.f;
    	    pItd->TotalDryAttenuation = pItd->LastDryAttenuation;
#endif
    	} else {
    	    // This is the value to multiply by every time
    	    pItd->VolSmoothScaleDry = pItd->VolSmoothScaleRecip;
    	}
    } else {
    	// We're already where we want to be
    	pItd->VolSmoothScaleDry = 1.f;
    }
	

    // Wet attenuation wants to be higher than it is
    if (pItd->TotalWetAttenuation > pItd->LastWetAttenuation) {
    	// or we may never get anywhere
    	if (pItd->LastWetAttenuation == 0.f)
    	    pItd->LastWetAttenuation = .0001f; // small enough not to click
    	// after gaining in volume throughout this entire range of samples
    	// we will end up going too high!
     	// VolSmoothScale is just 2^(8/f), so each sample goes up 
    	// 2^(8/f), so n samples goes up (2^(8/f))^n or 2^(8n/f)
    	attRatio = pItd->TotalWetAttenuation / pItd->LastWetAttenuation;
    	if (pow2(8. * cSamples / pItd->iSmoothFreq) > attRatio) {
#if 1
    	    // calculate what value besides 8 to use to end up at our
    	    // target after cSamples multiplies
    	    c = (D3DVALUE)fylog2x((double)pItd->iSmoothFreq / cSamples,
            							attRatio);
    	    pItd->VolSmoothScaleWet = (D3DVALUE)pow2(c / pItd->iSmoothFreq);
#else
    	    // decide we're happy where we are.
    	    // we will never get to our real destination
    	    pItd->VolSmoothScaleWet = 1.f;
    	    pItd->TotalWetAttenuation = pItd->LastWetAttenuation;
#endif
    	} else {
    	    // This is the value to multiply by every time
    	    pItd->VolSmoothScaleWet = pItd->VolSmoothScale;
    	}

        // Wet attenuation wants to be lower than it is
    } else if (pItd->TotalWetAttenuation < pItd->LastWetAttenuation) {

    	// after lowering the volume throughout this entire range of samples
        	// we will end up going too low!  going down from Last to Total is
        	// the same as going up from Total to Last
         	// VolSmoothScale is just 2^(8/f), so each sample goes up 
    	// 2^(8/f), so n samples goes up (2^(8/f))^n or 2^(8n/f)
    	attRatio = pItd->TotalWetAttenuation ?
    			pItd->LastWetAttenuation / pItd->TotalWetAttenuation :
    			999999;
    	if (pow2(8. * cSamples / pItd->iSmoothFreq) > attRatio) {
#if 1
    	    // calculate what value besides 8 to use to end up at our
    	    // target after cSamples multiplies
    	    c = (D3DVALUE)fylog2x((double)pItd->iSmoothFreq / cSamples,
    							attRatio);
    	    pItd->VolSmoothScaleWet = 1.f / (D3DVALUE)pow2(c / pItd->iSmoothFreq);
#else
    	    // decide we're happy where we are.
    	    // we will never get to our real destination
    	    pItd->VolSmoothScaleWet = 1.f;
    	    pItd->TotalWetAttenuation = pItd->LastWetAttenuation;
#endif
    	} else {
    	    // This is the value to multiply by every time
    	    pItd->VolSmoothScaleWet = pItd->VolSmoothScaleRecip;
    	}
    } else {
        	// We're already where we want to be
    	pItd->VolSmoothScaleWet = 1.f;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\filters\kmixer\filter.c ===
//---------------------------------------------------------------------------
//
//  Module:   filter.c
//
//  Description:
//
//
//@@BEGIN_MSINTERNAL
//  Development Team:
//     S.Mohanraj
//
//  History:   Date       Author      Comment
//
//  To Do:     Date       Author      Comment
//
//@@END_MSINTERNAL
//---------------------------------------------------------------------------
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1996-2000 Microsoft Corporation.  All Rights Reserved.
//
//---------------------------------------------------------------------------

#include "common.h"
#include "perf.h"

GUID KMIXERPROPSETID_Perf = {0x3EDFD090L, 0x070C, 0x11D3, 0xAE, 0xF1, 0x00, 0x60, 0x08, 0x1E, 0xBB, 0x9A};
typedef enum {
    KMIXERPERF_TUNABLEPARAMS,
    KMIXERPERF_STATS
} KMIXERPERF_ITEMS;


NTSTATUS
AllocatorDispatchCreatePin(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
FilterPinIntersection(
    IN PIRP     Irp,
    IN PKSP_PIN Pin,
    OUT PVOID   Data
    );

//---------------------------------------------------------------------------
//---------------------------------------------------------------------------

static const WCHAR PinTypeName[] = KSSTRING_Pin ;
static const WCHAR AllocatorTypeName[] = KSSTRING_Allocator;

BOOL    fLogToFile = FALSE;
extern ULONG gFixedSamplingRate;


DEFINE_KSCREATE_DISPATCH_TABLE ( CreateHandlers )
{
    DEFINE_KSCREATE_ITEM (PinDispatchCreate, PinTypeName, 0),
    DEFINE_KSCREATE_ITEM(AllocatorDispatchCreatePin, AllocatorTypeName, 0)
};

KSDISPATCH_TABLE FilterDispatchTable =
{
    FilterDispatchIoControl,
    NULL,
    KsDispatchInvalidDeviceRequest,
    NULL,
    FilterDispatchClose,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL
};

DEFINE_KSPROPERTY_PINSET(
    FilterPropertyHandlers,
    PinPropertyHandler,
    PinInstances,
    FilterPinIntersection
) ;

DEFINE_KSPROPERTY_TABLE(FilterConnectionHandlers)
{
    DEFINE_KSPROPERTY_ITEM(
        KSPROPERTY_CONNECTION_STATE,                // PropertyId
        NULL,                                       // GetHandler
        sizeof( KSPROPERTY ),                       // MinSetPropertyInput
        sizeof( ULONG ),                            // MinSetDataOutput
        FilterStateHandler,                         // SetHandler
        0,                                          // Values
        0,                                          // RelationsCount
        NULL,                                       // Relations
        NULL,                                       // SupportHandler
        0                                           // SerializedSize
    )
} ;

DEFINE_KSPROPERTY_TOPOLOGYSET(
        TopologyPropertyHandlers,
        FilterTopologyHandler
);

DEFINE_KSPROPERTY_TABLE(FilterAudioPropertyHandlers)
{
    DEFINE_KSPROPERTY_ITEM(
        KSPROPERTY_AUDIO_CPU_RESOURCES,             // PropertyId
        MxGetCpuResources,                          // GetHandler
        sizeof( KSNODEPROPERTY ),                   // MinSetPropertyInput
        sizeof( ULONG ),                            // MinSetDataOutput
        NULL,                                       // SetHandler
        0,                                          // Values
        0,                                          // RelationsCount
        NULL,                                       // Relations
        NULL,                                       // SupportHandler
        0                                           // SerializedSize
    ),

   DEFINE_KSPROPERTY_ITEM (
       KSPROPERTY_AUDIO_SURROUND_ENCODE,                // idProperty
       MxGetSurroundEncode,                             // pfnGetHandler
       sizeof(KSNODEPROPERTY),                          // cbMinGetPropertyInput
       sizeof(BOOL),                                    // cbMinGetDataInput
       MxSetSurroundEncode,                             // pfnSetHandler
       0,                                               // Values
       0,                                               // RelationsCount
       NULL,                                            // Relations
       NULL,                                            // SupportHandler
       0                                                // SerializedSize
   )

} ;

DEFINE_KSPROPERTY_TABLE(PerfPropertyHandlers)
{
    DEFINE_KSPROPERTY_ITEM(
        KMIXERPERF_TUNABLEPARAMS,                   // PropertyId
        MxGetTunableParams,                         // GetHandler
        sizeof( KSPROPERTY ),                       // MinSetPropertyInput
        sizeof( TUNABLEPARAMS ),                    // MinSetDataOutput
        MxSetTunableParams,                         // SetHandler
        0,                                          // Values
        0,                                          // RelationsCount
        NULL,                                       // Relations
        NULL,                                       // SupportHandler
        0                                           // SerializedSize
    ),
    DEFINE_KSPROPERTY_ITEM(
        KMIXERPERF_STATS,                           // PropertyId
        MxGetPerfStats,                             // GetHandler
        sizeof( KSPROPERTY ),                       // MinSetPropertyInput
        sizeof( PERFSTATS ),                        // MinSetDataOutput
        NULL,                                       // SetHandler
        0,                                          // Values
        0,                                          // RelationsCount
        NULL,                                       // Relations
        NULL,                                       // SupportHandler
        0                                           // SerializedSize
    )
} ;

DEFINE_KSPROPERTY_SET_TABLE(FilterPropertySet)
{
    DEFINE_KSPROPERTY_SET(
       &KSPROPSETID_Pin,                            // Set
       SIZEOF_ARRAY( FilterPropertyHandlers ),      // PropertiesCount
       FilterPropertyHandlers,                      // PropertyItem
       0,                                           // FastIoCount
       NULL                                         // FastIoTable
    ),

    DEFINE_KSPROPERTY_SET(
       &KSPROPSETID_Connection,                     // Set
       SIZEOF_ARRAY( FilterConnectionHandlers ),    // PropertiesCount
       FilterConnectionHandlers,                    // PropertyItem
       0,                                           // FastIoCount
       NULL                                         // FastIoTable
    ),

    DEFINE_KSPROPERTY_SET(
        &KSPROPSETID_Topology,                      // Set
        SIZEOF_ARRAY(TopologyPropertyHandlers),     // PropertiesCount
        TopologyPropertyHandlers,                   // PropertyItem
        0,                                          // FastIoCount
        NULL                                        // FastIoTable
    ),

    DEFINE_KSPROPERTY_SET(
        &KSPROPSETID_Audio,                         // Set
        SIZEOF_ARRAY(FilterAudioPropertyHandlers),  // PropertiesCount
        FilterAudioPropertyHandlers,                // PropertyItem
        0,                                          // FastIoCount
        NULL                                        // FastIoTable
    ),

    DEFINE_KSPROPERTY_SET(
        &KMIXERPROPSETID_Perf,
        SIZEOF_ARRAY(PerfPropertyHandlers),
        PerfPropertyHandlers,
        0,
        NULL
    )
} ;

KSPIN_INTERFACE PinInterfaces[] =
{
    {
        STATICGUIDOF(KSINTERFACESETID_Standard),
        KSINTERFACE_STANDARD_STREAMING
    },
    {
        STATICGUIDOF(KSINTERFACESETID_Media),
        KSINTERFACE_MEDIA_WAVE_QUEUED
    },
    {
    STATICGUIDOF(KSINTERFACESETID_Standard),
        KSINTERFACE_STANDARD_LOOPED_STREAMING
    }
} ;

KSPIN_MEDIUM PinMediums[] =
{
    {
        STATICGUIDOF(KSMEDIUMSETID_Standard),
        KSMEDIUM_STANDARD_DEVIO
    }
} ;

KSDATARANGE_AUDIO FilterDigitalAudioFormats[] =
{
    {   // 0
        {
            sizeof( KSDATARANGE_AUDIO ),
            0,
            0,
            0,
            STATICGUIDOF(KSDATAFORMAT_TYPE_AUDIO),
            STATICGUIDOF(KSDATAFORMAT_SUBTYPE_PCM),
            STATICGUIDOF(KSDATAFORMAT_SPECIFIER_WAVEFORMATEX),
        },
        (ULONG) -1L,
        8,
        32,
        MIN_SAMPLING_RATE,
        MAX_SAMPLING_RATE
    },
    {   // 1
        {
            sizeof( KSDATARANGE_AUDIO ),
            0,
            0,
            0,
            STATICGUIDOF(KSDATAFORMAT_TYPE_AUDIO),
            STATICGUIDOF(KSDATAFORMAT_SUBTYPE_PCM),
            STATICGUIDOF(KSDATAFORMAT_SPECIFIER_DSOUND),
        },
        (ULONG) -1L,
        8,
        32,
        MIN_SAMPLING_RATE,
        MAX_SAMPLING_RATE
    },
    {   // 2
        {
            sizeof( KSDATARANGE_AUDIO ),
            0,
            0,
            0,
            STATICGUIDOF(KSDATAFORMAT_TYPE_AUDIO),
            DEFINE_WAVEFORMATEX_GUID(WAVE_FORMAT_IEEE_FLOAT),
            STATICGUIDOF(KSDATAFORMAT_SPECIFIER_WAVEFORMATEX),
        },
        (ULONG) -1L,
        32,
        32,
        MIN_SAMPLING_RATE,
        MAX_SAMPLING_RATE
    },
    {   // 3
        {
            sizeof( KSDATARANGE_AUDIO ),
            0,
            0,
            0,
            STATICGUIDOF(KSDATAFORMAT_TYPE_AUDIO),
            STATICGUIDOF(KSDATAFORMAT_SUBTYPE_PCM),
            STATICGUIDOF(KSDATAFORMAT_SPECIFIER_WAVEFORMATEX),
        },
        (ULONG) -1L,
        8,
        32,
        MIN_SAMPLING_RATE,
        MAX_SAMPLING_RATE
    },
    {   // 4
        {
            sizeof( KSDATARANGE_AUDIO ),
            0,
            0,
            0,
            STATICGUIDOF(KSDATAFORMAT_TYPE_AUDIO),
            DEFINE_WAVEFORMATEX_GUID(WAVE_FORMAT_IEEE_FLOAT),
            STATICGUIDOF(KSDATAFORMAT_SPECIFIER_DSOUND),
        },
        (ULONG) -1L,
        32,
        32,
        MIN_SAMPLING_RATE,
        MAX_SAMPLING_RATE
    }
};

PKSDATARANGE SinkDataFormats[] =
{   // These are listed in order of kmixer's preference, which is highest to lowest quality.
    (PKSDATARANGE)&FilterDigitalAudioFormats[ 2 ],  // IEEE Float, WAVEFORMAT specifier
    (PKSDATARANGE)&FilterDigitalAudioFormats[ 0 ],  // PCM, WAVEFORMAT specifier
    (PKSDATARANGE)&FilterDigitalAudioFormats[ 4 ],  // IEEE Float, DSOUND specifier
    (PKSDATARANGE)&FilterDigitalAudioFormats[ 1 ]   // PCM, DSOUND specifier
} ;

PKSDATARANGE SourceDataFormats[] =
{   // These are listed in order of kmixer's preference, which is highest to lowest quality.
    (PKSDATARANGE)&FilterDigitalAudioFormats[ 2 ],  // IEEE Float
    (PKSDATARANGE)&FilterDigitalAudioFormats[ 3 ]   // PCM, WAVEFORMAT specifier
} ;

const KSPIN_CINSTANCES gPinInstances[] =
{
    // Indeterminate number of possible connections.

    {
    1,          // cPossible
    0           // cCurrent
    },

    {
    (ULONG)-1,  // cPossible
    0           // cCurrent
    },

    // Source pin, flow=in
    {
    1,          // cPossible
    0           // cCurrent
    },

    // Sink pin, flow=out
    {
    1,          // cPossible
    0           // cCurrent
    },
} ;

KSPIN_DESCRIPTOR PinDescs[] =
{
    // mixer source
    DEFINE_KSPIN_DESCRIPTOR_ITEM (
    1,
    &PinInterfaces[ 0 ],
    SIZEOF_ARRAY( PinMediums ),
    PinMediums,
    SIZEOF_ARRAY( SourceDataFormats ),
    SourceDataFormats,
    KSPIN_DATAFLOW_OUT,
    KSPIN_COMMUNICATION_SOURCE
    ),

    // mixer sink

    DEFINE_KSPIN_DESCRIPTOR_ITEM (
    3,
    &PinInterfaces[ 0 ],
    SIZEOF_ARRAY( PinMediums ),
    PinMediums,
    SIZEOF_ARRAY( SinkDataFormats ),
    SinkDataFormats,
    KSPIN_DATAFLOW_IN,
    KSPIN_COMMUNICATION_SINK
    ),

    // mixer source
    DEFINE_KSPIN_DESCRIPTOR_ITEM (
    1,
    &PinInterfaces[ 0 ],
    SIZEOF_ARRAY( PinMediums ),
    PinMediums,
    SIZEOF_ARRAY( SourceDataFormats ),
    SourceDataFormats,
    KSPIN_DATAFLOW_IN,
    KSPIN_COMMUNICATION_SOURCE
    ),

    // mixer sink

    DEFINE_KSPIN_DESCRIPTOR_ITEM (
    2,
    &PinInterfaces[ 0 ],
    SIZEOF_ARRAY( PinMediums ),
    PinMediums,
    SIZEOF_ARRAY( SourceDataFormats ),
    SourceDataFormats,
    KSPIN_DATAFLOW_OUT,
    KSPIN_COMMUNICATION_SINK
    )
} ;


#pragma LOCKED_DATA

ULONG gFilterInstanceCount = 0;
extern DWORD    PreferredQuality;

extern ULONG gNumCompletionsWhileStarved ;
extern ULONG gNumMixBuffersAdded;
extern ULONG gNumSilenceSamplesInserted;
//
// kmixer tuner variables
//
BOOL       gNoGlitch = FALSE;
ULONG      gMaxNumMixBuffers = DEFAULT_MAXNUMMIXBUFFERS ;
ULONG      gMinNumMixBuffers = DEFAULT_MINNUMMIXBUFFERS ;
ULONG      gMixBufferDuration = 0 ;
ULONG      gStartNumMixBuffers = DEFAULT_STARTNUMMIXBUFFERS ;
ULONG      gPreferredQuality = DEFAULT_PREFERREDQUALITY ;
ULONG      gDisableMmx = DEFAULT_DISABLEMMX ;
ULONG      gMaxOutputBits = DEFAULT_MAXOUTPUTBITS ;
ULONG      gMaxDsoundInChannels = DEFAULT_MAXDSOUNDINCHANNELS ;
ULONG      gMaxOutChannels = DEFAULT_MAXOUTCHANNELS ;
ULONG      gMaxInChannels = DEFAULT_MAXINCHANNELS ;
ULONG      gMaxFloatChannels = DEFAULT_MAXFLOATCHANNELS ;
ULONG      gLogToFile = DEFAULT_LOGTOFILE ;
ULONG      gFixedSamplingRate = DEFAULT_FIXEDSAMPLINGRATE ;
ULONG      gEnableShortHrtf = DEFAULT_ENABLESHORTHRTF ;
ULONG      gBuildPartialMdls = DEFAULT_BUILDPARTIALMDLS ;

#ifdef REALTIME_THREAD
ULONG      gDisableRealTime = FALSE;
#endif
KPRIORITY  gWorkerThreadPriority = MIXTHREADPRIORITY ;

//---------------------------------------------------------------------------
//---------------------------------------------------------------------------

NTSTATUS
OpenRegistryKey(
    PWSTR pwstr,
    PHANDLE pHandle
)
{
    UNICODE_STRING UnicodeDeviceString;
    OBJECT_ATTRIBUTES ObjectAttributes;

    RtlInitUnicodeString(&UnicodeDeviceString, pwstr);

    InitializeObjectAttributes( &ObjectAttributes, &UnicodeDeviceString, OBJ_CASE_INSENSITIVE, NULL, NULL);

    return(ZwOpenKey( pHandle, GENERIC_READ | GENERIC_WRITE, &ObjectAttributes));
}

NTSTATUS
QueryRegistryValue(
    HANDLE hkey,
    PWSTR pwstrValueName,
    PKEY_VALUE_FULL_INFORMATION *ppkvfi
)
{
    UNICODE_STRING ustrValueName;
    NTSTATUS Status;
    ULONG cbValue;

    RtlInitUnicodeString(&ustrValueName, pwstrValueName);
    Status = ZwQueryValueKey( hkey, &ustrValueName, KeyValueFullInformation, NULL, 0, &cbValue);

    if(Status != STATUS_BUFFER_OVERFLOW && Status != STATUS_BUFFER_TOO_SMALL) {
        goto exit;
    }

    *ppkvfi = ExAllocatePoolWithTag(PagedPool, cbValue, 0x58494d4b);  // 'KMIX'
    if(*ppkvfi == NULL) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto exit;
    }
    RtlZeroMemory(*ppkvfi, cbValue);

    Status = ZwQueryValueKey( hkey, &ustrValueName, KeyValueFullInformation, *ppkvfi, cbValue, &cbValue);

exit:
    return(Status);
}

ULONG
GetUlongFromRegistry(
    PWSTR pwstrRegistryPath,
    PWSTR pwstrRegistryValue,
    ULONG DefaultValue
)
{
    PVOID      pulValue ;
    ULONG       ulValue ;
    NTSTATUS    Status ;

    Status = QueryRegistryValueEx(RTL_REGISTRY_ABSOLUTE,
                         pwstrRegistryPath,
                         pwstrRegistryValue,
                         REG_DWORD,
                         &pulValue,
                         &DefaultValue,
                         sizeof(DWORD));
    if (NT_SUCCESS(Status)) {
        ulValue = *((PULONG)pulValue);
        ExFreePool(pulValue);
    }
    else {
        ulValue = DefaultValue;
    }
    return ( ulValue ) ;
}

NTSTATUS
QueryRegistryValueEx(
    ULONG Hive,
    PWSTR pwstrRegistryPath,
    PWSTR pwstrRegistryValue,
    ULONG uValueType,
    PVOID *ppValue,
    PVOID pDefaultData,
    ULONG DefaultDataLength
)
{
    PRTL_QUERY_REGISTRY_TABLE pRegistryValueTable = NULL;
    UNICODE_STRING usString;
    DWORD dwValue;
    NTSTATUS Status = STATUS_SUCCESS;
    usString.Buffer = NULL;

    pRegistryValueTable = (PRTL_QUERY_REGISTRY_TABLE) ExAllocatePoolWithTag(
                            PagedPool,
                            (sizeof(RTL_QUERY_REGISTRY_TABLE)*2),
                            'XIMK');

    if(!pRegistryValueTable) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto exit;
    }

    RtlZeroMemory(pRegistryValueTable, (sizeof(RTL_QUERY_REGISTRY_TABLE)*2));

    pRegistryValueTable[0].Flags = RTL_QUERY_REGISTRY_DIRECT;
    pRegistryValueTable[0].Name = pwstrRegistryValue;
    pRegistryValueTable[0].DefaultType = uValueType;
    pRegistryValueTable[0].DefaultLength = DefaultDataLength;
    pRegistryValueTable[0].DefaultData = pDefaultData;

    switch (uValueType) {
        case REG_SZ:
            pRegistryValueTable[0].EntryContext = &usString;
            break;
        case REG_DWORD:
            pRegistryValueTable[0].EntryContext = &dwValue;
            break;
        default:
            Status = STATUS_INVALID_PARAMETER ;
            goto exit;
    }

    Status = RtlQueryRegistryValues(
      Hive,
      pwstrRegistryPath,
      pRegistryValueTable,
      NULL,
      NULL);

    if(!NT_SUCCESS(Status)) {
        goto exit;
    }

    switch (uValueType) {
        case REG_SZ:
            *ppValue = ExAllocatePoolWithTag(
                        PagedPool,
                        usString.Length + sizeof(UNICODE_NULL),
                        'XIMK');
            if(!(*ppValue)) {
                RtlFreeUnicodeString(&usString);
                Status = STATUS_INSUFFICIENT_RESOURCES;
                goto exit;
            }
            memcpy(*ppValue, usString.Buffer, usString.Length);
            ((PWCHAR)*ppValue)[usString.Length/sizeof(WCHAR)] = UNICODE_NULL;

            RtlFreeUnicodeString(&usString);
            break;

        case REG_DWORD:
            *ppValue = ExAllocatePoolWithTag(
                        PagedPool,
                        sizeof(DWORD),
                        'XIMK');
            if(!(*ppValue)) {
                Status = STATUS_INSUFFICIENT_RESOURCES;
                goto exit;
            }
            *((DWORD *)(*ppValue)) = dwValue;
            break;

        default:
            Status = STATUS_INVALID_PARAMETER ;
            goto exit;
    }
exit:
    if (pRegistryValueTable) {
        ExFreePool(pRegistryValueTable);
    }
    return(Status);
}

VOID GetMixerSettingsFromRegistry()
{

    gMixBufferDuration = GetUlongFromRegistry( CORE_AUDIO_BUFFER_DURATION_PATH,
                                               CORE_AUDIO_BUFFER_DURATION_VALUE,
                                               0 );

    if (gMixBufferDuration) {
        // We turn on the gNoGlitch flag if there is a registry entry for
        // the buffer duration, and we are running on an MP system, and
        // the boot processor is active.  In that case we will wake up
        // from a failsafe timer in addition to completion events.
        gNoGlitch = (KeNumberProcessors > 1) && (KeQueryActiveProcessors()&1);
    }
    else {
        // No registry entry for buffer duration, set it to the default.
        gMixBufferDuration = DEFAULT_CORE_AUDIO_BUFFER_DURATION;
    }

    // Limit duration maximum.

    if ( gMixBufferDuration > MAX_CORE_AUDIO_BUFFER_DURATION ) {

        gMixBufferDuration = MAX_CORE_AUDIO_BUFFER_DURATION;

    }

    // Limit duration minimum.

    if ( gMixBufferDuration < MIN_CORE_AUDIO_BUFFER_DURATION ) {

        gMixBufferDuration = MIN_CORE_AUDIO_BUFFER_DURATION;

    }

#if !(MIN_CORE_AUDIO_BUFFER_DURATION/1000)
#error MIN_CORE_AUDIO_BUFFER_DURATION less than 1ms not yet supported in kmixer!
#endif

    gMixBufferDuration /= 1000;

    gMinNumMixBuffers = GetUlongFromRegistry( REGSTR_PATH_MULTIMEDIA_KMIXER,
                                              REGSTR_VAL_MINNUMMIXBUFFERS,
                                              DEFAULT_MINNUMMIXBUFFERS ) ;
    gMaxNumMixBuffers = GetUlongFromRegistry( REGSTR_PATH_MULTIMEDIA_KMIXER,
                                              REGSTR_VAL_MAXNUMMIXBUFFERS,
                                              DEFAULT_MAXNUMMIXBUFFERS ) ;
    gStartNumMixBuffers = GetUlongFromRegistry( REGSTR_PATH_MULTIMEDIA_KMIXER,
                                                REGSTR_VAL_STARTNUMMIXBUFFERS,
                                                DEFAULT_STARTNUMMIXBUFFERS ) ;
    gDisableMmx = GetUlongFromRegistry( REGSTR_PATH_MULTIMEDIA_KMIXER,
                                        REGSTR_VAL_DISABLEMMX,
                                        DEFAULT_DISABLEMMX ) ;
    gMaxOutputBits = GetUlongFromRegistry( REGSTR_PATH_MULTIMEDIA_KMIXER,
                                           REGSTR_VAL_MAXOUTPUTBITS,
                                           DEFAULT_MAXOUTPUTBITS ) ;
    gMaxInChannels = GetUlongFromRegistry( REGSTR_PATH_MULTIMEDIA_KMIXER,
                                           REGSTR_VAL_MAXINCHANNELS,
                                           DEFAULT_MAXINCHANNELS ) ;
    gMaxDsoundInChannels = GetUlongFromRegistry( REGSTR_PATH_MULTIMEDIA_KMIXER,
                                                 REGSTR_VAL_MAXDSOUNDINCHANNELS,
                                                 DEFAULT_MAXDSOUNDINCHANNELS ) ;
    gMaxFloatChannels = GetUlongFromRegistry( REGSTR_PATH_MULTIMEDIA_KMIXER,
                                              REGSTR_VAL_MAXFLOATCHANNELS,
                                              DEFAULT_MAXFLOATCHANNELS ) ;
    gMaxOutChannels = GetUlongFromRegistry( REGSTR_PATH_MULTIMEDIA_KMIXER,
                                            REGSTR_VAL_MAXOUTCHANNELS,
                                            DEFAULT_MAXOUTCHANNELS ) ;
    gLogToFile = GetUlongFromRegistry( REGSTR_PATH_MULTIMEDIA_KMIXER,
                                       REGSTR_VAL_LOGTOFILE,
                                       DEFAULT_LOGTOFILE ) ;
    if (gLogToFile) {
        gFixedSamplingRate = TRUE ;
    }
    else {
        gFixedSamplingRate = GetUlongFromRegistry( REGSTR_PATH_MULTIMEDIA_KMIXER,
                                                   REGSTR_VAL_FIXEDSAMPLINGRATE,
                                                   DEFAULT_FIXEDSAMPLINGRATE ) ;
    }

    gEnableShortHrtf = GetUlongFromRegistry( REGSTR_PATH_MULTIMEDIA_KMIXER,
                                             REGSTR_VAL_ENABLESHORTHRTF,
                                             DEFAULT_ENABLESHORTHRTF ) ;
    gBuildPartialMdls = GetUlongFromRegistry( REGSTR_PATH_MULTIMEDIA_KMIXER,
                                              REGSTR_VAL_BUILDPARTIALMDLS,
                                              DEFAULT_BUILDPARTIALMDLS ) ;
    gPreferredQuality = GetUlongFromRegistry( REGSTR_PATH_MULTIMEDIA_KMIXER,
                                              REGSTR_VAL_DEFAULTSRCQUALITY,
                                              DEFAULT_PREFERREDQUALITY );

#ifdef REALTIME_THREAD
    gDisableRealTime = GetUlongFromRegistry( REGSTR_PATH_MULTIMEDIA_KMIXER,
                                             REGSTR_VAL_REALTIMETHREAD,
                                             FALSE );
#endif

    gWorkerThreadPriority = GetUlongFromRegistry( REGSTR_PATH_MULTIMEDIA_KMIXER,
                                                  REGSTR_VAL_PRIVATETHREADPRI,
                                                  MIXTHREADPRIORITY ) ;

    if ( (gMinNumMixBuffers == 0) ||
         (gMaxNumMixBuffers == 0) ||
         (gStartNumMixBuffers == 0) ||
         (gMixBufferDuration == 0) ) {
        gMixBufferDuration = (DEFAULT_CORE_AUDIO_BUFFER_DURATION) / 1000 ;
        gMinNumMixBuffers = DEFAULT_MINNUMMIXBUFFERS ;
        gMaxNumMixBuffers = DEFAULT_MAXNUMMIXBUFFERS ;
        gStartNumMixBuffers = DEFAULT_STARTNUMMIXBUFFERS ;
    }

    if ( gMinNumMixBuffers > gMaxNumMixBuffers ) {
        gMaxNumMixBuffers = gMinNumMixBuffers ;
    }

    if ( gStartNumMixBuffers < gMinNumMixBuffers ) {
        gStartNumMixBuffers = gMinNumMixBuffers ;
    }

    if ( gPreferredQuality > KSAUDIO_QUALITY_ADVANCED) {
        gPreferredQuality = DEFAULT_PREFERREDQUALITY ;
    }

    if ( (gMaxOutputBits > 32) ||
         (gMaxOutputBits % 8) ||
         (gMaxOutputBits == 0) ) {
        gMaxOutputBits = DEFAULT_MAXOUTPUTBITS ;
    }

    if (gMaxDsoundInChannels == 0) {
        gMaxDsoundInChannels = DEFAULT_MAXDSOUNDINCHANNELS ;
    }

    if (gMaxOutChannels == 0) {
        gMaxOutChannels = DEFAULT_MAXOUTCHANNELS ;
    }

    if (gMaxInChannels == 0) {
        gMaxInChannels = DEFAULT_MAXINCHANNELS ;
    }

    if (gMaxFloatChannels == 0) {
        gMaxFloatChannels = DEFAULT_MAXFLOATCHANNELS ;
    }
}


NTSTATUS
FilterDispatchGlobalCreate (
    IN PDEVICE_OBJECT pdo,
    IN PIRP           pIrp
    )
{
    NTSTATUS            Status = STATUS_SUCCESS ;
    PFILTER_INSTANCE    pFilterInstance = NULL ;
    PIO_STACK_LOCATION  pIrpStack;
    BOOLEAN BusReferenced = FALSE;

    DENY_USERMODE_ACCESS( pIrp, TRUE );

    // We assume success here.  We do this to ensure that we always correctly see when
    // each new filter instance is either created or in the process of being
    // created.  WARNING!  Make sure all code paths that exit this function after this
    // call either goto exit or run the code at exit where we decrement this count if
    // something failed.
    InterlockedIncrement(&gFilterInstanceCount);

    Status = KsReferenceSoftwareBusObject(((PSOFTWARE_INSTANCE)pdo->DeviceExtension)->DeviceHeader );

    if (!NT_SUCCESS( Status )) {
        goto exit;
    }
    else {
        BusReferenced=TRUE;
    }

    pFilterInstance = (PFILTER_INSTANCE) ExAllocatePoolWithTag( NonPagedPool, sizeof( FILTER_INSTANCE ), 'XIMK' );
    if (!pFilterInstance) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto exit;
    }
    RtlZeroMemory( pFilterInstance, sizeof( FILTER_INSTANCE ) );

    // Initialize CloseEvent to non-signalled state
    KeInitializeEvent ( &pFilterInstance->CloseEvent,
                        SynchronizationEvent,
                        FALSE ) ;
    KeInitializeSpinLock ( &pFilterInstance->MixSpinLock ) ;
    KeInitializeSpinLock ( &pFilterInstance->SinkSpinLock ) ;

    Status = KsAllocateObjectHeader( &pFilterInstance->ObjectHeader,
                                    SIZEOF_ARRAY ( CreateHandlers ),
                                    (PKSOBJECT_CREATE_ITEM) CreateHandlers,
                                    pIrp,
                                    (PKSDISPATCH_TABLE)&FilterDispatchTable ) ;
    if (!NT_SUCCESS( Status )) {
        goto exit;
    }


    pFilterInstance->NoGlitch = gNoGlitch;
    pFilterInstance->MixBufferDuration = gMixBufferDuration ;
    pFilterInstance->MinNumMixBuffers = gMinNumMixBuffers ;
    pFilterInstance->MaxNumMixBuffers = gMaxNumMixBuffers ;
    pFilterInstance->StartNumMixBuffers = gStartNumMixBuffers ;

    if ( pFilterInstance->NoGlitch && pFilterInstance->MixBufferDuration == 1 ) {
        // To prevent glitching when we switch from mixing from buffer
        // completions to the timer mix, we MUST have 4 buffers if the
        // buffer duration is 1ms.  This is because the minimum system
        // timer resolution is also 1ms.
        // If we only initiated mixing from the timer, then we should be able
        // to work glitch free with 3 1ms buffers.
        if ( pFilterInstance->MinNumMixBuffers < 4 ) {
            pFilterInstance->MinNumMixBuffers = 4;
        }
        if ( pFilterInstance->StartNumMixBuffers < pFilterInstance->MinNumMixBuffers ) {
            pFilterInstance->StartNumMixBuffers = pFilterInstance->MinNumMixBuffers;
        }
        if ( pFilterInstance->MaxNumMixBuffers < pFilterInstance->MinNumMixBuffers ) {
            pFilterInstance->MaxNumMixBuffers = pFilterInstance->MinNumMixBuffers;
        }
    }

    InitializeListHead ( &pFilterInstance->SinkConnectionList ) ;
    InitializeListHead ( &pFilterInstance->ActiveSinkList ) ;
    InitializeListHead ( &pFilterInstance->SourceConnectionList ) ;
    InitializeListHead ( &pFilterInstance->DeadQueue ) ;
    InitializeListHead ( &pFilterInstance->AgingQueue ) ;

    KeInitializeSpinLock ( &pFilterInstance->AgingDeadSpinLock );

    KeInitializeMutex ( &pFilterInstance->ControlMutex, 1 ) ;

    pFilterInstance->CurrentNumMixBuffers = STARTNUMMIXBUFFERS ;
    pFilterInstance->PresentationTime.Numerator = 1 ;
    pFilterInstance->PresentationTime.Denominator = 1 ;
#ifdef SURROUND_ENCODE
#ifdef SURROUND_VOLUME_HACK
    pFilterInstance->fSurroundEncode = TRUE;
#else
    pFilterInstance->fSurroundEncode = FALSE;
#endif
#endif

    FilterDigitalAudioFormats[3].MaximumBitsPerSample = gMaxOutputBits ;
    FilterDigitalAudioFormats[0].MaximumChannels = gMaxInChannels ;
    FilterDigitalAudioFormats[1].MaximumChannels = gMaxDsoundInChannels ;
    FilterDigitalAudioFormats[2].MaximumChannels = gMaxFloatChannels ;
    FilterDigitalAudioFormats[3].MaximumChannels = gMaxOutChannels ;
    FilterDigitalAudioFormats[4].MaximumChannels = min(gMaxFloatChannels, gMaxDsoundInChannels);
    fLogToFile = gLogToFile;

    pIrpStack = IoGetCurrentIrpStackLocation( pIrp );
    pIrpStack->FileObject->FsContext = pFilterInstance;
    pFilterInstance->FileObject = pIrpStack->FileObject ;

    pFilterInstance->WritingTimerMixedBuffer = FALSE;
    pFilterInstance->WorkerThreadPriority = gWorkerThreadPriority ;
    //
    // Initialize the Trigger event for the Worker thread
    //
    KeInitializeEvent( &pFilterInstance->WorkerThreadEvent,
                        SynchronizationEvent,
                        FALSE ) ;

    KeInitializeTimerEx( &pFilterInstance->WorkerThreadTimer,
                        SynchronizationTimer ) ;

    //
    // Create the Worker thread
    //
    Status = PsCreateSystemThread( &pFilterInstance->WorkerThreadHandle,
                                    (ACCESS_MASK) 0L,
                                    NULL,
                                    NULL,
                                    NULL,
                                    MxPrivateWorkerThread,
                                    pFilterInstance ) ;
    //
    // Get the Worker thread object pointer
    //
    if ( NT_SUCCESS(Status) ) {
        //
        // On successful thread creation
        //
        Status = ObReferenceObjectByHandle( pFilterInstance->WorkerThreadHandle,
                                            GENERIC_READ | GENERIC_WRITE,
                                            NULL,
                                            KernelMode,
                                            &pFilterInstance->WorkerThreadObject,
                                            NULL ) ;
        //
        // We do not need the thread handle any more
        //
        ZwClose( pFilterInstance->WorkerThreadHandle ) ;

        if ( !NT_SUCCESS(Status) ) {
            //
            // If Obref failed
            // Kill the worker thread by setting the event & Exit flag
            //
            // Note: we do not have to deref the object, since it is not ref'd in the failure case.
            pFilterInstance->WorkerThreadExit = TRUE ;
            KeSetEvent( &pFilterInstance->WorkerThreadEvent, 0, FALSE ) ;
        }
    }

    if ( !NT_SUCCESS(Status) ) {
        goto exit ;
    }

    RtlCopyMemory(pFilterInstance->LocalPinInstances, gPinInstances, sizeof( gPinInstances ) );

    if ( pFilterInstance->NoGlitch ) {
        ExSetTimerResolution( 10000, TRUE );  // Set system timer resolution to 1ms.
    }

exit:
    if (!NT_SUCCESS(Status)) {

        if(pFilterInstance != NULL) {
            if ( pFilterInstance->ObjectHeader ) {
                KsFreeObjectHeader ( pFilterInstance->ObjectHeader ) ;
            }
            ExFreePool( pFilterInstance );
        }

        if ( BusReferenced ) {
            KsDereferenceSoftwareBusObject(((PSOFTWARE_INSTANCE)pdo->DeviceExtension)->DeviceHeader );
        }

        InterlockedDecrement(&gFilterInstanceCount);

    }

    if (NT_SUCCESS(Status)) {
        PerfRegisterProvider (pdo);
    }

    pIrp->IoStatus.Information = 0;
    pIrp->IoStatus.Status = Status;
    IoCompleteRequest( pIrp, 0 );
    return Status;
}


NTSTATUS
FilterDispatchClose (
    IN PDEVICE_OBJECT pdo,
    IN PIRP           pIrp
    )
{
    PIO_STACK_LOCATION  pIrpStack;
    PFILTER_INSTANCE    pFilterInstance ;

    DENY_USERMODE_ACCESS( pIrp, TRUE );

    pIrpStack = IoGetCurrentIrpStackLocation( pIrp );
    pFilterInstance = pIrpStack->FileObject->FsContext ;

    if ( pFilterInstance->NoGlitch ) {
        ExSetTimerResolution( 10000, FALSE );  // Release 1ms timer resolution.
    }

    PerfUnregisterProvider (pdo);

#ifdef REALTIME_THREAD
    ASSERT ( pFilterInstance->RealTimeThread == NULL );
#endif

    if ( KeCancelTimer( &pFilterInstance->WorkerThreadTimer ) ) {
        ASSERT( FALSE && "Kmixer private thread timer still active at filter close!" );
    }
    pFilterInstance->WorkerThreadExit = TRUE ;
    KeSetEvent( &pFilterInstance->WorkerThreadEvent, 0, FALSE ) ;
    KeWaitForSingleObject( pFilterInstance->WorkerThreadObject,
                            Executive,
                            KernelMode,
                            FALSE,
                            NULL ) ;

    ObDereferenceObject( pFilterInstance->WorkerThreadObject ) ;

    KsFreeObjectHeader ( pFilterInstance->ObjectHeader ) ;

    ExFreePool( pFilterInstance );

    KsDereferenceSoftwareBusObject(((PSOFTWARE_INSTANCE)pdo->DeviceExtension)->DeviceHeader );

    InterlockedDecrement(&gFilterInstanceCount);

    pIrp->IoStatus.Information = 0;
    pIrp->IoStatus.Status = STATUS_SUCCESS;
    IoCompleteRequest( pIrp, 0 );

    return STATUS_SUCCESS;
}

NTSTATUS FilterDispatchIoControl
(
   IN PDEVICE_OBJECT pDeviceObject,
   IN PIRP           pIrp
)
{
    NTSTATUS                     Status;
    PIO_STACK_LOCATION           pIrpStack;

    pIrpStack = IoGetCurrentIrpStackLocation( pIrp );
    switch (pIrpStack->Parameters.DeviceIoControl.IoControlCode)
    {

        case IOCTL_KS_PROPERTY:
            Status =
                KsPropertyHandler( pIrp, SIZEOF_ARRAY(FilterPropertySet),
                                   (PKSPROPERTY_SET) FilterPropertySet );
            break ;

        default:
            return KsDefaultDeviceIoCompletion(pDeviceObject, pIrp);
    }

    if (STATUS_PENDING == Status)
    {
        _DbgPrintF( DEBUGLVL_ERROR, ("PinDispatchIoControl: synchronous function returned STATUS_PENDING") );
    }

    pIrp->IoStatus.Status = Status;
    IoCompleteRequest( pIrp, IO_NO_INCREMENT );

    return Status;
}

NTSTATUS PinPropertyHandler
(
   IN PIRP         pIrp,
   IN PKSPROPERTY  pProperty,
   IN OUT PVOID    pvData
)
{
   return KsPinPropertyHandler( pIrp,
                                pProperty,
                                pvData,
                                SIZEOF_ARRAY( PinDescs ),
                                PinDescs );
}

NTSTATUS
AllocatorDispatchCreatePin(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    Forwards the allocator creation request to the default allocator.

Arguments:

    DeviceObject -
        Pointer to the device object

    Irp -
        Pointer to the I/O request packet

Return:

    STATUS_SUCCESS or an appropriate error code.

--*/
{
    NTSTATUS Status;

    Status = KsCreateDefaultAllocator(Irp);
    Irp->IoStatus.Status = Status;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    return Status;
}


NTSTATUS PinInstances
(
    IN PIRP                 pIrp,
    IN PKSP_PIN             pPin,
    OUT PKSPIN_CINSTANCES   pCInstances
)
{
    PIO_STACK_LOCATION  pIrpStack;
    PFILTER_INSTANCE    pFilterInstance;

    pIrpStack = IoGetCurrentIrpStackLocation( pIrp );

    pFilterInstance = (PFILTER_INSTANCE)pIrpStack->FileObject->FsContext;

    if ( pPin->PinId < MAXNUM_PIN_TYPES ) {
        *pCInstances = pFilterInstance->LocalPinInstances[ pPin->PinId  ];
    }
    else {
        return STATUS_INVALID_PARAMETER;
    }

    pIrp->IoStatus.Information = sizeof( KSPIN_CINSTANCES );

    return STATUS_SUCCESS;

} // PinXxxInstances()


NTSTATUS FilterStateHandler
(
    IN PIRP         pIrp,
    IN PKSPROPERTY  pProperty,
    IN OUT PKSSTATE DeviceState
)
{
        return ( STATUS_SUCCESS ) ;
}

VOID
WaveFormatFromAudioRange (
    PKSDATARANGE_AUDIO  pDataRangeAudio,
    WAVEFORMATEX *      pWavFormatEx)
{
    if(IS_VALID_WAVEFORMATEX_GUID(&pDataRangeAudio->DataRange.SubFormat)) {
        pWavFormatEx->wFormatTag =
          EXTRACT_WAVEFORMATEX_ID(&pDataRangeAudio->DataRange.SubFormat);
    }
    else {
        pWavFormatEx->wFormatTag = WAVE_FORMAT_UNKNOWN;
    }
    pWavFormatEx->nChannels = (WORD)pDataRangeAudio->MaximumChannels;
    pWavFormatEx->nSamplesPerSec = pDataRangeAudio->MaximumSampleFrequency;
    pWavFormatEx->wBitsPerSample = (WORD)pDataRangeAudio->MaximumBitsPerSample;
    pWavFormatEx->nBlockAlign =
      (pWavFormatEx->nChannels * pWavFormatEx->wBitsPerSample)/8;
    pWavFormatEx->nAvgBytesPerSec =
      pWavFormatEx->nSamplesPerSec * pWavFormatEx->nBlockAlign;
    pWavFormatEx->cbSize = 0;
}

VOID
LimitAudioRangeToWave (
    PWAVEFORMATEX       pWaveFormatEx,
    PKSDATARANGE_AUDIO  pDataRangeAudio)
{
    if(pDataRangeAudio->MinimumSampleFrequency <=
       pWaveFormatEx->nSamplesPerSec &&
       pDataRangeAudio->MaximumSampleFrequency >=
       pWaveFormatEx->nSamplesPerSec) {
        pDataRangeAudio->MaximumSampleFrequency = pWaveFormatEx->nSamplesPerSec;
    }
    if(pDataRangeAudio->MinimumBitsPerSample <=
       pWaveFormatEx->wBitsPerSample &&
       pDataRangeAudio->MaximumBitsPerSample >=
       pWaveFormatEx->wBitsPerSample) {
        pDataRangeAudio->MaximumBitsPerSample = pWaveFormatEx->wBitsPerSample;
    }
    if(pDataRangeAudio->MaximumChannels == MAXULONG) {
    pDataRangeAudio->MaximumChannels = pWaveFormatEx->nChannels;
    }
}

VOID
LimitAudioRange (PKSDATARANGE_AUDIO  pDataRangeAudio)
{
    WAVEFORMATEX WaveFormatEx;

    // Default values
    WaveFormatEx.nSamplesPerSec = 44100;
    WaveFormatEx.wBitsPerSample = 16;
    WaveFormatEx.nChannels = 2;

    LimitAudioRangeToWave(&WaveFormatEx, pDataRangeAudio);
}

BOOL DataIntersectionRange(
    PKSDATARANGE pDataRange1,
    PKSDATARANGE pDataRange2,
    PKSDATARANGE pDataRangeIntersection
)
{
    // Pick up pDataRange1 values by default.
    *pDataRangeIntersection = *pDataRange1;

    if(IsEqualGUID(&pDataRange1->MajorFormat, &pDataRange2->MajorFormat) ||
       IsEqualGUID(&pDataRange1->MajorFormat, &KSDATAFORMAT_TYPE_WILDCARD)) {
        pDataRangeIntersection->MajorFormat = pDataRange2->MajorFormat;
    }
    else if(!IsEqualGUID(
      &pDataRange2->MajorFormat,
      &KSDATAFORMAT_TYPE_WILDCARD)) {
        return FALSE;
    }
    if(IsEqualGUID(&pDataRange1->SubFormat, &pDataRange2->SubFormat) ||
       IsEqualGUID(&pDataRange1->SubFormat, &KSDATAFORMAT_TYPE_WILDCARD)) {
        pDataRangeIntersection->SubFormat = pDataRange2->SubFormat;
    }
    else if(!IsEqualGUID(
      &pDataRange2->SubFormat,
      &KSDATAFORMAT_TYPE_WILDCARD)) {
        return FALSE;
    }
    if(IsEqualGUID(&pDataRange1->Specifier, &pDataRange2->Specifier) ||
       IsEqualGUID(&pDataRange1->Specifier, &KSDATAFORMAT_TYPE_WILDCARD)) {
        pDataRangeIntersection->Specifier = pDataRange2->Specifier;
    }
    else if(!IsEqualGUID(
      &pDataRange2->Specifier,
      &KSDATAFORMAT_TYPE_WILDCARD)) {
        return FALSE;
    }
    pDataRangeIntersection->Reserved = 0; // Must be zero
    return(TRUE);
}


BOOL
DataIntersectionAudio(
    PKSDATARANGE_AUDIO pDataRangeAudio1,
    PKSDATARANGE_AUDIO pDataRangeAudio2,
    PKSDATARANGE_AUDIO pDataRangeAudioIntersection
)
{
    if(pDataRangeAudio1->MaximumChannels <
       pDataRangeAudio2->MaximumChannels) {
        pDataRangeAudioIntersection->MaximumChannels =
          pDataRangeAudio1->MaximumChannels;
    }
    else {
        pDataRangeAudioIntersection->MaximumChannels =
          pDataRangeAudio2->MaximumChannels;
    }

    if(pDataRangeAudio1->MaximumSampleFrequency <
       pDataRangeAudio2->MaximumSampleFrequency) {
        pDataRangeAudioIntersection->MaximumSampleFrequency =
          pDataRangeAudio1->MaximumSampleFrequency;
    }
    else {
        pDataRangeAudioIntersection->MaximumSampleFrequency =
          pDataRangeAudio2->MaximumSampleFrequency;
    }
    if(pDataRangeAudio1->MinimumSampleFrequency >
       pDataRangeAudio2->MinimumSampleFrequency) {
        pDataRangeAudioIntersection->MinimumSampleFrequency =
          pDataRangeAudio1->MinimumSampleFrequency;
    }
    else {
        pDataRangeAudioIntersection->MinimumSampleFrequency =
          pDataRangeAudio2->MinimumSampleFrequency;
    }
    if(pDataRangeAudioIntersection->MaximumSampleFrequency <
       pDataRangeAudioIntersection->MinimumSampleFrequency ) {
        return(FALSE);
    }

    if(pDataRangeAudio1->MaximumBitsPerSample <
       pDataRangeAudio2->MaximumBitsPerSample) {
        pDataRangeAudioIntersection->MaximumBitsPerSample =
          pDataRangeAudio1->MaximumBitsPerSample;
    }
    else {
        pDataRangeAudioIntersection->MaximumBitsPerSample =
          pDataRangeAudio2->MaximumBitsPerSample;
    }
    if(pDataRangeAudio1->MinimumBitsPerSample >
       pDataRangeAudio2->MinimumBitsPerSample) {
        pDataRangeAudioIntersection->MinimumBitsPerSample =
          pDataRangeAudio1->MinimumBitsPerSample;
    }
    else {
        pDataRangeAudioIntersection->MinimumBitsPerSample =
          pDataRangeAudio2->MinimumBitsPerSample;
    }
    if(pDataRangeAudioIntersection->MaximumBitsPerSample <
       pDataRangeAudioIntersection->MinimumBitsPerSample ) {
        return(FALSE);
    }
    return(TRUE);
}

NTSTATUS
DefaultIntersectHandler(
    IN PKSDATARANGE     DataRange,
    IN PKSDATARANGE     pDataRangePin,
    IN ULONG            OutputBufferLength,
    OUT PVOID           Data,
    OUT PULONG          pDataLength
    )
{
    KSDATARANGE_AUDIO   DataRangeAudioIntersection;
    ULONG               ExpectedBufferLength;
    PWAVEFORMATEX       pWaveFormatEx;
    BOOL                bDSoundFormat = FALSE;

    // Check for generic match on the specific ranges, allowing wildcards.
    if (!DataIntersectionRange(pDataRangePin,
                               DataRange,
                               &DataRangeAudioIntersection.DataRange)) {
        return STATUS_NO_MATCH;
    }

    // Check for format matches that the default handler can deal with.
    if (IsEqualGUID(
       &pDataRangePin->Specifier,
       &KSDATAFORMAT_SPECIFIER_WAVEFORMATEX))
    {
        pWaveFormatEx = &(((KSDATAFORMAT_WAVEFORMATEX *)Data)->WaveFormatEx);
        ExpectedBufferLength = sizeof(KSDATAFORMAT_WAVEFORMATEX);
    }
    else if (IsEqualGUID(
       &pDataRangePin->Specifier,
       &KSDATAFORMAT_SPECIFIER_DSOUND))
    {
        bDSoundFormat = TRUE;
        pWaveFormatEx =
          &(((KSDATAFORMAT_DSOUND *)Data)->BufferDesc.WaveFormatEx);
        ExpectedBufferLength = sizeof(KSDATAFORMAT_DSOUND);
    }
    else
    {
        return STATUS_NO_MATCH;
    }

    // GUIDs match, so check for valid intersection of audio ranges.
    if (!DataIntersectionAudio((PKSDATARANGE_AUDIO)pDataRangePin,
                               (PKSDATARANGE_AUDIO)DataRange,
                               &DataRangeAudioIntersection)) {
        return STATUS_NO_MATCH;
    }

    // Have a match!
    // Determine whether the data format itself is to be returned, or just
    // the size of the data format so that the client can allocate memory
    // for the full range.

    if (!OutputBufferLength) {
        *pDataLength = ExpectedBufferLength;
        return STATUS_BUFFER_OVERFLOW;
    } else if (OutputBufferLength < ExpectedBufferLength) {
        return STATUS_BUFFER_TOO_SMALL;
    } else {
        // Because maximums in ranges are generally random, limit maximums.
        LimitAudioRange(&DataRangeAudioIntersection);

        // Get WAV format from intersected and limited maximums.
        WaveFormatFromAudioRange(&DataRangeAudioIntersection, pWaveFormatEx);

        // Copy across DATARANGE/DATAFORMAT_x part of match, and adjust fields.
        *(PKSDATARANGE)Data = DataRangeAudioIntersection.DataRange;
        ((PKSDATAFORMAT)Data)->FormatSize = ExpectedBufferLength;

        // Fill in DSOUND specific fields, if any.
        if (bDSoundFormat) {
            ((PKSDATAFORMAT_DSOUND)Data)->BufferDesc.Flags = 0;
            ((PKSDATAFORMAT_DSOUND)Data)->BufferDesc.Control = 0;
        }
        *pDataLength = ExpectedBufferLength;
    }
    return STATUS_SUCCESS;
}

NTSTATUS
IntersectHandler(
    IN PIRP             Irp,
    IN PKSP_PIN         Pin,
    IN PKSDATARANGE     DataRange,
    OUT PVOID           Data
    )
/*++

Routine Description:

    This is the data range callback for KsPinDataIntersection, which is called by
    FilterPinIntersection to enumerate the given list of data ranges, looking for
    an acceptable match. If a data range is acceptable, a data format is copied
    into the return buffer. A STATUS_NO_MATCH continues the enumeration.

Arguments:

    Irp -
        Device control Irp.

    Pin -
        Specific property request followed by Pin factory identifier, followed by a
        KSMULTIPLE_ITEM structure. This is followed by zero or more data range structures.
        This enumeration callback does not need to look at any of this though. It need
        only look at the specific pin identifier.

    DataRange -
        Contains a specific data range to validate.

    Data -
        The place in which to return the data format selected as the first intersection
        between the list of data ranges passed, and the acceptable formats.

Return Values:

    returns STATUS_SUCCESS or STATUS_NO_MATCH, else STATUS_INVALID_PARAMETER,
    STATUS_BUFFER_TOO_SMALL, or STATUS_INVALID_BUFFER_SIZE.

--*/
{
    PIO_STACK_LOCATION  pIrpStack;
    PFILTER_INSTANCE    pFilterInstance;

    NTSTATUS            Status = STATUS_NO_MATCH;
    ULONG               OutputBufferLength;
    PKSDATARANGE        pDataRangePin;
    UINT                i;
    ULONG               DataLength = 0;

    // The underlying pin does not support data intersection.
    // Do the data intersection on its behalf for the pin formats that SYSAUDIO understands.
    //
    // All the major/sub/specifier checking has been done by the handler, but may include wildcards.
    //
    pIrpStack = IoGetCurrentIrpStackLocation( Irp );
    pFilterInstance = (PFILTER_INSTANCE)pIrpStack->FileObject->FsContext;
    OutputBufferLength = IoGetCurrentIrpStackLocation(Irp)->Parameters.DeviceIoControl.OutputBufferLength;
    for (i = 0; i < PinDescs[Pin->PinId].DataRangesCount; i++) {
        pDataRangePin = PinDescs[Pin->PinId].DataRanges[i];
        Status = DefaultIntersectHandler (DataRange,
                                          pDataRangePin,
                                          OutputBufferLength,
                                          Data,
                                          &DataLength);
        if(Status == STATUS_NO_MATCH) {
            continue;
        }
        Irp->IoStatus.Information = DataLength;
        break;
    }
    return Status;
}



NTSTATUS
FilterPinIntersection(
    IN PIRP     pIrp,
    IN PKSP_PIN Pin,
    OUT PVOID   Data
    )
/*++

Routine Description:

    Handles the KSPROPERTY_PIN_DATAINTERSECTION property in the Pin property set.
    Returns the first acceptable data format given a list of data ranges for a specified
    Pin factory. Actually just calls the Intersection Enumeration helper, which then
    calls the IntersectHandler callback with each data range.

Arguments:

    pIrp -
        Device control Irp.

    Pin -
        Specific property request followed by Pin factory identifier, followed by a
        KSMULTIPLE_ITEM structure. This is followed by zero or more data range structures.

    Data -
        The place in which to return the data format selected as the first intersection
        between the list of data ranges passed, and the acceptable formats.

Return Values:

    returns STATUS_SUCCESS or STATUS_NO_MATCH, else STATUS_INVALID_PARAMETER,
    STATUS_BUFFER_TOO_SMALL, or STATUS_INVALID_BUFFER_SIZE.

--*/
{
    PIO_STACK_LOCATION  pIrpStack;
    PFILTER_INSTANCE    pFilterInstance;

    pIrpStack = IoGetCurrentIrpStackLocation( pIrp );
    pFilterInstance = (PFILTER_INSTANCE)pIrpStack->FileObject->FsContext;
    return KsPinDataIntersection(
        pIrp,
        Pin,
        Data,
        SIZEOF_ARRAY(PinDescs), //cPins,
        PinDescs,
        IntersectHandler);
}

NTSTATUS
MxGetTunableParams
(
    PIRP    pIrp,
    PKSPROPERTY pKsProperty,
    PTUNABLEPARAMS pTunableParams
)
{
    pTunableParams->MinNumMixBuffers = gMinNumMixBuffers ;
    pTunableParams->MaxNumMixBuffers = gMaxNumMixBuffers ;
    pTunableParams->StartNumMixBuffers = gStartNumMixBuffers ;
    pTunableParams->MixBufferDuration = gMixBufferDuration ;
    pTunableParams->PreferredQuality = gPreferredQuality ;
    pTunableParams->DisableMmx = gDisableMmx ;
    pTunableParams->MaxOutputBits = gMaxOutputBits ;
    pTunableParams->MaxDsoundInChannels = gMaxDsoundInChannels ;
    pTunableParams->MaxOutChannels = gMaxOutChannels ;
    pTunableParams->MaxInChannels = gMaxInChannels ;
    pTunableParams->MaxFloatChannels = gMaxFloatChannels ;
    pTunableParams->LogToFile = gLogToFile ;
    pTunableParams->FixedSamplingRate = gFixedSamplingRate ;
    pTunableParams->EnableShortHrtf = gEnableShortHrtf ;
    pTunableParams->BuildPartialMdls = gBuildPartialMdls ;
    pTunableParams->WorkerThreadPriority = gWorkerThreadPriority ;

    pIrp->IoStatus.Information = sizeof (TUNABLEPARAMS);
    return ( STATUS_SUCCESS ) ;
}

NTSTATUS
MxSetTunableParams
(
    PIRP    pIrp,
    PKSPROPERTY pKsProperty,
    PTUNABLEPARAMS pTunableParams
)
{
    //
    // If there are other filter instances do not set any variables
    //
    if ( InterlockedCompareExchange(&gFilterInstanceCount, 0, 0) > 1 ) {
        return ( STATUS_DEVICE_NOT_READY ) ;
    }

    //
    // do some parameter validations [min<= max, start >= min etc]
    //
    if ( (pTunableParams->MinNumMixBuffers > pTunableParams->MaxNumMixBuffers) ||
         (pTunableParams->MinNumMixBuffers > pTunableParams->StartNumMixBuffers) ||
         (pTunableParams->StartNumMixBuffers > pTunableParams->MaxNumMixBuffers) ||
         (pTunableParams->MinNumMixBuffers == 0) ||
         (pTunableParams->MixBufferDuration == 0) ||
         (pTunableParams->PreferredQuality > KSAUDIO_QUALITY_ADVANCED) ||
         (pTunableParams->MaxOutputBits > 32) ||
         (pTunableParams->MaxOutputBits % 8) ||
         (pTunableParams->MaxOutputBits == 0) ||
         (pTunableParams->MaxDsoundInChannels == 0) ||
         (pTunableParams->MaxOutChannels == 0) ||
         (pTunableParams->MaxInChannels == 0) ||
         (pTunableParams->MaxFloatChannels == 0)
         || (pTunableParams->WorkerThreadPriority > 31)
        ) {
        return (STATUS_INVALID_PARAMETER) ;
    }

    gMinNumMixBuffers = pTunableParams->MinNumMixBuffers ;
    gMaxNumMixBuffers = pTunableParams->MaxNumMixBuffers ;
    gStartNumMixBuffers = pTunableParams->StartNumMixBuffers ;
    gMixBufferDuration = pTunableParams->MixBufferDuration ;

    gPreferredQuality = pTunableParams->PreferredQuality ;
    gDisableMmx = pTunableParams->DisableMmx ;
    gMaxOutputBits = pTunableParams->MaxOutputBits ;
    gMaxDsoundInChannels = pTunableParams->MaxDsoundInChannels ;
    gMaxOutChannels = pTunableParams->MaxOutChannels ;
    gMaxInChannels = pTunableParams->MaxInChannels ;
    gMaxFloatChannels = pTunableParams->MaxFloatChannels ;
    gLogToFile = pTunableParams->LogToFile ;
    gFixedSamplingRate = pTunableParams->FixedSamplingRate ;
    gEnableShortHrtf = pTunableParams->EnableShortHrtf ;
    gBuildPartialMdls = pTunableParams->BuildPartialMdls ;
    gWorkerThreadPriority = pTunableParams->WorkerThreadPriority ;

    pIrp->IoStatus.Information = sizeof (TUNABLEPARAMS);
    return ( STATUS_SUCCESS ) ;
}

NTSTATUS
MxGetPerfStats
(
    PIRP    pIrp,
    PKSPROPERTY pKsProperty,
    PPERFSTATS pPerfStats
)
{
    pPerfStats->NumMixBuffersAdded = gNumMixBuffersAdded ;
    pPerfStats->NumCompletionsWhileStarved = gNumCompletionsWhileStarved ;
    pPerfStats->NumSilenceSamplesInserted = gNumSilenceSamplesInserted ;

    pIrp->IoStatus.Information = sizeof (PERFSTATS);
    return ( STATUS_SUCCESS ) ;
}

//---------------------------------------------------------------------------
//  End of File: filter.c
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\filters\kmixer\flocal.h ===
/*++

    Copyright (c) 1998-2000 Microsoft Corporation.  All Rights Reserved.

Module Name:

    flocal.h

Abstract:

    This is the header for the floating point, HRTF 3D localizer 

Author:

    Jay Stokes (jstokes) 22-Apr-1998

--*/

#if !defined(FLOATLOCALIZER_HEADER)
#define FLOATLOCALIZER_HEADER
#pragma once

// Project-specific INCLUDEs
#include "vmaxhead.h"

#define DEFAULT_MAX_NUM_FLOAT_IIR3D_COEFFS  60

typedef struct _FLOAT_LOCALIZER 
{
    PRFIIR Iir[efilterCount];
    PFLOAT FilterOut[efilterCount];
    PFLOAT OverlapBuffer[efilterCount];
    UINT   PreviousNumSamples;
    BOOL   SwapChannels;
    BOOL   ZeroAzimuth;
    PFLOAT TempFloatBuffer;
    UINT   FilterOverlapLength;
    UINT   FilterMuteLength;
    BOOL   FirstUpdate;
    UINT   OutputOverlapLength;
    BOOL   CrossFadeOutput;
} FLOAT_LOCALIZER, *PFLOAT_LOCALIZER;

// ---------------------------------------------------------------------------
// Floating-point localizer

NTSTATUS FloatLocalizerCreate(PFLOAT_LOCALIZER*);
VOID FloatLocalizerDestroy(PFLOAT_LOCALIZER);
    
VOID FloatLocalizerLocalize(PMIXER_SINK_INSTANCE, PFLOAT, PFLOAT, UINT, BOOL);
NTSTATUS FloatLocalizerInitData(PFLOAT_LOCALIZER, KSDS3D_HRTF_FILTER_METHOD, UINT, KSDS3D_HRTF_FILTER_QUALITY, UINT, UINT, UINT);
VOID FloatLocalizerFreeBufferMemory(PFLOAT_LOCALIZER);
NTSTATUS FloatLocalizerUpdateCoeffs(PFLOAT_LOCALIZER, UINT, PFLOAT, UINT, PFLOAT, BOOL, BOOL, BOOL);
VOID FloatLocalizerFilterOverlap(PFLOAT_LOCALIZER, UINT, PFLOAT, PFLOAT, UINT);
NTSTATUS FloatLocalizerSetTransitionBufferLength(PFLOAT_LOCALIZER, UINT, UINT);
NTSTATUS FloatLocalizerSetOverlapLength(PFLOAT_LOCALIZER, UINT);


// ---------------------------------------------------------------------------
// Include inline definitions inline in release version

//#if !defined(DEBUG)
//#include "flocal.inl"
//#endif

#endif

// End of FLOATLOCALIZER.H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\filters\kmixer\fpconv.c ===
//
//    Copyright (c) 1998-2000 Microsoft Corporation.  All Rights Reserved.
//

#define SIGN_MASK           0x8000000
#define EXP_MASK            0x7F80000
#define SIGNIFICAND_MASK    0x007FFFF

#include "common.h"

LONG FpUpper
(
    FLOAT Value
)
{
    LONG Upper;

    Upper = (LONG)Value;

    return Upper;
}

ULONG FpLower
(
    FLOAT Value
)
{
    LONG  LongTemp;
    ULONG Lower;
    FLOAT FloatTemp;

    LongTemp = FpUpper(Value);
    FloatTemp = Value - LongTemp;
    Lower = (ULONG)(FloatTemp * 1000.0f);

    return Lower;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\filters\kmixer\fpconv.h ===
/*++

    Copyright (c) 1998 Microsoft Corporation

Module Name:

    fpconv.h

Abstract:

    This is the header for the FLOAT conversion routines 

Author:

    Jay Stokes (jstokes) 22-Apr-1998

--*/

#if !defined(FLOAT_HEADER)
#define FLOAT_HEADER
#pragma once

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

extern LONG FpUpper(FLOAT);
extern ULONG FpLower(FLOAT);

#ifdef __cplusplus
}
#endif // __cplusplus


#endif

// End of FPCONV.H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\filters\kmixer\iir3d.c ===
//---------------------------------------------------------------------------
//
//  Module:   iir3d.c
//
//  Description:
//
//
//@@BEGIN_MSINTERNAL
//  Development Team:
//     S.Mohanraj
//
//  History:   Date       Author      Comment
//
//  To Do:     Date       Author      Comment
//
//@@END_MSINTERNAL                                         
//
//  Copyright (c) 1996-2000 Microsoft Corporation.  All Rights Reserved.
//
//---------------------------------------------------------------------------

#include "common.h"

#define SQRT2    0.707f

ULONG __forceinline
StageMonoIir3DX
(
    PMIXER_OPERATION        CurStage,
    ULONG                   SampleCount,
    ULONG                   samplesleft,
    BOOL                    fFloat,
    BOOL                    fMixOutput
)
{
    UINT		i;
    UINT		j;
    PFLOAT		pTempFloatBuffer;
    PLONG		pTempLongBuffer;
    LONG		temp;
    FLOAT		floatTemp;

    PMIXER_SINK_INSTANCE CurSink = (PMIXER_SINK_INSTANCE) CurStage->Context;
    PLONG      pOutputBuffer = CurStage->pOutputBuffer;
    PFLOAT     pFloatBuffer = CurStage->pOutputBuffer;
    PLONG      pInputBuffer = CurStage->pInputBuffer;
    PFLOAT     pFloatInput = CurStage->pInputBuffer;
    
    if (fFloat) {

#if DBG && defined(VERIFY_HRTF_PROCESSING)
        _DbgPrintF( DEBUGLVL_TERSE, ("StageMonoIir3DX 1") );
        for(i=0; i<SampleCount; i++) {
            IsValidFloatData(pFloatInput[i],TRUE);
        }
#endif // DBG  and VERIFY_HRTF_PROCESSING

        if (FLOAT_COEFF == CurSink->CoeffFormat) {
            FloatLocalizerLocalize
            (
                CurSink, 
                pFloatInput, 
                pFloatBuffer, 
                SampleCount,
                fMixOutput
            );
        } else {

            for(i=0; i<SampleCount; i++)
            {
                pInputBuffer[i] = ConvertFloatToLong(pFloatInput[i]);
#if DBG && defined(VERIFY_HRTF_PROCESSING)
               _DbgPrintF( DEBUGLVL_TERSE, ("StageMonoIir3DX 2") );
               IsValidShortData(pInputInput[i],TRUE);
#endif // DBG  and VERIFY_HRTF_PROCESSING

#if DETECT_HRTF_SATURATION
                // Saturate to maximum
                if (pInputBuffer[i] > MaxSaturation) {
                    pInputBuffer[i] = MaxSaturation;
                    _DbgPrintF( DEBUGLVL_VERBOSE, ("Sample exceeded maximum saturation value Iir3d 1") );
                }
        
                // Saturate to minimum
                if (pInputBuffer[i] < MinSaturation) {
                    pInputBuffer[i] = MinSaturation;
                    _DbgPrintF( DEBUGLVL_VERBOSE, ("Sample exceeded maximum saturation value Iir3d 1") );
                }
#endif
            }

            if (fMixOutput) {

                if (!CurSink->pShortLocalizer) {
                    // We can't run the HRTF 3D algorithm without a valid ShortLocalizer
                    // Mute the output. 
                    j = 0;
                    for(i=0; i<SampleCount; i++)
                    {
                        floatTemp = (FLOAT)(SQRT2*pFloatBuffer[i]);
                        pFloatBuffer[j++] = floatTemp;
                        pFloatBuffer[j++] = floatTemp;
                    }
                    return SampleCount;
                }

#ifndef REALTIME_THREAD
                if (!CurSink->pShortLocalizer->TempLongBuffer ||
                    SampleCount > CurSink->pShortLocalizer->PreviousNumSamples) {

                    if (CurSink->pShortLocalizer->TempLongBuffer) {
                        ExFreePool(CurSink->pShortLocalizer->TempLongBuffer);
                        CurSink->pShortLocalizer->TempLongBuffer = NULL;
                    }
                    CurSink->pShortLocalizer->TempLongBuffer = ExAllocatePoolWithTag(PagedPool, 2*SampleCount*sizeof(LONG), 'XIMK');
                    if (!CurSink->pShortLocalizer->TempLongBuffer) {
                        // Couldn't allocate the buffer. Mute the output. 
                        j = 0;
                        for(i=0; i<SampleCount; i++)
                        {
                            floatTemp = (FLOAT)(SQRT2*pInputBuffer[i]);
                            pFloatBuffer[j++] = floatTemp;
                            pFloatBuffer[j++] = floatTemp;
                        }
                        return SampleCount;
                    }
            	}
#else
                if (!CurSink->pShortLocalizer->TempLongBuffer ||
                    SampleCount > CurSink->pShortLocalizer->PreviousNumSamples) {
                    // Couldn't allocate the buffer. Mute the output. 
                    j = 0;
                    for(i=0; i<SampleCount; i++)
                    {
                        floatTemp = (FLOAT)(SQRT2*pInputBuffer[i]);
                        pFloatBuffer[j++] = floatTemp;
                        pFloatBuffer[j++] = floatTemp;
                    }
                    return SampleCount;
            	}
#endif

                pTempLongBuffer = CurSink->pShortLocalizer->TempLongBuffer;
                
                ShortLocalizerLocalize
                (
                    CurSink->pShortLocalizer, 
                    pInputBuffer, 
                    pTempLongBuffer, 
                    SampleCount,
                    FALSE
                );
    
                for(i=0; i<2*SampleCount; i++)
                {
                    pFloatBuffer[i] += (FLOAT)(pTempLongBuffer[i]);
                }

            } else {

                ShortLocalizerLocalize
                (
                    CurSink->pShortLocalizer, 
                    pInputBuffer, 
                    pOutputBuffer, 
                    SampleCount,
                    FALSE
                );
    
                for(i=0; i<2*SampleCount; i++)
                {
                    pFloatBuffer[i] = (FLOAT)(pOutputBuffer[i]);
                }
            }
        }
    } else {

#if DBG && defined(VERIFY_HRTF_PROCESSING)
        _DbgPrintF( DEBUGLVL_TERSE, ("StageMonoIir3DX 3") );
        for(i=0; i<SampleCount; i++) {
            IsValidShortData(pInputInput[i],TRUE);
        }
#endif // DBG  and VERIFY_HRTF_PROCESSING

        if (FLOAT_COEFF == CurSink->CoeffFormat) {
		i = 0;
#if 0
#ifdef _X86_
                _asm {
                    mov     ecx, 16
                    mov     edx, j
                    cmp     ecx, edx
                    jge     Done
    
                    mov     esi, pInputBuffer 
                    mov     edi, pFloatInput
                Start:
                    fild    DWORD PTR [esi+ecx*4-64]
                    fstp    DWORD PTR [edi+ecx*4-64]
                    fild    DWORD PTR [esi+ecx*4-60]
                    fstp    DWORD PTR [edi+ecx*4-60]
                    fild    DWORD PTR [esi+ecx*4-56]
                    fstp    DWORD PTR [edi+ecx*4-56]
                    fild    DWORD PTR [esi+ecx*4-52]
                    fstp    DWORD PTR [edi+ecx*4-52]
                    fild    DWORD PTR [esi+ecx*4-48]
                    fstp    DWORD PTR [edi+ecx*4-48]
                    fild    DWORD PTR [esi+ecx*4-44]
                    fstp    DWORD PTR [edi+ecx*4-44]
                    fild    DWORD PTR [esi+ecx*4-40]
                    fstp    DWORD PTR [edi+ecx*4-40]
                    fild    DWORD PTR [esi+ecx*4-36]
                    fstp    DWORD PTR [edi+ecx*4-36]
                    fild    DWORD PTR [esi+ecx*4-32]
                    fstp    DWORD PTR [edi+ecx*4-32]
                    fild    DWORD PTR [esi+ecx*4-28]
                    fstp    DWORD PTR [edi+ecx*4-28]
                    fild    DWORD PTR [esi+ecx*4-24]
                    fstp    DWORD PTR [edi+ecx*4-24]
                    fild    DWORD PTR [esi+ecx*4-20]
                    fstp    DWORD PTR [edi+ecx*4-20]
                    fild    DWORD PTR [esi+ecx*4-16]
                    fstp    DWORD PTR [edi+ecx*4-16]
                    fild    DWORD PTR [esi+ecx*4-12]
                    fstp    DWORD PTR [edi+ecx*4-12]
                    fild    DWORD PTR [esi+ecx*4- 8]
                    fstp    DWORD PTR [edi+ecx*4- 8]
                    fild    DWORD PTR [esi+ecx*4- 4]
                    fstp    DWORD PTR [edi+ecx*4- 4]
                    add     ecx, 16
                    cmp     ecx, edx
                    jl      Start
                Done:
                    mov     i, ecx 
                }
#else
            for (i = 16; i < SampleCount; i += 16)
            {
                pFloatInput[i-16] = (FLOAT)(pInputBuffer[i-16]);
                pFloatInput[i-15] = (FLOAT)(pInputBuffer[i-15]);
                pFloatInput[i-14] = (FLOAT)(pInputBuffer[i-14]);
                pFloatInput[i-13] = (FLOAT)(pInputBuffer[i-13]);
                pFloatInput[i-12] = (FLOAT)(pInputBuffer[i-12]);
                pFloatInput[i-11] = (FLOAT)(pInputBuffer[i-11]);
                pFloatInput[i-10] = (FLOAT)(pInputBuffer[i-10]);
                pFloatInput[i- 9] = (FLOAT)(pInputBuffer[i- 9]);
                pFloatInput[i- 8] = (FLOAT)(pInputBuffer[i- 8]);
                pFloatInput[i- 7] = (FLOAT)(pInputBuffer[i- 7]);
                pFloatInput[i- 6] = (FLOAT)(pInputBuffer[i- 6]);
                pFloatInput[i- 5] = (FLOAT)(pInputBuffer[i- 5]);
                pFloatInput[i- 4] = (FLOAT)(pInputBuffer[i- 4]);
                pFloatInput[i- 3] = (FLOAT)(pInputBuffer[i- 3]);
                pFloatInput[i- 2] = (FLOAT)(pInputBuffer[i- 2]);
                pFloatInput[i- 1] = (FLOAT)(pInputBuffer[i- 1]);
            }
#endif

            i -= 16;
#endif
            for(; i<SampleCount; i++)
            {
                pFloatInput[i] = (FLOAT)(pInputBuffer[i]);
            }

#if DBG && defined(VERIFY_HRTF_PROCESSING)
        _DbgPrintF( DEBUGLVL_TERSE, ("StageMonoIir3DX 4") );
        for(i=0; i<SampleCount; i++) {
            IsValidFloatData(pFloatInput[i],TRUE);
        }
#endif // DBG  and VERIFY_HRTF_PROCESSING

            if (fMixOutput) {

                if (!CurSink->pFloatLocalizer) {
                    // We can't run the HRTF 3D algorithm without a valid FloatLocalizer
                    // Mute the output. 
                    j = 0;
                    for(i=0; i<SampleCount; i++)
                    {
                        temp = (LONG)(SQRT2*pInputBuffer[i]);
                        pOutputBuffer[j++] = temp;
                        pOutputBuffer[j++] = temp;
                    }
                    return SampleCount;
                }

#ifndef REALTIME_THREAD
                if (!CurSink->pFloatLocalizer->TempFloatBuffer ||
                    SampleCount > CurSink->pFloatLocalizer->PreviousNumSamples) {

                    if (CurSink->pFloatLocalizer->TempFloatBuffer) {
                        ExFreePool(CurSink->pFloatLocalizer->TempFloatBuffer);
                        CurSink->pFloatLocalizer->TempFloatBuffer = NULL;
                    }
                    CurSink->pFloatLocalizer->TempFloatBuffer = ExAllocatePoolWithTag(PagedPool, 2*SampleCount*sizeof(FLOAT), 'XIMK');
                    if (!CurSink->pFloatLocalizer->TempFloatBuffer) {
                        // Couldn't allocate the buffer. Mute the output. 
                        j = 0;
                        for(i=0; i<SampleCount; i++)
                        {
                            temp = (LONG)(SQRT2*pInputBuffer[i]);
                            pOutputBuffer[j++] = temp;
                            pOutputBuffer[j++] = temp;
                        }
                        return SampleCount;
                    }
            	}
#else
                if (!CurSink->pFloatLocalizer->TempFloatBuffer ||
                    SampleCount > CurSink->pFloatLocalizer->PreviousNumSamples) {
                    // Couldn't allocate the buffer. Mute the output. 
                    j = 0;
                    for(i=0; i<SampleCount; i++)
                    {
                        temp = (LONG)(SQRT2*pInputBuffer[i]);
                        pOutputBuffer[j++] = temp;
                        pOutputBuffer[j++] = temp;
                    }
                    return SampleCount;
            	}

#endif

                pTempFloatBuffer = CurSink->pFloatLocalizer->TempFloatBuffer;
                
                FloatLocalizerLocalize
                (
                    CurSink, 
                    pFloatInput, 
                    pTempFloatBuffer, 
                    SampleCount,
                    FALSE
                );
    
                i = 0   ;
                j = 2 * SampleCount;
#if 0
#ifdef _X86_
                _asm {
                    mov     ecx, 16
                    mov     edx, j
                    cmp     ecx, edx
                    jge     Donex
    
                    mov     esi, pTempFloatBuffer 
                    mov     edi, pOutputBuffer
                Startx:
                    mov     eax, DWORD PTR [edi+ecx*4-64]
                    fld     DWORD PTR [esi+ecx*4-64]
                    fistp   DWORD PTR [edi+ecx*4-64]

                    mov     ebx, DWORD PTR [edi+ecx*4-60]
                    add     DWORD PTR [edi+ecx*4-64], eax
                    fld     DWORD PTR [esi+ecx*4-60]
                    fistp   DWORD PTR [edi+ecx*4-60]

                    mov     eax, DWORD PTR [edi+ecx*4-56]
                    add     DWORD PTR [edi+ecx*4-60], ebx
                    fld     DWORD PTR [esi+ecx*4-56]
                    fistp   DWORD PTR [edi+ecx*4-56]

                    mov     ebx, DWORD PTR [edi+ecx*4-52]
                    add     DWORD PTR [edi+ecx*4-56], eax
                    fld     DWORD PTR [esi+ecx*4-52]
                    fistp   DWORD PTR [edi+ecx*4-52]

                    mov     eax, DWORD PTR [edi+ecx*4-48]
                    add     DWORD PTR [edi+ecx*4-52], ebx
                    fld     DWORD PTR [esi+ecx*4-48]
                    fistp   DWORD PTR [edi+ecx*4-48]

                    mov     ebx, DWORD PTR [edi+ecx*4-44]
                    add     DWORD PTR [edi+ecx*4-48], eax
                    fld     DWORD PTR [esi+ecx*4-44]
                    fistp   DWORD PTR [edi+ecx*4-44]

                    mov     eax, DWORD PTR [edi+ecx*4-40]
                    add     DWORD PTR [edi+ecx*4-44], ebx
                    fld     DWORD PTR [esi+ecx*4-40]
                    fistp   DWORD PTR [edi+ecx*4-40]

                    mov     ebx, DWORD PTR [edi+ecx*4-36]
                    add     DWORD PTR [edi+ecx*4-40], eax
                    fld     DWORD PTR [esi+ecx*4-36]
                    fistp   DWORD PTR [edi+ecx*4-36]

                    mov     eax, DWORD PTR [edi+ecx*4-32]
                    add     DWORD PTR [edi+ecx*4-36], ebx
                    fld     DWORD PTR [esi+ecx*4-32]
                    fistp   DWORD PTR [edi+ecx*4-32]

                    mov     ebx, DWORD PTR [edi+ecx*4-28]
                    add     DWORD PTR [edi+ecx*4-32], eax
                    fld     DWORD PTR [esi+ecx*4-28]
                    fistp   DWORD PTR [edi+ecx*4-28]

                    mov     eax, DWORD PTR [edi+ecx*4-24]
                    add     DWORD PTR [edi+ecx*4-28], ebx
                    fld     DWORD PTR [esi+ecx*4-24]
                    fistp   DWORD PTR [edi+ecx*4-24]

                    mov     ebx, DWORD PTR [edi+ecx*4-20]
                    add     DWORD PTR [edi+ecx*4-24], eax
                    fld     DWORD PTR [esi+ecx*4-20]
                    fistp   DWORD PTR [edi+ecx*4-20]

                    mov     eax, DWORD PTR [edi+ecx*4-16]
                    add     DWORD PTR [edi+ecx*4-20], ebx
                    fld     DWORD PTR [esi+ecx*4-16]
                    fistp   DWORD PTR [edi+ecx*4-16]

                    mov     ebx, DWORD PTR [edi+ecx*4-12]
                    add     DWORD PTR [edi+ecx*4-16], eax
                    fld     DWORD PTR [esi+ecx*4-12]
                    fistp   DWORD PTR [edi+ecx*4-12]

                    mov     eax, DWORD PTR [edi+ecx*4- 8]
                    add     DWORD PTR [edi+ecx*4-12], ebx
                    fld     DWORD PTR [esi+ecx*4- 8]
                    fistp   DWORD PTR [edi+ecx*4- 8]

                    mov     ebx, DWORD PTR [edi+ecx*4-4]
                    add     DWORD PTR [edi+ecx*4- 8], eax
                    fld     DWORD PTR [esi+ecx*4- 4]
                    fistp   DWORD PTR [edi+ecx*4- 4]

                    add     DWORD PTR [edi+ecx*4- 4], ebx
                    add     ecx, 16
                    cmp     ecx, edx
                    jl      Startx
                Donex:
                    mov     i, ecx 
                }
#else
#define CFL ConvertFloatToLong

                for (i = 16; i < j; i += 16)
                {
                    pOutputBuffer[i-16] += CFL(pTempFloatBuffer[i-16]);
                    pOutputBuffer[i-15] += CFL(pTempFloatBuffer[i-15]);
                    pOutputBuffer[i-14] += CFL(pTempFloatBuffer[i-14]);
                    pOutputBuffer[i-13] += CFL(pTempFloatBuffer[i-13]);
                    pOutputBuffer[i-12] += CFL(pTempFloatBuffer[i-12]);
                    pOutputBuffer[i-11] += CFL(pTempFloatBuffer[i-11]);
                    pOutputBuffer[i-10] += CFL(pTempFloatBuffer[i-10]);
                    pOutputBuffer[i- 9] += CFL(pTempFloatBuffer[i- 9]);
                    pOutputBuffer[i- 8] += CFL(pTempFloatBuffer[i- 8]);
                    pOutputBuffer[i- 7] += CFL(pTempFloatBuffer[i- 7]);
                    pOutputBuffer[i- 6] += CFL(pTempFloatBuffer[i- 6]);
                    pOutputBuffer[i- 5] += CFL(pTempFloatBuffer[i- 5]);
                    pOutputBuffer[i- 4] += CFL(pTempFloatBuffer[i- 4]);
                    pOutputBuffer[i- 3] += CFL(pTempFloatBuffer[i- 3]);
                    pOutputBuffer[i- 2] += CFL(pTempFloatBuffer[i- 2]);
                    pOutputBuffer[i- 1] += CFL(pTempFloatBuffer[i- 1]);
                }
#undef CFL
#endif
                i -= 16;
#endif
                for(; i<j; i++)
                {
                    pOutputBuffer[i] += ConvertFloatToLong(pTempFloatBuffer[i]);
                }

            } else {

                FloatLocalizerLocalize
                (
                    CurSink, 
                    pFloatInput, 
                    pFloatBuffer, 
                    SampleCount,
                    FALSE
                );
    
                i = 0;
                j = 2 * SampleCount;

#if 0
#ifdef _X86_
                _asm {
                    mov     ecx, 16
                    mov     edx, j
                    cmp     ecx, edx
                    jge     Doney
    
                    mov     esi, pFloatBuffer 
                    mov     edi, pOutputBuffer
                Starty:
                    fld     DWORD PTR [esi+ecx*4-64]
                    fistp   DWORD PTR [edi+ecx*4-64]
                    fld     DWORD PTR [esi+ecx*4-60]
                    fistp   DWORD PTR [edi+ecx*4-60]
                    fld     DWORD PTR [esi+ecx*4-56]
                    fistp   DWORD PTR [edi+ecx*4-56]
                    fld     DWORD PTR [esi+ecx*4-52]
                    fistp   DWORD PTR [edi+ecx*4-52]
                    fld     DWORD PTR [esi+ecx*4-48]
                    fistp   DWORD PTR [edi+ecx*4-48]
                    fld     DWORD PTR [esi+ecx*4-44]
                    fistp   DWORD PTR [edi+ecx*4-44]
                    fld     DWORD PTR [esi+ecx*4-40]
                    fistp   DWORD PTR [edi+ecx*4-40]
                    fld     DWORD PTR [esi+ecx*4-36]
                    fistp   DWORD PTR [edi+ecx*4-36]
                    fld     DWORD PTR [esi+ecx*4-32]
                    fistp   DWORD PTR [edi+ecx*4-32]
                    fld     DWORD PTR [esi+ecx*4-28]
                    fistp   DWORD PTR [edi+ecx*4-28]
                    fld     DWORD PTR [esi+ecx*4-24]
                    fistp   DWORD PTR [edi+ecx*4-24]
                    fld     DWORD PTR [esi+ecx*4-20]
                    fistp   DWORD PTR [edi+ecx*4-20]
                    fld     DWORD PTR [esi+ecx*4-16]
                    fistp   DWORD PTR [edi+ecx*4-16]
                    fld     DWORD PTR [esi+ecx*4-12]
                    fistp   DWORD PTR [edi+ecx*4-12]
                    fld     DWORD PTR [esi+ecx*4- 8]
                    fistp   DWORD PTR [edi+ecx*4- 8]
                    fld     DWORD PTR [esi+ecx*4- 4]
                    fistp   DWORD PTR [edi+ecx*4- 4]
                    add     ecx, 16
                    cmp     ecx, edx
                    jl      Starty
                Doney:
                    mov     i, ecx 
                }
#else
#define CFL ConvertFloatToLong
                for (i = 16; i < j; i += 16)
                {
                    pOutputBuffer[i-16] = CFL(pFloatBuffer[i-16]);
                    pOutputBuffer[i-15] = CFL(pFloatBuffer[i-15]);
                    pOutputBuffer[i-14] = CFL(pFloatBuffer[i-14]);
                    pOutputBuffer[i-13] = CFL(pFloatBuffer[i-13]);
                    pOutputBuffer[i-12] = CFL(pFloatBuffer[i-12]);
                    pOutputBuffer[i-11] = CFL(pFloatBuffer[i-11]);
                    pOutputBuffer[i-10] = CFL(pFloatBuffer[i-10]);
                    pOutputBuffer[i- 9] = CFL(pFloatBuffer[i- 9]);
                    pOutputBuffer[i- 8] = CFL(pFloatBuffer[i- 8]);
                    pOutputBuffer[i- 7] = CFL(pFloatBuffer[i- 7]);
                    pOutputBuffer[i- 6] = CFL(pFloatBuffer[i- 6]);
                    pOutputBuffer[i- 5] = CFL(pFloatBuffer[i- 5]);
                    pOutputBuffer[i- 4] = CFL(pFloatBuffer[i- 4]);
                    pOutputBuffer[i- 3] = CFL(pFloatBuffer[i- 3]);
                    pOutputBuffer[i- 2] = CFL(pFloatBuffer[i- 2]);
                    pOutputBuffer[i- 1] = CFL(pFloatBuffer[i- 1]);
                }

#undef CFL
#endif
                i -= 16;
#endif
                for(; i<j; i++)
                {
                    pOutputBuffer[i] = ConvertFloatToLong(pFloatBuffer[i]);
                }
            }

        } else {

            ShortLocalizerLocalize
            (
                CurSink->pShortLocalizer, 
                pInputBuffer, 
                pOutputBuffer, 
                SampleCount,
                fMixOutput
            );

        }

    }

    return SampleCount;
}

ULONG StageMonoIir3D( PMIXER_OPERATION CurStage, ULONG SampleCount, ULONG samplesleft )
{
    return StageMonoIir3DX(CurStage, SampleCount, samplesleft, FALSE, FALSE);
}

ULONG StageMonoIir3DFloat( PMIXER_OPERATION CurStage, ULONG SampleCount, ULONG samplesleft )
{
    KFLOATING_SAVE     FloatSave;
    ULONG nOutputSamples;

    SaveFloatState(&FloatSave);
    nOutputSamples = StageMonoIir3DX(CurStage, SampleCount, samplesleft, TRUE, FALSE);
    RestoreFloatState(&FloatSave);
    return nOutputSamples;
}

ULONG StageMonoIir3DMix( PMIXER_OPERATION CurStage, ULONG SampleCount, ULONG samplesleft )
{
    return StageMonoIir3DX(CurStage, SampleCount, samplesleft, FALSE, TRUE);
}

ULONG StageMonoIir3DFloatMix( PMIXER_OPERATION CurStage, ULONG SampleCount, ULONG samplesleft )
{
    KFLOATING_SAVE     FloatSave;
    ULONG nOutputSamples;

    SaveFloatState(&FloatSave);
    nOutputSamples = StageMonoIir3DX(CurStage, SampleCount, samplesleft, TRUE, TRUE);
    RestoreFloatState(&FloatSave);
    return nOutputSamples;
} 

ULONG __forceinline
StageStereoIir3DX
(
    PMIXER_OPERATION        CurStage,
    ULONG                   SampleCount,
    ULONG                   samplesleft,
    BOOL                    fFloat,
    BOOL                    fMixOutput
)
{
    ULONG	samp;
    PFLOAT	pFloatSample;
    PLONG	pLongSample;
    UINT	i;
    UINT	j;
    PFLOAT	pTempFloatBuffer;
    PLONG	pTempLongBuffer;

    PMIXER_SINK_INSTANCE CurSink = (PMIXER_SINK_INSTANCE) CurStage->Context;
    PLONG      pOutputBuffer = CurStage->pOutputBuffer;
    PFLOAT     pFloatBuffer = CurStage->pOutputBuffer;
    PLONG      pInputBuffer = CurStage->pInputBuffer;
    PFLOAT     pFloatInput = CurStage->pInputBuffer;
    
    if (fFloat) {

        // Average the stereo input samples
        pFloatSample = pFloatInput;
        for ( samp=0; samp<SampleCount; samp++ ) {
            // Filter the left and right channels
            *pFloatSample = (*(pFloatInput) + *(pFloatInput+1))*(0.5f);
            pFloatInput += 2;
            pFloatSample++;
        }

#if DBG && defined(VERIFY_HRTF_PROCESSING)
        _DbgPrintF( DEBUGLVL_TERSE, ("StageStereoIir3DX 1") );
        for(i=0; i<SampleCount; i++) {
            IsValidFloatData(pFloatInput[i],TRUE);
        }
#endif // DBG  and VERIFY_HRTF_PROCESSING

        pFloatInput = CurStage->pInputBuffer;

        if (FLOAT_COEFF == CurSink->CoeffFormat) {

            FloatLocalizerLocalize
            (
                CurSink, 
                pFloatInput, 
                pFloatBuffer, 
                SampleCount,
                fMixOutput
            );
        } else {
            for(i=0; i<SampleCount; i++)
            {
                pInputBuffer[i] = ConvertFloatToLong(pFloatInput[i]);

#if DBG && defined(VERIFY_HRTF_PROCESSING)
               _DbgPrintF( DEBUGLVL_TERSE, ("StageStereoIir3DX 2") );
               IsValidShortData(pInputBuffer[i],TRUE);
#endif // DBG  and VERIFY_HRTF_PROCESSING

#if DETECT_HRTF_SATURATION
                // Saturate to maximum
                if (pInputBuffer[i] > MaxSaturation) {
                    pInputBuffer[i] = MaxSaturation;
                    _DbgPrintF( DEBUGLVL_VERBOSE, ("Sample exceeded maximum saturation value Iir3d 2") );
                }
        
                // Saturate to minimum
                if (pInputBuffer[i] < MinSaturation) {
                    pInputBuffer[i] = MinSaturation;
                    _DbgPrintF( DEBUGLVL_VERBOSE, ("Sample exceeded maximum saturation value Iir3d 2") );
                }
#endif
            }

            if (fMixOutput) {

                if (!CurSink->pShortLocalizer) {
                    // We can't run the HRTF 3D algorithm without a valid FloatLocalizer
                    // Mute the output. 
                    j = 0;
                    for(i=0; i<2*SampleCount; i++)
                    {
                        pFloatBuffer[j++] = pFloatInput[i];
                    }
                    return SampleCount;
                }

#ifndef REALTIME_THREAD
                if(!CurSink->pShortLocalizer->TempLongBuffer ||
                   SampleCount > CurSink->pShortLocalizer->PreviousNumSamples) {

                    if (CurSink->pShortLocalizer->TempLongBuffer) {
                        ExFreePool(CurSink->pShortLocalizer->TempLongBuffer);
                        CurSink->pShortLocalizer->TempLongBuffer = NULL;
                    }
                    CurSink->pShortLocalizer->TempLongBuffer = ExAllocatePoolWithTag(PagedPool, 2*SampleCount*sizeof(LONG), 'XIMK');
                    if (!CurSink->pShortLocalizer->TempLongBuffer) {
                        // Couldn't allocate the buffer. Copy the output. 
                        j = 0;
                        for(i=0; i<2*SampleCount; i++)
                        {
                            pFloatBuffer[j++] = pFloatInput[i];
                        }
                        return SampleCount;
                    }
            	}
#else
                if(!CurSink->pShortLocalizer->TempLongBuffer ||
                   SampleCount > CurSink->pShortLocalizer->PreviousNumSamples) {
                    // Couldn't allocate the buffer. Copy the output. 
                    j = 0;
                    for(i=0; i<2*SampleCount; i++)
                    {
                        pFloatBuffer[j++] = pFloatInput[i];
                    }
                    return SampleCount;
            	}
#endif
                pTempLongBuffer = CurSink->pShortLocalizer->TempLongBuffer;
                
                ShortLocalizerLocalize
                (
                    CurSink->pShortLocalizer, 
                    pInputBuffer, 
                    pTempLongBuffer, 
                    SampleCount,
                    FALSE
                );
    
                for(i=0; i<2*SampleCount; i++)
                {
                    pFloatBuffer[i] += (FLOAT)(pTempLongBuffer[i]);
                }

            } else {

                ShortLocalizerLocalize
                (
                    CurSink->pShortLocalizer, 
                    pInputBuffer, 
                    pOutputBuffer, 
                    SampleCount,
                    FALSE
                );
    
                for(i=0; i<2*SampleCount; i++)
                {
                    pFloatBuffer[i] = (FLOAT)(pOutputBuffer[i]);
                }
            }

        }

    } else {

        // Average the stereo input samples
        pLongSample = pInputBuffer;
        for ( samp=0; samp<SampleCount; samp++ ) {
            // Filter the left and right channels
            // The compiler will optimize out the /2 to the correct shift.
            *pLongSample = (SHORT)((*(pInputBuffer) + *(pInputBuffer+1))/2);
            pInputBuffer += 2;
            pLongSample++;
        }

        pInputBuffer = CurStage->pInputBuffer;

#if DBG && defined(VERIFY_HRTF_PROCESSING)
               _DbgPrintF( DEBUGLVL_TERSE, ("StageStereoIir3DX 3") );
               for(i=0; i<SampleCount; i++) {
                   IsValidShortData(pInputBuffer[i],TRUE);
               }
#endif // DBG  and VERIFY_HRTF_PROCESSING


        if (FLOAT_COEFF == CurSink->CoeffFormat) {
            for(i=0; i<SampleCount; i++)
            {
#if DETECT_HRTF_SATURATION
                // Saturate to maximum
                if (pInputBuffer[i] > MaxSaturation) {
                    pInputBuffer[i] = MaxSaturation;
                    _DbgPrintF( DEBUGLVL_VERBOSE, ("Sample exceeded maximum saturation value Iir3d 3") );
                }

                // Saturate to minimum
                if (pInputBuffer[i] < MinSaturation) {
                    pInputBuffer[i] = MinSaturation;
                    _DbgPrintF( DEBUGLVL_VERBOSE, ("Sample exceeded maximum saturation value Iir3d 3") );
                }
#endif
                pFloatInput[i] = (FLOAT)(pInputBuffer[i]);
            }

#if DBG && defined(VERIFY_HRTF_PROCESSING)
        _DbgPrintF( DEBUGLVL_TERSE, ("StageStereoIir3DX 4") );
        for(i=0; i<SampleCount; i++) {
            IsValidFloatData(pFloatInput[i],TRUE);
        }
#endif // DBG  and VERIFY_HRTF_PROCESSING

            if (fMixOutput) {

                if (!CurSink->pFloatLocalizer) {
                    // We can't run the HRTF 3D algorithm without a valid FloatLocalizer
                    // Mute the output. 
                    j = 0;
                    for(i=0; i<2*SampleCount; i++)
                    {
                        pOutputBuffer[j++] = pInputBuffer[i];
                    }
                    return SampleCount;
                }

#ifndef REALTIME_THREAD
                if(!CurSink->pFloatLocalizer->TempFloatBuffer ||
                   SampleCount > CurSink->pFloatLocalizer->PreviousNumSamples) {

                    if (CurSink->pFloatLocalizer->TempFloatBuffer) {
                        ExFreePool(CurSink->pFloatLocalizer->TempFloatBuffer);
                        CurSink->pFloatLocalizer->TempFloatBuffer = NULL;
                    }
                    CurSink->pFloatLocalizer->TempFloatBuffer = ExAllocatePoolWithTag(PagedPool, 2*SampleCount*sizeof(FLOAT), 'XIMK');
                    if (!CurSink->pFloatLocalizer->TempFloatBuffer) {
                        // Couldn't allocate the buffer. Copy the output. 
                        j = 0;
                        for(i=0; i<2*SampleCount; i++)
                        {
                            pOutputBuffer[j++] = pInputBuffer[i];
                        }
                        return SampleCount;
                    }
            	}
#else
                if(!CurSink->pFloatLocalizer->TempFloatBuffer ||
                   SampleCount > CurSink->pFloatLocalizer->PreviousNumSamples) {
                    // Couldn't allocate the buffer. Copy the output. 
                    j = 0;
                    for(i=0; i<2*SampleCount; i++)
                    {
                        pOutputBuffer[j++] = pInputBuffer[i];
                    }
                    return SampleCount;
            	}
#endif

                pTempFloatBuffer = CurSink->pFloatLocalizer->TempFloatBuffer;
                
                FloatLocalizerLocalize
                (
                    CurSink, 
                    pFloatInput, 
                    pTempFloatBuffer, 
                    SampleCount,
                    FALSE
                );
    
                for(i=0; i<2*SampleCount; i++)
                {
                    pOutputBuffer[i] += ConvertFloatToLong(pTempFloatBuffer[i]);
                }

            } else {

                FloatLocalizerLocalize
                (
                    CurSink, 
                    pFloatInput, 
                    pFloatBuffer, 
                    SampleCount,
                    FALSE
                );
    
                for(i=0; i<2*SampleCount; i++)
                {
                    pOutputBuffer[i] = ConvertFloatToLong(pFloatBuffer[i]);
                }
            }

        } else {

            ShortLocalizerLocalize
            (
                CurSink->pShortLocalizer, 
                pInputBuffer, 
                pOutputBuffer, 
                SampleCount,
                fMixOutput
            );

        }
    }

    return SampleCount;
}

ULONG StageStereoIir3D( PMIXER_OPERATION CurStage, ULONG SampleCount, ULONG samplesleft )
{
    return StageStereoIir3DX(CurStage, SampleCount, samplesleft, FALSE, FALSE);
}

ULONG StageStereoIir3DFloat( PMIXER_OPERATION CurStage, ULONG SampleCount, ULONG samplesleft )
{
    KFLOATING_SAVE     FloatSave;
    ULONG nOutputSamples;

    SaveFloatState(&FloatSave);
    nOutputSamples = StageStereoIir3DX(CurStage, SampleCount, samplesleft, TRUE, FALSE);
    RestoreFloatState(&FloatSave);
    return nOutputSamples;
}

ULONG StageStereoIir3DMix( PMIXER_OPERATION CurStage, ULONG SampleCount, ULONG samplesleft )
{
    return StageStereoIir3DX(CurStage, SampleCount, samplesleft, FALSE, TRUE);
}

ULONG StageStereoIir3DFloatMix( PMIXER_OPERATION CurStage, ULONG SampleCount, ULONG samplesleft )
{
    KFLOATING_SAVE     FloatSave;
    ULONG nOutputSamples;

    SaveFloatState(&FloatSave);
    nOutputSamples = StageStereoIir3DX(CurStage, SampleCount, samplesleft, TRUE, TRUE);
    RestoreFloatState(&FloatSave);
    return nOutputSamples;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\filters\kmixer\modeflag.h ===
//---------------------------------------------------------------------------
//
//  Module:   modeflag.h
//
//  Description:
//
//
//@@BEGIN_MSINTERNAL
//  Development Team:
//     Jeff Taylor
//
//  History:   Date       Author      Comment
//
//  To Do:     Date       Author      Comment
//
//@@END_MSINTERNAL                                         
//
//  Copyright (c) 1997-2000 Microsoft Corporation.  All Rights Reserved.
//
//---------------------------------------------------------------------------

#define H_8_BITS	0
#define H_16_BITS  	1
#define H_MONO     	0
#define H_STEREO   	2
#define H_UNSIGNED	0 
#define H_SIGNED	4
#define H_ORDER_LR	0
#define H_ORDER_RL	8
#define H_NO_FILTER	0
#define H_FILTER	16
#define H_BASEMASK	31
#define H_NO_LOOP	0
#define H_LOOP		256
#define H_BUILD_MONO	256
#define H_BUILD_STEREO  32
#define H_NO_RESAMPLE	0
#define H_RESAMPLE	64
#define H_NO_SCALE	0
#define H_SCALE		128
#define H_NO_CLIP	0
#define H_CLIP		32
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\filters\kmixer\mix.c ===
/* MIX.C
 *
 * This file is a port of mix.asm.  All functionality should idealy be
 * identical.
 *
 * Revision History:
 *
 * 9/30/95   angusm   Initial Version
 *    Copyright (c) 1995-2000 Microsoft Corporation. All Rights Reserved.
 */

/* The following is m4 code */

/*  










 
 */

/*  */




#define NODSOUNDSERVICETABLE

#include "common.h"
#include <limits.h>

#define DIVIDEBY2(x)		( (x) >>  1 )
#define DIVIDEBY256(x)		( (x) >>  8 )
#define DIVIDEBY2POW16(x)	( (x) >> 16 )
#define DIVIDEBY2POW17(x)	( (x) >> 17 )

// do we want to profile the 3D mixer?
#ifdef DEBUG
//#define PENTIUM
#ifdef PENTIUM
extern "C" LONG glNum;
extern "C" DWORDLONG gdwlTot;
LONG glNum;
DWORDLONG gdwlTot;
#endif
#endif

#ifdef PENTIUM
#pragma warning(disable:4035)
DWORDLONG __forceinline GetPentiumCounter(void)
{
   _asm  _emit 0x0F
   _asm  _emit 0x31
}
#endif

// use the lightning-quick neato Itd3dFilterSampleAsm or the dog slow Itd3dFilterSampleC?
#ifdef _X86_
#define Itd3dFilterSample Itd3dFilterSampleAsm
#else
#define Itd3dFilterSample Itd3dFilterSampleC
#endif

//
// Here is a simple float to long conversion that rounds according to the 
// current rounding setting
//
__forceinline LONG FloatToLongRX(float f)
{
    LONG l;

#ifdef _X86_
    _asm fld f;
    _asm fistp l;
#else
    l = (long) f;
#endif

    return l;
}


// Morph a sample from this buffer to add all the cool 3D effects
// !!! Make this function as efficient as humanly possible.  It could
// be called a million times a second! (no, I'm not kidding)
//
// This function takes a filter state, and a sample value, and based on the
// filter state returns a different sample that should be used instead
//
// This function keeps a running total of all samples we've seen, 
// So, if we've been passed 5, 10, 2, 8, 3 we remember
// 5, 15, 17, 25, 28, in a circular buffer, remembering the last 64 numbers
// or so.
// 
// We might want to delay everything by a few samples, to simulate the sound
// taking longer to get to one ear than the other.
// So let's say we're delaying 1 sample, we will subtract 25-17 to get 8
// and use 8 as the current sample instead of 3. (that's the sample we were
// passed 1 sample ago)
//
// Now we need the average of the past 32 samples to use as a muffled sample
// (averaging samples produces a low-pass filter effect).  So pretending we
// still have a delay of 1 sample and that we're only averaging 2 samples
// (for the sake of this simple example) we take ((25 - 15) / 2) to get 5 as
// our "wet" sample (what our "dry" sample, 8, sounds like muffled, which is
// just the average of 2 + 8) In real life we average 32 samples, not 2.
// 
// OK, the number this function is supposed to return is just
// TotalDryAttenuation * sample(8) + TotalWetAttenuation * wetsample(5)
//
// But you get audible clicks and ugly artifacts if you change the
// Total***Attenuation in between calling the Filter() function.  So to avoid
// this, we will use variables Last***Attenuation, to mean the number we used
// last time Filter() was called.  If this time, the Total***Attenuation 
// number is bigger, we will take Last***Attenuation * 1.000125 as the value
// to use this time, and keep using slightly bigger numbers every time we
// are called, to move smoothly to the new Total***Attenuation number.
// Similarily, if we are smaller this time, we multiply the old one by
// .999875 each time to slowly get down to the new number.
//
// Oh, and every 128 samples, we remember what the current value of
// Last***Attenuation is, so that if 128 samples from now the mixer goes back
// in time and says "pretend I never gave you those last 128 numbers" we can
// go back to the way things were back then as if we never saw the last 128
// numbers.
//
// That's all there is to know!
//
__forceinline SHORT Itd3dFilterSampleC(PITDCONTEXT pfir, SHORT sample)
{
    SHORT wetsample;     
    LONG  lTotal, lDelay;
    UINT uiDelay;
    register int cSamples = pfir->cSampleCache - 1;

    // !!! We will fault if pfir->pSampleCache == NULL or cSampleCache == 0

    // remember this sample by keeping a running total (to make averaging quick)
    // cSamples will be 1 less than a power of 2
    pfir->pSampleCache[pfir->iCurSample] = pfir->pSampleCache[
		(pfir->iCurSample - 1) & cSamples] + sample;

    // Delay the signal by iDelay samples as one localization cue.
    uiDelay = (UINT)pfir->iCurSample - pfir->iDelay;

// !!! There are audible artifacts when changing the number of samples we 
// delay by, but changing very slowly does NOT help.
#ifdef SMOOTH_ITD
    // smoothly change the amount we delay by to avoid clicking.  Every 64
    // samples we will delay 1 more sample closer to the amount we want to
    // delay.
    if (pfir->iDelay > pfir->iLastDelay >> 6)
	pfir->iLastDelay++;
    else if (pfir->iDelay < pfir->iLastDelay >> 6)
	pfir->iLastDelay--;
    uiDelay = (UINT)pfir->iCurSample - (pfir->iLastDelay >> 6);
#endif

    // Don't worry about overflow, we'll be off by 4 Gig, which is 0
    lDelay = pfir->pSampleCache[uiDelay & cSamples];
    sample = (SHORT)(lDelay - pfir->pSampleCache[(uiDelay - 1) & cSamples]);

    // apply a cheezy low pass filter to the last few samples to get what this
    // sample sounds like wet
    lTotal = (lDelay - pfir->pSampleCache[(uiDelay - LOWPASS_SIZE) & cSamples]);
    wetsample = (SHORT)(lTotal >> FILTER_SHIFT);
	    
    // Next time, this is the current sample
    pfir->iCurSample = (pfir->iCurSample + 1) & cSamples;

    // attenuate however we decided we should be attenuating
    // If it's not the same as last time, move smoothly toward the new number
    // by a fixed number of dB, (say, 6dB every 1/8 second)
    // !!! Will this algorithm sound best?
    // !!! save time - cheat by adding not multiplying?
#if 1
    // Take all the "if"s out of this function, and precompute ahead of time
    pfir->LastDryAttenuation *= pfir->VolSmoothScaleDry;
    pfir->LastWetAttenuation *= pfir->VolSmoothScaleWet;
#else
    if (pfir->TotalDryAttenuation > pfir->LastDryAttenuation) {
	if (pfir->LastDryAttenuation == 0.f)
	    // or we'll never get anywhere
	    pfir->LastDryAttenuation = .0001f;	// small enough not to click
	pfir->LastDryAttenuation = pfir->LastDryAttenuation *
							pfir->VolSmoothScale;
	if (pfir->LastDryAttenuation > pfir->TotalDryAttenuation)
	    pfir->LastDryAttenuation = pfir->TotalDryAttenuation;
    } else if (pfir->TotalDryAttenuation < pfir->LastDryAttenuation) {
	pfir->LastDryAttenuation = pfir->LastDryAttenuation *
						pfir->VolSmoothScaleRecip;
	if (pfir->LastDryAttenuation < pfir->TotalDryAttenuation)
	    pfir->LastDryAttenuation = pfir->TotalDryAttenuation;
    }
    if (pfir->TotalWetAttenuation > pfir->LastWetAttenuation) {
	if (pfir->LastWetAttenuation == 0.f)
	    // or we'll never get anywhere
	    pfir->LastWetAttenuation = .0001f;	// small enough not to click
	pfir->LastWetAttenuation = pfir->LastWetAttenuation *
							pfir->VolSmoothScale;
	if (pfir->LastWetAttenuation > pfir->TotalWetAttenuation)
	    pfir->LastWetAttenuation = pfir->TotalWetAttenuation;
    } else if (pfir->TotalWetAttenuation < pfir->LastWetAttenuation) {
	pfir->LastWetAttenuation = pfir->LastWetAttenuation *
						pfir->VolSmoothScaleRecip;
	if (pfir->LastWetAttenuation < pfir->TotalWetAttenuation)
	    pfir->LastWetAttenuation = pfir->TotalWetAttenuation;
    }
#endif
    
    // Now here's what we will hear... some dry, some wet
    sample = (SHORT)FloatToLongRX(sample * pfir->LastDryAttenuation
				  + wetsample * pfir->LastWetAttenuation);

    // time to save our state yet? We save it every 128 samples in case we
    // have to rewind.
    pfir->iStateTick++;
    if (pfir->iStateTick == MIXER_REWINDGRANULARITY) {
	pfir->iStateTick = 0;
	pfir->pStateCache[pfir->iCurState].LastDryAttenuation =
						pfir->LastDryAttenuation;
	pfir->pStateCache[pfir->iCurState].LastWetAttenuation =
						pfir->LastWetAttenuation;
#ifdef SMOOTH_ITD
	pfir->pStateCache[pfir->iCurState].iLastDelay = pfir->iLastDelay;
#endif
	pfir->iCurState = pfir->iCurState + 1;
	if (pfir->iCurState == pfir->cStateCache)
	    pfir->iCurState = 0;
    }

    return sample;
}

// Remove inline for NT5 compile
#ifdef WIN95
__forceinline SHORT Itd3dFilterSampleAsm(PITDCONTEXT pfir, SHORT sample)
#else
SHORT Itd3dFilterSampleAsm(PITDCONTEXT pfir, SHORT sample)
#endif
{

    LONG  drysample, wetsample;

// This constant is used for address generation in the hand ASM optimized
// section of code that is saving the cache states.  If FIRSTATE is ever
// changed, either change this constant, or use the C version of this block
// of code.  (NOTE:  The only valid values for SIZEOFFIRSTATE are 2, 4, 8.
// All others will not compile)
#define SIZEOFFIRSTATE 8
//ASSERT(SIZEOFFIRSTATE == sizeof(FIRSTATE));

// Several of the float ASM instructions assume that the floating point
// variables are "float".  i.e. If they are changed to "double", or 
// "extended", the ASM code will need to change.

    wetsample = (LONG)sample;
    
#ifdef _X86_
    _asm
    {
        mov         esi, pfir								// Get pointer to data structure
        mov         ecx, DWORD PTR sample		// Get input sample value

        // Check if we need to perform scaling on the Dry attenuator.

// !!! 1 clock AGI penalty on esi

        mov         edi, [esi]pfir.cSampleCache             // Get cSampleCache
        mov         ebx, [esi]pfir.iCurSample               // Get current index to cached running totals

        dec         edi													// Calculate cCamples
        mov         edx, [esi]pfir.pSampleCache	// Get pointer to cached running totals

        lea         eax, [ebx-1]			// iCurSample - 1  (does not change flags)

        sal         ecx, 16						// Start sign extension of sample
        and         eax, edi					// Account for array wrapping on iCurSample

        // !!! AGI penalty

        sar         ecx, 16						// Finish sign extension of sample
        mov         eax, [edx+eax*4]	// pSampleCache[(iCurSample-1)&cSamples] = old_run_tot
        
        add         ecx, eax					// new_run_tot = old_run_tot + sample
        mov         eax, [esi]pfir.iDelay	// Get delay to use for wet sample

        mov         [edx+ebx*4], ecx	// pSampleCache[iCurSample] = new_run_tot
        lea         ecx, [ebx+1]			// iCurSample + 1

        and         ecx, edi					// Account for array wrap on iCurSample
        sub         ebx, eax					// uiDelay = iCurSample - iDelay

        // eax is now available for use in floating point scaling section


        // Scale the Dry attenuator up by a smoothing scale factor

        fld         [esi]pfir.LastDryAttenuation                    // Push Last Dry to the top of the FP stack
        fmul        [esi]pfir.VolSmoothScaleDry

	// do some non-fp stuff to wait for the fmul to finish

        mov         eax, ebx                                // Duplicate uiDelay
        and         ebx, edi                                // Account for array wrapping on uiDelay

	// OK, it's probably done now

        fstp        [esi]pfir.LastDryAttenuation                    // Save new Last Dry

        // Scale the Wet attenuator up by a smoothing scale factor

        fld         [esi]pfir.LastWetAttenuation                    // Push Last Wet to the top of the FP stack
        fmul        [esi]pfir.VolSmoothScaleWet

	// do some non-fp stuff to wait for the fmul to finish

        mov         [esi]pfir.iCurSample, ecx               // Save iCurSample for next pass thru
        mov         ecx, LOWPASS_SIZE			    // Get filter size to use for getting filter index

	// OK, it's probably done now

        fstp        [esi]pfir.LastWetAttenuation                    // Save new Last Wet


	// Now, go ahead and trash esi

        lea         esi, [eax-1]                            // uiDelay - 1
        sub         eax, ecx                                // low_pass_index = uiDelay - LOWPASS_SIZE

        and         esi, edi                                // Account for array wrapping on uiDelay - 1
        and         eax, edi                                // Account for array wrapping on low_pass_index
        mov         edi, pfir                               // Get pointer to data structure
        mov         ebx, [edx+ebx*4]                        // lDelay = pSampleCache[uiDelay & cSamples]

        mov         esi, [edx+esi*4]                        // old_delay_tot = pSampleCache[(uiDelay-1)&cSamples]
        mov         ecx, [edx+eax*4]                        // low_pass_tot = pSampleCache[(uiDelay-LOWPASS_SIZE)&cSamples]

        mov         eax, ebx                                // Duplicate lDelay
        sub         ebx, esi                                // drysample = lDelay - old_delay_tot

        mov         drysample, ebx                          // Save new sample value
        sub         eax, ecx                                // lTotal = lDelay - low_pass_tot

    	fild	    drysample                               // Get dry portion and convert to float

        sar         eax, FILTER_SHIFT                       // lTotal = lTotal >> FILTER_SHIFT
        mov         ebx, [edi]pfir.iStateTick               // Get counter to determine when to save state

        inc         ebx                                     // Bump the "save state" counter
        mov         wetsample, eax                          // wetsample = lTotal >> FILTER_SHIFT
        
        // floating point multiply unit can only accept instructions every other clock cycle
    	fmul	    [edi]pfir.LastDryAttenuation            // Multiply dry portion by dry attenuator

    	fild	    wetsample                               // Get wet portion and convert to float

    	fmul	    [edi]pfir.LastWetAttenuation            // Multiply wet portion by wet attenuator

        mov         esi, [edi]pfir.pStateCache              // Get address of the cache array
        mov         edx, [edi]pfir.iCurState                // Get current index into cache array

        mov         eax, [edi]pfir.LastDryAttenuation       // Get dry attenuation so we can save it in cache
        cmp         ebx, MIXER_REWINDGRANULARITY            // Is it time to save our state yet?

        // There is a 3 cycle latency before results of a floating point multiply can be used, so we need
        // 2 cycles of integer instructions between the last multiply and this floating point add.
    	faddp	    ST(1), ST(0)

        mov         ecx, [edi]pfir.LastWetAttenuation       // Get wet attenuation so we can save it in cache
        jl          DontUpdateStateCache                    // Jump if no  (uses results from cmp  ebx, MIXGRAN)

        mov         [esi+edx*SIZEOFFIRSTATE]FIRSTATE.LastDryAttenuation, eax
        mov         eax, [edi]pfir.cStateCache              // Get state cache array size

        mov         [esi+edx*SIZEOFFIRSTATE]FIRSTATE.LastWetAttenuation, ecx
        inc         edx                                     // Increment to next cache array entry
        
        cmp         edx, eax                                // Have we filled up the cache array?
        jl          DontResetStateCacheIndex                // Jump if no
        
        mov         edx, 0                                  // Reset state cache index
        
DontResetStateCacheIndex:

        mov         [edi]pfir.iCurState, edx                // Save new state cache index
        mov         ebx, 0

DontUpdateStateCache:
        mov         [edi]pfir.iStateTick, ebx               // Save new tick counter



        // There is a 3 cycle latency before results of a floating point add can be used, so we need
        // 2 cycles of integer instructions between the add this floating point integer store.

        fistp       wetsample

    }
#endif
    
    // Now here's what we will hear... some dry, some wet
    return ((SHORT) wetsample);

}

#ifdef _X86_ // {
// This constant is used for address generation in the hand ASM optimized
// section of code that is saving the cache states.  If FIRSTATE is ever
// changed, either change this constant, or use the C version of this block
// of code.  (NOTE:  The only valid values for SIZEOFFIRSTATE are 2, 4, 8.
// All others will not compile)
#define SIZEOFFIRSTATE 8

void Mix3DMono(PMIXER_SINK_INSTANCE CurSink, PLONG pInputBuffer, PLONG pOutputBuffer, ULONG SampleCount)
{
    LONG  drysample, wetsample;
	PITDCONTEXT pfirLeft = CurSink->pItdContextLeft, pfirRight = CurSink->pItdContextRight;
	LONG  cSampleCacheLeft, cSampleCacheRight;

	
	cSampleCacheLeft  = pfirLeft ->cSampleCache - 1;
	cSampleCacheRight = pfirRight->cSampleCache - 1;

	if (SampleCount)
    _asm
    {
        mov         esi, pfirLeft								// Get pointer to data structure
        mov         ecx, DWORD PTR pInputBuffer		// Get input sample value

LoopLab:
        // Check if we need to perform scaling on the Dry attenuator.

        mov         edi, cSampleCacheLeft             // Get cSampleCache
        mov         ebx, [esi]pfirLeft.iCurSample               // Get current index to cached running totals

        mov         edx, [esi]pfirLeft.pSampleCache	// Get pointer to cached running totals
		mov			ecx, DWORD PTR [ecx]			// Get input sample value

        sal         ecx, 16						// Start sign extension of sample
        lea         eax, [ebx-1]			// iCurSample - 1  (does not change flags)

        fld         [esi]pfirLeft.LastDryAttenuation                    // Push Last Dry to the top of the FP stack

        and         eax, edi					// Account for array wrapping on iCurSample

        fmul        [esi]pfirLeft.VolSmoothScaleDry

        sar         ecx, 16						// Finish sign extension of sample
        mov         eax, [edx+eax*4]	// pSampleCache[(iCurSample-1)&cSamples] = old_run_tot
        
        add         ecx, eax					// new_run_tot = old_run_tot + sample
        mov         eax, [esi]pfirLeft.iDelay	// Get delay to use for wet sample

        mov         [edx+ebx*4], ecx	// pSampleCache[iCurSample] = new_run_tot
        lea         ecx, [ebx+1]			// iCurSample + 1

        and         ecx, edi					// Account for array wrap on iCurSample
        sub         ebx, eax					// uiDelay = iCurSample - iDelay

        // Scale the Dry attenuator up by a smoothing scale factor

        mov         eax, ebx                                // Duplicate uiDelay
        and         ebx, edi                                // Account for array wrapping on uiDelay

        fstp        [esi]pfirLeft.LastDryAttenuation                    // Save new Last Dry

        // Scale the Wet attenuator up by a smoothing scale factor

        fld         [esi]pfirLeft.LastWetAttenuation                    // Push Last Wet to the top of the FP stack

        fmul        [esi]pfirLeft.VolSmoothScaleWet

        mov         [esi]pfirLeft.iCurSample, ecx               // Save iCurSample for next pass thru
        lea         ecx, [eax-1]                            // uiDelay - 1

        sub         eax, LOWPASS_SIZE                         // low_pass_index = uiDelay - LOWPASS_SIZE
        and         ecx, edi                                // Account for array wrapping on uiDelay - 1

        and         eax, edi                                // Account for array wrapping on low_pass_index
        mov         ebx, [edx+ebx*4]                        // lDelay = pSampleCache[uiDelay & cSamples]

        fstp        [esi]pfirLeft.LastWetAttenuation                    // Save new Last Wet

        mov         ecx, [edx+ecx*4]                        // old_delay_tot = pSampleCache[(uiDelay-1)&cSamples]
        mov         edi, [edx+eax*4]                        // low_pass_tot = pSampleCache[(uiDelay-LOWPASS_SIZE)&cSamples]

        mov         eax, ebx                                // Duplicate lDelay
        sub         ebx, ecx                                // drysample = lDelay - old_delay_tot

        mov         drysample, ebx                          // Save new sample value
        sub         eax, edi                                // lTotal = lDelay - low_pass_tot

    	fild	    drysample                               // Get dry portion and convert to float

        sar         eax, FILTER_SHIFT                       // lTotal = lTotal >> FILTER_SHIFT
        mov         ebx, [esi]pfirLeft.iStateTick               // Get counter to determine when to save state

    	fmul	    [esi]pfirLeft.LastDryAttenuation            // Multiply dry portion by dry attenuator

        inc         ebx                                     // Bump the "save state" counter
        mov         wetsample, eax                          // wetsample = lTotal >> FILTER_SHIFT
        
    	fild	    wetsample                               // Get wet portion and convert to float

    	fmul	    [esi]pfirLeft.LastWetAttenuation            // Multiply wet portion by wet attenuator

        cmp         ebx, MIXER_REWINDGRANULARITY            // Is it time to save our state yet?
        jl          DontUpdateStateCache                    // Jump if no  (uses results from cmp  ebx, MIXGRAN)

        mov         edi, [esi]pfirLeft.pStateCache              // Get address of the cache array
        mov         edx, [esi]pfirLeft.iCurState                // Get current index into cache array

        mov         ecx, [esi]pfirLeft.LastWetAttenuation       // Get wet attenuation so we can save it in cache
        mov         eax, [esi]pfirLeft.LastDryAttenuation       // Get dry attenuation so we can save it in cache

        mov         [edi+edx*SIZEOFFIRSTATE]FIRSTATE.LastDryAttenuation, eax
        mov         eax, [esi]pfirLeft.cStateCache              // Get state cache array size

        mov         [edi+edx*SIZEOFFIRSTATE]FIRSTATE.LastWetAttenuation, ecx
        inc         edx                                     // Increment to next cache array entry
        
        cmp         edx, eax                                // Have we filled up the cache array?
        jl          DontResetStateCacheIndex                // Jump if no
        
        mov         edx, 0                                  // Reset state cache index
        
DontResetStateCacheIndex:

        mov         [esi]pfirLeft.iCurState, edx                // Save new state cache index
        mov         ebx, 0

DontUpdateStateCache:
    	faddp	    ST(1), ST(0)

        mov         [esi]pfirLeft.iStateTick, ebx               // Save new tick counter
		mov		eax, pInputBuffer

		mov		ecx, pOutputBuffer
		add		eax, 4

		fistp	wetsample

		movsx	edi, WORD PTR wetsample

// Right

		add			[ecx], edi
        mov         esi, pfirRight								// Get pointer to data structure

		mov			ecx, [eax-4]						// Get input sample value
		mov			pInputBuffer, eax

        // Check if we need to perform scaling on the Dry attenuator.

        mov         edi, cSampleCacheRight             // Get cSampleCache
        mov         ebx, [esi]pfirRight.iCurSample               // Get current index to cached running totals

        fld         [esi]pfirRight.LastDryAttenuation                    // Push Last Dry to the top of the FP stack

        mov         edx, [esi]pfirRight.pSampleCache	// Get pointer to cached running totals
        lea         eax, [ebx-1]			// iCurSample - 1  (does not change flags)

        sal         ecx, 16						// Start sign extension of sample
        and         eax, edi					// Account for array wrapping on iCurSample

        fmul        [esi]pfirRight.VolSmoothScaleDry

        sar         ecx, 16						// Finish sign extension of sample
        mov         eax, [edx+eax*4]	// pSampleCache[(iCurSample-1)&cSamples] = old_run_tot
        
        add         ecx, eax					// new_run_tot = old_run_tot + sample
        mov         eax, [esi]pfirRight.iDelay	// Get delay to use for wet sample

        mov         [edx+ebx*4], ecx	// pSampleCache[iCurSample] = new_run_tot
        lea         ecx, [ebx+1]			// iCurSample + 1

        fstp        [esi]pfirRight.LastDryAttenuation                    // Save new Last Dry

        fld         [esi]pfirRight.LastWetAttenuation                    // Push Last Wet to the top of the FP stack

        and         ecx, edi					// Account for array wrap on iCurSample
        sub         ebx, eax					// uiDelay = iCurSample - iDelay

        // Scale the Dry attenuator up by a smoothing scale factor

        mov         eax, ebx                                // Duplicate uiDelay
        and         ebx, edi                                // Account for array wrapping on uiDelay

        fmul        [esi]pfirRight.VolSmoothScaleWet

        // Scale the Wet attenuator up by a smoothing scale factor

        mov         [esi]pfirRight.iCurSample, ecx               // Save iCurSample for next pass thru
        lea         ecx, [eax-1]                            // uiDelay - 1

        sub         eax, LOWPASS_SIZE                         // low_pass_index = uiDelay - LOWPASS_SIZE
        and         ecx, edi                                // Account for array wrapping on uiDelay - 1

        and         eax, edi                                // Account for array wrapping on low_pass_index
        mov         ebx, [edx+ebx*4]                        // lDelay = pSampleCache[uiDelay & cSamples]

        fstp        [esi]pfirRight.LastWetAttenuation                    // Save new Last Wet

        mov         ecx, [edx+ecx*4]                        // old_delay_tot = pSampleCache[(uiDelay-1)&cSamples]
        mov         edi, [edx+eax*4]                        // low_pass_tot = pSampleCache[(uiDelay-LOWPASS_SIZE)&cSamples]

        mov         eax, ebx                                // Duplicate lDelay
        sub         ebx, ecx                                // drysample = lDelay - old_delay_tot

        mov         drysample, ebx                          // Save new sample value
        sub         eax, edi                                // lTotal = lDelay - low_pass_tot

    	fild	    drysample                               // Get dry portion and convert to float

        sar         eax, FILTER_SHIFT                       // lTotal = lTotal >> FILTER_SHIFT
        mov         ebx, [esi]pfirRight.iStateTick               // Get counter to determine when to save state

    	fmul	    [esi]pfirRight.LastDryAttenuation            // Multiply dry portion by dry attenuator

        inc         ebx                                     // Bump the "save state" counter
        mov         wetsample, eax                          // wetsample = lTotal >> FILTER_SHIFT
        
    	fild	    wetsample                               // Get wet portion and convert to float

    	fmul	    [esi]pfirRight.LastWetAttenuation            // Multiply wet portion by wet attenuator

        cmp         ebx, MIXER_REWINDGRANULARITY            // Is it time to save our state yet?
        jl          XDontUpdateStateCache                    // Jump if no  (uses results from cmp  ebx, MIXGRAN)

        mov         edi, [esi]pfirRight.pStateCache              // Get address of the cache array
        mov         edx, [esi]pfirRight.iCurState                // Get current index into cache array

        mov         ecx, [esi]pfirRight.LastWetAttenuation       // Get wet attenuation so we can save it in cache
        mov         eax, [esi]pfirRight.LastDryAttenuation       // Get dry attenuation so we can save it in cache

        mov         [edi+edx*SIZEOFFIRSTATE]FIRSTATE.LastDryAttenuation, eax
        mov         eax, [esi]pfirRight.cStateCache              // Get state cache array size

        mov         [edi+edx*SIZEOFFIRSTATE]FIRSTATE.LastWetAttenuation, ecx
        inc         edx                                     // Increment to next cache array entry
        
        cmp         edx, eax                                // Have we filled up the cache array?
        jl          XDontResetStateCacheIndex                // Jump if no
        
        mov         edx, 0                                  // Reset state cache index
        
XDontResetStateCacheIndex:

        mov         [esi]pfirRight.iCurState, edx                // Save new state cache index
        mov         ebx, 0

XDontUpdateStateCache:
    	faddp	    ST(1), ST(0)

        mov         [esi]pfirRight.iStateTick, ebx               // Save new tick counter
		mov		ecx, pOutputBuffer

		mov		eax, SampleCount

		fistp	wetsample

		movsx	edi, WORD PTR wetsample

		add	[ecx+4], edi
		add		ecx, 8

		dec		eax
        mov         esi, pfirLeft								// Get pointer to data structure

		mov		DWORD PTR pOutputBuffer, ecx
        mov         ecx, DWORD PTR pInputBuffer		// Get input sample value

		mov		SampleCount, eax
		jne		LoopLab
		}
}


void Copy3DMono(PMIXER_SINK_INSTANCE CurSink, PLONG pInputBuffer, PLONG pOutputBuffer, ULONG SampleCount)
{
    LONG  drysample, wetsample;
	PITDCONTEXT pfirLeft = CurSink->pItdContextLeft, pfirRight = CurSink->pItdContextRight;
	LONG  cSampleCacheLeft, cSampleCacheRight;

	
	cSampleCacheLeft  = pfirLeft ->cSampleCache - 1;
	cSampleCacheRight = pfirRight->cSampleCache - 1;

	if (SampleCount)
    _asm
    {
        mov         esi, pfirLeft								// Get pointer to data structure
        mov         ecx, DWORD PTR pInputBuffer		// Get input sample value

LoopLab:
        // Check if we need to perform scaling on the Dry attenuator.

        mov         edi, cSampleCacheLeft             // Get cSampleCache
        mov         ebx, [esi]pfirLeft.iCurSample               // Get current index to cached running totals

        mov         edx, [esi]pfirLeft.pSampleCache	// Get pointer to cached running totals
		mov			ecx, DWORD PTR [ecx]			// Get input sample value

        sal         ecx, 16						// Start sign extension of sample
        lea         eax, [ebx-1]			// iCurSample - 1  (does not change flags)

        fld         [esi]pfirLeft.LastDryAttenuation                    // Push Last Dry to the top of the FP stack

        and         eax, edi					// Account for array wrapping on iCurSample

        fmul        [esi]pfirLeft.VolSmoothScaleDry

        sar         ecx, 16						// Finish sign extension of sample
        mov         eax, [edx+eax*4]	// pSampleCache[(iCurSample-1)&cSamples] = old_run_tot
        
        add         ecx, eax					// new_run_tot = old_run_tot + sample
        mov         eax, [esi]pfirLeft.iDelay	// Get delay to use for wet sample

        mov         [edx+ebx*4], ecx	// pSampleCache[iCurSample] = new_run_tot
        lea         ecx, [ebx+1]			// iCurSample + 1

        and         ecx, edi					// Account for array wrap on iCurSample
        sub         ebx, eax					// uiDelay = iCurSample - iDelay

        // Scale the Dry attenuator up by a smoothing scale factor

        mov         eax, ebx                                // Duplicate uiDelay
        and         ebx, edi                                // Account for array wrapping on uiDelay

        fstp        [esi]pfirLeft.LastDryAttenuation                    // Save new Last Dry

        // Scale the Wet attenuator up by a smoothing scale factor

        fld         [esi]pfirLeft.LastWetAttenuation                    // Push Last Wet to the top of the FP stack

        mov         [esi]pfirLeft.iCurSample, ecx               // Save iCurSample for next pass thru
        lea         ecx, [eax-1]                            // uiDelay - 1

        sub         eax, LOWPASS_SIZE                         // low_pass_index = uiDelay - LOWPASS_SIZE
        and         ecx, edi                                // Account for array wrapping on uiDelay - 1

        fmul        [esi]pfirLeft.VolSmoothScaleWet

        and         eax, edi                                // Account for array wrapping on low_pass_index
        mov         ebx, [edx+ebx*4]                        // lDelay = pSampleCache[uiDelay & cSamples]

        mov         ecx, [edx+ecx*4]                        // old_delay_tot = pSampleCache[(uiDelay-1)&cSamples]
        mov         edi, [edx+eax*4]                        // low_pass_tot = pSampleCache[(uiDelay-LOWPASS_SIZE)&cSamples]

        fstp        [esi]pfirLeft.LastWetAttenuation                    // Save new Last Wet

        mov         eax, ebx                                // Duplicate lDelay
        sub         ebx, ecx                                // drysample = lDelay - old_delay_tot

        mov         drysample, ebx                          // Save new sample value
        sub         eax, edi                                // lTotal = lDelay - low_pass_tot

    	fild	    drysample                               // Get dry portion and convert to float

        sar         eax, FILTER_SHIFT                       // lTotal = lTotal >> FILTER_SHIFT
        mov         ebx, [esi]pfirLeft.iStateTick               // Get counter to determine when to save state

    	fmul	    [esi]pfirLeft.LastDryAttenuation            // Multiply dry portion by dry attenuator

        inc         ebx                                     // Bump the "save state" counter
        mov         wetsample, eax                          // wetsample = lTotal >> FILTER_SHIFT
        
    	fild	    wetsample                               // Get wet portion and convert to float

    	fmul	    [esi]pfirLeft.LastWetAttenuation            // Multiply wet portion by wet attenuator

        cmp         ebx, MIXER_REWINDGRANULARITY            // Is it time to save our state yet?
        jl          DontUpdateStateCache                    // Jump if no  (uses results from cmp  ebx, MIXGRAN)

        mov         edi, [esi]pfirLeft.pStateCache              // Get address of the cache array
        mov         edx, [esi]pfirLeft.iCurState                // Get current index into cache array

        mov         ecx, [esi]pfirLeft.LastWetAttenuation       // Get wet attenuation so we can save it in cache
        mov         eax, [esi]pfirLeft.LastDryAttenuation       // Get dry attenuation so we can save it in cache

        mov         [edi+edx*SIZEOFFIRSTATE]FIRSTATE.LastDryAttenuation, eax
        mov         eax, [esi]pfirLeft.cStateCache              // Get state cache array size

        mov         [edi+edx*SIZEOFFIRSTATE]FIRSTATE.LastWetAttenuation, ecx
        inc         edx                                     // Increment to next cache array entry
        
        cmp         edx, eax                                // Have we filled up the cache array?
        jl          DontResetStateCacheIndex                // Jump if no
        
        mov         edx, 0                                  // Reset state cache index
        
DontResetStateCacheIndex:

        mov         [esi]pfirLeft.iCurState, edx                // Save new state cache index
        mov         ebx, 0

DontUpdateStateCache:
    	faddp	    ST(1), ST(0)

        mov         [esi]pfirLeft.iStateTick, ebx               // Save new tick counter
		mov		eax, pInputBuffer

		mov		ecx, pOutputBuffer
		add		eax, 4

		fistp	wetsample

		movsx	edi, WORD PTR wetsample

// Right

		mov			[ecx], edi
		mov			ecx, [eax-4]						// Get input sample value

		mov			pInputBuffer, eax
        mov         esi, pfirRight								// Get pointer to data structure

        // Check if we need to perform scaling on the Dry attenuator.

        mov         edi, cSampleCacheRight             // Get cSampleCache
        mov         ebx, [esi]pfirRight.iCurSample               // Get current index to cached running totals

        mov         edx, [esi]pfirRight.pSampleCache	// Get pointer to cached running totals
        lea         eax, [ebx-1]			// iCurSample - 1  (does not change flags)

        sal         ecx, 16						// Start sign extension of sample
        and         eax, edi					// Account for array wrapping on iCurSample

        fld         [esi]pfirRight.LastDryAttenuation                    // Push Last Dry to the top of the FP stack

        sar         ecx, 16						// Finish sign extension of sample
        mov         eax, [edx+eax*4]	// pSampleCache[(iCurSample-1)&cSamples] = old_run_tot
        
        add         ecx, eax					// new_run_tot = old_run_tot + sample
        mov         eax, [esi]pfirRight.iDelay	// Get delay to use for wet sample

        fmul        [esi]pfirRight.VolSmoothScaleDry

        mov         [edx+ebx*4], ecx	// pSampleCache[iCurSample] = new_run_tot
        lea         ecx, [ebx+1]			// iCurSample + 1

        and         ecx, edi					// Account for array wrap on iCurSample
        sub         ebx, eax					// uiDelay = iCurSample - iDelay

        // Scale the Dry attenuator up by a smoothing scale factor

        mov         eax, ebx                                // Duplicate uiDelay
        and         ebx, edi                                // Account for array wrapping on uiDelay

        fstp        [esi]pfirRight.LastDryAttenuation                    // Save new Last Dry

        // Scale the Wet attenuator up by a smoothing scale factor

        fld         [esi]pfirRight.LastWetAttenuation                    // Push Last Wet to the top of the FP stack

        mov         [esi]pfirRight.iCurSample, ecx               // Save iCurSample for next pass thru
        lea         ecx, [eax-1]                            // uiDelay - 1

        sub         eax, LOWPASS_SIZE                         // low_pass_index = uiDelay - LOWPASS_SIZE
        and         ecx, edi                                // Account for array wrapping on uiDelay - 1

        and         eax, edi                                // Account for array wrapping on low_pass_index
        mov         ebx, [edx+ebx*4]                        // lDelay = pSampleCache[uiDelay & cSamples]

        fmul        [esi]pfirRight.VolSmoothScaleWet

        mov         ecx, [edx+ecx*4]                        // old_delay_tot = pSampleCache[(uiDelay-1)&cSamples]
        mov         edi, [edx+eax*4]                        // low_pass_tot = pSampleCache[(uiDelay-LOWPASS_SIZE)&cSamples]

        mov         eax, ebx                                // Duplicate lDelay
        sub         ebx, ecx                                // drysample = lDelay - old_delay_tot

        fstp        [esi]pfirRight.LastWetAttenuation                    // Save new Last Wet

        mov         drysample, ebx                          // Save new sample value
        sub         eax, edi                                // lTotal = lDelay - low_pass_tot

    	fild	    drysample                               // Get dry portion and convert to float

        sar         eax, FILTER_SHIFT                       // lTotal = lTotal >> FILTER_SHIFT
        mov         ebx, [esi]pfirRight.iStateTick               // Get counter to determine when to save state

    	fmul	    [esi]pfirRight.LastDryAttenuation            // Multiply dry portion by dry attenuator

        inc         ebx                                     // Bump the "save state" counter
        mov         wetsample, eax                          // wetsample = lTotal >> FILTER_SHIFT
        
    	fild	    wetsample                               // Get wet portion and convert to float

    	fmul	    [esi]pfirRight.LastWetAttenuation            // Multiply wet portion by wet attenuator

        cmp         ebx, MIXER_REWINDGRANULARITY            // Is it time to save our state yet?
        jl          XDontUpdateStateCache                    // Jump if no  (uses results from cmp  ebx, MIXGRAN)

        mov         edi, [esi]pfirRight.pStateCache              // Get address of the cache array
        mov         edx, [esi]pfirRight.iCurState                // Get current index into cache array

        mov         ecx, [esi]pfirRight.LastWetAttenuation       // Get wet attenuation so we can save it in cache
        mov         eax, [esi]pfirRight.LastDryAttenuation       // Get dry attenuation so we can save it in cache

        mov         [edi+edx*SIZEOFFIRSTATE]FIRSTATE.LastDryAttenuation, eax
        mov         eax, [esi]pfirRight.cStateCache              // Get state cache array size

        mov         [edi+edx*SIZEOFFIRSTATE]FIRSTATE.LastWetAttenuation, ecx
        inc         edx                                     // Increment to next cache array entry
        
        cmp         edx, eax                                // Have we filled up the cache array?
        jl          XDontResetStateCacheIndex                // Jump if no
        
        mov         edx, 0                                  // Reset state cache index
        
XDontResetStateCacheIndex:

        mov         [esi]pfirRight.iCurState, edx                // Save new state cache index
        mov         ebx, 0

XDontUpdateStateCache:
    	faddp	    ST(1), ST(0)

        mov         [esi]pfirRight.iStateTick, ebx               // Save new tick counter
		mov		ecx, pOutputBuffer

		mov		eax, SampleCount

		fistp	wetsample

		movsx	edi, WORD PTR wetsample

		mov	[ecx+4], edi
		add		ecx, 8

		dec		eax
		mov		DWORD PTR pOutputBuffer, ecx

        mov         esi, pfirLeft								// Get pointer to data structure
        mov         ecx, DWORD PTR pInputBuffer		// Get input sample value

		mov		SampleCount, eax
		jne		LoopLab
		}
}
#endif // }

ULONG __forceinline
StageMonoItd3DX
(
    PMIXER_OPERATION        CurStage,
    ULONG                   SampleCount,
    ULONG                   samplesleft,
    BOOL                    fFloat,
    BOOL                    fMixOutput
)
{
    ULONG samp;
    PMIXER_SINK_INSTANCE CurSink = (PMIXER_SINK_INSTANCE) CurStage->Context;
    PLONG      pOutputBuffer = CurStage->pOutputBuffer;
    PFLOAT     pFloatBuffer = CurStage->pOutputBuffer;
    PLONG      pInputBuffer = CurStage->pInputBuffer;
    PFLOAT     pFloatInput = CurStage->pInputBuffer;
//    SHORT      sampleValue;
    
    // Run the 3D algorithm
    Itd3dFilterChunkUpdate( CurSink->pItdContextLeft, SampleCount );
    Itd3dFilterChunkUpdate( CurSink->pItdContextRight, SampleCount );


    if (fFloat) {
        if (fMixOutput) {
            for ( samp=0; samp<SampleCount; samp++ ) {
                // Filter the left and right channels
//                sampleValue = (SHORT)pFloatInput[samp];
                pFloatBuffer[0] += (FLOAT)Itd3dFilterSample(CurSink->pItdContextLeft, (SHORT)pFloatInput[samp]);
                pFloatBuffer[1] += (FLOAT)Itd3dFilterSample(CurSink->pItdContextRight, (SHORT)pFloatInput[samp]);
                pFloatBuffer += 2;
            }
        } else {
            for ( samp=0; samp<SampleCount; samp++ ) {
                // Filter the left and right channels
//                sampleValue = (SHORT)pFloatInput[samp];
                pFloatBuffer[0] = (FLOAT)Itd3dFilterSample(CurSink->pItdContextLeft, (SHORT)pFloatInput[samp]);
                pFloatBuffer[1] = (FLOAT)Itd3dFilterSample(CurSink->pItdContextRight, (SHORT)pFloatInput[samp]);
                pFloatBuffer += 2;
            }
        }
    } else {
        if (fMixOutput) {
#ifdef _X86_
			Mix3DMono(CurSink, pInputBuffer, pOutputBuffer, SampleCount);
#else
            for ( samp=0; samp<SampleCount; samp++ ) {
                // Filter the left and right channels
//                sampleValue = (SHORT)pInputBuffer[samp];
                pOutputBuffer[0] += (LONG)Itd3dFilterSample(CurSink->pItdContextLeft, (SHORT)pInputBuffer[samp]);
                pOutputBuffer[1] += (LONG)Itd3dFilterSample(CurSink->pItdContextRight, (SHORT)pInputBuffer[samp]);
                pOutputBuffer += 2;
            }
#endif            
        } else {
#ifdef _X86_
			Copy3DMono(CurSink, pInputBuffer, pOutputBuffer, SampleCount);
#else
            for ( samp=0; samp<SampleCount; samp++ ) {
                // Filter the left and right channels
//                sampleValue = (SHORT)pInputBuffer[samp];
                pOutputBuffer[0] = (LONG)Itd3dFilterSample(CurSink->pItdContextLeft, (SHORT)pInputBuffer[samp]);
                pOutputBuffer[1] = (LONG)Itd3dFilterSample(CurSink->pItdContextRight, (SHORT)pInputBuffer[samp]);
                pOutputBuffer += 2;
            }
#endif
        }
    }

    return SampleCount;
}

ULONG StageMonoItd3D( PMIXER_OPERATION CurStage, ULONG SampleCount, ULONG samplesleft )
{
    return StageMonoItd3DX(CurStage, SampleCount, samplesleft, FALSE, FALSE);
}

ULONG StageMonoItd3DFloat( PMIXER_OPERATION CurStage, ULONG SampleCount, ULONG samplesleft )
{
    KFLOATING_SAVE     FloatSave;
    ULONG nOutputSamples;

    SaveFloatState(&FloatSave);
    nOutputSamples = StageMonoItd3DX(CurStage, SampleCount, samplesleft, TRUE, FALSE);
    RestoreFloatState(&FloatSave);
    return nOutputSamples;
}

ULONG StageMonoItd3DMix( PMIXER_OPERATION CurStage, ULONG SampleCount, ULONG samplesleft )
{
    return StageMonoItd3DX(CurStage, SampleCount, samplesleft, FALSE, TRUE);
}

ULONG StageMonoItd3DFloatMix( PMIXER_OPERATION CurStage, ULONG SampleCount, ULONG samplesleft )
{
    KFLOATING_SAVE     FloatSave;
    ULONG nOutputSamples;

    SaveFloatState(&FloatSave);
    nOutputSamples = StageMonoItd3DX(CurStage, SampleCount, samplesleft, TRUE, TRUE);
    RestoreFloatState(&FloatSave);
    return nOutputSamples;
} 

ULONG __forceinline
StageStereoItd3DX
(
    PMIXER_OPERATION        CurStage,
    ULONG                   SampleCount,
    ULONG                   samplesleft,
    BOOL                    fFloat,
    BOOL                    fMixOutput
)
{
    ULONG samp;
    PMIXER_SINK_INSTANCE CurSink = (PMIXER_SINK_INSTANCE) CurStage->Context;
    PLONG      pOutputBuffer = CurStage->pOutputBuffer;
    PFLOAT     pFloatBuffer = CurStage->pOutputBuffer;
    PLONG      pInputBuffer = CurStage->pInputBuffer;
    PFLOAT     pFloatInput = CurStage->pInputBuffer;
    SHORT      sampleValue;
    
    // Run the 3D algorithm
    Itd3dFilterChunkUpdate( CurSink->pItdContextLeft, SampleCount );
    Itd3dFilterChunkUpdate( CurSink->pItdContextRight, SampleCount );

    if (fFloat) {
        if (fMixOutput) {
            for ( samp=0; samp<SampleCount; samp++ ) {
                // Filter the left and right channels
                sampleValue = (SHORT)DIVIDEBY2((LONG)(*(pFloatInput) + *(pFloatInput+1)));
                pFloatInput += 2;
                pFloatBuffer[0] += (FLOAT)Itd3dFilterSample(CurSink->pItdContextLeft, sampleValue);
                pFloatBuffer[1] += (FLOAT)Itd3dFilterSample(CurSink->pItdContextRight, sampleValue );
                pFloatBuffer += 2;
            }
        } else {
            for ( samp=0; samp<SampleCount; samp++ ) {
                // Filter the left and right channels
                sampleValue = (SHORT)DIVIDEBY2((LONG)(*(pFloatInput) + *(pFloatInput+1)));
                pFloatInput += 2;
                pFloatBuffer[0] = (FLOAT)Itd3dFilterSample(CurSink->pItdContextLeft, sampleValue);
                pFloatBuffer[1] = (FLOAT)Itd3dFilterSample(CurSink->pItdContextRight, sampleValue );
                pFloatBuffer += 2;
            }
        }
    } else {
        if (fMixOutput) {
            for ( samp=0; samp<SampleCount; samp++ ) {
                // Filter the left and right channels
                sampleValue = (SHORT)DIVIDEBY2(*(pInputBuffer) + *(pInputBuffer+1));
                pInputBuffer += 2;
                pOutputBuffer[0] += (LONG)Itd3dFilterSample(CurSink->pItdContextLeft, sampleValue);
                pOutputBuffer[1] += (LONG)Itd3dFilterSample(CurSink->pItdContextRight, sampleValue );
                pOutputBuffer += 2;
            }
        } else {
            for ( samp=0; samp<SampleCount; samp++ ) {
                // Filter the left and right channels
                sampleValue = (SHORT)DIVIDEBY2(*(pInputBuffer) + *(pInputBuffer+1));
                pInputBuffer += 2;
                pOutputBuffer[0] = (LONG)Itd3dFilterSample(CurSink->pItdContextLeft, sampleValue);
                pOutputBuffer[1] = (LONG)Itd3dFilterSample(CurSink->pItdContextRight, sampleValue);
                pOutputBuffer += 2;
            }
        }
    }

    return SampleCount;
}

ULONG StageStereoItd3D( PMIXER_OPERATION CurStage, ULONG SampleCount, ULONG samplesleft )
{
    return StageStereoItd3DX(CurStage, SampleCount, samplesleft, FALSE, FALSE);
}

ULONG StageStereoItd3DFloat( PMIXER_OPERATION CurStage, ULONG SampleCount, ULONG samplesleft )
{
    KFLOATING_SAVE     FloatSave;
    ULONG nOutputSamples;

    SaveFloatState(&FloatSave);
    nOutputSamples = StageStereoItd3DX(CurStage, SampleCount, samplesleft, TRUE, FALSE);
    RestoreFloatState(&FloatSave);
    return nOutputSamples;
}

ULONG StageStereoItd3DMix( PMIXER_OPERATION CurStage, ULONG SampleCount, ULONG samplesleft )
{
    return StageStereoItd3DX(CurStage, SampleCount, samplesleft, FALSE, TRUE);
}

ULONG StageStereoItd3DFloatMix( PMIXER_OPERATION CurStage, ULONG SampleCount, ULONG samplesleft )
{
    KFLOATING_SAVE     FloatSave;
    ULONG nOutputSamples;

    SaveFloatState(&FloatSave);
    nOutputSamples = StageStereoItd3DX(CurStage, SampleCount, samplesleft, TRUE, TRUE);
    RestoreFloatState(&FloatSave);
    return nOutputSamples;
}

/* m4 Macros for generation of DMACopy and Merge functions. */







/*  */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\filters\kmixer\perf.h ===
//---------------------------------------------------------------------------
//
//  Module:   perf.d
//
//  Description:
//
//
//@@BEGIN_MSINTERNAL
//
//  History:   Date       Author      Comment
//             --------------------------------------------------------------
//             01/02/01   ArthurZ     Created
//
//@@END_MSINTERNAL
//---------------------------------------------------------------------------
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1995-1999 Microsoft Corporation.  All Rights Reserved.
//
//---------------------------------------------------------------------------

#include <wmistr.h>
#include <evntrace.h>

extern NTSTATUS
(*PerfSystemControlDispatch) (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

extern ULONG TraceEnable;

#define PerfInstrumentationEnabled() (TraceEnable != 0)

#define KMIXER_SOURCE_GLITCH 2

VOID
PerfRegisterProvider (
    IN PDEVICE_OBJECT DeviceObject
    );

VOID
PerfUnregisterProvider (
    IN PDEVICE_OBJECT DeviceObject
    );

NTSTATUS
PerfWmiDispatch (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

VOID
PerfLogGlitch (
    IN ULONG_PTR InstanceId,
    IN ULONG Type,
    IN LONGLONG CurrentTime,
    IN LONGLONG PreviousTime
    );

//---------------------------------------------------------------------------
//  End of File: perf.c
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\filters\kmixer\modeflag.inc ===
H_8_BITS        equ 0
H_16_BITS       equ 1
H_MONO          equ 0
H_STEREO        equ 2
H_UNSIGNED      equ 0
H_SIGNED        equ 4
H_ORDER_LR      equ 0
H_ORDER_RL      equ 8
H_NO_FILTER	equ 0
H_FILTER	equ 16
H_BASEMASK	equ 31
H_NO_LOOP       equ 0
H_LOOP          equ 256
H_BUILD_MONO    equ 0
H_BUILD_STEREO  equ 32
H_NO_RESAMPLE   equ 0
H_RESAMPLE      equ 64
H_NO_SCALE      equ 0
H_SCALE         equ 128
H_NO_CLIP       equ 0
H_CLIP          equ 32
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\filters\kmixer\mmx.c ===
//---------------------------------------------------------------------------
//
//  Module:   mmx.c
//
//  Description:
//
//
//@@BEGIN_MSINTERNAL
//  Development Team:
//     Jeff Taylor
//
//  History:   Date       Author      Comment
//
//  To Do:     Date       Author      Comment
//
//@@END_MSINTERNAL                                         
//
//  Copyright (c) 1997-2000 Microsoft Corporation.  All Rights Reserved.
//
//---------------------------------------------------------------------------

#include "common.h"
#include "fir.h"

#ifdef _X86_

#define GTW_MIX		// Turn on the MMX stuff...
#define GTW_REORDER	// Turn on loop unrolling to lessen register contention.
//#define GTW_CONVERT	// Turn on the MMX stuff for the convert functions.

#define CPU_ID _asm _emit 0x0f _asm _emit 0xa2

ULONG   gfMmxPresent = 0 ;

#if _MSC_FULL_VER >= 13008827 && defined(_M_IX86)
#pragma warning(disable:4731)			// EBP modified with inline asm
#endif

BOOL
IsMmxPresent(VOID)
{
    BOOL    MmxAvailable = 0;
    _asm {
        push    ebx
        pushfd                      // Store original EFLAGS on stack
        pop     eax                 // Get original EFLAGS in EAX
        mov     ecx, eax            // Duplicate original EFLAGS in ECX for toggle check
        xor     eax, 0x00200000L    // Flip ID bit in EFLAGS
        push    eax                 // Save new EFLAGS value on stack
        popfd                       // Replace current EFLAGS value
        pushfd                      // Store new EFLAGS on stack
        pop     eax                 // Get new EFLAGS in EAX
        xor     eax, ecx            // Can we toggle ID bit?
        jz      Done                // Jump if no, Processor is older than a Pentium so CPU_ID is not supported
        mov     eax, 1              // Set EAX to tell the CPUID instruction what to return
        CPU_ID                      // Get family/model/stepping/features
        and    edx, 0x00800000L     // Check if mmx technology available
        mov MmxAvailable, edx
Done:
        pop     ebx
    }
    return (MmxAvailable);
}

ULONG MmxConvertMonoToStereo8(PMIXER_OPERATION CurStage, ULONG SampleCount, ULONG samplesleft)
{
    PMIXER_SINK_INSTANCE    CurSink = (PMIXER_SINK_INSTANCE) CurStage->Context;
    PLONG   pOutputBuffer = CurStage->pOutputBuffer;
    UNALIGNED PBYTE  pIn8 = CurStage->pInputBuffer;
    PLONG   pMap = CurSink->pVolumeTable;

    // vol*32768 for ch0, ch1, ch2, etc.

    if (SampleCount == 0) {
        return 0;
    }

#ifdef GTW_CONVERT // {
    LONG lLVol = pMap[0], lRVol = pMap[1];

    if (lLVol & 0xffff8000 /* && lRVol & 0xffff8000 */)
    {
        // No Vol Control
        _asm {
        mov	ebx, SampleCount
        mov	esi, pIn8
	dec	ebx			// lea	ebx, [ebx*1-1]
	xor	eax, eax
	cmp	ebx, 7
        mov	edi, pOutputBuffer
	jl	LastSamples

	sub	ebx, 3
	lea	ecx, [esi+ebx]
	pxor	mm0, mm0

	mov	edx, 0x800080		// 0, 0, 128, 128
	movd		mm5, edx	// 0, 0, 128, 128
//	punpcklwd	mm5, mm5	// 0, 0, 128, 128
	punpckldq	mm5, mm5	// 128, 128, 128, 128

	test	ecx, 3
	je	DoMMX

	add	ebx, 3

FirstSamples:	
	mov	al, BYTE PTR [esi+ebx]
	sub	eax, 128
	shl	eax, 8
	dec	ebx

	mov	DWORD PTR [edi+ebx*8+8], eax
	mov	DWORD PTR [edi+ebx*8+12], eax
	xor	eax, eax
	lea	ecx, [esi+ebx]
	and	ecx, 3
	cmp	ecx, 3
	jne	FirstSamples

	sub	ebx, 3

DoMMX:
#ifdef GTW_REORDER
	movd		mm1, DWORD PTR [esi+ebx]	// Load source
	punpcklbw	mm1, mm0			// Make unsigned 16 bit.
	psubw		mm1, mm5
	psllw		mm1, 8				// 4 Signed 16 bit mono.

	punpckhwd	mm3, mm1
	punpcklwd	mm1, mm1

	jmp	DoMMX00

DoMMX0:
	movd		mm1, DWORD PTR [esi+ebx]	// Load source
	punpckhdq	mm4, mm4

	movq		QWORD PTR [edi+ebx*8+8 +32], mm2
	punpcklbw	mm1, mm0			// Make unsigned 16 bit.

	movq		QWORD PTR [edi+ebx*8+16+32], mm3
	psubw		mm1, mm5

	movq		QWORD PTR [edi+ebx*8+24+32], mm4
	psllw		mm1, 8				// 4 Signed 16 bit mono.

	punpckhwd	mm3, mm1

	punpcklwd	mm1, mm1
DoMMX00:
	psrad		mm1, 16
	sub		ebx, 4

	psrad		mm3, 16
	movq		mm2, mm1

	punpckldq	mm1, mm1
	movq		mm4, mm3

	movq		QWORD PTR [edi+ebx*8+32],    mm1
	punpckhdq	mm2, mm2

	punpckldq	mm3, mm3
	jge		DoMMX0

	movq		QWORD PTR [edi+ebx*8+8 +32], mm2
	punpckhdq	mm4, mm4

	movq		QWORD PTR [edi+ebx*8+16+32], mm3
	movq		QWORD PTR [edi+ebx*8+24+32], mm4
#else
	movd		mm1, DWORD PTR [esi+ebx]	// Load source
	punpcklbw	mm1, mm0			// Make unsigned 16 bit.
	psubw		mm1, mm5
	psllw		mm1, 8				// 4 Signed 16 bit mono.

	punpckhwd	mm3, mm1
	punpcklwd	mm1, mm1

	psrad		mm1, 16
	psrad		mm3, 16

	movq		mm2, mm1
	movq		mm4, mm3

	punpckldq	mm1, mm1
	punpckhdq	mm2, mm2

	movq		QWORD PTR [edi+ebx*8],    mm1
	punpckldq	mm3, mm3

	movq		QWORD PTR [edi+ebx*8+8],  mm2
	punpckhdq	mm4, mm4

	movq		QWORD PTR [edi+ebx*8+16], mm3
	movq		QWORD PTR [edi+ebx*8+24], mm4
	
	sub		ebx, 4
	jge		DoMMX
#endif

	emms
	add	ebx, 4
	je	Done

	dec	ebx
	xor	eax, eax
	
LastSamples:	
	mov	al, BYTE PTR [esi+ebx]

	sub	eax, 128

	shl	eax, 8

	mov	DWORD PTR [edi+ebx*8], eax
	mov	DWORD PTR [edi+ebx*8+4], eax
	xor	eax, eax
	dec	ebx
	jge	LastSamples
Done:
        }
    }
    else
    {
        if (0 && (lLVol | lRVol) & 0xffff8000) {
           if (lLVol & 0xffff8000) lLVol = 0x00007fff;
           if (lRVol & 0xffff8000) lRVol = 0x00007fff;
        }
        // Vol Control
        _asm {
        mov	ebx, SampleCount
        mov	esi, pIn8
	dec	ebx			// lea	ebx, [ebx*1-1]
	xor	edx, edx
	cmp	ebx, 7
        mov	edi, pOutputBuffer
	jl	LastSamples1

	sub	ebx, 3

	pxor		mm0, mm0
	mov	eax, 0x800080		// 0, 0, 128, 128
	movd		mm5, eax	// 0, 0, 128, 128
//	punpcklwd	mm5, mm5	// 0, 0, 128, 128
	punpckldq	mm5, mm5	// 128, 128, 128, 128

	mov	ecx, lRVol // Use lower 16 bits
	mov	eax, lLVol
	shl	ecx, 16
	or	ecx, eax
	movd	mm6, ecx
	punpckldq	mm6, mm6

	lea	ecx, [esi+ebx]
	test	ecx, 3
	je	DoMMX1

	add	ebx, 3

FirstSamples1:	
	mov	dl, BYTE PTR [esi+ebx]

	sub	edx, 128
	mov	ecx, edx

	imul	edx, DWORD PTR lLVol
	imul	ecx, DWORD PTR lRVol

	shl	edx, 8

	sar	edx, 15

	shl	ecx, 8
	mov	DWORD PTR [edi+ebx*8], edx

	sar	ecx, 15
	xor	edx, edx

	dec	ebx
	mov	DWORD PTR [edi+ebx*8+12], ecx

	lea	ecx, [esi+ebx]

	and	ecx, 3
	cmp	ecx, 3

	jne	FirstSamples1

	sub	ebx, 3

DoMMX1:
#ifdef GTW_REORDER
	movd		mm1, DWORD PTR [esi+ebx]	// Load 4 bytes.
	punpcklbw	mm1, mm0			// Make unsigned 16 bit.
	psubw		mm1, mm5
	psllw		mm1, 8				// * 256
	
	movq		mm3, mm1			// Mono samples

	punpcklwd	mm1, mm1			// Make stereo
	punpckhwd	mm3, mm3

	jmp	DoMMX100

DoMMX10:
	movd		mm1, DWORD PTR [esi+ebx]	// Load 4 bytes.
	psrad		mm4, 15

	movq		QWORD PTR [edi+ebx*8+8 +32], mm2
	punpcklbw	mm1, mm0			// Make unsigned 16 bit.

	movq		QWORD PTR [edi+ebx*8+16+32], mm3
	psubw		mm1, mm5

	movq		QWORD PTR [edi+ebx*8+24+32], mm4
	psllw		mm1, 8				// * 256

	movq		mm3, mm1			// Mono samples
	punpcklwd	mm1, mm1			// Make stereo

	punpckhwd	mm3, mm3

DoMMX100:
	pmulhw		mm1, mm6			// Only need high parts.

	punpckhwd	mm2, mm1			// 32 bit stereo...
	pmulhw		mm3, mm6

	punpcklwd	mm1, mm1

	psrad		mm1, 15				// Approx. shr16, shl 1.

	punpckhwd	mm4, mm3

	movq		QWORD PTR [edi+ebx*8],    mm1
	punpcklwd	mm3, mm3

	psrad		mm2, 15
	sub		ebx, 4

	psrad		mm3, 15
	jge		DoMMX10

	movq		QWORD PTR [edi+ebx*8+8 +32], mm2
	psrad		mm4, 15

	movq		QWORD PTR [edi+ebx*8+16+32], mm3
	movq		QWORD PTR [edi+ebx*8+24+32], mm4
#else
	movd		mm1, DWORD PTR [esi+ebx]	// Load 4 bytes.
	punpcklbw	mm1, mm0			// Make unsigned 16 bit.
	psubw		mm1, mm5
	psllw		mm1, 8				// * 256
	
	movq		mm3, mm1			// Mono samples

	punpcklwd	mm1, mm1			// Make stereo
	punpckhwd	mm3, mm3

	pmulhw		mm1, mm6			// Only need high parts.
	pmulhw		mm3, mm6

	punpckhwd	mm2, mm1			// 32 bit stereo...
	punpcklwd	mm1, mm1

	punpckhwd	mm4, mm3
	psrad		mm1, 15				// Approx. shr16, shl 1.

	punpcklwd	mm3, mm3
	psrad		mm2, 15

	movq		QWORD PTR [edi+ebx*8],    mm1
	psrad		mm3, 15

	movq		QWORD PTR [edi+ebx*8+8],  mm2
	psrad		mm4, 15

	movq		QWORD PTR [edi+ebx*8+16], mm3
	movq		QWORD PTR [edi+ebx*8+24], mm4
	
	sub		ebx, 4
	jge		DoMMX1
#endif

	emms
	add	ebx, 4
	je	Done1

	dec	ebx
	xor	edx, edx
	
LastSamples1:	
	mov	dl, BYTE PTR [esi+ebx]

	sub	edx, 128
	mov	ecx, edx

	imul	edx, DWORD PTR lLVol
	imul	ecx, DWORD PTR lRVol

	shl	edx, 8

	sar	edx, 15

	shl	ecx, 8

	sar	ecx, 15

	mov	DWORD PTR [edi+ebx*8], edx

	xor	edx, edx
	dec	ebx

	mov	DWORD PTR [edi+ebx*8+12], ecx
	jge	LastSamples1
Done1:
        }
    }

#else // }
    ConvertMonoToStereo8(CurStage, SampleCount, samplesleft);
#endif
    
    return SampleCount;
}

ULONG MmxQuickMixMonoToStereo8(PMIXER_OPERATION CurStage, ULONG SampleCount, ULONG samplesleft)
{
    PMIXER_SINK_INSTANCE    CurSink = (PMIXER_SINK_INSTANCE) CurStage->Context;
    PLONG   pOutputBuffer = CurStage->pOutputBuffer;
    UNALIGNED PBYTE  pIn8 = CurStage->pInputBuffer;
    PLONG   pMap = CurSink->pVolumeTable;

    // vol*32768 for ch0, ch1, ch2, etc.

#ifdef GTW_MIX // {
    LONG lLVol = pMap[0], lRVol = pMap[1];

    if (SampleCount == 0) {
        return 0;
    }
    
    if (lLVol & 0xffff8000 /* && lRVol & 0xffff8000 */)
    {
	// No Vol Control
        _asm {
        mov	ebx, SampleCount
        mov	esi, pIn8
	dec	ebx			// lea	ebx, [ebx*1-1]
	xor	eax, eax
	cmp	ebx, 7
        mov	edi, pOutputBuffer
	jl	LastSamples

	sub	ebx, 3
	lea	ecx, [esi+ebx]
	pxor	mm0, mm0

	mov	edx, 0x800080		// 0, 0, 128, 128
	movd		mm5, edx	// 0, 0, 128, 128
//	punpcklwd	mm5, mm5	// 0, 0, 128, 128
	punpckldq	mm5, mm5	// 128, 128, 128, 128


	test	ecx, 3
	je	DoMMX

	add	ebx, 3

FirstSamples:	
	mov	al, BYTE PTR [esi+ebx]
	mov	edx, DWORD PTR [edi+ebx*8]

	sub	eax, 128

	shl	eax, 8
	mov	ecx, DWORD PTR [edi+ebx*8+4]

	add	edx, eax
	add	ecx, eax

	xor	eax, eax
	mov	DWORD PTR [edi+ebx*8], edx

	mov	DWORD PTR [edi+ebx*8+4], ecx
	dec	ebx
	lea	ecx, [esi+ebx]
	and	ecx, 3
	cmp	ecx, 3
	jne	FirstSamples

	sub	ebx, 3

DoMMX:
#ifdef GTW_REORDER
	movd		mm1, DWORD PTR [esi+ebx]	// Load source
	punpcklbw	mm1, mm0			// Make unsigned 16 bit.
	psubw		mm1, mm5
	psllw		mm1, 8				// 4 Signed 16 bit mono.

	punpckhwd	mm3, mm1
	punpcklwd	mm1, mm1

	jmp	DoMMX00

DoMMX0:
	movd		mm1, DWORD PTR [esi+ebx]	// Load source
	punpckhdq	mm4, mm4

	paddd		mm3, QWORD PTR [edi+ebx*8+16+32]
	punpcklbw	mm1, mm0			// Make unsigned 16 bit.

	movq		QWORD PTR [edi+ebx*8+8 +32], mm2
	psubw		mm1, mm5

	paddd		mm4, QWORD PTR [edi+ebx*8+24+32]
	psllw		mm1, 8				// 4 Signed 16 bit mono.

	movq		QWORD PTR [edi+ebx*8+16+32], mm3
	punpckhwd	mm3, mm1

	movq		QWORD PTR [edi+ebx*8+24+32], mm4
	punpcklwd	mm1, mm1
DoMMX00:
	psrad		mm1, 16
	sub		ebx, 4

	psrad		mm3, 16
	movq		mm2, mm1

	punpckldq	mm1, mm1
	movq		mm4, mm3

	paddd		mm1, QWORD PTR [edi+ebx*8+32]
	punpckhdq	mm2, mm2

	paddd		mm2, QWORD PTR [edi+ebx*8+8+32]
	punpckldq	mm3, mm3

	movq		QWORD PTR [edi+ebx*8+32],    mm1
	jge		DoMMX0

	paddd		mm3, QWORD PTR [edi+ebx*8+16+32]
	punpckhdq	mm4, mm4

	paddd		mm4, QWORD PTR [edi+ebx*8+24+32]

	movq		QWORD PTR [edi+ebx*8+8 +32], mm2
	movq		QWORD PTR [edi+ebx*8+16+32], mm3
	movq		QWORD PTR [edi+ebx*8+24+32], mm4
#else
	movd		mm1, DWORD PTR [esi+ebx]	// Load source
	punpcklbw	mm1, mm0			// Make unsigned 16 bit.
	psubw		mm1, mm5
	psllw		mm1, 8				// 4 Signed 16 bit mono.

	punpckhwd	mm3, mm1
	punpcklwd	mm1, mm1

	psrad		mm1, 16
	psrad		mm3, 16

	movq		mm2, mm1
	movq		mm4, mm3

	punpckldq	mm1, mm1
	punpckhdq	mm2, mm2

	paddd		mm1, QWORD PTR [edi+ebx*8]
	punpckldq	mm3, mm3

	paddd		mm2, QWORD PTR [edi+ebx*8+8]
	punpckhdq	mm4, mm4

	paddd		mm3, QWORD PTR [edi+ebx*8+16]
	paddd		mm4, QWORD PTR [edi+ebx*8+24]

	movq		QWORD PTR [edi+ebx*8],    mm1
	movq		QWORD PTR [edi+ebx*8+8],  mm2
	movq		QWORD PTR [edi+ebx*8+16], mm3
	movq		QWORD PTR [edi+ebx*8+24], mm4
	
	sub		ebx, 4
	jge		DoMMX
#endif

	emms
	add	ebx, 4
	je	Done

	dec	ebx
	xor	eax, eax
	
LastSamples:	
	mov	al, BYTE PTR [esi+ebx]
	mov	edx, DWORD PTR [edi+ebx*8]

	sub	eax, 128

	shl	eax, 8
	mov	ecx, DWORD PTR [edi+ebx*8+4]

	add	edx, eax
	add	ecx, eax

	xor	eax, eax
	mov	DWORD PTR [edi+ebx*8], edx

	mov	DWORD PTR [edi+ebx*8+4], ecx
	dec	ebx
	jge	LastSamples
Done:
        }
    }
    else
    {
        if (0 && (lLVol | lRVol) & 0xffff8000) {
           if (lLVol & 0xffff8000) lLVol = 0x00007fff;
           if (lRVol & 0xffff8000) lRVol = 0x00007fff;
        }
	// Vol Control
        _asm {
        mov	ebx, SampleCount
        mov	esi, pIn8
	dec	ebx			// lea	ebx, [ebx*1-1]
	xor	edx, edx
	cmp	ebx, 7
        mov	edi, pOutputBuffer
	jl	LastSamples1

	sub	ebx, 3

	pxor		mm0, mm0
	mov	eax, 0x800080		// 0, 0, 128, 128
	movd		mm5, eax	// 0, 0, 128, 128
//	punpcklwd	mm5, mm5	// 0, 0, 128, 128
	punpckldq	mm5, mm5	// 128, 128, 128, 128

	mov	ecx, DWORD PTR lRVol // Use lower 16 bits
	mov	eax, DWORD PTR lLVol
	shl	ecx, 16
	or	ecx, eax
	movd	mm6, ecx
	punpckldq	mm6, mm6

	lea	ecx, [esi+ebx]
	test	ecx, 3
	je	DoMMX1

	add	ebx, 3

FirstSamples1:	
	mov	dl, BYTE PTR [esi+ebx]

	sub	edx, 128
	mov	ecx, edx

	imul	edx, DWORD PTR lLVol
	imul	ecx, DWORD PTR lRVol

	shl	edx, 8
	mov	eax, DWORD PTR [edi+ebx*8]

	sar	edx, 15

	shl	ecx, 8
	add	edx, eax

	sar	ecx, 15
	mov	eax, DWORD PTR [edi+ebx*8+4]

	mov	DWORD PTR [edi+ebx*8], edx
	add	eax, ecx

	xor	edx, edx
	dec	ebx

	mov	DWORD PTR [edi+ebx*8+12], eax
	lea	ecx, [esi+ebx]

	and	ecx, 3
	cmp	ecx, 3

	jne	FirstSamples1

	sub	ebx, 3

DoMMX1:
#ifdef GTW_REORDER
	movd		mm1, DWORD PTR [esi+ebx]	// Load 4 bytes.
	punpcklbw	mm1, mm0			// Make unsigned 16 bit.
	psubw		mm1, mm5
	psllw		mm1, 8				// * 256
	
	movq		mm3, mm1			// Mono samples

	punpcklwd	mm1, mm1			// Make stereo
	punpckhwd	mm3, mm3

	jmp	DoMMX100

DoMMX10:
	movd		mm1, DWORD PTR [esi+ebx]	// Load 4 bytes.

	paddd		mm4, QWORD PTR [edi+ebx*8+24+32]
	punpcklbw	mm1, mm0			// Make unsigned 16 bit.

	movq		QWORD PTR [edi+ebx*8+8 +32],  mm2
	psubw		mm1, mm5

	movq		QWORD PTR [edi+ebx*8+16+32], mm3
	psllw		mm1, 8				// * 256

	movq		mm3, mm1			// Mono samples
	punpcklwd	mm1, mm1			// Make stereo

	movq		QWORD PTR [edi+ebx*8+24+32], mm4
	punpckhwd	mm3, mm3

DoMMX100:
	pmulhw		mm1, mm6			// Only need high parts.

	punpckhwd	mm2, mm1			// 32 bit stereo...

	pmulhw		mm3, mm6
	punpcklwd	mm1, mm1

	psrad		mm1, 15				// Approx. shr16, shl 1.

	paddd		mm1, QWORD PTR [edi+ebx*8]
	punpckhwd	mm4, mm3

	punpcklwd	mm3, mm3

	movq		QWORD PTR [edi+ebx*8],    mm1
	psrad		mm2, 15

	paddd		mm2, QWORD PTR [edi+ebx*8+8]
	psrad		mm3, 15

	paddd		mm3, QWORD PTR [edi+ebx*8+16]
	psrad		mm4, 15
	
	sub		ebx, 4
	jge		DoMMX10

	paddd		mm4, QWORD PTR [edi+ebx*8+24+32]
	movq		QWORD PTR [edi+ebx*8+8 +32], mm2
	movq		QWORD PTR [edi+ebx*8+16+32], mm3
	movq		QWORD PTR [edi+ebx*8+24+32], mm4
#else
	movd		mm1, DWORD PTR [esi+ebx]	// Load 4 bytes.
	punpcklbw	mm1, mm0			// Make unsigned 16 bit.
	psubw		mm1, mm5
	psllw		mm1, 8				// * 256
	
	movq		mm3, mm1			// Mono samples

	punpcklwd	mm1, mm1			// Make stereo
	punpckhwd	mm3, mm3

	pmulhw		mm1, mm6			// Only need high parts.

	pmulhw		mm3, mm6

	punpckhwd	mm2, mm1			// 32 bit stereo...
	punpcklwd	mm1, mm1

	punpckhwd	mm4, mm3
	psrad		mm1, 15				// Approx. shr16, shl 1.

	punpcklwd	mm3, mm3
	psrad		mm2, 15

	paddd		mm1, QWORD PTR [edi+ebx*8]
	psrad		mm3, 15

	paddd		mm2, QWORD PTR [edi+ebx*8+8]
	psrad		mm4, 15
	
	paddd		mm3, QWORD PTR [edi+ebx*8+16]
	paddd		mm4, QWORD PTR [edi+ebx*8+24]
	movq		QWORD PTR [edi+ebx*8],    mm1
	movq		QWORD PTR [edi+ebx*8+8],  mm2
	movq		QWORD PTR [edi+ebx*8+16], mm3
	movq		QWORD PTR [edi+ebx*8+24], mm4
	
	sub		ebx, 4
	jge		DoMMX1
#endif

	emms
	add	ebx, 4
	je	Done1

	dec	ebx
	xor	edx, edx
	
LastSamples1:	
	mov	dl, BYTE PTR [esi+ebx]

	sub	edx, 128
	mov	ecx, edx

	imul	edx, DWORD PTR lLVol
	imul	ecx, DWORD PTR lRVol

	shl	edx, 8
	mov	eax, DWORD PTR [edi+ebx*8]

	sar	edx, 15

	shl	ecx, 8
	add	edx, eax

	sar	ecx, 15
	mov	eax, DWORD PTR [edi+ebx*8+4]

	mov	DWORD PTR [edi+ebx*8], edx
	add	eax, ecx

	xor	edx, edx
	dec	ebx

	mov	DWORD PTR [edi+ebx*8+12], eax
	jge	LastSamples1
Done1:
        }
    }

#else // }
    QuickMixMonoToStereo8(CurStage, SampleCount, samplesleft);
#endif
    
    return SampleCount;
}

ULONG MmxConvertMonoToStereo16(PMIXER_OPERATION CurStage, ULONG SampleCount, ULONG samplesleft)
{
    PMIXER_SINK_INSTANCE    CurSink = (PMIXER_SINK_INSTANCE) CurStage->Context;
    PLONG   pOutputBuffer = CurStage->pOutputBuffer;
    UNALIGNED PSHORT  pIn16 = CurStage->pInputBuffer;
    PLONG   pMap = CurSink->pVolumeTable;

    // vol*32768 for ch0, ch1, ch2, etc.
    if (SampleCount == 0) {
        return 0;
    }

#ifdef GTW_CONVERT // {
    LONG lLVol = pMap[0], lRVol = pMap[1];

    if (lLVol & 0xffff8000 /* && lRVol & 0xffff8000 */)
    {
	// No Vol Control
       _asm {
        mov	ebx, SampleCount
        mov	esi, pIn16
	lea	ebx, [ebx*2-2]				// 2 at a time.
	cmp	ebx, 14
        mov	edi, pOutputBuffer
	jl	LastSamples

	sub	ebx, 6
	pxor	mm0, mm0
	lea	ecx, [esi+ebx]
	test	ecx, 7
	je	DoMMX

	add	ebx, 6

FirstSamples:	
	movsx	ecx, WORD PTR [esi+ebx]
	mov	DWORD PTR [edi+ebx*4], ecx
	mov	DWORD PTR [edi+ebx*4+4], ecx
	sub	ebx, 2
	lea	ecx, [esi+ebx]
	and	ecx, 7
	cmp	ecx, 6
	jne	FirstSamples

	sub	ebx, 6

DoMMX:
#ifdef GTW_REORDER
	movq		mm1, QWORD PTR [esi+ebx]	// Load source

	punpckhwd	mm3, mm1
	punpcklwd	mm1, mm1

	psrad		mm1, 16
	psrad		mm3, 16

	movq		mm2, mm1
	jmp	DoMMX00

DoMMX0:
	movq		mm1, QWORD PTR [esi+ebx]	// Load source

	movq		QWORD PTR [edi+ebx*4+16+32], mm3
	punpckhwd	mm3, mm1

	movq		QWORD PTR [edi+ebx*4+8 +32], mm2
	punpcklwd	mm1, mm1

	movq		QWORD PTR [edi+ebx*4+24+32], mm4
	psrad		mm1, 16

	movq		mm2, mm1
	psrad		mm3, 16

DoMMX00:
	sub		ebx, 8
	punpckldq	mm1, mm1

	punpckhdq	mm2, mm2
	movq		mm4, mm3

	movq		QWORD PTR [edi+ebx*4+32],    mm1
	punpckldq	mm3, mm3

	punpckhdq	mm4, mm4
	jge		DoMMX0

	movq		QWORD PTR [edi+ebx*4+8 +32], mm2
	movq		QWORD PTR [edi+ebx*4+16+32], mm3
	movq		QWORD PTR [edi+ebx*4+24+32], mm4
#else
	movq		mm1, QWORD PTR [esi+ebx]	// Load source

	punpckhwd	mm3, mm1
	punpcklwd	mm1, mm1

	psrad		mm1, 16
	psrad		mm3, 16

	movq		mm2, mm1
	movq		mm4, mm3

	punpckldq	mm1, mm1
	punpckhdq	mm2, mm2

	movq		QWORD PTR [edi+ebx*4],    mm1
	punpckldq	mm3, mm3

	movq		QWORD PTR [edi+ebx*4+8],  mm2
	punpckhdq	mm4, mm4

	movq		QWORD PTR [edi+ebx*4+16], mm3
	movq		QWORD PTR [edi+ebx*4+24], mm4
	
	sub		ebx, 8
	jge		DoMMX
#endif

	emms
	add	ebx, 8
	je	Done

	sub	ebx, 2
	
LastSamples:	
	movsx	eax, WORD PTR [esi+ebx]

	sub	ebx, 2
	mov	DWORD PTR [edi+ebx*4+8], eax

	mov	DWORD PTR [edi+ebx*4+12], eax
	jge	LastSamples
Done:
	}
    }
    else
    {
        if (0 && (lLVol | lRVol) & 0xffff8000) {
           if (lLVol & 0xffff8000) lLVol = 0x00007fff;
           if (lRVol & 0xffff8000) lRVol = 0x00007fff;
        }
	// Vol Control
        _asm {
        mov	ebx, SampleCount
        mov	esi, pIn16
	lea	ebx, [ebx*2-2]				// 2 at a time.
	cmp	ebx, 14
        mov	edi, pOutputBuffer
	jl	LastSamples1

	mov	eax, lRVol				// Use lower 16 bits
	mov	ecx, lLVol
	shl	eax, 16
	or	ecx, eax
	movd	mm6, ecx
	punpckldq	mm6, mm6

	sub	ebx, 6
	pxor	mm0, mm0
	lea	ecx, [esi+ebx]
	test	ecx, 7
	je	DoMMX1

	add	ebx, 6

FirstSamples1:	
	movsx	ecx, WORD PTR [esi+ebx]
	mov	edx, ecx

	imul	ecx, lLVol
	imul	edx, lRVol

	sar	ecx, 15
	sar	edx, 15

	mov	DWORD PTR [edi+ebx*4], ecx
	mov	DWORD PTR [edi+ebx*4+4], edx

	sub	ebx, 2
	lea	ecx, [esi+ebx]

	and	ecx, 7
	cmp	ecx, 6

	jne	FirstSamples1

	sub	ebx, 6

DoMMX1:
#ifdef GTW_REORDER
	movq		mm1, QWORD PTR [esi+ebx]	// Load source
	movq		mm3, mm1			// Mono samples

	punpcklwd	mm1, mm1
	punpckhwd	mm3, mm3

	pmulhw		mm1, mm6
	jmp	DoMMX100

DoMMX10:
	movq		mm1, QWORD PTR [esi+ebx]	// Load source

	movq		mm3, mm1			// Mono samples

	movq		QWORD PTR [edi+ebx*4+24+32], mm4
	punpcklwd	mm1, mm1

	punpckhwd	mm3, mm3

	pmulhw		mm1, mm6

DoMMX100:
	punpckhwd	mm2, mm1
	sub		ebx, 8

	pmulhw		mm3, mm6
	punpcklwd	mm1, mm1

	psrad		mm1, 15

	punpckhwd	mm4, mm3

	punpcklwd	mm3, mm3

	movq		QWORD PTR [edi+ebx*4+32],    mm1
	psrad		mm2, 15

	movq		QWORD PTR [edi+ebx*4+8 +32], mm2
	psrad		mm3, 15

	movq		QWORD PTR [edi+ebx*4+16+32], mm3
	psrad		mm4, 15

	jge		DoMMX10

	movq		QWORD PTR [edi+ebx*4+24+32], mm4
#else
	movq		mm1, QWORD PTR [esi+ebx]	// Load source
	movq		mm3, mm1			// Mono samples

	punpcklwd	mm1, mm1
	punpckhwd	mm3, mm3

	pmulhw		mm1, mm6
	pmulhw		mm3, mm6
	
	punpckhwd	mm2, mm1
	punpcklwd	mm1, mm1

	psrad		mm1, 15
	punpckhwd	mm4, mm3

	psrad		mm2, 15

	punpcklwd	mm3, mm3
	movq		QWORD PTR [edi+ebx*4],    mm1

	psrad		mm3, 15
	movq		QWORD PTR [edi+ebx*4+8],  mm2

	psrad		mm4, 15

	movq		QWORD PTR [edi+ebx*4+16], mm3
	movq		QWORD PTR [edi+ebx*4+24], mm4
	
	sub		ebx, 8
	jge		DoMMX1
#endif

	emms
	add	ebx, 8
	je	Done1

	sub	ebx, 2
	
LastSamples1:	
	movsx	ecx, WORD PTR [esi+ebx]
	mov	edx, ecx

	imul	ecx, lLVol
	imul	edx, lRVol

	sar	ecx, 15
	sar	edx, 15

	mov	DWORD PTR [edi+ebx*4], ecx
	mov	DWORD PTR [edi+ebx*4+4], edx

        sub	ebx, 2
	jge	LastSamples1
Done1:
	}
    }

#else // }
    ConvertMonoToStereo16(CurStage, SampleCount, samplesleft);
#endif
    
    return SampleCount;
}

ULONG MmxQuickMixMonoToStereo16(PMIXER_OPERATION CurStage, ULONG SampleCount, ULONG samplesleft)
{
    PMIXER_SINK_INSTANCE    CurSink = (PMIXER_SINK_INSTANCE) CurStage->Context;
    PLONG   pOutputBuffer = CurStage->pOutputBuffer;
    UNALIGNED PSHORT  pIn16 = CurStage->pInputBuffer;
    PLONG   pMap = CurSink->pVolumeTable;

    // vol*32768 for ch0, ch1, ch2, etc.
#ifdef GTW_MIX // {
    LONG lLVol = pMap[0], lRVol = pMap[1];

    if (SampleCount == 0) {
        return 0;
    }

    if (lLVol & 0xffff8000 /* && lRVol & 0xffff8000 */)
    {
	// No Vol Control
       _asm {
        mov	ebx, SampleCount
        mov	esi, pIn16
	lea	ebx, [ebx*2-2]				// 2 at a time.
	cmp	ebx, 14
        mov	edi, pOutputBuffer
	jl	LastSamples

	sub	ebx, 6
	pxor	mm0, mm0
	lea	ecx, [esi+ebx]
	test	ecx, 7
	je	DoMMX

	add	ebx, 6

FirstSamples:
        or      ebx, ebx
        jz      Done
	movsx	ecx, WORD PTR [esi+ebx]
	add	DWORD PTR [edi+ebx*4], ecx
	add	DWORD PTR [edi+ebx*4+4], ecx
	sub	ebx, 2
	lea	ecx, [esi+ebx]
	and	ecx, 7
	cmp	ecx, 6
	jne	FirstSamples

	sub	ebx, 6

DoMMX:
#ifdef GTW_REORDER
	movq		mm1, QWORD PTR [esi+ebx]	// Load source

	punpckhwd	mm3, mm1
	punpcklwd	mm1, mm1

	psrad		mm1, 16
	psrad		mm3, 16

	jmp	DoMMX00

DoMMX0:
	movq		mm1, QWORD PTR [esi+ebx]	// Load source

	movq		QWORD PTR [edi+ebx*4+16+32], mm3
	punpckhwd	mm3, mm1

	paddd		mm4, QWORD PTR [edi+ebx*4+24+32]
	punpcklwd	mm1, mm1

	movq		QWORD PTR [edi+ebx*4+8 +32], mm2
	psrad		mm1, 16

	movq		QWORD PTR [edi+ebx*4+24+32], mm4
	psrad		mm3, 16

DoMMX00:
	movq		mm2, mm1
	sub		ebx, 8

	punpckldq	mm1, mm1

	paddd		mm1, QWORD PTR [edi+ebx*4+32]
	punpckhdq	mm2, mm2

	paddd		mm2, QWORD PTR [edi+ebx*4+8+32]
	movq		mm4, mm3

	movq		QWORD PTR [edi+ebx*4+32],    mm1
	punpckldq	mm3, mm3

	paddd		mm3, QWORD PTR [edi+ebx*4+16+32]
	punpckhdq	mm4, mm4

	jge		DoMMX0

	paddd		mm4, QWORD PTR [edi+ebx*4+24+32]

	movq		QWORD PTR [edi+ebx*4+8 +32], mm2
	movq		QWORD PTR [edi+ebx*4+16+32], mm3
	movq		QWORD PTR [edi+ebx*4+24+32], mm4
#else
	movq		mm1, QWORD PTR [esi+ebx]	// Load source

	punpckhwd	mm3, mm1
	punpcklwd	mm1, mm1

	psrad		mm1, 16
	psrad		mm3, 16

	movq		mm2, mm1
	punpckldq	mm1, mm1

	punpckhdq	mm2, mm2
	paddd		mm1, QWORD PTR [edi+ebx*4]

	movq		mm4, mm3
	paddd		mm2, QWORD PTR [edi+ebx*4+8]

	punpckldq	mm3, mm3
	movq		QWORD PTR [edi+ebx*4],    mm1

	punpckhdq	mm4, mm4
	paddd		mm3, QWORD PTR [edi+ebx*4+16]

	paddd		mm4, QWORD PTR [edi+ebx*4+24]

	movq		QWORD PTR [edi+ebx*4+8],  mm2
	movq		QWORD PTR [edi+ebx*4+16], mm3
	movq		QWORD PTR [edi+ebx*4+24], mm4
	
	sub		ebx, 8
	jge		DoMMX
#endif

	emms
	add	ebx, 8
	je	Done

	sub	ebx, 2
	
LastSamples:	
	movsx	eax, WORD PTR [esi+ebx]

	mov	ecx, DWORD PTR[edi+ebx*4]
	mov	edx, DWORD PTR[edi+ebx*4+4]

	add	ecx, eax
	add	edx, eax

	sub	ebx, 2
	mov	DWORD PTR [edi+ebx*4+8], ecx

	mov	DWORD PTR [edi+ebx*4+12], edx
	jge	LastSamples
Done:
	}
    }
    else
    {
        if (0 && (lLVol | lRVol) & 0xffff8000) {
           if (lLVol & 0xffff8000) lLVol = 0x00007fff;
           if (lRVol & 0xffff8000) lRVol = 0x00007fff;
        }
	// Vol Control
        _asm {
        mov	ebx, SampleCount
        mov	esi, pIn16
	lea	ebx, [ebx*2-2]				// 2 at a time.
	cmp	ebx, 14
        mov	edi, pOutputBuffer
	jl	LastSamples1

	mov	eax, lRVol				// Use lower 16 bits
	mov	ecx, lLVol
	shl	eax, 16
	or	ecx, eax
	movd	mm6, ecx
	punpckldq	mm6, mm6

	sub	ebx, 6
	pxor	mm0, mm0
	lea	ecx, [esi+ebx]
	test	ecx, 7
	je	DoMMX1

	add	ebx, 6

FirstSamples1:
        or      ebx, ebx
        jz      Done1
	movsx	ecx, WORD PTR [esi+ebx]
	mov	edx, ecx

	imul	ecx, lLVol
	imul	edx, lRVol

	sar	ecx, 15
	sar	edx, 15

	add	DWORD PTR [edi+ebx*4], ecx
	add	DWORD PTR [edi+ebx*4+4], edx

	sub	ebx, 2
	lea	ecx, [esi+ebx]

	and	ecx, 7
	cmp	ecx, 6

	jne	FirstSamples1

	sub	ebx, 6

DoMMX1:
#ifdef GTW_REORDER
	movq		mm1, QWORD PTR [esi+ebx]	// Load source
	movq		mm3, mm1			// Mono samples

	punpcklwd	mm1, mm1
	punpckhwd	mm3, mm3

	pmulhw		mm1, mm6
	jmp	DoMMX100

DoMMX10:
	movq		mm1, QWORD PTR [esi+ebx]	// Load source

	movq		QWORD PTR [edi+ebx*4+16+32], mm3
	movq		mm3, mm1			// Mono samples

	paddd		mm4, QWORD PTR [edi+ebx*4+24+32]
	punpcklwd	mm1, mm1

	movq		QWORD PTR [edi+ebx*4+8 +32], mm2
	punpckhwd	mm3, mm3

	movq		QWORD PTR [edi+ebx*4+24+32], mm4
	pmulhw		mm1, mm6

DoMMX100:
	punpckhwd	mm2, mm1
	sub		ebx, 8

	pmulhw		mm3, mm6
	
	punpcklwd	mm1, mm1

	psrad		mm1, 15

	paddd		mm1, QWORD PTR [edi+ebx*4+32]
	punpckhwd	mm4, mm3

	punpcklwd	mm3, mm3

	movq		QWORD PTR [edi+ebx*4+32],    mm1
	psrad		mm2, 15

	paddd		mm2, QWORD PTR [edi+ebx*4+8+32]
	psrad		mm3, 15

	paddd		mm3, QWORD PTR [edi+ebx*4+16+32]
	psrad		mm4, 15

	jge		DoMMX10

	movq		QWORD PTR [edi+ebx*4+16+32], mm3
	paddd		mm4, QWORD PTR [edi+ebx*4+24+32]
	movq		QWORD PTR [edi+ebx*4+8 +32], mm2
	movq		QWORD PTR [edi+ebx*4+24+32], mm4
#else
	movq		mm1, QWORD PTR [esi+ebx]	// Load source
	movq		mm3, mm1			// Mono samples

	punpcklwd	mm1, mm1
	punpckhwd	mm3, mm3

	pmulhw		mm1, mm6
	pmulhw		mm3, mm6
	
	punpckhwd	mm2, mm1
	punpcklwd	mm1, mm1

	punpckhwd	mm4, mm3
	psrad		mm1, 15

	punpcklwd	mm3, mm3
	psrad		mm2, 15

	paddd		mm1, QWORD PTR [edi+ebx*4]
	psrad		mm3, 15

	paddd		mm2, QWORD PTR [edi+ebx*4+8]
	psrad		mm4, 15

	paddd		mm3, QWORD PTR [edi+ebx*4+16]
	paddd		mm4, QWORD PTR [edi+ebx*4+24]
	movq		QWORD PTR [edi+ebx*4],    mm1
	movq		QWORD PTR [edi+ebx*4+8],  mm2
	movq		QWORD PTR [edi+ebx*4+16], mm3
	movq		QWORD PTR [edi+ebx*4+24], mm4
	
	sub		ebx, 8
	jge		DoMMX1
#endif

	emms
	add	ebx, 8
	je	Done1

	sub	ebx, 2
	
LastSamples1:	
	movsx	ecx, WORD PTR [esi+ebx]
	mov	edx, ecx
	mov	eax, DWORD PTR [edi+ebx*4]

	imul	ecx, lLVol
	imul	edx, lRVol

	sar	ecx, 15
	sar	edx, 15

	add	eax, ecx
        mov	ecx, DWORD PTR [edi+ebx*4+4]

	mov	DWORD PTR [edi+ebx*4], eax
        add	ecx, edx

	mov	DWORD PTR [edi+ebx*4+4], ecx
        sub	ebx, 2

	jge	LastSamples1
Done1:
	}
    }

#else // }
    QuickMixMonoToStereo16(CurStage, SampleCount, samplesleft);
#endif
    
    return SampleCount;
}

NTSTATUS MmxPeg32to16
(
        PLONG  pMixBuffer,
        PSHORT  pWriteBuffer,
        ULONG   SampleCount,             // after multiplying by NumChannels
        ULONG   nStreams
)
{
	if (SampleCount) {
    	_asm {
        	mov	ebx, SampleCount
        	mov	esi, pMixBuffer
        	mov	edi, pWriteBuffer

        	mov	ecx, ebx
        	lea	esi, [esi+ebx*4]
        	lea	edi, [edi+ebx*2]

        	neg	ebx
        	cmp	ecx, 7
        	jl	Last

        	lea	eax, [edi+ebx*2]
        	test	eax, 7
        	jz	DoMMX

        	test eax, 1
        	jnz Last

Start:
        	mov	ecx, DWORD PTR [esi+ebx*4]

        	movd		mm1, ecx
        	inc	ebx

        	packssdw	mm1, mm1
        	lea	eax, [edi+ebx*2]

        	movd		ecx, mm1
        	test	eax, 7

        	mov	WORD PTR [edi+ebx*2-2], cx
        	jnz	Start

DoMMX:
        	add	ebx, 4

DoMMX0:
        	movq		mm1, [esi+ebx*4-16]
        	movq		mm2, [esi+ebx*4+8-16]

        	packssdw	mm1, mm2

        	movq		[edi+ebx*2-8], mm1

        	add	ebx, 4
        	jle	DoMMX0

        	sub	ebx, 4
        	jz	Done
Last:
        	mov	ecx, DWORD PTR [esi+ebx*4]

        	movd		mm1, ecx
        	inc	ebx
        	packssdw	mm1, mm1
        	movd		ecx, mm1

        	mov	WORD PTR [edi+ebx*2-2], cx
        	jl	Last

Done:	
        	emms
    	}
	}
	return STATUS_SUCCESS;
}

NTSTATUS MmxPeg32to8
(
        PLONG  pMixBuffer,
        PBYTE   pWriteBuffer,
        ULONG   SampleCount,             // after multiplying by NumChannels
        ULONG   nStreams
)
{
	if (SampleCount) {
    	_asm {
        	mov	ecx, 0x8000

        	movd		mm5, ecx
        	punpckldq	mm5, mm5	// 32768, 32768

        	mov	ecx, 0x80

        	movd		mm6, ecx
        	punpcklwd	mm6, mm6
        	punpckldq	mm6, mm6

        	mov	ebx, SampleCount
        	mov	esi, pMixBuffer
        	mov	edi, pWriteBuffer

        	mov	ecx, ebx
        	lea	esi, [esi+ebx*4]
        	add	edi, ebx		// lea	edi, [edi+ebx*1]

        	neg	ebx
        	cmp	ecx, 15
        	jl	Last

        	lea	eax, [edi+ebx*1]
        	test	eax, 7
        	jz	DoMMX

Start:
        	mov	ecx, DWORD PTR [esi+ebx*4]

        	movd		mm1, ecx

        	packssdw	mm1, mm1
        	lea	eax, [edi+ebx*1]

        	punpcklwd	mm1, mm1

        	psrad		mm1, 16
        	inc	ebx

        	paddd		mm1, mm5
        	test	eax, 7

        	psrad		mm1, 8

        	movd		ecx, mm1

        	mov	BYTE PTR [edi+ebx*1-1], cl
        	jnz	Start

DoMMX:
        	add	ebx, 8

        	movq		mm1, [esi+ebx*4-32]
        	movq		mm2, [esi+ebx*4+8-32]
        	jmp	Top00
Top0:
        	movq		mm7, [esi+ebx*4-32]
        	packuswb	mm1, mm3	// Saturation is NO-OP here.

        	movq		[edi+ebx*1-16], mm1

        	movq		mm2, [esi+ebx*4+8-32]
        	movq		mm1, mm7
Top00:
        	movq		mm3, [esi+ebx*4+16-32]
        	packssdw	mm1, mm2	// Clip.

        	movq		mm4, [esi+ebx*4+24-32]
        	psraw		mm1, 8

        	packssdw	mm3, mm4
        	add	ebx, 8

        	psraw		mm3, 8
        	paddw		mm1, mm6

        	paddw		mm3, mm6
        	jle	Top0

        	packuswb	mm1, mm3	// Saturation is NO-OP here.
        	sub	ebx, 8

        	movq		[edi+ebx*1-8], mm1
        	jz	Done

Last:
        	mov	ecx, DWORD PTR [esi+ebx*4]

        	movd		mm1, ecx
        	packssdw	mm1, mm1
        	punpcklwd	mm1, mm1
        	psrad		mm1, 16
        	inc	ebx
        	paddd		mm1, mm5
        	psrad		mm1, 8
        	movd		ecx, mm1

        	mov	BYTE PTR [edi+ebx*1-1], cl
        	jl	Last

Done:	
        	emms
    	}
	}
	return STATUS_SUCCESS;
}

DWORD
MmxSrcMix_StereoLinear
(
    PMIXER_OPERATION        CurStage,
    ULONG                   nSamples,
    ULONG                   nOutputSamples
)
{
    PMIXER_SRC_INSTANCE fp = (PMIXER_SRC_INSTANCE) CurStage->Context;
	ULONG nChannels = fp->nChannels;
	DWORD 	nOut = 0, dwFrac, SampleFrac;
	PLONG	pHistory;
	DWORD	L = fp->UpSampleRate;
	DWORD	M = fp->DownSampleRate;
    PLONG   pTemp;
	PLONG  pOut = CurStage->pOutputBuffer, pDstEnd, pSrcEnd;
    extern DWORD DownFraction[];
    extern DWORD UpFraction[];
	
    dwFrac = fp->dwFrac;

    pHistory = (PLONG)CurStage->pInputBuffer - 2*nChannels;
	SampleFrac = fp->SampleFrac;
	pDstEnd = pOut + nOutputSamples * nChannels;
	pSrcEnd = pHistory + (nSamples + 2)*nChannels;
	
   _asm {
    	mov	esi, pHistory
    	mov	edi, pOut

    	push	dwFrac
    	push	pDstEnd
    	mov	eax, pSrcEnd
    	sub	eax, 8
    	push	eax
      	mov eax, SampleFrac		// Fractional counter.
    	push	ebp
    	mov	edx, esi
    	mov	ebp, eax		// Current fraction.

    	mov	ecx, eax
    	shr	ecx, 12
    	lea	esi, [edx+ecx*8]	// pSource + (dwFraction >> 12) * 8
    	
    // Note that the exact number of times through the loop can be calculated...

    	cmp	edi, DWORD PTR [esp+8]	// plBuild >= plBuildEnd
    	jae	Exit

    Top:
    	cmp	esi, DWORD PTR [esp+4]	// pSource >= pSourceEnd
    	jae	Exit

    // End note.

    	movq		mm1, QWORD PTR [esi]
    	and	ebp, 4095		// dwFrac = dwFraction & 0x0fff

    	movq		mm2, QWORD PTR [esi+8]
    	movd		mm5, ebp

    	psubd		mm2, mm1
    	punpcklwd	mm5, mm5

    	packssdw	mm2, mm2	// Use the 2 lowest words.
    	add	edi, 8			// plBuild += 2

    	movq		mm3, mm2
    	pmullw		mm2, mm5

    	movq		mm6, QWORD PTR [edi-8]
    	pmulhw		mm3, mm5

    	mov	ebp, DWORD PTR [esp+12]	// dwStep
    	paddd		mm1, mm6

    	add	eax, ebp		// dwFraction += dwStep
    	punpcklwd	mm2, mm3

    	mov	ecx, eax
    	psrad		mm2, 12

    	mov	ebp, eax
    	shr	ecx, 12

    	paddd		mm1, mm2
    	movq		QWORD PTR [edi-8], mm1

    	lea	esi, [edx+ecx*8]	// pSource + (dwFraction >> 12) * 8
    	cmp	edi, DWORD PTR [esp+8]	// plBuild < plBuildEnd

    	jb	Top
Exit:
    	emms
    	pop	ebp
    	add	esp, 12
    	mov pOut, edi
    	mov pHistory, esi
    	mov SampleFrac, eax
	}
	
    pTemp = (PLONG)CurStage->pInputBuffer - 2*nChannels;
    pHistory = pTemp + nSamples * nChannels;
    pTemp[0] = pHistory[0];
    pTemp[1] = pHistory[1];
    pTemp[2] = pHistory[2];
    pTemp[3] = pHistory[3];

#ifdef SRC_NSAMPLES_ASSERT
    ASSERT((SampleFrac >> 12) >= nSamples);
#endif
    if ((SampleFrac >> 12) >= nSamples) {
        // We will take an extra sample next time.
        SampleFrac -= nSamples*4096;
    }
    fp->SampleFrac = SampleFrac;

#ifdef SRC_NSAMPLES_ASSERT
    ASSERT(pOut == pDstEnd);
#endif

	return (nOutputSamples);
}

DWORD
MmxSrc_StereoLinear
(
    PMIXER_OPERATION        CurStage,
    ULONG                   nSamples,
    ULONG                   nOutputSamples
)
{
    PMIXER_SRC_INSTANCE fp = (PMIXER_SRC_INSTANCE) CurStage->Context;
	ULONG nChannels = fp->nChannels;
	DWORD 	nOut = 0, dwFrac, SampleFrac;
	PLONG	pHistory;
	DWORD	L = fp->UpSampleRate;
	DWORD	M = fp->DownSampleRate;
    PLONG   pTemp;
	PLONG  pOut = CurStage->pOutputBuffer, pDstEnd, pSrcEnd;
    extern DWORD DownFraction[];
    extern DWORD UpFraction[];
	
    // We just clear the output buffer first.
    ZeroBuffer32(CurStage, nSamples, nOutputSamples);

    dwFrac = fp->dwFrac;

    pHistory = (PLONG)CurStage->pInputBuffer - 2*nChannels;
	SampleFrac = fp->SampleFrac;
	pDstEnd = pOut + nOutputSamples * nChannels;
	pSrcEnd = pHistory + (nSamples + 2)*nChannels;
	
   _asm {
    	mov	esi, pHistory
    	mov	edi, pOut

    	push	dwFrac
    	push	pDstEnd
    	mov	eax, pSrcEnd
    	sub	eax, 8
    	push	eax
      	mov eax, SampleFrac		// Fractional counter.
    	push	ebp
    	mov	edx, esi
    	mov	ebp, eax		// Current fraction.

    	mov	ecx, eax
    	shr	ecx, 12
    	lea	esi, [edx+ecx*8]	// pSource + (dwFraction >> 12) * 8
    	
    // Note that the exact number of times through the loop can be calculated...

    	cmp	edi, DWORD PTR [esp+8]	// plBuild >= plBuildEnd
    	jae	Exit

    Top:
    	cmp	esi, DWORD PTR [esp+4]	// pSource >= pSourceEnd
    	jae	Exit

    // End note.

    	movq		mm1, QWORD PTR [esi]
    	and	ebp, 4095		// dwFrac = dwFraction & 0x0fff

    	movq		mm2, QWORD PTR [esi+8]
    	movd		mm5, ebp

    	psubd		mm2, mm1
    	punpcklwd	mm5, mm5

    	packssdw	mm2, mm2	// Use the 2 lowest words.
    	add	edi, 8			// plBuild += 2

    	movq		mm3, mm2
    	pmullw		mm2, mm5

    	movq		mm6, QWORD PTR [edi-8]
    	pmulhw		mm3, mm5

    	mov	ebp, DWORD PTR [esp+12]	// dwStep
#if 0
    	paddd		mm1, mm6		// Not actually needed...ZeroBuffer32 above.
#endif

    	add	eax, ebp		// dwFraction += dwStep
    	punpcklwd	mm2, mm3

    	mov	ecx, eax
    	psrad		mm2, 12

    	mov	ebp, eax
    	shr	ecx, 12

    	paddd		mm1, mm2
    	movq		QWORD PTR [edi-8], mm1

    	lea	esi, [edx+ecx*8]	// pSource + (dwFraction >> 12) * 8
    	cmp	edi, DWORD PTR [esp+8]	// plBuild < plBuildEnd

    	jb	Top
Exit:
    	emms
    	pop	ebp
    	add	esp, 12
    	mov pOut, edi
    	mov pHistory, esi
    	mov SampleFrac, eax
	}
	
    pTemp = (PLONG)CurStage->pInputBuffer - 2*nChannels;
    pHistory = pTemp + nSamples * nChannels;
    pTemp[0] = pHistory[0];
    pTemp[1] = pHistory[1];
    pTemp[2] = pHistory[2];
    pTemp[3] = pHistory[3];

#ifdef SRC_NSAMPLES_ASSERT
    ASSERT((SampleFrac >> 12) >= nSamples);
#endif
    if ((SampleFrac >> 12) >= nSamples) {
        // We will take an extra sample next time.
        SampleFrac -= nSamples*4096;
    }
    fp->SampleFrac = SampleFrac;

#ifdef SRC_NSAMPLES_ASSERT
    ASSERT(pOut == pDstEnd);
#endif

	return (nOutputSamples);
}

// WARNING!!! The code below seems to have a bug that produces pops.
ULONG
MmxConvert16(PMIXER_OPERATION CurStage, ULONG SampleCount, ULONG samplesleft)
{
    PMIXER_SINK_INSTANCE    CurSink = (PMIXER_SINK_INSTANCE) CurStage->Context;
    PLONG   pOutputBuffer = CurStage->pOutputBuffer;
    PFLOAT  pFloatBuffer = CurStage->pOutputBuffer;
    UNALIGNED PSHORT  pIn16 = CurStage->pInputBuffer;
    UNALIGNED PBYTE	pIn8 = CurStage->pInputBuffer;
    ULONG   nChannels = CurStage->nOutputChannels;
    LARGE_INTEGER    Multiplier = {1, 1};
    
    samplesleft = SampleCount;
    if (SampleCount == 0) {
        return 0;
    }
    _asm {
        mov eax, SampleCount
        mov ebx, nChannels
        
        imul eax, ebx
        
        mov esi, pIn16
        mov edi, pOutputBuffer

        movq mm3, Multiplier                // 0, 1, 0, 1
        lea esi, [esi+eax*2]

        lea edi, [edi+eax*4]
        neg eax

        add eax, 8
        jns DoneWithEights

        // Do eight at a time
        movq mm0, qword ptr [esi+eax*2-16]  // x3, x2, x1, x0
        
        movq mm1, mm0                       // x3, x2, x1, x0
        
        movq mm4, qword ptr [esi+eax*2-8]   // x7, x6, x5, x4
        psrad mm0, 16                       // x3, x1

        pmaddwd mm1, mm3                    // 
        movq mm5, mm4
        
        psrad mm4, 16
        pmaddwd mm5, mm3

        movq mm2, mm1
        punpckldq mm1, mm0

        movq [edi+eax*4-32], mm1
        punpckhdq mm2, mm0

        movq [edi+eax*4-24], mm2
        movq mm6, mm5
        
        movq mm0, qword ptr [esi+eax*2]
        punpckldq mm5, mm4

        movq [edi+eax*4-16], mm5
        punpckhdq mm6, mm4

        add eax, 8
        jns DoneWithEights
Loop8:
        movq [edi+eax*4-40], mm6
        movq mm1, mm0
        
        movq mm4, qword ptr [esi+eax*2-8]
        psrad mm0, 16

        pmaddwd mm1, mm3
        movq mm5, mm4
        
        psrad mm4, 16
        pmaddwd mm5, mm3

        movq mm2, mm1
        punpckldq mm1, mm0

        movq [edi+eax*4-32], mm1
        punpckhdq mm2, mm0

        movq [edi+eax*4-24], mm2
        movq mm6, mm5
        
        movq mm0, qword ptr [esi+eax*2]
        punpckldq mm5, mm4

        movq [edi+eax*4-16], mm5
        punpckhdq mm6, mm4

        add eax, 8
        js Loop8

DoneWithEights:            
        movq [edi+eax*4-40], mm6
        sub eax, 8

Loop1:
        movsx ebx, word ptr [esi+eax*2]
        
        mov [edi+eax*4], ebx

        inc eax
        jnz Loop1
        
        emms
    }

    return samplesleft;
}

#define MMX32_START_MAC_SEQUENCE() _asm { mov esi, pTemp }; \
                _asm { mov edi, pCoeff }; \
                _asm { movq mm0, [esi+16] }; \
                _asm { pxor mm7, mm7 }; \
                _asm { movq mm2, [esi+8] }; \
                _asm { movq mm1, mm0 }; \
                _asm { pmaddwd mm0, [edi] }; \
                _asm { movq mm3, mm2 }; \
                _asm { pmaddwd mm1, [edi+9600*2] }; \
                _asm { movq mm4, [esi] }; \
                _asm { pmaddwd mm2, [edi+8] }; \
                _asm { movq mm5, mm4 }; \
                _asm { pmaddwd mm3, [edi+8+9600*2] }; \
                _asm { movq mm6, mm0 };

#define MMX32_MAC(a) _asm { movq mm0, [esi-a*24+16] }; \
                _asm { paddd mm7, mm1 }; \
                _asm { pmaddwd mm4, [edi+a*24-8] }; \
                _asm { movq mm1, mm0 }; \
                _asm { pmaddwd mm5, [edi+a*24-8+9600*2] }; \
                _asm { paddd mm6, mm2 }; \
                _asm { movq mm2, [esi-a*24+8] }; \
                _asm { paddd mm7, mm3 }; \
                _asm { pmaddwd mm0, [edi+a*24] }; \
                _asm { movq mm3, mm2 }; \
                _asm { pmaddwd mm1, [edi+a*24+9600*2] }; \
                _asm { paddd mm6, mm4 }; \
                _asm { movq mm4, [esi-a*24] }; \
                _asm { paddd mm7, mm5 }; \
                _asm { pmaddwd mm2, [edi+a*24+8] }; \
                _asm { movq mm5, mm4 }; \
                _asm { pmaddwd mm3, [edi+a*24+8+9600*2] }; \
                _asm { paddd mm6, mm0 };

#define MMX32_END_MAC_SEQUENCE(a) _asm { pmaddwd mm4, [edi+a*24-8] }; \
                _asm { paddd mm7, mm1 }; \
                _asm { pmaddwd mm5, [edi+a*24-8+9600*2] }; \
                _asm { paddd mm6, mm2 }; \
                _asm { paddd mm7, mm3 }; \
                _asm { paddd mm6, mm4 }; \
                _asm { paddd mm7, mm5 }; \
                _asm { movq mm0, mm6 }; \
                _asm { punpckhdq mm6, mm6 }; \
                _asm { paddd mm0, mm6 }; \
                _asm { psrad mm0, 8 }; \
                _asm { movq mm1, mm7 }; \
                _asm { punpckhdq mm7, mm7 }; \
                _asm { paddd mm1, mm7 }; \
                _asm { psrad mm1, 15 }; \
                _asm { paddd mm0, mm1 }; \
                _asm { movd eax, mm0 }; \
                _asm { mov edx, pOut }; \
                _asm { mov ecx, k }; \
                _asm { mov ebx, [edx+ecx*4-4] }; \
                _asm { add eax, ebx }; \
                _asm { mov [edx+ecx*4-4], eax };

#define MMX_START_MAC_SEQUENCE() _asm { mov esi, pTemp }; \
                _asm { mov edi, pCoeff }; \
                _asm { movq mm0, [esi+16] }; \
                _asm { pmaddwd mm0, [edi] }; \
                _asm { movq mm2, [esi+8] }; \
                _asm { pmaddwd mm2, [edi+8] }; \
                _asm { movq mm4, [esi] }; \
                _asm { movq mm6, mm0 }; \
                _asm { pmaddwd mm4, [edi+16] };

#define MMX_MAC(a) _asm { movq mm0, [esi-a*24+16] }; \
                _asm { paddd mm6, mm2 }; \
                _asm { movq mm2, [esi-a*24+8] }; \
                _asm { pmaddwd mm0, [edi+a*24] }; \
                _asm { paddd mm6, mm4 }; \
                _asm { movq mm4, [esi-a*24] }; \
                _asm { pmaddwd mm2, [edi+a*24+8] }; \
                _asm { paddd mm6, mm0 }; \
                _asm { pmaddwd mm4, [edi+a*24+16] };

#define MMX_END_MAC_SEQUENCE() _asm { paddd mm6, mm2 }; \
                _asm { mov edx, pOut }; \
                _asm { mov ecx, k }; \
                _asm { paddd mm6, mm4 }; \
                _asm { movq mm0, mm6 }; \
                _asm { punpckhdq mm6, mm6 }; \
                _asm { paddd mm0, mm6 }; \
                _asm { psrad mm0, 15 }; \
                _asm { movd eax, mm0 }; \
                _asm { mov ebx, [edx+ecx*4-4] }; \
                _asm { add eax, ebx }; \
                _asm { mov [edx+ecx*4-4], eax };

#define XMMX_GTW
//#define XMMX_P4			// P4 code not faster...
#ifdef XMMX_P4
#define XMMX_MAC()	\
					_asm { movq		mm0, [esi-1*24+16] }; \
					\
					_asm { movdqu	xmm6, [esi - 16] }; \
					_asm { movdqu	xmm5, [edi + 32] } ; \
					_asm { paddd	mm6, mm2 }; \
					_asm { pmaddwd	xmm6, xmm5 }; \
					\
					_asm { movdqu	xmm4, [esi - 32] }; \
					_asm { movdqu	xmm5, [edi + 48] } ; \
					_asm { movdqu	xmm0, [esi - 48] }; \
					_asm { pmaddwd	xmm4, xmm5 }; \
					\
					_asm { movdqu	xmm5, [edi + 64] } ; \
					_asm { pmaddwd	mm0, [edi+1*24] }; \
					_asm { movdqu	xmm2, [esi - 64] }; \
					_asm { pmaddwd	xmm0, xmm5 }; \
					_asm { movdqu	xmm5, [edi + 80] } ; \
					_asm { paddd	xmm6, xmm4 }; \
					\
					_asm { pmaddwd	xmm2, xmm5 }; \
					_asm { movdqu	xmm4, [esi - 80] }; \
					_asm { movdqu	xmm5, [edi + 96] } ; \
					_asm { paddd	xmm6, xmm0 }; \
					_asm { pmaddwd	xmm4, xmm5 }; \
					_asm { paddd	xmm6, xmm2 }; \
					_asm { paddd	mm6, mm4 }; \
					\
					_asm { paddd	xmm6, xmm4 }; \
					_asm { paddd	mm6, mm0 }; \
					\
					_asm { movdqu		xmm2, xmm6 }; \
					_asm { punpckhqdq	xmm6, xmm6 }; \
					_asm { movq			mm4, [esi-4*24] }; \
					_asm { paddd			xmm2, xmm6 }; \
					_asm { pmaddwd		mm4, [edi+4*24+16] }; \
					_asm { movdq2q		mm2,  xmm2 }; 
#else
#define XMMX_MAC()	\
					_asm { movq mm0, [esi-1*24+16] }; \
					_asm { paddd mm6, mm2 }; \
					_asm { movq mm2, [esi-1*24+8] }; 		/* -16 */ \
					_asm { pmaddwd mm0, [edi+1*24] }; \
					_asm { movq mm1, [esi-1*24] }; \
					\
					_asm { pmaddwd mm2, [edi+1*24+8] }; 	/* +32 */ \
					_asm { movq mm3, [esi-2*24+16] }; 		/* -32 */ \
					_asm { paddd mm6, mm4 }; \
					\
					_asm { pmaddwd mm1, [edi+1*24+16] }; \
					_asm { movq mm5, [esi-2*24+8] }; \
					_asm { paddd mm6, mm0 }; \
					\
					_asm { pmaddwd mm3, [edi+2*24] }; 		/* +48 */ \
					_asm { movq mm4, [esi-2*24] }; 			/* -48 */ \
					_asm { paddd mm6, mm2 }; \
					\
					_asm { pmaddwd mm5, [edi+2*24+8] }; \
					_asm { movq mm0, [esi-3*24+16] }; \
					_asm { paddd mm6, mm1 }; \
						\
					_asm { pmaddwd mm4, [edi+2*24+16] };	/* +64 */ \
					_asm { movq mm7, [esi-3*24+8] }; 		/* -64 */ \
					_asm { paddd mm6, mm3 }; \
					\
					_asm { pmaddwd mm0, [edi+3*24] }; \
					_asm { movq mm1, [esi-3*24] }; \
					_asm { paddd mm6, mm5 }; \
					\
					_asm { pmaddwd mm7, [edi+3*24+8] }; 	/* +80 */ \
					_asm { movq mm3, [esi-4*24+16] }; 		/* -80 */ \
					_asm { paddd mm6, mm4 }; \
					\
					_asm { pmaddwd mm1, [edi+3*24+16] }; \
					_asm { movq mm2, [esi-4*24+8] }; \
					_asm { paddd mm6, mm0 }; \
					\
					_asm { pmaddwd mm3, [edi+4*24] }; 		/* +96 */ \
					_asm { movq mm4, [esi-4*24] }; \
					_asm { paddd mm6, mm7 }; \
					\
					_asm { pmaddwd mm2, [edi+4*24+8] }; \
					_asm { paddd mm6, mm1 }; \
					\
					_asm { pmaddwd mm4, [edi+4*24+16] }; \
					_asm { paddd mm6, mm3 }; 
#endif

                
DWORD MmxSrcMix_Filtered
(
    PMIXER_OPERATION    CurStage,
    ULONG               nSamples,
    ULONG               nOutputSamples
)
{
    PMIXER_SRC_INSTANCE fp = (PMIXER_SRC_INSTANCE) CurStage->Context;
	DWORD 	i, k;
	PLONG	pTemp32 ;
	PSHORT  pTemp, pCoeffStart ;
    DWORD   L = fp->UpSampleRate;
	DWORD	M = fp->DownSampleRate;
    PLONG   pOut = (PLONG) CurStage->pOutputBuffer;
    ULONG   nSizeOfChannel = fp->csHistory;
    ULONG   nChannels = fp->nChannels;
    extern ULONG   FilterSizeFromQuality[];
    LONG    ElevenL = 11*L;
	DWORD   nCoefficients = FilterSizeFromQuality[fp->Quality];
	DWORD   j = fp->nOutCycle;
    PSHORT  pHistory = (PSHORT)CurStage->pInputBuffer;
	PSHORT  pCoeff = (PSHORT)fp->pCoeff + fp->CoeffIndex;
	PSHORT  pCoeffEnd = (PSHORT)fp->pCoeff + fp->nCoeffUsed;
	PSHORT  pHistoryStart = (PSHORT)CurStage->pInputBuffer - fp->nSizeOfHistory;
	LONG    Rounder[2] = { 0x4000L, 0L };

	/* First, we pretend that we up-sampled by a factor of L */
	/* Next, we low-pass filter the N * L samples */
	/* Finally, we down-sample (by a factor of M) to obtain N * L / M samples */
	/* Total: 	N * T / M Multiply Accumulate Cycles */
	/* (With T taps, N input samples, L:1 up-sample ratio, 1:M down-sample ratio) */

    // Change the input buffer to int16
    pTemp32 = (PLONG) CurStage->pInputBuffer;
    pTemp = (PSHORT) CurStage->pInputBuffer;
    if (nSamples) {
        _asm {
            mov esi, pTemp32
            mov edi, pTemp

            mov ecx, nSamples
            mov edx, nChannels

            imul ecx, edx

            lea esi, [esi+ecx*4]
            lea edi, [edi+ecx*2]
            
            neg ecx

    ConvertLoop:
            movq mm0, [esi+ecx*4]

            movq mm1, [esi+ecx*4+8]

            packssdw mm0, mm1

            movq [edi+ecx*2], mm0

            add ecx, 4
            js ConvertLoop
        }
    }

	/* Produce nOutputSamples samples generated from the input block */
	// (loop executes once for each output sample)

	for (i=0; i < nOutputSamples; i++) {
        while (j >= L) {
            // Take the next nChannels of input
            pTemp = pHistoryStart + nSizeOfChannel;
            pHistoryStart++;
            for (k=0; k<nChannels; k++) {
                *(pTemp) = pHistory[k];
                pTemp += nSizeOfChannel;
            }
    		j -= L;
            pHistory += nChannels;
    	}
    	
        pCoeffStart = pCoeff;
        pTemp = pHistoryStart + fp->nSizeOfHistory - 12;
        _asm {
            mov eax, j
            mov edx, nCoefficients

            sub eax, edx
            mov ebx, L

            mov esi, pTemp
            mov ecx, ElevenL                    // 11*L

            add eax, ecx                        // j-nCoefficients+11*L
            add ebx, ecx                        // 12*L

            mov edi, nSizeOfChannel
            push eax                            // j-nCoefficients+11*L

            shl edi, 1                          // nSizeOfChannel * sizeof(SHORT)
            mov ecx, nChannels

            push edi                            // 2*nSizeOfChannel
            push ebx                            // 12*L

            shl ebx, 2                          // 48*L
            mov edi, pCoeffStart

ChannelLoop:
            // Start the MAC sequence by doing the first 12 multiplies.
            movq mm6, [esi+16]

            pmaddwd mm6, [edi]

            movq mm2, [esi+8]

            pmaddwd mm2, [edi+8]

            movq mm4, [esi]

            pmaddwd mm4, [edi+16]

            add eax, ebx                        // j-nCoefficients+59*L
            jns SmallLoop

BigLoop:        
        }

#ifdef XMMX_GTW
		XMMX_MAC();
#else
        MMX_MAC(1);
        MMX_MAC(2);
        MMX_MAC(3);
        MMX_MAC(4);
#endif

        _asm {
            sub esi, 24*4
            add edi, 24*4

            add eax, ebx                        // +48*L
            js BigLoop

SmallLoop:
            sub eax, ebx                        // -48*L
            mov edx, [esp]                      // 12*L

            add eax, edx                        // +12*L
            jns OneLoop

Loop1:
        }

        MMX_MAC(1);

        _asm {
            sub esi, 24
            add edi, 24

            add eax, edx                        // +12*L
            js Loop1

OneLoop:
            sub eax, edx                        // -12*L
            mov edx, L

            shl edx, 2                          // 4*L

            add eax, edx                        // +4*L
            jns LoopDone

Loop2:
            paddd mm6, mm4
            
            movq mm4, [esi-8]

            pmaddwd mm4, [edi+24]

            sub esi, 8
            add edi, 8

            add eax, edx
            js Loop2

LoopDone:
            // Decide whether to do one last set of 4 MAC's
            sub eax, edx
            mov edx, L

            add eax, edx
            jns NoFinal

            paddd mm6, mm4

            movq mm4, [esi-8]

            pmaddwd mm4, [edi+24]

            sub esi, 8
            add edi, 8

NoFinal:
            paddd mm6, mm2
            add edi, 24

            mov pCoeff, edi
            mov edi, pOut

            paddd mm6, mm4
            mov esi, pTemp

            movq mm0, mm6
            punpckhdq mm6, mm6

            paddd mm0, mm6
            mov eax, [esp+4]                // 2*nSizeOfChannel

//            paddd mm0, Rounder
            
            psrad mm0, 15
            sub esi, eax

            mov edx, [edi+ecx*4-4]
            mov pTemp, esi

            movd eax, mm0

            add eax, edx

            mov [edi+ecx*4-4], eax
            dec ecx

            mov edi, pCoeffStart
            mov eax, [esp+8]                // j-nCoefficients+11*L
            
            jnz ChannelLoop

            add esp, 12
            
        }
        
		if (pCoeff >= pCoeffEnd) {
		    pCoeff = (PSHORT)fp->pCoeff;
		}
		
		pOut += nChannels;
        j += M;
	}

    nSamples -= (pHistoryStart + fp->nSizeOfHistory - (PSHORT)CurStage->pInputBuffer);
    while (j >= L && nSamples) {
        // Take the next nChannels of input
        pTemp = pHistoryStart + nSizeOfChannel;
        pHistoryStart++;
        for (k=0; k<nChannels; k++) {
            *(pTemp) = pHistory[k];
            pTemp += nSizeOfChannel;
        }
		j -= L;
        pHistory += nChannels;
    	nSamples--;
    }
    	
    // Copy last samples to history
    pTemp = (PSHORT)CurStage->pInputBuffer - fp->nSizeOfHistory;
    pHistory = pHistoryStart;
    for (i=0; i<fp->nSizeOfHistory; i++)
        pTemp[i] = pHistory[i];

	fp->nOutCycle = j;
	fp->CoeffIndex = pCoeff - (PSHORT)fp->pCoeff;

    // Check to make sure we did not use too many or too few input samples!!!
#ifdef SRC_NSAMPLES_ASSERT
    ASSERT( nSamples == 0 );
#endif

    _asm { emms }

	return (nOutputSamples);
}

DWORD MmxSrc_Filtered
(
    PMIXER_OPERATION    CurStage,
    ULONG               nSamples,
    ULONG               nOutputSamples
)
{
    PMIXER_SRC_INSTANCE fp = (PMIXER_SRC_INSTANCE) CurStage->Context;
	DWORD 	i, k;
	PLONG	pTemp32 ;
	PSHORT  pTemp, pCoeffStart ;
    DWORD   L = fp->UpSampleRate;
	DWORD	M = fp->DownSampleRate;
    PLONG   pOut = (PLONG) CurStage->pOutputBuffer;
    ULONG   nSizeOfChannel = fp->csHistory;
    ULONG   nChannels = fp->nChannels;
    extern ULONG   FilterSizeFromQuality[];
    LONG    ElevenL = 11*L;
	DWORD   nCoefficients = FilterSizeFromQuality[fp->Quality];
	DWORD   j = fp->nOutCycle;
    PSHORT  pHistory = (PSHORT)CurStage->pInputBuffer;
	PSHORT  pCoeff = (PSHORT)fp->pCoeff + fp->CoeffIndex;
	PSHORT  pCoeffEnd = (PSHORT)fp->pCoeff + fp->nCoeffUsed;
	PSHORT  pHistoryStart = (PSHORT)CurStage->pInputBuffer - fp->nSizeOfHistory;
	LONG    Rounder[2] = { 0x4000L, 0L };

    // We just clear the output buffer first.
    ZeroBuffer32(CurStage, nSamples, nOutputSamples);

	/* First, we pretend that we up-sampled by a factor of L */
	/* Next, we low-pass filter the N * L samples */
	/* Finally, we down-sample (by a factor of M) to obtain N * L / M samples */
	/* Total: 	N * T / M Multiply Accumulate Cycles */
	/* (With T taps, N input samples, L:1 up-sample ratio, 1:M down-sample ratio) */

    // Change the input buffer to int16
    pTemp32 = (PLONG) CurStage->pInputBuffer;
    pTemp = (PSHORT) CurStage->pInputBuffer;

    if (nSamples) {
        _asm {
            mov esi, pTemp32
            mov edi, pTemp

            mov ecx, nSamples
            mov edx, nChannels

            imul ecx, edx

            lea esi, [esi+ecx*4]
            lea edi, [edi+ecx*2]
            
            neg ecx

    ConvertLoop:
            movq mm0, [esi+ecx*4]

            movq mm1, [esi+ecx*4+8]

            packssdw mm0, mm1

            movq [edi+ecx*2], mm0

            add ecx, 4
            js ConvertLoop
        }
    }

	/* Produce nOutputSamples samples generated from the input block */
	// (loop executes once for each output sample)

	for (i=0; i < nOutputSamples; i++) {
        while (j >= L) {
            // Take the next nChannels of input
            pTemp = pHistoryStart + nSizeOfChannel;
            pHistoryStart++;
            for (k=0; k<nChannels; k++) {
                *(pTemp) = pHistory[k];
                pTemp += nSizeOfChannel;
            }
    		j -= L;
            pHistory += nChannels;
    	}
    	
        pCoeffStart = pCoeff;
        pTemp = pHistoryStart + fp->nSizeOfHistory - 12;
        _asm {
            mov eax, j
            mov edx, nCoefficients

            sub eax, edx
            mov ebx, L

            mov esi, pTemp
            mov ecx, ElevenL                    // 11*L

            add eax, ecx                        // j-nCoefficients+11*L
            add ebx, ecx                        // 12*L

            mov edi, nSizeOfChannel
            push eax                            // j-nCoefficients+11*L

            shl edi, 1                          // nSizeOfChannel * sizeof(SHORT)
            mov ecx, nChannels

            push edi                            // 2*nSizeOfChannel
            push ebx                            // 12*L

            shl ebx, 2                          // 48*L
            mov edi, pCoeffStart

ChannelLoop:
            // Start the MAC sequence by doing the first 12 multiplies.
            movq mm6, [esi+16]

            pmaddwd mm6, [edi]

            movq mm2, [esi+8]

            pmaddwd mm2, [edi+8]

            movq mm4, [esi]

            pmaddwd mm4, [edi+16]

            add eax, ebx                        // j-nCoefficients+59*L
            jns SmallLoop

BigLoop:        
        }

#ifdef XMMX_GTW
		XMMX_MAC();
#else
        MMX_MAC(1);
        MMX_MAC(2);
        MMX_MAC(3);
        MMX_MAC(4);
#endif

        _asm {
            sub esi, 24*4
            add edi, 24*4

            add eax, ebx                        // +48*L
            js BigLoop

SmallLoop:
            sub eax, ebx                        // -48*L
            mov edx, [esp]                      // 12*L

            add eax, edx                        // +12*L
            jns OneLoop

Loop1:
        }

        MMX_MAC(1);

        _asm {
            sub esi, 24
            add edi, 24

            add eax, edx                        // +12*L
            js Loop1

OneLoop:
            sub eax, edx                        // -12*L
            mov edx, L

            shl edx, 2                          // 4*L

            add eax, edx                        // +4*L
            jns LoopDone

Loop2:
            paddd mm6, mm4
            
            movq mm4, [esi-8]

            pmaddwd mm4, [edi+24]

            sub esi, 8
            add edi, 8

            add eax, edx
            js Loop2

LoopDone:
            // Decide whether to do one last set of 4 MAC's
            sub eax, edx
            mov edx, L

            add eax, edx
            jns NoFinal

            paddd mm6, mm4

            movq mm4, [esi-8]

            pmaddwd mm4, [edi+24]

            sub esi, 8
            add edi, 8

NoFinal:
            paddd mm6, mm2
            add edi, 24

            mov pCoeff, edi
            mov edi, pOut

            paddd mm6, mm4
            mov esi, pTemp

            movq mm0, mm6
            punpckhdq mm6, mm6

            paddd mm0, mm6
            mov eax, [esp+4]                // 2*nSizeOfChannel

//            paddd mm0, Rounder
            
            psrad mm0, 15
            sub esi, eax

            mov edx, [edi+ecx*4-4]
            movd eax, mm0
#if 0
            add	eax, edx			// Not actually needed...ZeroBuffer32 above.
#endif

            mov pTemp, esi
            mov [edi+ecx*4-4], eax
            dec ecx
            mov edi, pCoeffStart

            mov eax, [esp+8]                // j-nCoefficients+11*L
            jnz ChannelLoop

            add esp, 12
            
        }
        
		if (pCoeff >= pCoeffEnd) {
		    pCoeff = (PSHORT)fp->pCoeff;
		}
		
		pOut += nChannels;
        j += M;
	}

    nSamples -= (pHistoryStart + fp->nSizeOfHistory - (PSHORT)CurStage->pInputBuffer);
    while (j >= L && nSamples) {
        // Take the next nChannels of input
        pTemp = pHistoryStart + nSizeOfChannel;
        pHistoryStart++;
        for (k=0; k<nChannels; k++) {
            *(pTemp) = pHistory[k];
            pTemp += nSizeOfChannel;
        }
		j -= L;
        pHistory += nChannels;
    	nSamples--;
    }
    	
    // Copy last samples to history
    pTemp = (PSHORT)CurStage->pInputBuffer - fp->nSizeOfHistory;
    pHistory = pHistoryStart;
    for (i=0; i<fp->nSizeOfHistory; i++)
        pTemp[i] = pHistory[i];

	fp->nOutCycle = j;
	fp->CoeffIndex = pCoeff - (PSHORT)fp->pCoeff;

    // Check to make sure we did not use too many or too few input samples!!!
#ifdef SRC_NSAMPLES_ASSERT
    ASSERT( nSamples == 0 );
#endif

    _asm { emms }

	return (nOutputSamples);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\filters\kmixer\perf.c ===
/*++

Copyright (c) 2001 Microsoft Corporation.  All Rights Reserved.


Module Name:

    perf.c

Abstract:

Author:

    ArthurZ

Environment:

    Kernel Mode

--*/



#include "common.h"
#include "perf.h"



#define PROC_REG_PATH L"System\\CurrentControlSet\\Services\\Kmixer"



typedef struct PERFINFO_AUDIOGLITCH {
    ULONGLONG   cycleCounter;
    ULONG       glitchType;
    LONGLONG    sampleTime;
    LONGLONG    previousTime;
    ULONG_PTR       instanceId;
} PERFINFO_AUDIOGLITCH, *PPERFINFO_AUDIOGLITCH;

typedef struct PERFINFO_WMI_AUDIOGLITCH {
    EVENT_TRACE_HEADER          header;
    PERFINFO_AUDIOGLITCH        data;
} PERFINFO_WMI_AUDIO_GLITCH, *PPERFINFO_WMI_AUDIOGLITCH;



GUID ControlGuid =
{ 0x28cf047a, 0x2437, 0x4b24, 0xb6, 0x53, 0xb9, 0x44, 0x6a, 0x41, 0x9a, 0x69 };

GUID TraceGuid = 
{ 0xe5a43a19, 0x6de0, 0x44f8, 0xb0, 0xd7, 0x77, 0x2d, 0xbd, 0xe4, 0x6c, 0xc0 };

ULONG TraceEnable;
TRACEHANDLE LoggerHandle;
ULONG InstanceCount=0;


NTSTATUS
(*PerfSystemControlDispatch) (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );



VOID
PerfRegisterProvider (
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine registers this component as a WMI event tracing provider.

Arguments:

    DeviceObject - supplies the device object we are registering with WMI

Return Value:

    None.

--*/

{    
    if (InterlockedIncrement (&InstanceCount)==1) {
        IoWMIRegistrationControl (DeviceObject, WMIREG_ACTION_REGISTER);
    } //if
}



VOID
PerfUnregisterProvider (
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine unregisters this component as a WMI event tracing provider.

Arguments:

    DeviceObject - supplies the device object we are uregistering with WMI

Return Value:

    None.

--*/

{
    if (InterlockedDecrement (&InstanceCount)==0) {
        IoWMIRegistrationControl (DeviceObject, WMIREG_ACTION_DEREGISTER);
    } //if
}




NTSTATUS
RegisterWmiGuids (
    IN PWMIREGINFO WmiRegInfo,
    IN ULONG RegInfoSize,
    IN PULONG ReturnSize
    )

/*++

Routine Description:

    This routine registers WMI event tracing streams.

--*/

{
    ULONG SizeNeeded;
    PWMIREGGUIDW WmiRegGuidPtr;
    ULONG status;
    ULONG GuidCount;
    ULONG RegistryPathSize;
    PUCHAR Temp;

    if (WmiRegInfo == NULL ||
        ReturnSize == NULL ) {
        return STATUS_INVALID_PARAMETER;
    }

    GuidCount = 1;

    RegistryPathSize = sizeof (PROC_REG_PATH) - sizeof (WCHAR) + sizeof (USHORT);
    SizeNeeded = sizeof (WMIREGINFOW) + GuidCount * sizeof (WMIREGGUIDW) + RegistryPathSize;

    if (SizeNeeded > RegInfoSize) {
        if ( RegInfoSize >= sizeof(ULONG) ) {
            *((PULONG)WmiRegInfo) = SizeNeeded;
            *ReturnSize = sizeof (ULONG);
            return STATUS_BUFFER_OVERFLOW;
        }
        else {
            *ReturnSize = 0;
            return STATUS_BUFFER_TOO_SMALL;
        }
    }

    RtlZeroMemory (WmiRegInfo, SizeNeeded);
    WmiRegInfo->BufferSize = SizeNeeded;
    WmiRegInfo->GuidCount = GuidCount;

    WmiRegGuidPtr = WmiRegInfo->WmiRegGuid;
    WmiRegGuidPtr->Guid = ControlGuid;
    WmiRegGuidPtr->Flags |= (WMIREG_FLAG_TRACED_GUID | WMIREG_FLAG_TRACE_CONTROL_GUID);

    Temp = (PUCHAR)(WmiRegGuidPtr + 1);
    WmiRegInfo->RegistryPath = PtrToUlong ((PVOID)(Temp - (PUCHAR)WmiRegInfo));
    *((PUSHORT)Temp) = (USHORT)(sizeof (PROC_REG_PATH) - sizeof (WCHAR));

    Temp += sizeof (USHORT);
    RtlCopyMemory (Temp, PROC_REG_PATH, sizeof (PROC_REG_PATH) - sizeof (WCHAR));

    *ReturnSize = SizeNeeded;

    return STATUS_SUCCESS;
}


NTSTATUS
PerfWmiDispatch (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine handles IRP_MJ_SYSTEM_CONTROL calls. It processes
    WMI requests and passes everything else on to KS.

--*/

{
    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation (Irp);
    ULONG ReturnSize=0;
    PWNODE_HEADER Wnode;
    NTSTATUS ntStatus=STATUS_SUCCESS;

    if ((PDEVICE_OBJECT)IrpSp->Parameters.WMI.ProviderId != DeviceObject) {
        return PerfSystemControlDispatch (DeviceObject, Irp);
    }

    switch (IrpSp->MinorFunction) {
    
    case IRP_MN_REGINFO:
        ntStatus = RegisterWmiGuids (IrpSp->Parameters.WMI.Buffer,
                          IrpSp->Parameters.WMI.BufferSize,
                          &ReturnSize);
        break;
    
    case IRP_MN_ENABLE_EVENTS:
        InterlockedExchange (&TraceEnable, 1);
        Wnode = (PWNODE_HEADER)IrpSp->Parameters.WMI.Buffer;
        if (IrpSp->Parameters.WMI.BufferSize >= sizeof (WNODE_HEADER)) {
            LoggerHandle = Wnode->HistoricalContext;
        }
        break;

    case IRP_MN_DISABLE_EVENTS:
        InterlockedExchange (&TraceEnable, 0);
        break;

    case IRP_MN_ENABLE_COLLECTION:
    case IRP_MN_DISABLE_COLLECTION:
        break;

    default:
        return PerfSystemControlDispatch (DeviceObject, Irp);
    }

    Irp->IoStatus.Status = ntStatus;
    Irp->IoStatus.Information = ReturnSize;
    IoCompleteRequest (Irp, IO_NO_INCREMENT);
    return ntStatus;
}


VOID
PerfLogGlitch (
    IN ULONG_PTR InstanceId,
    IN ULONG Type,
    IN LONGLONG CurrentTime,
    IN LONGLONG PreviousTime
    )

/*++

Routine Description:

    This routine logs a WMI event tracing event with an audio glitch GUID
    and the supplied glitch type.

--*/

{
   PERFINFO_WMI_AUDIO_GLITCH Event;

    if (LoggerHandle == (TRACEHANDLE)NULL || TraceEnable == 0) {
        return;
    }

    RtlZeroMemory (&Event, sizeof (Event));
    Event.header.Size = sizeof (Event);
    Event.header.Flags = WNODE_FLAG_TRACED_GUID;
    Event.header.Guid = TraceGuid;
    Event.data.glitchType = Type;
    Event.data.instanceId = InstanceId;
    Event.data.sampleTime = CurrentTime;
    Event.data.previousTime = PreviousTime;

    ((PWNODE_HEADER)&Event)->HistoricalContext = LoggerHandle;

    IoWMIWriteEvent ((PVOID)&Event);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\filters\kmixer\private.h ===
//---------------------------------------------------------------------------
//
//  Module:   private.h
//
//  Description:
//
//
//@@BEGIN_MSINTERNAL
//  Development Team:
//     S.Mohanraj
//
//  History:   Date       Author      Comment
//
//@@END_MSINTERNAL
//---------------------------------------------------------------------------
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1996-2000 Microsoft Corporation.  All Rights Reserved.
//
//---------------------------------------------------------------------------

//
// constants
//

#define SURROUND_ENCODE 1
#define NEW_SURROUND 1
#define INTEGER_DITHER 1
//#define INSERT_STARVATION_NOISE 1
//#define DETECT_HRTF_SATURATION 1
//#define SURROUND_VOLUME_HACK    1
//#define PERF_COUNT 1
//#define LOG_TO_FILE 1
//#define LOG_CAPTURE_ONLY 1
//#define NOISE_SHAPING 1
//#define VERIFY_HRTF_PROCESSING 1
//#define LOG_HRTF_DATA 1
//#define VERIFY_CAPTURE_DATA 1
#ifndef _WIN64
//#define REALTIME_THREAD 1
#endif
//#define LOG_RT_POSITION 1
#define SRC_NSAMPLES_ASSERT   1

#define MAX_BUFFERS_PER_WORK_ITEM   DEFAULT_MAXNUMMIXBUFFERS*3
#define MAX_BUFFERS_BEFORE_MUTING   (DEFAULT_MAXNUMMIXBUFFERS+1)
#define MAX_BUFFERS_BEFORE_UNMUTING DEFAULT_MAXNUMMIXBUFFERS/2

#define FLOAT_SUPERMIX_BLOCKS	1
#define BLOCK_SIZE_OUT	2
#define BLOCK_SIZE_IN	2

#define PRIVATE_THREAD 1

#ifdef DEBUG
#define USE_CAREFUL_ALLOCATIONS     1
#endif

#if (DBG)
#define STR_MODULENAME "kmixer: "
#endif

#define STR_DEVICENAME  TEXT("\\Device\\KMIXER")

#ifdef SURROUND_ENCODE
#define SURSCALE 0.7079457843841f
#endif

#define DITHER_LENGTH   1024


//---------------------------------------------------------------------------
//---------------------------------------------------------------------------

//
// Pin constants
//

#define STOPBAND_FACTOR 320

#define MAXNUM_MAPPING_TABLES   300

#define MAXNUM_PIN_TYPES  4
#define PIN_ID_WAVEIN_SOURCE        2
#define PIN_ID_WAVEIN_SINK          3

// Note that pin IDs reflect the direction of communication 
// (sink or source) and not that of data flow.

#define PIN_ID_WAVEOUT_SOURCE       0
#define PIN_ID_WAVEOUT_SINK         1

#define NODE_INPUT_PIN				1
#define NODE_OUTPUT_PIN				0

//
#define _100NS_UNITS_PER_SECOND     10000000L
//
// Mixer constants
//
#define DEFAULT_MINNUMMIXBUFFERS     3
#define DEFAULT_MAXNUMMIXBUFFERS     8
#define DEFAULT_STARTNUMMIXBUFFERS   3
#define DEFAULT_RTMAXNUMMIXBUFFERS  16

#define DEFAULT_DISABLEMMX           0
#define DEFAULT_MAXOUTPUTBITS        32
#define DEFAULT_MAXDSOUNDINCHANNELS  ((ULONG)(-1))
#define DEFAULT_MAXOUTCHANNELS       ((ULONG)(-1))
#define DEFAULT_MAXINCHANNELS        ((ULONG)(-1))
#define DEFAULT_MAXFLOATCHANNELS     ((ULONG)(-1))

#ifdef LOG_TO_FILE
#define DEFAULT_LOGTOFILE            1
#else
#define DEFAULT_LOGTOFILE            0
#endif

#define DEFAULT_FIXEDSAMPLINGRATE    0

#define DEFAULT_ENABLESHORTHRTF      1
#define DEFAULT_BUILDPARTIALMDLS     1
#define DEFAULT_PREFERREDQUALITY     (KSAUDIO_QUALITY_ADVANCED)

#define MIXTHREADPRIORITY 24

//
// Mix buffer alignment
//
#define MIXBUFFERALIGNMENT 1024

#if MIXBUFFERALIGNMENT&(MIXBUFFERALIGNMENT-1)
#error MIXBUFFERALIGNMENT absolutely MUST be a power of 2 because of how the code uses it to align buffers!
#endif

#if MIXBUFFERALIGNMENT < 64
#error MIXBUFFERALIGNMENT should be 64 or higher.
// Note that it ABSOLUTELY MUST be > than 8 in order to guarantee proper alignment for IA64.
#endif

//
// Kmixer's mix buffer block size in ms
//
#define MIXBUFFERDURATION               (pFilterInstance->MixBufferDuration)
//
// Minimum number of Mix buffers to be used
//
#define MINNUMMIXBUFFERS                (pFilterInstance->MinNumMixBuffers)
//
// Start mixing off with StartNumMixBuffers
//
#define STARTNUMMIXBUFFERS              (pFilterInstance->StartNumMixBuffers)
//
// Upper limit of number of mix buffers
//
#define MAXNUMMIXBUFFERS                (pFilterInstance->MaxNumMixBuffers)

//
// Internal data width at which mixing is done
//
#define MIXBUFFERSAMPLESIZE             4               // 32 bit accumulation
//
// Number of seconds of "good" beahviour before scaling back the number of
// mix buffers (must be non-zero)
//
#define SCALEBACKWATERMARK              90

// Stage constants
#define MAXNUMMIXSTAGES                 6

#define MAXNUMCONVERTFUNCTIONS          64

#define MAXNUMSRCFUNCTIONS              32

#define MAXERRORCOUNT                   200
 
#define NUMIOSFORSCALEBACK              ((SCALEBACKWATERMARK*1000)/MIXBUFFERDURATION)
#define MIN_SAMPLING_RATE   100L
#define MAX_SAMPLING_RATE   200000L

typedef float D3DVALUE, *LPD3DVALUE;          

#define CACHE_MINSIZE	64	// big enough for LOWPASS_SIZE + delay
#define LOWPASS_SIZE	32	// how many samples to average
#define FILTER_SHIFT	5	// log2(LOWPASS_SIZE)

// Note: need to remove 3D filter state code in a future optimization
#define MIXER_REWINDGRANULARITY		128


#define CLIP_MAX              32767
#define CLIP_MIN              -32767
#define RESAMPLING_TOLERANCE  0	   /* 655 = 1% */
#define DS_SCALE_MAX	      65535
#define DS_SCALE_MID	      32768


#define PARTIAL_MDL_SIZE        (32*1024)
#define MAX_PARTIAL_MDL_SIZE    (2*PARTIAL_MDL_SIZE)

#define REGSTR_VAL_DEFAULTSRCQUALITY	    L"DefaultSrcQuality"
#define REGSTR_VAL_DISABLEMMX               L"DisableMmx"
#define REGSTR_VAL_MAXOUTPUTBITS	    L"MaxOutputBits"
#define REGSTR_VAL_MAXDSOUNDINCHANNELS      L"MaxDsoundInChannels"
#define REGSTR_VAL_MAXOUTCHANNELS           L"MaxOutChannels"
#define REGSTR_VAL_MAXINCHANNELS            L"MaxInChannels"
#define REGSTR_VAL_MAXFLOATCHANNELS         L"MaxFloatChannels"
#define REGSTR_VAL_LOGTOFILE                L"LogToFile"
#define REGSTR_VAL_FIXEDSAMPLINGRATE        L"FixedSamplingRate"
#define REGSTR_VAL_MINNUMMIXBUFFERS         L"MinNumMixBuffers"
#define REGSTR_VAL_MAXNUMMIXBUFFERS         L"MaxNumMixBuffers"
#define REGSTR_VAL_STARTNUMMIXBUFFERS       L"StartNumMixBuffers"
#define REGSTR_VAL_ENABLESHORTHRTF          L"EnableShortHrtf"
#define REGSTR_VAL_BUILDPARTIALMDLS         L"BuildPartialMdls"
#ifdef REALTIME_THREAD
#define REGSTR_VAL_REALTIMETHREAD           L"DisableRealTime"
#endif
#define REGSTR_VAL_PRIVATETHREADPRI         L"MixerThreadPriority"

#define REGSTR_PATH_MULTIMEDIA_KMIXER L"\\Registry\\Machine\\Software\\Microsoft\\Multimedia\\WDMAudio\\Kmixer"
	

//---------------------------------------------------------------------------
//---------------------------------------------------------------------------

//
// data structures
//

typedef struct {
    KSDATAFORMAT            DataFormat;
    WAVEFORMATEXTENSIBLE    WaveFormatExt;
} KSDATAFORMAT_WAVEFORMATEXTENSIBLE, *PKSDATAFORMAT_WAVEFORMATEXTENSIBLE;

typedef struct
{
    PVOID		   DeviceHeader ;
} SOFTWARE_INSTANCE, *PSOFTWARE_INSTANCE;

typedef struct 
{
    //
    // This pointer to the dispatch table is used in the common
    // dispatch routines  to route the IRP to the appropriate 
    // handlers.  This structure is referenced by the device driver 
    // with IoGetCurrentIrpStackLocation( pIrp ) -> FsContext 
    //
    PVOID                   ObjectHeader ;

    LIST_ENTRY              NextInstance ;         // List of filter instances
    PFILE_OBJECT            FileObject ;         // FileObject for this instance
    PFILE_OBJECT            pNextFileObject;

    PDEVICE_OBJECT          pNextDevice;
    HANDLE                  hNextFile ;
    ULONG                   ActivePins ;
    ULONG                   PausedPins ;

    LIST_ENTRY              SinkConnectionList;
    LIST_ENTRY              SourceConnectionList ;

    LIST_ENTRY              ActiveSinkList ;
    KSPIN_LOCK              SinkSpinLock ;
    KSPIN_LOCK              AgingDeadSpinLock ;

    LIST_ENTRY              AgingQueue ;         // IRPs age in this queue to die
    LIST_ENTRY              DeadQueue;           // All dead IRPs are here

    ULONG                   MixBufferDuration ;
    ULONG                   MinNumMixBuffers ;
    ULONG                   MaxNumMixBuffers ;
    ULONG                   StartNumMixBuffers ;

    volatile ULONG          NumPendingIos ;      // Number Of Irps still pending
    volatile ULONG          NumBuffersToMix ;
    ULONG                   CurrentNumMixBuffers ;
    ULONG                   NumLowLatencyIos ;

    ULONG                   ContinuousErrorCount ;
    volatile BOOL           ClosingSource ;      // Indicates that the filter source pin is closing
    BOOL                    MixScheduled ;
    BOOL                    DeadScheduled ;      // FreeDeadIrps Scheduled ?

	BOOL                    fNeedOptimizeMix;
    ULONG                   DrmMixedContentId ;  // DRM content ID of output content

    KSTIME                  PresentationTime ;   // Presentation time of next MixBuffer
    KEVENT                  CloseEvent ;         // Event used for Syncing
                                                //  completion of Pending Irps
    WORK_QUEUE_ITEM         MixWorkItem ;
    WORK_QUEUE_ITEM         FreeIrpsWorkItem ;   // WorkItem used to FreeDeadIrps
    KMUTEX                  ControlMutex ;
    KSPIN_LOCK              MixSpinLock ;
    KSPIN_CINSTANCES        LocalPinInstances[MAXNUM_PIN_TYPES] ;
#ifdef SURROUND_ENCODE
	BOOL                    fSurroundEncode;
#endif	
#ifdef REALTIME_THREAD
    HANDLE                  RealTimeThread;
    PRTAUDIOGETPOSITION     pfnRtAudioGetPosition;
    volatile ULONG          fPauseMix;
    ULONG                   MixHoldOffCount;
    ULONG                   OptimizeMixHoldOffCount;
    ULONG                   Startup;
#endif
    PKSWORKER               CriticalWorkerObject;
    PKSWORKER               DelayedWorkerObject;
    KEVENT                  WorkerThreadEvent ;
    BOOL                    WorkerThreadExit ;
    HANDLE                  WorkerThreadHandle ;
    PKTHREAD                WorkerThreadObject ;
    KPRIORITY               WorkerThreadPriority ;
    KTIMER                  WorkerThreadTimer;
    ULONG                   SkipTimerMix;
    BOOL                    WritingTimerMixedBuffer;
    BOOL                    NoGlitch;
#ifdef LOG_TO_FILE
    // File logging support
    BOOLEAN       LoggingStarted;
    LARGE_INTEGER filePos;
    HANDLE        NtFileHandle;
#endif
#ifdef PERF_COUNT
	LARGE_INTEGER			WorkItemQueueTime;
#endif
} FILTER_INSTANCE, *PFILTER_INSTANCE;

typedef struct tagWAVEHDREX
{
    BOOL                fLocked;            // locked by MmProbeAndLockPages()
    PVOID               DataBuffer ;
    PMDL                BufferMdl;
    ULONG               Flags ;
    ULONG               LoopCount ;
} WAVEHDREX, *PWAVEHDREX;

typedef enum {
    LOOPING_STATE_NOT_LOOPING,
    LOOPING_STATE_LOOPING,      
    LOOPING_STATE_LAST_LOOP
} LOOPING_STATE;

typedef struct tagLOOPPACKET
{
    PKSSTREAM_HEADER    pCurStreamHdr;
    PKSSTREAM_HEADER    LoopStartStreamHdr;
    ULONG               cBytesLeft;
    ULONGLONG           cBytesLeftInStreamHdr;
    PMDL                pCurMdl ;
    PMDL                LoopStartMdl;
    PMDL                LockedMdlHead ;
    PMDL                FirstMdl ;
    ULONG               NumLockedMdls ;
    BOOL                JustInTimeLock ;
    PEPROCESS           Process;
    LOOPING_STATE       CurLoopingState;
} LOOPPACKET, *PLOOPPACKET;


// every once in a while we remember the state of our 3D mixer so we can rewind
typedef struct _FIRSTATE
{
    D3DVALUE	LastDryAttenuation;
    D3DVALUE	LastWetAttenuation;
#ifdef SMOOTH_ITD
    int		iLastDelay;
#endif
} FIRSTATE, *PFIRSTATE;



typedef struct _ITDCONTEXT {
    LONG	        *pSampleCache; 		// cache of previous samples
    int		        cSampleCache;		// num samples in the cache
    int		        iCurSample;		    // next sample goes at this offset
    FIRSTATE        *pStateCache;		// remember state once in a while
    int		        cStateCache;		// num entries in cache
    int		        iCurState;		    // where in the state cache we are
    int		        iStateTick;		    // when it's time to remember state
    D3DVALUE	    TotalDryAttenuation;// multiply dry amplitude by this
    D3DVALUE	    LastDryAttenuation;	// what we did last time
    D3DVALUE	    TotalWetAttenuation;// multiply wet amplitude by this
    D3DVALUE	    LastWetAttenuation;	// what we did last time
    D3DVALUE	    VolSmoothScale;		// constant for volume smoothing
    D3DVALUE	    VolSmoothScaleRecip;// its reciprocal
    D3DVALUE	    VolSmoothScaleDry;	// constants to use for volume smoothing
    D3DVALUE	    VolSmoothScaleWet;	// in inner loop
    int		        iSmoothFreq;		// freq used to compute VolSmooth
    
//    BOOL	        fLeft;			    // are we making left or right channel?
    int		        iDelay;			    // want to delay by this many samples
#ifdef SMOOTH_ITD
    int		        iLastDelay;		    // last time we delayed by this much
#endif
} ITDCONTEXT, *PITDCONTEXT;

typedef struct {
    //
    // This pointer to the dispatch table is used in the common
    // dispatch routines  to route the IRP to the appropriate 
    // handlers.  This structure is referenced by the device driver 
    // with IoGetCurrentIrpStackLocation( pIrp ) -> FsContext 
    //

    PVOID		   ObjectHeader ;
    LIST_ENTRY	   NextInstance ;
    PFILE_OBJECT        pFilterFileObject;
    ULONG               PinId;

} MIXER_INSTHDR, *PMIXER_INSTHDR;

typedef ULONG (*PFNStage)(
    PVOID   CurStage,
    ULONG   SampleCount,
    ULONG   samplesleft
);

typedef NTSTATUS (*PFNPegFunc)(
	PLONG          pMixBuffer,
	PVOID           pWriteBuffer,
	ULONG           SampleCount,
	ULONG           nStreams
);

typedef PVOID (*PFNGetBlockFunc)(
    PVOID           pMixerSink,
    ULONG           lCount,
    PULONG          pBlockCount,
    PIRP            *FreeIrp,
    PIRP            *ReleaseIrp
) ;

typedef struct {
	// FIR Filter context
	PFLOAT  pCoeff;                // Buffer of nHistorySize coefficients
	PFLOAT  pHistory;              // Should be large enough to hold nCoefficients samples.
	DWORD   nOutCycle;
	DWORD   nSizeOfHistory;

	// Intermediate conversions
	PFLOAT	pInputBuffer;		// Intermediate conversion buffer

	/* Up/Down-sampling variables */
    ULONG   UpSampleRate;
    ULONG   DownSampleRate;

    // Conversion information
    ULONG   csInputBufferSize;

    ULONG   nChannels;
    ULONG   Quality;
    BOOL   fRequiresFloat;

    // Used for re-ordered coefficient lists
    ULONG   nCoeffUsed;
    ULONG   CoeffIndex;

    BOOL    fStarted;
    ULONG   SampleFrac;
    ULONG	dwFrac;

    FLOAT   Normalizer;

    // Used for de-interleaved history
    ULONG   csHistory;
} MIXER_SRC_INSTANCE, *PMIXER_SRC_INSTANCE;

typedef struct {
    ULONG                   NumBytes ;
    ULONG                   UpSampleRate ;
    ULONG                   DownSampleRate ;
    ULONG                   BytesPerSample ;
} SINKMIX_BLOCK_INFO, *PSINKMIX_BLOCK_INFO ;

typedef struct {
    ULONG                   NumBytes ;
    ULONG                   BytesPerSample ;
} SOURCEMIX_BLOCK_INFO, *PSOURCEMIX_BLOCK_INFO ;

typedef struct {
    PFNStage                pfnStage;      // Pointer to function for this stage
    PVOID                   Context;       // Context for this stage
    PVOID                   pInputBuffer;  // Input buffer
    PVOID                   pOutputBuffer; // Output buffer
    LONG                    Index;         // Index into function array for this stage
    PFNStage                *FunctionArray;
    ULONG                   nOutputChannels;
    ULONG                   nInputChannels;
#ifdef PERF_COUNT
	DWORD					AverageTicks;	// Average ticks to perform this stage
#endif
} MIXER_OPERATION, *PMIXER_OPERATION;

typedef struct {
    MIXER_INSTHDR           Header ;
    PFILTER_INSTANCE        pFilterInstance ;
    struct _MIXER_SINK_INSTANCE *pMixerSink ;
    KSPIN_LOCK              EventLock ;
    LIST_ENTRY              EventQueue ;
    ULONGLONG               PhysicalTime ;
    PFILE_OBJECT            pFileObject ;
} CLOCK_INSTANCE, *PCLOCK_INSTANCE ;

typedef struct _MIXER_SINK_INFO {
    // SRC Context
    MIXER_SRC_INSTANCE      Src;

    // Doppler SRC Context
    MIXER_SRC_INSTANCE      Doppler;

    // Stages
    MIXER_OPERATION         Stage[MAXNUMMIXSTAGES];
    ULONG                   nStages;

    // Block Info
	SINKMIX_BLOCK_INFO      *BlockInfo ;

	BOOL                    fVolChanged;
	BOOL                    fSrcChanged;

	ULONG                   IntermediateSamplingRate;
} MIXER_SINK_INFO, *PMIXER_SINK_INFO;

// The following structure is currently only used by the MMX-optimized version of supermix
// 
// The normal structure of supermix sequences looks like this (for M output channels):
//      first sequence (always output channels 0-3)
//      sequence (always output channels 4-7)
//      ...
//      last sequence (always output channels trunc(M/4)*4 - trunc(M/4)*4+3)
//
// Each normal supermix block sequence looks like this:
//      first block
//      block 
//      block 
//      ... 
//      block 
//      last block 
//      end-of-sequence
// 
// Each End-Of-Sequence structure is filled out like:
//      InputChannel    input sample offset for LAST block in sequence
//      OutputChannel   not used
//      SequenceSize    not used
//      Reserved2       not used
//      wMixLevel[4][2] not used
typedef struct {
    LONG    InputChannel;       // Starting input channel number for previous block
    LONG    OutputChannel;      // Starting output channel number for this block
    LONG    SequenceSize;       // Total size of this MAC block sequence
    LONG    Reserved2;          // Used to make this 32 bytes long
    union {
        WORD    wMixLevel[4][2];    // wMixLevel[M][N] = multiplier for N+InputChannel into M+OutputChannel
#ifdef FLOAT_SUPERMIX_BLOCKS        
        FLOAT	MixLevel[BLOCK_SIZE_OUT][BLOCK_SIZE_IN];	// MixLevel[M][N] = N+InputChannel into M+OutputChannel
#else        
        LONG	MixLevel[BLOCK_SIZE_OUT][BLOCK_SIZE_IN];	// MixLevel[M][N] = N+InputChannel into M+OutputChannel
#endif        
    };
} SUPERMIX_BLOCK, *PSUPERMIX_BLOCK ;

typedef struct {
	ULONG	InChannels;
	ULONG	OutChannels;
	ULONG	BitsPerSample;
	BOOL	fEnableSrc;
	BOOL	fEnableFloat;
	BOOL	fEnableSuperMix;
	BOOL	fFloatInput;
	BOOL	fEnableHiRes;
	BOOL	fChannelConversion;
	BOOL	fEnableDoppler;
} OPTIMIZER_FLAGS, *POPTIMIZER_FLAGS ;

typedef struct _MIXER_SINK_INSTANCE {
    MIXER_INSTHDR           Header;
    PFNGetBlockFunc         pfnGetBlock;
    ULONG		            InterfaceId;
    ULONG                   csNextSampleOffset ;
    LIST_ENTRY              WriteQueue;
    PIRP                    LoopIrp ;
    KSPIN_LOCK              WriteSpinLock ;
    LIST_ENTRY              CancelQueue ;
    KSPIN_LOCK              CancelSpinLock ;
    KSSTATE                 SinkState ;
    ULONG                   SinkStatus ;
    ULONG                   LoopCount ;
    KSTIME                  CurTime ;
    KSTIME                  TimeBase ;             // Time When this sink started running
    BOOL                    UpdateTimeBase ;
    ULONGLONG               WriteOffset ;

    union {
        WAVEFORMATEX            WaveFormatEx ;
        WAVEFORMATEXTENSIBLE    WaveFormatExt ;
    };

    // DRM
    ULONG                   DrmContentId;

    // ITD 3D Context
    PITDCONTEXT             pItdContextLeft;
    PITDCONTEXT             pItdContextRight;
    PKSDS3D_ITD_PARAMS      pNewItd3dParamsLeft;
    PKSDS3D_ITD_PARAMS      pNewItd3dParamsRight;

    // HRTF 3D Context
    PFLOAT_LOCALIZER        pFloatLocalizer;
    PSHORT_LOCALIZER        pShortLocalizer;
    PKSDS3D_HRTF_PARAMS_MSG  pNewIir3dParams;
    KSDS3D_HRTF_COEFF_FORMAT CoeffFormat;
    KSDS3D_HRTF_FILTER_METHOD FilterMethod;

    BOOL                    fUseIir3d;

    BOOL                    fEnableDsound;
    BOOL                    fCreate3D;
    BOOL                    fEnable3D;
    BOOL                    f3dParamsChanged;
    BOOL                    fSetCurrentPosition;
    ULONG                   BufferLength;
    KSPIN_LOCK              EventLock ;
    LIST_ENTRY              EventQueue ;

    BOOL                    fResetState;

	// Volume levels for this sink
	PFLOAT	                pMixLevelArray;			// Mix Level values
	PLONG	                pMixLevelModel;			// Model for upmixing/downmixing scenario
	PLONG	                pChannelVolumeLevel;	// Per-channel volume level array
	PLONG                   pPanVolumeLevel;
	LONG	                MasterVolumeLevel;		// Master volume level for this sink

    LONG                    nOutputChannels;
    PLONG                   pMappingTable;
    PLONG                   pVolumeTable;

    PMIXER_SRC_INSTANCE     pActualSrc;

    ULONG                   BytesPerSample ;
    ULONG                   BlockInfoIndex ;
    BOOL                    fMuted;
    ULONG                   OriginalSampleRate;

    LIST_ENTRY              ActiveQueue;
    ULONG                   BuffersTillInactive;
    PCLOCK_INSTANCE         pClock ;

#ifdef SURROUND_ENCODE
    SHORT   SurHistory[4];
    FLOAT   CenterVolume;
    FLOAT   SurroundVolume;
#endif
    PMIXER_SINK_INFO        pInfo;
    PSUPERMIX_BLOCK         pSuperMixBlock;
    BOOL                    fFloatFormat;
    ULONG                   BytesSubmitted;
    BOOL					fTooMuchCpu;
    BOOL                    fStarvationDetected;
    LONGLONG                LastStateChangeTimeSample;
} MIXER_SINK_INSTANCE, *PMIXER_SINK_INSTANCE;

typedef struct {
    PMDL                    MdlAddress;
    PUCHAR                  SystemAddress;
} MDL_INFO, *PMDL_INFO;


#define MIXER_SINK_STATUS_DATA_PRESENT  0x00000001
#define MIXER_SINK_STATUS_IN_LOOP       0x00000002
#define MIXER_SINK_STATUS_ADVANCE_IRP   0x00000004
#define MIXER_SINK_STATUS_LOCK_ERROR    0x00000008

#define WRITE_CONTEXT_FREE              0
#define WRITE_CONTEXT_INUSE             1
#define WRITE_CONTEXT_UNAVAILABLE       2
#define WRITE_CONTEXT_FULL              3
#ifdef REALTIME_THREAD
#define WRITE_CONTEXT_QUEUED            4
#define WRITE_CONTEXT_MIXED             5
#endif


typedef struct {
   PFILTER_INSTANCE    pFilterInstance ;
   PKSSTREAM_HEADER    StreamHeader ;
   PMDL                pMdl ;
   PIRP                pIrp ;
   ULONG               InUse ;         // 0 if available for mixing
                                       // 1 if in use by mix
                                       // 2 if if not available for mixing
   BOOL                fReading;
} MIXER_WRITE_CONTEXT, *PMIXER_WRITE_CONTEXT ;

typedef struct {
    MIXER_INSTHDR           Header;
    KDPC                    IntervalDpc;
    LIST_ENTRY              WriteQueue;
    PFILE_OBJECT	        FileObject ;
    ULONG                   csMixBufferSize ;
    ULONG                   cbMixBufferSize ;
    ULONG                   cmsMixBufferSize ;
    PLONG                   pMixBuffer ;
    MIXER_WRITE_CONTEXT     *WriteContext ;
    union {
        WAVEFORMATEX            WaveFormatEx ;
        WAVEFORMATEXTENSIBLE    WaveFormatExt ;
    };
    ULONG                   LeftOverFraction ;
	LONG					MasterVolumeLevel;
    ULONG                   PlayCursorPosition;
    ULONG                   nSinkPins;
	PVOID                   pScratchBuffer;
	PVOID                   pScratch2;
	ULONG                   MaxChannels;
	BOOL                    fZeroBufferFirst;
	BOOL                    fUsesFloat;
	ULONG                   BytesPerSample ;
	ULONG                   BlockInfoIndex ;
	SOURCEMIX_BLOCK_INFO    *BlockInfo ;
	ULONGLONG               BytesSubmitted ;                   
	ULONG               MaxSampleRate;
	BOOL                fNewMaxRate;
	PVOID                   pSrcBuffer[4][STOPBAND_FACTOR]; // 4 possible qualities
	ULONG                   SrcCount[4][STOPBAND_FACTOR];
    PMIXER_SINK_INSTANCE    pLastSink[4][STOPBAND_FACTOR];
    ULONG                   TempCount[4][STOPBAND_FACTOR];
#ifdef NEW_SURROUND
    BOOL                    fSurround;
    LONG    SurHistory[4];
#endif    
    PFLOAT                  pFloatMixBuffer;
    MIXER_SINK_INFO         Info;
    BOOL                    fFloatFormat;
    ULONG                   OriginalSampleRate;
#ifdef REALTIME_THREAD
	ULONG                   RtMixIndex;
	ULONG                   RtWriteIndex;
#endif
    ULONG                   NextBufferIndex;
} MIXER_SOURCE_INSTANCE, *PMIXER_SOURCE_INSTANCE;

typedef enum {
    PositionEvent,
    EndOfStreamEvent
} MXEVENT_TYPE ;

typedef struct {
    KSEVENT_ENTRY   EventEntry ;
    MXEVENT_TYPE    EventType ;
    ULONGLONG       Position ;
#ifdef REALTIME_THREAD    
    BOOL            fRtTrigger;
#endif    
} POSITION_EVENT_ENTRY, *PPOSITION_EVENT_ENTRY ;

typedef struct {
    KSEVENT_ENTRY   EventEntry ;
    MXEVENT_TYPE    EventType ;
    ULONGLONG       Reserved ;
} ENDOFSTREAM_EVENT_ENTRY, *PENDOFSTREAM_EVENT_ENTRY ;

typedef struct {
    ULONG           MaxNumMixBuffers ;
    ULONG           MinNumMixBuffers ;
    ULONG           MixBufferDuration ;
    ULONG           StartNumMixBuffers ;
    ULONG           PreferredQuality ;
    ULONG           DisableMmx ;
    ULONG           MaxOutputBits ;
    ULONG           MaxDsoundInChannels ;
    ULONG           MaxOutChannels ;
    ULONG           MaxInChannels ;
    ULONG           MaxFloatChannels ;
    ULONG           LogToFile ;
    ULONG           FixedSamplingRate ;
    ULONG           EnableShortHrtf ;
    ULONG           BuildPartialMdls ;
    ULONG           WorkerThreadPriority ;
} TUNABLEPARAMS, *PTUNABLEPARAMS ;

typedef struct {
    ULONG           NumMixBuffersAdded ;
    ULONG           NumCompletionsWhileStarved ;
    ULONG           NumSilenceSamplesInserted ;
} PERFSTATS, *PPERFSTATS;

#define NEEDPEG16(x)            (HIWORD(x + 32768))
#define NEEDPEG8(x)             (HIBYTE(x))
#define PEG(min,x,max)  {if(x<min) x=min; else if (x>max) x=max;}
#define PEG8(x)         PEG((int) 0, x, (int) 255)
#define PEG16(x)                PEG((long) -32768, x, (long) 32767) 


extern KSPIN_DESCRIPTOR PinDescs[ MAXNUM_PIN_TYPES ];
extern const KSPIN_CINSTANCES gPinInstances[ MAXNUM_PIN_TYPES ];

#define MxResetIrp(pIrp)    {\
            pIrp->Cancel = FALSE ;\
            pIrp->CancelRoutine = NULL;\
            pIrp->PendingReturned = FALSE ;\
            pIrp->IoStatus.Status = STATUS_SUCCESS;\
            pIrp->IoStatus.Information = 0;\
	    }

//---------------------------------------------------------------------------
//---------------------------------------------------------------------------

//
// global data
//

// device.c:

#ifndef KM_KDEXT
KSDISPATCH_TABLE FilterDispatchTable;
KSDISPATCH_TABLE PinDispatchTable;
#endif // KM_KDEXT

//
// local prototypes
//


KAFFINITY
KeQueryActiveProcessors (
    VOID
    );


//---------------------------------------------------------------------------
// filter.c

NTSTATUS FilterDispatchIoControl
(
   IN PDEVICE_OBJECT pdo,
   IN PIRP           pIrp
);

NTSTATUS BuildPartialMdls
(
    PFILTER_INSTANCE            pFilterInstance,
    PMIXER_SINK_INSTANCE        pMixerSink,
    IN PIRP                     pIrp,
    IN OUT PLOOPPACKET          pLoopPacket
);

VOID AttachLockedMdlsToIrp
(
    PLOOPPACKET pLoopPacket,
    PIRP        pIrp
);

NTSTATUS FilterDispatchClose
(
   IN PDEVICE_OBJECT pdo,
   IN PIRP           pIrp
);

NTSTATUS FilterDispatchGlobalCreate
(
   IN PDEVICE_OBJECT pdo,
   IN PIRP           pIrp
);

NTSTATUS PinInstances
(
    IN PIRP                 pIrp,
    IN PKSP_PIN             pPin,
    OUT PKSPIN_CINSTANCES   pCInstances
);

NTSTATUS PinPropertyHandler
(
    IN PIRP         pIrp,
    IN PKSPROPERTY  pProperty,
    IN OUT PVOID    pvData
);

NTSTATUS
QueryRegistryValueEx(
    ULONG Hive,
    PWSTR pwstrRegistryPath,
    PWSTR pwstrRegistryValue,
    ULONG uValueType,
    PVOID *ppValue,
    PVOID pDefaultData,
    ULONG DefaultDataLength
) ;

NTSTATUS
MxGetTunableParams
(
    PIRP    pIrp,
    PKSPROPERTY pKsProperty,
    PTUNABLEPARAMS pTunableParams
) ;

NTSTATUS
MxSetTunableParams
(
    PIRP    pIrp,
    PKSPROPERTY pKsProperty,
    PTUNABLEPARAMS pTunableParams
) ;

NTSTATUS
MxGetPerfStats
(
    PIRP    pIrp,
    PKSPROPERTY pKsProperty,
    PPERFSTATS pPerfStats
) ;

//---------------------------------------------------------------------------
// device.c

NTSTATUS DispatchInvalidDeviceRequest
(
    IN PDEVICE_OBJECT   pDeviceObject,
    IN PIRP             pIrp
);

NTSTATUS AddDevice
(
    IN PDRIVER_OBJECT   DriverObject,
    IN PDEVICE_OBJECT   PhysicalDeviceObject
) ;

//---------------------------------------------------------------------------
// pins.c:

NTSTATUS PinDispatchCreate
(
   IN PDEVICE_OBJECT pdo,
   IN PIRP           pIrp
);

NTSTATUS ChangeSrc
(
    PFILTER_INSTANCE pFilterInstance,
    PMIXER_SINK_INSTANCE CurSink,
    PMIXER_SOURCE_INSTANCE pMixerSource,
    ULONG Quality
);

NTSTATUS CreateSourcePin
(
    PIRP				pIrp,
    PKSPIN_CONNECT      pConnect,
    PFILE_OBJECT        pFileObject,
    PFILTER_INSTANCE    pFilterInstance,
    PKSDATAFORMAT       pAudioFormat
);

NTSTATUS CreateSinkPin
(
    PIRP				pIrp,
    PKSPIN_CONNECT      pConnect,
    PFILE_OBJECT        pFileObject,
    PFILTER_INSTANCE    pFilterInstance,
    PKSDATAFORMAT       pAudioFormat
);

NTSTATUS VerifyWaveFormatEx
(
    PWAVEFORMATEX pWaveFormatEx
);

NTSTATUS PinDispatchClose
(
   IN PDEVICE_OBJECT pdo,
   IN PIRP           pIrp
);

NTSTATUS PinDispatchRead
(
   IN PDEVICE_OBJECT pdo,
   IN PIRP           pIrp
);

NTSTATUS PinDispatchWrite
(
   IN PDEVICE_OBJECT pdo,
   IN PIRP           pIrp
);

NTSTATUS PinDispatchIoControl
(
   IN PDEVICE_OBJECT pdo,
   IN PIRP           pIrp
);

VOID AddIrpToSinkQueue
(
    PMIXER_SINK_INSTANCE pMixerSink,
    PIRP                 pIrp,
    PVOID	    Arg3,
    ULONG		    Arg4,
    PDRIVER_CANCEL  CancelRoutine
) ;
 
NTSTATUS MxBreakLoop
(
    IN PIRP         pIrp,
    IN PKSMETHOD    pMethod,
    IN OUT PVOID    pvData
);

NTSTATUS MxControlCancelIo
(
    IN PIRP         pIrp,
    IN PKSMETHOD    pMethod,
    IN OUT PVOID    pvData
);

VOID
MxCancelIrp
(
    PDEVICE_OBJECT DeviceObject,
    PIRP           Irp
);

PDRIVER_CANCEL MxCancelWrite
(
	IN PDEVICE_OBJECT pdo,
	IN PIRP         pIrp
);

ULONG
GetUlongFromRegistry(
    PWSTR pwstrRegistryPath,
    PWSTR pwstrRegistryValue,
    ULONG DefaultValue
);

VOID
GetMixerSettingsFromRegistry
(
    VOID
);

PIRP CompleteIrpsTill
(
PMIXER_SINK_INSTANCE pMixerSink,
PIRP pIrp
) ;

VOID MxCompleteRequest
(
PIRP    pIrp
) ;

VOID MxCleanupRequest
(
PIRP    pIrp
) ;

VOID FreeMdlList
(
    PMDL    pMdl
);

VOID MxUnlockMdl
(
    PMDL    pMdl
);

PMDL GetNextLoopMdl
(
    PLOOPPACKET pLoopPacket,
    PMDL        pMdl
);

ULONG
SrcInputBufferSize(
    PMIXER_SRC_INSTANCE pSrc,
    ULONG csOutputSize
);

#ifdef _X86_
DWORD MmxSrcMix_Filtered(PMIXER_OPERATION CurStage, ULONG nSamples, ULONG nOutputSamples);
DWORD MmxSrcMix_StereoLinear(PMIXER_OPERATION CurStage, ULONG nSamples, ULONG nOutputSamples);
DWORD MmxSrc_Filtered(PMIXER_OPERATION CurStage, ULONG nSamples, ULONG nOutputSamples);
DWORD MmxSrc_StereoLinear(PMIXER_OPERATION CurStage, ULONG nSamples, ULONG nOutputSamples);
#endif
DWORD SrcMix_Worst(PMIXER_OPERATION CurStage, ULONG nSamples, ULONG nOutputSamples);
DWORD SrcMix_Linear(PMIXER_OPERATION CurStage, ULONG nSamples, ULONG nOutputSamples);
DWORD SrcMix_Basic(PMIXER_OPERATION CurStage, ULONG nSamples, ULONG nOutputSamples);
DWORD SrcMix_Advanced(PMIXER_OPERATION CurStage, ULONG nSamples, ULONG nOutputSamples);
DWORD SrcMix_StereoUpNoFilter(PMIXER_OPERATION CurStage, ULONG nSamples, ULONG nOutputSamples);
DWORD SrcMix_StereoLinear(PMIXER_OPERATION CurStage, ULONG nSamples, ULONG nOutputSamples);
DWORD SrcMix_StereoUpBasic(PMIXER_OPERATION CurStage, ULONG nSamples, ULONG nOutputSamples);
DWORD SrcMix_StereoUpAdvanced(PMIXER_OPERATION CurStage, ULONG nSamples, ULONG nOutputSamples);

DWORD Src_Worst(PMIXER_OPERATION CurStage, ULONG nSamples, ULONG nOutputSamples);
DWORD Src_Linear(PMIXER_OPERATION CurStage, ULONG nSamples, ULONG nOutputSamples);
DWORD Src_Basic(PMIXER_OPERATION CurStage, ULONG nSamples, ULONG nOutputSamples);
DWORD Src_Advanced(PMIXER_OPERATION CurStage, ULONG nSamples, ULONG nOutputSamples);
DWORD Src_StereoUpNoFilter(PMIXER_OPERATION CurStage, ULONG nSamples, ULONG nOutputSamples);
DWORD Src_StereoLinear(PMIXER_OPERATION CurStage, ULONG nSamples, ULONG nOutputSamples);
DWORD Src_StereoUpLow(PMIXER_OPERATION CurStage, ULONG nSamples, ULONG nOutputSamples);
DWORD Src_StereoUpBasic(PMIXER_OPERATION CurStage, ULONG nSamples, ULONG nOutputSamples);
DWORD Src_StereoUpAdvanced(PMIXER_OPERATION CurStage, ULONG nSamples, ULONG nOutputSamples);

ULONG SuperMix(PMIXER_OPERATION CurStage, ULONG SampleCount, ULONG samplesleft);
ULONG SuperCopy(PMIXER_OPERATION CurStage, ULONG SampleCount, ULONG samplesleft);
ULONG SuperMixFloat(PMIXER_OPERATION CurStage, ULONG SampleCount, ULONG samplesleft);
ULONG SuperCopyFloat(PMIXER_OPERATION CurStage, ULONG SampleCount, ULONG samplesleft);

ULONG QuickMix16(PMIXER_OPERATION CurStage, ULONG SampleCount, ULONG samplesleft);
ULONG QuickMixStereo16(PMIXER_OPERATION CurStage, ULONG SampleCount, ULONG samplesleft);
ULONG QuickMixMonoToStereo16(PMIXER_OPERATION CurStage, ULONG SampleCount, ULONG samplesleft);
ULONG QuickMixStereoToMono16(PMIXER_OPERATION CurStage, ULONG SampleCount, ULONG samplesleft);

ULONG QuickMix8(PMIXER_OPERATION CurStage, ULONG SampleCount, ULONG samplesleft);
ULONG QuickMixStereo8(PMIXER_OPERATION CurStage, ULONG SampleCount, ULONG samplesleft);
ULONG QuickMixMonoToStereo8(PMIXER_OPERATION CurStage, ULONG SampleCount, ULONG samplesleft);
ULONG QuickMixStereoToMono8(PMIXER_OPERATION CurStage, ULONG SampleCount, ULONG samplesleft);

ULONG Convert16(PMIXER_OPERATION CurStage, ULONG SampleCount, ULONG samplesleft);
ULONG ConvertStereo16(PMIXER_OPERATION CurStage, ULONG SampleCount, ULONG samplesleft);
ULONG ConvertMonoToStereo16(PMIXER_OPERATION CurStage, ULONG SampleCount, ULONG samplesleft);
ULONG ConvertStereoToMono16(PMIXER_OPERATION CurStage, ULONG SampleCount, ULONG samplesleft);

ULONG Convert8(PMIXER_OPERATION CurStage, ULONG SampleCount, ULONG samplesleft);
ULONG ConvertMonoToStereo8(PMIXER_OPERATION CurStage, ULONG SampleCount, ULONG samplesleft);
ULONG ConvertStereoToMono8(PMIXER_OPERATION CurStage, ULONG SampleCount, ULONG samplesleft);

ULONG QuickMix16toFloat(PMIXER_OPERATION CurStage, ULONG SampleCount, ULONG samplesleft);
ULONG QuickMixStereo16toFloat(PMIXER_OPERATION CurStage, ULONG SampleCount, ULONG samplesleft);
ULONG QuickMixMonoToStereo16toFloat(PMIXER_OPERATION CurStage, ULONG SampleCount, ULONG samplesleft);
ULONG QuickMixStereoToMono16toFloat(PMIXER_OPERATION CurStage, ULONG SampleCount, ULONG samplesleft);

ULONG QuickMix8toFloat(PMIXER_OPERATION CurStage, ULONG SampleCount, ULONG samplesleft);
ULONG QuickMixStereo8toFloat(PMIXER_OPERATION CurStage, ULONG SampleCount, ULONG samplesleft);
ULONG QuickMixMonoToStereo8toFloat(PMIXER_OPERATION CurStage, ULONG SampleCount, ULONG samplesleft);
ULONG QuickMixStereoToMono8toFloat(PMIXER_OPERATION CurStage, ULONG SampleCount, ULONG samplesleft);

ULONG Convert16toFloat(PMIXER_OPERATION CurStage, ULONG SampleCount, ULONG samplesleft);
ULONG ConvertStereo16toFloat(PMIXER_OPERATION CurStage, ULONG SampleCount, ULONG samplesleft);
ULONG ConvertMonoToStereo16toFloat(PMIXER_OPERATION CurStage, ULONG SampleCount, ULONG samplesleft);
ULONG ConvertStereoToMono16toFloat(PMIXER_OPERATION CurStage, ULONG SampleCount, ULONG samplesleft);

ULONG Convert8toFloat(PMIXER_OPERATION CurStage, ULONG SampleCount, ULONG samplesleft);
ULONG ConvertMonoToStereo8toFloat(PMIXER_OPERATION CurStage, ULONG SampleCount, ULONG samplesleft);
ULONG ConvertStereoToMono8toFloat(PMIXER_OPERATION CurStage, ULONG SampleCount, ULONG samplesleft);

ULONG ConvertFloat32(PMIXER_OPERATION CurStage, ULONG SampleCount, ULONG samplesleft);
ULONG QuickMixFloat32(PMIXER_OPERATION CurStage, ULONG SampleCount, ULONG samplesleft);
ULONG ConvertFloat32toFloat(PMIXER_OPERATION CurStage, ULONG SampleCount, ULONG samplesleft);
ULONG QuickMixFloat32toFloat(PMIXER_OPERATION CurStage, ULONG SampleCount, ULONG samplesleft);

ULONG Convert24(PMIXER_OPERATION CurStage, ULONG SampleCount, ULONG samplesleft);
ULONG QuickMix24(PMIXER_OPERATION CurStage, ULONG SampleCount, ULONG samplesleft);
ULONG Convert24toFloat(PMIXER_OPERATION CurStage, ULONG SampleCount, ULONG samplesleft);
ULONG QuickMix24toFloat(PMIXER_OPERATION CurStage, ULONG SampleCount, ULONG samplesleft);
ULONG Convert32(PMIXER_OPERATION CurStage, ULONG SampleCount, ULONG samplesleft);
ULONG QuickMix32(PMIXER_OPERATION CurStage, ULONG SampleCount, ULONG samplesleft);
ULONG Convert32toFloat(PMIXER_OPERATION CurStage, ULONG SampleCount, ULONG samplesleft);
ULONG QuickMix32toFloat(PMIXER_OPERATION CurStage, ULONG SampleCount, ULONG samplesleft);

#ifdef _X86_
BOOL IsMmxPresent(VOID);

BOOL __inline
MmxPresent(VOID)
{
	extern int gfMmxPresent;

	return (gfMmxPresent);
}
#endif

ULONG MmxConvert8(PMIXER_OPERATION CurStage, ULONG SampleCount, ULONG samplesleft);
ULONG MmxQuickMix8(PMIXER_OPERATION CurStage, ULONG SampleCount, ULONG samplesleft);
ULONG MmxConvert16(PMIXER_OPERATION CurStage, ULONG SampleCount, ULONG samplesleft);
ULONG MmxQuickMix16(PMIXER_OPERATION CurStage, ULONG SampleCount, ULONG samplesleft);
ULONG MmxConvertMonoToStereo8(PMIXER_OPERATION CurStage, ULONG SampleCount, ULONG samplesleft);
ULONG MmxQuickMixMonoToStereo8(PMIXER_OPERATION CurStage, ULONG SampleCount, ULONG samplesleft);
ULONG MmxConvertMonoToStereo16(PMIXER_OPERATION CurStage, ULONG SampleCount, ULONG samplesleft);
ULONG MmxQuickMixMonoToStereo16(PMIXER_OPERATION CurStage, ULONG SampleCount, ULONG samplesleft);
ULONG MmxConvertStereo8(PMIXER_OPERATION CurStage, ULONG SampleCount, ULONG samplesleft);
ULONG MmxQuickMixStereo8(PMIXER_OPERATION CurStage, ULONG SampleCount, ULONG samplesleft);
ULONG MmxConvertStereo16(PMIXER_OPERATION CurStage, ULONG SampleCount, ULONG samplesleft);
ULONG MmxQuickMixStereo16(PMIXER_OPERATION CurStage, ULONG SampleCount, ULONG samplesleft);
ULONG MmxConvertStereoToMono8(PMIXER_OPERATION CurStage, ULONG SampleCount, ULONG samplesleft);
ULONG MmxQuickMixStereoToMono8(PMIXER_OPERATION CurStage, ULONG SampleCount, ULONG samplesleft);
ULONG MmxConvertStereoToMono16(PMIXER_OPERATION CurStage, ULONG SampleCount, ULONG samplesleft);
ULONG MmxQuickMixStereoToMono16(PMIXER_OPERATION CurStage, ULONG SampleCount, ULONG samplesleft);

VOID MixFloatToInt32( PFLOAT  pFloatBuffer, PLONG   pLongBuffer, ULONG   nSize);
VOID CopyFloatToInt32( PFLOAT  pFloatBuffer, PLONG   pLongBuffer, ULONG   nSize);

NTSTATUS Peg32to16
(
	PLONG          pMixBuffer,
	PSHORT         pWriteBuffer,
	ULONG           SampleCount,
	ULONG           nStreams
) ;

NTSTATUS Peg32to8
(
	PLONG          pMixBuffer,
	PBYTE           pWriteBuffer,
	ULONG           SampleCount,
	ULONG           nStreams
) ;

NTSTATUS MmxPeg32to16
(
	PLONG          pMixBuffer,
	PSHORT         pWriteBuffer,
	ULONG           SampleCount,
	ULONG           nStreams
) ;

NTSTATUS MmxPeg32to8
(
	PLONG          pMixBuffer,
	PBYTE           pWriteBuffer,
	ULONG           SampleCount,
	ULONG           nStreams
) ;

ULONG UpdateNumMixBuffers
(
    PFILTER_INSTANCE pFilterInstance
) ;

NTSTATUS MxWriteComplete
(
	PDEVICE_OBJECT  pdo,
	PIRP                    pIrp,
	PMIXER_WRITE_CONTEXT pWriteContext
) ;

VOID UpdateJustInTimeLocks
(
    PFILTER_INSTANCE    pFilterInstance
);

NTSTATUS MxPrivateWorkerThread
(
    PFILTER_INSTANCE pFilterInstance
) ;

NTSTATUS MxWorker
(
    PMIXER_WRITE_CONTEXT pWriteContext,
    BOOL TimerMix
) ;

NTSTATUS MxBeginMixing
(
	PFILTER_INSTANCE pFilterInstance
) ;

NTSTATUS MxEndMixing
(
	PFILTER_INSTANCE pFilterInstance
) ;

NTSTATUS WriteBuffer
(
	PMIXER_WRITE_CONTEXT    pWriteContext
) ;

VOID InitStreamPacket
(
	PMIXER_WRITE_CONTEXT    pWriteContext
) ;

PVOID WvGetNextBlock
(
	PMIXER_SINK_INSTANCE    pMixerSink,
	ULONG                   lCount,
	PULONG                  pBlockCount,
	PIRP                    *FreeIrp,
    PIRP                    *ReleaseIrp
) ;

PVOID StGetNextBlock
(
	PMIXER_SINK_INSTANCE    pMixerSink,
	ULONG                   lCount,
	PULONG                  pBlockCount,
	PIRP                    *FreeIrp,
    PIRP                    *ReleaseIrp
) ;

PVOID LoopStGetNextBlock
(
	PMIXER_SINK_INSTANCE    pMixerSink,
	ULONG                   lCount,
	PULONG                  pBlockCount,
	PIRP                    *FreeIrp,
    PIRP                    *ReleaseIrp
) ;

VOID MixOneBuff
(
PFILTER_INSTANCE pFilterInstance,
PVOID Buf
) ;

VOID KMixerRef
(
VOID
) ;

NTSTATUS MxSetFormat
(
   IN PIRP                    pIrp,
   IN PKSPROPERTY               pProperty,
   IN OUT PKSDATAFORMAT       pAudioFormat
);

NTSTATUS MxGetWavePosition
(
   IN PIRP                    pIrp,
   IN PKSPROPERTY             pProperty,
   IN OUT PVOID               pvData
);

NTSTATUS MxSetWavePosition
(
   IN PIRP                    pIrp,
   IN PKSPROPERTY             pProperty,
   IN OUT PVOID               pvData
);

NTSTATUS MxGetVolumeLevel
(
   IN PIRP                          pIrp,
   IN PKSNODEPROPERTY_AUDIO_CHANNEL pNodeProperty,
   IN OUT PVOID                     pvData
);

NTSTATUS MxSetVolumeLevel
(
   IN PIRP                          pIrp,
   IN PKSNODEPROPERTY_AUDIO_CHANNEL pNodeProperty,
   IN OUT PVOID                     pvData
);

NTSTATUS MxGetSamplingRate
(
   IN PIRP                    pIrp,
   IN PKSNODEPROPERTY         pNodeProperty,
   IN OUT PVOID               pvData
);

NTSTATUS MxSetSamplingRate
(
   IN PIRP                    pIrp,
   IN PKSNODEPROPERTY         pNodeProperty,
   IN OUT PVOID               pvData
);

NTSTATUS MxGetSurroundEncode
(
   IN PIRP                    pIrp,
   IN PKSNODEPROPERTY         pNodeProperty,
   IN OUT PVOID               pvData
);

NTSTATUS MxSetSurroundEncode
(
   IN PIRP                    pIrp,
   IN PKSNODEPROPERTY         pNodeProperty,
   IN OUT PVOID               pvData
);

NTSTATUS MxGetAudioQuality
(
   IN PIRP                    pIrp,
   IN PKSNODEPROPERTY         pNodeProperty,
   IN OUT PVOID               pvData
);

NTSTATUS MxSetAudioQuality
(
   IN PIRP                    pIrp,
   IN PKSNODEPROPERTY         pNodeProperty,
   IN OUT PVOID               pvData
);

NTSTATUS MxGetCurrentPosition
(
   IN PIRP                    pIrp,
   IN PKSPROPERTY             pProperty,
   IN OUT PVOID               pvData
);

NTSTATUS MxSetCurrentPosition
(
   IN PIRP                    pIrp,
   IN PKSPROPERTY             pProperty,
   IN OUT PVOID               pvData
);

NTSTATUS MxGetDynSamplingRate
(
   IN PIRP                    pIrp,
   IN PKSNODEPROPERTY         pNodeProperty,
   IN OUT PVOID               pvData
);

VOID OptimizeSink
(
    PMIXER_SINK_INSTANCE CurSink,
    PMIXER_SOURCE_INSTANCE  pMixerSource
);

VOID OptimizeMix
(
    PFILTER_INSTANCE  pFilterInstance
);

NTSTATUS MxGetMaxLatency
(
   IN PIRP                    pIrp,
   IN PKSPROPERTY             pProperty,
   IN OUT PVOID               pvData
);

NTSTATUS MxSetDynSamplingRate
(
   IN PIRP                    pIrp,
   IN PKSNODEPROPERTY         pNodeProperty,
   IN OUT PVOID               pvData
);

NTSTATUS MxGetMixLvlTable
(
   IN PIRP                    pIrp,
   IN PKSNODEPROPERTY         pNodeProperty,
   IN OUT PVOID               pvData
);

NTSTATUS MxSetMixLvlTable
(
   IN PIRP                    pIrp,
   IN PKSNODEPROPERTY         pNodeProperty,
   IN OUT PVOID               pvData
);

NTSTATUS MxGetMixLvlCaps
(
   IN PIRP                    pIrp,
   IN PKSNODEPROPERTY         pNodeProperty,
   IN OUT PVOID               pvData
);

NTSTATUS MxSetMixLvlCaps
(
   IN PIRP                    pIrp,
   IN PKSNODEPROPERTY         pNodeProperty,
   IN OUT PVOID               pvData
);

NTSTATUS MxGetCpuResources
(
   IN PIRP                    pIrp,
   IN PKSNODEPROPERTY         pNodeProperty,
   IN OUT PVOID               pvData
);

NTSTATUS MxSetItd3dParams
(
   IN PIRP                    pIrp,
   IN PKSNODEPROPERTY         pProperty,
   IN OUT PVOID               pvData
);

NTSTATUS UpdateItd3dParams
(
    PITDCONTEXT pContextLeft,
    PITDCONTEXT pContextRight,
    PKSDS3D_ITD_PARAMS pNewItd3dParamsLeft,
    PKSDS3D_ITD_PARAMS pNewItd3dParamsRight
);

NTSTATUS MxSetIir3dParams
(
   IN PIRP                    pIrp,
   IN PKSNODEPROPERTY         pProperty,
   IN OUT PVOID               pvData
);

NTSTATUS UpdateIir3dParams
(
    PMIXER_SINK_INSTANCE pMixerSink
); 

NTSTATUS MxIir3dInitialize
(
   IN PIRP                    pIrp,
   IN PKSNODEPROPERTY         pNodeProperty,
   IN OUT PVOID               pvData
);

NTSTATUS MxGetFilterMethodAndCoeffFormat
(
   IN PIRP                    pIrp,
   IN PKSNODEPROPERTY         pNodeProperty,
   IN OUT PVOID               pvData
);

VOID CancelIrpQueue
(
PMIXER_SINK_INSTANCE    pMixerSink,
PLIST_ENTRY             ListHead,
PKSPIN_LOCK              SpinLock
);

VOID CancelGlobalIrpQueue
(
   PMIXER_SINK_INSTANCE    pMixerSink,
   PLIST_ENTRY             ListHead,
   PKSPIN_LOCK              SpinLock
) ;

NTSTATUS FilterStateHandler
(
    IN PIRP         pIrp,
    IN PKSPROPERTY  pProperty,
    IN OUT PKSSTATE DeviceState
) ;

NTSTATUS PinStateHandler
(
    IN PIRP         pIrp,
    IN PKSPROPERTY  pProperty,
    IN OUT PKSSTATE DeviceState
) ;

NTSTATUS ResetStateHandler
(
    IN PIRP         pIrp
) ;

VOID CancelPendingIrps
(
    IN PMIXER_SINK_INSTANCE    pMixerSink, 
    IN PFILTER_INSTANCE        pFilterInstance 
) ;

VOID
UpdateSinkTime
(
   PMIXER_SINK_INSTANCE pMixerSink,
   ULONG                Increment
) ;

NTSTATUS
GetWriteAndPlayOffsets
(
   PFILTER_INSTANCE        pFilterInstance,
   PMIXER_SINK_INSTANCE    pMixerSink,
   PKSAUDIO_POSITION       pPosition,
   BOOL                    fReading
) ;

NTSTATUS
GetRenderPos
(
    PFILTER_INSTANCE    pFilterInstance,
    PULONGLONG          pPos
) ;

NTSTATUS
GetRenderState
(
    PFILTER_INSTANCE    pFilterInstance,
    PKSSTATE            pState
) ;

NTSTATUS
MxAddPositionEvent
(
   PIRP                     pIrp,
   PLOOPEDSTREAMING_POSITION_EVENT_DATA pPosEventData,
   PPOSITION_EVENT_ENTRY    pPositionEventEntry
) ;

NTSTATUS
MxAddEndOfStreamEvent
(
   PIRP                     pIrp,
   PKSEVENTDATA             pKsEventData,
   PPOSITION_EVENT_ENTRY    pEndOfStreamEventEntry
) ;

VOID
MxGenerateEndOfStreamEvents
(
    PMIXER_SINK_INSTANCE pMixerSink
) ;

PIRP GetFirstIrpInQueue
(
    IN PMIXER_SINK_INSTANCE pMixerSink
) ;

VOID
AddIrpToAgingQueue
(
    PFILTER_INSTANCE       pFilterInstance,
    PMIXER_SINK_INSTANCE   pMixerSink,
    PIRP                   pIrp,
    PVOID                  Arg3,
    BOOL                   UseNumPendingIos
) ;

VOID AgeIrps
(
   PFILTER_INSTANCE        pFilterInstance
) ;

NTSTATUS FreeDeadIrps
(
   PFILTER_INSTANCE        pFilterInstance
) ;

VOID AddAnotherMixBuffer
(
   PFILTER_INSTANCE    pFilterInstance
) ;

#if 0
NTSTATUS
MxRemovePositionEvent
(
   PFILE_OBJECT pFileObject,
   struct _KSEVENT_ENTRY *pEventEntry
//   PKSEVENT_ENTRY pEventEntry
) ;
#endif

VOID GenerateSpeakerMapping( VOID );

VOID GetOptimizerFlags(	PMIXER_SINK_INSTANCE CurSink, PMIXER_SOURCE_INSTANCE pMixerSource, POPTIMIZER_FLAGS	pFlags);

VOID MapSpeakerLocations
(
	PMIXER_SINK_INSTANCE pMixerSink,
	ULONG	InChannels,
	ULONG	OutChannels,
	ULONG   InMask,
	ULONG   OutMask,
    PMIXER_SOURCE_INSTANCE pMixerSource
);

VOID GenerateMixArray
(
	PMIXER_SINK_INSTANCE pMixerSink,
	ULONG	InChannels,
	ULONG	OutChannels,
    PMIXER_SOURCE_INSTANCE pMixerSource
);

VOID
PrepareFilter(
    PMIXER_SRC_INSTANCE pSrc
);

NTSTATUS
InitializeSRC(
    PMIXER_SRC_INSTANCE pSrc,
	ULONG InputRate, 
	ULONG OutputRate,
    ULONG nChannels,
    ULONG csMixBufferSize
);

NTSTATUS
EnableSRC(
    PFILTER_INSTANCE pFilterInstance,
    PMIXER_SRC_INSTANCE pSrc,
    PMIXER_SOURCE_INSTANCE pMixerSource // NULL for non-global instances of SRC's
);

NTSTATUS
DisableSRC(
    PMIXER_SRC_INSTANCE pSrc,
    PMIXER_SOURCE_INSTANCE pMixerSource
);

NTSTATUS
PinPropertyStreamMasterClock
(
    IN PIRP         Irp,
    IN PKSPROPERTY  Property,
    IN OUT PHANDLE  ClockHandle
) ;

//---------------------------------------------------------------------------
// clock.c

NTSTATUS
MxClockDispatchCreate(
    IN  PDEVICE_OBJECT  pDeviceObject,
    IN  PIRP            pIrp
) ;

NTSTATUS
MxClockDispatchClose(
    IN  PDEVICE_OBJECT  pDeviceObject,
    IN  PIRP            pIrp
) ;

NTSTATUS
MxClockDispatchIoControl(
    IN  PDEVICE_OBJECT  pDeviceObject,
    IN  PIRP            pIrp
) ;

NTSTATUS
MxGetTime
(
    PIRP                pIrp,
    PKSPROPERTY         pProperty,
    PULONGLONG          pTime
) ;

NTSTATUS
MxGetPhysicalTime
(
    PIRP                pIrp,
    PKSPROPERTY         pProperty,
    PULONGLONG          pPhysicalTime
) ;

NTSTATUS
MxGetCorrelatedTime
(
    PIRP                pIrp,
    PKSPROPERTY         pProperty,
    PKSCORRELATED_TIME  pCorrelatedTime
) ;


NTSTATUS
MxGetCorrelatedPhysicalTime
(
    PIRP                pIrp,
    PKSPROPERTY         pProperty,
    PKSCORRELATED_TIME  pCorrelatedPhysicalTime
) ;


NTSTATUS
MxGetResolution
(
    PIRP                pIrp,
    PKSPROPERTY         pProperty,
    PKSRESOLUTION       pResolution
) ;


NTSTATUS
MxGetState
(
    PIRP                pIrp,
    PKSPROPERTY         pProperty,
    PKSSTATE            pState
) ;


NTSTATUS
MxGetFunctionTable
(
    PIRP                    pIrp,
    PKSPROPERTY             pProperty,
    PKSCLOCK_FUNCTIONTABLE  pClockFunctionTable
) ;


LONGLONG
FASTCALL
MxFastGetTime
(
    PFILE_OBJECT        pFileObject
) ;


LONGLONG
FASTCALL
MxFastGetPhysicalTime
(
    PFILE_OBJECT        pFileObject
) ;


LONGLONG
FASTCALL
MxFastGetCorrelatedTime
(
    PFILE_OBJECT        pFileObject,
    PLONGLONG           pSystemTime
) ;


LONGLONG
FASTCALL
MxFastGetCorrelatedPhysicalTime
(
    PFILE_OBJECT        pFileObject,
    PLONGLONG           pSystemTime
) ;

NTSTATUS
MxAddClockEvent
(
    PIRP                    pIrp,
    PKSEVENT_TIME_INTERVAL  pEventTime,
    PKSEVENT_ENTRY          EventEntry
) ;

LONGLONG
MxConvertBytesToTime
(
    PMIXER_SINK_INSTANCE    pMixerSink,
    ULONGLONG               Bytes
) ;

MxGenerateClockEvents
(
    PCLOCK_INSTANCE    pClock
) ;

MxUpdatePhysicalTime
(
    PCLOCK_INSTANCE pClock,
    ULONGLONG       Increment           // in Bytes
) ;

//---------------------------------------------------------------------------
// filt3d.c:

NTSTATUS Itd3dFilterPrepare(
    PITDCONTEXT pfir, 
    int cSamples );

void Itd3dFilterUnprepare( PITDCONTEXT pfir );

void Itd3dFilterClear( PITDCONTEXT pfir );

void Itd3dFilterChunkUpdate( 
    PITDCONTEXT pfir, 
    int cSamples );

ULONG ZeroBuffer32(PMIXER_OPERATION CurStage, ULONG SampleCount, ULONG samplesleft);

ULONG StageMonoItd3D( PMIXER_OPERATION CurStage, ULONG SampleCount, ULONG samplesleft );
ULONG StageMonoItd3DFloat( PMIXER_OPERATION CurStage, ULONG SampleCount, ULONG samplesleft );
ULONG StageMonoItd3DMix( PMIXER_OPERATION CurStage, ULONG SampleCount, ULONG samplesleft );
ULONG StageMonoItd3DFloatMix( PMIXER_OPERATION CurStage, ULONG SampleCount, ULONG samplesleft );

ULONG StageStereoItd3D( PMIXER_OPERATION CurStage, ULONG SampleCount, ULONG samplesleft );
ULONG StageStereoItd3DFloat( PMIXER_OPERATION CurStage, ULONG SampleCount, ULONG samplesleft );
ULONG StageStereoItd3DMix( PMIXER_OPERATION CurStage, ULONG SampleCount, ULONG samplesleft );
ULONG StageStereoItd3DFloatMix( PMIXER_OPERATION CurStage, ULONG SampleCount, ULONG samplesleft );

ULONG StageMonoIir3D( PMIXER_OPERATION CurStage, ULONG SampleCount, ULONG samplesleft );
ULONG StageMonoIir3DFloat( PMIXER_OPERATION CurStage, ULONG SampleCount, ULONG samplesleft );
ULONG StageMonoIir3DMix( PMIXER_OPERATION CurStage, ULONG SampleCount, ULONG samplesleft );
ULONG StageMonoIir3DFloatMix( PMIXER_OPERATION CurStage, ULONG SampleCount, ULONG samplesleft );

ULONG StageStereoIir3D( PMIXER_OPERATION CurStage, ULONG SampleCount, ULONG samplesleft );
ULONG StageStereoIir3DFloat( PMIXER_OPERATION CurStage, ULONG SampleCount, ULONG samplesleft );
ULONG StageStereoIir3DMix( PMIXER_OPERATION CurStage, ULONG SampleCount, ULONG samplesleft );
ULONG StageStereoIir3DFloatMix( PMIXER_OPERATION CurStage, ULONG SampleCount, ULONG samplesleft );

#ifdef SURROUND_ENCODE
ULONG ConvertMono16toDolby( PMIXER_OPERATION CurStage, ULONG SampleCount, ULONG samplesleft );
ULONG ConvertMono8toDolby( PMIXER_OPERATION CurStage, ULONG SampleCount, ULONG samplesleft );
ULONG QuickMixMono16toDolby( PMIXER_OPERATION CurStage, ULONG SampleCount, ULONG samplesleft );
ULONG QuickMixMono8toDolby( PMIXER_OPERATION CurStage, ULONG SampleCount, ULONG samplesleft );
ULONG ConvertMono16toDolbyFloat( PMIXER_OPERATION CurStage, ULONG SampleCount, ULONG samplesleft );
ULONG ConvertMono8toDolbyFloat( PMIXER_OPERATION CurStage, ULONG SampleCount, ULONG samplesleft );
ULONG QuickMixMono16toDolbyFloat( PMIXER_OPERATION CurStage, ULONG SampleCount, ULONG samplesleft );
ULONG QuickMixMono8toDolbyFloat( PMIXER_OPERATION CurStage, ULONG SampleCount, ULONG samplesleft );
#endif

#ifdef NEW_SURROUND
ULONG ConvertQuad32toDolby( PMIXER_SOURCE_INSTANCE pMixerSource, PLONG pIn, PLONG pOut, ULONG SampleCount );
#endif

//---------------------------------------------------------------------------
// dxcrt.c:

// from our special c-runtime code
double _stdcall pow2(double);
double _stdcall fylog2x(double, double);

//---------------------------------------------------------------------------
// topology.c:

NTSTATUS FilterTopologyHandler(
    IN PIRP pIrp,
    IN PKSPROPERTY pProperty,
    IN OUT PVOID pData
);


LONG __inline
ConvertFloatToLong
(
    FLOAT Value
)
{
    LONG   RetVal = 2147483583L;

#ifdef _X86_
    // This checks for floats over 2147483583.0
    if (*((PLONG) &Value) < 0x4f000000L) {
        _asm {
            fld Value
            fistp RetVal    // Values > 2147483583.0 will be stored as 0x80000000 by default.
        }
    }
#else
    // On the Alpha, we must make sure that we don't cause a trap...
    // Note: These numbers are less than the 32-bit limits, because the float
    // only has 24 bits of precision, and we don't want it rounding up and
    // faulting on the conversion!
    if (Value < -2147483392.0f) {
        Value = -2147483392.0f;
    } else if (Value > 2147483392.0f) {
        Value = 2147483392.0f;
    }
    
    // We round here because the implicit ftol doesn't round!
    RetVal = (LONG) (Value < 0.0 ? (Value - 0.5) : (Value + 0.5));
#endif
    return RetVal;
}

#ifdef INTEGER_DITHER
ULONG __inline
GetRandomValue( VOID )
{
    extern ULONG Dither[];
    extern ULONG DitherIndex;

    // Move the dither index
    DitherIndex = ((DitherIndex - 1) & (DITHER_LENGTH-1));

    // Calculate the next random value
    Dither[DitherIndex] = Dither[((DitherIndex + 55) & (DITHER_LENGTH-1))];
    Dither[DitherIndex] += Dither[((DitherIndex + 24) & (DITHER_LENGTH-1))];

    return (Dither[DitherIndex]);
}

LONG __inline
DitherFloatToLong
(
    FLOAT Value,
    ULONG DitherScale
)
{
    LONG    Quantized;

    // Add the dither and quantize
    Value += (FLOAT) (DitherScale/2147483648.0)*((LONG) (GetRandomValue()/2 + GetRandomValue()/2 - 0x80000000));
    Quantized = ConvertFloatToLong(Value);

    return Quantized;
}

#else   // not INTEGER_DITHER
FLOAT __inline
GetRandomValue( VOID )
{
    extern FLOAT Dither[];
    extern ULONG DitherIndex;

    // Move the dither index
    DitherIndex = ((DitherIndex - 1) & (DITHER_LENGTH-1));

    // Calculate the next random value
    Dither[DitherIndex] = Dither[((DitherIndex + 55) & (DITHER_LENGTH-1))];
    Dither[DitherIndex] += Dither[((DitherIndex + 24) & (DITHER_LENGTH-1))];
    if (Dither[DitherIndex] > 1.0f) {
        Dither[DitherIndex] -= (FLOAT) (ConvertFloatToLong(Dither[DitherIndex]));
        if (Dither[DitherIndex] < 0.0f) {
            Dither[DitherIndex] += 1.0f;
        }
    }

    return (Dither[DitherIndex]);
}

LONG __inline
DitherFloatToLong
(
    FLOAT Value,
    ULONG DitherScale
)
{
    LONG    Quantized;
#if NOISE_SHAPING
    static FLOAT   ErrHistory[9] = { 0, 0, 0, 0, 0, 0, 0, 0, 0};
    ULONG   i;

    // The noise shaping filter
    FLOAT NoiseFilter[] = { 1.2196981247141332e-004f,8.5683793261167856e-003f,-6.7144381765513031e-002f,1.8615642628449458e-001f,7.4438176551303548e-001f};

    // Subtract the filtered error signal
    Value -= (ErrHistory[8] * NoiseFilter[0] +
            ErrHistory[7] * NoiseFilter[1] +
            ErrHistory[6] * NoiseFilter[2] +
            ErrHistory[5] * NoiseFilter[3] +
            ErrHistory[4] * NoiseFilter[4] +
            ErrHistory[3] * NoiseFilter[3] +
            ErrHistory[2] * NoiseFilter[2] +
            ErrHistory[1] * NoiseFilter[1] +
            ErrHistory[0] * NoiseFilter[0]);

    // Remember the value we're trying to produce
    for (i=0; i<8; i++) {
        ErrHistory[i] = ErrHistory[i+1];
    }
    ErrHistory[8] = -1*Value;
#endif

    // Add the dither and quantize
    Value += DitherScale*(GetRandomValue() + GetRandomValue() - 1);
    Quantized = ConvertFloatToLong(Value);

#if NOISE_SHAPING
    // Calculate and remember the error signal
    ErrHistory[8] += Quantized;
#endif

    return Quantized;
}
#endif // not INTEGER_DITHER

VOID __inline
MixFloat
(
    PLONG pOutputBuffer,
    FLOAT Value
)
{
#ifdef _X86_
    FLOAT   flShifter =  25165824.0;
    
        _asm {
            mov edi, pOutputBuffer
            mov edx, flShifter
            fld Value
            fadd flShifter
            mov eax, DWORD PTR [edi]
            sub eax, edx
            fstp DWORD PTR [edi]
            mov ebx, DWORD PTR [edi]
            add eax, ebx
            mov DWORD PTR [edi], eax
            }
#else
	    *pOutputBuffer += (LONG) Value;
#endif
}

VOID __inline
MixFloatStereoPair
(
    PLONG pOutputBuffer,
    FLOAT Value1,
    FLOAT Value2
)
{
#ifdef _X86_
    static FLOAT flShifter =  25165824.0;
    FLOAT   flTemp;
    
        _asm {
            fld Value1
            fadd flShifter
            mov edi, pOutputBuffer
            mov edx, flShifter
            fstp flTemp
            fld Value2
            fadd flShifter
            mov eax, DWORD PTR [edi]
            mov ebx, flTemp
            sub eax, edx
            mov ecx, DWORD PTR [edi+4]
            fstp flTemp
            add eax, ebx
            sub ecx, edx
            mov DWORD PTR [edi], eax
            mov ebx, flTemp
            add ecx, ebx
            mov DWORD PTR [edi+4], ecx
            }
#else
	    *pOutputBuffer += (LONG) Value1;
	    pOutputBuffer[1] += (LONG) Value2;
#endif
}

ULONG __inline
SrcInputBufferSize(
    PMIXER_SRC_INSTANCE pSrc,
    ULONG csOutputSize
)
{
    ULONG   csInputSize, L, M;
    LONG    nInternalSamplesNeeded;
    DWORD   dwFrac;
    extern DWORD DownFraction[];
    extern DWORD UpFraction[];
    
    L = pSrc->UpSampleRate;
    M = pSrc->DownSampleRate;

    if (L != M) {
        if (pSrc->Quality == KSAUDIO_QUALITY_PC) {
            dwFrac = pSrc->dwFrac;
        	nInternalSamplesNeeded = (csOutputSize*dwFrac)+pSrc->SampleFrac;
        	csInputSize = (nInternalSamplesNeeded >> 12) - 1;
        	if (nInternalSamplesNeeded & 4095) {
        	    csInputSize++;
        	}
        } else {
            // Calculate the number of input samples needed
            nInternalSamplesNeeded = csOutputSize*M+pSrc->nOutCycle - L;
            if (nInternalSamplesNeeded < 0) {
                nInternalSamplesNeeded = 0;
            }
            csInputSize = nInternalSamplesNeeded/L;

            // Round up, if necessary
            if (nInternalSamplesNeeded % L) {
                csInputSize++;
            }
        }
    } else {
        csInputSize = csOutputSize;
    }

    return csInputSize;
}

ULONG __inline
SrcOutputBufferSize(
    PMIXER_SRC_INSTANCE pSrc,
    ULONG csInputSize
)
{
    ULONG   csOutputSize, L, M, nInternalSamples;
    DWORD   dwFrac;
    extern DWORD DownFraction[];
    extern DWORD UpFraction[];
    
    L = pSrc->UpSampleRate;
    M = pSrc->DownSampleRate;

    if (L != M) {
        if (pSrc->Quality == KSAUDIO_QUALITY_PC) {
            dwFrac = pSrc->dwFrac;
        	nInternalSamples = (csInputSize << 12) + pSrc->SampleFrac;
        	csOutputSize = nInternalSamples / dwFrac;
        } else {
            // Calculate the number of input samples needed
            if (pSrc->nOutCycle > csInputSize*L) {
                // We can't produce any output samples.
                csOutputSize = 0;
            } else {
                nInternalSamples = csInputSize*L - pSrc->nOutCycle;
                csOutputSize = nInternalSamples/M;

                // Round up, if necessary
                if (nInternalSamples % M) {
                    csOutputSize++;
                }
            }
        }
    } else {
        csOutputSize = csInputSize;
    }

    return csOutputSize;
}

#define THE_SOUND_OF_SILENCE    0x80000000L

#ifdef REALTIME_THREAD
#define SaveFloatState(a)		(RtThread() ? STATUS_SUCCESS : KeSaveFloatingPointState(a))
#define RestoreFloatState(a)	(RtThread() ? STATUS_SUCCESS : KeRestoreFloatingPointState(a))
#else
#define SaveFloatState(a)       KeSaveFloatingPointState(a)
#define RestoreFloatState(a)    KeRestoreFloatingPointState(a)
#endif


// Calculate the worst case (maximum) size of an input buffer (in samples)
//
// The worst case occurs when the input rate is MAX_SAMPLING_RATE, and
// we are down-sampling as much as possible (L = 1 and M = STOPBAND_FACTOR/2).
//
// We will use L = 1 and M = STOPBAND_FACTOR/2 for all output/input ratios
// up to 1.5/(STOPBAND_FACTOR/2), so our worst case output rate is:
//      (MAX_SAMPLING_RATE * 1.5)/(STOPBAND_FACTOR/2)
//
// and the worst output buffer size is:
//      (WorstOutputRate * MIXBUFFERDURATION)/1000 + 1
//  =   ((MAX_SAMPLING_RATE * 1.5)/(STOPBAND_FACTOR/2)) * MIXBUFFERDURATION / 1000 + 1
//
// Making the worst input buffer size (in samples) for filtered SRC:
//      (WorstOutputSize+1)*(STOPBAND_FACTOR/2)
//  =   (MAX_SAMPLING_RATE * 1.5 * MIXBUFFERDURATION)/1000 + STOPBAND_FACTOR
//
// and for linear interpolation, we get a slightly smaller size:
//      (WorstOutputSize)*(STOPBAND_FACTOR/2)+2
//      

#define MAX_INPUT_SAMPLES   ((3*MAX_SAMPLING_RATE*MIXBUFFERDURATION)/2000 + STOPBAND_FACTOR)

#ifdef USE_CAREFUL_ALLOCATIONS
PVOID AllocMem( IN POOL_TYPE PoolType, IN ULONG size, IN ULONG Tag );
VOID FreeMem( PVOID p );
VOID ValidateAccess( PVOID p );

#ifndef NO_REMAPPING_ALLOC
#define ExAllocatePoolWithTag   AllocMem
#define ExFreePool  FreeMem
#endif
#else   // not USE_CAREFUL_ALLOCATIONS
#ifdef REALTIME_THREAD
#ifndef NO_REMAPPING_ALLOC
PVOID AllocMem( IN POOL_TYPE PoolType, IN ULONG size, IN ULONG Tag );
#define ExAllocatePoolWithTag   AllocMem
#endif
#endif
#endif

#ifdef REALTIME_THREAD
#ifndef NO_REMAPPING_ALLOC
#define KeWaitForSingleObject(a,b,c,d,e) RtWaitForSingleObject(pFilterInstance,a,b,c,d,e)
#define KeReleaseMutex(a,b) RtReleaseMutex(pFilterInstance,a,b)
#endif

VOID
PreMixUpdate(
    PFILTER_INSTANCE pFilterInstance
    );

NTSTATUS
GetRtPosFunction (
    PFILTER_INSTANCE    pFilterInstance
    );

NTSTATUS
MxWaitForSingleObject (
    IN PVOID Object,
    IN KWAIT_REASON WaitReason,
    IN KPROCESSOR_MODE WaitMode,
    IN BOOLEAN Alertable,
    IN PLARGE_INTEGER Timeout OPTIONAL
    );

LONG
MxReleaseMutex (
    IN PRKMUTEX Mutex,
    IN BOOLEAN Wait
    );

NTSTATUS
RtWaitForSingleObject (
    PFILTER_INSTANCE pFilterInstance,
    IN PVOID Object,
    IN KWAIT_REASON WaitReason,
    IN KPROCESSOR_MODE WaitMode,
    IN BOOLEAN Alertable,
    IN PLARGE_INTEGER Timeout OPTIONAL
    );

LONG
RtReleaseMutex (
    PFILTER_INSTANCE pFilterInstance,
    IN PRKMUTEX Mutex,
    IN BOOLEAN Wait
    );
#endif

#ifdef LOG_TO_FILE
NTSTATUS NTAPI FileOpenRoutine (PFILTER_INSTANCE pFilterInstance, BOOL fNewFile);
NTSTATUS NTAPI FileIoRoutine (PFILTER_INSTANCE pFilterInstance, PVOID buffer, ULONG length);
NTSTATUS NTAPI FileCloseRoutine (PFILTER_INSTANCE pFilterInstance);
#endif

#define SrcIndex(p) ((p)->UpSampleRate==160 ? ((p)->DownSampleRate-1) : ((p)->UpSampleRate+159))

#ifdef PERF_COUNT
#define START_PERF (StartTick = KeQueryPerformanceCounter(&Freq))
#define MEASURE_PERF(a) { EndTick = KeQueryPerformanceCounter(&Freq); \
    a = (EndTick.QuadPart > StartTick.QuadPart ? (a + (DWORD)(EndTick.QuadPart-StartTick.QuadPart))/(a ? 2 : 1) : a); }

#else
#define START_PERF
#define MEASURE_PERF(a)
#endif

NTSTATUS MxGetChannelConfig
(
   IN PIRP                    pIrp,
   IN PKSNODEPROPERTY         pNodeProperty,
   IN OUT PVOID               pvData
);

//---------------------------------------------------------------------------
//  End of File: private.h
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\filters\kmixer\rfcvec.h ===
/*++

    Copyright (c) 1998-2000 Microsoft Corporation.  All Rights Reserved.

Module Name:

    rfcrcvec.h

Abstract:

    This is the header for the real float circular vector

Author:

    Jay Stokes (jstokes) 22-Apr-1998

--*/


#if !defined(RFCVEC_HEADER)
#define RFCVEC_HEADER
#pragma once 

//#include "dsplib.h"

// ---------------------------------------------------------------------------
// Real FLOAT circular vector

typedef struct _RFCVEC {
    PFLOAT Start;
    PFLOAT End;
    PFLOAT Index;
    UINT   PreallocSize;
} RFCVEC, *PRFCVEC;

NTSTATUS
RfcVecCreate
(
    IN PRFCVEC* Vec,
    IN UINT  Size, 
    IN BOOL  Initialize,
    IN FLOAT InitValue
);

VOID RfcVecDestroy(PRFCVEC);
NTSTATUS RfcVecSetSize(PRFCVEC, UINT, FLOAT);
UINT RfcVecGetSize(PRFCVEC);
FLOAT RfcVecLIFORead(PRFCVEC);
VOID RfcVecLIFONext(PRFCVEC);
VOID RfcVecSkipBack(PRFCVEC);
FLOAT RfcVecFIFORead(PRFCVEC);
VOID RfcVecFIFONext(PRFCVEC);
VOID RfcVecSkipForward(PRFCVEC);
VOID RfcVecWrite(PRFCVEC, FLOAT);
VOID RfcVecFill(PRFCVEC, FLOAT);
VOID RfcVecLIFOFill(PRFCVEC, PRFCVEC);
VOID RfcVecFIFOFill(PRFCVEC, PRFCVEC);
UINT RfcVecGetIndex(PRFCVEC);
VOID RfcVecSetIndex(PRFCVEC, UINT);
VOID RfcVecReset(PRFCVEC);

/*
private:
    // Prohibit copy ruction and assignment
    CRfcVec( CRfcVec& rhs);
    CRfcVec& operator=( CRfcVec& rhs);
    */

VOID RfcVecInitData(PRFCVEC);
FLOAT RfcVecPreviousRead(PRFCVEC);
FLOAT RfcVecReadNext(PRFCVEC);

VOID RfcVecWriteNext(PRFCVEC, FLOAT);
NTSTATUS RfcVecInitPointers(PRFCVEC, UINT);
NTSTATUS RfcVecFullInit(PRFCVEC, UINT, FLOAT);
NTSTATUS RfcVecResizeBuffer(PRFCVEC, UINT, FLOAT);
VOID RfcVecSetEndPointer(PRFCVEC, UINT);
VOID RfcVecWriteLoop(PRFCVEC, PRFCVEC);
#if DBG
VOID RfcVecCheckPointers(PRFCVEC) ;
#endif // DBG

// ---------------------------------------------------------------------------
// Include inline definitions inline in release version

#if !DBG
#include "rfcvec.inl"
#endif // DBG

#endif

// End of RFCVEC.H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\filters\kmixer\rfcvec.c ===
/*++

    Copyright (c) 1998-2000 Microsoft Corporation.  All Rights Reserved.

Module Name:

    rfcrcvec.c

Abstract:

    This module implements real float circular vector

Author:

    Jay Stokes (jstokes) 22-Apr-1998

--*/


// Project-specific INCLUDEs
#include "common.h"

// ---------------------------------------------------------------------------
// Real FLOAT circular vector

// Set buffer size
NTSTATUS RfcVecSetSize
( 
    PRFCVEC Vec,
    UINT    Size,  
    FLOAT   InitValue
)
{
    NTSTATUS Status = STATUS_SUCCESS;

    ASSERT(Size > 0);

    // Check if preallocation size has been set and if resizing is necessary
    if (Vec->PreallocSize != 0 && Size <= Vec->PreallocSize) {
        // Don't need to resize, just change end pointer and reset buffer
        RfcVecSetEndPointer(Vec, Size);
        Vec->Index = Vec->Start;
        RfcVecFill(Vec, InitValue);
    } else {
        // Resizing necessary
        Status = RfcVecResizeBuffer(Vec, Size, InitValue);
    }

    return Status;
}

// Reset circular buffer
VOID RfcVecReset
(
    PRFCVEC Vec
)
{
    if (Vec->Start) {
        ExFreePool(Vec->Start);
        Vec->Start = NULL;
    }

    RfcVecInitData(Vec);
}

// Fill complete buffer with value
VOID RfcVecFill
( 
    PRFCVEC Vec,
    FLOAT InitValue
)
{
    PFLOAT LoopIndex;
#if DBG
//    RfcVecCheckPointers();
#endif // DBG

    for (LoopIndex = Vec->Start; LoopIndex<=Vec->End; ++LoopIndex)
        *LoopIndex = InitValue;
}

// Initialize data
VOID RfcVecInitData
(
    PRFCVEC Vec
)
{
    Vec->PreallocSize = 0;
    Vec->Start = NULL;
    Vec->End = NULL;
    Vec->Index = NULL;
}

// Allocate memory and initialize pointers
NTSTATUS RfcVecInitPointers
( 
    PRFCVEC Vec,
    UINT Size
)
{
    NTSTATUS Status = STATUS_SUCCESS;

    Vec->Start = ExAllocatePoolWithTag(PagedPool, Size*sizeof(FLOAT), 'XIMK');

    if(!Vec->Start) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
    } else {
        RfcVecSetEndPointer(Vec, Size);
    }

    return Status;
}

// Full initialization as required in regular ructor and resize operation
NTSTATUS RfcVecFullInit
( 
    PRFCVEC Vec,
    UINT Size,  
    FLOAT InitValue
)
{
    NTSTATUS Status;

    // Set pointers to initial values
    Status = RfcVecInitPointers(Vec, Size);

    if(NT_SUCCESS(Status))
    {
        Vec->Index = Vec->Start;

        // Initialize buffer with specified initialization value
        RfcVecFill(Vec, InitValue);
    }

    return Status;
}

// Resize buffer
NTSTATUS RfcVecResizeBuffer
( 
    PRFCVEC Vec,
    UINT Size,  
    FLOAT InitValue
)
{
    ASSERT(Size > 0);

    if (Vec->Start) {
        ExFreePool(Vec->Start);
        Vec->Start = NULL;
    }

    return(RfcVecFullInit(Vec, Size, InitValue));
}

/*
// Write loop
VOID RfcVecWriteLoop
( 
    PRFCVEC Vec,
    PRFCVEC rhs
//    FLOAT (PRFCVEC pmf)()
)
{
    UINT i;
    for (i=0; i<RfcVecGetSize(rhs); ++i)
        RfcVecWrite(Vec, (rhs->*pmf)());
}
*/

#if DBG
// Check pointers
VOID RfcVecCheckPointers
(
    PRFCVEC Vec
) 
{
    // Make sure pointers are good
    ASSERT(Vec->Start != NULL);
    
    // Make sure pointers make sense
    ASSERT(Vec->End >= Vec->Start);
    ASSERT(Vec->Index >= Vec->Start);
    ASSERT(Vec->Index <= Vec->End);
}
#endif // DBG

// ---------------------------------------------------------------------------
// Include inline definitions out-of-line in debug version

#if DBG
#include "rfcvec.inl"
#endif // DBG

// End of RFCIRCVEC.CPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\wdm\audio\filters\kmixer\pins.c ===
//---------------------------------------------------------------------------
//
//  Module:   pins.c
//
//  Description:
//
//
//@@BEGIN_MSINTERNAL
//  Development Team:
//     S.Mohanraj
//
//  History:   Date       Author      Comment
//
//  To Do:     Date       Author      Comment
//
//@@END_MSINTERNAL
//
//  Copyright (c) 1996-2000 Microsoft Corporation.  All Rights Reserved.
//
//---------------------------------------------------------------------------

#include "common.h"
#include "fir.h"
#include "topology.h"
#include <unknown.h>
#include <drmk.h>
#include "perf.h"


#ifndef _WIN64
#define DRM_KMIXER
#endif

KAFFINITY
KeSetAffinityThread (
    IN PKTHREAD Thread,
    IN KAFFINITY Affinity
    );


#ifdef _X86_

#define rdtsc __asm _emit 0x0f __asm _emit 0x31

LONGLONG __forceinline ReadCycleCounter(VOID)
{

    __asm {
        rdtsc
    }
}

#endif


#define     ZDbgPrint
#define     IO_AUD_INCREMENT       IO_NO_INCREMENT

#ifdef VERIFY_CAPTURE_DATA
ULONG ZeroSampleCount = 0;
#endif

#pragma LOCKED_DATA
#ifdef PERF_COUNT
ULONG gNumBuffersAdded = 0, gSinkStarved = 0, gMaxMixed = 0, WorstTicksPerWorkItem = 0;
BOOL	fStarved = FALSE;

#endif

ULONG gNumCompletionsWhileStarved = 0;
ULONG gNumMixBuffersAdded = 0;
ULONG gNumSilenceSamplesInserted = 0;
ULONG gIoCallDriverFailedCount = 0;

#pragma PAGEABLE_DATA

NTSTATUS
GetAllocatorFraming(
    IN PIRP                     Irp,
    IN PKSPROPERTY              Property,
    OUT PKSALLOCATOR_FRAMING    Framing
    );

//===========================================================================
//===========================================================================

extern ULONG FilterSizeFromQuality[];
extern PFNStage ConvertFunction[];
extern PFNStage SrcFunction[];
extern PFNStage MmxConvertFunction[];
extern PFNStage MmxSrcFunction[];
extern BOOL fLogToFile;

extern ULONG TraceEnable;
extern TRACEHANDLE LoggerHandle;

#ifdef LOG_TO_FILE
BYTE WaveHeader[] = {
    (BYTE) 0x52,(BYTE) 0x49,(BYTE) 0x46,(BYTE) 0x46,(BYTE) 0xf0,(BYTE) 0x7a,(BYTE) 0x01,(BYTE) 0x00,(BYTE) 0x57,(BYTE) 0x41,
    (BYTE) 0x56, (BYTE) 0x45, (BYTE) 0x66, (BYTE) 0x6d, (BYTE) 0x74, (BYTE) 0x20, (BYTE) 0x10, (BYTE) 0x00, (BYTE) 0x00, (BYTE) 0x00,
    (BYTE) 0x01, (BYTE) 0x00, (BYTE) 0x02, (BYTE) 0x00, (BYTE) 0x22, (BYTE) 0x56, (BYTE) 0x00, (BYTE) 0x00, (BYTE) 0x88, (BYTE) 0x58,
    (BYTE) 0x01, (BYTE) 0x00, (BYTE) 0x04, (BYTE) 0x00, (BYTE) 0x10, (BYTE) 0x00, (BYTE) 0x64, (BYTE) 0x61, (BYTE) 0x74, (BYTE) 0x61,
    (BYTE) 0x9c, (BYTE) 0x7a, (BYTE) 0x01, (BYTE) 0x04
};
#endif

#ifdef INTEGER_DITHER
ULONG Dither[DITHER_LENGTH] = {
  0x97607148,  0x88802242,  0x26577010,  0x72830083,  0x74557662,
  0x80745045,  0x84593113,  0x78265614,  0x71556441,  0x83341379,
  0x36030607,  0x94559055,  0x38197485,  0x97100034,  0x12308421,
  0x22535579,  0x22723188,  0x15934819,  0x79437052,  0x76216268,
  0x84277182,  0x24303903,  0x95559678,  0x85762244,  0x28075492,
  0x71061946,  0x34584071,  0x30182983,  0x37511702,  0x78086760,
  0x31128029,  0x33337902,  0x93008582,  0x13866352,  0x95423804,
  0x87911478,  0x52328720,  0x14893955,  0x54374102,  0x52763358,
  0x75637160,  0x64658006,  0x95686164,  0x27549469,  0x75854882,
  0x25050333,  0x12433981,  0x31849903,  0x57961230,  0x49809833,
  0x25444441,  0x41837551,  0x34178601,  0x18965704,  0x91970478,
  0x81985719,  0x32952180,  0x33292439,  0x97324106,  0x24361291,
  0x34634383,  0x20404594,  0x26788850,  0x85622742,  0x11582986,
  0x42435235,  0x99096700,  0x30978084,  0x90840333,  0x35032225,
  0x24343909,  0x15789398,  0x97161824,  0x18285150,  0x75227011,
  0x31320100,  0x87189446,  0x86442387,  0x30578470,  0x70623404,
  0x33354624,  0x97315616,  0x47388409,  0x52981236,  0x72295763,
  0x96608282,  0x68476917,  0x71378315,  0x67356973,  0x66079831,
  0x89957320,  0x85182872,  0x24144000,  0x14132635,  0x29084241,
  0x42497294,  0x41545920,  0x25129260,  0x58571020,  0x50004610,
  0x46823098,  0x29435594,  0x77598411,  0x81399102,  0x32061533,
  0x87753620,  0x88381911,  0x89078649,  0x36578263,  0x14134236,
  0x83925333,  0x88163688,  0x96095774,  0x27796221,  0x56959520,
  0x28024628,  0x69566411,  0x14962521,  0x98257203,  0x96963476,
  0x23701696,  0x52154279,  0x43928803,  0x48917033,  0x15934888,
  0x59283064,  0x73022728,  0x81671426,  0x27561822,  0x43285824,
  0x47957834,  0x43275472,  0x28629072,  0x37805488,  0x83645857,
  0x45419704,  0x11695641,  0x29363360,  0x56999535,  0x10347663,
  0x82193115,  0x40880100,  0x68790521,  0x95578515,  0x27113504,
  0x26483464,  0x99074283,  0x94079495,  0x19878194,  0x66077379,
  0x44103864,  0x93291022,  0x21547004,  0x99066759,  0x76158444,
  0x35844020,  0x54282568,  0x28194381,  0x63980115,  0x32223133,
  0x96172670,  0x56286233,  0x48030528,  0x63399984,  0x23932267,
  0x10568868,  0x99615669,  0x25502835,  0x34288738,  0x61094535,
  0x19956509,  0x10131644,  0x43512696,  0x64409236,  0x67879202,
  0x70911777,  0x25461827,  0x53287932,  0x71788571,  0x43357027,
  0x27933551,  0x93491471,  0x67737436,  0x33238512,  0x12558402,
  0x98981004,  0x34477313,  0x90305386,  0x97856412,  0x47483320,
  0x19442109,  0x27327416,  0x44818868,  0x79299831,  0x44413140,
  0x92247673,  0x34116637,  0x73563600,  0x21837990,  0x32956492,
  0x79242407,  0x82845592,  0x52116046,  0x99028305,  0x66529372,
  0x83018495,  0x39358082,  0x41491716,  0x98805087,  0x92457293,
  0x63790634,  0x41788816,  0x97164638,  0x33557250,  0x58964831,
  0x35101286,  0x42696088,  0x82029735,  0x68500044,  0x27739917,
  0x76818846,  0x52474762,  0x42252471,  0x76944760,  0x55090141,
  0x35059412,  0x37102037,  0x93558220,  0x79803162,  0x40913115,
  0x51082370,  0x47551270,  0x95644944,  0x30350637,  0x55178802,
  0x39436788,  0x96482748,  0x46895094,  0x16289649,  0x51046467,
  0x64037110,  0x46964184,  0x35309790,  0x80340875,  0x23091948,
  0x71128403,  0x79954082,  0x36392145,  0x46113752,  0x49707956,
  0x34653566,  0x45363008,  0x94199486,  0x93955167,  0x82628835,
  0x72202569,  0x71038958,  0x74144891,  0x18269859,  0x35963774,
  0x71298712,  0x91537835,  0x63137485,  0x92996973,  0x71778978,
  0x89724595,  0x91171931,  0x28639264,  0x33309183,  0x63547374,
  0x18726381,  0x44735938,  0x47511205,  0x19988380,  0x26316922,
  0x14683136,  0x19749139,  0x36285712,  0x18955700,  0x84323730,
  0x47465796,  0x44723664,  0x58997654,  0x33346203,  0x88041670,
  0x87124286,  0x78500813,  0x45025258,  0x63069629,  0x45325314,
  0x66829165,  0x45463159,  0x24150662,  0x93922405,  0x30927937,
  0x72904092,  0x11331287,  0x59165860,  0x76820905,  0x48483077,
  0x97361437,  0x65412401,  0x69241889,  0x71563578,  0x23953636,
  0x63068271,  0x57292244,  0x92020916,  0x87128511,  0x74846789,
  0x29444009,  0x25893852,  0x56394350,  0x72942257,  0x24390006,
  0x17770358,  0x63460260,  0x75987973,  0x64188966,  0x43057902,
  0x54338162,  0x97802540,  0x27397702,  0x37068400,  0x46249947,
  0x32306081,  0x70617479,  0x61647959,  0x38810599,  0x49492222,
  0x75242009,  0x14215033,  0x80131149,  0x51993779,  0x50479560,
  0x50701936,  0x25226850,  0x50798672,  0x36862637,  0x78382841,
  0x14995185,  0x24699721,  0x94509075,  0x38782332,  0x76567755,
  0x42031411,  0x46087513,  0x32916273,  0x62843117,  0x96612198,
  0x71767473,  0x30237418,  0x67216399,  0x43152062,  0x13376039,
  0x29241139,  0x31955321,  0x43131264,  0x20327523,  0x53284412,
  0x52829154,  0x54742679,  0x57514336,  0x11170352,  0x66459233,
  0x84072243,  0x72123010,  0x22585944,  0x39040124,  0x69127011,
  0x64027861,  0x14742222,  0x45750488,  0x77381699,  0x12414841,
  0x30097740,  0x32380236,  0x79935781,  0x74847777,  0x17188998,
  0x57698286,  0x26991481,  0x44188062,  0x71060026,  0x20807518,
  0x93968025,  0x21464266,  0x78404156,  0x49971999,  0x40573550,
  0x88558175,  0x29223597,  0x52030548,  0x87558096,  0x44361632,
  0x41167896,  0x73824048,  0x69409591,  0x56286895,  0x15313061,
  0x96787724,  0x44463441,  0x85461275,  0x88130952,  0x54107991,
  0x63435160,  0x57192077,  0x33535785,  0x78841123,  0x82555820,
  0x20695837,  0x14481952,  0x99095161,  0x24450532,  0x61774579,
  0x69745141,  0x52358575,  0x67795090,  0x66726106,  0x86797950,
  0x21260947,  0x38952118,  0x72075916,  0x37593516,  0x93990304,
  0x34346457,  0x56713160,  0x20970551,  0x43841616,  0x14578981,
  0x73804485,  0x43717914,  0x32485834,  0x16824126,  0x22592387,
  0x38577522,  0x34051594,  0x77734308,  0x85223777,  0x34821034,
  0x23294467,  0x19968361,  0x59836520,  0x74603771,  0x39715323,
  0x78706714,  0x52848182,  0x32271208,  0x32944359,  0x29931693,
  0x38780186,  0x36726640,  0x63358155,  0x35778715,  0x58766355,
  0x42331618,  0x28356048,  0x65147880,  0x46204810,  0x88500489,
  0x90462418,  0x95887278,  0x56566917,  0x28120835,  0x89588062,
  0x94997750,  0x29987106,  0x24636681,  0x46768937,  0x10824657,
  0x55476368,  0x74527283,  0x44578902,  0x27611972,  0x63929983,
  0x62175293,  0x66644861,  0x22928591,  0x88190439,  0x15669597,
  0x82242049,  0x30040752,  0x23721318,  0x40772135,  0x34880979,
  0x83757164,  0x52712469,  0x16340602,  0x43652944,  0x18923057,
  0x58527803,  0x28098971,  0x19367986,  0x12280228,  0x80383175,
  0x20705644,  0x33421503,  0x90483512,  0x17573901,  0x93879776,
  0x17643093,  0x82387186,  0x91077900,  0x95243993,  0x66764120,
  0x66039500,  0x57388132,  0x76440255,  0x66726820,  0x30862726,
  0x79916878,  0x31945772,  0x75880193,  0x68158175,  0x57632432,
  0x28828626,  0x94282456,  0x17029173,  0x53629203,  0x45899913,
  0x69133098,  0x36869178,  0x98121807,  0x10658577,  0x34882364,
  0x61824444,  0x74133683,  0x45147578,  0x20902681,  0x15559180,
  0x89970684,  0x31495695,  0x93218737,  0x76769468,  0x16886443,
  0x17341361,  0x86593427,  0x88395472,  0x68161709,  0x35364155,
  0x28341439,  0x49987523,  0x41391299,  0x95112883,  0x74574764,
  0x50620622,  0x68787337,  0x41735227,  0x51963833,  0x18886674,
  0x32891889,  0x91529145,  0x67633505,  0x39494462,  0x88899760,
  0x35425420,  0x30459817,  0x49190734,  0x31908065,  0x69447122,
  0x85743116,  0x96887278,  0x20517694,  0x90421652,  0x89811931,
  0x76300231,  0x34787318,  0x19528017,  0x65913642,  0x30492611,
  0x99370869,  0x38932885,  0x45292165,  0x13000339,  0x59669199,
  0x42983310,  0x88117975,  0x25953796,  0x35418769,  0x95753969,
  0x58877707,  0x12006447,  0x33329928,  0x64524827,  0x76285663,
  0x81903061,  0x68657266,  0x34282065,  0x70554633,  0x28849052,
  0x45552199,  0x76121692,  0x79150359,  0x81692318,  0x33403924,
  0x93755077,  0x84434691,  0x70749862,  0x81053949,  0x35077956,
  0x43573272,  0x58320201,  0x57318893,  0x48433628,  0x39639129,
  0x47217251,  0x93908859,  0x36418023,  0x92925962,  0x43529693,
  0x65875780,  0x65501994,  0x65734440,  0x71103319,  0x61765954,
  0x90478824,  0x64305543,  0x65577799,  0x56787767,  0x60686213,
  0x62706137,  0x20171961,  0x77169859,  0x72953988,  0x53597919,
  0x88983555,  0x12678645,  0x34714736,  0x46487359,  0x10110526,
  0x26312436,  0x30309148,  0x86126696,  0x43121954,  0x39484752,
  0x45905324,  0x81786259,  0x87546266,  0x58429807,  0x65364997,
  0x83666271,  0x60457111,  0x38168704,  0x40196574,  0x53707036,
  0x87928282,  0x64860294,  0x43847393,  0x83583419,  0x37541228,
  0x81084194,  0x61267503,  0x87783612,  0x40343776,  0x97165511,
  0x48821692,  0x94184830,  0x39854775,  0x10287104,  0x66266428,
  0x39184425,  0x13001603,  0x46563351,  0x14642635,  0x63849985,
  0x98010418,  0x47804121,  0x16333676,  0x31478425,  0x86326626,
  0x93619559,  0x12040031,  0x66696738,  0x43536448,  0x50480933,
  0x39439800,  0x99995428,  0x98348208,  0x88816349,  0x12883849,
  0x86160595,  0x91978618,  0x98736897,  0x49862335,  0x27167908,
  0x37244680,  0x20509154,  0x78933974,  0x66809467,  0x56357831,
  0x81769359,  0x43007719,  0x84844029,  0x40893951,  0x28607451,
  0x40754327,  0x38590847,  0x80016191,  0x12091312,  0x43863381,
  0x19122020,  0x65983651,  0x46562337,  0x50796566,  0x58302912,
  0x86442841,  0x15153383,  0x59223981,  0x92899911,  0x18299021,
  0x76436086,  0x18004300,  0x91152498,  0x73312843,  0x18179810,
  0x19705346,  0x41185803,  0x95317826,  0x83889185,  0x79021585,
  0x25809035,  0x70923979,  0x15883559,  0x54330348,  0x21751466,
  0x45812852,  0x85682270,  0x77658342,  0x29292862,  0x27050028,
  0x63649824,  0x84805019,  0x97898566,  0x97285382,  0x38685518,
  0x81640176,  0x26128203,  0x98912745,  0x50842431,  0x29918818,
  0x59808077,  0x23567727,  0x99113353,  0x37449940,  0x52115631,
  0x98456893,  0x97923160,  0x75078434,  0x33085200,  0x93862031,
  0x92868826,  0x10966949,  0x17056825,  0x45325574,  0x78820226,
  0x76430424,  0x42189278,  0x54621434,  0x45947261,  0x91077602,
  0x98914710,  0x24071053,  0x67772399,  0x74646441,  0x41502570,
  0x84686337,  0x83924035,  0x71220585,  0x24604166,  0x66206618,
  0x46312128,  0x13844653,  0x81291837,  0x82418183,  0x66447287,
  0x95429640,  0x55969466,  0x10972704,  0x46590615,  0x72562529,
  0x85910616,  0x11105056,  0x54551729,  0x71268338,  0x24868938,
  0x13125348,  0x85760789,  0x17753038,  0x69369586,  0x43771895,
  0x46384351,  0x28958170,  0x91486491,  0x61382463,  0x83532738,
  0x65391617,  0x38360331,  0x98277616,  0x55396287,  0x35252013,
  0x53410742,  0x26131485,  0x35284472,  0x67120468,  0x76431339,
  0x15977335,  0x55663154,  0x56865309,  0x17507797,  0x21282490,
  0x55462964,  0x15421202,  0x68692851,  0x30502339,  0x42208905,
  0x92041704,  0x35689361,  0x93939327,  0x15389680,  0x38661709,
  0x54346541,  0x78680662,  0x11655746,  0x81792925,  0x21915900,
  0x54248018,  0x71188007,  0x86291884,  0x22597711,  0x29758290,
  0x80505305,  0x76845098,  0x94449111,  0x71893198,  0x18276017,
  0x56177734,  0x41049540,  0x47423770,  0x95884773,  0x94019581,
  0x85779233,  0x27124323,  0x67112746,  0x32641826,  0x72114044,
  0x53060870,  0x70782077,  0x42947932,  0x46802985,  0x95629292,
  0x72513982,  0x52683071,  0x85039207,  0x70484224,  0x98918123,
  0x17446188,  0x49225428,  0x18391756,  0x96666667,  0x30498163,
  0x42563922,  0x53451747,  0x80956694,  0x81408897,  0x67717096,
  0x49451951,  0x52918471,  0x52454820,  0x31456112,  0x89960877,
  0x57315053,  0x85898414,  0x70960998,  0x17963152,  0x52439128,
  0x46750722,  0x98410926,  0x54823020,  0x95555927,  0x81049641,
  0x42968594,  0x84847020,  0x86339491,  0x35679945,  0x48575488,
  0x17661226,  0x54671317,  0x69540488,  0x85868225,  0x58095866,
  0x81303244,  0x39921181,  0x72698240,  0x54969992,  0x63458922,
  0x71913336,  0x55563533,  0x44047901,  0x61176559,  0x58597190,
  0x52276205,  0x35805623,  0x95229591,  0x94729962,  0x30930078,
  0x56794366,  0x56270239,  0x53862260,  0x96480095,  0x98549789,
  0x26393707,  0x23908631,  0x35655292,  0x67290303,  0x96443874,
  0x57304952,  0x55729911,  0x84530280,  0x64985191,  0x57576264,
  0x10671562,  0x86473664,  0x99567827,  0x42151908,  0x53210697,
  0x19973374,  0x94297788,  0x40676464,  0x46564061,  0x43826979,
  0x73131992,  0x19091801,  0x78056074,  0x77238290,  0x67342656,
  0x16455228,  0x29501560,  0x74820692,  0x86610557,  0x56184913,
  0x34894618,  0x79144197,  0x23233791,  0x41581808,  0x11540264,
  0x40973599,  0x74991225,  0x14977159,  0x36775380,  0x57479102,
  0x41336047,  0x93127691,  0x25722227,  0x79118708,  0x81356780,
  0x59514116,  0x93657167,  0x43807790,  0x35602775,  0x24767307,
  0x58861709,  0x97285922,  0x36584525,  0x98636620,  0x63159310,
  0x51247307,  0x81050823,  0x39753848,  0x11097678,  0x13906772,
  0x70340721,  0x80123527,  0x20607134,  0x48580254,  0x12405713,
  0x18721435,  0x70357650,  0x49011752,  0x58436315,  0x19922613,
  0x12704890,  0x43958424,  0x12889501,  0x49499693,  0x68468101,
  0x24817827,  0x67648773,  0x52193742,  0x84752265,  0x22165883,
  0x41791239,  0x53718628,  0x16416092,  0x96661173,  0x70447567,
  0x43288981,  0x50339468,  0x94965542,  0x59819917,  0x27442014,
  0x26009510,  0x20748540,  0x15814699,  0x81838593,  0x96356851,
  0x76070554,  0x78482991,  0x75592105,  0x19377665,  0x64036744,
  0x28699122,  0x78155526,  0x32840650,  0x13677443,  0x89637916,
  0x22158426,  0x92807118,  0x37933901,  0x13030645,  0x85026978,
  0x72540068,  0x92361723,  0x17530259,  0x37039140
};
#else
FLOAT Dither[DITHER_LENGTH] = {
  9.7607148e-001f,  8.8802242e-001f,  2.6577010e-001f,  7.2830083e-001f,  7.4557662e-001f,
  8.0745045e-001f,  8.4593113e-002f,  7.8265614e-001f,  7.1556441e-001f,  8.3341379e-001f,
  3.6030607e-001f,  9.4559055e-001f,  3.8197485e-001f,  9.7100034e-001f,  1.2308421e-001f,
  2.2535579e-001f,  2.2723188e-001f,  1.5934819e-001f,  7.9437052e-001f,  7.6216268e-002f,
  8.4277182e-001f,  2.4303903e-001f,  9.5559678e-001f,  8.5762244e-001f,  2.8075492e-001f,
  7.1061946e-001f,  3.4584071e-001f,  3.0182983e-001f,  3.7511702e-001f,  7.8086760e-001f,
  3.1128029e-002f,  3.3337902e-001f,  9.3008582e-002f,  1.3866352e-001f,  9.5423804e-002f,
  8.7911478e-001f,  5.2328720e-001f,  1.4893955e-001f,  5.4374102e-001f,  5.2763358e-001f,
  7.5637160e-001f,  6.4658006e-001f,  9.5686164e-001f,  2.7549469e-001f,  7.5854882e-001f,
  2.5050333e-001f,  1.2433981e-002f,  3.1849903e-001f,  5.7961230e-001f,  4.9809833e-001f,
  2.5444441e-001f,  4.1837551e-001f,  3.4178601e-001f,  1.8965704e-001f,  9.1970478e-001f,
  8.1985719e-001f,  3.2952180e-001f,  3.3292439e-001f,  9.7324106e-001f,  2.4361291e-001f,
  3.4634383e-001f,  2.0404594e-001f,  2.6788850e-001f,  8.5622742e-001f,  1.1582986e-001f,
  4.2435235e-001f,  9.9096700e-001f,  3.0978084e-002f,  9.0840333e-001f,  3.5032225e-001f,
  2.4343909e-001f,  1.5789398e-001f,  9.7161824e-002f,  1.8285150e-001f,  7.5227011e-002f,
  3.1320100e-002f,  8.7189446e-001f,  8.6442387e-001f,  3.0578470e-001f,  7.0623404e-001f,
  3.3354624e-001f,  9.7315616e-001f,  4.7388409e-001f,  5.2981236e-001f,  7.2295763e-001f,
  9.6608282e-001f,  6.8476917e-001f,  7.1378315e-001f,  6.7356973e-001f,  6.6079831e-001f,
  8.9957320e-001f,  8.5182872e-001f,  2.4144000e-001f,  1.4132635e-001f,  2.9084241e-001f,
  4.2497294e-001f,  4.1545920e-001f,  2.5129260e-001f,  5.8571020e-001f,  5.0004610e-001f,
  4.6823098e-001f,  2.9435594e-001f,  7.7598411e-001f,  8.1399102e-001f,  3.2061533e-001f,
  8.7753620e-001f,  8.8381911e-001f,  8.9078649e-001f,  3.6578263e-001f,  1.4134236e-001f,
  8.3925333e-001f,  8.8163688e-001f,  9.6095774e-001f,  2.7796221e-001f,  5.6959520e-002f,
  2.8024628e-001f,  6.9566411e-001f,  1.4962521e-001f,  9.8257203e-001f,  9.6963476e-001f,
  2.3701696e-001f,  5.2154279e-001f,  4.3928803e-001f,  4.8917033e-001f,  1.5934888e-001f,
  5.9283064e-001f,  7.3022728e-001f,  8.1671426e-001f,  2.7561822e-001f,  4.3285824e-001f,
  4.7957834e-002f,  4.3275472e-001f,  2.8629072e-001f,  3.7805488e-001f,  8.3645857e-001f,
  4.5419704e-003f,  1.1695641e-001f,  2.9363360e-002f,  5.6999535e-001f,  1.0347663e-001f,
  8.2193115e-001f,  4.0880100e-001f,  6.8790521e-001f,  9.5578515e-001f,  2.7113504e-001f,
  2.6483464e-001f,  9.9074283e-002f,  9.4079495e-001f,  1.9878194e-001f,  6.6077379e-001f,
  4.4103864e-001f,  9.3291022e-001f,  2.1547004e-002f,  9.9066759e-001f,  7.6158444e-001f,
  3.5844020e-001f,  5.4282568e-001f,  2.8194381e-001f,  6.3980115e-001f,  3.2223133e-001f,
  9.6172670e-001f,  5.6286233e-001f,  4.8030528e-001f,  6.3399984e-001f,  2.3932267e-003f,
  1.0568868e-001f,  9.9615669e-001f,  2.5502835e-001f,  3.4288738e-001f,  6.1094535e-001f,
  1.9956509e-001f,  1.0131644e-001f,  4.3512696e-001f,  6.4409236e-001f,  6.7879202e-001f,
  7.0911777e-001f,  2.5461827e-001f,  5.3287932e-001f,  7.1788571e-001f,  4.3357027e-001f,
  2.7933551e-001f,  9.3491471e-001f,  6.7737436e-001f,  3.3238512e-001f,  1.2558402e-003f,
  9.8981004e-002f,  3.4477313e-001f,  9.0305386e-001f,  9.7856412e-001f,  4.7483320e-001f,
  1.9442109e-001f,  2.7327416e-001f,  4.4818868e-001f,  7.9299831e-001f,  4.4413140e-001f,
  9.2247673e-001f,  3.4116637e-001f,  7.3563600e-001f,  2.1837990e-001f,  3.2956492e-001f,
  7.9242407e-001f,  8.2845592e-001f,  5.2116046e-001f,  9.9028305e-001f,  6.6529372e-001f,
  8.3018495e-001f,  3.9358082e-002f,  4.1491716e-001f,  9.8805087e-001f,  9.2457293e-001f,
  6.3790634e-001f,  4.1788816e-001f,  9.7164638e-001f,  3.3557250e-001f,  5.8964831e-001f,
  3.5101286e-001f,  4.2696088e-001f,  8.2029735e-001f,  6.8500044e-001f,  2.7739917e-002f,
  7.6818846e-001f,  5.2474762e-001f,  4.2252471e-002f,  7.6944760e-001f,  5.5090141e-001f,
  3.5059412e-001f,  3.7102037e-001f,  9.3558220e-001f,  7.9803162e-001f,  4.0913115e-001f,
  5.1082370e-001f,  4.7551270e-001f,  9.5644944e-001f,  3.0350637e-001f,  5.5178802e-001f,
  3.9436788e-001f,  9.6482748e-001f,  4.6895094e-001f,  1.6289649e-002f,  5.1046467e-002f,
  6.4037110e-002f,  4.6964184e-001f,  3.5309790e-001f,  8.0340875e-002f,  2.3091948e-001f,
  7.1128403e-001f,  7.9954082e-001f,  3.6392145e-001f,  4.6113752e-001f,  4.9707956e-001f,
  3.4653566e-002f,  4.5363008e-001f,  9.4199486e-001f,  9.3955167e-002f,  8.2628835e-001f,
  7.2202569e-001f,  7.1038958e-001f,  7.4144891e-002f,  1.8269859e-001f,  3.5963774e-001f,
  7.1298712e-001f,  9.1537835e-001f,  6.3137485e-001f,  9.2996973e-001f,  7.1778978e-001f,
  8.9724595e-002f,  9.1171931e-001f,  2.8639264e-001f,  3.3309183e-001f,  6.3547374e-001f,
  1.8726381e-001f,  4.4735938e-001f,  4.7511205e-002f,  1.9988380e-003f,  2.6316922e-001f,
  1.4683136e-001f,  1.9749139e-001f,  3.6285712e-002f,  1.8955700e-001f,  8.4323730e-001f,
  4.7465796e-001f,  4.4723664e-001f,  5.8997654e-001f,  3.3346203e-001f,  8.8041670e-001f,
  8.7124286e-001f,  7.8500813e-001f,  4.5025258e-001f,  6.3069629e-001f,  4.5325314e-001f,
  6.6829165e-001f,  4.5463159e-002f,  2.4150662e-001f,  9.3922405e-001f,  3.0927937e-001f,
  7.2904092e-001f,  1.1331287e-001f,  5.9165860e-001f,  7.6820905e-001f,  4.8483077e-001f,
  9.7361437e-001f,  6.5412401e-001f,  6.9241889e-001f,  7.1563578e-001f,  2.3953636e-001f,
  6.3068271e-001f,  5.7292244e-001f,  9.2020916e-001f,  8.7128511e-001f,  7.4846789e-001f,
  2.9444009e-001f,  2.5893852e-001f,  5.6394350e-001f,  7.2942257e-001f,  2.4390006e-001f,
  1.7770358e-001f,  6.3460260e-001f,  7.5987973e-001f,  6.4188966e-001f,  4.3057902e-001f,
  5.4338162e-002f,  9.7802540e-001f,  2.7397702e-001f,  3.7068400e-001f,  4.6249947e-001f,
  3.2306081e-001f,  7.0617479e-001f,  6.1647959e-001f,  3.8810599e-002f,  4.9492222e-001f,
  7.5242009e-001f,  1.4215033e-001f,  8.0131149e-001f,  5.1993779e-001f,  5.0479560e-001f,
  5.0701936e-001f,  2.5226850e-001f,  5.0798672e-001f,  3.6862637e-001f,  7.8382841e-001f,
  1.4995185e-001f,  2.4699721e-001f,  9.4509075e-001f,  3.8782332e-001f,  7.6567755e-001f,
  4.2031411e-001f,  4.6087513e-001f,  3.2916273e-001f,  6.2843117e-001f,  9.6612198e-001f,
  7.1767473e-002f,  3.0237418e-001f,  6.7216399e-001f,  4.3152062e-001f,  1.3376039e-001f,
  2.9241139e-001f,  3.1955321e-001f,  4.3131264e-001f,  2.0327523e-002f,  5.3284412e-001f,
  5.2829154e-001f,  5.4742679e-001f,  5.7514336e-001f,  1.1170352e-001f,  6.6459233e-001f,
  8.4072243e-001f,  7.2123010e-001f,  2.2585944e-001f,  3.9040124e-001f,  6.9127011e-001f,
  6.4027861e-001f,  1.4742222e-001f,  4.5750488e-001f,  7.7381699e-001f,  1.2414841e-001f,
  3.0097740e-001f,  3.2380236e-001f,  7.9935781e-001f,  7.4847777e-002f,  1.7188998e-001f,
  5.7698286e-001f,  2.6991481e-001f,  4.4188062e-001f,  7.1060026e-001f,  2.0807518e-001f,
  9.3968025e-001f,  2.1464266e-001f,  7.8404156e-001f,  4.9971999e-001f,  4.0573550e-001f,
  8.8558175e-003f,  2.9223597e-001f,  5.2030548e-001f,  8.7558096e-001f,  4.4361632e-001f,
  4.1167896e-001f,  7.3824048e-001f,  6.9409591e-001f,  5.6286895e-001f,  1.5313061e-001f,
  9.6787724e-001f,  4.4463441e-001f,  8.5461275e-001f,  8.8130952e-002f,  5.4107991e-002f,
  6.3435160e-001f,  5.7192077e-002f,  3.3535785e-001f,  7.8841123e-002f,  8.2555820e-001f,
  2.0695837e-001f,  1.4481952e-002f,  9.9095161e-001f,  2.4450532e-001f,  6.1774579e-001f,
  6.9745141e-001f,  5.2358575e-001f,  6.7795090e-001f,  6.6726106e-001f,  8.6797950e-001f,
  2.1260947e-001f,  3.8952118e-001f,  7.2075916e-001f,  3.7593516e-001f,  9.3990304e-001f,
  3.4346457e-001f,  5.6713160e-001f,  2.0970551e-001f,  4.3841616e-001f,  1.4578981e-001f,
  7.3804485e-001f,  4.3717914e-001f,  3.2485834e-001f,  1.6824126e-001f,  2.2592387e-001f,
  3.8577522e-001f,  3.4051594e-001f,  7.7734308e-002f,  8.5223777e-001f,  3.4821034e-001f,
  2.3294467e-001f,  1.9968361e-001f,  5.9836520e-001f,  7.4603771e-001f,  3.9715323e-001f,
  7.8706714e-001f,  5.2848182e-001f,  3.2271208e-001f,  3.2944359e-002f,  2.9931693e-001f,
  3.8780186e-001f,  3.6726640e-001f,  6.3358155e-001f,  3.5778715e-001f,  5.8766355e-001f,
  4.2331618e-001f,  2.8356048e-001f,  6.5147880e-001f,  4.6204810e-001f,  8.8500489e-001f,
  9.0462418e-001f,  9.5887278e-002f,  5.6566917e-001f,  2.8120835e-002f,  8.9588062e-001f,
  9.4997750e-001f,  2.9987106e-001f,  2.4636681e-001f,  4.6768937e-002f,  1.0824657e-001f,
  5.5476368e-001f,  7.4527283e-001f,  4.4578902e-001f,  2.7611972e-001f,  6.3929983e-001f,
  6.2175293e-001f,  6.6644861e-001f,  2.2928591e-001f,  8.8190439e-001f,  1.5669597e-001f,
  8.2242049e-001f,  3.0040752e-001f,  2.3721318e-001f,  4.0772135e-001f,  3.4880979e-001f,
  8.3757164e-002f,  5.2712469e-001f,  1.6340602e-001f,  4.3652944e-001f,  1.8923057e-001f,
  5.8527803e-001f,  2.8098971e-001f,  1.9367986e-001f,  1.2280228e-001f,  8.0383175e-003f,
  2.0705644e-001f,  3.3421503e-001f,  9.0483512e-001f,  1.7573901e-001f,  9.3879776e-001f,
  1.7643093e-002f,  8.2387186e-001f,  9.1077900e-001f,  9.5243993e-001f,  6.6764120e-001f,
  6.6039500e-002f,  5.7388132e-001f,  7.6440255e-001f,  6.6726820e-001f,  3.0862726e-001f,
  7.9916878e-001f,  3.1945772e-001f,  7.5880193e-001f,  6.8158175e-001f,  5.7632432e-001f,
  2.8828626e-001f,  9.4282456e-001f,  1.7029173e-001f,  5.3629203e-001f,  4.5899913e-001f,
  6.9133098e-001f,  3.6869178e-001f,  9.8121807e-001f,  1.0658577e-001f,  3.4882364e-001f,
  6.1824444e-001f,  7.4133683e-001f,  4.5147578e-001f,  2.0902681e-001f,  1.5559180e-001f,
  8.9970684e-001f,  3.1495695e-001f,  9.3218737e-001f,  7.6769468e-001f,  1.6886443e-001f,
  1.7341361e-001f,  8.6593427e-001f,  8.8395472e-001f,  6.8161709e-001f,  3.5364155e-001f,
  2.8341439e-001f,  4.9987523e-001f,  4.1391299e-001f,  9.5112883e-001f,  7.4574764e-001f,
  5.0620622e-002f,  6.8787337e-001f,  4.1735227e-001f,  5.1963833e-001f,  1.8886674e-001f,
  3.2891889e-001f,  9.1529145e-002f,  6.7633505e-001f,  3.9494462e-001f,  8.8899760e-001f,
  3.5425420e-001f,  3.0459817e-001f,  4.9190734e-001f,  3.1908065e-001f,  6.9447122e-001f,
  8.5743116e-002f,  9.6887278e-001f,  2.0517694e-001f,  9.0421652e-002f,  8.9811931e-001f,
  7.6300231e-001f,  3.4787318e-001f,  1.9528017e-001f,  6.5913642e-001f,  3.0492611e-002f,
  9.9370869e-001f,  3.8932885e-001f,  4.5292165e-002f,  1.3000339e-001f,  5.9669199e-001f,
  4.2983310e-001f,  8.8117975e-001f,  2.5953796e-001f,  3.5418769e-001f,  9.5753969e-001f,
  5.8877707e-001f,  1.2006447e-001f,  3.3329928e-001f,  6.4524827e-001f,  7.6285663e-001f,
  8.1903061e-001f,  6.8657266e-001f,  3.4282065e-001f,  7.0554633e-001f,  2.8849052e-001f,
  4.5552199e-001f,  7.6121692e-001f,  7.9150359e-001f,  8.1692318e-001f,  3.3403924e-001f,
  9.3755077e-001f,  8.4434691e-001f,  7.0749862e-001f,  8.1053949e-001f,  3.5077956e-001f,
  4.3573272e-001f,  5.8320201e-001f,  5.7318893e-001f,  4.8433628e-001f,  3.9639129e-001f,
  4.7217251e-001f,  9.3908859e-001f,  3.6418023e-001f,  9.2925962e-001f,  4.3529693e-001f,
  6.5875780e-001f,  6.5501994e-001f,  6.5734440e-001f,  7.1103319e-001f,  6.1765954e-001f,
  9.0478824e-001f,  6.4305543e-001f,  6.5577799e-001f,  5.6787767e-001f,  6.0686213e-001f,
  6.2706137e-001f,  2.0171961e-002f,  7.7169859e-001f,  7.2953988e-001f,  5.3597919e-001f,
  8.8983555e-001f,  1.2678645e-001f,  3.4714736e-001f,  4.6487359e-001f,  1.0110526e-001f,
  2.6312436e-001f,  3.0309148e-001f,  8.6126696e-001f,  4.3121954e-001f,  3.9484752e-001f,
  4.5905324e-001f,  8.1786259e-001f,  8.7546266e-002f,  5.8429807e-001f,  6.5364997e-001f,
  8.3666271e-001f,  6.0457111e-001f,  3.8168704e-001f,  4.0196574e-001f,  5.3707036e-001f,
  8.7928282e-001f,  6.4860294e-001f,  4.3847393e-001f,  8.3583419e-001f,  3.7541228e-001f,
  8.1084194e-001f,  6.1267503e-001f,  8.7783612e-001f,  4.0343776e-001f,  9.7165511e-002f,
  4.8821692e-002f,  9.4184830e-001f,  3.9854775e-001f,  1.0287104e-001f,  6.6266428e-001f,
  3.9184425e-001f,  1.3001603e-002f,  4.6563351e-001f,  1.4642635e-002f,  6.3849985e-001f,
  9.8010418e-001f,  4.7804121e-001f,  1.6333676e-001f,  3.1478425e-002f,  8.6326626e-001f,
  9.3619559e-001f,  1.2040031e-001f,  6.6696738e-001f,  4.3536448e-001f,  5.0480933e-001f,
  3.9439800e-001f,  9.9995428e-001f,  9.8348208e-002f,  8.8816349e-001f,  1.2883849e-001f,
  8.6160595e-001f,  9.1978618e-001f,  9.8736897e-001f,  4.9862335e-001f,  2.7167908e-001f,
  3.7244680e-001f,  2.0509154e-001f,  7.8933974e-002f,  6.6809467e-001f,  5.6357831e-001f,
  8.1769359e-001f,  4.3007719e-001f,  8.4844029e-001f,  4.0893951e-001f,  2.8607451e-001f,
  4.0754327e-001f,  3.8590847e-001f,  8.0016191e-001f,  1.2091312e-001f,  4.3863381e-001f,
  1.9122020e-001f,  6.5983651e-001f,  4.6562337e-001f,  5.0796566e-001f,  5.8302912e-001f,
  8.6442841e-001f,  1.5153383e-001f,  5.9223981e-001f,  9.2899911e-001f,  1.8299021e-001f,
  7.6436086e-001f,  1.8004300e-001f,  9.1152498e-001f,  7.3312843e-001f,  1.8179810e-001f,
  1.9705346e-001f,  4.1185803e-002f,  9.5317826e-001f,  8.3889185e-001f,  7.9021585e-001f,
  2.5809035e-001f,  7.0923979e-001f,  1.5883559e-001f,  5.4330348e-001f,  2.1751466e-001f,
  4.5812852e-001f,  8.5682270e-001f,  7.7658342e-002f,  2.9292862e-001f,  2.7050028e-001f,
  6.3649824e-002f,  8.4805019e-002f,  9.7898566e-001f,  9.7285382e-001f,  3.8685518e-001f,
  8.1640176e-002f,  2.6128203e-002f,  9.8912745e-001f,  5.0842431e-001f,  2.9918818e-001f,
  5.9808077e-001f,  2.3567727e-001f,  9.9113353e-001f,  3.7449940e-002f,  5.2115631e-001f,
  9.8456893e-001f,  9.7923160e-001f,  7.5078434e-001f,  3.3085200e-001f,  9.3862031e-001f,
  9.2868826e-001f,  1.0966949e-001f,  1.7056825e-001f,  4.5325574e-001f,  7.8820226e-001f,
  7.6430424e-001f,  4.2189278e-001f,  5.4621434e-001f,  4.5947261e-001f,  9.1077602e-002f,
  9.8914710e-001f,  2.4071053e-001f,  6.7772399e-001f,  7.4646441e-002f,  4.1502570e-001f,
  8.4686337e-001f,  8.3924035e-001f,  7.1220585e-002f,  2.4604166e-001f,  6.6206618e-001f,
  4.6312128e-001f,  1.3844653e-001f,  8.1291837e-001f,  8.2418183e-001f,  6.6447287e-001f,
  9.5429640e-001f,  5.5969466e-001f,  1.0972704e-001f,  4.6590615e-001f,  7.2562529e-001f,
  8.5910616e-001f,  1.1105056e-001f,  5.4551729e-001f,  7.1268338e-001f,  2.4868938e-001f,
  1.3125348e-001f,  8.5760789e-001f,  1.7753038e-001f,  6.9369586e-001f,  4.3771895e-001f,
  4.6384351e-001f,  2.8958170e-001f,  9.1486491e-001f,  6.1382463e-001f,  8.3532738e-001f,
  6.5391617e-001f,  3.8360331e-001f,  9.8277616e-001f,  5.5396287e-001f,  3.5252013e-001f,
  5.3410742e-002f,  2.6131485e-001f,  3.5284472e-001f,  6.7120468e-001f,  7.6431339e-001f,
  1.5977335e-001f,  5.5663154e-001f,  5.6865309e-002f,  1.7507797e-001f,  2.1282490e-001f,
  5.5462964e-001f,  1.5421202e-001f,  6.8692851e-001f,  3.0502339e-001f,  4.2208905e-001f,
  9.2041704e-001f,  3.5689361e-001f,  9.3939327e-001f,  1.5389680e-001f,  3.8661709e-001f,
  5.4346541e-001f,  7.8680662e-001f,  1.1655746e-001f,  8.1792925e-001f,  2.1915900e-001f,
  5.4248018e-001f,  7.1188007e-001f,  8.6291884e-001f,  2.2597711e-002f,  2.9758290e-001f,
  8.0505305e-001f,  7.6845098e-001f,  9.4449111e-001f,  7.1893198e-001f,  1.8276017e-002f,
  5.6177734e-001f,  4.1049540e-004f,  4.7423770e-002f,  9.5884773e-001f,  9.4019581e-001f,
  8.5779233e-001f,  2.7124323e-002f,  6.7112746e-001f,  3.2641826e-001f,  7.2114044e-001f,
  5.3060870e-001f,  7.0782077e-001f,  4.2947932e-002f,  4.6802985e-001f,  9.5629292e-001f,
  7.2513982e-001f,  5.2683071e-001f,  8.5039207e-001f,  7.0484224e-002f,  9.8918123e-001f,
  1.7446188e-001f,  4.9225428e-001f,  1.8391756e-001f,  9.6666667e-002f,  3.0498163e-001f,
  4.2563922e-001f,  5.3451747e-001f,  8.0956694e-002f,  8.1408897e-001f,  6.7717096e-001f,
  4.9451951e-001f,  5.2918471e-001f,  5.2454820e-001f,  3.1456112e-001f,  8.9960877e-001f,
  5.7315053e-001f,  8.5898414e-001f,  7.0960998e-001f,  1.7963152e-001f,  5.2439128e-002f,
  4.6750722e-001f,  9.8410926e-001f,  5.4823020e-001f,  9.5555927e-001f,  8.1049641e-001f,
  4.2968594e-001f,  8.4847020e-001f,  8.6339491e-001f,  3.5679945e-001f,  4.8575488e-001f,
  1.7661226e-001f,  5.4671317e-001f,  6.9540488e-002f,  8.5868225e-001f,  5.8095866e-001f,
  8.1303244e-002f,  3.9921181e-001f,  7.2698240e-001f,  5.4969992e-003f,  6.3458922e-001f,
  7.1913336e-001f,  5.5563533e-001f,  4.4047901e-001f,  6.1176559e-001f,  5.8597190e-001f,
  5.2276205e-001f,  3.5805623e-001f,  9.5229591e-001f,  9.4729962e-001f,  3.0930078e-001f,
  5.6794366e-002f,  5.6270239e-001f,  5.3862260e-001f,  9.6480095e-002f,  9.8549789e-001f,
  2.6393707e-001f,  2.3908631e-001f,  3.5655292e-001f,  6.7290303e-001f,  9.6443874e-001f,
  5.7304952e-001f,  5.5729911e-001f,  8.4530280e-001f,  6.4985191e-001f,  5.7576264e-001f,
  1.0671562e-001f,  8.6473664e-001f,  9.9567827e-001f,  4.2151908e-001f,  5.3210697e-002f,
  1.9973374e-001f,  9.4297788e-001f,  4.0676464e-001f,  4.6564061e-001f,  4.3826979e-001f,
  7.3131992e-001f,  1.9091801e-001f,  7.8056074e-003f,  7.7238290e-001f,  6.7342656e-002f,
  1.6455228e-001f,  2.9501560e-001f,  7.4820692e-001f,  8.6610557e-001f,  5.6184913e-001f,
  3.4894618e-001f,  7.9144197e-001f,  2.3233791e-001f,  4.1581808e-001f,  1.1540264e-001f,
  4.0973599e-001f,  7.4991225e-001f,  1.4977159e-001f,  3.6775380e-001f,  5.7479102e-002f,
  4.1336047e-001f,  9.3127691e-001f,  2.5722227e-001f,  7.9118708e-001f,  8.1356780e-001f,
  5.9514116e-001f,  9.3657167e-001f,  4.3807790e-001f,  3.5602775e-001f,  2.4767307e-001f,
  5.8861709e-001f,  9.7285922e-001f,  3.6584525e-001f,  9.8636620e-001f,  6.3159310e-001f,
  5.1247307e-001f,  8.1050823e-001f,  3.9753848e-001f,  1.1097678e-002f,  1.3906772e-001f,
  7.0340721e-002f,  8.0123527e-002f,  2.0607134e-001f,  4.8580254e-001f,  1.2405713e-001f,
  1.8721435e-001f,  7.0357650e-001f,  4.9011752e-001f,  5.8436315e-001f,  1.9922613e-001f,
  1.2704890e-001f,  4.3958424e-001f,  1.2889501e-001f,  4.9499693e-001f,  6.8468101e-001f,
  2.4817827e-002f,  6.7648773e-001f,  5.2193742e-001f,  8.4752265e-001f,  2.2165883e-001f,
  4.1791239e-001f,  5.3718628e-001f,  1.6416092e-001f,  9.6661173e-001f,  7.0447567e-001f,
  4.3288981e-001f,  5.0339468e-001f,  9.4965542e-001f,  5.9819917e-001f,  2.7442014e-001f,
  2.6009510e-001f,  2.0748540e-001f,  1.5814699e-001f,  8.1838593e-001f,  9.6356851e-001f,
  7.6070554e-001f,  7.8482991e-001f,  7.5592105e-002f,  1.9377665e-001f,  6.4036744e-001f,
  2.8699122e-001f,  7.8155526e-001f,  3.2840650e-001f,  1.3677443e-001f,  8.9637916e-001f,
  2.2158426e-001f,  9.2807118e-001f,  3.7933901e-001f,  1.3030645e-002f,  8.5026978e-001f,
  7.2540068e-001f,  9.2361723e-002f,  1.7530259e-001f,  3.7039140e-002f
};
#endif // not INTEGER_DITHER

ULONG DitherIndex = 0;

extern ULONG gEnableShortHrtf;
#ifdef REALTIME_THREAD
extern ULONG gDisableRealTime;
extern ULONG gMaxNumMixBuffers;
#endif
extern ULONG gBuildPartialMdls ;


static const SHORT SilenceBuffer[] = {
                                       0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,
                                       0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,
                                       0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,
                                       0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,
                                       0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,
                                       0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,
                                       0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,
                                       0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,
                                       0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,
                                       0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,
                                       0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,
                                       0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,
                                       0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,
                                       0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,
                                       0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,
                                       0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,
                                       0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,
                                       0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,
                                       0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,
                                       0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,
                                       0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,
                                       0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,
                                       0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,
                                       0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,
                                       0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,
                                       0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,
                                       0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,
                                       0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,
                                       0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,
                                       0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,
                                       0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,
                                       0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,
                                       0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,
                                       0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,
                                       0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,
                                       0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,
                                       0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,
                                       0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,
                                       0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,
                                       0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,
                                       0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,
                                       0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,
                                       0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,
                                       0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,
                                       0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,
                                       0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,
                                       0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,
                                       0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,
                                       0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,
                                       0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,
                                       0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,
                                       0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,
                                       0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,
                                       0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,
                                       0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,
                                       0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,
                                       0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,
                                       0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,
                                       0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,
                                       0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,
                                       0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,
                                       0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,
                                       0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,
                                       0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0
                                     };

static const UCHAR Silence8[] = {
                                  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
                                  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
                                  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
                                  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
                                  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
                                  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
                                  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
                                  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
                                  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
                                  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
                                  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
                                  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
                                  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
                                  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
                                  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
                                  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
                                  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
                                  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
                                  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
                                  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
                                  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
                                  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
                                  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
                                  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
                                  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
                                  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
                                  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
                                  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
                                  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
                                  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
                                  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
                                  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
                                  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
                                  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
                                  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
                                  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
                                  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
                                  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
                                  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
                                  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
                                  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
                                  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
                                  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
                                  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
                                  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
                                  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
                                  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
                                  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
                                  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
                                  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
                                  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
                                  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
                                  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
                                  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
                                  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
                                  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
                                  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
                                  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
                                  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
                                  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
                                  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
                                  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
                                  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
                                  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
                                  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
                                  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
                                  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
                                  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
                                  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
                                  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
                                  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
                                  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
                                  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
                                  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
                                  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
                                  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
                                  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
                                  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
                                  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
                                  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
                                  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
                                  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
                                  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
                                  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
                                  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
                                  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
                                  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
                                  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
                                  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
                                  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
                                  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
                                  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
                                  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
                                  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
                                  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
                                  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
                                  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
                                  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
                                  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
                                  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
                                  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
                                  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
                                  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
                                  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
                                  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
                                  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
                                  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
                                  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
                                  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
                                  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
                                  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
                                  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
                                  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
                                  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
                                  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
                                  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
                                  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
                                  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
                                  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
                                  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
                                  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
                                  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
                                  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
                                  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
                                  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
                                  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
                                  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
                                  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80
                                };

static const KSPROPERTY_ITEM PinConnectionHandlers[] =
{
   DEFINE_KSPROPERTY_ITEM (
       KSPROPERTY_CONNECTION_STATE,                     // idProperty
       PinStateHandler,                                 // pfnGetHandler
       sizeof( KSPROPERTY ),                            // cbMinSetPropertyInput
       sizeof( ULONG ),                                 // cbMinSetDataOutput
       PinStateHandler,                                 // pfnSetHandler
       0,                                               // Values
       0,                                               // RelationsCount
       NULL,                                            // Relations
       NULL,                                            // SupportHandler
       0                                                // SerializedSize
   ),

   DEFINE_KSPROPERTY_ITEM_CONNECTION_ALLOCATORFRAMING(GetAllocatorFraming),

   DEFINE_KSPROPERTY_ITEM (
       KSPROPERTY_CONNECTION_DATAFORMAT,                // idProperty
       NULL,                                 // pfnGetHandler
       sizeof( KSPROPERTY ),                            // cbMinSetPropertyInput
       sizeof( KSDATAFORMAT_WAVEFORMATEX ),                                 // cbMinSetDataOutput
       MxSetFormat,                                 // pfnSetHandler
       0,                                               // Values
       0,                                               // RelationsCount
       NULL,                                            // Relations
       NULL,                                            // SupportHandler
       0                                                // SerializedSize
   )

};

static const KSPROPERTY_ITEM WaveQueuedPropHandlers[] =
{
   DEFINE_KSPROPERTY_ITEM (
       KSPROPERTY_WAVE_QUEUED_POSITION,                 // idProperty
       MxGetWavePosition,                               // pfnGetHandler
       sizeof(KSPROPERTY),                              // cbMinGetPropertyInput
       sizeof(KSTIME),                                  // cbMinGetDataInput
       MxSetWavePosition,                               // pfnSetHandler
       0,                                               // Values
       0,                                               // RelationsCount
       NULL,                                            // Relations
       NULL,                                            // SupportHandler
       0                                                // SerializedSize
   )
};

KSPROPERTY_STEPPING_LONG SteppingLongVolume[] = {
    (65536/2),					// SteppingDelta
    0,						// Reserved
    {						// Bounds
	(-96 * 65536),		            	    // SignedMinimum
	0					    // SignedMaximum
    }
};

KSPROPERTY_MEMBERSLIST MemberListVolume = {
    {						// MembersHeader
	KSPROPERTY_MEMBER_STEPPEDRANGES,	    // MembersFlags
	sizeof(KSPROPERTY_STEPPING_LONG),	    // MembersSize
	SIZEOF_ARRAY(SteppingLongVolume),           // MembersCount
	0,			    	    	    // Flags
    },
    SteppingLongVolume				// Members
};

KSPROPERTY_VALUES PropertyValuesVolume = {
    {						// PropTypeSet
	STATIC_KSPROPTYPESETID_General,
        VT_I4,
        0
    },
    1,						// MembersListCount
    &MemberListVolume				// MembersList
};

static const KSPROPERTY_ITEM AudioPropHandlers[] =
{
   DEFINE_KSPROPERTY_ITEM (
       KSPROPERTY_AUDIO_VOLUMELEVEL,                    // idProperty
       MxGetVolumeLevel,                                // pfnGetHandler
       sizeof(KSNODEPROPERTY_AUDIO_CHANNEL),            // cbMinGetPropertyInput
       sizeof(LONG),                                    // cbMinGetDataInput
       MxSetVolumeLevel,                                // pfnSetHandler
       &PropertyValuesVolume,                            // Values
       0,                                               // RelationsCount
       NULL,                                            // Relations
       NULL,                                            // SupportHandler
       0                                                // SerializedSize
   ),

   DEFINE_KSPROPERTY_ITEM (
       KSPROPERTY_AUDIO_SAMPLING_RATE,                  // idProperty
       MxGetSamplingRate,                               // pfnGetHandler
       sizeof(KSNODEPROPERTY),                          // cbMinGetPropertyInput
       sizeof(ULONG),                                   // cbMinGetDataInput
       MxSetSamplingRate,                               // pfnSetHandler
       0,                                               // Values
       0,                                               // RelationsCount
       NULL,                                            // Relations
       NULL,                                            // SupportHandler
       0                                                // SerializedSize
   ),

   DEFINE_KSPROPERTY_ITEM (
       KSPROPERTY_AUDIO_DYNAMIC_SAMPLING_RATE,          // idProperty
       MxGetDynSamplingRate,                            // pfnGetHandler
       sizeof(KSNODEPROPERTY),                          // cbMinGetPropertyInput
       sizeof(BOOLEAN),                                 // cbMinGetDataInput
       MxSetDynSamplingRate,                            // pfnSetHandler
       0,                                               // Values
       0,                                               // RelationsCount
       NULL,                                            // Relations
       NULL,                                            // SupportHandler
       0                                                // SerializedSize
   ),

   DEFINE_KSPROPERTY_ITEM (
       KSPROPERTY_AUDIO_QUALITY,                        // idProperty
       MxGetAudioQuality,                               // pfnGetHandler
       sizeof(KSNODEPROPERTY),                          // cbMinGetPropertyInput
       sizeof(ULONG),                                   // cbMinGetDataInput
       MxSetAudioQuality,                               // pfnSetHandler
       0,                                               // Values
       0,                                               // RelationsCount
       NULL,                                            // Relations
       NULL,                                            // SupportHandler
       0                                                // SerializedSize
   ),

   DEFINE_KSPROPERTY_ITEM (
       KSPROPERTY_AUDIO_POSITION,                       // idProperty
       MxGetCurrentPosition,                            // pfnGetHandler
       sizeof(KSPROPERTY),                              // cbMinGetPropertyInput
       sizeof(KSAUDIO_POSITION),                        // cbMinGetDataInput
       MxSetCurrentPosition,                            // pfnSetHandler
       0,                                               // Values
       0,                                               // RelationsCount
       NULL,                                            // Relations
       NULL,                                            // SupportHandler
       0                                                // SerializedSize
   ),

   DEFINE_KSPROPERTY_ITEM (
       KSPROPERTY_AUDIO_MIX_LEVEL_TABLE,                // idProperty
       MxGetMixLvlTable,                                // pfnGetHandler
       sizeof(KSNODEPROPERTY),                          // cbMinGetPropertyInput
       sizeof(KSAUDIO_MIXLEVEL),                        // cbMinGetDataInput
       MxSetMixLvlTable,                                // pfnSetHandler
       0,                                               // Values
       0,                                               // RelationsCount
       NULL,                                            // Relations
       NULL,                                            // SupportHandler
       0                                                // SerializedSize
   ),

   DEFINE_KSPROPERTY_ITEM (
       KSPROPERTY_AUDIO_MIX_LEVEL_CAPS,                 // idProperty
       MxGetMixLvlCaps,                                 // pfnGetHandler
       sizeof(KSNODEPROPERTY),                          // cbMinGetPropertyInput
       sizeof(ULONG) + sizeof(ULONG),                        // cbMinGetDataInput
       MxSetMixLvlCaps,                                 // pfnSetHandler
       0,                                               // Values
       0,                                               // RelationsCount
       NULL,                                            // Relations
       NULL,                                            // SupportHandler
       0                                                // SerializedSize
   ),
   DEFINE_KSPROPERTY_ITEM (
       KSPROPERTY_AUDIO_CPU_RESOURCES,                  // idProperty
       MxGetCpuResources,                               // pfnGetHandler
       sizeof(KSNODEPROPERTY),                          // cbMinGetPropertyInput
       sizeof(ULONG),                                   // cbMinGetDataInput
       NULL,                                            // pfnSetHandler - read only
       0,                                               // Values
       0,                                               // RelationsCount
       NULL,                                            // Relations
       NULL,                                            // SupportHandler
       0                                                // SerializedSize
   ),
   DEFINE_KSPROPERTY_ITEM (
       KSPROPERTY_AUDIO_LATENCY,                        // idProperty
       MxGetMaxLatency,                                 // pfnGetHandler
       sizeof(KSPROPERTY),                              // cbMinGetPropertyInput
       sizeof(KSTIME),                                  // cbMinGetDataInput
       NULL,                                            // pfnSetHandler - read only
       0,                                               // Values
       0,                                               // RelationsCount
       NULL,                                            // Relations
       NULL,                                            // SupportHandler
       0                                                // SerializedSize
   ),
       
   DEFINE_KSPROPERTY_ITEM (
       KSPROPERTY_AUDIO_SURROUND_ENCODE,                // idProperty
       MxGetSurroundEncode,                             // pfnGetHandler
       sizeof(KSNODEPROPERTY),                          // cbMinGetPropertyInput
       sizeof(BOOL),                                    // cbMinGetDataInput
       MxSetSurroundEncode,                             // pfnSetHandler
       0,                                               // Values
       0,                                               // RelationsCount
       NULL,                                            // Relations
       NULL,                                            // SupportHandler
       0                                                // SerializedSize
   ),

   DEFINE_KSPROPERTY_ITEM (
       KSPROPERTY_AUDIO_CHANNEL_CONFIG,                 // idProperty
       MxGetChannelConfig,                              // pfnGetHandler
       sizeof(KSNODEPROPERTY),                          // cbMinGetPropertyInput
       sizeof(ULONG),                                   // cbMinGetDataInput
       NULL,                                            // pfnSetHandler
       0,                                               // Values
       0,                                               // RelationsCount
       NULL,                                            // Relations
       NULL,                                            // SupportHandler
       0                                                // SerializedSize
   )

};

static const KSPROPERTY_ITEM Itd3dPropHandlers[] =
{
    DEFINE_KSPROPERTY_ITEM (
        KSPROPERTY_ITD3D_PARAMS,                        // idProperty
        NULL,                                           // pfnGetHandler
        sizeof(KSNODEPROPERTY),                         // cbMinGetPropertyInput
        sizeof(ULONG),                                  // cbMinGetDataInput
        MxSetItd3dParams,                               // pfnSetHandler
        0,                                              // Values
        0,                                              // RelationsCount
        NULL,                                           // Relations
        NULL,                                           // SupportHandler
        0                                               // SerializedSize
    )

};

static const KSPROPERTY_ITEM Iir3dPropHandlers[] =
{
    DEFINE_KSPROPERTY_ITEM (
        KSPROPERTY_HRTF3D_PARAMS,                        // idProperty
        NULL,                                           // pfnGetHandler
        sizeof(KSNODEPROPERTY),                         // cbMinGetPropertyInput
        sizeof(ULONG),                                  // cbMinGetDataInput
        MxSetIir3dParams,                               // pfnSetHandler
        0,                                              // Values
        0,                                              // RelationsCount
        NULL,                                           // Relations
        NULL,                                           // SupportHandler
        0                                               // SerializedSize
    ),
    DEFINE_KSPROPERTY_ITEM (
        KSPROPERTY_HRTF3D_INITIALIZE,                    // idProperty
        NULL,                                           // pfnGetHandler
        sizeof(KSNODEPROPERTY),                         // cbMinGetPropertyInput
        sizeof(ULONG),                                  // cbMinGetDataInput
        MxIir3dInitialize,                              // pfnSetHandler
        0,                                              // Values
        0,                                              // RelationsCount
        NULL,                                           // Relations
        NULL,                                           // SupportHandler
        0                                               // SerializedSize
    ),
    DEFINE_KSPROPERTY_ITEM (
        KSPROPERTY_HRTF3D_FILTER_FORMAT,                 // idProperty
        MxGetFilterMethodAndCoeffFormat,                // pfnGetHandler
        sizeof(KSNODEPROPERTY),                         // cbMinGetPropertyInput
        sizeof(ULONG),                                  // cbMinGetDataInput
        NULL,                                           // pfnSetHandler
        0,                                              // Values
        0,                                              // RelationsCount
        NULL,                                           // Relations
        NULL,                                           // SupportHandler
        0                                               // SerializedSize
    )


};

DEFINE_KSPROPERTY_TABLE(PinPropertyTableStream)
{
    DEFINE_KSPROPERTY_ITEM_STREAM_MASTERCLOCK(
        PinPropertyStreamMasterClock,
        PinPropertyStreamMasterClock )
};

#ifdef DRM_KMIXER
NTSTATUS DrmUpdateMixedContent
(
 IN PFILTER_INSTANCE pFilterInstance
);

NTSTATUS DrmAudioStream_SetContentId
(
 IN PIRP	pIrp,
 IN PKSPROPERTY	pProperty,
 IN PVOID	pvData
);

static const KSPROPERTY_ITEM DrmAudioStreamPropHandlers[] =
{
    DEFINE_KSPROPERTY_ITEM (
        KSPROPERTY_DRMAUDIOSTREAM_CONTENTID,            // idProperty
	NULL,                                           // pfnGetHandler
	sizeof(KSPROPERTY),                             // cbMinGetPropertyInput
	sizeof(ULONG),                                  // cbMinGetDataInput
	DrmAudioStream_SetContentId,                    // pfnSetHandler
	0,                                              // Values
	0,                                              // RelationsCount
	NULL,                                           // Relations
	NULL,                                           // SupportHandler
	0                                               // SerializedSize
    )
};
#endif

static const KSPROPERTY_SET Properties[] =
{
   {
      &KSPROPSETID_Connection,
      SIZEOF_ARRAY( PinConnectionHandlers ),
      (PVOID) PinConnectionHandlers
   },
   {
      &KSPROPSETID_Wave_Queued,
      SIZEOF_ARRAY( WaveQueuedPropHandlers ),
      (PVOID) WaveQueuedPropHandlers
   },
   {
      &KSPROPSETID_Audio,
      SIZEOF_ARRAY( AudioPropHandlers ),
      (PVOID) AudioPropHandlers
   },
   {
      &KSPROPSETID_Itd3d,
      SIZEOF_ARRAY( Itd3dPropHandlers ),
      (PVOID) Itd3dPropHandlers
   },
   {
      &KSPROPSETID_Hrtf3d,
      SIZEOF_ARRAY( Iir3dPropHandlers ),
      (PVOID) Iir3dPropHandlers
   },
   {
      &KSPROPSETID_Stream,
      SIZEOF_ARRAY(PinPropertyTableStream),
      PinPropertyTableStream
   }
#ifdef DRM_KMIXER
   ,
   {
      &KSPROPSETID_DrmAudioStream,
      SIZEOF_ARRAY(DrmAudioStreamPropHandlers),
      DrmAudioStreamPropHandlers
   }
#endif
};

DEFINE_KSMETHOD_TABLE(MixerMethodHandlers)
{
        DEFINE_KSMETHOD_ITEM ( KSMETHOD_WAVE_QUEUED_BREAKLOOP,
                                  KSMETHOD_TYPE_WRITE,
                                  MxBreakLoop,
                                  0,
                                  0,
                                  NULL )
} ;

static const KSMETHOD_SET Methods[] =
{
   {
      &KSMETHODSETID_Wave_Queued,
      SIZEOF_ARRAY( MixerMethodHandlers ),
      (PVOID) MixerMethodHandlers
   }
};

DEFINE_KSEVENT_TABLE( MxPinEventTable )
{
    DEFINE_KSEVENT_ITEM( KSEVENT_LOOPEDSTREAMING_POSITION,
                         sizeof( LOOPEDSTREAMING_POSITION_EVENT_DATA),
                         sizeof(POSITION_EVENT_ENTRY)-sizeof(KSEVENT_ENTRY),
                         (PFNKSADDEVENT)MxAddPositionEvent,
                         NULL,
                         NULL )
} ;

DEFINE_KSEVENT_TABLE( MxConnectionEventTable )
{
    DEFINE_KSEVENT_ITEM( KSEVENT_CONNECTION_ENDOFSTREAM,
                         sizeof(KSEVENTDATA),
                         sizeof(ENDOFSTREAM_EVENT_ENTRY)-sizeof(KSEVENT_ENTRY),
                         (PFNKSADDEVENT)MxAddEndOfStreamEvent,
                         NULL,
                         NULL )
};

DEFINE_KSEVENT_SET_TABLE( MxEvents )
{
    DEFINE_KSEVENT_SET( &KSEVENTSETID_LoopedStreaming,
                        SIZEOF_ARRAY( MxPinEventTable ),
                        MxPinEventTable ),
    DEFINE_KSEVENT_SET( &KSEVENTSETID_Connection,
                        SIZEOF_ARRAY( MxConnectionEventTable ),
                        MxConnectionEventTable )
};

//
// Clock Related data structures
//
static const WCHAR ClockTypeName[] = KSSTRING_Clock ;

DEFINE_KSCREATE_DISPATCH_TABLE ( PinCreateHandlers )
{
    DEFINE_KSCREATE_ITEM (MxClockDispatchCreate, ClockTypeName, 0),
};

//
// Globals for debugging (&controlling) retail version
//

DWORD   AverageTicksPerBuffer = 0, AverageFrequency = 0;
DWORD   AverageTicksPerMix = 0, AverageTicksForFirstBuffer = 0;
DWORD   AverageTicksPerChangeSrc = 0;
PMIXER_SRC_INSTANCE gpSrc = NULL;

extern ULONG    gPreferredQuality;
extern DWORD    CaptureQuality;

FLOAT   MaxCpuUsage = 0.5;

ULONG gNumLowLatencyIos = 0 ;
ULONG gClipCount = 0 ;


//===========================================================================
//===========================================================================

PVOID
GetSystemAddressForMdlWithFailFlag
(
    PMDL pMdl
)
{
    PVOID   pAddress;
    CSHORT  OldFlags;
    
    OldFlags = (pMdl->MdlFlags & MDL_MAPPING_CAN_FAIL);
    pMdl->MdlFlags |= MDL_MAPPING_CAN_FAIL;
    
    pAddress = MmGetSystemAddressForMdl( pMdl ) ;
    
    pMdl->MdlFlags &= ~(MDL_MAPPING_CAN_FAIL);
    pMdl->MdlFlags |= OldFlags;

    return pAddress;
}


NTSTATUS
GetAllocatorFraming(
    IN PIRP                     Irp,
    IN PKSPROPERTY              Property,
    OUT PKSALLOCATOR_FRAMING    Framing
    )
/*++

Routine Description:

    Returns the allocator framing preferences for this object. For this stream
    the size is chosen based on PAGE_SIZE and block alignment of the data.

Arguments:

    Irp -
        Device control Irp.

    Property -
        Specific property request.

    Framing -
        The place in which to put the allocator preferences.

Return:

    Returns STATUS_SUCCESS.
--*/

{
    PIO_STACK_LOCATION      pIrpStack;

    pIrpStack = IoGetCurrentIrpStackLocation(Irp);
    Framing->RequirementsFlags =
        KSALLOCATOR_REQUIREMENTF_SYSTEM_MEMORY |
        KSALLOCATOR_REQUIREMENTF_PREFERENCES_ONLY;
    Framing->PoolType = PagedPool;
    Framing->Frames = 2;
    Framing->FrameSize = PAGE_SIZE;
    Framing->FileAlignment = PAGE_SIZE - 1;
    Framing->Reserved = 0;
    Irp->IoStatus.Information = sizeof(*Framing);
    return STATUS_SUCCESS;
}

NTSTATUS
PinPropertyStreamMasterClock
(
    IN PIRP         pIrp,
    IN PKSPROPERTY  pProperty,
    IN OUT PHANDLE  pClockHandle
)
{
    NTSTATUS                Status;
    PIO_STACK_LOCATION      pIrpStack;
    PMIXER_SINK_INSTANCE    pMixerSink ;

    pIrpStack = IoGetCurrentIrpStackLocation( pIrp );
    pMixerSink = pIrpStack->FileObject->FsContext ;

    if (pProperty->Flags & KSPROPERTY_TYPE_GET) {
        //
        // This is a query to see if we support the creation of
        // clocks.  The returned handle is always NULL, but we
        // signal that we support the creation of clocks by
        // returning STATUS_SUCCESS.
        //
        *pClockHandle = NULL;
    }
    Status = STATUS_SUCCESS;
    return Status;
}


NTSTATUS PinDispatchCreate
(
    IN PDEVICE_OBJECT   pDeviceObject,
    IN PIRP             pIrp
)
{
    PKSPIN_CONNECT              pConnect;
    PFILE_OBJECT                pFileObject;
    NTSTATUS                    Status;
    PIO_STACK_LOCATION          pIrpStack;
    PFILTER_INSTANCE            pFilterInstance;
    PKSDATAFORMAT               pAudioFormat ;

    DENY_USERMODE_ACCESS( pIrp, TRUE );

    pIrpStack = IoGetCurrentIrpStackLocation( pIrp );
    AverageTicksPerBuffer = 0;
    AverageTicksPerMix = 0;

    if (NT_SUCCESS( Status = KsValidateConnectRequest( pIrp,
                                                     SIZEOF_ARRAY( PinDescs ),
                                                     PinDescs,
                                                     &pConnect )))
    {
        pFileObject = pIrpStack->FileObject->RelatedFileObject ;
        pFilterInstance = (PFILTER_INSTANCE) pFileObject->FsContext;
        pAudioFormat = (PKSDATAFORMAT) (pConnect+1) ;


        // Assume we will succeed.  Reference the file object up front.
        // If we fail to create a pin, we will release this reference.
        ObReferenceObject ( pFileObject ) ;


        // NB: This is order dependant!  We must connect the source first
        //     and then the sink.  This code uses this assumption to
        //     set the appropriate file object information.

        // Lock out all other CREATEs & CLOSEs

//        KeWaitForSingleObject ( &pFilterInstance->ControlMutex,
//                                Executive,
//                                KernelMode,
//                                FALSE,
//                                NULL ) ;

        switch (pConnect->PinId)
        {
            case PIN_ID_WAVEOUT_SOURCE:
            case PIN_ID_WAVEIN_SOURCE:
                Status = CreateSourcePin(pIrp,
                                         pConnect,
                                         pFileObject,
                                         pFilterInstance,
                                         pAudioFormat);
                break;
            case PIN_ID_WAVEOUT_SINK:
            case PIN_ID_WAVEIN_SINK:
                Status = CreateSinkPin(pIrp,
                                       pConnect,
                                       pFileObject,
                                       pFilterInstance,
                                       pAudioFormat);
                break;

            default:
                Status = STATUS_INVALID_DEVICE_REQUEST;
                break;
        }

        if (!NT_SUCCESS( Status )) {
            // Pin creation failed, release our reference on the parent file object.
            ObDereferenceObject ( pFileObject ) ;
        }

//        KeReleaseMutex ( &pFilterInstance->ControlMutex, FALSE ) ;
    }
    pIrp->IoStatus.Status = Status;
    IoCompleteRequest( pIrp, IO_AUD_INCREMENT );

    return Status;
}

NTSTATUS CreateSourcePin
(
    PIRP               pIrp,
    PKSPIN_CONNECT     pConnect,
    PFILE_OBJECT       pFileObject,
    PFILTER_INSTANCE   pFilterInstance,
    PKSDATAFORMAT      pAudioFormat
)
{
    NTSTATUS            Status;
    ULONG               MixBufferRate, i, WriteBufferSize, siz ;
    PMIXER_SOURCE_INSTANCE pMixerSource = NULL;
    PUCHAR              pMem ;
    PIO_STACK_LOCATION  pIrpStack;
    PWAVEFORMATEX       pWaveFormatEx;
    BOOL                fObRefSuccess = FALSE;

    pIrpStack = IoGetCurrentIrpStackLocation( pIrp );

    _DbgPrintF( DEBUGLVL_VERBOSE, ("create source, pin %d", pConnect->PinId) ) ;


    // We only allow 1 source pin on our filter.  Make sure we have properly
    // indicated that.
    ASSERT(pFilterInstance->LocalPinInstances[pConnect->PinId].PossibleCount==1);

    // Assume success.  Decrement instance count if we fail to complete the pin creation.
    if ((ULONG)InterlockedIncrement(&pFilterInstance->LocalPinInstances[pConnect->PinId].CurrentCount) >
        pFilterInstance->LocalPinInstances[pConnect->PinId].PossibleCount ) {
        Status = STATUS_INVALID_DEVICE_REQUEST;
        goto Exit ;
    }


    // This list better be empty, since we only allow 1 source pin to be
    // created at a time.
    ASSERT( IsListEmpty(&pFilterInstance->SourceConnectionList) );


    if (!NT_SUCCESS(Status = ObReferenceObjectByHandle( pConnect->PinToHandle,
                                        GENERIC_READ | GENERIC_WRITE,
                                        NULL,
                                        KernelMode,
                                        &pFilterInstance->pNextFileObject,
                                        NULL ))) {
        goto Exit;
    }

    fObRefSuccess = TRUE;

    pFilterInstance->hNextFile = pConnect->PinToHandle ;

#ifdef REALTIME_THREAD

    ASSERT ( pFilterInstance->RealTimeThread == NULL );

    if ( (!gDisableRealTime) && (STATUS_SUCCESS == RtVersion(NULL))) {

        if (pFilterInstance->pfnRtAudioGetPosition==NULL) {
            GetRtPosFunction(pFilterInstance);
        }

        if (pFilterInstance->pfnRtAudioGetPosition!=NULL &&
            pConnect->PinId != PIN_ID_WAVEIN_SOURCE) {

            pFilterInstance->fPauseMix++;
            pFilterInstance->Startup=TRUE;

            RtCreateThread((ULONGLONG)MIXBUFFERDURATION*MSEC, (ULONGLONG)MIXBUFFERDURATION*250*USEC, USESFLOAT|USESMMX, 2, (RTTHREADPROC)RtMix, pFilterInstance, &pFilterInstance->RealTimeThread);

            if (pFilterInstance->RealTimeThread) {
                pFilterInstance->MaxNumMixBuffers = DEFAULT_RTMAXNUMMIXBUFFERS;
                pFilterInstance->MinNumMixBuffers = DEFAULT_RTMAXNUMMIXBUFFERS;
                pFilterInstance->StartNumMixBuffers = DEFAULT_RTMAXNUMMIXBUFFERS;
                pFilterInstance->CurrentNumMixBuffers = DEFAULT_RTMAXNUMMIXBUFFERS;
            }
            else {
                pFilterInstance->fPauseMix--;
                pFilterInstance->Startup=FALSE;
            }
        }
    }

#endif

    pMixerSource = (PMIXER_SOURCE_INSTANCE) ExAllocatePoolWithTag( NonPagedPool, sizeof(MIXER_SOURCE_INSTANCE), 'XIMK' );
    if (!pMixerSource)
        {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Exit;
        }

    RtlZeroMemory ( pMixerSource, sizeof ( MIXER_SOURCE_INSTANCE ) ) ;

    //
    // Allocate WriteContext & Source BlockInfo arrays
    //
    if (pConnect->PinId == PIN_ID_WAVEIN_SOURCE) {
        pFilterInstance->StartNumMixBuffers = pFilterInstance->MaxNumMixBuffers;
        pFilterInstance->MinNumMixBuffers = pFilterInstance->MaxNumMixBuffers;
    }

    pMixerSource->WriteContext = ExAllocatePoolWithTag(
                                   NonPagedPool,
                                   sizeof(MIXER_WRITE_CONTEXT)*MAXNUMMIXBUFFERS,
                                   'XIMK' ) ;
    if ( pMixerSource->WriteContext ) {
        RtlZeroMemory( pMixerSource->WriteContext,
                        (sizeof(MIXER_WRITE_CONTEXT)*MAXNUMMIXBUFFERS) ) ;
    }

    pMixerSource->BlockInfo = ExAllocatePoolWithTag(
                                   NonPagedPool,
                                   sizeof(SOURCEMIX_BLOCK_INFO)*MAXNUMMIXBUFFERS,
                                   'XIMK' ) ;

    if ( pMixerSource->BlockInfo ) {
        RtlZeroMemory( pMixerSource->BlockInfo,
                        (sizeof(SOURCEMIX_BLOCK_INFO)*MAXNUMMIXBUFFERS) ) ;
    }

    if ( (pMixerSource->WriteContext == NULL) ||
         (pMixerSource->BlockInfo == NULL) ) {
        Status = STATUS_INSUFFICIENT_RESOURCES ;
        goto Exit ;
    }

    if (pFilterInstance->CriticalWorkerObject == NULL) {
        Status = KsRegisterWorker(CriticalWorkQueue, &pFilterInstance->CriticalWorkerObject );
        if (!NT_SUCCESS( Status )) {
            goto Exit;
        }     
    }

    if (pFilterInstance->DelayedWorkerObject  == NULL) {
        Status = KsRegisterWorker(CriticalWorkQueue, &pFilterInstance->DelayedWorkerObject );
        if (!NT_SUCCESS( Status )) {
            goto Exit;
        }
    }

    if ( IsEqualGUID( &(pAudioFormat->Specifier), &KSDATAFORMAT_SPECIFIER_WAVEFORMATEX ) )
    {
        pWaveFormatEx = &(((KSDATAFORMAT_WAVEFORMATEX *)pAudioFormat)->WaveFormatEx);
    }
    else if ( IsEqualGUID( &(pAudioFormat->Specifier), &KSDATAFORMAT_SPECIFIER_DSOUND ) )
    {
        pWaveFormatEx = &(((KSDATAFORMAT_DSOUND *)pAudioFormat)->BufferDesc.WaveFormatEx);
    }
    else
    {
        _DbgPrintF( DEBUGLVL_ERROR, ("Invalid Specifier Guid") );
        Status = STATUS_INVALID_PARAMETER;
        goto Exit;
    }

    if ( STATUS_INVALID_PARAMETER == (Status=VerifyWaveFormatEx( pWaveFormatEx ) ))
    {
        goto Exit;
    }

    if (pWaveFormatEx->wFormatTag != WAVE_FORMAT_EXTENSIBLE) {
        RtlCopyMemory ( &pMixerSource->WaveFormatEx, pWaveFormatEx, sizeof ( WAVEFORMATEX ) ) ;

        // We assume that left and right are known.
        pMixerSource->WaveFormatExt.dwChannelMask = (SPEAKER_FRONT_LEFT | SPEAKER_FRONT_RIGHT);
    } else {
        RtlCopyMemory ( &pMixerSource->WaveFormatEx, pWaveFormatEx, sizeof ( WAVEFORMATEXTENSIBLE ) ) ;
    }
#ifdef NEW_SURROUND
    if (pFilterInstance->fSurroundEncode &&
        pConnect->PinId == PIN_ID_WAVEOUT_SOURCE &&
        pWaveFormatEx->nChannels == 2) {
        pMixerSource->fSurround = TRUE;
        pWaveFormatEx = &pMixerSource->WaveFormatEx;
        pWaveFormatEx->nChannels = 4;
        pMixerSource->WaveFormatExt.dwChannelMask = (SPEAKER_FRONT_LEFT | SPEAKER_FRONT_RIGHT | SPEAKER_FRONT_CENTER | SPEAKER_BACK_CENTER);
    }             
#endif    
    MixBufferRate = pWaveFormatEx->nSamplesPerSec ;

#ifdef REALTIME_THREAD
    ASSERT(pMixerSource->RtMixIndex == 0);
    ASSERT(pMixerSource->RtWriteIndex == 0);
#endif

    pMixerSource->OriginalSampleRate = MixBufferRate;
    pMixerSource->cmsMixBufferSize = MIXBUFFERDURATION;
    pMixerSource->csMixBufferSize = (MAX_SAMPLING_RATE * MIXBUFFERDURATION)/1000 + 1 ;
    pMixerSource->cbMixBufferSize = pMixerSource->csMixBufferSize *
                                    MIXBUFFERSAMPLESIZE *
                                    pWaveFormatEx->nChannels ;
#ifdef NEW_SURROUND
    if (pMixerSource->fSurround) {
        pMixerSource->BytesPerSample = (pWaveFormatEx->wBitsPerSample/8) * 2;
    } else    
#endif    
    pMixerSource->BytesPerSample = (pWaveFormatEx->wBitsPerSample/8) * pWaveFormatEx->nChannels ;

    // In order to make it so that splitter has frames that match on both top
    // and bottom, we calculate our buffer size for capture differently from
    // playback.  We do NOT add the extra sample that is used during playback
    // to send an extra sample every so often while playing sample rates that
    // have a non integral number of samples per ms so that we get exact
    // buffer size matches with usbaudio.  Rather since on capture the buffer
    // size will be filled by EVERYONE usbaudio included, we set the size
    // to match the calculations made by most drivers.  This will allow
    // splitter to copy from a frame size that matches the frame size it is
    // copying to.  That will help prevent jitter in the rate that capture data
    // is sent up to user mode.  Since splitter will always have input and output
    // frames that match in size at least for portcls and kmixer.
    if (pConnect->PinId == PIN_ID_WAVEIN_SOURCE) {
        pMixerSource->csMixBufferSize = (MixBufferRate * MIXBUFFERDURATION)/1000 ;
        pMixerSource->cbMixBufferSize = pMixerSource->csMixBufferSize *
                                    pMixerSource->BytesPerSample ;
    }
    WriteBufferSize = pMixerSource->cbMixBufferSize;

    pMem = ExAllocatePoolWithTag ( NonPagedPool, PAGE_SIZE * (
#ifndef REALTIME_THREAD
                (((MAXNUMMIXBUFFERS * ((WriteBufferSize + (MIXBUFFERALIGNMENT - 1)) / MIXBUFFERALIGNMENT) * MIXBUFFERALIGNMENT) + (PAGE_SIZE - 1)) / PAGE_SIZE) +
#endif
                (((MAXNUMMIXBUFFERS * (sizeof(KSSTREAM_HEADER) + (sizeof(PVOID) - 1))) + (PAGE_SIZE - 1)) / PAGE_SIZE)),
                'XIMK' ) ;


    pMixerSource->pMixBuffer = (PLONG) pMem ;

    if ( !pMixerSource->pMixBuffer ) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Exit;
    }

    // Allocate space for our temporary output buffer
    siz = (MAX_SAMPLING_RATE * MIXBUFFERDURATION / (STOPBAND_FACTOR/2))/1000 + 1;

    // Scale so that it covers the worst case input buffer (before SRC)
    siz = siz * (STOPBAND_FACTOR) + 1;

    // Plan for the maximum number of channels we've seen so far
    siz *= (pWaveFormatEx->nChannels * sizeof(FLOAT));

    pMixerSource->pScratchBuffer = ExAllocatePoolWithTag(PagedPool, siz, 'XIMK');
    pMixerSource->pScratch2 = ExAllocatePoolWithTag(PagedPool, siz, 'XIMK');
    pMixerSource->pFloatMixBuffer = ExAllocatePoolWithTag(PagedPool, siz, 'XIMK');
    pMixerSource->MaxChannels = pWaveFormatEx->nChannels;

    if (!pMixerSource->pScratchBuffer || !pMixerSource->pScratch2 || !pMixerSource->pFloatMixBuffer) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Exit;
    }

#ifdef _X86_
    if (MmxPresent()) {
        // Fill-in all the function pointers to use MMX.
        RtlCopyMemory(&ConvertFunction[0],
                      &MmxConvertFunction[0],
                      MAXNUMCONVERTFUNCTIONS * sizeof(PFNStage));

        RtlCopyMemory(&SrcFunction[0],
                      &MmxSrcFunction[0],
                      MAXNUMSRCFUNCTIONS * sizeof(PFNStage));
    }
#endif

    Status = KsAllocateObjectHeader ( &pMixerSource->Header.ObjectHeader,
                                0,
                                NULL,
                                pIrp,
                                (PKSDISPATCH_TABLE)&PinDispatchTable ) ;
    if (!NT_SUCCESS(Status) ) {
        goto Exit ;
    }

    pMixerSource->Header.PinId = pConnect->PinId;
    pMixerSource->Header.pFilterFileObject = pFileObject;
    pMixerSource->LeftOverFraction = 0 ;
    pMixerSource->MasterVolumeLevel = 0;

    InitializeListHead ( &pMixerSource->WriteQueue ) ;

#if DBG
    for ( i = 0; i < STOPBAND_FACTOR; i++) {
        pMixerSource->pSrcBuffer[0][i]=INVALID_POINTER;
        pMixerSource->pSrcBuffer[1][i]=INVALID_POINTER;
        pMixerSource->pSrcBuffer[2][i]=INVALID_POINTER;
        pMixerSource->pSrcBuffer[3][i]=INVALID_POINTER;
    }
#endif

    pFilterInstance->pNextDevice = IoGetRelatedDeviceObject(pFilterInstance->pNextFileObject);

    // First get pointers to all the stream headers.  We do this so that we
    // can align all of the data blocks so they all start on page boundaries.
    // That minimizes the number of mappings that the hardware must make for
    // each buffer of data that we send down.
    for ( i = 0; i < MAXNUMMIXBUFFERS; i++ ) {
        pMixerSource->WriteContext[i].StreamHeader = (PKSSTREAM_HEADER) pMem ;
        pMem += sizeof(KSSTREAM_HEADER) ;
        (ULONG_PTR)pMem+=(sizeof(PVOID) - 1);
        (ULONG_PTR)pMem&=~(sizeof(PVOID) - 1);
    }

    // Align pMem to a page boundary.  Ensures first data block is page aligned.
    (ULONG_PTR)pMem+=(PAGE_SIZE - 1);
    (ULONG_PTR)pMem&=~(PAGE_SIZE - 1);

    // Now get pointers to the data blocks and fill in the stream headers.
    for ( i = 0; i < MAXNUMMIXBUFFERS; i++ ) {
        pMixerSource->WriteContext[i].StreamHeader->Size = sizeof(KSSTREAM_HEADER);
        pMixerSource->WriteContext[i].StreamHeader->TypeSpecificFlags = 0;

#ifdef REALTIME_THREAD
        pMixerSource->WriteContext[i].StreamHeader->Data = ExAllocatePoolWithTag(NonPagedPool,
                                                            ((WriteBufferSize+(MAXNUMMIXBUFFERS<<4)+4095)/4096)*4096,
                                                            'XIMK');

        if (!pMixerSource->WriteContext[i].StreamHeader->Data) {
            _DbgPrintF( DEBUGLVL_ERROR, ("kmixer: pins.c StreamHeader->Data memory allocation failed") );
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Exit;
        }

        (ULONG_PTR)(pMixerSource->WriteContext[i].StreamHeader->Data)+=(i<<4);
#else
        pMixerSource->WriteContext[i].StreamHeader->Data = pMem ;
#endif
        pMixerSource->WriteContext[i].StreamHeader->FrameExtent = WriteBufferSize ;        
        pMixerSource->WriteContext[i].StreamHeader->DataUsed = WriteBufferSize ;            
#ifndef REALTIME_THREAD
        pMem += WriteBufferSize ;
        (ULONG_PTR)pMem+=(MIXBUFFERALIGNMENT - 1);
        (ULONG_PTR)pMem&=~(MIXBUFFERALIGNMENT - 1);
#endif
        pMixerSource->WriteContext[i].pFilterInstance = pFilterInstance ;
        pMixerSource->WriteContext[i].pIrp = IoAllocateIrp ( pFilterInstance->pNextDevice->StackSize,
                                                FALSE ) ;
        if (!pMixerSource->WriteContext[i].pIrp) {
            _DbgPrintF( DEBUGLVL_ERROR, ("kmixer: pins.c IoAllocateIrp failed") );
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Exit;
        }

        pMixerSource->WriteContext[i].pMdl = IoAllocateMdl (
                                    pMixerSource->WriteContext[i].StreamHeader->Data,
                                    WriteBufferSize,
                                    FALSE,
                                    FALSE,
                                    pMixerSource->WriteContext[i].pIrp ) ;

        if (!pMixerSource->WriteContext[i].pMdl) {
            _DbgPrintF( DEBUGLVL_ERROR, ("kmixer: pins.c IoAllocateMdl failed") );
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Exit;
        }

        pMixerSource->WriteContext[i].InUse = WRITE_CONTEXT_UNAVAILABLE ;
        if (pConnect->PinId == PIN_ID_WAVEIN_SOURCE) {
            pMixerSource->WriteContext[i].fReading = TRUE;
        } else {
            pMixerSource->WriteContext[i].fReading = FALSE;
        }

        MmCreateMdl( pMixerSource->WriteContext[i].pMdl,
                     pMixerSource->WriteContext[i].StreamHeader->Data,
                     WriteBufferSize );
    }

    ASSERT(pFilterInstance->NumPendingIos==0);
    ASSERT(pFilterInstance->NumBuffersToMix==0);
    pFilterInstance->CurrentNumMixBuffers = STARTNUMMIXBUFFERS ;
    for ( i = 0; i < pFilterInstance->CurrentNumMixBuffers; i++ ) {
        pMixerSource->WriteContext[i].InUse = WRITE_CONTEXT_FREE ;
    }

    pMixerSource->csMixBufferSize = (MixBufferRate * MIXBUFFERDURATION)/1000 + 1 ;

    pMixerSource->nSinkPins = 0;

#ifdef LOG_TO_FILE
    if (fLogToFile) {
        FileOpenRoutine(pFilterInstance, TRUE);
        FileCloseRoutine(pFilterInstance);
        if (pWaveFormatEx->wFormatTag != WAVE_FORMAT_EXTENSIBLE) {
            FileIoRoutine(pFilterInstance,&WaveHeader[0],20);
            FileIoRoutine(pFilterInstance,pWaveFormatEx,16);
            FileIoRoutine(pFilterInstance,&WaveHeader[36],8);
        } else {
            FileIoRoutine(pFilterInstance,&WaveHeader[0],16);
            siz = sizeof ( WAVEFORMATEXTENSIBLE );
            FileIoRoutine(pFilterInstance,&siz,sizeof(ULONG));
            FileIoRoutine(pFilterInstance,pWaveFormatEx,sizeof ( WAVEFORMATEXTENSIBLE ));
            FileIoRoutine(pFilterInstance,&WaveHeader[36],8);
        }
    }
#endif

    GenerateSpeakerMapping();

    pMixerSource->FileObject = pIrpStack->FileObject ;
    pIrpStack->FileObject->FsContext = pMixerSource;
    pIrpStack->DeviceObject->StackSize = pFilterInstance->pNextDevice->StackSize ;
    InsertTailList ( &pFilterInstance->SourceConnectionList, &pMixerSource->Header.NextInstance ) ;

Exit:
    if (!NT_SUCCESS(Status)) {

        if (pMixerSource) {

            if ( pMixerSource->BlockInfo ) {
                ExFreePool( pMixerSource->BlockInfo ) ;
            }

            if ( pMixerSource->Header.ObjectHeader ) {
                KsFreeObjectHeader ( pMixerSource->Header.ObjectHeader );
            }

            if ( pFilterInstance->CriticalWorkerObject ) {
                KsUnregisterWorker( pFilterInstance->CriticalWorkerObject );
                pFilterInstance->CriticalWorkerObject = NULL ;
            }

            if ( pFilterInstance->DelayedWorkerObject ) {
                KsUnregisterWorker( pFilterInstance->DelayedWorkerObject );
                pFilterInstance->DelayedWorkerObject = NULL ;
            }

            if (pMixerSource->pScratchBuffer)
                ExFreePool( pMixerSource->pScratchBuffer );

            if (pMixerSource->pScratch2)
                ExFreePool( pMixerSource->pScratch2 );

            if (pMixerSource->pFloatMixBuffer)
                ExFreePool( pMixerSource->pFloatMixBuffer );

            if ( pMixerSource->WriteContext ) {

                for ( i = 0; i < MAXNUMMIXBUFFERS; i++ ) {
                    if (pMixerSource->WriteContext[i].pMdl) {
                        IoFreeMdl ( pMixerSource->WriteContext[i].pMdl ) ;
                    }

#ifdef REALTIME_THREAD
                    if (pMixerSource->WriteContext[i].StreamHeader &&
                        pMixerSource->WriteContext[i].StreamHeader->Data) {
                        (ULONG_PTR)(pMixerSource->WriteContext[i].StreamHeader->Data)-=(i<<4);
                        ExFreePool( pMixerSource->WriteContext[i].StreamHeader->Data );
                    }
#endif

                    if (pMixerSource->WriteContext[i].pIrp) {
                        IoFreeIrp ( pMixerSource->WriteContext[i].pIrp ) ;
                    }
                }
        
                ExFreePool( pMixerSource->WriteContext ) ;
            }

            if (pMixerSource->pMixBuffer)
                ExFreePool( pMixerSource->pMixBuffer );

            ExFreePool( pMixerSource );
        }

        if (fObRefSuccess) {
            ObDereferenceObject( pFilterInstance->pNextFileObject );
        }

        InterlockedDecrement(&pFilterInstance->LocalPinInstances[pConnect->PinId].CurrentCount);

    }

    return Status;
}

NTSTATUS CreateSinkPin
(
    PIRP                pIrp,
    PKSPIN_CONNECT      pConnect,
    PFILE_OBJECT        pFileObject,
    PFILTER_INSTANCE    pFilterInstance,
    PKSDATAFORMAT       pAudioFormat
)
{
    NTSTATUS    Status = STATUS_SUCCESS;
    ULONG                   i, siz ;
    ULONG                   InChannels, OutChannels, MinChannels, MaxChannels ;
    PMIXER_SOURCE_INSTANCE      pMixerSource;
    PMIXER_SINK_INSTANCE        pMixerSink = NULL;
    PLIST_ENTRY                 ple ;
//    KIRQL                       OldIrql ;
    PIO_STACK_LOCATION  pIrpStack;
    PWAVEFORMATEX pWaveFormatEx;
    PKSDSOUND_BUFFERDESC pDsBufferDesc;
    PKSDATAFORMAT_DSOUND        pDsAudioFormat;
    PITDCONTEXT pItdContextLeft;
    PITDCONTEXT pItdContextRight;
    PLONG pTemp, pTemp2;
    PFLOAT pTemp3;
    ULONG InMask, OutMask;
    BOOL fObRefSuccess = FALSE;


    pIrpStack = IoGetCurrentIrpStackLocation( pIrp );
    if ( IsListEmpty ( &pFilterInstance->SourceConnectionList ) ) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Exit;
    }

    // NOTE: assumes only one source instance
    ple = pFilterInstance->SourceConnectionList.Flink ;
    pMixerSource = (PMIXER_SOURCE_INSTANCE) CONTAINING_RECORD ( ple, MIXER_INSTHDR, NextInstance ) ;

    // Reference the source pin.
    ObReferenceObject ( pMixerSource->FileObject ) ;
    fObRefSuccess = TRUE;

    if (pConnect->PinId != (pMixerSource->Header.PinId+1)) {
        Status = STATUS_INVALID_PARAMETER ;
        goto Exit;
    }

    if ( IsEqualGUID( &(pAudioFormat->Specifier), &KSDATAFORMAT_SPECIFIER_WAVEFORMATEX ) )
        {
            pWaveFormatEx = &(((KSDATAFORMAT_WAVEFORMATEX *)pAudioFormat)->WaveFormatEx);
        }
    else if ( IsEqualGUID( &(pAudioFormat->Specifier), &KSDATAFORMAT_SPECIFIER_DSOUND ) )
        {
            pDsAudioFormat = (KSDATAFORMAT_DSOUND *)pAudioFormat;
            pDsBufferDesc = &(pDsAudioFormat->BufferDesc);
            pWaveFormatEx = &(pDsBufferDesc->WaveFormatEx);
            if (pDsBufferDesc->Flags & KSDSOUND_BUFFER_LOCHARDWARE) {
                _DbgPrintF( DEBUGLVL_VERBOSE, ("Invalid Dsound Buffer Location") );
                Status = STATUS_INVALID_PARAMETER;
                goto Exit;
            }
        }
    else
        {
            _DbgPrintF( DEBUGLVL_ERROR, ("Invalid Specifier Guid") );
            Status = STATUS_INVALID_PARAMETER;
            goto Exit;
        }

    if ( STATUS_INVALID_PARAMETER == (Status=VerifyWaveFormatEx( pWaveFormatEx ) ))
    {
        goto Exit;
    }

    if (IsEqualGUID( &(pConnect->Interface.Set), &KSINTERFACESETID_Standard )) {
        if (pConnect->Interface.Id != KSINTERFACE_STANDARD_STREAMING &&
            pConnect->Interface.Id != KSINTERFACE_STANDARD_LOOPED_STREAMING) {
            // We do not support this interface ID
            Status = STATUS_INVALID_PARAMETER;
            goto Exit;
        }
    } else if (IsEqualGUID( &(pConnect->Interface.Set), &KSINTERFACESETID_Media )) {
        if (pConnect->Interface.Id != KSINTERFACE_MEDIA_WAVE_QUEUED) {
            // We do not support this interface ID
            Status = STATUS_INVALID_PARAMETER;
            goto Exit;
        }
    }

    _DbgPrintF( DEBUGLVL_VERBOSE, ("create sink, pin %d", pConnect->PinId) ) ;
    pMixerSink = (PMIXER_SINK_INSTANCE) ExAllocatePoolWithTag( NonPagedPool, sizeof( MIXER_SINK_INSTANCE ), 'XIMK' );
    if (!pMixerSink)
        {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Exit;
        }

    RtlZeroMemory ( pMixerSink, sizeof ( MIXER_SINK_INSTANCE ) ) ;
    if (pWaveFormatEx->wFormatTag != WAVE_FORMAT_EXTENSIBLE) {
        RtlCopyMemory ( &pMixerSink->WaveFormatEx, pWaveFormatEx, sizeof ( WAVEFORMATEX ) ) ;
        
        // We assume that left and right are known.
        pMixerSink->WaveFormatExt.dwChannelMask = (SPEAKER_FRONT_LEFT | SPEAKER_FRONT_RIGHT);
    } else {
        RtlCopyMemory ( &pMixerSink->WaveFormatEx, pWaveFormatEx, sizeof ( WAVEFORMATEXTENSIBLE ) ) ;
    }

    pMixerSink->pInfo = (PMIXER_SINK_INFO) ExAllocatePoolWithTag( PagedPool, sizeof( MIXER_SINK_INFO ), 'XIMK' );
    if (!pMixerSink->pInfo)
        {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Exit;
        }


    RtlZeroMemory ( pMixerSink->pInfo, sizeof ( MIXER_SINK_INFO ) ) ;

    //
    // Allocate Sink BlockInfo Array
    //

    pMixerSink->pInfo->BlockInfo = ExAllocatePoolWithTag(
                                       PagedPool,
                                       sizeof(SINKMIX_BLOCK_INFO)*MAXNUMMIXBUFFERS,
                                       'XIMK' ) ;

    if ( pMixerSink->pInfo->BlockInfo == NULL ) {
        Status = STATUS_INSUFFICIENT_RESOURCES ;
        goto Exit ;
    }
    else {
        RtlZeroMemory( pMixerSink->pInfo->BlockInfo,
                       (sizeof(SINKMIX_BLOCK_INFO)*MAXNUMMIXBUFFERS) ) ;
    }

    pMixerSink->OriginalSampleRate = pMixerSink->WaveFormatEx.nSamplesPerSec;
    pMixerSink->pInfo->IntermediateSamplingRate = pMixerSink->WaveFormatEx.nSamplesPerSec;

    Status = KsAllocateObjectHeader ( &pMixerSink->Header.ObjectHeader,
                             SIZEOF_ARRAY(PinCreateHandlers),
                             PinCreateHandlers,
                             pIrp,
                             (PKSDISPATCH_TABLE)&PinDispatchTable ) ;

    if (!NT_SUCCESS(Status) ) {
        goto Exit ;
    }                             
    pMixerSink->Header.PinId = pConnect->PinId;
    pMixerSink->Header.pFilterFileObject = pFileObject;

    InitializeListHead ( &pMixerSink->WriteQueue ) ;       // IRP queue
    InitializeListHead ( &pMixerSink->CancelQueue ) ;      // Temp Queue for Cancel

    // Corresponding Locks for each queue

    KeInitializeSpinLock ( &pMixerSink->WriteSpinLock ) ;
    KeInitializeSpinLock ( &pMixerSink->CancelSpinLock ) ;

    pMixerSink->csNextSampleOffset = 0 ;
    pMixerSink->SinkState = KSSTATE_STOP ;
    pMixerSink->SinkStatus = 0 ;
    pMixerSink->UpdateTimeBase = TRUE ;
    pMixerSink->BlockInfoIndex = 0 ;
    pMixerSink->BytesPerSample = (pWaveFormatEx->wBitsPerSample/8) *
                                        pWaveFormatEx->nChannels ;

    pMixerSink->InterfaceId = pConnect->Interface.Id ;

    InitializeListHead ( &pMixerSink->EventQueue ) ;
    KeInitializeSpinLock ( &pMixerSink->EventLock ) ;

    pMixerSink->pfnGetBlock = WvGetNextBlock;
    if ( pMixerSink->InterfaceId == KSINTERFACE_STANDARD_STREAMING )
        {
        pMixerSink->pfnGetBlock = StGetNextBlock ;
        }
    else if ( pMixerSink->InterfaceId == KSINTERFACE_STANDARD_LOOPED_STREAMING )
        {
        pMixerSink->pfnGetBlock = LoopStGetNextBlock ;
        }

    pMixerSink->CurTime.Time = 0 ;
    pMixerSink->CurTime.Numerator = 10000000 ; // 1 sec in 100 ns
    pMixerSink->CurTime.Denominator = pMixerSink->WaveFormatEx.nSamplesPerSec ;

    InChannels = pMixerSink->WaveFormatEx.nChannels;
    OutChannels = pMixerSource->WaveFormatEx.nChannels;
    pMixerSink->nOutputChannels = OutChannels;
    InMask = pMixerSink->WaveFormatExt.dwChannelMask;
    OutMask = pMixerSource->WaveFormatExt.dwChannelMask;
    if (pMixerSink->Header.PinId == PIN_ID_WAVEIN_SINK) {
#ifdef REALTIME_THREAD
        ASSERT( pFilterInstance->RealTimeThread == NULL );
#endif
        OutChannels = InChannels;
        InChannels = pMixerSink->nOutputChannels;
        pMixerSink->nOutputChannels = OutChannels;
        InMask = OutMask;
        OutMask = pMixerSink->WaveFormatExt.dwChannelMask;
    }

    // Pick a filter size based on the current CPU we're using...
    if ( IsEqualGUID( &(pAudioFormat->Specifier), &KSDATAFORMAT_SPECIFIER_DSOUND ) ) {
        pMixerSink->pInfo->Src.Quality = KSAUDIO_QUALITY_PC;
    } else if (pConnect->PinId == PIN_ID_WAVEIN_SINK) {
        pMixerSink->pInfo->Src.Quality = CaptureQuality;
    } else {
        pMixerSink->pInfo->Src.Quality = gPreferredQuality;
    }

    // Initialize the SRC context
    Status = InitializeSRC( &pMixerSink->pInfo->Src,
		       pMixerSink->WaveFormatEx.nSamplesPerSec,
		       pMixerSource->WaveFormatEx.nSamplesPerSec,
		       OutChannels,
		       pMixerSource->csMixBufferSize);
    if (Status != STATUS_SUCCESS) {
        _DbgPrintF( DEBUGLVL_VERBOSE,("kmixer:pins.c SRC init fail"));
        goto Exit;
    }

    if (pConnect->PinId == PIN_ID_WAVEIN_SINK) {
        siz = SrcInputBufferSize(&pMixerSink->pInfo->Src,
                                            pMixerSource->csMixBufferSize);
        Status = InitializeSRC( &pMixerSink->pInfo->Src,
    		       pMixerSource->WaveFormatEx.nSamplesPerSec,
    		       pMixerSink->WaveFormatEx.nSamplesPerSec,
    		       OutChannels,
    		       siz);
        if (Status != STATUS_SUCCESS) {
            _DbgPrintF( DEBUGLVL_VERBOSE,("kmixer:pins.c SRC init fail"));
            goto Exit;
        }
    }

    if ( IsEqualGUID( &(pAudioFormat->Specifier), &KSDATAFORMAT_SPECIFIER_DSOUND ) )
    {
    // Initialize 3D
    if ( IsEqualGUID( &(pAudioFormat->Specifier), &KSDATAFORMAT_SPECIFIER_DSOUND ) )
        {
        if ( pDsBufferDesc->Control & KSDSOUND_BUFFER_CTRL_3D )
            {

            // Must be a mono or stereo source to use 3D.
            if ( 2 < pMixerSink->WaveFormatEx.nChannels )
                {
                _DbgPrintF( DEBUGLVL_ERROR, ("3D source is not a mono or stereo buffer") );
                Status = STATUS_INVALID_PARAMETER;
                goto Exit;
                }

            pMixerSink->fCreate3D = TRUE;
            pMixerSink->fEnable3D = TRUE;

            if ( pDsBufferDesc->Control & KSDSOUND_BUFFER_CTRL_HRTF_3D )
                {

                pMixerSink->fUseIir3d = TRUE;

                if (gEnableShortHrtf) {
                    pMixerSink->FilterMethod = CASCADE_FORM;
                    pMixerSink->CoeffFormat = SHORT_COEFF;
                    // Create the localizer object
                    Status = ShortLocalizerCreate(&pMixerSink->pShortLocalizer);

                    if (!NT_SUCCESS(Status))
                        {
                        _DbgPrintF( DEBUGLVL_VERBOSE,("kmixer:pins.c Short Localizer alloc fail"));
                        goto Exit;
                        }
                } else {
                    pMixerSink->FilterMethod = DIRECT_FORM;
                    pMixerSink->CoeffFormat = FLOAT_COEFF;
                    // Create the localizer object
                    Status = FloatLocalizerCreate(&pMixerSink->pFloatLocalizer);

                    if (!NT_SUCCESS(Status))
                        {
                        _DbgPrintF( DEBUGLVL_VERBOSE,("kmixer:pins.c Float Localizer alloc fail"));
                        goto Exit;
                        }
                }

                pMixerSink->pNewIir3dParams = (PKSDS3D_HRTF_PARAMS_MSG)ExAllocatePoolWithTag( PagedPool, sizeof(KSDS3D_HRTF_PARAMS_MSG) + DEFAULT_MAX_NUM_FLOAT_IIR3D_COEFFS*sizeof(FLOAT), 'XIMK' );

                if (NULL == pMixerSink->pNewIir3dParams)
                    {
                    _DbgPrintF( DEBUGLVL_VERBOSE,("kmixer:pins.c IIR context alloc fail"));
                    Status = STATUS_INSUFFICIENT_RESOURCES;
                    goto Exit;
                    }

                RtlZeroMemory( pMixerSink->pNewIir3dParams, sizeof(KSDS3D_HRTF_PARAMS_MSG) + DEFAULT_MAX_NUM_FLOAT_IIR3D_COEFFS*sizeof(FLOAT));
                pMixerSink->pNewIir3dParams->Size = sizeof(KSDS3D_HRTF_PARAMS_MSG) + DEFAULT_MAX_NUM_FLOAT_IIR3D_COEFFS*sizeof(FLOAT);
                }
            else
                {
                    pMixerSink->fUseIir3d = FALSE;

                    // Create the filter contexts
                    pMixerSink->pItdContextLeft = (PITDCONTEXT)ExAllocatePoolWithTag( PagedPool, sizeof(ITDCONTEXT), 'XIMK' );
                    if (NULL == pMixerSink->pItdContextLeft) {
                        _DbgPrintF( DEBUGLVL_VERBOSE,("kmixer:pins.c FIR context alloc fail"));
                        Status = STATUS_INSUFFICIENT_RESOURCES;
                        goto Exit;
                    }
                    RtlZeroMemory( pMixerSink->pItdContextLeft, sizeof( ITDCONTEXT ) );

                    pMixerSink->pItdContextRight = (PITDCONTEXT)ExAllocatePoolWithTag( PagedPool, sizeof(ITDCONTEXT), 'XIMK' );
                    if (NULL == pMixerSink->pItdContextRight) {
                        _DbgPrintF( DEBUGLVL_VERBOSE,("kmixer:pins.c FIR context alloc fail"));
                        Status = STATUS_INSUFFICIENT_RESOURCES;
                        goto Exit;
                    }
                    RtlZeroMemory( pMixerSink->pItdContextRight, sizeof( ITDCONTEXT ) );

                    pMixerSink->pNewItd3dParamsLeft = (PKSDS3D_ITD_PARAMS)ExAllocatePoolWithTag( PagedPool, sizeof(KSDS3D_ITD_PARAMS), 'XIMK' );
                    if (NULL == pMixerSink->pNewItd3dParamsLeft ){
                        _DbgPrintF( DEBUGLVL_VERBOSE,("kmixer:pins.c ITD_PARAMS context alloc fail"));
                        Status = STATUS_INSUFFICIENT_RESOURCES;
                        goto Exit;
                    }
                    RtlZeroMemory( pMixerSink->pNewItd3dParamsLeft, sizeof( KSDS3D_ITD_PARAMS ) );
                    
                    pMixerSink->pNewItd3dParamsRight = (PKSDS3D_ITD_PARAMS)ExAllocatePoolWithTag( PagedPool, sizeof(KSDS3D_ITD_PARAMS), 'XIMK' );

                    if (NULL == pMixerSink->pNewItd3dParamsRight ) {
                        _DbgPrintF( DEBUGLVL_VERBOSE,("kmixer:pins.c ITD_PARAMS context alloc fail"));
                        Status = STATUS_INSUFFICIENT_RESOURCES;
                        goto Exit;
                    }
                    RtlZeroMemory( pMixerSink->pNewItd3dParamsRight, sizeof( KSDS3D_ITD_PARAMS ) );

                    // Create the filter caches
                    Status = Itd3dFilterPrepare( pMixerSink->pItdContextLeft, 0 );
                    if (Status != STATUS_SUCCESS) {
                        _DbgPrintF( DEBUGLVL_VERBOSE,("kmixer:pins.c 3d left prep fail"));
                        goto Exit;
                    }
                    Itd3dFilterClear( pMixerSink->pItdContextLeft );

                    Status = Itd3dFilterPrepare( pMixerSink->pItdContextRight, 0 );
                    if (Status != STATUS_SUCCESS) {
                        _DbgPrintF( DEBUGLVL_VERBOSE,("kmixer:pins.c 3d right prep fail"));
                        goto Exit;
                    }
                    Itd3dFilterClear( pMixerSink->pItdContextRight );

                    pItdContextLeft = pMixerSink->pItdContextLeft;

                    pItdContextLeft->TotalDryAttenuation = 1.0f;
                    pItdContextLeft->LastDryAttenuation = 1.0f;
                    pItdContextLeft->TotalWetAttenuation = 0.0f;
                    pItdContextLeft->LastWetAttenuation = 0.0f;
                    pItdContextLeft->VolSmoothScale = 1.0f;
                    pItdContextLeft->VolSmoothScaleRecip = 1.0f;
                    pItdContextLeft->iSmoothFreq = pMixerSource->WaveFormatEx.nSamplesPerSec;

                    pItdContextLeft->iDelay = 0;
        #ifdef SMOOTH_ITD
                    pItdContextLeft->iLastDelay = 0;
        #endif

                    pItdContextRight = pMixerSink->pItdContextRight;

                    pItdContextRight->TotalDryAttenuation = 1.0f;
                    pItdContextRight->LastDryAttenuation = 1.0f;
                    pItdContextRight->TotalWetAttenuation = 0.0f;
                    pItdContextRight->LastWetAttenuation = 0.0f;
                    pItdContextRight->VolSmoothScale = 1.0f;
                    pItdContextRight->VolSmoothScaleRecip = 1.0f;
                    pItdContextRight->iSmoothFreq = pMixerSource->WaveFormatEx.nSamplesPerSec;

                    pItdContextRight->iDelay = 0;
        #ifdef SMOOTH_ITD
                    pItdContextRight->iLastDelay = 0;
        #endif

                }

    	    // Initialize the Doppler Effects SRC context
    	    pMixerSink->pInfo->Doppler.Quality = KSAUDIO_QUALITY_PC;
    	    Status = InitializeSRC( &pMixerSink->pInfo->Doppler,
	    		   pMixerSink->WaveFormatEx.nSamplesPerSec,
		    	   pMixerSink->WaveFormatEx.nSamplesPerSec,
			      pMixerSink->WaveFormatEx.nChannels,
    			   pMixerSink->pInfo->Src.csInputBufferSize);
    	    if (Status != STATUS_SUCCESS) {
                _DbgPrintF( DEBUGLVL_VERBOSE,("kmixer:pins.c Doppler SRC init fail"));
                goto Exit;
    	        }
        	        
            // Always stereo output from the 3D stage
            InChannels = 2;
            }
        }
    }

    // Initialize the master volume
    pMixerSink->MasterVolumeLevel = 0;

    // Calculate the size of our mix level values
    MinChannels = (InChannels < OutChannels ? InChannels : OutChannels);
    siz = InChannels * OutChannels * sizeof(LONG);

    // Allocate space for our mix levels
    pMixerSink->pMixLevelArray = (PFLOAT) ExAllocatePoolWithTag( PagedPool, siz, 'XIMK' );
    pMixerSink->pMixLevelModel = (PLONG) ExAllocatePoolWithTag( PagedPool, siz, 'XIMK' );

    // At most, we need (OutChannels/4+1)*(InChannels/2+2) Blocks for MMX version
    // and (OutChannels/BLOCK_SIZE_OUT+1)*(InChannels/BLOCK_SIZE_IN+2) Blocks for non-MMX
    // plus two blocks so that we can look ahead in our fast loop!!!
    siz = (InChannels/2 + 2) * (OutChannels/4 + 1);
    if ((OutChannels/BLOCK_SIZE_OUT+1)*(InChannels/BLOCK_SIZE_IN+2) > siz) {
		siz = (OutChannels/BLOCK_SIZE_OUT+1)*(InChannels/BLOCK_SIZE_IN+2);
	}
	siz += 2;
	siz *= sizeof(SUPERMIX_BLOCK);
    pMixerSink->pSuperMixBlock = (PSUPERMIX_BLOCK) ExAllocatePoolWithTag( PagedPool, siz, 'XIMK');

    if (pMixerSink->pMixLevelArray == NULL || 
        pMixerSink->pMixLevelModel == NULL ||
        pMixerSink->pSuperMixBlock == NULL)
        {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Exit;
        }

	MapSpeakerLocations(pMixerSink, InChannels, OutChannels, InMask, OutMask, pMixerSource);
	
    // Allocate space for the channel volume level array
    siz = InChannels * sizeof(LONG);
    pMixerSink->pChannelVolumeLevel = (PLONG) ExAllocatePoolWithTag( PagedPool, siz, 'XIMK' );
    if (!pMixerSink->pChannelVolumeLevel)
        {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Exit;
        }

    // Initialize the channel volume level array
    for (i=0; i<InChannels; i++)
        pMixerSink->pChannelVolumeLevel[i] = 0;

    // Allocate space for the pan volume level array
    siz = OutChannels * sizeof(LONG);
    pMixerSink->pPanVolumeLevel = (PLONG) ExAllocatePoolWithTag( PagedPool, siz, 'XIMK' );
    if (!pMixerSink->pPanVolumeLevel)
        {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Exit;
        }

    // Initialize the pan volume level array
    for (i=0; i<OutChannels; i++)
        pMixerSink->pPanVolumeLevel[i] = 0;

	// Allocate space for the optimized input mapping table
	MaxChannels = InChannels;
	if (MaxChannels < OutChannels)
	    MaxChannels = OutChannels;

	// Space for a long table
    siz = MaxChannels * 256 * sizeof(LONG);

    // Space for a byte table
    siz += MaxChannels * 256 * sizeof(BYTE);

    // Space for two dwords/floats
    siz += MaxChannels * 2 * sizeof(FLOAT);

    if (pMixerSource->nSinkPins < MAXNUM_MAPPING_TABLES) {
    	pMixerSink->pMappingTable = (PLONG) ExAllocatePoolWithTag( PagedPool, siz, 'XIMK' );
    }

    siz = MaxChannels * sizeof(LONG);
    pMixerSink->pVolumeTable = (PLONG) ExAllocatePoolWithTag( PagedPool, siz, 'XIMK' );
    if (!pMixerSink->pVolumeTable) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Exit;
    }

    // Convert to floats
    GenerateMixArray(pMixerSink, InChannels, OutChannels, pMixerSource);

    KeWaitForSingleObject ( &pFilterInstance->ControlMutex,
                            Executive,
                            KernelMode,
                            FALSE,
                            NULL ) ;

    if (MaxChannels > pMixerSource->MaxChannels)
        {
        // Allocate space for our temporary output buffer
        siz = (MAX_SAMPLING_RATE * MIXBUFFERDURATION / (STOPBAND_FACTOR/2))/1000 + 1;

        // Scale so that it covers the worst case input buffer (before SRC)
        siz = siz * (STOPBAND_FACTOR) + 1;

        // Plan for the maximum number of channels we've seen so far
        siz *= (MaxChannels * sizeof(FLOAT));

        pTemp = ExAllocatePoolWithTag(PagedPool, siz, 'XIMK');
        pTemp2 = ExAllocatePoolWithTag(PagedPool, siz, 'XIMK');
        pTemp3 = ExAllocatePoolWithTag(PagedPool, siz, 'XIMK');
        if (!pTemp || !pTemp2 || !pTemp3) {
            KeReleaseMutex ( &pFilterInstance->ControlMutex, FALSE ) ;
            if (pTemp) {
                ExFreePool(pTemp);
            }
            if (pTemp2) {
                ExFreePool(pTemp2);
            }
            if (pTemp3) {
                ExFreePool(pTemp3);
            }
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Exit;
        }

        ExFreePool(pMixerSource->pScratchBuffer);
        ExFreePool(pMixerSource->pScratch2);
        ExFreePool(pMixerSource->pFloatMixBuffer);
        pMixerSource->pScratchBuffer = pTemp;
        pMixerSource->pScratch2 = pTemp2;
        pMixerSource->pFloatMixBuffer = pTemp3;
        pMixerSource->MaxChannels = MaxChannels;
        }

    InsertTailList ( &pFilterInstance->SinkConnectionList, &pMixerSink->Header.NextInstance ) ;

    if (pMixerSink->WaveFormatEx.nSamplesPerSec > pMixerSource->MaxSampleRate) {
        // We should increase the output rate, if possible
        pMixerSource->MaxSampleRate = pMixerSink->WaveFormatEx.nSamplesPerSec;
        pMixerSource->fNewMaxRate = TRUE;
        pFilterInstance->fNeedOptimizeMix = FALSE;
       	OptimizeMix(pFilterInstance);
    } else {
        pFilterInstance->fNeedOptimizeMix = TRUE;
    }

    if (pMixerSink->Header.PinId == PIN_ID_WAVEIN_SINK) {
        Status = EnableSRC(pFilterInstance, &pMixerSink->pInfo->Src, pMixerSource);
        if (NT_SUCCESS(Status)) {
            if (pMixerSink->fCreate3D) {
                Status = EnableSRC(pFilterInstance, &pMixerSink->pInfo->Doppler, NULL);
                if (Status != STATUS_SUCCESS) {
                    DisableSRC(&pMixerSink->pInfo->Src, pMixerSource);
                    KeReleaseMutex ( &pFilterInstance->ControlMutex, FALSE ) ;
                    goto Exit;
                }
            }
        } else {
            KeReleaseMutex ( &pFilterInstance->ControlMutex, FALSE ) ;
            goto Exit;
        }
    }

    KeReleaseMutex ( &pFilterInstance->ControlMutex, FALSE ) ;

    pFilterInstance->LocalPinInstances[pConnect->PinId].CurrentCount++ ;
    pIrpStack->FileObject->FsContext = pMixerSink;
    pMixerSource->nSinkPins++;


Exit:

    if (!NT_SUCCESS(Status)) {

        if (pMixerSink) {

            if (pMixerSink->pItdContextLeft) {
                if (pMixerSink->pItdContextLeft->pSampleCache)
                {
                    ExFreePool( pMixerSink->pItdContextLeft->pSampleCache );
                    pMixerSink->pItdContextLeft->pSampleCache = NULL;
                }

                if (pMixerSink->pItdContextLeft->pStateCache)
                {
                    ExFreePool( pMixerSink->pItdContextLeft->pStateCache );
                    pMixerSink->pItdContextLeft->pStateCache = NULL;
                }

                ExFreePool( pMixerSink->pItdContextLeft );
                pMixerSink->pItdContextLeft = NULL;
            }

            if (pMixerSink->pItdContextRight) {
                if (pMixerSink->pItdContextRight->pSampleCache)
                {
                    ExFreePool( pMixerSink->pItdContextRight->pSampleCache );
                    pMixerSink->pItdContextRight->pSampleCache = NULL;
                }

                if (pMixerSink->pItdContextRight->pStateCache)
                {
                    ExFreePool( pMixerSink->pItdContextRight->pStateCache );
                    pMixerSink->pItdContextRight->pStateCache  = NULL;
                }

                ExFreePool( pMixerSink->pItdContextRight );
                pMixerSink->pItdContextRight = NULL;
            }

            if (pMixerSink->pInfo) {
                if ( pMixerSink->pInfo->BlockInfo ) {
                    ExFreePool( pMixerSink->pInfo->BlockInfo ) ;
                }
                if (pMixerSink->pInfo->Doppler.pCoeff)
                    ExFreePool( pMixerSink->pInfo->Doppler.pCoeff );

                if (pMixerSink->pInfo->Src.pCoeff)
                    ExFreePool( pMixerSink->pInfo->Src.pCoeff );

                ExFreePool( pMixerSink->pInfo );
                pMixerSink->pInfo = NULL;
            }

            if (pMixerSink->pNewItd3dParamsLeft)
            {
                ExFreePool( pMixerSink->pNewItd3dParamsLeft );
            pMixerSink->pNewItd3dParamsLeft = NULL;
        }
           

        if (pMixerSink->pNewItd3dParamsRight)
        {
            ExFreePool( pMixerSink->pNewItd3dParamsRight );
            pMixerSink->pNewItd3dParamsRight = NULL;
        }

        if(FLOAT_COEFF == pMixerSink->CoeffFormat) {
            FloatLocalizerDestroy( pMixerSink->pFloatLocalizer );
            pMixerSink->pFloatLocalizer = NULL;
        } else {
            ShortLocalizerDestroy( pMixerSink->pShortLocalizer );
            pMixerSink->pShortLocalizer = NULL;
        }

        if (pMixerSink->pNewIir3dParams) {
            ExFreePool( pMixerSink->pNewIir3dParams );
            pMixerSink->pNewIir3dParams = NULL;
        }

        if (pMixerSink->pMixLevelArray)
            ExFreePool( pMixerSink->pMixLevelArray );

        if (pMixerSink->pSuperMixBlock)
            ExFreePool( pMixerSink->pSuperMixBlock );

        if (pMixerSink->pMixLevelModel)
            ExFreePool( pMixerSink->pMixLevelModel );

        if (pMixerSink->pChannelVolumeLevel)
            ExFreePool( pMixerSink->pChannelVolumeLevel );

        if (pMixerSink->pPanVolumeLevel)
            ExFreePool( pMixerSink->pPanVolumeLevel );

        if (pMixerSink->pVolumeTable)
            ExFreePool( pMixerSink->pVolumeTable );

        if (pMixerSink->pMappingTable)
            ExFreePool( pMixerSink->pMappingTable );

#if 0
        if (pMixerSink->pInfo->Doppler.pHistory)
            ExFreePool( pMixerSink->pInfo->Doppler.pHistory );

        if (pMixerSink->pInfo->Src.pHistory)
            ExFreePool( pMixerSink->pInfo->Src.pHistory );
#endif
        ExFreePool( pMixerSink );

        }

        if (fObRefSuccess) {
            ObDereferenceObject ( pMixerSource->FileObject ) ;
        }

    }

    return Status;
}

NTSTATUS VerifyWaveFormatEx
(
    PWAVEFORMATEX pWaveFormatEx
)
{
    NTSTATUS    Status = STATUS_SUCCESS;
    PWAVEFORMATEXTENSIBLE pWaveExtended;
    WORD wFormatTag = WAVE_FORMAT_UNKNOWN;

    try {

        // Verify the format tag
        if (pWaveFormatEx->wFormatTag != WAVE_FORMAT_PCM &&
            pWaveFormatEx->wFormatTag != WAVE_FORMAT_IEEE_FLOAT &&
            pWaveFormatEx->wFormatTag != WAVE_FORMAT_EXTENSIBLE)
        {
            Status = STATUS_INVALID_PARAMETER;
        }

        // Verify the extended format
        if (pWaveFormatEx->wFormatTag == WAVE_FORMAT_EXTENSIBLE) {
            pWaveExtended = (PWAVEFORMATEXTENSIBLE) pWaveFormatEx;
            if ( !IS_VALID_WAVEFORMATEX_GUID(&pWaveExtended->SubFormat) ) {
                Status = STATUS_INVALID_PARAMETER;
            }
            else {
                wFormatTag = EXTRACT_WAVEFORMATEX_ID(&pWaveExtended->SubFormat);

                if( (wFormatTag != WAVE_FORMAT_PCM ) &&
                    (wFormatTag != WAVE_FORMAT_IEEE_FLOAT ) ) {
                    Status = STATUS_INVALID_PARAMETER;
                }
            }
        }

        // Verify the number of channels
        if (pWaveFormatEx->nChannels == 0 )
        {
            Status = STATUS_INVALID_PARAMETER;
        }
        else {
            // Only support mono or stereo with WAVE_FORMAT_PCM and WAVE_FORMAT_IEEE_FLOAT
            if (pWaveFormatEx->nChannels > 2) {
                if ( (pWaveFormatEx->wFormatTag == WAVE_FORMAT_PCM) ||
                     (pWaveFormatEx->wFormatTag == WAVE_FORMAT_IEEE_FLOAT) ) {
                    Status = STATUS_INVALID_PARAMETER;
                }
            }
        }

        // Verify the sample rate
        if ( (pWaveFormatEx->nSamplesPerSec < MIN_SAMPLING_RATE ) ||
             (pWaveFormatEx->nSamplesPerSec > MAX_SAMPLING_RATE ) )

        {
            Status = STATUS_INVALID_PARAMETER;
        }
#if 0
        // NOTE: The average bytes per sec is not set properly for some formats,
        // which causes a race condition inside SysAudio !!!
        // Otherwise, we would verify the number of average bytes per second
        if ( pWaveFormatEx->nAvgBytesPerSec !=
             (pWaveFormatEx->nSamplesPerSec * pWaveFormatEx->nBlockAlign) )
        {

            Status = STATUS_INVALID_PARAMETER;
        }
#endif
        // Verify the block alignment
        if (pWaveFormatEx->nBlockAlign == 0 )
        {
            Status = STATUS_INVALID_PARAMETER;
        }

        // Verify the number of bits per sample
        if (pWaveFormatEx->wFormatTag == WAVE_FORMAT_PCM) {
            if ( pWaveFormatEx->wBitsPerSample != 16 &&
                 pWaveFormatEx->wBitsPerSample != 8 ) {
#ifdef ALLOW_PACKED_HIGH_BITWIDTH_LEGACY_FORMATS
                 // Allow unambiguous packed formats only for legacy waveformat.
                 // 24 bit packed, and 32 bit packed are OK.
                 if (!((pWaveFormatEx->wBitsPerSample == 32 && pWaveFormatEx->nChannels*4==pWaveFormatEx->nBlockAlign) ||
                       (pWaveFormatEx->wBitsPerSample == 24 && pWaveFormatEx->nChannels*3==pWaveFormatEx->nBlockAlign))
                    ) {
                    Status = STATUS_INVALID_PARAMETER;
                }
#else
                Status = STATUS_INVALID_PARAMETER;
#endif
            }
        }
        else if ( (pWaveFormatEx->wFormatTag == WAVE_FORMAT_IEEE_FLOAT) ||
                  (wFormatTag                == WAVE_FORMAT_IEEE_FLOAT) ) {
            if ( pWaveFormatEx->wBitsPerSample != 32 ) {
                Status = STATUS_INVALID_PARAMETER;
            }
        }
        else if (wFormatTag == WAVE_FORMAT_PCM) {
            if ( pWaveFormatEx->wBitsPerSample != 32 &&
                 pWaveFormatEx->wBitsPerSample != 24 &&
                 pWaveFormatEx->wBitsPerSample != 16 &&
                 pWaveFormatEx->wBitsPerSample != 8 ) {
                Status = STATUS_INVALID_PARAMETER;
            }
        }
        else {
            Status = STATUS_INVALID_PARAMETER;
        }

        // All values of size are allowed.

    }
    except (EXCEPTION_EXECUTE_HANDLER) {
       Status = STATUS_INVALID_PARAMETER;
    }

    return( Status );
}

NTSTATUS ChangeSrc
(
    PFILTER_INSTANCE pFilterInstance,
    PMIXER_SINK_INSTANCE CurSink,
    PMIXER_SOURCE_INSTANCE pMixerSource,
    ULONG Quality
)
{
    ULONG siz;
    MIXER_SRC_INSTANCE  NewSrc, NewDoppler;
    NTSTATUS    Status;
#ifdef PERF_COUNT
    LARGE_INTEGER   StartTick, EndTick, Freq;
#endif
    BOOL    fOldRequiresFloat;
    ULONG   NewIndex, OldIndex, i;
    PLONG   pSource, pDest;

    START_PERF;
    NewSrc = CurSink->pInfo->Src;
    NewSrc.Quality = Quality;

    NewDoppler = CurSink->pInfo->Doppler;
    NewDoppler.Quality = Quality;

    NewSrc.pHistory = NULL;
    NewDoppler.pHistory = NULL;
    NewSrc.pCoeff = NULL;
    NewDoppler.pCoeff = NULL;

   	Status = InitializeSRC( &NewSrc,
		   CurSink->pInfo->IntermediateSamplingRate,
		   pMixerSource->WaveFormatEx.nSamplesPerSec,
		   pMixerSource->WaveFormatEx.nChannels,
		   pMixerSource->csMixBufferSize);
    if (Status != STATUS_SUCCESS) {
        _DbgPrintF( DEBUGLVL_VERBOSE,("kmixer:pins.c ChangeSrc SRC init fail"));
        goto Exit;
    }

    if (CurSink->fCreate3D) {
        Status = InitializeSRC( &NewDoppler,
	    		   CurSink->WaveFormatEx.nSamplesPerSec,
		    	   CurSink->pInfo->IntermediateSamplingRate,
			       CurSink->WaveFormatEx.nChannels,
    			   NewSrc.csInputBufferSize);
        if (Status != STATUS_SUCCESS) {
            _DbgPrintF( DEBUGLVL_VERBOSE,("kmixer:pins.c ChangeSrc Doppler init fail"));
            goto Exit;
        }
    }
		
  	// Preserve the sample history as much as possible
  	if (CurSink->pInfo->Src.fStarted) {
      	siz = (NewSrc.nSizeOfHistory > CurSink->pInfo->Src.nSizeOfHistory ?
  	       CurSink->pInfo->Src.nSizeOfHistory : NewSrc.nSizeOfHistory);
  	
  	    Status = EnableSRC(pFilterInstance, &NewSrc, pMixerSource);
  	    if (!NT_SUCCESS(Status)) {
            _DbgPrintF( DEBUGLVL_VERBOSE,("kmixer:pins.c ChangeSrc SRC enable fail"));
            goto Exit;
  	    }

        NewIndex = SrcIndex(&NewSrc);
        OldIndex = SrcIndex(&CurSink->pInfo->Src);
        if (NewIndex != OldIndex) {
            pDest = (PLONG)NewSrc.pHistory + NewSrc.nSizeOfHistory - siz;
            pSource = (PLONG)CurSink->pInfo->Src.pHistory + CurSink->pInfo->Src.nSizeOfHistory - siz;

            // If the new one has no previous streams, clear it out.
            if (pMixerSource->SrcCount[NewSrc.Quality][NewIndex] == 1) {
                RtlZeroMemory( pDest, siz * sizeof(FLOAT) );
            }
            
            if (pMixerSource->SrcCount[CurSink->pInfo->Src.Quality][OldIndex] != 1) {
                // We can't separate the old streams, so we're stuck with the new history.
                _DbgPrintF( DEBUGLVL_VERBOSE,("kmixer:pins.c Too many old streams: no history"));
            } else if (NewSrc.fRequiresFloat && CurSink->pInfo->Src.fRequiresFloat) {
                // Float -> Float
                for (i=0; i<siz; i++) {
                    ((PFLOAT)pDest)[i] += ((PFLOAT)pSource)[i];
                }
            } else if (NewSrc.fRequiresFloat) {
                // Int -> Float
                for (i=0; i<siz; i++) {
                    ((PFLOAT)pDest)[i] += pSource[i];
                }
            } else if (CurSink->pInfo->Src.fRequiresFloat) {
                // Float -> Int
                for (i=0; i<siz; i++) {
                    pDest[i] += ((LONG) ((PFLOAT)pSource)[i]);
                }
            } else {
                // Int -> Int
                for (i=0; i<siz; i++) {
                    pDest[i] += pSource[i];
                }
            }
        }
    }

    if (CurSink->pInfo->Doppler.fStarted) {
      	siz = (NewDoppler.nSizeOfHistory > CurSink->pInfo->Doppler.nSizeOfHistory ?
  	       CurSink->pInfo->Doppler.nSizeOfHistory : NewDoppler.nSizeOfHistory);
  	
  	    Status = EnableSRC(pFilterInstance, &NewDoppler, NULL);  // pMixerSource == NULL indicates non-global SRC
  	    if (!NT_SUCCESS(Status)) {
            _DbgPrintF( DEBUGLVL_VERBOSE,("kmixer:pins.c ChangeSrc Doppler enable fail"));
            goto Exit;
  	    }
       	RtlCopyMemory((NewDoppler.pHistory + NewDoppler.nSizeOfHistory - siz),
                 (CurSink->pInfo->Doppler.pHistory + CurSink->pInfo->Doppler.nSizeOfHistory - siz),
                 siz * sizeof(FLOAT) );
    }

  	// Preserve the output cycle
//    NewSrc.nOutCycle = CurSink->pInfo->Src.nOutCycle % NewSrc.UpSampleRate;
    fOldRequiresFloat = CurSink->pInfo->Src.fRequiresFloat;
    NewSrc.SampleFrac = CurSink->pInfo->Src.SampleFrac;
    NewDoppler.SampleFrac = CurSink->pInfo->Doppler.SampleFrac;

    // Free the old buffer(s)
    DisableSRC(&CurSink->pInfo->Src, pMixerSource);
    if (CurSink->fCreate3D) {
        DisableSRC(&CurSink->pInfo->Doppler, NULL);
    }

    // Switch to the new SRC context
    CurSink->pInfo->Src = NewSrc;
    CurSink->pInfo->Doppler = NewDoppler;
    gpSrc = &CurSink->pInfo->Src;

    // Re-generate the mapping table, if necessary
    if (CurSink->pInfo->Src.fRequiresFloat != fOldRequiresFloat &&
        CurSink->WaveFormatEx.wBitsPerSample == 8) {
        if (!CurSink->fEnable3D) {
            GenerateMixArray(CurSink,
                             CurSink->WaveFormatEx.nChannels,
                             pMixerSource->WaveFormatEx.nChannels,
                             pMixerSource);
        } else {
            GenerateMixArray(CurSink,
                             2, // Always 2 channels out of the 3D stage
                             pMixerSource->WaveFormatEx.nChannels,
                             pMixerSource);
        }
    }

    ASSERT( CurSink->pInfo->Src.UpSampleRate == 160 || CurSink->pInfo->Src.DownSampleRate == 160 );

Exit:
    if (Status) {
#if 0
        if (NewSrc.pHistory)
            ExFreePool( NewSrc.pHistory );

        if (NewDoppler.pHistory)
            ExFreePool( NewDoppler.pHistory );
#endif
        if (NewSrc.pCoeff)
            ExFreePool( NewSrc.pCoeff );

        if (NewDoppler.pCoeff)
            ExFreePool( NewDoppler.pCoeff );

    }

    MEASURE_PERF(AverageTicksPerChangeSrc);
    return ( Status ) ;
}


#pragma LOCKED_CODE

VOID
WaitForPendingSourceIrps (
    PFILTER_INSTANCE pFilterInstance
    )
{

    KIRQL OldIrql;


    // if there are pending IRPs then wait for them to complete.
    KeAcquireSpinLock ( &pFilterInstance->MixSpinLock, &OldIrql ) ;

    ASSERT(pFilterInstance->NumPendingIos >= pFilterInstance->NumBuffersToMix) ;
    ASSERT(pFilterInstance->NumPendingIos <= pFilterInstance->CurrentNumMixBuffers) ;
    ASSERT(pFilterInstance->NumBuffersToMix <= pFilterInstance->CurrentNumMixBuffers) ;

    pFilterInstance->ClosingSource = TRUE ;
    pFilterInstance->NumPendingIos -= pFilterInstance->NumBuffersToMix ;
    pFilterInstance->NumBuffersToMix = 0 ;
    if (pFilterInstance->NumPendingIos) {

        KeReleaseSpinLock ( &pFilterInstance->MixSpinLock, OldIrql ) ;

        KeWaitForSingleObject ( &pFilterInstance->CloseEvent,
                                  Executive,
                                  KernelMode,
                                  FALSE,
                                  NULL ) ;

        pFilterInstance->ClosingSource = FALSE ;

    }
    else {

        pFilterInstance->ClosingSource = FALSE ;

        KeReleaseSpinLock ( &pFilterInstance->MixSpinLock, OldIrql ) ;

    }


}

#pragma PAGEABLE_CODE


NTSTATUS PinDispatchClose
(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             pIrp
)
{
    PFILTER_INSTANCE    pFilterInstance;
    PMIXER_INSTHDR       pMixerHeader;
    PIO_STACK_LOCATION  pIrpStack;
    PMIXER_SOURCE_INSTANCE pMixerSource ;
    PLIST_ENTRY         ple ;
    ULONG               i;
#ifdef LOG_TO_FILE
    ULONG               TotalSize ;
#endif    
    PMIXER_SINK_INSTANCE    pMixerSink;
    PFILE_OBJECT        pFileObject ;
    PKSWORKER           Worker;
    PULONG              pPinInstanceCount;
//    KIRQL                  OldIrql ;

    DENY_USERMODE_ACCESS( pIrp, TRUE );

    pIrpStack = IoGetCurrentIrpStackLocation( pIrp );
    pMixerHeader = (PMIXER_INSTHDR) pIrpStack->FileObject->FsContext;
    pFilterInstance = (PFILTER_INSTANCE) pMixerHeader->pFilterFileObject->FsContext;

    pPinInstanceCount=&pFilterInstance->LocalPinInstances[pMixerHeader->PinId].CurrentCount;

    switch (pMixerHeader->PinId)
    {
        case PIN_ID_WAVEOUT_SINK:
        case PIN_ID_WAVEIN_SINK:
            pMixerSink = (PMIXER_SINK_INSTANCE) pMixerHeader;

            _DbgPrintF( DEBUGLVL_VERBOSE, ("Close sink") ) ;
            // lock out all other CLOSEs & CREATEs

            KeWaitForSingleObject ( &pFilterInstance->ControlMutex,
    					         Executive,
    					         KernelMode,
    					         FALSE,
    					         NULL ) ;


            // KeAcquireSpinLock ( &pFilterInstance->SinkSpinLock, &OldIrql ) ;
            RemoveEntryList ( &pMixerHeader->NextInstance ) ;
            // KeReleaseSpinLock ( &pFilterInstance->SinkSpinLock, OldIrql ) ;

            if (pMixerSink->BuffersTillInactive || pMixerSink->SinkState == KSSTATE_RUN) {
                 RemoveEntryList ( &pMixerSink->ActiveQueue ) ;
            }

            KsFreeEventList ( pIrpStack->FileObject,
                              &pMixerSink->EventQueue,
                              KSEVENTS_SPINLOCK,
                              &pMixerSink->EventLock ) ;

            CancelIrpQueue ( pMixerSink,
                             &pMixerSink->WriteQueue,
                             &pMixerSink->WriteSpinLock ) ;

            ASSERT ( !IsListEmpty(&pFilterInstance->SourceConnectionList) ) ;
            ple = pFilterInstance->SourceConnectionList.Flink ;
            pMixerSource = (PMIXER_SOURCE_INSTANCE) CONTAINING_RECORD
                                    ( ple, MIXER_INSTHDR, NextInstance ) ;

    	    ExFreePool( pMixerSink->pMixLevelArray );
    	    ExFreePool( pMixerSink->pSuperMixBlock );
    	    ExFreePool( pMixerSink->pMixLevelModel );
    	    ExFreePool( pMixerSink->pChannelVolumeLevel );
    	    ExFreePool( pMixerSink->pPanVolumeLevel );
    	    ExFreePool( pMixerSink->pVolumeTable );

    	    DisableSRC(&pMixerSink->pInfo->Src, pMixerSource);
            if (pMixerSink->pMappingTable)
                ExFreePool( pMixerSink->pMappingTable );

            if ( pMixerSink->fCreate3D == TRUE )
            {
                DisableSRC(&pMixerSink->pInfo->Doppler, NULL);
                if(pMixerSink->fUseIir3d) {
                    if(FLOAT_COEFF == pMixerSink->CoeffFormat) {
                        FloatLocalizerDestroy( pMixerSink->pFloatLocalizer );
                    } else {
                        ShortLocalizerDestroy( pMixerSink->pShortLocalizer );
                    }
                    if (pMixerSink->pNewIir3dParams) {
                        ExFreePool( pMixerSink->pNewIir3dParams );
                        pMixerSink->pNewIir3dParams = NULL;
                    }
                } else {
                    // Delete the filter contexts
                    if( pMixerSink->pItdContextLeft->pSampleCache ) {
                        ExFreePool( pMixerSink->pItdContextLeft->pSampleCache );
                        pMixerSink->pItdContextLeft->pSampleCache = NULL;
                    }

                    if( pMixerSink->pItdContextLeft->pStateCache ) {
                        ExFreePool( pMixerSink->pItdContextLeft->pStateCache );
                        pMixerSink->pItdContextLeft->pStateCache = NULL;
                    }

                    if( pMixerSink->pItdContextLeft ) {
                        ExFreePool( pMixerSink->pItdContextLeft );
                        pMixerSink->pItdContextLeft = NULL;
                    }

                    if( pMixerSink->pItdContextRight->pSampleCache ) {
                        ExFreePool( pMixerSink->pItdContextRight->pSampleCache );
                        pMixerSink->pItdContextRight->pSampleCache = NULL;
                    } 

                    if( pMixerSink->pItdContextRight->pStateCache ) {
                        ExFreePool( pMixerSink->pItdContextRight->pStateCache );
                        pMixerSink->pItdContextRight->pStateCache = NULL;
                    }


                    if( pMixerSink->pItdContextRight ) {
                        ExFreePool( pMixerSink->pItdContextRight );
                        pMixerSink->pItdContextRight = NULL;
                    }

                    if( pMixerSink->pNewItd3dParamsLeft ) {
                        ExFreePool( pMixerSink->pNewItd3dParamsLeft );
                        pMixerSink->pNewItd3dParamsLeft = NULL;
                    }
                  
                    if( pMixerSink->pNewItd3dParamsRight ) {
                        ExFreePool( pMixerSink->pNewItd3dParamsRight );
                        pMixerSink->pNewItd3dParamsRight = NULL;
                    }
                }

            }

            ExFreePool( pMixerSink->pInfo->BlockInfo ) ;
            ExFreePool( pMixerSink->pInfo );

            pMixerSource->nSinkPins--;

#if 0
                //
                // Resetting the maxsample rate is disabled currently.
                // We have Energy Level issues depending on whether a stream
                // is going thru SRC or not.
                //
            if (pMixerSink->OriginalSampleRate == pMixerSource->MaxSampleRate) {
                // Re-calculate the maximum sample rate
        	    ple = pFilterInstance->SinkConnectionList.Flink ;
        	    pMixerSource->MaxSampleRate = 0;
                while ( ple != &pFilterInstance->SinkConnectionList ) {
                   pMixerSink = (PMIXER_SINK_INSTANCE) CONTAINING_RECORD ( ple,
            	                                                           MIXER_INSTHDR,
            	                                                           NextInstance ) ;
            	
            	   if (pMixerSink->OriginalSampleRate > pMixerSource->MaxSampleRate) {
            	       pMixerSource->MaxSampleRate = pMixerSink->OriginalSampleRate;
            	   }
            	
                   ple = pMixerSink->Header.NextInstance.Flink ;
    		    }
            }
#endif
            pFilterInstance->fNeedOptimizeMix = TRUE;
#ifdef DRM_KMIXER
            DrmUpdateMixedContent(pFilterInstance);     // Do this before dereferencing
#endif
                                                        // the MixerSource.FileObject
            ObDereferenceObject ( pMixerSource->FileObject ) ;
            break;

        case PIN_ID_WAVEOUT_SOURCE:
        case PIN_ID_WAVEIN_SOURCE:
            _DbgPrintF( DEBUGLVL_VERBOSE, ("Close source") ) ;

            if ((Worker=InterlockedExchangePointer(&pFilterInstance->CriticalWorkerObject, NULL))!=NULL) {
                KsUnregisterWorker(Worker);
            }

            if ((Worker=InterlockedExchangePointer(&pFilterInstance->DelayedWorkerObject, NULL))!=NULL) {
                KsUnregisterWorker(Worker);
            }

            // lock out all other CLOSEs & CREATEs

            KeWaitForSingleObject ( &pFilterInstance->ControlMutex,
					         Executive,
					         KernelMode,
					         FALSE,
					         NULL ) ;


#ifdef REALTIME_THREAD
           if (pFilterInstance->RealTimeThread) {

                KIRQL OldIrql;

                KeAcquireSpinLock ( &pFilterInstance->MixSpinLock, &OldIrql );

                KeLowerIrql( OldIrql );

                // Kill the thread.
                if (RtDestroyThread(pFilterInstance->RealTimeThread)!=STATUS_SUCCESS) {
                    _DbgPrintF(DEBUGLVL_TERSE, (STR_MODULENAME "Destroy realtime thread FAILED!\n") );
                    }

            	pFilterInstance->RealTimeThread=NULL;

            	KeInitializeSpinLock( &pFilterInstance->MixSpinLock );

            }
#endif


#ifdef LOG_TO_FILE
            if (fLogToFile) {
                // Write the correct total size
                TotalSize = pFilterInstance->filePos.LowPart - 8;
                pFilterInstance->filePos.LowPart = 4;
                FileIoRoutine(pFilterInstance,&TotalSize,4);

                // Write the correct data size
                pMixerSource = (PMIXER_SOURCE_INSTANCE)pMixerHeader ;
                if (pMixerSource->WaveFormatEx.wFormatTag != WAVE_FORMAT_EXTENSIBLE) {
                    TotalSize -= 36;
                    pFilterInstance->filePos.LowPart = 40;
                } else {
                    TotalSize -= (20+sizeof(WAVEFORMATEXTENSIBLE));
                    pFilterInstance->filePos.LowPart = (24+sizeof(WAVEFORMATEXTENSIBLE));
                }
                FileIoRoutine(pFilterInstance,&TotalSize,4);

//                FileCloseRoutine(pFilterInstance);
            }
#endif

            // if there are pending IRPs then wait for them to complete.
            WaitForPendingSourceIrps(pFilterInstance);

            ObDereferenceObject( pFilterInstance->pNextFileObject );
            RemoveEntryList ( &pMixerHeader->NextInstance ) ;
            pMixerSource = (PMIXER_SOURCE_INSTANCE)pMixerHeader ;


            for ( i = 0; i < MAXNUMMIXBUFFERS; i++ ) {
                if ( pMixerSource->WriteContext[i].pMdl->MdlFlags &
                        MDL_PAGES_LOCKED ) {
                    MmUnlockPages( pMixerSource->WriteContext[i].pMdl ) ;
                }
                IoFreeMdl ( pMixerSource->WriteContext[i].pMdl ) ;
#ifdef REALTIME_THREAD
                (ULONG_PTR)(pMixerSource->WriteContext[i].StreamHeader->Data)-=(i<<4);
                ExFreePool( pMixerSource->WriteContext[i].StreamHeader->Data );
#endif
                IoFreeIrp ( pMixerSource->WriteContext[i].pIrp ) ;
            }

#if DBG
            for ( i = 0; i < STOPBAND_FACTOR; i++) {
                if (!pMixerSource->pSrcBuffer[0][i] ||
                    (pMixerSource->pSrcBuffer[0][i]!=INVALID_POINTER && ((ULONG_PTR)pMixerSource->pSrcBuffer[0][i]&7))) {
                    ASSERT( FALSE && "Someone has corrupted kmixer's memory!");
                }
                if (!pMixerSource->pSrcBuffer[1][i] ||
                    (pMixerSource->pSrcBuffer[1][i]!=INVALID_POINTER && ((ULONG_PTR)pMixerSource->pSrcBuffer[1][i]&7))) {
                    ASSERT( FALSE && "Someone has corrupted kmixer's memory!");
                }
                if (!pMixerSource->pSrcBuffer[2][i] ||
                    (pMixerSource->pSrcBuffer[2][i]!=INVALID_POINTER && ((ULONG_PTR)pMixerSource->pSrcBuffer[2][i]&7))) {
                    ASSERT( FALSE && "Someone has corrupted kmixer's memory!");
                }
                if (!pMixerSource->pSrcBuffer[3][i] ||
                    (pMixerSource->pSrcBuffer[3][i]!=INVALID_POINTER && ((ULONG_PTR)pMixerSource->pSrcBuffer[3][i]&7))) {
                    ASSERT( FALSE && "Someone has corrupted kmixer's memory!");
                }
            }
#endif

            for ( i = 0; i < STOPBAND_FACTOR; i++) {
                if (pMixerSource->pSrcBuffer[0][i]!=INVALID_POINTER) {
                    ExFreePool ( pMixerSource->pSrcBuffer[0][i] );
                }
                if (pMixerSource->pSrcBuffer[1][i]!=INVALID_POINTER) {
                    ExFreePool ( pMixerSource->pSrcBuffer[1][i] );
                }
                if (pMixerSource->pSrcBuffer[2][i]!=INVALID_POINTER) {
                    ExFreePool ( pMixerSource->pSrcBuffer[2][i] );
                }
                if (pMixerSource->pSrcBuffer[3][i]!=INVALID_POINTER) {
                    ExFreePool ( pMixerSource->pSrcBuffer[3][i] );
                }
            }
    	    ExFreePool ( pMixerSource->pScratchBuffer );
    	    ExFreePool ( pMixerSource->pScratch2 );
    	    ExFreePool ( pMixerSource->pFloatMixBuffer );
            ExFreePool ( pMixerSource->pMixBuffer ) ;
            ExFreePool( pMixerSource->WriteContext ) ;
            ExFreePool( pMixerSource->BlockInfo ) ;
            break;
    }
    pFileObject = pMixerHeader->pFilterFileObject ;
    KsFreeObjectHeader ( pMixerHeader->ObjectHeader ) ;
    ExFreePool( pMixerHeader );

    KeReleaseMutex ( &pFilterInstance->ControlMutex, FALSE ) ;

    InterlockedDecrement(pPinInstanceCount);

    ObDereferenceObject( pFileObject );

    pIrp->IoStatus.Status = STATUS_SUCCESS;
    IoCompleteRequest( pIrp, IO_AUD_INCREMENT );

    return STATUS_SUCCESS;
}

#pragma LOCKED_CODE
#pragma LOCKED_DATA

NTSTATUS PinDispatchIoControl
(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             pIrp
)
{
    NTSTATUS            Status = STATUS_SUCCESS;
    PFILTER_INSTANCE    pFilterInstance;
    PMIXER_INSTHDR      pMixerHeader;
    PMIXER_SINK_INSTANCE pMixerSink ;
    PIO_STACK_LOCATION  pIrpStack;
    PLOOPPACKET         pCurLoopPacket;
    PLOOPPACKET         pNextLoopPacket;
    ULONG               Flags ;
    PLIST_ENTRY         ple ;
    KIRQL                  OldIrql ;
    PMDL                pMdl;
    PKSSTREAM_HEADER    pStrmHdr ;
    ULONG               NumDataBytes ;
    PKSSTREAM_HEADER    pCurStreamingHeader ;
    BOOL                FreeMdl = FALSE;

    pIrpStack = IoGetCurrentIrpStackLocation( pIrp );
    pMixerHeader =
        (PMIXER_INSTHDR) pIrpStack->FileObject->FsContext;
    pFilterInstance =
        (PFILTER_INSTANCE) pMixerHeader->pFilterFileObject->FsContext;

    pMixerSink = (PMIXER_SINK_INSTANCE) pMixerHeader ;
    switch (pIrpStack->Parameters.DeviceIoControl.IoControlCode)
    {
            case IOCTL_KS_READ_STREAM:
            case IOCTL_KS_WRITE_STREAM:

                if ( TRUE == pMixerSink->fResetState ) {
                    Status = STATUS_CANCELLED;
				    pIrp->IoStatus.Status = STATUS_CANCELLED ;
				    IoCompleteRequest ( pIrp, IO_AUD_INCREMENT ) ;
                    return( Status );
                }

                if ( pMixerSink->InterfaceId ==
                     KSINTERFACE_STANDARD_LOOPED_STREAMING ) {
                    Flags = KSPROBE_STREAMWRITE |
                            KSPROBE_ALLOCATEMDL ;
                } else if (pIrpStack->Parameters.DeviceIoControl.IoControlCode == IOCTL_KS_READ_STREAM) {
                    Flags = KSPROBE_STREAMREAD |
                            KSPROBE_ALLOCATEMDL |
                            KSPROBE_PROBEANDLOCK;
                } else {
                    Flags = KSPROBE_STREAMWRITE |
                            KSPROBE_ALLOCATEMDL |
                            KSPROBE_PROBEANDLOCK;
                }
                Status = KsProbeStreamIrp ( pIrp, Flags, sizeof ( KSSTREAM_HEADER) ) ;
                if ( !NT_SUCCESS ( Status ) ) {
                        break;
                }

                if ( pMixerSink->InterfaceId ==
                     KSINTERFACE_STANDARD_LOOPED_STREAMING ) {

                    KeAcquireSpinLock ( &pMixerSink->WriteSpinLock, &OldIrql ) ;
                    if ( ! IsListEmpty (&pMixerSink->WriteQueue) ) {
                        PIRP                ListHead;
                        PIO_STACK_LOCATION  irpSpListHead;

                        ple = pMixerSink->WriteQueue.Flink ;
                        ListHead  = (PIRP) CONTAINING_RECORD( ple, IRP, Tail.Overlay.ListEntry );
                        irpSpListHead = IoGetCurrentIrpStackLocation( ListHead );


                        pCurLoopPacket = irpSpListHead->Parameters.Others.Argument3 ;
                        if ( pCurLoopPacket->CurLoopingState == LOOPING_STATE_LOOPING )
                        {
                            pCurLoopPacket->CurLoopingState = LOOPING_STATE_LAST_LOOP;
                        }
                    }
                    KeReleaseSpinLock ( &pMixerSink->WriteSpinLock, OldIrql ) ;

                    pNextLoopPacket = ExAllocatePoolWithTag( NonPagedPool, sizeof( LOOPPACKET ), 'XIMK'  );

                    if (!pNextLoopPacket)
                    {
                            Status = STATUS_INSUFFICIENT_RESOURCES ;
                            FreeMdl = TRUE;
                            break;
                    }

                    Status = BuildPartialMdls( pFilterInstance, pMixerSink, pIrp, pNextLoopPacket ) ;
                    if ( !NT_SUCCESS(Status) ) {
                        ExFreePool( pNextLoopPacket ) ;
                        FreeMdl = TRUE;
                        break ;
                    }
                    pNextLoopPacket->Process = IoGetCurrentProcess() ;
                    
                    // Calculate number of bytes of data in the IRP
                    NumDataBytes = 0;
                    pStrmHdr = pIrp->AssociatedIrp.SystemBuffer;
    
                    for (pMdl = pIrp->MdlAddress; pMdl; pMdl = pMdl->Next) {
                        NumDataBytes += pStrmHdr->DataUsed; 
                        pStrmHdr++;
                    }
    
                    pMixerSink->BufferLength = NumDataBytes / (pMixerSink->WaveFormatEx.nChannels*
                          (pMixerSink->WaveFormatEx.wBitsPerSample/8) ) ;

                    AddIrpToSinkQueue ( pMixerSink,
                                        pIrp,
                                        pNextLoopPacket,
                                        0,
                                        MxCancelIrp ) ;

                }
                else {
                    pMdl = pIrp->MdlAddress;
                    while (pMdl) {
                        if (NULL == GetSystemAddressForMdlWithFailFlag(pMdl)) {
                            Status = STATUS_INSUFFICIENT_RESOURCES;
                            goto ErrorReturn;
                        }
                        pMdl = pMdl->Next;
                    }

                    if (pIrpStack->Parameters.DeviceIoControl.IoControlCode == IOCTL_KS_READ_STREAM) {
                        pCurStreamingHeader = pIrp->AssociatedIrp.SystemBuffer ;
                        if (pCurStreamingHeader) {
                            if (pIrp->MdlAddress) {
                                pCurStreamingHeader->DataUsed = MmGetMdlByteCount(pIrp->MdlAddress);
                            } else {
                                pCurStreamingHeader->DataUsed = 0;
                            }
                        }
                        pIrp->IoStatus.Information = sizeof (KSSTREAM_HEADER);
                    }

                    pStrmHdr = 
                        (PKSSTREAM_HEADER) pIrp->AssociatedIrp.SystemBuffer;
                    
                    // Calculate number of bytes of data in the IRP
                    NumDataBytes = 0;
                    if (pStrmHdr) {
                        pCurStreamingHeader = pIrp->AssociatedIrp.SystemBuffer ;
                        for (pMdl = pIrp->MdlAddress; pMdl; pMdl = pMdl->Next) {
                            NumDataBytes += pCurStreamingHeader->DataUsed; 
                            pCurStreamingHeader++;
                        }
                    }
                    pMixerSink->BytesSubmitted += NumDataBytes ;
                    
                    pIrpStack = IoGetCurrentIrpStackLocation( pIrp );
                    pIrpStack->Parameters.Others.Argument2 = pStrmHdr;
                    AddIrpToSinkQueue ( pMixerSink,
                                        pIrp,
                                        pIrp->MdlAddress,
                                        pStrmHdr?pStrmHdr->DataUsed:0,
                                        NULL ) ;
                }

                return ( STATUS_PENDING ) ;

        case IOCTL_KS_PROPERTY:
            _DbgPrintF( DEBUGLVL_VERBOSE, ("IOCTL :: GetSet Property") ) ;

            Status = KsPropertyHandler( pIrp,
                                    SIZEOF_ARRAY( Properties ),
                                    (PKSPROPERTY_SET) Properties );
            break;

        case IOCTL_KS_ENABLE_EVENT:
            _DbgPrintF( DEBUGLVL_VERBOSE, ("IOCTL :: Enable Event") ) ;

            if (((pMixerHeader->PinId == PIN_ID_WAVEOUT_SINK) || (pMixerHeader->PinId == PIN_ID_WAVEIN_SINK)) &&
               ((KSINTERFACE_STANDARD_STREAMING == pMixerSink->InterfaceId) ||
                (KSINTERFACE_STANDARD_LOOPED_STREAMING ==
                                                pMixerSink->InterfaceId))) {
                Status = KsEnableEvent ( pIrp,
                                    SIZEOF_ARRAY( MxEvents ),
                                    (PKSEVENT_SET) MxEvents,
                                    &pMixerSink->EventQueue,
                                    KSEVENTS_SPINLOCK,
                                    &pMixerSink->EventLock ) ;
            }
            else {
                return KsDefaultDeviceIoCompletion(DeviceObject, pIrp);
            }
            break ;

        case IOCTL_KS_DISABLE_EVENT:
            _DbgPrintF( DEBUGLVL_VERBOSE, ("IOCTL :: Disable Event") ) ;

            if ( (KSINTERFACE_STANDARD_STREAMING == pMixerSink->InterfaceId) ||
                 (KSINTERFACE_STANDARD_LOOPED_STREAMING ==
                                                pMixerSink->InterfaceId) ) {
                Status = KsDisableEvent ( pIrp,
                                    &pMixerSink->EventQueue,
                                    KSEVENTS_SPINLOCK,
                                    &pMixerSink->EventLock ) ;
            }
            else {
                return KsDefaultDeviceIoCompletion(DeviceObject, pIrp);
            }
            break ;

        case IOCTL_KS_METHOD:
            _DbgPrintF( DEBUGLVL_VERBOSE, ("IOCTL :: Method") ) ;

            Status = KsMethodHandler( pIrp,
                                    SIZEOF_ARRAY( Methods ),
                                    (PKSMETHOD_SET) Methods );
            break;

        case IOCTL_KS_RESET_STATE:
            _DbgPrintF( DEBUGLVL_VERBOSE, ("IOCTL :: Reset State") ) ;
            Status = ResetStateHandler( pIrp );
            break;

        default:

            return KsDefaultDeviceIoCompletion(DeviceObject, pIrp);
    }

ErrorReturn:    
    if ( Status != STATUS_PENDING ) {
        if (FreeMdl) {
            if  (pIrp->MdlAddress) {
                FreeMdlList( pIrp->MdlAddress ) ;
                pIrp->MdlAddress = NULL ;
            }
        }        
        pIrp->IoStatus.Status = Status;
        IoCompleteRequest ( pIrp, IO_AUD_INCREMENT ) ;
    }
    return ( Status );
}

#pragma PAGEABLE_CODE
#pragma PAGEABLE_DATA

NTSTATUS BuildPartialMdls
(
    IN PFILTER_INSTANCE         pFilterInstance,
    IN PMIXER_SINK_INSTANCE     pMixerSink,
    IN PIRP                     pIrp,
    IN OUT PLOOPPACKET          pLoopPacket
)
{
    PMDL                pCurStreamingMdl, pPartialMdl, pLastPartialMdl ;
    PKSSTREAM_HEADER    pCurStreamingHeader ;
    PVOID               CurVa, PartialVa ;
    NTSTATUS            Status ;
    ULONG               BytesLeftInMdl, PartialLen ;
    ULONG               NumPartialMdls, i ;
    ULONG               NumChannels, SampleSize, SampleRate ;

    Status = STATUS_SUCCESS ;
    pLastPartialMdl = NULL ;
    pLoopPacket->FirstMdl = NULL ;
    pLoopPacket->LoopStartMdl = NULL ;
    pLoopPacket->pCurStreamHdr = NULL ;
    pLoopPacket->pCurMdl = NULL ;
    pLoopPacket->cBytesLeft = 0 ;
    pLoopPacket->cBytesLeftInStreamHdr = 0 ;
    NumPartialMdls = 0 ;

    pCurStreamingMdl = pIrp->MdlAddress ;
    pCurStreamingHeader = pIrp->AssociatedIrp.SystemBuffer ;

    if ( (pCurStreamingHeader->Data == NULL) ||
         (pCurStreamingHeader->DataUsed == 0) ) {
        return (STATUS_SUCCESS) ;
    }
    while ( pCurStreamingMdl && NT_SUCCESS(Status) ) {
        CurVa = MmGetMdlVirtualAddress( pCurStreamingMdl ) ;
        BytesLeftInMdl = MmGetMdlByteCount( pCurStreamingMdl ) ;
        PartialVa = CurVa ;
        if ( gBuildPartialMdls
#ifdef REALTIME_THREAD
             && !pFilterInstance->RealTimeThread
#endif
                               ) {
            NumChannels = pMixerSink->WaveFormatEx.nChannels ;
            SampleSize = pMixerSink->WaveFormatEx.wBitsPerSample/8 ;
            SampleRate = pMixerSink->WaveFormatEx.nSamplesPerSec;

			// Calculate the worst case input size we will mix in one buffer
			// Note: this calculation accounts for the worst case SRC slop, also.
			PartialLen = (MAX_SAMPLING_RATE * MIXBUFFERDURATION / (STOPBAND_FACTOR/2))/1000 + 1;
			PartialLen = PartialLen * (STOPBAND_FACTOR) + 1;
          	PartialLen *= (NumChannels * SampleSize);
          	
            if (PARTIAL_MDL_SIZE > PartialLen) {
	            if (NumChannels * SampleSize != 0) {
	                PartialLen = (PARTIAL_MDL_SIZE / (NumChannels * SampleSize)) * NumChannels * SampleSize;
	            } else {
	                PartialLen = BytesLeftInMdl;
	            }
	        }
        }
        else {
            PartialLen = BytesLeftInMdl ;
        }
        while ( BytesLeftInMdl ) {
            if ( BytesLeftInMdl < 2*PartialLen ) { //MAX_PARTIAL_MDL_SIZE ) {
                PartialLen = BytesLeftInMdl ;
            }
            pPartialMdl = IoAllocateMdl( PartialVa,
                                            PartialLen,
                                            TRUE,
                                            FALSE,
                                            NULL ) ;
            if ( pPartialMdl ) {
                NumPartialMdls++ ;
                PartialVa = (PVOID)(((PCHAR)PartialVa)+PartialLen) ;
                BytesLeftInMdl -= PartialLen ;
                if ( pLastPartialMdl ) {
                    pLastPartialMdl->Next = pPartialMdl ;
                }
                else {
                    pLoopPacket->pCurMdl = pPartialMdl ;
                    pLoopPacket->FirstMdl = pPartialMdl ;
                }
                pLastPartialMdl = pPartialMdl ;
                if ( pCurStreamingHeader->OptionsFlags &
                        KSSTREAM_HEADER_OPTIONSF_LOOPEDDATA ) {
                    if ( pLoopPacket->LoopStartMdl == NULL ) {
                        pLoopPacket->LoopStartMdl = pPartialMdl ;
                        pLoopPacket->LoopStartStreamHdr =
                                pCurStreamingHeader ;
                    }
                }
            }
            else {
                Status = STATUS_INSUFFICIENT_RESOURCES ;
                break ;
            }
        }
        pCurStreamingMdl = pCurStreamingMdl->Next ;
        pCurStreamingHeader++ ;
    }

    if ( NT_SUCCESS( Status ) ) {
        pPartialMdl = pLoopPacket->pCurMdl ;
        if ( NumPartialMdls <= 2 ) {
            pLoopPacket->JustInTimeLock = FALSE ;
        }
        else {
            pLoopPacket->JustInTimeLock = TRUE ;
        }
        // Lock down necessary MDLs

        for ( i = 0; (i < 2) && (pPartialMdl) && NT_SUCCESS(Status); i++ ) {
            try {
                MmProbeAndLockPages( pPartialMdl, KernelMode, IoReadAccess ) ;
            }
            except (EXCEPTION_EXECUTE_HANDLER) {
                pMixerSink->SinkStatus |= MIXER_SINK_STATUS_LOCK_ERROR ;
                Status = GetExceptionCode();
            }
            if (NT_SUCCESS(Status)) {
                if (NULL == GetSystemAddressForMdlWithFailFlag( pPartialMdl )) {
                    Status = STATUS_INSUFFICIENT_RESOURCES;
                }
            }
            pPartialMdl = pPartialMdl->Next ;
        }
    }

    if ( NT_SUCCESS(Status) ) {
        pLoopPacket->LockedMdlHead = pLoopPacket->pCurMdl ;
        pLoopPacket->NumLockedMdls =
                            (NumPartialMdls > 2) ? 2:NumPartialMdls ;
        pLoopPacket->pCurStreamHdr = pIrp->AssociatedIrp.SystemBuffer;
        pLoopPacket->cBytesLeft = MmGetMdlByteCount(
                                                pLoopPacket->pCurMdl ) ;
        pLoopPacket->cBytesLeftInStreamHdr =
                pLoopPacket->pCurStreamHdr->DataUsed ;
        pLoopPacket->CurLoopingState = LOOPING_STATE_NOT_LOOPING;
    }

    if ( !NT_SUCCESS(Status)) {
        // Cleanup all mdl allocations
        FreeMdlList( pIrp->MdlAddress ) ;
        pIrp->MdlAddress = NULL ;
        FreeMdlList ( pLoopPacket->FirstMdl ) ;
    }

    return( Status ) ;
}

NTSTATUS PinDispatchRead
(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             pIrp
)
{
    NTSTATUS    Status;

        _DbgPrintF( DEBUGLVL_VERBOSE, ("Read") ) ;
    Status = STATUS_SUCCESS;

    pIrp->IoStatus.Status = Status;
    IoCompleteRequest( pIrp, IO_AUD_INCREMENT );

    return Status;
}

NTSTATUS PinDispatchWrite
(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             pIrp
)
{
    NTSTATUS                Status;
    LPWAVEHDR               phdr;
    PIO_STACK_LOCATION      pIrpStack;
    PWAVEHDREX              phdrex;
    PMIXER_SINK_INSTANCE    pMixerSink;
    PMDL                    pMdl ;

    _DbgPrintF( DEBUGLVL_VERBOSE, ("Write") ) ;

    pIrpStack = IoGetCurrentIrpStackLocation( pIrp );

    pMixerSink =
       (PMIXER_SINK_INSTANCE) pIrpStack->FileObject->FsContext;

    if ( (pIrpStack->Parameters.Write.Length != sizeof( WAVEHDR )) ||
          (pMixerSink->InterfaceId == KSINTERFACE_STANDARD_STREAMING) ) {
          
        _DbgPrintF( DEBUGLVL_ERROR, ("size != sizeof( WAVEHDR )") );

        Status = STATUS_INVALID_BUFFER_SIZE;
        pIrp->IoStatus.Status = Status;
        IoCompleteRequest( pIrp, IO_AUD_INCREMENT );
        return Status;
    }

    if ( TRUE == pMixerSink->fResetState ) {
        Status = STATUS_CANCELLED;
        pIrp->IoStatus.Status = STATUS_CANCELLED ;
        IoCompleteRequest ( pIrp, IO_AUD_INCREMENT ) ;
        return( Status );
    }

    phdr = GetSystemAddressForMdlWithFailFlag( pIrp->MdlAddress );
    if ( phdr == NULL ) {
        Status = STATUS_INSUFFICIENT_RESOURCES ;
        pIrp->IoStatus.Status = Status ;
        IoCompleteRequest( pIrp, IO_AUD_INCREMENT ) ;
        return( Status ) ;
    }

    phdrex = ExAllocatePoolWithTag( NonPagedPool, sizeof( WAVEHDREX ), 'XIMK'  );

    if (phdrex) {
        RtlZeroMemory( phdrex, sizeof( WAVEHDREX ) );
        if (phdr->dwBufferLength) {
            phdrex->BufferMdl =
                MmCreateMdl( NULL, phdr->lpData, phdr->dwBufferLength );
            if (phdrex->BufferMdl) {
                try {
                    MmProbeAndLockPages( phdrex->BufferMdl,
                                         pIrp->RequestorMode,
                                         IoReadAccess );
                }
                except (EXCEPTION_EXECUTE_HANDLER) {
                    IoFreeMdl( phdrex->BufferMdl );
                    phdrex->BufferMdl = NULL;
                }
                if (phdrex->BufferMdl) {
                    phdrex->DataBuffer = GetSystemAddressForMdlWithFailFlag(phdrex->BufferMdl);
                    if (NULL == phdrex->DataBuffer) {
                        MxUnlockMdl(phdrex->BufferMdl);
                        IoFreeMdl( phdrex->BufferMdl );
                        phdrex->BufferMdl = NULL;
                    } else {
                        phdrex->fLocked = TRUE;
                    }
                }
            }
        }
    }

    if ((!phdrex) ||
        ((phdrex->BufferMdl == NULL) && (phdr->dwBufferLength))) {
        if (phdrex)
            ExFreePool( phdrex );
        Status = STATUS_INSUFFICIENT_RESOURCES;
        pIrp->IoStatus.Status = Status;
        IoCompleteRequest( pIrp, IO_AUD_INCREMENT );
        return Status;
    }

    phdrex->Flags = phdr->dwFlags ;
    phdrex->LoopCount = phdr->dwLoops ;

    //
    // Add the Mdl to the IRP's Mdl List, so that we do
    // not have to worry about unlocking/unmapping the
    // Mdl
    //

    if ( pMdl = pIrp->MdlAddress ) {
        while ( pMdl->Next ) {
            pMdl = pMdl->Next ;
        }
        pMdl->Next = phdrex->BufferMdl ;
    }
    else {
        pIrp->MdlAddress = phdrex->BufferMdl ;
    }



    //
    // Overload the Irp's current stack location and store
    // the driver's private extended header information in
    // argument 3.  (Arguments 3 & 4 map to the ByteOffset
    // of the IRP_MJ_WRITE stack location, but this parameter
    // is ignored for this device object.
    //

    pMixerSink->BytesSubmitted += phdr->dwBufferLength ;
        
    AddIrpToSinkQueue ( pMixerSink, pIrp, phdrex, 0, MxCancelIrp ) ;
    _DbgPrintF( DEBUGLVL_VERBOSE, ("added %16x", (DWORD_PTR) phdr) );

    return STATUS_PENDING;

}

VOID
AddIrpToSinkQueue
(
    PMIXER_SINK_INSTANCE pMixerSink,
    PIRP                 pIrp,
    PVOID            Arg3,
    ULONG                Arg4,
    PDRIVER_CANCEL       CancelRoutine
)
{
    PIO_STACK_LOCATION      pIrpStack;
    PFILTER_INSTANCE        pFilterInstance ;

    pIrpStack = IoGetCurrentIrpStackLocation( pIrp );

    pIrpStack->Parameters.Others.Argument3 = Arg3;
    pIrpStack->Parameters.Others.Argument4 = ULongToPtr(Arg4);

    // Add to tail of list...

    pFilterInstance = (PFILTER_INSTANCE)
                       pMixerSink->Header.pFilterFileObject->FsContext ;
    KeWaitForSingleObject ( &pFilterInstance->ControlMutex,
                            Executive,
                            KernelMode,
                            FALSE,
                            NULL ) ;

    KsAddIrpToCancelableQueue( &pMixerSink->WriteQueue,
                                &pMixerSink->WriteSpinLock,
                                pIrp,
                                KsListEntryTail,
                                CancelRoutine );

    pMixerSink->SinkStatus |= MIXER_SINK_STATUS_DATA_PRESENT ;
    KeReleaseMutex ( &pFilterInstance->ControlMutex, FALSE ) ;
}



NTSTATUS PinStateHandler
(
    IN PIRP         pIrp,
    IN PKSPROPERTY  pProperty,
    IN OUT PKSSTATE SinkState
)
{
    PIO_STACK_LOCATION      pIrpStack;
    PMIXER_SINK_INSTANCE    pMixerSink ;
    PFILTER_INSTANCE        pFilterInstance ;
    NTSTATUS                status = STATUS_SUCCESS ;
    KSSTATE                 OldState, RenderState ;
    BOOL                    DoOptimizeMix = TRUE ;
    PMIXER_SOURCE_INSTANCE  pMixerSource ;


    ZDbgPrint("'PinState enter\r\n");

    _DbgPrintF( DEBUGLVL_VERBOSE, ("GetSet DeviceState") ) ;
    pIrpStack = IoGetCurrentIrpStackLocation( pIrp );
    pMixerSink = (PMIXER_SINK_INSTANCE) pIrpStack->FileObject->FsContext;
    pFilterInstance = (PFILTER_INSTANCE)
                                pMixerSink->Header.pFilterFileObject->FsContext;
    pMixerSource = (PMIXER_SOURCE_INSTANCE) CONTAINING_RECORD (pFilterInstance->SourceConnectionList.Flink, MIXER_INSTHDR, NextInstance) ;

    if(pMixerSink->Header.PinId == PIN_ID_WAVEOUT_SOURCE) {
        KeWaitForSingleObject( &pFilterInstance->ControlMutex,
                       Executive,
                       KernelMode,
                       FALSE,                  // not alertable
                       NULL );

        if ( pProperty->Flags & KSPROPERTY_TYPE_SET ) {
            if ( *SinkState == KSSTATE_STOP ) {
                pMixerSource->LeftOverFraction = 0 ;
            }
        }

        KeReleaseMutex ( &pFilterInstance->ControlMutex, FALSE ) ;

    } else  if(pMixerSink->Header.PinId == PIN_ID_WAVEOUT_SINK || pMixerSink->Header.PinId == PIN_ID_WAVEIN_SINK) {

        ZDbgPrint("'PS acquire\r\n");

        KeWaitForSingleObject( &pFilterInstance->ControlMutex,
                       Executive,
                       KernelMode,
                       FALSE,                  // not alertable
                       NULL );

        ZDbgPrint("'PS running\r\n");

        if ( *SinkState == KSSTATE_STOP ) {
            pMixerSink->fStarvationDetected = FALSE;
        }

        if ( pProperty->Flags & KSPROPERTY_TYPE_GET ) {
            _DbgPrintF( DEBUGLVL_VERBOSE, ("Get PinState") ) ;
            *SinkState = pMixerSink->SinkState ;
            if ( *SinkState == KSSTATE_PAUSE ) {
                status = STATUS_NO_DATA_DETECTED ;
            }
        } else {
            _DbgPrintF( DEBUGLVL_VERBOSE, ("Set PinState to %d", *SinkState) ) ;
            OldState = pMixerSink->SinkState ;
            if ( *SinkState != OldState ) {
                if ( OldState == KSSTATE_RUN ) {
                    pFilterInstance->ActivePins-- ;
                    pMixerSink->BuffersTillInactive = MAXNUMMIXBUFFERS;

                    if ( pFilterInstance->ActivePins == 0 ) {
                        KeCancelTimer( &pFilterInstance->WorkerThreadTimer );
                    }

                    ZDbgPrint("'PS dis src start\r\n");

                    if (pMixerSink->Header.PinId != PIN_ID_WAVEIN_SINK) {
                     DisableSRC(&pMixerSink->pInfo->Src, pMixerSource);
                    }

                    ZDbgPrint("'PS dis src done\r\n");

                }
                if ( OldState == KSSTATE_PAUSE || OldState == KSSTATE_ACQUIRE ) {
                     pFilterInstance->PausedPins-- ;
                }
                switch (*SinkState) {

                    case KSSTATE_RUN:
                           ZDbgPrint("'ZZ-PS:RN\n");
#ifdef REALTIME_THREAD


    if (pFilterInstance->RealTimeThread &&
        InterlockedCompareExchange(&pFilterInstance->Startup, FALSE, TRUE)==TRUE) {

        pFilterInstance->fPauseMix--;

    }

#endif

                    ZDbgPrint("'PS en src start\r\n");

                           status = EnableSRC(pFilterInstance, &pMixerSink->pInfo->Src, pMixerSource);

                    ZDbgPrint("'PS en src done\r\n");

                           if (status != STATUS_SUCCESS) {
                                if (OldState == KSSTATE_PAUSE || OldState == KSSTATE_ACQUIRE) {
                                    pFilterInstance->PausedPins++;
                                }

                                KeReleaseMutex ( &pFilterInstance->ControlMutex, FALSE ) ;
                                goto exit;
                           }

                           if (pMixerSink->fCreate3D) {

                    ZDbgPrint("'PS 3D src start\r\n");

                               status = EnableSRC(pFilterInstance, &pMixerSink->pInfo->Doppler, NULL);
                               if (status != STATUS_SUCCESS) {
                    if (pMixerSink->Header.PinId != PIN_ID_WAVEIN_SINK) {
                                    DisableSRC(&pMixerSink->pInfo->Src, pMixerSource);
                    }
                                    if (OldState == KSSTATE_PAUSE || OldState == KSSTATE_ACQUIRE) {
                                        pFilterInstance->PausedPins++;
                                    }

                    ZDbgPrint("'PS 3D src done\r\n");

                                    KeReleaseMutex ( &pFilterInstance->ControlMutex, FALSE ) ;
                                    goto exit;
                               }
                           }
                           
                           if ( pMixerSink->UpdateTimeBase ) {
                               pMixerSink->UpdateTimeBase = FALSE ;
                               pMixerSink->TimeBase =
                                       pFilterInstance->PresentationTime ;
                           }
                           pFilterInstance->ActivePins++;
                           if (pMixerSink->BuffersTillInactive == 0) {
                               InsertTailList ( &pFilterInstance->ActiveSinkList,
                                            &pMixerSink->ActiveQueue ) ;
                           }

                           if ( pFilterInstance->ActivePins == 1 ) {
                               pMixerSink->SinkState = KSSTATE_RUN ;
                               pFilterInstance->fNeedOptimizeMix = TRUE;
                               DoOptimizeMix = FALSE ;

                    ZDbgPrint("'PS begin mix start\r\n");

                               MxBeginMixing ( pFilterInstance ) ;

                    ZDbgPrint("'PS begin mix done\r\n");

                           }
                           break ;

                    case KSSTATE_STOP:
                           ZDbgPrint("'ZZ-PS:ST\n");

                    ZDbgPrint("'PS cancel irps start\r\n");

                           CancelPendingIrps ( pMixerSink,
                                               pFilterInstance );

                    ZDbgPrint("'PS cancel irps done\r\n");

                           break ;

                    case KSSTATE_ACQUIRE:
                    case KSSTATE_PAUSE:
                            ZDbgPrint("'ZZ-PS:PS\n");
                            pFilterInstance->PausedPins++ ;
                            if ( (pMixerSink->Header.PinId == PIN_ID_WAVEIN_SINK) &&
                                 (OldState == KSSTATE_RUN) ) {
                                if (NT_SUCCESS(GetRenderState(pFilterInstance,
                                                              &RenderState)) ) {
                                    if (RenderState == KSSTATE_RUN) {

                                        WaitForPendingSourceIrps(pFilterInstance);

                                    }
                                }
                            }
                            break ;
                }
                pMixerSink->SinkState = *SinkState ;
                if ( DoOptimizeMix ) {
                    pFilterInstance->fNeedOptimizeMix = TRUE;
                }
            }
        }

        KeReleaseMutex ( &pFilterInstance->ControlMutex, FALSE ) ;
    }

exit:

    pIrp->IoStatus.Information = sizeof (KSSTATE);

    ZDbgPrint("'PinState leave\r\n");

    return ( status ) ;
}

NTSTATUS ResetStateHandler
(
    IN PIRP         pIrp
)
{
    PIO_STACK_LOCATION      pIrpStack;
    PMIXER_SINK_INSTANCE    pMixerSink ;
    PFILTER_INSTANCE        pFilterInstance ;
    NTSTATUS                status = STATUS_SUCCESS ;
    KSRESET                 ResetValue ;

    pIrpStack = IoGetCurrentIrpStackLocation( pIrp );
    pMixerSink = (PMIXER_SINK_INSTANCE) pIrpStack->FileObject->FsContext;
    pFilterInstance = (PFILTER_INSTANCE)
                                pMixerSink->Header.pFilterFileObject->FsContext;

    if(pMixerSink->Header.PinId == PIN_ID_WAVEOUT_SINK || pMixerSink->Header.PinId == PIN_ID_WAVEIN_SINK) {
        KeWaitForSingleObject( &pFilterInstance->ControlMutex,
                       Executive,
                       KernelMode,
                       FALSE,                  // not alertable
                       NULL );

        status = KsAcquireResetValue( pIrp, &ResetValue );

        if ( KSRESET_BEGIN == ResetValue ) {
            _DbgPrintF( DEBUGLVL_VERBOSE, ("ResetStateHandler with value = KSRESET_BEGIN") ) ;

            CancelPendingIrps ( pMixerSink,
                                pFilterInstance );

            pMixerSink->fResetState = TRUE;
        }
        else if ( KSRESET_END == ResetValue ) {
            _DbgPrintF( DEBUGLVL_VERBOSE, ("ResetStateHandler with value = KSRESET_END") ) ;
            pMixerSink->fResetState = FALSE;
        }
        else {
            _DbgPrintF( DEBUGLVL_ERROR, ("Invalid ResetStateHandler value") ) ;
            status = STATUS_INVALID_DEVICE_REQUEST;
        }

        KeReleaseMutex ( &pFilterInstance->ControlMutex, FALSE ) ;
    }

    return ( status ) ;
}

VOID CancelPendingIrps
(
    IN PMIXER_SINK_INSTANCE    pMixerSink,
    IN PFILTER_INSTANCE        pFilterInstance
)
{
    PMIXER_SOURCE_INSTANCE  pMixerSource ;

    CancelIrpQueue ( pMixerSink,
                     &pMixerSink->WriteQueue,
                     &pMixerSink->WriteSpinLock ) ;
    pMixerSink->csNextSampleOffset = 0 ;
    pMixerSink->CurTime.Time = 0 ;
    pMixerSink->WriteOffset = 0 ;
    pMixerSink->SinkStatus &= ~MIXER_SINK_STATUS_IN_LOOP ;
    pMixerSink->LoopIrp = NULL ;
    pMixerSink->UpdateTimeBase = TRUE ;
    pMixerSink->BytesSubmitted = 0 ;

    CancelGlobalIrpQueue ( pMixerSink,
                    &pFilterInstance->AgingQueue,
                    &pFilterInstance->AgingDeadSpinLock ) ;
    CancelGlobalIrpQueue ( pMixerSink,
                     &pFilterInstance->DeadQueue,
                     &pFilterInstance->AgingDeadSpinLock ) ;

    if ( (pFilterInstance->ActivePins + pFilterInstance->PausedPins) == 0 ) {
        MxEndMixing ( pFilterInstance ) ;
        pMixerSource = (PMIXER_SOURCE_INSTANCE)
                CONTAINING_RECORD (pFilterInstance->SourceConnectionList.Flink,
                MIXER_INSTHDR,
                NextInstance) ;
        pMixerSource->BytesSubmitted = 0 ;
        pFilterInstance->PresentationTime.Time = 0 ;
    }
}


#pragma LOCKED_CODE

NTSTATUS MxBeginMixing
(
   PFILTER_INSTANCE pFilterInstance
)
{
   PMIXER_SOURCE_INSTANCE  pMixerSource;
   ULONG i;
   KIRQL OldIrql;

   _DbgPrintF( DEBUGLVL_VERBOSE, ("'" STR_MODULENAME "Begin mixing") ) ;

   pMixerSource = (PMIXER_SOURCE_INSTANCE) CONTAINING_RECORD (pFilterInstance->SourceConnectionList.Flink, MIXER_INSTHDR, NextInstance) ;

   // We start at time zero

   pFilterInstance->PresentationTime.Time = 0 ;

#ifdef REALTIME_THREAD
   if (pFilterInstance->RealTimeThread) {
       ULONG HoldPause;
   	   PreMixUpdate(pFilterInstance);
   	   HoldPause=pFilterInstance->fPauseMix;
       for ( i = 0; i<MAXNUMMIXBUFFERS; i++ ) {
           if ( InterlockedCompareExchange( &pMixerSource->WriteContext[pMixerSource->RtWriteIndex].InUse,
                                            WRITE_CONTEXT_INUSE,
                                            WRITE_CONTEXT_FREE ) == WRITE_CONTEXT_FREE ) {
                ZDbgPrint("'ZZ-BM:NP++\n");
                InterlockedIncrement ((PLONG)&pFilterInstance->NumPendingIos);
                WriteBuffer (&pMixerSource->WriteContext[pMixerSource->RtWriteIndex] ) ;
                pFilterInstance->fPauseMix=0;
           } else {
                //__asm int 3;
                break;
           }
       }
       pFilterInstance->fPauseMix=HoldPause;
   } else {
#endif

    KeAcquireSpinLock(&pFilterInstance->MixSpinLock, &OldIrql);

    KeClearEvent(&pFilterInstance->CloseEvent);

    pFilterInstance->NumBuffersToMix+=pFilterInstance->CurrentNumMixBuffers-pFilterInstance->NumPendingIos;
    pFilterInstance->NumPendingIos=pFilterInstance->CurrentNumMixBuffers;

    ASSERT (pFilterInstance->NumPendingIos <= pFilterInstance->CurrentNumMixBuffers ) ;
    ASSERT (pFilterInstance->NumBuffersToMix <= pFilterInstance->CurrentNumMixBuffers ) ;

    KeSetEvent(&pFilterInstance->WorkerThreadEvent, 0, FALSE );

    KeReleaseSpinLock(&pFilterInstance->MixSpinLock, OldIrql);

#ifdef REALTIME_THREAD
   }
#endif   

   return STATUS_SUCCESS ;
}

#pragma PAGEABLE_CODE


#ifdef _X86_
VOID
fastFillMemoryZero
(
    PBYTE pBuf,
    ULONG cbBuf
)
{
    // THIS FUNCTION ASSUMES THE FOLLOWING:
    //  cbBuf is a multiple of 4
    //  pBuf is 4-byte aligned
    
    ASSERT(((ULONG)pBuf & 0x00000003)==0);
    ASSERT((cbBuf & 0x00000003)==0);
        
    _asm {
                xor eax, eax
                mov esi, pBuf
                mov ecx, cbBuf

                mov edx, ecx
                test edx, edx
                je FillEnd

                mov edx, esi
                and edx, 0x0000001F
                je FillLine

        HeadLoop:
                mov [esi], eax
                add esi, 4
                sub ecx, 4
                je  FillEnd             
                
                mov edx, esi
                and edx, 0x0000001F
                jne HeadLoop

        FillLine:
                mov edx, ecx
                shr edx, 5
                je FillTail
                dec edx
                je FillTail

                shl edx, 5
                sub ecx, edx

        LineLoop:
                mov ebx, [esi+32]
                mov [esi+4], eax

                mov [esi+8], eax
                mov [esi+12], eax

                mov [esi+16], eax
                mov [esi+20], eax

                mov [esi+24], eax
                mov [esi+28], eax

                mov [esi], eax
                add esi, 32

                sub edx, 32
                jne LineLoop

        FillTail:
                mov edx, ecx
                test edx, edx
                je FillEnd

        TailLoop:
                mov [esi], eax
                add esi, 4
                sub ecx, 4
                jne TailLoop

        FillEnd:
    }
}
#endif

BOOL
MxCaptureBufferPresent
(
    PFILTER_INSTANCE pFilterInstance
)
{
    PLIST_ENTRY ple;
    PMIXER_SINK_INSTANCE CurSink;

    if (IsListEmpty(&pFilterInstance->ActiveSinkList)) {
        return(FALSE);
    }
    ple = pFilterInstance->ActiveSinkList.Flink;
    CurSink = (PMIXER_SINK_INSTANCE) CONTAINING_RECORD ( ple, MIXER_SINK_INSTANCE, ActiveQueue ) ;
    return ( CurSink->SinkStatus & MIXER_SINK_STATUS_DATA_PRESENT);
}

VOID
MixFloatToInt32
(
    PFLOAT  pFloatBuffer,
    PLONG   pLongBuffer,
    ULONG   nSize
)
{
  
#define GTW_OPTS
#ifdef GTW_OPTS
	{
	ULONG i = nSize >> 3;

	if (i) {
		nSize &= 0x7;

#undef  ONESAMPLE
#define ONESAMPLE(x) pLongBuffer[x] += DitherFloatToLong(pFloatBuffer[x], 1)
		while (i--) {

			ONESAMPLE(0);
			ONESAMPLE(1);
			ONESAMPLE(2);
			ONESAMPLE(3);
			ONESAMPLE(4);
			ONESAMPLE(5);
			ONESAMPLE(6);
			ONESAMPLE(7);

			pLongBuffer  += 8;
			pFloatBuffer += 8;
		}
	}
    while (nSize--) {
		ONESAMPLE(0);

		pLongBuffer++;
		pFloatBuffer++;
    }
	}
#else
    while (nSize--) {
        pLongBuffer[nSize] += DitherFloatToLong(pFloatBuffer[nSize],1);
    }
#endif
}

VOID
CopyFloatToInt32
(
    PFLOAT  pFloatBuffer,
    PLONG   pLongBuffer,
    ULONG   nSize
)
{
  
#ifdef GTW_OPTS
	{
	ULONG i = nSize >> 3;

	if (i) {
		nSize &= 0x7;

#undef  ONESAMPLE
#define ONESAMPLE(x) pLongBuffer[x] = DitherFloatToLong(pFloatBuffer[x], 1)
		while (i--) {

			ONESAMPLE(0);
			ONESAMPLE(1);
			ONESAMPLE(2);
			ONESAMPLE(3);
			ONESAMPLE(4);
			ONESAMPLE(5);
			ONESAMPLE(6);
			ONESAMPLE(7);

			pLongBuffer  += 8;
			pFloatBuffer += 8;
		}
	}
    while (nSize--) {
		ONESAMPLE(0);

        pLongBuffer++;
		pFloatBuffer++;
    }
    }
#else
    while (nSize--) {
        pLongBuffer[nSize] = DitherFloatToLong(pFloatBuffer[nSize],1);
    }
#endif
}

#ifdef REALTIME_THREAD
VOID PreMixUpdate
(
PFILTER_INSTANCE pFilterInstance
)
{
    PMIXER_SINK_INSTANCE CurSink;
    PMIXER_SOURCE_INSTANCE pMixerSource;
    PLIST_ENTRY ple, pleEvents;
    ULONG InChannels, OutChannels;
    BOOL fMuted;
    NTSTATUS status;
    KIRQL OldIrql;
    PPOSITION_EVENT_ENTRY  pPosEventEntry;

    pMixerSource = (PMIXER_SOURCE_INSTANCE) CONTAINING_RECORD (pFilterInstance->SourceConnectionList.Flink, MIXER_INSTHDR, NextInstance) ;

    ple = pFilterInstance->ActiveSinkList.Flink ;
    while ( ple != &pFilterInstance->ActiveSinkList ) {
        CurSink = (PMIXER_SINK_INSTANCE) CONTAINING_RECORD ( ple, MIXER_SINK_INSTANCE, ActiveQueue ) ;
        if (CurSink->pInfo->fVolChanged) {
            InChannels = CurSink->WaveFormatEx.nChannels;
            OutChannels = CurSink->nOutputChannels ;
            fMuted = CurSink->fMuted;
            if (CurSink->fEnable3D) {
                InChannels = 2; // Always 2 channels out of the 3D stage
            }
            GenerateMixArray(CurSink, InChannels, OutChannels, pMixerSource);
            pFilterInstance->fNeedOptimizeMix |= (fMuted != CurSink->fMuted);
            CurSink->pInfo->fVolChanged = FALSE;
        }
        if (CurSink->pInfo->fSrcChanged && CurSink->fMuted == FALSE) {
            status = ChangeSrc(pFilterInstance, CurSink, pMixerSource, CurSink->pInfo->Src.Quality);
            pFilterInstance->fNeedOptimizeMix = TRUE;
            CurSink->pInfo->fSrcChanged = FALSE;
            if (status != STATUS_SUCCESS) {
                CurSink->fMuted = TRUE;
                CurSink->pInfo->fSrcChanged = TRUE;
            }
        }
        if ( CurSink->fEnable3D && CurSink->f3dParamsChanged ) {
            if (CurSink->fUseIir3d) {
                status = UpdateIir3dParams( CurSink );
            } else {
                status = UpdateItd3dParams( CurSink->pItdContextLeft,
                                              CurSink->pItdContextRight,
                                              CurSink->pNewItd3dParamsLeft,
                                              CurSink->pNewItd3dParamsRight );
            }

            // Mute if we can't update the 3D parameters.
            if (status != STATUS_SUCCESS) {
                CurSink->fMuted = TRUE;
            } else {
                InterlockedExchange( &(CurSink->f3dParamsChanged), FALSE );
            }
        }

        if ( CurSink->pClock ) {
            if (!IsListEmpty(&CurSink->pClock->EventQueue)) {
                MxGenerateClockEvents( CurSink->pClock ) ;
            }
        }

        if ( CurSink->InterfaceId == KSINTERFACE_STANDARD_LOOPED_STREAMING ) {
            KeAcquireSpinLock ( &CurSink->EventLock, &OldIrql ) ;
            if ( !IsListEmpty ( &CurSink->EventQueue ) ) {
                pleEvents = CurSink->EventQueue.Flink ;
                while ( pleEvents != &CurSink->EventQueue ) {
                    pPosEventEntry = (PPOSITION_EVENT_ENTRY) CONTAINING_RECORD ( pleEvents,
                                                                    KSEVENT_ENTRY,
                                                                    ListEntry ) ;
                    pleEvents = pleEvents->Flink ;
                    if ( pPosEventEntry->EventType == PositionEvent &&
                         pPosEventEntry->fRtTrigger ) {
                        pPosEventEntry->fRtTrigger = FALSE;
                        KsGenerateEvent ( &pPosEventEntry->EventEntry ) ;
                    }
                }
            }
            
            KeReleaseSpinLock ( &CurSink->EventLock, OldIrql ) ;
        }
        
        ple = CurSink->ActiveQueue.Flink ;
    }

    if (pFilterInstance->fNeedOptimizeMix) {
        pFilterInstance->fNeedOptimizeMix = FALSE;
       	OptimizeMix(pFilterInstance);
    }
}
#endif

VOID MixOneBuff
(
PFILTER_INSTANCE pFilterInstance,
PMIXER_WRITE_CONTEXT    pWriteContext
)
{
    KFLOATING_SAVE     FloatSave;
    PSHORT          pInputBuffer;          // assumes 16 bit sample
    ULONG           BlockCount, nInputSamples, nOutputSamples, i;
#ifdef VERIFY_CAPTURE_DATA
    ULONG           j;
#endif	
    PIRP            FreeIrp, ReleaseIrp ;
    PLONG           pMixBuffer;
    PMIXER_SINK_INSTANCE CurSink ;
    PMIXER_SOURCE_INSTANCE pMixerSource ;
    LONG samplesleft ;
    PLIST_ENTRY     ple ;
    ULONG   InChannels, OutChannels, InSampleSize, OutSampleSize ;
    ULONG   MixBufferSize ;
    PIO_STACK_LOCATION      pIrpStack ;
    PVOID   Buf = pWriteContext->StreamHeader->Data;
    PVOID   TempBuffer, temp;
    static  ULONG CatPointer = 0;
    ULONG   Index ;
    ULONG   StreamsMixed, nStagesToDo;
    BOOL    fMuted, FinalBufferPresent;
    NTSTATUS    status = STATUS_SUCCESS;
    NTSTATUS Status3D;
#ifdef PERF_COUNT
    LARGE_INTEGER   StartTick, EndTick, Freq;
#endif
    LARGE_INTEGER currentPC;

    _DbgPrintF( DEBUGLVL_VERBOSE, ("Mixing one buff") ) ;

    pMixerSource = (PMIXER_SOURCE_INSTANCE) CONTAINING_RECORD (pFilterInstance->SourceConnectionList.Flink, MIXER_INSTHDR, NextInstance) ;
    ZDbgPrint("'MixOneBuff(%d)\n",(pWriteContext - (&pMixerSource->WriteContext[0])));

#ifdef REALTIME_THREAD
    if (!pFilterInstance->RealTimeThread) {
#endif            
        ple = pFilterInstance->ActiveSinkList.Flink ;
        while ( ple != &pFilterInstance->ActiveSinkList ) {
            CurSink = (PMIXER_SINK_INSTANCE) CONTAINING_RECORD ( ple, MIXER_SINK_INSTANCE, ActiveQueue ) ;
            if (CurSink->pInfo->fVolChanged) {
                InChannels = CurSink->WaveFormatEx.nChannels;
                OutChannels = CurSink->nOutputChannels ;
                fMuted = CurSink->fMuted;
                if (CurSink->fEnable3D) {
                    InChannels = 2; // Always 2 channels out of the 3D stage
                }

                GenerateMixArray(CurSink, InChannels, OutChannels, pMixerSource);
                pFilterInstance->fNeedOptimizeMix |= (fMuted != CurSink->fMuted);

                CurSink->pInfo->fVolChanged = FALSE;
//                DbgPrint("'done setting Volume...\n");
            }
            if (CurSink->pInfo->fSrcChanged && CurSink->fMuted == FALSE) {
                status = ChangeSrc(pFilterInstance, CurSink, pMixerSource, CurSink->pInfo->Src.Quality);
                pFilterInstance->fNeedOptimizeMix = TRUE;
                CurSink->pInfo->fSrcChanged = FALSE;
                if (status != STATUS_SUCCESS) {
                    CurSink->fMuted = TRUE;
                    CurSink->pInfo->fSrcChanged = TRUE;
                }
            }
            ple = CurSink->ActiveQueue.Flink ;
        }

        if (pFilterInstance->fNeedOptimizeMix) {
            pFilterInstance->fNeedOptimizeMix = FALSE;
           	OptimizeMix(pFilterInstance);
        }
#ifdef REALTIME_THREAD
    }
#endif
//    if (pMixerSource->fUsesFloat) {
        SaveFloatState(&FloatSave);
//    }

    OutChannels = pMixerSource->WaveFormatEx.nChannels ;
    OutSampleSize = pMixerSource->WaveFormatEx.wBitsPerSample/8 ;

#ifdef REALTIME_THREAD
    if (pFilterInstance->RealTimeThread) {
        MixBufferSize = pWriteContext->StreamHeader->DataUsed / pMixerSource->BytesPerSample;
    } else {
#endif    
        MixBufferSize = (pMixerSource->WaveFormatEx.nSamplesPerSec  * MIXBUFFERDURATION) ;
        MixBufferSize += pMixerSource->LeftOverFraction ;
        pMixerSource->LeftOverFraction = MixBufferSize % 1000 ;
        MixBufferSize /= 1000 ;
        if (pWriteContext->fReading == FALSE)
            pWriteContext->StreamHeader->DataUsed = MixBufferSize * pMixerSource->BytesPerSample ;
            
#ifdef REALTIME_THREAD
    }
#endif

    ple = pFilterInstance->ActiveSinkList.Flink ;

    if (pMixerSource->fZeroBufferFirst) {
#ifdef _X86_
        fastFillMemoryZero(Buf, MixBufferSize * sizeof(LONG) * OutChannels);
#else
        RtlFillMemory( Buf, MixBufferSize * sizeof(LONG) * OutChannels, 0 );
#endif
    }

    StreamsMixed = 0;
    while ( ple != &pFilterInstance->ActiveSinkList ) {
        CurSink = (PMIXER_SINK_INSTANCE) CONTAINING_RECORD ( ple, MIXER_SINK_INSTANCE, ActiveQueue ) ;

        //
        // Fill in the number of bytes we consumed from this Sink block with 0
        //

        Index = (CurSink->BlockInfoIndex+1) % MAXNUMMIXBUFFERS ;

        CurSink->BlockInfoIndex = Index ;
        CurSink->pInfo->BlockInfo[Index].NumBytes = 0 ;
        CurSink->pInfo->BlockInfo[Index].UpSampleRate = CurSink->pInfo->Src.UpSampleRate ;
        CurSink->pInfo->BlockInfo[Index].DownSampleRate = CurSink->pInfo->Src.DownSampleRate ;
        CurSink->pInfo->BlockInfo[Index].BytesPerSample = CurSink->BytesPerSample ;

        if (CurSink->SinkState != KSSTATE_RUN) {
            if (CurSink->BuffersTillInactive) {
                // This one is waiting to become inactive.
                CurSink->BuffersTillInactive--;
            }
            if (CurSink->BuffersTillInactive == 0) {
                 RemoveEntryList ( &CurSink->ActiveQueue ) ;
            }
        } else if ((CurSink->SinkStatus & MIXER_SINK_STATUS_LOCK_ERROR) == 0) {
#ifdef REALTIME_THREAD        
            if (!pFilterInstance->RealTimeThread) {
#endif            
                if ( CurSink->fEnable3D && CurSink->f3dParamsChanged ) {
                    if (CurSink->fUseIir3d) {
                        Status3D = UpdateIir3dParams( CurSink );
                    } else {
                        Status3D = UpdateItd3dParams( CurSink->pItdContextLeft,
                                                      CurSink->pItdContextRight,
                                                      CurSink->pNewItd3dParamsLeft,
                                                      CurSink->pNewItd3dParamsRight );
                    }

                    // Mute if we can't update the 3D parameters.
                    if(!NT_SUCCESS(Status3D)) {
                        ple = CurSink->ActiveQueue.Flink ;
                        continue;
                    }

                    InterlockedExchange( &(CurSink->f3dParamsChanged), FALSE );
                }
#ifdef REALTIME_THREAD        
            }
#endif            

            InChannels = CurSink->WaveFormatEx.nChannels;
            InSampleSize = CurSink->WaveFormatEx.wBitsPerSample/8;

            pMixBuffer = Buf;
            samplesleft = MixBufferSize;

            // Calculate the number of input samples needed (and round up)
            nInputSamples = SrcInputBufferSize(CurSink->pActualSrc, MixBufferSize);
            if (CurSink->fCreate3D) {
                if (CurSink->pInfo->Doppler.UpSampleRate != CurSink->pInfo->Doppler.DownSampleRate) {
                    samplesleft = nInputSamples;
                }
                nInputSamples = SrcInputBufferSize(&CurSink->pInfo->Doppler, nInputSamples);
            }

            TempBuffer = CurSink->pInfo->Stage[CurSink->pInfo->nStages - 1].pOutputBuffer;
            if (TempBuffer) {
                pMixBuffer = TempBuffer;
            }

            if (pWriteContext->fReading) {
                // Set-up stage buffers
                CurSink->pInfo->Stage[0].pInputBuffer = Buf;

                // Convert all of the input data.
                nOutputSamples = pWriteContext->StreamHeader->DataUsed / (OutSampleSize * OutChannels);
                if (nOutputSamples > 0) {
                    samplesleft = SrcOutputBufferSize(CurSink->pActualSrc, nOutputSamples);

                    if (samplesleft > 0) {
                        // Clear the output buffer
                        RtlFillMemory( (PUCHAR)pMixerSource->pScratch2,
                                       (samplesleft * InChannels * sizeof(LONG)),
                                       0 );

                        if (!CurSink->fMuted) {
                        
                            // Complete all of the stages
                            for (i=0; i<CurSink->pInfo->nStages; i++) {
                                START_PERF;
                                nOutputSamples = CurSink->pInfo->Stage[i].pfnStage(
                                                    &CurSink->pInfo->Stage[i],
                                                    nOutputSamples,
                                                    samplesleft);
                                MEASURE_PERF(CurSink->pInfo->Stage[i].AverageTicks);
                            }
                        } else {
                            nOutputSamples = samplesleft;
                        }
                    } else {
                        nOutputSamples = samplesleft;
                    }

                    StreamsMixed++;
                }
            } else {
                // Set-up stage buffers
                CurSink->pInfo->Stage[CurSink->pInfo->nStages - 1].pOutputBuffer = pMixBuffer;

                // Get enough input samples to complete an output buffer.
                temp = CurSink->pInfo->Stage[0].pOutputBuffer;
                nOutputSamples = 0;

                if ( CurSink->pClock ) {
                    MxUpdatePhysicalTime( CurSink->pClock,
                                          nInputSamples * CurSink->BytesPerSample) ;
                }


                do {
                    // Get some input
                    pInputBuffer = CurSink->pfnGetBlock ( CurSink,
                                                      nInputSamples,
                                                      &BlockCount,
                                                      &FreeIrp,
                                                      &ReleaseIrp ) ;
                    UpdateSinkTime ( CurSink, BlockCount ) ;


                    if (pInputBuffer==NULL) {
#ifdef PERF_COUNT
						if (!fStarved) {
//						    _DbgPrintF( DEBUGLVL_TERSE, ("Sink Starved") ) ;
						    fStarved = TRUE;
						}
					   	gSinkStarved++;
#endif                  
                        
                        if (LoggerHandle && TraceEnable) {
                            currentPC = KeQueryPerformanceCounter (NULL);
                            if (CurSink->fStarvationDetected==FALSE) {
                                CurSink->fStarvationDetected = TRUE;
                                PerfLogGlitch ((ULONG_PTR)CurSink, TRUE, currentPC.QuadPart, CurSink->LastStateChangeTimeSample);
                            
                            } //if
                            CurSink->LastStateChangeTimeSample = currentPC.QuadPart;
                        } //if                        

                        // We are starving. Insert our starvation noise.
                        gNumSilenceSamplesInserted += nInputSamples ;
                        BlockCount = nInputSamples;
                        if (InSampleSize == 1) {
                            pInputBuffer = (PSHORT)Silence8;
                            if (BlockCount*InChannels > sizeof(Silence8)) {
                                BlockCount = sizeof(Silence8)/InChannels;
                            }
                        } else {
                            pInputBuffer = (PSHORT)SilenceBuffer;
                            if (BlockCount*InChannels*InSampleSize > sizeof(SilenceBuffer)) {
                                BlockCount = sizeof(SilenceBuffer)/(InChannels*InSampleSize);
                            }
                        }

                        
#ifdef INSERT_STARVATION_NOISE
                        // We are starving. Insert our starvation noise.
                        BlockCount = nInputSamples;
                        pInputBuffer = (PSHORT)(Dither);
                        if (nInputSamples*InSampleSize*InChannels > sizeof(Dither)) {
                            BlockCount = sizeof(Dither)/(InSampleSize*InChannels);
                        }
#endif
                    }
                    else {
                    
#ifdef REALTIME_THREAD        
                        if (!pFilterInstance->RealTimeThread) {
#endif            
                            if (LoggerHandle && TraceEnable) {
                                currentPC = KeQueryPerformanceCounter (NULL);
                                if (CurSink->fStarvationDetected ==TRUE) {
                                    CurSink->fStarvationDetected = FALSE;
                                    PerfLogGlitch ((ULONG_PTR)CurSink, FALSE, currentPC.QuadPart, CurSink->LastStateChangeTimeSample);
                                } //if
                                CurSink->LastStateChangeTimeSample = currentPC.QuadPart;
                            }//if
#ifdef REALTIME_THREAD        
                        }
#endif            
                        
                        

#ifdef PERF_COUNT
                        fStarved = FALSE;
#endif
                        
                    }

                    if (BlockCount) {
                        // Set-up first stage buffers
                        CurSink->pInfo->Stage[0].pInputBuffer = pInputBuffer;

                        if (!CurSink->fMuted) {
                            // Do stage one
                            START_PERF;
                            CurSink->pInfo->Stage[0].pfnStage(&CurSink->pInfo->Stage[0], BlockCount, samplesleft);
                            MEASURE_PERF(CurSink->pInfo->Stage[0].AverageTicks);
                        }

                        // Update counters
                        CurSink->pInfo->Stage[0].pOutputBuffer = (PLONG)CurSink->pInfo->Stage[0].pOutputBuffer +
                                                          BlockCount * CurSink->pInfo->Stage[0].nOutputChannels;
                        nOutputSamples += BlockCount;
                        nInputSamples -= BlockCount;
                    }
            
                    if (FreeIrp) {
                        pIrpStack = IoGetCurrentIrpStackLocation( FreeIrp );
                        AddIrpToAgingQueue ( pFilterInstance,
                                             CurSink,
                                             FreeIrp,
                                             pIrpStack->Parameters.Others.Argument3,
                                             (CurSink->InterfaceId == KSINTERFACE_MEDIA_WAVE_QUEUED)
                                             );
                        // If the last parameter is TRUE, we keep the irp
                        // in AgingQueue until all pending Irps are completed.
                        // Otherwise IRP is completed after the first sourceirp 
                        // completion.
                    }
                    if (ReleaseIrp) {
                        KsReleaseIrpOnCancelableQueue(
                                ReleaseIrp,
                                (CurSink->InterfaceId ==
                                KSINTERFACE_STANDARD_STREAMING)?
                                                NULL:MxCancelIrp) ;
                    }                
                } while (nInputSamples > 0 && pInputBuffer);

                CurSink->pInfo->Stage[0].pOutputBuffer = temp;

                if (!CurSink->fMuted) {
                    // Complete the other stages
                    for (i=1; i<CurSink->pInfo->nStages; i++) {
                        if (CurSink->pInfo->Stage[i].pOutputBuffer == pMixBuffer) {
                            // If we're writing to the output buffer,
                            // We know how many samples are left to write
                            samplesleft = MixBufferSize;
                        }
                        START_PERF;
                        nOutputSamples = CurSink->pInfo->Stage[i].pfnStage(&CurSink->pInfo->Stage[i],
                                                                nOutputSamples,
                                                            samplesleft);
                        MEASURE_PERF(CurSink->pInfo->Stage[i].AverageTicks);
                    }

                    StreamsMixed++;
                }
            }    
            CurSink->pInfo->Stage[CurSink->pInfo->nStages - 1].pOutputBuffer = TempBuffer;
        	ASSERT(samplesleft >= 0);
        }

        ple = CurSink->ActiveQueue.Flink ;
    }
    
    if (StreamsMixed && nOutputSamples > 0) {
        nStagesToDo = pMixerSource->Info.nStages;
        FinalBufferPresent = TRUE;
        if (pWriteContext->fReading) {
            MixBufferSize = nOutputSamples;
            FinalBufferPresent = MxCaptureBufferPresent(pFilterInstance);
            nStagesToDo--;
        }

        if (FinalBufferPresent) {
            for (i=0; i<nStagesToDo; i++) {
                pInputBuffer = pMixerSource->Info.Stage[i].pInputBuffer;
                temp = pMixerSource->Info.Stage[i].pOutputBuffer;
                if (pInputBuffer == NULL) {
                    pMixerSource->Info.Stage[i].pInputBuffer = Buf;
                }
                if (temp == NULL) {
                    pMixerSource->Info.Stage[i].pOutputBuffer = Buf;
                }
                START_PERF;
                pMixerSource->Info.Stage[i].pfnStage(&pMixerSource->Info.Stage[i],
                                                     MixBufferSize,
                                                     MixBufferSize);
                MEASURE_PERF(pMixerSource->Info.Stage[i].AverageTicks);
                pMixerSource->Info.Stage[i].pInputBuffer = pInputBuffer;
                pMixerSource->Info.Stage[i].pOutputBuffer = temp;
            }
        }

        // The last stage might need to be done in partial buffers (in the case of a reverse pump)
        if (pWriteContext->fReading && FinalBufferPresent) {
            CurSink = (PMIXER_SINK_INSTANCE) CONTAINING_RECORD (
                                                        pFilterInstance->ActiveSinkList.Flink,
                                                        MIXER_SINK_INSTANCE,
                                                        ActiveQueue ) ;
                                                        
            if ( CurSink->pClock ) {
                MxUpdatePhysicalTime( CurSink->pClock, nOutputSamples * CurSink->BytesPerSample) ;
            }
            
            pMixBuffer = pMixerSource->Info.Stage[i].pInputBuffer;
            TempBuffer = pMixBuffer;
            do {
                // Get some input
                pInputBuffer = CurSink->pfnGetBlock ( CurSink,
                                                      nOutputSamples,
                                                      &BlockCount,
                                                      &FreeIrp,
                                                      &ReleaseIrp ) ;
                UpdateSinkTime ( CurSink, BlockCount ) ;

                if (pInputBuffer && BlockCount) {
                    pMixerSource->Info.Stage[i].pInputBuffer = pMixBuffer;
                    pMixerSource->Info.Stage[i].pOutputBuffer = pInputBuffer;
                    START_PERF;
                    pMixerSource->Info.Stage[i].pfnStage(&pMixerSource->Info.Stage[i],
                                                         BlockCount,
                                                         nOutputSamples);
                    MEASURE_PERF(pMixerSource->Info.Stage[i].AverageTicks);

#ifdef VERIFY_CAPTURE_DATA
                    for (j=0; j<(BlockCount * CurSink->WaveFormatEx.nChannels); j++) {
                        if (((PBYTE)pInputBuffer)[j] != 0x80) {
                            ZeroSampleCount = 0;
                        } else {
                            ZeroSampleCount++;
                        }
                    }
                    if (ZeroSampleCount > 500) {
#ifdef _X86_                    
                        _asm int 3;
#endif                        
                    }
#endif
                    // Update counters
                    pMixBuffer += (BlockCount * CurSink->WaveFormatEx.nChannels);
                    nOutputSamples -= BlockCount;
                }
        	
                if (FreeIrp) {
                    pIrpStack = IoGetCurrentIrpStackLocation( FreeIrp );
                      MxCompleteRequest(FreeIrp);
//                    AddIrpToAgingQueue ( pFilterInstance,
//                                         CurSink,
//                                         FreeIrp,
//                                         pIrpStack->Parameters.Others.Argument3,
//                                         FALSE
//                                         );
                }

                if (ReleaseIrp) {
                    KsReleaseIrpOnCancelableQueue(
                            ReleaseIrp,
                            (CurSink->InterfaceId ==
                                 KSINTERFACE_STANDARD_STREAMING)?
                            NULL:MxCancelIrp) ;
                }
            } while (nOutputSamples > 0 && pInputBuffer);
            pMixerSource->Info.Stage[i].pInputBuffer = TempBuffer;
            pMixerSource->Info.Stage[i].pOutputBuffer = NULL;
        } else if (!pWriteContext->fReading) {
            // In case the number of channels changed on the way through (e.g. surround encoding)
            pWriteContext->StreamHeader->DataUsed = MixBufferSize * pMixerSource->BytesPerSample ;
        }
    }
        
    Index = (pMixerSource->BlockInfoIndex+1)%MAXNUMMIXBUFFERS ;
    pMixerSource->BlockInfoIndex = Index ;
    pMixerSource->BlockInfo[Index].NumBytes =
                                        pWriteContext->StreamHeader->DataUsed ;
    pMixerSource->BlockInfo[Index].BytesPerSample =
                                        pMixerSource->BytesPerSample ;
//    if (pMixerSource->fUsesFloat) {
        RestoreFloatState(&FloatSave);
//    }
#ifdef REALTIME_THREAD
    if (pFilterInstance->RealTimeThread) {
        pMixerSource->BytesSubmitted += pWriteContext->StreamHeader->DataUsed ;
    }
#endif    
}

NTSTATUS WriteBuffer
(
    PMIXER_WRITE_CONTEXT    pWriteContext
)
{
    PIO_STACK_LOCATION      pIrpStack ;
    PMIXER_SOURCE_INSTANCE  pMixerSource ;
    NTSTATUS                Status = STATUS_SUCCESS;

#ifdef REALTIME_THREAD
    PFILTER_INSTANCE pFilterInstance = pWriteContext->pFilterInstance;
    ULONG   OutChannels, OutSampleSize ;
    ULONG   MixBufferSize ;

    pMixerSource = (PMIXER_SOURCE_INSTANCE) CONTAINING_RECORD (pFilterInstance->SourceConnectionList.Flink, MIXER_INSTHDR, NextInstance) ;
    ZDbgPrint("'WriteBuffer(%d)\n",(pWriteContext - (&pMixerSource->WriteContext[0])));
    if (pFilterInstance->RealTimeThread) {
        OutChannels = pMixerSource->WaveFormatEx.nChannels ;
        OutSampleSize = pMixerSource->WaveFormatEx.wBitsPerSample/8 ;

        MixBufferSize = (pMixerSource->WaveFormatEx.nSamplesPerSec  * MIXBUFFERDURATION) ;
        MixBufferSize += pMixerSource->LeftOverFraction ;
        pMixerSource->LeftOverFraction = MixBufferSize % 1000 ;
        MixBufferSize /= 1000 ;

        if (pWriteContext->fReading == FALSE) {
            pWriteContext->StreamHeader->DataUsed = MixBufferSize * pMixerSource->BytesPerSample ;

            RtlFillMemory(  pWriteContext->StreamHeader->Data,
                            pWriteContext->StreamHeader->DataUsed,
                            0 );
        }
        pMixerSource->RtWriteIndex = (pMixerSource->RtWriteIndex + 1) % MAXNUMMIXBUFFERS;
    }
#endif

    _DbgPrintF( DEBUGLVL_VERBOSE, ("Writing one buffer") ) ;

    MxResetIrp(pWriteContext->pIrp) ;

    pWriteContext->pIrp->MdlAddress = pWriteContext->pMdl;

    pIrpStack = IoGetNextIrpStackLocation (pWriteContext->pIrp) ;

    pIrpStack->MajorFunction = IRP_MJ_DEVICE_CONTROL ;
    pIrpStack->MinorFunction = 0 ;
    pIrpStack->Flags = 0 ;
    pIrpStack->Control = 0 ;
    pIrpStack->DeviceObject = pWriteContext->pFilterInstance->pNextDevice ;
    pIrpStack->FileObject = pWriteContext->pFilterInstance->pNextFileObject ;

    pIrpStack->Parameters.DeviceIoControl.IoControlCode = IOCTL_KS_WRITE_STREAM ;
    pWriteContext->pIrp->UserBuffer = pWriteContext->StreamHeader ;
    pIrpStack->Parameters.DeviceIoControl.OutputBufferLength = sizeof ( KSSTREAM_HEADER ) ;
    pIrpStack->Parameters.DeviceIoControl.Type3InputBuffer = NULL ;
    pIrpStack->Parameters.DeviceIoControl.InputBufferLength = 0 ;
    if (pWriteContext->fReading) {
        pIrpStack->Parameters.DeviceIoControl.IoControlCode = IOCTL_KS_READ_STREAM ;
    }

    // Initialize StreamHeader
    // Note: the DataPacket itself is initialized at allocation (in CreateSourcePin)

    InitStreamPacket (pWriteContext) ;
    pWriteContext->pIrp->RequestorMode = KernelMode ;
    pWriteContext->pIrp->Flags = IRP_NOCACHE ;

    IoSetCompletionRoutine ( pWriteContext->pIrp,
                                    MxWriteComplete,
                                    pWriteContext,
                                    TRUE,
                                    TRUE,
                                    TRUE ) ;

    _DbgPrintF (DEBUGLVL_VERBOSE, ("Calling the next driver") ) ;


#if defined(LOG_TO_FILE) && !defined(LOG_HRTF_DATA) && !defined(LOG_CAPTURE_ONLY)
    if (fLogToFile) {
        FileIoRoutine (pWriteContext->pFilterInstance,
                       pWriteContext->StreamHeader->Data,
                       pWriteContext->StreamHeader->DataUsed);
    }
#endif

#ifdef REALTIME_THREAD

    if (pFilterInstance->RealTimeThread) {

        ULONG Value;

        Value=InterlockedExchange(&pWriteContext->InUse, WRITE_CONTEXT_QUEUED);

        ASSERT( Value == WRITE_CONTEXT_INUSE );
        
        ZDbgPrint("'WB mix=%d write=%d start=%x\n",pMixerSource->RtMixIndex, pMixerSource->RtWriteIndex, pWriteContext->StreamHeader->Data);
    }

#endif

    Status = IoCallDriver ( pWriteContext->pFilterInstance->pNextDevice,
                                                 pWriteContext->pIrp )  ;

    if ( !NT_SUCCESS ( Status ) ) {
        // removing the debug trap
        // traced through this with USB surprise removal
        //
        //_DbgPrintF(DEBUGLVL_ERROR, ("IoCallDriver Failed with Result = %x\n", Status) ) ;
        if (InterlockedCompareExchange(&pWriteContext->InUse, WRITE_CONTEXT_FREE, WRITE_CONTEXT_INUSE)==WRITE_CONTEXT_INUSE) {
            InterlockedDecrement((PLONG)&pWriteContext->pFilterInstance->NumPendingIos);
            InterlockedIncrement(&gIoCallDriverFailedCount);
        }
    }
    else {
        pMixerSource =
            (PMIXER_SOURCE_INSTANCE)
              CONTAINING_RECORD(
               pWriteContext->pFilterInstance->SourceConnectionList.Flink,
               MIXER_INSTHDR,
               NextInstance) ;

#ifdef REALTIME_THREAD
        if (!pFilterInstance->RealTimeThread)
#endif
        {
            pMixerSource->BytesSubmitted += pWriteContext->StreamHeader->DataUsed ;
        }

    }

    return ( STATUS_SUCCESS  ) ;
}

VOID InitStreamPacket
(
   PMIXER_WRITE_CONTEXT pWriteContext
)
{
   PKSSTREAM_HEADER StreamHeader = pWriteContext->StreamHeader ;
   PFILTER_INSTANCE    pFilterInstance ;

   //
   // Setup pFilterInstance for accessing MIXBUFFERDURATION
   //
   pFilterInstance = pWriteContext->pFilterInstance ;

   StreamHeader->PresentationTime =
                       pWriteContext->pFilterInstance->PresentationTime ;
   StreamHeader->Duration = MIXBUFFERDURATION * 10000 ;
   StreamHeader->OptionsFlags = KSSTREAM_HEADER_OPTIONSF_TIMEVALID ;
   StreamHeader->Size = sizeof( KSSTREAM_HEADER ) ;
   StreamHeader->TypeSpecificFlags = 0;
   pWriteContext->pFilterInstance->PresentationTime.Time +=
               (MIXBUFFERDURATION * 10000) ; // ms to 100ns
}

#pragma LOCKED_CODE
#pragma LOCKED_DATA

VOID UpdateJustInTimeLocks
(
    PFILTER_INSTANCE    pFilterInstance
)
{
    PLIST_ENTRY             ple ;
    PMIXER_SINK_INSTANCE    pCurSink ;
    PIRP                    pIrp ;
    PIO_STACK_LOCATION      pIrpStack ;
    PMDL                    pNewMdl ;
    PLOOPPACKET             pLoopPacket ;
    BOOL                    LockSucceeded;

    ple = pFilterInstance->ActiveSinkList.Flink ;
    while ( ple != &pFilterInstance->ActiveSinkList ) {
        pCurSink = (PMIXER_SINK_INSTANCE) CONTAINING_RECORD ( ple, MIXER_SINK_INSTANCE, ActiveQueue ) ;
        if ( pCurSink->SinkState == KSSTATE_RUN &&
             pCurSink->InterfaceId == KSINTERFACE_STANDARD_LOOPED_STREAMING &&
             ((pCurSink->SinkStatus & MIXER_SINK_STATUS_LOCK_ERROR) == 0) ) {
            if ( pIrp = GetFirstIrpInQueue ( pCurSink ) ) {
                pIrpStack = IoGetCurrentIrpStackLocation( pIrp );
                pLoopPacket = pIrpStack->Parameters.Others.Argument3 ;
                if ( pLoopPacket->JustInTimeLock ) {
                    if ( pLoopPacket->pCurMdl != pLoopPacket->LockedMdlHead ) {

                        // UNLOCK the 1st locked mdl
                        MmUnmapLockedPages(
                            MmGetSystemAddressForMdl(pLoopPacket->LockedMdlHead),
                            pLoopPacket->LockedMdlHead ) ;
                        MxUnlockMdl( pLoopPacket->LockedMdlHead ) ;

                        pLoopPacket->LockedMdlHead = GetNextLoopMdl(
                                                      pLoopPacket,
                                                      pLoopPacket->LockedMdlHead ) ;

                        // Lock the next Mdl
                        pNewMdl = NULL ;
                        if ( pLoopPacket->LockedMdlHead ) {
                            pNewMdl = GetNextLoopMdl( pLoopPacket,
                                                      pLoopPacket->LockedMdlHead ) ;
                        }
                        if ( pNewMdl ) {
                            LockSucceeded = TRUE;
                            try {
                                MmProbeAndLockProcessPages( pNewMdl,
                                                        pLoopPacket->Process,
                                                        KernelMode,
                                                        IoReadAccess ) ;
                            }
                            except (EXCEPTION_EXECUTE_HANDLER) {
                                pCurSink->SinkStatus |= MIXER_SINK_STATUS_LOCK_ERROR ;
                                LockSucceeded = FALSE;
                            }
                            if (LockSucceeded) {
                                if (NULL == GetSystemAddressForMdlWithFailFlag( pNewMdl )) {
                                    pCurSink->SinkStatus |= MIXER_SINK_STATUS_LOCK_ERROR ;
                                }
                            }
                        }
                        else {
                            pLoopPacket->NumLockedMdls-- ;
                        }
                    }
                }
            }
        }
        ple = pCurSink->ActiveQueue.Flink ;
    }

}

PMDL GetNextLoopMdl
(
    PLOOPPACKET pLoopPacket,
    PMDL        pMdl
)
{
    PMDL    retMdl = NULL ;

    retMdl = pMdl->Next ;

    if ( !retMdl ) {
        if ( pLoopPacket->CurLoopingState == LOOPING_STATE_LOOPING ) {
            retMdl = pLoopPacket->LoopStartMdl ;
        } else if ( (pLoopPacket->pCurStreamHdr->OptionsFlags & KSSTREAM_HEADER_OPTIONSF_LOOPEDDATA ) &&
                    ( pLoopPacket->CurLoopingState == LOOPING_STATE_NOT_LOOPING )) {
            // When we call loopstgetnext block next time, we will loop!
            retMdl = pLoopPacket->LoopStartMdl ;
        }
    }
    return( retMdl ) ;
}

PIRP GetFirstIrpInQueue
(
    IN PMIXER_SINK_INSTANCE pMixerSink
)
{
    PIRP        pIrp ;
    PLIST_ENTRY ple ;
    KIRQL       OldIrql ;

    pIrp = NULL ;
    KeAcquireSpinLock ( &pMixerSink->WriteSpinLock, &OldIrql ) ;
    if ( IsListEmpty (&pMixerSink->WriteQueue) ) {
        KeReleaseSpinLock ( &pMixerSink->WriteSpinLock, OldIrql ) ;
    }
    else {
        ple = pMixerSink->WriteQueue.Flink ;
        KeReleaseSpinLock ( &pMixerSink->WriteSpinLock, OldIrql ) ;
        pIrp  = (PIRP) CONTAINING_RECORD( ple, IRP, Tail.Overlay.ListEntry );
    }
    return ( pIrp ) ;
}

NTSTATUS FreeDeadIrps
(
   PFILTER_INSTANCE        pFilterInstance
)
{
   PIRP                    Irp ;
   KIRQL                   OldIrql ;

   KeAcquireSpinLock ( &pFilterInstance->MixSpinLock, &OldIrql ) ;
   while ( Irp = KsRemoveIrpFromCancelableQueue(&pFilterInstance->DeadQueue,
                                                &pFilterInstance->AgingDeadSpinLock,
                                                KsListEntryHead,
                                                KsAcquireAndRemove) ) {
       _DbgPrintF(DEBUGLVL_VERBOSE, ("'" STR_MODULENAME "Completing Irp :: %08x\n", Irp) ) ;
       KeReleaseSpinLock ( &pFilterInstance->MixSpinLock, OldIrql ) ;
       MxCompleteRequest ( Irp ) ;
       KeAcquireSpinLock ( &pFilterInstance->MixSpinLock, &OldIrql ) ;
   }

   pFilterInstance->DeadScheduled = FALSE ;
   KeReleaseSpinLock ( &pFilterInstance->MixSpinLock, OldIrql ) ;
   return STATUS_SUCCESS;
}

VOID
AddIrpToAgingQueue
(
    PFILTER_INSTANCE       pFilterInstance,
    PMIXER_SINK_INSTANCE   pMixerSink,
    PIRP                   pIrp,
    PVOID                  Arg3,
    BOOL                   UseNumPendingIos
)
{
    PIO_STACK_LOCATION      pIrpStack;
    ULONG                   Arg4 ;
    KIRQL                   OldIrql ;

    pIrpStack = IoGetCurrentIrpStackLocation( pIrp );

    pIrpStack->Parameters.Others.Argument2 = pMixerSink ;
    pIrpStack->Parameters.Others.Argument3 = Arg3;

#ifdef REALTIME_THREAD
    if (!pFilterInstance->RealTimeThread) {
#endif    
        KeAcquireSpinLock ( &pFilterInstance->MixSpinLock, &OldIrql ) ;
#ifdef REALTIME_THREAD
    }        
#endif


#ifdef REALTIME_THREAD
    if (pFilterInstance->RealTimeThread) {

        Arg4=1;

        if (UseNumPendingIos) {
            PMIXER_SOURCE_INSTANCE pMixerSource;
            ULONG index;

            pMixerSource = (PMIXER_SOURCE_INSTANCE) CONTAINING_RECORD ( pFilterInstance->SourceConnectionList.Flink,
                                                                        MIXER_INSTHDR,
                                                                        NextInstance ) ;

            index=pMixerSource->RtMixIndex;
            index=(index+MAXNUMMIXBUFFERS-1)%MAXNUMMIXBUFFERS;

            while (pMixerSource->WriteContext[index].InUse == WRITE_CONTEXT_MIXED) {
                Arg4++;
                index=(index+MAXNUMMIXBUFFERS-1)%MAXNUMMIXBUFFERS;
            }

        }

    }
    else
#endif    
    Arg4 = (UseNumPendingIos) ? pFilterInstance->NumPendingIos : 1 ;


    pIrpStack->Parameters.Others.Argument4 = ULongToPtr(Arg4);

    KsAddIrpToCancelableQueue( &pFilterInstance->AgingQueue,
                               &pFilterInstance->AgingDeadSpinLock,
                               pIrp,
                               KsListEntryTail,
                               MxCancelIrp );

#ifdef REALTIME_THREAD
    if (!pFilterInstance->RealTimeThread) {
#endif    
        KeReleaseSpinLock ( &pFilterInstance->MixSpinLock, OldIrql ) ;
#ifdef REALTIME_THREAD
    }        
#endif
}


NTSTATUS AgeOneIrp
(
    PIRP    pIrp,
    PULONG  pMoved
)
{
    NTSTATUS            Status = STATUS_SUCCESS ;
    PIO_STACK_LOCATION  pIrpStack ;

    if ( pIrp ) {
        pIrpStack = IoGetCurrentIrpStackLocation( pIrp );
        //
        // Age the IRP
        //
        if ( ((DWORD_PTR)pIrpStack->Parameters.Others.Argument4) ) {
            ((DWORD_PTR)pIrpStack->Parameters.Others.Argument4)-- ;
        }
        //
        // Indicate whether it is time to die
        //
        if ( ((DWORD_PTR)pIrpStack->Parameters.Others.Argument4) ) {
            Status = STATUS_NO_MATCH ;
        }
        else {
            *pMoved = TRUE ;
        }
    }
    return (Status) ;
}


VOID
AgeIrps (
    PFILTER_INSTANCE        pFilterInstance
    )
{
    ULONG                   TimerTripped ;

    TimerTripped = FALSE ;

    KsMoveIrpsOnCancelableQueue(&pFilterInstance->AgingQueue,
                                &pFilterInstance->AgingDeadSpinLock,
                                &pFilterInstance->DeadQueue,
                                NULL,
                                KsListEntryHead,
                                AgeOneIrp,
                                &TimerTripped);

    if ( TimerTripped ) {
        if ( !InterlockedExchange(&pFilterInstance->DeadScheduled, TRUE) ) {
            ExInitializeWorkItem (&pFilterInstance->FreeIrpsWorkItem,
                                    FreeDeadIrps,
                                    pFilterInstance);
            KsQueueWorkItem ( pFilterInstance->DelayedWorkerObject, &pFilterInstance->FreeIrpsWorkItem );
        }
    }
}

ULONG UpdateNumMixBuffers
(
    PFILTER_INSTANCE pFilterInstance
)
{
    KIRQL OldIrql ;
    ULONG retval ;

    KeAcquireSpinLock ( &pFilterInstance->MixSpinLock, &OldIrql ) ;
    ZDbgPrint("'ZZ-UM:NP=%x, NM=%x\n",
                pFilterInstance->NumPendingIos,
                pFilterInstance->NumBuffersToMix);
    retval = pFilterInstance->CurrentNumMixBuffers -
             pFilterInstance->NumPendingIos ;
    KeReleaseSpinLock ( &pFilterInstance->MixSpinLock, OldIrql ) ;
    return(retval);
}

#ifdef REALTIME_THREAD


LONG
PositionToIndex(
    PFILTER_INSTANCE pFilterInstance,
    PMIXER_SOURCE_INSTANCE pMixerSource,
    PUCHAR LinearBaseAddress
)
{

    // If any of the bottom 4 bits are set, then this address does NOT have the
    // index built into the bottom bits of the address.

    if (NULL==LinearBaseAddress || (ULONG_PTR)LinearBaseAddress&0xf) {
        return (-1);
    }
    else {
        ULONG Index;

        // We calculate the bit mask for pulling out the index from the address.
        // Note that this will work whether MAXNUMMIXBUFFERS is a power of 2 or not!
        // Indeces range from 0 to MAXNUMMIXBUFFERS-1.

        //IndexMask=(((MAXNUMMIXBUFFERS-1)<<5)|(((MAXNUMMIXBUFFERS-1)<<5)-1))>>1;


        // Although the above code does work properly, we also want to check that
        // all of our buffers are page aligned.  This makes our job much simpler,
        // since we simply always mask off the bottom 12 bits.  If we ever get
        // an index greater than MAXNUMBMIXBUFFERS-1, then there is a problem,
        // otherwise not only do we have the correct index, but our buffers are
        // properly page aligned as well.  (As closely page aligned as they can
        // be given that we offset them slightly to force the buffer indeces into
        // the address of the buffer.)

        Index=(ULONG)((ULONG_PTR)LinearBaseAddress&0xfff)>>4;

        if (Index>MAXNUMMIXBUFFERS-1) {
            // Our buffer is not properly page aligned.  Barf.
            DbgBreakPoint();
            Index=(-1);
            }

        return Index;
    }

}



NTSTATUS
GetRtPosFunction
(
    PFILTER_INSTANCE    pFilterInstance
)
{
    KSPROPERTY          RtAudioProperty ;
    PRTAUDIOGETPOSITION pfnRtPositionFunction ;
    NTSTATUS            Status ;
    ULONG               BytesReturned ;

    pFilterInstance->pfnRtAudioGetPosition = NULL;

    RtAudioProperty.Set   = KSPROPSETID_RtAudio ;
    RtAudioProperty.Id    = KSPROPERTY_RTAUDIO_GETPOSITIONFUNCTION ;
    RtAudioProperty.Flags = KSPROPERTY_TYPE_GET ;

    Status = KsSynchronousIoControlDevice (
                   pFilterInstance->pNextFileObject,
                   KernelMode,
                   IOCTL_KS_PROPERTY,
                   &RtAudioProperty,
                   sizeof (KSPROPERTY),
                   &pfnRtPositionFunction,
                   sizeof (PRTAUDIOGETPOSITION),
                   &BytesReturned ) ;

    if ( BytesReturned != sizeof(PRTAUDIOGETPOSITION) ) {
        Status = STATUS_INVALID_DEVICE_REQUEST ;
    }
    else {
        pFilterInstance->pfnRtAudioGetPosition = pfnRtPositionFunction ;
    }
    return ( Status ) ;
}


#ifdef LOG_RT_POSITION
ULONG RtInfoIndex=(ULONG)(-1);
ULONG RtGetPosInfo[512][4];
#endif


VOID RtMix(PFILTER_INSTANCE pFilterInstance, ThreadStats *Statistics)
{

	PMIXER_SOURCE_INSTANCE pMixerSource;
    KIRQL OldIrql ;
    ULONG Mixed;
    PUCHAR pPosition;
    LONG Offset;
    ULONG HardwareIndex;
    BOOL FirstNegativeOffset;
    ULONGLONG AcquireLockStartTime;
    ULONGLONG GetPosStartTime;
    ULONGLONG PeriodStart;

    #ifdef LOG_RT_POSITION
    RtInfoIndex=(ULONG)(-1);
    #endif
    FirstNegativeOffset=TRUE;
	PeriodStart=Statistics->ThisPeriodStartTime;

	// This is the RealTime mix routine
	while (TRUE) {
	    Mixed=FALSE;
	    
        // Make sure it doesn't take too long to acquire the SpinLock

        AcquireLockStartTime=Statistics->ThisTimesliceStartTime;

        KeAcquireSpinLock ( &pFilterInstance->MixSpinLock, &OldIrql );

        if ((Statistics->ThisTimesliceStartTime-AcquireLockStartTime)/MSEC>3) {
            //__asm int 3;
            }
        
        if (pFilterInstance->fPauseMix) {
        	pFilterInstance->MixHoldOffCount++;
        	if (pFilterInstance->MixHoldOffCount==10) {
        		//__asm int 3;
        		}
        	}
        else {
        	if (pFilterInstance->MixHoldOffCount>=10) {
        		//__asm int 3;
        		}
        	pFilterInstance->MixHoldOffCount=0;
        	}

        if (pFilterInstance->fNeedOptimizeMix) {
        	pFilterInstance->OptimizeMixHoldOffCount++;
        	if (pFilterInstance->OptimizeMixHoldOffCount==11) {
        		//__asm int 3;
        		}
        	}
        else {
        	if (pFilterInstance->OptimizeMixHoldOffCount>=11) {
        		//__asm int 3;
        		}
        	pFilterInstance->OptimizeMixHoldOffCount=0;
        	}


        if (!pFilterInstance->fPauseMix && 
            pFilterInstance->ActivePins > 0 &&
            !pFilterInstance->fNeedOptimizeMix ) {

		    pMixerSource = (PMIXER_SOURCE_INSTANCE) CONTAINING_RECORD ( pFilterInstance->SourceConnectionList.Flink,
                                                               MIXER_INSTHDR,
                                                               NextInstance ) ;

            do {

            pPosition=NULL;

            GetPosStartTime=Statistics->ThisTimesliceStartTime;

            // Get the position of the hardware in the irps we have queued down.
            if ((*pFilterInstance->pfnRtAudioGetPosition)(pFilterInstance->pNextFileObject, &pPosition, &Offset)==STATUS_SUCCESS) {
				HardwareIndex=PositionToIndex(pFilterInstance, pMixerSource, pPosition);
                }
            else {
                HardwareIndex=(-1);
                }


            #ifdef LOG_RT_POSITION

            RtInfoIndex++;
            RtGetPosInfo[RtInfoIndex%512][0]=HardwareIndex;
            //RtGetPosInfo[RtInfoIndex%512][1]=(ULONG)((Statistics->ThisTimesliceStartTime-GetPosStartTime)/MSEC);
            RtGetPosInfo[RtInfoIndex%512][1]=Offset;
            RtGetPosInfo[RtInfoIndex%512][2]=pMixerSource->RtWriteIndex;
            RtGetPosInfo[RtInfoIndex%512][3]=pMixerSource->RtMixIndex;

            #endif


            if (HardwareIndex==(-1)) {
                FirstNegativeOffset=TRUE;
                break;
                }

            // If HardwareIndex is not (-1) and we have a negative offset, and it is the
            // first one, then we are starting up a stream and we need to set the first
            // buffer to mix into.
            if (Offset<0 && TRUE==FirstNegativeOffset) {
                FirstNegativeOffset=FALSE;
                pMixerSource->RtMixIndex=HardwareIndex;
                }

            if (Offset>=0) {
                FirstNegativeOffset=TRUE;
                }

            if ((TRUE==FirstNegativeOffset && HardwareIndex==pMixerSource->RtMixIndex) ||
                (pMixerSource->RtMixIndex+MAXNUMMIXBUFFERS-HardwareIndex)%MAXNUMMIXBUFFERS>10) {
                //__asm int 3;
                pMixerSource->RtMixIndex=(HardwareIndex+1)%MAXNUMMIXBUFFERS;
                }


            if (pMixerSource->WriteContext[pMixerSource->RtMixIndex].InUse == WRITE_CONTEXT_QUEUED) {
                MixOneBuff( pFilterInstance, &pMixerSource->WriteContext[pMixerSource->RtMixIndex] );
                pMixerSource->WriteContext[pMixerSource->RtMixIndex].InUse = WRITE_CONTEXT_MIXED;
                pMixerSource->RtMixIndex = (pMixerSource->RtMixIndex + 1) % MAXNUMMIXBUFFERS;
                Mixed=TRUE;
                }
            else {
                //__asm int 3;
                break;
                }

            } while ((pMixerSource->RtMixIndex+MAXNUMMIXBUFFERS-HardwareIndex)%MAXNUMMIXBUFFERS<3);

        }

        KeReleaseSpinLock ( &pFilterInstance->MixSpinLock, OldIrql ) ;

    	if (!Mixed) {
    	    PeriodStart=Statistics->ThisPeriodStartTime;
    	    RtYield(0, 0);
    	}
    	else {
    		ULONGLONG YieldTime;

    		// Note that in this case (MIXED==TRUE) we assume that we have a 
    		// valid HardwareIndex!
    		YieldTime=Statistics->Period;
    		if ((pMixerSource->RtMixIndex+MAXNUMMIXBUFFERS-HardwareIndex)%MAXNUMMIXBUFFERS>4) {
    			// If we are more than 3 ahead, then yield an extra period.
    			YieldTime+=Statistics->Period;
    			}
    	    RtYield(PeriodStart, YieldTime);
    		PeriodStart+=YieldTime;
    	}
	}
}
#endif // REALTIME_THREAD

NTSTATUS MxWriteComplete
(
    PDEVICE_OBJECT       pDeviceObject,
    PIRP                 pIrp,
    PMIXER_WRITE_CONTEXT pWriteContext
)
{
    PFILTER_INSTANCE pFilterInstance ;
    KIRQL OldIrql ;
    PMIXER_SOURCE_INSTANCE      pMixerSource;
#ifdef PERF_COUNT
	LARGE_INTEGER	Frequency;	
#endif
    BOOL TimerMix = FALSE;
    BOOL BufferRemoved = FALSE;
    ULONG_PTR LowerLimit, UpperLimit;

    pFilterInstance = pWriteContext->pFilterInstance ;

    KeAcquireSpinLock ( &pFilterInstance->MixSpinLock, &OldIrql ) ;
    ZDbgPrint("'ZZ-WC:IRP=%x\n", pIrp);

    pMixerSource = (PMIXER_SOURCE_INSTANCE) CONTAINING_RECORD ( pFilterInstance->SourceConnectionList.Flink,
                                                               MIXER_INSTHDR,
                                                               NextInstance ) ;

    ZDbgPrint("'MxWriteComplete(%d),status=%x\n", (pWriteContext - (&pMixerSource->WriteContext[0])), pIrp->IoStatus.Status);

    //
    // one less IRP pending
    //
    ZDbgPrint("'ZZ-WC1:NP--\n");
    InterlockedDecrement((PLONG)&pFilterInstance->NumPendingIos) ;
    ASSERT ( pFilterInstance->NumPendingIos <= pFilterInstance->CurrentNumMixBuffers ) ;

    if ( pIrp->IoStatus.Status != STATUS_SUCCESS && pIrp->IoStatus.Status != STATUS_CANCELLED ) {
#if DBG
        //  We want to see this debug spew, but only every sixteen....
        if ((pFilterInstance->ContinuousErrorCount % 16) == 0) {
            DbgPrint("'" STR_MODULENAME "WriteComplete error %08x\n", pIrp->IoStatus.Status );
        }
#endif
       pFilterInstance->ContinuousErrorCount++ ;
    }
    else {
       pFilterInstance->ContinuousErrorCount = 0 ;
    }


    if ( pIrp->Cancel ) {
        #if DBG
        DbgPrint("'" STR_MODULENAME "MxWriteComplete: Canceled\n" );
        #endif
    }


#ifdef REALTIME_THREAD
/*
    if (pFilterInstance->RealTimeThread &&
        pWriteContext->InUse!=WRITE_CONTEXT_MIXED) {
        __asm int 3;
        }
*/
#endif


    //
    // Mark that this mix buffer is available for mixing
    //
    pWriteContext->InUse = WRITE_CONTEXT_FREE ;


    //
    // Check if we need to remove this buffer from the pool because it was
    // added from our timer driven mix thread, and is not needed anymore.
    //
    if ( pFilterInstance->NoGlitch ) {

        IoGetStackLimits(&LowerLimit, &UpperLimit);

        if (KeGetCurrentThread()==pFilterInstance->WorkerThreadObject &&
            (ULONG_PTR)&pDeviceObject >= LowerLimit &&
            (ULONG_PTR)&pDeviceObject <= UpperLimit) {

            // This completion is happening from within the mix thread.
            if ( pFilterInstance->WritingTimerMixedBuffer ) {
                // The mix thread woke up from a timer.
                TimerMix = TRUE;
            }
        }

        if ( TimerMix == FALSE ) {
            // We either got a completion from within a DPC, or from within the mix
            // thread that woke up from a DPC.  Cancel the timer.
            // We will reschedule it just before we leave MxWorker when
            // we have finished mixing buffers.
            // We do this so that as long as buffer completions are firing, we stay
            // synchronized to them.  When the completions get held off by other long
            // running DPCs, we use our timer to continue sending buffers down
            // to the hardware.
            // Most of the time we should be scheduled because the completion
            // event gets fired.  Only when we would have glitched should we get
            // scheduled from the timer firing.
            // We cancel the timer as early as possible and schedule it as late
            // as possible to try to help stay running from DPC completions and not
            // from the timer.
            KeCancelTimer( &pFilterInstance->WorkerThreadTimer );
        }

        if ( (LONG)(pFilterInstance->CurrentNumMixBuffers - MINNUMMIXBUFFERS) > 0 ) {
            // Remove this buffer from pool of available buffers.
            pFilterInstance->CurrentNumMixBuffers-- ;
            pWriteContext->InUse = WRITE_CONTEXT_UNAVAILABLE ;
            BufferRemoved = TRUE;
        }

    }

    //
    // If it was the last IRP and if we are closing Source Pin then signal
    // the Close event.
    //
    if ( pFilterInstance->ClosingSource ) {
        ASSERT ( pFilterInstance->ActivePins == 0 );
        if ( !pFilterInstance->NumPendingIos ) {
            KeSetEvent ( &pFilterInstance->CloseEvent, 0, FALSE ) ;
        }
        goto exit;
    }
    else {
        if ( !pFilterInstance->NumPendingIos ) {
            InterlockedIncrement(&gNumCompletionsWhileStarved) ;
#ifdef PERF_COUNT       
            //_DbgPrintF(DEBUGLVL_TERSE, (STR_MODULENAME "Starving renderer\n") );
#else
            _DbgPrintF(DEBUGLVL_VERBOSE, (STR_MODULENAME "Starving renderer\n") );
#endif
        }
    }


    if (pIrp->Cancel ||
        pFilterInstance->ContinuousErrorCount >= MAXERRORCOUNT ||
        pFilterInstance->ActivePins == 0 ) {
        //
        // If the renderer is canceling our IRPs, it is trying to STOP
        // Do not send anymore Irps, in that case.
        // Also if we do not have any active pins, we should not be sending
        // any more IRPs down
        //
        if ( pFilterInstance->NoGlitch ) {
            KeCancelTimer( &pFilterInstance->WorkerThreadTimer );
        }
        goto exit;
    }

   if ( BufferRemoved ) {
        goto checkwakeup;
    }

if ( TRUE 
#ifdef REALTIME_THREAD
    && pFilterInstance->RealTimeThread == 0
#endif
    && pFilterInstance->NoGlitch == FALSE
    )
{

    if (NT_SUCCESS( pIrp->IoStatus.Status ) ) {
        if (pFilterInstance->NumBuffersToMix == (pFilterInstance->CurrentNumMixBuffers-1)
            && pWriteContext->fReading != TRUE) {
            //
            // There is only one (or none) buffer which is either pending or
            // mixed and ready to go. Try adding another mix buffer
            // to the mix pool
            //
            AddAnotherMixBuffer ( pFilterInstance ) ;
        }
    }

    //
    // if all the buffers except this one are with the renderer
    // increment the number of succesive low latency io count
    // and check whether it is time to remove a mix buffer from
    // the mix buffer pool
    //

    if ( pFilterInstance->NumBuffersToMix <= 2 ) {
       pFilterInstance->NumLowLatencyIos++ ;
       if ( pFilterInstance->NumLowLatencyIos >= NUMIOSFORSCALEBACK && pWriteContext->fReading != TRUE ) {
           //
           // We have succesfully gone thru 20 seconds worth of
           // succesive Low latency Ios, remove this buffer from
           // the mix pool, if we did add something earlier
           //
           if ( pFilterInstance->CurrentNumMixBuffers > MINNUMMIXBUFFERS ) {
               pFilterInstance->NumLowLatencyIos = 0 ;
               pFilterInstance->CurrentNumMixBuffers-- ;
               pWriteContext->InUse = WRITE_CONTEXT_UNAVAILABLE ;
               goto exit ;
           }
       }
    }
    else {
       //
       // Looks like we have more than one mix buffer pending
       // Zero out the succesive low latency io count
       //
       pFilterInstance->NumLowLatencyIos = 0 ;
    }

}


    // We are going to send this buffer back down the stack.  In the
    // capture case, we need to mark it as full, so that we will process
    // it in MixOneBuff before sending it back down.
    if (pWriteContext->fReading) {
        pWriteContext->InUse = WRITE_CONTEXT_FULL ;
    }

    //
    // One more buffer ready for mixing
    //
    ZDbgPrint("'ZZ-WC:NM++\n");
    InterlockedIncrement((PLONG)&pFilterInstance->NumBuffersToMix) ;

    //
    // one more IRP pending
    //
    ZDbgPrint("'ZZ-WC:NP++\n");
    InterlockedIncrement((PLONG)&pFilterInstance->NumPendingIos) ;


    ASSERT (pFilterInstance->NumPendingIos <= pFilterInstance->CurrentNumMixBuffers ) ;
    ASSERT (pFilterInstance->NumBuffersToMix <= pFilterInstance->CurrentNumMixBuffers ) ;


checkwakeup:
    // If this completion was fired because our private mix thread
    // woke up on a timer, and mixed and sent another buffer down the stack
    // (Portcls will check if there are buffers to complete when it is sent
    // a buffer, so sending a buffer can cause a completion to occur.)
    // then we do NOT want to signal the event - since we only want
    // to do that when portcls completes us a buffer from its DPC.
    // In this way, we ensure that when we wake up from the timer, we
    // will keep getting woken up from the timer until such time as the
    // DPC queued by portcls starts firing again.

    // If the following 3 things are true, then we do not want to set the
    // event: 1) the current thread is our mix thread, 2) the WritingTimerMixedBuffer
    // flag is TRUE, and 3) the stack we are running on is our own threads
    // stack.   (That will not be the case if a DPC is completing a buffer
    // because DPCs run on their own stack.)


    if (
        TimerMix == FALSE &&
        InterlockedExchange(&pFilterInstance->MixScheduled, TRUE) == FALSE
        ) {
        //
        // No Mix Work item is in progress, go ahead & Queue a new one
        //
        KeSetEvent( &pFilterInstance->WorkerThreadEvent, 0, FALSE ) ;
    }


exit:

    AgeIrps ( pFilterInstance ) ;
    KeReleaseSpinLock ( &pFilterInstance->MixSpinLock, OldIrql ) ;
    return ( STATUS_MORE_PROCESSING_REQUIRED ) ;

}


VOID AddAnotherMixBuffer
(
   PFILTER_INSTANCE    pFilterInstance
)
{
    PMIXER_SOURCE_INSTANCE      pMixerSource;
    PLIST_ENTRY                 ple ;
    ULONG                       i ;

    pFilterInstance->NumLowLatencyIos = 0 ;
    ple = pFilterInstance->SourceConnectionList.Flink ;
    pMixerSource = (PMIXER_SOURCE_INSTANCE) CONTAINING_RECORD ( ple,
                                                               MIXER_INSTHDR,
                                                               NextInstance ) ;
    for ( i = 0; i < MAXNUMMIXBUFFERS; i++ ) {
        if ( pMixerSource->WriteContext[i].InUse == WRITE_CONTEXT_UNAVAILABLE ) {
            pMixerSource->WriteContext[i].InUse = WRITE_CONTEXT_FREE ;
            InterlockedIncrement(&pFilterInstance->CurrentNumMixBuffers) ;
            InterlockedIncrement(&pFilterInstance->NumPendingIos) ;
            ZDbgPrint("'ZZ-AM:NP++\n");
            // We HAVE to use an interlocked increment on NumBuffersToMix because
            // it is not changed under the spinlock in MxWorker!!!  We hit the
            // ASSERT( fFoundContext == TRUE ) in MxWorker on MP machines if we don't
            // use InterlockedIncrement here.
            InterlockedIncrement(&pFilterInstance->NumBuffersToMix) ;
            ZDbgPrint("'ZZ-AM:NM++\n");

            InterlockedIncrement(&gNumMixBuffersAdded) ;

            break ;
        }
    }
}


gEventSignaledCount=0;
gTimerSignaledCount=0;
gTimerSkipMixCount=0;

NTSTATUS MxPrivateWorkerThread
(
    PFILTER_INSTANCE pFilterInstance
)
{
    PMIXER_SOURCE_INSTANCE pMixerSource ;
    PLIST_ENTRY            ple ;
    ULONG WaitCount=1;  // By default we only wait on event.
    PVOID WaitObjects[2];
    NTSTATUS Status;

    KeSetPriorityThread( KeGetCurrentThread(), pFilterInstance->WorkerThreadPriority ) ;

    // If we are running on an MP system, try to set our thread affinity so that we run
    // on the boot processor.  We will turn off all non targeted DPCs and interrupts
    // on that processor.
    
    if ( pFilterInstance->NoGlitch ) {

        KAFFINITY ActiveProcessors=KeQueryActiveProcessors();

        if ( ActiveProcessors&1 ) {
            // On MP machines we wait on both the completion event and the failsafe timer.
            WaitCount=2;

            // Set our thread affinity to the boot processor - which is the one that
            // processes timers.
            KeSetAffinityThread( KeGetCurrentThread(), 1 );
        }
        else {
            // If the boot processor is no longer active.  Turn off NoGlitch mode.
            pFilterInstance->NoGlitch = FALSE;
        }

    }

    WaitObjects[0]=&pFilterInstance->WorkerThreadEvent;
    WaitObjects[1]=&pFilterInstance->WorkerThreadTimer;

    //
    // while true loop waiting for notification
    //
    while ( TRUE ) {
        Status = KeWaitForMultipleObjects( WaitCount,
                               WaitObjects,
                               WaitAny,
                               Executive,
                               KernelMode,
                               FALSE,
                               NULL,
                               NULL) ;
        if ( pFilterInstance->WorkerThreadExit ) {
            break ;
        }

#ifdef REALTIME_THREAD
    if (!pFilterInstance->RealTimeThread) {
#endif

        KeWaitForSingleObject ( &pFilterInstance->ControlMutex,
                                 Executive,
                                 KernelMode,
                                 FALSE,
                                 NULL ) ;

#ifdef REALTIME_THREAD   

    }
    else {

        MxWaitForSingleObject ( &pFilterInstance->ControlMutex,
                                 Executive,
                                 KernelMode,
                                 FALSE,
                                 NULL ) ;

    }
#endif

        if ((Status&1)==0) {
            gEventSignaledCount++;
        }
        else {
            gTimerSignaledCount++;
        }


        if ( !IsListEmpty(&pFilterInstance->SourceConnectionList) ) {
            ple = pFilterInstance->SourceConnectionList.Flink ;
            pMixerSource = (PMIXER_SOURCE_INSTANCE) CONTAINING_RECORD ( ple, MIXER_INSTHDR, NextInstance ) ;            
            MxWorker( &pMixerSource->WriteContext[0], Status&1 );
        }

#ifdef REALTIME_THREAD
    if (!pFilterInstance->RealTimeThread) {
#endif

        KeReleaseMutex ( &pFilterInstance->ControlMutex, FALSE ) ;

#ifdef REALTIME_THREAD   

    }
    else {

        MxReleaseMutex ( &pFilterInstance->ControlMutex, FALSE ) ;

    }
#endif

    }
    PsTerminateSystemThread( STATUS_SUCCESS ) ;
    return STATUS_SUCCESS ;
}


NTSTATUS
MxWorker (
    PMIXER_WRITE_CONTEXT pWriteContext,
    BOOL TimerMix
    )
{
    PFILTER_INSTANCE            pFilterInstance ;
    KIRQL                       OldIrql ;
    PMIXER_SOURCE_INSTANCE      pMixerSource;
    PMIXER_SINK_INSTANCE        CurSink;
    PLIST_ENTRY                 ple ;
    ULONG                       i, TotalMixed ;
#ifdef PERF_COUNT
    LARGE_INTEGER   StartTick, EndTick, Freq;
#endif
    BOOL                        fTooMuchCpu;
    BOOL                        fFoundContext;
    BOOL                        fRecordMix;
    LARGE_INTEGER Time;
    BOOL AllowNewBuffer=TimerMix;

    pFilterInstance = pWriteContext->pFilterInstance ;

    TotalMixed = 0;

    // Loop till we finish mixing all free mix buffers
    // or until we've mixed MAXNUMMIXBUFFERS worth of data.

    //DbgPrint("'MxWork waiting\r\n");

#ifndef PRIVATE_THREAD

#ifdef REALTIME_THREAD
    if (!pFilterInstance->RealTimeThread) {
#endif

        KeWaitForSingleObject ( &pFilterInstance->ControlMutex,
                                 Executive,
                                 KernelMode,
                                 FALSE,
                                 NULL ) ;

#ifdef REALTIME_THREAD   

    }
    else {

        MxWaitForSingleObject ( &pFilterInstance->ControlMutex,
                                 Executive,
                                 KernelMode,
                                 FALSE,
                                 NULL ) ;

    }
#endif

#endif

    //DbgPrint("'MxWork running\r\n");

#ifdef PERF_COUNT
    // Store the worst counter
    EndTick = KeQueryPerformanceCounter(&Freq);
    if (EndTick.QuadPart > pFilterInstance->WorkItemQueueTime.QuadPart) {
    	if (WorstTicksPerWorkItem < ((DWORD) (EndTick.QuadPart - pFilterInstance->WorkItemQueueTime.QuadPart))) {
    		WorstTicksPerWorkItem = ((DWORD) (EndTick.QuadPart - pFilterInstance->WorkItemQueueTime.QuadPart));
    	}
    }
#endif

    ple = pFilterInstance->SourceConnectionList.Flink ;
    pMixerSource = (PMIXER_SOURCE_INSTANCE)
                   CONTAINING_RECORD ( ple,
                                       MIXER_INSTHDR,
                                       NextInstance ) ;

    fTooMuchCpu = FALSE;


    if ( TimerMix ) {
        // TimerMix should never be TRUE unless NoGlitch is also TRUE.
        ASSERT( pFilterInstance->NoGlitch );
        // For now this is not supported for capture.
        ASSERT( pWriteContext->fReading == FALSE );
    }
    

    while ( TRUE ) {

        fRecordMix = FALSE;

        START_PERF;
        KeAcquireSpinLock ( &pFilterInstance->MixSpinLock, &OldIrql ) ;

    if ( pFilterInstance->NoGlitch && pMixerSource->WriteContext[0].fReading == FALSE) {
        // For now we don't support timer wakeup on capture.
        // If the event is ever signaled while we are in our thread,
        // it means a DPC completed while we were running a mix that was not
        // scheduled from a previous DPC.
        if ( KeReadStateEvent(&pFilterInstance->WorkerThreadEvent) ) {
            // We process normally as if the event woke us up.
            // Note that since the event was signaled, it means either a buffer WAS
            // completed, or someone is trying to get us to exit our thread.
            TimerMix = FALSE;
            AllowNewBuffer = FALSE;
        }

        // At this point if TimerMix is TRUE, we better NOT have a scheduled mix.
        // We also should never have any buffers available to mix the first time
        // through the loop.
        if ( TimerMix ) {
            ASSERT( pFilterInstance->MixScheduled == FALSE );
            if ( !TotalMixed ) {
                ASSERT( pFilterInstance->NumBuffersToMix == 0 );
            }
        }
        else {
            pFilterInstance->SkipTimerMix = 0 ;
        }

        if (!pFilterInstance->NumBuffersToMix) {
            if ( TimerMix ) {
                // We get here in 3 different cases.
                // 1) The first time through the loop the first time we wake up on a timer
                // to mix.  In this case, SkipTimerMix will be FALSE, TotalMixed will
                // be zero, and AllowNewBuffer will be TRUE.  So we will add a buffer,
                // mix it, and send it down the stack.
                // 2) The last time through the loop whenever we have woken up on a timer and mixed.
                // In this case, SkipTimerMix will be FALSE and TotalMixed will be non
                // zero, so we then set SkipTimerMix TRUE if we have more than MINNUMMIXBUFFERS
                // down on the hardware.  This is so that in cases where we are waking up
                // more frequently than the hardware is consuming buffers, we skip a buffer
                // every so often so our latency doesn't get too high.
                // 3) The first time through the loop, when we wake up to mix from the timer,
                // and it is NOT the first time we woke up from the timer.  In this case
                // SkipTimerMix will be non zero if we need to skip mixing this time around,
                // and so we don't add another buffer, update SkipTimerMix, and exit.
                if ( pFilterInstance->SkipTimerMix ) {
                    AllowNewBuffer = FALSE;
                    pFilterInstance->SkipTimerMix--;
                }
                else if ( TotalMixed ) {
                    pFilterInstance->SkipTimerMix = pFilterInstance->CurrentNumMixBuffers - MINNUMMIXBUFFERS;
                    gTimerSkipMixCount+=pFilterInstance->SkipTimerMix;
                }
            }

            if ( AllowNewBuffer ) {
                // This is the case we expect when our timer wakes us up.  No buffers
                // ready to mix.  Add one.  We will remove it automatically at the 
                // appropriate time in MxWriteComplete later.
                // Note that this code can also run if a DPC completion happens while
                // running the timer mix - and the completed buffer is removed from
                // the pool by MxWriteComplete.  In that case we grab a new buffer
                // and send it down anyway.  This does mean that our maximum latency
                // is one buffer more than MINNUMMIXBUFFERS.
                ASSERT( KeReadStateEvent(&pFilterInstance->WorkerThreadEvent) == FALSE );
                AddAnotherMixBuffer(pFilterInstance);
            }
        }

        // We only allow adding a new buffer the first time we enter this loop.
        AllowNewBuffer = FALSE;
    }

        if ( !pFilterInstance->NumBuffersToMix ) {
            // No more free buffers to mix

            InterlockedExchange(&pFilterInstance->MixScheduled, FALSE) ;
            KeReleaseSpinLock ( &pFilterInstance->MixSpinLock, OldIrql ) ;
            break ;
#ifndef PRIVATE_THREAD
        } else if ( TotalMixed > MAX_BUFFERS_PER_WORK_ITEM ) {
            // We are using too much cpu. Give someone else a chance.

            //DbgPrint("'MxWork REQUEUING - ERROR!!!\r\n");

            //
            // go ahead & Queue another work item (which will run later)
            //
            ExInitializeWorkItem ( &pFilterInstance->MixWorkItem,
                                   MxWorker,
                                   pWriteContext ) ;
            KsQueueWorkItem ( pFilterInstance->CriticalWorkerObject,
                              &pFilterInstance->MixWorkItem );
            KeReleaseSpinLock ( &pFilterInstance->MixSpinLock, OldIrql ) ;
            break ;
#endif
        } else {
            if (pWriteContext->fReading) {
                if (pMixerSource->WriteContext[pMixerSource->NextBufferIndex].InUse == WRITE_CONTEXT_INUSE) {
                    // The next buffer to mix has not come back yet. Wait until it does.
                    InterlockedExchange(&pFilterInstance->MixScheduled, FALSE) ;
                    KeReleaseSpinLock ( &pFilterInstance->MixSpinLock, OldIrql ) ;
                    goto Exit;
                }
                pWriteContext = &pMixerSource->WriteContext[pMixerSource->NextBufferIndex];
            }

            // we have atleast one free buffer to mix

            ple = pFilterInstance->SourceConnectionList.Flink ;
            pMixerSource = (PMIXER_SOURCE_INSTANCE)
                           CONTAINING_RECORD ( ple,
                                               MIXER_INSTHDR,
                                               NextInstance ) ;

            // Get a Free Buffer
            // Find the first one filled.
#ifdef REALTIME_THREAD    
            if (pFilterInstance->RealTimeThread) {
                pWriteContext = (&pMixerSource->WriteContext[pMixerSource->RtWriteIndex]);
                if ( InterlockedCompareExchange( &pWriteContext->InUse,
                                            WRITE_CONTEXT_INUSE,
                                            WRITE_CONTEXT_FREE ) != WRITE_CONTEXT_FREE ) {
                    InterlockedExchange(&pFilterInstance->MixScheduled, FALSE) ;
                    //__asm int 3;
                    KeReleaseSpinLock ( &pFilterInstance->MixSpinLock, OldIrql ) ;
                    break ;
                }
                
                fFoundContext = TRUE;

                TotalMixed=0;

                //DbgPrint("'MxWork premix start\r\n");

                PreMixUpdate ( pFilterInstance );

                //DbgPrint("'MxWork premix done\r\n");

                KeReleaseSpinLock ( &pFilterInstance->MixSpinLock, OldIrql ) ;

            } else {
#endif            
                fFoundContext = FALSE;
                for ( i = 0; i < MAXNUMMIXBUFFERS; i++ ) {
                    pWriteContext = &pMixerSource->WriteContext[pMixerSource->NextBufferIndex];
                    
                    pMixerSource->NextBufferIndex++;
                    if (pMixerSource->NextBufferIndex > (MAXNUMMIXBUFFERS - 1)) {
                        pMixerSource->NextBufferIndex = 0;
                    }

                    if ( pWriteContext->fReading && 
                        InterlockedCompareExchange ( &pWriteContext->InUse, WRITE_CONTEXT_FREE, WRITE_CONTEXT_FULL) == WRITE_CONTEXT_FULL ) {
                        fFoundContext = TRUE;
                        fRecordMix = TRUE;
                        break;
                    }
                    
                    if ( pWriteContext->InUse == WRITE_CONTEXT_FREE ) {
                        fFoundContext = TRUE;
                        break;
                    }
                }

                // If we don't find a context, then we are dead, because our NumBuffersToMix
                // count will go down, but we will not submit a buffer.  That means our
                // NumBuffersToMix and NumPendingIo counts will be off, and we will lockup
                // when we call WaitForPendingSourceIrps.
                ASSERT ( fFoundContext==TRUE );
                
                if (fFoundContext) {
                    ASSERT(pWriteContext->InUse == WRITE_CONTEXT_FREE);
                    pWriteContext->InUse = WRITE_CONTEXT_INUSE ;
                }

                KeReleaseSpinLock ( &pFilterInstance->MixSpinLock, OldIrql ) ;

                //DbgPrint("'MxWork MIXING start - ERROR\r\n");

                if (fFoundContext) {
                    if (!pWriteContext->fReading) {
                        MixOneBuff ( pFilterInstance, pWriteContext ) ;
                        TotalMixed++;
                    }
                    else if (fRecordMix) {
                        MixOneBuff ( pFilterInstance, pWriteContext ) ;
                        TotalMixed++;
                    }
                }

                //DbgPrint("'MxWork MIXING done - ERROR\r\n");

#ifdef REALTIME_THREAD
            }
#endif            

            MEASURE_PERF(AverageTicksPerMix);
            
            if (!pWriteContext->fReading &&
                (TotalMixed > MAX_BUFFERS_BEFORE_MUTING)) {
                ple = pFilterInstance->ActiveSinkList.Flink ;
                while ( ple != &pFilterInstance->ActiveSinkList ) {
                    CurSink = (PMIXER_SINK_INSTANCE) CONTAINING_RECORD ( ple, MIXER_SINK_INSTANCE, ActiveQueue ) ;

                    // We are using too much time. Try to demote to WORST quality...
                    if (CurSink->SinkState == KSSTATE_RUN && !CurSink->fMuted) {
                        // we'll just mute the stream.
                        // Although this is radical, the alternative is to use 100% of the cpu.
                        CurSink->fMuted = TRUE;
                        CurSink->fTooMuchCpu = TRUE;
                        pFilterInstance->fNeedOptimizeMix = TRUE;
                        TotalMixed = 1;
                        fTooMuchCpu = TRUE;
                        break;
                    }
                    ple = CurSink->ActiveQueue.Flink ;
                }
            }

            // KeReleaseMutex ( &pFilterInstance->ControlMutex, FALSE ) ;

            ZDbgPrint("'ZZ-MW:NM--\n");

            InterlockedDecrement((PLONG)&pFilterInstance->NumBuffersToMix);

            //DbgPrint("'MxWork write buffer start\r\n");

            if (fFoundContext) {
                // Writing the mixed buffer down the stack can cause completions
                // to happen from within our own thread.  Indicate to MxWriteComplete
                // when we are writing a buffer that was mixed when our thread woke
                // up from the timer.  This prevents us from switching back and forth
                // between waking up from the timer and waking up from the event.
                // We keep waking up from the timer until our completion is called from
                // a DPC queued by the driver - at which time the event will be
                // signaled, and we will then restart our timer and try to run only
                // from events.
                pFilterInstance->WritingTimerMixedBuffer = TimerMix;
                WriteBuffer ( pWriteContext ) ;
                pFilterInstance->WritingTimerMixedBuffer = FALSE;
            }

            //DbgPrint("'MxWork write buffer done\r\n");

#ifdef REALTIME_THREAD            
            if (!pFilterInstance->RealTimeThread) {
#endif            
                //DbgPrint("'MxWork update locks start\r\n");
	            if (fFoundContext) {
	                UpdateJustInTimeLocks( pFilterInstance ) ;
	            }
                //DbgPrint("'MxWork update locks done\r\n");
#ifdef REALTIME_THREAD   
            }
#endif

        }

#ifdef PERF_COUNT
        MEASURE_PERF(AverageTicksPerBuffer);
        AverageFrequency = Freq.LowPart;

        if (TotalMixed > gMaxMixed) {
        	gMaxMixed = TotalMixed;
        }
#endif
    }

    // if we mixed less than 40 ms worth of data, turn on the capture pin if it's muted
    if ((!fTooMuchCpu) && (TotalMixed < MAX_BUFFERS_BEFORE_UNMUTING)) {
    	// Unmute one stream at a time
        ple = pFilterInstance->ActiveSinkList.Flink ;
        while ( ple != &pFilterInstance->ActiveSinkList ) {
            CurSink = (PMIXER_SINK_INSTANCE) CONTAINING_RECORD ( ple, MIXER_SINK_INSTANCE, ActiveQueue ) ;
            if (CurSink->SinkState == KSSTATE_RUN && CurSink->fMuted && CurSink->fTooMuchCpu) {
                CurSink->fMuted = FALSE;
                CurSink->fTooMuchCpu = FALSE;
                pFilterInstance->fNeedOptimizeMix = TRUE;
                break;
            }
            ple = CurSink->ActiveQueue.Flink ;
        }
    }

Exit:


    if (pFilterInstance->NoGlitch && TimerMix == FALSE && pMixerSource->WriteContext[0].fReading == FALSE ) {
        // We need to reschedule our timer, since we just finished mixing after
        // the event was signaled.
        // For now we don't support timer wakeup for capture.
        Time.QuadPart = 0;
        Time.QuadPart -= 10000*(MIXBUFFERDURATION + ((MIXBUFFERDURATION - 1) / 2) );
        KeSetTimerEx(&pFilterInstance->WorkerThreadTimer, Time, MIXBUFFERDURATION, NULL);
    }


#ifndef PRIVATE_THREAD

#ifdef REALTIME_THREAD
    if (!pFilterInstance->RealTimeThread) {
#endif

        KeReleaseMutex ( &pFilterInstance->ControlMutex, FALSE ) ;

#ifdef REALTIME_THREAD   

    }
    else {

        MxReleaseMutex ( &pFilterInstance->ControlMutex, FALSE ) ;

    }
#endif

#endif


    //DbgPrint("'MxWork done\r\n");


    return (STATUS_SUCCESS);
}


NTSTATUS MxEndMixing
(
        PFILTER_INSTANCE pFilterInstance
)
{

    KIRQL   OldIrql ;
    ULONG   i;
    PLIST_ENTRY                 ple ;
    PMIXER_SOURCE_INSTANCE      pMixerSource;

    // if there are pending IRPs cancel them and then wait for them to complete.
    KeAcquireSpinLock ( &pFilterInstance->MixSpinLock, &OldIrql ) ;

    ASSERT(pFilterInstance->NumPendingIos >= pFilterInstance->NumBuffersToMix) ;
    ASSERT(pFilterInstance->NumPendingIos <= pFilterInstance->CurrentNumMixBuffers) ;
    ASSERT(pFilterInstance->NumBuffersToMix <= pFilterInstance->CurrentNumMixBuffers) ;

    pFilterInstance->ClosingSource = TRUE ;
    pFilterInstance->NumPendingIos -= pFilterInstance->NumBuffersToMix ;
    pFilterInstance->NumBuffersToMix = 0 ;
    if (pFilterInstance->NumPendingIos) {

        KeReleaseSpinLock ( &pFilterInstance->MixSpinLock, OldIrql ) ;

        ple = pFilterInstance->SourceConnectionList.Flink ;
        pMixerSource = (PMIXER_SOURCE_INSTANCE) CONTAINING_RECORD ( ple, MIXER_INSTHDR, NextInstance ) ;
        for ( i = 0; i < MAXNUMMIXBUFFERS; i++ ) {
            if (pMixerSource->WriteContext[i].InUse != WRITE_CONTEXT_FREE &&
                pMixerSource->WriteContext[i].InUse != WRITE_CONTEXT_UNAVAILABLE) {
                IoCancelIrp( pMixerSource->WriteContext[i].pIrp );
            }
        }

        KeWaitForSingleObject ( &pFilterInstance->CloseEvent,
                                Executive,
                                KernelMode,
                                FALSE,
                                NULL ) ;

        pFilterInstance->ClosingSource = FALSE ;

    }
    else {

        pFilterInstance->ClosingSource = FALSE ;

        KeReleaseSpinLock ( &pFilterInstance->MixSpinLock, OldIrql ) ;

    }

    _DbgPrintF( DEBUGLVL_VERBOSE, ("End Mixing") ) ;
    return ( STATUS_SUCCESS ) ;

}

#pragma LOCKED_CODE
#pragma LOCKED_DATA

PVOID WvGetNextBlock
(
        PMIXER_SINK_INSTANCE    pMixerSink,
        ULONG                   lCount,
        PULONG                  pBlockCount,
        PIRP                    *FreeIrp,
        PIRP                    *ReleaseIrp
)
{
   PIRP                    pIrp ;
   PWAVEHDREX              phdrex;
   PIO_STACK_LOCATION      pIrpStack ;
   ULONG                   lByteOffset ;
   ULONG                   BufSize ;
   PVOID                   ptr ;
   PLIST_ENTRY             ple;
   ULONG                   NumChannels, SampleSize ;
   KIRQL                   OldIrql ;


   // Assume we will not consume an Irp fully

   *FreeIrp = NULL ;
   *ReleaseIrp = NULL ;

   // if we are in loop mode get Irp from LoopIrp instead of head

   // We must deal with a cancelled LoopIrp
        
    if ( (pMixerSink->SinkStatus & MIXER_SINK_STATUS_IN_LOOP) && pMixerSink->LoopIrp == NULL ) {
       pMixerSink->LoopCount = 0 ;
       pMixerSink->SinkStatus &= ~MIXER_SINK_STATUS_IN_LOOP ;
    }
    
   if ( pMixerSink->SinkStatus & MIXER_SINK_STATUS_IN_LOOP ) {

       KeAcquireSpinLock ( &pMixerSink->WriteSpinLock, &OldIrql ) ;

       pIrp = pMixerSink->LoopIrp ;

       // If we exhausted the LoopIrp lasttime advance to the next irp

       if ( pMixerSink->SinkStatus & MIXER_SINK_STATUS_ADVANCE_IRP ) {

           ple = pIrp->Tail.Overlay.ListEntry.Flink ;

           // if we hit end of Queue behave as if queue is empty

           if ( ple == &pMixerSink->WriteQueue ) {
               // setup pIrp so that we take the empty Queue path below
               pIrp = NULL ;
           }
           else {
               pIrp  = (PIRP) CONTAINING_RECORD( ple, IRP, Tail.Overlay.ListEntry );
               pMixerSink->SinkStatus &= ~MIXER_SINK_STATUS_ADVANCE_IRP ;
           }
       }
       KeReleaseSpinLock ( &pMixerSink->WriteSpinLock, OldIrql ) ;

   }

   // If not Looping get the Irp from the Head of the Queue

   else {
       pIrp = KsRemoveIrpFromCancelableQueue( &pMixerSink->WriteQueue,
                                              &pMixerSink->WriteSpinLock,
                                              KsListEntryHead,
                                              KsAcquireOnly ) ;
   }

   if ( !pIrp ) {
       pMixerSink->SinkStatus &= ~MIXER_SINK_STATUS_DATA_PRESENT ;
       *pBlockCount = 0 ;
       return NULL ;
   }

   *ReleaseIrp = pIrp ;
   
   pIrpStack = IoGetCurrentIrpStackLocation( pIrp );
   phdrex = pIrpStack->Parameters.Others.Argument3 ;

   // Check if the Irp is starting a new Loop block

   if ( (phdrex->Flags & WHDR_BEGINLOOP) && (phdrex->LoopCount > 1) ) {
       if ( !(pMixerSink->SinkStatus & MIXER_SINK_STATUS_IN_LOOP) ) {
           pMixerSink->SinkStatus |= MIXER_SINK_STATUS_IN_LOOP ;
           pMixerSink->SinkStatus &= ~MIXER_SINK_STATUS_ADVANCE_IRP ;
           pMixerSink->LoopIrp = pIrp ;
           pMixerSink->LoopCount = phdrex->LoopCount ;
       }
   }

   NumChannels = pMixerSink->WaveFormatEx.nChannels ;
   SampleSize = pMixerSink->WaveFormatEx.wBitsPerSample/8 ;


   lByteOffset = pMixerSink->csNextSampleOffset * (NumChannels * SampleSize) ;

   if (phdrex->BufferMdl != NULL) {
       BufSize = MmGetMdlByteCount (phdrex->BufferMdl) ;
       ptr = (PUCHAR)(phdrex->DataBuffer) + pMixerSink->csNextSampleOffset * (NumChannels * SampleSize) ;
   } else {
       BufSize = 0L;
       ptr = (PVOID) SilenceBuffer;
   }

   if ( (lCount * (NumChannels * SampleSize)) < (BufSize - lByteOffset) ) {
      *pBlockCount = lCount ;
      pMixerSink->csNextSampleOffset += lCount ;
   }

   else {
      *pBlockCount = (BufSize - lByteOffset) / (NumChannels * SampleSize) ;
      pMixerSink->csNextSampleOffset = 0 ;

      if ( pMixerSink->SinkStatus & MIXER_SINK_STATUS_IN_LOOP ) {
           if ( phdrex->Flags & WHDR_ENDLOOP ) {
               pMixerSink->LoopCount-- ;
               if ( pMixerSink->LoopCount ) {
                   KeAcquireSpinLock ( &pMixerSink->WriteSpinLock, &OldIrql ) ;
                   ple = pMixerSink->WriteQueue.Flink ;
                   pIrp  = (PIRP) CONTAINING_RECORD( ple, IRP, Tail.Overlay.ListEntry );
                   pMixerSink->LoopIrp = pIrp ;
                   KeReleaseSpinLock ( &pMixerSink->WriteSpinLock, OldIrql ) ;
               }
               else {
                   pMixerSink->SinkStatus &= ~MIXER_SINK_STATUS_IN_LOOP ;
                   *ReleaseIrp = NULL ;
                   KsReleaseIrpOnCancelableQueue( pIrp, MxCancelIrp ) ;
                   *FreeIrp = CompleteIrpsTill ( pMixerSink, pIrp ) ;
               }
           }
           else {
               pMixerSink->SinkStatus |= MIXER_SINK_STATUS_ADVANCE_IRP ;
           }
      }
      else {
         *FreeIrp = pIrp ;
         *ReleaseIrp = NULL ;
         KsRemoveSpecificIrpFromCancelableQueue( pIrp ) ;
      }
   }

   return ptr ;
}

PVOID StGetNextBlock
(
        PMIXER_SINK_INSTANCE    pMixerSink,
        ULONG                   lCount,
        PULONG                  pBlockCount,
        PIRP                    *FreeIrp,
        PIRP                    *ReleaseIrp
)
{
    PIRP                    pIrp ;
    PIO_STACK_LOCATION      pIrpStack ;
    PVOID                   ptr ;
    ULONG                   NumChannels, SampleSize ;
    PMDL                    CurMdl ;
    ULONG_PTR               BytesLeft ;
    PKSSTREAM_HEADER        pCurStrmHdr ;


    //
    // Assume that we will not consume the first IRP fully
    //
    *FreeIrp = NULL ;
    *ReleaseIrp = NULL ;

    //
    // Get the first IRP in queue
    //
    pIrp = KsRemoveIrpFromCancelableQueue( &pMixerSink->WriteQueue,
                                           &pMixerSink->WriteSpinLock,
                                           KsListEntryHead,
                                           KsAcquireOnly ) ;

    if ( !pIrp ) {
        //
        // if no data available return immediately
        //
        _DbgPrintF (DEBUGLVL_VERBOSE, ("Write Queue empty") ) ;
        pMixerSink->SinkStatus &= ~MIXER_SINK_STATUS_DATA_PRESENT ;
        *pBlockCount = 0 ;
        return NULL ;
    }

    *ReleaseIrp = pIrp ;

    NumChannels = pMixerSink->WaveFormatEx.nChannels ;
    SampleSize = pMixerSink->WaveFormatEx.wBitsPerSample/8 ;

    pIrpStack = IoGetCurrentIrpStackLocation( pIrp );

    CurMdl = pIrpStack->Parameters.Others.Argument3;
    pCurStrmHdr = pIrpStack->Parameters.Others.Argument2;
    BytesLeft = (ULONG_PTR)pIrpStack->Parameters.Others.Argument4 ;
    if ( CurMdl ) {
        ptr = ((PUCHAR)MmGetSystemAddressForMdl(CurMdl)) +
                                    pCurStrmHdr->DataUsed - BytesLeft ;
    }
    else {
        ptr = (PVOID)SilenceBuffer ;
    }

    if ( (lCount * (NumChannels * SampleSize)) <= BytesLeft ) {
        *pBlockCount = lCount ;
        (ULONG_PTR)pIrpStack->Parameters.Others.Argument4 -=
                                           lCount * (NumChannels * SampleSize) ;
    }
    else {
        *pBlockCount = (ULONG)(BytesLeft / (NumChannels * SampleSize)) ;
        pIrpStack->Parameters.Others.Argument4 = 0 ;
    }
    if ( pIrpStack->Parameters.Others.Argument4 == 0 ) {
        if ( CurMdl ) {
            pIrpStack->Parameters.Others.Argument3 = CurMdl->Next ;
            pIrpStack->Parameters.Others.Argument2 = pCurStrmHdr+1;
            if ( CurMdl->Next ) {
                (ULONG_PTR) pIrpStack->Parameters.Others.Argument4 =
                                        (pCurStrmHdr+1)->DataUsed ;
            }
        }
    }
    if ( pIrpStack->Parameters.Others.Argument3 == 0 ) {
           *FreeIrp = pIrp ;
           *ReleaseIrp = NULL ;
           KsRemoveSpecificIrpFromCancelableQueue( pIrp ) ;
    }

    return ptr ;
}

PVOID LoopStGetNextBlock
(
        PMIXER_SINK_INSTANCE    pMixerSink,
        ULONG                   lCount,
        PULONG                  pBlockCount,
        PIRP                    *FreeIrp,
        PIRP                    *ReleaseIrp
)
{
        PIRP                    pIrp ;
        PIO_STACK_LOCATION      pIrpStack ;
        PVOID                   ptr ;
        ULONG                   NumChannels, SampleSize ;
        PMDL                    pCurMdl ;
        ULONG                   BytesLeft ;
        PKSSTREAM_HEADER        pStreamHeader;
        PLOOPPACKET             pLoopPacket;

        //
        // Assume that we will not consume the first IRP fully
        //
        *FreeIrp = NULL ;
        *ReleaseIrp = NULL ;

        //
        // Get the first IRP in queue
        //
        pIrp = KsRemoveIrpFromCancelableQueue( &pMixerSink->WriteQueue,
                                           &pMixerSink->WriteSpinLock,
                                           KsListEntryHead,
                                           KsAcquireOnly ) ;

        if ( !pIrp ) {
            //
            // if no data available return immediately
            //
            _DbgPrintF (DEBUGLVL_VERBOSE, ("Write Queue empty") ) ;
            pMixerSink->SinkStatus &= ~MIXER_SINK_STATUS_DATA_PRESENT ;
            *pBlockCount = 0 ;
            return NULL ;
        }

        *ReleaseIrp = pIrp ;
        
        NumChannels = pMixerSink->WaveFormatEx.nChannels ;
        SampleSize = pMixerSink->WaveFormatEx.wBitsPerSample/8 ;

        pIrpStack = IoGetCurrentIrpStackLocation( pIrp );

        pLoopPacket = pIrpStack->Parameters.Others.Argument3 ;
        pMixerSink->fSetCurrentPosition = FALSE;
        pCurMdl = pLoopPacket->pCurMdl;
        pStreamHeader = pLoopPacket->pCurStreamHdr;
        BytesLeft = pLoopPacket->cBytesLeft;

        if (( pStreamHeader->OptionsFlags & KSSTREAM_HEADER_OPTIONSF_LOOPEDDATA ) &&
            ( pLoopPacket->CurLoopingState == LOOPING_STATE_NOT_LOOPING ))
        {
            pLoopPacket->CurLoopingState = LOOPING_STATE_LOOPING;
        }


        if ( pCurMdl != NULL ) {
            ptr = (PUCHAR)(MmGetSystemAddressForMdl(pCurMdl)) +
                    MmGetMdlByteCount(pCurMdl) - BytesLeft ;
        }
        else {
            ptr = (PVOID)SilenceBuffer ;
        }

        if ( (lCount * (NumChannels * SampleSize)) <= BytesLeft ) {
                *pBlockCount = lCount ;
                pLoopPacket->cBytesLeft -= lCount * (NumChannels * SampleSize) ;
                pLoopPacket->cBytesLeftInStreamHdr -=
                                    lCount * (NumChannels * SampleSize) ;
        }
        else {
                *pBlockCount = BytesLeft / (NumChannels * SampleSize) ;
                pLoopPacket->cBytesLeftInStreamHdr -= BytesLeft ;
                pLoopPacket->cBytesLeft = 0 ;
        }
        if ( pLoopPacket->cBytesLeft == 0 ) {
                if (pLoopPacket->pCurMdl) {
                    pLoopPacket->pCurMdl = pLoopPacket->pCurMdl->Next ;
                    if ( pLoopPacket->pCurMdl ) {
                        pLoopPacket->cBytesLeft =
                                        MmGetMdlByteCount(pCurMdl->Next);
                    }
                    if ( pLoopPacket->cBytesLeftInStreamHdr == 0 ) {
                        pLoopPacket->pCurStreamHdr++;
                    }
                }
        }
        if ( pLoopPacket->pCurMdl == 0 ) {
             if( ( LOOPING_STATE_NOT_LOOPING ==
                   pLoopPacket->CurLoopingState ) ||
                 ( LOOPING_STATE_LAST_LOOP ==
                   pLoopPacket->CurLoopingState ) ||
                 ( NULL == pLoopPacket->LoopStartMdl) ) {
                 *FreeIrp = pIrp ;
                 *ReleaseIrp = NULL ;
                 KsRemoveSpecificIrpFromCancelableQueue( pIrp ) ;
             }
             else {
                pLoopPacket->pCurMdl = pLoopPacket->LoopStartMdl ;
                pLoopPacket->pCurStreamHdr = pLoopPacket->LoopStartStreamHdr;
                pLoopPacket->cBytesLeft = MmGetMdlByteCount(pLoopPacket->pCurMdl);
                pLoopPacket->cBytesLeftInStreamHdr =
                                    pLoopPacket->pCurStreamHdr->DataUsed;
             }
        }
        return ptr ;
}

NTSTATUS DoesSinkMatch
(
    PIRP                    pIrp,
    PMIXER_SINK_INSTANCE    pMixerSink
)
{
    NTSTATUS Status = STATUS_SUCCESS ;
    PIO_STACK_LOCATION   pIrpStack ;

    if ( pIrp ) {
        pIrpStack = IoGetCurrentIrpStackLocation( pIrp );
        if (pIrpStack->Parameters.Others.Argument2 != pMixerSink) {
            Status = STATUS_NO_MATCH ;
        }
    }
    return (Status) ;
}

#pragma PAGEABLE_CODE
#pragma PAGEABLE_DATA

PIRP CompleteIrpsTill
(
   PMIXER_SINK_INSTANCE pMixerSink,
   PIRP pIrp
)
{
    PIRP                    CurIrp ;


    //
    // Get the head of the queue
    //
    
    CurIrp = KsRemoveIrpFromCancelableQueue( &pMixerSink->WriteQueue,
                                             &pMixerSink->WriteSpinLock,
                                             KsListEntryHead,
                                             KsAcquireOnly ) ;

    //
    // while the queue is not empty && we have not reached the IRP
    //  we are interested in
    //
    
    while ( CurIrp && (CurIrp != pIrp) ) {
    
        //
        // remove the IRP from the Queue & complete it
        //
        
        KsRemoveSpecificIrpFromCancelableQueue( CurIrp ) ;
        MxCompleteRequest ( CurIrp ) ;
        
        //
        // get the next IRP
        //
        
        CurIrp = KsRemoveIrpFromCancelableQueue(  &pMixerSink->WriteQueue,
                                         &pMixerSink->WriteSpinLock,
                                         KsListEntryHead,
                                         KsAcquireOnly ) ;
    }

    //
    // We come here when we exhausted all the IRPs or we found the desired IRP
    //
    
    if ( CurIrp ) {
    
        //
        // if we found the IRP remove it from the Queue
        //
        
        KsRemoveSpecificIrpFromCancelableQueue( CurIrp ) ;
    }
    
    //
    // return the IRP to be freed
    //
    
    return (CurIrp) ;
}

VOID MxCompleteRequest
(
PIRP    pIrp
)
{
   MxCleanupRequest ( pIrp ) ;
   pIrp->IoStatus.Status = STATUS_SUCCESS;
   IoCompleteRequest ( pIrp, IO_AUD_INCREMENT ) ;
}

#ifdef LOG_TO_FILE
NTSTATUS
NTAPI
FileOpenRoutine (PFILTER_INSTANCE pFilterInstance, BOOL fNewFile)
{
    NTSTATUS status;

    UNICODE_STRING FullFileName;

    UNICODE_STRING FileName;
    ANSI_STRING astr;
    char dumpFileName[80] = {"c:\\temp\\mixout.wav"};
    WCHAR PathPrefix[] = L"\\DosDevices\\";
    ULONG FullFilenameLen;
    IO_STATUS_BLOCK IoStatus;
    OBJECT_ATTRIBUTES ObjectAttributes;
    static ULONG NumberToAppend = 0;

    if (pFilterInstance->LoggingStarted || !fLogToFile) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    // Append a number to the end of the file name
    if (fNewFile) {
        NumberToAppend++;
    }
    sprintf(dumpFileName, "c:\\temp\\mixout%lu.wav", NumberToAppend);

    RtlInitAnsiString (&astr, dumpFileName);
    status = RtlAnsiStringToUnicodeString(&FileName, &astr, TRUE);

    FullFilenameLen= sizeof(PathPrefix) + FileName.MaximumLength;
    FullFileName.Buffer = (USHORT *)ExAllocatePoolWithTag( NonPagedPool, FullFilenameLen, 'XIMK' );
    if (FullFileName.Buffer == NULL)
    {
        RtlFreeUnicodeString( &FileName );
        _DbgPrintF(DEBUGLVL_ERROR, ("buffer alloc for filename failed"));
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    FullFileName.Length = sizeof(PathPrefix) - sizeof(WCHAR);
    FullFileName.MaximumLength = (USHORT)FullFilenameLen;
    RtlMoveMemory (FullFileName.Buffer, PathPrefix, sizeof(PathPrefix));

    RtlAppendUnicodeStringToString (&FullFileName, &FileName);
    RtlFreeUnicodeString(&FileName );

    _DbgPrintF(DEBUGLVL_VERBOSE, ("Opening file %wZ", &FullFileName));

    InitializeObjectAttributes(&ObjectAttributes,
                               &FullFileName,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);

    status = ZwCreateFile( &pFilterInstance->NtFileHandle,
                           GENERIC_WRITE | SYNCHRONIZE |FILE_APPEND_DATA,
                           &ObjectAttributes,
                           &IoStatus,
                           NULL,
                           FILE_ATTRIBUTE_NORMAL,
                           0,
                           (fNewFile ? FILE_OVERWRITE_IF : FILE_OPEN_IF),
                           FILE_SYNCHRONOUS_IO_NONALERT,
                           NULL,
                           0 );
    ExFreePool(FullFileName.Buffer);
    if (status != STATUS_SUCCESS)
    {
        _DbgPrintF(DEBUGLVL_ERROR, ("Error creating file"));
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    if (fNewFile) {
        // This flag does not work for memphis. Need to maintain my own file pointers
        //filePos.LowPart = FILE_USE_FILE_POINTER_POSITION;
        pFilterInstance->filePos.LowPart = 0;
        pFilterInstance->filePos.HighPart = 0;
    }

    pFilterInstance->LoggingStarted = TRUE;

    return status;
}

NTSTATUS
NTAPI
FileIoRoutine (PFILTER_INSTANCE pFilterInstance, PVOID buffer, ULONG length)
{
    NTSTATUS status;

    IO_STATUS_BLOCK IoStatus;

    FileOpenRoutine(pFilterInstance, FALSE);

    if (!pFilterInstance->LoggingStarted) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    status = ZwWriteFile (pFilterInstance->NtFileHandle, NULL, NULL, NULL, &IoStatus,
                          buffer,
                          length, &pFilterInstance->filePos, NULL);

    if (status == STATUS_SUCCESS) {
        pFilterInstance->filePos.LowPart += length;
    } else {
        // This is commented out because we get errors on the first few buffers,
        // since the file handle is not valid during MxBeginMixing.
//        _DbgPrintF(DEBUGLVL_ERROR, ("Error writing to log file"));
    }

    FileCloseRoutine(pFilterInstance);

    return status;
}

NTSTATUS
NTAPI
FileCloseRoutine (PFILTER_INSTANCE pFilterInstance)
{
    if (!pFilterInstance->LoggingStarted) {
        return STATUS_SUCCESS;
    }

        _DbgPrintF(DEBUGLVL_VERBOSE, ("Closing Logging File ...."));
        ZwClose (pFilterInstance->NtFileHandle);
        pFilterInstance->LoggingStarted = FALSE;
    return STATUS_SUCCESS;
}
#endif


NTSTATUS Peg32to16
(
        PLONG  pMixBuffer,
        PSHORT  pWriteBuffer,
        ULONG   SampleCount,             // after multiplying by NumChannels
        ULONG   nStreams
)
{
        LONG    lSample ;

        if (nStreams > 1) {
        while (SampleCount--) {
                lSample = *pMixBuffer;
                pMixBuffer++;

        if (NEEDPEG16(lSample)) goto Peg1;
ret1:   *pWriteBuffer++ = (short) lSample;
        }
        return STATUS_SUCCESS;
Peg1:   PEG16(lSample); gClipCount++; goto ret1;
        } else {
#ifdef _X86_
            _asm {
                mov ecx, SampleCount
                mov esi, pMixBuffer

// This next line ensures that we process an even number of samples
// in the main loop.  This guarantees that we will never access beyond
// the boundaries of the source array.  We handle the last sample (if it
// exists) at the end of the main loop.				
                shr ecx, 1
                mov edi, pWriteBuffer

                lea esi, [esi+ecx*8]
                lea edi, [edi+ecx*4-4]

                neg ecx
                jz	checklast

loop1:
                mov eax, DWORD PTR [esi+ecx*8]
                mov edx, DWORD PTR [esi+ecx*8+4]

                shl	edx,16
                and eax,0x0000ffff

                or eax,edx
                inc ecx

       			mov	DWORD PTR [edi+ecx*4],eax
                jnz Loop1
	
            checklast:	// do we need to process the last sample?
				test SampleCount,1
            	jz done

// If we get here, then we DID have an odd number of samples to clip
// so we do the very last sample now.
                mov eax, DWORD PTR [esi+ecx*8]
       	        mov	WORD PTR [edi+ecx*4+4],ax

            	
            done:
            	;
            }
#else
            while (SampleCount--) {
                *pWriteBuffer++ = (short) (*pMixBuffer++);
            }
#endif
            return STATUS_SUCCESS;
        }
}

NTSTATUS Peg32to8
(
        PLONG  pMixBuffer,
        PBYTE   pWriteBuffer,
        ULONG   SampleCount,             // after multiplying by NumChannels
        ULONG   nStreams
)
{
        LONG    lSample ;

        if (nStreams > 1) {

        while (SampleCount--)
                {
                lSample = *pMixBuffer;
                pMixBuffer++;

                // Peg it to 16-bits
            if (NEEDPEG16(lSample)) goto Peg2;

ret2:           // Convert to 8-bits and store
                        *pWriteBuffer++ = (BYTE) ((lSample >> 8) + 0x80);
            }

        return STATUS_SUCCESS;

Peg2:   PEG16(lSample); gClipCount++; goto ret2;
        } else {
    while (SampleCount--) {
        // Convert to 8-bits and store
        *pWriteBuffer++ = (BYTE) (((*pMixBuffer++) >> 8) + 0x80);
    }

    return STATUS_SUCCESS;
        }


}

PDRIVER_CANCEL MxCancelWrite
(
    IN PDEVICE_OBJECT pdo,
    IN PIRP         pIrp
)
{
        return ( 0 ) ;
}

#pragma LOCKED_CODE
#pragma LOCKED_DATA

NTSTATUS MxGetMaxLatency
(
   IN PIRP                    pIrp,
   IN PKSPROPERTY             pProperty,
   IN OUT PVOID               pvData
)
{
    PMIXER_SINK_INSTANCE    pMixerSink;
    PFILTER_INSTANCE        pFilterInstance ;
    PKSTIME                 pLatency ;
    PIO_STACK_LOCATION      pIrpStack ;
    PMIXER_INSTHDR          pHeader;
    NTSTATUS                status = STATUS_SUCCESS ;

    pIrpStack = IoGetCurrentIrpStackLocation(pIrp) ;
    pHeader = (PMIXER_INSTHDR) pIrpStack->FileObject->FsContext;
    pLatency = (PKSTIME) pvData ;

    if ( pHeader->PinId == PIN_ID_WAVEOUT_SINK) {
       pMixerSink = (PMIXER_SINK_INSTANCE) pIrpStack->FileObject->FsContext;

       // Get Control Mutex

       pFilterInstance = (PFILTER_INSTANCE)
                           pMixerSink->Header.pFilterFileObject->FsContext ;
       KeWaitForSingleObject ( &pFilterInstance->ControlMutex,
                               Executive,
                               KernelMode,
                               FALSE,
                               NULL ) ;

       pLatency->Time = pFilterInstance->CurrentNumMixBuffers + 1;
       pLatency->Numerator = MIXBUFFERDURATION * 10000L;
       pLatency->Denominator = 1;

       // Release Control Mutex

       KeReleaseMutex ( &pFilterInstance->ControlMutex, FALSE ) ;

    }
    else {
       // We won't get the position of the source pin.
       status = STATUS_INVALID_DEVICE_REQUEST;
    }

    pIrp->IoStatus.Information = sizeof (KSTIME);
    return status ;
}


NTSTATUS MxGetWavePosition
(
   IN PIRP                    pIrp,
   IN PKSPROPERTY             pProperty,
   IN OUT PVOID               pvData
)
{
    PMIXER_SINK_INSTANCE        pMixerSink;
    KSTIME                      *ksTime ;
    PIO_STACK_LOCATION          pIrpStack ;
    PFILTER_INSTANCE            pFilterInstance;
    PMIXER_INSTHDR              pMixerHeader;
    KSAUDIO_POSITION            Position ;

    pIrpStack = IoGetCurrentIrpStackLocation(pIrp) ;
    pMixerSink = (PMIXER_SINK_INSTANCE) pIrpStack->FileObject->FsContext;

    pMixerHeader = (PMIXER_INSTHDR) pMixerSink ;
    pFilterInstance =
        (PFILTER_INSTANCE) pMixerHeader->pFilterFileObject->FsContext;


    ksTime = (KSTIME *)pvData ;

    GetWriteAndPlayOffsets( pFilterInstance,
                            pMixerSink,
                            &Position,
                            (pMixerHeader->PinId != PIN_ID_WAVEOUT_SINK)
                            ) ;

    ksTime->Time = Position.PlayOffset ;

    ksTime->Numerator = pMixerSink->CurTime.Numerator ;
    ksTime->Denominator = pMixerSink->CurTime.Denominator * pMixerSink->BytesPerSample ;
    pIrp->IoStatus.Information = sizeof (KSTIME);
    return STATUS_SUCCESS ;
}

#pragma PAGEABLE_CODE
#pragma PAGEABLE_DATA

NTSTATUS MxSetWavePosition
(
   IN PIRP                    pIrp,
   IN PKSPROPERTY             pProperty,
   IN OUT PVOID               pvData
)
{
    PMIXER_SINK_INSTANCE    pMixerSink;
    KSTIME                      *ksTime ;
    PIO_STACK_LOCATION  pIrpStack ;

    pIrpStack = IoGetCurrentIrpStackLocation(pIrp) ;

    pMixerSink = (PMIXER_SINK_INSTANCE) pIrpStack->FileObject->FsContext;

    ksTime = (KSTIME *)pvData ;

    pMixerSink->CurTime.Time = ksTime->Time ;

    return STATUS_SUCCESS ;
}

NTSTATUS MxGetVolumeLevel
(
   IN PIRP                          pIrp,
   IN PKSNODEPROPERTY_AUDIO_CHANNEL pNodeProperty,
   IN OUT PVOID                     pvData
)
{
    PMIXER_SINK_INSTANCE    pMixerSink;
    PLONG                   pVolumeLevel;
    PIO_STACK_LOCATION      pIrpStack;
    PMIXER_INSTHDR          pHeader;
    PMIXER_SOURCE_INSTANCE  pMixerSource;
    NTSTATUS                status = STATUS_SUCCESS;

    pIrpStack = IoGetCurrentIrpStackLocation(pIrp) ;
    pHeader = (PMIXER_INSTHDR) pIrpStack->FileObject->FsContext;
    pVolumeLevel = (PLONG) pvData ;

    ASSERT(pNodeProperty->NodeProperty.Property.Flags & KSPROPERTY_TYPE_TOPOLOGY);

    switch (pNodeProperty->NodeProperty.NodeId)
       {

       case NODE_ID_VOLUME_SOURCE:
            if ( pHeader->PinId == PIN_ID_WAVEOUT_SOURCE )
            {
                pMixerSource = (PMIXER_SOURCE_INSTANCE) pIrpStack->FileObject->FsContext;
                *pVolumeLevel = pMixerSource->MasterVolumeLevel;
            }
            else
               status = STATUS_INVALID_DEVICE_REQUEST;

            break;
       case NODE_ID_VOLUME_SINK:
            if ( pHeader->PinId == PIN_ID_WAVEOUT_SINK )
            {
                pMixerSink = (PMIXER_SINK_INSTANCE) pIrpStack->FileObject->FsContext;
                if (pNodeProperty->Channel == -1L)
                   *pVolumeLevel = pMixerSink->MasterVolumeLevel;
                else if ( (pNodeProperty->Channel < pMixerSink->WaveFormatEx.nChannels) &&
                          (pNodeProperty->Channel < pMixerSink->WaveFormatEx.nChannels) )
                   *pVolumeLevel = pMixerSink->pChannelVolumeLevel[pNodeProperty->Channel];
               else
                   status = STATUS_INVALID_DEVICE_REQUEST;
            }
            else
               status = STATUS_INVALID_DEVICE_REQUEST;
            break;

       case NODE_ID_VOLUME_PAN:
            if ( pHeader->PinId == PIN_ID_WAVEOUT_SINK )
            {
                pMixerSink = (PMIXER_SINK_INSTANCE) pIrpStack->FileObject->FsContext;
                if (pNodeProperty->Channel == -1L)
                   *pVolumeLevel = pMixerSink->MasterVolumeLevel;
#ifdef SURROUND_VOLUME_HACK
                else if (pMixerSink->nOutputChannels == 4 && pNodeProperty->Channel == 1) {
                    *pVolumeLevel = pMixerSink->pPanVolumeLevel[3];
                }
#endif
                else if (pNodeProperty->Channel < pMixerSink->nOutputChannels)
                   *pVolumeLevel = pMixerSink->pPanVolumeLevel[pNodeProperty->Channel];
                else
                   status = STATUS_INVALID_DEVICE_REQUEST;
            }
            else
               status = STATUS_INVALID_DEVICE_REQUEST;
            break;

       default:
            status = STATUS_INVALID_DEVICE_REQUEST;
               break;
       }

    pIrp->IoStatus.Information = sizeof (LONG);
    return status ;
}

NTSTATUS MxSetVolumeLevel
(
   IN PIRP                          pIrp,
   IN PKSNODEPROPERTY_AUDIO_CHANNEL pNodeProperty,
   IN OUT PVOID                     pvData
)
{
    PMIXER_SINK_INSTANCE    pMixerSink;
    PLONG                   pVolumeLevel ;
    PIO_STACK_LOCATION      pIrpStack ;
    PFILTER_INSTANCE        pFilterInstance;
    PMIXER_SOURCE_INSTANCE  pMixerSource;
    ULONG                   OutChannels, InChannels;
    PMIXER_INSTHDR          pHeader;
    PLIST_ENTRY             ple ;
    NTSTATUS                status = STATUS_SUCCESS ;
    BOOL                    fNeedOptimizeMix, fMuted;
#ifdef REALTIME_THREAD
    KIRQL OldIrql;
#endif

    pIrpStack = IoGetCurrentIrpStackLocation(pIrp) ;
    pHeader = (PMIXER_INSTHDR) pIrpStack->FileObject->FsContext;
    pVolumeLevel = (PLONG) pvData ;
    pFilterInstance = (PFILTER_INSTANCE) pHeader->pFilterFileObject->FsContext;

    ASSERT(pNodeProperty->NodeProperty.Property.Flags & KSPROPERTY_TYPE_TOPOLOGY);

#ifdef REALTIME_THREAD
    if (!pFilterInstance->RealTimeThread) {
#endif

        KeWaitForSingleObject ( &pFilterInstance->ControlMutex,
                                 Executive,
                                 KernelMode,
                                 FALSE,
                                 NULL ) ;

#ifdef REALTIME_THREAD   

    }
    else {

        MxWaitForSingleObject ( &pFilterInstance->ControlMutex,
                                 Executive,
                                 KernelMode,
                                 FALSE,
                                 NULL ) ;

        KeAcquireSpinLock ( &pFilterInstance->MixSpinLock, &OldIrql ) ;
    }
#endif

    ZDbgPrint("'MxSetVolumeLevel\n");
    ZDbgPrint("'KMIXER: MxSetVolumeLevel channel=%d, value=%x\n, ",
          pNodeProperty->Channel, (*pVolumeLevel) );
        
    // Note: we can only have one source instance
    pMixerSource = (PMIXER_SOURCE_INSTANCE) CONTAINING_RECORD (pFilterInstance->SourceConnectionList.Flink,
                                                               MIXER_INSTHDR,
                                                               NextInstance) ;

    fNeedOptimizeMix = FALSE;

    switch (pNodeProperty->NodeProperty.NodeId) {
        case NODE_ID_VOLUME_SOURCE:

            if ( pHeader->PinId != PIN_ID_WAVEOUT_SOURCE ) {
                status = STATUS_INVALID_DEVICE_REQUEST;
                break;
            }

            pMixerSource = (PMIXER_SOURCE_INSTANCE) pIrpStack->FileObject->FsContext;
            if (pMixerSource->MasterVolumeLevel != (*pVolumeLevel) ) {
                pMixerSource->MasterVolumeLevel = *pVolumeLevel;

        	    // Adjust filter coefficients for all sinks attached to this source.
                // Note: we can only have one source instance
    	        ple = pFilterInstance->SinkConnectionList.Flink ;
        	    while ( ple != &pFilterInstance->SinkConnectionList ) {
            	    pMixerSink = (PMIXER_SINK_INSTANCE) CONTAINING_RECORD ( ple,
            	                                                            MIXER_INSTHDR,
            	                                                            NextInstance ) ;
            	    fMuted = pMixerSink->fMuted;
        	        InChannels = pMixerSink->WaveFormatEx.nChannels;
    	            OutChannels = pMixerSource->WaveFormatEx.nChannels;
    	            if (pMixerSink->fEnable3D) {
    	                InChannels = 2;
    	            }
        	        GenerateMixArray(pMixerSink, InChannels, OutChannels, pMixerSource);
        	        if (fMuted != pMixerSink->fMuted) {
        	            fNeedOptimizeMix = TRUE;
        	        }
            		ple = pMixerSink->Header.NextInstance.Flink ;
    		    }
    		}
    	    break;

        case NODE_ID_VOLUME_SINK:
            if ( pHeader->PinId != PIN_ID_WAVEOUT_SINK ) {
                status = STATUS_INVALID_DEVICE_REQUEST;
                break;
            }

            pMixerSink = (PMIXER_SINK_INSTANCE) pIrpStack->FileObject->FsContext;
            if (pNodeProperty->Channel == -1L) {
                if (pMixerSink->MasterVolumeLevel != (*pVolumeLevel)) {
                    pMixerSink->MasterVolumeLevel = *pVolumeLevel;
                    pMixerSink->pInfo->fVolChanged = TRUE;
                }
            } else if (pNodeProperty->Channel < pMixerSink->WaveFormatEx.nChannels) {
                if (pMixerSink->pChannelVolumeLevel[pNodeProperty->Channel] != (*pVolumeLevel)) {
                    pMixerSink->pChannelVolumeLevel[pNodeProperty->Channel] = *pVolumeLevel;
                    pMixerSink->pInfo->fVolChanged = TRUE;
                }
            } else {
                status = STATUS_INVALID_DEVICE_REQUEST;
                break;
            }

    	    break;

        case NODE_ID_VOLUME_PAN:
            if ( pHeader->PinId != PIN_ID_WAVEOUT_SINK ) {
                status = STATUS_INVALID_DEVICE_REQUEST;
                break;
            }
            pMixerSink = (PMIXER_SINK_INSTANCE) pIrpStack->FileObject->FsContext;
            // Works for any speaker configs (even non-stereo)
            // Works for any number of output channels
            if (pNodeProperty->Channel == -1L) {
                if (pMixerSink->MasterVolumeLevel != (*pVolumeLevel)) {
                    pMixerSink->MasterVolumeLevel = *pVolumeLevel;
                    pMixerSink->pInfo->fVolChanged = TRUE;
                }
            } else if ( (pNodeProperty->Channel >= 0 ) &&
                        (pNodeProperty->Channel < pMixerSource->WaveFormatEx.nChannels) ) {
                if (pMixerSink->pPanVolumeLevel[pNodeProperty->Channel] != (*pVolumeLevel)) {
#ifdef SURROUND_VOLUME_HACK
                    if (pMixerSource->fSurround) {
                        if (pNodeProperty->Channel == 0) {
                            pMixerSink->pPanVolumeLevel[0] = *pVolumeLevel;
                            pMixerSink->pPanVolumeLevel[1] = *pVolumeLevel;
                            pMixerSink->pPanVolumeLevel[2] = *pVolumeLevel;
                        } else if (pNodeProperty->Channel == 1) {
                            pMixerSink->pPanVolumeLevel[3] = *pVolumeLevel;
                        }
                    }
#else
                    pMixerSink->pPanVolumeLevel[pNodeProperty->Channel] = *pVolumeLevel;
#endif                    
                    pMixerSink->pInfo->fVolChanged = TRUE;
                }
            } else {
                status = STATUS_INVALID_DEVICE_REQUEST;
                break;
            }

    	    break;

        default:
            status = STATUS_INVALID_DEVICE_REQUEST;
            break;
    }

    if (fNeedOptimizeMix) {
        pFilterInstance->fNeedOptimizeMix = TRUE;
    }

    ZDbgPrint("'return from MxSetVolumeLevel\n");

#ifdef REALTIME_THREAD
    if (!pFilterInstance->RealTimeThread) {
#endif

        KeReleaseMutex ( &pFilterInstance->ControlMutex, FALSE ) ;

#ifdef REALTIME_THREAD   

    }
    else {

        KeReleaseSpinLock ( &pFilterInstance->MixSpinLock, OldIrql ) ;

        MxReleaseMutex ( &pFilterInstance->ControlMutex, FALSE ) ;

    }
#endif

    pIrp->IoStatus.Information = sizeof (LONG);
    return status ;
}

NTSTATUS MxGetSamplingRate
(
   IN PIRP                    pIrp,
   IN PKSNODEPROPERTY         pNodeProperty,
   IN OUT PVOID               pvData
)
{
    PMIXER_SINK_INSTANCE    pMixerSink;
    PMIXER_SOURCE_INSTANCE  pMixerSource;
    PFILTER_INSTANCE        pFilterInstance;
    PIO_STACK_LOCATION      pIrpStack ;
    PMIXER_INSTHDR          pHeader;
    NTSTATUS                status = STATUS_INVALID_DEVICE_REQUEST;

    pIrpStack = IoGetCurrentIrpStackLocation(pIrp) ;
    pHeader = (PMIXER_INSTHDR) pIrpStack->FileObject->FsContext;
    pFilterInstance = (PFILTER_INSTANCE) pHeader->pFilterFileObject->FsContext;
    pMixerSource = (PMIXER_SOURCE_INSTANCE) CONTAINING_RECORD (pFilterInstance->SourceConnectionList.Flink, MIXER_INSTHDR, NextInstance) ;

    ASSERT(pNodeProperty->Property.Flags & KSPROPERTY_TYPE_TOPOLOGY);

    // Note: The first SRC node is normally "dead". If the sample rate is changed
    // on either node, the input and output rates of the first node (and therefore 
    // the input rate of the second node) are changed simultaneously.
    //
    // When 3D is active, the first and second SRC nodes operate independently of each
    // other. If the sample rate is changed on the first node, it does not affect the
    // intermediate rate or the second SRC. If the sample rate is changed on the second
    // node, it affects only the input rate of the second SRC and the output rate of
    // the first.

    switch (pNodeProperty->NodeId)
        {
        case NODE_ID_DOPPLER_SRC:
            if (pHeader->PinId == PIN_ID_WAVEOUT_SINK) {
                pMixerSink = (PMIXER_SINK_INSTANCE) pIrpStack->FileObject->FsContext;
                ((PULONG)pvData)[0] = pMixerSink->WaveFormatEx.nSamplesPerSec;
                ((PULONG)pvData)[1] = pMixerSink->pInfo->IntermediateSamplingRate;
                status = STATUS_SUCCESS;
            }
            break;
            
        case NODE_ID_SRC_SINK:
            if (pHeader->PinId == PIN_ID_WAVEOUT_SINK) {
                pMixerSink = (PMIXER_SINK_INSTANCE) pIrpStack->FileObject->FsContext;
                ((PULONG)pvData)[0] = pMixerSink->pInfo->IntermediateSamplingRate;
                ((PULONG)pvData)[1] = pMixerSource->WaveFormatEx.nSamplesPerSec;
                status = STATUS_SUCCESS;
            }
            break;

        default:
                break;
        }

    pIrp->IoStatus.Information = sizeof (ULONG);
    return status ;
}

NTSTATUS MxSetFormat
(
   IN PIRP                    pIrp,
   IN PKSPROPERTY               pProperty,
   IN OUT PKSDATAFORMAT       pAudioFormat
)
{
    PMIXER_SINK_INSTANCE    pMixerSink;
    PIO_STACK_LOCATION          pIrpStack ;
    PMIXER_INSTHDR              pHeader;
    PMIXER_SOURCE_INSTANCE      pMixerSource;
    PFILTER_INSTANCE            pFilterInstance;
    ULONG                       NewSampleRate;
    NTSTATUS                    Status;
    PWAVEFORMATEX pWaveFormatEx;
    PKSDSOUND_BUFFERDESC pDsBufferDesc;
    PKSDATAFORMAT_DSOUND        pDsAudioFormat;

    pIrpStack = IoGetCurrentIrpStackLocation(pIrp) ;
    pHeader = (PMIXER_INSTHDR) pIrpStack->FileObject->FsContext;
    Status = STATUS_INVALID_DEVICE_REQUEST;
    pFilterInstance = (PFILTER_INSTANCE) pHeader->pFilterFileObject->FsContext;

    KeWaitForSingleObject ( &pFilterInstance->ControlMutex, Executive, KernelMode, FALSE, NULL ) ;

    if (pHeader->PinId != PIN_ID_WAVEOUT_SINK) {
        goto Exit;
    }

    pMixerSink = (PMIXER_SINK_INSTANCE) pIrpStack->FileObject->FsContext;
    // Note: we can only have one source instance
    pMixerSource = (PMIXER_SOURCE_INSTANCE) CONTAINING_RECORD (pFilterInstance->SourceConnectionList.Flink, MIXER_INSTHDR, NextInstance) ;

    if ( IsEqualGUID( &(pAudioFormat->Specifier), &KSDATAFORMAT_SPECIFIER_WAVEFORMATEX ) ) {
        pWaveFormatEx = &(((KSDATAFORMAT_WAVEFORMATEX *)pAudioFormat)->WaveFormatEx);
    } else if ( IsEqualGUID( &(pAudioFormat->Specifier), &KSDATAFORMAT_SPECIFIER_DSOUND ) ) {
        pDsAudioFormat = (KSDATAFORMAT_DSOUND *)pAudioFormat;
        pDsBufferDesc = &(pDsAudioFormat->BufferDesc);
        pWaveFormatEx = &(pDsBufferDesc->WaveFormatEx);
    } else {
        _DbgPrintF( DEBUGLVL_ERROR, ("Invalid Specifier Guid") );
        Status = STATUS_INVALID_PARAMETER;
        goto Exit;
    }

    if ( STATUS_INVALID_PARAMETER == (Status=VerifyWaveFormatEx( pWaveFormatEx ) ))
    {
        goto Exit;
    }

    if (pWaveFormatEx->nChannels != pMixerSink->WaveFormatEx.nChannels ||
        pWaveFormatEx->nBlockAlign != pMixerSink->WaveFormatEx.nBlockAlign ||
        pWaveFormatEx->wBitsPerSample != pMixerSink->WaveFormatEx.wBitsPerSample ||
        pWaveFormatEx->wFormatTag != pMixerSink->WaveFormatEx.wFormatTag) {
        Status = STATUS_INVALID_PARAMETER;
        goto Exit;
    }

    // Now we build a new SRC context.
    NewSampleRate = pWaveFormatEx->nSamplesPerSec;

    if (NewSampleRate != pMixerSink->WaveFormatEx.nSamplesPerSec) {
        pMixerSink->WaveFormatEx.nSamplesPerSec = NewSampleRate;
        pMixerSink->CurTime.Denominator = NewSampleRate;
        if (pMixerSource->MaxSampleRate < NewSampleRate) {
            pMixerSource->MaxSampleRate = NewSampleRate;
            pMixerSource->fNewMaxRate = TRUE;
        }
        pMixerSink->pInfo->fSrcChanged = TRUE;
    }

    Status = STATUS_SUCCESS;

Exit:
    KeReleaseMutex ( &pFilterInstance->ControlMutex, FALSE ) ;

    pIrp->IoStatus.Information = sizeof (ULONG);
    return Status ;
}

NTSTATUS MxSetSamplingRate
(
   IN PIRP                    pIrp,
   IN PKSNODEPROPERTY         pNodeProperty,
   IN OUT PVOID               pvData
)
{
    PMIXER_SINK_INSTANCE    pMixerSink;
    PIO_STACK_LOCATION          pIrpStack ;
    PMIXER_INSTHDR              pHeader;
    PMIXER_SOURCE_INSTANCE      pMixerSource;
    PFILTER_INSTANCE            pFilterInstance;
    ULONG                       NewSampleRate;
    NTSTATUS                    Status;
    MIXER_SRC_INSTANCE          NewSrc;

    pIrpStack = IoGetCurrentIrpStackLocation(pIrp) ;
    pHeader = (PMIXER_INSTHDR) pIrpStack->FileObject->FsContext;
    Status = STATUS_INVALID_DEVICE_REQUEST;
    pFilterInstance = (PFILTER_INSTANCE) pHeader->pFilterFileObject->FsContext;

    // We have a new sampling rate.
    NewSampleRate = *((PULONG)pvData);

    ASSERT(pNodeProperty->Property.Flags & KSPROPERTY_TYPE_TOPOLOGY);

    // We only support this property on the waveout sink
    if (pHeader->PinId != PIN_ID_WAVEOUT_SINK) {
        pIrp->IoStatus.Information = sizeof (ULONG);
        return Status ;
    }

    KeWaitForSingleObject ( &pFilterInstance->ControlMutex, Executive, KernelMode, FALSE, NULL ) ;
    
    pMixerSink = (PMIXER_SINK_INSTANCE) pIrpStack->FileObject->FsContext;
    // Note: we can only have one source instance
    pMixerSource = (PMIXER_SOURCE_INSTANCE) CONTAINING_RECORD (pFilterInstance->SourceConnectionList.Flink, MIXER_INSTHDR, NextInstance) ;

    switch (pNodeProperty->NodeId) {
        case NODE_ID_DOPPLER_SRC:
            pMixerSink->WaveFormatEx.nSamplesPerSec = NewSampleRate;
            if (!pMixerSink->fCreate3D) {
                // The first SRC node is dead, so the intermediate sampling
                // rate must also change.
                pMixerSink->pInfo->IntermediateSamplingRate = NewSampleRate;
            }
            Status = STATUS_SUCCESS;
            break;
        case NODE_ID_SRC_SINK:
            // The second SRC node is always "live".
            // The intermediate sampling rate has changed
            pMixerSink->pInfo->IntermediateSamplingRate = NewSampleRate;
            
            if (!pMixerSink->fCreate3D) {
                // The first SRC is "dead", so change the input rate
                pMixerSink->WaveFormatEx.nSamplesPerSec = NewSampleRate;
            }
            Status = STATUS_SUCCESS;
            break;
        default:
            goto exit;
            break;
    }

    // Make sure the waveformat agrees with the current input sampling rate
    pMixerSink->WaveFormatEx.nAvgBytesPerSec = pMixerSink->WaveFormatEx.nSamplesPerSec * 
                                               pMixerSink->WaveFormatEx.nBlockAlign;
    pMixerSink->CurTime.Denominator = pMixerSink->WaveFormatEx.nSamplesPerSec;
                
    // Now we build a new SRC context to see if we need to do anything
    NewSrc.Quality = pMixerSink->pInfo->Src.Quality;
   	InitializeSRC( &NewSrc,
		   pMixerSink->pInfo->IntermediateSamplingRate,
		   pMixerSource->WaveFormatEx.nSamplesPerSec,
		   pMixerSource->WaveFormatEx.nChannels,
		   pMixerSource->csMixBufferSize);
		   
    if (NewSrc.UpSampleRate != pMixerSink->pInfo->Src.UpSampleRate ||
        NewSrc.dwFrac != pMixerSink->pInfo->Src.dwFrac ||
        NewSrc.DownSampleRate != pMixerSink->pInfo->Src.DownSampleRate) {
        pMixerSink->pInfo->fSrcChanged = TRUE;
    }

    // Now we build a new Doppler SRC context to see if we need to do anything
    if (pMixerSink->fCreate3D) {
        // Change the doppler SRC's output to use this rate
        NewSrc.Quality = pMixerSink->pInfo->Doppler.Quality;
       	InitializeSRC( &NewSrc,
    		   pMixerSink->WaveFormatEx.nSamplesPerSec,
    		   pMixerSink->pInfo->IntermediateSamplingRate,
    		   pMixerSink->WaveFormatEx.nChannels,
    		   pMixerSource->csMixBufferSize);
    		   
        if (NewSrc.UpSampleRate != pMixerSink->pInfo->Doppler.UpSampleRate ||
            NewSrc.dwFrac != pMixerSink->pInfo->Src.dwFrac ||
            NewSrc.DownSampleRate != pMixerSink->pInfo->Doppler.DownSampleRate) {
            pMixerSink->pInfo->fSrcChanged = TRUE;
        }
    }

exit:

    KeReleaseMutex ( &pFilterInstance->ControlMutex, FALSE ) ;

    pIrp->IoStatus.Information = sizeof (ULONG);
    return Status ;
}

NTSTATUS MxGetAudioQuality
(
   IN PIRP                    pIrp,
   IN PKSNODEPROPERTY         pNodeProperty,
   IN OUT PVOID               pvData
)
{
    PMIXER_SINK_INSTANCE    pMixerSink;
    PIO_STACK_LOCATION          pIrpStack ;
    PMIXER_INSTHDR              pHeader;
    NTSTATUS                Status;

    pIrpStack = IoGetCurrentIrpStackLocation(pIrp) ;
    pHeader = (PMIXER_INSTHDR) pIrpStack->FileObject->FsContext;
    Status = STATUS_SUCCESS;

    ASSERT(pNodeProperty->Property.Flags & KSPROPERTY_TYPE_TOPOLOGY);

    switch (pNodeProperty->NodeId)
        {
        case NODE_ID_DOPPLER_SRC:
            if ( pHeader->PinId == PIN_ID_WAVEOUT_SINK ) {
                pMixerSink = (PMIXER_SINK_INSTANCE) pIrpStack->FileObject->FsContext;
                *((PULONG)pvData) = pMixerSink->pInfo->Doppler.Quality;
            } else {
                Status = STATUS_INVALID_DEVICE_REQUEST;
            }
            break;

        case NODE_ID_SRC_SINK:
            if ( pHeader->PinId == PIN_ID_WAVEOUT_SINK ) {
                pMixerSink = (PMIXER_SINK_INSTANCE) pIrpStack->FileObject->FsContext;
                *((PULONG)pvData) = pMixerSink->pInfo->Src.Quality;
            } else {
                Status = STATUS_INVALID_DEVICE_REQUEST;
            }
            break;

        default:
            // We can't determine the quality of the requested pin.
            Status = STATUS_INVALID_DEVICE_REQUEST;
            break;
        }

    pIrp->IoStatus.Information = sizeof (ULONG);
    return Status ;
}

NTSTATUS MxSetAudioQuality
(
   IN PIRP                    pIrp,
   IN PKSNODEPROPERTY         pNodeProperty,
   IN OUT PULONG              pQuality
)
{
    PMIXER_SINK_INSTANCE    pMixerSink;
    PIO_STACK_LOCATION          pIrpStack ;
    PMIXER_INSTHDR              pHeader;
    PMIXER_SOURCE_INSTANCE      pMixerSource;
    PFILTER_INSTANCE            pFilterInstance;
    NTSTATUS                    Status;

    pIrpStack = IoGetCurrentIrpStackLocation(pIrp) ;
    pHeader = (PMIXER_INSTHDR) pIrpStack->FileObject->FsContext;
    Status = STATUS_SUCCESS;
    pFilterInstance = (PFILTER_INSTANCE) pHeader->pFilterFileObject->FsContext;

    ASSERT(pNodeProperty->Property.Flags & KSPROPERTY_TYPE_TOPOLOGY);

    KeWaitForSingleObject ( &pFilterInstance->ControlMutex, Executive, KernelMode, FALSE, NULL ) ;
    switch (pNodeProperty->NodeId)
        {
        case NODE_ID_DOPPLER_SRC:
        case NODE_ID_SRC_SINK:
            if (pHeader->PinId == PIN_ID_WAVEOUT_SINK) {
                pMixerSink = (PMIXER_SINK_INSTANCE) pIrpStack->FileObject->FsContext;
                // Note: we can only have one source instance
                pMixerSource = (PMIXER_SOURCE_INSTANCE) CONTAINING_RECORD (pFilterInstance->SourceConnectionList.Flink, MIXER_INSTHDR, NextInstance) ;

                // Now we build a new SRC context.
                if ((*pQuality) <= gPreferredQuality &&
                    (*pQuality) != pMixerSink->pInfo->Src.Quality) {
                    // Set the maximum SRC quality for this sink pin
                    pMixerSink->pInfo->Src.Quality = (*pQuality);
                    ChangeSrc(pFilterInstance, pMixerSink, pMixerSource, pMixerSink->pInfo->Src.Quality);
                    pFilterInstance->fNeedOptimizeMix = TRUE;
                }
            }
            else
                Status = STATUS_INVALID_DEVICE_REQUEST;
            break;

        default:
            // We can't really change the source pin.
            Status = STATUS_INVALID_DEVICE_REQUEST;
            break;
        }
    KeReleaseMutex ( &pFilterInstance->ControlMutex, FALSE ) ;

    pIrp->IoStatus.Information = sizeof (ULONG);
    return Status ;
}

NTSTATUS MxGetCurrentPosition
(
   IN PIRP                    pIrp,
   IN PKSPROPERTY             pProperty,
   IN OUT PVOID               pvData
)
{
    PMIXER_SINK_INSTANCE    pMixerSink;
    PFILTER_INSTANCE        pFilterInstance ;
    PKSAUDIO_POSITION       pPosition ;
    PIO_STACK_LOCATION      pIrpStack ;
    PMIXER_INSTHDR          pHeader;
    NTSTATUS                status = STATUS_SUCCESS ;

    pIrpStack = IoGetCurrentIrpStackLocation(pIrp) ;
    pHeader = (PMIXER_INSTHDR) pIrpStack->FileObject->FsContext;
    pPosition = (PKSAUDIO_POSITION) pvData ;

    if ( pHeader->PinId == PIN_ID_WAVEOUT_SINK || pHeader->PinId == PIN_ID_WAVEIN_SINK ) {
       pMixerSink = (PMIXER_SINK_INSTANCE) pIrpStack->FileObject->FsContext;

       pFilterInstance = (PFILTER_INSTANCE)
                           pMixerSink->Header.pFilterFileObject->FsContext ;

       status = GetWriteAndPlayOffsets(pFilterInstance,
                                        pMixerSink,
                                        pPosition,
                                        (pHeader->PinId != PIN_ID_WAVEOUT_SINK)
                                        ) ;

    } else {
       // We won't get the position of the source pin.
       status = STATUS_INVALID_DEVICE_REQUEST;
    }

    pIrp->IoStatus.Information = sizeof (KSAUDIO_POSITION);
    return status ;

}

NTSTATUS MxSetCurrentPosition
(
   IN PIRP                    pIrp,
   IN PKSPROPERTY             pProperty,
   IN OUT PVOID               pvData
)
{
    PFILTER_INSTANCE          pFilterInstance ;
    PMIXER_SINK_INSTANCE      pMixerSink;
    PKSAUDIO_POSITION         pNewPosition ;
    PIO_STACK_LOCATION        pIrpStack ;
    PMIXER_INSTHDR            pHeader;
    NTSTATUS                  status = STATUS_SUCCESS ;
    PIRP                      pWriteIrp ;
    PIO_STACK_LOCATION        pWriteIrpStack ;
    ULONGLONG                 PositionInBytes, BytesInMdl, BytesInStreamHdr ;
    PMDL                      pCurMdl ;
    PKSSTREAM_HEADER          pStreamHeader ;
    PLOOPPACKET               pLoopPacket ;
    ULONG                     i ;

    pIrpStack = IoGetCurrentIrpStackLocation(pIrp) ;
    pHeader = (PMIXER_INSTHDR) pIrpStack->FileObject->FsContext;
    pNewPosition = (PKSAUDIO_POSITION) pvData;
    pMixerSink = (PMIXER_SINK_INSTANCE) pIrpStack->FileObject->FsContext;

    if ( pMixerSink->InterfaceId == KSINTERFACE_STANDARD_LOOPED_STREAMING ) {
        if ( pNewPosition->PlayOffset > (pMixerSink->BufferLength *
                                         pMixerSink->BytesPerSample) ) {
            status = STATUS_INVALID_PARAMETER ;
            goto exit ;
        }
    }

    if (pHeader->PinId == PIN_ID_WAVEOUT_SINK) {

        // If a DirectSound app called SetPosition on a DsBuffer, do it here.

        pMixerSink->CurTime.Time = (pNewPosition->PlayOffset) /
                                 (pMixerSink->WaveFormatEx.nChannels *
                                 (pMixerSink->WaveFormatEx.wBitsPerSample/8) ) ;

        if ( pMixerSink->InterfaceId == KSINTERFACE_STANDARD_LOOPED_STREAMING ) {

            pFilterInstance = (PFILTER_INSTANCE)
                                pHeader->pFilterFileObject->FsContext;

            // Grab control Mutex
            KeWaitForSingleObject( &pFilterInstance->ControlMutex,
                       Executive,
                       KernelMode,
                       FALSE,                  // not alertable
                       NULL );

            pMixerSink->fSetCurrentPosition = TRUE ;

            for ( i = 0; i < MAXNUMMIXBUFFERS; i++ ) {
                pMixerSink->pInfo->BlockInfo[i].NumBytes = 0 ;
            }

            // If a DirectSound app called SetPosition on a DsBuffer, do it here.
            pWriteIrp = GetFirstIrpInQueue ( pMixerSink ) ;

            if ( pWriteIrp &&
                 ((pMixerSink->SinkStatus & MIXER_SINK_STATUS_LOCK_ERROR) == 0) ) {

                pWriteIrpStack = IoGetCurrentIrpStackLocation( pWriteIrp ) ;
                pLoopPacket = pWriteIrpStack->Parameters.Others.Argument3 ;

                if ( pLoopPacket->JustInTimeLock ) {
                    // Unlock the previously locked Mdls
                    pCurMdl = pLoopPacket->LockedMdlHead ;
                    for ( i = 0; (i < 2) && (pCurMdl); i++ ) {
                        MmUnmapLockedPages( MmGetSystemAddressForMdl(pCurMdl),
                                            pCurMdl ) ;
                        MxUnlockMdl( pCurMdl ) ;
                        pCurMdl = GetNextLoopMdl( pLoopPacket,
                                                  pCurMdl ) ;
                        if ( pCurMdl == pLoopPacket->LockedMdlHead ) {
                                break ;
                        }
                    }
                }

                pCurMdl = pLoopPacket->FirstMdl ;
                pStreamHeader = pWriteIrp->AssociatedIrp.SystemBuffer;
                BytesInMdl = MmGetMdlByteCount(pCurMdl);
                BytesInStreamHdr = pStreamHeader->DataUsed ;

                PositionInBytes = pMixerSink->CurTime.Time *
                                    (pMixerSink->WaveFormatEx.nChannels*
                                    (pMixerSink->WaveFormatEx.wBitsPerSample/8) ) ;
                while ( BytesInMdl < PositionInBytes ) {
                    PositionInBytes -= BytesInMdl;
                    BytesInStreamHdr -= BytesInMdl ;
                    pCurMdl = pCurMdl->Next ;
                    BytesInMdl = MmGetMdlByteCount(pCurMdl);
                    if ( BytesInStreamHdr == 0 ) {
                        pStreamHeader++ ;
                        BytesInStreamHdr = pStreamHeader->DataUsed ;
                    }
                }
                pLoopPacket->pCurMdl = pCurMdl ;
                pLoopPacket->pCurStreamHdr = pStreamHeader;

                // NOTE - since BytesInMdl is never > ULONG, and
                //        BytesInMdl >= PositionInBytes (see while() above),
                //        PositionInBytes is guaranteed to fit in ULONG
                pLoopPacket->cBytesLeft = (ULONG)(BytesInMdl - PositionInBytes);
                pLoopPacket->cBytesLeftInStreamHdr =
                        BytesInStreamHdr-PositionInBytes ;

                if ( pLoopPacket->JustInTimeLock ) {
                    // Lock down the new set of Mdls
                    pLoopPacket->LockedMdlHead = pCurMdl ;
                    for ( i = 0; (i < 2) && (pCurMdl); i++ ) {
                        try {
                            MmProbeAndLockProcessPages( pCurMdl,
                                                        pLoopPacket->Process,
                                                        KernelMode,
                                                        IoReadAccess ) ;
                        }
                        except (EXCEPTION_EXECUTE_HANDLER) {
                            pMixerSink->SinkStatus |= MIXER_SINK_STATUS_LOCK_ERROR ;
                            status = STATUS_INSUFFICIENT_RESOURCES;
                            KeReleaseMutex ( &pFilterInstance->ControlMutex, FALSE ) ;
                            goto exit;
                        }
                        
                        if (NULL == GetSystemAddressForMdlWithFailFlag( pCurMdl )) {
                            pMixerSink->SinkStatus |= MIXER_SINK_STATUS_LOCK_ERROR ;
                            status = STATUS_INSUFFICIENT_RESOURCES;
                            KeReleaseMutex ( &pFilterInstance->ControlMutex, FALSE ) ;
                            goto exit;
                        }
                        pCurMdl = GetNextLoopMdl( pLoopPacket,
                                                  pCurMdl ) ;
                        if ( pCurMdl == pLoopPacket->LockedMdlHead ) {
                            break ;
                        }
                    }
                }
            }
            else {
            }
            KeReleaseMutex ( &pFilterInstance->ControlMutex, FALSE ) ;
        }
    }
    else {
       status = STATUS_INVALID_DEVICE_REQUEST;
    }
exit:
    pIrp->IoStatus.Information = sizeof (KSAUDIO_POSITION);
    return status ;
}

NTSTATUS MxGetSurroundEncode
(
   IN PIRP                    pIrp,
   IN PKSNODEPROPERTY         pNodeProperty,
   IN OUT PVOID               pvData
)
{
    PIO_STACK_LOCATION      pIrpStack ;
    PMIXER_INSTHDR          pHeader;
    PMIXER_SOURCE_INSTANCE  pMixerSource;
    PFILTER_INSTANCE        pFilterInstance;
    NTSTATUS                Status;

    pIrpStack = IoGetCurrentIrpStackLocation(pIrp) ;
    pHeader = (PMIXER_INSTHDR) pIrpStack->FileObject->FsContext;
    Status = STATUS_SUCCESS;
    pFilterInstance = (PFILTER_INSTANCE) pHeader->pFilterFileObject->FsContext;

    ASSERT(pNodeProperty->Property.Flags & KSPROPERTY_TYPE_TOPOLOGY);
    
    KeWaitForSingleObject ( &pFilterInstance->ControlMutex, Executive, KernelMode, FALSE, NULL ) ;
    switch (pNodeProperty->NodeId)
        {
#ifdef NEW_SURROUND        
        case NODE_ID_MATRIX_ENCODER:
            if (IsListEmpty ( &pFilterInstance->SourceConnectionList ) ) {
                *((PBOOL)pvData) = pFilterInstance->fSurroundEncode;
            } else {
                // Note: we can only have one source instance
                pMixerSource = (PMIXER_SOURCE_INSTANCE) CONTAINING_RECORD (pFilterInstance->SourceConnectionList.Flink,
                                                                       MIXER_INSTHDR,
                                                                       NextInstance) ;
                *((PBOOL)pvData) = pMixerSource->fSurround;
            }
            break;
#endif            
        default:
            Status = STATUS_INVALID_DEVICE_REQUEST;
            break;
        }
    KeReleaseMutex ( &pFilterInstance->ControlMutex, FALSE ) ;

    pIrp->IoStatus.Information = sizeof (BOOL);
    return Status ;
}

NTSTATUS MxSetSurroundEncode
(
   IN PIRP                    pIrp,
   IN PKSNODEPROPERTY         pNodeProperty,
   IN OUT PVOID               pvData
)
{
    PIO_STACK_LOCATION      pIrpStack ;
    PMIXER_INSTHDR          pHeader;
    PFILTER_INSTANCE        pFilterInstance;
    NTSTATUS                Status;

    pIrpStack = IoGetCurrentIrpStackLocation(pIrp) ;
    pHeader = (PMIXER_INSTHDR) pIrpStack->FileObject->FsContext;
    Status = STATUS_SUCCESS;
    pFilterInstance = (PFILTER_INSTANCE) pHeader->pFilterFileObject->FsContext;

    ASSERT(pNodeProperty->Property.Flags & KSPROPERTY_TYPE_TOPOLOGY);
    
    KeWaitForSingleObject ( &pFilterInstance->ControlMutex, Executive, KernelMode, FALSE, NULL ) ;
    switch (pNodeProperty->NodeId)
        {
#ifdef NEW_SURROUND        
        case NODE_ID_MATRIX_ENCODER:
            if (IsListEmpty ( &pFilterInstance->SourceConnectionList ) ) {
                pFilterInstance->fSurroundEncode = *((PBOOLEAN)pvData);
            } else {
                Status = STATUS_INVALID_DEVICE_REQUEST;
            }
            
            break;
#endif            
        default:
            Status = STATUS_INVALID_DEVICE_REQUEST;
            break;
        }
    KeReleaseMutex ( &pFilterInstance->ControlMutex, FALSE ) ;

    pIrp->IoStatus.Information = sizeof (BOOLEAN);
    return Status ;
}

NTSTATUS MxGetChannelConfig
(
   IN PIRP                    pIrp,
   IN PKSNODEPROPERTY         pNodeProperty,
   IN OUT PVOID               pvData
)
{
    PIO_STACK_LOCATION      pIrpStack ;
    PMIXER_INSTHDR          pHeader;
    PMIXER_SOURCE_INSTANCE  pMixerSource;
    PFILTER_INSTANCE        pFilterInstance;
    NTSTATUS                Status;

    pIrpStack = IoGetCurrentIrpStackLocation(pIrp) ;
    pHeader = (PMIXER_INSTHDR) pIrpStack->FileObject->FsContext;
    Status = STATUS_SUCCESS;
    pFilterInstance = (PFILTER_INSTANCE) pHeader->pFilterFileObject->FsContext;

    ASSERT(pNodeProperty->Property.Flags & KSPROPERTY_TYPE_TOPOLOGY);
    
    KeWaitForSingleObject ( &pFilterInstance->ControlMutex, Executive, KernelMode, FALSE, NULL ) ;
    switch (pNodeProperty->NodeId)
        {
#ifdef NEW_SURROUND        
        case NODE_ID_VOLUME_PAN:
            if (IsListEmpty ( &pFilterInstance->SourceConnectionList ) ) {
                *((PULONG)pvData) = 0;
            } else {
                // Note: we can only have one source instance
                pMixerSource = (PMIXER_SOURCE_INSTANCE) CONTAINING_RECORD (pFilterInstance->SourceConnectionList.Flink,
                                                                       MIXER_INSTHDR,
                                                                       NextInstance) ;
                *((PULONG)pvData) = pMixerSource->WaveFormatExt.dwChannelMask;
            }
            break;
#endif            
        default:
            Status = STATUS_INVALID_DEVICE_REQUEST;
            break;
        }
    KeReleaseMutex ( &pFilterInstance->ControlMutex, FALSE ) ;

    pIrp->IoStatus.Information = sizeof (ULONG);
    return Status ;
}

NTSTATUS MxGetDynSamplingRate
(
   IN PIRP                    pIrp,
   IN PKSNODEPROPERTY         pNodeProperty,
   IN OUT PVOID               pvData
)
{
//    PMIXER_SINK_INSTANCE    pMixerSink;
    PIO_STACK_LOCATION      pIrpStack ;
    PMIXER_INSTHDR          pHeader;
//    PMIXER_SOURCE_INSTANCE  pMixerSource;
    PFILTER_INSTANCE        pFilterInstance;
    NTSTATUS                Status;

    pIrpStack = IoGetCurrentIrpStackLocation(pIrp) ;
    pHeader = (PMIXER_INSTHDR) pIrpStack->FileObject->FsContext;
    Status = STATUS_SUCCESS;
    pFilterInstance = (PFILTER_INSTANCE) pHeader->pFilterFileObject->FsContext;

    switch (pNodeProperty->NodeId)
        {
        case NODE_ID_DOPPLER_SRC:
        case NODE_ID_SRC_SINK:
        default:
            Status = STATUS_INVALID_DEVICE_REQUEST;
            break;
        }

    pIrp->IoStatus.Information = sizeof (ULONG);
    return Status ;
}

NTSTATUS MxSetDynSamplingRate
(
   IN PIRP                    pIrp,
   IN PKSNODEPROPERTY         pNodeProperty,
   IN OUT PVOID               pvData
)
{
//    PMIXER_SINK_INSTANCE    pMixerSink;
    PIO_STACK_LOCATION      pIrpStack ;
    PMIXER_INSTHDR          pHeader;
//    PMIXER_SOURCE_INSTANCE  pMixerSource;
    PFILTER_INSTANCE        pFilterInstance;
    NTSTATUS                Status;

    pIrpStack = IoGetCurrentIrpStackLocation(pIrp) ;
    pHeader = (PMIXER_INSTHDR) pIrpStack->FileObject->FsContext;
    Status = STATUS_SUCCESS;
    pFilterInstance = (PFILTER_INSTANCE) pHeader->pFilterFileObject->FsContext;

    switch (pNodeProperty->NodeId)
        {
        case NODE_ID_DOPPLER_SRC:
        case NODE_ID_SRC_SINK:
        default:
            Status = STATUS_INVALID_DEVICE_REQUEST;
            break;
        }

    pIrp->IoStatus.Information = sizeof (ULONG);
    return Status ;
}

NTSTATUS MxGetMixLvlTable
(
   IN PIRP                    pIrp,
   IN PKSNODEPROPERTY         pNodeProperty,
   IN OUT PVOID               pvData
)
{
    PMIXER_SINK_INSTANCE    pMixerSink;
    PKSAUDIO_MIXLEVEL       pMixLevel;
    PIO_STACK_LOCATION      pIrpStack;
    PMIXER_INSTHDR          pHeader;
    NTSTATUS                status = STATUS_INVALID_DEVICE_REQUEST;
    ULONG                   RequiredSize, nEntries, i;

    pIrpStack = IoGetCurrentIrpStackLocation(pIrp) ;
    pHeader = (PMIXER_INSTHDR) pIrpStack->FileObject->FsContext;
    pMixLevel = (PKSAUDIO_MIXLEVEL) pvData ;

    ASSERT(pNodeProperty->Property.Flags & KSPROPERTY_TYPE_TOPOLOGY);

    if (pNodeProperty->NodeId == NODE_ID_SUPERMIX &&
        pHeader->PinId == PIN_ID_WAVEOUT_SINK) {

        pMixerSink = (PMIXER_SINK_INSTANCE) pIrpStack->FileObject->FsContext;

        // Try filling in the entries
        if (pMixerSink->fEnable3D) {
            nEntries = 2 * pMixerSink->nOutputChannels;
        } else {
            nEntries = pMixerSink->WaveFormatEx.nChannels * pMixerSink->nOutputChannels;
        }
        RequiredSize = nEntries * sizeof(KSAUDIO_MIXLEVEL);
        if (pIrpStack->Parameters.DeviceIoControl.OutputBufferLength >= RequiredSize) {
            // Fill in the entries from our static mix model
            for (i=0; i<nEntries; i++) {
                pMixLevel[i].Mute = FALSE;
                pMixLevel[i].Level = pMixerSink->pMixLevelModel[i];
            }

            pIrp->IoStatus.Information = RequiredSize;
            status = STATUS_SUCCESS;
        }
    }

    return status ;
}

NTSTATUS MxSetMixLvlTable
(
   IN PIRP                    pIrp,
   IN PKSNODEPROPERTY         pNodeProperty,
   IN OUT PVOID               pvData
)
{
    PMIXER_SINK_INSTANCE    pMixerSink;
    PKSAUDIO_MIXLEVEL       pMixLevel;
    PIO_STACK_LOCATION      pIrpStack;
    PMIXER_INSTHDR          pHeader;
    NTSTATUS                status = STATUS_INVALID_DEVICE_REQUEST;
    ULONG                   RequiredSize, nEntries, i;
    PMIXER_SOURCE_INSTANCE  pMixerSource;
    PFILTER_INSTANCE        pFilterInstance;
    BOOL                    fMuted;

    pIrpStack = IoGetCurrentIrpStackLocation(pIrp) ;
    pHeader = (PMIXER_INSTHDR) pIrpStack->FileObject->FsContext;
    pMixLevel = (PKSAUDIO_MIXLEVEL) pvData ;
    pFilterInstance = (PFILTER_INSTANCE) pHeader->pFilterFileObject->FsContext;

    ASSERT(pNodeProperty->Property.Flags & KSPROPERTY_TYPE_TOPOLOGY);

    if (pNodeProperty->NodeId == NODE_ID_SUPERMIX &&
        pHeader->PinId == PIN_ID_WAVEOUT_SINK) {

        KeWaitForSingleObject ( &pFilterInstance->ControlMutex, Executive, KernelMode, FALSE, NULL ) ;
        pMixerSink = (PMIXER_SINK_INSTANCE) pIrpStack->FileObject->FsContext;
        // Note: we can only have one source instance
        pMixerSource = (PMIXER_SOURCE_INSTANCE) CONTAINING_RECORD (pFilterInstance->SourceConnectionList.Flink,
                                                                   MIXER_INSTHDR,
                                                                   NextInstance) ;

        // Try filling in the entries
        nEntries = pMixerSink->WaveFormatEx.nChannels * pMixerSink->nOutputChannels;
        RequiredSize = nEntries * sizeof(KSAUDIO_MIXLEVEL);
        if (pIrpStack->Parameters.DeviceIoControl.OutputBufferLength >= RequiredSize) {
            // Fill in the entries from our static mix model
            for (i=0; i<nEntries; i++) {
                pMixerSink->pMixLevelModel[i] = pMixLevel[i].Level;
            }

            fMuted = pMixerSink->fMuted;
            if (pMixerSink->fEnable3D) {
    	        GenerateMixArray(pMixerSink,
    	                         2, // Always 2 channels out of the 3D stage
    	                         pMixerSink->nOutputChannels,
    	                         pMixerSource);
            } else {
    	        GenerateMixArray(pMixerSink,
    	                         pMixerSink->WaveFormatEx.nChannels,
    	                         pMixerSink->nOutputChannels,
    	                         pMixerSource);
    	    }
	        if (fMuted != pMixerSink->fMuted) {
                pFilterInstance->fNeedOptimizeMix = TRUE;
    	    }
	
            pIrp->IoStatus.Information = RequiredSize;
            status = STATUS_SUCCESS;
        }

        KeReleaseMutex ( &pFilterInstance->ControlMutex, FALSE ) ;
    }

    return status ;
}

NTSTATUS MxGetMixLvlCaps
(
   IN PIRP                    pIrp,
   IN PKSNODEPROPERTY         pNodeProperty,
   IN OUT PVOID               pvData
)
{
    PMIXER_SINK_INSTANCE    pMixerSink;
    PKSAUDIO_MIXCAP_TABLE   pMixCapTable;
    PIO_STACK_LOCATION      pIrpStack;
    PMIXER_INSTHDR          pHeader;
    NTSTATUS                status = STATUS_INVALID_DEVICE_REQUEST;
    ULONG                   RequiredSize, nEntries, i, j, Index;

    pIrpStack = IoGetCurrentIrpStackLocation(pIrp) ;
    pHeader = (PMIXER_INSTHDR) pIrpStack->FileObject->FsContext;
    pMixCapTable = (PKSAUDIO_MIXCAP_TABLE) pvData ;

    ASSERT(pNodeProperty->Property.Flags & KSPROPERTY_TYPE_TOPOLOGY);

    if (pNodeProperty->NodeId == NODE_ID_SUPERMIX &&
        pHeader->PinId == PIN_ID_WAVEOUT_SINK) {

        pMixerSink = (PMIXER_SINK_INSTANCE) pIrpStack->FileObject->FsContext;

        // fill-in M and N
        if (!pMixerSink->fEnable3D) {
            pMixCapTable->InputChannels = pMixerSink->WaveFormatEx.nChannels;
        } else {
            pMixCapTable->InputChannels = 2;    // Always 2 channels out of the 3D stage
        }
        pMixCapTable->OutputChannels = pMixerSink->nOutputChannels;
        pIrp->IoStatus.Information = 2 * sizeof (ULONG);

        // Try filling in the entries
        nEntries = pMixCapTable->InputChannels * pMixCapTable->OutputChannels;
        RequiredSize = (nEntries - 1) * sizeof(KSAUDIO_MIX_CAPS) + sizeof(KSAUDIO_MIXCAP_TABLE);
        if (pIrpStack->Parameters.DeviceIoControl.OutputBufferLength >= RequiredSize) {
            // Fill in the entries from our mix model
            Index = 0;
            for (i=0; i<pMixCapTable->InputChannels; i++) {
                for (j=0; j<pMixCapTable->OutputChannels; j++) {

                    pMixCapTable->Capabilities[Index].Mute = FALSE;
                    pMixCapTable->Capabilities[Index].Minimum = THE_SOUND_OF_SILENCE;
                    pMixCapTable->Capabilities[Index].Maximum = 0x7fffffff;

                    // Start with no outputs
                    pMixCapTable->Capabilities[Index].Reset = THE_SOUND_OF_SILENCE;

                    // For each input channel with a corresponding output, out=1*in
                    if (i == j) {
                        pMixCapTable->Capabilities[Index].Reset = 0L;
                    } else if (i >= pMixCapTable->OutputChannels) {
                        // For extra input channels, mix them into all output channels
                        pMixCapTable->Capabilities[Index].Reset = 0L;
                    } else if (j >= pMixCapTable->InputChannels) {
                        // Mix all input channels to form extra output channels
                        pMixCapTable->Capabilities[Index].Reset = 0L;
                    }

                    Index++;
                }
            }

            pIrp->IoStatus.Information = RequiredSize;
        }

        status = STATUS_SUCCESS;
    }

    return status ;
}

NTSTATUS MxSetMixLvlCaps
(
   IN PIRP                    pIrp,
   IN PKSNODEPROPERTY         pNodeProperty,
   IN OUT PVOID               pvData
)
{
    pIrp->IoStatus.Information = sizeof (ULONG);
    return STATUS_INVALID_DEVICE_REQUEST ;
}

NTSTATUS MxSetItd3dParams
(
   IN PIRP                    pIrp,
   IN PKSNODEPROPERTY         pNodeProperty,
   IN OUT PVOID               pvData
)
{
    PMIXER_SINK_INSTANCE      pMixerSink;
    PIO_STACK_LOCATION        pIrpStack ;
    PMIXER_INSTHDR            pHeader;
    PFILTER_INSTANCE          pFilterInstance;
    ULONG                     InChannels, OutChannels, InMask, OutMask;
    ULONG                     fOldEnabled;
    PKSDS3D_ITD_PARAMS_MSG    pFirMsg;
    NTSTATUS                  Status = STATUS_INVALID_DEVICE_REQUEST;
    PMIXER_SOURCE_INSTANCE  pMixerSource;

    pIrpStack = IoGetCurrentIrpStackLocation(pIrp) ;
    pHeader = (PMIXER_INSTHDR) pIrpStack->FileObject->FsContext;

    pFilterInstance = (PFILTER_INSTANCE) pHeader->pFilterFileObject->FsContext;

    if (pNodeProperty->NodeId == NODE_ID_3D_EFFECTS &&
        pHeader->PinId == PIN_ID_WAVEOUT_SINK)
    {
        pMixerSink = (PMIXER_SINK_INSTANCE) pIrpStack->FileObject->FsContext;

        // Update the parameters

        if(!pMixerSink->fUseIir3d && pMixerSink->fCreate3D) {

            KeWaitForSingleObject ( &pFilterInstance->ControlMutex, Executive, KernelMode, FALSE, NULL ) ; 
            pFirMsg = (PKSDS3D_ITD_PARAMS_MSG) pvData;
            fOldEnabled = InterlockedExchange( &(pMixerSink->fEnable3D), pFirMsg->Enabled );
            if (pMixerSink->fEnable3D)
            {
                    
                *(pMixerSink->pNewItd3dParamsLeft) = pFirMsg->LeftParams;
                *(pMixerSink->pNewItd3dParamsRight) = pFirMsg->RightParams;
    
                InterlockedExchange( &(pMixerSink->f3dParamsChanged), TRUE );
            }
    
            pMixerSink->pInfo->fVolChanged = TRUE;
            pFilterInstance->fNeedOptimizeMix = TRUE;
            pMixerSink->pInfo->fVolChanged = TRUE;

            if (fOldEnabled != pFirMsg->Enabled) {
                // The supermix table must be reset every time we change enable/disable 3D.
                // Note: we can only have one source instance
                pMixerSource = (PMIXER_SOURCE_INSTANCE) CONTAINING_RECORD (pFilterInstance->SourceConnectionList.Flink,
                                                                           MIXER_INSTHDR,
                                                                           NextInstance) ;
                InChannels = pMixerSink->WaveFormatEx.nChannels;
                if (pMixerSink->fEnable3D) {
                    InChannels = 2;
                }
                OutChannels = pMixerSource->WaveFormatEx.nChannels;
                InMask = pMixerSink->WaveFormatExt.dwChannelMask;
                OutMask = pMixerSource->WaveFormatExt.dwChannelMask;
                MapSpeakerLocations(pMixerSink, InChannels, OutChannels, InMask, OutMask, pMixerSource);
            }
            
            KeReleaseMutex ( &pFilterInstance->ControlMutex, FALSE ) ;
            pIrp->IoStatus.Information = sizeof (ULONG);
            Status = STATUS_SUCCESS;

        } else {
            Status = STATUS_INVALID_PARAMETER;
        }

    }
    return Status ;
}

NTSTATUS UpdateItd3dParams
(
    PITDCONTEXT pItdContextLeft,
    PITDCONTEXT pItdContextRight,
    PKSDS3D_ITD_PARAMS pNewItd3dParamsLeft,
    PKSDS3D_ITD_PARAMS pNewItd3dParamsRight
)
{
    NTSTATUS Status = STATUS_SUCCESS;

    // Update Parameters

    pItdContextLeft->TotalDryAttenuation = pNewItd3dParamsLeft->TotalDryAttenuation;
    pItdContextLeft->LastDryAttenuation = pItdContextLeft->TotalDryAttenuation;
    pItdContextLeft->TotalWetAttenuation = pNewItd3dParamsLeft->TotalWetAttenuation;
    pItdContextLeft->LastWetAttenuation = pItdContextLeft->TotalWetAttenuation;
    pItdContextLeft->VolSmoothScale = pNewItd3dParamsLeft->VolSmoothScale;
    pItdContextLeft->VolSmoothScaleRecip = 1.0f / pItdContextLeft->VolSmoothScale;
    pItdContextLeft->iSmoothFreq = pNewItd3dParamsLeft->SmoothFrequency;

    pItdContextLeft->iDelay = pNewItd3dParamsLeft->Delay;
#ifdef SMOOTH_ITD
    pItdContextLeft->iLastDelay = pItdContextLeft->iDelay;
#endif
    Itd3dFilterClear( pItdContextLeft );


    pItdContextRight->TotalDryAttenuation = pNewItd3dParamsRight->TotalDryAttenuation;
    pItdContextRight->LastDryAttenuation = pItdContextRight->TotalDryAttenuation;
    pItdContextRight->TotalWetAttenuation = pNewItd3dParamsRight->TotalWetAttenuation;
    pItdContextRight->LastWetAttenuation = pItdContextRight->TotalWetAttenuation;
    pItdContextRight->VolSmoothScale = pNewItd3dParamsRight->VolSmoothScale;
    pItdContextRight->VolSmoothScaleRecip = 1.0f / pItdContextLeft->VolSmoothScale;
    pItdContextRight->iSmoothFreq = pNewItd3dParamsRight->SmoothFrequency;

    pItdContextRight->iDelay = pNewItd3dParamsRight->Delay;
#ifdef SMOOTH_ITD
    pItdContextRight->iLastDelay = pItdContextRight->iDelay;
#endif
    Itd3dFilterClear( pItdContextRight );

    return Status;
}


NTSTATUS MxSetIir3dParams
(
   IN PIRP                    pIrp,
   IN PKSNODEPROPERTY         pNodeProperty,
   IN OUT PVOID               pvData
)
{
    PMIXER_SINK_INSTANCE      pMixerSink;
    PIO_STACK_LOCATION        pIrpStack ;
    PMIXER_INSTHDR            pHeader;
    PFILTER_INSTANCE          pFilterInstance;
    ULONG                     CurrentTotalSize;
    ULONG                     NewTotalSize;

    PKSDS3D_HRTF_PARAMS_MSG    pMsg;
    PKSDS3D_HRTF_PARAMS_MSG    pBuffer;
    NTSTATUS                   Status = STATUS_INVALID_DEVICE_REQUEST;
    ULONG                      InChannels, OutChannels, InMask, OutMask;
    ULONG                      fOldEnabled;
    PMIXER_SOURCE_INSTANCE     pMixerSource;

    pIrpStack = IoGetCurrentIrpStackLocation(pIrp) ;
    pHeader = (PMIXER_INSTHDR) pIrpStack->FileObject->FsContext;

    pFilterInstance = (PFILTER_INSTANCE) pHeader->pFilterFileObject->FsContext;

    if (pNodeProperty->NodeId == NODE_ID_3D_EFFECTS &&
        pHeader->PinId == PIN_ID_WAVEOUT_SINK)
    {
        pMixerSink = (PMIXER_SINK_INSTANCE) pIrpStack->FileObject->FsContext;

        if(pMixerSink->fUseIir3d && pMixerSink->fCreate3D) {

            // Update the parameters
            KeWaitForSingleObject( &pFilterInstance->ControlMutex, Executive, KernelMode, FALSE, NULL );
    
            pMsg = (PKSDS3D_HRTF_PARAMS_MSG) pvData;
            fOldEnabled = InterlockedExchange( &(pMixerSink->fEnable3D), pMsg->Enabled );
            if (pMixerSink->fEnable3D)
            {
                CurrentTotalSize = pMixerSink->pNewIir3dParams->Size 
                            + pMixerSink->pNewIir3dParams->FilterSize; 
                NewTotalSize = pMsg->Size + pMsg->FilterSize; 
                if(CurrentTotalSize < NewTotalSize)
                {
                    pBuffer =
                        (PKSDS3D_HRTF_PARAMS_MSG) ExAllocatePoolWithTag( PagedPool, NewTotalSize, 'XIMK' );
    
                    if(pBuffer) {
                        ExFreePool(pMixerSink->pNewIir3dParams);
                        pMixerSink->pNewIir3dParams = pBuffer;
                    } else {
                        InterlockedExchange( &(pMixerSink->fEnable3D), fOldEnabled );
                        KeReleaseMutex( &pFilterInstance->ControlMutex, FALSE );
                        return(STATUS_INSUFFICIENT_RESOURCES);
                    }
                }
    
                if(pMixerSink->pNewIir3dParams)
                {
                    RtlCopyBytes(pMixerSink->pNewIir3dParams, pMsg, NewTotalSize);
                }
    
                InterlockedExchange( &(pMixerSink->f3dParamsChanged), TRUE );
            }

            pMixerSink->pInfo->fVolChanged = TRUE;
            pFilterInstance->fNeedOptimizeMix = TRUE;
            pMixerSink->pInfo->fVolChanged = TRUE;

            if (fOldEnabled != pMsg->Enabled) {
                // The supermix table must be reset every time we change enable/disable 3D.
                // Note: we can only have one source instance
                pMixerSource = (PMIXER_SOURCE_INSTANCE) CONTAINING_RECORD (pFilterInstance->SourceConnectionList.Flink,
                                                                           MIXER_INSTHDR,
                                                                           NextInstance) ;
                InChannels = pMixerSink->WaveFormatEx.nChannels;
                if (pMixerSink->fEnable3D) {
                    InChannels = 2;
                }
                OutChannels = pMixerSource->WaveFormatEx.nChannels;
                InMask = pMixerSink->WaveFormatExt.dwChannelMask;
                OutMask = pMixerSource->WaveFormatExt.dwChannelMask;
                MapSpeakerLocations(pMixerSink, InChannels, OutChannels, InMask, OutMask, pMixerSource);
            }
            
            KeReleaseMutex( &pFilterInstance->ControlMutex, FALSE );
            pIrp->IoStatus.Information = sizeof(ULONG);
            Status = STATUS_SUCCESS;

        } else {
            Status = STATUS_INVALID_PARAMETER;
        }
    }
    return Status;
}

NTSTATUS UpdateIir3dParams
(
    PMIXER_SINK_INSTANCE pMixerSink
)
{
    NTSTATUS    Status;
    PULONG      pData;
    ULONG       NumSigmaCoeffs;
    ULONG       NumDeltaCoeffs;
    PFLOAT      pFloatSigmaCoeffs;
    PFLOAT      pFloatDeltaCoeffs;
    PSHORT      pShortSigmaCoeffs;
    PSHORT      pShortDeltaCoeffs;
    PUSHORT     pSigmaGain;
    PUSHORT     pDeltaGain;

    // Update Parameters

    if (FLOAT_COEFF == pMixerSink->CoeffFormat) {
        pData = (PULONG)(pMixerSink->pNewIir3dParams + 1);
        NumSigmaCoeffs = *pData;

        pFloatSigmaCoeffs = (PFLOAT)(pData + 1);

        pData = (PULONG)(pFloatSigmaCoeffs + NumSigmaCoeffs);
        NumDeltaCoeffs = *pData;

        pFloatDeltaCoeffs = (PFLOAT)(pData + 1);

        Status = FloatLocalizerUpdateCoeffs
                 (
                     pMixerSink->pFloatLocalizer,
                     NumSigmaCoeffs,
                     pFloatSigmaCoeffs,
                     NumDeltaCoeffs,
                     pFloatDeltaCoeffs,
                     pMixerSink->pNewIir3dParams->SwapChannels,
                     pMixerSink->pNewIir3dParams->ZeroAzimuth,
                     pMixerSink->pNewIir3dParams->CrossFadeOutput
                 );
    } else {
        pData = (PULONG)(pMixerSink->pNewIir3dParams + 1);
        NumSigmaCoeffs = *pData;
        pShortSigmaCoeffs = (PSHORT)(pData + 1);
        pSigmaGain = (PUSHORT)(pShortSigmaCoeffs + NumSigmaCoeffs);
        pData = (PULONG)(pSigmaGain + 1);
        NumDeltaCoeffs = *(UNALIGNED ULONG *)pData;
        pShortDeltaCoeffs = (PSHORT)(pData + 1);
        pDeltaGain = (PUSHORT)(pShortDeltaCoeffs + NumDeltaCoeffs);

        Status = ShortLocalizerUpdateCoeffs
                 (
                     pMixerSink->pShortLocalizer,
                     NumSigmaCoeffs,
                     pShortSigmaCoeffs,
                     *pSigmaGain,
                     NumDeltaCoeffs,
                     pShortDeltaCoeffs,
                     *pDeltaGain,
                     pMixerSink->pNewIir3dParams->SwapChannels,
                     pMixerSink->pNewIir3dParams->ZeroAzimuth,
                     pMixerSink->pNewIir3dParams->CrossFadeOutput
                 );
    }

    return Status;

}


NTSTATUS MxIir3dInitialize
(
   IN PIRP                    pIrp,
   IN PKSNODEPROPERTY         pNodeProperty,
   IN OUT PVOID               pvData
)
{
    PMIXER_SINK_INSTANCE      pMixerSink;
    PIO_STACK_LOCATION        pIrpStack ;
    PMIXER_INSTHDR            pHeader;
    PFILTER_INSTANCE          pFilterInstance;

    PKSDS3D_HRTF_INIT_MSG     pMsg;
    NTSTATUS                  Status = STATUS_INVALID_DEVICE_REQUEST;

    pIrpStack = IoGetCurrentIrpStackLocation(pIrp) ;
    pHeader = (PMIXER_INSTHDR) pIrpStack->FileObject->FsContext;

    pFilterInstance = (PFILTER_INSTANCE) pHeader->pFilterFileObject->FsContext;

    if (pNodeProperty->NodeId == NODE_ID_3D_EFFECTS &&
        pHeader->PinId == PIN_ID_WAVEOUT_SINK)
    {
        pMixerSink = (PMIXER_SINK_INSTANCE) pIrpStack->FileObject->FsContext;

        if(pMixerSink->fUseIir3d && pMixerSink->fCreate3D) {

            // Update the parameters
    
            pMsg = (PKSDS3D_HRTF_INIT_MSG) pvData;
            if (pMixerSink->fEnable3D)
            {
                if (FLOAT_COEFF == pMixerSink->CoeffFormat) {
                    Status = FloatLocalizerInitData(pMixerSink->pFloatLocalizer, 
                                                    DIRECT_FORM, 
                                                    pMsg->MaxFilterSize,
                                                    pMsg->Quality,
                                                    pMsg->FilterTransientMuteLength,
                                                    pMsg->FilterOverlapBufferLength,
                                                    pMsg->OutputOverlapBufferLength);
#ifdef REALTIME_THREAD
    // allocate maximum memory needed
    pMixerSink->pFloatLocalizer->PreviousNumSamples = MAX_INPUT_SAMPLES;
    FloatLocalizerFreeBufferMemory(pMixerSink->pFloatLocalizer);

    pMixerSink->pFloatLocalizer->FilterOut[tagSigma] = 
        ExAllocatePoolWithTag(PagedPool, MAX_INPUT_SAMPLES*sizeof(FLOAT), 'XIMK');

    pMixerSink->pFloatLocalizer->FilterOut[tagDelta] = 
        ExAllocatePoolWithTag(PagedPool, MAX_INPUT_SAMPLES*sizeof(FLOAT), 'XIMK');

    pMixerSink->pFloatLocalizer->TempFloatBuffer = 
        ExAllocatePoolWithTag(PagedPool, 2*MAX_INPUT_SAMPLES*sizeof(FLOAT), 'XIMK');
#endif

                } else {
                    Status = ShortLocalizerInitData(pMixerSink->pShortLocalizer, 
                                                    CASCADE_FORM, 
                                                    pMsg->MaxFilterSize,
                                                    pMsg->Quality,
                                                    pMsg->FilterTransientMuteLength,
                                                    pMsg->FilterOverlapBufferLength,
                                                    pMsg->OutputOverlapBufferLength);
#ifdef REALTIME_THREAD
    // allocate max memory necessary
    pMixerSink->pShortLocalizer->PreviousNumSamples = MAX_INPUT_SAMPLES;
    ShortLocalizerFreeBufferMemory(pMixerSink->pShortLocalizer);

    pMixerSink->pShortLocalizer->FilterOut[tagSigma] = 
        ExAllocatePoolWithTag(PagedPool, MAX_INPUT_SAMPLES*sizeof(LONG), 'XIMK');

    pMixerSink->pShortLocalizer->FilterOut[tagDelta] = 
        ExAllocatePoolWithTag(PagedPool, MAX_INPUT_SAMPLES*sizeof(LONG), 'XIMK');

    pMixerSink->pShortLocalizer->TempLongBuffer = 
        ExAllocatePoolWithTag(PagedPool, 2*MAX_INPUT_SAMPLES*sizeof(LONG), 'XIMK');
#endif

                }
    
            }

            if(NT_SUCCESS(Status)) {
                KeWaitForSingleObject( &pFilterInstance->ControlMutex, 
                                       Executive, KernelMode, FALSE, NULL );
                pFilterInstance->fNeedOptimizeMix = TRUE;
                KeReleaseMutex ( &pFilterInstance->ControlMutex, FALSE );
                pIrp->IoStatus.Information = sizeof(ULONG);
            }

        } else {
            Status = STATUS_INVALID_PARAMETER;
        }

    }
    return Status;
}


NTSTATUS MxGetFilterMethodAndCoeffFormat
(
   IN PIRP                    pIrp,
   IN PKSNODEPROPERTY         pNodeProperty,
   IN OUT PVOID               pvData
)
{
    PMIXER_SINK_INSTANCE            pMixerSink;
    PKSDS3D_HRTF_FILTER_FORMAT_MSG  pMsg;
    PIO_STACK_LOCATION              pIrpStack;
    PMIXER_INSTHDR                  pHeader;
    NTSTATUS                        Status = STATUS_INVALID_DEVICE_REQUEST;

    pIrpStack = IoGetCurrentIrpStackLocation(pIrp) ;
    pHeader = (PMIXER_INSTHDR) pIrpStack->FileObject->FsContext;

    ASSERT(pNodeProperty->Property.Flags & KSPROPERTY_TYPE_TOPOLOGY);

    if (pNodeProperty->NodeId == NODE_ID_3D_EFFECTS &&
        pHeader->PinId == PIN_ID_WAVEOUT_SINK) {

        pMixerSink = (PMIXER_SINK_INSTANCE) pIrpStack->FileObject->FsContext;

        if(pMixerSink->fUseIir3d && pMixerSink->fCreate3D) {
            pMsg = (PKSDS3D_HRTF_FILTER_FORMAT_MSG) pvData;

            // fill-in desired filter method and coefficient format
            pMsg->FilterMethod = pMixerSink->FilterMethod;
            pMsg->CoeffFormat = pMixerSink->CoeffFormat;
            pMsg->Version = DS3D_HRTF_VERSION_1;
    
            pIrp->IoStatus.Information = 2 * sizeof(ULONG);
    
            Status = STATUS_SUCCESS;  
        } else {
            Status = STATUS_INVALID_PARAMETER;  
        }
    }

    return Status;
}


VOID CancelIrpQueue
(
   PMIXER_SINK_INSTANCE    pMixerSink,
   PLIST_ENTRY             ListHead,
   PKSPIN_LOCK              SpinLock
)
{
   PIRP        Irp ;

   pMixerSink->SinkStatus &= ~MIXER_SINK_STATUS_DATA_PRESENT ;
   while ( TRUE ) {
       Irp = KsRemoveIrpFromCancelableQueue( ListHead,
                                             SpinLock,
                                             KsListEntryHead,
                                             KsAcquireAndRemove) ;
       if ( Irp ) {
           MxCleanupRequest ( Irp ) ;
           KsAddIrpToCancelableQueue( &pMixerSink->CancelQueue,
                                      &pMixerSink->CancelSpinLock,
                                      Irp,
                                      KsListEntryTail,
                                      MxCancelIrp );
       }
       else {
           break ;
       }
   }
   KsCancelIo ( &pMixerSink->CancelQueue, &pMixerSink->CancelSpinLock ) ;
}


VOID CancelGlobalIrpQueue
(
   PMIXER_SINK_INSTANCE    pMixerSink,
   PLIST_ENTRY             ListHead,
   PKSPIN_LOCK             SpinLock
)
{
   pMixerSink->SinkStatus &= ~MIXER_SINK_STATUS_DATA_PRESENT ;

   KsMoveIrpsOnCancelableQueue(ListHead,
                               SpinLock,
                               &pMixerSink->CancelQueue,
                               &pMixerSink->CancelSpinLock,
                               KsListEntryHead,
                               DoesSinkMatch,
                               pMixerSink);

    KsCancelIo ( &pMixerSink->CancelQueue, &pMixerSink->CancelSpinLock ) ;
}


NTSTATUS MxGetCpuResources
(
   IN PIRP              pIrp,
   IN PKSNODEPROPERTY   pNodeProperty,
   IN OUT PVOID         pvData
)
{
    PLONG                   pCpuResources;
    NTSTATUS                status = STATUS_SUCCESS;

    pCpuResources = (PLONG) pvData ;

    ASSERT(pNodeProperty->Property.Flags & KSPROPERTY_TYPE_TOPOLOGY);

    switch (pNodeProperty->NodeId)
       {

       case NODE_ID_VOLUME_SINK:
       case NODE_ID_3D_EFFECTS:
       case NODE_ID_SUPERMIX:
       case NODE_ID_VOLUME_PAN:
       case NODE_ID_DOPPLER_SRC:
       case NODE_ID_SRC_SINK:
       case NODE_ID_SUM:
       case NODE_ID_VOLUME_SOURCE:
       case NODE_ID_INPUT_SUPERMIX: 
       case NODE_ID_INPUT_SRC: 
       case NODE_ID_MATRIX_ENCODER:
            *pCpuResources = KSAUDIO_CPU_RESOURCES_HOST_CPU;
            break;

       default:
            status = STATUS_INVALID_DEVICE_REQUEST;
            break;
       }

    pIrp->IoStatus.Information = sizeof (LONG);
    return status ;
}


NTSTATUS
MxBreakLoop (
    IN PIRP         pIrp,
    IN PKSMETHOD    pMethod,
    IN OUT PVOID    pvData
    )
{
    PMIXER_SINK_INSTANCE    pMixerSink;
    PIO_STACK_LOCATION      pIrpStack ;

    pIrpStack = IoGetCurrentIrpStackLocation(pIrp) ;
    pMixerSink = (PMIXER_SINK_INSTANCE) pIrpStack->FileObject->FsContext;

    pMixerSink->LoopCount = 1 ;

    return STATUS_SUCCESS;
}

NTSTATUS MxControlCancelIo
(
    IN PIRP         pIrp,
    IN PKSMETHOD    pMethod,
    IN OUT PVOID    pvData
)
{
    return STATUS_SUCCESS;
}

#pragma    LOCKED_CODE
#pragma    LOCKED_DATA

VOID
MxGenerateEndOfStreamEvents
(
    PMIXER_SINK_INSTANCE pMixerSink
)
{
    KIRQL                       OldIrql ;
    PLIST_ENTRY                 ple ;
    PENDOFSTREAM_EVENT_ENTRY    pEndOfStreamEventEntry ;

    if ( !IsListEmpty(&pMixerSink->EventQueue) ) {
        KeAcquireSpinLock(&pMixerSink->EventLock, &OldIrql) ;
        ple = pMixerSink->EventQueue.Flink ;
        while ( ple != &pMixerSink->EventQueue ) {
            pEndOfStreamEventEntry = (PENDOFSTREAM_EVENT_ENTRY)
                                         CONTAINING_RECORD( ple,
                                                            KSEVENT_ENTRY,
                                                            ListEntry) ;
            ple = ple->Flink ;
            if ( pEndOfStreamEventEntry->EventType == EndOfStreamEvent ) {
                KsGenerateEvent(&pEndOfStreamEventEntry->EventEntry) ;
            }
        }
        KeReleaseSpinLock(&pMixerSink->EventLock, OldIrql) ;
    }
}

NTSTATUS
MxAddEndOfStreamEvent
(
   PIRP    pIrp,
   PKSEVENTDATA pKsEventData,
   PPOSITION_EVENT_ENTRY pEndOfStreamEventEntry
)
{
    PMIXER_INSTHDR         pMixerHeader;
    PMIXER_SINK_INSTANCE   pMixerSink ;
    PIO_STACK_LOCATION     pIrpStack;
    KIRQL                  OldIrql ;

    pIrpStack = IoGetCurrentIrpStackLocation( pIrp );
    pMixerHeader = (PMIXER_INSTHDR) pIrpStack->FileObject->FsContext;
    pMixerSink = (PMIXER_SINK_INSTANCE) pMixerHeader ;

    pEndOfStreamEventEntry->EventType = EndOfStreamEvent ;

    KeAcquireSpinLock ( &pMixerSink->EventLock, &OldIrql ) ;
    InsertTailList ( &pMixerSink->EventQueue,
                     &pEndOfStreamEventEntry->EventEntry.ListEntry ) ;
    KeReleaseSpinLock ( &pMixerSink->EventLock, OldIrql ) ;
    return ( STATUS_SUCCESS ) ;
}

NTSTATUS
MxAddPositionEvent
(
   PIRP    pIrp,
   PLOOPEDSTREAMING_POSITION_EVENT_DATA pPosEventData,
   PPOSITION_EVENT_ENTRY pPositionEventEntry
)
{
    PMIXER_INSTHDR         pMixerHeader;
    PMIXER_SINK_INSTANCE   pMixerSink ;
    PIO_STACK_LOCATION     pIrpStack;
    KIRQL                  OldIrql ;

    pIrpStack = IoGetCurrentIrpStackLocation( pIrp );
    pMixerHeader = (PMIXER_INSTHDR) pIrpStack->FileObject->FsContext;
    pMixerSink = (PMIXER_SINK_INSTANCE) pMixerHeader ;

    pPositionEventEntry->EventType = PositionEvent ;
    pPositionEventEntry->Position = pPosEventData->Position ;
#ifdef REALTIME_THREAD    
    pPositionEventEntry->fRtTrigger = FALSE;
#endif    

    KeAcquireSpinLock ( &pMixerSink->EventLock, &OldIrql ) ;
    InsertTailList ( &pMixerSink->EventQueue,
                     &pPositionEventEntry->EventEntry.ListEntry ) ;
    KeReleaseSpinLock ( &pMixerSink->EventLock, OldIrql ) ;
    return ( STATUS_SUCCESS ) ;
}

VOID
UpdateSinkTime
(
   PMIXER_SINK_INSTANCE pMixerSink,
   ULONG                Increment          // in number of samples
)
{
    KIRQL                  OldIrql ;
    PLIST_ENTRY            ple ;
    PPOSITION_EVENT_ENTRY  pPosEventEntry ;
    ULONGLONG              CurPos, NewPos, EventSamplePos ;
    ULONG                  Index, BytesPerSample ;
#ifdef REALTIME_THREAD
    PFILTER_INSTANCE       pFilterInstance = pMixerSink->Header.pFilterFileObject->FsContext;
#endif

   BytesPerSample = pMixerSink->BytesPerSample ;

   //
   // Update the number of bytes we consumed from this Sink Pin
   //

   Index = pMixerSink->BlockInfoIndex ;
   pMixerSink->pInfo->BlockInfo[Index].NumBytes += Increment * BytesPerSample ;

#ifdef REALTIME_THREAD
    if (!pFilterInstance->RealTimeThread) {
#endif            
       if ( pMixerSink->pClock ) {
            if (!IsListEmpty(&pMixerSink->pClock->EventQueue)) {
                MxGenerateClockEvents( pMixerSink->pClock ) ;
            }
       }
#ifdef REALTIME_THREAD
    }
#endif   

   if ( pMixerSink->InterfaceId == KSINTERFACE_STANDARD_LOOPED_STREAMING ) {
       CurPos = pMixerSink->CurTime.Time ;
       NewPos = CurPos + Increment ;
       KeAcquireSpinLock ( &pMixerSink->EventLock, &OldIrql ) ;
       if ( !IsListEmpty ( &pMixerSink->EventQueue ) ) {
     